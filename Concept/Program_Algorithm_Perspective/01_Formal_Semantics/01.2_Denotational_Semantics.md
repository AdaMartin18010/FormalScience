# 1.2 Denotational Semantics

> **å­ä¸»é¢˜ç¼–å·**: 01.2
> **ä¸»é¢˜**: ç¨‹åºç®—æ³•è§†è§’

## 1 ğŸ“Š æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ

<details>
<summary><b>ğŸ¯ğŸ”¬ ç‚¹å‡»å±•å¼€ï¼šæŒ‡ç§°è¯­ä¹‰æ ¸å¿ƒæ´å¯Ÿ</b></summary>

**ç»ˆææ´å¯Ÿ**: æŒ‡ç§°è¯­ä¹‰=ç¨‹åºçš„æ•°å­¦æ„ä¹‰è®ºã€‚æ ¸å¿ƒæ€æƒ³ï¼šå°†ç¨‹åºæ˜ å°„åˆ°æ•°å­¦å¯¹è±¡ï¼ˆå‡½æ•°ã€é›†åˆã€åŸŸï¼‰ï¼Œå›ç­”"ç¨‹åºè¡¨ç¤ºä»€ä¹ˆ"è€Œé"å¦‚ä½•æ‰§è¡Œ"ã€‚æ•°å­¦åŸºç¡€ï¼šDomain Theoryï¼ˆåŸŸç†è®ºï¼‰â€”â€”Scottæ„é€ çš„å®Œå…¨ååºé›†ï¼ˆCPOï¼‰+è¿ç»­å‡½æ•°+ä¸åŠ¨ç‚¹å®šç†ï¼Œè§£å†³é€’å½’å®šä¹‰çš„æ•°å­¦éš¾é¢˜ã€‚å…³é”®æ¦‚å¿µï¼šâ‘ ç»„åˆæ€§ï¼ˆCompositionalityï¼‰ï¼šâŸ¦eâ‚+eâ‚‚âŸ§=âŸ¦eâ‚âŸ§+âŸ¦eâ‚‚âŸ§ï¼Œæ•´ä½“è¯­ä¹‰ç”±éƒ¨åˆ†è¯­ä¹‰ç»„åˆâ‘¡æŒ‡ç§°åŸŸï¼ˆDenotational Domainï¼‰ï¼šç¨‹åºæ˜ å°„çš„ç›®æ ‡æ•°å­¦ç©ºé—´â‘¢æœ€å°ä¸åŠ¨ç‚¹ï¼ˆLeast Fixed Pointï¼‰ï¼šé€’å½’çš„æ•°å­¦æ¨¡å‹ï¼Œfix(Î»f.F(f))=âŠ¥âˆªF(âŠ¥)âˆªFÂ²(âŠ¥)âˆª...ã€‚åº”ç”¨ä»·å€¼ï¼šâ‘ ç¼–è¯‘å™¨ä¼˜åŒ–ï¼ˆè¯­ä¹‰ç­‰ä»·æ€§è¯æ˜ï¼‰â‘¡ç¨‹åºå˜æ¢ï¼ˆé‡æ„æ­£ç¡®æ€§ï¼‰â‘¢ç±»å‹ç³»ç»Ÿè®¾è®¡â‘£æŠ½è±¡è§£é‡ŠåŸºç¡€ã€‚ä¸æ“ä½œè¯­ä¹‰çš„å…³ç³»ï¼šå……åˆ†æ€§å®šç†eâ‡“v âŸº âŸ¦eâŸ§=vï¼Œå…¨æŠ½è±¡ï¼ˆâŸ¦eâ‚âŸ§=âŸ¦eâ‚‚âŸ§ âŸº eâ‚â‰ˆeâ‚‚ï¼‰ã€‚å·¥å…·ï¼šHaskellï¼ˆå¤©ç„¶çš„æŒ‡ç§°è¯­ä¹‰å®ç°ï¼‰ã€Coq/Leanï¼ˆå½¢å¼åŒ–éªŒè¯ï¼‰ã€‚æŒ‘æˆ˜ï¼šå¹¶å‘ã€å¼‚å¸¸ã€çŠ¶æ€éš¾å»ºæ¨¡ï¼›éœ€è¦å¤æ‚çš„Monad/Effect Systemã€‚å…³é”®ï¼šæŒ‡ç§°è¯­ä¹‰æä¾›ç¨‹åºçš„æŠ½è±¡æ•°å­¦æ¨¡å‹ï¼Œæ˜¯å‡½æ•°å¼ç¼–ç¨‹å’Œç±»å‹è®ºçš„ç†è®ºåŸºç¡€ã€‚

</details>

---

## ğŸ“‹ ç›®å½•

- [1.2 Denotational Semantics](#12-denotational-semantics)
  - [1 ğŸ“Š æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ](#1--æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [2 æ¦‚è¿°](#2-æ¦‚è¿°)
  - [1 åŠ¨æœºä¸å¯¹æ¯”](#1-åŠ¨æœºä¸å¯¹æ¯”)
    - [1.1 ä¸‰ç§è¯­ä¹‰å­¦å¯¹æ¯”](#11-ä¸‰ç§è¯­ä¹‰å­¦å¯¹æ¯”)
    - [1.2 æŒ‡ç§°è¯­ä¹‰çš„ä¼˜åŠ¿](#12-æŒ‡ç§°è¯­ä¹‰çš„ä¼˜åŠ¿)
  - [2 æ•°å­¦åŸºç¡€ï¼šåŸŸç†è®ºï¼ˆDomain Theoryï¼‰](#2-æ•°å­¦åŸºç¡€åŸŸç†è®ºdomain-theory)
    - [2.1 ååºé›†ï¼ˆPartial Orderï¼‰](#21-ååºé›†partial-order)
    - [2.2 é“¾ä¸ä¸Šç¡®ç•Œ](#22-é“¾ä¸ä¸Šç¡®ç•Œ)
    - [2.3 å®Œå…¨ååºé›†ï¼ˆCPOï¼‰](#23-å®Œå…¨ååºé›†cpo)
    - [2.4 è¿ç»­å‡½æ•°ä¸ä¸åŠ¨ç‚¹å®šç†](#24-è¿ç»­å‡½æ•°ä¸ä¸åŠ¨ç‚¹å®šç†)
  - [3 ç®€å•è¡¨è¾¾å¼è¯­è¨€çš„æŒ‡ç§°è¯­ä¹‰](#3-ç®€å•è¡¨è¾¾å¼è¯­è¨€çš„æŒ‡ç§°è¯­ä¹‰)
    - [3.1 è¯­æ³•å®šä¹‰](#31-è¯­æ³•å®šä¹‰)
    - [3.2 è¯­ä¹‰åŸŸï¼ˆSemantic Domainsï¼‰](#32-è¯­ä¹‰åŸŸsemantic-domains)
    - [3.3 è¯­ä¹‰å®šä¹‰](#33-è¯­ä¹‰å®šä¹‰)
    - [3.4 Haskell å®ç°](#34-haskell-å®ç°)
  - [4 å‘½ä»¤å¼è¯­è¨€çš„æŒ‡ç§°è¯­ä¹‰](#4-å‘½ä»¤å¼è¯­è¨€çš„æŒ‡ç§°è¯­ä¹‰)
    - [4.1 è¯­æ³•å®šä¹‰](#41-è¯­æ³•å®šä¹‰)
    - [4.2 è¯­ä¹‰åŸŸ](#42-è¯­ä¹‰åŸŸ)
    - [4.3 è¯­ä¹‰å®šä¹‰](#43-è¯­ä¹‰å®šä¹‰)
    - [4.4 ä¸åŠ¨ç‚¹å±•å¼€ç¤ºä¾‹](#44-ä¸åŠ¨ç‚¹å±•å¼€ç¤ºä¾‹)
    - [4.5 Lean4 å½¢å¼åŒ–](#45-lean4-å½¢å¼åŒ–)
  - [5 Î» æ¼”ç®—çš„æŒ‡ç§°è¯­ä¹‰](#5-Î»-æ¼”ç®—çš„æŒ‡ç§°è¯­ä¹‰)
    - [5.1 æ— ç±»å‹ Î» æ¼”ç®—](#51-æ— ç±»å‹-Î»-æ¼”ç®—)
    - [5.2 Scott åŸŸæ„é€ ](#52-scott-åŸŸæ„é€ )
    - [5.3 è¯­ä¹‰å®šä¹‰](#53-è¯­ä¹‰å®šä¹‰)
  - [6 æŒ‡ç§°è¯­ä¹‰ä¸æ“ä½œè¯­ä¹‰çš„å…³ç³»](#6-æŒ‡ç§°è¯­ä¹‰ä¸æ“ä½œè¯­ä¹‰çš„å…³ç³»)
    - [6.1 å……åˆ†æ€§å®šç†ï¼ˆAdequacyï¼‰](#61-å……åˆ†æ€§å®šç†adequacy)
    - [6.2 å…¨æŠ½è±¡ï¼ˆFull Abstractionï¼‰](#62-å…¨æŠ½è±¡full-abstraction)
  - [7 åº”ç”¨ï¼šç¼–è¯‘å™¨ä¼˜åŒ–](#7-åº”ç”¨ç¼–è¯‘å™¨ä¼˜åŒ–)
    - [7.1 å¸¸é‡æŠ˜å ï¼ˆConstant Foldingï¼‰](#71-å¸¸é‡æŠ˜å constant-folding)
    - [7.2 æ­»ä»£ç æ¶ˆé™¤ï¼ˆDead Code Eliminationï¼‰](#72-æ­»ä»£ç æ¶ˆé™¤dead-code-elimination)
    - [7.3 å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤ï¼ˆCSEï¼‰](#73-å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤cse)
  - [8 ä¸å›½é™…è¯¾ç¨‹å¯¹æ ‡](#8-ä¸å›½é™…è¯¾ç¨‹å¯¹æ ‡)
    - [8.1 å¤§å­¦è¯¾ç¨‹æ˜ å°„](#81-å¤§å­¦è¯¾ç¨‹æ˜ å°„)
    - [8.2 æ•™æå¯¹åº”](#82-æ•™æå¯¹åº”)
  - [9 å·¥å…·ä¸ç”Ÿæ€](#9-å·¥å…·ä¸ç”Ÿæ€)
    - [9.1 å®šç†è¯æ˜å™¨](#91-å®šç†è¯æ˜å™¨)
    - [9.2 ç¼–ç¨‹è¯­è¨€å®ç°](#92-ç¼–ç¨‹è¯­è¨€å®ç°)
  - [10 æ‰©å±•é˜…è¯»](#10-æ‰©å±•é˜…è¯»)
    - [10.1 å­¦æœ¯è®ºæ–‡](#101-å­¦æœ¯è®ºæ–‡)
    - [10.2 åœ¨çº¿èµ„æº](#102-åœ¨çº¿èµ„æº)
    - [10.3 æœ¬åœ°é¡¹ç›®å¼•ç”¨](#103-æœ¬åœ°é¡¹ç›®å¼•ç”¨)
  - [11 é™„å½• Aï¼šWikipedia æ¦‚å¿µå¯¹ç…§](#11-é™„å½•-awikipedia-æ¦‚å¿µå¯¹ç…§)
  - [è·¨è§†è§’é“¾æ¥](#è·¨è§†è§’é“¾æ¥)

---

## 2 æ¦‚è¿°

**æŒ‡ç§°è¯­ä¹‰**ï¼ˆDenotational Semanticsï¼‰å›ç­”æ ¸å¿ƒé—®é¢˜ï¼š
> ç¨‹åºçš„**æ„ä¹‰**ï¼ˆmeaningï¼‰æ˜¯ä»€ä¹ˆï¼Ÿ

ä¸æ“ä½œè¯­ä¹‰ä¸åŒï¼ŒæŒ‡ç§°è¯­ä¹‰ä¸å…³å¿ƒç¨‹åº**å¦‚ä½•æ‰§è¡Œ**ï¼Œè€Œæ˜¯ç›´æ¥å°†ç¨‹åºæ˜ å°„åˆ°æ•°å­¦å¯¹è±¡ï¼ˆé€šå¸¸æ˜¯å‡½æ•°æˆ–é›†åˆï¼‰ã€‚è¿™ç§æ–¹æ³•ï¼š

- æä¾›ç¨‹åºçš„**æŠ½è±¡æ•°å­¦æ¨¡å‹**
- æ”¯æŒ**ç»„åˆæ€§**ï¼ˆcompositionalï¼‰æ¨ç†
- é€‚åˆ**ç¼–è¯‘å™¨ä¼˜åŒ–**å’Œ**ç­‰ä»·æ€§è¯æ˜**

æœ¬æ–‡å°†ä»**domain theory**ï¼ˆåŸŸç†è®ºï¼‰åŸºç¡€å‡ºå‘ï¼Œç³»ç»Ÿä»‹ç»æŒ‡ç§°è¯­ä¹‰çš„æ„é€ æ–¹æ³•å’Œåº”ç”¨ã€‚

---

## 1 åŠ¨æœºä¸å¯¹æ¯”

### 1.1 ä¸‰ç§è¯­ä¹‰å­¦å¯¹æ¯”

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                â”‚ æ“ä½œè¯­ä¹‰              â”‚ æŒ‡ç§°è¯­ä¹‰           â”‚ å…¬ç†è¯­ä¹‰            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ ¸å¿ƒé—®é¢˜        â”‚ ç¨‹åºå¦‚ä½•æ‰§è¡Œï¼Ÿ        â”‚ ç¨‹åºæ„ä¹‰æ˜¯ä»€ä¹ˆï¼Ÿ   â”‚ å¦‚ä½•è¯æ˜ç¨‹åºæ€§è´¨ï¼Ÿ    â”‚
â”‚ å½¢å¼åŒ–æ–¹æ³•      â”‚ è½¬ç§»ç³»ç»Ÿ              â”‚ æ•°å­¦å‡½æ•°           â”‚ Hoare é€»è¾‘          â”‚
â”‚ æŠ½è±¡å±‚æ¬¡        â”‚ ä½ï¼ˆæ¥è¿‘æœºå™¨ï¼‰         â”‚ é«˜ï¼ˆæ•°å­¦å¯¹è±¡ï¼‰     â”‚ ä¸­ï¼ˆé€»è¾‘å…¬å¼ï¼‰      â”‚
â”‚ ç»„åˆæ€§          â”‚ å¼±                   â”‚ å¼º                 â”‚ å¼º                 â”‚
â”‚ é€‚ç”¨åœºæ™¯        â”‚ è¯æ˜ç®—æ³•æ­£ç¡®æ€§         â”‚ ç¼–è¯‘å™¨ä¼˜åŒ–         â”‚ ç¨‹åºéªŒè¯            â”‚
â”‚ ä»£è¡¨å·¥å…·        â”‚ K-Framework          â”‚ Haskell (lazy eval)â”‚ Coq, Frama-C       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æŒ‡ç§°è¯­ä¹‰çš„ä¼˜åŠ¿

**ç»„åˆæ€§ï¼ˆCompositionalityï¼‰**ï¼š

```text
å®šç†ï¼ˆç»„åˆæ€§åŸç†ï¼‰ï¼š
  âŸ¦eâ‚ op eâ‚‚âŸ§ = F(âŸ¦eâ‚âŸ§, âŸ¦eâ‚‚âŸ§)

  ç¨‹åºçš„æ„ä¹‰å®Œå…¨ç”±å­ç¨‹åºçš„æ„ä¹‰å†³å®šï¼Œä¸ä¾èµ–æ‰§è¡Œç»†èŠ‚ã€‚

ä¾‹ï¼š
  âŸ¦(2 + 3) * 5âŸ§ = âŸ¦2 + 3âŸ§ Ã— âŸ¦5âŸ§ = 5 Ã— 5 = 25
```

**ç­‰ä»·æ€§æ¨ç†**ï¼š

```text
å®šç†ï¼ˆå……åˆ†æ€§ Adequacyï¼‰ï¼š
  âŸ¦eâ‚âŸ§ = âŸ¦eâ‚‚âŸ§  â‡’  eâ‚ å’Œ eâ‚‚ è¡Œä¸ºç­‰ä»·

åº”ç”¨ï¼š
  - ç¼–è¯‘å™¨ä¼˜åŒ–ï¼ˆå¸¸é‡æŠ˜å ã€å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤ï¼‰
  - ç¨‹åºé‡æ„
  - ç­‰ä»·æ€§è‡ªåŠ¨è¯æ˜
```

---

## 2 æ•°å­¦åŸºç¡€ï¼šåŸŸç†è®ºï¼ˆDomain Theoryï¼‰

### 2.1 ååºé›†ï¼ˆPartial Orderï¼‰

**å®šä¹‰**ï¼š

```text
ååºé›†ï¼ˆPosetï¼‰æ˜¯äºŒå…ƒç»„ (D, âŠ‘) å…¶ä¸­ï¼š
  - D æ˜¯é›†åˆ
  - âŠ‘ æ˜¯ååºå…³ç³»ï¼Œæ»¡è¶³ï¼š
    1. è‡ªåæ€§ï¼šâˆ€x. x âŠ‘ x
    2. åå¯¹ç§°æ€§ï¼šx âŠ‘ y âˆ§ y âŠ‘ x â‡’ x = y
    3. ä¼ é€’æ€§ï¼šx âŠ‘ y âˆ§ y âŠ‘ z â‡’ x âŠ‘ z
```

**ç›´è§‰**ï¼š`x âŠ‘ y` è¡¨ç¤º `x` æ¯” `y` **ä¿¡æ¯å°‘**æˆ–**æ›´ä¸ç¡®å®š**ã€‚

**ç¤ºä¾‹ 1**ï¼šè‡ªç„¶æ•°çš„å¹³å¦åŸŸï¼ˆFlat Domainï¼‰

```text
â„•_âŠ¥ = {âŠ¥, 0, 1, 2, 3, ...}

ååºï¼š
  âŠ¥ âŠ‘ n  å¯¹æ‰€æœ‰ n âˆˆ â„•
  n âŠ‘ m  â‡”  n = m

è¡¨ç¤ºï¼š
  âŠ¥: éç»ˆæ­¢è®¡ç®—ï¼ˆundefinedï¼‰
  n: ç¡®å®šçš„å€¼
```

**ç¤ºä¾‹ 2**ï¼šçœŸå€¼çš„ä¸‰å…ƒåŸŸ

```text
ğ”¹_âŠ¥ = {âŠ¥, false, true}

ååºï¼š
  âŠ¥ âŠ‘ false
  âŠ¥ âŠ‘ true
  false å’Œ true ä¸å¯æ¯”
```

### 2.2 é“¾ä¸ä¸Šç¡®ç•Œ

**å®šä¹‰**ï¼š

```text
é“¾ï¼ˆChainï¼‰ï¼šå‡é“¾ xâ‚€ âŠ‘ xâ‚ âŠ‘ xâ‚‚ âŠ‘ ...

ä¸Šç¡®ç•Œï¼ˆSupremumï¼‰ï¼šâŠ”áµ¢ xáµ¢
  - ä¸Šç•Œï¼šâˆ€i. xáµ¢ âŠ‘ âŠ”áµ¢ xáµ¢
  - æœ€å°ä¸Šç•Œï¼šâˆ€y. (âˆ€i. xáµ¢ âŠ‘ y) â‡’ âŠ”áµ¢ xáµ¢ âŠ‘ y
```

**ç¤ºä¾‹**ï¼šé€¼è¿‘æ— é™å¾ªç¯

```text
è€ƒè™‘ç¨‹åºï¼šwhile true do skip

é€¼è¿‘é“¾ï¼š
  âŠ¥ âŠ‘ (skip; âŠ¥) âŠ‘ (skip; skip; âŠ¥) âŠ‘ ...

ä¸Šç¡®ç•Œï¼šâŠ”áµ¢ (skip^i; âŠ¥) = æ— é™å¾ªç¯
```

### 2.3 å®Œå…¨ååºé›†ï¼ˆCPOï¼‰

**å®šä¹‰**ï¼š

```text
CPOï¼ˆComplete Partial Orderï¼‰æ˜¯ååºé›† (D, âŠ‘) æ»¡è¶³ï¼š
  1. å­˜åœ¨æœ€å°å…ƒç´  âŠ¥ï¼ˆbottomï¼‰
  2. æ¯æ¡é“¾éƒ½æœ‰ä¸Šç¡®ç•Œ
```

**ä¸ºä»€ä¹ˆéœ€è¦ CPO**ï¼Ÿ

```text
é—®é¢˜ï¼šå¦‚ä½•å®šä¹‰é€’å½’å‡½æ•°çš„æ„ä¹‰ï¼Ÿ

ç¤ºä¾‹ï¼šé˜¶ä¹˜å‡½æ•°
  fact(n) = if n == 0 then 1 else n * fact(n-1)

æŒ‡ç§°ï¼š
  âŸ¦factâŸ§ = ?

CPO æä¾›çš„è§£å†³æ–¹æ¡ˆï¼š
  âŸ¦factâŸ§ = fix(F)  å…¶ä¸­ F(f) = Î»n. if n == 0 then 1 else n * f(n-1)

  fix(F) æ˜¯ F çš„æœ€å°ä¸åŠ¨ç‚¹ï¼ˆleast fixed pointï¼‰
```

### 2.4 è¿ç»­å‡½æ•°ä¸ä¸åŠ¨ç‚¹å®šç†

**å®šä¹‰**ï¼š

```text
å‡½æ•° f: D â†’ E æ˜¯è¿ç»­çš„ï¼ˆScott-continuousï¼‰âŸº
  å¯¹ä»»ä½•é“¾ xâ‚€ âŠ‘ xâ‚ âŠ‘ xâ‚‚ âŠ‘ ...ï¼š
    f(âŠ”áµ¢ xáµ¢) = âŠ”áµ¢ f(xáµ¢)

  ï¼ˆä¿æŒä¸Šç¡®ç•Œï¼‰
```

**Kleene ä¸åŠ¨ç‚¹å®šç†**ï¼š

```text
å®šç†ï¼šè®¾ D æ˜¯ CPOï¼Œf: D â†’ D æ˜¯è¿ç»­å‡½æ•°ï¼Œåˆ™ï¼š
  fix(f) = âŠ”â‚™ fâ¿(âŠ¥)

  ä¸” fix(f) æ˜¯ f çš„æœ€å°ä¸åŠ¨ç‚¹ï¼Œå³ï¼š
    f(fix(f)) = fix(f)
    âˆ€x. f(x) = x â‡’ fix(f) âŠ‘ x

è¯æ˜è‰å›¾ï¼š
  1. æ„é€ é“¾ï¼šâŠ¥ âŠ‘ f(âŠ¥) âŠ‘ fÂ²(âŠ¥) âŠ‘ ...  ï¼ˆå•è°ƒæ€§ï¼‰
  2. å–ä¸Šç¡®ç•Œï¼šx = âŠ”â‚™ fâ¿(âŠ¥)
  3. è¯æ˜ f(x) = xï¼š
     f(x) = f(âŠ”â‚™ fâ¿(âŠ¥)) = âŠ”â‚™ f(fâ¿(âŠ¥)) = âŠ”â‚™ fâ¿âºÂ¹(âŠ¥) = x
  4. æœ€å°æ€§ï¼šç•¥ï¼ˆå‡è®¾å­˜åœ¨æ›´å°çš„ä¸åŠ¨ç‚¹å¯¼å‡ºçŸ›ç›¾ï¼‰
```

**Coq å½¢å¼åŒ–**ï¼š

```coq
Require Import Coq.Init.Nat.
Require Import Coq.Reals.Reals.

(* CPO çš„æŠ½è±¡å®šä¹‰ *)
Class CPO (D : Type) := {
  leq : D -> D -> Prop;
  bottom : D;
  sup : (nat -> D) -> D;  (* é“¾çš„ä¸Šç¡®ç•Œ *)

  (* å…¬ç† *)
  leq_refl : forall x, leq x x;
  leq_trans : forall x y z, leq x y -> leq y z -> leq x z;
  leq_antisym : forall x y, leq x y -> leq y x -> x = y;

  bottom_least : forall x, leq bottom x;

  sup_ub : forall (c : nat -> D) (n : nat), leq (c n) (sup c);
  sup_lub : forall (c : nat -> D) (x : D),
    (forall n, leq (c n) x) -> leq (sup c) x;
}.

(* è¿ç»­å‡½æ•° *)
Definition continuous {D E : Type} `{CPO D} `{CPO E} (f : D -> E) : Prop :=
  forall c : nat -> D,
    f (sup c) = sup (fun n => f (c n)).

(* ä¸åŠ¨ç‚¹ *)
Definition is_fixpoint {D : Type} (f : D -> D) (x : D) : Prop :=
  f x = x.

(* Kleene ä¸åŠ¨ç‚¹ *)
Fixpoint iterate {D : Type} `{CPO D} (f : D -> D) (n : nat) : D :=
  match n with
  | 0 => bottom
  | S n' => f (iterate f n')
  end.

Definition kleene_fixpoint {D : Type} `{CPO D} (f : D -> D) : D :=
  sup (iterate f).

(* ä¸åŠ¨ç‚¹å®šç†ï¼ˆé™ˆè¿°ï¼‰ *)
Theorem kleene_fixpoint_theorem {D : Type} `{CPO D} (f : D -> D) :
  continuous f ->
  is_fixpoint f (kleene_fixpoint f).
Proof.
  intros Hcont.
  unfold kleene_fixpoint, is_fixpoint.
  (* f (sup (iterate f)) = sup (fun n => f (iterate f n)) *)
  rewrite Hcont.
  (* sup (fun n => f (iterate f n)) = sup (iterate f) *)
  apply leq_antisym.
  - (* â‰¤ *)
    apply sup_lub. intros n. simpl.
    destruct n.
    + simpl. apply bottom_least.
    + apply sup_ub.
  - (* â‰¥ *)
    apply sup_lub. intros n.
    destruct n.
    + apply bottom_least.
    + simpl. apply leq_refl.
Qed.
```

---

## 3 ç®€å•è¡¨è¾¾å¼è¯­è¨€çš„æŒ‡ç§°è¯­ä¹‰

### 3.1 è¯­æ³•å®šä¹‰

```text
e âˆˆ Expr ::= n                     (æ•´æ•°å¸¸é‡)
           | x                     (å˜é‡)
           | eâ‚ + eâ‚‚               (åŠ æ³•)
           | eâ‚ * eâ‚‚               (ä¹˜æ³•)
           | eâ‚ == eâ‚‚              (ç›¸ç­‰æ¯”è¾ƒ)
           | if eâ‚ then eâ‚‚ else eâ‚ƒ (æ¡ä»¶)
```

### 3.2 è¯­ä¹‰åŸŸï¼ˆSemantic Domainsï¼‰

```text
å€¼åŸŸï¼š
  Val = â„¤_âŠ¥  (æ•´æ•° + bottom)

ç¯å¢ƒï¼š
  Env = Var â†’ Val  (å˜é‡åˆ°å€¼çš„æ˜ å°„)

è¯­ä¹‰å‡½æ•°ï¼š
  âŸ¦_âŸ§: Expr â†’ Env â†’ Val
```

### 3.3 è¯­ä¹‰å®šä¹‰

```text
âŸ¦nâŸ§Ï = n

âŸ¦xâŸ§Ï = Ï(x)

âŸ¦eâ‚ + eâ‚‚âŸ§Ï =
  let vâ‚ = âŸ¦eâ‚âŸ§Ï in
  let vâ‚‚ = âŸ¦eâ‚‚âŸ§Ï in
  if vâ‚ = âŠ¥ âˆ¨ vâ‚‚ = âŠ¥ then âŠ¥ else vâ‚ + vâ‚‚

âŸ¦eâ‚ * eâ‚‚âŸ§Ï =
  let vâ‚ = âŸ¦eâ‚âŸ§Ï in
  let vâ‚‚ = âŸ¦eâ‚‚âŸ§Ï in
  if vâ‚ = âŠ¥ âˆ¨ vâ‚‚ = âŠ¥ then âŠ¥ else vâ‚ * vâ‚‚

âŸ¦if eâ‚ then eâ‚‚ else eâ‚ƒâŸ§Ï =
  let v = âŸ¦eâ‚âŸ§Ï in
  if v = âŠ¥ then âŠ¥
  else if v = true then âŸ¦eâ‚‚âŸ§Ï
  else âŸ¦eâ‚ƒâŸ§Ï
```

**ä¸¥æ ¼æ€§ï¼ˆStrictnessï¼‰**ï¼š

```text
å®šä¹‰ï¼šå‡½æ•° f æ˜¯ä¸¥æ ¼çš„ âŸº f(âŠ¥) = âŠ¥

ç¤ºä¾‹ï¼š
  - åŠ æ³•æ˜¯ä¸¥æ ¼çš„ï¼šâŠ¥ + n = âŠ¥
  - if-then-else åœ¨æ¡ä»¶ä¸Šä¸¥æ ¼ï¼Œä½†åœ¨åˆ†æ”¯ä¸Šéä¸¥æ ¼
```

### 3.4 Haskell å®ç°

```haskell
-- å€¼åŸŸ
data Val = Bottom | Int Integer | Bool Bool
  deriving (Show, Eq)

-- ç¯å¢ƒ
type Env = String -> Val

-- è¡¨è¾¾å¼
data Expr
  = Const Integer
  | Var String
  | Add Expr Expr
  | Mul Expr Expr
  | Eq Expr Expr
  | If Expr Expr Expr
  deriving (Show)

-- æŒ‡ç§°è¯­ä¹‰
denote :: Expr -> Env -> Val
denote (Const n) _ = Int n
denote (Var x) env = env x
denote (Add e1 e2) env =
  case (denote e1 env, denote e2 env) of
    (Int v1, Int v2) -> Int (v1 + v2)
    _ -> Bottom
denote (Mul e1 e2) env =
  case (denote e1 env, denote e2 env) of
    (Int v1, Int v2) -> Int (v1 * v2)
    _ -> Bottom
denote (Eq e1 e2) env =
  case (denote e1 env, denote e2 env) of
    (Int v1, Int v2) -> Bool (v1 == v2)
    _ -> Bottom
denote (If e1 e2 e3) env =
  case denote e1 env of
    Bool True -> denote e2 env
    Bool False -> denote e3 env
    _ -> Bottom

-- ç¤ºä¾‹
example :: Expr
example = If (Eq (Var "x") (Const 0))
             (Const 1)
             (Mul (Var "x") (Const 2))

-- æ±‚å€¼
main :: IO ()
main = do
  let env = \x -> if x == "x" then Int 5 else Bottom
  print $ denote example env  -- è¾“å‡º: Int 10
```

---

## 4 å‘½ä»¤å¼è¯­è¨€çš„æŒ‡ç§°è¯­ä¹‰

### 4.1 è¯­æ³•å®šä¹‰

```text
å‘½ä»¤ï¼š
  c âˆˆ Comm ::= skip
             | x := e
             | câ‚; câ‚‚
             | if e then câ‚ else câ‚‚
             | while e do c
```

### 4.2 è¯­ä¹‰åŸŸ

```text
çŠ¶æ€ç©ºé—´ï¼š
  State = Var â†’ Val

å‘½ä»¤çš„æ„ä¹‰ï¼š
  âŸ¦_âŸ§: Comm â†’ (State â†’ State_âŠ¥)

  ï¼ˆå‘½ä»¤æ˜¯ä»çŠ¶æ€åˆ°çŠ¶æ€çš„åå‡½æ•°ï¼‰
```

### 4.3 è¯­ä¹‰å®šä¹‰

```text
âŸ¦skipâŸ§Ïƒ = Ïƒ

âŸ¦x := eâŸ§Ïƒ = Ïƒ[x â†¦ âŸ¦eâŸ§Ïƒ]

âŸ¦câ‚; câ‚‚âŸ§ = âŸ¦câ‚‚âŸ§ âˆ˜ âŸ¦câ‚âŸ§
  ï¼ˆå‡½æ•°ç»„åˆï¼‰

âŸ¦if e then câ‚ else câ‚‚âŸ§Ïƒ =
  if âŸ¦eâŸ§Ïƒ = true then âŸ¦câ‚âŸ§Ïƒ
  else if âŸ¦eâŸ§Ïƒ = false then âŸ¦câ‚‚âŸ§Ïƒ
  else âŠ¥

âŸ¦while e do câŸ§ = fix(F)
  where F(f) = Î»Ïƒ. if âŸ¦eâŸ§Ïƒ = true then f(âŸ¦câŸ§Ïƒ)
                   else if âŸ¦eâŸ§Ïƒ = false then Ïƒ
                   else âŠ¥
```

**å…³é”®**ï¼š`while` å¾ªç¯çš„è¯­ä¹‰é€šè¿‡ä¸åŠ¨ç‚¹å®šä¹‰ï¼

### 4.4 ä¸åŠ¨ç‚¹å±•å¼€ç¤ºä¾‹

**ç¨‹åº**ï¼š

```text
while x > 0 do x := x - 1
```

**æŒ‡ç§°**ï¼š

```text
âŸ¦while x > 0 do x := x - 1âŸ§ = fix(F)

F(f) = Î»Ïƒ. if Ïƒ(x) > 0 then f(Ïƒ[x â†¦ Ïƒ(x) - 1]) else Ïƒ

é€¼è¿‘åºåˆ—ï¼š
  fâ° = Î»Ïƒ. âŠ¥  ï¼ˆä¸ç»ˆæ­¢ï¼‰

  fÂ¹ = Î»Ïƒ. if Ïƒ(x) > 0 then âŠ¥ else Ïƒ
       ï¼ˆå¾ªç¯ä¸€æ¬¡åä¸ç»ˆæ­¢ï¼‰

  fÂ² = Î»Ïƒ. if Ïƒ(x) > 0 then
             (if Ïƒ(x) - 1 > 0 then âŠ¥ else Ïƒ[x â†¦ 0])
           else Ïƒ
       ï¼ˆæœ€å¤šå¾ªç¯ä¸¤æ¬¡ï¼‰

  ...

  fix(F) = âŠ”â‚™ fâ¿
         = Î»Ïƒ. if Ïƒ(x) â‰¥ 0 then Ïƒ[x â†¦ 0] else âŠ¥
```

### 4.5 Lean4 å½¢å¼åŒ–

```lean
import Mathlib.Data.Finmap
import Mathlib.Order.FixedPoints

-- çŠ¶æ€ç©ºé—´
def State := String â†’ Int

-- å‘½ä»¤
inductive Comm where
  | skip : Comm
  | assign : String â†’ (State â†’ Int) â†’ Comm
  | seq : Comm â†’ Comm â†’ Comm
  | ite : (State â†’ Bool) â†’ Comm â†’ Comm â†’ Comm
  | while : (State â†’ Bool) â†’ Comm â†’ Comm

-- è¯­ä¹‰å‡½æ•°ç±»å‹
def StateFunc := State â†’ Option State

-- æŒ‡ç§°è¯­ä¹‰
def denoteComm : Comm â†’ StateFunc
  | Comm.skip => fun Ïƒ => some Ïƒ
  | Comm.assign x e => fun Ïƒ => some (fun y => if y == x then e Ïƒ else Ïƒ y)
  | Comm.seq c1 c2 => fun Ïƒ =>
      match denoteComm c1 Ïƒ with
      | none => none
      | some Ïƒ' => denoteComm c2 Ïƒ'
  | Comm.ite b c1 c2 => fun Ïƒ =>
      if b Ïƒ then denoteComm c1 Ïƒ else denoteComm c2 Ïƒ
  | Comm.while b c =>
      -- éœ€è¦ä¸åŠ¨ç‚¹ï¼ˆåœ¨ Lean ä¸­éœ€è¦é€šè¿‡ well-founded recursion å®ç°ï¼‰
      sorry  -- ç•¥ï¼ˆéœ€è¦å®šä¹‰ CPO å’Œä¸åŠ¨ç‚¹ç»„åˆå­ï¼‰

-- ç¤ºä¾‹ï¼šx := x + 1
def incX : Comm :=
  Comm.assign "x" (fun Ïƒ => Ïƒ "x" + 1)

#eval denoteComm incX (fun _ => 0)  -- some (fun _ => 1)
```

---

## 5 Î» æ¼”ç®—çš„æŒ‡ç§°è¯­ä¹‰

### 5.1 æ— ç±»å‹ Î» æ¼”ç®—

**è¯­æ³•**ï¼š

```text
e ::= x          (å˜é‡)
    | Î»x. e      (æŠ½è±¡)
    | eâ‚ eâ‚‚      (åº”ç”¨)
```

**é—®é¢˜**ï¼šå¦‚ä½•å®šä¹‰ `âŸ¦Î»x. eâŸ§`ï¼Ÿ

**å¤©çœŸå°è¯•**ï¼ˆå¤±è´¥ï¼‰ï¼š

```text
âŸ¦Î»x. eâŸ§Ï = å‡½æ•° f: Val â†’ Val
  å…¶ä¸­ f(v) = âŸ¦eâŸ§(Ï[x â†¦ v])

é—®é¢˜ï¼šVal æ˜¯ä»€ä¹ˆï¼Ÿ
  - å¦‚æœ Val = Int âˆª Boolï¼šå¤ªå°ï¼ˆæ— æ³•è¡¨ç¤ºé«˜é˜¶å‡½æ•°ï¼‰
  - å¦‚æœ Val = Int âˆª Bool âˆª (Val â†’ Val)ï¼šå¾ªç¯å®šä¹‰ï¼
```

**è§£å†³æ–¹æ¡ˆ**ï¼šScott åŸŸï¼ˆDomain Equationï¼‰

### 5.2 Scott åŸŸæ„é€ 

**ç›®æ ‡**ï¼šæ‰¾åˆ° D ä½¿å¾— `D â‰… D â†’ D`ï¼ˆåŒæ„ï¼‰

**æ­¥éª¤**ï¼š

```text
1. æ„é€  CPO èŒƒç•´çš„å­èŒƒç•´ï¼ˆå…·æœ‰æœ‰é™å…ƒç´ çš„åŸŸï¼‰
2. è¯æ˜å‡½æ•°ç©ºé—´æ„é€  D â†’ E æ˜¯ CPO
3. åˆ©ç”¨åå°„åŸŸç†è®ºï¼ˆinverse limitï¼‰æ„é€  D_âˆ â‰… D_âˆ â†’ D_âˆ
```

**ç›´è§‰**ï¼š

```text
Dâ‚€ = {âŠ¥}
Dâ‚ = {âŠ¥} âˆª (Dâ‚€ â†’ Dâ‚€) = {âŠ¥, âŠ¥â†’âŠ¥}
Dâ‚‚ = {âŠ¥} âˆª (Dâ‚ â†’ Dâ‚) = ...
...
D_âˆ = åå‘æé™(Dâ‚€, Dâ‚, Dâ‚‚, ...)
```

**ç»“æœ**ï¼š

```text
å®šç†ï¼ˆScott 1972ï¼‰ï¼š
  å­˜åœ¨ CPO D_âˆ ä½¿å¾— D_âˆ â‰… [D_âˆ â†’ D_âˆ]

  å…¶ä¸­ [D â†’ E] æ˜¯è¿ç»­å‡½æ•°ç©ºé—´
```

### 5.3 è¯­ä¹‰å®šä¹‰

```text
ç¯å¢ƒï¼š
  Ï âˆˆ Env = Var â†’ D_âˆ

è¯­ä¹‰å‡½æ•°ï¼š
  âŸ¦_âŸ§: Expr â†’ Env â†’ D_âˆ

âŸ¦xâŸ§Ï = Ï(x)

âŸ¦Î»x. eâŸ§Ï = Î›v âˆˆ D_âˆ. âŸ¦eâŸ§(Ï[x â†¦ v])
  ï¼ˆÎ› è¡¨ç¤ºè¿ç»­å‡½æ•°æŠ½è±¡ï¼‰

âŸ¦eâ‚ eâ‚‚âŸ§Ï = (âŸ¦eâ‚âŸ§Ï) Â· (âŸ¦eâ‚‚âŸ§Ï)
  ï¼ˆÂ· è¡¨ç¤ºå‡½æ•°åº”ç”¨ï¼‰
```

**é€’å½’å®šä¹‰**ï¼š

```text
Y ç»„åˆå­ï¼šY = Î»f. (Î»x. f (x x)) (Î»x. f (x x))

æŒ‡ç§°ï¼š
  âŸ¦YâŸ§Ï = fix(Î»f. f)

  æ»¡è¶³ï¼šâŸ¦Y fâŸ§ = âŸ¦f (Y f)âŸ§
```

---

## 6 æŒ‡ç§°è¯­ä¹‰ä¸æ“ä½œè¯­ä¹‰çš„å…³ç³»

### 6.1 å……åˆ†æ€§å®šç†ï¼ˆAdequacyï¼‰

**å®šç†**ï¼š

```text
å¯¹äºè¡¨è¾¾å¼ eï¼š
  âŸ¦eâŸ§Ï â‰  âŠ¥  â‡”  âˆƒv. e â‡“ v  ï¼ˆæ“ä½œè¯­ä¹‰ç»ˆæ­¢ï¼‰

æ„ä¹‰ï¼š
  - æŒ‡ç§°è¯­ä¹‰çš„ âŠ¥ å¯¹åº”æ“ä½œè¯­ä¹‰çš„å‘æ•£ï¼ˆdivergenceï¼‰
  - æŒ‡ç§°è¯­ä¹‰çš„ç¡®å®šå€¼å¯¹åº”æ“ä½œè¯­ä¹‰çš„ç»ˆæ­¢
```

**è¯æ˜è‰å›¾**ï¼š

```text
â‡’ æ–¹å‘ï¼š
  - å‡è®¾ âŸ¦eâŸ§Ï â‰  âŠ¥
  - å¯¹ e çš„ç»“æ„å½’çº³
  - åˆ©ç”¨æŒ‡ç§°è¯­ä¹‰çš„ç»„åˆæ€§
  - æ„é€ æ“ä½œè¯­ä¹‰çš„æ¨å¯¼æ ‘

â‡ æ–¹å‘ï¼š
  - å‡è®¾ e â‡“ v
  - å¯¹æ¨å¯¼é«˜åº¦å½’çº³
  - è¯æ˜ âŸ¦eâŸ§Ï = âŸ¦vâŸ§Ï
```

### 6.2 å…¨æŠ½è±¡ï¼ˆFull Abstractionï¼‰

**å®šä¹‰**ï¼š

```text
æŒ‡ç§°è¯­ä¹‰æ˜¯å…¨æŠ½è±¡çš„ âŸº
  âŸ¦eâ‚âŸ§ = âŸ¦eâ‚‚âŸ§  â‡”  eâ‚ â‰ˆ eâ‚‚  ï¼ˆä¸Šä¸‹æ–‡ç­‰ä»·ï¼‰

å…¶ä¸­ eâ‚ â‰ˆ eâ‚‚ è¡¨ç¤ºï¼š
  âˆ€C[_]. C[eâ‚] â‡“ v â‡” C[eâ‚‚] â‡“ v
```

**é—®é¢˜**ï¼šæ ‡å‡†çš„ PCF æŒ‡ç§°è¯­ä¹‰**ä¸æ˜¯**å…¨æŠ½è±¡çš„ï¼

**åä¾‹**ï¼ˆPlotkin 1977ï¼‰ï¼š

```text
eâ‚ = Î»f. if (f Î»x.âŠ¥ = âŠ¥) then âŠ¥ else 1
eâ‚‚ = Î»f. âŠ¥

æŒ‡ç§°ç­‰ä»·ï¼šâŸ¦eâ‚âŸ§ = âŸ¦eâ‚‚âŸ§ = âŠ¥
ä¸Šä¸‹æ–‡ä¸ç­‰ä»·ï¼šå­˜åœ¨ C ä½¿å¾— C[eâ‚] â‡“ 1 ä½† C[eâ‚‚] â‡“ âŠ¥

åŸå› ï¼šæŒ‡ç§°è¯­ä¹‰æ— æ³•åŒºåˆ†"é¡ºåº"ï¼ˆsequentialï¼‰å’Œ"å¹¶è¡Œ"ï¼ˆparallel orï¼‰
```

**è§£å†³æ–¹æ¡ˆ**ï¼š

- **Game Semantics**ï¼ˆAbramsky, Hylandï¼‰ï¼šé€šè¿‡åšå¼ˆè®ºå»ºæ¨¡äº¤äº’
- **Sequentiality**ï¼šæ·»åŠ é¡ºåºæ€§çº¦æŸ

---

## 7 åº”ç”¨ï¼šç¼–è¯‘å™¨ä¼˜åŒ–

### 7.1 å¸¸é‡æŠ˜å ï¼ˆConstant Foldingï¼‰

**è§„åˆ™**ï¼š

```text
âŸ¦2 + 3âŸ§ = 5  â‡’  å°†è¡¨è¾¾å¼æ›¿æ¢ä¸ºå¸¸é‡ 5
```

**æ­£ç¡®æ€§**ï¼š

```text
å®šç†ï¼šâŸ¦eâŸ§ = âŸ¦optimize(e)âŸ§
```

**å®ç°**ï¼ˆHaskellï¼‰ï¼š

```haskell
optimize :: Expr -> Expr
optimize (Add (Const n1) (Const n2)) = Const (n1 + n2)
optimize (Mul (Const n1) (Const n2)) = Const (n1 * n2)
optimize (Add e1 e2) = Add (optimize e1) (optimize e2)
optimize (Mul e1 e2) = Mul (optimize e1) (optimize e2)
optimize e = e

-- æ­£ç¡®æ€§å®šç†ï¼ˆæ‰‹åŠ¨è¯æ˜ï¼‰
-- Theorem: forall e, denote e = denote (optimize e)
```

### 7.2 æ­»ä»£ç æ¶ˆé™¤ï¼ˆDead Code Eliminationï¼‰

**è§„åˆ™**ï¼š

```text
if true then eâ‚ else eâ‚‚  âŸ¹  eâ‚
if false then eâ‚ else eâ‚‚  âŸ¹  eâ‚‚
```

**æŒ‡ç§°ç­‰ä»·æ€§**ï¼š

```text
âŸ¦if true then eâ‚ else eâ‚‚âŸ§Ï
  = (if true then âŸ¦eâ‚âŸ§Ï else âŸ¦eâ‚‚âŸ§Ï)
  = âŸ¦eâ‚âŸ§Ï

ç±»ä¼¼åœ°ï¼šâŸ¦if false then eâ‚ else eâ‚‚âŸ§Ï = âŸ¦eâ‚‚âŸ§Ï
```

### 7.3 å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤ï¼ˆCSEï¼‰

**è§„åˆ™**ï¼š

```text
(x + y) * (x + y)  âŸ¹  let t = x + y in t * t
```

**æ­£ç¡®æ€§**ï¼š

```text
âŸ¦(x + y) * (x + y)âŸ§Ï
  = âŸ¦x + yâŸ§Ï * âŸ¦x + yâŸ§Ï
  = let v = âŸ¦x + yâŸ§Ï in v * v
  = âŸ¦let t = x + y in t * tâŸ§Ï
```

---

## 8 ä¸å›½é™…è¯¾ç¨‹å¯¹æ ‡

### 8.1 å¤§å­¦è¯¾ç¨‹æ˜ å°„

| è¯¾ç¨‹ | ç›¸å…³ç« èŠ‚ |
|------|---------|
| **MIT 6.820 å½¢å¼è¯­ä¹‰å­¦** | Domain Theory, Denotational Semantics |
| **CMU 15-312 ç¼–ç¨‹è¯­è¨€åŸºç¡€** | Î» æ¼”ç®—æŒ‡ç§°è¯­ä¹‰ |
| **Stanford CS242 ç±»å‹ç³»ç»Ÿ** | æŒ‡ç§°è¯­ä¹‰ä¸ç±»å‹ç³»ç»Ÿ |
| **Oxford ç¼–ç¨‹è¯­è¨€ç†è®º** | Scott åŸŸï¼Œå…¨æŠ½è±¡ |
| **EPFL CS-550 å½¢å¼éªŒè¯** | å……åˆ†æ€§å®šç† |

### 8.2 æ•™æå¯¹åº”

| æ•™æ | ç›¸å…³ç« èŠ‚ |
|------|---------|
| **Winskel "The Formal Semantics of Programming Languages"** | å®Œæ•´æ•™æå¯¹åº” |
| **Pierce "Types and Programming Languages"** | Ch 5 (Untyped Lambda Calculus) |
| **Gunter "Semantics of Programming Languages"** | Domain Theory |
| **Abramsky & Jung "Domain Theory"** | æ•°å­¦åŸºç¡€ï¼ˆÂ§2ï¼‰ |

---

## 9 å·¥å…·ä¸ç”Ÿæ€

### 9.1 å®šç†è¯æ˜å™¨

| å·¥å…· | ç”¨é€” | ç¤ºä¾‹ |
|------|------|------|
| **Coq** | æŒ‡ç§°è¯­ä¹‰å½¢å¼åŒ– | Â§2.4, Â§4.5 |
| **Isabelle/HOL** | Domain Theory | HOLCF åº“ |
| **Agda** | ä¾èµ–ç±»å‹è¯­ä¹‰ | é«˜é˜¶æŠ½è±¡è¯­æ³• |

### 9.2 ç¼–ç¨‹è¯­è¨€å®ç°

| è¯­è¨€ | ç‰¹ç‚¹ | å¯¹åº”æ¦‚å¿µ |
|------|------|----------|
| **Haskell** | æƒ°æ€§æ±‚å€¼ | éä¸¥æ ¼è¯­ä¹‰ |
| **ML** | ä¸¥æ ¼æ±‚å€¼ | ä¸¥æ ¼è¯­ä¹‰ |
| **Scheme** | å°¾é€’å½’ä¼˜åŒ– | ä¸åŠ¨ç‚¹ä¼˜åŒ– |

---

## 10 æ‰©å±•é˜…è¯»

### 10.1 å­¦æœ¯è®ºæ–‡

1. **Scott, D.** "Outline of a Mathematical Theory of Computation." 1970.
2. **Plotkin, G.** "LCF Considered as a Programming Language." 1977.
3. **Abramsky, S. & Jung, A.** "Domain Theory." Handbook, 1994.

### 10.2 åœ¨çº¿èµ„æº

- **Denotational Semantics**ï¼š<https://en.wikipedia.org/wiki/Denotational_semantics>
- **Domain Theory**ï¼š<http://www.cs.bham.ac.uk/~axj/pub/papers/handy1.pdf>

### 10.3 æœ¬åœ°é¡¹ç›®å¼•ç”¨

- **æ“ä½œè¯­ä¹‰**ï¼š[./01.1_Operational_Semantics.md](./01.1_Operational_Semantics.md)
- **å…¬ç†è¯­ä¹‰**ï¼š[./01.3_Axiomatic_Semantics.md](./01.3_Axiomatic_Semantics.md)
- **ç±»å‹ç³»ç»Ÿ**ï¼š[./01.4_Type_Systems.md](./01.4_Type_Systems.md)

---

## 11 é™„å½• Aï¼šWikipedia æ¦‚å¿µå¯¹ç…§

| æ¦‚å¿µ | Wikipedia æ¡ç›® | æœ¬æ–‡ç« èŠ‚ |
|------|---------------|----------|
| Denotational Semantics | <https://en.wikipedia.org/wiki/Denotational_semantics> | Â§1 |
| Domain Theory | <https://en.wikipedia.org/wiki/Domain_theory> | Â§2 |
| Complete Partial Order | <https://en.wikipedia.org/wiki/Complete_partial_order> | Â§2.3 |
| Fixed Point | <https://en.wikipedia.org/wiki/Fixed-point_combinator> | Â§2.4 |
| Lambda Calculus | <https://en.wikipedia.org/wiki/Lambda_calculus> | Â§5 |
| Full Abstraction | <https://en.wikipedia.org/wiki/Full_abstraction> | Â§6.2 |

---

**ç‰ˆæœ¬**ï¼šv1.0
**æœ€åæ›´æ–°**ï¼š2025-10-29
**ç»´æŠ¤è€…**ï¼šFormalScience Project
**è®¸å¯**ï¼šMIT

---

## è·¨è§†è§’é“¾æ¥

- [FormalLanguage_Perspective](../../FormalLanguage_Perspective/README.md)
- [Software_Perspective](../../Software_Perspective/README.md)
- [æ¦‚å¿µäº¤å‰ç´¢å¼•ï¼ˆä¸ƒè§†è§’ç‰ˆï¼‰](../../CONCEPT_CROSS_INDEX.md) - æŸ¥çœ‹ç›¸å…³æ¦‚å¿µçš„ä¸ƒè§†è§’åˆ†æï¼š
  - [å›¾çµå®Œå¤‡æ€§](../../CONCEPT_CROSS_INDEX.md#191-å›¾çµå®Œå¤‡æ€§-turing-completeness-ä¸ƒè§†è§’) - æŒ‡ç§°è¯­ä¹‰å®šä¹‰çš„è®¡ç®—èƒ½åŠ›
  - [Church-Turingè®ºé¢˜](../../CONCEPT_CROSS_INDEX.md#57-church-turingè®ºé¢˜-church-turing-thesis-ä¸ƒè§†è§’) - è®¡ç®—æ¨¡å‹çš„ç­‰ä»·æ€§
  - [GÃ¶delä¸å®Œå¤‡å®šç†](../../CONCEPT_CROSS_INDEX.md#101-gÃ¶delä¸å®Œå¤‡å®šç†-gÃ¶dels-incompleteness-theorems-ä¸ƒè§†è§’) - å½¢å¼ç³»ç»Ÿçš„è¯­ä¹‰å®Œæ•´æ€§é™åˆ¶
