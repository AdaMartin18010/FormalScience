# 01.2 指称语义（Denotational Semantics）

## 📚 目录

- [概述](#概述)
- [1. 动机与对比](#1-动机与对比)
  - [1.1 三种语义学对比](#11-三种语义学对比)
  - [1.2 指称语义的优势](#12-指称语义的优势)
- [2. 数学基础：域理论（Domain Theory）](#2-数学基础域理论domain-theory)
  - [2.1 偏序集（Partial Order）](#21-偏序集partial-order)
  - [2.2 链与上确界](#22-链与上确界)
  - [2.3 完全偏序集（CPO）](#23-完全偏序集cpo)
  - [2.4 连续函数与不动点定理](#24-连续函数与不动点定理)
- [3. 简单表达式语言的指称语义](#3-简单表达式语言的指称语义)
  - [3.1 语法定义](#31-语法定义)
  - [3.2 语义域（Semantic Domains）](#32-语义域semantic-domains)
  - [3.3 语义定义](#33-语义定义)
  - [3.4 Haskell 实现](#34-haskell-实现)
- [4. 命令式语言的指称语义](#4-命令式语言的指称语义)
  - [4.1 语法定义](#41-语法定义)
  - [4.2 语义域](#42-语义域)
  - [4.3 语义定义](#43-语义定义)
  - [4.4 不动点展开示例](#44-不动点展开示例)
  - [4.5 Lean4 形式化](#45-lean4-形式化)
- [5. λ 演算的指称语义](#5-λ-演算的指称语义)
  - [5.1 无类型 λ 演算](#51-无类型-λ-演算)
  - [5.2 Scott 域构造](#52-scott-域构造)
  - [5.3 语义定义](#53-语义定义)
- [6. 指称语义与操作语义的关系](#6-指称语义与操作语义的关系)
  - [6.1 充分性定理（Adequacy）](#61-充分性定理adequacy)
  - [6.2 全抽象（Full Abstraction）](#62-全抽象full-abstraction)
- [7. 应用：编译器优化](#7-应用编译器优化)
- [8. 与国际课程对标](#8-与国际课程对标)
- [9. 教材对应](#9-教材对应)
- [10. 本地项目引用](#10-本地项目引用)

---

## 概述

**指称语义**（Denotational Semantics）回答核心问题：
> 程序的**意义**（meaning）是什么？

与操作语义不同，指称语义不关心程序**如何执行**，而是直接将程序映射到数学对象（通常是函数或集合）。这种方法：

- 提供程序的**抽象数学模型**
- 支持**组合性**（compositional）推理
- 适合**编译器优化**和**等价性证明**

本文将从**domain theory**（域理论）基础出发，系统介绍指称语义的构造方法和应用。

---

## 1. 动机与对比

### 1.1 三种语义学对比

```text
┌────────────────┬──────────────────────┬────────────────────┬────────────────────┐
│                │ 操作语义              │ 指称语义           │ 公理语义            │
├────────────────┼──────────────────────┼────────────────────┼────────────────────┤
│ 核心问题        │ 程序如何执行？        │ 程序意义是什么？   │ 如何证明程序性质？    │
│ 形式化方法      │ 转移系统             │ 数学函数           │ Hoare 逻辑          │
│ 抽象层次       │ 低（接近机器）         │ 高（数学对象）     │ 中（逻辑公式）      │
│ 组合性         │ 弱                   │ 强                 │ 强                 │
│ 适用场景       │ 证明算法正确性         │ 编译器优化         │ 程序验证            │
│ 代表工具       │ K-Framework          │ Haskell (lazy eval)│ Coq, Frama-C       │
└────────────────┴──────────────────────┴────────────────────┴────────────────────┘
```

### 1.2 指称语义的优势

**组合性（Compositionality）**：

```text
定理（组合性原理）：
  ⟦e₁ op e₂⟧ = F(⟦e₁⟧, ⟦e₂⟧)
  
  程序的意义完全由子程序的意义决定，不依赖执行细节。
  
例：
  ⟦(2 + 3) * 5⟧ = ⟦2 + 3⟧ × ⟦5⟧ = 5 × 5 = 25
```

**等价性推理**：

```text
定理（充分性 Adequacy）：
  ⟦e₁⟧ = ⟦e₂⟧  ⇒  e₁ 和 e₂ 行为等价
  
应用：
  - 编译器优化（常量折叠、公共子表达式消除）
  - 程序重构
  - 等价性自动证明
```

---

## 2. 数学基础：域理论（Domain Theory）

### 2.1 偏序集（Partial Order）

**定义**：

```text
偏序集（Poset）是二元组 (D, ⊑) 其中：
  - D 是集合
  - ⊑ 是偏序关系，满足：
    1. 自反性：∀x. x ⊑ x
    2. 反对称性：x ⊑ y ∧ y ⊑ x ⇒ x = y
    3. 传递性：x ⊑ y ∧ y ⊑ z ⇒ x ⊑ z
```

**直觉**：`x ⊑ y` 表示 `x` 比 `y` **信息少**或**更不确定**。

**示例 1**：自然数的平坦域（Flat Domain）

```text
ℕ_⊥ = {⊥, 0, 1, 2, 3, ...}

偏序：
  ⊥ ⊑ n  对所有 n ∈ ℕ
  n ⊑ m  ⇔  n = m

表示：
  ⊥: 非终止计算（undefined）
  n: 确定的值
```

**示例 2**：真值的三元域

```text
𝔹_⊥ = {⊥, false, true}

偏序：
  ⊥ ⊑ false
  ⊥ ⊑ true
  false 和 true 不可比
```

### 2.2 链与上确界

**定义**：

```text
链（Chain）：升链 x₀ ⊑ x₁ ⊑ x₂ ⊑ ...

上确界（Supremum）：⊔ᵢ xᵢ
  - 上界：∀i. xᵢ ⊑ ⊔ᵢ xᵢ
  - 最小上界：∀y. (∀i. xᵢ ⊑ y) ⇒ ⊔ᵢ xᵢ ⊑ y
```

**示例**：逼近无限循环

```text
考虑程序：while true do skip

逼近链：
  ⊥ ⊑ (skip; ⊥) ⊑ (skip; skip; ⊥) ⊑ ...
  
上确界：⊔ᵢ (skip^i; ⊥) = 无限循环
```

### 2.3 完全偏序集（CPO）

**定义**：

```text
CPO（Complete Partial Order）是偏序集 (D, ⊑) 满足：
  1. 存在最小元素 ⊥（bottom）
  2. 每条链都有上确界
```

**为什么需要 CPO**？

```text
问题：如何定义递归函数的意义？

示例：阶乘函数
  fact(n) = if n == 0 then 1 else n * fact(n-1)

指称：
  ⟦fact⟧ = ?

CPO 提供的解决方案：
  ⟦fact⟧ = fix(F)  其中 F(f) = λn. if n == 0 then 1 else n * f(n-1)
  
  fix(F) 是 F 的最小不动点（least fixed point）
```

### 2.4 连续函数与不动点定理

**定义**：

```text
函数 f: D → E 是连续的（Scott-continuous）⟺
  对任何链 x₀ ⊑ x₁ ⊑ x₂ ⊑ ...：
    f(⊔ᵢ xᵢ) = ⊔ᵢ f(xᵢ)
  
  （保持上确界）
```

**Kleene 不动点定理**：

```text
定理：设 D 是 CPO，f: D → D 是连续函数，则：
  fix(f) = ⊔ₙ fⁿ(⊥)
  
  且 fix(f) 是 f 的最小不动点，即：
    f(fix(f)) = fix(f)
    ∀x. f(x) = x ⇒ fix(f) ⊑ x

证明草图：
  1. 构造链：⊥ ⊑ f(⊥) ⊑ f²(⊥) ⊑ ...  （单调性）
  2. 取上确界：x = ⊔ₙ fⁿ(⊥)
  3. 证明 f(x) = x：
     f(x) = f(⊔ₙ fⁿ(⊥)) = ⊔ₙ f(fⁿ(⊥)) = ⊔ₙ fⁿ⁺¹(⊥) = x
  4. 最小性：略（假设存在更小的不动点导出矛盾）
```

**Coq 形式化**：

```coq
Require Import Coq.Init.Nat.
Require Import Coq.Reals.Reals.

(* CPO 的抽象定义 *)
Class CPO (D : Type) := {
  leq : D -> D -> Prop;
  bottom : D;
  sup : (nat -> D) -> D;  (* 链的上确界 *)
  
  (* 公理 *)
  leq_refl : forall x, leq x x;
  leq_trans : forall x y z, leq x y -> leq y z -> leq x z;
  leq_antisym : forall x y, leq x y -> leq y x -> x = y;
  
  bottom_least : forall x, leq bottom x;
  
  sup_ub : forall (c : nat -> D) (n : nat), leq (c n) (sup c);
  sup_lub : forall (c : nat -> D) (x : D),
    (forall n, leq (c n) x) -> leq (sup c) x;
}.

(* 连续函数 *)
Definition continuous {D E : Type} `{CPO D} `{CPO E} (f : D -> E) : Prop :=
  forall c : nat -> D,
    f (sup c) = sup (fun n => f (c n)).

(* 不动点 *)
Definition is_fixpoint {D : Type} (f : D -> D) (x : D) : Prop :=
  f x = x.

(* Kleene 不动点 *)
Fixpoint iterate {D : Type} `{CPO D} (f : D -> D) (n : nat) : D :=
  match n with
  | 0 => bottom
  | S n' => f (iterate f n')
  end.

Definition kleene_fixpoint {D : Type} `{CPO D} (f : D -> D) : D :=
  sup (iterate f).

(* 不动点定理（陈述） *)
Theorem kleene_fixpoint_theorem {D : Type} `{CPO D} (f : D -> D) :
  continuous f ->
  is_fixpoint f (kleene_fixpoint f).
Proof.
  intros Hcont.
  unfold kleene_fixpoint, is_fixpoint.
  (* f (sup (iterate f)) = sup (fun n => f (iterate f n)) *)
  rewrite Hcont.
  (* sup (fun n => f (iterate f n)) = sup (iterate f) *)
  apply leq_antisym.
  - (* ≤ *)
    apply sup_lub. intros n. simpl.
    destruct n.
    + simpl. apply bottom_least.
    + apply sup_ub.
  - (* ≥ *)
    apply sup_lub. intros n.
    destruct n.
    + apply bottom_least.
    + simpl. apply leq_refl.
Qed.
```

---

## 3. 简单表达式语言的指称语义

### 3.1 语法定义

```text
e ∈ Expr ::= n                     (整数常量)
           | x                     (变量)
           | e₁ + e₂               (加法)
           | e₁ * e₂               (乘法)
           | e₁ == e₂              (相等比较)
           | if e₁ then e₂ else e₃ (条件)
```

### 3.2 语义域（Semantic Domains）

```text
值域：
  Val = ℤ_⊥  (整数 + bottom)

环境：
  Env = Var → Val  (变量到值的映射)

语义函数：
  ⟦_⟧: Expr → Env → Val
```

### 3.3 语义定义

```text
⟦n⟧ρ = n

⟦x⟧ρ = ρ(x)

⟦e₁ + e₂⟧ρ = 
  let v₁ = ⟦e₁⟧ρ in
  let v₂ = ⟦e₂⟧ρ in
  if v₁ = ⊥ ∨ v₂ = ⊥ then ⊥ else v₁ + v₂

⟦e₁ * e₂⟧ρ = 
  let v₁ = ⟦e₁⟧ρ in
  let v₂ = ⟦e₂⟧ρ in
  if v₁ = ⊥ ∨ v₂ = ⊥ then ⊥ else v₁ * v₂

⟦if e₁ then e₂ else e₃⟧ρ =
  let v = ⟦e₁⟧ρ in
  if v = ⊥ then ⊥
  else if v = true then ⟦e₂⟧ρ
  else ⟦e₃⟧ρ
```

**严格性（Strictness）**：

```text
定义：函数 f 是严格的 ⟺ f(⊥) = ⊥

示例：
  - 加法是严格的：⊥ + n = ⊥
  - if-then-else 在条件上严格，但在分支上非严格
```

### 3.4 Haskell 实现

```haskell
-- 值域
data Val = Bottom | Int Integer | Bool Bool
  deriving (Show, Eq)

-- 环境
type Env = String -> Val

-- 表达式
data Expr 
  = Const Integer
  | Var String
  | Add Expr Expr
  | Mul Expr Expr
  | Eq Expr Expr
  | If Expr Expr Expr
  deriving (Show)

-- 指称语义
denote :: Expr -> Env -> Val
denote (Const n) _ = Int n
denote (Var x) env = env x
denote (Add e1 e2) env =
  case (denote e1 env, denote e2 env) of
    (Int v1, Int v2) -> Int (v1 + v2)
    _ -> Bottom
denote (Mul e1 e2) env =
  case (denote e1 env, denote e2 env) of
    (Int v1, Int v2) -> Int (v1 * v2)
    _ -> Bottom
denote (Eq e1 e2) env =
  case (denote e1 env, denote e2 env) of
    (Int v1, Int v2) -> Bool (v1 == v2)
    _ -> Bottom
denote (If e1 e2 e3) env =
  case denote e1 env of
    Bool True -> denote e2 env
    Bool False -> denote e3 env
    _ -> Bottom

-- 示例
example :: Expr
example = If (Eq (Var "x") (Const 0))
             (Const 1)
             (Mul (Var "x") (Const 2))

-- 求值
main :: IO ()
main = do
  let env = \x -> if x == "x" then Int 5 else Bottom
  print $ denote example env  -- 输出: Int 10
```

---

## 4. 命令式语言的指称语义

### 4.1 语法定义

```text
命令：
  c ∈ Comm ::= skip
             | x := e
             | c₁; c₂
             | if e then c₁ else c₂
             | while e do c
```

### 4.2 语义域

```text
状态空间：
  State = Var → Val

命令的意义：
  ⟦_⟧: Comm → (State → State_⊥)
  
  （命令是从状态到状态的偏函数）
```

### 4.3 语义定义

```text
⟦skip⟧σ = σ

⟦x := e⟧σ = σ[x ↦ ⟦e⟧σ]

⟦c₁; c₂⟧ = ⟦c₂⟧ ∘ ⟦c₁⟧
  （函数组合）

⟦if e then c₁ else c₂⟧σ =
  if ⟦e⟧σ = true then ⟦c₁⟧σ
  else if ⟦e⟧σ = false then ⟦c₂⟧σ
  else ⊥

⟦while e do c⟧ = fix(F)
  where F(f) = λσ. if ⟦e⟧σ = true then f(⟦c⟧σ)
                   else if ⟦e⟧σ = false then σ
                   else ⊥
```

**关键**：`while` 循环的语义通过不动点定义！

### 4.4 不动点展开示例

**程序**：

```text
while x > 0 do x := x - 1
```

**指称**：

```text
⟦while x > 0 do x := x - 1⟧ = fix(F)

F(f) = λσ. if σ(x) > 0 then f(σ[x ↦ σ(x) - 1]) else σ

逼近序列：
  f⁰ = λσ. ⊥  （不终止）
  
  f¹ = λσ. if σ(x) > 0 then ⊥ else σ
       （循环一次后不终止）
  
  f² = λσ. if σ(x) > 0 then
             (if σ(x) - 1 > 0 then ⊥ else σ[x ↦ 0])
           else σ
       （最多循环两次）
  
  ...
  
  fix(F) = ⊔ₙ fⁿ
         = λσ. if σ(x) ≥ 0 then σ[x ↦ 0] else ⊥
```

### 4.5 Lean4 形式化

```lean
import Mathlib.Data.Finmap
import Mathlib.Order.FixedPoints

-- 状态空间
def State := String → Int

-- 命令
inductive Comm where
  | skip : Comm
  | assign : String → (State → Int) → Comm
  | seq : Comm → Comm → Comm
  | ite : (State → Bool) → Comm → Comm → Comm
  | while : (State → Bool) → Comm → Comm

-- 语义函数类型
def StateFunc := State → Option State

-- 指称语义
def denoteComm : Comm → StateFunc
  | Comm.skip => fun σ => some σ
  | Comm.assign x e => fun σ => some (fun y => if y == x then e σ else σ y)
  | Comm.seq c1 c2 => fun σ => 
      match denoteComm c1 σ with
      | none => none
      | some σ' => denoteComm c2 σ'
  | Comm.ite b c1 c2 => fun σ =>
      if b σ then denoteComm c1 σ else denoteComm c2 σ
  | Comm.while b c => 
      -- 需要不动点（在 Lean 中需要通过 well-founded recursion 实现）
      sorry  -- 略（需要定义 CPO 和不动点组合子）

-- 示例：x := x + 1
def incX : Comm :=
  Comm.assign "x" (fun σ => σ "x" + 1)

#eval denoteComm incX (fun _ => 0)  -- some (fun _ => 1)
```

---

## 5. λ 演算的指称语义

### 5.1 无类型 λ 演算

**语法**：

```text
e ::= x          (变量)
    | λx. e      (抽象)
    | e₁ e₂      (应用)
```

**问题**：如何定义 `⟦λx. e⟧`？

**天真尝试**（失败）：

```text
⟦λx. e⟧ρ = 函数 f: Val → Val
  其中 f(v) = ⟦e⟧(ρ[x ↦ v])

问题：Val 是什么？
  - 如果 Val = Int ∪ Bool：太小（无法表示高阶函数）
  - 如果 Val = Int ∪ Bool ∪ (Val → Val)：循环定义！
```

**解决方案**：Scott 域（Domain Equation）

### 5.2 Scott 域构造

**目标**：找到 D 使得 `D ≅ D → D`（同构）

**步骤**：

```text
1. 构造 CPO 范畴的子范畴（具有有限元素的域）
2. 证明函数空间构造 D → E 是 CPO
3. 利用反射域理论（inverse limit）构造 D_∞ ≅ D_∞ → D_∞
```

**直觉**：

```text
D₀ = {⊥}
D₁ = {⊥} ∪ (D₀ → D₀) = {⊥, ⊥→⊥}
D₂ = {⊥} ∪ (D₁ → D₁) = ...
...
D_∞ = 反向极限(D₀, D₁, D₂, ...)
```

**结果**：

```text
定理（Scott 1972）：
  存在 CPO D_∞ 使得 D_∞ ≅ [D_∞ → D_∞]
  
  其中 [D → E] 是连续函数空间
```

### 5.3 语义定义

```text
环境：
  ρ ∈ Env = Var → D_∞

语义函数：
  ⟦_⟧: Expr → Env → D_∞

⟦x⟧ρ = ρ(x)

⟦λx. e⟧ρ = Λv ∈ D_∞. ⟦e⟧(ρ[x ↦ v])
  （Λ 表示连续函数抽象）

⟦e₁ e₂⟧ρ = (⟦e₁⟧ρ) · (⟦e₂⟧ρ)
  （· 表示函数应用）
```

**递归定义**：

```text
Y 组合子：Y = λf. (λx. f (x x)) (λx. f (x x))

指称：
  ⟦Y⟧ρ = fix(λf. f)
  
  满足：⟦Y f⟧ = ⟦f (Y f)⟧
```

---

## 6. 指称语义与操作语义的关系

### 6.1 充分性定理（Adequacy）

**定理**：

```text
对于表达式 e：
  ⟦e⟧ρ ≠ ⊥  ⇔  ∃v. e ⇓ v  （操作语义终止）

意义：
  - 指称语义的 ⊥ 对应操作语义的发散（divergence）
  - 指称语义的确定值对应操作语义的终止
```

**证明草图**：

```text
⇒ 方向：
  - 假设 ⟦e⟧ρ ≠ ⊥
  - 对 e 的结构归纳
  - 利用指称语义的组合性
  - 构造操作语义的推导树

⇐ 方向：
  - 假设 e ⇓ v
  - 对推导高度归纳
  - 证明 ⟦e⟧ρ = ⟦v⟧ρ
```

### 6.2 全抽象（Full Abstraction）

**定义**：

```text
指称语义是全抽象的 ⟺
  ⟦e₁⟧ = ⟦e₂⟧  ⇔  e₁ ≈ e₂  （上下文等价）

其中 e₁ ≈ e₂ 表示：
  ∀C[_]. C[e₁] ⇓ v ⇔ C[e₂] ⇓ v
```

**问题**：标准的 PCF 指称语义**不是**全抽象的！

**反例**（Plotkin 1977）：

```text
e₁ = λf. if (f λx.⊥ = ⊥) then ⊥ else 1
e₂ = λf. ⊥

指称等价：⟦e₁⟧ = ⟦e₂⟧ = ⊥
上下文不等价：存在 C 使得 C[e₁] ⇓ 1 但 C[e₂] ⇓ ⊥

原因：指称语义无法区分"顺序"（sequential）和"并行"（parallel or）
```

**解决方案**：

- **Game Semantics**（Abramsky, Hyland）：通过博弈论建模交互
- **Sequentiality**：添加顺序性约束

---

## 7. 应用：编译器优化

### 7.1 常量折叠（Constant Folding）

**规则**：

```text
⟦2 + 3⟧ = 5  ⇒  将表达式替换为常量 5
```

**正确性**：

```text
定理：⟦e⟧ = ⟦optimize(e)⟧
```

**实现**（Haskell）：

```haskell
optimize :: Expr -> Expr
optimize (Add (Const n1) (Const n2)) = Const (n1 + n2)
optimize (Mul (Const n1) (Const n2)) = Const (n1 * n2)
optimize (Add e1 e2) = Add (optimize e1) (optimize e2)
optimize (Mul e1 e2) = Mul (optimize e1) (optimize e2)
optimize e = e

-- 正确性定理（手动证明）
-- Theorem: forall e, denote e = denote (optimize e)
```

### 7.2 死代码消除（Dead Code Elimination）

**规则**：

```text
if true then e₁ else e₂  ⟹  e₁
if false then e₁ else e₂  ⟹  e₂
```

**指称等价性**：

```text
⟦if true then e₁ else e₂⟧ρ
  = (if true then ⟦e₁⟧ρ else ⟦e₂⟧ρ)
  = ⟦e₁⟧ρ

类似地：⟦if false then e₁ else e₂⟧ρ = ⟦e₂⟧ρ
```

### 7.3 公共子表达式消除（CSE）

**规则**：

```text
(x + y) * (x + y)  ⟹  let t = x + y in t * t
```

**正确性**：

```text
⟦(x + y) * (x + y)⟧ρ
  = ⟦x + y⟧ρ * ⟦x + y⟧ρ
  = let v = ⟦x + y⟧ρ in v * v
  = ⟦let t = x + y in t * t⟧ρ
```

---

## 8. 与国际课程对标

### 8.1 大学课程映射

| 课程 | 相关章节 |
|------|---------|
| **MIT 6.820 形式语义学** | Domain Theory, Denotational Semantics |
| **CMU 15-312 编程语言基础** | λ 演算指称语义 |
| **Stanford CS242 类型系统** | 指称语义与类型系统 |
| **Oxford 编程语言理论** | Scott 域，全抽象 |
| **EPFL CS-550 形式验证** | 充分性定理 |

### 8.2 教材对应

| 教材 | 相关章节 |
|------|---------|
| **Winskel "The Formal Semantics of Programming Languages"** | 完整教材对应 |
| **Pierce "Types and Programming Languages"** | Ch 5 (Untyped Lambda Calculus) |
| **Gunter "Semantics of Programming Languages"** | Domain Theory |
| **Abramsky & Jung "Domain Theory"** | 数学基础（§2） |

---

## 9. 工具与生态

### 9.1 定理证明器

| 工具 | 用途 | 示例 |
|------|------|------|
| **Coq** | 指称语义形式化 | §2.4, §4.5 |
| **Isabelle/HOL** | Domain Theory | HOLCF 库 |
| **Agda** | 依赖类型语义 | 高阶抽象语法 |

### 9.2 编程语言实现

| 语言 | 特点 | 对应概念 |
|------|------|----------|
| **Haskell** | 惰性求值 | 非严格语义 |
| **ML** | 严格求值 | 严格语义 |
| **Scheme** | 尾递归优化 | 不动点优化 |

---

## 10. 扩展阅读

### 10.1 学术论文

1. **Scott, D.** "Outline of a Mathematical Theory of Computation." 1970.
2. **Plotkin, G.** "LCF Considered as a Programming Language." 1977.
3. **Abramsky, S. & Jung, A.** "Domain Theory." Handbook, 1994.

### 10.2 在线资源

- **Denotational Semantics**：<https://en.wikipedia.org/wiki/Denotational_semantics>
- **Domain Theory**：<http://www.cs.bham.ac.uk/~axj/pub/papers/handy1.pdf>

### 10.3 本地项目引用

- **操作语义**：[./01.1_Operational_Semantics.md](./01.1_Operational_Semantics.md)
- **公理语义**：[./01.3_Axiomatic_Semantics.md](./01.3_Axiomatic_Semantics.md)
- **类型系统**：[./01.4_Type_Systems.md](./01.4_Type_Systems.md)

---

## 附录 A：Wikipedia 概念对照

| 概念 | Wikipedia 条目 | 本文章节 |
|------|---------------|----------|
| Denotational Semantics | <https://en.wikipedia.org/wiki/Denotational_semantics> | §1 |
| Domain Theory | <https://en.wikipedia.org/wiki/Domain_theory> | §2 |
| Complete Partial Order | <https://en.wikipedia.org/wiki/Complete_partial_order> | §2.3 |
| Fixed Point | <https://en.wikipedia.org/wiki/Fixed-point_combinator> | §2.4 |
| Lambda Calculus | <https://en.wikipedia.org/wiki/Lambda_calculus> | §5 |
| Full Abstraction | <https://en.wikipedia.org/wiki/Full_abstraction> | §6.2 |

---

**版本**：v1.0  
**最后更新**：2025-10-29  
**维护者**：FormalScience Project  
**许可**：MIT
