# å…¬ç†è¯­ä¹‰ï¼ˆAxiomatic Semanticsï¼‰

## ğŸ“š ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [1. Hoare é€»è¾‘æ¨ç†è§„åˆ™](#1-hoare-é€»è¾‘æ¨ç†è§„åˆ™)
  - [1.1 åŸºæœ¬è§„åˆ™](#11-åŸºæœ¬è§„åˆ™)
  - [1.2 å®Œæ•´ç¤ºä¾‹ï¼šéªŒè¯äº¤æ¢ç®—æ³•](#12-å®Œæ•´ç¤ºä¾‹éªŒè¯äº¤æ¢ç®—æ³•)
- [2. æœ€å¼±å‰ç½®æ¡ä»¶ï¼ˆWeakest Preconditionï¼‰](#2-æœ€å¼±å‰ç½®æ¡ä»¶weakest-precondition)
  - [2.1 å®šä¹‰](#21-å®šä¹‰)
  - [2.2 WP è®¡ç®—è§„åˆ™](#22-wp-è®¡ç®—è§„åˆ™)
  - [2.3 ç¤ºä¾‹ï¼šè®¡ç®—é˜¶ä¹˜çš„ WP](#23-ç¤ºä¾‹è®¡ç®—é˜¶ä¹˜çš„-wp)
- [3. æœ€å¼ºåç½®æ¡ä»¶ï¼ˆStrongest Postconditionï¼‰](#3-æœ€å¼ºåç½®æ¡ä»¶strongest-postcondition)
  - [3.1 å®šä¹‰](#31-å®šä¹‰)
  - [3.2 SP è®¡ç®—è§„åˆ™](#32-sp-è®¡ç®—è§„åˆ™)
  - [3.3 WP vs SP](#33-wp-vs-sp)
- [4. åˆ†ç¦»é€»è¾‘ï¼ˆSeparation Logicï¼‰](#4-åˆ†ç¦»é€»è¾‘separation-logic)
  - [4.1 åŠ¨æœº](#41-åŠ¨æœº)
  - [4.2 åˆ†ç¦»é€»è¾‘æ ¸å¿ƒæ¦‚å¿µ](#42-åˆ†ç¦»é€»è¾‘æ ¸å¿ƒæ¦‚å¿µ)
  - [4.3 åˆ†ç¦»é€»è¾‘è§„åˆ™](#43-åˆ†ç¦»é€»è¾‘è§„åˆ™)
  - [4.4 ç¤ºä¾‹ï¼šé“¾è¡¨åè½¬çš„éªŒè¯](#44-ç¤ºä¾‹é“¾è¡¨åè½¬çš„éªŒè¯)
- [5. ç»ˆæ­¢æ€§ä¸å˜ä½“ï¼ˆVariantï¼‰](#5-ç»ˆæ­¢æ€§ä¸å˜ä½“variant)
  - [5.1 å®Œå…¨æ­£ç¡®æ€§](#51-å®Œå…¨æ­£ç¡®æ€§)
  - [5.2 ç¤ºä¾‹ï¼šæ¬§å‡ é‡Œå¾—ç®—æ³•](#52-ç¤ºä¾‹æ¬§å‡ é‡Œå¾—ç®—æ³•)
- [6. å·¥å…·ä¸å®è·µ](#6-å·¥å…·ä¸å®è·µ)
  - [6.1 è‡ªåŠ¨åŒ–éªŒè¯å·¥å…·](#61-è‡ªåŠ¨åŒ–éªŒè¯å·¥å…·)
  - [6.2 Dafny ç¤ºä¾‹](#62-dafny-ç¤ºä¾‹)
  - [6.3 Why3 ç¤ºä¾‹](#63-why3-ç¤ºä¾‹)
- [7. å¤§å­¦è¯¾ç¨‹å¯¹åº”](#7-å¤§å­¦è¯¾ç¨‹å¯¹åº”)
- [8. æ•™æå¯¹åº”](#8-æ•™æå¯¹åº”)
- [9. æœ¬åœ°é¡¹ç›®å¼•ç”¨](#9-æœ¬åœ°é¡¹ç›®å¼•ç”¨)

---

## æ¦‚è¿°

**å…¬ç†è¯­ä¹‰**é€šè¿‡é€»è¾‘å…¬å¼æè¿°ç¨‹åºçš„è¡Œä¸ºï¼Œå›ç­”"**å¦‚ä½•è¯æ˜ç¨‹åºæ€§è´¨**"ï¼Œè€Œä¸å…³å¿ƒç¨‹åºå¦‚ä½•æ‰§è¡Œæˆ–è®¡ç®—ä»€ä¹ˆå€¼ã€‚å…¶æ ¸å¿ƒæ˜¯ **Hoare é€»è¾‘**ï¼ˆHoare Logicï¼‰ï¼Œç”¨ä¸‰å…ƒç»„ `{P} c {Q}` è¡¨ç¤ºï¼š

- **å‰ç½®æ¡ä»¶** `P`ï¼šç¨‹åº `c` æ‰§è¡Œå‰å¿…é¡»æ»¡è¶³çš„æ€§è´¨
- **ç¨‹åº** `c`ï¼šå¾…éªŒè¯çš„ä»£ç 
- **åç½®æ¡ä»¶** `Q`ï¼šç¨‹åº `c` æ‰§è¡Œåä¿è¯çš„æ€§è´¨

**å®šç†**ï¼ˆéƒ¨åˆ†æ­£ç¡®æ€§ Partial Correctnessï¼‰ï¼š

```text
{P} c {Q}  âŸº  âˆ€Ïƒ, P(Ïƒ) âˆ§ âŸ¦câŸ§Ïƒâ†“Ïƒ' â‡’ Q(Ïƒ')
```

**å®šç†**ï¼ˆå®Œå…¨æ­£ç¡®æ€§ Total Correctnessï¼‰ï¼š

```text
[P] c [Q]  âŸº  âˆ€Ïƒ, P(Ïƒ) â‡’ (âŸ¦câŸ§Ïƒâ†“Ïƒ' âˆ§ Q(Ïƒ'))
```

æœ¬æ–‡å°†ç³»ç»Ÿä»‹ç»ï¼š
    - 1. Hoare é€»è¾‘çš„æ¨ç†è§„åˆ™
    - 2. æœ€å¼±å‰ç½®æ¡ä»¶ï¼ˆWPï¼‰ä¸æœ€å¼ºåç½®æ¡ä»¶ï¼ˆSPï¼‰
    - 3. å¾ªç¯ä¸å˜å¼ä¸ç»ˆæ­¢æ€§è¯æ˜
    - 4. åˆ†ç¦»é€»è¾‘ï¼ˆSeparation Logicï¼‰æ‰©å±•
    - 5. Coq/Lean4 æœºå™¨éªŒè¯ç¤ºä¾‹

---

## 1. Hoare é€»è¾‘æ¨ç†è§„åˆ™

### 1.1 åŸºæœ¬è§„åˆ™

#### èµ‹å€¼è§„åˆ™ï¼ˆAssignmentï¼‰

```text
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{P[e/x]} x := e {P}
```

**è§£é‡Š**ï¼šè¦è¯æ˜èµ‹å€¼å `P` æˆç«‹ï¼Œéœ€åœ¨èµ‹å€¼å‰è¯æ˜ `P[e/x]`ï¼ˆå°† `P` ä¸­æ‰€æœ‰ `x` æ›¿æ¢ä¸º `e`ï¼‰ã€‚

**ç¤ºä¾‹**ï¼š

```text
æ±‚è¯ï¼š{x+1>0} y := x+1 {y>0}

è¯æ˜ï¼š
  åç½®æ¡ä»¶ï¼šy > 0
  èµ‹å€¼å‰ï¼š(y > 0)[x+1/y] = x+1 > 0
  å› æ­¤å‰ç½®æ¡ä»¶ä¸º x+1 > 0  âœ“
```

#### é¡ºåºç»„åˆè§„åˆ™ï¼ˆSequential Compositionï¼‰

```text
{P} câ‚ {Q}    {Q} câ‚‚ {R}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {P} câ‚; câ‚‚ {R}
```

**è§£é‡Š**ï¼šè‹¥ `câ‚` ä» `P` åˆ° `Q`ï¼Œ`câ‚‚` ä» `Q` åˆ° `R`ï¼Œåˆ™é¡ºåºæ‰§è¡Œä» `P` åˆ° `R`ã€‚

#### æ¡ä»¶è§„åˆ™ï¼ˆConditionalï¼‰

```text
{P âˆ§ b} câ‚ {Q}    {P âˆ§ Â¬b} câ‚‚ {Q}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {P} if b then câ‚ else câ‚‚ {Q}
```

**è§£é‡Š**ï¼šéœ€åˆ†åˆ«è¯æ˜ä¸¤ä¸ªåˆ†æ”¯åœ¨å„è‡ªæ¡ä»¶ä¸‹éƒ½èƒ½ä» `P` æ¨å‡º `Q`ã€‚

#### å¾ªç¯è§„åˆ™ï¼ˆWhile Loopï¼‰

```text
{I âˆ§ b} c {I}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{I} while b do c {I âˆ§ Â¬b}
```

**è§£é‡Š**ï¼š`I` æ˜¯**å¾ªç¯ä¸å˜å¼**ï¼ˆLoop Invariantï¼‰ï¼Œå¿…é¡»æ»¡è¶³ï¼š

1. åˆå§‹æ—¶ `I` æˆç«‹
2. æ¯æ¬¡è¿­ä»£ä¿æŒ `I`
3. å¾ªç¯ç»“æŸæ—¶ `I âˆ§ Â¬b` æˆç«‹

#### åæœè§„åˆ™ï¼ˆConsequenceï¼‰

```text
P' â‡’ P    {P} c {Q}    Q â‡’ Q'
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {P'} c {Q'}
```

**è§£é‡Š**ï¼šå¯ä»¥**åŠ å¼ºå‰ç½®æ¡ä»¶**æˆ–**å¼±åŒ–åç½®æ¡ä»¶**ã€‚

---

### 1.2 å®Œæ•´ç¤ºä¾‹ï¼šéªŒè¯äº¤æ¢ç®—æ³•

**é—®é¢˜**ï¼šéªŒè¯ä»¥ä¸‹ç¨‹åºäº¤æ¢ `x` å’Œ `y` çš„å€¼ã€‚

```c
// å‰ç½®ï¼šx=a âˆ§ y=b
tmp := x;
x := y;
y := tmp;
// åç½®ï¼šx=b âˆ§ y=a
```

**è¯æ˜**ï¼š

```text
{x=a âˆ§ y=b}
    tmp := x;
{tmp=a âˆ§ y=b}               // èµ‹å€¼è§„åˆ™
    x := y;
{tmp=a âˆ§ x=b}               // èµ‹å€¼è§„åˆ™
    y := tmp;
{x=b âˆ§ y=a}                 // èµ‹å€¼è§„åˆ™
```

**Coq å½¢å¼åŒ–**ï¼š

```coq
Require Import Coq.ZArith.ZArith.

Definition swap_spec (a b: Z) : Prop :=
  forall x y tmp,
    x = a -> y = b ->
    exists x' y',
      (* tmp := x *)
      tmp = x ->
      (* x := y *)
      x' = y ->
      (* y := tmp *)
      y' = tmp ->
      x' = b /\ y' = a.

Theorem swap_correct : forall a b, swap_spec a b.
Proof.
  intros a b x y tmp Hx Hy.
  exists b, a.
  intros Htmp Hx' Hy'.
  split.
  - (* x' = b *) rewrite Hx'. symmetry. exact Hy.
  - (* y' = a *) rewrite Hy'. rewrite Htmp. exact Hx.
Qed.
```

---

## 2. æœ€å¼±å‰ç½®æ¡ä»¶ï¼ˆWeakest Preconditionï¼‰

### 2.1 å®šä¹‰

**æœ€å¼±å‰ç½®æ¡ä»¶** `wp(c, Q)` æ˜¯ä½¿å¾— `{wp(c,Q)} c {Q}` æˆç«‹çš„**æœ€å®½æ¾**å‰ç½®æ¡ä»¶ã€‚

**å½¢å¼å®šä¹‰**ï¼š

```text
wp(c, Q) â‰œ Î»Ïƒ. âˆ€Ïƒ', âŸ¦câŸ§Ïƒâ†“Ïƒ' â‡’ Q(Ïƒ')
```

**æ€§è´¨**ï¼š

1. `{wp(c,Q)} c {Q}` æˆç«‹
2. è‹¥ `{P} c {Q}` æˆç«‹ï¼Œåˆ™ `P â‡’ wp(c,Q)`

### 2.2 WP è®¡ç®—è§„åˆ™

```text
wp(skip, Q)            = Q

wp(x := e, Q)          = Q[e/x]

wp(câ‚; câ‚‚, Q)          = wp(câ‚, wp(câ‚‚, Q))

wp(if b then câ‚ else câ‚‚, Q) = (b â‡’ wp(câ‚, Q)) âˆ§ (Â¬b â‡’ wp(câ‚‚, Q))

wp(while b do c, Q)    = I ä½¿å¾—ï¼š
                         I â‡’ (b â‡’ wp(c, I))
                         I â‡’ (Â¬b â‡’ Q)
```

### 2.3 ç¤ºä¾‹ï¼šè®¡ç®—é˜¶ä¹˜çš„ WP

```c
// åç½®æ¡ä»¶ï¼šr = n!
r := 1;
i := 0;
while i < n do
  i := i + 1;
  r := r * i
end
```

**å¾ªç¯ä¸å˜å¼**ï¼š

```text
I â‰œ r = i! âˆ§ 0 â‰¤ i â‰¤ n
```

**éªŒè¯**ï¼š

```text
åˆå§‹ï¼šr=1 âˆ§ i=0  â‡’  I[1/r][0/i] = 1 = 0! âˆ§ 0 â‰¤ 0 â‰¤ n  âœ“

ä¿æŒï¼š
{I âˆ§ i < n}
  i := i + 1;
  r := r * i;
{I}

å±•å¼€ï¼š
{r = i! âˆ§ 0 â‰¤ i < n}
  i := i + 1;
{r = (i-1)! âˆ§ 0 < i â‰¤ n}
  r := r * i;
{rÂ·i = i! âˆ§ 0 < i â‰¤ n}  â‡’  I  âœ“

ç»ˆæ­¢ï¼šI âˆ§ Â¬(i < n)  â‡’  r = n! âˆ§ i = n  âœ“
```

**Lean4 å½¢å¼åŒ–**ï¼š

```lean
import Mathlib.Data.Nat.Factorial

def factorial_loop (n : â„•) : â„• :=
  let rec loop (i r : â„•) : â„• :=
    if i < n then
      loop (i + 1) (r * (i + 1))
    else
      r
  loop 0 1

-- å¾ªç¯ä¸å˜å¼
def inv (n i r : â„•) : Prop :=
  r = i.factorial âˆ§ i â‰¤ n

theorem factorial_correct (n : â„•) :
  factorial_loop n = n.factorial := by
  unfold factorial_loop
  -- å½’çº³è¯æ˜çœç•¥ï¼ˆéœ€ç”¨ well-founded recursionï¼‰
  sorry
```

---

## 3. æœ€å¼ºåç½®æ¡ä»¶ï¼ˆStrongest Postconditionï¼‰

### 3.1 å®šä¹‰

**æœ€å¼ºåç½®æ¡ä»¶** `sp(P, c)` æ˜¯ä» `P` æ‰§è¡Œ `c` åèƒ½ä¿è¯çš„**æœ€å¼º**æ€§è´¨ã€‚

**å½¢å¼å®šä¹‰**ï¼š

```text
sp(P, c) â‰œ Î»Ïƒ'. âˆƒÏƒ, P(Ïƒ) âˆ§ âŸ¦câŸ§Ïƒâ†“Ïƒ'
```

### 3.2 SP è®¡ç®—è§„åˆ™

```text
sp(P, skip)            = P

sp(P, x := e)          = âˆƒv. P[v/x] âˆ§ x = e[v/x]

sp(P, câ‚; câ‚‚)          = sp(sp(P, câ‚), câ‚‚)

sp(P, if b then câ‚ else câ‚‚) = sp(P âˆ§ b, câ‚) âˆ¨ sp(P âˆ§ Â¬b, câ‚‚)
```

### 3.3 WP vs SP

| ç»´åº¦ | WPï¼ˆå‘åä¼ æ’­ï¼‰ | SPï¼ˆå‘å‰ä¼ æ’­ï¼‰ |
|------|----------------|----------------|
| **æ–¹å‘** | ä»åç½®æ¡ä»¶åæ¨å‰ç½® | ä»å‰ç½®æ¡ä»¶æ¨åç½® |
| **ç”¨é€”** | éªŒè¯ç»™å®šè§„èŒƒ | æ¨æ–­ç¨‹åºæ•ˆæœ |
| **å­˜åœ¨é‡è¯** | å…¨ç§° `âˆ€` | å­˜åœ¨ `âˆƒ` |
| **å·¥å…·æ”¯æŒ** | Why3, Dafny | Frama-C, Boogie |

---

## 4. åˆ†ç¦»é€»è¾‘ï¼ˆSeparation Logicï¼‰

### 4.1 åŠ¨æœº

ç»å…¸ Hoare é€»è¾‘éš¾ä»¥å¤„ç†**æŒ‡é’ˆ**å’Œ**å †æ“ä½œ**ï¼š

```c
{x â†¦ 1 âˆ§ y â†¦ 2}
*x := 3;
{x â†¦ 3 âˆ§ y â†¦ ?}  // y æ˜¯å¦è¢«ä¿®æ”¹ï¼Ÿ
```

**é—®é¢˜**ï¼šå½“ `x = y` æ—¶ï¼Œ`y` ä¹Ÿä¼šå˜æˆ 3ï¼ˆ**åˆ«åé—®é¢˜**ï¼‰ã€‚

### 4.2 åˆ†ç¦»é€»è¾‘æ ¸å¿ƒæ¦‚å¿µ

**åˆ†ç¦»åˆå–** `P * Q`ï¼š

```text
P * Q â‰œ å­˜åœ¨å †çš„åˆ†ç¦»åˆ†å‰² hâ‚, hâ‚‚ ä½¿å¾—ï¼š
        h = hâ‚ âŠ hâ‚‚  âˆ§  hâ‚ âŠ¨ P  âˆ§  hâ‚‚ âŠ¨ Q
```

**ç›´è§‰**ï¼š`P` å’Œ `Q` æè¿°**ä¸ç›¸äº¤çš„å †åŒºåŸŸ**ã€‚

**ç‚¹åˆ°æ–­è¨€** `x â†¦ v`ï¼š

```text
x â†¦ v â‰œ å †æ°å¥½åªæœ‰ä¸€ä¸ªå•å…ƒï¼Œåœ°å€ä¸º xï¼Œå€¼ä¸º v
```

### 4.3 åˆ†ç¦»é€»è¾‘è§„åˆ™

#### å¸§è§„åˆ™ï¼ˆFrame Ruleï¼‰

```text
{P} c {Q}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (c ä¸ä¿®æ”¹ R æ¶‰åŠçš„å˜é‡)
{P * R} c {Q * R}
```

**ç›´è§‰**ï¼šè‹¥ `c` åªä¿®æ”¹ `P` æè¿°çš„å †ï¼Œåˆ™ `R` æè¿°çš„å †ä¿æŒä¸å˜ã€‚

#### åˆ†é…è§„åˆ™

```text
{emp}
  x := alloc(n)
{x â†¦ - * ... * x+n-1 â†¦ -}
```

#### é‡Šæ”¾è§„åˆ™

```text
{x â†¦ -}
  free(x)
{emp}
```

### 4.4 ç¤ºä¾‹ï¼šé“¾è¡¨åè½¬çš„éªŒè¯

**ç¨‹åº**ï¼š

```c
Node* reverse(Node* head) {
  Node* prev = NULL;
  Node* curr = head;
  while (curr != NULL) {
    Node* next = curr->next;
    curr->next = prev;
    prev = curr;
    curr = next;
  }
  return prev;
}
```

**å¾ªç¯ä¸å˜å¼**ï¼ˆåˆ†ç¦»é€»è¾‘ï¼‰ï¼š

```text
I â‰œ list(prev, as) * list(curr, bs) âˆ§ as ++ bs = è¾“å…¥åˆ—è¡¨
```

å…¶ä¸­ `list(p, xs)` å®šä¹‰ä¸ºï¼š

```text
list(NULL, [])      = emp
list(p, x::xs)      = p â†¦ (x, next) * list(next, xs)
```

**Coq å½¢å¼åŒ–**ï¼ˆä½¿ç”¨ Iris æ¡†æ¶ï¼‰ï¼š

```coq
From iris.program_logic Require Import weakestpre.
From iris.heap_lang Require Import lang proofmode notation.

Definition list_rep (l : val) (xs : list val) : iProp Î£ :=
  match xs with
  | [] => âŒœl = NONEVâŒ
  | x :: xs' =>
    âˆƒ (next : val), l â†¦ (x, next) âˆ— list_rep next xs'
  end.

Lemma reverse_spec (l : val) (xs : list val) :
  {{{ list_rep l xs }}}
    reverse l
  {{{ v, RET v; list_rep v (rev xs) }}}.
Proof.
  (* éœ€ä½¿ç”¨ Iris é€»è¾‘çš„ wp_rec, wp_load, wp_store ç­–ç•¥ *)
  admit.
Qed.
```

---

## 5. ç»ˆæ­¢æ€§ä¸å˜ä½“ï¼ˆVariantï¼‰

### 5.1 å®Œå…¨æ­£ç¡®æ€§

**éƒ¨åˆ†æ­£ç¡®æ€§**ï¼šè‹¥ç¨‹åºç»ˆæ­¢ï¼Œåˆ™ç»“æœæ­£ç¡®ã€‚  
**å®Œå…¨æ­£ç¡®æ€§**ï¼šç¨‹åºå¿…å®šç»ˆæ­¢**ä¸”**ç»“æœæ­£ç¡®ã€‚

**å¾ªç¯çš„å®Œå…¨æ­£ç¡®æ€§è§„åˆ™**ï¼š

```text
{I âˆ§ b âˆ§ v=n} c {I âˆ§ v<n}    n âˆˆ â„•
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    [I] while b do c [I âˆ§ Â¬b]
```

å…¶ä¸­ `v` æ˜¯**å˜ä½“**ï¼ˆvariantï¼‰ï¼Œæ¯æ¬¡è¿­ä»£ä¸¥æ ¼é€’å‡ã€‚

### 5.2 ç¤ºä¾‹ï¼šæ¬§å‡ é‡Œå¾—ç®—æ³•

```c
// å‰ç½®ï¼ša > 0 âˆ§ b > 0
while b != 0 do
  tmp := b;
  b := a mod b;
  a := tmp;
end
// åç½®ï¼ša = gcd(è¾“å…¥çš„a, è¾“å…¥çš„b)
```

**å¾ªç¯ä¸å˜å¼**ï¼š

```text
I â‰œ gcd(a, b) = gcd(åˆå§‹a, åˆå§‹b)
```

**å˜ä½“**ï¼š

```text
v â‰œ b
```

**è¯æ˜**ï¼š

1. åˆå§‹æ—¶ `b > 0`ï¼Œå› æ­¤ `v > 0`
2. æ¯æ¬¡è¿­ä»£ `b' = a mod b < b`ï¼Œå› æ­¤ `v` ä¸¥æ ¼é€’å‡
3. ç”± Well-foundednessï¼Œå¾ªç¯å¿…å®šç»ˆæ­¢

**Coq å½¢å¼åŒ–**ï¼š

```coq
Require Import Coq.Arith.Wf_nat.

Fixpoint gcd (a b : nat) {struct b} : nat :=
  match b with
  | 0 => a
  | S b' => gcd b (a mod b)
  end.

Theorem gcd_terminates : forall a b, b > 0 -> exists n, gcd a b = n.
Proof.
  intros a b Hb.
  functional induction (gcd a b).
  - (* b = 0, çŸ›ç›¾ *) omega.
  - (* é€’å½’æ­¥ *) apply IHn.
Qed.
```

---

## 6. å·¥å…·ä¸å®è·µ

### 6.1 è‡ªåŠ¨åŒ–éªŒè¯å·¥å…·

| å·¥å…· | è¯­è¨€ | ç‰¹ç‚¹ | å®˜ç½‘ |
|------|------|------|------|
| **Dafny** | Dafny DSL | è‡ªåŠ¨æ¨æ–­å¾ªç¯ä¸å˜å¼ | <https://dafny.org> |
| **Why3** | WhyML | ç”Ÿæˆ Coq/Isabelle è¯æ˜ | <http://why3.lri.fr> |
| **Frama-C** | C | æ’ä»¶å¼ WP è®¡ç®— | <https://frama-c.com> |
| **Viper** | Viper IR | åˆ†ç¦»é€»è¾‘è‡ªåŠ¨åŒ– | <https://viper.ethz.ch> |
| **F*** | F* | ä¾èµ–ç±»å‹ + WP | <https://www.fstar-lang.org> |

### 6.2 Dafny ç¤ºä¾‹

```dafny
method Abs(x: int) returns (y: int)
  ensures y >= 0
  ensures y == x || y == -x
{
  if x < 0 {
    return -x;
  } else {
    return x;
  }
}
```

**éªŒè¯**ï¼š

```bash
dafny /compile:0 abs.dfy
# Dafny program verifier finished with 1 verified, 0 errors
```

### 6.3 Why3 ç¤ºä¾‹

```ocaml
let swap (x y: int) : (int, int)
  ensures { let (x', y') = result in x' = y /\ y' = x }
= (y, x)
```

**ç”Ÿæˆ Coq è¯æ˜**ï¼š

```bash
why3 prove -P coq swap.mlw
```

---

## 7. å¤§å­¦è¯¾ç¨‹å¯¹åº”

| è¯¾ç¨‹ | ç›¸å…³ç« èŠ‚ |
|------|----------|
| **CMU 15-414 Bug Catching** | Hoare é€»è¾‘ã€Dafny |
| **MIT 6.512 å½¢å¼éªŒè¯** | åˆ†ç¦»é€»è¾‘ã€Coq |
| **Stanford CS 357 è‡ªåŠ¨åŒ–æ¨ç†** | WPã€SMT æ±‚è§£å™¨ |
| **ETH ZÃ¼rich 252-0216-00L è½¯ä»¶éªŒè¯** | Viperã€åˆ†ç¦»é€»è¾‘ |
| **Cambridge Part II Hoare Logic** | å…¬ç†è¯­ä¹‰åŸºç¡€ |

---

## 8. æ•™æå¯¹åº”

| æ•™æ | ç›¸å…³ç« èŠ‚ |
|------|----------|
| **Software Foundations (Coq)** | Volume 2: Programming Language Foundations |
| **Concrete Semantics (Isabelle)** | Chapter 6: Hoare Logic |
| **Program Proofs (Dafny)** | K. Rustan M. Leino |
| **Separation Logic** | Reynolds, O'Hearn |

---

## 9. æœ¬åœ°é¡¹ç›®å¼•ç”¨

- `../AI_model_Perspective/07_AI_Philosophy/07.4_Correctness_Verification.md` - AI æ¨¡å‹çš„æ­£ç¡®æ€§éªŒè¯
- `../FormalLanguage_Perspective/04_Mathematical_Structures/04.3_Proof_Theory.md` - è¯æ˜è®ºåŸºç¡€
- `../Software_Perspective/01_Foundational_Theory/01.1_Semantic_Formal_Duality.md` - è¯­ä¹‰ä¸å½¢å¼çš„å¯¹å¶

---

## 10. æ€»ç»“

### æ ¸å¿ƒæ´å¯Ÿ

```text
å…¬ç†è¯­ä¹‰ = ç¨‹åºçš„é€»è¾‘è§„èŒƒ

å…³é”®å…¬å¼ï¼š
  {P} c {Q}  âŸº  âˆ€Ïƒ, P(Ïƒ) âˆ§ âŸ¦câŸ§Ïƒâ†“Ïƒ' â‡’ Q(Ïƒ')
  
æ ¸å¿ƒæŠ€æœ¯ï¼š
  - å¾ªç¯ä¸å˜å¼ï¼šæ•è·å¾ªç¯çš„æœ¬è´¨æ€§è´¨
  - WP/SPï¼šè‡ªåŠ¨æ¨æ–­å‰åç½®æ¡ä»¶
  - åˆ†ç¦»é€»è¾‘ï¼šè§£å†³åˆ«åé—®é¢˜
  - å˜ä½“ï¼šè¯æ˜ç»ˆæ­¢æ€§
```

### å·¥å…·é“¾æ¨è

```bash
# è‡ªåŠ¨éªŒè¯
dafny verify.dfy

# äº¤äº’å¼è¯æ˜
coq hoare_logic.v

# SMT åç«¯
why3 prove -P z3 spec.mlw
```

### å®æˆ˜å»ºè®®

1. **å°ç¨‹åº**ï¼šç”¨ Dafny å¿«é€ŸéªŒè¯
2. **å¤æ‚ç³»ç»Ÿ**ï¼šç”¨ Why3 ç”Ÿæˆ Coq è¯æ˜
3. **æŒ‡é’ˆæ“ä½œ**ï¼šç”¨ Viper çš„åˆ†ç¦»é€»è¾‘
4. **æ“ä½œç³»ç»Ÿ**ï¼šç”¨ Irisï¼ˆCoq æ¡†æ¶ï¼‰

---

## é™„å½• Aï¼šWikipedia æ¦‚å¿µå¯¹ç…§

| æ¦‚å¿µ | Wikipedia æ¡ç›® | æœ¬æ–‡ç« èŠ‚ |
|------|----------------|----------|
| Hoare Logic | <https://en.wikipedia.org/wiki/Hoare_logic> | Â§1 |
| Weakest Precondition | <https://en.wikipedia.org/wiki/Predicate_transformer_semantics> | Â§2 |
| Loop Invariant | <https://en.wikipedia.org/wiki/Loop_invariant> | Â§2.3 |
| Separation Logic | <https://en.wikipedia.org/wiki/Separation_logic> | Â§4 |
| Frame Rule | <https://en.wikipedia.org/wiki/Frame_rule> | Â§4.3 |

---

**ç‰ˆæœ¬**ï¼šv1.0  
**æœ€åæ›´æ–°**ï¼š2025-10-29  
**ç»´æŠ¤è€…**ï¼šFormalScience Project  
**è®¸å¯**ï¼šCC BY-SA 4.0
