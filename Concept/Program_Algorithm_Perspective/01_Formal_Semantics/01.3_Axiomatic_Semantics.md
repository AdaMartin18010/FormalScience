# 公理语义（Axiomatic Semantics）

## 概述

**公理语义**通过逻辑公式描述程序的行为，回答"**如何证明程序性质**"，而不关心程序如何执行或计算什么值。其核心是 **Hoare 逻辑**（Hoare Logic），用三元组 `{P} c {Q}` 表示：

- **前置条件** `P`：程序 `c` 执行前必须满足的性质
- **程序** `c`：待验证的代码
- **后置条件** `Q`：程序 `c` 执行后保证的性质

**定理**（部分正确性 Partial Correctness）：

```text
{P} c {Q}  ⟺  ∀σ, P(σ) ∧ ⟦c⟧σ↓σ' ⇒ Q(σ')
```

**定理**（完全正确性 Total Correctness）：

```text
[P] c [Q]  ⟺  ∀σ, P(σ) ⇒ (⟦c⟧σ↓σ' ∧ Q(σ'))
```

本文将系统介绍：
    - 1. Hoare 逻辑的推理规则
    - 2. 最弱前置条件（WP）与最强后置条件（SP）
    - 3. 循环不变式与终止性证明
    - 4. 分离逻辑（Separation Logic）扩展
    - 5. Coq/Lean4 机器验证示例

---

## 1. Hoare 逻辑推理规则

### 1.1 基本规则

#### 赋值规则（Assignment）

```text
─────────────────────
{P[e/x]} x := e {P}
```

**解释**：要证明赋值后 `P` 成立，需在赋值前证明 `P[e/x]`（将 `P` 中所有 `x` 替换为 `e`）。

**示例**：

```text
求证：{x+1>0} y := x+1 {y>0}

证明：
  后置条件：y > 0
  赋值前：(y > 0)[x+1/y] = x+1 > 0
  因此前置条件为 x+1 > 0  ✓
```

#### 顺序组合规则（Sequential Composition）

```text
{P} c₁ {Q}    {Q} c₂ {R}
───────────────────────────
    {P} c₁; c₂ {R}
```

**解释**：若 `c₁` 从 `P` 到 `Q`，`c₂` 从 `Q` 到 `R`，则顺序执行从 `P` 到 `R`。

#### 条件规则（Conditional）

```text
{P ∧ b} c₁ {Q}    {P ∧ ¬b} c₂ {Q}
───────────────────────────────────
  {P} if b then c₁ else c₂ {Q}
```

**解释**：需分别证明两个分支在各自条件下都能从 `P` 推出 `Q`。

#### 循环规则（While Loop）

```text
{I ∧ b} c {I}
────────────────────────
{I} while b do c {I ∧ ¬b}
```

**解释**：`I` 是**循环不变式**（Loop Invariant），必须满足：

1. 初始时 `I` 成立
2. 每次迭代保持 `I`
3. 循环结束时 `I ∧ ¬b` 成立

#### 后果规则（Consequence）

```text
P' ⇒ P    {P} c {Q}    Q ⇒ Q'
────────────────────────────────
        {P'} c {Q'}
```

**解释**：可以**加强前置条件**或**弱化后置条件**。

---

### 1.2 完整示例：验证交换算法

**问题**：验证以下程序交换 `x` 和 `y` 的值。

```c
// 前置：x=a ∧ y=b
tmp := x;
x := y;
y := tmp;
// 后置：x=b ∧ y=a
```

**证明**：

```text
{x=a ∧ y=b}
    tmp := x;
{tmp=a ∧ y=b}               // 赋值规则
    x := y;
{tmp=a ∧ x=b}               // 赋值规则
    y := tmp;
{x=b ∧ y=a}                 // 赋值规则
```

**Coq 形式化**：

```coq
Require Import Coq.ZArith.ZArith.

Definition swap_spec (a b: Z) : Prop :=
  forall x y tmp,
    x = a -> y = b ->
    exists x' y',
      (* tmp := x *)
      tmp = x ->
      (* x := y *)
      x' = y ->
      (* y := tmp *)
      y' = tmp ->
      x' = b /\ y' = a.

Theorem swap_correct : forall a b, swap_spec a b.
Proof.
  intros a b x y tmp Hx Hy.
  exists b, a.
  intros Htmp Hx' Hy'.
  split.
  - (* x' = b *) rewrite Hx'. symmetry. exact Hy.
  - (* y' = a *) rewrite Hy'. rewrite Htmp. exact Hx.
Qed.
```

---

## 2. 最弱前置条件（Weakest Precondition）

### 2.1 定义

**最弱前置条件** `wp(c, Q)` 是使得 `{wp(c,Q)} c {Q}` 成立的**最宽松**前置条件。

**形式定义**：

```text
wp(c, Q) ≜ λσ. ∀σ', ⟦c⟧σ↓σ' ⇒ Q(σ')
```

**性质**：

1. `{wp(c,Q)} c {Q}` 成立
2. 若 `{P} c {Q}` 成立，则 `P ⇒ wp(c,Q)`

### 2.2 WP 计算规则

```text
wp(skip, Q)            = Q

wp(x := e, Q)          = Q[e/x]

wp(c₁; c₂, Q)          = wp(c₁, wp(c₂, Q))

wp(if b then c₁ else c₂, Q) = (b ⇒ wp(c₁, Q)) ∧ (¬b ⇒ wp(c₂, Q))

wp(while b do c, Q)    = I 使得：
                         I ⇒ (b ⇒ wp(c, I))
                         I ⇒ (¬b ⇒ Q)
```

### 2.3 示例：计算阶乘的 WP

```c
// 后置条件：r = n!
r := 1;
i := 0;
while i < n do
  i := i + 1;
  r := r * i
end
```

**循环不变式**：

```text
I ≜ r = i! ∧ 0 ≤ i ≤ n
```

**验证**：

```text
初始：r=1 ∧ i=0  ⇒  I[1/r][0/i] = 1 = 0! ∧ 0 ≤ 0 ≤ n  ✓

保持：
{I ∧ i < n}
  i := i + 1;
  r := r * i;
{I}

展开：
{r = i! ∧ 0 ≤ i < n}
  i := i + 1;
{r = (i-1)! ∧ 0 < i ≤ n}
  r := r * i;
{r·i = i! ∧ 0 < i ≤ n}  ⇒  I  ✓

终止：I ∧ ¬(i < n)  ⇒  r = n! ∧ i = n  ✓
```

**Lean4 形式化**：

```lean
import Mathlib.Data.Nat.Factorial

def factorial_loop (n : ℕ) : ℕ :=
  let rec loop (i r : ℕ) : ℕ :=
    if i < n then
      loop (i + 1) (r * (i + 1))
    else
      r
  loop 0 1

-- 循环不变式
def inv (n i r : ℕ) : Prop :=
  r = i.factorial ∧ i ≤ n

theorem factorial_correct (n : ℕ) :
  factorial_loop n = n.factorial := by
  unfold factorial_loop
  -- 归纳证明省略（需用 well-founded recursion）
  sorry
```

---

## 3. 最强后置条件（Strongest Postcondition）

### 3.1 定义

**最强后置条件** `sp(P, c)` 是从 `P` 执行 `c` 后能保证的**最强**性质。

**形式定义**：

```text
sp(P, c) ≜ λσ'. ∃σ, P(σ) ∧ ⟦c⟧σ↓σ'
```

### 3.2 SP 计算规则

```text
sp(P, skip)            = P

sp(P, x := e)          = ∃v. P[v/x] ∧ x = e[v/x]

sp(P, c₁; c₂)          = sp(sp(P, c₁), c₂)

sp(P, if b then c₁ else c₂) = sp(P ∧ b, c₁) ∨ sp(P ∧ ¬b, c₂)
```

### 3.3 WP vs SP

| 维度 | WP（向后传播） | SP（向前传播） |
|------|----------------|----------------|
| **方向** | 从后置条件反推前置 | 从前置条件推后置 |
| **用途** | 验证给定规范 | 推断程序效果 |
| **存在量词** | 全称 `∀` | 存在 `∃` |
| **工具支持** | Why3, Dafny | Frama-C, Boogie |

---

## 4. 分离逻辑（Separation Logic）

### 4.1 动机

经典 Hoare 逻辑难以处理**指针**和**堆操作**：

```c
{x ↦ 1 ∧ y ↦ 2}
*x := 3;
{x ↦ 3 ∧ y ↦ ?}  // y 是否被修改？
```

**问题**：当 `x = y` 时，`y` 也会变成 3（**别名问题**）。

### 4.2 分离逻辑核心概念

**分离合取** `P * Q`：

```text
P * Q ≜ 存在堆的分离分割 h₁, h₂ 使得：
        h = h₁ ⊎ h₂  ∧  h₁ ⊨ P  ∧  h₂ ⊨ Q
```

**直觉**：`P` 和 `Q` 描述**不相交的堆区域**。

**点到断言** `x ↦ v`：

```text
x ↦ v ≜ 堆恰好只有一个单元，地址为 x，值为 v
```

### 4.3 分离逻辑规则

#### 帧规则（Frame Rule）

```text
{P} c {Q}
─────────────────────────  (c 不修改 R 涉及的变量)
{P * R} c {Q * R}
```

**直觉**：若 `c` 只修改 `P` 描述的堆，则 `R` 描述的堆保持不变。

#### 分配规则

```text
{emp}
  x := alloc(n)
{x ↦ - * ... * x+n-1 ↦ -}
```

#### 释放规则

```text
{x ↦ -}
  free(x)
{emp}
```

### 4.4 示例：链表反转的验证

**程序**：

```c
Node* reverse(Node* head) {
  Node* prev = NULL;
  Node* curr = head;
  while (curr != NULL) {
    Node* next = curr->next;
    curr->next = prev;
    prev = curr;
    curr = next;
  }
  return prev;
}
```

**循环不变式**（分离逻辑）：

```text
I ≜ list(prev, as) * list(curr, bs) ∧ as ++ bs = 输入列表
```

其中 `list(p, xs)` 定义为：

```text
list(NULL, [])      = emp
list(p, x::xs)      = p ↦ (x, next) * list(next, xs)
```

**Coq 形式化**（使用 Iris 框架）：

```coq
From iris.program_logic Require Import weakestpre.
From iris.heap_lang Require Import lang proofmode notation.

Definition list_rep (l : val) (xs : list val) : iProp Σ :=
  match xs with
  | [] => ⌜l = NONEV⌝
  | x :: xs' =>
    ∃ (next : val), l ↦ (x, next) ∗ list_rep next xs'
  end.

Lemma reverse_spec (l : val) (xs : list val) :
  {{{ list_rep l xs }}}
    reverse l
  {{{ v, RET v; list_rep v (rev xs) }}}.
Proof.
  (* 需使用 Iris 逻辑的 wp_rec, wp_load, wp_store 策略 *)
  admit.
Qed.
```

---

## 5. 终止性与变体（Variant）

### 5.1 完全正确性

**部分正确性**：若程序终止，则结果正确。  
**完全正确性**：程序必定终止**且**结果正确。

**循环的完全正确性规则**：

```text
{I ∧ b ∧ v=n} c {I ∧ v<n}    n ∈ ℕ
─────────────────────────────────────
    [I] while b do c [I ∧ ¬b]
```

其中 `v` 是**变体**（variant），每次迭代严格递减。

### 5.2 示例：欧几里得算法

```c
// 前置：a > 0 ∧ b > 0
while b != 0 do
  tmp := b;
  b := a mod b;
  a := tmp;
end
// 后置：a = gcd(输入的a, 输入的b)
```

**循环不变式**：

```text
I ≜ gcd(a, b) = gcd(初始a, 初始b)
```

**变体**：

```text
v ≜ b
```

**证明**：

1. 初始时 `b > 0`，因此 `v > 0`
2. 每次迭代 `b' = a mod b < b`，因此 `v` 严格递减
3. 由 Well-foundedness，循环必定终止

**Coq 形式化**：

```coq
Require Import Coq.Arith.Wf_nat.

Fixpoint gcd (a b : nat) {struct b} : nat :=
  match b with
  | 0 => a
  | S b' => gcd b (a mod b)
  end.

Theorem gcd_terminates : forall a b, b > 0 -> exists n, gcd a b = n.
Proof.
  intros a b Hb.
  functional induction (gcd a b).
  - (* b = 0, 矛盾 *) omega.
  - (* 递归步 *) apply IHn.
Qed.
```

---

## 6. 工具与实践

### 6.1 自动化验证工具

| 工具 | 语言 | 特点 | 官网 |
|------|------|------|------|
| **Dafny** | Dafny DSL | 自动推断循环不变式 | <https://dafny.org> |
| **Why3** | WhyML | 生成 Coq/Isabelle 证明 | <http://why3.lri.fr> |
| **Frama-C** | C | 插件式 WP 计算 | <https://frama-c.com> |
| **Viper** | Viper IR | 分离逻辑自动化 | <https://viper.ethz.ch> |
| **F*** | F* | 依赖类型 + WP | <https://www.fstar-lang.org> |

### 6.2 Dafny 示例

```dafny
method Abs(x: int) returns (y: int)
  ensures y >= 0
  ensures y == x || y == -x
{
  if x < 0 {
    return -x;
  } else {
    return x;
  }
}
```

**验证**：

```bash
dafny /compile:0 abs.dfy
# Dafny program verifier finished with 1 verified, 0 errors
```

### 6.3 Why3 示例

```ocaml
let swap (x y: int) : (int, int)
  ensures { let (x', y') = result in x' = y /\ y' = x }
= (y, x)
```

**生成 Coq 证明**：

```bash
why3 prove -P coq swap.mlw
```

---

## 7. 大学课程对应

| 课程 | 相关章节 |
|------|----------|
| **CMU 15-414 Bug Catching** | Hoare 逻辑、Dafny |
| **MIT 6.512 形式验证** | 分离逻辑、Coq |
| **Stanford CS 357 自动化推理** | WP、SMT 求解器 |
| **ETH Zürich 252-0216-00L 软件验证** | Viper、分离逻辑 |
| **Cambridge Part II Hoare Logic** | 公理语义基础 |

---

## 8. 教材对应

| 教材 | 相关章节 |
|------|----------|
| **Software Foundations (Coq)** | Volume 2: Programming Language Foundations |
| **Concrete Semantics (Isabelle)** | Chapter 6: Hoare Logic |
| **Program Proofs (Dafny)** | K. Rustan M. Leino |
| **Separation Logic** | Reynolds, O'Hearn |

---

## 9. 本地项目引用

- `../AI_model_Perspective/07_AI_Philosophy/07.4_Correctness_Verification.md` - AI 模型的正确性验证
- `../FormalLanguage_Perspective/04_Mathematical_Structures/04.3_Proof_Theory.md` - 证明论基础
- `../Software_Perspective/01_Foundational_Theory/01.1_Semantic_Formal_Duality.md` - 语义与形式的对偶

---

## 10. 总结

### 核心洞察

```text
公理语义 = 程序的逻辑规范

关键公式：
  {P} c {Q}  ⟺  ∀σ, P(σ) ∧ ⟦c⟧σ↓σ' ⇒ Q(σ')
  
核心技术：
  - 循环不变式：捕获循环的本质性质
  - WP/SP：自动推断前后置条件
  - 分离逻辑：解决别名问题
  - 变体：证明终止性
```

### 工具链推荐

```bash
# 自动验证
dafny verify.dfy

# 交互式证明
coq hoare_logic.v

# SMT 后端
why3 prove -P z3 spec.mlw
```

### 实战建议

1. **小程序**：用 Dafny 快速验证
2. **复杂系统**：用 Why3 生成 Coq 证明
3. **指针操作**：用 Viper 的分离逻辑
4. **操作系统**：用 Iris（Coq 框架）

---

## 附录 A：Wikipedia 概念对照

| 概念 | Wikipedia 条目 | 本文章节 |
|------|----------------|----------|
| Hoare Logic | <https://en.wikipedia.org/wiki/Hoare_logic> | §1 |
| Weakest Precondition | <https://en.wikipedia.org/wiki/Predicate_transformer_semantics> | §2 |
| Loop Invariant | <https://en.wikipedia.org/wiki/Loop_invariant> | §2.3 |
| Separation Logic | <https://en.wikipedia.org/wiki/Separation_logic> | §4 |
| Frame Rule | <https://en.wikipedia.org/wiki/Frame_rule> | §4.3 |

---

**版本**：v1.0  
**最后更新**：2025-10-29  
**维护者**：FormalScience Project  
**许可**：CC BY-SA 4.0
