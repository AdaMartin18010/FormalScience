# 操作语义 (Operational Semantics)

> **定义**: 通过定义程序如何逐步执行来给出程序的意义

---

## 📊 核心概念深度分析

<details>
<summary><b>⚙️🔬 点击展开：操作语义核心洞察</b></summary>

**终极洞察**: 操作语义=程序执行的数学模型。核心思想：通过形式化的转移规则精确定义每一步计算。两大流派：①小步语义（Small-step）：逐步执行，适合建模并发、中间状态、非确定性，类似图灵机的状态转移②大步语义（Big-step）：直接求值，适合建模函数式语言、归纳证明、类型安全性。形式化框架：转移系统⟨S,→,I,F⟩，状态空间+转移关系+初始/终止状态。成本语义扩展：附加资源向量κ=(时间,空间,能量,通信,...)，将抽象语义具体化为可测量的性能模型。工具支撑：K-Framework（可执行语义）、Coq（机器验证）、Lean4（依赖类型证明）。应用价值：①语言设计（Rust/Python/Golang语义定义）②编译器验证（CompCert）③安全分析（污点追踪）④性能预测（复杂度分析）。与其他语义的关系：操作语义描述"怎么算"，指称语义描述"算什么"，公理语义描述"为什么对"——三者通过充分性定理、全抽象、可靠性定理相互连接。关键：操作语义将程序从文本变为可推理的数学对象，是形式化方法的基石。

</details>

---

## 📋 目录

- [📊 核心概念深度分析](#核心概念深度分析)
- [📋 目录](#目录)
- [1. 概念定义](#1-概念定义)
  - [1.1 Wikipedia 定义](#11-wikipedia-定义)
  - [1.2 内涵与外延](#12-内涵与外延)
- [2. 形式化框架](#2-形式化框架)
  - [2.1 基本定义](#21-基本定义)
  - [2.2 转移系统 (Transition System)](#22-转移系统-transition-system)
- [3. 小步语义 vs 大步语义](#3-小步语义-vs-大步语义)
  - [3.1 小步语义 (Small-step Semantics)](#31-小步语义-small-step-semantics)
  - [3.2 大步语义 (Big-step Semantics)](#32-大步语义-big-step-semantics)
  - [3.3 对比表](#33-对比表)
- [4. 成本语义扩展](#4-成本语义扩展)
  - [4.1 定义](#41-定义)
  - [4.2 规则示例](#42-规则示例)
  - [4.3 K-Framework 中的成本语义](#43-k-framework-中的成本语义)
- [5. 实例：算术表达式](#5-实例算术表达式)
  - [5.1 语法](#51-语法)
  - [5.2 小步语义](#52-小步语义)
  - [5.3 示例推导](#53-示例推导)
- [6. 编程语言应用](#6-编程语言应用)
  - [6.1 Rust 的操作语义 (KRust)](#61-rust-的操作语义-krust)
  - [6.2 Python 的操作语义 (KPython)](#62-python-的操作语义-kpython)
  - [6.3 Golang 的操作语义 (缺失)](#63-golang-的操作语义-缺失)
- [7. 工具与验证](#7-工具与验证)
  - [7.1 K-Framework](#71-k-framework)
  - [7.2 Coq 中的操作语义](#72-coq-中的操作语义)
  - [7.3 Lean4 中的操作语义](#73-lean4-中的操作语义)
- [8. 与其他语义的关系](#8-与其他语义的关系)
  - [8.1 操作语义 vs 指称语义](#81-操作语义-vs-指称语义)
  - [8.2 操作语义 vs 公理语义](#82-操作语义-vs-公理语义)
- [9. 对标课程内容](#9-对标课程内容)
  - [9.1 CMU 15-312](#91-cmu-15-312)
  - [9.2 MIT 6.820](#92-mit-6820)
  - [9.3 Stanford CS 242](#93-stanford-cs-242)
- [10. 参考资源](#10-参考资源)
  - [10.1 经典教材](#101-经典教材)
  - [10.2 论文](#102-论文)
  - [10.3 在线资源](#103-在线资源)
- [11. 练习题](#11-练习题)
  - [练习 1: 添加减法](#练习-1-添加减法)
  - [练习 2: 成本语义](#练习-2-成本语义)
  - [练习 3: K-Framework 实现](#练习-3-k-framework-实现)
  - [练习 4: Coq 证明](#练习-4-coq-证明)
- [12. 小结](#12-小结)

---

## 1. 概念定义

### 1.1 Wikipedia 定义

根据 [Wikipedia: Operational semantics](https://en.wikipedia.org/wiki/Operational_semantics)：

> **Operational semantics** is a category of formal programming language semantics in which certain desired properties of a program, such as correctness, safety or security, are verified by constructing proofs from logical statements about its execution and procedures, rather than by attaching mathematical meanings to its terms.

**关键要素**：

- **状态 (State)**: 程序执行的当前配置
- **转移 (Transition)**: 从一个状态到下一个状态的规则
- **推导 (Derivation)**: 通过应用规则得到的执行序列

### 1.2 内涵与外延

**内涵** (Intension)：

- 程序的**执行过程**本身就是其意义
- 通过**转移规则**精确定义每一步如何执行
- 可以是**抽象机器**（如 SECD、CEK）或**重写系统**

**外延** (Extension)：

- **小步语义** (Small-step)：每次执行一个原子操作
- **大步语义** (Big-step / Natural semantics)：直接求值到最终结果
- **结构化操作语义** (SOS)：Plotkin 的经典框架
- **成本语义** (Cost semantics)：附加资源消耗的语义
- **并发语义**：进程代数（CCS、π-演算）

---

## 2. 形式化框架

### 2.1 基本定义

**语法域**：

```text
e ∈ Expr    表达式
v ∈ Value   值
σ ∈ State   状态（内存/环境）
```

**判断形式**：

```text
⟨e, σ⟩ → ⟨e', σ'⟩    (小步语义)
e ⇓ v                 (大步语义)
```

### 2.2 转移系统 (Transition System)

**定义**：一个转移系统是五元组 `⟨S, →, I, F, L⟩`

```text
S  : 状态集合
→  : 转移关系 (S × S)
I  : 初始状态集合 (I ⊆ S)
F  : 最终状态集合 (F ⊆ S)
L  : 标签函数 (可选)
```

**性质**：

- **确定性**: `∀s. s→s₁ ∧ s→s₂ ⇒ s₁=s₂`
- **终止性**: `∀s∈I. ∃n. s→ⁿf ∧ f∈F`
- **合流性**: 不同路径可以重新汇合

---

## 3. 小步语义 vs 大步语义

### 3.1 小步语义 (Small-step Semantics)

**定义**：每次执行**一个原子操作**

**示例**：算术表达式

```text
————————————————    (E-Const)
⟨n, σ⟩ → ⟨n, σ⟩

⟨e₁, σ⟩ → ⟨e₁', σ'⟩
————————————————————    (E-Add1)
⟨e₁+e₂, σ⟩ → ⟨e₁'+e₂, σ'⟩

⟨e₂, σ⟩ → ⟨e₂', σ'⟩
————————————————————    (E-Add2)
⟨n₁+e₂, σ⟩ → ⟨n₁+e₂', σ'⟩

————————————————————    (E-AddVal)
⟨n₁+n₂, σ⟩ → ⟨n, σ⟩
  where n = n₁ + n₂
```

**优点**：

- ✅ 可以建模**中间状态**（对调试/优化有用）
- ✅ 易于添加**并发**和**交互**
- ✅ 可以定义**非终止**程序的部分行为

**缺点**：

- ❌ 推导树可能很**长**
- ❌ 不如大步语义**直观**

### 3.2 大步语义 (Big-step Semantics)

**定义**：直接求值到**最终结果**

**示例**：算术表达式

```text
————————    (E-Const)
n ⇓ n

e₁ ⇓ n₁    e₂ ⇓ n₂
——————————————————    (E-Add)
e₁+e₂ ⇓ n
  where n = n₁ + n₂
```

**优点**：

- ✅ 推导树**紧凑**
- ✅ 与数学归纳法**自然对应**
- ✅ 易于证明**正确性**性质

**缺点**：

- ❌ 难以建模**非终止**程序
- ❌ 难以建模**并发**和**交互**
- ❌ 不显示**中间计算步骤**

### 3.3 对比表

| 维度 | 小步语义 | 大步语义 |
|------|----------|----------|
| **粒度** | 单步执行 | 直接求值 |
| **推导长度** | 长（= 执行步数） | 短（= 表达式深度） |
| **非终止** | 可建模（无限推导） | 难建模 |
| **并发** | 容易（交错规则） | 困难 |
| **中间状态** | 可见 | 不可见 |
| **证明风格** | 归纳于步数 | 归纳于结构 |

---

## 4. 成本语义扩展

### 4.1 定义

在标准操作语义上附加**资源计数器**：

```text
⟨e, σ, κ⟩ → ⟨e', σ', κ'⟩

其中 κ ∈ ℕ^d 是资源向量，例如：
  κ = (time, space, energy, comm, cache, ...)
```

### 4.2 规则示例

**加法的时间成本**：

```text
⟨e₁, σ, κ⟩ → ⟨e₁', σ', κ'⟩
————————————————————————————    (E-Add1-Cost)
⟨e₁+e₂, σ, κ⟩ → ⟨e₁'+e₂, σ', κ'⟩

⟨e₂, σ, κ⟩ → ⟨e₂', σ', κ'⟩
————————————————————————————    (E-Add2-Cost)
⟨n₁+e₂, σ, κ⟩ → ⟨n₁+e₂', σ', κ'⟩

————————————————————————————    (E-AddVal-Cost)
⟨n₁+n₂, σ, κ⟩ → ⟨n, σ, κ+1⟩
  where n = n₁ + n₂
```

**能量成本**（基于比特翻转）：

```text
bitflip(σ, σ') = 汉明距离(σ, σ')

————————————————————————————    (E-Store-Energy)
⟨x:=v, σ, ε⟩ → ⟨skip, σ[x↦v], ε+bitflip(σ,σ[x↦v])⟩
```

### 4.3 K-Framework 中的成本语义

```k
syntax Expr ::= Int | Expr "+" Expr

configuration
  <k> $PGM:Expr </k>
  <result> .K </result>
  <time> 0 </time>
  <energy> 0 </energy>

rule <k> I:Int => .K </k>
     <result> _ => I </result>

rule <k> E1:Expr + E2:Expr => E1 ~> E2 ~> add </k>

rule <k> add => .K </k>
     <result> I1:Int </result>
     <result> I2:Int </result>
     <result> _ => I1 +Int I2 </result>
     <time> T => T +Int 1 </time>
     <energy> E => E +Int popcount(I1 xor I2) </energy>
```

---

## 5. 实例：算术表达式

### 5.1 语法

```text
e ::= n                   (常量)
    | x                   (变量)
    | e₁ + e₂             (加法)
    | e₁ * e₂             (乘法)
    | let x = e₁ in e₂    (let 绑定)

v ::= n                   (值)

σ : Var → Val             (环境)
```

### 5.2 小步语义

```text
————————————————    (E-Const)
⟨n, σ⟩ → ⟨n, σ⟩

x ∈ dom(σ)
————————————————    (E-Var)
⟨x, σ⟩ → ⟨σ(x), σ⟩

⟨e₁, σ⟩ → ⟨e₁', σ'⟩
————————————————————    (E-Add1)
⟨e₁+e₂, σ⟩ → ⟨e₁'+e₂, σ'⟩

⟨e₂, σ⟩ → ⟨e₂', σ'⟩
————————————————————    (E-Add2)
⟨n+e₂, σ⟩ → ⟨n+e₂', σ'⟩

————————————————————    (E-AddVal)
⟨n₁+n₂, σ⟩ → ⟨n, σ⟩
  where n = n₁ + n₂

⟨e₁, σ⟩ → ⟨e₁', σ'⟩
——————————————————————————————————    (E-Let1)
⟨let x=e₁ in e₂, σ⟩ → ⟨let x=e₁' in e₂, σ'⟩

————————————————————————————————    (E-LetVal)
⟨let x=v in e, σ⟩ → ⟨e, σ[x↦v]⟩
```

### 5.3 示例推导

**程序**: `let x = 1+2 in x*x`

**推导**:

```text
⟨let x=1+2 in x*x, ∅⟩
  → ⟨let x=3 in x*x, ∅⟩              [E-Let1, E-AddVal]
  → ⟨x*x, [x↦3]⟩                      [E-LetVal]
  → ⟨3*x, [x↦3]⟩                      [E-Mult1, E-Var]
  → ⟨3*3, [x↦3]⟩                      [E-Mult2, E-Var]
  → ⟨9, [x↦3]⟩                        [E-MultVal]
```

**步数**: 5 步  
**成本**: `κ_time = 3` (两次算术，一次乘法)

---

## 6. 编程语言应用

### 6.1 Rust 的操作语义 (KRust)

**项目**: <https://github.com/rust-formal-methods/krust>

**覆盖特性**:

- ✅ 所有权 (Ownership)
- ✅ 借用 (Borrowing)
- ✅ 生命周期 (Lifetimes)
- ✅ 模式匹配
- ⚠️ Trait (部分)
- ❌ Unsafe (未完全覆盖)

**验证方法**: 191 测试用例与 rustc 行为对比

**规则示例** (借用检查):

```k
rule <k> &'a mut x => ptr(L) ... </k>
     <env> ... x |-> L ... </env>
     <heap> ... L |-> V:Val ... </heap>
     <borrows> BS => BS[L <- 'a] </borrows>
  requires notBorrowed(L, BS)
```

### 6.2 Python 的操作语义 (KPython)

**难点**:

- 动态类型
- 元编程 (`eval`, `exec`, `getattr`)
- 复杂对象模型（描述符、装饰器）

**部分规则**:

```k
rule <k> x = e => .K ... </k>
     <env> ENV => ENV[x <- L] </env>
     <store> S => S[L <- V] </store>
  where V = eval(e, ENV, S)
```

### 6.3 Golang 的操作语义 (缺失)

**现状**: 尚无系统性形式语义定义

**挑战**:

- Goroutine 并发模型
- Channel 通讯
- Select 语句的非确定性
- Interface 动态分发

**可能方法**:

- 用 π-演算建模 Goroutine
- 用进程代数建模 Channel
- 用随机语义建模 Select

---

## 7. 工具与验证

### 7.1 K-Framework

**官网**: <https://kframework.org/>

**特点**:

- 可执行语义：定义即解释器
- 自动生成符号执行器
- 支持模型检测（可达性）

**安装**:

```bash
brew install kframework
# 或
docker pull runtimeverification/kframework
```

**示例**:

```k
// simple-arithmetic.k
module SIMPLE-ARITHMETIC
  imports INT

  syntax Expr ::= Int
                | Expr "+" Expr   [strict]
                | Expr "*" Expr   [strict]

  rule I1:Int + I2:Int => I1 +Int I2
  rule I1:Int * I2:Int => I1 *Int I2
endmodule
```

**编译与运行**:

```bash
kompile simple-arithmetic.k
krun -cPGM="1 + 2 * 3"
# 输出: 7
```

### 7.2 Coq 中的操作语义

**Software Foundations** (Vol 1: Logical Foundations)

**示例**:

```coq
Inductive aexp : Type :=
  | ANum (n : nat)
  | APlus (a1 a2 : aexp)
  | AMult (a1 a2 : aexp).

Fixpoint aeval (a : aexp) : nat :=
  match a with
  | ANum n => n
  | APlus a1 a2 => (aeval a1) + (aeval a2)
  | AMult a1 a2 => (aeval a1) * (aeval a2)
  end.

(* 小步语义 *)
Reserved Notation " a '==>' a' " (at level 40).

Inductive astep : aexp -> aexp -> Prop :=
  | AS_Plus1 : forall a1 a1' a2,
      a1 ==> a1' ->
      APlus a1 a2 ==> APlus a1' a2
  | AS_Plus2 : forall n1 a2 a2',
      a2 ==> a2' ->
      APlus (ANum n1) a2 ==> APlus (ANum n1) a2'
  | AS_PlusVal : forall n1 n2,
      APlus (ANum n1) (ANum n2) ==> ANum (n1 + n2)
  | AS_Mult1 : forall a1 a1' a2,
      a1 ==> a1' ->
      AMult a1 a2 ==> AMult a1' a2
  | AS_Mult2 : forall n1 a2 a2',
      a2 ==> a2' ->
      AMult (ANum n1) a2 ==> AMult (ANum n1) a2'
  | AS_MultVal : forall n1 n2,
      AMult (ANum n1) (ANum n2) ==> ANum (n1 * n2)

where " a '==>' a' " := (astep a a').

(* 定理：小步语义是确定性的 *)
Theorem astep_deterministic : forall a a1 a2,
  a ==> a1 ->
  a ==> a2 ->
  a1 = a2.
Proof.
  intros a a1 a2 H1 H2.
  generalize dependent a2.
  induction H1; intros; inversion H2; subst; auto.
  - (* AS_Plus1 *)
    apply IHastep in H4. rewrite H4. reflexivity.
  - (* AS_Plus2 *)
    apply IHastep in H4. rewrite H4. reflexivity.
  - (* 其他情况类似 *)
Qed.
```

### 7.3 Lean4 中的操作语义

```lean
inductive Expr where
  | const : Nat → Expr
  | add : Expr → Expr → Expr
  | mult : Expr → Expr → Expr

inductive Step : Expr → Expr → Prop where
  | add_l : Step e1 e1' → Step (Expr.add e1 e2) (Expr.add e1' e2)
  | add_r : Step e2 e2' → Step (Expr.add (Expr.const n) e2) (Expr.add (Expr.const n) e2')
  | add_val : Step (Expr.add (Expr.const n1) (Expr.const n2)) (Expr.const (n1 + n2))
  | mult_l : Step e1 e1' → Step (Expr.mult e1 e2) (Expr.mult e1' e2)
  | mult_r : Step e2 e2' → Step (Expr.mult (Expr.const n) e2) (Expr.mult (Expr.const n) e2')
  | mult_val : Step (Expr.mult (Expr.const n1) (Expr.const n2)) (Expr.const (n1 * n2))

theorem step_deterministic : Step e e1 → Step e e2 → e1 = e2 := by
  intro h1 h2
  induction h1 with
  | add_l h_step ih =>
    cases h2
    · apply congrArg (Expr.add · _) (ih ‹_›)
    · contradiction
  | add_val =>
    cases h2
    · contradiction
    · rfl
  | -- 其他情况类似
```

---

## 8. 与其他语义的关系

### 8.1 操作语义 vs 指称语义

| 维度 | 操作语义 | 指称语义 |
|------|----------|----------|
| **核心思想** | 程序如何**执行** | 程序**表示**什么 |
| **数学对象** | 转移系统 | 数学函数/域 |
| **可执行性** | 直接可执行 | 需要实现 |
| **组合性** | 较弱 | 强 |
| **非终止** | 难建模（大步） | 易建模（⊥） |
| **并发** | 易建模 | 难建模 |

**定理**（充分性）:  
`e ⇓ v ⟺ ⟦e⟧ = v`  
操作语义与指称语义一致

### 8.2 操作语义 vs 公理语义

| 维度 | 操作语义 | 公理语义 |
|------|----------|----------|
| **描述对象** | 执行过程 | 程序性质 |
| **判断形式** | `e → e'` | `{P} c {Q}` |
| **可执行性** | 是 | 否 |
| **验证目标** | 语义定义 | 程序正确性 |

**定理**（可靠性 Soundness）:  
`⊢ {P} c {Q} ⇒ ⊨ {P} c {Q}`  
公理语义可靠当且仅当操作语义满足霍尔三元组

---

## 9. 对标课程内容

### 9.1 CMU 15-312

**课程**: Foundations of Programming Languages  
**链接**: <https://www.cs.cmu.edu/~15312/>

**涵盖主题**:

- Structural Operational Semantics (SOS)
- Type Safety (Progress + Preservation)
- Lambda Calculus
- System F

**对应章节**: 本文 + 01.4_Type_Systems.md

### 9.2 MIT 6.820

**课程**: Fundamentals of Program Analysis  
**链接**: <http://mit.edu/6.820/>

**涵盖主题**:

- Abstract Interpretation
- Data Flow Analysis
- Symbolic Execution

**对应章节**: 本文 + 05.4_Symbolic_Execution.md

### 9.3 Stanford CS 242

**课程**: Programming Languages  
**链接**: <http://cs242.stanford.edu/>

**涵盖主题**:

- Operational Semantics
- Type Systems
- Concurrency

**对应章节**: 本文 + 01.4_Type_Systems.md + 02.4_Concurrency_Patterns.md

---

## 10. 参考资源

### 10.1 经典教材

1. **The Formal Semantics of Programming Languages**  
   Glynn Winskel, MIT Press, 1993  
   ISBN: 978-0262731034

2. **Semantics with Applications**  
   Hanne Riis Nielson, Flemming Nielson  
   在线免费: <http://www.daimi.au.dk/~bra8130/Wiley_book/wiley.html>

3. **Programming Language Foundations** (Software Foundations Vol 2)  
   在线免费: <https://softwarefoundations.cis.upenn.edu/plf-current/index.html>

### 10.2 论文

1. **Structural Operational Semantics** (SOS)  
   Gordon D. Plotkin, 1981  
   <https://homepages.inf.ed.ac.uk/gdp/publications/sos_jlap.pdf>

2. **A Formal Semantics of Rust** (KRust)  
   Feng Wang et al., 2018  
   <https://arxiv.org/abs/1804.07608>

### 10.3 在线资源

- [Wikipedia: Operational semantics](https://en.wikipedia.org/wiki/Operational_semantics)
- [K-Framework Tutorial](https://kframework.org/k-distribution/pl-tutorial/)
- [Software Foundations (Coq)](https://softwarefoundations.cis.upenn.edu/)

---

## 11. 练习题

### 练习 1: 添加减法

扩展第 5 节的语言，添加减法运算符 `e₁ - e₂`。

1. 给出小步语义规则
2. 给出大步语义规则
3. 用 Coq 实现并证明确定性

### 练习 2: 成本语义

为第 5 节的语言添加**空间成本**，规则：

- 每个 `let` 绑定占用 1 单位空间
- 离开作用域时释放空间

写出带成本的语义规则。

### 练习 3: K-Framework 实现

用 K-Framework 实现一个带 `if-then-else` 的简单语言，并用 `krun` 验证以下程序：

```text
if 1 + 2 > 2 then 100 else 200
```

### 练习 4: Coq 证明

在 Coq 中证明：如果 `⟨e, σ⟩ →* ⟨n, σ'⟩` 且 `e` 中没有变量，则 `σ = σ'`。

---

## 12. 小结

操作语义通过定义**程序如何执行**来给出程序的意义，是形式化编程语言语义的核心方法之一。

**关键要点**:

- ✅ **小步语义**适合建模并发和中间状态
- ✅ **大步语义**适合建模求值和归纳证明
- ✅ **成本语义**扩展标准语义，附加资源消耗
- ✅ **K-Framework** 等工具可将语义定义直接执行

**下一步**:

- 阅读 [01.2_Denotational_Semantics.md](01.2_Denotational_Semantics.md) 了解指称语义
- 阅读 [01.3_Axiomatic_Semantics.md](01.3_Axiomatic_Semantics.md) 了解公理语义
- 阅读 [05.3_K_Framework.md](../05_Formal_Verification/05.3_K_Framework.md) 深入学习 K-Framework

---

**最后更新**: 2025-10-29  
**作者**: FormalScience Team  
**相关视角**: [形式语言视角](../../FormalLanguage_Perspective/), [信息论视角](../../Information_Theory_Perspective/)
