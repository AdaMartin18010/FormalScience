# 类型系统（Type Systems）

## 概述

**类型系统**是编程语言的**静态语义**，在编译期检查程序是否满足类型规则，从而**在运行前排除大量错误**。从形式化视角，类型系统是一套**推导规则**，回答"这个表达式有哪种类型？"

**核心定理**：

```text
Type Soundness（类型健全性）：
  Well-typed programs don't go wrong.
  
  形式化：
    ∀e τ, ∅ ⊢ e : τ  ⇒  ∃v, e ↓ v ∧ ∅ ⊢ v : τ
  
  （良类型程序要么归约到值，要么无限循环，但不会 stuck）
```

本文系统介绍：
    - 1. 简单类型系统（Simple Types）
    - 2. 依赖类型（Dependent Types）
    - 3. 线性类型（Linear Types）
    - 4. 定量类型（Quantitative Types）
    - 5. Affine 类型（Rust 的所有权）
    - 6. 渐进类型（Gradual Types）
    - 7. 类型系统的形式化验证

---

## 1. 简单类型 λ 演算（Simply Typed Lambda Calculus, STLC）

### 1.1 语法

```text
类型：
  τ ::= B          (基础类型：int, bool, ...)
      | τ₁ → τ₂    (函数类型)

项：
  e ::= x          (变量)
      | n          (常量)
      | λx:τ. e    (抽象)
      | e₁ e₂      (应用)
```

### 1.2 类型推导规则

#### 变量规则

```text
x:τ ∈ Γ
─────────  (Var)
Γ ⊢ x : τ
```

#### 抽象规则

```text
Γ, x:τ₁ ⊢ e : τ₂
──────────────────────  (Abs)
Γ ⊢ λx:τ₁. e : τ₁ → τ₂
```

#### 应用规则

```text
Γ ⊢ e₁ : τ₁ → τ₂    Γ ⊢ e₂ : τ₁
───────────────────────────────  (App)
      Γ ⊢ e₁ e₂ : τ₂
```

### 1.3 类型健全性证明

**定理**（Progress）：

```text
若 ∅ ⊢ e : τ，则 e 是值或 ∃e', e → e'
```

**定理**（Preservation）：

```text
若 Γ ⊢ e : τ 且 e → e'，则 Γ ⊢ e' : τ
```

**推论**（Soundness）：

```text
若 ∅ ⊢ e : τ，则 e 不会 stuck
```

**Coq 形式化**：

```coq
Require Import Coq.Lists.List.
Import ListNotations.

Inductive ty : Type :=
| TBool : ty
| TArrow : ty -> ty -> ty.

Inductive tm : Type :=
| tm_var : string -> tm
| tm_abs : string -> ty -> tm -> tm
| tm_app : tm -> tm -> tm
| tm_true : tm
| tm_false : tm
| tm_if : tm -> tm -> tm -> tm.

Reserved Notation "'[' x ':=' s ']' t" (at level 20).

Fixpoint subst (x : string) (s : tm) (t : tm) : tm :=
  match t with
  | tm_var y => if eqb_string x y then s else t
  | tm_abs y T t1 => tm_abs y T (if eqb_string x y then t1 else subst x s t1)
  | tm_app t1 t2 => tm_app (subst x s t1) (subst x s t2)
  | tm_true => tm_true
  | tm_false => tm_false
  | tm_if t1 t2 t3 => tm_if (subst x s t1) (subst x s t2) (subst x s t3)
  end
where "'[' x ':=' s ']' t" := (subst x s t).

Definition context := list (string * ty).

Reserved Notation "Gamma '⊢' t '∈' T" (at level 40).

Inductive has_type : context -> tm -> ty -> Prop :=
| T_Var : forall Gamma x T,
    In (x, T) Gamma ->
    Gamma ⊢ tm_var x ∈ T
| T_Abs : forall Gamma x T11 T12 t12,
    (x, T11) :: Gamma ⊢ t12 ∈ T12 ->
    Gamma ⊢ tm_abs x T11 t12 ∈ TArrow T11 T12
| T_App : forall T11 T12 Gamma t1 t2,
    Gamma ⊢ t1 ∈ TArrow T11 T12 ->
    Gamma ⊢ t2 ∈ T11 ->
    Gamma ⊢ tm_app t1 t2 ∈ T12
| T_True : forall Gamma,
    Gamma ⊢ tm_true ∈ TBool
| T_False : forall Gamma,
    Gamma ⊢ tm_false ∈ TBool
| T_If : forall t1 t2 t3 T Gamma,
    Gamma ⊢ t1 ∈ TBool ->
    Gamma ⊢ t2 ∈ T ->
    Gamma ⊢ t3 ∈ T ->
    Gamma ⊢ tm_if t1 t2 t3 ∈ T
where "Gamma '⊢' t '∈' T" := (has_type Gamma t T).

(* Progress 和 Preservation 定理的陈述省略，完整证明见 Software Foundations Vol 2 *)
```

---

## 2. 依赖类型（Dependent Types）

### 2.1 动机

**简单类型的局限**：无法表达"长度为 n 的向量"这样的性质。

**依赖类型的核心思想**：类型可以依赖于**值**。

### 2.2 形式定义

**依赖函数类型**（Π 类型）：

```text
Π (x:A). B(x)
```

**直觉**：函数的返回类型 `B` 依赖于输入值 `x`。

**示例**：

```text
replicate : Π (n:ℕ) (x:A). Vec A n
```

意义：给定长度 `n` 和元素 `x`，返回长度为 `n` 的向量。

### 2.3 Lean4 示例

```lean
import Mathlib.Data.Vector

-- 定义：长度为 n 的向量
def Vector (α : Type) (n : Nat) : Type := { l : List α // l.length = n }

-- 依赖函数：复制 n 次
def replicate (n : Nat) (x : α) : Vector α n :=
  ⟨List.replicate n x, List.length_replicate n x⟩

-- 证明：append 长度相加
theorem append_length (v1 : Vector α n) (v2 : Vector α m) :
  (v1.val ++ v2.val).length = n + m := by
  rw [List.length_append, v1.property, v2.property]

-- 依赖类型的 append
def append (v1 : Vector α n) (v2 : Vector α m) : Vector α (n + m) :=
  ⟨v1.val ++ v2.val, append_length v1 v2⟩
```

### 2.4 依赖类型的威力

| 性质 | 简单类型 | 依赖类型 |
|------|----------|----------|
| **数组越界** | 运行时检查 | 编译期排除 |
| **排序正确性** | 单元测试 | 类型保证 `sort : List A → Sorted A` |
| **网络协议** | 运行时断言 | Session Types |

---

## 3. 线性类型（Linear Types）

### 3.1 动机

**问题**：如何在类型系统中表达"资源必须恰好使用一次"？

**应用场景**：

- 文件句柄：打开后必须关闭，且只能关闭一次
- 密钥材料：使用后必须销毁
- 并发锁：获取后必须释放

### 3.2 形式定义

**线性函数类型**：

```text
A ⊸ B
```

**直觉**：函数必须**恰好使用一次**其参数。

**类型规则**：

```text
Γ, x:A ⊢ e : B
───────────────  （x 在 e 中恰好使用一次）
Γ ⊢ λx. e : A ⊸ B
```

### 3.3 示例：线性文件操作

```haskell
-- Haskell + Linear Types 扩展
{-# LANGUAGE LinearTypes #-}

data File = MkFile Handle

openFile :: FilePath -> IO (File %1)
readLine :: File %1 -> (String, File %1)
closeFile :: File %1 -> IO ()

-- 正确：文件恰好关闭一次
safeRead :: FilePath -> IO String
safeRead path = do
  file <- openFile path
  (line, file') <- readLine file
  closeFile file'
  return line

-- 错误：文件未关闭（编译期报错）
unsafeRead :: FilePath -> IO String
unsafeRead path = do
  file <- openFile path
  (line, _) <- readLine file
  return line  -- 类型错误：file 未使用
```

---

## 4. Affine 类型（Rust 的所有权）

### 4.1 Affine vs Linear

| 类型 | 使用次数 | Rust 例子 |
|------|----------|-----------|
| **线性（Linear）** | 恰好 1 次 | - |
| **Affine** | 至多 1 次 | `Box<T>`, `String` |
| **普通** | 任意次 | `i32`, `&T` |

**Affine 规则**：

```text
资源可以被使用 0 次（丢弃）或 1 次（转移），但不能复制
```

### 4.2 Rust 的所有权类型系统

**核心概念**：

```rust
// 所有权转移
let s1 = String::from("hello");
let s2 = s1;  // s1 失效（move）
// println!("{}", s1);  // 编译错误：use after move

// 借用（Borrow）
let s1 = String::from("hello");
let len = calculate_length(&s1);  // 不可变借用
println!("{}", s1);  // s1 仍有效

fn calculate_length(s: &String) -> usize {
    s.len()
}

// 可变借用（Mutable Borrow）
let mut s = String::from("hello");
change(&mut s);

fn change(s: &mut String) {
    s.push_str(", world");
}
```

**借用检查规则**：

```text
1. 任意时刻，要么只有一个可变引用，要么多个不可变引用
2. 引用必须有效（生命周期检查）
```

### 4.3 λRust 形式化（RustBelt）

**类型规则**：

```text
Γ ⊢ e : T    own(T)
──────────────────────  (Move)
Γ ⊢ move e : T

Γ ⊢ e : T    T : Copy
──────────────────────  (Copy)
Γ ⊢ e : T

Γ ⊢ e : T
──────────────────────  (Borrow)
Γ ⊢ &e : &T
```

**Coq 中的 Iris 逻辑**：

```coq
From iris.program_logic Require Import weakestpre.
From iris.heap_lang Require Import lang proofmode notation.

(* 所有权断言 *)
Definition own (l : loc) (v : val) : iProp Σ := l ↦ v.

(* 借用断言 *)
Definition borrowed (l : loc) (v : val) : iProp Σ :=
  ∃ q, l ↦{q} v.

(* 定理：所有权转移保持 *)
Lemma move_preserves_ownership (l : loc) (v : val) :
  {{{ own l v }}}
    move #l
  {{{ w, RET w; own w v }}}.
Proof.
  (* 使用 Iris 策略证明 *)
  admit.
Qed.
```

---

## 5. 定量类型（Quantitative Types）

### 5.1 动机

**问题**：如何在类型系统中跟踪**资源消耗**（时间、空间、能量、隐私预算）？

**定量类型**：将**成本**嵌入类型。

### 5.2 形式定义

**定量函数类型**：

```text
A →_ε B
```

**直觉**：函数从 `A` 到 `B`，同时消耗资源 `ε`（可以是时间、能量、差分隐私的 ε 等）。

### 5.3 示例：能量感知类型系统

```text
排序算法的类型：
  sort : List(n) →_{E(n)} Sorted(n)
  
  其中 E(n) = O(n log n)·能量单位
```

### 5.4 F* 示例（隐私预算）

```fsharp
// F* 中的差分隐私类型
type Privacy = float  // ε-预算

val laplace_noise : x:int -> epsilon:Privacy -> (y:int{DP epsilon x y})

val count_query : 
  db:list int -> epsilon:Privacy 
  -> (result:int{DP epsilon (List.length db) result})
let count_query db epsilon =
  let true_count = List.length db in
  let noise = laplace_noise true_count epsilon in
  true_count + noise
```

---

## 6. 渐进类型（Gradual Types）

### 6.1 动机

**问题**：如何在动态类型语言（如 Python）中逐步引入静态类型检查？

**渐进类型**：允许部分代码有类型注解，部分代码为动态类型 `?`。

### 6.2 类型规则

**一致性关系** `T ∼ S`：

```text
T ∼ T
? ∼ T
T ∼ ?
T₁ → T₂ ∼ S₁ → S₂  if  T₁ ∼ S₁ ∧ T₂ ∼ S₂
```

**子类型规则**：

```text
T <: ?
? <: T
```

### 6.3 Python 类型注解示例

```python
from typing import List, Optional

# 渐进类型：部分注解
def greet(name: str) -> str:
    return f"Hello, {name}"

# 动态类型：无注解
def process(data):
    return data.upper()

# 混合
def pipeline(items: List[str]) -> List:
    return [process(item) for item in items]
```

**MyPy 类型检查**：

```bash
$ mypy example.py
example.py:10: error: Returning Any from function declared to return "List[str]"
```

---

## 7. 类型系统对比

| 类型系统 | 表达力 | 检查时机 | 典型语言 | 证明负担 |
|----------|--------|----------|----------|----------|
| **简单类型** | 低 | 编译期 | Java, C# | 无 |
| **依赖类型** | 极高 | 编译期 | Coq, Agda, Lean | 高 |
| **线性类型** | 中 | 编译期 | Clean, Mercury | 低 |
| **Affine 类型** | 中 | 编译期 | Rust | 低 |
| **定量类型** | 高 | 编译期 | F*, Granule | 中 |
| **渐进类型** | 中 | 编译+运行 | TypeScript, Python | 低 |

---

## 8. 类型系统的形式化验证

### 8.1 验证目标

1. **类型健全性**（Soundness）：良类型程序不会 stuck
2. **完备性**（Completeness）：所有安全程序都可以类型化（不总成立）
3. **可判定性**（Decidability）：类型检查算法终止

### 8.2 Coq 中的类型健全性证明

```coq
(* Progress 定理 *)
Theorem progress : forall t T,
  [] ⊢ t ∈ T ->
  value t \/ exists t', t --> t'.
Proof.
  intros t T Ht.
  remember (@nil (string * ty)) as Gamma.
  induction Ht; subst; auto.
  (* ... 对每条类型规则归纳 ... *)
Qed.

(* Preservation 定理 *)
Theorem preservation : forall t t' T,
  [] ⊢ t ∈ T ->
  t --> t' ->
  [] ⊢ t' ∈ T.
Proof.
  intros t t' T HT HE.
  generalize dependent t'.
  induction HT; intros t' HE; inversion HE; subst; eauto.
  (* ... 对每条归约规则归纳 ... *)
Qed.

(* Soundness 推论 *)
Corollary soundness : forall t t' T,
  [] ⊢ t ∈ T ->
  t -->* t' ->
  ~(stuck t').
Proof.
  intros t t' T Hhas_type Hmulti.
  unfold stuck. intros [Hnot_val Hnot_step].
  induction Hmulti.
  - (* t = t' *) apply progress in Hhas_type. destruct Hhas_type; contradiction.
  - (* t --> t' -->* t'' *)
    apply preservation with (t':=y) in Hhas_type; auto.
Qed.
```

---

## 9. 大学课程对应

| 课程 | 相关章节 |
|------|----------|
| **CMU 15-312 Foundations of PL** | STLC, 类型健全性证明 |
| **Stanford CS 242** | 依赖类型、线性类型 |
| **EPFL CS-628 交互式定理证明** | Coq 中的类型系统形式化 |
| **ETH Zürich Advanced Topics in PL** | Affine 类型、Rust RustBelt |
| **Cambridge Part III Types** | Dependent Types, Homotopy Type Theory |

---

## 10. 教材对应

| 教材 | 相关章节 |
|------|----------|
| **Types and Programming Languages** (TAPL) | Ch 9-15 (STLC), Ch 30 (依赖类型) |
| **Practical Foundations for PL** (PFPL) | Part IV (Finite Data), Part IX (Dynamic Types) |
| **Software Foundations Vol 2** (Coq) | STLC 的完整形式化 |
| **Programming with Dependent Types** (Idris) | 依赖类型实践 |
| **Rust Belt Papers** | Affine 类型的 Iris 形式化 |

---

## 11. 本地项目引用

- `01.2_Denotational_Semantics.md` - 类型系统的指称语义
- `../02_Design_Patterns/02.1_GoF_Formal_Analysis.md` - 模式的类型刻画
- `../05_Formal_Verification/05.1_Coq_Introduction.md` - 类型系统的机器验证
- `../../FormalLanguage_Perspective/04_Mathematical_Structures/04.2_Type_Theory.md` - 类型论基础

---

## 12. 总结

### 核心洞察

```text
类型系统 = 静态程序分析 + 正确性保证

分类维度：
  ├─ 表达力：简单 → 依赖
  ├─ 资源管理：普通 → Affine → 线性
  ├─ 定量：无成本 → 定量类型
  └─ 灵活性：静态 → 渐进

设计权衡：
  更强类型 = 更多保证 + 更高证明负担
```

### 工具链推荐

| 需求 | 推荐工具 |
|------|----------|
| **学习依赖类型** | Lean4, Agda |
| **工业 Affine 类型** | Rust |
| **渐进类型** | TypeScript, Python+MyPy |
| **定量类型研究** | F*, Granule |
| **类型系统形式化** | Coq, Isabelle/HOL |

### 实战建议

1. **入门**：从 STLC 的 Coq 形式化开始（Software Foundations Vol 2）
2. **进阶**：学习 Rust，理解 Affine 类型的实际应用
3. **高级**：用 Lean4 实现依赖类型的数据结构
4. **前沿**：阅读 RustBelt 论文，理解 Iris 分离逻辑

---

## 附录 A：类型推导示例

### 示例：推导 `(λx:Bool. x) true`

```text
步骤 1：
  x:Bool ∈ {x:Bool}
  ──────────────────  (Var)
  {x:Bool} ⊢ x : Bool

步骤 2：
  {x:Bool} ⊢ x : Bool
  ─────────────────────────────  (Abs)
  {} ⊢ (λx:Bool. x) : Bool → Bool

步骤 3：
  ────────────────  (True)
  {} ⊢ true : Bool

步骤 4：
  {} ⊢ (λx:Bool. x) : Bool → Bool    {} ⊢ true : Bool
  ────────────────────────────────────────────────────  (App)
            {} ⊢ (λx:Bool. x) true : Bool
```

---

## 附录 B：Wikipedia 概念对照

| 概念 | Wikipedia 条目 | 本文章节 |
|------|----------------|----------|
| Type System | <https://en.wikipedia.org/wiki/Type_system> | §1 |
| Dependent Type | <https://en.wikipedia.org/wiki/Dependent_type> | §2 |
| Linear Type System | <https://en.wikipedia.org/wiki/Substructural_type_system> | §3 |
| Affine Type System | <https://en.wikipedia.org/wiki/Substructural_type_system#Affine_type_systems> | §4 |
| Gradual Typing | <https://en.wikipedia.org/wiki/Gradual_typing> | §6 |
| Type Safety | <https://en.wikipedia.org/wiki/Type_safety> | §8 |

---

**版本**：v1.0  
**最后更新**：2025-10-29  
**维护者**：FormalScience Project  
**许可**：CC BY-SA 4.0
