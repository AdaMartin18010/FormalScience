# ç±»å‹ç³»ç»Ÿï¼ˆType Systemsï¼‰

## ğŸ“Š æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ

<details>
<summary><b>ğŸ”’ğŸ”¬ ç‚¹å‡»å±•å¼€ï¼šç±»å‹ç³»ç»Ÿæ ¸å¿ƒæ´å¯Ÿ</b></summary>

**ç»ˆææ´å¯Ÿ**: ç±»å‹ç³»ç»Ÿ=é™æ€è¯­ä¹‰çš„å®ˆæŠ¤è€…ã€‚æ ¸å¿ƒå®šç†ï¼šType Soundnessï¼ˆç±»å‹å¥å…¨æ€§ï¼‰="Well-typed programs don't go wrong"=Progressï¼ˆèƒ½ç»§ç»­æ‰§è¡Œæˆ–å·²æ˜¯å€¼ï¼‰+Preservationï¼ˆæ‰§è¡Œä¿æŒç±»å‹ï¼‰ã€‚ç±»å‹ç³»ç»Ÿå±‚æ¬¡ï¼šâ‘ ç®€å•ç±»å‹Î»æ¼”ç®—ï¼ˆSTLCï¼‰ï¼šåŸºç¡€ç±»å‹+å‡½æ•°ç±»å‹â‘¡System Fï¼ˆå¤šæ€ï¼‰ï¼šâˆ€ç±»å‹ï¼Œæ³›å‹ç¼–ç¨‹åŸºç¡€â‘¢ä¾èµ–ç±»å‹ï¼ˆDependent Typesï¼‰ï¼šç±»å‹ä¾èµ–äºå€¼ï¼Œå¦‚Vec<n>ï¼ˆé•¿åº¦ä¸ºnçš„å‘é‡ï¼‰ï¼ŒCoq/Lean/Agdaçš„åŸºç¡€â‘£çº¿æ€§ç±»å‹ï¼ˆLinear Typesï¼‰ï¼šèµ„æºå¿…é¡»ä½¿ç”¨æ°å¥½ä¸€æ¬¡ï¼Œä¿è¯æ— å†…å­˜æ³„æ¼â‘¤Affineç±»å‹ï¼šèµ„æºæœ€å¤šä½¿ç”¨ä¸€æ¬¡ï¼ŒRustçš„æ‰€æœ‰æƒç³»ç»Ÿâ‘¥å®šé‡ç±»å‹ï¼ˆQuantitative Typesï¼‰ï¼šè·Ÿè¸ªèµ„æºä½¿ç”¨æ¬¡æ•°/èƒ½é‡/éšç§é¢„ç®—â‘¦æ¸è¿›ç±»å‹ï¼ˆGradual Typesï¼‰ï¼šé™æ€+åŠ¨æ€æ··åˆï¼ŒTypeScript/Pythonã€‚Curry-HowardåŒæ„ï¼šç±»å‹=å‘½é¢˜ï¼Œç¨‹åº=è¯æ˜ï¼Œæ‰§è¡Œ=åŒ–ç®€ã€‚åº”ç”¨ï¼šâ‘ Rustæ‰€æœ‰æƒç³»ç»Ÿï¼ˆRustBeltå½¢å¼åŒ–ï¼‰â‘¡Haskellç±»å‹ç±»â‘¢TypeScriptç»“æ„ç±»å‹â‘£Liquid Typesï¼ˆè°“è¯ç²¾åŒ–ï¼‰â‘¤Session Typesï¼ˆåè®®æ­£ç¡®æ€§ï¼‰ã€‚å½¢å¼åŒ–éªŒè¯ï¼šç”¨Coq/Leanè¯æ˜ç±»å‹ç³»ç»Ÿçš„å¥å…¨æ€§ã€å¼ºè§„èŒƒåŒ–ã€Church-Rosseræ€§è´¨ã€‚å…³é”®ï¼šç±»å‹ç³»ç»Ÿå°†å¤§é‡è¿è¡Œæ—¶é”™è¯¯æå‰åˆ°ç¼–è¯‘æœŸï¼Œæ˜¯ç°ä»£ç¼–ç¨‹è¯­è¨€å®‰å…¨æ€§çš„åŸºçŸ³ã€‚

</details>

---

## ğŸ“‹ ç›®å½•

- [ğŸ“Š æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ](#-æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ)
- [ğŸ“‹ ç›®å½•](#-ç›®å½•)
- [æ¦‚è¿°](#æ¦‚è¿°)
- [1. ç®€å•ç±»å‹ Î» æ¼”ç®—ï¼ˆSimply Typed Lambda Calculus, STLCï¼‰](#1-ç®€å•ç±»å‹--æ¼”ç®—simply-typed-lambda-calculus-stlc)
  - [1.1 è¯­æ³•](#11-è¯­æ³•)
  - [1.2 ç±»å‹æ¨å¯¼è§„åˆ™](#12-ç±»å‹æ¨å¯¼è§„åˆ™)
    - [å˜é‡è§„åˆ™](#å˜é‡è§„åˆ™)
    - [æŠ½è±¡è§„åˆ™](#æŠ½è±¡è§„åˆ™)
    - [åº”ç”¨è§„åˆ™](#åº”ç”¨è§„åˆ™)
  - [1.3 ç±»å‹å¥å…¨æ€§è¯æ˜](#13-ç±»å‹å¥å…¨æ€§è¯æ˜)
- [2. ä¾èµ–ç±»å‹ï¼ˆDependent Typesï¼‰](#2-ä¾èµ–ç±»å‹dependent-types)
  - [2.1 åŠ¨æœº](#21-åŠ¨æœº)
  - [2.2 å½¢å¼å®šä¹‰](#22-å½¢å¼å®šä¹‰)
  - [2.3 Lean4 ç¤ºä¾‹](#23-lean4-ç¤ºä¾‹)
  - [2.4 ä¾èµ–ç±»å‹çš„å¨åŠ›](#24-ä¾èµ–ç±»å‹çš„å¨åŠ›)
- [3. çº¿æ€§ç±»å‹ï¼ˆLinear Typesï¼‰](#3-çº¿æ€§ç±»å‹linear-types)
  - [3.1 åŠ¨æœº](#31-åŠ¨æœº)
  - [3.2 å½¢å¼å®šä¹‰](#32-å½¢å¼å®šä¹‰)
  - [3.3 ç¤ºä¾‹ï¼šçº¿æ€§æ–‡ä»¶æ“ä½œ](#33-ç¤ºä¾‹çº¿æ€§æ–‡ä»¶æ“ä½œ)
- [4. Affine ç±»å‹ï¼ˆRust çš„æ‰€æœ‰æƒï¼‰](#4-affine-ç±»å‹rust-çš„æ‰€æœ‰æƒ)
  - [4.1 Affine vs Linear](#41-affine-vs-linear)
  - [4.2 Rust çš„æ‰€æœ‰æƒç±»å‹ç³»ç»Ÿ](#42-rust-çš„æ‰€æœ‰æƒç±»å‹ç³»ç»Ÿ)
  - [4.3 Î»Rust å½¢å¼åŒ–ï¼ˆRustBeltï¼‰](#43-rust-å½¢å¼åŒ–rustbelt)
- [5. å®šé‡ç±»å‹ï¼ˆQuantitative Typesï¼‰](#5-å®šé‡ç±»å‹quantitative-types)
  - [5.1 åŠ¨æœº](#51-åŠ¨æœº)
  - [5.2 å½¢å¼å®šä¹‰](#52-å½¢å¼å®šä¹‰)
  - [5.3 ç¤ºä¾‹ï¼šèƒ½é‡æ„ŸçŸ¥ç±»å‹ç³»ç»Ÿ](#53-ç¤ºä¾‹èƒ½é‡æ„ŸçŸ¥ç±»å‹ç³»ç»Ÿ)
  - [5.4 F* ç¤ºä¾‹ï¼ˆéšç§é¢„ç®—ï¼‰](#54-f-ç¤ºä¾‹éšç§é¢„ç®—)
- [6. æ¸è¿›ç±»å‹ï¼ˆGradual Typesï¼‰](#6-æ¸è¿›ç±»å‹gradual-types)
  - [6.1 åŠ¨æœº](#61-åŠ¨æœº)
  - [6.2 ç±»å‹è§„åˆ™](#62-ç±»å‹è§„åˆ™)
  - [6.3 Python ç±»å‹æ³¨è§£ç¤ºä¾‹](#63-python-ç±»å‹æ³¨è§£ç¤ºä¾‹)
- [7. ç±»å‹ç³»ç»Ÿå¯¹æ¯”](#7-ç±»å‹ç³»ç»Ÿå¯¹æ¯”)
- [8. ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–éªŒè¯](#8-ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–éªŒè¯)
  - [8.1 éªŒè¯ç›®æ ‡](#81-éªŒè¯ç›®æ ‡)
  - [8.2 Coq ä¸­çš„ç±»å‹å¥å…¨æ€§è¯æ˜](#82-coq-ä¸­çš„ç±»å‹å¥å…¨æ€§è¯æ˜)
- [9. å¤§å­¦è¯¾ç¨‹å¯¹åº”](#9-å¤§å­¦è¯¾ç¨‹å¯¹åº”)
- [10. æ•™æå¯¹åº”](#10-æ•™æå¯¹åº”)
- [11. æœ¬åœ°é¡¹ç›®å¼•ç”¨](#11-æœ¬åœ°é¡¹ç›®å¼•ç”¨)
- [12. æ€»ç»“](#12-æ€»ç»“)
  - [æ ¸å¿ƒæ´å¯Ÿ](#æ ¸å¿ƒæ´å¯Ÿ)
  - [å·¥å…·é“¾æ¨è](#å·¥å…·é“¾æ¨è)
  - [å®æˆ˜å»ºè®®](#å®æˆ˜å»ºè®®)
- [é™„å½• Aï¼šç±»å‹æ¨å¯¼ç¤ºä¾‹](#é™„å½•-aç±»å‹æ¨å¯¼ç¤ºä¾‹)
  - [ç¤ºä¾‹ï¼šæ¨å¯¼ `(Î»x:Bool. x) true`](#ç¤ºä¾‹æ¨å¯¼-xbool-x-true)
- [é™„å½• Bï¼šWikipedia æ¦‚å¿µå¯¹ç…§](#é™„å½•-bwikipedia-æ¦‚å¿µå¯¹ç…§)

---

## æ¦‚è¿°

**ç±»å‹ç³»ç»Ÿ**æ˜¯ç¼–ç¨‹è¯­è¨€çš„**é™æ€è¯­ä¹‰**ï¼Œåœ¨ç¼–è¯‘æœŸæ£€æŸ¥ç¨‹åºæ˜¯å¦æ»¡è¶³ç±»å‹è§„åˆ™ï¼Œä»è€Œ**åœ¨è¿è¡Œå‰æ’é™¤å¤§é‡é”™è¯¯**ã€‚ä»å½¢å¼åŒ–è§†è§’ï¼Œç±»å‹ç³»ç»Ÿæ˜¯ä¸€å¥—**æ¨å¯¼è§„åˆ™**ï¼Œå›ç­”"è¿™ä¸ªè¡¨è¾¾å¼æœ‰å“ªç§ç±»å‹ï¼Ÿ"

**æ ¸å¿ƒå®šç†**ï¼š

```text
Type Soundnessï¼ˆç±»å‹å¥å…¨æ€§ï¼‰ï¼š
  Well-typed programs don't go wrong.
  
  å½¢å¼åŒ–ï¼š
    âˆ€e Ï„, âˆ… âŠ¢ e : Ï„  â‡’  âˆƒv, e â†“ v âˆ§ âˆ… âŠ¢ v : Ï„
  
  ï¼ˆè‰¯ç±»å‹ç¨‹åºè¦ä¹ˆå½’çº¦åˆ°å€¼ï¼Œè¦ä¹ˆæ— é™å¾ªç¯ï¼Œä½†ä¸ä¼š stuckï¼‰
```

æœ¬æ–‡ç³»ç»Ÿä»‹ç»ï¼š
    - 1. ç®€å•ç±»å‹ç³»ç»Ÿï¼ˆSimple Typesï¼‰
    - 2. ä¾èµ–ç±»å‹ï¼ˆDependent Typesï¼‰
    - 3. çº¿æ€§ç±»å‹ï¼ˆLinear Typesï¼‰
    - 4. å®šé‡ç±»å‹ï¼ˆQuantitative Typesï¼‰
    - 5. Affine ç±»å‹ï¼ˆRust çš„æ‰€æœ‰æƒï¼‰
    - 6. æ¸è¿›ç±»å‹ï¼ˆGradual Typesï¼‰
    - 7. ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–éªŒè¯

---

## 1. ç®€å•ç±»å‹ Î» æ¼”ç®—ï¼ˆSimply Typed Lambda Calculus, STLCï¼‰

### 1.1 è¯­æ³•

```text
ç±»å‹ï¼š
  Ï„ ::= B          (åŸºç¡€ç±»å‹ï¼šint, bool, ...)
      | Ï„â‚ â†’ Ï„â‚‚    (å‡½æ•°ç±»å‹)

é¡¹ï¼š
  e ::= x          (å˜é‡)
      | n          (å¸¸é‡)
      | Î»x:Ï„. e    (æŠ½è±¡)
      | eâ‚ eâ‚‚      (åº”ç”¨)
```

### 1.2 ç±»å‹æ¨å¯¼è§„åˆ™

#### å˜é‡è§„åˆ™

```text
x:Ï„ âˆˆ Î“
â”€â”€â”€â”€â”€â”€â”€â”€â”€  (Var)
Î“ âŠ¢ x : Ï„
```

#### æŠ½è±¡è§„åˆ™

```text
Î“, x:Ï„â‚ âŠ¢ e : Ï„â‚‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (Abs)
Î“ âŠ¢ Î»x:Ï„â‚. e : Ï„â‚ â†’ Ï„â‚‚
```

#### åº”ç”¨è§„åˆ™

```text
Î“ âŠ¢ eâ‚ : Ï„â‚ â†’ Ï„â‚‚    Î“ âŠ¢ eâ‚‚ : Ï„â‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (App)
      Î“ âŠ¢ eâ‚ eâ‚‚ : Ï„â‚‚
```

### 1.3 ç±»å‹å¥å…¨æ€§è¯æ˜

**å®šç†**ï¼ˆProgressï¼‰ï¼š

```text
è‹¥ âˆ… âŠ¢ e : Ï„ï¼Œåˆ™ e æ˜¯å€¼æˆ– âˆƒe', e â†’ e'
```

**å®šç†**ï¼ˆPreservationï¼‰ï¼š

```text
è‹¥ Î“ âŠ¢ e : Ï„ ä¸” e â†’ e'ï¼Œåˆ™ Î“ âŠ¢ e' : Ï„
```

**æ¨è®º**ï¼ˆSoundnessï¼‰ï¼š

```text
è‹¥ âˆ… âŠ¢ e : Ï„ï¼Œåˆ™ e ä¸ä¼š stuck
```

**Coq å½¢å¼åŒ–**ï¼š

```coq
Require Import Coq.Lists.List.
Import ListNotations.

Inductive ty : Type :=
| TBool : ty
| TArrow : ty -> ty -> ty.

Inductive tm : Type :=
| tm_var : string -> tm
| tm_abs : string -> ty -> tm -> tm
| tm_app : tm -> tm -> tm
| tm_true : tm
| tm_false : tm
| tm_if : tm -> tm -> tm -> tm.

Reserved Notation "'[' x ':=' s ']' t" (at level 20).

Fixpoint subst (x : string) (s : tm) (t : tm) : tm :=
  match t with
  | tm_var y => if eqb_string x y then s else t
  | tm_abs y T t1 => tm_abs y T (if eqb_string x y then t1 else subst x s t1)
  | tm_app t1 t2 => tm_app (subst x s t1) (subst x s t2)
  | tm_true => tm_true
  | tm_false => tm_false
  | tm_if t1 t2 t3 => tm_if (subst x s t1) (subst x s t2) (subst x s t3)
  end
where "'[' x ':=' s ']' t" := (subst x s t).

Definition context := list (string * ty).

Reserved Notation "Gamma 'âŠ¢' t 'âˆˆ' T" (at level 40).

Inductive has_type : context -> tm -> ty -> Prop :=
| T_Var : forall Gamma x T,
    In (x, T) Gamma ->
    Gamma âŠ¢ tm_var x âˆˆ T
| T_Abs : forall Gamma x T11 T12 t12,
    (x, T11) :: Gamma âŠ¢ t12 âˆˆ T12 ->
    Gamma âŠ¢ tm_abs x T11 t12 âˆˆ TArrow T11 T12
| T_App : forall T11 T12 Gamma t1 t2,
    Gamma âŠ¢ t1 âˆˆ TArrow T11 T12 ->
    Gamma âŠ¢ t2 âˆˆ T11 ->
    Gamma âŠ¢ tm_app t1 t2 âˆˆ T12
| T_True : forall Gamma,
    Gamma âŠ¢ tm_true âˆˆ TBool
| T_False : forall Gamma,
    Gamma âŠ¢ tm_false âˆˆ TBool
| T_If : forall t1 t2 t3 T Gamma,
    Gamma âŠ¢ t1 âˆˆ TBool ->
    Gamma âŠ¢ t2 âˆˆ T ->
    Gamma âŠ¢ t3 âˆˆ T ->
    Gamma âŠ¢ tm_if t1 t2 t3 âˆˆ T
where "Gamma 'âŠ¢' t 'âˆˆ' T" := (has_type Gamma t T).

(* Progress å’Œ Preservation å®šç†çš„é™ˆè¿°çœç•¥ï¼Œå®Œæ•´è¯æ˜è§ Software Foundations Vol 2 *)
```

---

## 2. ä¾èµ–ç±»å‹ï¼ˆDependent Typesï¼‰

### 2.1 åŠ¨æœº

**ç®€å•ç±»å‹çš„å±€é™**ï¼šæ— æ³•è¡¨è¾¾"é•¿åº¦ä¸º n çš„å‘é‡"è¿™æ ·çš„æ€§è´¨ã€‚

**ä¾èµ–ç±»å‹çš„æ ¸å¿ƒæ€æƒ³**ï¼šç±»å‹å¯ä»¥ä¾èµ–äº**å€¼**ã€‚

### 2.2 å½¢å¼å®šä¹‰

**ä¾èµ–å‡½æ•°ç±»å‹**ï¼ˆÎ  ç±»å‹ï¼‰ï¼š

```text
Î  (x:A). B(x)
```

**ç›´è§‰**ï¼šå‡½æ•°çš„è¿”å›ç±»å‹ `B` ä¾èµ–äºè¾“å…¥å€¼ `x`ã€‚

**ç¤ºä¾‹**ï¼š

```text
replicate : Î  (n:â„•) (x:A). Vec A n
```

æ„ä¹‰ï¼šç»™å®šé•¿åº¦ `n` å’Œå…ƒç´  `x`ï¼Œè¿”å›é•¿åº¦ä¸º `n` çš„å‘é‡ã€‚

### 2.3 Lean4 ç¤ºä¾‹

```lean
import Mathlib.Data.Vector

-- å®šä¹‰ï¼šé•¿åº¦ä¸º n çš„å‘é‡
def Vector (Î± : Type) (n : Nat) : Type := { l : List Î± // l.length = n }

-- ä¾èµ–å‡½æ•°ï¼šå¤åˆ¶ n æ¬¡
def replicate (n : Nat) (x : Î±) : Vector Î± n :=
  âŸ¨List.replicate n x, List.length_replicate n xâŸ©

-- è¯æ˜ï¼šappend é•¿åº¦ç›¸åŠ 
theorem append_length (v1 : Vector Î± n) (v2 : Vector Î± m) :
  (v1.val ++ v2.val).length = n + m := by
  rw [List.length_append, v1.property, v2.property]

-- ä¾èµ–ç±»å‹çš„ append
def append (v1 : Vector Î± n) (v2 : Vector Î± m) : Vector Î± (n + m) :=
  âŸ¨v1.val ++ v2.val, append_length v1 v2âŸ©
```

### 2.4 ä¾èµ–ç±»å‹çš„å¨åŠ›

| æ€§è´¨ | ç®€å•ç±»å‹ | ä¾èµ–ç±»å‹ |
|------|----------|----------|
| **æ•°ç»„è¶Šç•Œ** | è¿è¡Œæ—¶æ£€æŸ¥ | ç¼–è¯‘æœŸæ’é™¤ |
| **æ’åºæ­£ç¡®æ€§** | å•å…ƒæµ‹è¯• | ç±»å‹ä¿è¯ `sort : List A â†’ Sorted A` |
| **ç½‘ç»œåè®®** | è¿è¡Œæ—¶æ–­è¨€ | Session Types |

---

## 3. çº¿æ€§ç±»å‹ï¼ˆLinear Typesï¼‰

### 3.1 åŠ¨æœº

**é—®é¢˜**ï¼šå¦‚ä½•åœ¨ç±»å‹ç³»ç»Ÿä¸­è¡¨è¾¾"èµ„æºå¿…é¡»æ°å¥½ä½¿ç”¨ä¸€æ¬¡"ï¼Ÿ

**åº”ç”¨åœºæ™¯**ï¼š

- æ–‡ä»¶å¥æŸ„ï¼šæ‰“å¼€åå¿…é¡»å…³é—­ï¼Œä¸”åªèƒ½å…³é—­ä¸€æ¬¡
- å¯†é’¥ææ–™ï¼šä½¿ç”¨åå¿…é¡»é”€æ¯
- å¹¶å‘é”ï¼šè·å–åå¿…é¡»é‡Šæ”¾

### 3.2 å½¢å¼å®šä¹‰

**çº¿æ€§å‡½æ•°ç±»å‹**ï¼š

```text
A âŠ¸ B
```

**ç›´è§‰**ï¼šå‡½æ•°å¿…é¡»**æ°å¥½ä½¿ç”¨ä¸€æ¬¡**å…¶å‚æ•°ã€‚

**ç±»å‹è§„åˆ™**ï¼š

```text
Î“, x:A âŠ¢ e : B
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  ï¼ˆx åœ¨ e ä¸­æ°å¥½ä½¿ç”¨ä¸€æ¬¡ï¼‰
Î“ âŠ¢ Î»x. e : A âŠ¸ B
```

### 3.3 ç¤ºä¾‹ï¼šçº¿æ€§æ–‡ä»¶æ“ä½œ

```haskell
-- Haskell + Linear Types æ‰©å±•
{-# LANGUAGE LinearTypes #-}

data File = MkFile Handle

openFile :: FilePath -> IO (File %1)
readLine :: File %1 -> (String, File %1)
closeFile :: File %1 -> IO ()

-- æ­£ç¡®ï¼šæ–‡ä»¶æ°å¥½å…³é—­ä¸€æ¬¡
safeRead :: FilePath -> IO String
safeRead path = do
  file <- openFile path
  (line, file') <- readLine file
  closeFile file'
  return line

-- é”™è¯¯ï¼šæ–‡ä»¶æœªå…³é—­ï¼ˆç¼–è¯‘æœŸæŠ¥é”™ï¼‰
unsafeRead :: FilePath -> IO String
unsafeRead path = do
  file <- openFile path
  (line, _) <- readLine file
  return line  -- ç±»å‹é”™è¯¯ï¼šfile æœªä½¿ç”¨
```

---

## 4. Affine ç±»å‹ï¼ˆRust çš„æ‰€æœ‰æƒï¼‰

### 4.1 Affine vs Linear

| ç±»å‹ | ä½¿ç”¨æ¬¡æ•° | Rust ä¾‹å­ |
|------|----------|-----------|
| **çº¿æ€§ï¼ˆLinearï¼‰** | æ°å¥½ 1 æ¬¡ | - |
| **Affine** | è‡³å¤š 1 æ¬¡ | `Box<T>`, `String` |
| **æ™®é€š** | ä»»æ„æ¬¡ | `i32`, `&T` |

**Affine è§„åˆ™**ï¼š

```text
èµ„æºå¯ä»¥è¢«ä½¿ç”¨ 0 æ¬¡ï¼ˆä¸¢å¼ƒï¼‰æˆ– 1 æ¬¡ï¼ˆè½¬ç§»ï¼‰ï¼Œä½†ä¸èƒ½å¤åˆ¶
```

### 4.2 Rust çš„æ‰€æœ‰æƒç±»å‹ç³»ç»Ÿ

**æ ¸å¿ƒæ¦‚å¿µ**ï¼š

```rust
// æ‰€æœ‰æƒè½¬ç§»
let s1 = String::from("hello");
let s2 = s1;  // s1 å¤±æ•ˆï¼ˆmoveï¼‰
// println!("{}", s1);  // ç¼–è¯‘é”™è¯¯ï¼šuse after move

// å€Ÿç”¨ï¼ˆBorrowï¼‰
let s1 = String::from("hello");
let len = calculate_length(&s1);  // ä¸å¯å˜å€Ÿç”¨
println!("{}", s1);  // s1 ä»æœ‰æ•ˆ

fn calculate_length(s: &String) -> usize {
    s.len()
}

// å¯å˜å€Ÿç”¨ï¼ˆMutable Borrowï¼‰
let mut s = String::from("hello");
change(&mut s);

fn change(s: &mut String) {
    s.push_str(", world");
}
```

**å€Ÿç”¨æ£€æŸ¥è§„åˆ™**ï¼š

```text
1. ä»»æ„æ—¶åˆ»ï¼Œè¦ä¹ˆåªæœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¦ä¹ˆå¤šä¸ªä¸å¯å˜å¼•ç”¨
2. å¼•ç”¨å¿…é¡»æœ‰æ•ˆï¼ˆç”Ÿå‘½å‘¨æœŸæ£€æŸ¥ï¼‰
```

### 4.3 Î»Rust å½¢å¼åŒ–ï¼ˆRustBeltï¼‰

**ç±»å‹è§„åˆ™**ï¼š

```text
Î“ âŠ¢ e : T    own(T)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (Move)
Î“ âŠ¢ move e : T

Î“ âŠ¢ e : T    T : Copy
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (Copy)
Î“ âŠ¢ e : T

Î“ âŠ¢ e : T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (Borrow)
Î“ âŠ¢ &e : &T
```

**Coq ä¸­çš„ Iris é€»è¾‘**ï¼š

```coq
From iris.program_logic Require Import weakestpre.
From iris.heap_lang Require Import lang proofmode notation.

(* æ‰€æœ‰æƒæ–­è¨€ *)
Definition own (l : loc) (v : val) : iProp Î£ := l â†¦ v.

(* å€Ÿç”¨æ–­è¨€ *)
Definition borrowed (l : loc) (v : val) : iProp Î£ :=
  âˆƒ q, l â†¦{q} v.

(* å®šç†ï¼šæ‰€æœ‰æƒè½¬ç§»ä¿æŒ *)
Lemma move_preserves_ownership (l : loc) (v : val) :
  {{{ own l v }}}
    move #l
  {{{ w, RET w; own w v }}}.
Proof.
  (* ä½¿ç”¨ Iris ç­–ç•¥è¯æ˜ *)
  admit.
Qed.
```

---

## 5. å®šé‡ç±»å‹ï¼ˆQuantitative Typesï¼‰

### 5.1 åŠ¨æœº

**é—®é¢˜**ï¼šå¦‚ä½•åœ¨ç±»å‹ç³»ç»Ÿä¸­è·Ÿè¸ª**èµ„æºæ¶ˆè€—**ï¼ˆæ—¶é—´ã€ç©ºé—´ã€èƒ½é‡ã€éšç§é¢„ç®—ï¼‰ï¼Ÿ

**å®šé‡ç±»å‹**ï¼šå°†**æˆæœ¬**åµŒå…¥ç±»å‹ã€‚

### 5.2 å½¢å¼å®šä¹‰

**å®šé‡å‡½æ•°ç±»å‹**ï¼š

```text
A â†’_Îµ B
```

**ç›´è§‰**ï¼šå‡½æ•°ä» `A` åˆ° `B`ï¼ŒåŒæ—¶æ¶ˆè€—èµ„æº `Îµ`ï¼ˆå¯ä»¥æ˜¯æ—¶é—´ã€èƒ½é‡ã€å·®åˆ†éšç§çš„ Îµ ç­‰ï¼‰ã€‚

### 5.3 ç¤ºä¾‹ï¼šèƒ½é‡æ„ŸçŸ¥ç±»å‹ç³»ç»Ÿ

```text
æ’åºç®—æ³•çš„ç±»å‹ï¼š
  sort : List(n) â†’_{E(n)} Sorted(n)
  
  å…¶ä¸­ E(n) = O(n log n)Â·èƒ½é‡å•ä½
```

### 5.4 F* ç¤ºä¾‹ï¼ˆéšç§é¢„ç®—ï¼‰

```fsharp
// F* ä¸­çš„å·®åˆ†éšç§ç±»å‹
type Privacy = float  // Îµ-é¢„ç®—

val laplace_noise : x:int -> epsilon:Privacy -> (y:int{DP epsilon x y})

val count_query : 
  db:list int -> epsilon:Privacy 
  -> (result:int{DP epsilon (List.length db) result})
let count_query db epsilon =
  let true_count = List.length db in
  let noise = laplace_noise true_count epsilon in
  true_count + noise
```

---

## 6. æ¸è¿›ç±»å‹ï¼ˆGradual Typesï¼‰

### 6.1 åŠ¨æœº

**é—®é¢˜**ï¼šå¦‚ä½•åœ¨åŠ¨æ€ç±»å‹è¯­è¨€ï¼ˆå¦‚ Pythonï¼‰ä¸­é€æ­¥å¼•å…¥é™æ€ç±»å‹æ£€æŸ¥ï¼Ÿ

**æ¸è¿›ç±»å‹**ï¼šå…è®¸éƒ¨åˆ†ä»£ç æœ‰ç±»å‹æ³¨è§£ï¼Œéƒ¨åˆ†ä»£ç ä¸ºåŠ¨æ€ç±»å‹ `?`ã€‚

### 6.2 ç±»å‹è§„åˆ™

**ä¸€è‡´æ€§å…³ç³»** `T âˆ¼ S`ï¼š

```text
T âˆ¼ T
? âˆ¼ T
T âˆ¼ ?
Tâ‚ â†’ Tâ‚‚ âˆ¼ Sâ‚ â†’ Sâ‚‚  if  Tâ‚ âˆ¼ Sâ‚ âˆ§ Tâ‚‚ âˆ¼ Sâ‚‚
```

**å­ç±»å‹è§„åˆ™**ï¼š

```text
T <: ?
? <: T
```

### 6.3 Python ç±»å‹æ³¨è§£ç¤ºä¾‹

```python
from typing import List, Optional

# æ¸è¿›ç±»å‹ï¼šéƒ¨åˆ†æ³¨è§£
def greet(name: str) -> str:
    return f"Hello, {name}"

# åŠ¨æ€ç±»å‹ï¼šæ— æ³¨è§£
def process(data):
    return data.upper()

# æ··åˆ
def pipeline(items: List[str]) -> List:
    return [process(item) for item in items]
```

**MyPy ç±»å‹æ£€æŸ¥**ï¼š

```bash
$ mypy example.py
example.py:10: error: Returning Any from function declared to return "List[str]"
```

---

## 7. ç±»å‹ç³»ç»Ÿå¯¹æ¯”

| ç±»å‹ç³»ç»Ÿ | è¡¨è¾¾åŠ› | æ£€æŸ¥æ—¶æœº | å…¸å‹è¯­è¨€ | è¯æ˜è´Ÿæ‹… |
|----------|--------|----------|----------|----------|
| **ç®€å•ç±»å‹** | ä½ | ç¼–è¯‘æœŸ | Java, C# | æ—  |
| **ä¾èµ–ç±»å‹** | æé«˜ | ç¼–è¯‘æœŸ | Coq, Agda, Lean | é«˜ |
| **çº¿æ€§ç±»å‹** | ä¸­ | ç¼–è¯‘æœŸ | Clean, Mercury | ä½ |
| **Affine ç±»å‹** | ä¸­ | ç¼–è¯‘æœŸ | Rust | ä½ |
| **å®šé‡ç±»å‹** | é«˜ | ç¼–è¯‘æœŸ | F*, Granule | ä¸­ |
| **æ¸è¿›ç±»å‹** | ä¸­ | ç¼–è¯‘+è¿è¡Œ | TypeScript, Python | ä½ |

---

## 8. ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–éªŒè¯

### 8.1 éªŒè¯ç›®æ ‡

1. **ç±»å‹å¥å…¨æ€§**ï¼ˆSoundnessï¼‰ï¼šè‰¯ç±»å‹ç¨‹åºä¸ä¼š stuck
2. **å®Œå¤‡æ€§**ï¼ˆCompletenessï¼‰ï¼šæ‰€æœ‰å®‰å…¨ç¨‹åºéƒ½å¯ä»¥ç±»å‹åŒ–ï¼ˆä¸æ€»æˆç«‹ï¼‰
3. **å¯åˆ¤å®šæ€§**ï¼ˆDecidabilityï¼‰ï¼šç±»å‹æ£€æŸ¥ç®—æ³•ç»ˆæ­¢

### 8.2 Coq ä¸­çš„ç±»å‹å¥å…¨æ€§è¯æ˜

```coq
(* Progress å®šç† *)
Theorem progress : forall t T,
  [] âŠ¢ t âˆˆ T ->
  value t \/ exists t', t --> t'.
Proof.
  intros t T Ht.
  remember (@nil (string * ty)) as Gamma.
  induction Ht; subst; auto.
  (* ... å¯¹æ¯æ¡ç±»å‹è§„åˆ™å½’çº³ ... *)
Qed.

(* Preservation å®šç† *)
Theorem preservation : forall t t' T,
  [] âŠ¢ t âˆˆ T ->
  t --> t' ->
  [] âŠ¢ t' âˆˆ T.
Proof.
  intros t t' T HT HE.
  generalize dependent t'.
  induction HT; intros t' HE; inversion HE; subst; eauto.
  (* ... å¯¹æ¯æ¡å½’çº¦è§„åˆ™å½’çº³ ... *)
Qed.

(* Soundness æ¨è®º *)
Corollary soundness : forall t t' T,
  [] âŠ¢ t âˆˆ T ->
  t -->* t' ->
  ~(stuck t').
Proof.
  intros t t' T Hhas_type Hmulti.
  unfold stuck. intros [Hnot_val Hnot_step].
  induction Hmulti.
  - (* t = t' *) apply progress in Hhas_type. destruct Hhas_type; contradiction.
  - (* t --> t' -->* t'' *)
    apply preservation with (t':=y) in Hhas_type; auto.
Qed.
```

---

## 9. å¤§å­¦è¯¾ç¨‹å¯¹åº”

| è¯¾ç¨‹ | ç›¸å…³ç« èŠ‚ |
|------|----------|
| **CMU 15-312 Foundations of PL** | STLC, ç±»å‹å¥å…¨æ€§è¯æ˜ |
| **Stanford CS 242** | ä¾èµ–ç±»å‹ã€çº¿æ€§ç±»å‹ |
| **EPFL CS-628 äº¤äº’å¼å®šç†è¯æ˜** | Coq ä¸­çš„ç±»å‹ç³»ç»Ÿå½¢å¼åŒ– |
| **ETH ZÃ¼rich Advanced Topics in PL** | Affine ç±»å‹ã€Rust RustBelt |
| **Cambridge Part III Types** | Dependent Types, Homotopy Type Theory |

---

## 10. æ•™æå¯¹åº”

| æ•™æ | ç›¸å…³ç« èŠ‚ |
|------|----------|
| **Types and Programming Languages** (TAPL) | Ch 9-15 (STLC), Ch 30 (ä¾èµ–ç±»å‹) |
| **Practical Foundations for PL** (PFPL) | Part IV (Finite Data), Part IX (Dynamic Types) |
| **Software Foundations Vol 2** (Coq) | STLC çš„å®Œæ•´å½¢å¼åŒ– |
| **Programming with Dependent Types** (Idris) | ä¾èµ–ç±»å‹å®è·µ |
| **Rust Belt Papers** | Affine ç±»å‹çš„ Iris å½¢å¼åŒ– |

---

## 11. æœ¬åœ°é¡¹ç›®å¼•ç”¨

- `01.2_Denotational_Semantics.md` - ç±»å‹ç³»ç»Ÿçš„æŒ‡ç§°è¯­ä¹‰
- `../02_Design_Patterns/02.1_GoF_Formal_Analysis.md` - æ¨¡å¼çš„ç±»å‹åˆ»ç”»
- `../05_Formal_Verification/05.1_Coq_Introduction.md` - ç±»å‹ç³»ç»Ÿçš„æœºå™¨éªŒè¯
- `../../FormalLanguage_Perspective/04_Mathematical_Structures/04.2_Type_Theory.md` - ç±»å‹è®ºåŸºç¡€

---

## 12. æ€»ç»“

### æ ¸å¿ƒæ´å¯Ÿ

```text
ç±»å‹ç³»ç»Ÿ = é™æ€ç¨‹åºåˆ†æ + æ­£ç¡®æ€§ä¿è¯

åˆ†ç±»ç»´åº¦ï¼š
  â”œâ”€ è¡¨è¾¾åŠ›ï¼šç®€å• â†’ ä¾èµ–
  â”œâ”€ èµ„æºç®¡ç†ï¼šæ™®é€š â†’ Affine â†’ çº¿æ€§
  â”œâ”€ å®šé‡ï¼šæ— æˆæœ¬ â†’ å®šé‡ç±»å‹
  â””â”€ çµæ´»æ€§ï¼šé™æ€ â†’ æ¸è¿›

è®¾è®¡æƒè¡¡ï¼š
  æ›´å¼ºç±»å‹ = æ›´å¤šä¿è¯ + æ›´é«˜è¯æ˜è´Ÿæ‹…
```

### å·¥å…·é“¾æ¨è

| éœ€æ±‚ | æ¨èå·¥å…· |
|------|----------|
| **å­¦ä¹ ä¾èµ–ç±»å‹** | Lean4, Agda |
| **å·¥ä¸š Affine ç±»å‹** | Rust |
| **æ¸è¿›ç±»å‹** | TypeScript, Python+MyPy |
| **å®šé‡ç±»å‹ç ”ç©¶** | F*, Granule |
| **ç±»å‹ç³»ç»Ÿå½¢å¼åŒ–** | Coq, Isabelle/HOL |

### å®æˆ˜å»ºè®®

1. **å…¥é—¨**ï¼šä» STLC çš„ Coq å½¢å¼åŒ–å¼€å§‹ï¼ˆSoftware Foundations Vol 2ï¼‰
2. **è¿›é˜¶**ï¼šå­¦ä¹  Rustï¼Œç†è§£ Affine ç±»å‹çš„å®é™…åº”ç”¨
3. **é«˜çº§**ï¼šç”¨ Lean4 å®ç°ä¾èµ–ç±»å‹çš„æ•°æ®ç»“æ„
4. **å‰æ²¿**ï¼šé˜…è¯» RustBelt è®ºæ–‡ï¼Œç†è§£ Iris åˆ†ç¦»é€»è¾‘

---

## é™„å½• Aï¼šç±»å‹æ¨å¯¼ç¤ºä¾‹

### ç¤ºä¾‹ï¼šæ¨å¯¼ `(Î»x:Bool. x) true`

```text
æ­¥éª¤ 1ï¼š
  x:Bool âˆˆ {x:Bool}
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (Var)
  {x:Bool} âŠ¢ x : Bool

æ­¥éª¤ 2ï¼š
  {x:Bool} âŠ¢ x : Bool
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (Abs)
  {} âŠ¢ (Î»x:Bool. x) : Bool â†’ Bool

æ­¥éª¤ 3ï¼š
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (True)
  {} âŠ¢ true : Bool

æ­¥éª¤ 4ï¼š
  {} âŠ¢ (Î»x:Bool. x) : Bool â†’ Bool    {} âŠ¢ true : Bool
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (App)
            {} âŠ¢ (Î»x:Bool. x) true : Bool
```

---

## é™„å½• Bï¼šWikipedia æ¦‚å¿µå¯¹ç…§

| æ¦‚å¿µ | Wikipedia æ¡ç›® | æœ¬æ–‡ç« èŠ‚ |
|------|----------------|----------|
| Type System | <https://en.wikipedia.org/wiki/Type_system> | Â§1 |
| Dependent Type | <https://en.wikipedia.org/wiki/Dependent_type> | Â§2 |
| Linear Type System | <https://en.wikipedia.org/wiki/Substructural_type_system> | Â§3 |
| Affine Type System | <https://en.wikipedia.org/wiki/Substructural_type_system#Affine_type_systems> | Â§4 |
| Gradual Typing | <https://en.wikipedia.org/wiki/Gradual_typing> | Â§6 |
| Type Safety | <https://en.wikipedia.org/wiki/Type_safety> | Â§8 |

---

**ç‰ˆæœ¬**ï¼šv1.0  
**æœ€åæ›´æ–°**ï¼š2025-10-29  
**ç»´æŠ¤è€…**ï¼šFormalScience Project  
**è®¸å¯**ï¼šCC BY-SA 4.0
