# 03.4 å¹¶è¡Œç®—æ³•ä¸Work-Spanæ¨¡å‹

## ğŸ“š ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [1. å¹¶è¡Œè®¡ç®—æ¨¡å‹](#1-å¹¶è¡Œè®¡ç®—æ¨¡å‹)
  - [1.1 PRAM æ¨¡å‹ï¼ˆParallel Random Access Machineï¼‰](#11-pram-æ¨¡å‹parallel-random-access-machine)
  - [1.2 Work-Span æ¨¡å‹](#12-work-span-æ¨¡å‹)
  - [1.3 å½¢å¼åŒ–å®šä¹‰](#13-å½¢å¼åŒ–å®šä¹‰)
- [2. å¹¶è¡Œç®—æ³•è®¾è®¡æŠ€æœ¯](#2-å¹¶è¡Œç®—æ³•è®¾è®¡æŠ€æœ¯)
  - [2.1 åˆ†æ²»ï¼ˆDivide and Conquerï¼‰](#21-åˆ†æ²»divide-and-conquer)
  - [2.2 å‰ç¼€å’Œï¼ˆPrefix Sum / Scanï¼‰](#22-å‰ç¼€å’Œprefix-sum--scan)
  - [2.3 çŸ©é˜µä¹˜æ³•](#23-çŸ©é˜µä¹˜æ³•)
- [3. è°ƒåº¦ç†è®º](#3-è°ƒåº¦ç†è®º)
  - [3.1 Work-Stealing è°ƒåº¦](#31-work-stealing-è°ƒåº¦)
  - [3.2 Greedy è°ƒåº¦çš„Coqè¯æ˜](#32-greedy-è°ƒåº¦çš„coqè¯æ˜)
- [4. å®æˆ˜æ¡ˆä¾‹](#4-å®æˆ˜æ¡ˆä¾‹)
  - [4.1 å¿«é€Ÿæ’åºï¼ˆParallel Quicksortï¼‰](#41-å¿«é€Ÿæ’åºparallel-quicksort)
  - [4.2 å¹¶è¡ŒBFSï¼ˆBreadth-First Searchï¼‰](#42-å¹¶è¡Œbfsbreadth-first-search)
- [5. ä¸å›½é™…è¯¾ç¨‹å¯¹æ ‡](#5-ä¸å›½é™…è¯¾ç¨‹å¯¹æ ‡)
  - [5.1 å¤§å­¦è¯¾ç¨‹æ˜ å°„](#51-å¤§å­¦è¯¾ç¨‹æ˜ å°„)
  - [5.2 æ•™æå¯¹åº”](#52-æ•™æå¯¹åº”)
- [6. å·¥å…·ä¸ç”Ÿæ€](#6-å·¥å…·ä¸ç”Ÿæ€)
  - [6.1 å¹¶è¡Œç¼–ç¨‹æ¡†æ¶](#61-å¹¶è¡Œç¼–ç¨‹æ¡†æ¶)
  - [6.2 å½¢å¼åŒ–å·¥å…·](#62-å½¢å¼åŒ–å·¥å…·)
- [7. é«˜çº§ä¸»é¢˜](#7-é«˜çº§ä¸»é¢˜)
  - [7.1 Cache-Oblivious å¹¶è¡Œç®—æ³•](#71-cache-oblivious-å¹¶è¡Œç®—æ³•)
  - [7.2 å¤–éƒ¨å­˜å‚¨å¹¶è¡Œç®—æ³•](#72-å¤–éƒ¨å­˜å‚¨å¹¶è¡Œç®—æ³•)
  - [7.3 é‡å­å¹¶è¡Œç®—æ³•](#73-é‡å­å¹¶è¡Œç®—æ³•)
- [8. æ‰©å±•é˜…è¯»](#8-æ‰©å±•é˜…è¯»)
  - [8.1 å­¦æœ¯è®ºæ–‡](#81-å­¦æœ¯è®ºæ–‡)
  - [8.2 åœ¨çº¿èµ„æº](#82-åœ¨çº¿èµ„æº)
  - [8.3 æœ¬åœ°é¡¹ç›®å¼•ç”¨](#83-æœ¬åœ°é¡¹ç›®å¼•ç”¨)
- [é™„å½• Aï¼šWikipedia æ¦‚å¿µå¯¹ç…§](#é™„å½•-awikipedia-æ¦‚å¿µå¯¹ç…§)

---

## æ¦‚è¿°

**å¹¶è¡Œç®—æ³•**ï¼ˆParallel Algorithmsï¼‰ç ”ç©¶å¦‚ä½•åˆ©ç”¨å¤šä¸ªå¤„ç†å™¨åŒæ—¶è®¡ç®—ä»¥åŠ é€Ÿé—®é¢˜æ±‚è§£ã€‚æ ¸å¿ƒé—®é¢˜ï¼š
> ç»™å®š P ä¸ªå¤„ç†å™¨ï¼Œå¦‚ä½•è®¾è®¡ç®—æ³•ä½¿æ€»æ—¶é—´æœ€å°ï¼Ÿ

æœ¬æ–‡ç³»ç»Ÿä»‹ç»ï¼š

1. **Work-Span æ¨¡å‹**ï¼šå¹¶è¡Œå¤æ‚åº¦çš„ç†è®ºåŸºç¡€
2. **å¹¶è¡Œç®—æ³•è®¾è®¡æŠ€æœ¯**ï¼šåˆ†æ²»ã€å‰ç¼€å’Œã€åˆ—è¡¨æ’åº
3. **è°ƒåº¦ç†è®º**ï¼šWork-Stealing, Greedy Scheduling
4. **å½¢å¼åŒ–éªŒè¯**ï¼šCoq/Lean4 ä¸­çš„å¹¶è¡Œæ€§è¯æ˜

---

## 1. å¹¶è¡Œè®¡ç®—æ¨¡å‹

### 1.1 PRAM æ¨¡å‹ï¼ˆParallel Random Access Machineï¼‰

**å®šä¹‰**ï¼š

```text
PRAM = âŸ¨Pä¸ªå¤„ç†å™¨, å…±äº«å†…å­˜, åŒæ­¥æ—¶é’ŸâŸ©

æ¯ä¸ªæ—¶é—´æ­¥ï¼š
  1. æ¯ä¸ªå¤„ç†å™¨ä»å…±äº«å†…å­˜è¯»å–æ•°æ®
  2. æ‰§è¡Œæœ¬åœ°è®¡ç®—
  3. å†™å›å…±äº«å†…å­˜

å˜ç§ï¼ˆæ ¹æ®è¯»å†™å†²çªå¤„ç†ï¼‰ï¼š
  - EREW (Exclusive Read Exclusive Write)ï¼šæ— å†²çª
  - CREW (Concurrent Read Exclusive Write)ï¼šå…è®¸åŒæ—¶è¯»
  - CRCW (Concurrent Read Concurrent Write)ï¼šå…è®¸åŒæ—¶è¯»å†™
    - COMMONï¼šå†™å…¥ç›¸åŒå€¼
    - ARBITRARYï¼šä»»æ„ä¸€ä¸ªå†™å…¥æˆåŠŸ
    - PRIORITYï¼šä¼˜å…ˆçº§æœ€é«˜çš„å†™å…¥
```

**ç¤ºä¾‹**ï¼šå¹¶è¡Œæ±‚å’Œï¼ˆCREW PRAMï¼‰

```text
è¾“å…¥ï¼šA[1..n]
è¾“å‡ºï¼šsum = Î£áµ¢ A[i]

ç®—æ³•ï¼ˆäºŒå‰æ ‘å½’çº¦ï¼‰ï¼š
  for d = 1 to âŒˆlogâ‚‚ nâŒ‰:
    parfor i = 1 to âŒŠn / 2^dâŒ‹:
      B[i] = A[2i-1] + A[2i]
    A := B

æ—¶é—´ï¼šO(log n)  ï¼ˆä½¿ç”¨ n/2 ä¸ªå¤„ç†å™¨ï¼‰
å·¥ä½œï¼šO(n)      ï¼ˆæ€»æ“ä½œæ•°ï¼‰
```

### 1.2 Work-Span æ¨¡å‹

**æ ¸å¿ƒæ¦‚å¿µ**ï¼š

```text
Work (Tâ‚)ï¼š
  - å•å¤„ç†å™¨æ‰§è¡Œçš„æ€»æ—¶é—´
  - ç­‰ä»·äºä¸²è¡Œç®—æ³•çš„æ—¶é—´å¤æ‚åº¦

Span (T_âˆ)ï¼š
  - æ— é™å¤„ç†å™¨çš„æ‰§è¡Œæ—¶é—´
  - ç­‰ä»·äºå…³é”®è·¯å¾„é•¿åº¦ï¼ˆcritical pathï¼‰
  - ä¹Ÿç§°ä¸º Depth

å¹¶è¡Œåº¦ï¼ˆParallelismï¼‰ï¼š
  Tâ‚ / T_âˆ
  
  è¡¨ç¤ºç®—æ³•å¯ä»¥ä»å¹¶è¡Œä¸­è·ç›Šçš„ç¨‹åº¦
```

**Brentå®šç†**ï¼ˆè°ƒåº¦ä¸‹ç•Œï¼‰ï¼š

```text
å®šç†ï¼šä½¿ç”¨ P ä¸ªå¤„ç†å™¨ï¼Œä»»ä½•è°ƒåº¦çš„æ‰§è¡Œæ—¶é—´æ»¡è¶³ï¼š
  T_P â‰¥ max(Tâ‚/P, T_âˆ)

è¯æ˜ï¼š
  - Tâ‚/Pï¼šå¹³å‡æ¯ä¸ªå¤„ç†å™¨éœ€è¦ Tâ‚/P æ—¶é—´ï¼ˆå·¥ä½œé‡ä¸‹ç•Œï¼‰
  - T_âˆï¼šå…³é”®è·¯å¾„æ— æ³•å¹¶è¡ŒåŒ–ï¼ˆä¾èµ–æ€§ä¸‹ç•Œï¼‰
```

**è´ªå¿ƒè°ƒåº¦ï¼ˆGreedy Schedulingï¼‰**ï¼š

```text
å®šç†ï¼šè´ªå¿ƒè°ƒåº¦ä¿è¯ï¼š
  T_P â‰¤ Tâ‚/P + T_âˆ

è¯æ˜è‰å›¾ï¼š
  - å°†æ—¶é—´æ­¥åˆ†ä¸ºä¸¤ç±»ï¼š
    1. "å®Œæ•´æ­¥"ï¼ˆComplete Stepï¼‰ï¼šP ä¸ªå¤„ç†å™¨éƒ½åœ¨å·¥ä½œ
    2. "ä¸å®Œæ•´æ­¥"ï¼ˆIncomplete Stepï¼‰ï¼š< P ä¸ªå¤„ç†å™¨åœ¨å·¥ä½œ
  
  - å®Œæ•´æ­¥æ•° â‰¤ Tâ‚/Pï¼ˆå·¥ä½œé‡é™åˆ¶ï¼‰
  - ä¸å®Œæ•´æ­¥æ•° â‰¤ T_âˆï¼ˆå…³é”®è·¯å¾„é™åˆ¶ï¼Œæ¯æ­¥è‡³å°‘å‡å°‘1æ·±åº¦ï¼‰
  
  - å› æ­¤ T_P â‰¤ Tâ‚/P + T_âˆ

æ¨è®ºï¼ˆçº¿æ€§åŠ é€Ÿï¼‰ï¼š
  å¦‚æœ Tâ‚/T_âˆ â‰« Pï¼Œåˆ™ T_P â‰ˆ Tâ‚/Pï¼ˆè¿‘ä¼¼çº¿æ€§åŠ é€Ÿï¼‰
```

### 1.3 å½¢å¼åŒ–å®šä¹‰

```text
å¹¶è¡Œç®—æ³•çš„æŠ½è±¡è¯­æ³•ï¼š

e ::= n                    (å¸¸é‡)
    | x                    (å˜é‡)
    | eâ‚ op eâ‚‚             (é¡ºåºè¿ç®—)
    | spawn eâ‚; eâ‚‚         (æ´¾ç”Ÿå¹¶è¡Œä»»åŠ¡)
    | sync                 (åŒæ­¥ç­‰å¾…)
    | parfor(i, 1, n, e)   (å¹¶è¡Œå¾ªç¯)

Work-Span è¯­ä¹‰ï¼š

âŸ¦nâŸ§ = (1, 1)              (Work=1, Span=1)

âŸ¦eâ‚ op eâ‚‚âŸ§ = let (Wâ‚, Sâ‚) = âŸ¦eâ‚âŸ§
               let (Wâ‚‚, Sâ‚‚) = âŸ¦eâ‚‚âŸ§
             in (Wâ‚ + Wâ‚‚ + 1, Sâ‚ + Sâ‚‚ + 1)

âŸ¦spawn eâ‚; eâ‚‚âŸ§ = let (Wâ‚, Sâ‚) = âŸ¦eâ‚âŸ§
                  let (Wâ‚‚, Sâ‚‚) = âŸ¦eâ‚‚âŸ§
                in (Wâ‚ + Wâ‚‚, max(Sâ‚, Sâ‚‚))
                  ï¼ˆå¹¶è¡Œæ‰§è¡Œï¼Œå·¥ä½œé‡ç›¸åŠ ï¼ŒSpan å–æœ€å¤§ï¼‰

âŸ¦parfor(i, 1, n, e)âŸ§ = let (W, S) = âŸ¦eâŸ§ per iteration
                     in (n Ã— W, S)
                       ï¼ˆn ä¸ªä»»åŠ¡å¹¶è¡Œï¼Œæ€»å·¥ä½œé‡ nÃ—Wï¼ŒSpan = Sï¼‰
```

---

## 2. å¹¶è¡Œç®—æ³•è®¾è®¡æŠ€æœ¯

### 2.1 åˆ†æ²»ï¼ˆDivide and Conquerï¼‰

#### å¹¶è¡Œå½’å¹¶æ’åº

**ç®—æ³•**ï¼š

```pseudocode
parallel_merge_sort(A[1..n]):
  if n <= 1:
    return A
  
  mid = n / 2
  spawn L = parallel_merge_sort(A[1..mid])
  spawn R = parallel_merge_sort(A[mid+1..n])
  sync
  
  return parallel_merge(L, R)
```

**åˆ†æ**ï¼š

```text
Workï¼ˆTâ‚ï¼‰ï¼š
  W(n) = 2W(n/2) + O(n)  ï¼ˆå½’å¹¶éœ€è¦ O(nï¼‰å·¥ä½œï¼‰
  W(n) = O(n log n)      ï¼ˆMaster Theoremï¼‰

Spanï¼ˆT_âˆï¼‰ï¼š
  S(n) = S(n/2) + O(log n)  ï¼ˆå¹¶è¡Œå½’å¹¶çš„ Spanï¼‰
  S(n) = O(logÂ² n)

å¹¶è¡Œåº¦ï¼š
  P = W/S = (n log n) / (logÂ² n) = n / log n
  
  ç»“è®ºï¼šå½“ P â‰ª n/log n æ—¶ï¼Œå¯è·å¾—è¿‘ä¼¼çº¿æ€§åŠ é€Ÿ
```

**å¹¶è¡Œå½’å¹¶ï¼ˆParallel Mergeï¼‰**ï¼š

```pseudocode
parallel_merge(A[1..m], B[1..n]):
  if m + n <= threshold:
    return serial_merge(A, B)
  
  # å– A çš„ä¸­ä½æ•°
  mid_A = A[m/2]
  
  # åœ¨ B ä¸­äºŒåˆ†æŸ¥æ‰¾ mid_A çš„ä½ç½®
  pos_B = binary_search(B, mid_A)
  
  # å¹¶è¡Œå½’å¹¶å·¦å³ä¸¤éƒ¨åˆ†
  spawn left = parallel_merge(A[1..m/2], B[1..pos_B])
  spawn right = parallel_merge(A[m/2+1..m], B[pos_B+1..n])
  sync
  
  return concat(left, right)
```

**Span åˆ†æ**ï¼š

```text
S(m, n) = S(m/2, k) + O(log n)  ï¼ˆk â‰¤ nï¼‰
S(m, n) = O(log m Ã— log n)

å› æ­¤å½’å¹¶æ’åºçš„æ€» Spanï¼š
  S_sort(n) = S_sort(n/2) + O(logÂ² n) = O(logÂ³ n)
  
ä¼˜åŒ–ï¼ˆCole 1988ï¼‰ï¼šå¯ä»¥è¾¾åˆ° O(log n) Spanï¼
```

### 2.2 å‰ç¼€å’Œï¼ˆPrefix Sum / Scanï¼‰

**é—®é¢˜**ï¼š

```text
è¾“å…¥ï¼šA[1..n]
è¾“å‡ºï¼šB[i] = Î£â±¼â‚Œâ‚â± A[j]  å¯¹æ‰€æœ‰ i

ç¤ºä¾‹ï¼š
  A = [3, 1, 4, 1, 5]
  B = [3, 4, 8, 9, 14]
```

**ä¸²è¡Œç®—æ³•**ï¼šO(n) æ—¶é—´ï¼ŒO(1) ç©ºé—´

**å¹¶è¡Œç®—æ³•ï¼ˆUp-Down Treeï¼‰**ï¼š

```pseudocode
parallel_scan(A[1..n]):
  # Up-sweep phaseï¼ˆè‡ªåº•å‘ä¸Šï¼‰
  for d = 0 to logâ‚‚ n - 1:
    parfor i where 2^(d+1) | i:
      A[i] = A[i - 2^d] + A[i]
  
  # Down-sweep phaseï¼ˆè‡ªé¡¶å‘ä¸‹ï¼‰
  A[n] = 0  # åˆå§‹åŒ–æ ¹ä¸º0
  for d = logâ‚‚ n - 1 downto 0:
    parfor i where 2^(d+1) | i:
      temp = A[i - 2^d]
      A[i - 2^d] = A[i]
      A[i] = A[i] + temp
  
  return A
```

**å¤æ‚åº¦**ï¼š

```text
Workï¼š
  - Up-sweep: Î£áµˆ n/2^(d+1) = O(n)
  - Down-sweep: O(n)
  - æ€»è®¡ï¼šO(n)

Spanï¼š
  - Up-sweep: O(log n) å±‚
  - Down-sweep: O(log n) å±‚
  - æ€»è®¡ï¼šO(log n)

å¹¶è¡Œåº¦ï¼šP = n / log n
```

**åº”ç”¨**ï¼š

```text
1. Compactï¼ˆæ•°ç»„å‹ç¼©ï¼‰ï¼š
   è¾“å…¥ï¼š[3, 0, 0, 5, 0, 7]  ï¼ˆ0 è¡¨ç¤ºåˆ é™¤ï¼‰
   Flagsï¼š[1, 0, 0, 1, 0, 1]
   Scanï¼š[1, 1, 1, 2, 2, 3]
   è¾“å‡ºï¼š[3, 5, 7]

2. Quicksort åˆ†å‰²ï¼š
   å¹¶è¡Œè®¡ç®— < pivot å’Œ â‰¥ pivot çš„å…ƒç´ ä½ç½®

3. æ ‘éå†ï¼ˆEuler Tourï¼‰ï¼š
   å¹¶è¡Œè®¡ç®—æ ‘èŠ‚ç‚¹çš„æ·±åº¦ã€å­æ ‘å¤§å°ç­‰
```

### 2.3 çŸ©é˜µä¹˜æ³•

#### å¤©çœŸå¹¶è¡Œç®—æ³•

```pseudocode
parallel_matmul(A[nÃ—n], B[nÃ—n]):
  parfor i = 1 to n:
    parfor j = 1 to n:
      C[i][j] = Î£â‚– A[i][k] * B[k][j]
  
  return C
```

**å¤æ‚åº¦**ï¼š

```text
Workï¼šO(nÂ³)
Spanï¼šO(n)  ï¼ˆå†…å±‚æ±‚å’Œä¸²è¡Œï¼‰
å¹¶è¡Œåº¦ï¼šO(nÂ²)
```

#### Strassen å¹¶è¡Œç®—æ³•

```pseudocode
parallel_strassen(A[nÃ—n], B[nÃ—n]):
  if n <= threshold:
    return serial_matmul(A, B)
  
  # åˆ†å—
  Aâ‚â‚, Aâ‚â‚‚, Aâ‚‚â‚, Aâ‚‚â‚‚ = partition(A)
  Bâ‚â‚, Bâ‚â‚‚, Bâ‚‚â‚, Bâ‚‚â‚‚ = partition(B)
  
  # å¹¶è¡Œè®¡ç®— 7 ä¸ªçŸ©é˜µä¹˜æ³•
  spawn Mâ‚ = parallel_strassen(Aâ‚â‚ + Aâ‚‚â‚‚, Bâ‚â‚ + Bâ‚‚â‚‚)
  spawn Mâ‚‚ = parallel_strassen(Aâ‚‚â‚ + Aâ‚‚â‚‚, Bâ‚â‚)
  spawn Mâ‚ƒ = parallel_strassen(Aâ‚â‚, Bâ‚â‚‚ - Bâ‚‚â‚‚)
  spawn Mâ‚„ = parallel_strassen(Aâ‚‚â‚‚, Bâ‚‚â‚ - Bâ‚â‚)
  spawn Mâ‚… = parallel_strassen(Aâ‚â‚ + Aâ‚â‚‚, Bâ‚‚â‚‚)
  spawn Mâ‚† = parallel_strassen(Aâ‚‚â‚ - Aâ‚â‚, Bâ‚â‚ + Bâ‚â‚‚)
  spawn Mâ‚‡ = parallel_strassen(Aâ‚â‚‚ - Aâ‚‚â‚‚, Bâ‚‚â‚ + Bâ‚‚â‚‚)
  sync
  
  # ç»„åˆç»“æœ
  Câ‚â‚ = Mâ‚ + Mâ‚„ - Mâ‚… + Mâ‚‡
  Câ‚â‚‚ = Mâ‚ƒ + Mâ‚…
  Câ‚‚â‚ = Mâ‚‚ + Mâ‚„
  Câ‚‚â‚‚ = Mâ‚ - Mâ‚‚ + Mâ‚ƒ + Mâ‚†
  
  return combine(Câ‚â‚, Câ‚â‚‚, Câ‚‚â‚, Câ‚‚â‚‚)
```

**å¤æ‚åº¦**ï¼š

```text
Workï¼š
  W(n) = 7W(n/2) + O(nÂ²)
  W(n) = O(n^logâ‚‚ 7) â‰ˆ O(n^2.807)

Spanï¼š
  S(n) = S(n/2) + O(log n)  ï¼ˆåŠ æ³•çŸ©é˜µå¹¶è¡Œï¼‰
  S(n) = O(logÂ² n)

å¹¶è¡Œåº¦ï¼šP = n^2.807 / logÂ² n
```

---

## 3. è°ƒåº¦ç†è®º

### 3.1 Work-Stealing è°ƒåº¦

**ç®—æ³•**ï¼š

```text
æ¯ä¸ªå¤„ç†å™¨ç»´æŠ¤ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—ï¼ˆdequeï¼‰ï¼š
  - æœ¬åœ°ä»»åŠ¡æ”¾åœ¨é˜Ÿåˆ—å¤´éƒ¨
  - å¤„ç†å™¨ç©ºé—²æ—¶ï¼Œä»å…¶ä»–å¤„ç†å™¨é˜Ÿåˆ—å°¾éƒ¨"å·å–"ä»»åŠ¡

ä¼˜ç‚¹ï¼š
  - ä½åŒæ­¥å¼€é”€ï¼ˆå¤§éƒ¨åˆ†æ—¶é—´æœ¬åœ°æ“ä½œï¼‰
  - åŠ¨æ€è´Ÿè½½å‡è¡¡
  - å±€éƒ¨æ€§å¥½ï¼ˆæœ¬åœ°ä»»åŠ¡ä¼˜å…ˆï¼‰
```

**æ€§èƒ½ä¿è¯**ï¼š

```text
å®šç†ï¼ˆBlumofe & Leiserson 1999ï¼‰ï¼š
  Work-Stealing è°ƒåº¦çš„æœŸæœ›æ‰§è¡Œæ—¶é—´æ»¡è¶³ï¼š
    E[T_P] â‰¤ Tâ‚/P + O(T_âˆ)
  
  è¯æ˜è‰å›¾ï¼š
    - å°†æ—¶é—´æ­¥åˆ†ä¸ºä¸¤ç±»ï¼š
      1. è‡³å°‘ P/2 ä¸ªå¤„ç†å™¨åœ¨å·¥ä½œï¼ˆ"é‡"æ­¥ï¼‰
      2. < P/2 ä¸ªå¤„ç†å™¨åœ¨å·¥ä½œï¼ˆ"è½»"æ­¥ï¼‰
    
    - é‡æ­¥æ•° â‰¤ 2Tâ‚/Pï¼ˆå·¥ä½œé‡é™åˆ¶ï¼‰
    - è½»æ­¥æ•°åˆ†æï¼š
      * æ¯ä¸ªè½»æ­¥ï¼Œè‡³å°‘æœ‰ P/2 ä¸ªå¤„ç†å™¨ç©ºé—²
      * æ¯ä¸ªç©ºé—²å¤„ç†å™¨å°è¯•å·å–ä»»åŠ¡
      * æˆåŠŸå·å–çš„æ¦‚ç‡ä¸å…³é”®è·¯å¾„é•¿åº¦ç›¸å…³
      * æœŸæœ›è½»æ­¥æ•° = O(P Ã— T_âˆ)
    
    - å› æ­¤ E[T_P] = O(Tâ‚/P + P Ã— T_âˆ / P) = O(Tâ‚/P + T_âˆ)
```

**å®ç°**ï¼ˆCilk-styleï¼‰ï¼š

```c
// å¤„ç†å™¨ä¸»å¾ªç¯
void worker_loop(int id) {
  while (true) {
    Task* task = deque_pop_top(local_deque[id]);  // æœ¬åœ°å¼¹å‡º
    
    if (task == NULL) {
      // å°è¯•å·å–ä»»åŠ¡
      task = steal_random();
      if (task == NULL) break;  // å…¨å±€å®Œæˆ
    }
    
    execute(task);
  }
}

Task* steal_random() {
  int victim = random_processor_id();
  return deque_pop_bottom(local_deque[victim]);  // ä»å°¾éƒ¨å·å–
}
```

### 3.2 Greedy è°ƒåº¦çš„Coqè¯æ˜

```coq
Require Import Coq.Arith.Arith.
Require Import Coq.Lists.List.

(* ä»»åŠ¡ä¾èµ–å›¾ï¼ˆDAGï¼‰ *)
Record DAG := {
  nodes : list nat;
  edges : list (nat * nat);  (* ä¾èµ–å…³ç³» *)
}.

(* Work å’Œ Span å®šä¹‰ *)
Definition Work (g : DAG) : nat :=
  length (nodes g).

Definition Span (g : DAG) : nat :=
  (* æœ€é•¿è·¯å¾„é•¿åº¦ï¼Œéœ€è¦é€šè¿‡æ‹“æ‰‘æ’åºè®¡ç®— *)
  0.  (* ç®€åŒ– *)

(* è°ƒåº¦ *)
Definition Schedule := nat -> list nat.  (* æ—¶é—´æ­¥ -> æ‰§è¡Œçš„èŠ‚ç‚¹ *)

(* Greedy è°ƒåº¦æ€§è´¨ *)
Definition is_greedy (s : Schedule) (P : nat) : Prop :=
  forall t : nat,
    length (s t) <= P /\  (* ä¸è¶…è¿‡å¤„ç†å™¨æ•° *)
    (length (s t) < P -> (* å¦‚æœä¸æ»¡ï¼Œåˆ™æ— å¯ç”¨ä»»åŠ¡ *)
       forall n, In n (nodes g) -> executed_before t s n \/ depends_on_pending t s n).

(* Brent å®šç† *)
Theorem brent_theorem (g : DAG) (P : nat) (s : Schedule) :
  is_greedy s P ->
  let T_1 := Work g in
  let T_inf := Span g in
  let T_P := schedule_length s in
  T_P >= max (Nat.div T_1 P) T_inf.
Proof.
  intros H_greedy T_1 T_inf T_P.
  (* è¯æ˜å·¥ä½œé‡ä¸‹ç•Œ *)
  assert (H_work : T_P >= Nat.div T_1 P).
  {
    (* æ€»å·¥ä½œé‡ = Î£â‚œ |s(t)| â‰¤ T_P Ã— P *)
    (* å› æ­¤ T_1 â‰¤ T_P Ã— Pï¼Œå³ T_P â‰¥ T_1 / P *)
    unfold Work, T_1. unfold schedule_length, T_P.
    (* ... è¯¦ç»†è¯æ˜ ... *)
    admit.
  }
  
  (* è¯æ˜å…³é”®è·¯å¾„ä¸‹ç•Œ *)
  assert (H_span : T_P >= T_inf).
  {
    (* å…³é”®è·¯å¾„ä¸Šæ¯ä¸ªèŠ‚ç‚¹è‡³å°‘éœ€è¦ 1 ä¸ªæ—¶é—´æ­¥ *)
    (* ... è¯¦ç»†è¯æ˜ ... *)
    admit.
  }
  
  apply Nat.max_lub; assumption.
Admitted.
```

---

## 4. å®æˆ˜æ¡ˆä¾‹

### 4.1 å¿«é€Ÿæ’åºï¼ˆParallel Quicksortï¼‰

```rust
use rayon::prelude::*;

fn parallel_quicksort<T: Ord + Send>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }
    
    let pivot_idx = partition(arr);
    let (left, right) = arr.split_at_mut(pivot_idx);
    
    // å¹¶è¡Œé€’å½’æ’åºå·¦å³ä¸¤éƒ¨åˆ†
    rayon::join(
        || parallel_quicksort(left),
        || parallel_quicksort(right),
    );
}

fn partition<T: Ord>(arr: &mut [T]) -> usize {
    let pivot_idx = arr.len() / 2;
    arr.swap(pivot_idx, arr.len() - 1);
    
    let mut i = 0;
    for j in 0..arr.len() - 1 {
        if arr[j] <= arr[arr.len() - 1] {
            arr.swap(i, j);
            i += 1;
        }
    }
    arr.swap(i, arr.len() - 1);
    i
}

// æµ‹è¯•
fn main() {
    let mut data = vec![5, 2, 8, 1, 9, 3, 7, 4, 6];
    parallel_quicksort(&mut data);
    println!("{:?}", data);  // [1, 2, 3, 4, 5, 6, 7, 8, 9]
}
```

**å¤æ‚åº¦**ï¼š

```text
Workï¼ˆæœŸæœ›ï¼‰ï¼šO(n log n)
Spanï¼ˆæœŸæœ›ï¼‰ï¼šO(logÂ² n)  ï¼ˆæ¯å±‚ O(log n)ï¼Œå…± log n å±‚ï¼‰
å¹¶è¡Œåº¦ï¼šO(n / log n)

æœ€åæƒ…å†µï¼š
  Workï¼šO(nÂ²)
  Spanï¼šO(n)
```

### 4.2 å¹¶è¡ŒBFSï¼ˆBreadth-First Searchï¼‰

```go
package main

import (
    "sync"
)

type Graph struct {
    adj [][]int  // é‚»æ¥è¡¨
}

func ParallelBFS(g *Graph, start int) []int {
    n := len(g.adj)
    level := make([]int, n)
    for i := range level {
        level[i] = -1
    }
    level[start] = 0
    
    frontier := []int{start}
    currentLevel := 0
    
    for len(frontier) > 0 {
        nextFrontier := make(chan int, n)
        var wg sync.WaitGroup
        
        // å¹¶è¡Œå¤„ç†å½“å‰å±‚çš„æ‰€æœ‰èŠ‚ç‚¹
        for _, u := range frontier {
            wg.Add(1)
            go func(u int) {
                defer wg.Done()
                for _, v := range g.adj[u] {
                    // åŸå­åœ°æ£€æŸ¥å¹¶æ›´æ–° level[v]
                    if atomic.CompareAndSwapInt32(&level[v], -1, currentLevel+1) {
                        nextFrontier <- v
                    }
                }
            }(u)
        }
        
        wg.Wait()
        close(nextFrontier)
        
        // æ”¶é›†ä¸‹ä¸€å±‚èŠ‚ç‚¹
        frontier = make([]int, 0)
        for v := range nextFrontier {
            frontier = append(frontier, v)
        }
        
        currentLevel++
    }
    
    return level
}
```

**å¤æ‚åº¦**ï¼š

```text
Workï¼šO(V + E)  ï¼ˆä¸ä¸²è¡ŒBFSç›¸åŒï¼‰
Spanï¼šO(D Ã— log V)  ï¼ˆD = å›¾çš„ç›´å¾„ï¼‰

è§£é‡Šï¼š
  - æ¯å±‚å¹¶è¡Œå¤„ç†ï¼Œå…± D å±‚
  - æ¯å±‚å†…ï¼Œå¤„ç† frontier éœ€è¦ O(log |frontier|) æ—¶é—´ï¼ˆåˆå¹¶æ“ä½œï¼‰
```

---

## 5. ä¸å›½é™…è¯¾ç¨‹å¯¹æ ‡

### 5.1 å¤§å­¦è¯¾ç¨‹æ˜ å°„

| è¯¾ç¨‹ | ç›¸å…³ç« èŠ‚ |
|------|---------|
| **MIT 6.046J ç®—æ³•è®¾è®¡ä¸åˆ†æ** | Work-Span æ¨¡å‹ï¼Œå¹¶è¡Œæ’åº |
| **CMU 15-418 å¹¶è¡Œè®¡ç®—æœºæ¶æ„ä¸ç¼–ç¨‹** | Work-Stealing, PRAM |
| **Stanford CS149 å¹¶è¡Œè®¡ç®—** | è°ƒåº¦ç†è®ºï¼ŒçŸ©é˜µä¹˜æ³• |
| **UC Berkeley CS267 é«˜æ€§èƒ½è®¡ç®—** | å¹¶è¡ŒBFSï¼Œå‰ç¼€å’Œ |
| **UIUC CS420 å¹¶è¡Œç¼–ç¨‹** | Cilk, OpenMP |

### 5.2 æ•™æå¯¹åº”

| æ•™æ | ç›¸å…³ç« èŠ‚ |
|------|---------|
| **CLRS** (Introduction to Algorithms) | Ch 27 (Multithreaded Algorithms) |
| **JaJa "Introduction to Parallel Algorithms"** | PRAM æ¨¡å‹ï¼Œå‰ç¼€å’Œ |
| **Blelloch "Programming Parallel Algorithms"** | Scan, Work-Span |
| **Herlihy & Shavit "The Art of Multiprocessor Programming"** | å¹¶å‘æ•°æ®ç»“æ„ |

---

## 6. å·¥å…·ä¸ç”Ÿæ€

### 6.1 å¹¶è¡Œç¼–ç¨‹æ¡†æ¶

| æ¡†æ¶ | è¯­è¨€ | ç‰¹ç‚¹ | Work-Stealing |
|------|------|------|---------------|
| **Cilk Plus** | C/C++ | `spawn/sync`ï¼Œç¼–è¯‘å™¨å†…ç½® | âœ… |
| **Rayon** | Rust | æ•°æ®å¹¶è¡Œï¼Œ`par_iter` | âœ… |
| **OpenMP** | C/C++/Fortran | `#pragma omp parallel for` | âš ï¸ ä¾èµ–å®ç° |
| **TBB** | C++ | Intel çº¿ç¨‹æ„å»ºå— | âœ… |
| **Go** | Go | `goroutine`ï¼ŒCSPæ¨¡å‹ | âš ï¸ M:N è°ƒåº¦ |

### 6.2 å½¢å¼åŒ–å·¥å…·

| å·¥å…· | ç”¨é€” | ç¤ºä¾‹ |
|------|------|------|
| **Coq** | Work-Span è¯æ˜ | Â§3.2 |
| **Isabelle/HOL** | è°ƒåº¦ç®—æ³•éªŒè¯ | - |
| **CIVL** | å¹¶å‘ç¨‹åºéªŒè¯ | MPI ç¨‹åºéªŒè¯ |

---

## 7. é«˜çº§ä¸»é¢˜

### 7.1 Cache-Oblivious å¹¶è¡Œç®—æ³•

**å®šä¹‰**ï¼š

```text
Cache-Oblivious ç®—æ³•ï¼š
  - ä¸çŸ¥é“ç¼“å­˜å¤§å° Z å’Œç¼“å­˜è¡Œå¤§å° L
  - è‡ªåŠ¨é€‚åº”ä»»ä½•å†…å­˜å±‚æ¬¡ç»“æ„

å¹¶è¡Œ + Cache-Obliviousï¼š
  - æ—¢è¦å¹¶è¡Œé«˜æ•ˆï¼ˆä½ Spanï¼‰
  - åˆè¦ç¼“å­˜é«˜æ•ˆï¼ˆä½ Cache Missï¼‰
```

**ç¤ºä¾‹**ï¼šçŸ©é˜µè½¬ç½®

```pseudocode
parallel_transpose(A[nÃ—n]):
  if n <= base_case:
    for i, j: B[j][i] = A[i][j]
    return
  
  spawn parallel_transpose(A[0:n/2, 0:n/2])
  spawn parallel_transpose(A[0:n/2, n/2:n])
  spawn parallel_transpose(A[n/2:n, 0:n/2])
  spawn parallel_transpose(A[n/2:n, n/2:n])
  sync
```

**å¤æ‚åº¦**ï¼š

```text
Workï¼šO(nÂ²)
Spanï¼šO(log n)
Cache Missï¼šO(nÂ² / L + nÂ² / âˆšZ)  ï¼ˆæœ€ä¼˜ï¼‰
```

### 7.2 å¤–éƒ¨å­˜å‚¨å¹¶è¡Œç®—æ³•

**PDEM æ¨¡å‹**ï¼ˆParallel Disk External Memoryï¼‰ï¼š

```text
å‚æ•°ï¼š
  P : å¤„ç†å™¨æ•°é‡
  D : ç£ç›˜æ•°é‡
  M : å†…å­˜å¤§å°ï¼ˆæ¯ä¸ªå¤„ç†å™¨ï¼‰
  B : ç£ç›˜å—å¤§å°

å¹¶è¡Œæ’åºï¼ˆPDEMï¼‰ï¼š
  T_I/O = O((N / (PDB)) log_{M/B} (N / P))
  T_CPU = O((N / P) log N)
```

### 7.3 é‡å­å¹¶è¡Œç®—æ³•

**Grover æœç´¢**ï¼š

```text
ç»å…¸å¹¶è¡Œï¼š
  Workï¼šO(N)
  Spanï¼šO(N / P)

é‡å­ï¼š
  Workï¼šO(âˆšN)
  Spanï¼šO(âˆšN)  ï¼ˆæœ¬è´¨ä¸²è¡Œï¼‰

é‡å­ + ç»å…¸å¹¶è¡Œï¼š
  ä½¿ç”¨ P ä¸ªé‡å­è®¡ç®—æœºå¹¶è¡Œæœç´¢ï¼š
  Spanï¼šO(âˆš(N / P))
```

---

## 8. æ‰©å±•é˜…è¯»

### 8.1 å­¦æœ¯è®ºæ–‡

1. **Work-Stealing**: Blumofe & Leiserson. "Scheduling Multithreaded Computations by Work Stealing." JACM 1999.
2. **Scan**: Blelloch, G. "Prefix Sums and Their Applications." CMU Tech Report 1990.
3. **PRAM**: JaJa, J. "An Introduction to Parallel Algorithms." 1992.

### 8.2 åœ¨çº¿èµ„æº

- **å¹¶è¡Œç®—æ³•æ•™ç¨‹**ï¼š<http://www.cs.cmu.edu/~scandal/nesl.html>
- **Work-Span åˆ†æ**ï¼š<https://ocw.mit.edu/courses/6-046j-design-and-analysis-of-algorithms-spring-2015/>

### 8.3 æœ¬åœ°é¡¹ç›®å¼•ç”¨

- **ç®—æ³•å¤æ‚åº¦**ï¼š[./03.1_Multidimensional_Complexity.md](./03.1_Multidimensional_Complexity.md)
- **ä¸‹ç•ŒæŠ€æœ¯**ï¼š[./03.3_Lower_Bound_Techniques.md](./03.3_Lower_Bound_Techniques.md)
- **å¹¶å‘æ¨¡å‹**ï¼š[../../FormalLanguage_Perspective/05_Computational_Models/](../../FormalLanguage_Perspective/05_Computational_Models/)

---

## é™„å½• Aï¼šWikipedia æ¦‚å¿µå¯¹ç…§

| æ¦‚å¿µ | Wikipedia æ¡ç›® | æœ¬æ–‡ç« èŠ‚ |
|------|---------------|----------|
| Parallel Algorithm | <https://en.wikipedia.org/wiki/Parallel_algorithm> | Â§1 |
| PRAM | <https://en.wikipedia.org/wiki/Parallel_random-access_machine> | Â§1.1 |
| Work-Span Model | <https://en.wikipedia.org/wiki/Analysis_of_parallel_algorithms> | Â§1.2 |
| Work Stealing | <https://en.wikipedia.org/wiki/Work_stealing> | Â§3.1 |
| Parallel Prefix | <https://en.wikipedia.org/wiki/Prefix_sum> | Â§2.2 |

---

**ç‰ˆæœ¬**ï¼šv1.0  
**æœ€åæ›´æ–°**ï¼š2025-10-29  
**ç»´æŠ¤è€…**ï¼šFormalScience Project  
**è®¸å¯**ï¼šMIT
