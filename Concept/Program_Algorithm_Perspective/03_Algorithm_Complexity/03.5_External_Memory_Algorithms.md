# å¤–éƒ¨å­˜å‚¨ç®—æ³•ä¸ I/O å¤æ‚åº¦

## ğŸ“š ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [1. I/O æ¨¡å‹ä¸å¤æ‚åº¦](#1-io-æ¨¡å‹ä¸å¤æ‚åº¦)
  - [1.1 DAM æ¨¡å‹ï¼ˆDisk Access Machineï¼‰](#11-dam-æ¨¡å‹disk-access-machine)
  - [1.2 Cache-Oblivious æ¨¡å‹](#12-cache-oblivious-æ¨¡å‹)
- [2. ç»å…¸å¤–éƒ¨å­˜å‚¨ç®—æ³•](#2-ç»å…¸å¤–éƒ¨å­˜å‚¨ç®—æ³•)
  - [2.1 å¤–éƒ¨å½’å¹¶æ’åºï¼ˆExternal Merge Sortï¼‰](#21-å¤–éƒ¨å½’å¹¶æ’åºexternal-merge-sort)
  - [2.2 å¤–éƒ¨å“ˆå¸Œï¼ˆExternal Hashingï¼‰](#22-å¤–éƒ¨å“ˆå¸Œexternal-hashing)
  - [2.3 B-æ ‘ï¼ˆB-Treeï¼‰](#23-b-æ ‘b-tree)
- [3. Cache-Oblivious ç®—æ³•](#3-cache-oblivious-ç®—æ³•)
  - [3.1 Funnelsortï¼ˆæ¼æ–—æ’åºï¼‰](#31-funnelsortæ¼æ–—æ’åº)
  - [3.2 Cache-Oblivious B-Tree](#32-cache-oblivious-b-tree)
  - [3.3 Matrix Transposeï¼ˆçŸ©é˜µè½¬ç½®ï¼‰](#33-matrix-transposeçŸ©é˜µè½¬ç½®)
- [4. I/O å¤æ‚åº¦ä¸‹ç•Œ](#4-io-å¤æ‚åº¦ä¸‹ç•Œ)
  - [4.1 æ’åºä¸‹ç•Œ](#41-æ’åºä¸‹ç•Œ)
  - [4.2 çŸ©é˜µä¹˜æ³•ä¸‹ç•Œ](#42-çŸ©é˜µä¹˜æ³•ä¸‹ç•Œ)
- [5. å®é™…ç³»ç»Ÿä¸­çš„åº”ç”¨](#5-å®é™…ç³»ç»Ÿä¸­çš„åº”ç”¨)
  - [5.1 æ•°æ®åº“æ’åº](#51-æ•°æ®åº“æ’åº)
  - [5.2 MapReduce](#52-mapreduce)
  - [5.3 å¤§è§„æ¨¡å›¾ç®—æ³•](#53-å¤§è§„æ¨¡å›¾ç®—æ³•)
- [6. å·¥å…·ä¸å®ç°](#6-å·¥å…·ä¸å®ç°)
  - [6.1 STXXLï¼ˆC++ å¤–éƒ¨å­˜å‚¨åº“ï¼‰](#61-stxxlc-å¤–éƒ¨å­˜å‚¨åº“)
  - [6.2 Spark å¤–éƒ¨æ’åº](#62-spark-å¤–éƒ¨æ’åº)
- [7. æ€§èƒ½åˆ†æ](#7-æ€§èƒ½åˆ†æ)
  - [7.1 ç†è®º vs å®è·µ](#71-ç†è®º-vs-å®è·µ)
  - [7.2 SSD vs HDD](#72-ssd-vs-hdd)
- [8. å¤§å­¦è¯¾ç¨‹å¯¹åº”](#8-å¤§å­¦è¯¾ç¨‹å¯¹åº”)
- [9. æ•™æä¸è®ºæ–‡](#9-æ•™æä¸è®ºæ–‡)
- [10. æœ¬åœ°é¡¹ç›®å¼•ç”¨](#10-æœ¬åœ°é¡¹ç›®å¼•ç”¨)

---

## æ¦‚è¿°

**å¤–éƒ¨å­˜å‚¨ç®—æ³•**ï¼ˆExternal Memory Algorithmsï¼‰æ˜¯é’ˆå¯¹**æ•°æ®é‡è¿œè¶…å†…å­˜**çš„åœºæ™¯è®¾è®¡çš„ç®—æ³•ï¼Œæ ¸å¿ƒç›®æ ‡æ˜¯**æœ€å°åŒ–ç£ç›˜ I/O æ¬¡æ•°**ã€‚

**æ ¸å¿ƒæ€æƒ³**ï¼š

```text
å¤–éƒ¨å­˜å‚¨æ¨¡å‹ï¼ˆEM æ¨¡å‹ï¼‰ï¼š

å‚æ•°ï¼š
  N: æ•°æ®å…ƒç´ æ€»æ•°
  M: å†…å­˜å¤§å°ï¼ˆå…ƒç´ æ•°ï¼‰
  B: ç£ç›˜å—å¤§å°ï¼ˆå…ƒç´ æ•°ï¼‰

å‡è®¾ï¼šN >> M >> B

æˆæœ¬ï¼š
  - å†…å­˜æ“ä½œï¼šå…è´¹ï¼ˆO(1)ï¼‰
  - ç£ç›˜ I/Oï¼šæ˜‚è´µï¼ˆä¸»å¯¼æˆæœ¬ï¼‰

ç›®æ ‡ï¼šæœ€å°åŒ– I/O æ¬¡æ•°
```

**ç°å®æ„ä¹‰**ï¼š

| å­˜å‚¨å±‚çº§ | å»¶è¿Ÿ | å®¹é‡ | å¸¦å®½ |
|----------|------|------|------|
| L1 Cache | 1 ns | 32 KB | 1 TB/s |
| L2 Cache | 3 ns | 256 KB | 500 GB/s |
| L3 Cache | 12 ns | 8 MB | 100 GB/s |
| DRAM | 100 ns | 16 GB | 20 GB/s |
| SSD | 100 Î¼s | 1 TB | 500 MB/s |
| HDD | 10 ms | 4 TB | 150 MB/s |

**ç›¸å¯¹é€Ÿåº¦**ï¼šå†…å­˜æ¯” SSD å¿« **1000x**ï¼Œæ¯” HDD å¿« **100,000x**

---

## 1. I/O æ¨¡å‹ä¸å¤æ‚åº¦

### 1.1 DAM æ¨¡å‹ï¼ˆDisk Access Machineï¼‰

**å‚æ•°**ï¼š

```text
N: é—®é¢˜è§„æ¨¡ï¼ˆå…ƒç´ æ•°ï¼‰
M: å†…å­˜å¤§å°ï¼ˆå…ƒç´ æ•°ï¼‰
B: å—å¤§å°ï¼ˆå…ƒç´ æ•°ï¼‰

å‡è®¾ï¼š1 â‰¤ B â‰¤ M/2 â‰¤ N
```

**I/O å¤æ‚åº¦è®°å·**ï¼š

```text
Scan(N) = Î˜(N/B)              # æ‰«æ N ä¸ªå…ƒç´ 
Sort(N) = Î˜((N/B) log_{M/B}(N/B))  # æ’åº
Search(N) = Î˜(log_B N)         # B-æ ‘æŸ¥æ‰¾
```

**ä¸‹ç•Œ**ï¼ˆä¿¡æ¯è®ºï¼‰ï¼š

```text
æ’åºä¸‹ç•Œï¼šÎ©((N/B) log_{M/B}(N/B)) I/Os
åŸå› ï¼š
  - æ¯æ¬¡ I/O æœ€å¤šè¯» M ä¸ªå…ƒç´ 
  - éœ€è¦ log_{M/B}(N/M) è½®å½’å¹¶
```

### 1.2 Cache-Oblivious æ¨¡å‹

**ç‰¹ç‚¹**ï¼šç®—æ³•**ä¸çŸ¥é“** M å’Œ B çš„å€¼ï¼Œä½†åœ¨æ‰€æœ‰å±‚çº§éƒ½ä¼˜åŒ–

**ä¼˜åŠ¿**ï¼š

- è‡ªåŠ¨é€‚åº”æ‰€æœ‰ç¼“å­˜å±‚çº§ï¼ˆL1, L2, L3, DRAMï¼‰
- æ— éœ€æ‰‹å·¥è°ƒä¼˜
- å¯ç§»æ¤æ€§å¼º

**å…¸å‹ç®—æ³•**ï¼š

- Funnelsortï¼ˆæ¼æ–—æ’åºï¼‰
- Cache-oblivious B-tree
- Van Emde Boas å¸ƒå±€

---

## 2. ç»å…¸å¤–éƒ¨å­˜å‚¨ç®—æ³•

### 2.1 å¤–éƒ¨å½’å¹¶æ’åºï¼ˆExternal Merge Sortï¼‰

**ç®—æ³•**ï¼š

```text
Phase 1: åˆå§‹å½’å¹¶æ®µç”Ÿæˆ
  - è¯» M ä¸ªå…ƒç´ åˆ°å†…å­˜
  - å†…éƒ¨æ’åºï¼ˆQuickSort/HeapSortï¼‰
  - å†™å›ç£ç›˜
  - é‡å¤ç›´åˆ°æ‰€æœ‰æ•°æ®å¤„ç†å®Œ
  â†’ ç”Ÿæˆ âŒˆN/MâŒ‰ ä¸ªæœ‰åºæ®µ

Phase 2: K-è·¯å½’å¹¶
  - K = M/Bï¼ˆæ¯è·¯å  B ä¸ªç¼“å†²åŒºï¼‰
  - æ¯è½®å½’å¹¶ K ä¸ªæ®µ
  - é‡å¤ log_K(N/M) è½®
```

**I/O å¤æ‚åº¦**ï¼š

```text
Phase 1: 2Â·(N/B)             # è¯» + å†™
Phase 2: 2Â·(N/B)Â·log_{M/B}(N/M)  # æ¯è½®è¯»å†™

æ€»è®¡ï¼šÎ˜((N/B)Â·log_{M/B}(N/B)) I/Os
```

**ç¤ºä¾‹**ï¼š

```text
N = 1,000,000,000 å…ƒç´ ï¼ˆ4 GBï¼‰
M = 100,000,000 å…ƒç´ ï¼ˆ400 MBï¼‰
B = 10,000 å…ƒç´ ï¼ˆ40 KBï¼‰

Phase 1: 10 ä¸ªåˆå§‹æ®µ
Phase 2: å½’å¹¶è½®æ•° = log_{10,000}(10) â‰ˆ 1
æ€» I/O: 2Â·(100,000) + 2Â·(100,000) = 400,000 æ¬¡
```

### 2.2 å¤–éƒ¨å“ˆå¸Œï¼ˆExternal Hashingï¼‰

**Phase 1ï¼šåˆ†åŒº**:

```text
for each record r in input:
  h = hash(r.key) mod P  # P = åˆ†åŒºæ•°
  write r to partition[h]

é€‰æ‹© P = M/Bï¼Œç¡®ä¿æ¯ä¸ªåˆ†åŒº â‰¤ M
```

**Phase 2ï¼šå†…å­˜å“ˆå¸Œ**:

```text
for each partition p:
  load p into memory
  build in-memory hash table
  process queries/joins
```

**I/O å¤æ‚åº¦**ï¼š

```text
åˆ†åŒºé˜¶æ®µï¼š2Â·(N/B)   # è¯» + å†™
å¤„ç†é˜¶æ®µï¼š(N/B)     # è¯»
æ€»è®¡ï¼š3Â·(N/B) I/Os
```

**Grace Hash Join**ï¼ˆæ•°æ®åº“ç»å…¸ç®—æ³•ï¼‰ï¼š

```text
Join(R, S):
  # Phase 1: åˆ†åŒº
  Partition R into R_1, ..., R_P
  Partition S into S_1, ..., S_P
  
  # Phase 2: å†…å­˜ Join
  for i = 1 to P:
    load R_i into hash table
    for each s in S_i:
      probe hash table
      output matches
```

### 2.3 B-æ ‘ï¼ˆB-Treeï¼‰

**ç»“æ„**ï¼š

```text
é˜¶æ•°ï¼št = Î˜(B)
æ¯ä¸ªèŠ‚ç‚¹ï¼št-1 åˆ° 2t-1 ä¸ªé”®
é«˜åº¦ï¼šh = Î˜(log_B N)

æ’å…¥/åˆ é™¤/æŸ¥æ‰¾ï¼šO(log_B N) I/Os
```

**B+ æ ‘ä¼˜åŒ–**ï¼š

- å¶å­èŠ‚ç‚¹é“¾æ¥ï¼ˆèŒƒå›´æŸ¥è¯¢å‹å¥½ï¼‰
- å†…éƒ¨èŠ‚ç‚¹åªå­˜é”®ï¼ˆæ›´é«˜æ‰‡å‡ºï¼‰

**å½¢å¼åŒ–å®šä¹‰**ï¼ˆCoqï¼‰ï¼š

```coq
Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.
Import ListNotations.

Record BTree : Type := mkBTree {
  t : nat;                      (* æœ€å°åº¦æ•° *)
  root : BNode;
}.

Inductive BNode : Type :=
  | Leaf : list (Z * Z) -> BNode           (* é”®å€¼å¯¹ *)
  | Internal : list Z -> list BNode -> BNode.  (* é”® + å­èŠ‚ç‚¹ *)

(* ä¸å˜å¼ *)
Definition btree_invariant (tree : BTree) : Prop :=
  let t := tree.(t) in
  (t >= 2) /\
  (forall node : BNode, 
    match node with
    | Internal keys children =>
        (length keys >= t - 1) /\
        (length keys <= 2*t - 1) /\
        (length children = length keys + 1)
    | Leaf pairs =>
        (length pairs >= t - 1) /\
        (length pairs <= 2*t - 1)
    end).
```

**æŸ¥æ‰¾å®šç†**ï¼š

```coq
Theorem btree_search_io:
  forall (tree : BTree) (key : Z),
    btree_invariant tree ->
    let h := height tree in
    io_cost (search tree key) = O (log (B tree) (size tree)).
```

---

## 3. Cache-Oblivious ç®—æ³•

### 3.1 Funnelsortï¼ˆæ¼æ–—æ’åºï¼‰

**æ€æƒ³**ï¼šé€’å½’çš„ K-è·¯å½’å¹¶ï¼ŒK è‡ªåŠ¨é€‚åº”ç¼“å­˜å¤§å°

**ç»“æ„**ï¼š

```text
Funnel(N):
  if N â‰¤ M:
    sort in memory
  else:
    åˆ†æˆ âˆšN ä¸ªå­æ•°ç»„
    é€’å½’æ’åºæ¯ä¸ªå­æ•°ç»„
    ç”¨ âˆšN-è·¯ Funnel å½’å¹¶
```

**I/O å¤æ‚åº¦**ï¼ˆcache-obliviousï¼‰ï¼š

```text
Î˜((N/B) log_{M/B}(N/B)) I/Os
ï¼ˆä¸ optimal external sort ç›¸åŒï¼‰
```

**ä¼˜åŠ¿**ï¼š

- æ— éœ€çŸ¥é“ M, B
- è‡ªåŠ¨é€‚åº”æ‰€æœ‰ç¼“å­˜å±‚çº§

### 3.2 Cache-Oblivious B-Tree

**Van Emde Boas å¸ƒå±€**ï¼š

```text
é€’å½’å¸ƒå±€ï¼š
  - å°†æ ‘åˆ†æˆé«˜åº¦ h/2 çš„å­æ ‘
  - å­æ ‘æ ¹èŠ‚ç‚¹è¿ç»­å­˜å‚¨
  - é€’å½’å¯¹æ¯ä¸ªå­æ ‘åº”ç”¨
```

**ç¤ºä¾‹**ï¼ˆ16 èŠ‚ç‚¹æ ‘ï¼‰ï¼š

```text
ä¼ ç»Ÿ BFS å¸ƒå±€ï¼š[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]

VEB å¸ƒå±€ï¼š
  å±‚ 1-2: [0,1,2]
  å±‚ 3: [3,4,5,6]
  é€’å½’å­æ ‘ 1: [7,8,9]
  é€’å½’å­æ ‘ 2: [10,11,12]
  ...
```

**I/O å¤æ‚åº¦**ï¼š

```text
æŸ¥æ‰¾ï¼šO(log_B N) I/Os
æ’å…¥/åˆ é™¤ï¼šO((log_B N)^2 / B) I/Osï¼ˆæ‘Šé”€ï¼‰
```

### 3.3 Matrix Transposeï¼ˆçŸ©é˜µè½¬ç½®ï¼‰

**Cache-Oblivious ç®—æ³•**ï¼š

```text
Transpose(A, n):
  if n == 1:
    return A
  else:
    åˆ†æˆ 4 ä¸ª n/2 Ã— n/2 å­çŸ©é˜µï¼š
      [A11 A12]
      [A21 A22]
    é€’å½’è½¬ç½®ï¼š
      Transpose(A11)
      Transpose(A22)
      Swap(A12, A21)
```

**I/O å¤æ‚åº¦**ï¼š

```text
Î˜(n^2 / B) I/Osï¼ˆoptimalï¼‰
```

**å¯¹æ¯”**ï¼š

- è¡Œä¼˜å…ˆéå†ï¼šÎ˜(n^2) I/Osï¼ˆæœ€å·®ï¼‰
- åˆ†å—ç®—æ³•ï¼šéœ€è¦çŸ¥é“ B

---

## 4. I/O å¤æ‚åº¦ä¸‹ç•Œ

### 4.1 æ’åºä¸‹ç•Œ

**å®šç†**ï¼š

```text
ä»»ä½•åŸºäºæ¯”è¾ƒçš„å¤–éƒ¨æ’åºç®—æ³•éœ€è¦è‡³å°‘
Î©((N/B) log_{M/B}(N/B)) I/Os
```

**è¯æ˜**ï¼ˆä¿¡æ¯è®ºï¼‰ï¼š

```text
1. å…±æœ‰ N! ç§æ’åˆ—
2. æ¯æ¬¡ I/O æœ€å¤šè¯» M ä¸ªå…ƒç´ 
3. æ¯è½®å½’å¹¶æœ€å¤šåˆå¹¶ M/B ä¸ªæ®µ
4. éœ€è¦ log_{M/B}(N/M) è½®
5. æ¯è½® I/Oï¼š2N/Bï¼ˆè¯» + å†™ï¼‰
6. æ€»è®¡ï¼šÎ˜((N/B) log_{M/B}(N/B))
```

**Lean4 å½¢å¼åŒ–**ï¼š

```lean
import Mathlib.Data.Real.Basic
import Mathlib.Data.Nat.Log

theorem external_sort_lower_bound (N M B : â„•) 
  (h1 : B â‰¤ M / 2) 
  (h2 : M â‰¤ N) :
  âˆ€ (alg : SortAlgorithm),
    io_cost alg â‰¥ (N / B) * (Nat.log (M / B) (N / B)) := by
  intro alg
  -- ä¿¡æ¯è®ºè®ºè¯
  have h_permutations : num_permutations N = N.factorial := rfl
  have h_io_per_round : io_per_round â‰¤ M / B := by sorry
  have h_rounds : rounds â‰¥ Nat.log (M / B) (N / M) := by sorry
  -- ç»„åˆè¯æ˜
  sorry
```

### 4.2 çŸ©é˜µä¹˜æ³•ä¸‹ç•Œ

**å®šç†**ï¼š

```text
n Ã— n çŸ©é˜µä¹˜æ³•éœ€è¦è‡³å°‘
Î©(n^3 / BâˆšM) I/Os
```

**è¯æ˜è‰å›¾**ï¼š

```text
1. è¾“å‡ºçŸ©é˜µ n^2 ä¸ªå…ƒç´ 
2. æ¯ä¸ªå…ƒç´ éœ€è¦ n æ¬¡ä¹˜åŠ 
3. æœ€ä¼˜åˆ†å—ï¼šæ¯æ¬¡åŠ è½½ âˆšM Ã— âˆšM å­çŸ©é˜µ
4. å­çŸ©é˜µæ•°ï¼š(n/âˆšM)^2
5. æ€» I/Oï¼š(n/âˆšM)^2 Â· (n^2/B) = n^3 / (BâˆšM)
```

---

## 5. å®é™…ç³»ç»Ÿä¸­çš„åº”ç”¨

### 5.1 æ•°æ®åº“æ’åº

**PostgreSQL External Sort**ï¼š

```c
typedef struct Tuplesortstate {
    int64 memtupsize;      // å†…å­˜ä¸­å…ƒç»„æ•°
    SortTuple *memtuples;  // å†…å­˜å…ƒç»„æ•°ç»„
    LogicalTapeSet *tapeset;  // å¤–éƒ¨ç£ç›˜å¸¦
    int maxTapes;          // å½’å¹¶è·¯æ•°
    int currentRun;        // å½“å‰å½’å¹¶æ®µ
} Tuplesortstate;
```

**å…³é”®ä¼˜åŒ–**ï¼š

- **æ›¿æ¢é€‰æ‹©**ï¼ˆReplacement Selectionï¼‰ï¼šç”Ÿæˆæ›´é•¿çš„åˆå§‹æ®µ
- **é¢„è¯»**ï¼ˆPrefetchingï¼‰ï¼šå¼‚æ­¥ I/O
- **å‹ç¼©**ï¼ˆCompressionï¼‰ï¼šå‡å°‘ I/O é‡

### 5.2 MapReduce

**Shuffle é˜¶æ®µ**ï¼ˆå¤–éƒ¨æ’åºï¼‰ï¼š

```text
Map:
  for each record:
    emit(partition(key), (key, value))
  
  sort in-memory buffer
  spill to disk when full
  
Merge:
  K-way merge of spill files
  
Reduce:
  read sorted data
  apply reduce function
```

**Hadoop TeraSort**ï¼ˆTB çº§æ’åºï¼‰ï¼š

- é‡‡æ ·é”®åˆ†å¸ƒï¼ˆSamplerï¼‰
- åˆ†åŒºä¿è¯è´Ÿè½½å‡è¡¡
- å¤–éƒ¨å½’å¹¶ï¼ˆK=100ï¼‰

### 5.3 å¤§è§„æ¨¡å›¾ç®—æ³•

**é—®é¢˜**ï¼šç¤¾äº¤ç½‘ç»œå›¾æ— æ³•è½½å…¥å†…å­˜

**è§£å†³æ–¹æ¡ˆ**ï¼šGraphChiï¼ˆå•æœºå¤–éƒ¨å­˜å‚¨å›¾ï¼‰

**ç®—æ³•**ï¼ˆParallel Sliding Windowsï¼‰ï¼š

```text
1. å°†å›¾æŒ‰é¡¶ç‚¹åˆ†æˆ P ä¸ªåˆ†ç‰‡
2. æ¯è½®ï¼š
   - åŠ è½½ä¸€ä¸ªåˆ†ç‰‡çš„æ‰€æœ‰è¾¹ï¼ˆé¡ºåº I/Oï¼‰
   - æ›´æ–°å†…å­˜ä¸­çš„é¡¶ç‚¹æ•°æ®
   - å†™å›æ›´æ–°
3. é‡å¤ P è½®
```

**I/O å¤æ‚åº¦**ï¼š

```text
Î˜(P Â· (|V| + |E|)/B) I/Os
å…¶ä¸­ P = âŒˆ(|V| + |E|)/MâŒ‰
```

---

## 6. å·¥å…·ä¸å®ç°

### 6.1 STXXLï¼ˆC++ å¤–éƒ¨å­˜å‚¨åº“ï¼‰

**å®‰è£…**ï¼š

```bash
git clone https://github.com/stxxl/stxxl.git
mkdir build && cd build
cmake .. && make
```

**ç¤ºä¾‹**ï¼ˆå¤–éƒ¨æ’åºï¼‰ï¼š

```cpp
#include <stxxl/vector>
#include <stxxl/sort>

int main() {
    typedef stxxl::VECTOR_GENERATOR<int>::result vector_type;
    vector_type v;
    
    // ç”Ÿæˆ 10 äº¿ä¸ªéšæœºæ•°
    for (size_t i = 0; i < 1000000000; ++i) {
        v.push_back(rand());
    }
    
    // å¤–éƒ¨æ’åº
    stxxl::sort(v.begin(), v.end(), std::less<int>());
    
    // éªŒè¯
    assert(stxxl::is_sorted(v.begin(), v.end()));
    return 0;
}
```

**ç‰¹æ€§**ï¼š

- è‡ªåŠ¨ç®¡ç†ç£ç›˜æ–‡ä»¶
- å¼‚æ­¥ I/O
- æ”¯æŒ vector, map, queue, priority_queue

### 6.2 Spark å¤–éƒ¨æ’åº

**é…ç½®**ï¼š

```scala
val conf = new SparkConf()
  .set("spark.shuffle.spill.compress", "true")
  .set("spark.shuffle.sort.bypassMergeThreshold", "200")

val rdd = sc.parallelize(1 to 1e9.toInt)
val sorted = rdd.sortBy(identity)
```

**å†…éƒ¨å®ç°**ï¼š

- **ExternalSorter**ï¼šå†…å­˜ + ç£ç›˜æ··åˆæ’åº
- **ShuffleBlockResolver**ï¼šç®¡ç†æº¢å†™æ–‡ä»¶
- **TimSort**ï¼šåˆ©ç”¨éƒ¨åˆ†æœ‰åºæ€§

---

## 7. æ€§èƒ½åˆ†æ

### 7.1 ç†è®º vs å®è·µ

**ç¤ºä¾‹**ï¼šæ’åº 1TB æ•°æ®ï¼ˆ250M æ•´æ•°ï¼‰

| ç®—æ³• | ç†è®º I/O | å®é™…æ—¶é—´ | è¯´æ˜ |
|------|----------|----------|------|
| **QuickSortï¼ˆå†…å­˜ï¼‰** | 0 | æ— æ³•è¿è¡Œ | å†…å­˜ä¸è¶³ |
| **Naive å¤–éƒ¨æ’åº** | 2e9 | 10 å°æ—¶ | å•è·¯å½’å¹¶ |
| **K-è·¯å½’å¹¶ (K=1000)** | 2e7 | 30 åˆ†é’Ÿ | ç¬¦åˆç†è®º |
| **STXXL** | 2e7 | 20 åˆ†é’Ÿ | å¼‚æ­¥ I/O ä¼˜åŒ– |
| **Hadoop TeraSort** | 2e7 | 10 åˆ†é’Ÿ | åˆ†å¸ƒå¼å¹¶è¡Œ |

**å®é™…å¼€é”€**ï¼š

- ç£ç›˜å¯»é“ï¼ˆHDDï¼‰ï¼šéšæœº I/O æ…¢ 100x
- ç½‘ç»œä¼ è¾“ï¼ˆåˆ†å¸ƒå¼ï¼‰ï¼šé¢å¤–å¼€é”€
- CPUï¼ˆå‹ç¼©/è§£å‹ï¼‰ï¼šæƒè¡¡ I/O vs è®¡ç®—

### 7.2 SSD vs HDD

**I/O ç‰¹æ€§å¯¹æ¯”**ï¼š

| ç»´åº¦ | HDD | SSD |
|------|-----|-----|
| **é¡ºåºè¯»** | 150 MB/s | 500 MB/s |
| **éšæœºè¯»ï¼ˆ4Kï¼‰** | 0.5 MB/s | 300 MB/s |
| **å»¶è¿Ÿ** | 10 ms | 100 Î¼s |
| **IOPS** | 100 | 100,000 |

**ç®—æ³•å½±å“**ï¼š

- **HDD**ï¼šé¡ºåº I/O ä¼˜å…ˆï¼ˆå¤–éƒ¨å½’å¹¶ä¼˜åŠ¿æ˜æ˜¾ï¼‰
- **SSD**ï¼šéšæœº I/O å¯æ¥å—ï¼ˆB-æ ‘æ›´å®ç”¨ï¼‰

---

## 8. å¤§å­¦è¯¾ç¨‹å¯¹åº”

| è¯¾ç¨‹ | ç›¸å…³ç« èŠ‚ |
|------|----------|
| **MIT 6.851 é«˜çº§æ•°æ®ç»“æ„** | Cache-oblivious ç®—æ³• |
| **CMU 15-826 æ•°æ®åº“å®ç°** | å¤–éƒ¨æ’åºã€å“ˆå¸Œ Join |
| **Berkeley CS 267 å¹¶è¡Œç®—æ³•** | I/O å¤æ‚åº¦ã€å¤–éƒ¨å­˜å‚¨å¹¶è¡Œç®—æ³• |
| **ETHZ Big Data** | MapReduce, Spark shuffle |

---

## 9. æ•™æä¸è®ºæ–‡

### æ ¸å¿ƒè®ºæ–‡

1. **EM æ¨¡å‹**ï¼š
   - Aggarwal, A., & Vitter, J. S. (1988). *The input/output complexity of sorting and related problems*. CACM 31(9).

2. **Cache-Oblivious**ï¼š
   - Frigo, M., et al. (1999). *Cache-oblivious algorithms*. FOCS 1999.

3. **Funnelsort**ï¼š
   - Brodal, G. S., & Fagerberg, R. (2002). *Cache-oblivious distribution sweeping*. ICALP 2002.

### æ¨èæ•™æ

- *Algorithms and Data Structures for External Memory* (Vitter, 2008)
- *Database Management Systems* (Ramakrishnan & Gehrke) - Chapter 13

---

## å¿«é€Ÿå‚è€ƒ

### æ ¸å¿ƒå…¬å¼

```text
I/O æ¨¡å‹å‚æ•°ï¼š
  N: æ•°æ®è§„æ¨¡
  M: å†…å­˜å¤§å°
  B: å—å¤§å°

åŸºç¡€æ“ä½œï¼š
  Scan(N) = Î˜(N/B)
  Sort(N) = Î˜((N/B) log_{M/B}(N/B))
  Search(N) = Î˜(log_B N)

æ’åºä¸‹ç•Œï¼š
  Î©((N/B) log_{M/B}(N/B)) I/Os
  
çŸ©é˜µä¹˜æ³•ï¼š
  Î˜(n^3 / (BâˆšM)) I/Os
```

### ç®—æ³•é€‰æ‹©

```text
æ’åºï¼š
  - å°æ•°æ®ï¼ˆ< 1GBï¼‰ï¼šå†…å­˜å¿«æ’
  - ä¸­æ•°æ®ï¼ˆ1-100GBï¼‰ï¼šå¤–éƒ¨å½’å¹¶
  - å¤§æ•°æ®ï¼ˆ> 100GBï¼‰ï¼šåˆ†å¸ƒå¼ TeraSort

æŸ¥æ‰¾ï¼š
  - HDDï¼šB-æ ‘ï¼ˆé¡ºåºå‹å¥½ï¼‰
  - SSDï¼šå“ˆå¸Œè¡¨ï¼ˆéšæœº I/O å¿«ï¼‰
  - å†…å­˜ï¼šçº¢é»‘æ ‘

Joinï¼š
  - å°è¡¨ï¼šå†…å­˜å“ˆå¸Œ Join
  - å¤§è¡¨ï¼šå¤–éƒ¨å“ˆå¸Œ Join
  - è¶…å¤§è¡¨ï¼šMapReduce Join
```

### å®æˆ˜å»ºè®®

1. **ä¼˜å…ˆé¡ºåº I/O**ï¼šHDD ä¸Šéšæœº I/O æ…¢ 200x
2. **åˆ©ç”¨é¢„è¯»**ï¼šæ“ä½œç³»ç»Ÿé¢„è¯» 128KB å—
3. **å‹ç¼©æƒè¡¡**ï¼šCPU æ¢ I/Oï¼ˆé€šå¸¸å€¼å¾—ï¼‰
4. **ç›‘æ§å·¥å…·**ï¼š`iostat`, `iotop`ï¼ˆLinuxï¼‰

---

## é™„å½• Aï¼šWikipedia æ¦‚å¿µå¯¹ç…§

| æ¦‚å¿µ | Wikipedia æ¡ç›® | æœ¬æ–‡ç« èŠ‚ |
|------|----------------|----------|
| External Memory Algorithm | <https://en.wikipedia.org/wiki/External_memory_algorithm> | Â§1 |
| B-tree | <https://en.wikipedia.org/wiki/B-tree> | Â§2.3 |
| Cache-Oblivious Algorithm | <https://en.wikipedia.org/wiki/Cache-oblivious_algorithm> | Â§3 |
| External Sorting | <https://en.wikipedia.org/wiki/External_sorting> | Â§2.1 |
| Van Emde Boas Layout | <https://en.wikipedia.org/wiki/Van_Emde_Boas_tree> | Â§3.2 |

---

**ç‰ˆæœ¬**ï¼šv1.0  
**æœ€åæ›´æ–°**ï¼š2025-10-29  
**ç»´æŠ¤è€…**ï¼šFormalScience Project  
**è®¸å¯**ï¼šCC BY-SA 4.0
