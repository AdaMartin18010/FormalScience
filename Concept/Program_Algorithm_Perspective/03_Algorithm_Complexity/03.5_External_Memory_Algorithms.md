# 外部存储算法与 I/O 复杂度

## 📚 目录

- [概述](#概述)
- [1. I/O 模型与复杂度](#1-io-模型与复杂度)
  - [1.1 DAM 模型（Disk Access Machine）](#11-dam-模型disk-access-machine)
  - [1.2 Cache-Oblivious 模型](#12-cache-oblivious-模型)
- [2. 经典外部存储算法](#2-经典外部存储算法)
  - [2.1 外部归并排序（External Merge Sort）](#21-外部归并排序external-merge-sort)
  - [2.2 外部哈希（External Hashing）](#22-外部哈希external-hashing)
  - [2.3 B-树（B-Tree）](#23-b-树b-tree)
- [3. Cache-Oblivious 算法](#3-cache-oblivious-算法)
  - [3.1 Funnelsort（漏斗排序）](#31-funnelsort漏斗排序)
  - [3.2 Cache-Oblivious B-Tree](#32-cache-oblivious-b-tree)
  - [3.3 Matrix Transpose（矩阵转置）](#33-matrix-transpose矩阵转置)
- [4. I/O 复杂度下界](#4-io-复杂度下界)
  - [4.1 排序下界](#41-排序下界)
  - [4.2 矩阵乘法下界](#42-矩阵乘法下界)
- [5. 实际系统中的应用](#5-实际系统中的应用)
  - [5.1 数据库排序](#51-数据库排序)
  - [5.2 MapReduce](#52-mapreduce)
  - [5.3 大规模图算法](#53-大规模图算法)
- [6. 工具与实现](#6-工具与实现)
  - [6.1 STXXL（C++ 外部存储库）](#61-stxxlc-外部存储库)
  - [6.2 Spark 外部排序](#62-spark-外部排序)
- [7. 性能分析](#7-性能分析)
  - [7.1 理论 vs 实践](#71-理论-vs-实践)
  - [7.2 SSD vs HDD](#72-ssd-vs-hdd)
- [8. 大学课程对应](#8-大学课程对应)
- [9. 教材与论文](#9-教材与论文)
- [10. 本地项目引用](#10-本地项目引用)

---

## 概述

**外部存储算法**（External Memory Algorithms）是针对**数据量远超内存**的场景设计的算法，核心目标是**最小化磁盘 I/O 次数**。

**核心思想**：

```text
外部存储模型（EM 模型）：

参数：
  N: 数据元素总数
  M: 内存大小（元素数）
  B: 磁盘块大小（元素数）

假设：N >> M >> B

成本：
  - 内存操作：免费（O(1)）
  - 磁盘 I/O：昂贵（主导成本）

目标：最小化 I/O 次数
```

**现实意义**：

| 存储层级 | 延迟 | 容量 | 带宽 |
|----------|------|------|------|
| L1 Cache | 1 ns | 32 KB | 1 TB/s |
| L2 Cache | 3 ns | 256 KB | 500 GB/s |
| L3 Cache | 12 ns | 8 MB | 100 GB/s |
| DRAM | 100 ns | 16 GB | 20 GB/s |
| SSD | 100 μs | 1 TB | 500 MB/s |
| HDD | 10 ms | 4 TB | 150 MB/s |

**相对速度**：内存比 SSD 快 **1000x**，比 HDD 快 **100,000x**

---

## 1. I/O 模型与复杂度

### 1.1 DAM 模型（Disk Access Machine）

**参数**：

```text
N: 问题规模（元素数）
M: 内存大小（元素数）
B: 块大小（元素数）

假设：1 ≤ B ≤ M/2 ≤ N
```

**I/O 复杂度记号**：

```text
Scan(N) = Θ(N/B)              # 扫描 N 个元素
Sort(N) = Θ((N/B) log_{M/B}(N/B))  # 排序
Search(N) = Θ(log_B N)         # B-树查找
```

**下界**（信息论）：

```text
排序下界：Ω((N/B) log_{M/B}(N/B)) I/Os
原因：
  - 每次 I/O 最多读 M 个元素
  - 需要 log_{M/B}(N/M) 轮归并
```

### 1.2 Cache-Oblivious 模型

**特点**：算法**不知道** M 和 B 的值，但在所有层级都优化

**优势**：

- 自动适应所有缓存层级（L1, L2, L3, DRAM）
- 无需手工调优
- 可移植性强

**典型算法**：

- Funnelsort（漏斗排序）
- Cache-oblivious B-tree
- Van Emde Boas 布局

---

## 2. 经典外部存储算法

### 2.1 外部归并排序（External Merge Sort）

**算法**：

```text
Phase 1: 初始归并段生成
  - 读 M 个元素到内存
  - 内部排序（QuickSort/HeapSort）
  - 写回磁盘
  - 重复直到所有数据处理完
  → 生成 ⌈N/M⌉ 个有序段

Phase 2: K-路归并
  - K = M/B（每路占 B 个缓冲区）
  - 每轮归并 K 个段
  - 重复 log_K(N/M) 轮
```

**I/O 复杂度**：

```text
Phase 1: 2·(N/B)             # 读 + 写
Phase 2: 2·(N/B)·log_{M/B}(N/M)  # 每轮读写

总计：Θ((N/B)·log_{M/B}(N/B)) I/Os
```

**示例**：

```text
N = 1,000,000,000 元素（4 GB）
M = 100,000,000 元素（400 MB）
B = 10,000 元素（40 KB）

Phase 1: 10 个初始段
Phase 2: 归并轮数 = log_{10,000}(10) ≈ 1
总 I/O: 2·(100,000) + 2·(100,000) = 400,000 次
```

### 2.2 外部哈希（External Hashing）

**Phase 1：分区**:

```text
for each record r in input:
  h = hash(r.key) mod P  # P = 分区数
  write r to partition[h]

选择 P = M/B，确保每个分区 ≤ M
```

**Phase 2：内存哈希**:

```text
for each partition p:
  load p into memory
  build in-memory hash table
  process queries/joins
```

**I/O 复杂度**：

```text
分区阶段：2·(N/B)   # 读 + 写
处理阶段：(N/B)     # 读
总计：3·(N/B) I/Os
```

**Grace Hash Join**（数据库经典算法）：

```text
Join(R, S):
  # Phase 1: 分区
  Partition R into R_1, ..., R_P
  Partition S into S_1, ..., S_P
  
  # Phase 2: 内存 Join
  for i = 1 to P:
    load R_i into hash table
    for each s in S_i:
      probe hash table
      output matches
```

### 2.3 B-树（B-Tree）

**结构**：

```text
阶数：t = Θ(B)
每个节点：t-1 到 2t-1 个键
高度：h = Θ(log_B N)

插入/删除/查找：O(log_B N) I/Os
```

**B+ 树优化**：

- 叶子节点链接（范围查询友好）
- 内部节点只存键（更高扇出）

**形式化定义**（Coq）：

```coq
Require Import Coq.ZArith.ZArith.
Require Import Coq.Lists.List.
Import ListNotations.

Record BTree : Type := mkBTree {
  t : nat;                      (* 最小度数 *)
  root : BNode;
}.

Inductive BNode : Type :=
  | Leaf : list (Z * Z) -> BNode           (* 键值对 *)
  | Internal : list Z -> list BNode -> BNode.  (* 键 + 子节点 *)

(* 不变式 *)
Definition btree_invariant (tree : BTree) : Prop :=
  let t := tree.(t) in
  (t >= 2) /\
  (forall node : BNode, 
    match node with
    | Internal keys children =>
        (length keys >= t - 1) /\
        (length keys <= 2*t - 1) /\
        (length children = length keys + 1)
    | Leaf pairs =>
        (length pairs >= t - 1) /\
        (length pairs <= 2*t - 1)
    end).
```

**查找定理**：

```coq
Theorem btree_search_io:
  forall (tree : BTree) (key : Z),
    btree_invariant tree ->
    let h := height tree in
    io_cost (search tree key) = O (log (B tree) (size tree)).
```

---

## 3. Cache-Oblivious 算法

### 3.1 Funnelsort（漏斗排序）

**思想**：递归的 K-路归并，K 自动适应缓存大小

**结构**：

```text
Funnel(N):
  if N ≤ M:
    sort in memory
  else:
    分成 √N 个子数组
    递归排序每个子数组
    用 √N-路 Funnel 归并
```

**I/O 复杂度**（cache-oblivious）：

```text
Θ((N/B) log_{M/B}(N/B)) I/Os
（与 optimal external sort 相同）
```

**优势**：

- 无需知道 M, B
- 自动适应所有缓存层级

### 3.2 Cache-Oblivious B-Tree

**Van Emde Boas 布局**：

```text
递归布局：
  - 将树分成高度 h/2 的子树
  - 子树根节点连续存储
  - 递归对每个子树应用
```

**示例**（16 节点树）：

```text
传统 BFS 布局：[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]

VEB 布局：
  层 1-2: [0,1,2]
  层 3: [3,4,5,6]
  递归子树 1: [7,8,9]
  递归子树 2: [10,11,12]
  ...
```

**I/O 复杂度**：

```text
查找：O(log_B N) I/Os
插入/删除：O((log_B N)^2 / B) I/Os（摊销）
```

### 3.3 Matrix Transpose（矩阵转置）

**Cache-Oblivious 算法**：

```text
Transpose(A, n):
  if n == 1:
    return A
  else:
    分成 4 个 n/2 × n/2 子矩阵：
      [A11 A12]
      [A21 A22]
    递归转置：
      Transpose(A11)
      Transpose(A22)
      Swap(A12, A21)
```

**I/O 复杂度**：

```text
Θ(n^2 / B) I/Os（optimal）
```

**对比**：

- 行优先遍历：Θ(n^2) I/Os（最差）
- 分块算法：需要知道 B

---

## 4. I/O 复杂度下界

### 4.1 排序下界

**定理**：

```text
任何基于比较的外部排序算法需要至少
Ω((N/B) log_{M/B}(N/B)) I/Os
```

**证明**（信息论）：

```text
1. 共有 N! 种排列
2. 每次 I/O 最多读 M 个元素
3. 每轮归并最多合并 M/B 个段
4. 需要 log_{M/B}(N/M) 轮
5. 每轮 I/O：2N/B（读 + 写）
6. 总计：Θ((N/B) log_{M/B}(N/B))
```

**Lean4 形式化**：

```lean
import Mathlib.Data.Real.Basic
import Mathlib.Data.Nat.Log

theorem external_sort_lower_bound (N M B : ℕ) 
  (h1 : B ≤ M / 2) 
  (h2 : M ≤ N) :
  ∀ (alg : SortAlgorithm),
    io_cost alg ≥ (N / B) * (Nat.log (M / B) (N / B)) := by
  intro alg
  -- 信息论论证
  have h_permutations : num_permutations N = N.factorial := rfl
  have h_io_per_round : io_per_round ≤ M / B := by sorry
  have h_rounds : rounds ≥ Nat.log (M / B) (N / M) := by sorry
  -- 组合证明
  sorry
```

### 4.2 矩阵乘法下界

**定理**：

```text
n × n 矩阵乘法需要至少
Ω(n^3 / B√M) I/Os
```

**证明草图**：

```text
1. 输出矩阵 n^2 个元素
2. 每个元素需要 n 次乘加
3. 最优分块：每次加载 √M × √M 子矩阵
4. 子矩阵数：(n/√M)^2
5. 总 I/O：(n/√M)^2 · (n^2/B) = n^3 / (B√M)
```

---

## 5. 实际系统中的应用

### 5.1 数据库排序

**PostgreSQL External Sort**：

```c
typedef struct Tuplesortstate {
    int64 memtupsize;      // 内存中元组数
    SortTuple *memtuples;  // 内存元组数组
    LogicalTapeSet *tapeset;  // 外部磁盘带
    int maxTapes;          // 归并路数
    int currentRun;        // 当前归并段
} Tuplesortstate;
```

**关键优化**：

- **替换选择**（Replacement Selection）：生成更长的初始段
- **预读**（Prefetching）：异步 I/O
- **压缩**（Compression）：减少 I/O 量

### 5.2 MapReduce

**Shuffle 阶段**（外部排序）：

```text
Map:
  for each record:
    emit(partition(key), (key, value))
  
  sort in-memory buffer
  spill to disk when full
  
Merge:
  K-way merge of spill files
  
Reduce:
  read sorted data
  apply reduce function
```

**Hadoop TeraSort**（TB 级排序）：

- 采样键分布（Sampler）
- 分区保证负载均衡
- 外部归并（K=100）

### 5.3 大规模图算法

**问题**：社交网络图无法载入内存

**解决方案**：GraphChi（单机外部存储图）

**算法**（Parallel Sliding Windows）：

```text
1. 将图按顶点分成 P 个分片
2. 每轮：
   - 加载一个分片的所有边（顺序 I/O）
   - 更新内存中的顶点数据
   - 写回更新
3. 重复 P 轮
```

**I/O 复杂度**：

```text
Θ(P · (|V| + |E|)/B) I/Os
其中 P = ⌈(|V| + |E|)/M⌉
```

---

## 6. 工具与实现

### 6.1 STXXL（C++ 外部存储库）

**安装**：

```bash
git clone https://github.com/stxxl/stxxl.git
mkdir build && cd build
cmake .. && make
```

**示例**（外部排序）：

```cpp
#include <stxxl/vector>
#include <stxxl/sort>

int main() {
    typedef stxxl::VECTOR_GENERATOR<int>::result vector_type;
    vector_type v;
    
    // 生成 10 亿个随机数
    for (size_t i = 0; i < 1000000000; ++i) {
        v.push_back(rand());
    }
    
    // 外部排序
    stxxl::sort(v.begin(), v.end(), std::less<int>());
    
    // 验证
    assert(stxxl::is_sorted(v.begin(), v.end()));
    return 0;
}
```

**特性**：

- 自动管理磁盘文件
- 异步 I/O
- 支持 vector, map, queue, priority_queue

### 6.2 Spark 外部排序

**配置**：

```scala
val conf = new SparkConf()
  .set("spark.shuffle.spill.compress", "true")
  .set("spark.shuffle.sort.bypassMergeThreshold", "200")

val rdd = sc.parallelize(1 to 1e9.toInt)
val sorted = rdd.sortBy(identity)
```

**内部实现**：

- **ExternalSorter**：内存 + 磁盘混合排序
- **ShuffleBlockResolver**：管理溢写文件
- **TimSort**：利用部分有序性

---

## 7. 性能分析

### 7.1 理论 vs 实践

**示例**：排序 1TB 数据（250M 整数）

| 算法 | 理论 I/O | 实际时间 | 说明 |
|------|----------|----------|------|
| **QuickSort（内存）** | 0 | 无法运行 | 内存不足 |
| **Naive 外部排序** | 2e9 | 10 小时 | 单路归并 |
| **K-路归并 (K=1000)** | 2e7 | 30 分钟 | 符合理论 |
| **STXXL** | 2e7 | 20 分钟 | 异步 I/O 优化 |
| **Hadoop TeraSort** | 2e7 | 10 分钟 | 分布式并行 |

**实际开销**：

- 磁盘寻道（HDD）：随机 I/O 慢 100x
- 网络传输（分布式）：额外开销
- CPU（压缩/解压）：权衡 I/O vs 计算

### 7.2 SSD vs HDD

**I/O 特性对比**：

| 维度 | HDD | SSD |
|------|-----|-----|
| **顺序读** | 150 MB/s | 500 MB/s |
| **随机读（4K）** | 0.5 MB/s | 300 MB/s |
| **延迟** | 10 ms | 100 μs |
| **IOPS** | 100 | 100,000 |

**算法影响**：

- **HDD**：顺序 I/O 优先（外部归并优势明显）
- **SSD**：随机 I/O 可接受（B-树更实用）

---

## 8. 大学课程对应

| 课程 | 相关章节 |
|------|----------|
| **MIT 6.851 高级数据结构** | Cache-oblivious 算法 |
| **CMU 15-826 数据库实现** | 外部排序、哈希 Join |
| **Berkeley CS 267 并行算法** | I/O 复杂度、外部存储并行算法 |
| **ETHZ Big Data** | MapReduce, Spark shuffle |

---

## 9. 教材与论文

### 核心论文

1. **EM 模型**：
   - Aggarwal, A., & Vitter, J. S. (1988). *The input/output complexity of sorting and related problems*. CACM 31(9).

2. **Cache-Oblivious**：
   - Frigo, M., et al. (1999). *Cache-oblivious algorithms*. FOCS 1999.

3. **Funnelsort**：
   - Brodal, G. S., & Fagerberg, R. (2002). *Cache-oblivious distribution sweeping*. ICALP 2002.

### 推荐教材

- *Algorithms and Data Structures for External Memory* (Vitter, 2008)
- *Database Management Systems* (Ramakrishnan & Gehrke) - Chapter 13

---

## 快速参考

### 核心公式

```text
I/O 模型参数：
  N: 数据规模
  M: 内存大小
  B: 块大小

基础操作：
  Scan(N) = Θ(N/B)
  Sort(N) = Θ((N/B) log_{M/B}(N/B))
  Search(N) = Θ(log_B N)

排序下界：
  Ω((N/B) log_{M/B}(N/B)) I/Os
  
矩阵乘法：
  Θ(n^3 / (B√M)) I/Os
```

### 算法选择

```text
排序：
  - 小数据（< 1GB）：内存快排
  - 中数据（1-100GB）：外部归并
  - 大数据（> 100GB）：分布式 TeraSort

查找：
  - HDD：B-树（顺序友好）
  - SSD：哈希表（随机 I/O 快）
  - 内存：红黑树

Join：
  - 小表：内存哈希 Join
  - 大表：外部哈希 Join
  - 超大表：MapReduce Join
```

### 实战建议

1. **优先顺序 I/O**：HDD 上随机 I/O 慢 200x
2. **利用预读**：操作系统预读 128KB 块
3. **压缩权衡**：CPU 换 I/O（通常值得）
4. **监控工具**：`iostat`, `iotop`（Linux）

---

## 附录 A：Wikipedia 概念对照

| 概念 | Wikipedia 条目 | 本文章节 |
|------|----------------|----------|
| External Memory Algorithm | <https://en.wikipedia.org/wiki/External_memory_algorithm> | §1 |
| B-tree | <https://en.wikipedia.org/wiki/B-tree> | §2.3 |
| Cache-Oblivious Algorithm | <https://en.wikipedia.org/wiki/Cache-oblivious_algorithm> | §3 |
| External Sorting | <https://en.wikipedia.org/wiki/External_sorting> | §2.1 |
| Van Emde Boas Layout | <https://en.wikipedia.org/wiki/Van_Emde_Boas_tree> | §3.2 |

---

**版本**：v1.0  
**最后更新**：2025-10-29  
**维护者**：FormalScience Project  
**许可**：CC BY-SA 4.0
