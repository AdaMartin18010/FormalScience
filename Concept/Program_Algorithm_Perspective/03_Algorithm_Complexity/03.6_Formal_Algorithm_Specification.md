# ç®—æ³•å½¢å¼åŒ–è§„èŒƒ

## ğŸ“Š æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ

<details>
<summary><b>ğŸ“ğŸ”¬ ç‚¹å‡»å±•å¼€ï¼šç®—æ³•å½¢å¼åŒ–æ ¸å¿ƒæ´å¯Ÿ</b></summary>

**ç»ˆææ´å¯Ÿ**: ç®—æ³•å½¢å¼åŒ–=ä»ä»£ç åˆ°å®šç†ã€‚ä¸‰å±‚è§„èŒƒï¼šâ‘ åŠŸèƒ½æ­£ç¡®æ€§ï¼š{å‰ç½®P} Algorithm {åç½®Q}ï¼Œç”¨Hoareé€»è¾‘/åˆ†ç¦»é€»è¾‘æè¿°è¾“å…¥è¾“å‡ºå…³ç³»â‘¡å¤æ‚åº¦ç•Œé™ï¼šè¯æ˜T(n)â‰¤f(n)ã€S(n)â‰¤g(n)ï¼Œç”¨é€’æ¨å…³ç³»+å½’çº³æ³•â‘¢ç»ˆæ­¢æ€§ï¼šè¯æ˜å­˜åœ¨è‰¯åŸºåºé€’å‡ã€‚å·¥å…·é“¾ï¼šâ‘ Dafnyï¼ˆè‡ªåŠ¨SMTæ±‚è§£ï¼‰ï¼šå†…ç½®éªŒè¯ï¼Œdecreaseså­å¥è¯æ˜ç»ˆæ­¢â‘¡Coqï¼ˆäº¤äº’å¼è¯æ˜ï¼‰ï¼šæ‰‹å·¥ç­–ç•¥è¯æ˜ï¼Œå®Œå…¨å¯ä¿¡ï¼Œå¦‚å½’å¹¶æ’åºå®Œæ•´è¯æ˜â‘¢Lean4ï¼ˆä¾èµ–ç±»å‹ï¼‰ï¼šç±»å‹å³å‘½é¢˜ï¼Œç¨‹åºå³è¯æ˜ï¼Œå¦‚æ’åºçš„Sortedè°“è¯â‘£Why3ï¼ˆå¤šåç«¯ï¼‰ï¼šç»Ÿä¸€å‰ç«¯ï¼Œç”ŸæˆCoq/Alt-Ergo/Z3è¯æ˜â‘¤K-Frameworkï¼ˆæˆæœ¬è¯­ä¹‰ï¼‰ï¼šæ‰©å±•æ“ä½œè¯­ä¹‰é™„åŠ èµ„æºè®¡æ•°ã€‚ç»å…¸æ¡ˆä¾‹ï¼šâ‘ TimsortéªŒè¯ï¼ˆPython/Javaæ ‡å‡†åº“ï¼ŒKeYé¡¹ç›®å‘ç°bugï¼‰â‘¡CompCertï¼ˆéªŒè¯çš„Cç¼–è¯‘å™¨ï¼ŒCoqï¼‰â‘¢seL4ï¼ˆéªŒè¯çš„å¾®å†…æ ¸ï¼ŒIsabelle/HOLï¼‰ã€‚å¤æ‚åº¦å½¢å¼åŒ–ï¼šMasterå®šç†ã€åŠ¿èƒ½åˆ†æã€æ‘Šè¿˜åˆ†æçš„Coqè¯æ˜ã€‚æŒ‘æˆ˜ï¼šå¤æ‚åº¦è¯æ˜æ¯”æ­£ç¡®æ€§è¯æ˜æ›´éš¾ï¼ˆéœ€è¦ç²¾ç¡®é€’æ¨å¼ï¼‰ã€‚å…³é”®ï¼šå½¢å¼åŒ–è§„èŒƒå°†ç®—æ³•ä»å·¥ç¨‹å®è·µæå‡ä¸ºæ•°å­¦å®šç†ï¼Œæ˜¯é«˜ä¿éšœè½¯ä»¶çš„åŸºç¡€ã€‚

</details>

---

## ğŸ“‹ ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [1. è§„èŒƒè¯­è¨€](#1-è§„èŒƒè¯­è¨€)
  - [1.1 Hoare ä¸‰å…ƒç»„](#11-hoare-ä¸‰å…ƒç»„)
  - [1.2 æ‰©å±•ï¼šæˆæœ¬è¯­ä¹‰](#12-æ‰©å±•æˆæœ¬è¯­ä¹‰)
  - [1.3 åˆ†ç¦»é€»è¾‘è§„èŒƒ](#13-åˆ†ç¦»é€»è¾‘è§„èŒƒ)
- [2. Dafnyï¼šè‡ªåŠ¨éªŒè¯è¯­è¨€](#2-dafnyè‡ªåŠ¨éªŒè¯è¯­è¨€)
  - [2.1 åŸºæœ¬è¯­æ³•](#21-åŸºæœ¬è¯­æ³•)
  - [2.2 éªŒè¯ç¤ºä¾‹](#22-éªŒè¯ç¤ºä¾‹)
  - [2.3 å¤æ‚åº¦æ³¨è§£ï¼ˆéæ ‡å‡†æ‰©å±•ï¼‰](#23-å¤æ‚åº¦æ³¨è§£éæ ‡å‡†æ‰©å±•)
- [3. Lean4ï¼šä¾èµ–ç±»å‹è§„èŒƒ](#3-lean4ä¾èµ–ç±»å‹è§„èŒƒ)
  - [3.1 åˆ—è¡¨æ’åºè§„èŒƒ](#31-åˆ—è¡¨æ’åºè§„èŒƒ)
  - [3.2 å¤æ‚åº¦ç±»å‹](#32-å¤æ‚åº¦ç±»å‹)
- [4. Coqï¼šå½’å¹¶æ’åºå®Œæ•´è¯æ˜](#4-coqå½’å¹¶æ’åºå®Œæ•´è¯æ˜)
  - [4.1 å®šä¹‰ä¸è§„èŒƒ](#41-å®šä¹‰ä¸è§„èŒƒ)
  - [4.2 å½’å¹¶æ’åºå®ç°](#42-å½’å¹¶æ’åºå®ç°)
  - [4.3 æ­£ç¡®æ€§è¯æ˜](#43-æ­£ç¡®æ€§è¯æ˜)
  - [4.4 å¤æ‚åº¦è¯æ˜](#44-å¤æ‚åº¦è¯æ˜)
- [5. Why3ï¼šå¤šåç«¯éªŒè¯](#5-why3å¤šåç«¯éªŒè¯)
  - [5.1 Why3ML è¯­æ³•](#51-why3ml-è¯­æ³•)
  - [5.2 ç”Ÿæˆ Coq è¯æ˜](#52-ç”Ÿæˆ-coq-è¯æ˜)
- [6. å®é™…æ¡ˆä¾‹ï¼šTimsort å½¢å¼åŒ–](#6-å®é™…æ¡ˆä¾‹timsort-å½¢å¼åŒ–)
  - [6.1 Timsort ç®—æ³•æ¦‚è¿°](#61-timsort-ç®—æ³•æ¦‚è¿°)
  - [6.2 å…³é”®ä¸å˜å¼](#62-å…³é”®ä¸å˜å¼)
  - [6.3 å½¢å¼åŒ–éªŒè¯ï¼ˆKeY Projectï¼‰](#63-å½¢å¼åŒ–éªŒè¯key-project)
- [7. ç®—æ³•åˆ†æçš„å½¢å¼åŒ–](#7-ç®—æ³•åˆ†æçš„å½¢å¼åŒ–)
  - [7.1 Master Theorem å½¢å¼åŒ–](#71-master-theorem-å½¢å¼åŒ–)
  - [7.2 æ‘Šè¿˜åˆ†æå½¢å¼åŒ–](#72-æ‘Šè¿˜åˆ†æå½¢å¼åŒ–)
- [8. å·¥å…·å¯¹æ¯”](#8-å·¥å…·å¯¹æ¯”)
- [9. å¤§å­¦è¯¾ç¨‹å¯¹åº”](#9-å¤§å­¦è¯¾ç¨‹å¯¹åº”)
- [10. æ•™æä¸è®ºæ–‡](#10-æ•™æä¸è®ºæ–‡)

---

## æ¦‚è¿°

**ç®—æ³•å½¢å¼åŒ–è§„èŒƒ**æ˜¯ç”¨æ•°å­¦è¯­è¨€ç²¾ç¡®å®šä¹‰ç®—æ³•çš„**è¡Œä¸º**ã€**æ­£ç¡®æ€§**å’Œ**å¤æ‚åº¦**ï¼Œä½¿å¾—ç®—æ³•å¯ä»¥è¢«**æœºå™¨éªŒè¯**ã€‚

**æ ¸å¿ƒæ€æƒ³**ï¼š

```text
ç®—æ³•è§„èŒƒ = å‰ç½®æ¡ä»¶ + åç½®æ¡ä»¶ + å¤æ‚åº¦ç•Œé™

è§„èŒƒ ::= {P} Algorithm {Q, Îº}
  P: å‰ç½®æ¡ä»¶ï¼ˆPreconditionï¼‰
  Q: åç½®æ¡ä»¶ï¼ˆPostconditionï¼‰
  Îº: æˆæœ¬ç•Œé™ï¼ˆCost Boundï¼‰

éªŒè¯ç›®æ ‡ï¼š
  âˆ€è¾“å…¥ Ïƒ, P(Ïƒ) â‡’ (Algorithm(Ïƒ)â†“ âˆ§ Q(Ïƒ') âˆ§ Cost â‰¤ Îº(n))
```

**å½¢å¼åŒ–æ–¹æ³•**ï¼š

1. **Hoare é€»è¾‘**ï¼š{P} S {Q}
2. **åˆ†ç¦»é€»è¾‘**ï¼šå¸¦èµ„æºçš„ Hoare é€»è¾‘
3. **ä¾èµ–ç±»å‹**ï¼šç±»å‹ä¸­ç¼–ç è§„èŒƒï¼ˆLean4, Agdaï¼‰
4. **Why3/Dafny**ï¼šè‡ªåŠ¨éªŒè¯è¯­è¨€

**åº”ç”¨åœºæ™¯**ï¼š

- âœ… **å…³é”®ç®—æ³•**ï¼šåŠ å¯†ã€å…±è¯†ã€å®‰å…¨
- âœ… **åº“å‡½æ•°**ï¼šæ ‡å‡†åº“ã€æ•°å€¼åº“
- âœ… **æ•™å­¦**ï¼šç®—æ³•æ­£ç¡®æ€§æ•™å­¦
- âŒ **å¿«é€ŸåŸå‹**ï¼šéªŒè¯æˆæœ¬é«˜

---

## 1. è§„èŒƒè¯­è¨€

### 1.1 Hoare ä¸‰å…ƒç»„

**åŸºæœ¬å½¢å¼**ï¼š

```text
{P} S {Q}

å«ä¹‰ï¼š
  è‹¥ P(Ïƒ) æˆç«‹ä¸” S åœ¨ Ïƒ ä¸Šæ‰§è¡Œç»ˆæ­¢åˆ° Ïƒ',
  åˆ™ Q(Ïƒ') æˆç«‹
```

**ç¤ºä¾‹**ï¼ˆæ•´æ•°ç»å¯¹å€¼ï¼‰ï¼š

```text
{true}
  if x >= 0 then
    y := x
  else
    y := -x
{y >= 0 âˆ§ (y = x âˆ¨ y = -x)}
```

### 1.2 æ‰©å±•ï¼šæˆæœ¬è¯­ä¹‰

**å½¢å¼**ï¼š

```text
{P} S {Q, Îº}

å«ä¹‰ï¼š
  {P} S {Q}  âˆ§  Time(S) â‰¤ Îº(n)
```

**ç¤ºä¾‹**ï¼ˆäºŒåˆ†æŸ¥æ‰¾ï¼‰ï¼š

```text
{sorted(arr) âˆ§ n = |arr|}
  binary_search(arr, target)
{result = -1 âˆ¨ arr[result] = target, O(log n)}
```

### 1.3 åˆ†ç¦»é€»è¾‘è§„èŒƒ

**å½¢å¼**ï¼ˆå¸¦èµ„æºï¼‰ï¼š

```text
{P * R} S {Q * R}

è§£é‡Šï¼š
  - P * R: å †åˆ†ç¦»åˆå–
  - ä¿ç•™èµ„æº Rï¼ˆå¸§è§„åˆ™ï¼‰
```

**ç¤ºä¾‹**ï¼ˆé“¾è¡¨åè½¬ï¼‰ï¼š

```text
{list(head, xs)}
  reverse(head)
{list(result, reverse(xs))}
```

---

## 2. Dafnyï¼šè‡ªåŠ¨éªŒè¯è¯­è¨€

### 2.1 åŸºæœ¬è¯­æ³•

**ç¤ºä¾‹**ï¼ˆäºŒåˆ†æŸ¥æ‰¾ï¼‰ï¼š

```dafny
method BinarySearch(arr: array<int>, target: int) returns (index: int)
  requires arr.Length > 0
  requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]  // sorted
  ensures 0 <= index < arr.Length ==> arr[index] == target
  ensures index == -1 ==> forall i :: 0 <= i < arr.Length ==> arr[i] != target
{
  var low := 0;
  var high := arr.Length;
  
  while low < high
    invariant 0 <= low <= high <= arr.Length
    invariant forall i :: 0 <= i < low ==> arr[i] < target
    invariant forall i :: high <= i < arr.Length ==> arr[i] > target
    decreases high - low
  {
    var mid := (low + high) / 2;
    if arr[mid] < target {
      low := mid + 1;
    } else if arr[mid] > target {
      high := mid;
    } else {
      return mid;
    }
  }
  return -1;
}
```

**å…³é”®æ³¨è§£**ï¼š

- `requires`ï¼šå‰ç½®æ¡ä»¶
- `ensures`ï¼šåç½®æ¡ä»¶
- `invariant`ï¼šå¾ªç¯ä¸å˜å¼
- `decreases`ï¼šç»ˆæ­¢åº¦é‡ï¼ˆè¯æ˜ç»ˆæ­¢ï¼‰

### 2.2 éªŒè¯ç¤ºä¾‹

**è¿è¡ŒéªŒè¯**ï¼š

```bash
dafny /compile:0 binary_search.dfy
# Dafny program verifier finished with 1 verified, 0 errors
```

**è‡ªåŠ¨æ¨æ–­**ï¼š

- Dafny è‡ªåŠ¨æ¨æ–­ä¸­é—´æ–­è¨€
- è°ƒç”¨ Z3 æ±‚è§£å™¨éªŒè¯ VCï¼ˆVerification Conditionï¼‰

### 2.3 å¤æ‚åº¦æ³¨è§£ï¼ˆéæ ‡å‡†æ‰©å±•ï¼‰

```dafny
method LinearSearch(arr: array<int>, target: int) returns (index: int)
  ensures 0 <= index < arr.Length ==> arr[index] == target
  ensures index == -1 ==> forall i :: 0 <= i < arr.Length ==> arr[i] != target
  // Non-standard: time complexity
  // Time: O(arr.Length)
{
  var i := 0;
  while i < arr.Length
    invariant 0 <= i <= arr.Length
    invariant forall j :: 0 <= j < i ==> arr[j] != target
  {
    if arr[i] == target {
      return i;
    }
    i := i + 1;
  }
  return -1;
}
```

---

## 3. Lean4ï¼šä¾èµ–ç±»å‹è§„èŒƒ

### 3.1 åˆ—è¡¨æ’åºè§„èŒƒ

```lean
import Mathlib.Data.List.Sort

-- å®šä¹‰ï¼šæœ‰åºæ€§
def Sorted (l : List â„•) : Prop :=
  âˆ€ i j, i < j â†’ j < l.length â†’ l[i]! â‰¤ l[j]!

-- å®šä¹‰ï¼šæ’åˆ—
def Permutation (l1 l2 : List â„•) : Prop :=
  l1.length = l2.length âˆ§ 
  âˆ€ x, l1.count x = l2.count x

-- æ’å…¥æ’åºè§„èŒƒ
def insertionSort (l : List â„•) : { l' : List â„• // Sorted l' âˆ§ Permutation l l' }

-- å®ç°
def insert (x : â„•) (l : List â„•) (h : Sorted l) : { l' : List â„• // Sorted l' } :=
  match l with
  | [] => âŸ¨[x], by simp [Sorted]âŸ©
  | y :: ys =>
      if x â‰¤ y then
        âŸ¨x :: y :: ys, by
          intro i j hi hj
          cases i <;> cases j <;> simp [*]
          apply hâŸ©
      else
        let âŸ¨ys', hys'âŸ© := insert x ys (by sorry)  -- é€’å½’è¯æ˜
        âŸ¨y :: ys', by sorryâŸ©

def insertionSort : (l : List â„•) â†’ { l' : List â„• // Sorted l' âˆ§ Permutation l l' }
  | [] => âŸ¨[], by simp [Sorted, Permutation]âŸ©
  | x :: xs =>
      let âŸ¨xs', hxs'âŸ© := insertionSort xs
      let âŸ¨result, hresultâŸ© := insert x xs' hxs'.1
      âŸ¨result, by
        constructor
        Â· exact hresult
        Â· sorry  -- è¯æ˜ Permutation
      âŸ©
```

### 3.2 å¤æ‚åº¦ç±»å‹

**å®šä¹‰ Timed Monad**ï¼š

```lean
structure Timed (Î± : Type) where
  value : Î±
  cost : â„•

def bind {Î± Î² : Type} (ta : Timed Î±) (f : Î± â†’ Timed Î²) : Timed Î² :=
  let tb := f ta.value
  âŸ¨tb.value, ta.cost + tb.costâŸ©

notation:60 x " >>= " f => bind x f
```

**ç¤ºä¾‹**ï¼ˆå¸¦æˆæœ¬çš„äºŒåˆ†æŸ¥æ‰¾ï¼‰ï¼š

```lean
def binarySearch (arr : Array â„•) (target : â„•) 
  (h : arr.sorted) : Timed (Option â„•) :=
  let rec search (low high : â„•) (fuel : â„•) : Timed (Option â„•) :=
    if fuel = 0 then
      âŸ¨none, 0âŸ©  -- ä¸åº”åˆ°è¾¾
    else if low >= high then
      âŸ¨none, 1âŸ©
    else
      let mid := (low + high) / 2
      if arr[mid]! < target then
        let âŸ¨result, costâŸ© := search (mid + 1) high (fuel - 1)
        âŸ¨result, cost + 3âŸ©  -- æ¯”è¾ƒ + ç®—æœ¯ + é€’å½’
      else if arr[mid]! > target then
        let âŸ¨result, costâŸ© := search low mid (fuel - 1)
        âŸ¨result, cost + 3âŸ©
      else
        âŸ¨some mid, 2âŸ©  -- æ‰¾åˆ°
  search 0 arr.size (Nat.log2 arr.size + 1)

-- å®šç†ï¼šæˆæœ¬ç•Œé™
theorem binarySearch_cost_bound (arr : Array â„•) (target : â„•) (h : arr.sorted) :
  let result := binarySearch arr target h
  result.cost â‰¤ 3 * (Nat.log2 arr.size + 1) := by
  sorry
```

---

## 4. Coqï¼šå½’å¹¶æ’åºå®Œæ•´è¯æ˜

### 4.1 å®šä¹‰ä¸è§„èŒƒ

```coq
Require Import Coq.Lists.List.
Require Import Coq.Sorting.Sorted.
Import ListNotations.

(* å®šä¹‰ï¼šæ’åˆ— *)
Inductive Permutation {A : Type} : list A -> list A -> Prop :=
  | perm_nil : Permutation [] []
  | perm_skip x l l' : Permutation l l' -> Permutation (x::l) (x::l')
  | perm_swap x y l : Permutation (y::x::l) (x::y::l)
  | perm_trans l l' l'' : Permutation l l' -> Permutation l' l'' -> Permutation l l''.

(* è§„èŒƒ *)
Definition sort_spec {A : Type} (f : list A -> list A) : Prop :=
  forall l, Sorted le (f l) /\ Permutation l (f l).
```

### 4.2 å½’å¹¶æ’åºå®ç°

```coq
Fixpoint merge (l1 l2 : list nat) : list nat :=
  match l1, l2 with
  | [], _ => l2
  | _, [] => l1
  | a1::l1', a2::l2' =>
      if a1 <=? a2 then a1 :: merge l1' l2
      else a2 :: merge l1 l2'
  end.

Fixpoint split (l : list nat) : list nat * list nat :=
  match l with
  | [] => ([], [])
  | [x] => ([x], [])
  | x::y::l' =>
      let (l1, l2) := split l' in
      (x::l1, y::l2)
  end.

Fixpoint mergeSort (l : list nat) : list nat :=
  match l with
  | [] => []
  | [x] => [x]
  | _ =>
      let (l1, l2) := split l in
      merge (mergeSort l1) (mergeSort l2)
  end.
```

### 4.3 æ­£ç¡®æ€§è¯æ˜

```coq
(* å¼•ç†1ï¼šmerge ä¿æŒæœ‰åºæ€§ *)
Lemma merge_sorted : forall l1 l2,
  Sorted le l1 -> Sorted le l2 -> Sorted le (merge l1 l2).
Proof.
  induction l1; intros l2 H1 H2; simpl.
  - apply H2.
  - destruct l2; simpl.
    + apply H1.
    + destruct (a <=? n) eqn:E.
      * constructor.
        ** apply IHl1.
           *** inv H1; auto.
           *** apply H2.
        ** (* éœ€è¦è¯æ˜ a æ˜¯æœ€å°çš„ *)
           admit.
      * constructor.
        ** apply IHl1; auto.
           inv H2; auto.
        ** admit.
Admitted.

(* å¼•ç†2ï¼šmerge ä¿æŒæ’åˆ— *)
Lemma merge_permutation : forall l1 l2,
  Permutation (l1 ++ l2) (merge l1 l2).
Proof.
  induction l1; intros l2; simpl.
  - reflexivity.
  - destruct l2; simpl.
    + rewrite app_nil_r. reflexivity.
    + destruct (a <=? n) eqn:E.
      * apply perm_skip. apply IHl1.
      * apply perm_trans with (n :: a :: l1 ++ l2).
        ** apply perm_swap.
        ** apply perm_skip. apply IHl1.
Qed.

(* å®šç†ï¼šmergeSort æ»¡è¶³è§„èŒƒ *)
Theorem mergeSort_correct : sort_spec mergeSort.
Proof.
  unfold sort_spec. intro l.
  functional induction (mergeSort l); split.
  - constructor.
  - apply perm_nil.
  - constructor.
  - apply perm_skip. apply perm_nil.
  - apply merge_sorted.
    + apply IHl0.
    + apply IHl1.
  - (* è¯æ˜æ’åˆ— *)
    admit.
Admitted.
```

### 4.4 å¤æ‚åº¦è¯æ˜

```coq
Require Import Coq.omega.Omega.

(* å®šä¹‰æˆæœ¬ *)
Fixpoint merge_cost (l1 l2 : list nat) : nat :=
  match l1, l2 with
  | [], _ => 0
  | _, [] => 0
  | a1::l1', a2::l2' =>
      1 + if a1 <=? a2 then merge_cost l1' l2
          else merge_cost l1 l2'
  end.

Lemma merge_cost_bound : forall l1 l2,
  merge_cost l1 l2 <= length l1 + length l2.
Proof.
  induction l1; intros l2; simpl.
  - omega.
  - destruct l2; simpl.
    + omega.
    + destruct (a <=? n); simpl;
      specialize (IHl1 l2); omega.
Qed.

Fixpoint mergeSort_cost (l : list nat) : nat :=
  match l with
  | [] => 0
  | [_] => 0
  | _ =>
      let (l1, l2) := split l in
      let c1 := mergeSort_cost l1 in
      let c2 := mergeSort_cost l2 in
      c1 + c2 + merge_cost (mergeSort l1) (mergeSort l2)
  end.

(* å®šç†ï¼šO(n log n) *)
Theorem mergeSort_cost_bound : forall l,
  mergeSort_cost l <= (length l) * (Nat.log2 (length l) + 1).
Proof.
  (* éœ€è¦è¯æ˜ split å¹³è¡¡æ€§ + å½’çº³ *)
  admit.
Admitted.
```

---

## 5. Why3ï¼šå¤šåç«¯éªŒè¯

### 5.1 Why3ML è¯­æ³•

**ç¤ºä¾‹**ï¼ˆå¿«é€Ÿæ’åºï¼‰ï¼š

```why3
module QuickSort
  use int.Int
  use list.List
  use list.Append
  use list.Permut
  use list.SortedInt
  
  (* è§„èŒƒ *)
  val function partition (l: list int) (pivot: int) : (list int, list int, list int)
    ensures { let (less, eq, greater) = result in
              permut (l) (less ++ eq ++ greater) /\
              (forall x. mem x less -> x < pivot) /\
              (forall x. mem x eq -> x = pivot) /\
              (forall x. mem x greater -> x > pivot) }
  
  let rec quicksort (l: list int) : list int
    ensures { sorted result /\ permut l result }
    variant { length l }
  =
    match l with
    | Nil -> Nil
    | Cons pivot rest ->
        let (less, eq, greater) = partition rest pivot in
        let sorted_less = quicksort less in
        let sorted_greater = quicksort greater in
        sorted_less ++ (Cons pivot eq) ++ sorted_greater
    end
end
```

### 5.2 ç”Ÿæˆ Coq è¯æ˜

```bash
why3 prove -P coq quicksort.mlw
why3 extract -D coq quicksort.mlw -o quicksort.v
```

**ç”Ÿæˆçš„ Coq ä»£ç **ï¼š

```coq
Require Import List.
Import ListNotations.

Fixpoint quicksort (l : list Z) : list Z :=
  match l with
  | nil => nil
  | pivot :: rest =>
      let '(less, eq, greater) := partition rest pivot in
      quicksort less ++ (pivot :: eq) ++ quicksort greater
  end.
```

---

## 6. å®é™…æ¡ˆä¾‹ï¼šTimsort å½¢å¼åŒ–

### 6.1 Timsort ç®—æ³•æ¦‚è¿°

**ç‰¹ç‚¹**ï¼š

- Pythonã€Java æ ‡å‡†åº“æ’åº
- æ··åˆå½’å¹¶æ’åº + æ’å…¥æ’åº
- åˆ©ç”¨éƒ¨åˆ†æœ‰åºæ€§ï¼ˆrunsï¼‰

**ç®—æ³•**ï¼š

```text
1. æ‰«æè¾“å…¥ï¼Œè¯†åˆ«å•è°ƒé€’å¢/é€’å‡æ®µï¼ˆrunsï¼‰
2. çŸ­æ®µç”¨æ’å…¥æ’åºæ‰©å±•åˆ°æœ€å°é•¿åº¦ï¼ˆminrunï¼‰
3. ç”¨æ ˆç»´æŠ¤ runsï¼Œæ»¡è¶³ä¸å˜å¼æ—¶å½’å¹¶
4. æœ€ç»ˆå½’å¹¶æ‰€æœ‰ runs
```

### 6.2 å…³é”®ä¸å˜å¼

**æ ˆä¸å˜å¼**ï¼š

```text
è®¾æ ˆé¡¶ä¸‰ä¸ª runs é•¿åº¦ä¸º X, Y, Zï¼ˆä»é¡¶åˆ°åº•ï¼‰
å¿…é¡»æ»¡è¶³ï¼š
  1. Z > Y + X
  2. Y > X

å¦åˆ™å½’å¹¶
```

**æ¼æ´**ï¼š2015 å¹´å‘ç° Timsort bugï¼ˆè¿åä¸å˜å¼ï¼‰

### 6.3 å½¢å¼åŒ–éªŒè¯ï¼ˆKeY Projectï¼‰

**å·¥å…·**ï¼šKeYï¼ˆJava å½¢å¼åŒ–éªŒè¯ï¼‰

**æˆæœ**ï¼š

- å®Œæ•´ Java Timsort éªŒè¯
- å‘ç°åŸå§‹ JDK bug
- 2015 å¹´ä¿®å¤ï¼ˆJDK 9ï¼‰

**è§„èŒƒç¤ºä¾‹**ï¼ˆä¼ªä»£ç ï¼‰ï¼š

```java
/*@ requires sorted(runs, 0, runCount);
  @ requires stackInvariant(runs, runCount);
  @ ensures sorted(runs, 0, runCount);
  @ ensures stackInvariant(runs, runCount);
  @*/
private void mergeCollapse() {
    while (runCount > 1) {
        int n = runCount - 2;
        if ((n > 0 && runLen[n-1] <= runLen[n] + runLen[n+1]) ||
            (n > 1 && runLen[n-2] <= runLen[n-1] + runLen[n])) {
            if (runLen[n-1] < runLen[n+1])
                n--;
            mergeAt(n);
        } else if (runLen[n] <= runLen[n+1]) {
            mergeAt(n);
        } else {
            break;
        }
    }
}
```

---

## 7. ç®—æ³•åˆ†æçš„å½¢å¼åŒ–

### 7.1 Master Theorem å½¢å¼åŒ–

**å®šç†**ï¼ˆä¸»å®šç†ï¼‰ï¼š

```text
T(n) = aÂ·T(n/b) + f(n)

æƒ…å†µ1ï¼šè‹¥ f(n) = O(n^c), c < log_b a
       åˆ™ T(n) = Î˜(n^{log_b a})

æƒ…å†µ2ï¼šè‹¥ f(n) = Î˜(n^cÂ·log^k n), c = log_b a
       åˆ™ T(n) = Î˜(n^cÂ·log^{k+1} n)

æƒ…å†µ3ï¼šè‹¥ f(n) = Î©(n^c), c > log_b a
       ä¸” aÂ·f(n/b) â‰¤ kÂ·f(n) for some k < 1
       åˆ™ T(n) = Î˜(f(n))
```

**Lean4 å½¢å¼åŒ–**ï¼š

```lean
theorem master_theorem_case1 
  (a b : â„•) 
  (f : â„• â†’ â„) 
  (c : â„) 
  (ha : a > 0) 
  (hb : b > 1) 
  (hf : âˆ€ n, f n = O (n ^ c)) 
  (hc : c < Real.log a / Real.log b) :
  let T := fun n => a * T (n / b) + f n
  âˆƒ k, âˆ€ n, T n = Î˜ (n ^ (Real.log a / Real.log b)) := by
  sorry
```

### 7.2 æ‘Šè¿˜åˆ†æå½¢å¼åŒ–

**åŠ¿èƒ½å‡½æ•°æ³•**ï¼š

```text
æ‘Šè¿˜æˆæœ¬ = å®é™…æˆæœ¬ + Î¦(çŠ¶æ€') - Î¦(çŠ¶æ€)

è¦æ±‚ï¼šÎ¦(åˆå§‹) = 0, Î¦(ä»»æ„çŠ¶æ€) â‰¥ 0

åˆ™æ€»æ‘Šè¿˜æˆæœ¬ â‰¥ æ€»å®é™…æˆæœ¬
```

**ç¤ºä¾‹**ï¼ˆåŠ¨æ€æ•°ç»„ï¼‰ï¼š

```coq
Definition potential (arr : DynamicArray) : nat :=
  2 * (arr.(size) - arr.(capacity) / 2).

Theorem amortized_push_O1 : forall arr x,
  potential arr >= 0 ->
  amortized_cost (push arr x) = O(1).
Proof.
  intros arr x Hpot.
  unfold amortized_cost.
  destruct (arr.(size) < arr.(capacity)) eqn:E.
  - (* æ— æ‰©å®¹ *)
    simpl. omega.
  - (* æ‰©å®¹ *)
    (* å®é™…æˆæœ¬ = O(n)ï¼Œä½†åŠ¿èƒ½ä¸‹é™ O(n) *)
    admit.
Admitted.
```

---

## 8. å·¥å…·å¯¹æ¯”

### 8.1 éªŒè¯å™¨å¯¹æ¯”

| å·¥å…· | è‡ªåŠ¨åŒ– | è¡¨è¾¾åŠ› | å­¦ä¹ æ›²çº¿ | é€‚ç”¨åœºæ™¯ |
|------|--------|--------|----------|----------|
| **Dafny** | é«˜ï¼ˆSMTï¼‰ | ä¸­ | ä½ | å¿«é€ŸéªŒè¯ |
| **Why3** | é«˜ï¼ˆå¤šæ±‚è§£å™¨ï¼‰ | ä¸­ | ä¸­ | å¤šåç«¯éœ€æ±‚ |
| **Coq** | ä½ï¼ˆæ‰‹å·¥è¯æ˜ï¼‰ | æé«˜ | é«˜ | å¤æ‚æ•°å­¦è¯æ˜ |
| **Lean4** | ä¸­ï¼ˆç­–ç•¥ï¼‰ | æé«˜ | ä¸­ | æ•°å­¦åŒ–ç¼–ç¨‹ |
| **F*** | ä¸­ï¼ˆSMT+æ‰‹å·¥ï¼‰ | é«˜ | ä¸­ | ä¾èµ–ç±»å‹ |

### 8.2 é€‰æ‹©å»ºè®®

```text
åœºæ™¯1ï¼šæ•™å­¦ã€å¿«é€ŸéªŒè¯
  â†’ Dafnyï¼ˆè‡ªåŠ¨åŒ–é«˜ï¼‰

åœºæ™¯2ï¼šå·¥ä¸šé¡¹ç›®ã€å¤šè¯­è¨€
  â†’ Why3ï¼ˆå¯ç”Ÿæˆ C/OCaml/Javaï¼‰

åœºæ™¯3ï¼šæ•°å­¦è¯æ˜ã€è®ºæ–‡
  â†’ Coq/Isabelleï¼ˆå¯ä¿¡åº¦é«˜ï¼‰

åœºæ™¯4ï¼šRustç”Ÿæ€
  â†’ Lean4ï¼ˆä¸ Rust é£æ ¼æ¥è¿‘ï¼‰

åœºæ™¯5ï¼šå®‰å…¨å…³é”®ç³»ç»Ÿ
  â†’ F*ï¼ˆå¾®è½¯ SymCrypt ä½¿ç”¨ï¼‰
```

---

## 9. å¤§å­¦è¯¾ç¨‹å¯¹åº”

| è¯¾ç¨‹ | ç›¸å…³ç« èŠ‚ |
|------|----------|
| **CMU 15-414 Bug Catching** | Dafny, è‡ªåŠ¨éªŒè¯ |
| **MIT 6.512 å½¢å¼éªŒè¯** | Coq, å½’å¹¶æ’åºè¯æ˜ |
| **Stanford CS 357 è‡ªåŠ¨åŒ–æ¨ç†** | Why3, SMT æ±‚è§£å™¨ |
| **UIUC CS 477 å½¢å¼åŒ–æ–¹æ³•** | Hoare é€»è¾‘, æˆæœ¬è¯­ä¹‰ |
| **Waterloo CS 766 ç¨‹åºè¯æ˜** | åˆ†ç¦»é€»è¾‘, å¤æ‚åº¦åˆ†æ |

---

## 10. æ•™æä¸è®ºæ–‡

### æ ¸å¿ƒè®ºæ–‡

1. **Timsort éªŒè¯**ï¼š
   - de Gouw, S., et al. (2015). *Verifying the Dual Pivot Quicksort*. OOPSLA 2015.

2. **å¤æ‚åº¦ç±»å‹**ï¼š
   - Hoffmann, J., et al. (2017). *Resource Aware ML*. POPL 2017.

3. **æ‘Šè¿˜åˆ†æå½¢å¼åŒ–**ï¼š
   - Nipkow, T. (2015). *Amortized Complexity Verified*. ITP 2015.

### æ¨èæ•™æ

- *Program Proofs* (K. Rustan M. Leino) - Dafny å®˜æ–¹æ•™æ
- *Software Foundations Vol 3* - Coq ä¸­çš„ç®—æ³•éªŒè¯
- *The Science of Programming* (David Gries) - Hoare é€»è¾‘åŸºç¡€

---

## å¿«é€Ÿå‚è€ƒ

### æ ¸å¿ƒæ¨¡å¼

```text
ç®—æ³•è§„èŒƒ = {P} Algorithm {Q, Îº}

éªŒè¯æµç¨‹ï¼š
  1. å®šä¹‰å‰ç½®æ¡ä»¶ P
  2. å®šä¹‰åç½®æ¡ä»¶ Q
  3. ç»™å‡ºå¾ªç¯ä¸å˜å¼
  4. è¯æ˜éƒ¨åˆ†æ­£ç¡®æ€§ï¼ˆP â‡’ Qï¼‰
  5. è¯æ˜ç»ˆæ­¢æ€§ï¼ˆdecreasesï¼‰
  6. åˆ†æå¤æ‚åº¦ï¼ˆÎºï¼‰
```

### å·¥å…·é“¾

```bash
# Dafny
dafny /compile:0 algorithm.dfy

# Why3
why3 prove -P alt-ergo algorithm.mlw

# Coq
coqc algorithm.v

# Lean4
lake build
```

### å®æˆ˜å»ºè®®

1. **ä»ç®€å•å¼€å§‹**ï¼šäºŒåˆ†æŸ¥æ‰¾ã€çº¿æ€§æŸ¥æ‰¾
2. **æ¸è¿›å¤æ‚**ï¼šæ’åºã€å›¾ç®—æ³•
3. **å­¦ä¹ ç­–ç•¥**ï¼šCoq çš„ `auto`, `omega`; Dafny çš„ `assert`
4. **å‚è€ƒæ¡ˆä¾‹**ï¼šSoftware Foundations, Verified Software Toolchain

---

## é™„å½• Aï¼šWikipedia æ¦‚å¿µå¯¹ç…§

| æ¦‚å¿µ | Wikipedia æ¡ç›® | æœ¬æ–‡ç« èŠ‚ |
|------|----------------|----------|
| Hoare Logic | <https://en.wikipedia.org/wiki/Hoare_logic> | Â§1.1 |
| Dafny | <https://en.wikipedia.org/wiki/Dafny> | Â§2 |
| Why3 | <https://why3.lri.fr/> | Â§5 |
| Timsort | <https://en.wikipedia.org/wiki/Timsort> | Â§6 |
| Master Theorem | <https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)> | Â§7.1 |

---

**ç‰ˆæœ¬**ï¼šv1.0  
**æœ€åæ›´æ–°**ï¼š2025-10-29  
**ç»´æŠ¤è€…**ï¼šFormalScience Project  
**è®¸å¯**ï¼šCC BY-SA 4.0
