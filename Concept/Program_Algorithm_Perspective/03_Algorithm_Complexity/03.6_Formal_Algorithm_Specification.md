# 算法形式化规范

## 📊 核心概念深度分析

<details>
<summary><b>📐🔬 点击展开：算法形式化核心洞察</b></summary>

**终极洞察**: 算法形式化=从代码到定理。三层规范：①功能正确性：{前置P} Algorithm {后置Q}，用Hoare逻辑/分离逻辑描述输入输出关系②复杂度界限：证明T(n)≤f(n)、S(n)≤g(n)，用递推关系+归纳法③终止性：证明存在良基序递减。工具链：①Dafny（自动SMT求解）：内置验证，decreases子句证明终止②Coq（交互式证明）：手工策略证明，完全可信，如归并排序完整证明③Lean4（依赖类型）：类型即命题，程序即证明，如排序的Sorted谓词④Why3（多后端）：统一前端，生成Coq/Alt-Ergo/Z3证明⑤K-Framework（成本语义）：扩展操作语义附加资源计数。经典案例：①Timsort验证（Python/Java标准库，KeY项目发现bug）②CompCert（验证的C编译器，Coq）③seL4（验证的微内核，Isabelle/HOL）。复杂度形式化：Master定理、势能分析、摊还分析的Coq证明。挑战：复杂度证明比正确性证明更难（需要精确递推式）。关键：形式化规范将算法从工程实践提升为数学定理，是高保障软件的基础。

</details>

---

## 📋 目录

- [概述](#概述)
- [1. 规范语言](#1-规范语言)
  - [1.1 Hoare 三元组](#11-hoare-三元组)
  - [1.2 扩展：成本语义](#12-扩展成本语义)
  - [1.3 分离逻辑规范](#13-分离逻辑规范)
- [2. Dafny：自动验证语言](#2-dafny自动验证语言)
  - [2.1 基本语法](#21-基本语法)
  - [2.2 验证示例](#22-验证示例)
  - [2.3 复杂度注解（非标准扩展）](#23-复杂度注解非标准扩展)
- [3. Lean4：依赖类型规范](#3-lean4依赖类型规范)
  - [3.1 列表排序规范](#31-列表排序规范)
  - [3.2 复杂度类型](#32-复杂度类型)
- [4. Coq：归并排序完整证明](#4-coq归并排序完整证明)
  - [4.1 定义与规范](#41-定义与规范)
  - [4.2 归并排序实现](#42-归并排序实现)
  - [4.3 正确性证明](#43-正确性证明)
  - [4.4 复杂度证明](#44-复杂度证明)
- [5. Why3：多后端验证](#5-why3多后端验证)
  - [5.1 Why3ML 语法](#51-why3ml-语法)
  - [5.2 生成 Coq 证明](#52-生成-coq-证明)
- [6. 实际案例：Timsort 形式化](#6-实际案例timsort-形式化)
  - [6.1 Timsort 算法概述](#61-timsort-算法概述)
  - [6.2 关键不变式](#62-关键不变式)
  - [6.3 形式化验证（KeY Project）](#63-形式化验证key-project)
- [7. 算法分析的形式化](#7-算法分析的形式化)
  - [7.1 Master Theorem 形式化](#71-master-theorem-形式化)
  - [7.2 摊还分析形式化](#72-摊还分析形式化)
- [8. 工具对比](#8-工具对比)
- [9. 大学课程对应](#9-大学课程对应)
- [10. 教材与论文](#10-教材与论文)

---

## 概述

**算法形式化规范**是用数学语言精确定义算法的**行为**、**正确性**和**复杂度**，使得算法可以被**机器验证**。

**核心思想**：

```text
算法规范 = 前置条件 + 后置条件 + 复杂度界限

规范 ::= {P} Algorithm {Q, κ}
  P: 前置条件（Precondition）
  Q: 后置条件（Postcondition）
  κ: 成本界限（Cost Bound）

验证目标：
  ∀输入 σ, P(σ) ⇒ (Algorithm(σ)↓ ∧ Q(σ') ∧ Cost ≤ κ(n))
```

**形式化方法**：

1. **Hoare 逻辑**：{P} S {Q}
2. **分离逻辑**：带资源的 Hoare 逻辑
3. **依赖类型**：类型中编码规范（Lean4, Agda）
4. **Why3/Dafny**：自动验证语言

**应用场景**：

- ✅ **关键算法**：加密、共识、安全
- ✅ **库函数**：标准库、数值库
- ✅ **教学**：算法正确性教学
- ❌ **快速原型**：验证成本高

---

## 1. 规范语言

### 1.1 Hoare 三元组

**基本形式**：

```text
{P} S {Q}

含义：
  若 P(σ) 成立且 S 在 σ 上执行终止到 σ',
  则 Q(σ') 成立
```

**示例**（整数绝对值）：

```text
{true}
  if x >= 0 then
    y := x
  else
    y := -x
{y >= 0 ∧ (y = x ∨ y = -x)}
```

### 1.2 扩展：成本语义

**形式**：

```text
{P} S {Q, κ}

含义：
  {P} S {Q}  ∧  Time(S) ≤ κ(n)
```

**示例**（二分查找）：

```text
{sorted(arr) ∧ n = |arr|}
  binary_search(arr, target)
{result = -1 ∨ arr[result] = target, O(log n)}
```

### 1.3 分离逻辑规范

**形式**（带资源）：

```text
{P * R} S {Q * R}

解释：
  - P * R: 堆分离合取
  - 保留资源 R（帧规则）
```

**示例**（链表反转）：

```text
{list(head, xs)}
  reverse(head)
{list(result, reverse(xs))}
```

---

## 2. Dafny：自动验证语言

### 2.1 基本语法

**示例**（二分查找）：

```dafny
method BinarySearch(arr: array<int>, target: int) returns (index: int)
  requires arr.Length > 0
  requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]  // sorted
  ensures 0 <= index < arr.Length ==> arr[index] == target
  ensures index == -1 ==> forall i :: 0 <= i < arr.Length ==> arr[i] != target
{
  var low := 0;
  var high := arr.Length;
  
  while low < high
    invariant 0 <= low <= high <= arr.Length
    invariant forall i :: 0 <= i < low ==> arr[i] < target
    invariant forall i :: high <= i < arr.Length ==> arr[i] > target
    decreases high - low
  {
    var mid := (low + high) / 2;
    if arr[mid] < target {
      low := mid + 1;
    } else if arr[mid] > target {
      high := mid;
    } else {
      return mid;
    }
  }
  return -1;
}
```

**关键注解**：

- `requires`：前置条件
- `ensures`：后置条件
- `invariant`：循环不变式
- `decreases`：终止度量（证明终止）

### 2.2 验证示例

**运行验证**：

```bash
dafny /compile:0 binary_search.dfy
# Dafny program verifier finished with 1 verified, 0 errors
```

**自动推断**：

- Dafny 自动推断中间断言
- 调用 Z3 求解器验证 VC（Verification Condition）

### 2.3 复杂度注解（非标准扩展）

```dafny
method LinearSearch(arr: array<int>, target: int) returns (index: int)
  ensures 0 <= index < arr.Length ==> arr[index] == target
  ensures index == -1 ==> forall i :: 0 <= i < arr.Length ==> arr[i] != target
  // Non-standard: time complexity
  // Time: O(arr.Length)
{
  var i := 0;
  while i < arr.Length
    invariant 0 <= i <= arr.Length
    invariant forall j :: 0 <= j < i ==> arr[j] != target
  {
    if arr[i] == target {
      return i;
    }
    i := i + 1;
  }
  return -1;
}
```

---

## 3. Lean4：依赖类型规范

### 3.1 列表排序规范

```lean
import Mathlib.Data.List.Sort

-- 定义：有序性
def Sorted (l : List ℕ) : Prop :=
  ∀ i j, i < j → j < l.length → l[i]! ≤ l[j]!

-- 定义：排列
def Permutation (l1 l2 : List ℕ) : Prop :=
  l1.length = l2.length ∧ 
  ∀ x, l1.count x = l2.count x

-- 插入排序规范
def insertionSort (l : List ℕ) : { l' : List ℕ // Sorted l' ∧ Permutation l l' }

-- 实现
def insert (x : ℕ) (l : List ℕ) (h : Sorted l) : { l' : List ℕ // Sorted l' } :=
  match l with
  | [] => ⟨[x], by simp [Sorted]⟩
  | y :: ys =>
      if x ≤ y then
        ⟨x :: y :: ys, by
          intro i j hi hj
          cases i <;> cases j <;> simp [*]
          apply h⟩
      else
        let ⟨ys', hys'⟩ := insert x ys (by sorry)  -- 递归证明
        ⟨y :: ys', by sorry⟩

def insertionSort : (l : List ℕ) → { l' : List ℕ // Sorted l' ∧ Permutation l l' }
  | [] => ⟨[], by simp [Sorted, Permutation]⟩
  | x :: xs =>
      let ⟨xs', hxs'⟩ := insertionSort xs
      let ⟨result, hresult⟩ := insert x xs' hxs'.1
      ⟨result, by
        constructor
        · exact hresult
        · sorry  -- 证明 Permutation
      ⟩
```

### 3.2 复杂度类型

**定义 Timed Monad**：

```lean
structure Timed (α : Type) where
  value : α
  cost : ℕ

def bind {α β : Type} (ta : Timed α) (f : α → Timed β) : Timed β :=
  let tb := f ta.value
  ⟨tb.value, ta.cost + tb.cost⟩

notation:60 x " >>= " f => bind x f
```

**示例**（带成本的二分查找）：

```lean
def binarySearch (arr : Array ℕ) (target : ℕ) 
  (h : arr.sorted) : Timed (Option ℕ) :=
  let rec search (low high : ℕ) (fuel : ℕ) : Timed (Option ℕ) :=
    if fuel = 0 then
      ⟨none, 0⟩  -- 不应到达
    else if low >= high then
      ⟨none, 1⟩
    else
      let mid := (low + high) / 2
      if arr[mid]! < target then
        let ⟨result, cost⟩ := search (mid + 1) high (fuel - 1)
        ⟨result, cost + 3⟩  -- 比较 + 算术 + 递归
      else if arr[mid]! > target then
        let ⟨result, cost⟩ := search low mid (fuel - 1)
        ⟨result, cost + 3⟩
      else
        ⟨some mid, 2⟩  -- 找到
  search 0 arr.size (Nat.log2 arr.size + 1)

-- 定理：成本界限
theorem binarySearch_cost_bound (arr : Array ℕ) (target : ℕ) (h : arr.sorted) :
  let result := binarySearch arr target h
  result.cost ≤ 3 * (Nat.log2 arr.size + 1) := by
  sorry
```

---

## 4. Coq：归并排序完整证明

### 4.1 定义与规范

```coq
Require Import Coq.Lists.List.
Require Import Coq.Sorting.Sorted.
Import ListNotations.

(* 定义：排列 *)
Inductive Permutation {A : Type} : list A -> list A -> Prop :=
  | perm_nil : Permutation [] []
  | perm_skip x l l' : Permutation l l' -> Permutation (x::l) (x::l')
  | perm_swap x y l : Permutation (y::x::l) (x::y::l)
  | perm_trans l l' l'' : Permutation l l' -> Permutation l' l'' -> Permutation l l''.

(* 规范 *)
Definition sort_spec {A : Type} (f : list A -> list A) : Prop :=
  forall l, Sorted le (f l) /\ Permutation l (f l).
```

### 4.2 归并排序实现

```coq
Fixpoint merge (l1 l2 : list nat) : list nat :=
  match l1, l2 with
  | [], _ => l2
  | _, [] => l1
  | a1::l1', a2::l2' =>
      if a1 <=? a2 then a1 :: merge l1' l2
      else a2 :: merge l1 l2'
  end.

Fixpoint split (l : list nat) : list nat * list nat :=
  match l with
  | [] => ([], [])
  | [x] => ([x], [])
  | x::y::l' =>
      let (l1, l2) := split l' in
      (x::l1, y::l2)
  end.

Fixpoint mergeSort (l : list nat) : list nat :=
  match l with
  | [] => []
  | [x] => [x]
  | _ =>
      let (l1, l2) := split l in
      merge (mergeSort l1) (mergeSort l2)
  end.
```

### 4.3 正确性证明

```coq
(* 引理1：merge 保持有序性 *)
Lemma merge_sorted : forall l1 l2,
  Sorted le l1 -> Sorted le l2 -> Sorted le (merge l1 l2).
Proof.
  induction l1; intros l2 H1 H2; simpl.
  - apply H2.
  - destruct l2; simpl.
    + apply H1.
    + destruct (a <=? n) eqn:E.
      * constructor.
        ** apply IHl1.
           *** inv H1; auto.
           *** apply H2.
        ** (* 需要证明 a 是最小的 *)
           admit.
      * constructor.
        ** apply IHl1; auto.
           inv H2; auto.
        ** admit.
Admitted.

(* 引理2：merge 保持排列 *)
Lemma merge_permutation : forall l1 l2,
  Permutation (l1 ++ l2) (merge l1 l2).
Proof.
  induction l1; intros l2; simpl.
  - reflexivity.
  - destruct l2; simpl.
    + rewrite app_nil_r. reflexivity.
    + destruct (a <=? n) eqn:E.
      * apply perm_skip. apply IHl1.
      * apply perm_trans with (n :: a :: l1 ++ l2).
        ** apply perm_swap.
        ** apply perm_skip. apply IHl1.
Qed.

(* 定理：mergeSort 满足规范 *)
Theorem mergeSort_correct : sort_spec mergeSort.
Proof.
  unfold sort_spec. intro l.
  functional induction (mergeSort l); split.
  - constructor.
  - apply perm_nil.
  - constructor.
  - apply perm_skip. apply perm_nil.
  - apply merge_sorted.
    + apply IHl0.
    + apply IHl1.
  - (* 证明排列 *)
    admit.
Admitted.
```

### 4.4 复杂度证明

```coq
Require Import Coq.omega.Omega.

(* 定义成本 *)
Fixpoint merge_cost (l1 l2 : list nat) : nat :=
  match l1, l2 with
  | [], _ => 0
  | _, [] => 0
  | a1::l1', a2::l2' =>
      1 + if a1 <=? a2 then merge_cost l1' l2
          else merge_cost l1 l2'
  end.

Lemma merge_cost_bound : forall l1 l2,
  merge_cost l1 l2 <= length l1 + length l2.
Proof.
  induction l1; intros l2; simpl.
  - omega.
  - destruct l2; simpl.
    + omega.
    + destruct (a <=? n); simpl;
      specialize (IHl1 l2); omega.
Qed.

Fixpoint mergeSort_cost (l : list nat) : nat :=
  match l with
  | [] => 0
  | [_] => 0
  | _ =>
      let (l1, l2) := split l in
      let c1 := mergeSort_cost l1 in
      let c2 := mergeSort_cost l2 in
      c1 + c2 + merge_cost (mergeSort l1) (mergeSort l2)
  end.

(* 定理：O(n log n) *)
Theorem mergeSort_cost_bound : forall l,
  mergeSort_cost l <= (length l) * (Nat.log2 (length l) + 1).
Proof.
  (* 需要证明 split 平衡性 + 归纳 *)
  admit.
Admitted.
```

---

## 5. Why3：多后端验证

### 5.1 Why3ML 语法

**示例**（快速排序）：

```why3
module QuickSort
  use int.Int
  use list.List
  use list.Append
  use list.Permut
  use list.SortedInt
  
  (* 规范 *)
  val function partition (l: list int) (pivot: int) : (list int, list int, list int)
    ensures { let (less, eq, greater) = result in
              permut (l) (less ++ eq ++ greater) /\
              (forall x. mem x less -> x < pivot) /\
              (forall x. mem x eq -> x = pivot) /\
              (forall x. mem x greater -> x > pivot) }
  
  let rec quicksort (l: list int) : list int
    ensures { sorted result /\ permut l result }
    variant { length l }
  =
    match l with
    | Nil -> Nil
    | Cons pivot rest ->
        let (less, eq, greater) = partition rest pivot in
        let sorted_less = quicksort less in
        let sorted_greater = quicksort greater in
        sorted_less ++ (Cons pivot eq) ++ sorted_greater
    end
end
```

### 5.2 生成 Coq 证明

```bash
why3 prove -P coq quicksort.mlw
why3 extract -D coq quicksort.mlw -o quicksort.v
```

**生成的 Coq 代码**：

```coq
Require Import List.
Import ListNotations.

Fixpoint quicksort (l : list Z) : list Z :=
  match l with
  | nil => nil
  | pivot :: rest =>
      let '(less, eq, greater) := partition rest pivot in
      quicksort less ++ (pivot :: eq) ++ quicksort greater
  end.
```

---

## 6. 实际案例：Timsort 形式化

### 6.1 Timsort 算法概述

**特点**：

- Python、Java 标准库排序
- 混合归并排序 + 插入排序
- 利用部分有序性（runs）

**算法**：

```text
1. 扫描输入，识别单调递增/递减段（runs）
2. 短段用插入排序扩展到最小长度（minrun）
3. 用栈维护 runs，满足不变式时归并
4. 最终归并所有 runs
```

### 6.2 关键不变式

**栈不变式**：

```text
设栈顶三个 runs 长度为 X, Y, Z（从顶到底）
必须满足：
  1. Z > Y + X
  2. Y > X

否则归并
```

**漏洞**：2015 年发现 Timsort bug（违反不变式）

### 6.3 形式化验证（KeY Project）

**工具**：KeY（Java 形式化验证）

**成果**：

- 完整 Java Timsort 验证
- 发现原始 JDK bug
- 2015 年修复（JDK 9）

**规范示例**（伪代码）：

```java
/*@ requires sorted(runs, 0, runCount);
  @ requires stackInvariant(runs, runCount);
  @ ensures sorted(runs, 0, runCount);
  @ ensures stackInvariant(runs, runCount);
  @*/
private void mergeCollapse() {
    while (runCount > 1) {
        int n = runCount - 2;
        if ((n > 0 && runLen[n-1] <= runLen[n] + runLen[n+1]) ||
            (n > 1 && runLen[n-2] <= runLen[n-1] + runLen[n])) {
            if (runLen[n-1] < runLen[n+1])
                n--;
            mergeAt(n);
        } else if (runLen[n] <= runLen[n+1]) {
            mergeAt(n);
        } else {
            break;
        }
    }
}
```

---

## 7. 算法分析的形式化

### 7.1 Master Theorem 形式化

**定理**（主定理）：

```text
T(n) = a·T(n/b) + f(n)

情况1：若 f(n) = O(n^c), c < log_b a
       则 T(n) = Θ(n^{log_b a})

情况2：若 f(n) = Θ(n^c·log^k n), c = log_b a
       则 T(n) = Θ(n^c·log^{k+1} n)

情况3：若 f(n) = Ω(n^c), c > log_b a
       且 a·f(n/b) ≤ k·f(n) for some k < 1
       则 T(n) = Θ(f(n))
```

**Lean4 形式化**：

```lean
theorem master_theorem_case1 
  (a b : ℕ) 
  (f : ℕ → ℝ) 
  (c : ℝ) 
  (ha : a > 0) 
  (hb : b > 1) 
  (hf : ∀ n, f n = O (n ^ c)) 
  (hc : c < Real.log a / Real.log b) :
  let T := fun n => a * T (n / b) + f n
  ∃ k, ∀ n, T n = Θ (n ^ (Real.log a / Real.log b)) := by
  sorry
```

### 7.2 摊还分析形式化

**势能函数法**：

```text
摊还成本 = 实际成本 + Φ(状态') - Φ(状态)

要求：Φ(初始) = 0, Φ(任意状态) ≥ 0

则总摊还成本 ≥ 总实际成本
```

**示例**（动态数组）：

```coq
Definition potential (arr : DynamicArray) : nat :=
  2 * (arr.(size) - arr.(capacity) / 2).

Theorem amortized_push_O1 : forall arr x,
  potential arr >= 0 ->
  amortized_cost (push arr x) = O(1).
Proof.
  intros arr x Hpot.
  unfold amortized_cost.
  destruct (arr.(size) < arr.(capacity)) eqn:E.
  - (* 无扩容 *)
    simpl. omega.
  - (* 扩容 *)
    (* 实际成本 = O(n)，但势能下降 O(n) *)
    admit.
Admitted.
```

---

## 8. 工具对比

### 8.1 验证器对比

| 工具 | 自动化 | 表达力 | 学习曲线 | 适用场景 |
|------|--------|--------|----------|----------|
| **Dafny** | 高（SMT） | 中 | 低 | 快速验证 |
| **Why3** | 高（多求解器） | 中 | 中 | 多后端需求 |
| **Coq** | 低（手工证明） | 极高 | 高 | 复杂数学证明 |
| **Lean4** | 中（策略） | 极高 | 中 | 数学化编程 |
| **F*** | 中（SMT+手工） | 高 | 中 | 依赖类型 |

### 8.2 选择建议

```text
场景1：教学、快速验证
  → Dafny（自动化高）

场景2：工业项目、多语言
  → Why3（可生成 C/OCaml/Java）

场景3：数学证明、论文
  → Coq/Isabelle（可信度高）

场景4：Rust生态
  → Lean4（与 Rust 风格接近）

场景5：安全关键系统
  → F*（微软 SymCrypt 使用）
```

---

## 9. 大学课程对应

| 课程 | 相关章节 |
|------|----------|
| **CMU 15-414 Bug Catching** | Dafny, 自动验证 |
| **MIT 6.512 形式验证** | Coq, 归并排序证明 |
| **Stanford CS 357 自动化推理** | Why3, SMT 求解器 |
| **UIUC CS 477 形式化方法** | Hoare 逻辑, 成本语义 |
| **Waterloo CS 766 程序证明** | 分离逻辑, 复杂度分析 |

---

## 10. 教材与论文

### 核心论文

1. **Timsort 验证**：
   - de Gouw, S., et al. (2015). *Verifying the Dual Pivot Quicksort*. OOPSLA 2015.

2. **复杂度类型**：
   - Hoffmann, J., et al. (2017). *Resource Aware ML*. POPL 2017.

3. **摊还分析形式化**：
   - Nipkow, T. (2015). *Amortized Complexity Verified*. ITP 2015.

### 推荐教材

- *Program Proofs* (K. Rustan M. Leino) - Dafny 官方教材
- *Software Foundations Vol 3* - Coq 中的算法验证
- *The Science of Programming* (David Gries) - Hoare 逻辑基础

---

## 快速参考

### 核心模式

```text
算法规范 = {P} Algorithm {Q, κ}

验证流程：
  1. 定义前置条件 P
  2. 定义后置条件 Q
  3. 给出循环不变式
  4. 证明部分正确性（P ⇒ Q）
  5. 证明终止性（decreases）
  6. 分析复杂度（κ）
```

### 工具链

```bash
# Dafny
dafny /compile:0 algorithm.dfy

# Why3
why3 prove -P alt-ergo algorithm.mlw

# Coq
coqc algorithm.v

# Lean4
lake build
```

### 实战建议

1. **从简单开始**：二分查找、线性查找
2. **渐进复杂**：排序、图算法
3. **学习策略**：Coq 的 `auto`, `omega`; Dafny 的 `assert`
4. **参考案例**：Software Foundations, Verified Software Toolchain

---

## 附录 A：Wikipedia 概念对照

| 概念 | Wikipedia 条目 | 本文章节 |
|------|----------------|----------|
| Hoare Logic | <https://en.wikipedia.org/wiki/Hoare_logic> | §1.1 |
| Dafny | <https://en.wikipedia.org/wiki/Dafny> | §2 |
| Why3 | <https://why3.lri.fr/> | §5 |
| Timsort | <https://en.wikipedia.org/wiki/Timsort> | §6 |
| Master Theorem | <https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)> | §7.1 |

---

**版本**：v1.0  
**最后更新**：2025-10-29  
**维护者**：FormalScience Project  
**许可**：CC BY-SA 4.0
