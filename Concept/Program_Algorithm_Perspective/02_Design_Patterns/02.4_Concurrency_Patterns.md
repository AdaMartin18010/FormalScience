# å¹¶å‘æ¨¡å¼ï¼ˆConcurrency Patternsï¼‰

## ğŸ“Š æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ

<details>
<summary><b>âš¡ğŸ”¬ ç‚¹å‡»å±•å¼€ï¼šå¹¶å‘æ¨¡å¼æ ¸å¿ƒæ´å¯Ÿ</b></summary>

**ç»ˆææ´å¯Ÿ**: å¹¶å‘ç¼–ç¨‹=éç¡®å®šæ€§çš„é©¯æœä¹‹é“ã€‚ä¸‰å¤§èŒƒå¼ï¼šâ‘ æ¶ˆæ¯ä¼ é€’ï¼ˆMessage Passingï¼‰ï¼šActoræ¨¡å‹ï¼ˆErlang/Akkaï¼‰+CSPï¼ˆGolangï¼‰+Ï€-æ¼”ç®—ï¼ˆç†è®ºåŸºç¡€ï¼‰ï¼Œè¿›ç¨‹é€šè¿‡æ¶ˆæ¯é€šä¿¡ï¼Œæ— å…±äº«çŠ¶æ€ï¼Œå¤©ç„¶é¿å…æ•°æ®ç«äº‰â‘¡å…±äº«å†…å­˜ï¼ˆShared Memoryï¼‰ï¼šMutexï¼ˆäº’æ–¥ï¼‰+RwLockï¼ˆè¯»å†™é”ï¼‰+Atomicï¼ˆåŸå­æ“ä½œï¼‰+STMï¼ˆè½¯ä»¶äº‹åŠ¡å†…å­˜ï¼‰ï¼Œéœ€è¦ç²¾å¿ƒè®¾è®¡åŒæ­¥åŸè¯­é¿å…æ­»é”/ç«æ€â‘¢æ··åˆæ¨¡å‹ï¼šRustï¼ˆSend/Sync trait+æ‰€æœ‰æƒï¼‰ï¼Œç¼–è¯‘æœŸä¿è¯çº¿ç¨‹å®‰å…¨ã€‚å½¢å¼åŒ–å·¥å…·ï¼šâ‘ è¿›ç¨‹ä»£æ•°ï¼ˆCCS/CSP/Ï€-æ¼”ç®—ï¼‰ï¼šå»ºæ¨¡å¹¶å‘äº¤äº’â‘¡æ—¶åºé€»è¾‘ï¼ˆLTL/CTLï¼‰ï¼šéªŒè¯å®‰å…¨æ€§ï¼ˆ"åäº‹ä¸å‘ç”Ÿ"ï¼‰å’Œæ´»æ€§ï¼ˆ"å¥½äº‹ç»ˆå°†å‘ç”Ÿ"ï¼‰â‘¢åˆ†ç¦»é€»è¾‘ï¼ˆConcurrent Separation Logicï¼‰ï¼šæ¨ç†å…±äº«çŠ¶æ€â‘£Irisé€»è¾‘ï¼šRustå¹¶å‘éªŒè¯åŸºç¡€ã€‚ç»å…¸é—®é¢˜ï¼šå“²å­¦å®¶å°±é¤ã€è¯»è€…å†™è€…ã€ç”Ÿäº§è€…æ¶ˆè´¹è€…ã€‚éªŒè¯æŠ€æœ¯ï¼šæ¨¡å‹æ£€æµ‹ï¼ˆTLA+/SPINï¼‰ã€å®šç†è¯æ˜ï¼ˆCoq/Irisï¼‰ã€åŠ¨æ€åˆ†æï¼ˆThreadSanitizer/Loomï¼‰ã€‚å…³é”®ï¼šå¹¶å‘æ¨¡å¼é€šè¿‡ç»“æ„åŒ–å¹¶å‘æ¶ˆé™¤éç¡®å®šæ€§å¸¦æ¥çš„æ··ä¹±ã€‚

</details>

---

## ğŸ“‹ ç›®å½•

- [ğŸ“Š æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ](#æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ)
- [ğŸ“‹ ç›®å½•](#ç›®å½•)
- [æ¦‚è¿°](#æ¦‚è¿°)
- [1. Actor æ¨¡å‹](#1-actor-æ¨¡å‹)
  - [1.1 æ ¸å¿ƒæ¦‚å¿µ](#11-æ ¸å¿ƒæ¦‚å¿µ)
  - [1.2 å½¢å¼åŒ–å®šä¹‰](#12-å½¢å¼åŒ–å®šä¹‰)
  - [1.3 Scala Akka ç¤ºä¾‹](#13-scala-akka-ç¤ºä¾‹)
  - [1.4 æ— æ­»é”è¯æ˜](#14-æ— æ­»é”è¯æ˜)
- [2. CSPï¼ˆCommunicating Sequential Processesï¼‰](#2-cspcommunicating-sequential-processes)
  - [2.1 æ ¸å¿ƒæ¦‚å¿µ](#21-æ ¸å¿ƒæ¦‚å¿µ)
  - [2.2 å½¢å¼åŒ–å®šä¹‰](#22-å½¢å¼åŒ–å®šä¹‰)
  - [2.3 Golang å®ç°](#23-golang-å®ç°)
    - [å¸¦ç¼“å†² vs æ— ç¼“å†²](#å¸¦ç¼“å†²-vs-æ— ç¼“å†²)
  - [2.4 Select å¤šè·¯å¤ç”¨](#24-select-å¤šè·¯å¤ç”¨)
  - [2.5 æ­»é”æ£€æµ‹](#25-æ­»é”æ£€æµ‹)
- [3. Ï€-æ¼”ç®—ï¼ˆPi-Calculusï¼‰](#3--æ¼”ç®—pi-calculus)
  - [3.1 æ ¸å¿ƒæ¦‚å¿µ](#31-æ ¸å¿ƒæ¦‚å¿µ)
  - [3.2 å½’çº¦è¯­ä¹‰](#32-å½’çº¦è¯­ä¹‰)
  - [3.3 ç¤ºä¾‹ï¼šç§»åŠ¨ç”µè¯åˆ‡æ¢](#33-ç¤ºä¾‹ç§»åŠ¨ç”µè¯åˆ‡æ¢)
  - [3.4 mCRL2 Ï€-æ¼”ç®—ç¼–ç ](#34-mcrl2--æ¼”ç®—ç¼–ç )
- [4. å…±äº«å†…å­˜æ¨¡å¼](#4-å…±äº«å†…å­˜æ¨¡å¼)
  - [4.1 Mutexï¼ˆäº’æ–¥é”ï¼‰](#41-mutexäº’æ–¥é”)
  - [4.2 Reader-Writer Lock](#42-reader-writer-lock)
  - [4.3 Condition Variableï¼ˆæ¡ä»¶å˜é‡ï¼‰](#43-condition-variableæ¡ä»¶å˜é‡)
  - [4.4 Atomic Operationsï¼ˆåŸå­æ“ä½œï¼‰](#44-atomic-operationsåŸå­æ“ä½œ)
- [5. å¹¶å‘æ¨¡å¼éªŒè¯](#5-å¹¶å‘æ¨¡å¼éªŒè¯)
  - [5.1 éªŒè¯æŠ€æœ¯](#51-éªŒè¯æŠ€æœ¯)
  - [5.2 Iris é€»è¾‘ï¼ˆRust å¹¶å‘éªŒè¯ï¼‰](#52-iris-é€»è¾‘rust-å¹¶å‘éªŒè¯)
  - [5.3 Loomï¼ˆRust å¹¶å‘æµ‹è¯•ï¼‰](#53-loomrust-å¹¶å‘æµ‹è¯•)
- [6. å¹¶å‘æ¨¡å¼å¯¹æ¯”](#6-å¹¶å‘æ¨¡å¼å¯¹æ¯”)
- [7. å¹¶å‘æ¨¡å¼çš„å…¸å‹é—®é¢˜](#7-å¹¶å‘æ¨¡å¼çš„å…¸å‹é—®é¢˜)
  - [7.1 å“²å­¦å®¶å°±é¤é—®é¢˜](#71-å“²å­¦å®¶å°±é¤é—®é¢˜)
    - [CSP è§£æ³•](#csp-è§£æ³•)
    - [Golang å®ç°ï¼ˆèµ„æºæ’åºï¼‰](#golang-å®ç°èµ„æºæ’åº)
  - [7.2 ç”Ÿäº§è€…-æ¶ˆè´¹è€…](#72-ç”Ÿäº§è€…-æ¶ˆè´¹è€…)
    - [Actor å®ç°](#actor-å®ç°)
    - [Golang å®ç°ï¼ˆé€šé“ï¼‰](#golang-å®ç°é€šé“)
- [8. å¤§å­¦è¯¾ç¨‹å¯¹åº”](#8-å¤§å­¦è¯¾ç¨‹å¯¹åº”)
- [9. æ•™æå¯¹åº”](#9-æ•™æå¯¹åº”)
- [10. æœ¬åœ°é¡¹ç›®å¼•ç”¨](#10-æœ¬åœ°é¡¹ç›®å¼•ç”¨)
- [11. æ€»ç»“](#11-æ€»ç»“)
  - [æ ¸å¿ƒæ´å¯Ÿ](#æ ¸å¿ƒæ´å¯Ÿ)
  - [å·¥å…·é“¾æ¨è](#å·¥å…·é“¾æ¨è)
  - [å®æˆ˜å»ºè®®](#å®æˆ˜å»ºè®®)
- [é™„å½• Aï¼šå¹¶å‘åŸè¯­å¯¹æ¯”](#é™„å½•-aå¹¶å‘åŸè¯­å¯¹æ¯”)
- [é™„å½• Bï¼šWikipedia æ¦‚å¿µå¯¹ç…§](#é™„å½•-bwikipedia-æ¦‚å¿µå¯¹ç…§)

---

## æ¦‚è¿°

**å¹¶å‘æ¨¡å¼**æè¿°å¤šä¸ªæ‰§è¡Œå•å…ƒå¦‚ä½•å®‰å…¨ã€é«˜æ•ˆåœ°å…±äº«èµ„æºå’Œé€šä¿¡ã€‚ä»å½¢å¼åŒ–è§†è§’ï¼Œå¹¶å‘æ¨¡å¼æ˜¯**è¿›ç¨‹ä»£æ•°**ï¼ˆProcess Algebraï¼‰çš„å®ä¾‹ï¼Œä¸»è¦åŒ…æ‹¬ï¼š

1. **Actor æ¨¡å‹**ï¼šæ¶ˆæ¯ä¼ é€’ï¼Œæ— å…±äº«çŠ¶æ€
2. **CSP**ï¼ˆCommunicating Sequential Processesï¼‰ï¼šåŒæ­¥é€šé“
3. **Ï€-æ¼”ç®—**ï¼šåŠ¨æ€åˆ›å»ºé€šé“
4. **å…±äº«å†…å­˜æ¨¡å¼**ï¼šé”ã€æ¡ä»¶å˜é‡ã€åŸå­æ“ä½œ

**æ ¸å¿ƒæ´å¯Ÿ**ï¼š

```text
å¹¶å‘æ¨¡å¼ = è¿›ç¨‹ä»£æ•° + åŒæ­¥æœºåˆ¶

éªŒè¯ = æ¨¡å‹æ£€æµ‹ + å®šç†è¯æ˜
  - æ— æ­»é”ï¼ˆDeadlock Freedomï¼‰
  - æ´»æ€§ï¼ˆLivenessï¼‰
  - æ•°æ®ç«äº‰è‡ªç”±ï¼ˆData Race Freedomï¼‰
```

æœ¬æ–‡å°†ç³»ç»Ÿä»‹ç»ï¼š
    - 1. Actor æ¨¡å‹çš„å½¢å¼åŒ–
    - 2. CSP ä¸ Golang å®è·µ
    - 3. Ï€-æ¼”ç®—ä¸åŠ¨æ€å¹¶å‘
    - 4. å…±äº«å†…å­˜æ¨¡å¼ä¸éªŒè¯
    - 5. å¹¶å‘æ¨¡å¼çš„æœºå™¨éªŒè¯

---

## 1. Actor æ¨¡å‹

### 1.1 æ ¸å¿ƒæ¦‚å¿µ

**Actor** æ˜¯å¹¶å‘çš„åŸºæœ¬å•å…ƒï¼Œå…·æœ‰ï¼š

- **é‚®ç®±**ï¼ˆMailboxï¼‰ï¼šå­˜å‚¨æ¥æ”¶çš„æ¶ˆæ¯
- **è¡Œä¸º**ï¼ˆBehaviorï¼‰ï¼šå¤„ç†æ¶ˆæ¯çš„å‡½æ•°
- **çŠ¶æ€**ï¼ˆStateï¼‰ï¼šç§æœ‰ï¼Œä¸å…±äº«

**ä¸‰å¤§èƒ½åŠ›**ï¼š

1. **å‘é€æ¶ˆæ¯**ï¼šéé˜»å¡ï¼Œå¼‚æ­¥
2. **åˆ›å»º Actor**ï¼šåŠ¨æ€æ‰©å±•
3. **æ”¹å˜è¡Œä¸º**ï¼šä¸‹æ¬¡æ¶ˆæ¯ç”¨æ–°è¡Œä¸ºå¤„ç†

### 1.2 å½¢å¼åŒ–å®šä¹‰

**è¯­æ³•**ï¼š

```text
Actor a ::= receive
            | aâ‚ | aâ‚‚                  (å¹¶è¡Œç»„åˆ)
            | Î½a. A                    (æ–°å»º Actor)
            | send(a, msg)            (å‘é€æ¶ˆæ¯)
            | become(behavior)        (æ”¹å˜è¡Œä¸º)

æ¶ˆæ¯ï¼š
  msg âˆˆ Msg
```

**è¯­ä¹‰ï¼ˆLTSï¼‰**ï¼š

```text
å‘é€ï¼š
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  âŸ¨send(a, m), ÏƒâŸ© â†’ âŸ¨skip, Ïƒ[mailbox(a) â† mailbox(a) ++ [m]]âŸ©

æ¥æ”¶ï¼š
  mailbox(a) = m :: rest
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  âŸ¨receive, ÏƒâŸ© â†’ âŸ¨handle(m), Ïƒ[mailbox(a) â† rest]âŸ©

åˆ›å»ºï¼š
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  âŸ¨Î½a. A, ÏƒâŸ© â†’ âŸ¨A, Ïƒ[actors â† actors âˆª {a}]âŸ©
```

### 1.3 Scala Akka ç¤ºä¾‹

```scala
import akka.actor._

// å®šä¹‰æ¶ˆæ¯
case class Greet(name: String)
case object Goodbye

// å®šä¹‰ Actor
class GreeterActor extends Actor {
  def receive = {
    case Greet(name) =>
      println(s"Hello, $name")
      sender() ! Goodbye  // å›å¤å‘é€è€…
    
    case Goodbye =>
      context.stop(self)  // åœæ­¢è‡ªå·±
  }
}

// ä½¿ç”¨
val system = ActorSystem("HelloSystem")
val greeter = system.actorOf(Props[GreeterActor], "greeter")

greeter ! Greet("Alice")
```

### 1.4 æ— æ­»é”è¯æ˜

**å®šç†**ï¼ˆActor æ— æ­»é”ï¼‰ï¼š

```text
è‹¥ Actor ç³»ç»Ÿæ»¡è¶³ï¼š
  1. é‚®ç®±æ— ç•Œï¼ˆæˆ–è¶³å¤Ÿå¤§ï¼‰
  2. å‘é€éé˜»å¡
åˆ™ä¸å­˜åœ¨æ­»é”ï¼ˆæ‰€æœ‰ Actor éƒ½åœ¨ç­‰å¾…ï¼‰
```

**è¯æ˜è‰å›¾**ï¼š

```text
å‡è®¾å­˜åœ¨æ­»é”çŠ¶æ€ Ïƒï¼Œåˆ™ï¼š
  âˆ€a âˆˆ actors, mailbox(a) = [] âˆ§ a åœ¨ receive å¤„é˜»å¡

ä½†å‘é€æ˜¯éé˜»å¡çš„ï¼Œè‡³å°‘æœ‰ä¸€ä¸ª Actor å¯ä»¥å‘é€æ¶ˆæ¯ï¼ŒçŸ›ç›¾ âœ—
```

**mCRL2 å½¢å¼åŒ–**ï¼š

```mcrl2
sort Actor = struct a1 | a2;
     Msg = struct hello | bye;

act send, receive : Actor # Msg;

proc A(id: Actor) =
  sum m:Msg. receive(id, m) . 
    (send(id, bye) . A(id) + delta);

init A(a1) | A(a2);
```

**éªŒè¯**ï¼š

```bash
mcrl22lps actor.mcrl2 | lps2lts -v | ltsconvert -e deadlock
# è¾“å‡ºï¼šNo deadlocks
```

---

## 2. CSPï¼ˆCommunicating Sequential Processesï¼‰

### 2.1 æ ¸å¿ƒæ¦‚å¿µ

**CSP** å¼ºè°ƒ**åŒæ­¥é€šä¿¡**ï¼š

- **é€šé“**ï¼ˆChannelï¼‰ï¼šå‘é€æ–¹å’Œæ¥æ”¶æ–¹**åŒæ—¶å‡†å¤‡å¥½**æ‰èƒ½é€šä¿¡
- **é€‰æ‹©**ï¼ˆChoiceï¼‰ï¼š`P â–¡ Q` å¤–éƒ¨é€‰æ‹©ï¼Œ`P âŠ“ Q` å†…éƒ¨é€‰æ‹©
- **å¹¶è¡Œ**ï¼ˆParallelï¼‰ï¼š`P || Q` ç‹¬ç«‹äº¤é”™ï¼Œ`P |[A]| Q` åœ¨ A ä¸ŠåŒæ­¥

### 2.2 å½¢å¼åŒ–å®šä¹‰

**è¯­æ³•**ï¼š

```text
P ::= SKIP                         (ç©ºè¿›ç¨‹)
    | STOP                         (æ­»é”)
    | a â†’ P                        (äº‹ä»¶å‰ç¼€)
    | P â–¡ Q                        (å¤–éƒ¨é€‰æ‹©)
    | P âŠ“ Q                        (å†…éƒ¨é€‰æ‹©)
    | P || Q                       (äº¤é”™å¹¶è¡Œ)
    | P |[A]| Q                    (åŒæ­¥å¹¶è¡Œ)
    | P \ A                        (éšè—äº‹ä»¶)
    | P ; Q                        (é¡ºåºç»„åˆ)
```

**è¯­ä¹‰ï¼ˆTracesï¼‰**ï¼š

```text
traces(SKIP) = {âŸ¨âŸ©}
traces(a â†’ P) = {âŸ¨âŸ©} âˆª {âŸ¨aâŸ© ++ t | t âˆˆ traces(P)}
traces(P â–¡ Q) = traces(P) âˆª traces(Q)
traces(P || Q) = traces(P) |||  traces(Q)  (äº¤é”™)
```

### 2.3 Golang å®ç°

Golang çš„ **channel** æ˜¯ CSP çš„ç›´æ¥å®ç°ï¼š

```go
package main

import "fmt"

func producer(ch chan int) {
    for i := 0; i < 5; i++ {
        ch <- i  // å‘é€ï¼Œé˜»å¡ç›´åˆ°æ¥æ”¶æ–¹å‡†å¤‡å¥½
    }
    close(ch)
}

func consumer(ch chan int) {
    for v := range ch {
        fmt.Println("Received:", v)
    }
}

func main() {
    ch := make(chan int)  // æ— ç¼“å†²é€šé“ï¼ˆåŒæ­¥ï¼‰
    go producer(ch)
    go consumer(ch)
}
```

#### å¸¦ç¼“å†² vs æ— ç¼“å†²

```go
// æ— ç¼“å†²ï¼šå‘é€é˜»å¡ç›´åˆ°æ¥æ”¶
ch := make(chan int)

// æœ‰ç¼“å†²ï¼šå‘é€åœ¨ç¼“å†²æ»¡æ—¶é˜»å¡
ch := make(chan int, 10)
```

### 2.4 Select å¤šè·¯å¤ç”¨

```go
func multiplex(ch1, ch2 chan int, quit chan bool) {
    for {
        select {
        case v := <-ch1:
            fmt.Println("From ch1:", v)
        case v := <-ch2:
            fmt.Println("From ch2:", v)
        case <-quit:
            return
        }
    }
}
```

**CSP å¯¹åº”**ï¼š

```text
P = (ch1?v â†’ print(v) . P)
    â–¡
    (ch2?v â†’ print(v) . P)
    â–¡
    (quit? â†’ SKIP)
```

### 2.5 æ­»é”æ£€æµ‹

**å®šç†**ï¼ˆCSP æ­»é”åˆ¤å®šï¼‰ï¼š

```text
P æœ‰æ­»é” âŸº STOP âˆˆ traces(P)
```

**FDRï¼ˆFailures-Divergences Refinementï¼‰å·¥å…·**ï¼š

```csp
channel send, receive : Int

PRODUCER = send!0 -> send!1 -> SKIP
CONSUMER = receive?x -> receive?y -> SKIP
SYSTEM = PRODUCER ||| CONSUMER

assert SYSTEM :[deadlock free [F]]
```

**éªŒè¯**ï¼š

```bash
fdr example.csp
# è¾“å‡ºï¼šPassed
```

---

## 3. Ï€-æ¼”ç®—ï¼ˆPi-Calculusï¼‰

### 3.1 æ ¸å¿ƒæ¦‚å¿µ

**Ï€-æ¼”ç®—**æ‰©å±• CSPï¼Œå…è®¸**é€šé“ä½œä¸ºæ¶ˆæ¯ä¼ é€’**ï¼š

```text
P ::= 0                          (ç©ºè¿›ç¨‹)
    | a(x).P                     (æ¥æ”¶)
    | ÄâŸ¨bâŸ©.P                     (å‘é€)
    | P | Q                      (å¹¶è¡Œ)
    | Î½a.P                       (æ–°å»ºé€šé“)
    | !P                         (å¤åˆ¶)
```

**å…³é”®**ï¼šé€šé“ `a` å¯ä»¥ä½œä¸ºæ¶ˆæ¯å‘é€ï¼Œå®ç°**åŠ¨æ€æ‹“æ‰‘**ã€‚

### 3.2 å½’çº¦è¯­ä¹‰

```text
é€šä¿¡ï¼š
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  a(x).P | ÄâŸ¨bâŸ©.Q â†’ P{b/x} | Q

ä½œç”¨åŸŸæŒ¤å‡ºï¼ˆScope Extrusionï¼‰ï¼š
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  (Î½a.P) | Q â†’ Î½a.(P | Q)  if a âˆ‰ fn(Q)
```

### 3.3 ç¤ºä¾‹ï¼šç§»åŠ¨ç”µè¯åˆ‡æ¢

**åœºæ™¯**ï¼šç”µè¯ä»åŸºç«™ A åˆ‡æ¢åˆ°åŸºç«™ Bã€‚

```text
// åŸºç«™ A æŒæœ‰é€šé“ car
BaseA = carâŸ¨talkâŸ©.0

// è½¦è¾†é€šè¿‡ talk é€šé“ä¸ A é€šä¿¡
Car = car(c).câŸ¨msgâŸ©.0

// åˆ‡æ¢ï¼šA å°† talk å‘é€ç»™ B
BaseA' = handoffâŸ¨talkâŸ©.0
BaseB = handoff(c).câŸ¨msgâŸ©.0

// ç³»ç»Ÿ
SYSTEM = (Î½talk.(Î½car.BaseA | Car)) | BaseB
```

**å½’çº¦**ï¼š

```text
(Î½talk.Î½car.carâŸ¨talkâŸ©.0 | car(c).câŸ¨msgâŸ©.0) | BaseB
â†’ (Î½talk.talkâŸ¨msgâŸ©.0) | BaseB
â†’ (Î½talk.0) | handoff(c).câŸ¨msgâŸ©.0
```

### 3.4 mCRL2 Ï€-æ¼”ç®—ç¼–ç 

```mcrl2
sort Channel = struct a | b | talk;

act send, receive : Channel # Channel;

proc PiCalc =
  (receive(a, talk) . send(talk, msg) . delta)
  ||
  (send(a, talk) . delta)
  ||
  (receive(talk, msg) . delta);

init hide({send, receive}, PiCalc);
```

---

## 4. å…±äº«å†…å­˜æ¨¡å¼

### 4.1 Mutexï¼ˆäº’æ–¥é”ï¼‰

**å®šä¹‰**ï¼šä¿è¯**ä¸´ç•ŒåŒº**äº’æ–¥è®¿é—®ã€‚

**Petri ç½‘å»ºæ¨¡**ï¼š

```text
Place: mutex, critical1, critical2

Transitions:
  lock1: mutex â†’ critical1
  unlock1: critical1 â†’ mutex
  lock2: mutex â†’ critical2
  unlock2: critical2 â†’ mutex

åˆå§‹æ ‡è¯†ï¼šmutex=1
```

**æ€§è´¨**ï¼š

```text
å®šç†ï¼ˆäº’æ–¥æ€§ï¼‰ï¼š
  AG Â¬(critical1=1 âˆ§ critical2=1)
```

**Rust å®ç°**ï¼š

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

### 4.2 Reader-Writer Lock

**è§„åˆ™**ï¼š

- å¤šä¸ªè¯»è€…å¯åŒæ—¶è¯»
- å†™è€…ç‹¬å è®¿é—®

**Petri ç½‘**ï¼š

```text
Place: free, reading(n), writing

Transitions:
  acquire_read: free â†’ reading(1)
  acquire_read: reading(n) â†’ reading(n+1)
  release_read: reading(n) â†’ reading(n-1)
  release_read: reading(1) â†’ free
  acquire_write: free â†’ writing
  release_write: writing â†’ free
```

**Go å®ç°**ï¼š

```go
import "sync"

var rwlock sync.RWMutex
var data int

func reader() {
    rwlock.RLock()
    _ = data
    rwlock.RUnlock()
}

func writer() {
    rwlock.Lock()
    data++
    rwlock.Unlock()
}
```

### 4.3 Condition Variableï¼ˆæ¡ä»¶å˜é‡ï¼‰

**åœºæ™¯**ï¼šçº¿ç¨‹ç­‰å¾…æŸä¸ªæ¡ä»¶æ»¡è¶³ã€‚

**Go å®ç°**ï¼š

```go
var mu sync.Mutex
var cond = sync.NewCond(&mu)
var ready = false

func waiter() {
    mu.Lock()
    for !ready {
        cond.Wait()  // é‡Šæ”¾ mu å¹¶ç­‰å¾…
    }
    mu.Unlock()
    fmt.Println("Condition met")
}

func notifier() {
    mu.Lock()
    ready = true
    cond.Signal()  // å”¤é†’ä¸€ä¸ªç­‰å¾…è€…
    mu.Unlock()
}
```

### 4.4 Atomic Operationsï¼ˆåŸå­æ“ä½œï¼‰

**Rust ç¤ºä¾‹**ï¼š

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

static COUNTER: AtomicUsize = AtomicUsize::new(0);

fn increment() {
    COUNTER.fetch_add(1, Ordering::SeqCst);
}

fn decrement() {
    COUNTER.fetch_sub(1, Ordering::SeqCst);
}
```

**å†…å­˜æ¨¡å‹**ï¼š

- `Relaxed`ï¼šæ— åŒæ­¥ä¿è¯
- `Acquire` / `Release`ï¼šå»ºç«‹ happens-before å…³ç³»
- `SeqCst`ï¼šå…¨åºï¼ˆSequential Consistencyï¼‰

---

## 5. å¹¶å‘æ¨¡å¼éªŒè¯

### 5.1 éªŒè¯æŠ€æœ¯

| æŠ€æœ¯ | å·¥å…· | éªŒè¯æ€§è´¨ |
|------|------|----------|
| **æ¨¡å‹æ£€æµ‹** | mCRL2, FDR, SPIN | æ­»é”ã€æ´»æ€§ã€å®‰å…¨æ€§ |
| **å®šç†è¯æ˜** | Coq (Iris), Isabelle | æ•°æ®ç«äº‰è‡ªç”±ã€å†…å­˜å®‰å…¨ |
| **åŠ¨æ€æ£€æµ‹** | ThreadSanitizer, Loom | è¿è¡Œæ—¶æ•°æ®ç«äº‰ |
| **é™æ€åˆ†æ** | Rust Borrow Checker | ç¼–è¯‘æœŸæ•°æ®ç«äº‰æ’é™¤ |

### 5.2 Iris é€»è¾‘ï¼ˆRust å¹¶å‘éªŒè¯ï¼‰

**Iris** æ˜¯ **Coq** ä¸­çš„**å¹¶å‘åˆ†ç¦»é€»è¾‘**æ¡†æ¶ï¼Œç”¨äºéªŒè¯ Rust çš„å¹¶å‘ã€‚

**ç¤ºä¾‹**ï¼šéªŒè¯ `Arc<Mutex<T>>` çš„æ­£ç¡®æ€§

```coq
From iris.program_logic Require Import weakestpre.
From iris.heap_lang Require Import lang proofmode notation.
From iris.base_logic.lib Require Import invariants.

(* é”ä¸å˜å¼ *)
Definition lock_inv (l : loc) (R : iProp Î£) : iProp Î£ :=
  âˆƒ (b : bool), l â†¦ #b âˆ— if b then True else R.

(* é”è§„åˆ™ *)
Lemma acquire_spec (l : loc) (R : iProp Î£) :
  {{{ inv N (lock_inv l R) }}}
    acquire #l
  {{{ RET #(); R }}}.
Proof.
  (* ä½¿ç”¨ Iris ç­–ç•¥ wp_rec, inv_open, etc. *)
  admit.
Qed.
```

### 5.3 Loomï¼ˆRust å¹¶å‘æµ‹è¯•ï¼‰

**Loom** æ˜¯ Rust çš„**æ¨¡å‹æ£€æµ‹**å·¥å…·ï¼Œç³»ç»Ÿæ¢ç´¢æ‰€æœ‰å¯èƒ½çš„çº¿ç¨‹äº¤é”™ã€‚

```rust
use loom::sync::atomic::{AtomicUsize, Ordering};
use loom::thread;

#[test]
fn test_concurrent_increment() {
    loom::model(|| {
        let counter = Arc::new(AtomicUsize::new(0));

        let threads: Vec<_> = (0..2)
            .map(|_| {
                let counter = counter.clone();
                thread::spawn(move || {
                    counter.fetch_add(1, Ordering::SeqCst);
                })
            })
            .collect();

        for t in threads {
            t.join().unwrap();
        }

        assert_eq!(counter.load(Ordering::SeqCst), 2);
    });
}
```

**Loom ä¼šæ¢ç´¢**ï¼š

- æ‰€æœ‰å¯èƒ½çš„çº¿ç¨‹è°ƒåº¦
- æ‰€æœ‰å¯èƒ½çš„å†…å­˜åº
- æŠ¥å‘Šæ•°æ®ç«äº‰æˆ–æ–­è¨€å¤±è´¥

---

## 6. å¹¶å‘æ¨¡å¼å¯¹æ¯”

| æ¨¡å¼ | é€šä¿¡æ–¹å¼ | å…±äº«çŠ¶æ€ | æ­»é”é£é™© | å…¸å‹è¯­è¨€ |
|------|----------|----------|----------|----------|
| **Actor** | å¼‚æ­¥æ¶ˆæ¯ | æ—  | ä½ï¼ˆé‚®ç®±æ— ç•Œï¼‰ | Erlang, Akka |
| **CSP** | åŒæ­¥é€šé“ | æ—  | ä¸­ï¼ˆé€šé“é˜»å¡ï¼‰ | Golang, Occam |
| **Ï€-æ¼”ç®—** | åŠ¨æ€é€šé“ | æ—  | ä¸­ | ç†è®ºæ¨¡å‹ |
| **å…±äº«å†…å­˜** | é”ã€åŸå­ | æœ‰ | é«˜ï¼ˆé”é¡ºåºï¼‰ | C++, Rust |

---

## 7. å¹¶å‘æ¨¡å¼çš„å…¸å‹é—®é¢˜

### 7.1 å“²å­¦å®¶å°±é¤é—®é¢˜

**é—®é¢˜**ï¼š5 ä¸ªå“²å­¦å®¶å›´åï¼Œ5 æ ¹ç­·å­ï¼Œéœ€è¦ 2 æ ¹æ‰èƒ½åƒé¥­ï¼Œå¦‚ä½•é¿å…æ­»é”ï¼Ÿ

#### CSP è§£æ³•

```csp
PHIL(i) = pickup(left(i)) -> pickup(right(i)) 
          -> eat -> putdown(left(i)) -> putdown(right(i)) -> PHIL(i)

FORK(i) = pickup(i) -> putdown(i) -> FORK(i)

SYSTEM = ||| i:1..5 @ (PHIL(i) |[{pickup, putdown}]| FORK(i))
```

**æ­»é”è§£å†³**ï¼š

1. **èµ„æºæ’åº**ï¼šå¥‡æ•°å·å…ˆå·¦åå³ï¼Œå¶æ•°å·å…ˆå³åå·¦
2. **é™åˆ¶å¹¶å‘**ï¼šæœ€å¤š 4 äººåŒæ—¶æ‹¿ç­·å­

#### Golang å®ç°ï¼ˆèµ„æºæ’åºï¼‰

```go
func philosopher(id int, forks []*sync.Mutex) {
    left, right := id, (id+1)%5
    if id%2 == 0 {
        left, right = right, left  // å¶æ•°å·ååº
    }

    forks[left].Lock()
    forks[right].Lock()
    fmt.Println("Philosopher", id, "eating")
    forks[right].Unlock()
    forks[left].Unlock()
}
```

### 7.2 ç”Ÿäº§è€…-æ¶ˆè´¹è€…

#### Actor å®ç°

```scala
class ProducerActor(buffer: ActorRef) extends Actor {
  def receive = {
    case "produce" =>
      val item = produce()
      buffer ! Put(item)
  }
}

class BufferActor extends Actor {
  var items = Queue.empty[Item]
  
  def receive = {
    case Put(item) => items = items.enqueue(item)
    case Get => sender() ! items.dequeue
  }
}
```

#### Golang å®ç°ï¼ˆé€šé“ï¼‰

```go
func producer(ch chan int) {
    for i := 0; i < 10; i++ {
        ch <- i
    }
    close(ch)
}

func consumer(ch chan int) {
    for item := range ch {
        fmt.Println("Consumed:", item)
    }
}
```

---

## 8. å¤§å­¦è¯¾ç¨‹å¯¹åº”

| è¯¾ç¨‹ | ç›¸å…³ç« èŠ‚ |
|------|----------|
| **MIT 6.824 åˆ†å¸ƒå¼ç³»ç»Ÿ** | Actorã€CSP |
| **CMU 15-410 æ“ä½œç³»ç»Ÿ** | å…±äº«å†…å­˜ã€é” |
| **UC Berkeley CS262A å¹¶å‘ç†è®º** | Ï€-æ¼”ç®—ã€è¿›ç¨‹ä»£æ•° |
| **ETH ZÃ¼rich 252-0029-00L å¹¶å‘ç®—æ³•** | æ— é”æ•°æ®ç»“æ„ |
| **Stanford CS 240 é«˜çº§ç¼–ç¨‹** | Rust å¹¶å‘ |

---

## 9. æ•™æå¯¹åº”

| æ•™æ | ç›¸å…³ç« èŠ‚ |
|------|----------|
| **The Art of Multiprocessor Programming** | Locks, Atomic Operations |
| **Communicating Sequential Processes** (Hoare) | CSP å®Œæ•´å®šä¹‰ |
| **Programming with Actors** | Actor ç†è®ºä¸å®è·µ |
| **Rust Atomics and Locks** | Rust å¹¶å‘æ¨¡å¼ |
| **Formal Methods for Concurrency** | Ï€-æ¼”ç®—ã€Petri ç½‘ |

---

## 10. æœ¬åœ°é¡¹ç›®å¼•ç”¨

- `02.2_Distributed_Patterns.md` - åˆ†å¸ƒå¼å¹¶å‘æ¨¡å¼ï¼ˆSagaã€CQRSï¼‰
- `02.3_Workflow_Patterns.md` - å¹¶å‘å·¥ä½œæµï¼ˆPetri ç½‘ï¼‰
- `../01_Formal_Semantics/01.5_Language_Comparison.md` - Rustã€Golang å¹¶å‘è¯­ä¹‰
- `../05_Formal_Verification/05.2_Model_Checking_Tools.md` - mCRL2ã€SPIN

---

## 11. æ€»ç»“

### æ ¸å¿ƒæ´å¯Ÿ

```text
å¹¶å‘æ¨¡å¼ = è¿›ç¨‹ä»£æ•° + åŒæ­¥æœºåˆ¶

ä¸‰å¤§èŒƒå¼ï¼š
  1. æ¶ˆæ¯ä¼ é€’ï¼ˆActorã€CSPã€Ï€-æ¼”ç®—ï¼‰
  2. å…±äº«å†…å­˜ï¼ˆMutexã€Atomicï¼‰
  3. æ··åˆï¼ˆRust: Ownership + Channelï¼‰

éªŒè¯æŠ€æœ¯ï¼š
  - æ¨¡å‹æ£€æµ‹ï¼šè‡ªåŠ¨æ¢ç´¢æ‰€æœ‰çŠ¶æ€
  - å®šç†è¯æ˜ï¼šæ•°å­¦ä¿è¯æ­£ç¡®æ€§
  - åŠ¨æ€æ£€æµ‹ï¼šè¿è¡Œæ—¶å‘ç°ç«æ€
```

### å·¥å…·é“¾æ¨è

| åœºæ™¯ | æ¨èå·¥å…· |
|------|----------|
| **å¿«é€ŸåŸå‹** | Golang + Channel |
| **é«˜å¹¶å‘** | Erlang/Akka |
| **å½¢å¼éªŒè¯** | mCRL2, Coq (Iris) |
| **å†…å­˜å®‰å…¨** | Rust |
| **åŠ¨æ€æ£€æµ‹** | Loom, ThreadSanitizer |

### å®æˆ˜å»ºè®®

1. **å…¥é—¨**ï¼šä» Golang Channel å¼€å§‹ï¼Œç†è§£åŒæ­¥é€šä¿¡
2. **è¿›é˜¶**ï¼šå­¦ä¹  Rustï¼Œç†è§£æ‰€æœ‰æƒå¦‚ä½•é¿å…æ•°æ®ç«äº‰
3. **é«˜çº§**ï¼šç”¨ mCRL2 å»ºæ¨¡å¤æ‚å¹¶å‘ç³»ç»Ÿ
4. **å‰æ²¿**ï¼šç”¨ Iris éªŒè¯ Rust å¹¶å‘åº“çš„æ­£ç¡®æ€§

---

## é™„å½• Aï¼šå¹¶å‘åŸè¯­å¯¹æ¯”

| åŸè¯­ | é˜»å¡ | ç¼“å†² | é€‚ç”¨åœºæ™¯ |
|------|------|------|----------|
| **Golang Channel** | å¯é€‰ | å¯é€‰ | CSP é£æ ¼é€šä¿¡ |
| **Rust `mpsc::channel`** | æ˜¯ | æ— ç•Œ | å¤šç”Ÿäº§è€…å•æ¶ˆè´¹è€… |
| **Java `BlockingQueue`** | æ˜¯ | æœ‰ç•Œ | ç”Ÿäº§è€…-æ¶ˆè´¹è€… |
| **Actor Mailbox** | å¦ | æ— ç•Œ | å¼‚æ­¥æ¶ˆæ¯ä¼ é€’ |
| **Mutex** | æ˜¯ | N/A | ä¸´ç•ŒåŒºä¿æŠ¤ |
| **RwLock** | æ˜¯ | N/A | è¯»å¤šå†™å°‘ |
| **Atomic** | å¦ | N/A | æ— é”è®¡æ•°å™¨ |

---

## é™„å½• Bï¼šWikipedia æ¦‚å¿µå¯¹ç…§

| æ¦‚å¿µ | Wikipedia æ¡ç›® | æœ¬æ–‡ç« èŠ‚ |
|------|----------------|----------|
| Actor Model | <https://en.wikipedia.org/wiki/Actor_model> | Â§1 |
| CSP | <https://en.wikipedia.org/wiki/Communicating_sequential_processes> | Â§2 |
| Pi-Calculus | <https://en.wikipedia.org/wiki/Pi-calculus> | Â§3 |
| Mutex | <https://en.wikipedia.org/wiki/Mutual_exclusion> | Â§4.1 |
| Dining Philosophers | <https://en.wikipedia.org/wiki/Dining_philosophers_problem> | Â§7.1 |

---

**ç‰ˆæœ¬**ï¼šv1.0  
**æœ€åæ›´æ–°**ï¼š2025-10-29  
**ç»´æŠ¤è€…**ï¼šFormalScience Project  
**è®¸å¯**ï¼šCC BY-SA 4.0
