# 并发模式（Concurrency Patterns）

## 概述

**并发模式**描述多个执行单元如何安全、高效地共享资源和通信。从形式化视角，并发模式是**进程代数**（Process Algebra）的实例，主要包括：

1. **Actor 模型**：消息传递，无共享状态
2. **CSP**（Communicating Sequential Processes）：同步通道
3. **π-演算**：动态创建通道
4. **共享内存模式**：锁、条件变量、原子操作

**核心洞察**：

```text
并发模式 = 进程代数 + 同步机制

验证 = 模型检测 + 定理证明
  - 无死锁（Deadlock Freedom）
  - 活性（Liveness）
  - 数据竞争自由（Data Race Freedom）
```

本文将系统介绍：
    - 1. Actor 模型的形式化
    - 2. CSP 与 Golang 实践
    - 3. π-演算与动态并发
    - 4. 共享内存模式与验证
    - 5. 并发模式的机器验证

---

## 1. Actor 模型

### 1.1 核心概念

**Actor** 是并发的基本单元，具有：

- **邮箱**（Mailbox）：存储接收的消息
- **行为**（Behavior）：处理消息的函数
- **状态**（State）：私有，不共享

**三大能力**：

1. **发送消息**：非阻塞，异步
2. **创建 Actor**：动态扩展
3. **改变行为**：下次消息用新行为处理

### 1.2 形式化定义

**语法**：

```text
Actor a ::= receive
            | a₁ | a₂                  (并行组合)
            | νa. A                    (新建 Actor)
            | send(a, msg)            (发送消息)
            | become(behavior)        (改变行为)

消息：
  msg ∈ Msg
```

**语义（LTS）**：

```text
发送：
  ──────────────────────────────
  ⟨send(a, m), σ⟩ → ⟨skip, σ[mailbox(a) ← mailbox(a) ++ [m]]⟩

接收：
  mailbox(a) = m :: rest
  ──────────────────────────────
  ⟨receive, σ⟩ → ⟨handle(m), σ[mailbox(a) ← rest]⟩

创建：
  ──────────────────────────────
  ⟨νa. A, σ⟩ → ⟨A, σ[actors ← actors ∪ {a}]⟩
```

### 1.3 Scala Akka 示例

```scala
import akka.actor._

// 定义消息
case class Greet(name: String)
case object Goodbye

// 定义 Actor
class GreeterActor extends Actor {
  def receive = {
    case Greet(name) =>
      println(s"Hello, $name")
      sender() ! Goodbye  // 回复发送者
    
    case Goodbye =>
      context.stop(self)  // 停止自己
  }
}

// 使用
val system = ActorSystem("HelloSystem")
val greeter = system.actorOf(Props[GreeterActor], "greeter")

greeter ! Greet("Alice")
```

### 1.4 无死锁证明

**定理**（Actor 无死锁）：

```text
若 Actor 系统满足：
  1. 邮箱无界（或足够大）
  2. 发送非阻塞
则不存在死锁（所有 Actor 都在等待）
```

**证明草图**：

```text
假设存在死锁状态 σ，则：
  ∀a ∈ actors, mailbox(a) = [] ∧ a 在 receive 处阻塞

但发送是非阻塞的，至少有一个 Actor 可以发送消息，矛盾 ✗
```

**mCRL2 形式化**：

```mcrl2
sort Actor = struct a1 | a2;
     Msg = struct hello | bye;

act send, receive : Actor # Msg;

proc A(id: Actor) =
  sum m:Msg. receive(id, m) . 
    (send(id, bye) . A(id) + delta);

init A(a1) | A(a2);
```

**验证**：

```bash
mcrl22lps actor.mcrl2 | lps2lts -v | ltsconvert -e deadlock
# 输出：No deadlocks
```

---

## 2. CSP（Communicating Sequential Processes）

### 2.1 核心概念

**CSP** 强调**同步通信**：

- **通道**（Channel）：发送方和接收方**同时准备好**才能通信
- **选择**（Choice）：`P □ Q` 外部选择，`P ⊓ Q` 内部选择
- **并行**（Parallel）：`P || Q` 独立交错，`P |[A]| Q` 在 A 上同步

### 2.2 形式化定义

**语法**：

```text
P ::= SKIP                         (空进程)
    | STOP                         (死锁)
    | a → P                        (事件前缀)
    | P □ Q                        (外部选择)
    | P ⊓ Q                        (内部选择)
    | P || Q                       (交错并行)
    | P |[A]| Q                    (同步并行)
    | P \ A                        (隐藏事件)
    | P ; Q                        (顺序组合)
```

**语义（Traces）**：

```text
traces(SKIP) = {⟨⟩}
traces(a → P) = {⟨⟩} ∪ {⟨a⟩ ++ t | t ∈ traces(P)}
traces(P □ Q) = traces(P) ∪ traces(Q)
traces(P || Q) = traces(P) |||  traces(Q)  (交错)
```

### 2.3 Golang 实现

Golang 的 **channel** 是 CSP 的直接实现：

```go
package main

import "fmt"

func producer(ch chan int) {
    for i := 0; i < 5; i++ {
        ch <- i  // 发送，阻塞直到接收方准备好
    }
    close(ch)
}

func consumer(ch chan int) {
    for v := range ch {
        fmt.Println("Received:", v)
    }
}

func main() {
    ch := make(chan int)  // 无缓冲通道（同步）
    go producer(ch)
    go consumer(ch)
}
```

#### 带缓冲 vs 无缓冲

```go
// 无缓冲：发送阻塞直到接收
ch := make(chan int)

// 有缓冲：发送在缓冲满时阻塞
ch := make(chan int, 10)
```

### 2.4 Select 多路复用

```go
func multiplex(ch1, ch2 chan int, quit chan bool) {
    for {
        select {
        case v := <-ch1:
            fmt.Println("From ch1:", v)
        case v := <-ch2:
            fmt.Println("From ch2:", v)
        case <-quit:
            return
        }
    }
}
```

**CSP 对应**：

```text
P = (ch1?v → print(v) . P)
    □
    (ch2?v → print(v) . P)
    □
    (quit? → SKIP)
```

### 2.5 死锁检测

**定理**（CSP 死锁判定）：

```text
P 有死锁 ⟺ STOP ∈ traces(P)
```

**FDR（Failures-Divergences Refinement）工具**：

```csp
channel send, receive : Int

PRODUCER = send!0 -> send!1 -> SKIP
CONSUMER = receive?x -> receive?y -> SKIP
SYSTEM = PRODUCER ||| CONSUMER

assert SYSTEM :[deadlock free [F]]
```

**验证**：

```bash
fdr example.csp
# 输出：Passed
```

---

## 3. π-演算（Pi-Calculus）

### 3.1 核心概念

**π-演算**扩展 CSP，允许**通道作为消息传递**：

```text
P ::= 0                          (空进程)
    | a(x).P                     (接收)
    | ā⟨b⟩.P                     (发送)
    | P | Q                      (并行)
    | νa.P                       (新建通道)
    | !P                         (复制)
```

**关键**：通道 `a` 可以作为消息发送，实现**动态拓扑**。

### 3.2 归约语义

```text
通信：
  ──────────────────────────────
  a(x).P | ā⟨b⟩.Q → P{b/x} | Q

作用域挤出（Scope Extrusion）：
  ──────────────────────────────
  (νa.P) | Q → νa.(P | Q)  if a ∉ fn(Q)
```

### 3.3 示例：移动电话切换

**场景**：电话从基站 A 切换到基站 B。

```text
// 基站 A 持有通道 car
BaseA = car⟨talk⟩.0

// 车辆通过 talk 通道与 A 通信
Car = car(c).c⟨msg⟩.0

// 切换：A 将 talk 发送给 B
BaseA' = handoff⟨talk⟩.0
BaseB = handoff(c).c⟨msg⟩.0

// 系统
SYSTEM = (νtalk.(νcar.BaseA | Car)) | BaseB
```

**归约**：

```text
(νtalk.νcar.car⟨talk⟩.0 | car(c).c⟨msg⟩.0) | BaseB
→ (νtalk.talk⟨msg⟩.0) | BaseB
→ (νtalk.0) | handoff(c).c⟨msg⟩.0
```

### 3.4 mCRL2 π-演算编码

```mcrl2
sort Channel = struct a | b | talk;

act send, receive : Channel # Channel;

proc PiCalc =
  (receive(a, talk) . send(talk, msg) . delta)
  ||
  (send(a, talk) . delta)
  ||
  (receive(talk, msg) . delta);

init hide({send, receive}, PiCalc);
```

---

## 4. 共享内存模式

### 4.1 Mutex（互斥锁）

**定义**：保证**临界区**互斥访问。

**Petri 网建模**：

```text
Place: mutex, critical1, critical2

Transitions:
  lock1: mutex → critical1
  unlock1: critical1 → mutex
  lock2: mutex → critical2
  unlock2: critical2 → mutex

初始标识：mutex=1
```

**性质**：

```text
定理（互斥性）：
  AG ¬(critical1=1 ∧ critical2=1)
```

**Rust 实现**：

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

### 4.2 Reader-Writer Lock

**规则**：

- 多个读者可同时读
- 写者独占访问

**Petri 网**：

```text
Place: free, reading(n), writing

Transitions:
  acquire_read: free → reading(1)
  acquire_read: reading(n) → reading(n+1)
  release_read: reading(n) → reading(n-1)
  release_read: reading(1) → free
  acquire_write: free → writing
  release_write: writing → free
```

**Go 实现**：

```go
import "sync"

var rwlock sync.RWMutex
var data int

func reader() {
    rwlock.RLock()
    _ = data
    rwlock.RUnlock()
}

func writer() {
    rwlock.Lock()
    data++
    rwlock.Unlock()
}
```

### 4.3 Condition Variable（条件变量）

**场景**：线程等待某个条件满足。

**Go 实现**：

```go
var mu sync.Mutex
var cond = sync.NewCond(&mu)
var ready = false

func waiter() {
    mu.Lock()
    for !ready {
        cond.Wait()  // 释放 mu 并等待
    }
    mu.Unlock()
    fmt.Println("Condition met")
}

func notifier() {
    mu.Lock()
    ready = true
    cond.Signal()  // 唤醒一个等待者
    mu.Unlock()
}
```

### 4.4 Atomic Operations（原子操作）

**Rust 示例**：

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

static COUNTER: AtomicUsize = AtomicUsize::new(0);

fn increment() {
    COUNTER.fetch_add(1, Ordering::SeqCst);
}

fn decrement() {
    COUNTER.fetch_sub(1, Ordering::SeqCst);
}
```

**内存模型**：

- `Relaxed`：无同步保证
- `Acquire` / `Release`：建立 happens-before 关系
- `SeqCst`：全序（Sequential Consistency）

---

## 5. 并发模式验证

### 5.1 验证技术

| 技术 | 工具 | 验证性质 |
|------|------|----------|
| **模型检测** | mCRL2, FDR, SPIN | 死锁、活性、安全性 |
| **定理证明** | Coq (Iris), Isabelle | 数据竞争自由、内存安全 |
| **动态检测** | ThreadSanitizer, Loom | 运行时数据竞争 |
| **静态分析** | Rust Borrow Checker | 编译期数据竞争排除 |

### 5.2 Iris 逻辑（Rust 并发验证）

**Iris** 是 **Coq** 中的**并发分离逻辑**框架，用于验证 Rust 的并发。

**示例**：验证 `Arc<Mutex<T>>` 的正确性

```coq
From iris.program_logic Require Import weakestpre.
From iris.heap_lang Require Import lang proofmode notation.
From iris.base_logic.lib Require Import invariants.

(* 锁不变式 *)
Definition lock_inv (l : loc) (R : iProp Σ) : iProp Σ :=
  ∃ (b : bool), l ↦ #b ∗ if b then True else R.

(* 锁规则 *)
Lemma acquire_spec (l : loc) (R : iProp Σ) :
  {{{ inv N (lock_inv l R) }}}
    acquire #l
  {{{ RET #(); R }}}.
Proof.
  (* 使用 Iris 策略 wp_rec, inv_open, etc. *)
  admit.
Qed.
```

### 5.3 Loom（Rust 并发测试）

**Loom** 是 Rust 的**模型检测**工具，系统探索所有可能的线程交错。

```rust
use loom::sync::atomic::{AtomicUsize, Ordering};
use loom::thread;

#[test]
fn test_concurrent_increment() {
    loom::model(|| {
        let counter = Arc::new(AtomicUsize::new(0));

        let threads: Vec<_> = (0..2)
            .map(|_| {
                let counter = counter.clone();
                thread::spawn(move || {
                    counter.fetch_add(1, Ordering::SeqCst);
                })
            })
            .collect();

        for t in threads {
            t.join().unwrap();
        }

        assert_eq!(counter.load(Ordering::SeqCst), 2);
    });
}
```

**Loom 会探索**：

- 所有可能的线程调度
- 所有可能的内存序
- 报告数据竞争或断言失败

---

## 6. 并发模式对比

| 模式 | 通信方式 | 共享状态 | 死锁风险 | 典型语言 |
|------|----------|----------|----------|----------|
| **Actor** | 异步消息 | 无 | 低（邮箱无界） | Erlang, Akka |
| **CSP** | 同步通道 | 无 | 中（通道阻塞） | Golang, Occam |
| **π-演算** | 动态通道 | 无 | 中 | 理论模型 |
| **共享内存** | 锁、原子 | 有 | 高（锁顺序） | C++, Rust |

---

## 7. 并发模式的典型问题

### 7.1 哲学家就餐问题

**问题**：5 个哲学家围坐，5 根筷子，需要 2 根才能吃饭，如何避免死锁？

#### CSP 解法

```csp
PHIL(i) = pickup(left(i)) -> pickup(right(i)) 
          -> eat -> putdown(left(i)) -> putdown(right(i)) -> PHIL(i)

FORK(i) = pickup(i) -> putdown(i) -> FORK(i)

SYSTEM = ||| i:1..5 @ (PHIL(i) |[{pickup, putdown}]| FORK(i))
```

**死锁解决**：

1. **资源排序**：奇数号先左后右，偶数号先右后左
2. **限制并发**：最多 4 人同时拿筷子

#### Golang 实现（资源排序）

```go
func philosopher(id int, forks []*sync.Mutex) {
    left, right := id, (id+1)%5
    if id%2 == 0 {
        left, right = right, left  // 偶数号反序
    }

    forks[left].Lock()
    forks[right].Lock()
    fmt.Println("Philosopher", id, "eating")
    forks[right].Unlock()
    forks[left].Unlock()
}
```

### 7.2 生产者-消费者

#### Actor 实现

```scala
class ProducerActor(buffer: ActorRef) extends Actor {
  def receive = {
    case "produce" =>
      val item = produce()
      buffer ! Put(item)
  }
}

class BufferActor extends Actor {
  var items = Queue.empty[Item]
  
  def receive = {
    case Put(item) => items = items.enqueue(item)
    case Get => sender() ! items.dequeue
  }
}
```

#### Golang 实现（通道）

```go
func producer(ch chan int) {
    for i := 0; i < 10; i++ {
        ch <- i
    }
    close(ch)
}

func consumer(ch chan int) {
    for item := range ch {
        fmt.Println("Consumed:", item)
    }
}
```

---

## 8. 大学课程对应

| 课程 | 相关章节 |
|------|----------|
| **MIT 6.824 分布式系统** | Actor、CSP |
| **CMU 15-410 操作系统** | 共享内存、锁 |
| **UC Berkeley CS262A 并发理论** | π-演算、进程代数 |
| **ETH Zürich 252-0029-00L 并发算法** | 无锁数据结构 |
| **Stanford CS 240 高级编程** | Rust 并发 |

---

## 9. 教材对应

| 教材 | 相关章节 |
|------|----------|
| **The Art of Multiprocessor Programming** | Locks, Atomic Operations |
| **Communicating Sequential Processes** (Hoare) | CSP 完整定义 |
| **Programming with Actors** | Actor 理论与实践 |
| **Rust Atomics and Locks** | Rust 并发模式 |
| **Formal Methods for Concurrency** | π-演算、Petri 网 |

---

## 10. 本地项目引用

- `02.2_Distributed_Patterns.md` - 分布式并发模式（Saga、CQRS）
- `02.3_Workflow_Patterns.md` - 并发工作流（Petri 网）
- `../01_Formal_Semantics/01.5_Language_Comparison.md` - Rust、Golang 并发语义
- `../05_Formal_Verification/05.2_Model_Checking_Tools.md` - mCRL2、SPIN

---

## 11. 总结

### 核心洞察

```text
并发模式 = 进程代数 + 同步机制

三大范式：
  1. 消息传递（Actor、CSP、π-演算）
  2. 共享内存（Mutex、Atomic）
  3. 混合（Rust: Ownership + Channel）

验证技术：
  - 模型检测：自动探索所有状态
  - 定理证明：数学保证正确性
  - 动态检测：运行时发现竞态
```

### 工具链推荐

| 场景 | 推荐工具 |
|------|----------|
| **快速原型** | Golang + Channel |
| **高并发** | Erlang/Akka |
| **形式验证** | mCRL2, Coq (Iris) |
| **内存安全** | Rust |
| **动态检测** | Loom, ThreadSanitizer |

### 实战建议

1. **入门**：从 Golang Channel 开始，理解同步通信
2. **进阶**：学习 Rust，理解所有权如何避免数据竞争
3. **高级**：用 mCRL2 建模复杂并发系统
4. **前沿**：用 Iris 验证 Rust 并发库的正确性

---

## 附录 A：并发原语对比

| 原语 | 阻塞 | 缓冲 | 适用场景 |
|------|------|------|----------|
| **Golang Channel** | 可选 | 可选 | CSP 风格通信 |
| **Rust `mpsc::channel`** | 是 | 无界 | 多生产者单消费者 |
| **Java `BlockingQueue`** | 是 | 有界 | 生产者-消费者 |
| **Actor Mailbox** | 否 | 无界 | 异步消息传递 |
| **Mutex** | 是 | N/A | 临界区保护 |
| **RwLock** | 是 | N/A | 读多写少 |
| **Atomic** | 否 | N/A | 无锁计数器 |

---

## 附录 B：Wikipedia 概念对照

| 概念 | Wikipedia 条目 | 本文章节 |
|------|----------------|----------|
| Actor Model | <https://en.wikipedia.org/wiki/Actor_model> | §1 |
| CSP | <https://en.wikipedia.org/wiki/Communicating_sequential_processes> | §2 |
| Pi-Calculus | <https://en.wikipedia.org/wiki/Pi-calculus> | §3 |
| Mutex | <https://en.wikipedia.org/wiki/Mutual_exclusion> | §4.1 |
| Dining Philosophers | <https://en.wikipedia.org/wiki/Dining_philosophers_problem> | §7.1 |

---

**版本**：v1.0  
**最后更新**：2025-10-29  
**维护者**：FormalScience Project  
**许可**：CC BY-SA 4.0
