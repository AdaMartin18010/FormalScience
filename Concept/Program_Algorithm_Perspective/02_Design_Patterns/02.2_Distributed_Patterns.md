# 02.2 åˆ†å¸ƒå¼è®¾è®¡æ¨¡å¼ï¼šSagaã€CQRSã€Event Sourcing

## ğŸ“š ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [1. Saga æ¨¡å¼ï¼ˆé•¿äº‹åŠ¡è¡¥å¿ï¼‰](#1-saga-æ¨¡å¼é•¿äº‹åŠ¡è¡¥å¿)
  - [1.1 é—®é¢˜èƒŒæ™¯](#11-é—®é¢˜èƒŒæ™¯)
  - [1.2 å½¢å¼åŒ–å®šä¹‰](#12-å½¢å¼åŒ–å®šä¹‰)
  - [1.3 ä¸¤ç§ç¼–æ’æ–¹å¼](#13-ä¸¤ç§ç¼–æ’æ–¹å¼)
  - [1.4 å½¢å¼éªŒè¯ï¼šæ¨¡å‹æ£€æµ‹](#14-å½¢å¼éªŒè¯æ¨¡å‹æ£€æµ‹)
  - [1.5 å®æˆ˜æ¡ˆä¾‹ï¼šç”µå•†è®¢å•ç³»ç»Ÿ](#15-å®æˆ˜æ¡ˆä¾‹ç”µå•†è®¢å•ç³»ç»Ÿ)
- [2. CQRS æ¨¡å¼ï¼ˆå‘½ä»¤æŸ¥è¯¢åˆ†ç¦»ï¼‰](#2-cqrs-æ¨¡å¼å‘½ä»¤æŸ¥è¯¢åˆ†ç¦»)
  - [2.1 é—®é¢˜èƒŒæ™¯](#21-é—®é¢˜èƒŒæ™¯)
  - [2.2 å½¢å¼åŒ–å®šä¹‰](#22-å½¢å¼åŒ–å®šä¹‰)
  - [2.3 å½¢å¼éªŒè¯ï¼šä¸€è‡´æ€§æ¨¡å‹](#23-å½¢å¼éªŒè¯ä¸€è‡´æ€§æ¨¡å‹)
  - [2.4 å®æˆ˜æ¡ˆä¾‹ï¼šç”µå•†ç³»ç»Ÿ](#24-å®æˆ˜æ¡ˆä¾‹ç”µå•†ç³»ç»Ÿ)
- [3. Event Sourcing æ¨¡å¼ï¼ˆäº‹ä»¶æº¯æºï¼‰](#3-event-sourcing-æ¨¡å¼äº‹ä»¶æº¯æº)
  - [3.1 é—®é¢˜èƒŒæ™¯](#31-é—®é¢˜èƒŒæ™¯)
  - [3.2 å½¢å¼åŒ–å®šä¹‰](#32-å½¢å¼åŒ–å®šä¹‰)
  - [3.3 å¿«ç…§ä¼˜åŒ–ï¼ˆSnapshotï¼‰](#33-å¿«ç…§ä¼˜åŒ–snapshot)
  - [3.4 å½¢å¼éªŒè¯ï¼šCQRS + Event Sourcing ç»„åˆ](#34-å½¢å¼éªŒè¯cqrs--event-sourcing-ç»„åˆ)
  - [3.5 å®æˆ˜æ¡ˆä¾‹ï¼šé“¶è¡Œè´¦æˆ·ç³»ç»Ÿ](#35-å®æˆ˜æ¡ˆä¾‹é“¶è¡Œè´¦æˆ·ç³»ç»Ÿ)
- [4. ä¸‰æ¨¡å¼ç»„åˆï¼šæœ€ä½³å®è·µ](#4-ä¸‰æ¨¡å¼ç»„åˆæœ€ä½³å®è·µ)
  - [4.1 ç»„åˆæ¶æ„](#41-ç»„åˆæ¶æ„)
  - [4.2 å†³ç­–çŸ©é˜µ](#42-å†³ç­–çŸ©é˜µ)
  - [4.3 é™·é˜±ä¸åæ¨¡å¼](#43-é™·é˜±ä¸åæ¨¡å¼)
- [5. ä¸å›½é™…è¯¾ç¨‹å¯¹æ ‡](#5-ä¸å›½é™…è¯¾ç¨‹å¯¹æ ‡)
  - [5.1 å¤§å­¦è¯¾ç¨‹æ˜ å°„](#51-å¤§å­¦è¯¾ç¨‹æ˜ å°„)
  - [5.2 æ•™æå¯¹åº”](#52-æ•™æå¯¹åº”)
- [6. å·¥å…·ä¸ç”Ÿæ€](#6-å·¥å…·ä¸ç”Ÿæ€)
  - [6.1 Saga å·¥å…·](#61-saga-å·¥å…·)
  - [6.2 CQRS å·¥å…·](#62-cqrs-å·¥å…·)
  - [6.3 Event Sourcing å·¥å…·](#63-event-sourcing-å·¥å…·)
- [7. æ‰©å±•é˜…è¯»](#7-æ‰©å±•é˜…è¯»)
  - [7.1 å­¦æœ¯è®ºæ–‡](#71-å­¦æœ¯è®ºæ–‡)
  - [7.2 åœ¨çº¿èµ„æº](#72-åœ¨çº¿èµ„æº)
  - [7.3 æœ¬åœ°é¡¹ç›®å¼•ç”¨](#73-æœ¬åœ°é¡¹ç›®å¼•ç”¨)
- [é™„å½• Aï¼šWikipedia æ¦‚å¿µå¯¹ç…§](#é™„å½•-awikipedia-æ¦‚å¿µå¯¹ç…§)

---

## æ¦‚è¿°

åˆ†å¸ƒå¼ç³»ç»Ÿçš„è®¾è®¡æ¨¡å¼è§£å†³äº†**è·¨ç½‘ç»œè¾¹ç•Œçš„æ•°æ®ä¸€è‡´æ€§ã€å¹¶å‘æ§åˆ¶ã€æ•…éšœæ¢å¤**é—®é¢˜ã€‚æœ¬æ–‡é€šè¿‡ **UH-Cost æ¡†æ¶**å½¢å¼åŒ–åˆ†æä¸‰ç§æ ¸å¿ƒæ¨¡å¼ï¼š

1. **Saga æ¨¡å¼**ï¼šé•¿äº‹åŠ¡çš„è¡¥å¿æœºåˆ¶
2. **CQRS æ¨¡å¼**ï¼šå‘½ä»¤æŸ¥è¯¢è´£ä»»åˆ†ç¦»
3. **Event Sourcing æ¨¡å¼**ï¼šäº‹ä»¶æº¯æºå­˜å‚¨

æˆ‘ä»¬å°†ä»**æ§åˆ¶Â·æ‰§è¡ŒÂ·æ•°æ®**ä¸‰å…ƒè§†è§’ï¼Œç»“åˆ**è¿›ç¨‹ä»£æ•°ã€æ¨¡å‹æ£€æµ‹ã€åˆ†å¸ƒå¼å…±è¯†**ç†è®ºï¼Œç»™å‡ºå¯éªŒè¯çš„å½¢å¼åŒ–å®šä¹‰ã€‚

---

## 1. Saga æ¨¡å¼ï¼ˆé•¿äº‹åŠ¡è¡¥å¿ï¼‰

### 1.1 é—®é¢˜èƒŒæ™¯

**åˆ†å¸ƒå¼äº‹åŠ¡å›°å¢ƒ**ï¼š

- **2PC/3PC**ï¼šéœ€è¦å…¨å±€åè°ƒå™¨ï¼Œé˜»å¡æ€§ï¼Œå¯ç”¨æ€§å·®
- **XA äº‹åŠ¡**ï¼šé”å®šèµ„æºæ—¶é—´é•¿ï¼Œååé‡ä½

**Saga æ–¹æ¡ˆ**ï¼š
> å°†é•¿äº‹åŠ¡æ‹†åˆ†ä¸ºå¤šä¸ª**æœ¬åœ°äº‹åŠ¡**ï¼ˆå­äº‹åŠ¡ï¼‰ï¼Œæ¯ä¸ªå­äº‹åŠ¡æœ‰å¯¹åº”çš„**è¡¥å¿äº‹åŠ¡**ï¼ˆCompensating Transactionï¼‰ï¼Œå¤±è´¥æ—¶é€šè¿‡è¡¥å¿æ’¤é”€å·²å®Œæˆçš„å­äº‹åŠ¡ã€‚

### 1.2 å½¢å¼åŒ–å®šä¹‰

#### åŸºæœ¬ç»“æ„

```text
Saga = âŸ¨Tâ‚, Tâ‚‚, ..., Tâ‚™, Câ‚, Câ‚‚, ..., Câ‚™â‚‹â‚âŸ©

å…¶ä¸­ï¼š
  Táµ¢ : ç¬¬ i ä¸ªå­äº‹åŠ¡
  Cáµ¢ : Táµ¢ çš„è¡¥å¿äº‹åŠ¡
  
æ‰§è¡Œè¯­ä¹‰ï¼š
  1. æ­£å‘æ‰§è¡Œï¼šTâ‚ â†’ Tâ‚‚ â†’ ... â†’ Tâ‚™
  2. å¤±è´¥å›æ»šï¼šTáµ¢ å¤±è´¥ â†’ æ‰§è¡Œ Cáµ¢â‚‹â‚, Cáµ¢â‚‹â‚‚, ..., Câ‚
```

**å…³é”®æ€§è´¨**ï¼š

```text
åŸå­æ€§å¼±åŒ–ï¼š
  ä¼ ç»Ÿäº‹åŠ¡ï¼šè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥ï¼ˆå›æ»šï¼‰
  Saga äº‹åŠ¡ï¼šè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆéƒ¨åˆ†æˆåŠŸ + è¡¥å¿è¿˜åŸ

å®šç†ï¼ˆæœ€ç»ˆä¸€è‡´æ€§ï¼‰ï¼š
  å¦‚æœæ‰€æœ‰è¡¥å¿äº‹åŠ¡ Cáµ¢ æœ€ç»ˆæˆåŠŸï¼Œåˆ™ç³»ç»Ÿè¾¾åˆ°ä¸€è‡´çŠ¶æ€ã€‚
```

#### UH-Cost å»ºæ¨¡

```text
Saga as Hypergraph Rewriting:

èŠ‚ç‚¹ï¼š
  Sâ‚€, Sâ‚, ..., Sâ‚™  (çŠ¶æ€)
  
è¾¹ï¼ˆäº‹åŠ¡ï¼‰ï¼š
  Táµ¢: Sáµ¢â‚‹â‚ âŸ¹ Sáµ¢  (æ­£å‘)
  Cáµ¢: Sáµ¢ âŸ¹ Sáµ¢â‚‹â‚  (è¡¥å¿)

é‡å†™è§„åˆ™ï¼š
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (Forward)
  âŸ¨Sáµ¢, Táµ¢âŸ© âŸ¶ Sáµ¢â‚Šâ‚
  
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (Compensate)
  âŸ¨Sáµ¢, failâŸ© âŸ¶ âŸ¨Sáµ¢â‚‹â‚, Cáµ¢â‚‹â‚âŸ©

æˆæœ¬å‡½æ•°ï¼š
  Îº(Saga) = Î£áµ¢ cost(Táµ¢) + Î£â±¼ [å¤±è´¥] Ã— cost(Câ±¼)
```

### 1.3 ä¸¤ç§ç¼–æ’æ–¹å¼

#### ååŒå¼ Sagaï¼ˆChoreographyï¼‰

```text
æ¯ä¸ªæœåŠ¡è®¢é˜…äº‹ä»¶ï¼Œè‡ªä¸»å†³å®šä¸‹ä¸€æ­¥ï¼š

Process Order = 
  receive_order . 
  reserve_inventory! . 
  (payment_success? . ship_order! . 0
   + payment_failed? . release_inventory! . 0)

Process Inventory = 
  reserve_inventory? . 
  (release_inventory? . restore_stock . 0
   + ship_order? . deduct_stock . 0)
```

**ä¼˜ç‚¹**ï¼šæ— ä¸­å¿ƒåè°ƒå™¨ï¼Œæ¾è€¦åˆ  
**ç¼ºç‚¹**ï¼šéš¾ä»¥è¿½è¸ªå…¨å±€çŠ¶æ€ï¼Œè°ƒè¯•å›°éš¾

#### ç¼–æ’å¼ Sagaï¼ˆOrchestrationï¼‰

```text
ä¸­å¿ƒåè°ƒå™¨é©±åŠ¨æµç¨‹ï¼š

Orchestrator:
  execute(Tâ‚) â†’
    | success â†’ execute(Tâ‚‚) â†’ ... â†’ execute(Tâ‚™)
    | fail_at_i â†’ compensate(Cáµ¢â‚‹â‚) â†’ ... â†’ compensate(Câ‚)
```

**ä¼˜ç‚¹**ï¼šæµç¨‹æ¸…æ™°ï¼Œæ˜“ç›‘æ§  
**ç¼ºç‚¹**ï¼šåè°ƒå™¨æˆä¸ºå•ç‚¹æ•…éšœ

### 1.4 å½¢å¼éªŒè¯ï¼šæ¨¡å‹æ£€æµ‹

#### mCRL2 å»ºæ¨¡ï¼ˆç®€åŒ–ç‰ˆï¼‰

```mcrl2
sort Status = struct pending | completed | failed | compensated;

act
  execute_tx: Nat;          % æ‰§è¡Œäº‹åŠ¡
  compensate_tx: Nat;       % è¡¥å¿äº‹åŠ¡
  fail: Nat;                % äº‹åŠ¡å¤±è´¥

proc
  % å•ä¸ªå­äº‹åŠ¡
  SubTxn(id: Nat) = 
    execute_tx(id) . SubTxnCompleted(id)
    + fail(id) . SubTxnFailed(id);
  
  SubTxnCompleted(id: Nat) = compensate_tx(id) . delta;
  SubTxnFailed(id: Nat) = delta;

  % Saga åè°ƒå™¨
  SagaOrchestrator(n: Nat) = SagaExec(0, n);
  
  SagaExec(i: Nat, n: Nat) =
    (i < n) -> (
      execute_tx(i) . SagaExec(i+1, n)
      + fail(i) . SagaCompensate(i-1)
    ) <> delta;  % i == n: å®Œæˆ
  
  SagaCompensate(i: Int) =
    (i >= 0) -> compensate_tx(i) . SagaCompensate(i-1)
    <> delta;  % è¡¥å¿å®Œæˆ

init SagaOrchestrator(3);
```

**éªŒè¯æ€§è´¨**ï¼š

```mcrl2
% 1. æœ€ç»ˆä¸€è‡´æ€§ï¼šè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨è¡¥å¿
[true*] <exists i: Nat . execute_tx(i)> 
  => <true*> (forall j: Nat . (j < i) => <true*> compensate_tx(j))

% 2. è¡¥å¿é¡ºåºæ­£ç¡®ï¼ˆé€†åºï¼‰
[true* . compensate_tx(i) . true* . compensate_tx(j)] (i < j)
```

### 1.5 å®æˆ˜æ¡ˆä¾‹ï¼šç”µå•†è®¢å•ç³»ç»Ÿ

#### åœºæ™¯åˆ†è§£

```text
è®¢å•æµç¨‹ Saga:
  Tâ‚: åˆ›å»ºè®¢å• (Order Service)
  Tâ‚‚: é¢„æ‰£åº“å­˜ (Inventory Service)
  Tâ‚ƒ: æ‰£æ¬¾ (Payment Service)
  Tâ‚„: é€šçŸ¥ç‰©æµ (Shipping Service)

è¡¥å¿æµç¨‹ï¼š
  Câ‚: å–æ¶ˆè®¢å•
  Câ‚‚: é‡Šæ”¾åº“å­˜
  Câ‚ƒ: é€€æ¬¾
```

#### Go å®ç°ï¼ˆOrchestrationï¼‰

```go
type SagaStep struct {
    Execute    func() error
    Compensate func() error
}

type SagaOrchestrator struct {
    steps []SagaStep
}

func (s *SagaOrchestrator) Run() error {
    executed := 0
    
    // Forward phase
    for i, step := range s.steps {
        if err := step.Execute(); err != nil {
            // Compensate phase
            for j := i - 1; j >= 0; j-- {
                if compErr := s.steps[j].Compensate(); compErr != nil {
                    log.Printf("Compensation failed at step %d: %v", j, compErr)
                }
            }
            return fmt.Errorf("saga failed at step %d: %w", i, err)
        }
        executed++
    }
    
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func PlaceOrder(orderID string) error {
    saga := &SagaOrchestrator{
        steps: []SagaStep{
            {
                Execute:    func() error { return createOrder(orderID) },
                Compensate: func() error { return cancelOrder(orderID) },
            },
            {
                Execute:    func() error { return reserveInventory(orderID) },
                Compensate: func() error { return releaseInventory(orderID) },
            },
            {
                Execute:    func() error { return processPayment(orderID) },
                Compensate: func() error { return refundPayment(orderID) },
            },
            {
                Execute:    func() error { return notifyShipping(orderID) },
                Compensate: func() error { return nil }, // æœ€åä¸€æ­¥æ— éœ€è¡¥å¿
            },
        },
    }
    
    return saga.Run()
}
```

**æˆæœ¬åˆ†æ**ï¼š

```text
æ­£å¸¸è·¯å¾„ï¼š
  T_normal = Î£áµ¢ latency(Táµ¢) + Î£áµ¢ latency(network_RTT)
  â‰ˆ 50ms + 100ms + 200ms + 80ms = 430ms

å¤±è´¥è·¯å¾„ï¼ˆåœ¨ Tâ‚ƒ å¤±è´¥ï¼‰ï¼š
  T_failure = Tâ‚ + Tâ‚‚ + failed(Tâ‚ƒ) + Câ‚‚ + Câ‚
  â‰ˆ 50ms + 100ms + 50ms + 60ms + 30ms = 290ms
```

---

## 2. CQRS æ¨¡å¼ï¼ˆå‘½ä»¤æŸ¥è¯¢åˆ†ç¦»ï¼‰

### 2.1 é—®é¢˜èƒŒæ™¯

**ä¼ ç»Ÿ CRUD å›°å¢ƒ**ï¼š

- è¯»å†™å…±äº«åŒä¸€ä¸ªæ•°æ®æ¨¡å‹
- å¤æ‚æŸ¥è¯¢æ‹–ç´¯å†™å…¥æ€§èƒ½
- è¯»å†™æ‰©å±•æ€§çŸ›ç›¾

**CQRS æ–¹æ¡ˆ**ï¼š
> å°†**å‘½ä»¤ï¼ˆå†™ï¼‰** å’Œ**æŸ¥è¯¢ï¼ˆè¯»ï¼‰** åˆ†ç¦»ä¸ºä¸åŒçš„æ¨¡å‹å’Œè·¯å¾„ã€‚

### 2.2 å½¢å¼åŒ–å®šä¹‰

#### 2.2.1 åŸºæœ¬ç»“æ„

```text
System = âŸ¨CommandSide, QuerySide, SyncâŸ©

CommandSide:
  - å¤„ç† Commandsï¼ˆåˆ›å»ºã€æ›´æ–°ã€åˆ é™¤ï¼‰
  - ç»´æŠ¤å†™ä¼˜åŒ–çš„æ•°æ®æ¨¡å‹
  - å‘å¸ƒ Events é€šçŸ¥ QuerySide

QuerySide:
  - å¤„ç† Queriesï¼ˆè¯»å–ï¼‰
  - ç»´æŠ¤è¯»ä¼˜åŒ–çš„æ•°æ®æ¨¡å‹ï¼ˆå¯å¤šä¸ªè§†å›¾ï¼‰
  - è®¢é˜… Events æ›´æ–°æ•°æ®

Sync:
  - å¼‚æ­¥åŒæ­¥æœºåˆ¶ï¼ˆEvent Busï¼‰
  - æœ€ç»ˆä¸€è‡´æ€§
```

#### 2.2.2 æ•°å­¦æ¨¡å‹

```text
å‘½ä»¤ç©ºé—´ï¼š
  C = {CreateOrder, UpdateInventory, CancelOrder, ...}

æŸ¥è¯¢ç©ºé—´ï¼š
  Q = {GetOrderByID, ListOrders, SearchProducts, ...}

çŠ¶æ€è½¬ç§»ï¼š
  apply: State Ã— C â†’ State Ã— Events
  project: Events â†’ QueryModel

ä¸€è‡´æ€§ä¸å˜å¼ï¼š
  âˆ€e âˆˆ Events. eventually(QueryModel reflects e)
```

#### 2.2.3 UH-Cost å»ºæ¨¡

```text
è¶…å›¾ç»“æ„ï¼š

èŠ‚ç‚¹ï¼š
  WriteDB, EventBus, ReadDBâ‚, ReadDBâ‚‚, ...

è¶…è¾¹ï¼š
  Command: Client â†’ WriteDB â†’ EventBus
  Projection: EventBus â†’ ReadDB_i
  Query: Client â†’ ReadDB_i

æˆæœ¬è¯­ä¹‰ï¼š
  Îº(Command) = write_latency + event_publish_latency
  Îº(Query) = read_latency  (æ— é”ï¼Œä½å»¶è¿Ÿ)

æƒè¡¡ï¼š
  - å†™è·¯å¾„æ›´é•¿ï¼ˆéœ€å‘å¸ƒäº‹ä»¶ï¼‰
  - è¯»è·¯å¾„æ›´å¿«ï¼ˆé¢„è®¡ç®—è§†å›¾ï¼‰
```

### 2.3 å½¢å¼éªŒè¯ï¼šä¸€è‡´æ€§æ¨¡å‹

#### æœ€ç»ˆä¸€è‡´æ€§è¯æ˜

```text
å®šç†ï¼ˆæœ€ç»ˆä¸€è‡´æ€§ï¼‰ï¼š
  âˆ€c âˆˆ Commands. âˆ€q âˆˆ Queries.
  å¦‚æœ c åœ¨æ—¶åˆ» t æ‰§è¡Œï¼Œåˆ™å­˜åœ¨ Î”t ä½¿å¾—ï¼š
    q åœ¨ t + Î”t åè¿”å›åæ˜  c çš„ç»“æœ

è¯æ˜è‰å›¾ï¼š
  1. c äº§ç”Ÿäº‹ä»¶ eï¼Œe è¿›å…¥ EventBusï¼ˆå¯é æ¶ˆæ¯é˜Ÿåˆ—ï¼‰
  2. QuerySide è®¢é˜…è€…æœ€ç»ˆæ¶ˆè´¹ eï¼ˆat-least-once è¯­ä¹‰ï¼‰
  3. æŠ•å½±å‡½æ•° project(e) æ›´æ–° QueryModel
  4. åç»­æŸ¥è¯¢ q è¯»å–æ›´æ–°åçš„ QueryModel

å‰ææ¡ä»¶ï¼š
  - EventBus ä¿è¯æ¶ˆæ¯ä¸ä¸¢å¤±
  - æŠ•å½±å‡½æ•°æ˜¯å¹‚ç­‰çš„ï¼ˆé‡å¤æ¶ˆè´¹ä¸å½±å“ç»“æœï¼‰
```

#### Coq å½¢å¼åŒ–ï¼ˆç®€åŒ–ï¼‰

```coq
(* äº‹ä»¶æµ *)
Definition EventStream := list Event.

(* æŠ•å½±å‡½æ•° *)
Definition project (es: EventStream) : QueryModel :=
  fold_left apply_event empty_model es.

(* å®šç†ï¼šæŸ¥è¯¢æ¨¡å‹æœ€ç»ˆåæ˜ æ‰€æœ‰äº‹ä»¶ *)
Theorem eventual_consistency :
  forall (cmd: Command) (events: EventStream) (model: QueryModel),
    In (command_to_event cmd) events ->
    exists model', project events = model' /\
                    reflects model' cmd.
Proof.
  intros cmd events model H_in.
  exists (project events).
  split.
  - reflexivity.
  - (* å½’çº³è¯æ˜ï¼šfold_left æœ€ç»ˆåº”ç”¨æ‰€æœ‰äº‹ä»¶ *)
    induction events as [| e es IH].
    + simpl in H_in. contradiction.
    + simpl. destruct (event_eq_dec (command_to_event cmd) e).
      * subst. apply apply_event_reflects.
      * apply IH. simpl in H_in. destruct H_in; [contradiction | assumption].
Qed.
```

### 2.4 å®æˆ˜æ¡ˆä¾‹ï¼šç”µå•†ç³»ç»Ÿ

#### æ¶æ„è®¾è®¡

```text
CommandSide:
  - PostgreSQL (è§„èŒƒåŒ–ï¼Œæ”¯æŒäº‹åŠ¡)
  - Commands: CreateOrder, UpdateOrderStatus

QuerySide:
  - Elasticsearch (å…¨æ–‡æœç´¢)
  - Redis (ç¼“å­˜çƒ­æ•°æ®)
  - Cassandra (åˆ†ææŸ¥è¯¢ï¼Œå®½è¡¨)

åŒæ­¥æœºåˆ¶ï¼š
  - Kafka (Event Bus)
  - Debezium (CDC - Change Data Capture)
```

#### Go å®ç°

```go
// Command ç«¯
type OrderCommandHandler struct {
    db        *sql.DB
    eventBus  *kafka.Producer
}

func (h *OrderCommandHandler) CreateOrder(cmd CreateOrderCommand) error {
    tx, _ := h.db.Begin()
    defer tx.Rollback()
    
    // 1. å†™å…¥æ•°æ®åº“
    _, err := tx.Exec(
        "INSERT INTO orders (id, user_id, total) VALUES (?, ?, ?)",
        cmd.OrderID, cmd.UserID, cmd.Total,
    )
    if err != nil {
        return err
    }
    
    // 2. å‘å¸ƒäº‹ä»¶
    event := OrderCreatedEvent{
        OrderID:   cmd.OrderID,
        UserID:    cmd.UserID,
        Total:     cmd.Total,
        Timestamp: time.Now(),
    }
    if err := h.eventBus.Produce("orders", event); err != nil {
        return err
    }
    
    return tx.Commit()
}

// Query ç«¯ï¼ˆElasticsearch æŠ•å½±ï¼‰
type OrderQueryHandler struct {
    es *elasticsearch.Client
}

func (h *OrderQueryHandler) OnOrderCreated(event OrderCreatedEvent) error {
    doc := map[string]interface{}{
        "order_id": event.OrderID,
        "user_id":  event.UserID,
        "total":    event.Total,
        "status":   "pending",
    }
    
    _, err := h.es.Index(
        "orders",
        esutil.NewJSONReader(doc),
        h.es.Index.WithDocumentID(event.OrderID),
    )
    return err
}

func (h *OrderQueryHandler) SearchOrders(userID string) ([]Order, error) {
    query := map[string]interface{}{
        "query": map[string]interface{}{
            "term": map[string]interface{}{
                "user_id": userID,
            },
        },
    }
    
    res, err := h.es.Search(
        h.es.Search.WithIndex("orders"),
        h.es.Search.WithBody(esutil.NewJSONReader(query)),
    )
    // ... è§£æç»“æœ
    return orders, err
}
```

**æˆæœ¬å¯¹æ¯”**ï¼š

```text
ä¼ ç»Ÿ CRUDï¼ˆPostgreSQLï¼‰ï¼š
  - å†™å…¥ï¼šINSERT + ç´¢å¼•æ›´æ–° â‰ˆ 10ms
  - å¤æ‚æŸ¥è¯¢ï¼ˆJOIN + å…¨æ–‡æœç´¢ï¼‰ï¼š200-500ms

CQRSï¼š
  - å†™å…¥ï¼šINSERT + Kafka Produce â‰ˆ 15ms (+5ms)
  - ç®€å•æŸ¥è¯¢ï¼ˆRedisï¼‰ï¼š< 1ms (200-500x faster)
  - å¤æ‚æŸ¥è¯¢ï¼ˆElasticsearchï¼‰ï¼š20-50ms (10x faster)

æƒè¡¡ï¼šå†™å…¥ç•¥æ…¢ï¼ˆ+5msï¼‰ï¼Œä½†è¯»å–æ˜¾è‘—åŠ é€Ÿã€‚
```

---

## 3. Event Sourcing æ¨¡å¼ï¼ˆäº‹ä»¶æº¯æºï¼‰

### 3.1 é—®é¢˜èƒŒæ™¯

**ä¼ ç»ŸçŠ¶æ€å­˜å‚¨å›°å¢ƒ**ï¼š

- åªå­˜å‚¨**å½“å‰çŠ¶æ€**ï¼Œå†å²ä¸¢å¤±
- å®¡è®¡å›°éš¾
- éš¾ä»¥é‡å»ºè¿‡å»çš„çŠ¶æ€

**Event Sourcing æ–¹æ¡ˆ**ï¼š
> ä¸å­˜å‚¨å½“å‰çŠ¶æ€ï¼Œè€Œæ˜¯å­˜å‚¨**æ‰€æœ‰å¯¼è‡´çŠ¶æ€å˜åŒ–çš„äº‹ä»¶**ï¼Œå½“å‰çŠ¶æ€é€šè¿‡**é‡æ”¾äº‹ä»¶**è®¡ç®—å¾—å‡ºã€‚

### 3.2 å½¢å¼åŒ–å®šä¹‰

#### 3.2.1 åŸºæœ¬ç»“æ„

```text
EventStore = æœ‰åºäº‹ä»¶åºåˆ— [eâ‚, eâ‚‚, ..., eâ‚™]

çŠ¶æ€è®¡ç®—ï¼š
  State = fold_left apply empty [eâ‚, eâ‚‚, ..., eâ‚™]
  
  å…¶ä¸­ apply: State Ã— Event â†’ State

ä¸å˜å¼ï¼š
  - äº‹ä»¶ä¸å¯å˜ï¼ˆImmutableï¼‰
  - äº‹ä»¶ä»…è¿½åŠ ï¼ˆAppend-Onlyï¼‰
  - äº‹ä»¶æœ‰åºï¼ˆæŒ‰æ—¶é—´æˆ³æˆ–åºåˆ—å·ï¼‰
```

#### 3.2.2 æ•°å­¦æ¨¡å‹

```text
äº‹ä»¶ç©ºé—´ï¼š
  E = {OrderCreated, PaymentReceived, OrderShipped, ...}

çŠ¶æ€ç©ºé—´ï¼š
  S = {Order states}

è½¬ç§»å‡½æ•°ï¼š
  Î´: S Ã— E â†’ S

é‡æ”¾å‡½æ•°ï¼š
  replay: Sâ‚€ Ã— E* â†’ S
  replay(sâ‚€, []) = sâ‚€
  replay(sâ‚€, e::es) = replay(Î´(sâ‚€, e), es)

å®šç†ï¼ˆç¡®å®šæ€§é‡æ”¾ï¼‰ï¼š
  âˆ€eâ‚, eâ‚‚ âˆˆ E*. eâ‚ = eâ‚‚ â‡’ replay(sâ‚€, eâ‚) = replay(sâ‚€, eâ‚‚)
```

#### 3.2.3 UH-Cost å»ºæ¨¡

```text
EventStore as Hypergraph:

èŠ‚ç‚¹ï¼š
  Eventâ‚, Eventâ‚‚, ..., Eventâ‚™, State

è¶…è¾¹ï¼ˆå› æœä¾èµ–ï¼‰ï¼š
  Event_i â†’ Event_{i+1}  (é¡ºåº)
  {Eventâ‚, ..., Event_n} â†’ State (æŠ•å½±)

é‡å†™è§„åˆ™ï¼š
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (Append)
  EventStore âˆª {new_event}
  
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  (Replay)
  fold(EventStore) â†’ State

æˆæœ¬å‡½æ•°ï¼š
  Îº(Append) = O(1)  (è¿½åŠ å¸¸æ•°æ—¶é—´)
  Îº(Replay) = O(n)  (n = äº‹ä»¶æ•°é‡)
  Îº(Snapshot) = O(n) å†™ + O(1) è¯»  (ä¼˜åŒ–)
```

### 3.3 å¿«ç…§ä¼˜åŒ–ï¼ˆSnapshotï¼‰

**é—®é¢˜**ï¼šäº‹ä»¶æ•°é‡å¢é•¿å¯¼è‡´é‡æ”¾ç¼“æ…¢ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼šå®šæœŸåˆ›å»º**å¿«ç…§**ï¼ˆSnapshotï¼‰ã€‚

```text
EventStore = [eâ‚, ..., eâ‚â‚€â‚€â‚€, snapshotâ‚â‚€â‚€â‚€, eâ‚â‚€â‚€â‚, ..., eâ‚‚â‚€â‚€â‚€]

é‡æ”¾ä¼˜åŒ–ï¼š
  replay_optimized(es):
    latest_snapshot = find_latest_snapshot(es)
    events_after = es.after(latest_snapshot)
    return replay(latest_snapshot.state, events_after)

æˆæœ¬ï¼š
  Îº(replay_optimized) = O(m)  (m = æœ€åä¸€ä¸ªå¿«ç…§åçš„äº‹ä»¶æ•°)
```

### 3.4 å½¢å¼éªŒè¯ï¼šCQRS + Event Sourcing ç»„åˆ

#### TLA+ è§„çº¦

```tla
---- MODULE EventSourcingCQRS ----
EXTENDS Naturals, Sequences

VARIABLES
  eventStore,    \* äº‹ä»¶å­˜å‚¨ï¼ˆåºåˆ—ï¼‰
  writeModel,    \* å†™æ¨¡å‹çŠ¶æ€
  readModel,     \* è¯»æ¨¡å‹çŠ¶æ€
  pending        \* å¾…æŠ•å½±çš„äº‹ä»¶

Init ==
  /\ eventStore = <<>>
  /\ writeModel = [balance |-> 0]
  /\ readModel = [balance |-> 0]
  /\ pending = <<>>

\* å¤„ç†å‘½ä»¤ï¼šå­˜å‚¨äº‹ä»¶
ProcessCommand(event) ==
  /\ eventStore' = Append(eventStore, event)
  /\ writeModel' = ApplyEvent(writeModel, event)
  /\ pending' = Append(pending, event)
  /\ UNCHANGED readModel

\* æŠ•å½±äº‹ä»¶åˆ°æŸ¥è¯¢æ¨¡å‹
ProjectEvent ==
  /\ pending /= <<>>
  /\ LET event == Head(pending) IN
       /\ readModel' = ApplyEvent(readModel, event)
       /\ pending' = Tail(pending)
  /\ UNCHANGED <<eventStore, writeModel>>

\* ä¸å˜å¼ï¼šæœ€ç»ˆä¸€è‡´æ€§
EventualConsistency ==
  <>[] (pending = <<>> => readModel = writeModel)

\* ä¸å˜å¼ï¼šäº‹ä»¶é¡ºåºä¿æŒ
EventOrder ==
  \A i \in 1..Len(eventStore) : 
    eventStore[i].timestamp < eventStore[i+1].timestamp

====
```

### 3.5 å®æˆ˜æ¡ˆä¾‹ï¼šé“¶è¡Œè´¦æˆ·ç³»ç»Ÿ

#### äº‹ä»¶è®¾è®¡

```go
type Event interface {
    EventID() string
    Timestamp() time.Time
}

type AccountCreated struct {
    AccountID string
    InitialBalance int
    Timestamp time.Time
}

type MoneyDeposited struct {
    AccountID string
    Amount    int
    Timestamp time.Time
}

type MoneyWithdrawn struct {
    AccountID string
    Amount    int
    Timestamp time.Time
}
```

#### Event Store å®ç°

```go
type EventStore struct {
    db *sql.DB
}

func (es *EventStore) AppendEvent(event Event) error {
    data, _ := json.Marshal(event)
    _, err := es.db.Exec(
        "INSERT INTO events (aggregate_id, event_type, data, timestamp) VALUES (?, ?, ?, ?)",
        event.AggregateID(), event.EventType(), data, event.Timestamp(),
    )
    return err
}

func (es *EventStore) LoadEvents(aggregateID string) ([]Event, error) {
    rows, err := es.db.Query(
        "SELECT event_type, data FROM events WHERE aggregate_id = ? ORDER BY timestamp",
        aggregateID,
    )
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var events []Event
    for rows.Next() {
        var eventType string
        var data []byte
        rows.Scan(&eventType, &data)
        
        event := DeserializeEvent(eventType, data)
        events = append(events, event)
    }
    return events, nil
}
```

#### èšåˆæ ¹ï¼ˆAggregate Rootï¼‰

```go
type Account struct {
    ID      string
    Balance int
    Version int
    changes []Event
}

func (a *Account) Deposit(amount int) error {
    if amount <= 0 {
        return errors.New("amount must be positive")
    }
    
    event := MoneyDeposited{
        AccountID: a.ID,
        Amount:    amount,
        Timestamp: time.Now(),
    }
    
    a.apply(event)
    a.changes = append(a.changes, event)
    return nil
}

func (a *Account) Withdraw(amount int) error {
    if amount > a.Balance {
        return errors.New("insufficient balance")
    }
    
    event := MoneyWithdrawn{
        AccountID: a.ID,
        Amount:    amount,
        Timestamp: time.Now(),
    }
    
    a.apply(event)
    a.changes = append(a.changes, event)
    return nil
}

func (a *Account) apply(event Event) {
    switch e := event.(type) {
    case AccountCreated:
        a.ID = e.AccountID
        a.Balance = e.InitialBalance
    case MoneyDeposited:
        a.Balance += e.Amount
    case MoneyWithdrawn:
        a.Balance -= e.Amount
    }
    a.Version++
}

func (a *Account) Replay(events []Event) {
    for _, event := range events {
        a.apply(event)
    }
}
```

#### ä»“å‚¨ï¼ˆRepositoryï¼‰

```go
type AccountRepository struct {
    eventStore *EventStore
}

func (repo *AccountRepository) Save(account *Account) error {
    for _, event := range account.changes {
        if err := repo.eventStore.AppendEvent(event); err != nil {
            return err
        }
    }
    account.changes = nil // æ¸…ç©ºå·²ä¿å­˜çš„äº‹ä»¶
    return nil
}

func (repo *AccountRepository) Load(accountID string) (*Account, error) {
    events, err := repo.eventStore.LoadEvents(accountID)
    if err != nil {
        return nil, err
    }
    
    account := &Account{}
    account.Replay(events)
    return account, nil
}
```

**æˆæœ¬åˆ†æ**ï¼š

```text
å†™å…¥ï¼ˆè¿½åŠ äº‹ä»¶ï¼‰ï¼š
  Îº(Append) = O(1) â‰ˆ 5ms (å•æ¡ INSERT)

è¯»å–ï¼ˆæ— å¿«ç…§ï¼‰ï¼š
  Îº(Load) = O(n) â‰ˆ n Ã— 0.1ms
  ä¾‹ï¼š1000 ä¸ªäº‹ä»¶ â‰ˆ 100ms

è¯»å–ï¼ˆæœ‰å¿«ç…§ï¼Œæ¯ 100 äº‹ä»¶ä¸€æ¬¡ï¼‰ï¼š
  Îº(Load_snapshot) = O(1) + O(m) â‰ˆ 1ms + m Ã— 0.1ms
  ä¾‹ï¼šæœ€å 50 ä¸ªäº‹ä»¶ â‰ˆ 6ms (16x åŠ é€Ÿ)
```

---

## 4. ä¸‰æ¨¡å¼ç»„åˆï¼šæœ€ä½³å®è·µ

### 4.1 ç»„åˆæ¶æ„

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      å®¢æˆ·ç«¯                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ Commands                           â”‚ Queries
         â–¼                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Command Handler   â”‚              â”‚  Query Handler   â”‚
â”‚   (Saga åè°ƒå™¨)     â”‚              â”‚  (å¤šä¸ªè§†å›¾)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                                   â”‚
           â”‚ 1. æ‰§è¡Œ Saga æµç¨‹                 â”‚
           â”‚ 2. è¿½åŠ  Events                    â”‚
           â–¼                                   â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Event Store       â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚   Event Bus      â”‚
â”‚   (ä¸å¯å˜æ—¥å¿—)      â”‚              â”‚   (Kafka)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                                   â”‚
           â”‚ Snapshot                          â”‚ Projections
           â–¼                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Snapshot Store    â”‚              â”‚  Read Models     â”‚
â”‚   (ä¼˜åŒ–è¯»å–)        â”‚              â”‚  (ES, Redis)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 å†³ç­–çŸ©é˜µ

| åœºæ™¯ | Saga | CQRS | Event Sourcing | ç»„åˆå»ºè®® |
|------|------|------|---------------|---------|
| å•ä½“åº”ç”¨ï¼Œç®€å• CRUD | âŒ | âŒ | âŒ | ä¼ ç»Ÿ ACID |
| å¾®æœåŠ¡ï¼Œè·¨æœåŠ¡äº‹åŠ¡ | âœ… | âœ… | âš ï¸ | Saga + CQRS |
| é«˜è¯»å†™æ¯”ï¼ˆ10:1 ä»¥ä¸Šï¼‰ | âš ï¸ | âœ… | âš ï¸ | CQRS |
| éœ€è¦å®Œæ•´å®¡è®¡æ—¥å¿— | âš ï¸ | âš ï¸ | âœ… | Event Sourcing |
| é‡‘èç³»ç»Ÿï¼ˆç›‘ç®¡è¦æ±‚ï¼‰ | âœ… | âœ… | âœ… | å…¨éƒ¨ |
| åä½œç³»ç»Ÿï¼ˆç‰ˆæœ¬æ§åˆ¶ï¼‰ | âŒ | âœ… | âœ… | CQRS + Event Sourcing |

### 4.3 é™·é˜±ä¸åæ¨¡å¼

**Saga é™·é˜±**ï¼š

1. **è¡¥å¿ä¸å¹‚ç­‰**ï¼šè¡¥å¿äº‹åŠ¡è¢«é‡å¤æ‰§è¡Œå¯¼è‡´é”™è¯¯
   - è§£å†³ï¼šè®°å½•è¡¥å¿æ‰§è¡ŒçŠ¶æ€ï¼Œæ·»åŠ å¹‚ç­‰æ€§æ£€æŸ¥
2. **å¾ªç¯ä¾èµ–**ï¼šTâ‚‚ ä¾èµ– Tâ‚ï¼ŒTâ‚ çš„è¡¥å¿åˆä¾èµ– Tâ‚‚
   - è§£å†³ï¼šé‡æ–°è®¾è®¡äº‹åŠ¡è¾¹ç•Œ

**CQRS é™·é˜±**ï¼š

1. **è¿‡åº¦åˆ†ç¦»**ï¼šä¸ºç®€å• CRUD å¼•å…¥ CQRS å¯¼è‡´å¤æ‚åº¦çˆ†ç‚¸
   - è§£å†³ï¼šä»…åœ¨è¯»å†™è´Ÿè½½å·®å¼‚å¤§æˆ–æŸ¥è¯¢æ¨¡å‹å¤æ‚æ—¶ä½¿ç”¨
2. **åŒæ­¥å»¶è¿Ÿä¸å¯æ¥å—**ï¼šç”¨æˆ·æœŸæœ›ç«‹å³ä¸€è‡´æ€§
   - è§£å†³ï¼šä½¿ç”¨"è¯»è‡ªå·±å†™"ï¼ˆRead-Your-Writesï¼‰ä¸€è‡´æ€§

**Event Sourcing é™·é˜±**ï¼š

1. **äº‹ä»¶çˆ†ç‚¸**ï¼šäº‹ä»¶æ•°é‡è¿‡å¤šå¯¼è‡´é‡æ”¾ç¼“æ…¢
   - è§£å†³ï¼šå®šæœŸå¿«ç…§ + äº‹ä»¶å½’æ¡£
2. **äº‹ä»¶ç‰ˆæœ¬æ¼”åŒ–**ï¼šäº‹ä»¶ç»“æ„å˜åŒ–å¯¼è‡´æ—§äº‹ä»¶æ— æ³•è§£æ
   - è§£å†³ï¼šäº‹ä»¶ upcastingï¼ˆç‰ˆæœ¬è½¬æ¢å™¨ï¼‰

---

## 5. ä¸å›½é™…è¯¾ç¨‹å¯¹æ ‡

### 5.1 å¤§å­¦è¯¾ç¨‹æ˜ å°„

| è¯¾ç¨‹ | ç›¸å…³ç« èŠ‚ |
|------|---------|
| **MIT 6.824 åˆ†å¸ƒå¼ç³»ç»Ÿ** | Saga (ä¸¤é˜¶æ®µæäº¤æ›¿ä»£), Event Sourcing (æ—¥å¿—å¤åˆ¶) |
| **CMU 15-445 æ•°æ®åº“ç³»ç»Ÿ** | CQRS (ç‰©åŒ–è§†å›¾), Event Sourcing (WAL æœºåˆ¶) |
| **Berkeley CS294-91 äº‘è®¡ç®—** | Saga ç¼–æ’ (å·¥ä½œæµå¼•æ“), CQRS (Lambda æ¶æ„) |
| **ETH ZÃ¼rich å½¢å¼åŒ–æ–¹æ³•** | Saga çš„ TLA+ éªŒè¯, CQRS çš„æœ€ç»ˆä¸€è‡´æ€§è¯æ˜ |
| **Stanford CS343 å¹¶å‘ç¼–ç¨‹** | Saga çš„è¡¥å¿äº‹åŠ¡ (äº‹åŠ¡å†…å­˜), Event Sourcing (MVCC) |

### 5.2 æ•™æå¯¹åº”

| æ•™æ | ç›¸å…³ç« èŠ‚ |
|------|---------|
| **Designing Data-Intensive Applications** (Kleppmann) | Ch 7 (Transactions), Ch 11 (Stream Processing) |
| **Microservices Patterns** (Richardson) | Ch 4 (Saga), Ch 7 (CQRS/Event Sourcing) |
| **Building Microservices** (Newman) | Ch 6 (Saga), Ch 8 (Event-Driven) |
| **Domain-Driven Design** (Evans) | Event Sourcing å“²å­¦åŸºç¡€ |

---

## 6. å·¥å…·ä¸ç”Ÿæ€

### 6.1 Saga å·¥å…·

| å·¥å…· | ç±»å‹ | ç‰¹ç‚¹ |
|------|------|------|
| **Temporal** | Orchestration | å·¥ä½œæµå¼•æ“ï¼Œæ”¯æŒé•¿äº‹åŠ¡ï¼ŒGo/Java SDK |
| **Apache Camel** | Choreography | ESB é›†æˆæ¡†æ¶ï¼Œæ”¯æŒ Saga EIP |
| **Axon Framework** | Orchestration | Javaï¼Œç»“åˆ CQRS/ES |
| **Eventuate Tram** | Choreography | è½»é‡çº§ï¼ŒåŸºäºæ¶ˆæ¯é˜Ÿåˆ— |

### 6.2 CQRS å·¥å…·

| å·¥å…· | ç±»å‹ | ç‰¹ç‚¹ |
|------|------|------|
| **Kafka** | Event Bus | é«˜ååé‡ï¼ŒæŒä¹…åŒ–æ—¥å¿— |
| **Debezium** | CDC | æ•è·æ•°æ®åº“å˜æ›´ä¸ºäº‹ä»¶ |
| **Elasticsearch** | Read Model | å…¨æ–‡æœç´¢ï¼ŒèšåˆæŸ¥è¯¢ |
| **Redis** | Read Model | ç¼“å­˜ï¼Œä½å»¶è¿Ÿ |

### 6.3 Event Sourcing å·¥å…·

| å·¥å…· | ç±»å‹ | ç‰¹ç‚¹ |
|------|------|------|
| **EventStoreDB** | ä¸“ç”¨å­˜å‚¨ | åŸç”Ÿæ”¯æŒäº‹ä»¶æµï¼ŒæŠ•å½±åŠŸèƒ½ |
| **Axon Server** | ä¸“ç”¨å­˜å‚¨ | Java ç”Ÿæ€ï¼Œé›†æˆ Axon Framework |
| **Kafka + KSQL** | æµå¤„ç† | åˆ©ç”¨ Kafka ä½œä¸ºäº‹ä»¶æ—¥å¿— |
| **PostgreSQL** | é€šç”¨å­˜å‚¨ | è¿½åŠ è¡¨ + è§¦å‘å™¨å®ç° |

---

## 7. æ‰©å±•é˜…è¯»

### 7.1 å­¦æœ¯è®ºæ–‡

1. **Saga**: Garcia-Molina & Salem. "Sagas." SIGMOD 1987.
2. **CQRS ç†è®º**: Young, Greg. "CQRS Documents." 2010.
3. **Event Sourcing**: Fowler, Martin. "Event Sourcing." martinfowler.com, 2005.
4. **å½¢å¼åŒ–éªŒè¯**: Lamport, Leslie. "Specifying Systems: The TLA+ Language and Tools." 2002.

### 7.2 åœ¨çº¿èµ„æº

- **Saga æ¨¡å¼**ï¼š<https://microservices.io/patterns/data/saga.html>
- **CQRS**ï¼š<https://martinfowler.com/bliki/CQRS.html>
- **Event Sourcing**ï¼š<https://martinfowler.com/eaaDev/EventSourcing.html>

### 7.3 æœ¬åœ°é¡¹ç›®å¼•ç”¨

- **å¹¶å‘æ¨¡å‹**ï¼š[../../FormalLanguage_Perspective/05_Computational_Models/](../../FormalLanguage_Perspective/05_Computational_Models/)
- **å½¢å¼éªŒè¯**ï¼š[../05_Formal_Verification/05.2_Model_Checking_Tools.md](../05_Formal_Verification/05.2_Model_Checking_Tools.md)
- **åˆ†å¸ƒå¼ç³»ç»Ÿ**ï¼š[../../Information_Theory_Perspective/08_Cross_Domain_Applications/](../../Information_Theory_Perspective/08_Cross_Domain_Applications/)

---

## é™„å½• Aï¼šWikipedia æ¦‚å¿µå¯¹ç…§

| æ¦‚å¿µ | Wikipedia æ¡ç›® | æœ¬æ–‡ç« èŠ‚ |
|------|---------------|----------|
| Saga Pattern | <https://en.wikipedia.org/wiki/Long-running_transaction> | Â§1 |
| CQRS | <https://en.wikipedia.org/wiki/Command_Query_Responsibility_Segregation> | Â§2 |
| Event Sourcing | <https://en.wikipedia.org/wiki/Event_sourcing> | Â§3 |
| Two-Phase Commit | <https://en.wikipedia.org/wiki/Two-phase_commit_protocol> | Â§1.1 |
| Eventual Consistency | <https://en.wikipedia.org/wiki/Eventual_consistency> | Â§2.3 |
| Compensating Transaction | <https://en.wikipedia.org/wiki/Compensating_transaction> | Â§1.2 |

---

**ç‰ˆæœ¬**ï¼šv1.0  
**æœ€åæ›´æ–°**ï¼š2025-10-29  
**ç»´æŠ¤è€…**ï¼šFormalScience Project  
**è®¸å¯**ï¼šMIT
