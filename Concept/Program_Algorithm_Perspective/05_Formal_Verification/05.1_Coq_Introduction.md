# 5.1 Coq Introduction

> **å­ä¸»é¢˜ç¼–å·**: 05.1
> **ä¸»é¢˜**: ç¨‹åºç®—æ³•è§†è§’

## 1 ğŸ“Š æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ

<details>
<summary><b>ğŸ“ğŸ”¬ ç‚¹å‡»å±•å¼€ï¼šCoqå®šç†è¯æ˜æ ¸å¿ƒæ´å¯Ÿ</b></summary>

**ç»ˆææ´å¯Ÿ**: Coq=ç¨‹åºä¸è¯æ˜çš„ç»Ÿä¸€ç³»ç»Ÿã€‚ç†è®ºåŸºç¡€ï¼šCICï¼ˆCalculus of Inductive Constructionsï¼‰ï¼Œç±»å‹è®º+å½’çº³ç±»å‹+ä¾èµ–ç±»å‹çš„ç»“åˆã€‚Curry-HowardåŒæ„ï¼šç±»å‹=å‘½é¢˜ï¼Œç¨‹åº=è¯æ˜ï¼Œç±»å‹æ£€æŸ¥=è¯æ˜éªŒè¯ã€‚æ ¸å¿ƒèƒ½åŠ›ï¼šâ‘ å®šä¹‰å½’çº³ç±»å‹ï¼šå¦‚è‡ªç„¶æ•°ã€åˆ—è¡¨ã€æ ‘â‘¡é™ˆè¿°å®šç†ï¼šç”¨ç±»å‹è¡¨è¾¾å‘½é¢˜â‘¢æ„é€ è¯æ˜ï¼šç”¨ç­–ç•¥ï¼ˆtacticsï¼‰äº¤äº’å¼è¯æ˜â‘£ç¨‹åºæå–ï¼šä»è¯æ˜ä¸­æå–å¯è¿è¡Œä»£ç ï¼ˆOCaml/Haskell/Schemeï¼‰ã€‚è¯æ˜ç­–ç•¥ï¼šâ‘ intro/introsï¼šå¼•å…¥å‡è®¾â‘¡applyï¼šåº”ç”¨å®šç†â‘¢inductionï¼šå½’çº³æ³•è¯æ˜â‘£simpl/unfoldï¼šåŒ–ç®€/å±•å¼€å®šä¹‰â‘¤auto/omegaï¼šè‡ªåŠ¨åŒ–ç­–ç•¥ã€‚ç»å…¸åº”ç”¨ï¼šâ‘ CompCertï¼ˆéªŒè¯çš„Cç¼–è¯‘å™¨ï¼‰ï¼š90Kè¡ŒCoqè¯æ˜â‘¡å››è‰²å®šç†ï¼šè®¡ç®—æœºè¾…åŠ©è¯æ˜â‘¢Feit-Thompsonå®šç†ï¼šå½¢å¼åŒ–æ•°å­¦è¯æ˜â‘£è½¯ä»¶åŸºç¡€ï¼ˆSoftware Foundationsï¼‰ï¼šPLæ•™å­¦ã€‚Coq vså…¶ä»–è¯æ˜å™¨ï¼šIsabelle/HOLï¼ˆæ›´å¼ºè‡ªåŠ¨åŒ–ï¼‰ã€Leanï¼ˆç°ä»£è¯­æ³•+æ•°å­¦åº“ï¼‰ã€Agdaï¼ˆæ›´çº¯ç²¹çš„ä¾èµ–ç±»å‹ï¼‰ã€‚å­¦ä¹ æ›²çº¿ï¼šé™¡å³­ä½†å›æŠ¥ä¸°åšï¼ŒæŒæ¡åå¯è¯æ˜å‡ ä¹ä»»ä½•æ•°å­¦/è®¡ç®—æ€§è´¨ã€‚å…³é”®ï¼šCoqå°†ç›´è§‰è¯æ˜å˜ä¸ºæœºå™¨å¯éªŒè¯çš„å½¢å¼è¯æ˜ï¼Œæ˜¯é«˜ä¿éšœè½¯ä»¶å¼€å‘çš„ç»ˆææ­¦å™¨ã€‚

</details>

---

## ğŸ“‹ ç›®å½•

- [5.1 Coq Introduction](#51-coq-introduction)
  - [1 ğŸ“Š æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ](#1--æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [2 æ¦‚è¿°](#2-æ¦‚è¿°)
  - [1 Coq åŸºç¡€](#1-coq-åŸºç¡€)
    - [1.1 å®‰è£…ä¸ç¯å¢ƒ](#11-å®‰è£…ä¸ç¯å¢ƒ)
      - [1 å®‰è£… Coq](#1-å®‰è£…-coq)
      - [2 IDE é€‰æ‹©](#2-ide-é€‰æ‹©)
    - [1.2 ç¬¬ä¸€ä¸ª Coq æ–‡ä»¶](#12-ç¬¬ä¸€ä¸ª-coq-æ–‡ä»¶)
    - [1.3 Coq çš„ç±»å‹ç³»ç»Ÿ](#13-coq-çš„ç±»å‹ç³»ç»Ÿ)
      - [1 ç±»å‹å±‚çº§](#1-ç±»å‹å±‚çº§)
      - [2 åŸºæœ¬ç±»å‹](#2-åŸºæœ¬ç±»å‹)
  - [2 å‘½é¢˜ä¸è¯æ˜](#2-å‘½é¢˜ä¸è¯æ˜)
    - [2.1 å‘½é¢˜é€»è¾‘](#21-å‘½é¢˜é€»è¾‘)
      - [1 åˆå–ï¼ˆANDï¼‰](#1-åˆå–and)
      - [2 æå–ï¼ˆORï¼‰](#2-æå–or)
      - [3 è•´å«ï¼ˆIMPLYï¼‰](#3-è•´å«imply)
    - [2.2 ä¸€é˜¶é€»è¾‘](#22-ä¸€é˜¶é€»è¾‘)
      - [1 å…¨ç§°é‡è¯ï¼ˆâˆ€ï¼‰](#1-å…¨ç§°é‡è¯)
      - [2 å­˜åœ¨é‡è¯ï¼ˆâˆƒï¼‰](#2-å­˜åœ¨é‡è¯)
  - [3 å½’çº³ç±»å‹ä¸é€’å½’](#3-å½’çº³ç±»å‹ä¸é€’å½’)
    - [3.1 è‡ªç„¶æ•°å®šä¹‰](#31-è‡ªç„¶æ•°å®šä¹‰)
    - [3.2 å½’çº³è¯æ˜](#32-å½’çº³è¯æ˜)
      - [1 å®šç†ï¼šåŠ æ³•äº¤æ¢å¾‹](#1-å®šç†åŠ æ³•äº¤æ¢å¾‹)
    - [3.3 åˆ—è¡¨è¯æ˜](#33-åˆ—è¡¨è¯æ˜)
  - [4 ç­–ç•¥ï¼ˆTacticsï¼‰è¯¦è§£](#4-ç­–ç•¥tacticsè¯¦è§£)
    - [4.1 åŸºæœ¬ç­–ç•¥](#41-åŸºæœ¬ç­–ç•¥)
    - [4.2 åˆ†è§£ç­–ç•¥](#42-åˆ†è§£ç­–ç•¥)
    - [4.3 è‡ªåŠ¨åŒ–ç­–ç•¥](#43-è‡ªåŠ¨åŒ–ç­–ç•¥)
  - [5 ç¨‹åºéªŒè¯](#5-ç¨‹åºéªŒè¯)
    - [5.1 ç¨‹åºæå–ï¼ˆExtractionï¼‰](#51-ç¨‹åºæå–extraction)
    - [5.2 å®šä¹‰ä¸éªŒè¯ï¼šæ’åºç®—æ³•](#52-å®šä¹‰ä¸éªŒè¯æ’åºç®—æ³•)
      - [1 æ’å…¥æ’åº](#1-æ’å…¥æ’åº)
  - [6 é«˜çº§ä¸»é¢˜](#6-é«˜çº§ä¸»é¢˜)
    - [6.1 ä¾èµ–ç±»å‹](#61-ä¾èµ–ç±»å‹)
    - [6.2 ç±»å‹ç±»ï¼ˆType Classesï¼‰](#62-ç±»å‹ç±»type-classes)
    - [6.3 Ltacï¼ˆç­–ç•¥è¯­è¨€ï¼‰](#63-ltacç­–ç•¥è¯­è¨€)
  - [7 å®æˆ˜æ¡ˆä¾‹ï¼šéªŒè¯å½’å¹¶æ’åº](#7-å®æˆ˜æ¡ˆä¾‹éªŒè¯å½’å¹¶æ’åº)
    - [7.1 å®ç°](#71-å®ç°)
    - [7.2 è¾…åŠ©å¼•ç†](#72-è¾…åŠ©å¼•ç†)
    - [7.3 ä¸»å®šç†](#73-ä¸»å®šç†)
  - [8 ä¸å›½é™…è¯¾ç¨‹å¯¹æ ‡](#8-ä¸å›½é™…è¯¾ç¨‹å¯¹æ ‡)
    - [8.1 å¤§å­¦è¯¾ç¨‹æ˜ å°„](#81-å¤§å­¦è¯¾ç¨‹æ˜ å°„)
    - [8.2 æ•™æå¯¹åº”](#82-æ•™æå¯¹åº”)
  - [9 æ‰©å±•é˜…è¯»](#9-æ‰©å±•é˜…è¯»)
    - [9.1 å­¦æœ¯è®ºæ–‡](#91-å­¦æœ¯è®ºæ–‡)
    - [9.2 åœ¨çº¿èµ„æº](#92-åœ¨çº¿èµ„æº)
    - [9.3 æœ¬åœ°é¡¹ç›®å¼•ç”¨](#93-æœ¬åœ°é¡¹ç›®å¼•ç”¨)
  - [10 ç»ƒä¹ é¢˜](#10-ç»ƒä¹ é¢˜)
    - [10.1 åŸºç¡€ç»ƒä¹ ](#101-åŸºç¡€ç»ƒä¹ )
    - [10.2 è¿›é˜¶ç»ƒä¹ ](#102-è¿›é˜¶ç»ƒä¹ )
    - [10.3 æŒ‘æˆ˜ç»ƒä¹ ](#103-æŒ‘æˆ˜ç»ƒä¹ )
  - [11 é™„å½• Aï¼šå¸¸ç”¨ç­–ç•¥é€ŸæŸ¥](#11-é™„å½•-aå¸¸ç”¨ç­–ç•¥é€ŸæŸ¥)
  - [12 é™„å½• Bï¼šWikipedia æ¦‚å¿µå¯¹ç…§](#12-é™„å½•-bwikipedia-æ¦‚å¿µå¯¹ç…§)
  - [è·¨è§†è§’é“¾æ¥](#è·¨è§†è§’é“¾æ¥)

---

## 2 æ¦‚è¿°

**Coq** æ˜¯ä¸€æ¬¾åŸºäº**é«˜é˜¶æ„é€ æ¼”ç®—**ï¼ˆCalculus of Inductive Constructions, CICï¼‰çš„äº¤äº’å¼å®šç†è¯æ˜å™¨ï¼Œå¹¿æ³›åº”ç”¨äºï¼š

- **ç¨‹åºéªŒè¯**ï¼šCompCertï¼ˆéªŒè¯çš„ C ç¼–è¯‘å™¨ï¼‰
- **æ•°å­¦å½¢å¼åŒ–**ï¼šå››è‰²å®šç†ã€å¥‡å¶å®šç†
- **å¯†ç å­¦**ï¼šå®‰å…¨åè®®éªŒè¯

æœ¬æ–‡æä¾› **é›¶åŸºç¡€åˆ°å®æˆ˜** çš„å®Œæ•´æ•™ç¨‹ï¼Œæ¶µç›–ï¼š

1. Coq çš„åŸºç¡€è¯­æ³•å’Œé€»è¾‘
2. å½’çº³ç±»å‹ä¸è¯æ˜ç­–ç•¥
3. ç¨‹åºæå–ä¸éªŒè¯
4. å®æˆ˜æ¡ˆä¾‹ï¼šæ’åºç®—æ³•è¯æ˜

---

## 1 Coq åŸºç¡€

### 1.1 å®‰è£…ä¸ç¯å¢ƒ

#### 1 å®‰è£… Coq

```bash
# macOS (Homebrew)
brew install coq

# Ubuntu/Debian
sudo apt install coq

# OPAMï¼ˆæ¨èï¼Œæ”¯æŒå¤šç‰ˆæœ¬ï¼‰
opam install coq

# éªŒè¯å®‰è£…
coqc --version  # è¾“å‡ºï¼šThe Coq Proof Assistant, version 8.18.0
```

#### 2 IDE é€‰æ‹©

```text
æ¨è IDEï¼š
1. CoqIDEï¼ˆå®˜æ–¹ï¼‰ï¼š
   - é›†æˆç¯å¢ƒï¼Œé€‚åˆåˆå­¦è€…
   - å®‰è£…ï¼šbrew install coqide

2. VS Code + VSCoqï¼š
   - ç°ä»£åŒ–ä½“éªŒ
   - å®‰è£…æ’ä»¶ï¼šVSCoq

3. Emacs + Proof Generalï¼š
   - ç»å…¸é€‰æ‹©ï¼Œå¼ºå¤§ä½†å­¦ä¹ æ›²çº¿é™¡å³­
```

### 1.2 ç¬¬ä¸€ä¸ª Coq æ–‡ä»¶

åˆ›å»º `hello.v`ï¼š

```coq
(* è¿™æ˜¯æ³¨é‡Š *)

(* å®šç†ï¼šå¯¹äºä»»ä½•å‘½é¢˜ Pï¼Œå¦‚æœ P ä¸ºçœŸï¼Œåˆ™ P ä¸ºçœŸ *)
Theorem identity : forall P : Prop, P -> P.
Proof.
  intros P HP.  (* å¼•å…¥å‡è®¾ï¼šP æ˜¯å‘½é¢˜ï¼ŒHP æ˜¯ P çš„è¯æ˜ *)
  exact HP.     (* HP å°±æ˜¯æˆ‘ä»¬è¦çš„è¯æ˜ *)
Qed.

(* æ£€æŸ¥å®šç†ç±»å‹ *)
Check identity.
(* è¾“å‡ºï¼šidentity : forall P : Prop, P -> P *)
```

**è¿è¡Œ**ï¼š

```bash
coqc hello.v  # ç¼–è¯‘
coqtop        # è¿›å…¥äº¤äº’å¼ç¯å¢ƒ
> Load hello.
> Check identity.
```

### 1.3 Coq çš„ç±»å‹ç³»ç»Ÿ

#### 1 ç±»å‹å±‚çº§

```text
Coq çš„ç±»å‹å®‡å®™ï¼ˆType Hierarchyï¼‰ï¼š

Prop    : å‘½é¢˜å®‡å®™ï¼ˆé€»è¾‘ï¼‰
Set     : å°ç±»å‹å®‡å®™ï¼ˆæ•°æ®ç»“æ„ï¼‰
Type(i) : å¤§ç±»å‹å®‡å®™ï¼ˆi æ˜¯å®‡å®™å±‚çº§ï¼‰

å±‚çº§å…³ç³»ï¼š
  Prop : Type(0)
  Set  : Type(0)
  Type(i) : Type(i+1)
```

#### 2 åŸºæœ¬ç±»å‹

```coq
(* å¸ƒå°”ç±»å‹ *)
Inductive bool : Set :=
  | true : bool
  | false : bool.

(* è‡ªç„¶æ•° *)
Inductive nat : Set :=
  | O : nat          (* é›¶ *)
  | S : nat -> nat.  (* åç»§ *)

(* ç¤ºä¾‹ï¼š3 çš„è¡¨ç¤º *)
Check (S (S (S O))).  (* : nat *)

(* åˆ—è¡¨ *)
Inductive list (A : Type) : Type :=
  | nil : list A
  | cons : A -> list A -> list A.

(* ä½¿ç”¨è¯­æ³•ç³– *)
Require Import List.
Import ListNotations.

Check [1; 2; 3].  (* : list nat *)
```

---

## 2 å‘½é¢˜ä¸è¯æ˜

### 2.1 å‘½é¢˜é€»è¾‘

#### 1 åˆå–ï¼ˆANDï¼‰

```coq
(* P âˆ§ Q å®šä¹‰ *)
Print and.
(*
  Inductive and (A B : Prop) : Prop :=
    conj : A -> B -> A /\ B
*)

(* è¯æ˜ï¼šP âˆ§ Q â†’ P *)
Theorem and_proj1 : forall P Q : Prop, P /\ Q -> P.
Proof.
  intros P Q H.
  (* H : P /\ Q *)
  destruct H as [HP HQ].
  (* HP : P, HQ : Q *)
  exact HP.
Qed.

(* è¯æ˜ï¼šP â†’ Q â†’ P âˆ§ Q *)
Theorem and_intro : forall P Q : Prop, P -> Q -> P /\ Q.
Proof.
  intros P Q HP HQ.
  split.
  - exact HP.
  - exact HQ.
Qed.
```

#### 2 æå–ï¼ˆORï¼‰

```coq
(* P âˆ¨ Q å®šä¹‰ *)
Print or.
(*
  Inductive or (A B : Prop) : Prop :=
    | or_introl : A -> A \/ B
    | or_intror : B -> A \/ B
*)

(* è¯æ˜ï¼šP â†’ P âˆ¨ Q *)
Theorem or_intro_l : forall P Q : Prop, P -> P \/ Q.
Proof.
  intros P Q HP.
  left.  (* é€‰æ‹©å·¦è¾¹ *)
  exact HP.
Qed.

(* è¯æ˜ï¼šP âˆ¨ Q â†’ Q âˆ¨ P *)
Theorem or_comm : forall P Q : Prop, P \/ Q -> Q \/ P.
Proof.
  intros P Q H.
  destruct H as [HP | HQ].
  - (* æƒ…å†µ 1: P *)
    right. exact HP.
  - (* æƒ…å†µ 2: Q *)
    left. exact HQ.
Qed.
```

#### 3 è•´å«ï¼ˆIMPLYï¼‰

```coq
(* P â†’ Q æ˜¯å‡½æ•°ç±»å‹ *)
Check forall P Q : Prop, P -> Q.

(* è¯æ˜ï¼š(P â†’ Q) â†’ (Q â†’ R) â†’ (P â†’ R) *)
Theorem impl_trans : forall P Q R : Prop,
  (P -> Q) -> (Q -> R) -> (P -> R).
Proof.
  intros P Q R HPQ HQR HP.
  apply HQR.
  apply HPQ.
  exact HP.
Qed.
```

### 2.2 ä¸€é˜¶é€»è¾‘

#### 1 å…¨ç§°é‡è¯ï¼ˆâˆ€ï¼‰

```coq
(* è¯æ˜ï¼šâˆ€x, P(x) â†’ âˆƒx, P(x) *)
Theorem forall_to_exists : forall (A : Type) (P : A -> Prop),
  (forall x : A, P x) -> exists x : A, P x.
Proof.
  intros A P H.
  (* éœ€è¦ä¸€ä¸ªå…·ä½“çš„ x *)
  (* ä½†æˆ‘ä»¬æ²¡æœ‰å‡è®¾ A éç©ºï¼è¿™ä¸ªå®šç†åœ¨ Coq ä¸­ä¸å¯è¯ *)
Abort.

(* ä¿®æ­£ï¼šæ·»åŠ  A éç©ºå‡è®¾ *)
Theorem forall_to_exists_correct : forall (A : Type) (P : A -> Prop),
  (exists x : A, True) ->  (* A éç©º *)
  (forall x : A, P x) ->
  exists x : A, P x.
Proof.
  intros A P [x0 _] Hall.
  exists x0.
  apply Hall.
Qed.
```

#### 2 å­˜åœ¨é‡è¯ï¼ˆâˆƒï¼‰

```coq
(* è¯æ˜ï¼šå­˜åœ¨å¶æ•° *)
Definition even (n : nat) : Prop :=
  exists k : nat, n = 2 * k.

Theorem two_is_even : even 2.
Proof.
  unfold even.
  exists 1.
  reflexivity.  (* 2 = 2 * 1 *)
Qed.

(* è¯æ˜ï¼šâˆƒx, P(x) âˆ§ Q(x) â†’ (âˆƒx, P(x)) âˆ§ (âˆƒx, Q(x)) *)
Theorem exists_and : forall (A : Type) (P Q : A -> Prop),
  (exists x : A, P x /\ Q x) ->
  (exists x : A, P x) /\ (exists x : A, Q x).
Proof.
  intros A P Q [x [HP HQ]].
  split.
  - exists x. exact HP.
  - exists x. exact HQ.
Qed.
```

---

## 3 å½’çº³ç±»å‹ä¸é€’å½’

### 3.1 è‡ªç„¶æ•°å®šä¹‰

```coq
Inductive nat : Set :=
  | O : nat
  | S : nat -> nat.

(* åŠ æ³•å®šä¹‰ï¼ˆé€’å½’ï¼‰ *)
Fixpoint plus (n m : nat) : nat :=
  match n with
  | O => m
  | S n' => S (plus n' m)
  end.

(* è¯­æ³•ç³– *)
Notation "n + m" := (plus n m).

(* ä¹˜æ³• *)
Fixpoint mult (n m : nat) : nat :=
  match n with
  | O => O
  | S n' => m + (mult n' m)
  end.

Notation "n * m" := (mult n m).
```

### 3.2 å½’çº³è¯æ˜

#### 1 å®šç†ï¼šåŠ æ³•äº¤æ¢å¾‹

```coq
(* å¼•ç†ï¼šn + 0 = n *)
Lemma plus_O_r : forall n : nat, n + O = n.
Proof.
  induction n as [| n' IH].
  - (* n = O *)
    simpl. reflexivity.
  - (* n = S n' *)
    simpl.  (* S n' + O = S (n' + O) *)
    rewrite IH.  (* åº”ç”¨å½’çº³å‡è®¾ï¼šn' + O = n' *)
    reflexivity.
Qed.

(* å¼•ç†ï¼šS n + m = n + S m *)
Lemma plus_S : forall n m : nat, S (n + m) = n + S m.
Proof.
  induction n as [| n' IH].
  - (* n = O *)
    intros m. simpl. reflexivity.
  - (* n = S n' *)
    intros m. simpl.
    rewrite IH.
    reflexivity.
Qed.

(* å®šç†ï¼šåŠ æ³•äº¤æ¢å¾‹ *)
Theorem plus_comm : forall n m : nat, n + m = m + n.
Proof.
  induction n as [| n' IH].
  - (* n = O *)
    intros m.
    simpl.  (* O + m = m *)
    rewrite plus_O_r.  (* m + O = m *)
    reflexivity.
  - (* n = S n' *)
    intros m.
    simpl.  (* S n' + m = S (n' + m) *)
    rewrite IH.  (* n' + m = m + n' *)
    rewrite plus_S.  (* S (m + n') = m + S n' *)
    reflexivity.
Qed.
```

### 3.3 åˆ—è¡¨è¯æ˜

```coq
Require Import List.
Import ListNotations.

(* åˆ—è¡¨è¿æ¥ *)
Fixpoint app {A : Type} (l1 l2 : list A) : list A :=
  match l1 with
  | nil => l2
  | h :: t => h :: (app t l2)
  end.

Notation "l1 ++ l2" := (app l1 l2).

(* å®šç†ï¼šåˆ—è¡¨è¿æ¥ç»“åˆå¾‹ *)
Theorem app_assoc : forall (A : Type) (l1 l2 l3 : list A),
  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).
Proof.
  intros A l1 l2 l3.
  induction l1 as [| h t IH].
  - (* l1 = nil *)
    simpl. reflexivity.
  - (* l1 = h :: t *)
    simpl.
    rewrite IH.
    reflexivity.
Qed.

(* åˆ—è¡¨é•¿åº¦ *)
Fixpoint length {A : Type} (l : list A) : nat :=
  match l with
  | nil => O
  | _ :: t => S (length t)
  end.

(* å®šç†ï¼šè¿æ¥åçš„é•¿åº¦ *)
Theorem app_length : forall (A : Type) (l1 l2 : list A),
  length (l1 ++ l2) = length l1 + length l2.
Proof.
  intros A l1 l2.
  induction l1 as [| h t IH].
  - (* l1 = nil *)
    simpl. reflexivity.
  - (* l1 = h :: t *)
    simpl.
    rewrite IH.
    reflexivity.
Qed.
```

---

## 4 ç­–ç•¥ï¼ˆTacticsï¼‰è¯¦è§£

### 4.1 åŸºæœ¬ç­–ç•¥

```coq
(* intros: å¼•å…¥å‡è®¾ *)
Theorem example_intros : forall n m : nat, n = m -> m = n.
Proof.
  intros n m H.
  (* Goal: m = n *)
  (* Context: n, m : nat, H : n = m *)
Abort.

(* exact: æä¾›ç²¾ç¡®è¯æ˜é¡¹ *)
Theorem example_exact : forall P : Prop, P -> P.
Proof.
  intros P HP.
  exact HP.
Qed.

(* apply: åº”ç”¨å®šç†/å‡è®¾ *)
Theorem example_apply : forall P Q R : Prop,
  (P -> Q) -> (Q -> R) -> P -> R.
Proof.
  intros P Q R HPQ HQR HP.
  apply HQR.
  apply HPQ.
  exact HP.
Qed.

(* reflexivity: ç­‰å¼è‡ªåæ€§ *)
Theorem example_refl : 2 + 2 = 4.
Proof.
  reflexivity.  (* Coq è‡ªåŠ¨è®¡ç®— 2 + 2 *)
Qed.

(* rewrite: ç­‰å¼æ”¹å†™ *)
Theorem example_rewrite : forall n m : nat,
  n = m -> n + n = m + m.
Proof.
  intros n m H.
  rewrite H.
  reflexivity.
Qed.
```

### 4.2 åˆ†è§£ç­–ç•¥

```coq
(* destruct: åˆ†æƒ…å†µè®¨è®º *)
Theorem example_destruct : forall b : bool,
  b = true \/ b = false.
Proof.
  intros b.
  destruct b.
  - (* b = true *)
    left. reflexivity.
  - (* b = false *)
    right. reflexivity.
Qed.

(* induction: å½’çº³æ³• *)
Theorem example_induction : forall n : nat,
  n + O = n.
Proof.
  intros n.
  induction n as [| n' IH].
  - (* n = O *)
    simpl. reflexivity.
  - (* n = S n' *)
    simpl.
    rewrite IH.
    reflexivity.
Qed.

(* inversion: åæ¼”å½’çº³ç±»å‹ *)
Inductive even : nat -> Prop :=
  | even_O : even O
  | even_SS : forall n, even n -> even (S (S n)).

Theorem example_inversion : forall n : nat,
  even (S n) -> even (S (S (S n))).
Proof.
  intros n H.
  inversion H.  (* S n ä¸å¯èƒ½ç”± even_O æ„é€  *)
  (* H å¿…å®šæ¥è‡ª even_SSï¼Œå¾—åˆ° n = S n0 *)
  apply even_SS.
  exact H.
Qed.
```

### 4.3 è‡ªåŠ¨åŒ–ç­–ç•¥

```coq
(* auto: è‡ªåŠ¨è¯æ˜ï¼ˆæµ…å±‚ï¼‰ *)
Theorem example_auto : forall P Q : Prop,
  P -> (P -> Q) -> Q.
Proof.
  auto.  (* è‡ªåŠ¨å®Œæˆ *)
Qed.

(* omega: çº¿æ€§ç®—æœ¯ *)
Require Import Omega.

Theorem example_omega : forall n m : nat,
  n < m -> n + 1 <= m.
Proof.
  intros n m H.
  omega.  (* è‡ªåŠ¨è§£å†³çº¿æ€§ä¸ç­‰å¼ *)
Qed.

(* lia: çº¿æ€§æ•´æ•°ç®—æœ¯ï¼ˆæ›¿ä»£ omegaï¼‰ *)
Require Import Lia.

Theorem example_lia : forall a b c : nat,
  a + b = c -> b + a = c.
Proof.
  intros a b c H.
  lia.
Qed.

(* ring: ç¯è®ºè‡ªåŠ¨åŒ– *)
Require Import Ring.

Theorem example_ring : forall a b c : nat,
  (a + b) * c = a * c + b * c.
Proof.
  intros.
  ring.
Qed.
```

---

## 5 ç¨‹åºéªŒè¯

### 5.1 ç¨‹åºæå–ï¼ˆExtractionï¼‰

```coq
(* å®šä¹‰ï¼šåˆ—è¡¨åè½¬ *)
Fixpoint rev {A : Type} (l : list A) : list A :=
  match l with
  | nil => nil
  | h :: t => rev t ++ [h]
  end.

(* å®šç†ï¼šåè½¬ä¸¤æ¬¡å¾—åˆ°åŸåˆ—è¡¨ *)
Theorem rev_involutive : forall (A : Type) (l : list A),
  rev (rev l) = l.
Proof.
  intros A l.
  induction l as [| h t IH].
  - (* l = nil *)
    simpl. reflexivity.
  - (* l = h :: t *)
    simpl.
    (* rev (rev t ++ [h]) = h :: t *)
    (* éœ€è¦å¼•ç†ï¼šrev (l1 ++ l2) = rev l2 ++ rev l1 *)
    Admitted.  (* ç•™ä½œç»ƒä¹  *)

(* æå–ä¸º OCaml ä»£ç  *)
Require Extraction.
Extraction Language OCaml.
Extraction "rev.ml" rev.
```

**ç”Ÿæˆçš„ OCaml ä»£ç **ï¼ˆ`rev.ml`ï¼‰ï¼š

```ocaml
type 'a list =
| Nil
| Cons of 'a * 'a list

let rec app l1 l2 =
  match l1 with
  | Nil -> l2
  | Cons (h, t) -> Cons (h, (app t l2))

let rec rev l =
  match l with
  | Nil -> Nil
  | Cons (h, t) -> app (rev t) (Cons (h, Nil))
```

### 5.2 å®šä¹‰ä¸éªŒè¯ï¼šæ’åºç®—æ³•

#### 1 æ’å…¥æ’åº

```coq
Require Import List Sorting.Sorted.
Import ListNotations.

(* è¾…åŠ©å‡½æ•°ï¼šæ’å…¥å…ƒç´ åˆ°æœ‰åºåˆ—è¡¨ *)
Fixpoint insert (x : nat) (l : list nat) : list nat :=
  match l with
  | nil => [x]
  | h :: t => if x <=? h then x :: h :: t else h :: insert x t
  end.

(* æ’å…¥æ’åº *)
Fixpoint insertion_sort (l : list nat) : list nat :=
  match l with
  | nil => nil
  | h :: t => insert h (insertion_sort t)
  end.

(* å®šä¹‰ï¼šæœ‰åºæ€§ *)
Inductive sorted : list nat -> Prop :=
  | sorted_nil : sorted nil
  | sorted_one : forall x, sorted [x]
  | sorted_cons : forall x y l,
      x <= y -> sorted (y :: l) -> sorted (x :: y :: l).

(* å¼•ç†ï¼šæ’å…¥ä¿æŒæœ‰åºæ€§ *)
Lemma insert_sorted : forall x l,
  sorted l -> sorted (insert x l).
Proof.
  intros x l H.
  induction H as [| y | y z l' Hyz Hsorted IH].
  - (* l = nil *)
    simpl. apply sorted_one.
  - (* l = [y] *)
    simpl. destruct (x <=? y) eqn:E.
    + apply sorted_cons. apply Nat.leb_le. exact E. apply sorted_one.
    + apply sorted_cons. apply Nat.leb_nle in E. lia. apply sorted_one.
  - (* l = y :: z :: l' *)
    simpl. destruct (x <=? y) eqn:E.
    + apply sorted_cons. apply Nat.leb_le. exact E. exact (sorted_cons y z l' Hyz Hsorted).
    + simpl in IH. destruct (x <=? z) eqn:E2.
      * apply sorted_cons. apply Nat.leb_nle in E. lia. apply sorted_cons.
        apply Nat.leb_le. exact E2. exact Hsorted.
      * apply sorted_cons. exact Hyz. exact IH.
Qed.

(* å®šç†ï¼šæ’å…¥æ’åºæ­£ç¡®æ€§ï¼ˆæœ‰åºæ€§ï¼‰ *)
Theorem insertion_sort_sorted : forall l,
  sorted (insertion_sort l).
Proof.
  intros l.
  induction l as [| h t IH].
  - (* l = nil *)
    simpl. apply sorted_nil.
  - (* l = h :: t *)
    simpl. apply insert_sorted. exact IH.
Qed.

(* å®šä¹‰ï¼šæ’åˆ— *)
(* ä½¿ç”¨ Coq æ ‡å‡†åº“çš„ Permutation *)
Require Import Permutation.

(* å¼•ç†ï¼šæ’å…¥ä¿æŒæ’åˆ— *)
Lemma insert_perm : forall x l,
  Permutation (x :: l) (insert x l).
Proof.
  intros x l.
  induction l as [| h t IH].
  - simpl. reflexivity.
  - simpl. destruct (x <=? h).
    + reflexivity.
    + transitivity (h :: x :: t).
      * apply perm_swap.
      * apply perm_skip. exact IH.
Qed.

(* å®šç†ï¼šæ’å…¥æ’åºæ­£ç¡®æ€§ï¼ˆæ’åˆ—ï¼‰ *)
Theorem insertion_sort_perm : forall l,
  Permutation l (insertion_sort l).
Proof.
  intros l.
  induction l as [| h t IH].
  - simpl. reflexivity.
  - simpl. transitivity (h :: insertion_sort t).
    + apply perm_skip. exact IH.
    + apply insert_perm.
Qed.

(* å®Œæ•´æ­£ç¡®æ€§ï¼šæ’åºæ—¢ä¿æŒæœ‰åºåˆä¿æŒæ’åˆ— *)
Theorem insertion_sort_correct : forall l,
  sorted (insertion_sort l) /\ Permutation l (insertion_sort l).
Proof.
  intros l.
  split.
  - apply insertion_sort_sorted.
  - apply insertion_sort_perm.
Qed.
```

---

## 6 é«˜çº§ä¸»é¢˜

### 6.1 ä¾èµ–ç±»å‹

```coq
(* å‘é‡ï¼šé•¿åº¦ç´¢å¼•çš„åˆ—è¡¨ *)
Inductive vec (A : Type) : nat -> Type :=
  | vnil : vec A 0
  | vcons : forall n : nat, A -> vec A n -> vec A (S n).

Arguments vnil {A}.
Arguments vcons {A} {n}.

(* å®‰å…¨çš„å–å¤´ *)
Definition vhead {A : Type} {n : nat} (v : vec A (S n)) : A :=
  match v with
  | vcons h _ => h
  end.

(* ç¼–è¯‘æœŸä¿è¯ï¼švhead ä¸èƒ½åº”ç”¨äºç©ºå‘é‡ *)
(* Fail Compute (vhead vnil). *)  (* ç±»å‹é”™è¯¯ï¼ *)

(* å‘é‡è¿æ¥ *)
Fixpoint vapp {A : Type} {n m : nat} (v1 : vec A n) (v2 : vec A m) : vec A (n + m) :=
  match v1 with
  | vnil => v2
  | vcons h t => vcons h (vapp t v2)
  end.

(* å®šç†ï¼šè¿æ¥åçš„é•¿åº¦ *)
Theorem vapp_length : forall (A : Type) (n m : nat) (v1 : vec A n) (v2 : vec A m),
  length (vapp v1 v2) = n + m.
Proof.
  (* é•¿åº¦å·²ç»ç¼–ç åœ¨ç±»å‹ä¸­ï¼ *)
  intros. reflexivity.
Qed.
```

### 6.2 ç±»å‹ç±»ï¼ˆType Classesï¼‰

```coq
(* å®šä¹‰å¯æ¯”è¾ƒç±»å‹ç±» *)
Class Comparable (A : Type) := {
  eqb : A -> A -> bool;
  eqb_eq : forall x y, eqb x y = true <-> x = y
}.

(* å®ä¾‹ï¼šnat çš„å¯æ¯”è¾ƒæ€§ *)
Instance nat_comparable : Comparable nat := {
  eqb := Nat.eqb;
  eqb_eq := Nat.eqb_eq
}.

(* æ³›å‹å‡½æ•°ï¼šåˆ—è¡¨ä¸­æ˜¯å¦åŒ…å«å…ƒç´  *)
Definition mem {A : Type} `{Comparable A} (x : A) (l : list A) : bool :=
  existsb (eqb x) l.

(* ä½¿ç”¨ *)
Compute mem 3 [1; 2; 3; 4].  (* true *)
```

### 6.3 Ltacï¼ˆç­–ç•¥è¯­è¨€ï¼‰

```coq
(* è‡ªå®šä¹‰ç­–ç•¥ï¼šè‡ªåŠ¨å¤„ç†ç®€å•åˆå– *)
Ltac split_and :=
  match goal with
  | |- _ /\ _ => split; split_and
  | _ => idtac
  end.

(* ä½¿ç”¨ç¤ºä¾‹ *)
Theorem example_ltac : forall P Q R : Prop,
  P -> Q -> R -> P /\ Q /\ R.
Proof.
  intros P Q R HP HQ HR.
  split_and.
  - exact HP.
  - exact HQ.
  - exact HR.
Qed.

(* æ›´å¤æ‚çš„ç­–ç•¥ï¼šè‡ªåŠ¨è§£æ„æ‰€æœ‰åˆå– *)
Ltac destruct_all_and :=
  repeat match goal with
  | H : _ /\ _ |- _ => destruct H
  end.

Theorem example_destruct_all : forall P Q R : Prop,
  (P /\ Q) /\ R -> P.
Proof.
  intros P Q R H.
  destruct_all_and.
  exact H.
Qed.
```

---

## 7 å®æˆ˜æ¡ˆä¾‹ï¼šéªŒè¯å½’å¹¶æ’åº

### 7.1 å®ç°

```coq
Require Import List Arith Permutation.
Import ListNotations.

(* åˆ†å‰²åˆ—è¡¨ *)
Fixpoint split {A : Type} (l : list A) : list A * list A :=
  match l with
  | nil => (nil, nil)
  | [x] => ([x], nil)
  | x :: y :: l' => let (l1, l2) := split l' in (x :: l1, y :: l2)
  end.

(* åˆå¹¶ä¸¤ä¸ªæœ‰åºåˆ—è¡¨ *)
Fixpoint merge (l1 l2 : list nat) : list nat :=
  match l1, l2 with
  | nil, _ => l2
  | _, nil => l1
  | h1 :: t1, h2 :: t2 =>
      if h1 <=? h2 then h1 :: merge t1 l2 else h2 :: merge l1 t2
  end.

(* å½’å¹¶æ’åº *)
Fixpoint merge_sort (l : list nat) : list nat :=
  match l with
  | nil | [_] => l
  | _ => let (l1, l2) := split l in merge (merge_sort l1) (merge_sort l2)
  end.
```

### 7.2 è¾…åŠ©å¼•ç†

```coq
(* å¼•ç†ï¼šsplit ä¸å¢åŠ é•¿åº¦ *)
Lemma split_length : forall (A : Type) (l : list A) l1 l2,
  split l = (l1, l2) ->
  length l1 + length l2 = length l.
Proof.
  intros A l. induction l as [| x [| y l'] IH]; intros l1 l2 Hsplit.
  - (* l = nil *)
    simpl in Hsplit. inversion Hsplit. reflexivity.
  - (* l = [x] *)
    simpl in Hsplit. inversion Hsplit. reflexivity.
  - (* l = x :: y :: l' *)
    simpl in Hsplit.
    destruct (split l') as [l1' l2'] eqn:E.
    inversion Hsplit; subst.
    simpl. assert (H := IH l1' l2' E). lia.
Qed.

(* å¼•ç†ï¼šsplit ä¿æŒæ’åˆ— *)
Lemma split_perm : forall (A : Type) (l : list A) l1 l2,
  split l = (l1, l2) ->
  Permutation l (l1 ++ l2).
Proof.
  intros A l. induction l as [| x [| y l'] IH]; intros l1 l2 Hsplit.
  - simpl in Hsplit. inversion Hsplit. reflexivity.
  - simpl in Hsplit. inversion Hsplit. simpl. reflexivity.
  - simpl in Hsplit.
    destruct (split l') as [l1' l2'] eqn:E.
    inversion Hsplit; subst.
    assert (Hperm := IH l1' l2' E).
    simpl. transitivity (x :: y :: (l1' ++ l2')).
    + apply perm_skip. apply perm_skip. exact Hperm.
    + (* x :: y :: (l1' ++ l2') = (x :: l1') ++ (y :: l2') *)
      simpl. rewrite <- app_comm_cons. apply Permutation_refl.
Qed.

(* å¼•ç†ï¼šmerge ä¿æŒæœ‰åºæ€§ *)
Lemma merge_sorted : forall l1 l2,
  sorted l1 -> sorted l2 -> sorted (merge l1 l2).
Proof.
  intros l1 l2. generalize dependent l2.
  induction l1 as [| h1 t1 IH1]; intros l2 Hs1 Hs2.
  - simpl. exact Hs2.
  - destruct l2 as [| h2 t2].
    + simpl. exact Hs1.
    + simpl. destruct (h1 <=? h2) eqn:E.
      * (* h1 <= h2 *)
        apply sorted_cons.
        -- apply Nat.leb_le in E. exact E.
        -- apply IH1.
           ++ inversion Hs1. { apply sorted_nil. } { exact H1. }
           ++ exact Hs2.
      * (* h2 < h1 *)
        apply sorted_cons.
        -- apply Nat.leb_nle in E. lia.
        -- apply IH1.
           ++ exact Hs1.
           ++ inversion Hs2. { apply sorted_nil. } { exact H1. }
Qed.

(* å¼•ç†ï¼šmerge ä¿æŒæ’åˆ— *)
Lemma merge_perm : forall l1 l2,
  Permutation (l1 ++ l2) (merge l1 l2).
Proof.
  intros l1. induction l1 as [| h1 t1 IH1]; intros l2.
  - simpl. reflexivity.
  - simpl. destruct l2 as [| h2 t2].
    + simpl. rewrite app_nil_r. reflexivity.
    + simpl. destruct (h1 <=? h2).
      * simpl. apply perm_skip. apply IH1.
      * transitivity (h2 :: h1 :: t1 ++ t2).
        -- simpl. apply perm_swap.
        -- apply perm_skip. apply IH1.
Qed.
```

### 7.3 ä¸»å®šç†

```coq
(* å®šç†ï¼šå½’å¹¶æ’åºæ­£ç¡®æ€§ *)
Theorem merge_sort_correct : forall l,
  sorted (merge_sort l) /\ Permutation l (merge_sort l).
Proof.
  intros l.
  (* éœ€è¦è‰¯åŸºå½’çº³ï¼ˆwell-founded inductionï¼‰å› ä¸ºé€’å½’ä¸æ˜¯ç»“æ„é€’å½’ *)
  remember (length l) as n.
  generalize dependent l.
  induction n as [n IH] using lt_wf_ind.
  intros l Hlen.
  destruct l as [| x [| y l']].
  - (* l = nil *)
    simpl. split.
    + apply sorted_nil.
    + reflexivity.
  - (* l = [x] *)
    simpl. split.
    + apply sorted_one.
    + reflexivity.
  - (* l = x :: y :: l' *)
    simpl.
    destruct (split (x :: y :: l')) as [l1 l2] eqn:E.
    assert (Hperm := split_perm _ _ _ _ E).
    assert (Hlen_sum := split_length _ _ _ _ E).
    simpl in Hlen_sum.
    (* å½’çº³å‡è®¾åº”ç”¨äº l1 å’Œ l2 *)
    assert (IH1 := IH (length l1)).
    assert (IH2 := IH (length l2)).
    (* è¯æ˜é•¿åº¦å‡å° *)
    assert (Hlen1 : length l1 < n).
    { rewrite Hlen. lia. }
    assert (Hlen2 : length l2 < n).
    { rewrite Hlen. lia. }
    destruct (IH1 Hlen1 l1 eq_refl) as [Hs1 Hp1].
    destruct (IH2 Hlen2 l2 eq_refl) as [Hs2 Hp2].
    split.
    + (* sorted *)
      apply merge_sorted; assumption.
    + (* Permutation *)
      transitivity (l1 ++ l2).
      * exact Hperm.
      * transitivity (merge_sort l1 ++ merge_sort l2).
        -- apply Permutation_app; assumption.
        -- apply merge_perm.
Qed.
```

---

## 8 ä¸å›½é™…è¯¾ç¨‹å¯¹æ ‡

### 8.1 å¤§å­¦è¯¾ç¨‹æ˜ å°„

| è¯¾ç¨‹ | ç›¸å…³ç« èŠ‚ |
|------|---------|
| **UPenn CIS500 Software Foundations** | Coq åŸºç¡€ï¼ˆæœ¬æ–‡å…¨éƒ¨å†…å®¹ï¼‰ |
| **MIT 6.826 Principles of Computer Systems** | ç¨‹åºéªŒè¯ï¼ˆÂ§5ï¼‰ |
| **Stanford CS250 é«˜çº§ç¼–è¯‘å™¨** | ç¨‹åºæå–ï¼ˆÂ§5.1ï¼‰ |
| **CMU 15-819 Foundations of Programming Languages** | ä¾èµ–ç±»å‹ï¼ˆÂ§6.1ï¼‰ |

### 8.2 æ•™æå¯¹åº”

| æ•™æ | ç›¸å…³ç« èŠ‚ |
|------|---------|
| **Software Foundations (Pierce et al.)** | æœ¬æ–‡å…¨éƒ¨å†…å®¹ |
| **Certified Programming with Dependent Types (Chlipala)** | ä¾èµ–ç±»å‹ï¼ˆÂ§6.1ï¼‰ï¼ŒLtacï¼ˆÂ§6.3ï¼‰ |
| **Programs and Proofs (Sergey)** | ç¨‹åºéªŒè¯ï¼ˆÂ§5ï¼‰ |

---

## 9 æ‰©å±•é˜…è¯»

### 9.1 å­¦æœ¯è®ºæ–‡

1. **Coq åŸºç¡€**ï¼šCoquand & Huet. "The Calculus of Constructions." 1988.
2. **CompCert**ï¼šLeroy, X. "Formal Verification of a Realistic Compiler." CACM 2009.
3. **å››è‰²å®šç†**ï¼šGonthier, G. "Formal Proofâ€”The Four Color Theorem." 2008.

### 9.2 åœ¨çº¿èµ„æº

- **Software Foundations**ï¼š<https://softwarefoundations.cis.upenn.edu/>
- **Coq å®˜æ–¹æ–‡æ¡£**ï¼š<https://coq.inria.fr/refman/>
- **Coq Reddit**ï¼š<https://www.reddit.com/r/Coq/>

### 9.3 æœ¬åœ°é¡¹ç›®å¼•ç”¨

- **å½¢å¼è¯­ä¹‰**ï¼š[../01_Formal_Semantics/01.1_Operational_Semantics.md](../01_Formal_Semantics/01.1_Operational_Semantics.md)
- **ç±»å‹ç³»ç»Ÿ**ï¼š[../01_Formal_Semantics/01.3_Type_Systems.md](../01_Formal_Semantics/01.3_Type_Systems.md)
- **ç®—æ³•å¤æ‚åº¦**ï¼š[../03_Algorithm_Complexity/03.3_Lower_Bound_Techniques.md](../03_Algorithm_Complexity/03.3_Lower_Bound_Techniques.md)

---

## 10 ç»ƒä¹ é¢˜

### 10.1 åŸºç¡€ç»ƒä¹ 

1. è¯æ˜ï¼š`forall P Q : Prop, (P -> Q) -> ~Q -> ~P`
2. å®šä¹‰é˜¶ä¹˜å‡½æ•°å¹¶è¯æ˜ `fact 0 = 1`
3. è¯æ˜åˆ—è¡¨åè½¬çš„æ€§è´¨ï¼š`rev (rev l) = l`

### 10.2 è¿›é˜¶ç»ƒä¹ 

1. å®ç°å¿«é€Ÿæ’åºå¹¶è¯æ˜å…¶æ­£ç¡®æ€§
2. å®šä¹‰äºŒå‰æœç´¢æ ‘å¹¶éªŒè¯æ’å…¥æ“ä½œä¿æŒæœç´¢æ ‘æ€§è´¨
3. ä½¿ç”¨ä¾èµ–ç±»å‹å®ç°å®‰å…¨çš„æ•°ç»„è®¿é—®

### 10.3 æŒ‘æˆ˜ç»ƒä¹ 

1. å½¢å¼åŒ– Î» æ¼”ç®—å¹¶è¯æ˜ Church-Rosser å®šç†
2. éªŒè¯ç®€å•çš„ç¼–è¯‘å™¨ï¼ˆä»è¡¨è¾¾å¼è¯­è¨€åˆ°æ ˆæœºå™¨ï¼‰
3. è¯æ˜ Curry-Howard åŒæ„ï¼ˆå‘½é¢˜å³ç±»å‹ï¼‰

---

## 11 é™„å½• Aï¼šå¸¸ç”¨ç­–ç•¥é€ŸæŸ¥

| ç­–ç•¥ | ç”¨é€” | ç¤ºä¾‹ |
|------|------|------|
| `intros` | å¼•å…¥å‡è®¾ | `intros n m H` |
| `apply` | åº”ç”¨å®šç† | `apply plus_comm` |
| `rewrite` | ç­‰å¼æ”¹å†™ | `rewrite H` |
| `reflexivity` | ç­‰å¼è‡ªåæ€§ | `reflexivity` |
| `simpl` | ç®€åŒ–è¡¨è¾¾å¼ | `simpl` |
| `destruct` | åˆ†æƒ…å†µ | `destruct n` |
| `induction` | å½’çº³æ³• | `induction n as [\|n' IH]` |
| `inversion` | åæ¼” | `inversion H` |
| `split` | åˆ†è§£åˆå– | `split` |
| `left / right` | é€‰æ‹©æå– | `left` |
| `exists` | æä¾›å­˜åœ¨è¯æ˜ | `exists 5` |
| `assert` | æ·»åŠ å¼•ç† | `assert (H: n < m)` |
| `auto` | è‡ªåŠ¨è¯æ˜ | `auto` |
| `lia` | çº¿æ€§ç®—æœ¯ | `lia` |
| `ring` | ç¯è®º | `ring` |

---

## 12 é™„å½• Bï¼šWikipedia æ¦‚å¿µå¯¹ç…§

| æ¦‚å¿µ | Wikipedia æ¡ç›® | æœ¬æ–‡ç« èŠ‚ |
|------|---------------|----------|
| Coq | <https://en.wikipedia.org/wiki/Coq> | Â§1 |
| Curry-Howard Correspondence | <https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence> | Â§2 |
| Dependent Type | <https://en.wikipedia.org/wiki/Dependent_type> | Â§6.1 |
| Inductive Type | <https://en.wikipedia.org/wiki/Inductive_type> | Â§3 |
| Formal Verification | <https://en.wikipedia.org/wiki/Formal_verification> | Â§5 |

---

**ç‰ˆæœ¬**ï¼šv1.0
**æœ€åæ›´æ–°**ï¼š2025-10-29
**ç»´æŠ¤è€…**ï¼šFormalScience Project
**è®¸å¯**ï¼šMIT

---

## è·¨è§†è§’é“¾æ¥

- [FormalLanguage_Perspective](../../FormalLanguage_Perspective/README.md)
- [Software_Perspective](../../Software_Perspective/README.md)
- [æ¦‚å¿µäº¤å‰ç´¢å¼•ï¼ˆä¸ƒè§†è§’ç‰ˆï¼‰](../../CONCEPT_CROSS_INDEX.md) - æŸ¥çœ‹ç›¸å…³æ¦‚å¿µçš„ä¸ƒè§†è§’åˆ†æï¼š
  - [GÃ¶delä¸å®Œå¤‡å®šç†](../../CONCEPT_CROSS_INDEX.md#101-gÃ¶delä¸å®Œå¤‡å®šç†-gÃ¶dels-incompleteness-theorems-ä¸ƒè§†è§’) - å½¢å¼åŒ–éªŒè¯çš„ç†è®ºé™åˆ¶
  - [åœæœºé—®é¢˜](../../CONCEPT_CROSS_INDEX.md#102-åœæœºé—®é¢˜-halting-problem-ä¸ƒè§†è§’) - ç¨‹åºéªŒè¯ä¸­çš„ç»ˆæ­¢æ€§åˆ¤å®š
  - [Riceå®šç†](../../CONCEPT_CROSS_INDEX.md#171-riceå®šç†-rices-theorem-ä¸ƒè§†è§’) - ç¨‹åºæ€§è´¨éªŒè¯çš„ä¸å¯åˆ¤å®šæ€§
