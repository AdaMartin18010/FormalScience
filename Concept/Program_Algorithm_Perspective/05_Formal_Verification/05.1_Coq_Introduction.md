# 05.1 Coq 交互式定理证明入门

## 📊 核心概念深度分析

<details>
<summary><b>🎓🔬 点击展开：Coq定理证明核心洞察</b></summary>

**终极洞察**: Coq=程序与证明的统一系统。理论基础：CIC（Calculus of Inductive Constructions），类型论+归纳类型+依赖类型的结合。Curry-Howard同构：类型=命题，程序=证明，类型检查=证明验证。核心能力：①定义归纳类型：如自然数、列表、树②陈述定理：用类型表达命题③构造证明：用策略（tactics）交互式证明④程序提取：从证明中提取可运行代码（OCaml/Haskell/Scheme）。证明策略：①intro/intros：引入假设②apply：应用定理③induction：归纳法证明④simpl/unfold：化简/展开定义⑤auto/omega：自动化策略。经典应用：①CompCert（验证的C编译器）：90K行Coq证明②四色定理：计算机辅助证明③Feit-Thompson定理：形式化数学证明④软件基础（Software Foundations）：PL教学。Coq vs其他证明器：Isabelle/HOL（更强自动化）、Lean（现代语法+数学库）、Agda（更纯粹的依赖类型）。学习曲线：陡峭但回报丰厚，掌握后可证明几乎任何数学/计算性质。关键：Coq将直觉证明变为机器可验证的形式证明，是高保障软件开发的终极武器。

</details>

---

## 📚 目录

- [概述](#概述)
- [1. Coq 基础](#1-coq-基础)
  - [1.1 安装与环境](#11-安装与环境)
  - [1.2 第一个 Coq 文件](#12-第一个-coq-文件)
  - [1.3 Coq 的类型系统](#13-coq-的类型系统)
- [2. 命题与证明](#2-命题与证明)
  - [2.1 命题逻辑](#21-命题逻辑)
  - [2.2 一阶逻辑](#22-一阶逻辑)
- [3. 归纳类型与递归](#3-归纳类型与递归)
  - [3.1 自然数定义](#31-自然数定义)
  - [3.2 归纳证明](#32-归纳证明)
  - [3.3 列表证明](#33-列表证明)
- [4. 策略（Tactics）详解](#4-策略tactics详解)
  - [4.1 基本策略](#41-基本策略)
  - [4.2 分解策略](#42-分解策略)
  - [4.3 自动化策略](#43-自动化策略)
- [5. 程序验证](#5-程序验证)
  - [5.1 程序提取（Extraction）](#51-程序提取extraction)
  - [5.2 定义与验证：排序算法](#52-定义与验证排序算法)
- [6. 高级主题](#6-高级主题)
  - [6.1 依赖类型](#61-依赖类型)
  - [6.2 类型类（Type Classes）](#62-类型类type-classes)
  - [6.3 Ltac（策略语言）](#63-ltac策略语言)
- [7. 实战案例：验证归并排序](#7-实战案例验证归并排序)
- [8. 与国际课程对标](#8-与国际课程对标)
- [9. 扩展阅读](#9-扩展阅读)
- [10. 练习题](#10-练习题)

---

## 概述

**Coq** 是一款基于**高阶构造演算**（Calculus of Inductive Constructions, CIC）的交互式定理证明器，广泛应用于：

- **程序验证**：CompCert（验证的 C 编译器）
- **数学形式化**：四色定理、奇偶定理
- **密码学**：安全协议验证

本文提供 **零基础到实战** 的完整教程，涵盖：

1. Coq 的基础语法和逻辑
2. 归纳类型与证明策略
3. 程序提取与验证
4. 实战案例：排序算法证明

---

## 1. Coq 基础

### 1.1 安装与环境

#### 安装 Coq

```bash
# macOS (Homebrew)
brew install coq

# Ubuntu/Debian
sudo apt install coq

# OPAM（推荐，支持多版本）
opam install coq

# 验证安装
coqc --version  # 输出：The Coq Proof Assistant, version 8.18.0
```

#### IDE 选择

```text
推荐 IDE：
1. CoqIDE（官方）：
   - 集成环境，适合初学者
   - 安装：brew install coqide

2. VS Code + VSCoq：
   - 现代化体验
   - 安装插件：VSCoq

3. Emacs + Proof General：
   - 经典选择，强大但学习曲线陡峭
```

### 1.2 第一个 Coq 文件

创建 `hello.v`：

```coq
(* 这是注释 *)

(* 定理：对于任何命题 P，如果 P 为真，则 P 为真 *)
Theorem identity : forall P : Prop, P -> P.
Proof.
  intros P HP.  (* 引入假设：P 是命题，HP 是 P 的证明 *)
  exact HP.     (* HP 就是我们要的证明 *)
Qed.

(* 检查定理类型 *)
Check identity.
(* 输出：identity : forall P : Prop, P -> P *)
```

**运行**：

```bash
coqc hello.v  # 编译
coqtop        # 进入交互式环境
> Load hello.
> Check identity.
```

### 1.3 Coq 的类型系统

#### 类型层级

```text
Coq 的类型宇宙（Type Hierarchy）：

Prop    : 命题宇宙（逻辑）
Set     : 小类型宇宙（数据结构）
Type(i) : 大类型宇宙（i 是宇宙层级）

层级关系：
  Prop : Type(0)
  Set  : Type(0)
  Type(i) : Type(i+1)
```

#### 基本类型

```coq
(* 布尔类型 *)
Inductive bool : Set :=
  | true : bool
  | false : bool.

(* 自然数 *)
Inductive nat : Set :=
  | O : nat          (* 零 *)
  | S : nat -> nat.  (* 后继 *)

(* 示例：3 的表示 *)
Check (S (S (S O))).  (* : nat *)

(* 列表 *)
Inductive list (A : Type) : Type :=
  | nil : list A
  | cons : A -> list A -> list A.

(* 使用语法糖 *)
Require Import List.
Import ListNotations.

Check [1; 2; 3].  (* : list nat *)
```

---

## 2. 命题与证明

### 2.1 命题逻辑

#### 合取（AND）

```coq
(* P ∧ Q 定义 *)
Print and.
(*
  Inductive and (A B : Prop) : Prop :=
    conj : A -> B -> A /\ B
*)

(* 证明：P ∧ Q → P *)
Theorem and_proj1 : forall P Q : Prop, P /\ Q -> P.
Proof.
  intros P Q H.
  (* H : P /\ Q *)
  destruct H as [HP HQ].
  (* HP : P, HQ : Q *)
  exact HP.
Qed.

(* 证明：P → Q → P ∧ Q *)
Theorem and_intro : forall P Q : Prop, P -> Q -> P /\ Q.
Proof.
  intros P Q HP HQ.
  split.
  - exact HP.
  - exact HQ.
Qed.
```

#### 析取（OR）

```coq
(* P ∨ Q 定义 *)
Print or.
(*
  Inductive or (A B : Prop) : Prop :=
    | or_introl : A -> A \/ B
    | or_intror : B -> A \/ B
*)

(* 证明：P → P ∨ Q *)
Theorem or_intro_l : forall P Q : Prop, P -> P \/ Q.
Proof.
  intros P Q HP.
  left.  (* 选择左边 *)
  exact HP.
Qed.

(* 证明：P ∨ Q → Q ∨ P *)
Theorem or_comm : forall P Q : Prop, P \/ Q -> Q \/ P.
Proof.
  intros P Q H.
  destruct H as [HP | HQ].
  - (* 情况 1: P *)
    right. exact HP.
  - (* 情况 2: Q *)
    left. exact HQ.
Qed.
```

#### 蕴含（IMPLY）

```coq
(* P → Q 是函数类型 *)
Check forall P Q : Prop, P -> Q.

(* 证明：(P → Q) → (Q → R) → (P → R) *)
Theorem impl_trans : forall P Q R : Prop,
  (P -> Q) -> (Q -> R) -> (P -> R).
Proof.
  intros P Q R HPQ HQR HP.
  apply HQR.
  apply HPQ.
  exact HP.
Qed.
```

### 2.2 一阶逻辑

#### 全称量词（∀）

```coq
(* 证明：∀x, P(x) → ∃x, P(x) *)
Theorem forall_to_exists : forall (A : Type) (P : A -> Prop),
  (forall x : A, P x) -> exists x : A, P x.
Proof.
  intros A P H.
  (* 需要一个具体的 x *)
  (* 但我们没有假设 A 非空！这个定理在 Coq 中不可证 *)
Abort.

(* 修正：添加 A 非空假设 *)
Theorem forall_to_exists_correct : forall (A : Type) (P : A -> Prop),
  (exists x : A, True) ->  (* A 非空 *)
  (forall x : A, P x) ->
  exists x : A, P x.
Proof.
  intros A P [x0 _] Hall.
  exists x0.
  apply Hall.
Qed.
```

#### 存在量词（∃）

```coq
(* 证明：存在偶数 *)
Definition even (n : nat) : Prop :=
  exists k : nat, n = 2 * k.

Theorem two_is_even : even 2.
Proof.
  unfold even.
  exists 1.
  reflexivity.  (* 2 = 2 * 1 *)
Qed.

(* 证明：∃x, P(x) ∧ Q(x) → (∃x, P(x)) ∧ (∃x, Q(x)) *)
Theorem exists_and : forall (A : Type) (P Q : A -> Prop),
  (exists x : A, P x /\ Q x) ->
  (exists x : A, P x) /\ (exists x : A, Q x).
Proof.
  intros A P Q [x [HP HQ]].
  split.
  - exists x. exact HP.
  - exists x. exact HQ.
Qed.
```

---

## 3. 归纳类型与递归

### 3.1 自然数定义

```coq
Inductive nat : Set :=
  | O : nat
  | S : nat -> nat.

(* 加法定义（递归） *)
Fixpoint plus (n m : nat) : nat :=
  match n with
  | O => m
  | S n' => S (plus n' m)
  end.

(* 语法糖 *)
Notation "n + m" := (plus n m).

(* 乘法 *)
Fixpoint mult (n m : nat) : nat :=
  match n with
  | O => O
  | S n' => m + (mult n' m)
  end.

Notation "n * m" := (mult n m).
```

### 3.2 归纳证明

#### 定理：加法交换律

```coq
(* 引理：n + 0 = n *)
Lemma plus_O_r : forall n : nat, n + O = n.
Proof.
  induction n as [| n' IH].
  - (* n = O *)
    simpl. reflexivity.
  - (* n = S n' *)
    simpl.  (* S n' + O = S (n' + O) *)
    rewrite IH.  (* 应用归纳假设：n' + O = n' *)
    reflexivity.
Qed.

(* 引理：S n + m = n + S m *)
Lemma plus_S : forall n m : nat, S (n + m) = n + S m.
Proof.
  induction n as [| n' IH].
  - (* n = O *)
    intros m. simpl. reflexivity.
  - (* n = S n' *)
    intros m. simpl.
    rewrite IH.
    reflexivity.
Qed.

(* 定理：加法交换律 *)
Theorem plus_comm : forall n m : nat, n + m = m + n.
Proof.
  induction n as [| n' IH].
  - (* n = O *)
    intros m.
    simpl.  (* O + m = m *)
    rewrite plus_O_r.  (* m + O = m *)
    reflexivity.
  - (* n = S n' *)
    intros m.
    simpl.  (* S n' + m = S (n' + m) *)
    rewrite IH.  (* n' + m = m + n' *)
    rewrite plus_S.  (* S (m + n') = m + S n' *)
    reflexivity.
Qed.
```

### 3.3 列表证明

```coq
Require Import List.
Import ListNotations.

(* 列表连接 *)
Fixpoint app {A : Type} (l1 l2 : list A) : list A :=
  match l1 with
  | nil => l2
  | h :: t => h :: (app t l2)
  end.

Notation "l1 ++ l2" := (app l1 l2).

(* 定理：列表连接结合律 *)
Theorem app_assoc : forall (A : Type) (l1 l2 l3 : list A),
  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).
Proof.
  intros A l1 l2 l3.
  induction l1 as [| h t IH].
  - (* l1 = nil *)
    simpl. reflexivity.
  - (* l1 = h :: t *)
    simpl.
    rewrite IH.
    reflexivity.
Qed.

(* 列表长度 *)
Fixpoint length {A : Type} (l : list A) : nat :=
  match l with
  | nil => O
  | _ :: t => S (length t)
  end.

(* 定理：连接后的长度 *)
Theorem app_length : forall (A : Type) (l1 l2 : list A),
  length (l1 ++ l2) = length l1 + length l2.
Proof.
  intros A l1 l2.
  induction l1 as [| h t IH].
  - (* l1 = nil *)
    simpl. reflexivity.
  - (* l1 = h :: t *)
    simpl.
    rewrite IH.
    reflexivity.
Qed.
```

---

## 4. 策略（Tactics）详解

### 4.1 基本策略

```coq
(* intros: 引入假设 *)
Theorem example_intros : forall n m : nat, n = m -> m = n.
Proof.
  intros n m H.
  (* Goal: m = n *)
  (* Context: n, m : nat, H : n = m *)
Abort.

(* exact: 提供精确证明项 *)
Theorem example_exact : forall P : Prop, P -> P.
Proof.
  intros P HP.
  exact HP.
Qed.

(* apply: 应用定理/假设 *)
Theorem example_apply : forall P Q R : Prop,
  (P -> Q) -> (Q -> R) -> P -> R.
Proof.
  intros P Q R HPQ HQR HP.
  apply HQR.
  apply HPQ.
  exact HP.
Qed.

(* reflexivity: 等式自反性 *)
Theorem example_refl : 2 + 2 = 4.
Proof.
  reflexivity.  (* Coq 自动计算 2 + 2 *)
Qed.

(* rewrite: 等式改写 *)
Theorem example_rewrite : forall n m : nat,
  n = m -> n + n = m + m.
Proof.
  intros n m H.
  rewrite H.
  reflexivity.
Qed.
```

### 4.2 分解策略

```coq
(* destruct: 分情况讨论 *)
Theorem example_destruct : forall b : bool,
  b = true \/ b = false.
Proof.
  intros b.
  destruct b.
  - (* b = true *)
    left. reflexivity.
  - (* b = false *)
    right. reflexivity.
Qed.

(* induction: 归纳法 *)
Theorem example_induction : forall n : nat,
  n + O = n.
Proof.
  intros n.
  induction n as [| n' IH].
  - (* n = O *)
    simpl. reflexivity.
  - (* n = S n' *)
    simpl.
    rewrite IH.
    reflexivity.
Qed.

(* inversion: 反演归纳类型 *)
Inductive even : nat -> Prop :=
  | even_O : even O
  | even_SS : forall n, even n -> even (S (S n)).

Theorem example_inversion : forall n : nat,
  even (S n) -> even (S (S (S n))).
Proof.
  intros n H.
  inversion H.  (* S n 不可能由 even_O 构造 *)
  (* H 必定来自 even_SS，得到 n = S n0 *)
  apply even_SS.
  exact H.
Qed.
```

### 4.3 自动化策略

```coq
(* auto: 自动证明（浅层） *)
Theorem example_auto : forall P Q : Prop,
  P -> (P -> Q) -> Q.
Proof.
  auto.  (* 自动完成 *)
Qed.

(* omega: 线性算术 *)
Require Import Omega.

Theorem example_omega : forall n m : nat,
  n < m -> n + 1 <= m.
Proof.
  intros n m H.
  omega.  (* 自动解决线性不等式 *)
Qed.

(* lia: 线性整数算术（替代 omega） *)
Require Import Lia.

Theorem example_lia : forall a b c : nat,
  a + b = c -> b + a = c.
Proof.
  intros a b c H.
  lia.
Qed.

(* ring: 环论自动化 *)
Require Import Ring.

Theorem example_ring : forall a b c : nat,
  (a + b) * c = a * c + b * c.
Proof.
  intros.
  ring.
Qed.
```

---

## 5. 程序验证

### 5.1 程序提取（Extraction）

```coq
(* 定义：列表反转 *)
Fixpoint rev {A : Type} (l : list A) : list A :=
  match l with
  | nil => nil
  | h :: t => rev t ++ [h]
  end.

(* 定理：反转两次得到原列表 *)
Theorem rev_involutive : forall (A : Type) (l : list A),
  rev (rev l) = l.
Proof.
  intros A l.
  induction l as [| h t IH].
  - (* l = nil *)
    simpl. reflexivity.
  - (* l = h :: t *)
    simpl.
    (* rev (rev t ++ [h]) = h :: t *)
    (* 需要引理：rev (l1 ++ l2) = rev l2 ++ rev l1 *)
    Admitted.  (* 留作练习 *)

(* 提取为 OCaml 代码 *)
Require Extraction.
Extraction Language OCaml.
Extraction "rev.ml" rev.
```

**生成的 OCaml 代码**（`rev.ml`）：

```ocaml
type 'a list =
| Nil
| Cons of 'a * 'a list

let rec app l1 l2 =
  match l1 with
  | Nil -> l2
  | Cons (h, t) -> Cons (h, (app t l2))

let rec rev l =
  match l with
  | Nil -> Nil
  | Cons (h, t) -> app (rev t) (Cons (h, Nil))
```

### 5.2 定义与验证：排序算法

#### 插入排序

```coq
Require Import List Sorting.Sorted.
Import ListNotations.

(* 辅助函数：插入元素到有序列表 *)
Fixpoint insert (x : nat) (l : list nat) : list nat :=
  match l with
  | nil => [x]
  | h :: t => if x <=? h then x :: h :: t else h :: insert x t
  end.

(* 插入排序 *)
Fixpoint insertion_sort (l : list nat) : list nat :=
  match l with
  | nil => nil
  | h :: t => insert h (insertion_sort t)
  end.

(* 定义：有序性 *)
Inductive sorted : list nat -> Prop :=
  | sorted_nil : sorted nil
  | sorted_one : forall x, sorted [x]
  | sorted_cons : forall x y l,
      x <= y -> sorted (y :: l) -> sorted (x :: y :: l).

(* 引理：插入保持有序性 *)
Lemma insert_sorted : forall x l,
  sorted l -> sorted (insert x l).
Proof.
  intros x l H.
  induction H as [| y | y z l' Hyz Hsorted IH].
  - (* l = nil *)
    simpl. apply sorted_one.
  - (* l = [y] *)
    simpl. destruct (x <=? y) eqn:E.
    + apply sorted_cons. apply Nat.leb_le. exact E. apply sorted_one.
    + apply sorted_cons. apply Nat.leb_nle in E. lia. apply sorted_one.
  - (* l = y :: z :: l' *)
    simpl. destruct (x <=? y) eqn:E.
    + apply sorted_cons. apply Nat.leb_le. exact E. exact (sorted_cons y z l' Hyz Hsorted).
    + simpl in IH. destruct (x <=? z) eqn:E2.
      * apply sorted_cons. apply Nat.leb_nle in E. lia. apply sorted_cons.
        apply Nat.leb_le. exact E2. exact Hsorted.
      * apply sorted_cons. exact Hyz. exact IH.
Qed.

(* 定理：插入排序正确性（有序性） *)
Theorem insertion_sort_sorted : forall l,
  sorted (insertion_sort l).
Proof.
  intros l.
  induction l as [| h t IH].
  - (* l = nil *)
    simpl. apply sorted_nil.
  - (* l = h :: t *)
    simpl. apply insert_sorted. exact IH.
Qed.

(* 定义：排列 *)
(* 使用 Coq 标准库的 Permutation *)
Require Import Permutation.

(* 引理：插入保持排列 *)
Lemma insert_perm : forall x l,
  Permutation (x :: l) (insert x l).
Proof.
  intros x l.
  induction l as [| h t IH].
  - simpl. reflexivity.
  - simpl. destruct (x <=? h).
    + reflexivity.
    + transitivity (h :: x :: t).
      * apply perm_swap.
      * apply perm_skip. exact IH.
Qed.

(* 定理：插入排序正确性（排列） *)
Theorem insertion_sort_perm : forall l,
  Permutation l (insertion_sort l).
Proof.
  intros l.
  induction l as [| h t IH].
  - simpl. reflexivity.
  - simpl. transitivity (h :: insertion_sort t).
    + apply perm_skip. exact IH.
    + apply insert_perm.
Qed.

(* 完整正确性：排序既保持有序又保持排列 *)
Theorem insertion_sort_correct : forall l,
  sorted (insertion_sort l) /\ Permutation l (insertion_sort l).
Proof.
  intros l.
  split.
  - apply insertion_sort_sorted.
  - apply insertion_sort_perm.
Qed.
```

---

## 6. 高级主题

### 6.1 依赖类型

```coq
(* 向量：长度索引的列表 *)
Inductive vec (A : Type) : nat -> Type :=
  | vnil : vec A 0
  | vcons : forall n : nat, A -> vec A n -> vec A (S n).

Arguments vnil {A}.
Arguments vcons {A} {n}.

(* 安全的取头 *)
Definition vhead {A : Type} {n : nat} (v : vec A (S n)) : A :=
  match v with
  | vcons h _ => h
  end.

(* 编译期保证：vhead 不能应用于空向量 *)
(* Fail Compute (vhead vnil). *)  (* 类型错误！ *)

(* 向量连接 *)
Fixpoint vapp {A : Type} {n m : nat} (v1 : vec A n) (v2 : vec A m) : vec A (n + m) :=
  match v1 with
  | vnil => v2
  | vcons h t => vcons h (vapp t v2)
  end.

(* 定理：连接后的长度 *)
Theorem vapp_length : forall (A : Type) (n m : nat) (v1 : vec A n) (v2 : vec A m),
  length (vapp v1 v2) = n + m.
Proof.
  (* 长度已经编码在类型中！ *)
  intros. reflexivity.
Qed.
```

### 6.2 类型类（Type Classes）

```coq
(* 定义可比较类型类 *)
Class Comparable (A : Type) := {
  eqb : A -> A -> bool;
  eqb_eq : forall x y, eqb x y = true <-> x = y
}.

(* 实例：nat 的可比较性 *)
Instance nat_comparable : Comparable nat := {
  eqb := Nat.eqb;
  eqb_eq := Nat.eqb_eq
}.

(* 泛型函数：列表中是否包含元素 *)
Definition mem {A : Type} `{Comparable A} (x : A) (l : list A) : bool :=
  existsb (eqb x) l.

(* 使用 *)
Compute mem 3 [1; 2; 3; 4].  (* true *)
```

### 6.3 Ltac（策略语言）

```coq
(* 自定义策略：自动处理简单合取 *)
Ltac split_and :=
  match goal with
  | |- _ /\ _ => split; split_and
  | _ => idtac
  end.

(* 使用示例 *)
Theorem example_ltac : forall P Q R : Prop,
  P -> Q -> R -> P /\ Q /\ R.
Proof.
  intros P Q R HP HQ HR.
  split_and.
  - exact HP.
  - exact HQ.
  - exact HR.
Qed.

(* 更复杂的策略：自动解构所有合取 *)
Ltac destruct_all_and :=
  repeat match goal with
  | H : _ /\ _ |- _ => destruct H
  end.

Theorem example_destruct_all : forall P Q R : Prop,
  (P /\ Q) /\ R -> P.
Proof.
  intros P Q R H.
  destruct_all_and.
  exact H.
Qed.
```

---

## 7. 实战案例：验证归并排序

### 7.1 实现

```coq
Require Import List Arith Permutation.
Import ListNotations.

(* 分割列表 *)
Fixpoint split {A : Type} (l : list A) : list A * list A :=
  match l with
  | nil => (nil, nil)
  | [x] => ([x], nil)
  | x :: y :: l' => let (l1, l2) := split l' in (x :: l1, y :: l2)
  end.

(* 合并两个有序列表 *)
Fixpoint merge (l1 l2 : list nat) : list nat :=
  match l1, l2 with
  | nil, _ => l2
  | _, nil => l1
  | h1 :: t1, h2 :: t2 =>
      if h1 <=? h2 then h1 :: merge t1 l2 else h2 :: merge l1 t2
  end.

(* 归并排序 *)
Fixpoint merge_sort (l : list nat) : list nat :=
  match l with
  | nil | [_] => l
  | _ => let (l1, l2) := split l in merge (merge_sort l1) (merge_sort l2)
  end.
```

### 7.2 辅助引理

```coq
(* 引理：split 不增加长度 *)
Lemma split_length : forall (A : Type) (l : list A) l1 l2,
  split l = (l1, l2) ->
  length l1 + length l2 = length l.
Proof.
  intros A l. induction l as [| x [| y l'] IH]; intros l1 l2 Hsplit.
  - (* l = nil *)
    simpl in Hsplit. inversion Hsplit. reflexivity.
  - (* l = [x] *)
    simpl in Hsplit. inversion Hsplit. reflexivity.
  - (* l = x :: y :: l' *)
    simpl in Hsplit.
    destruct (split l') as [l1' l2'] eqn:E.
    inversion Hsplit; subst.
    simpl. assert (H := IH l1' l2' E). lia.
Qed.

(* 引理：split 保持排列 *)
Lemma split_perm : forall (A : Type) (l : list A) l1 l2,
  split l = (l1, l2) ->
  Permutation l (l1 ++ l2).
Proof.
  intros A l. induction l as [| x [| y l'] IH]; intros l1 l2 Hsplit.
  - simpl in Hsplit. inversion Hsplit. reflexivity.
  - simpl in Hsplit. inversion Hsplit. simpl. reflexivity.
  - simpl in Hsplit.
    destruct (split l') as [l1' l2'] eqn:E.
    inversion Hsplit; subst.
    assert (Hperm := IH l1' l2' E).
    simpl. transitivity (x :: y :: (l1' ++ l2')).
    + apply perm_skip. apply perm_skip. exact Hperm.
    + (* x :: y :: (l1' ++ l2') = (x :: l1') ++ (y :: l2') *)
      simpl. rewrite <- app_comm_cons. apply Permutation_refl.
Qed.

(* 引理：merge 保持有序性 *)
Lemma merge_sorted : forall l1 l2,
  sorted l1 -> sorted l2 -> sorted (merge l1 l2).
Proof.
  intros l1 l2. generalize dependent l2.
  induction l1 as [| h1 t1 IH1]; intros l2 Hs1 Hs2.
  - simpl. exact Hs2.
  - destruct l2 as [| h2 t2].
    + simpl. exact Hs1.
    + simpl. destruct (h1 <=? h2) eqn:E.
      * (* h1 <= h2 *)
        apply sorted_cons.
        -- apply Nat.leb_le in E. exact E.
        -- apply IH1.
           ++ inversion Hs1. { apply sorted_nil. } { exact H1. }
           ++ exact Hs2.
      * (* h2 < h1 *)
        apply sorted_cons.
        -- apply Nat.leb_nle in E. lia.
        -- apply IH1.
           ++ exact Hs1.
           ++ inversion Hs2. { apply sorted_nil. } { exact H1. }
Qed.

(* 引理：merge 保持排列 *)
Lemma merge_perm : forall l1 l2,
  Permutation (l1 ++ l2) (merge l1 l2).
Proof.
  intros l1. induction l1 as [| h1 t1 IH1]; intros l2.
  - simpl. reflexivity.
  - simpl. destruct l2 as [| h2 t2].
    + simpl. rewrite app_nil_r. reflexivity.
    + simpl. destruct (h1 <=? h2).
      * simpl. apply perm_skip. apply IH1.
      * transitivity (h2 :: h1 :: t1 ++ t2).
        -- simpl. apply perm_swap.
        -- apply perm_skip. apply IH1.
Qed.
```

### 7.3 主定理

```coq
(* 定理：归并排序正确性 *)
Theorem merge_sort_correct : forall l,
  sorted (merge_sort l) /\ Permutation l (merge_sort l).
Proof.
  intros l.
  (* 需要良基归纳（well-founded induction）因为递归不是结构递归 *)
  remember (length l) as n.
  generalize dependent l.
  induction n as [n IH] using lt_wf_ind.
  intros l Hlen.
  destruct l as [| x [| y l']].
  - (* l = nil *)
    simpl. split.
    + apply sorted_nil.
    + reflexivity.
  - (* l = [x] *)
    simpl. split.
    + apply sorted_one.
    + reflexivity.
  - (* l = x :: y :: l' *)
    simpl.
    destruct (split (x :: y :: l')) as [l1 l2] eqn:E.
    assert (Hperm := split_perm _ _ _ _ E).
    assert (Hlen_sum := split_length _ _ _ _ E).
    simpl in Hlen_sum.
    (* 归纳假设应用于 l1 和 l2 *)
    assert (IH1 := IH (length l1)).
    assert (IH2 := IH (length l2)).
    (* 证明长度减小 *)
    assert (Hlen1 : length l1 < n).
    { rewrite Hlen. lia. }
    assert (Hlen2 : length l2 < n).
    { rewrite Hlen. lia. }
    destruct (IH1 Hlen1 l1 eq_refl) as [Hs1 Hp1].
    destruct (IH2 Hlen2 l2 eq_refl) as [Hs2 Hp2].
    split.
    + (* sorted *)
      apply merge_sorted; assumption.
    + (* Permutation *)
      transitivity (l1 ++ l2).
      * exact Hperm.
      * transitivity (merge_sort l1 ++ merge_sort l2).
        -- apply Permutation_app; assumption.
        -- apply merge_perm.
Qed.
```

---

## 8. 与国际课程对标

### 8.1 大学课程映射

| 课程 | 相关章节 |
|------|---------|
| **UPenn CIS500 Software Foundations** | Coq 基础（本文全部内容） |
| **MIT 6.826 Principles of Computer Systems** | 程序验证（§5） |
| **Stanford CS250 高级编译器** | 程序提取（§5.1） |
| **CMU 15-819 Foundations of Programming Languages** | 依赖类型（§6.1） |

### 8.2 教材对应

| 教材 | 相关章节 |
|------|---------|
| **Software Foundations (Pierce et al.)** | 本文全部内容 |
| **Certified Programming with Dependent Types (Chlipala)** | 依赖类型（§6.1），Ltac（§6.3） |
| **Programs and Proofs (Sergey)** | 程序验证（§5） |

---

## 9. 扩展阅读

### 9.1 学术论文

1. **Coq 基础**：Coquand & Huet. "The Calculus of Constructions." 1988.
2. **CompCert**：Leroy, X. "Formal Verification of a Realistic Compiler." CACM 2009.
3. **四色定理**：Gonthier, G. "Formal Proof—The Four Color Theorem." 2008.

### 9.2 在线资源

- **Software Foundations**：<https://softwarefoundations.cis.upenn.edu/>
- **Coq 官方文档**：<https://coq.inria.fr/refman/>
- **Coq Reddit**：<https://www.reddit.com/r/Coq/>

### 9.3 本地项目引用

- **形式语义**：[../01_Formal_Semantics/01.1_Operational_Semantics.md](../01_Formal_Semantics/01.1_Operational_Semantics.md)
- **类型系统**：[../01_Formal_Semantics/01.3_Type_Systems.md](../01_Formal_Semantics/01.3_Type_Systems.md)
- **算法复杂度**：[../03_Algorithm_Complexity/03.3_Lower_Bound_Techniques.md](../03_Algorithm_Complexity/03.3_Lower_Bound_Techniques.md)

---

## 10. 练习题

### 10.1 基础练习

1. 证明：`forall P Q : Prop, (P -> Q) -> ~Q -> ~P`
2. 定义阶乘函数并证明 `fact 0 = 1`
3. 证明列表反转的性质：`rev (rev l) = l`

### 10.2 进阶练习

1. 实现快速排序并证明其正确性
2. 定义二叉搜索树并验证插入操作保持搜索树性质
3. 使用依赖类型实现安全的数组访问

### 10.3 挑战练习

1. 形式化 λ 演算并证明 Church-Rosser 定理
2. 验证简单的编译器（从表达式语言到栈机器）
3. 证明 Curry-Howard 同构（命题即类型）

---

## 附录 A：常用策略速查

| 策略 | 用途 | 示例 |
|------|------|------|
| `intros` | 引入假设 | `intros n m H` |
| `apply` | 应用定理 | `apply plus_comm` |
| `rewrite` | 等式改写 | `rewrite H` |
| `reflexivity` | 等式自反性 | `reflexivity` |
| `simpl` | 简化表达式 | `simpl` |
| `destruct` | 分情况 | `destruct n` |
| `induction` | 归纳法 | `induction n as [\|n' IH]` |
| `inversion` | 反演 | `inversion H` |
| `split` | 分解合取 | `split` |
| `left / right` | 选择析取 | `left` |
| `exists` | 提供存在证明 | `exists 5` |
| `assert` | 添加引理 | `assert (H: n < m)` |
| `auto` | 自动证明 | `auto` |
| `lia` | 线性算术 | `lia` |
| `ring` | 环论 | `ring` |

---

## 附录 B：Wikipedia 概念对照

| 概念 | Wikipedia 条目 | 本文章节 |
|------|---------------|----------|
| Coq | <https://en.wikipedia.org/wiki/Coq> | §1 |
| Curry-Howard Correspondence | <https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence> | §2 |
| Dependent Type | <https://en.wikipedia.org/wiki/Dependent_type> | §6.1 |
| Inductive Type | <https://en.wikipedia.org/wiki/Inductive_type> | §3 |
| Formal Verification | <https://en.wikipedia.org/wiki/Formal_verification> | §5 |

---

**版本**：v1.0  
**最后更新**：2025-10-29  
**维护者**：FormalScience Project  
**许可**：MIT
