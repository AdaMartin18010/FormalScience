# K-Frameworkï¼šå¯æ‰§è¡Œè¯­ä¹‰æ¡†æ¶

## ğŸ“š ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [1. K-Framework åŸºç¡€](#1-k-framework-åŸºç¡€)
  - [1.1 é…ç½®ï¼ˆConfigurationï¼‰](#11-é…ç½®configuration)
  - [1.2 é‡å†™è§„åˆ™ï¼ˆRewriting Rulesï¼‰](#12-é‡å†™è§„åˆ™rewriting-rules)
  - [1.3 K å•å…ƒï¼ˆK Cellï¼‰](#13-k-å•å…ƒk-cell)
- [2. å®šä¹‰ä¸€ä¸ªç®€å•è¯­è¨€ï¼šIMP](#2-å®šä¹‰ä¸€ä¸ªç®€å•è¯­è¨€imp)
  - [2.1 IMP è¯­æ³•](#21-imp-è¯­æ³•)
  - [2.2 IMP é…ç½®](#22-imp-é…ç½®)
  - [2.3 ç®—æœ¯è¡¨è¾¾å¼è¯­ä¹‰](#23-ç®—æœ¯è¡¨è¾¾å¼è¯­ä¹‰)
  - [2.4 å¸ƒå°”è¡¨è¾¾å¼è¯­ä¹‰](#24-å¸ƒå°”è¡¨è¾¾å¼è¯­ä¹‰)
  - [2.5 è¯­å¥è¯­ä¹‰](#25-è¯­å¥è¯­ä¹‰)
  - [2.6 å®Œæ•´ç¤ºä¾‹](#26-å®Œæ•´ç¤ºä¾‹)
- [3. K-Framework é«˜çº§ç‰¹æ€§](#3-k-framework-é«˜çº§ç‰¹æ€§)
  - [3.1 Heating/Cooling è§„åˆ™](#31-heatingcooling-è§„åˆ™)
  - [3.2 Semantic Lists å’Œ Maps](#32-semantic-lists-å’Œ-maps)
  - [3.3 Symbolic Execution](#33-symbolic-execution)
- [4. K-Framework åœ¨å·¥ä¸šä¸­çš„åº”ç”¨](#4-k-framework-åœ¨å·¥ä¸šä¸­çš„åº”ç”¨)
  - [4.1 ä»¥å¤ªåŠè™šæ‹Ÿæœºï¼ˆKEVMï¼‰](#41-ä»¥å¤ªåŠè™šæ‹Ÿæœºkevm)
  - [4.2 WebAssemblyï¼ˆKWasmï¼‰](#42-webassemblykwasm)
  - [4.3 C è¯­è¨€ï¼ˆRV-Matchï¼‰](#43-c-è¯­è¨€rv-match)
- [5. å½¢å¼åŒ–éªŒè¯ç¤ºä¾‹](#5-å½¢å¼åŒ–éªŒè¯ç¤ºä¾‹)
  - [5.1 å®šä¹‰è§„èŒƒ](#51-å®šä¹‰è§„èŒƒ)
  - [5.2 å¯è¾¾æ€§è¯æ˜](#52-å¯è¾¾æ€§è¯æ˜)
- [6. å·¥å…·é“¾ä¸ç”Ÿæ€](#6-å·¥å…·é“¾ä¸ç”Ÿæ€)
- [7. ä¸å…¶ä»–å·¥å…·å¯¹æ¯”](#7-ä¸å…¶ä»–å·¥å…·å¯¹æ¯”)
- [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
- [9. å®æˆ˜æ¡ˆä¾‹ï¼šéªŒè¯æ’åºç®—æ³•](#9-å®æˆ˜æ¡ˆä¾‹éªŒè¯æ’åºç®—æ³•)
- [10. å¤§å­¦è¯¾ç¨‹å¯¹åº”](#10-å¤§å­¦è¯¾ç¨‹å¯¹åº”)
- [11. æ•™æä¸è®ºæ–‡](#11-æ•™æä¸è®ºæ–‡)

---

## æ¦‚è¿°

**K-Framework** æ˜¯ä¸€ä¸ªç”¨äºå®šä¹‰ç¼–ç¨‹è¯­è¨€**å¯æ‰§è¡Œè¯­ä¹‰**çš„æ¡†æ¶ï¼Œæ ¸å¿ƒæ€æƒ³ï¼š

```text
è¯­è¨€å®šä¹‰ = é…ç½® + é‡å†™è§„åˆ™

é…ç½®ï¼ˆConfigurationï¼‰ï¼šç¨‹åºçŠ¶æ€çš„ç»“æ„
é‡å†™è§„åˆ™ï¼ˆRewriting Rulesï¼‰ï¼šçŠ¶æ€è½¬æ¢è§„åˆ™

éªŒè¯ = å¯è¾¾æ€§åˆ†æ + ä¸å˜å¼æ£€æŸ¥
```

**æ ¸å¿ƒä¼˜åŠ¿**ï¼š

- **è¯­è¨€æ— å…³**ï¼šç»Ÿä¸€æ¡†æ¶å®šä¹‰ä»»ä½•è¯­è¨€
- **å¯æ‰§è¡Œæ€§**ï¼šè¯­ä¹‰å®šä¹‰å¯ç›´æ¥æ‰§è¡Œ
- **è‡ªåŠ¨éªŒè¯**ï¼šä»è¯­ä¹‰è‡ªåŠ¨ç”ŸæˆéªŒè¯å·¥å…·
- **å·¥ä¸šåº”ç”¨**ï¼šå·²ç”¨äº EVMã€WASMã€LLVM ç­‰

**å®˜ç½‘**ï¼š<https://kframework.org/>

---

## 1. K-Framework åŸºç¡€

### 1.1 é…ç½®ï¼ˆConfigurationï¼‰

**å®šä¹‰**ï¼šç¨‹åºæ‰§è¡ŒçŠ¶æ€çš„æ ‘å½¢ç»“æ„

```k
configuration
  <k> $PGM:Stmt </k>          // å¾…æ‰§è¡Œçš„ç¨‹åº
  <env> .Map </env>           // ç¯å¢ƒï¼ˆå˜é‡ç»‘å®šï¼‰
  <store> .Map </store>       // å­˜å‚¨ï¼ˆå†…å­˜ï¼‰
  <output> .List </output>    // è¾“å‡ºæµ
```

**è¯­ä¹‰**ï¼š

- `<k>` å•å…ƒï¼šè®¡ç®—ä»»åŠ¡ï¼ˆComputation Cellï¼‰
- `<env>` å•å…ƒï¼šå˜é‡ â†’ åœ°å€æ˜ å°„
- `<store>` å•å…ƒï¼šåœ°å€ â†’ å€¼æ˜ å°„
- `<output>` å•å…ƒï¼šè¾“å‡ºç¼“å†²åŒº

### 1.2 é‡å†™è§„åˆ™ï¼ˆRewriting Rulesï¼‰

**è¯­æ³•**ï¼š

```k
rule <k> Pattern => Replacement ... </k>
     <state> Constraints </state>
```

**ç¤ºä¾‹**ï¼ˆèµ‹å€¼è¯­å¥ï¼‰ï¼š

```k
rule <k> X = E ; => . ... </k>
     <env> ... X |-> L ... </env>
     <store> ... L |-> (_ => V) ... </store>
  requires E ==K V
```

**è§£é‡Š**ï¼š

1. æ¨¡å¼åŒ¹é… `X = E ;` åœ¨ `<k>` å•å…ƒ
2. æŸ¥æ‰¾ `X` åœ¨ `<env>` ä¸­çš„åœ°å€ `L`
3. æ›´æ–° `<store>` ä¸­åœ°å€ `L` çš„å€¼ä¸º `V`
4. èµ‹å€¼è¯­å¥æ‰§è¡Œå®Œæ¯•ï¼ˆ`=> .`ï¼‰

### 1.3 K å•å…ƒï¼ˆK Cellï¼‰

**K åºåˆ—**ï¼š

```k
$PGM:Stmt ~> K:K
```

è¡¨ç¤º"å…ˆæ‰§è¡Œ `$PGM`ï¼Œç„¶åæ‰§è¡Œ `K`"ã€‚

**ç¤ºä¾‹**ï¼š

```k
x = 1; y = 2; print(x+y)
```

å†…éƒ¨è¡¨ç¤ºä¸ºï¼š

```k
(x = 1) ~> (y = 2) ~> (print(x+y)) ~> .
```

---

## 2. å®šä¹‰ä¸€ä¸ªç®€å•è¯­è¨€ï¼šIMP

### 2.1 IMP è¯­æ³•

```k
module IMP-SYNTAX
  imports DOMAINS-SYNTAX

  syntax AExp ::= Int | Id
                | AExp "+" AExp   [left, strict]
                | AExp "*" AExp   [left, strict]
                | "(" AExp ")"    [bracket]

  syntax BExp ::= Bool
                | AExp "<=" AExp  [strict]
                | "!" BExp        [strict]
                | BExp "&&" BExp  [left, strict(1)]

  syntax Stmt ::= Id "=" AExp ";"       [strict(2)]
                | "if" "(" BExp ")" Block "else" Block  [strict(1)]
                | "while" "(" BExp ")" Block
                | Block

  syntax Block ::= "{" Stmt "}"
                 | "{" "}"

  syntax Pgm ::= "int" Ids ";" Stmt

  syntax Ids ::= List{Id, ","}
endmodule
```

**å…³é”®å±æ€§**ï¼š

- `[strict]`ï¼šå‚æ•°å…ˆæ±‚å€¼
- `[left]`ï¼šå·¦ç»“åˆ
- `[bracket]`ï¼šæ‹¬å·å¯ä»¥çœç•¥

### 2.2 IMP é…ç½®

```k
module IMP
  imports IMP-SYNTAX
  imports DOMAINS

  configuration
    <T>
      <k> $PGM:Pgm </k>
      <state> .Map </state>
    </T>

  // ç¨‹åºåˆå§‹åŒ–
  rule <k> int Xs:Ids ; S => S </k>
       <state> Rho:Map => Rho[Xs <- 0] </state>
```

### 2.3 ç®—æœ¯è¡¨è¾¾å¼è¯­ä¹‰

```k
  // å˜é‡æŸ¥æ‰¾
  rule <k> X:Id => I ... </k>
       <state> ... X |-> I ... </state>

  // åŠ æ³•
  rule I1:Int + I2:Int => I1 +Int I2

  // ä¹˜æ³•
  rule I1:Int * I2:Int => I1 *Int I2
```

### 2.4 å¸ƒå°”è¡¨è¾¾å¼è¯­ä¹‰

```k
  // å°äºç­‰äº
  rule I1:Int <= I2:Int => I1 <=Int I2

  // é€»è¾‘é
  rule ! B:Bool => notBool B

  // é€»è¾‘ä¸ï¼ˆçŸ­è·¯æ±‚å€¼ï¼‰
  rule true && B => B
  rule false && _ => false
```

### 2.5 è¯­å¥è¯­ä¹‰

**èµ‹å€¼**ï¼š

```k
  rule <k> X = I:Int ; => . ... </k>
       <state> ... X |-> (_ => I) ... </state>
```

**æ¡ä»¶è¯­å¥**ï¼š

```k
  rule if ( true )  S else _ => S
  rule if ( false ) _ else S => S
```

**å¾ªç¯**ï¼š

```k
  rule while ( B ) S => if ( B ) { S while ( B ) S } else { }
```

**å—**ï¼š

```k
  rule {} => .
  rule { S } => S
```

### 2.6 å®Œæ•´ç¤ºä¾‹

```k
endmodule
```

ä¿å­˜ä¸º `imp.k`ã€‚

**ç¼–è¯‘**ï¼š

```bash
kompile imp.k
```

**æµ‹è¯•ç¨‹åº**ï¼ˆ`sum.imp`ï¼‰ï¼š

```imp
int n, sum;
n = 10;
sum = 0;
while (!(n <= 0)) {
  sum = sum + n;
  n = n + (-1);
}
```

**æ‰§è¡Œ**ï¼š

```bash
krun sum.imp
```

**è¾“å‡º**ï¼š

```xml
<T>
  <k> . </k>
  <state>
    n |-> 0
    sum |-> 55
  </state>
</T>
```

---

## 3. K-Framework é«˜çº§ç‰¹æ€§

### 3.1 Heating/Cooling è§„åˆ™

**é—®é¢˜**ï¼šå¦‚ä½•æ§åˆ¶æ±‚å€¼é¡ºåºï¼Ÿ

**è§£å†³æ–¹æ¡ˆ**ï¼šHeatingï¼ˆæå–å­é¡¹æ±‚å€¼ï¼‰å’Œ Coolingï¼ˆå¡«å›ç»“æœï¼‰

**ç¤ºä¾‹**ï¼ˆå‡½æ•°è°ƒç”¨ï¼‰ï¼š

```k
syntax KResult ::= Int

context _+_
  requires notBool isKResult(HOLE)

// Heating: æå–å·¦æ“ä½œæ•°
rule <k> E1:AExp + E2:AExp => E1 ~> [] + E2 ... </k>
  requires notBool isKResult(E1)

// Cooling: å¡«å›ç»“æœ
rule <k> V:Int ~> [] + E2 => V + E2 ... </k>
```

### 3.2 Semantic Lists å’Œ Maps

**Lists**ï¼š

```k
rule <output> ... .List => ListItem(V) </output>  // è¿½åŠ 
rule <output> ListItem(V) => .List </output>      // æ¶ˆè´¹
```

**Maps**ï¼š

```k
rule <state> Rho:Map => Rho[X <- V] </state>       // æ›´æ–°
rule <state> ... X |-> V => .Map ... </state>      // åˆ é™¤
```

### 3.3 Symbolic Execution

**å®šä¹‰ç¬¦å·å˜é‡**ï¼š

```k
syntax AExp ::= "#symInt" "(" Int ")"  [function, functional, no-evaluators]
```

**ç¬¦å·è§„åˆ™**ï¼š

```k
rule #symInt(N) => ?I:Int
  ensures ?I >=Int 0
```

**éªŒè¯ç¤ºä¾‹**ï¼ˆæ•°ç»„è¶Šç•Œæ£€æŸ¥ï¼‰ï¼š

```k
rule <k> arr[I] => V ... </k>
     <store> ... arr |-> (Arr => Arr[I <- V]) ... </store>
  requires I >=Int 0 andBool I <Int size(Arr)
```

**è¿è¡Œç¬¦å·æ‰§è¡Œ**ï¼š

```bash
kprove --spec array-bounds.k
```

---

## 4. K-Framework åœ¨å·¥ä¸šä¸­çš„åº”ç”¨

### 4.1 ä»¥å¤ªåŠè™šæ‹Ÿæœºï¼ˆKEVMï¼‰

**é¡¹ç›®**ï¼š<https://github.com/runtimeverification/evm-semantics>

**æˆæœ**ï¼š

- EVM çš„å®Œæ•´å½¢å¼åŒ–è¯­ä¹‰
- è‡ªåŠ¨ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹
- æ™ºèƒ½åˆçº¦å½¢å¼åŒ–éªŒè¯

**éªŒè¯ç¤ºä¾‹**ï¼ˆERC20 Transferï¼‰ï¼š

```k
rule <k> #execute => #halt ... </k>
     <id> ACCTFROM </id>
     <balance> BALFROM => BALFROM - VALUE </balance>
     <id> ACCTTO </id>
     <balance> BALTO => BALTO + VALUE </balance>
  requires VALUE <=Int BALFROM
```

**å®é™…åº”ç”¨**ï¼š

- å·²å‘ç°å¤šä¸ª EVM å®ç°çš„ bug
- ç”¨äº MakerDAOã€Uniswap ç­‰åè®®çš„éªŒè¯
- 2021 å¹´éªŒè¯äº† DeFi Saver çš„å¤æ‚äº¤æ˜“

### 4.2 WebAssemblyï¼ˆKWasmï¼‰

**é¡¹ç›®**ï¼š<https://github.com/runtimeverification/wasm-semantics>

**ç‰¹ç‚¹**ï¼š

- å®Œæ•´çš„ Wasm è¯­ä¹‰
- æ”¯æŒæ‰€æœ‰ Wasm æŒ‡ä»¤
- éªŒè¯ Wasm â†’ KEVM ç¼–è¯‘å™¨

### 4.3 C è¯­è¨€ï¼ˆRV-Matchï¼‰

**å•†ä¸šäº§å“**ï¼šRuntime Verification çš„ C è¯­ä¹‰éªŒè¯å·¥å…·

**èƒ½åŠ›**ï¼š

- æ£€æµ‹æœªå®šä¹‰è¡Œä¸ºï¼ˆUndefined Behaviorï¼‰
- æ¯” UBSan æ›´ç²¾ç¡®
- æ”¯æŒ MISRA-C æ ‡å‡†æ£€æŸ¥

---

## 5. å½¢å¼åŒ–éªŒè¯ç¤ºä¾‹

### 5.1 å®šä¹‰è§„èŒƒ

**ä¸å˜å¼**ï¼š

```k
rule <k> INV => . ... </k>
  requires isInvariant(State)

syntax Bool ::= isInvariant(Map) [function]
rule isInvariant(... X |-> V ...) => V >=Int 0
```

### 5.2 å¯è¾¾æ€§è¯æ˜

**å®šç†**ï¼šä»åˆå§‹çŠ¶æ€ `Init` æ‰§è¡Œç¨‹åº `P`ï¼Œæœ€ç»ˆçŠ¶æ€æ»¡è¶³ `Post`

```k
module VERIFICATION
  imports IMP

  claim <k> P => . </k>
        <state> Init => Post </state>
    requires Pre
    ensures Post
endmodule
```

**éªŒè¯å‘½ä»¤**ï¼š

```bash
kprove verification.k --definition imp-kompiled
```

### 5.3 Coq äº’æ“ä½œ

**å¯¼å‡º Coq å®šä¹‰**ï¼š

```bash
kompile imp.k --backend coq
```

**ç”Ÿæˆçš„ Coq ä»£ç **ï¼š

```coq
Inductive AExp :=
  | AInt : Z -> AExp
  | AId : string -> AExp
  | APlus : AExp -> AExp -> AExp.

Inductive step : config -> config -> Prop :=
  | step_plus : forall n1 n2,
      step <k> APlus (AInt n1) (AInt n2) </k>
           <k> AInt (n1 + n2) </k>.
```

---

## 6. K-Framework å·¥å…·é“¾

### 6.1 å‘½ä»¤è¡Œå·¥å…·

**ç¼–è¯‘è¯­ä¹‰å®šä¹‰**ï¼š

```bash
kompile lang.k
```

**æ‰§è¡Œç¨‹åº**ï¼š

```bash
krun program.lang
```

**è°ƒè¯•**ï¼š

```bash
krun program.lang --debugger
```

**ç¬¦å·æ‰§è¡Œ**ï¼š

```bash
krun program.lang --search --pattern "<k> . </k>"
```

**è¯æ˜å™¨**ï¼š

```bash
kprove spec.k --definition lang-kompiled
```

### 6.2 REPL

```bash
kast --parse program.lang | krun -i <(cat -)
```

### 6.3 IDE æ”¯æŒ

**VSCode æ‰©å±•**ï¼š

- K Framework Syntax Highlighting
- K Language Server

**å®‰è£…**ï¼š

```bash
code --install-extension k-framework.k-vscode
```

---

## 7. ä¸å…¶ä»–å·¥å…·å¯¹æ¯”

### 7.1 K vs PLT Redex

| ç»´åº¦ | K-Framework | PLT Redex |
|------|-------------|-----------|
| **å®¿ä¸»è¯­è¨€** | ç‹¬ç«‹ DSL | Racket |
| **å¯æ‰§è¡Œæ€§** | é«˜æ€§èƒ½ç¼–è¯‘å™¨ | è§£é‡Šæ‰§è¡Œ |
| **éªŒè¯** | è‡ªåŠ¨å®šç†è¯æ˜ | æ‰‹åŠ¨ |
| **å·¥ä¸šåº”ç”¨** | å¤šä¸ªï¼ˆEVM, Wasmï¼‰ | å­¦æœ¯ä¸ºä¸» |

### 7.2 K vs Lem

| ç»´åº¦ | K-Framework | Lem |
|------|-------------|-----|
| **ç›®æ ‡** | å¯æ‰§è¡Œè¯­ä¹‰ | å¤šåç«¯å½¢å¼åŒ– |
| **è¯­æ³•** | K ç‰¹å®š | ML é£æ ¼ |
| **åç«¯** | LLVM, Haskell, Coq | Coq, Isabelle, HOL4 |
| **è‡ªåŠ¨åŒ–** | é«˜ï¼ˆè‡ªåŠ¨ç”Ÿæˆå·¥å…·ï¼‰ | ä½ï¼ˆéœ€æ‰‹å·¥è¯æ˜ï¼‰ |

---

## 8. æœ€ä½³å®è·µ

### 8.1 æ¨¡å—åŒ–è®¾è®¡

**åˆ†ç¦»è¯­æ³•å’Œè¯­ä¹‰**ï¼š

```k
// imp-syntax.k
module IMP-SYNTAX
  // ä»…è¯­æ³•å®šä¹‰
endmodule

// imp-semantics.k
module IMP
  imports IMP-SYNTAX
  // è¯­ä¹‰è§„åˆ™
endmodule
```

### 8.2 æµ‹è¯•é©±åŠ¨å¼€å‘

**ç›®å½•ç»“æ„**ï¼š

```text
lang/
â”œâ”€â”€ lang.k              // è¯­ä¹‰å®šä¹‰
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ pass/          // åº”è¯¥é€šè¿‡çš„æµ‹è¯•
â”‚   â”œâ”€â”€ fail/          // åº”è¯¥å¤±è´¥çš„æµ‹è¯•
â”‚   â””â”€â”€ proofs/        // å½¢å¼åŒ–è¯æ˜
â””â”€â”€ Makefile
```

**Makefile**ï¼š

```makefile
.PHONY: test
test: kompile
 krun tests/pass/*.lang
 kprove tests/proofs/*.k
```

### 8.3 æ€§èƒ½ä¼˜åŒ–

**Lazy Evaluation**ï¼š

```k
syntax Lazy ::= "lazy" "(" Exp ")"

rule lazy(E) => E  [lazy]
```

**Memoization**ï¼š

```k
rule fib(N) => ... [memo]
```

---

## 9. å®æˆ˜æ¡ˆä¾‹ï¼šéªŒè¯æ’åºç®—æ³•

### 9.1 å®šä¹‰è¯­è¨€

```k
module SORT-LANG
  imports INT
  imports LIST

  syntax Stmt ::= "sort" "(" List ")"

  configuration <k> $PGM:Stmt </k>
                <result> .List </result>
```

### 9.2 æ’å…¥æ’åºè¯­ä¹‰

```k
  syntax List ::= insert(Int, List) [function]

  rule insert(X, .List) => ListItem(X)
  rule insert(X, ListItem(Y) L) => ListItem(X) ListItem(Y) L
    requires X <=Int Y
  rule insert(X, ListItem(Y) L) => ListItem(Y) insert(X, L)
    requires X >Int Y

  syntax List ::= isort(List) [function]
  rule isort(.List) => .List
  rule isort(ListItem(X) L) => insert(X, isort(L))
```

### 9.3 éªŒè¯è§„èŒƒ

```k
  claim <k> sort(L) => . </k>
        <result> R </result>
    ensures sorted(R) andBool permutation(L, R)

  syntax Bool ::= sorted(List) [function]
  rule sorted(.List) => true
  rule sorted(ListItem(_)) => true
  rule sorted(ListItem(X) ListItem(Y) L) =>
       X <=Int Y andBool sorted(ListItem(Y) L)

  syntax Bool ::= permutation(List, List) [function, smtlib(perm)]
endmodule
```

### 9.4 è¿è¡ŒéªŒè¯

```bash
kprove sort-spec.k --smt-prelude perm.smt2
```

---

## 10. å¤§å­¦è¯¾ç¨‹å¯¹åº”

| è¯¾ç¨‹ | ç›¸å…³ç« èŠ‚ |
|------|----------|
| **UIUC CS 422 ç¼–ç¨‹è¯­è¨€è®¾è®¡** | K-Framework åŸåˆ›è¯¾ç¨‹ |
| **CMU 15-312 ç¼–ç¨‹è¯­è¨€åŸºç¡€** | æ“ä½œè¯­ä¹‰å¯¹æ¯” |
| **Berkeley CS 263 ç¨‹åºåˆ†æ** | ç¬¦å·æ‰§è¡Œåº”ç”¨ |
| **Stanford CS 242** | è¯­è¨€è®¾è®¡ä¸å®ç° |

---

## 11. æ•™æä¸è®ºæ–‡

### æ ¸å¿ƒè®ºæ–‡

1. **K-Framework åŸå§‹è®ºæ–‡**ï¼š
   - RoÈ™u, G., & È˜erbÄƒnuÈ›Äƒ, T. F. (2010). *An overview of the K semantic framework*. Journal of Logic and Algebraic Programming.

2. **KEVM è®ºæ–‡**ï¼š
   - Hildenbrandt, E., et al. (2018). *KEVM: A complete formal semantics of the Ethereum Virtual Machine*. CSF 2018.

3. **å¯è¾¾æ€§é€»è¾‘**ï¼š
   - RoÈ™u, G. (2017). *Matching logic*. Logical Methods in Computer Science.

### æ¨èé˜…è¯»

- K-Framework å®˜æ–¹æ•™ç¨‹ï¼š<https://kframework.org/k-distribution/pl-tutorial/>
- Runtime Verification æŠ€æœ¯åšå®¢

---

## å¿«é€Ÿå‚è€ƒ

### æ ¸å¿ƒæ¦‚å¿µ

```text
K-Framework = Configuration + Rewriting Rules + Automatic Tools

å…³é”®å…¬å¼ï¼š
  <k> Pattern => Replacement </k>  (åŸºç¡€é‡å†™)
  
  rule LHS => RHS requires Cond   (æ¡ä»¶é‡å†™)
  
  context C[HOLE]                  (æ±‚å€¼ä¸Šä¸‹æ–‡)
```

### å·¥å…·é“¾

```bash
# å®Œæ•´å·¥ä½œæµ
kompile lang.k                     # ç¼–è¯‘
krun program.lang                  # æ‰§è¡Œ
krun --search                      # çŠ¶æ€ç©ºé—´æœç´¢
kprove spec.k                      # å½¢å¼åŒ–éªŒè¯
kompile --backend coq              # å¯¼å‡º Coq
```

### å®æˆ˜å»ºè®®

1. **èµ·æ­¥**ï¼šä» IMP è¯­è¨€å¼€å§‹ï¼ˆå®˜æ–¹æ•™ç¨‹ï¼‰
2. **è¿›é˜¶**ï¼šå®šä¹‰è‡ªå·±çš„ DSL
3. **é«˜çº§**ï¼šä¸ºç°æœ‰è¯­è¨€ï¼ˆå¦‚ Python å­é›†ï¼‰ç¼–å†™è¯­ä¹‰
4. **ä¸“å®¶**ï¼šå‚ä¸ KEVM ç­‰é¡¹ç›®ï¼Œè´¡çŒ®è¯æ˜

---

## é™„å½• Aï¼šK-Framework å®‰è£…

### Linux/macOS

```bash
# ä½¿ç”¨ Homebrew
brew install kframework

# æˆ–ä»æºç ç¼–è¯‘
git clone https://github.com/runtimeverification/k.git
cd k
mvn package
export PATH=$PATH:$(pwd)/k-distribution/target/release/k/bin
```

### Windows (WSL)

```bash
# åœ¨ WSL ä¸­æŒ‰ Linux æ­¥éª¤å®‰è£…
```

### Docker

```bash
docker pull runtimeverification/k:latest
docker run -it -v $(pwd):/workspace runtimeverification/k
```

---

## é™„å½• Bï¼šWikipedia æ¦‚å¿µå¯¹ç…§

| æ¦‚å¿µ | Wikipedia æ¡ç›® | æœ¬æ–‡ç« èŠ‚ |
|------|----------------|----------|
| K Framework | <https://en.wikipedia.org/wiki/K_framework> | Â§1-2 |
| Rewriting System | <https://en.wikipedia.org/wiki/Rewriting> | Â§1.2 |
| Operational Semantics | <https://en.wikipedia.org/wiki/Operational_semantics> | Â§2 |
| KEVM | <https://github.com/runtimeverification/evm-semantics> | Â§4.1 |
| Matching Logic | <https://matching-logic.org/> | Â§5.2 |

---

**ç‰ˆæœ¬**ï¼šv1.0  
**æœ€åæ›´æ–°**ï¼š2025-10-29  
**ç»´æŠ¤è€…**ï¼šFormalScience Project  
**è®¸å¯**ï¼šCC BY-SA 4.0
