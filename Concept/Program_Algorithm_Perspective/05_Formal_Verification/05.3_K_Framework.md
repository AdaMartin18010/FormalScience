# K-Framework：可执行语义框架

## 📊 核心概念深度分析

<details>
<summary><b>⚙️🔬 点击展开：K-Framework核心洞察</b></summary>

**终极洞察**: K-Framework=可执行的编程语言语义定义框架。核心思想：定义即实现——用重写逻辑（Rewriting Logic）写出语言的操作语义，自动生成①解释器②符号执行器③模型检查器④反编译器⑤测试生成器。K定义结构：①语法（Syntax）：BNF定义AST②配置（Configuration）：运行时状态单元（<k>代码</k> <env>环境</env> <store>存储</store>）③语义规则（Rules）：模式匹配+重写，如rule <k> X:Int + Y:Int => X +Int Y </k>④成本语义：附加资源计数器（时间/能量/IO）。实战应用：①KEVM：以太坊EVM的形式化，发现智能合约漏洞②KRust：Rust语义，验证所有权系统③KJS：JavaScript完整语义④C/Java/Python语义定义。验证能力：①到达性验证：证明程序性质②等价性检查：优化正确性③符号执行：自动测试生成。对比其他工具：Coq（手工证明）、PLT Redex（研究原型）、K（工业级语义+自动工具）。学习曲线：中等，需要理解重写逻辑和匹配逻辑。关键：K将编程语言语义从纸上规范变为可执行可验证的精确定义，是语言形式化的统一框架。

</details>

---

## 📋 目录

- [K-Framework：可执行语义框架](#k-framework可执行语义框架)
  - [📊 核心概念深度分析](#-核心概念深度分析)
  - [📋 目录](#-目录)
  - [概述](#概述)
  - [1. K-Framework 基础](#1-k-framework-基础)
    - [1.1 配置（Configuration）](#11-配置configuration)
    - [1.2 重写规则（Rewriting Rules）](#12-重写规则rewriting-rules)
    - [1.3 K 单元（K Cell）](#13-k-单元k-cell)
  - [2. 定义一个简单语言：IMP](#2-定义一个简单语言imp)
    - [2.1 IMP 语法](#21-imp-语法)
    - [2.2 IMP 配置](#22-imp-配置)
    - [2.3 算术表达式语义](#23-算术表达式语义)
    - [2.4 布尔表达式语义](#24-布尔表达式语义)
    - [2.5 语句语义](#25-语句语义)
    - [2.6 完整示例](#26-完整示例)
  - [3. K-Framework 高级特性](#3-k-framework-高级特性)
    - [3.1 Heating/Cooling 规则](#31-heatingcooling-规则)
    - [3.2 Semantic Lists 和 Maps](#32-semantic-lists-和-maps)
    - [3.3 Symbolic Execution](#33-symbolic-execution)
  - [4. K-Framework 在工业中的应用](#4-k-framework-在工业中的应用)
    - [4.1 以太坊虚拟机（KEVM）](#41-以太坊虚拟机kevm)
    - [4.2 WebAssembly（KWasm）](#42-webassemblykwasm)
    - [4.3 C 语言（RV-Match）](#43-c-语言rv-match)
  - [5. 形式化验证示例](#5-形式化验证示例)
    - [5.1 定义规范](#51-定义规范)
    - [5.2 可达性证明](#52-可达性证明)
    - [5.3 Coq 互操作](#53-coq-互操作)
  - [6. K-Framework 工具链](#6-k-framework-工具链)
    - [6.1 命令行工具](#61-命令行工具)
    - [6.2 REPL](#62-repl)
    - [6.3 IDE 支持](#63-ide-支持)
  - [7. 与其他工具对比](#7-与其他工具对比)
    - [7.1 K vs PLT Redex](#71-k-vs-plt-redex)
    - [7.2 K vs Lem](#72-k-vs-lem)
  - [8. 最佳实践](#8-最佳实践)
    - [8.1 模块化设计](#81-模块化设计)
    - [8.2 测试驱动开发](#82-测试驱动开发)
    - [8.3 性能优化](#83-性能优化)
  - [9. 实战案例：验证排序算法](#9-实战案例验证排序算法)
    - [9.1 定义语言](#91-定义语言)
    - [9.2 插入排序语义](#92-插入排序语义)
    - [9.3 验证规范](#93-验证规范)
    - [9.4 运行验证](#94-运行验证)
  - [10. 大学课程对应](#10-大学课程对应)
  - [11. 教材与论文](#11-教材与论文)
    - [核心论文](#核心论文)
    - [推荐阅读](#推荐阅读)
  - [快速参考](#快速参考)
    - [核心概念](#核心概念)
    - [工具链](#工具链)
    - [实战建议](#实战建议)
  - [附录 A：K-Framework 安装](#附录-ak-framework-安装)
    - [Linux/macOS](#linuxmacos)
    - [Windows (WSL)](#windows-wsl)
    - [Docker](#docker)
  - [附录 B：Wikipedia 概念对照](#附录-bwikipedia-概念对照)

---

## 概述

**K-Framework** 是一个用于定义编程语言**可执行语义**的框架，核心思想：

```text
语言定义 = 配置 + 重写规则

配置（Configuration）：程序状态的结构
重写规则（Rewriting Rules）：状态转换规则

验证 = 可达性分析 + 不变式检查
```

**核心优势**：

- **语言无关**：统一框架定义任何语言
- **可执行性**：语义定义可直接执行
- **自动验证**：从语义自动生成验证工具
- **工业应用**：已用于 EVM、WASM、LLVM 等

**官网**：<https://kframework.org/>

---

## 1. K-Framework 基础

### 1.1 配置（Configuration）

**定义**：程序执行状态的树形结构

```k
configuration
  <k> $PGM:Stmt </k>          // 待执行的程序
  <env> .Map </env>           // 环境（变量绑定）
  <store> .Map </store>       // 存储（内存）
  <output> .List </output>    // 输出流
```

**语义**：

- `<k>` 单元：计算任务（Computation Cell）
- `<env>` 单元：变量 → 地址映射
- `<store>` 单元：地址 → 值映射
- `<output>` 单元：输出缓冲区

### 1.2 重写规则（Rewriting Rules）

**语法**：

```k
rule <k> Pattern => Replacement ... </k>
     <state> Constraints </state>
```

**示例**（赋值语句）：

```k
rule <k> X = E ; => . ... </k>
     <env> ... X |-> L ... </env>
     <store> ... L |-> (_ => V) ... </store>
  requires E ==K V
```

**解释**：

1. 模式匹配 `X = E ;` 在 `<k>` 单元
2. 查找 `X` 在 `<env>` 中的地址 `L`
3. 更新 `<store>` 中地址 `L` 的值为 `V`
4. 赋值语句执行完毕（`=> .`）

### 1.3 K 单元（K Cell）

**K 序列**：

```k
$PGM:Stmt ~> K:K
```

表示"先执行 `$PGM`，然后执行 `K`"。

**示例**：

```k
x = 1; y = 2; print(x+y)
```

内部表示为：

```k
(x = 1) ~> (y = 2) ~> (print(x+y)) ~> .
```

---

## 2. 定义一个简单语言：IMP

### 2.1 IMP 语法

```k
module IMP-SYNTAX
  imports DOMAINS-SYNTAX

  syntax AExp ::= Int | Id
                | AExp "+" AExp   [left, strict]
                | AExp "*" AExp   [left, strict]
                | "(" AExp ")"    [bracket]

  syntax BExp ::= Bool
                | AExp "<=" AExp  [strict]
                | "!" BExp        [strict]
                | BExp "&&" BExp  [left, strict(1)]

  syntax Stmt ::= Id "=" AExp ";"       [strict(2)]
                | "if" "(" BExp ")" Block "else" Block  [strict(1)]
                | "while" "(" BExp ")" Block
                | Block

  syntax Block ::= "{" Stmt "}"
                 | "{" "}"

  syntax Pgm ::= "int" Ids ";" Stmt

  syntax Ids ::= List{Id, ","}
endmodule
```

**关键属性**：

- `[strict]`：参数先求值
- `[left]`：左结合
- `[bracket]`：括号可以省略

### 2.2 IMP 配置

```k
module IMP
  imports IMP-SYNTAX
  imports DOMAINS

  configuration
    <T>
      <k> $PGM:Pgm </k>
      <state> .Map </state>
    </T>

  // 程序初始化
  rule <k> int Xs:Ids ; S => S </k>
       <state> Rho:Map => Rho[Xs <- 0] </state>
```

### 2.3 算术表达式语义

```k
  // 变量查找
  rule <k> X:Id => I ... </k>
       <state> ... X |-> I ... </state>

  // 加法
  rule I1:Int + I2:Int => I1 +Int I2

  // 乘法
  rule I1:Int * I2:Int => I1 *Int I2
```

### 2.4 布尔表达式语义

```k
  // 小于等于
  rule I1:Int <= I2:Int => I1 <=Int I2

  // 逻辑非
  rule ! B:Bool => notBool B

  // 逻辑与（短路求值）
  rule true && B => B
  rule false && _ => false
```

### 2.5 语句语义

**赋值**：

```k
  rule <k> X = I:Int ; => . ... </k>
       <state> ... X |-> (_ => I) ... </state>
```

**条件语句**：

```k
  rule if ( true )  S else _ => S
  rule if ( false ) _ else S => S
```

**循环**：

```k
  rule while ( B ) S => if ( B ) { S while ( B ) S } else { }
```

**块**：

```k
  rule {} => .
  rule { S } => S
```

### 2.6 完整示例

```k
endmodule
```

保存为 `imp.k`。

**编译**：

```bash
kompile imp.k
```

**测试程序**（`sum.imp`）：

```imp
int n, sum;
n = 10;
sum = 0;
while (!(n <= 0)) {
  sum = sum + n;
  n = n + (-1);
}
```

**执行**：

```bash
krun sum.imp
```

**输出**：

```xml
<T>
  <k> . </k>
  <state>
    n |-> 0
    sum |-> 55
  </state>
</T>
```

---

## 3. K-Framework 高级特性

### 3.1 Heating/Cooling 规则

**问题**：如何控制求值顺序？

**解决方案**：Heating（提取子项求值）和 Cooling（填回结果）

**示例**（函数调用）：

```k
syntax KResult ::= Int

context _+_
  requires notBool isKResult(HOLE)

// Heating: 提取左操作数
rule <k> E1:AExp + E2:AExp => E1 ~> [] + E2 ... </k>
  requires notBool isKResult(E1)

// Cooling: 填回结果
rule <k> V:Int ~> [] + E2 => V + E2 ... </k>
```

### 3.2 Semantic Lists 和 Maps

**Lists**：

```k
rule <output> ... .List => ListItem(V) </output>  // 追加
rule <output> ListItem(V) => .List </output>      // 消费
```

**Maps**：

```k
rule <state> Rho:Map => Rho[X <- V] </state>       // 更新
rule <state> ... X |-> V => .Map ... </state>      // 删除
```

### 3.3 Symbolic Execution

**定义符号变量**：

```k
syntax AExp ::= "#symInt" "(" Int ")"  [function, functional, no-evaluators]
```

**符号规则**：

```k
rule #symInt(N) => ?I:Int
  ensures ?I >=Int 0
```

**验证示例**（数组越界检查）：

```k
rule <k> arr[I] => V ... </k>
     <store> ... arr |-> (Arr => Arr[I <- V]) ... </store>
  requires I >=Int 0 andBool I <Int size(Arr)
```

**运行符号执行**：

```bash
kprove --spec array-bounds.k
```

---

## 4. K-Framework 在工业中的应用

### 4.1 以太坊虚拟机（KEVM）

**项目**：<https://github.com/runtimeverification/evm-semantics>

**成果**：

- EVM 的完整形式化语义
- 自动生成测试用例
- 智能合约形式化验证

**验证示例**（ERC20 Transfer）：

```k
rule <k> #execute => #halt ... </k>
     <id> ACCTFROM </id>
     <balance> BALFROM => BALFROM - VALUE </balance>
     <id> ACCTTO </id>
     <balance> BALTO => BALTO + VALUE </balance>
  requires VALUE <=Int BALFROM
```

**实际应用**：

- 已发现多个 EVM 实现的 bug
- 用于 MakerDAO、Uniswap 等协议的验证
- 2021 年验证了 DeFi Saver 的复杂交易

### 4.2 WebAssembly（KWasm）

**项目**：<https://github.com/runtimeverification/wasm-semantics>

**特点**：

- 完整的 Wasm 语义
- 支持所有 Wasm 指令
- 验证 Wasm → KEVM 编译器

### 4.3 C 语言（RV-Match）

**商业产品**：Runtime Verification 的 C 语义验证工具

**能力**：

- 检测未定义行为（Undefined Behavior）
- 比 UBSan 更精确
- 支持 MISRA-C 标准检查

---

## 5. 形式化验证示例

### 5.1 定义规范

**不变式**：

```k
rule <k> INV => . ... </k>
  requires isInvariant(State)

syntax Bool ::= isInvariant(Map) [function]
rule isInvariant(... X |-> V ...) => V >=Int 0
```

### 5.2 可达性证明

**定理**：从初始状态 `Init` 执行程序 `P`，最终状态满足 `Post`

```k
module VERIFICATION
  imports IMP

  claim <k> P => . </k>
        <state> Init => Post </state>
    requires Pre
    ensures Post
endmodule
```

**验证命令**：

```bash
kprove verification.k --definition imp-kompiled
```

### 5.3 Coq 互操作

**导出 Coq 定义**：

```bash
kompile imp.k --backend coq
```

**生成的 Coq 代码**：

```coq
Inductive AExp :=
  | AInt : Z -> AExp
  | AId : string -> AExp
  | APlus : AExp -> AExp -> AExp.

Inductive step : config -> config -> Prop :=
  | step_plus : forall n1 n2,
      step <k> APlus (AInt n1) (AInt n2) </k>
           <k> AInt (n1 + n2) </k>.
```

---

## 6. K-Framework 工具链

### 6.1 命令行工具

**编译语义定义**：

```bash
kompile lang.k
```

**执行程序**：

```bash
krun program.lang
```

**调试**：

```bash
krun program.lang --debugger
```

**符号执行**：

```bash
krun program.lang --search --pattern "<k> . </k>"
```

**证明器**：

```bash
kprove spec.k --definition lang-kompiled
```

### 6.2 REPL

```bash
kast --parse program.lang | krun -i <(cat -)
```

### 6.3 IDE 支持

**VSCode 扩展**：

- K Framework Syntax Highlighting
- K Language Server

**安装**：

```bash
code --install-extension k-framework.k-vscode
```

---

## 7. 与其他工具对比

### 7.1 K vs PLT Redex

| 维度 | K-Framework | PLT Redex |
|------|-------------|-----------|
| **宿主语言** | 独立 DSL | Racket |
| **可执行性** | 高性能编译器 | 解释执行 |
| **验证** | 自动定理证明 | 手动 |
| **工业应用** | 多个（EVM, Wasm） | 学术为主 |

### 7.2 K vs Lem

| 维度 | K-Framework | Lem |
|------|-------------|-----|
| **目标** | 可执行语义 | 多后端形式化 |
| **语法** | K 特定 | ML 风格 |
| **后端** | LLVM, Haskell, Coq | Coq, Isabelle, HOL4 |
| **自动化** | 高（自动生成工具） | 低（需手工证明） |

---

## 8. 最佳实践

### 8.1 模块化设计

**分离语法和语义**：

```k
// imp-syntax.k
module IMP-SYNTAX
  // 仅语法定义
endmodule

// imp-semantics.k
module IMP
  imports IMP-SYNTAX
  // 语义规则
endmodule
```

### 8.2 测试驱动开发

**目录结构**：

```text
lang/
├── lang.k              // 语义定义
├── tests/
│   ├── pass/          // 应该通过的测试
│   ├── fail/          // 应该失败的测试
│   └── proofs/        // 形式化证明
└── Makefile
```

**Makefile**：

```makefile
.PHONY: test
test: kompile
 krun tests/pass/*.lang
 kprove tests/proofs/*.k
```

### 8.3 性能优化

**Lazy Evaluation**：

```k
syntax Lazy ::= "lazy" "(" Exp ")"

rule lazy(E) => E  [lazy]
```

**Memoization**：

```k
rule fib(N) => ... [memo]
```

---

## 9. 实战案例：验证排序算法

### 9.1 定义语言

```k
module SORT-LANG
  imports INT
  imports LIST

  syntax Stmt ::= "sort" "(" List ")"

  configuration <k> $PGM:Stmt </k>
                <result> .List </result>
```

### 9.2 插入排序语义

```k
  syntax List ::= insert(Int, List) [function]

  rule insert(X, .List) => ListItem(X)
  rule insert(X, ListItem(Y) L) => ListItem(X) ListItem(Y) L
    requires X <=Int Y
  rule insert(X, ListItem(Y) L) => ListItem(Y) insert(X, L)
    requires X >Int Y

  syntax List ::= isort(List) [function]
  rule isort(.List) => .List
  rule isort(ListItem(X) L) => insert(X, isort(L))
```

### 9.3 验证规范

```k
  claim <k> sort(L) => . </k>
        <result> R </result>
    ensures sorted(R) andBool permutation(L, R)

  syntax Bool ::= sorted(List) [function]
  rule sorted(.List) => true
  rule sorted(ListItem(_)) => true
  rule sorted(ListItem(X) ListItem(Y) L) =>
       X <=Int Y andBool sorted(ListItem(Y) L)

  syntax Bool ::= permutation(List, List) [function, smtlib(perm)]
endmodule
```

### 9.4 运行验证

```bash
kprove sort-spec.k --smt-prelude perm.smt2
```

---

## 10. 大学课程对应

| 课程 | 相关章节 |
|------|----------|
| **UIUC CS 422 编程语言设计** | K-Framework 原创课程 |
| **CMU 15-312 编程语言基础** | 操作语义对比 |
| **Berkeley CS 263 程序分析** | 符号执行应用 |
| **Stanford CS 242** | 语言设计与实现 |

---

## 11. 教材与论文

### 核心论文

1. **K-Framework 原始论文**：
   - Roșu, G., & Șerbănuță, T. F. (2010). _An overview of the K semantic framework_. Journal of Logic and Algebraic Programming.

2. **KEVM 论文**：
   - Hildenbrandt, E., et al. (2018). _KEVM: A complete formal semantics of the Ethereum Virtual Machine_. CSF 2018.

3. **可达性逻辑**：
   - Roșu, G. (2017). _Matching logic_. Logical Methods in Computer Science.

### 推荐阅读

- K-Framework 官方教程：<https://kframework.org/k-distribution/pl-tutorial/>
- Runtime Verification 技术博客

---

## 快速参考

### 核心概念

```text
K-Framework = Configuration + Rewriting Rules + Automatic Tools

关键公式：
  <k> Pattern => Replacement </k>  (基础重写)

  rule LHS => RHS requires Cond   (条件重写)

  context C[HOLE]                  (求值上下文)
```

### 工具链

```bash
# 完整工作流
kompile lang.k                     # 编译
krun program.lang                  # 执行
krun --search                      # 状态空间搜索
kprove spec.k                      # 形式化验证
kompile --backend coq              # 导出 Coq
```

### 实战建议

1. **起步**：从 IMP 语言开始（官方教程）
2. **进阶**：定义自己的 DSL
3. **高级**：为现有语言（如 Python 子集）编写语义
4. **专家**：参与 KEVM 等项目，贡献证明

---

## 附录 A：K-Framework 安装

### Linux/macOS

```bash
# 使用 Homebrew
brew install kframework

# 或从源码编译
git clone https://github.com/runtimeverification/k.git
cd k
mvn package
export PATH=$PATH:$(pwd)/k-distribution/target/release/k/bin
```

### Windows (WSL)

```bash
# 在 WSL 中按 Linux 步骤安装
```

### Docker

```bash
docker pull runtimeverification/k:latest
docker run -it -v $(pwd):/workspace runtimeverification/k
```

---

## 附录 B：Wikipedia 概念对照

| 概念 | Wikipedia 条目 | 本文章节 |
|------|----------------|----------|
| K Framework | <https://en.wikipedia.org/wiki/K_framework> | §1-2 |
| Rewriting System | <https://en.wikipedia.org/wiki/Rewriting> | §1.2 |
| Operational Semantics | <https://en.wikipedia.org/wiki/Operational_semantics> | §2 |
| KEVM | <https://github.com/runtimeverification/evm-semantics> | §4.1 |
| Matching Logic | <https://matching-logic.org/> | §5.2 |

---

**版本**：v1.0
**最后更新**：2025-10-29
**维护者**：FormalScience Project
**许可**：CC BY-SA 4.0
