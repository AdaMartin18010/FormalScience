# 05.2 模型检测工具：mCRL2, UPPAAL, TLA+

## 概述

**模型检测**（Model Checking）是一种自动化验证技术，通过**穷举搜索**状态空间来验证系统性质。与定理证明不同：

```text
┌──────────────┬─────────────────┬─────────────────┐
│              │ 模型检测         │ 定理证明        │
├──────────────┼─────────────────┼─────────────────┤
│ 自动化程度    │ 完全自动         │ 需人工引导      │
│ 验证范围      │ 有限状态         │ 无限状态        │
│ 反例          │ 自动生成         │ 无             │
│ 学习曲线      │ 平缓            │ 陡峭             │
│ 适用场景      │ 协议、并发       │ 算法、数据结构   │
└──────────────┴─────────────────┴─────────────────┘
```

本文介绍三款业界主流工具：

1. **mCRL2**：进程代数（Process Algebra）建模
2. **UPPAAL**：实时系统（Timed Automata）验证
3. **TLA+**：分布式系统（Temporal Logic）规约

---

## 1. 模型检测基础

### 1.1 核心概念

**状态空间（State Space）**：

```text
系统 = ⟨S, s₀, →, L⟩

S  : 状态集合
s₀ : 初始状态
→  : 转移关系（S × S）
L  : 标签函数（S → 2^AP，AP 为原子命题）
```

**时态逻辑（Temporal Logic）**：

```text
LTL（Linear Temporal Logic）：
  φ ::= p | ¬φ | φ ∧ φ | X φ | F φ | G φ | φ U φ
  
  X φ : 下一步 φ 成立（neXt）
  F φ : 将来某时刻 φ 成立（Future）
  G φ : 总是 φ 成立（Globally）
  φ U ψ : φ 一直成立直到 ψ 成立（Until）

CTL（Computation Tree Logic）：
  φ ::= p | ¬φ | φ ∧ φ | AX φ | EX φ | AF φ | EF φ | ...
  
  A : 所有路径（All paths）
  E : 存在路径（Exists a path）
```

**模型检测算法**：

```text
1. 显式状态（Explicit State）：
   - DFS/BFS 遍历状态空间
   - 适合小规模系统

2. 符号模型检测（Symbolic）：
   - 使用 BDD（Binary Decision Diagram）表示状态集合
   - 可处理 10^20 个状态

3. 有界模型检测（Bounded）：
   - 限制路径长度 k
   - 转化为 SAT 问题
   - 快速找到短反例
```

### 1.2 状态爆炸问题

**挑战**：

```text
示例：n 个进程，每个进程有 m 个状态

状态空间大小 = m^n

n=10, m=10 ⇒ 10^10 个状态（100亿）
n=20, m=10 ⇒ 10^20 个状态（不可行）
```

**缓解技术**：

```text
1. 偏序归约（Partial Order Reduction）：
   - 利用独立动作的交换性
   - 只探索代表性交错（interleaving）

2. 抽象（Abstraction）：
   - 忽略不相关细节
   - 保持关键性质

3. 组合式（Compositional）：
   - 分别验证各组件
   - 假设-保证（Assume-Guarantee）

4. 对称性归约（Symmetry Reduction）：
   - 利用系统对称性
   - 合并对称状态
```

---

## 2. mCRL2：进程代数建模

### 2.1 介绍

```text
mCRL2 = micro Common Representation Language 2

核心特性：
  - 基于 ACP（Algebra of Communicating Processes）
  - 支持数据类型和参数化进程
  - 强大的可视化工具
  - μ-calculus 性质验证
```

### 2.2 语法基础

#### 进程定义

```mcrl2
% 简单的交通信号灯
act
  red, yellow, green;  % 动作声明

proc
  TrafficLight = red . yellow . green . TrafficLight;

init
  TrafficLight;
```

#### 数据类型

```mcrl2
sort
  Color = struct Red | Yellow | Green;
  
map
  next: Color -> Color;

eqn
  next(Red) = Yellow;
  next(Yellow) = Green;
  next(Green) = Red;

proc
  Light(c: Color) = signal(c) . Light(next(c));

init
  Light(Red);
```

#### 并行组合

```mcrl2
act
  send, receive, comm;  % 动作

proc
  Sender = send . Sender;
  Receiver = receive . Receiver;

init
  allow({comm},
    comm({send, receive},
      Sender || Receiver
    )
  );
```

### 2.3 实战案例：生产者-消费者

```mcrl2
% 有界缓冲区的生产者-消费者

sort
  Buffer = List(Nat);

act
  produce, consume: Nat;
  put, get: Nat;

proc
  Producer(n: Nat) =
    produce(n) . put(n) . Producer(n+1);
  
  Consumer =
    sum m: Nat . get(m) . consume(m) . Consumer;
  
  Buffer(buf: Buffer, capacity: Nat) =
    (#buf < capacity) ->
      sum x: Nat . put(x) . Buffer(x |> buf, capacity)
    +
    (#buf > 0) ->
      get(head(buf)) . Buffer(tail(buf), capacity);

init
  allow({produce, consume},
    comm({put|get -> tau},
      Producer(0) || Buffer([], 5) || Consumer
    )
  );
```

**生成状态空间**：

```bash
mcrl22lps producer_consumer.mcrl2 producer_consumer.lps
lps2lts producer_consumer.lps producer_consumer.lts

# 可视化
ltsgraph producer_consumer.lts
```

### 2.4 性质验证（μ-calculus）

```mcrl2
% 检查：生产者总能最终放入数据
[true*] <produce(0)> true

% 检查：永远不会死锁
[true*] <true> true

% 检查：缓冲区永不溢出
[true*.put(x)]
  val(#buffer < capacity)
```

**使用工具**：

```bash
lps2pbes -f property.mcf producer_consumer.lps | pbes2bool
# 输出：true 或 false，若 false 则提供反例
```

### 2.5 实战案例：互斥协议（Peterson算法）

```mcrl2
sort
  ProcessID = struct P1 | P2;

act
  enter, exit: ProcessID;
  set_flag, set_turn: ProcessID;

proc
  Process(id: ProcessID, other: ProcessID) =
    % 进入临界区协议
    set_flag(id) .
    set_turn(other) .
    wait_until(not flag[other] or turn == id) .
    enter(id) .
    % 临界区
    exit(id) .
    % 离开
    clear_flag(id) .
    Process(id, other);

init
  Process(P1, P2) || Process(P2, P1);
```

**验证性质**：

```mcrl2
% 互斥性：两个进程不能同时在临界区
[true*] forall p, q: ProcessID .
  (p != q) => !(val(in_cs[p]) && val(in_cs[q]))

% 无饥饿：每个请求最终被满足
[true*] [set_flag(p)] mu X . (<true> true && [!enter(p)] X)
```

---

## 3. UPPAAL：实时系统验证

### 3.1 介绍

```text
UPPAAL = Uppsala + Aalborg

核心特性：
  - 时间自动机（Timed Automata）网络
  - 时钟约束（Clock Constraints）
  - 图形化建模界面
  - CTL 性质验证
  - 反例动画演示
```

### 3.2 时间自动机基础

**定义**：

```text
时间自动机 = ⟨L, l₀, C, A, E, I⟩

L  : 位置集合
l₀ : 初始位置
C  : 时钟集合
A  : 动作集合
E  : 边（转移）：l →^(g,a,r) l'
    g : 守卫（clock constraints）
    a : 动作
    r : 时钟重置
I  : 不变式（每个位置的时钟约束）
```

**示例**：简单定时器

```text
     ┌───────┐  x := 0  ┌──────────┐
Start│       ├─────────→│ Running  │
     └───────┘           │ x ≤ 10   │
                         └─────┬────┘
                          x≥10 │
                         ┌─────▼────┐
                         │ Timeout  │
                         └──────────┘
```

### 3.3 UPPAAL 建模语言

#### 全局声明

```c
// 时钟
clock x, y;

// 整数变量
int[0,10] counter;

// 通道（同步）
chan start, stop;
urgent chan error;  // 立即同步
```

#### 位置与转移

```text
位置 L0:
  不变式：x <= 5
  
转移 L0 -> L1:
  守卫：x >= 2 && counter > 0
  同步：start!  （发送）
  更新：counter--, x := 0
```

### 3.4 实战案例：火车过轨道口

**问题**：火车与轨道口的安全控制

**模型**：

```text
// Train 自动机
location Approaching {
  invariant x <= 5
}

location Crossing {
  invariant x <= 10
}

transition Approaching -> Crossing {
  guard x >= 3
  sync appr!
  update x := 0
}

transition Crossing -> Safe {
  guard x >= 7
  sync leave!
}

// Gate 自动机
location Up {
}

location Lowering {
  invariant y <= 2
}

location Down {
  invariant y <= 20
}

transition Up -> Lowering {
  sync appr?
  update y := 0
}

transition Lowering -> Down {
  guard y >= 2
}

transition Down -> Up {
  sync leave?
}
```

**性质验证**：

```c
// 安全性：火车在轨道口时，门必须是关闭的
A[] (Train.Crossing imply Gate.Down)

// 活性：火车最终会通过
Train.Approaching --> Train.Safe

// 有界性：门关闭时间不超过 25 秒
A[] (Gate.Lowering imply y <= 25)
```

**运行**：

```bash
verifyta -t1 train_gate.xml
# 输出：Property is satisfied 或 提供反例轨迹
```

### 3.5 反例分析

**反例轨迹示例**：

```text
State 0: Train.Approaching, Gate.Up, x=0, y=0
  --[delay 3.5]-->
State 1: Train.Approaching, Gate.Up, x=3.5, y=0
  --[appr!]-->
State 2: Train.Crossing, Gate.Lowering, x=0, y=0
  --[delay 1.5]-->  ❌ 火车已进入轨道口，但门尚未关闭！
State 3: Train.Crossing, Gate.Lowering, x=1.5, y=1.5

修正：增加火车等待时间或加快门关闭速度
```

### 3.6 实战案例：Fischer 互斥协议

```c
// 全局变量
int id;  // 共享 ID

// Process 模板
process Process(const int pid) {
  clock x;
  
  location Idle {}
  
  location Req {
    invariant x <= k
  }
  
  location Wait {
    invariant x <= k
  }
  
  location CS {}
  
  // Idle -> Req
  transition {
    select Idle to Req
    guard id == 0
    update x := 0
  }
  
  // Req -> Wait
  transition {
    select Req to Wait
    guard x <= k
    update id := pid, x := 0
  }
  
  // Wait -> CS
  transition {
    select Wait to CS
    guard x >= k && id == pid
  }
  
  // CS -> Idle
  transition {
    select CS to Idle
    update id := 0
  }
}

// 实例化
system Process1 = Process(1);
system Process2 = Process(2);
```

**验证互斥性**：

```c
A[] not (Process1.CS and Process2.CS)

// 参数化验证：找到合适的 k 值
// k = 0: 违反互斥
// k ≥ 某个阈值: 满足互斥
```

---

## 4. TLA+：分布式系统规约

### 4.1 介绍

```text
TLA+ = Temporal Logic of Actions +

核心特性：
  - 数学严格（基于 ZF 集合论）
  - 适合高层规约（不关心实现细节）
  - TLC 模型检测器
  - PlusCal 算法语言（可转换为 TLA+）
```

### 4.2 TLA+ 语法基础

#### 常量与变量

```tla
CONSTANTS N, Data

VARIABLES x, y, pc
```

#### 初始状态与转移

```tla
Init == 
  /\ x = 0
  /\ y = 0
  /\ pc = "idle"

Next ==
  \/ Increment  \* 选择分支
  \/ Decrement

Increment ==
  /\ pc = "idle"
  /\ x' = x + 1  \* x 的下一个状态
  /\ y' = y
  /\ pc' = "inc"

Decrement ==
  /\ pc = "idle"
  /\ x' = x - 1
  /\ x' = y
  /\ pc' = "dec"

Spec == Init /\ [][Next]_<<x, y, pc>>
```

#### 不变式

```tla
TypeInvariant ==
  /\ x \in Int
  /\ y \in Int
  /\ pc \in {"idle", "inc", "dec"}

SafetyProperty ==
  pc = "inc" => x > 0
```

### 4.3 实战案例：两阶段提交（2PC）

```tla
---- MODULE TwoPhaseCommit ----
EXTENDS Integers, FiniteSets

CONSTANTS RM  \* 资源管理器集合

VARIABLES
  rmState,     \* RM -> {"working", "prepared", "committed", "aborted"}
  tmState,     \* TM 状态
  tmPrepared,  \* 已准备的 RM 集合
  msgs         \* 消息集合

Messages ==
  [type : {"Prepare"}, rm : RM] \cup
  [type : {"Prepared", "Aborted"}, rm : RM] \cup
  [type : {"Commit", "Abort"}]

Init ==
  /\ rmState = [rm \in RM |-> "working"]
  /\ tmState = "init"
  /\ tmPrepared = {}
  /\ msgs = {}

\* RM 发送 Prepared 消息
RMPrepare(rm) ==
  /\ rmState[rm] = "working"
  /\ rmState' = [rmState EXCEPT ![rm] = "prepared"]
  /\ msgs' = msgs \cup {[type |-> "Prepared", rm |-> rm]}
  /\ UNCHANGED <<tmState, tmPrepared>>

\* RM 选择中止
RMChooseToAbort(rm) ==
  /\ rmState[rm] = "working"
  /\ rmState' = [rmState EXCEPT ![rm] = "aborted"]
  /\ msgs' = msgs \cup {[type |-> "Aborted", rm |-> rm]}
  /\ UNCHANGED <<tmState, tmPrepared>>

\* TM 收集 Prepared 消息
TMRcvPrepared(rm) ==
  /\ tmState = "init"
  /\ [type |-> "Prepared", rm |-> rm] \in msgs
  /\ tmPrepared' = tmPrepared \cup {rm}
  /\ UNCHANGED <<rmState, tmState, msgs>>

\* TM 决定提交
TMCommit ==
  /\ tmState = "init"
  /\ tmPrepared = RM  \* 所有 RM 都准备好
  /\ tmState' = "commit"
  /\ msgs' = msgs \cup {[type |-> "Commit"]}
  /\ UNCHANGED <<rmState, tmPrepared>>

\* TM 决定中止
TMAbort ==
  /\ tmState = "init"
  /\ tmState' = "abort"
  /\ msgs' = msgs \cup {[type |-> "Abort"]}
  /\ UNCHANGED <<rmState, tmPrepared>>

\* RM 收到 Commit 消息
RMRcvCommitMsg(rm) ==
  /\ [type |-> "Commit"] \in msgs
  /\ rmState' = [rmState EXCEPT ![rm] = "committed"]
  /\ UNCHANGED <<tmState, tmPrepared, msgs>>

\* RM 收到 Abort 消息
RMRcvAbortMsg(rm) ==
  /\ [type |-> "Abort"] \in msgs
  /\ rmState' = [rmState EXCEPT ![rm] = "aborted"]
  /\ UNCHANGED <<tmState, tmPrepared, msgs>>

Next ==
  \/ \E rm \in RM :
       \/ RMPrepare(rm)
       \/ RMChooseToAbort(rm)
       \/ TMRcvPrepared(rm)
       \/ RMRcvCommitMsg(rm)
       \/ RMRcvAbortMsg(rm)
  \/ TMCommit
  \/ TMAbort

Spec == Init /\ [][Next]_<<rmState, tmState, tmPrepared, msgs>>

\* 不变式：原子提交性
Consistency ==
  \A rm1, rm2 \in RM :
    (rmState[rm1] = "committed" /\ rmState[rm2] = "aborted") => FALSE

====
```

**运行 TLC**：

```bash
# 配置文件 TwoPhaseCommit.cfg
CONSTANTS RM = {rm1, rm2, rm3}
INVARIANT Consistency

# 运行
java -jar tla2tools.jar -workers 4 TwoPhaseCommit.tla
```

### 4.4 PlusCal：算法语言

**示例**：Euclid GCD

```tla
---- MODULE GCD ----
EXTENDS Integers

(*--algorithm gcd
variables x = 24, y = 18;

begin
  while x /= y do
    if x > y then
      x := x - y;
    else
      y := y - x;
    end if;
  end while;
  print x;  \* 输出 GCD
end algorithm; *)

\* TLA+ 翻译（自动生成）
...
```

---

## 5. 工具对比与选择

### 5.1 特性对比

| 特性 | mCRL2 | UPPAAL | TLA+ |
|------|-------|--------|------|
| **建模范式** | 进程代数 | 时间自动机 | 状态机 + 动作 |
| **时间建模** | ❌ | ✅（实时） | ⚠️（逻辑时间） |
| **数据类型** | ✅（丰富） | ⚠️（有限） | ✅（集合论） |
| **可视化** | ✅（LTS图） | ✅（自动机图） | ❌ |
| **反例** | ✅（轨迹） | ✅（动画） | ✅（状态序列） |
| **学习曲线** | 中等 | 平缓 | 陡峭 |
| **工业应用** | 通信协议 | 嵌入式系统 | 分布式系统 |

### 5.2 选择指南

```text
选择 mCRL2 如果：
  - 系统以消息传递为主（CSP/ACP 风格）
  - 需要丰富的数据类型
  - 需要可视化状态空间

选择 UPPAAL 如果：
  - 系统有实时约束（时钟、定时器）
  - 需要图形化建模
  - 需要教学或演示

选择 TLA+ 如果：
  - 系统是分布式系统
  - 需要高层规约（不关心实现细节）
  - 团队有数学背景
```

---

## 6. 与国际课程对标

### 6.1 大学课程映射

| 课程 | 相关章节 |
|------|---------|
| **MIT 6.826 计算机系统原理** | TLA+ 规约 |
| **CMU 15-414 软件工程** | mCRL2 进程验证 |
| **UC Berkeley CS294-126 形式化方法** | UPPAAL 实时系统 |
| **ETH Zürich 形式化方法** | 模型检测理论 |

### 6.2 教材对应

| 教材 | 相关章节 |
|------|---------|
| **Baier & Katoen "Principles of Model Checking"** | 完整教材 |
| **Clarke et al. "Model Checking"** | 模型检测算法 |
| **Lamport "Specifying Systems"** | TLA+ 完整指南 |
| **Alur & Dill "Theory of Timed Automata"** | UPPAAL 理论基础 |

---

## 7. 工业应用案例

### 7.1 Amazon Web Services（TLA+）

**应用**：S3, DynamoDB, EBS 等服务的规约

**发现的Bug**：

```text
1. S3 复制协议中的竞态条件
2. DynamoDB 的数据不一致问题
3. EBS 的卷快照bug

引用：http://lamport.azurewebsites.net/tla/amazon.html
```

### 7.2 欧洲火车控制系统（UPPAAL）

**应用**：ERTMS/ETCS Level 2 协议验证

**规模**：

```text
- 50+ 时间自动机
- 100+ 时钟
- 10^8 状态空间
- 发现 12 个设计缺陷
```

### 7.3 通信协议（mCRL2）

**应用**：IEEE 1394 FireWire 协议验证

**结果**：

```text
- 发现树标识协议的死锁
- 提供修正建议
- 论文：https://link.springer.com/chapter/10.1007/3-540-48153-2_34
```

---

## 8. 扩展阅读

### 8.1 学术论文

1. **mCRL2**: Groote & Mousavi. "Modeling and Analysis of Communicating Systems." 2014.
2. **UPPAAL**: Bengtsson & Yi. "Timed Automata: Semantics, Algorithms and Tools." 2004.
3. **TLA+**: Lamport, L. "The Temporal Logic of Actions." ACM TOPLAS 1994.

### 8.2 在线资源

- **mCRL2**: <https://mcrl2.org/>
- **UPPAAL**: <https://uppaal.org/>
- **TLA+**: <https://lamport.azurewebsites.net/tla/tla.html>

### 8.3 本地项目引用

- **Coq 入门**：[./05.1_Coq_Introduction.md](./05.1_Coq_Introduction.md)
- **设计模式验证**：[../02_Design_Patterns/02.1_GoF_Formal_Analysis.md](../02_Design_Patterns/02.1_GoF_Formal_Analysis.md)
- **并发模型**：[../../FormalLanguage_Perspective/05_Computational_Models/](../../FormalLanguage_Perspective/05_Computational_Models/)

---

## 附录 A：Wikipedia 概念对照

| 概念 | Wikipedia 条目 | 本文章节 |
|------|---------------|----------|
| Model Checking | <https://en.wikipedia.org/wiki/Model_checking> | §1 |
| Temporal Logic | <https://en.wikipedia.org/wiki/Temporal_logic> | §1.1 |
| Process Algebra | <https://en.wikipedia.org/wiki/Process_calculus> | §2 |
| Timed Automata | <https://en.wikipedia.org/wiki/Timed_automaton> | §3 |
| TLA+ | <https://en.wikipedia.org/wiki/TLA%2B> | §4 |

---

## 附录 B：工具安装指南

### mCRL2

```bash
# macOS
brew install mcrl2

# Ubuntu
sudo apt-add-repository ppa:mcrl2/release-ppa
sudo apt install mcrl2

# 验证
mcrl22lps --version
```

### UPPAAL

```bash
# 下载（所有平台）
wget https://people.cs.aau.dk/~marius/uppaal/uppaal64-4.1.26.zip
unzip uppaal64-4.1.26.zip

# 运行
cd uppaal64-4.1.26
./uppaal
```

### TLA+

```bash
# 下载 TLA+ Toolbox
wget https://github.com/tlaplus/tlaplus/releases/download/v1.7.1/TLAToolbox-1.7.1-linux.gtk.x86_64.zip

# 或使用命令行 TLC
java -jar tla2tools.jar -help
```

---

**版本**：v1.0  
**最后更新**：2025-10-29  
**维护者**：FormalScience Project  
**许可**：MIT
