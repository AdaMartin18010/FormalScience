# ç¬¦å·æ‰§è¡Œï¼ˆSymbolic Executionï¼‰

## 1 ğŸ“Š æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ

<details>
<summary><b>ğŸ­ğŸ”¬ ç‚¹å‡»å±•å¼€ï¼šç¬¦å·æ‰§è¡Œæ ¸å¿ƒæ´å¯Ÿ</b></summary>

**ç»ˆææ´å¯Ÿ**: ç¬¦å·æ‰§è¡Œ=ç”¨ç¬¦å·è€Œéå…·ä½“å€¼æ‰§è¡Œç¨‹åºã€‚åŸºæœ¬æ€æƒ³ï¼šâ‘ å˜é‡èµ‹ç¬¦å·å€¼Î±ã€Î²è€Œéå…·ä½“å€¼1ã€2â‘¡æ‰§è¡Œæ”¶é›†è·¯å¾„çº¦æŸï¼ˆPath Constraintï¼‰å¦‚Î±>0 âˆ§ Î±+Î²<100â‘¢åˆ†æ”¯æ—¶åˆ†è£‚çŠ¶æ€ï¼ˆForkï¼‰ï¼Œæ¯ä¸ªåˆ†æ”¯ç‹¬ç«‹æ‰§è¡Œâ‘£ç”¨SMTæ±‚è§£å™¨ï¼ˆZ3ï¼‰åˆ¤æ–­çº¦æŸå¯æ»¡è¶³æ€§â‘¤ç”Ÿæˆè§¦å‘æ¯æ¡è·¯å¾„çš„æµ‹è¯•ç”¨ä¾‹ã€‚ä¸‰å¤§å·¥å…·ï¼šâ‘ KLEEï¼ˆLLVMï¼‰ï¼šC/C++ç¬¦å·æ‰§è¡Œï¼Œå‘ç°GNU coreutils 56ä¸ªbugâ‘¡Kaniï¼ˆRustï¼‰ï¼šåŸºäºCBMCï¼ŒéªŒè¯unsafeä»£ç /å¹¶å‘/æº¢å‡ºâ‘¢Angrï¼ˆäºŒè¿›åˆ¶ï¼‰ï¼šæ— éœ€æºç ï¼Œé€†å‘å·¥ç¨‹/æ¼æ´æŒ–æ˜ã€‚æ ¸å¿ƒæŒ‘æˆ˜ï¼šâ‘ è·¯å¾„çˆ†ç‚¸ï¼šåˆ†æ”¯æ•°æŒ‡æ•°å¢é•¿â‘¡çº¦æŸå¤æ‚åº¦ï¼šSMTæ±‚è§£è¶…æ—¶â‘¢å†…å­˜/æŒ‡é’ˆå»ºæ¨¡ï¼šç¬¦å·åœ°å€â‘£ç¯å¢ƒäº¤äº’ï¼šç³»ç»Ÿè°ƒç”¨/æ–‡ä»¶/ç½‘ç»œã€‚ä¼˜åŒ–æŠ€æœ¯ï¼šâ‘ é€‰æ‹©æ€§ç¬¦å·æ‰§è¡Œï¼šåªç¬¦å·åŒ–å…³é”®å˜é‡â‘¡å¹¶å‘ç¬¦å·æ‰§è¡Œï¼šå¹¶è¡Œæ¢ç´¢è·¯å¾„â‘¢lazyçº¦æŸæ±‚è§£ï¼šå»¶è¿ŸSMTè°ƒç”¨â‘£æŠ½è±¡ï¼šè¿‡åº¦çº¦è¿‘ä¼¼å‡å°‘è·¯å¾„ã€‚ç¬¦å·æ‰§è¡Œvs Fuzzingï¼šç¬¦å·æ‰§è¡Œç²¾ç¡®ä½†æ…¢ï¼ˆç³»ç»Ÿæ€§è¦†ç›–ï¼‰ï¼ŒFuzzingå¿«é€Ÿä½†éšæœºï¼ˆç›²ç›®çªå˜ï¼‰ã€‚æ··åˆï¼šDrillerï¼ˆFuzzing+ç¬¦å·æ‰§è¡Œï¼‰ã€QSYMï¼ˆå¿«é€Ÿç¬¦å·æ‰§è¡Œï¼‰ã€‚åº”ç”¨ï¼šâ‘ æ¼æ´æ£€æµ‹ï¼šç¼“å†²åŒºæº¢å‡ºã€æ•´æ•°æº¢å‡ºã€UAFâ‘¡æµ‹è¯•ç”Ÿæˆï¼šé«˜è¦†ç›–ç‡è‡ªåŠ¨åŒ–æµ‹è¯•â‘¢ç­‰ä»·æ€§éªŒè¯ï¼šç¨‹åºä¼˜åŒ–æ­£ç¡®æ€§ã€‚å…³é”®ï¼šç¬¦å·æ‰§è¡Œå°†ç¨‹åºåˆ†æä»å…·ä½“æ‰§è¡Œç©ºé—´æå‡åˆ°ç¬¦å·ç©ºé—´ï¼Œç³»ç»Ÿæ€§æ¢ç´¢ç¨‹åºè¡Œä¸ºã€‚

</details>

---

## ğŸ“‹ ç›®å½•

- [ç¬¦å·æ‰§è¡Œï¼ˆSymbolic Executionï¼‰](#ç¬¦å·æ‰§è¡Œsymbolic-execution)
  - [1 ğŸ“Š æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ](#1-æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ)
  - [2 æ¦‚è¿°](#2-æ¦‚è¿°)
  - [1 . ç¬¦å·æ‰§è¡ŒåŸºç¡€](#1-ç¬¦å·æ‰§è¡ŒåŸºç¡€)
  - [1. ç¬¦å·æ‰§è¡ŒåŸºç¡€](#1-ç¬¦å·æ‰§è¡ŒåŸºç¡€)
    - [1.1 å½¢å¼åŒ–å®šä¹‰](#11-å½¢å¼åŒ–å®šä¹‰)
    - [1.2 ç¤ºä¾‹ï¼šç®€å•ç¨‹åº](#12-ç¤ºä¾‹ç®€å•ç¨‹åº)
  - [2 . KLEEï¼šLLVM ç¬¦å·æ‰§è¡Œå¼•æ“](#2-kleellvm-ç¬¦å·æ‰§è¡Œå¼•æ“)
    - [2.1 KLEE æ¶æ„](#21-klee-æ¶æ„)
    - [2.2 åŸºæœ¬ä½¿ç”¨](#22-åŸºæœ¬ä½¿ç”¨)
    - [2.3 æ£€æµ‹æ¼æ´](#23-æ£€æµ‹æ¼æ´)
    - [2.4 é«˜çº§ç‰¹æ€§](#24-é«˜çº§ç‰¹æ€§)
      - [1 è·¯å¾„é€‰æ‹©ç­–ç•¥](#1-è·¯å¾„é€‰æ‹©ç­–ç•¥)
      - [2 å¹¶å‘æ¢ç´¢](#2-å¹¶å‘æ¢ç´¢)
      - [3 ç¬¦å·åŒ–ç¯å¢ƒ](#3-ç¬¦å·åŒ–ç¯å¢ƒ)
  - [3 . Kaniï¼šRust ç¬¦å·éªŒè¯](#3-kanirust-ç¬¦å·éªŒè¯)
    - [3.1 Kani ç®€ä»‹](#31-kani-ç®€ä»‹)
    - [3.3 ä¿®å¤ï¼šä½¿ç”¨ checked_add](#33-ä¿®å¤ä½¿ç”¨-checked_add)
    - [3.4 éªŒè¯ unsafe ä»£ç ](#34-éªŒè¯-unsafe-ä»£ç )
    - [3.5 å¹¶å‘éªŒè¯](#35-å¹¶å‘éªŒè¯)
    - [3.5 å¹¶å‘éªŒè¯](#35-å¹¶å‘éªŒè¯)
  - [4 . Angrï¼šäºŒè¿›åˆ¶ç¬¦å·æ‰§è¡Œ](#4-angräºŒè¿›åˆ¶ç¬¦å·æ‰§è¡Œ)
    - [4.1 Angr æ¶æ„](#41-angr-æ¶æ„)
    - [4.3 CTF æŒ‘æˆ˜ï¼šåå‘å·¥ç¨‹](#43-ctf-æŒ‘æˆ˜åå‘å·¥ç¨‹)
    - [4.4 æ¼æ´æŒ–æ˜](#44-æ¼æ´æŒ–æ˜)
    - [4.4 æ¼æ´æŒ–æ˜](#44-æ¼æ´æŒ–æ˜)
  - [5 . å·¥å…·å¯¹æ¯”](#5-å·¥å…·å¯¹æ¯”)
    - [5.1 ä¸‰å¤§å·¥å…·æ¯”è¾ƒ](#51-ä¸‰å¤§å·¥å…·æ¯”è¾ƒ)
    - [5.2 é€‚ç”¨åœºæ™¯](#52-é€‚ç”¨åœºæ™¯)
  - [6 . é«˜çº§ä¸»é¢˜](#6-é«˜çº§ä¸»é¢˜)
    - [6.1 è·¯å¾„çˆ†ç‚¸ç¼“è§£](#61-è·¯å¾„çˆ†ç‚¸ç¼“è§£)
    - [6.2 çº¦æŸæ±‚è§£ä¼˜åŒ–](#62-çº¦æŸæ±‚è§£ä¼˜åŒ–)
    - [6.3 æ··åˆæ‰§è¡Œï¼ˆConcolic Executionï¼‰](#63-æ··åˆæ‰§è¡Œconcolic-execution)
  - [7 . å·¥ä¸šåº”ç”¨](#7-å·¥ä¸šåº”ç”¨)
    - [7.1 NASA ç«æ˜Ÿæ¢æµ‹å™¨](#71-nasa-ç«æ˜Ÿæ¢æµ‹å™¨)
    - [7.2 Amazon S3](#72-amazon-s3)
    - [7.3 å›½é˜²é«˜çº§ç ”ç©¶è®¡åˆ’å±€ï¼ˆDARPAï¼‰CGC](#73-å›½é˜²é«˜çº§ç ”ç©¶è®¡åˆ’å±€darpacgc)
  - [8 . å®æˆ˜æ¡ˆä¾‹ï¼šéªŒè¯æ’åºç®—æ³•](#8-å®æˆ˜æ¡ˆä¾‹éªŒè¯æ’åºç®—æ³•)
    - [8.1 ç”¨ KLEE éªŒè¯](#81-ç”¨-klee-éªŒè¯)
    - [8.2 ç”¨ Kani éªŒè¯](#82-ç”¨-kani-éªŒè¯)
  - [9 . å¤§å­¦è¯¾ç¨‹å¯¹åº”](#9-å¤§å­¦è¯¾ç¨‹å¯¹åº”)
  - [10 . æ•™æä¸è®ºæ–‡](#10-æ•™æä¸è®ºæ–‡)
    - [1 æ ¸å¿ƒè®ºæ–‡](#1-æ ¸å¿ƒè®ºæ–‡)
    - [10.2 æ¨èä¹¦ç±](#102-æ¨èä¹¦ç±)
  - [11 å¿«é€Ÿå‚è€ƒ](#11-å¿«é€Ÿå‚è€ƒ)
    - [1 æ ¸å¿ƒæ¦‚å¿µ](#1-æ ¸å¿ƒæ¦‚å¿µ)
    - [11.2 å·¥å…·é“¾é€ŸæŸ¥](#112-å·¥å…·é“¾é€ŸæŸ¥)
    - [11.3 å®æˆ˜å»ºè®®](#113-å®æˆ˜å»ºè®®)
  - [12 é™„å½• Aï¼šå®‰è£…æŒ‡å—](#12-é™„å½•-aå®‰è£…æŒ‡å—)
    - [1 KLEE (Docker)](#1-klee-docker)
    - [12.2 Kani](#122-kani)
    - [12.3 Angr](#123-angr)
  - [13 é™„å½• Bï¼šWikipedia æ¦‚å¿µå¯¹ç…§](#13-é™„å½•-bwikipedia-æ¦‚å¿µå¯¹ç…§)

---

## 2 æ¦‚è¿°

**ç¬¦å·æ‰§è¡Œ**æ˜¯ä¸€ç§ç¨‹åºåˆ†ææŠ€æœ¯ï¼Œç”¨**ç¬¦å·å€¼**è€Œé**å…·ä½“å€¼**æ‰§è¡Œç¨‹åºï¼Œä»è€Œç³»ç»Ÿåœ°æ¢ç´¢ç¨‹åºçš„æ‰€æœ‰æ‰§è¡Œè·¯å¾„ã€‚

**æ ¸å¿ƒæ€æƒ³**ï¼š

```text
ç¬¦å·æ‰§è¡Œ = è·¯å¾„æ¢ç´¢ + çº¦æŸæ±‚è§£

çŠ¶æ€ = âŸ¨PC, Ïƒ, Ï€âŸ©
  PC: ç¨‹åºè®¡æ•°å™¨
  Ïƒ:  ç¬¦å·çŠ¶æ€ï¼ˆå˜é‡ â†’ ç¬¦å·è¡¨è¾¾å¼ï¼‰
  Ï€:  è·¯å¾„æ¡ä»¶ï¼ˆå¸ƒå°”å…¬å¼ï¼‰

ç›®æ ‡ï¼š
  - è‡ªåŠ¨ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹
  - å‘ç°æ¼æ´ï¼ˆè¶Šç•Œã€ç©ºæŒ‡é’ˆã€æ•´æ•°æº¢å‡ºï¼‰
  - éªŒè¯æ–­è¨€
```

**ä¼˜åŠ¿**ï¼š

- **é«˜è¦†ç›–ç‡**ï¼šç³»ç»Ÿæ¢ç´¢æ‰€æœ‰è·¯å¾„
- **ç²¾ç¡®æ€§**ï¼šæ— è¯¯æŠ¥ï¼ˆFalse Positiveï¼‰
- **è‡ªåŠ¨åŒ–**ï¼šæ— éœ€æ‰‹å·¥ç¼–å†™æµ‹è¯•

**æŒ‘æˆ˜**ï¼š

- **è·¯å¾„çˆ†ç‚¸**ï¼šè·¯å¾„æ•°æŒ‡æ•°å¢é•¿
- **çº¦æŸæ±‚è§£**ï¼šSMT æ±‚è§£å™¨æ€§èƒ½ç“¶é¢ˆ
- **ç¯å¢ƒå»ºæ¨¡**ï¼šç³»ç»Ÿè°ƒç”¨ã€å¤–éƒ¨åº“

---

## 1 . ç¬¦å·æ‰§è¡ŒåŸºç¡€

### 1.1 å½¢å¼åŒ–å®šä¹‰

**ç¬¦å·çŠ¶æ€**ï¼š

```text
Ïƒ : Var â†’ SymExpr
Ï€ : List<BoolExpr>

SymExpr ::= Const | Var | SymExpr âŠ• SymExpr
BoolExpr ::= SymExpr âŠ™ SymExpr
```

**è¯­ä¹‰è§„åˆ™**ï¼š

```text
âŸ¨x = e, Ïƒ, Ï€âŸ© â‡ âŸ¨skip, Ïƒ[x â†¦ eval(e, Ïƒ)], Ï€âŸ©

âŸ¨if (b) S1 else S2, Ïƒ, Ï€âŸ© â‡ {
  âŸ¨S1, Ïƒ, Ï€ âˆ§ eval(b, Ïƒ)âŸ©      (then åˆ†æ”¯)
  âŸ¨S2, Ïƒ, Ï€ âˆ§ Â¬eval(b, Ïƒ)âŸ©     (else åˆ†æ”¯)
}

âŸ¨assert(P), Ïƒ, Ï€âŸ© â‡ {
  âŸ¨skip, Ïƒ, Ï€âŸ©                   if Ï€ âˆ§ eval(P, Ïƒ) is SAT
  Error                          if Ï€ âˆ§ Â¬eval(P, Ïƒ) is SAT
}
```

### 1.2 ç¤ºä¾‹ï¼šç®€å•ç¨‹åº

**æºä»£ç **ï¼š

```c
void foo(int x, int y) {
    int z = x + y;
    if (z > 100) {
        assert(x > 50 || y > 50);  // å®‰å…¨å—ï¼Ÿ
    }
}
```

**ç¬¦å·æ‰§è¡Œæ ‘**ï¼š

```text
åˆå§‹çŠ¶æ€: Ïƒ = {x â†’ Î±, y â†’ Î²}, Ï€ = true

z = x + y:
  Ïƒ = {x â†’ Î±, y â†’ Î², z â†’ Î± + Î²}, Ï€ = true

if (z > 100):
  åˆ†æ”¯1 (then): Ï€ = Î± + Î² > 100
    assert(x > 50 || y > 50):
      æ£€æŸ¥: Ï€ âˆ§ Â¬(Î± > 50 âˆ¨ Î² > 50) is SAT?
      åä¾‹: Î± = 51, Î² = 50  âœ“ (æ–­è¨€æˆç«‹)

  åˆ†æ”¯2 (else): Ï€ = Î± + Î² â‰¤ 100
    ï¼ˆæ— æ“ä½œï¼‰
```

**ç»“è®º**ï¼šæ–­è¨€åœ¨æ‰€æœ‰è·¯å¾„ä¸Šéƒ½æˆç«‹ã€‚

---

## 2 . KLEEï¼šLLVM ç¬¦å·æ‰§è¡Œå¼•æ“

### 2.1 KLEE æ¶æ„

**å·¥ä½œæµç¨‹**ï¼š

```text
C/C++ æºç  â†’ Clang â†’ LLVM IR â†’ KLEE â†’ æµ‹è¯•ç”¨ä¾‹
                                   â†“
                               SMT Solver (STP/Z3)
```

**æ ¸å¿ƒç»„ä»¶**ï¼š

- **Executor**ï¼šè§£é‡Šæ‰§è¡Œ LLVM IR
- **Memory Model**ï¼šç¬¦å·å†…å­˜ç®¡ç†
- **Searcher**ï¼šè·¯å¾„é€‰æ‹©ç­–ç•¥ï¼ˆDFS, BFS, Randomï¼‰
- **Solver**ï¼šçº¦æŸæ±‚è§£ï¼ˆSTP, Z3ï¼‰

### 2.2 åŸºæœ¬ä½¿ç”¨

**ç¤ºä¾‹ç¨‹åº**ï¼ˆ`get_sign.c`ï¼‰ï¼š

```c
#include <klee/klee.h>

int get_sign(int x) {
  if (x == 0)
     return 0;
  if (x < 0)
     return -1;
  else
     return 1;
}

int main() {
  int a;
  klee_make_symbolic(&a, sizeof(a), "a");
  return get_sign(a);
}
```

**ç¼–è¯‘ä¸è¿è¡Œ**ï¼š

```bash
# ç¼–è¯‘ä¸º LLVM IR
clang -I /path/to/klee/include -emit-llvm -c -g get_sign.c -o get_sign.bc

# è¿è¡Œ KLEE
klee get_sign.bc
```

**è¾“å‡º**ï¼š

```text
KLEE: output directory = "klee-out-0"
KLEE: done: total instructions = 33
KLEE: done: completed paths = 3
KLEE: done: generated tests = 3
```

**ç”Ÿæˆçš„æµ‹è¯•ç”¨ä¾‹**ï¼š

```bash
ktest-tool klee-last/test000001.ktest
# object 0: name: 'a'
# object 0: size: 4
# object 0: data: b'\x00\x00\x00\x00'  (a = 0)

ktest-tool klee-last/test000002.ktest
# object 0: data: b'\xff\xff\xff\xff'  (a = -1)

ktest-tool klee-last/test000003.ktest
# object 0: data: b'\x01\x00\x00\x00'  (a = 1)
```

### 2.3 æ£€æµ‹æ¼æ´

**è¶Šç•Œè®¿é—®**ï¼ˆ`buffer.c`ï¼‰ï¼š

```c
#include <klee/klee.h>

void buggy(int i) {
  int arr[10];
  arr[i] = 42;  // å¯èƒ½è¶Šç•Œ
}

int main() {
  int index;
  klee_make_symbolic(&index, sizeof(index), "index");
  buggy(index);
  return 0;
}
```

**è¿è¡Œ**ï¼š

```bash
clang -emit-llvm -c -g buffer.c -o buffer.bc
klee buffer.bc
```

**è¾“å‡º**ï¼š

```text
KLEE: ERROR: buffer.c:5: memory error: out of bound pointer
KLEE: NOTE: now ignoring this error at this location
```

**æŸ¥çœ‹é”™è¯¯è¾“å…¥**ï¼š

```bash
ktest-tool klee-last/*.err.ktest
# index = 10 æˆ– -1
```

### 2.4 é«˜çº§ç‰¹æ€§

#### 1 è·¯å¾„é€‰æ‹©ç­–ç•¥

```bash
klee --search=dfs program.bc       # æ·±åº¦ä¼˜å…ˆ
klee --search=bfs program.bc       # å¹¿åº¦ä¼˜å…ˆ
klee --search=random-path program.bc  # éšæœº
klee --search=nurs:covnew program.bc  # è¦†ç›–ç‡å¯¼å‘
```

#### 2 å¹¶å‘æ¢ç´¢

```bash
klee --use-forked-solver=true program.bc
```

#### 3 ç¬¦å·åŒ–ç¯å¢ƒ

```c
// ç¬¦å·åŒ–å‘½ä»¤è¡Œå‚æ•°
int main(int argc, char *argv[]) {
  klee_make_symbolic(&argc, sizeof(argc), "argc");
  klee_make_symbolic(argv, sizeof(argv), "argv");
  // ...
}
```

---

## 3 . Kaniï¼šRust ç¬¦å·éªŒè¯

### 3.1 Kani ç®€ä»‹

**Kani** æ˜¯ Amazon å¼€å‘çš„ Rust ç¬¦å·éªŒè¯å·¥å…·ï¼ŒåŸºäº **CBMC**ï¼ˆC Bounded Model Checkerï¼‰ã€‚

**ç‰¹ç‚¹**ï¼š

- **Rust åŸç”Ÿ**ï¼šæ·±åº¦é›†æˆ Rust ç±»å‹ç³»ç»Ÿ
- **æ‰€æœ‰æƒéªŒè¯**ï¼šæ£€æŸ¥å€Ÿç”¨è§„åˆ™
- **æ—  unsafe**ï¼šéªŒè¯ unsafe ä»£ç çš„å®‰å…¨æ€§
- **å¹¶å‘**ï¼šéªŒè¯å¤šçº¿ç¨‹ä»£ç 

**å®˜ç½‘**ï¼š<https://model-checking.github.io/kani/>

### 3.2 åŸºæœ¬ä½¿ç”¨

**å®‰è£…**ï¼š

```bash
cargo install --locked kani-verifier
cargo kani setup
```

**ç¤ºä¾‹**ï¼ˆ`sum.rs`ï¼‰ï¼š

```rust
fn sum(a: u32, b: u32) -> u32 {
    a + b
}

#[cfg(kani)]
#[kani::proof]
fn verify_sum() {
    let a: u32 = kani::any();
    let b: u32 = kani::any();
    let result = sum(a, b);
    assert!(result >= a);  // ä¼šæº¢å‡ºå—ï¼Ÿ
}
```

**è¿è¡ŒéªŒè¯**ï¼š

```bash
cargo kani
```

**è¾“å‡º**ï¼š

```text
VERIFICATION:- FAILED
Check 1: assertion failed: result >= a
 --> src/main.rs:8:5

Counterexample:
  a = 4294967295
  b = 1
  result = 0  (æº¢å‡ºï¼)
```

### 3.3 ä¿®å¤ï¼šä½¿ç”¨ checked_add

```rust
fn sum_safe(a: u32, b: u32) -> Option<u32> {
    a.checked_add(b)
}

#[cfg(kani)]
#[kani::proof]
fn verify_sum_safe() {
    let a: u32 = kani::any();
    let b: u32 = kani::any();
    match sum_safe(a, b) {
        Some(result) => assert!(result >= a && result >= b),
        None => assert!(a as u64 + b as u64 > u32::MAX as u64),
    }
}
```

**éªŒè¯é€šè¿‡**ï¼š

```text
VERIFICATION:- SUCCESSFUL
```

### 3.4 éªŒè¯ unsafe ä»£ç 

**ç¤ºä¾‹**ï¼ˆæ‰‹åŠ¨å®ç° Vecï¼‰ï¼š

```rust
struct MyVec<T> {
    ptr: *mut T,
    len: usize,
    cap: usize,
}

impl<T> MyVec<T> {
    fn push(&mut self, value: T) {
        assert!(self.len < self.cap);
        unsafe {
            std::ptr::write(self.ptr.add(self.len), value);
        }
        self.len += 1;
    }
}

#[cfg(kani)]
#[kani::proof]
fn verify_push() {
    let mut v: MyVec<u32> = kani::any();
    kani::assume(v.len < v.cap);
    kani::assume(!v.ptr.is_null());
    v.push(42);
    assert!(v.len <= v.cap);  // ä¸å˜å¼
}
```

### 3.5 å¹¶å‘éªŒè¯

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};

#[cfg(kani)]
#[kani::proof]
#[kani::unwind(3)]
fn verify_atomic_increment() {
    let counter = Arc::new(AtomicUsize::new(0));
    let c1 = counter.clone();
    let c2 = counter.clone();

    std::thread::scope(|s| {
        s.spawn(|| c1.fetch_add(1, Ordering::SeqCst));
        s.spawn(|| c2.fetch_add(1, Ordering::SeqCst));
    });

    assert!(counter.load(Ordering::SeqCst) == 2);
}
```

---

## 4 . Angrï¼šäºŒè¿›åˆ¶ç¬¦å·æ‰§è¡Œ

### 4.1 Angr æ¶æ„

**Angr** æ˜¯ Python æ¡†æ¶ï¼Œç”¨äº**äºŒè¿›åˆ¶ç¨‹åº**çš„ç¬¦å·æ‰§è¡Œå’ŒåŠ¨æ€åˆ†æã€‚

**ç‰¹ç‚¹**ï¼š

- **æ— éœ€æºç **ï¼šç›´æ¥åˆ†æäºŒè¿›åˆ¶
- **å¤šæ¶æ„**ï¼šx86, ARM, MIPS, PowerPC
- **åæ··æ·†**ï¼šå¤„ç†åŠ å£³ã€æ··æ·†ä»£ç 
- **æ¼æ´æŒ–æ˜**ï¼šCTFã€æ¶æ„è½¯ä»¶åˆ†æ

**å®˜ç½‘**ï¼š<https://angr.io/>

### 4.2 åŸºæœ¬ä½¿ç”¨

**å®‰è£…**ï¼š

```bash
pip install angr
```

**ç¤ºä¾‹ç¨‹åº**ï¼ˆ`simple.c`ï¼‰ï¼š

```c
#include <stdio.h>
#include <string.h>

int main() {
  char password[10];
  printf("Enter password: ");
  scanf("%9s", password);
  if (strcmp(password, "secret") == 0) {
    printf("Access granted!\n");
  } else {
    printf("Access denied.\n");
  }
  return 0;
}
```

**ç¼–è¯‘**ï¼š

```bash
gcc simple.c -o simple
```

**Angr è„šæœ¬**ï¼ˆ`solve.py`ï¼‰ï¼š

```python
import angr
import claripy

# åŠ è½½äºŒè¿›åˆ¶
project = angr.Project('simple', auto_load_libs=False)

# åˆ›å»ºç¬¦å·å˜é‡
password = claripy.BVS('password', 9 * 8)  # 9 å­—èŠ‚

# è®¾ç½®åˆå§‹çŠ¶æ€
initial_state = project.factory.entry_state(
    args=['./simple'],
    stdin=password
)

# æ·»åŠ çº¦æŸï¼šåªå…è®¸å¯æ‰“å°å­—ç¬¦
for byte in password.chop(8):
    initial_state.solver.add(byte >= ord(' '))
    initial_state.solver.add(byte <= ord('~'))

# åˆ›å»ºæ¨¡æ‹Ÿç®¡ç†å™¨
simgr = project.factory.simulation_manager(initial_state)

# æŸ¥æ‰¾ç›®æ ‡åœ°å€ï¼ˆ"Access granted" çš„ä½ç½®ï¼‰
target_addr = 0x401180  # ä½¿ç”¨ objdump æˆ– IDA æ‰¾åˆ°
avoid_addr = 0x4011a0   # "Access denied"

simgr.explore(find=target_addr, avoid=avoid_addr)

# è·å–è§£
if simgr.found:
    found_state = simgr.found[0]
    solution = found_state.solver.eval(password, cast_to=bytes)
    print(f"Password: {solution.decode()}")
else:
    print("No solution found")
```

**è¿è¡Œ**ï¼š

```bash
python solve.py
# Password: secret
```

### 4.3 CTF æŒ‘æˆ˜ï¼šåå‘å·¥ç¨‹

**ç›®æ ‡**ï¼šç ´è§£ä¸€ä¸ªæ£€æŸ¥åºåˆ—å·çš„ç¨‹åº

**äºŒè¿›åˆ¶**ï¼š`crackme`ï¼ˆæ— æºç ï¼‰

**Angr è„šæœ¬**ï¼š

```python
import angr
import claripy

project = angr.Project('crackme')

# åˆ›å»ºç¬¦å·ä¸²ï¼ˆ32 å­—èŠ‚ï¼‰
serial = claripy.BVS('serial', 32 * 8)

initial_state = project.factory.entry_state(
    args=['./crackme'],
    stdin=serial
)

# çº¦æŸï¼š16 è¿›åˆ¶å­—ç¬¦
for byte in serial.chop(8):
    initial_state.solver.add(
        claripy.Or(
            claripy.And(byte >= ord('0'), byte <= ord('9')),
            claripy.And(byte >= ord('A'), byte <= ord('F'))
        )
    )

simgr = project.factory.simulation_manager(initial_state)

# æŸ¥æ‰¾"Correct!"å­—ç¬¦ä¸²çš„åœ°å€
def is_successful(state):
    return b'Correct!' in state.posix.dumps(1)

def should_abort(state):
    return b'Wrong!' in state.posix.dumps(1)

simgr.explore(find=is_successful, avoid=should_abort)

if simgr.found:
    solution = simgr.found[0].solver.eval(serial, cast_to=bytes)
    print(f"Serial: {solution.decode()}")
```

### 4.4 æ¼æ´æŒ–æ˜

**ç¤ºä¾‹**ï¼šæ£€æµ‹æ ˆæº¢å‡º

```python
import angr

project = angr.Project('vuln_program')
cfg = project.analyses.CFGFast()

# æŸ¥æ‰¾å¯èƒ½çš„ç¼“å†²åŒºæº¢å‡º
for func in cfg.functions.values():
    for block in func.blocks:
        if 'strcpy' in block.disassembly:
            print(f"Potential buffer overflow at {hex(block.addr)}")
```

---

## 5 . å·¥å…·å¯¹æ¯”

### 5.1 ä¸‰å¤§å·¥å…·æ¯”è¾ƒ

| ç»´åº¦ | KLEE | Kani | Angr |
|------|------|------|------|
| **è¾“å…¥** | LLVM IR (C/C++) | Rust MIR | äºŒè¿›åˆ¶ |
| **SMT æ±‚è§£å™¨** | STP, Z3 | CBMC | Z3, CVC4 |
| **è·¯å¾„æ¢ç´¢** | é«˜æ•ˆ | æœ‰ç•Œ | æ…¢ï¼ˆäºŒè¿›åˆ¶ï¼‰ |
| **å¹¶å‘æ”¯æŒ** | æœ‰é™ | å¼ºï¼ˆRustï¼‰ | æœ‰é™ |
| **åº”ç”¨åœºæ™¯** | ç³»ç»Ÿè½¯ä»¶ | Rust ç”Ÿæ€ | é€†å‘å·¥ç¨‹ |
| **å­¦ä¹ æ›²çº¿** | ä¸­ | ä½ï¼ˆRust ç”¨æˆ·ï¼‰ | é«˜ |

### 5.2 é€‚ç”¨åœºæ™¯

**KLEE**ï¼š

- âœ… C/C++ ç³»ç»Ÿè½¯ä»¶
- âœ… æ“ä½œç³»ç»Ÿã€é©±åŠ¨
- âœ… åµŒå…¥å¼å›ºä»¶
- âŒ å¤æ‚ C++ ç‰¹æ€§ï¼ˆè™šå‡½æ•°ã€å¼‚å¸¸ï¼‰

**Kani**ï¼š

- âœ… Rust é¡¹ç›®ï¼ˆå°¤å…¶ unsafe ä»£ç ï¼‰
- âœ… åŠ å¯†åº“ã€ç½‘ç»œåè®®
- âœ… å¹¶å‘ç®—æ³•
- âŒ é Rust ä»£ç 

**Angr**ï¼š

- âœ… é€†å‘å·¥ç¨‹
- âœ… CTF æ¯”èµ›
- âœ… æ¶æ„è½¯ä»¶åˆ†æ
- âŒ æ€§èƒ½æ•æ„Ÿä»»åŠ¡ï¼ˆæ…¢ï¼‰

---

## 6 . é«˜çº§ä¸»é¢˜

### 6.1 è·¯å¾„çˆ†ç‚¸ç¼“è§£

**æŠ€æœ¯ 1ï¼šè·¯å¾„åˆå¹¶ï¼ˆPath Mergingï¼‰**:

```text
if (x > 0) y = 1; else y = 2;

å¸¸è§„ç¬¦å·æ‰§è¡Œï¼š2 ä¸ªçŠ¶æ€
è·¯å¾„åˆå¹¶ï¼š1 ä¸ªçŠ¶æ€ï¼Œy = ite(x > 0, 1, 2)
```

**KLEE ä¸­å¯ç”¨**ï¼š

```bash
klee --use-merge program.bc
```

**æŠ€æœ¯ 2ï¼šå‡½æ•°æ‘˜è¦ï¼ˆFunction Summariesï¼‰**:

```c
int sqrt(int x);  // ä¸å±•å¼€ï¼Œç”¨æ‘˜è¦æ›¿ä»£
```

**æŠ€æœ¯ 3ï¼šå¾ªç¯ç•Œé™ï¼ˆLoop Unrolling Boundï¼‰**:

```bash
klee --max-loop-iterations=10 program.bc
```

### 6.2 çº¦æŸæ±‚è§£ä¼˜åŒ–

**å¢é‡æ±‚è§£ï¼ˆIncremental Solvingï¼‰**ï¼š

```text
Ï€â‚ = x > 0
Ï€â‚‚ = Ï€â‚ âˆ§ y < 10

å¤ç”¨ Ï€â‚ çš„æ±‚è§£ç»“æœ
```

**æ±‚è§£å™¨ç¼“å­˜ï¼ˆSolver Cachingï¼‰**ï¼š

```bash
klee --use-cache program.bc
```

### 6.3 æ··åˆæ‰§è¡Œï¼ˆConcolic Executionï¼‰

**å®šä¹‰**ï¼šå…·ä½“æ‰§è¡Œ + ç¬¦å·æ‰§è¡Œ

```text
åˆå§‹è¾“å…¥ï¼šå…·ä½“å€¼ vâ‚€
æ‰§è¡Œï¼šè®°å½•è·¯å¾„æ¡ä»¶ Ï€
å˜å¼‚ï¼šä¿®æ”¹çº¦æŸæ±‚è§£æ–°è¾“å…¥ vâ‚
è¿­ä»£ï¼šæé«˜è¦†ç›–ç‡
```

**å·¥å…·**ï¼š

- **DART**ï¼ˆMicrosoftï¼‰
- **SAGE**ï¼ˆMicrosoftï¼Œå‘ç° Windows bugï¼‰
- **AFL + SymCC**ï¼ˆæ··åˆ fuzzing + ç¬¦å·æ‰§è¡Œï¼‰

---

## 7 . å·¥ä¸šåº”ç”¨

### 7.1 NASA ç«æ˜Ÿæ¢æµ‹å™¨

**å·¥å…·**ï¼šKLEE

**æˆæœ**ï¼š

- éªŒè¯ Curiosity ç«æ˜Ÿè½¦çš„æ–‡ä»¶ç³»ç»Ÿ
- å‘ç° 10+ ä¸¥é‡ bug
- 100% ä»£ç è¦†ç›–ç‡

### 7.2 Amazon S3

**å·¥å…·**ï¼šKani

**åº”ç”¨**ï¼š

- éªŒè¯ S3 åŠ å¯†æ¨¡å—
- ç¡®ä¿ unsafe ä»£ç å®‰å…¨
- æŒç»­é›†æˆä¸­è¿è¡Œ

### 7.3 å›½é˜²é«˜çº§ç ”ç©¶è®¡åˆ’å±€ï¼ˆDARPAï¼‰CGC

**æ¯”èµ›**ï¼šCyber Grand Challenge

**è·èƒœè€…**ï¼šä½¿ç”¨ Angr çš„ Mayhem ç³»ç»Ÿ

**æˆå°±**ï¼š

- è‡ªåŠ¨å‘ç°æ¼æ´
- è‡ªåŠ¨ç”Ÿæˆè¡¥ä¸
- å‡»è´¥äººç±»å®‰å…¨ä¸“å®¶

---

## 8 . å®æˆ˜æ¡ˆä¾‹ï¼šéªŒè¯æ’åºç®—æ³•

### 8.1 ç”¨ KLEE éªŒè¯

```c
#include <klee/klee.h>

void bubble_sort(int *arr, int n) {
  for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j+1]) {
        int temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
      }
    }
  }
}

int is_sorted(int *arr, int n) {
  for (int i = 0; i < n - 1; i++) {
    if (arr[i] > arr[i+1]) return 0;
  }
  return 1;
}

int main() {
  int arr[5];
  klee_make_symbolic(arr, sizeof(arr), "arr");

  bubble_sort(arr, 5);

  klee_assert(is_sorted(arr, 5));
  return 0;
}
```

**éªŒè¯**ï¼š

```bash
clang -emit-llvm -c -g bubble_sort.c -o bubble_sort.bc
klee bubble_sort.bc
# VERIFICATION SUCCESSFUL
```

### 8.2 ç”¨ Kani éªŒè¯

```rust
fn bubble_sort(arr: &mut [i32]) {
    let n = arr.len();
    for i in 0..n {
        for j in 0..n - i - 1 {
            if arr[j] > arr[j + 1] {
                arr.swap(j, j + 1);
            }
        }
    }
}

#[cfg(kani)]
#[kani::proof]
#[kani::unwind(6)]  // æ•°ç»„é•¿åº¦ â‰¤ 5
fn verify_bubble_sort() {
    let mut arr: [i32; 5] = kani::any();
    bubble_sort(&mut arr);

    // éªŒè¯æœ‰åºæ€§
    for i in 0..arr.len() - 1 {
        assert!(arr[i] <= arr[i + 1]);
    }
}
```

---

## 9 . å¤§å­¦è¯¾ç¨‹å¯¹åº”

| è¯¾ç¨‹ | ç›¸å…³ç« èŠ‚ |
|------|----------|
| **CMU 15-414 Bug Catching** | KLEE, ç¬¦å·æ‰§è¡Œç†è®º |
| **Berkeley CS 294 Program Analysis** | ç¬¦å·æ‰§è¡Œã€æ··åˆæ‰§è¡Œ |
| **MIT 6.858 Computer Security** | Angr, æ¼æ´æŒ–æ˜ |
| **Stanford CS 155 å®‰å…¨** | é€†å‘å·¥ç¨‹ã€äºŒè¿›åˆ¶åˆ†æ |

---

## 10 . æ•™æä¸è®ºæ–‡

### 1 æ ¸å¿ƒè®ºæ–‡

1. **KLEE**ï¼š
   - Cadar, C., Dunbar, D., & Engler, D. (2008). _KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs_. OSDI 2008.

2. **æ··åˆæ‰§è¡Œ**ï¼š
   - Godefroid, P., Klarlund, N., & Sen, K. (2005). _DART: Directed Automated Random Testing_. PLDI 2005.

3. **Angr**ï¼š
   - Shoshitaishvili, Y., et al. (2016). _SoK: (State of) The Art of War: Offensive Techniques in Binary Analysis_. S&P 2016.

### 10.2 æ¨èä¹¦ç±

- _The Art of Software Security Assessment_ (Dowd et al.)
- _Fuzzing for Software Security Testing and Quality Assurance_ (Takanen et al.)

---

## 11 å¿«é€Ÿå‚è€ƒ

### 1 æ ¸å¿ƒæ¦‚å¿µ

```text
ç¬¦å·æ‰§è¡Œ = è·¯å¾„æ¢ç´¢ + çº¦æŸæ±‚è§£

çŠ¶æ€ï¼šâŸ¨PC, Ïƒ, Ï€âŸ©
  Ïƒ: å˜é‡ â†’ ç¬¦å·è¡¨è¾¾å¼
  Ï€: è·¯å¾„æ¡ä»¶ï¼ˆç§¯ç´¯çš„åˆ†æ”¯çº¦æŸï¼‰

åˆ†æ”¯ï¼š
  if (cond) S1 else S2
  â†’ åˆ†è£‚ä¸ºä¸¤ä¸ªçŠ¶æ€ï¼šÏ€ âˆ§ cond å’Œ Ï€ âˆ§ Â¬cond

éªŒè¯ï¼š
  assert(P) â‡’ æ£€æŸ¥ Ï€ âˆ§ Â¬P æ˜¯å¦ UNSAT
```

### 11.2 å·¥å…·é“¾é€ŸæŸ¥

```bash
# KLEE
clang -emit-llvm -c -g program.c -o program.bc
klee program.bc

# Kani
cargo kani

# Angr
python solve.py
```

### 11.3 å®æˆ˜å»ºè®®

1. **KLEE å…¥é—¨**ï¼šä» get_sign ç¤ºä¾‹å¼€å§‹
2. **Kani å®è·µ**ï¼šéªŒè¯è‡ªå·±çš„ Rust é¡¹ç›®
3. **Angr è¿›é˜¶**ï¼šå‚åŠ  CTF ç»ƒä¹ é€†å‘
4. **æ··åˆå·¥å…·**ï¼šAFL + SymCC ç»„åˆä½¿ç”¨

---

## 12 é™„å½• Aï¼šå®‰è£…æŒ‡å—

### 1 KLEE (Docker)

```bash
docker pull klee/klee:latest
docker run --rm -ti --ulimit='stack=-1:-1' klee/klee
```

### 12.2 Kani

```bash
cargo install --locked kani-verifier
cargo kani setup
```

### 12.3 Angr

```bash
pip install angr angr-management
```

---

## 13 é™„å½• Bï¼šWikipedia æ¦‚å¿µå¯¹ç…§

| æ¦‚å¿µ | Wikipedia æ¡ç›® | æœ¬æ–‡ç« èŠ‚ |
|------|----------------|----------|
| Symbolic Execution | <https://en.wikipedia.org/wiki/Symbolic_execution> | Â§1 |
| KLEE | <https://klee.github.io/> | Â§2 |
| CBMC | <https://en.wikipedia.org/wiki/C_Bounded_Model_Checker> | Â§3.1 |
| Angr | <https://angr.io/> | Â§4 |
| Concolic Testing | <https://en.wikipedia.org/wiki/Concolic_testing> | Â§6.3 |

---

**ç‰ˆæœ¬**ï¼šv1.0
**æœ€åæ›´æ–°**ï¼š2025-10-29
**ç»´æŠ¤è€…**ï¼šFormalScience Project
**è®¸å¯**ï¼šCC BY-SA 4.0
