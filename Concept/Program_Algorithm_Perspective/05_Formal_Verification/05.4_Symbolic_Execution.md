# 符号执行（Symbolic Execution）

## 📊 核心概念深度分析

<details>
<summary><b>🎭🔬 点击展开：符号执行核心洞察</b></summary>

**终极洞察**: 符号执行=用符号而非具体值执行程序。基本思想：①变量赋符号值α、β而非具体值1、2②执行收集路径约束（Path Constraint）如α>0 ∧ α+β<100③分支时分裂状态（Fork），每个分支独立执行④用SMT求解器（Z3）判断约束可满足性⑤生成触发每条路径的测试用例。三大工具：①KLEE（LLVM）：C/C++符号执行，发现GNU coreutils 56个bug②Kani（Rust）：基于CBMC，验证unsafe代码/并发/溢出③Angr（二进制）：无需源码，逆向工程/漏洞挖掘。核心挑战：①路径爆炸：分支数指数增长②约束复杂度：SMT求解超时③内存/指针建模：符号地址④环境交互：系统调用/文件/网络。优化技术：①选择性符号执行：只符号化关键变量②并发符号执行：并行探索路径③lazy约束求解：延迟SMT调用④抽象：过度约近似减少路径。符号执行vs Fuzzing：符号执行精确但慢（系统性覆盖），Fuzzing快速但随机（盲目突变）。混合：Driller（Fuzzing+符号执行）、QSYM（快速符号执行）。应用：①漏洞检测：缓冲区溢出、整数溢出、UAF②测试生成：高覆盖率自动化测试③等价性验证：程序优化正确性。关键：符号执行将程序分析从具体执行空间提升到符号空间，系统性探索程序行为。

</details>

---

## 📋 目录

- [概述](#概述)
- [1. 符号执行基础](#1-符号执行基础)
  - [1.1 形式化定义](#11-形式化定义)
  - [1.2 示例：简单程序](#12-示例简单程序)
- [2. KLEE：LLVM 符号执行引擎](#2-kleellvm-符号执行引擎)
  - [2.1 KLEE 架构](#21-klee-架构)
  - [2.2 基本使用](#22-基本使用)
  - [2.3 检测漏洞](#23-检测漏洞)
  - [2.4 高级特性](#24-高级特性)
- [3. Kani：Rust 符号验证](#3-kanirust-符号验证)
  - [3.1 Kani 简介](#31-kani-简介)
  - [3.2 基本使用](#32-基本使用)
  - [3.3 修复：使用 checked_add](#33-修复使用-checked_add)
  - [3.4 验证 unsafe 代码](#34-验证-unsafe-代码)
  - [3.5 并发验证](#35-并发验证)
- [4. Angr：二进制符号执行](#4-angr二进制符号执行)
- [5. 符号执行优化技术](#5-符号执行优化技术)
- [6. 符号执行 vs Fuzzing](#6-符号执行-vs-fuzzing)
- [7. 工业应用](#7-工业应用)
- [8. 实战案例：验证排序算法](#8-实战案例验证排序算法)
- [9. 大学课程对应](#9-大学课程对应)
- [10. 教材与论文](#10-教材与论文)

---

## 概述

**符号执行**是一种程序分析技术，用**符号值**而非**具体值**执行程序，从而系统地探索程序的所有执行路径。

**核心思想**：

```text
符号执行 = 路径探索 + 约束求解

状态 = ⟨PC, σ, π⟩
  PC: 程序计数器
  σ:  符号状态（变量 → 符号表达式）
  π:  路径条件（布尔公式）

目标：
  - 自动生成测试用例
  - 发现漏洞（越界、空指针、整数溢出）
  - 验证断言
```

**优势**：

- **高覆盖率**：系统探索所有路径
- **精确性**：无误报（False Positive）
- **自动化**：无需手工编写测试

**挑战**：

- **路径爆炸**：路径数指数增长
- **约束求解**：SMT 求解器性能瓶颈
- **环境建模**：系统调用、外部库

---

## 1. 符号执行基础

### 1.1 形式化定义

**符号状态**：

```text
σ : Var → SymExpr
π : List<BoolExpr>

SymExpr ::= Const | Var | SymExpr ⊕ SymExpr
BoolExpr ::= SymExpr ⊙ SymExpr
```

**语义规则**：

```text
⟨x = e, σ, π⟩ ⇝ ⟨skip, σ[x ↦ eval(e, σ)], π⟩

⟨if (b) S1 else S2, σ, π⟩ ⇝ {
  ⟨S1, σ, π ∧ eval(b, σ)⟩      (then 分支)
  ⟨S2, σ, π ∧ ¬eval(b, σ)⟩     (else 分支)
}

⟨assert(P), σ, π⟩ ⇝ {
  ⟨skip, σ, π⟩                   if π ∧ eval(P, σ) is SAT
  Error                          if π ∧ ¬eval(P, σ) is SAT
}
```

### 1.2 示例：简单程序

**源代码**：

```c
void foo(int x, int y) {
    int z = x + y;
    if (z > 100) {
        assert(x > 50 || y > 50);  // 安全吗？
    }
}
```

**符号执行树**：

```text
初始状态: σ = {x → α, y → β}, π = true

z = x + y:
  σ = {x → α, y → β, z → α + β}, π = true

if (z > 100):
  分支1 (then): π = α + β > 100
    assert(x > 50 || y > 50):
      检查: π ∧ ¬(α > 50 ∨ β > 50) is SAT?
      反例: α = 51, β = 50  ✓ (断言成立)
  
  分支2 (else): π = α + β ≤ 100
    （无操作）
```

**结论**：断言在所有路径上都成立。

---

## 2. KLEE：LLVM 符号执行引擎

### 2.1 KLEE 架构

**工作流程**：

```text
C/C++ 源码 → Clang → LLVM IR → KLEE → 测试用例
                                   ↓
                               SMT Solver (STP/Z3)
```

**核心组件**：

- **Executor**：解释执行 LLVM IR
- **Memory Model**：符号内存管理
- **Searcher**：路径选择策略（DFS, BFS, Random）
- **Solver**：约束求解（STP, Z3）

### 2.2 基本使用

**示例程序**（`get_sign.c`）：

```c
#include <klee/klee.h>

int get_sign(int x) {
  if (x == 0)
     return 0;
  if (x < 0)
     return -1;
  else
     return 1;
}

int main() {
  int a;
  klee_make_symbolic(&a, sizeof(a), "a");
  return get_sign(a);
}
```

**编译与运行**：

```bash
# 编译为 LLVM IR
clang -I /path/to/klee/include -emit-llvm -c -g get_sign.c -o get_sign.bc

# 运行 KLEE
klee get_sign.bc
```

**输出**：

```text
KLEE: output directory = "klee-out-0"
KLEE: done: total instructions = 33
KLEE: done: completed paths = 3
KLEE: done: generated tests = 3
```

**生成的测试用例**：

```bash
ktest-tool klee-last/test000001.ktest
# object 0: name: 'a'
# object 0: size: 4
# object 0: data: b'\x00\x00\x00\x00'  (a = 0)

ktest-tool klee-last/test000002.ktest
# object 0: data: b'\xff\xff\xff\xff'  (a = -1)

ktest-tool klee-last/test000003.ktest
# object 0: data: b'\x01\x00\x00\x00'  (a = 1)
```

### 2.3 检测漏洞

**越界访问**（`buffer.c`）：

```c
#include <klee/klee.h>

void buggy(int i) {
  int arr[10];
  arr[i] = 42;  // 可能越界
}

int main() {
  int index;
  klee_make_symbolic(&index, sizeof(index), "index");
  buggy(index);
  return 0;
}
```

**运行**：

```bash
clang -emit-llvm -c -g buffer.c -o buffer.bc
klee buffer.bc
```

**输出**：

```text
KLEE: ERROR: buffer.c:5: memory error: out of bound pointer
KLEE: NOTE: now ignoring this error at this location
```

**查看错误输入**：

```bash
ktest-tool klee-last/*.err.ktest
# index = 10 或 -1
```

### 2.4 高级特性

#### 路径选择策略

```bash
klee --search=dfs program.bc       # 深度优先
klee --search=bfs program.bc       # 广度优先
klee --search=random-path program.bc  # 随机
klee --search=nurs:covnew program.bc  # 覆盖率导向
```

#### 并发探索

```bash
klee --use-forked-solver=true program.bc
```

#### 符号化环境

```c
// 符号化命令行参数
int main(int argc, char *argv[]) {
  klee_make_symbolic(&argc, sizeof(argc), "argc");
  klee_make_symbolic(argv, sizeof(argv), "argv");
  // ...
}
```

---

## 3. Kani：Rust 符号验证

### 3.1 Kani 简介

**Kani** 是 Amazon 开发的 Rust 符号验证工具，基于 **CBMC**（C Bounded Model Checker）。

**特点**：

- **Rust 原生**：深度集成 Rust 类型系统
- **所有权验证**：检查借用规则
- **无 unsafe**：验证 unsafe 代码的安全性
- **并发**：验证多线程代码

**官网**：<https://model-checking.github.io/kani/>

### 3.2 基本使用

**安装**：

```bash
cargo install --locked kani-verifier
cargo kani setup
```

**示例**（`sum.rs`）：

```rust
fn sum(a: u32, b: u32) -> u32 {
    a + b
}

#[cfg(kani)]
#[kani::proof]
fn verify_sum() {
    let a: u32 = kani::any();
    let b: u32 = kani::any();
    let result = sum(a, b);
    assert!(result >= a);  // 会溢出吗？
}
```

**运行验证**：

```bash
cargo kani
```

**输出**：

```text
VERIFICATION:- FAILED
Check 1: assertion failed: result >= a
 --> src/main.rs:8:5

Counterexample:
  a = 4294967295
  b = 1
  result = 0  (溢出！)
```

### 3.3 修复：使用 checked_add

```rust
fn sum_safe(a: u32, b: u32) -> Option<u32> {
    a.checked_add(b)
}

#[cfg(kani)]
#[kani::proof]
fn verify_sum_safe() {
    let a: u32 = kani::any();
    let b: u32 = kani::any();
    match sum_safe(a, b) {
        Some(result) => assert!(result >= a && result >= b),
        None => assert!(a as u64 + b as u64 > u32::MAX as u64),
    }
}
```

**验证通过**：

```text
VERIFICATION:- SUCCESSFUL
```

### 3.4 验证 unsafe 代码

**示例**（手动实现 Vec）：

```rust
struct MyVec<T> {
    ptr: *mut T,
    len: usize,
    cap: usize,
}

impl<T> MyVec<T> {
    fn push(&mut self, value: T) {
        assert!(self.len < self.cap);
        unsafe {
            std::ptr::write(self.ptr.add(self.len), value);
        }
        self.len += 1;
    }
}

#[cfg(kani)]
#[kani::proof]
fn verify_push() {
    let mut v: MyVec<u32> = kani::any();
    kani::assume(v.len < v.cap);
    kani::assume(!v.ptr.is_null());
    v.push(42);
    assert!(v.len <= v.cap);  // 不变式
}
```

### 3.5 并发验证

```rust
use std::sync::Arc;
use std::sync::atomic::{AtomicUsize, Ordering};

#[cfg(kani)]
#[kani::proof]
#[kani::unwind(3)]
fn verify_atomic_increment() {
    let counter = Arc::new(AtomicUsize::new(0));
    let c1 = counter.clone();
    let c2 = counter.clone();

    std::thread::scope(|s| {
        s.spawn(|| c1.fetch_add(1, Ordering::SeqCst));
        s.spawn(|| c2.fetch_add(1, Ordering::SeqCst));
    });

    assert!(counter.load(Ordering::SeqCst) == 2);
}
```

---

## 4. Angr：二进制符号执行

### 4.1 Angr 架构

**Angr** 是 Python 框架，用于**二进制程序**的符号执行和动态分析。

**特点**：

- **无需源码**：直接分析二进制
- **多架构**：x86, ARM, MIPS, PowerPC
- **反混淆**：处理加壳、混淆代码
- **漏洞挖掘**：CTF、恶意软件分析

**官网**：<https://angr.io/>

### 4.2 基本使用

**安装**：

```bash
pip install angr
```

**示例程序**（`simple.c`）：

```c
#include <stdio.h>
#include <string.h>

int main() {
  char password[10];
  printf("Enter password: ");
  scanf("%9s", password);
  if (strcmp(password, "secret") == 0) {
    printf("Access granted!\n");
  } else {
    printf("Access denied.\n");
  }
  return 0;
}
```

**编译**：

```bash
gcc simple.c -o simple
```

**Angr 脚本**（`solve.py`）：

```python
import angr
import claripy

# 加载二进制
project = angr.Project('simple', auto_load_libs=False)

# 创建符号变量
password = claripy.BVS('password', 9 * 8)  # 9 字节

# 设置初始状态
initial_state = project.factory.entry_state(
    args=['./simple'],
    stdin=password
)

# 添加约束：只允许可打印字符
for byte in password.chop(8):
    initial_state.solver.add(byte >= ord(' '))
    initial_state.solver.add(byte <= ord('~'))

# 创建模拟管理器
simgr = project.factory.simulation_manager(initial_state)

# 查找目标地址（"Access granted" 的位置）
target_addr = 0x401180  # 使用 objdump 或 IDA 找到
avoid_addr = 0x4011a0   # "Access denied"

simgr.explore(find=target_addr, avoid=avoid_addr)

# 获取解
if simgr.found:
    found_state = simgr.found[0]
    solution = found_state.solver.eval(password, cast_to=bytes)
    print(f"Password: {solution.decode()}")
else:
    print("No solution found")
```

**运行**：

```bash
python solve.py
# Password: secret
```

### 4.3 CTF 挑战：反向工程

**目标**：破解一个检查序列号的程序

**二进制**：`crackme`（无源码）

**Angr 脚本**：

```python
import angr
import claripy

project = angr.Project('crackme')

# 创建符号串（32 字节）
serial = claripy.BVS('serial', 32 * 8)

initial_state = project.factory.entry_state(
    args=['./crackme'],
    stdin=serial
)

# 约束：16 进制字符
for byte in serial.chop(8):
    initial_state.solver.add(
        claripy.Or(
            claripy.And(byte >= ord('0'), byte <= ord('9')),
            claripy.And(byte >= ord('A'), byte <= ord('F'))
        )
    )

simgr = project.factory.simulation_manager(initial_state)

# 查找"Correct!"字符串的地址
def is_successful(state):
    return b'Correct!' in state.posix.dumps(1)

def should_abort(state):
    return b'Wrong!' in state.posix.dumps(1)

simgr.explore(find=is_successful, avoid=should_abort)

if simgr.found:
    solution = simgr.found[0].solver.eval(serial, cast_to=bytes)
    print(f"Serial: {solution.decode()}")
```

### 4.4 漏洞挖掘

**示例**：检测栈溢出

```python
import angr

project = angr.Project('vuln_program')
cfg = project.analyses.CFGFast()

# 查找可能的缓冲区溢出
for func in cfg.functions.values():
    for block in func.blocks:
        if 'strcpy' in block.disassembly:
            print(f"Potential buffer overflow at {hex(block.addr)}")
```

---

## 5. 工具对比

### 5.1 三大工具比较

| 维度 | KLEE | Kani | Angr |
|------|------|------|------|
| **输入** | LLVM IR (C/C++) | Rust MIR | 二进制 |
| **SMT 求解器** | STP, Z3 | CBMC | Z3, CVC4 |
| **路径探索** | 高效 | 有界 | 慢（二进制） |
| **并发支持** | 有限 | 强（Rust） | 有限 |
| **应用场景** | 系统软件 | Rust 生态 | 逆向工程 |
| **学习曲线** | 中 | 低（Rust 用户） | 高 |

### 5.2 适用场景

**KLEE**：

- ✅ C/C++ 系统软件
- ✅ 操作系统、驱动
- ✅ 嵌入式固件
- ❌ 复杂 C++ 特性（虚函数、异常）

**Kani**：

- ✅ Rust 项目（尤其 unsafe 代码）
- ✅ 加密库、网络协议
- ✅ 并发算法
- ❌ 非 Rust 代码

**Angr**：

- ✅ 逆向工程
- ✅ CTF 比赛
- ✅ 恶意软件分析
- ❌ 性能敏感任务（慢）

---

## 6. 高级主题

### 6.1 路径爆炸缓解

**技术 1：路径合并（Path Merging）**:

```text
if (x > 0) y = 1; else y = 2;

常规符号执行：2 个状态
路径合并：1 个状态，y = ite(x > 0, 1, 2)
```

**KLEE 中启用**：

```bash
klee --use-merge program.bc
```

**技术 2：函数摘要（Function Summaries）**:

```c
int sqrt(int x);  // 不展开，用摘要替代
```

**技术 3：循环界限（Loop Unrolling Bound）**:

```bash
klee --max-loop-iterations=10 program.bc
```

### 6.2 约束求解优化

**增量求解（Incremental Solving）**：

```text
π₁ = x > 0
π₂ = π₁ ∧ y < 10

复用 π₁ 的求解结果
```

**求解器缓存（Solver Caching）**：

```bash
klee --use-cache program.bc
```

### 6.3 混合执行（Concolic Execution）

**定义**：具体执行 + 符号执行

```text
初始输入：具体值 v₀
执行：记录路径条件 π
变异：修改约束求解新输入 v₁
迭代：提高覆盖率
```

**工具**：

- **DART**（Microsoft）
- **SAGE**（Microsoft，发现 Windows bug）
- **AFL + SymCC**（混合 fuzzing + 符号执行）

---

## 7. 工业应用

### 7.1 NASA 火星探测器

**工具**：KLEE

**成果**：

- 验证 Curiosity 火星车的文件系统
- 发现 10+ 严重 bug
- 100% 代码覆盖率

### 7.2 Amazon S3

**工具**：Kani

**应用**：

- 验证 S3 加密模块
- 确保 unsafe 代码安全
- 持续集成中运行

### 7.3 国防高级研究计划局（DARPA）CGC

**比赛**：Cyber Grand Challenge

**获胜者**：使用 Angr 的 Mayhem 系统

**成就**：

- 自动发现漏洞
- 自动生成补丁
- 击败人类安全专家

---

## 8. 实战案例：验证排序算法

### 8.1 用 KLEE 验证

```c
#include <klee/klee.h>

void bubble_sort(int *arr, int n) {
  for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j+1]) {
        int temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
      }
    }
  }
}

int is_sorted(int *arr, int n) {
  for (int i = 0; i < n - 1; i++) {
    if (arr[i] > arr[i+1]) return 0;
  }
  return 1;
}

int main() {
  int arr[5];
  klee_make_symbolic(arr, sizeof(arr), "arr");
  
  bubble_sort(arr, 5);
  
  klee_assert(is_sorted(arr, 5));
  return 0;
}
```

**验证**：

```bash
clang -emit-llvm -c -g bubble_sort.c -o bubble_sort.bc
klee bubble_sort.bc
# VERIFICATION SUCCESSFUL
```

### 8.2 用 Kani 验证

```rust
fn bubble_sort(arr: &mut [i32]) {
    let n = arr.len();
    for i in 0..n {
        for j in 0..n - i - 1 {
            if arr[j] > arr[j + 1] {
                arr.swap(j, j + 1);
            }
        }
    }
}

#[cfg(kani)]
#[kani::proof]
#[kani::unwind(6)]  // 数组长度 ≤ 5
fn verify_bubble_sort() {
    let mut arr: [i32; 5] = kani::any();
    bubble_sort(&mut arr);
    
    // 验证有序性
    for i in 0..arr.len() - 1 {
        assert!(arr[i] <= arr[i + 1]);
    }
}
```

---

## 9. 大学课程对应

| 课程 | 相关章节 |
|------|----------|
| **CMU 15-414 Bug Catching** | KLEE, 符号执行理论 |
| **Berkeley CS 294 Program Analysis** | 符号执行、混合执行 |
| **MIT 6.858 Computer Security** | Angr, 漏洞挖掘 |
| **Stanford CS 155 安全** | 逆向工程、二进制分析 |

---

## 10. 教材与论文

### 核心论文

1. **KLEE**：
   - Cadar, C., Dunbar, D., & Engler, D. (2008). *KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs*. OSDI 2008.

2. **混合执行**：
   - Godefroid, P., Klarlund, N., & Sen, K. (2005). *DART: Directed Automated Random Testing*. PLDI 2005.

3. **Angr**：
   - Shoshitaishvili, Y., et al. (2016). *SoK: (State of) The Art of War: Offensive Techniques in Binary Analysis*. S&P 2016.

### 推荐书籍

- *The Art of Software Security Assessment* (Dowd et al.)
- *Fuzzing for Software Security Testing and Quality Assurance* (Takanen et al.)

---

## 快速参考

### 核心概念

```text
符号执行 = 路径探索 + 约束求解

状态：⟨PC, σ, π⟩
  σ: 变量 → 符号表达式
  π: 路径条件（积累的分支约束）

分支：
  if (cond) S1 else S2
  → 分裂为两个状态：π ∧ cond 和 π ∧ ¬cond

验证：
  assert(P) ⇒ 检查 π ∧ ¬P 是否 UNSAT
```

### 工具链速查

```bash
# KLEE
clang -emit-llvm -c -g program.c -o program.bc
klee program.bc

# Kani
cargo kani

# Angr
python solve.py
```

### 实战建议

1. **KLEE 入门**：从 get_sign 示例开始
2. **Kani 实践**：验证自己的 Rust 项目
3. **Angr 进阶**：参加 CTF 练习逆向
4. **混合工具**：AFL + SymCC 组合使用

---

## 附录 A：安装指南

### KLEE (Docker)

```bash
docker pull klee/klee:latest
docker run --rm -ti --ulimit='stack=-1:-1' klee/klee
```

### Kani

```bash
cargo install --locked kani-verifier
cargo kani setup
```

### Angr

```bash
pip install angr angr-management
```

---

## 附录 B：Wikipedia 概念对照

| 概念 | Wikipedia 条目 | 本文章节 |
|------|----------------|----------|
| Symbolic Execution | <https://en.wikipedia.org/wiki/Symbolic_execution> | §1 |
| KLEE | <https://klee.github.io/> | §2 |
| CBMC | <https://en.wikipedia.org/wiki/C_Bounded_Model_Checker> | §3.1 |
| Angr | <https://angr.io/> | §4 |
| Concolic Testing | <https://en.wikipedia.org/wiki/Concolic_testing> | §6.3 |

---

**版本**：v1.0  
**最后更新**：2025-10-29  
**维护者**：FormalScience Project  
**许可**：CC BY-SA 4.0
