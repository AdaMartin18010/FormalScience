# 04.3 äº‹ä»¶é©±åŠ¨æ¶æ„ (Event-Driven Architecture, EDA)

## ğŸ“Š æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ

<details>
<summary><b>âš¡ğŸ”¬ ç‚¹å‡»å±•å¼€ï¼šäº‹ä»¶é©±åŠ¨æ¶æ„æ ¸å¿ƒæ´å¯Ÿ</b></summary>

**ç»ˆææ´å¯Ÿ**: äº‹ä»¶é©±åŠ¨=å¼‚æ­¥æ¾è€¦åˆçš„æè‡´ã€‚æ ¸å¿ƒæ¦‚å¿µï¼šâ‘ äº‹ä»¶=çŠ¶æ€å˜åŒ–çš„ä¸å¯å˜äº‹å®ï¼ˆOrderCreated, PaymentProcessedï¼‰â‘¡å‘å¸ƒ-è®¢é˜…ï¼šç”Ÿäº§è€…å‘å¸ƒäº‹ä»¶ä¸çŸ¥é“æ¶ˆè´¹è€…ï¼Œæ¶ˆè´¹è€…è®¢é˜…æ„Ÿå…´è¶£çš„äº‹ä»¶â‘¢æœ€ç»ˆä¸€è‡´æ€§ï¼šæ”¾å¼ƒå³æ—¶ä¸€è‡´æ€§ï¼Œé€šè¿‡äº‹ä»¶ä¼ æ’­æœ€ç»ˆè¾¾åˆ°ä¸€è‡´ã€‚æ¶æ„æ¨¡å¼ï¼šâ‘ Event Notificationï¼ˆäº‹ä»¶é€šçŸ¥ï¼‰ï¼šè½»é‡çº§äº‹ä»¶ï¼Œè§¦å‘åç»­åŠ¨ä½œâ‘¡Event-Carried State Transferï¼šäº‹ä»¶æºå¸¦å®Œæ•´çŠ¶æ€ï¼Œå‡å°‘æŸ¥è¯¢â‘¢Event Sourcingï¼šå­˜å‚¨äº‹ä»¶åºåˆ—è€Œéå½“å‰çŠ¶æ€ï¼ŒState=fold(events)ï¼Œæ”¯æŒæ—¶é—´æ—…è¡Œ/å®¡è®¡/å›æ”¾â‘£CQRS+Event Sourcingï¼šå‘½ä»¤å†™å…¥+äº‹ä»¶å­˜å‚¨+ç‰©åŒ–è§†å›¾æŸ¥è¯¢ã€‚äº‹ä»¶æ€»çº¿ï¼šKafkaï¼ˆé«˜ååæ—¥å¿—ï¼‰ã€RabbitMQï¼ˆçµæ´»è·¯ç”±ï¼‰ã€AWS EventBridgeï¼ˆæ‰˜ç®¡æœåŠ¡ï¼‰ã€‚å¤æ‚äº‹ä»¶å¤„ç†ï¼ˆCEPï¼‰ï¼šä»äº‹ä»¶æµä¸­æ£€æµ‹æ¨¡å¼ï¼ˆå¦‚Esper/Flinkï¼‰ã€‚å½¢å¼åŒ–éªŒè¯ï¼šâ‘ TLA+éªŒè¯äº‹ä»¶é¡ºåºæ€§å’Œå› æœä¸€è‡´æ€§â‘¡Actoræ¨¡å‹ï¼ˆAkkaï¼‰å½¢å¼åŒ–äº‹ä»¶å¤„ç†â‘¢æ—¶åºé€»è¾‘éªŒè¯æ´»æ€§ï¼ˆæ‰€æœ‰äº‹ä»¶æœ€ç»ˆè¢«å¤„ç†ï¼‰ã€‚æŒ‘æˆ˜ï¼šâ‘ è°ƒè¯•å›°éš¾ï¼ˆå¼‚æ­¥è¿½è¸ªï¼‰â‘¡äº‹ä»¶ç‰ˆæœ¬æ¼”åŒ–â‘¢é‡å¤/ä¹±åº/ä¸¢å¤±å¤„ç†ã€‚å…³é”®ï¼šäº‹ä»¶é©±åŠ¨æ¶æ„ç”¨å¤æ‚æ€§æ¢å¯æ‰©å±•æ€§å’Œå“åº”æ€§ï¼Œæ˜¯ç°ä»£äº‘åŸç”Ÿæ¶æ„çš„åŸºçŸ³ã€‚

</details>

---

## ğŸ“š ç›®å½•

- [1. æ ¸å¿ƒå®šä¹‰ (Core Definition)](#1-æ ¸å¿ƒå®šä¹‰-core-definition)
  - [1.1 å½¢å¼åŒ–å®šä¹‰ (Formal Definition)](#11-å½¢å¼åŒ–å®šä¹‰-formal-definition)
  - [1.2 ä¸å…¶ä»–æ¶æ„æ¨¡å¼çš„å¯¹æ¯” (Comparison)](#12-ä¸å…¶ä»–æ¶æ„æ¨¡å¼çš„å¯¹æ¯”-comparison)
- [2. æ ¸å¿ƒç»„ä»¶ (Core Components)](#2-æ ¸å¿ƒç»„ä»¶-core-components)
  - [2.1 äº‹ä»¶æ€»çº¿ (Event Bus / Event Broker)](#21-äº‹ä»¶æ€»çº¿-event-bus--event-broker)
  - [2.2 äº‹ä»¶å­˜å‚¨ (Event Store)](#22-äº‹ä»¶å­˜å‚¨-event-store)
  - [2.3 å¤æ‚äº‹ä»¶å¤„ç† (Complex Event Processing, CEP)](#23-å¤æ‚äº‹ä»¶å¤„ç†-complex-event-processing-cep)
- [3. äº‹ä»¶é©±åŠ¨æ¶æ„æ¨¡å¼ (EDA Patterns)](#3-äº‹ä»¶é©±åŠ¨æ¶æ„æ¨¡å¼-eda-patterns)
  - [3.1 Event Notification (äº‹ä»¶é€šçŸ¥)](#31-event-notification-äº‹ä»¶é€šçŸ¥)
  - [3.2 Event-Carried State Transfer (äº‹ä»¶æºå¸¦çŠ¶æ€)](#32-event-carried-state-transfer-äº‹ä»¶æºå¸¦çŠ¶æ€)
  - [3.3 Event Sourcing (äº‹ä»¶æº¯æº)](#33-event-sourcing-äº‹ä»¶æº¯æº)
  - [3.4 CQRS + Event Sourcing (å‘½ä»¤æŸ¥è¯¢è´£ä»»åˆ†ç¦» + äº‹ä»¶æº¯æº)](#34-cqrs--event-sourcing-å‘½ä»¤æŸ¥è¯¢è´£ä»»åˆ†ç¦»--äº‹ä»¶æº¯æº)
- [4. å½¢å¼åŒ–éªŒè¯ (Formal Verification)](#4-å½¢å¼åŒ–éªŒè¯-formal-verification)
  - [4.1 ä½¿ç”¨ TLA+ éªŒè¯äº‹ä»¶é¡ºåºæ€§](#41-ä½¿ç”¨-tla-éªŒè¯äº‹ä»¶é¡ºåºæ€§)
  - [4.2 ä½¿ç”¨ mCRL2 éªŒè¯äº‹ä»¶å¤„ç†æ— æ­»é”](#42-ä½¿ç”¨-mcrl2-éªŒè¯äº‹ä»¶å¤„ç†æ— æ­»é”)
- [5. å¯è§‚æµ‹æ€§ (Observability)](#5-å¯è§‚æµ‹æ€§-observability)
  - [5.1 åˆ†å¸ƒå¼è¿½è¸ª (Distributed Tracing)](#51-åˆ†å¸ƒå¼è¿½è¸ª-distributed-tracing)
  - [5.2 äº‹ä»¶ç›‘æ§æŒ‡æ ‡](#52-äº‹ä»¶ç›‘æ§æŒ‡æ ‡)
- [6. å®æˆ˜æ¡ˆä¾‹](#6-å®æˆ˜æ¡ˆä¾‹)
- [7. æœ€ä½³å®è·µ (Best Practices)](#7-æœ€ä½³å®è·µ-best-practices)
- [8. æŒ‘æˆ˜ä¸æƒè¡¡ (Challenges & Tradeoffs)](#8-æŒ‘æˆ˜ä¸æƒè¡¡-challenges--tradeoffs)
- [9. å¤§å­¦è¯¾ç¨‹æ˜ å°„ (University Course Alignment)](#9-å¤§å­¦è¯¾ç¨‹æ˜ å°„-university-course-alignment)

---

## 1. æ ¸å¿ƒå®šä¹‰ (Core Definition)

**äº‹ä»¶é©±åŠ¨æ¶æ„ (Event-Driven Architecture, EDA)** æ˜¯ä¸€ç§ä»¥äº‹ä»¶ä¸ºæ ¸å¿ƒçš„ç³»ç»Ÿæ¶æ„æ¨¡å¼ï¼Œç»„ä»¶ä¹‹é—´é€šè¿‡äº§ç”Ÿã€æ£€æµ‹å’Œæ¶ˆè´¹äº‹ä»¶æ¥è¿›è¡Œé€šä¿¡å’Œåä½œã€‚

### 1.1 å½¢å¼åŒ–å®šä¹‰ (Formal Definition)

äº‹ä»¶é©±åŠ¨æ¶æ„å¯ä»¥å½¢å¼åŒ–ä¸ºï¼š

```text
EDA = âŸ¨E, P, C, R, Ï†âŸ©

å…¶ä¸­ï¼š
- E = {eâ‚, eâ‚‚, ..., eâ‚™}  : äº‹ä»¶é›†åˆ (Event Set)
- P = {pâ‚, pâ‚‚, ..., pâ‚˜}  : ç”Ÿäº§è€…é›†åˆ (Producer Set)
- C = {câ‚, câ‚‚, ..., câ‚–}  : æ¶ˆè´¹è€…é›†åˆ (Consumer Set)
- R âŠ† E Ã— C              : è®¢é˜…å…³ç³» (Subscription Relation)
- Ï† : E â†’ Time â†’ Prop    : äº‹ä»¶æ€§è´¨è°“è¯ (Event Properties)
```

**äº‹ä»¶ (Event)** çš„å½¢å¼åŒ–ç»“æ„ï¼š

```text
Event = âŸ¨id, type, timestamp, payload, metadataâŸ©

å…¶ä¸­ï¼š
- id         : å…¨å±€å”¯ä¸€æ ‡è¯†ç¬¦
- type       : äº‹ä»¶ç±»å‹ (å¦‚ OrderCreated, PaymentCompleted)
- timestamp  : æ—¶é—´æˆ³ (å‘ç”Ÿæ—¶é—´)
- payload    : äº‹ä»¶æ•°æ®è´Ÿè½½
- metadata   : å…ƒæ•°æ® (correlation_id, version, source, etc.)
```

### 1.2 ä¸å…¶ä»–æ¶æ„æ¨¡å¼çš„å¯¹æ¯” (Comparison)

| ç‰¹æ€§ | äº‹ä»¶é©±åŠ¨æ¶æ„ | è¯·æ±‚-å“åº” (Request-Response) | å‘å¸ƒ-è®¢é˜… (Pub-Sub) |
|------|-------------|------------------------------|---------------------|
| **è€¦åˆåº¦** | æ¾è€¦åˆ (Loose Coupling) | ç´§è€¦åˆ (Tight Coupling) | æ¾è€¦åˆ |
| **åŒæ­¥æ€§** | å¼‚æ­¥ (Async) | åŒæ­¥ (Sync) | å¼‚æ­¥ |
| **å¯æ‰©å±•æ€§** | é«˜ (High) | ä½ (Low) | é«˜ |
| **äº‹ä»¶æº¯æº** | æ”¯æŒ (Event Sourcing) | ä¸æ”¯æŒ | éƒ¨åˆ†æ”¯æŒ |
| **æ•…éšœéš”ç¦»** | å¥½ (Good) | å·® (Poor) | å¥½ |

**å…³é”®åŒºåˆ«**ï¼š

- **EDA vs Pub-Sub**ï¼šPub-Sub æ˜¯ EDA çš„ä¸€ä¸ªé€šä¿¡æ¨¡å¼ï¼ŒEDA æ›´å¼ºè°ƒäº‹ä»¶çš„æŒä¹…åŒ–ã€æº¯æºå’Œå¤æ‚äº‹ä»¶å¤„ç†
- **EDA vs Microservices**ï¼šEDA æ˜¯ä¸€ç§é€šä¿¡èŒƒå¼ï¼ŒMicroservices æ˜¯ä¸€ç§éƒ¨ç½²æ¶æ„ï¼›ä¸¤è€…å¸¸ç»“åˆä½¿ç”¨

---

## 2. æ ¸å¿ƒç»„ä»¶ (Core Components)

### 2.1 äº‹ä»¶æ€»çº¿ (Event Bus / Event Broker)

**ä½œç”¨**ï¼šè§£è€¦äº‹ä»¶ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ï¼Œè´Ÿè´£äº‹ä»¶çš„è·¯ç”±ã€æŒä¹…åŒ–å’Œä¼ é€’ã€‚

#### 2.1.1 Apache Kafka (åˆ†å¸ƒå¼æ¶ˆæ¯æµå¹³å°)

**æ¶æ„ç‰¹ç‚¹**ï¼š

- **Topic-Partition æ¨¡å‹**ï¼šäº‹ä»¶æŒ‰ä¸»é¢˜åˆ†ç±»ï¼Œåˆ†åŒºä¿è¯é¡ºåºæ€§
- **æŒä¹…åŒ–æ—¥å¿—**ï¼šäº‹ä»¶å­˜å‚¨åœ¨ç£ç›˜ï¼Œæ”¯æŒäº‹ä»¶å›æº¯
- **é«˜ååé‡**ï¼šé›¶æ‹·è´ã€æ‰¹å¤„ç†ã€å‹ç¼©

**å½¢å¼åŒ–æ¨¡å‹**ï¼š

```text
Kafka = âŸ¨Topics, Partitions, Offsets, Producers, ConsumersâŸ©

å…¶ä¸­ï¼š
- Topic t åŒ…å«å¤šä¸ª Partition pâ‚, ..., pâ‚™
- æ¯ä¸ª Partition æ˜¯æœ‰åºäº‹ä»¶åºåˆ— [eâ‚€, eâ‚, eâ‚‚, ...]
- Offset æ˜¯äº‹ä»¶åœ¨ Partition ä¸­çš„ä½ç½® (ä»0å¼€å§‹)
- Producer å†™å…¥äº‹ä»¶æ—¶ç”± Kafka åˆ†é… Offset
- Consumer é€šè¿‡ Offset è¿½è¸ªæ¶ˆè´¹è¿›åº¦
```

**ä¸€è‡´æ€§ä¿è¯**ï¼š

- **At-least-once**ï¼šæ¶ˆè´¹è€…å¯èƒ½é‡å¤æ¶ˆè´¹äº‹ä»¶ï¼ˆéœ€å¹‚ç­‰å¤„ç†ï¼‰
- **Exactly-once**ï¼šé€šè¿‡äº‹åŠ¡ API ä¿è¯ï¼ˆKafka 0.11+ï¼‰

**Java ç¤ºä¾‹ï¼šå‘å¸ƒäº‹ä»¶**:

```java
import org.apache.kafka.clients.producer.*;
import java.util.Properties;

public class OrderEventProducer {
    private final KafkaProducer<String, String> producer;
    
    public OrderEventProducer() {
        Properties props = new Properties();
        props.put("bootstrap.servers", "localhost:9092");
        props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
        props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");
        props.put("acks", "all"); // ç­‰å¾…æ‰€æœ‰å‰¯æœ¬ç¡®è®¤
        props.put("enable.idempotence", "true"); // å¯ç”¨å¹‚ç­‰æ€§
        
        this.producer = new KafkaProducer<>(props);
    }
    
    public void publishOrderCreated(String orderId, String orderData) {
        ProducerRecord<String, String> record = new ProducerRecord<>(
            "order-events",      // Topic
            orderId,             // Key (ç”¨äºåˆ†åŒº)
            orderData            // Value
        );
        
        producer.send(record, (metadata, exception) -> {
            if (exception == null) {
                System.out.printf("Event sent to partition %d at offset %d%n",
                    metadata.partition(), metadata.offset());
            } else {
                exception.printStackTrace();
            }
        });
    }
    
    public void close() {
        producer.close();
    }
}
```

**Python ç¤ºä¾‹ï¼šæ¶ˆè´¹äº‹ä»¶**:

```python
from kafka import KafkaConsumer
import json

consumer = KafkaConsumer(
    'order-events',
    bootstrap_servers=['localhost:9092'],
    group_id='order-processor',
    auto_offset_reset='earliest',  # ä»æœ€æ—©çš„äº‹ä»¶å¼€å§‹æ¶ˆè´¹
    enable_auto_commit=False,      # æ‰‹åŠ¨æäº¤ offset
    value_deserializer=lambda x: json.loads(x.decode('utf-8'))
)

for message in consumer:
    event = message.value
    try:
        # å¤„ç†äº‹ä»¶ï¼ˆéœ€ä¿è¯å¹‚ç­‰ï¼‰
        process_order_event(event)
        
        # æ‰‹åŠ¨æäº¤ offset
        consumer.commit()
    except Exception as e:
        print(f"Failed to process event: {e}")
        # å¯ä»¥é€‰æ‹©è·³è¿‡æˆ–é‡è¯•
```

#### 2.1.2 RabbitMQ (AMQP æ¶ˆæ¯ä¸­é—´ä»¶)

**æ¶æ„ç‰¹ç‚¹**ï¼š

- **Exchange-Queue-Binding æ¨¡å‹**ï¼šçµæ´»çš„è·¯ç”±æœºåˆ¶
- **å¤šç§ Exchange ç±»å‹**ï¼šDirect, Topic, Fanout, Headers
- **æ¶ˆæ¯ç¡®è®¤æœºåˆ¶**ï¼šPublisher Confirms + Consumer ACK

**Golang ç¤ºä¾‹ï¼šTopic Exchange**:

```go
package main

import (
    "github.com/streadway/amqp"
    "log"
)

// å‘å¸ƒè€…ï¼šå‘é€ä¸åŒä¸¥é‡çº§åˆ«çš„æ—¥å¿—äº‹ä»¶
func publishLogEvent(severity, message string) error {
    conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
    if err != nil {
        return err
    }
    defer conn.Close()
    
    ch, err := conn.Channel()
    if err != nil {
        return err
    }
    defer ch.Close()
    
    // å£°æ˜ Topic Exchange
    err = ch.ExchangeDeclare(
        "logs_topic", // name
        "topic",      // type
        true,         // durable
        false,        // auto-deleted
        false,        // internal
        false,        // no-wait
        nil,          // arguments
    )
    if err != nil {
        return err
    }
    
    // å‘å¸ƒæ¶ˆæ¯ï¼Œrouting key ä¸º "severity.component"
    err = ch.Publish(
        "logs_topic",              // exchange
        severity + ".app",         // routing key (e.g., "error.app")
        false,                     // mandatory
        false,                     // immediate
        amqp.Publishing{
            ContentType: "text/plain",
            Body:        []byte(message),
        },
    )
    return err
}

// æ¶ˆè´¹è€…ï¼šè®¢é˜…ç‰¹å®šä¸¥é‡çº§åˆ«çš„æ—¥å¿—
func consumeLogEvents(bindingKeys []string) error {
    conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
    if err != nil {
        return err
    }
    defer conn.Close()
    
    ch, err := conn.Channel()
    if err != nil {
        return err
    }
    defer ch.Close()
    
    // å£°æ˜ä¸´æ—¶é˜Ÿåˆ—
    q, err := ch.QueueDeclare(
        "",    // name (æœåŠ¡å™¨ç”Ÿæˆ)
        false, // durable
        true,  // delete when unused
        true,  // exclusive
        false, // no-wait
        nil,   // arguments
    )
    if err != nil {
        return err
    }
    
    // ç»‘å®šé˜Ÿåˆ—åˆ° Exchangeï¼Œå¯ä»¥ä½¿ç”¨é€šé…ç¬¦
    // ä¾‹å¦‚ï¼š*.error åŒ¹é…æ‰€æœ‰ error çº§åˆ«æ—¥å¿—
    for _, key := range bindingKeys {
        err = ch.QueueBind(
            q.Name,       // queue name
            key,          // routing key (æ”¯æŒé€šé…ç¬¦ * å’Œ #)
            "logs_topic", // exchange
            false,
            nil,
        )
        if err != nil {
            return err
        }
    }
    
    msgs, err := ch.Consume(
        q.Name, // queue
        "",     // consumer
        false,  // auto-ack (æ‰‹åŠ¨ç¡®è®¤)
        false,  // exclusive
        false,  // no-local
        false,  // no-wait
        nil,    // args
    )
    if err != nil {
        return err
    }
    
    for msg := range msgs {
        log.Printf("Received: %s", msg.Body)
        msg.Ack(false) // æ‰‹åŠ¨ç¡®è®¤
    }
    
    return nil
}
```

### 2.2 äº‹ä»¶å­˜å‚¨ (Event Store)

**ç›®çš„**ï¼šæŒä¹…åŒ–äº‹ä»¶æµï¼Œæ”¯æŒäº‹ä»¶æº¯æº (Event Sourcing) å’Œå®¡è®¡ã€‚

#### 2.2.1 Event Sourcing æ¨¡å¼

**æ ¸å¿ƒæ€æƒ³**ï¼šå°†ç³»ç»ŸçŠ¶æ€çš„æ‰€æœ‰å˜æ›´è®°å½•ä¸ºäº‹ä»¶åºåˆ—ï¼Œå½“å‰çŠ¶æ€é€šè¿‡é‡æ”¾äº‹ä»¶è®¡ç®—å¾—å‡ºã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š

```text
State(t) = fold(events[0..t], initialState, apply)

å…¶ä¸­ï¼š
- events[0..t] : ä»æ—¶åˆ» 0 åˆ° t çš„æ‰€æœ‰äº‹ä»¶
- initialState : åˆå§‹çŠ¶æ€
- apply        : äº‹ä»¶åº”ç”¨å‡½æ•° (State Ã— Event â†’ State)
```

**TypeScript ç¤ºä¾‹ï¼šé“¶è¡Œè´¦æˆ·äº‹ä»¶æº¯æº**:

```typescript
// äº‹ä»¶å®šä¹‰
type AccountEvent =
  | { type: 'AccountOpened'; accountId: string; initialBalance: number }
  | { type: 'MoneyDeposited'; amount: number; timestamp: Date }
  | { type: 'MoneyWithdrawn'; amount: number; timestamp: Date }
  | { type: 'AccountClosed'; timestamp: Date };

// è´¦æˆ·çŠ¶æ€
interface AccountState {
  accountId: string;
  balance: number;
  isOpen: boolean;
}

// äº‹ä»¶åº”ç”¨å‡½æ•°
function applyEvent(state: AccountState, event: AccountEvent): AccountState {
  switch (event.type) {
    case 'AccountOpened':
      return {
        accountId: event.accountId,
        balance: event.initialBalance,
        isOpen: true
      };
    case 'MoneyDeposited':
      return { ...state, balance: state.balance + event.amount };
    case 'MoneyWithdrawn':
      return { ...state, balance: state.balance - event.amount };
    case 'AccountClosed':
      return { ...state, isOpen: false };
  }
}

// é‡å»ºçŠ¶æ€
function rebuildState(events: AccountEvent[]): AccountState {
  return events.reduce(
    applyEvent,
    { accountId: '', balance: 0, isOpen: false }
  );
}

// ç¤ºä¾‹
const events: AccountEvent[] = [
  { type: 'AccountOpened', accountId: 'A123', initialBalance: 1000 },
  { type: 'MoneyDeposited', amount: 500, timestamp: new Date('2025-01-01') },
  { type: 'MoneyWithdrawn', amount: 200, timestamp: new Date('2025-01-02') }
];

const currentState = rebuildState(events);
console.log(currentState); // { accountId: 'A123', balance: 1300, isOpen: true }
```

**ä¼˜åŠ¿**ï¼š

- **å®Œæ•´å®¡è®¡æ—¥å¿—**ï¼šæ‰€æœ‰çŠ¶æ€å˜æ›´å¯è¿½æº¯
- **æ—¶é—´æ—…è¡Œ**ï¼šå¯é‡å»ºä»»æ„æ—¶åˆ»çš„çŠ¶æ€
- **çµæ´»æŸ¥è¯¢**ï¼šå¯ä»äº‹ä»¶æµæ„å»ºå¤šç§æŠ•å½±ï¼ˆRead Modelï¼‰

**æŒ‘æˆ˜**ï¼š

- **æ€§èƒ½é—®é¢˜**ï¼šé‡å»ºçŠ¶æ€éœ€é‡æ”¾å¤§é‡äº‹ä»¶ï¼ˆè§£å†³ï¼šå¿«ç…§ Snapshotï¼‰
- **äº‹ä»¶ç‰ˆæœ¬ç®¡ç†**ï¼šäº‹ä»¶æ¨¡å¼å˜æ›´éœ€å‘åå…¼å®¹

#### 2.2.2 EventStoreDB (ä¸“ç”¨äº‹ä»¶å­˜å‚¨æ•°æ®åº“)

**ç‰¹ç‚¹**ï¼š

- **æµå¼å­˜å‚¨**ï¼šäº‹ä»¶æŒ‰æµï¼ˆStreamï¼‰ç»„ç»‡
- **ä¹è§‚å¹¶å‘æ§åˆ¶**ï¼šåŸºäºç‰ˆæœ¬å·é˜²æ­¢å¹¶å‘å†™å†²çª
- **æŠ•å½±åŠŸèƒ½**ï¼šè‡ªåŠ¨æ„å»ºè¯»æ¨¡å‹

**C# ç¤ºä¾‹**ï¼š

```csharp
using EventStore.Client;

var settings = EventStoreClientSettings.Create("esdb://localhost:2113?tls=false");
var client = new EventStoreClient(settings);

// å†™å…¥äº‹ä»¶æµ
var eventData = new EventData(
    Uuid.NewUuid(),
    "OrderCreated",
    JsonSerializer.SerializeToUtf8Bytes(new { OrderId = "12345", Amount = 100.0 })
);

await client.AppendToStreamAsync(
    "order-12345",
    StreamState.Any,
    new[] { eventData }
);

// è¯»å–äº‹ä»¶æµ
var result = client.ReadStreamAsync(
    Direction.Forwards,
    "order-12345",
    StreamPosition.Start
);

await foreach (var resolvedEvent in result) {
    Console.WriteLine($"Event: {resolvedEvent.Event.EventType}");
}
```

### 2.3 å¤æ‚äº‹ä»¶å¤„ç† (Complex Event Processing, CEP)

**ç›®çš„**ï¼šä»äº‹ä»¶æµä¸­æ£€æµ‹æ¨¡å¼ã€èšåˆå’Œå…³è”äº‹ä»¶ã€‚

#### 2.3.1 Apache Flink (æµå¤„ç†å¼•æ“)

**é€‚ç”¨åœºæ™¯**ï¼š

- **å®æ—¶åˆ†æ**ï¼šè®¡ç®—æ»‘åŠ¨çª—å£ç»Ÿè®¡ï¼ˆå¦‚æœ€è¿‘1å°æ—¶çš„è®¢å•æ€»é¢ï¼‰
- **æ¨¡å¼æ£€æµ‹**ï¼šæ£€æµ‹å¼‚å¸¸è¡Œä¸ºï¼ˆå¦‚çŸ­æ—¶é—´å†…å¤šæ¬¡å¤±è´¥ç™»å½•ï¼‰

**Java ç¤ºä¾‹ï¼šæ£€æµ‹æ¬ºè¯ˆäº¤æ˜“**:

```java
import org.apache.flink.api.common.functions.FilterFunction;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.windowing.time.Time;

public class FraudDetection {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        
        // ä» Kafka è¯»å–äº¤æ˜“äº‹ä»¶
        DataStream<Transaction> transactions = env
            .addSource(new FlinkKafkaConsumer<>("transactions", new TransactionSchema(), properties));
        
        // æ£€æµ‹ï¼š5åˆ†é’Ÿå†…æ¥è‡ªåŒä¸€ç”¨æˆ·çš„äº¤æ˜“é‡‘é¢è¶…è¿‡$10,000
        DataStream<Alert> alerts = transactions
            .keyBy(Transaction::getUserId)
            .timeWindow(Time.minutes(5))
            .aggregate(new SumAmountAggregator())
            .filter(new FilterFunction<AggregatedTransaction>() {
                @Override
                public boolean filter(AggregatedTransaction agg) {
                    return agg.getTotalAmount() > 10000;
                }
            })
            .map(agg -> new Alert(agg.getUserId(), "High transaction volume"));
        
        // è¾“å‡ºåˆ°å‘Šè­¦ç³»ç»Ÿ
        alerts.addSink(new AlertSink());
        
        env.execute("Fraud Detection");
    }
}
```

#### 2.3.2 Esper (äº‹ä»¶å¤„ç†è¯­è¨€ EPL)

**ç‰¹ç‚¹**ï¼š

- **SQL-like è¯­æ³•**ï¼šå£°æ˜å¼æ¨¡å¼åŒ¹é…
- **æ—¶é—´çª—å£**ï¼šæ”¯æŒæ»‘åŠ¨çª—å£ã€æ‰¹é‡çª—å£

**ç¤ºä¾‹ï¼šæ£€æµ‹æ¸©åº¦å¼‚å¸¸**:

```java
import com.espertech.esper.client.*;

EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
EPAdministrator admin = epService.getEPAdministrator();

// å®šä¹‰äº‹ä»¶ç±»å‹
admin.getConfiguration().addEventType(TemperatureEvent.class);

// EPL æŸ¥è¯¢ï¼š5åˆ†é’Ÿå†…å¹³å‡æ¸©åº¦è¶…è¿‡ 30Â°C
String epl = "SELECT sensor, AVG(temperature) as avgTemp " +
             "FROM TemperatureEvent.win:time(5 min) " +
             "GROUP BY sensor " +
             "HAVING AVG(temperature) > 30";

EPStatement statement = admin.createEPL(epl);
statement.addListener((newEvents, oldEvents) -> {
    for (EventBean event : newEvents) {
        System.out.println("Alert: Sensor " + event.get("sensor") + 
                           " avgTemp = " + event.get("avgTemp"));
    }
});

// å‘é€äº‹ä»¶
epService.getEPRuntime().sendEvent(new TemperatureEvent("S1", 32.5));
```

---

## 3. äº‹ä»¶é©±åŠ¨æ¶æ„æ¨¡å¼ (EDA Patterns)

### 3.1 Event Notification (äº‹ä»¶é€šçŸ¥)

**å®šä¹‰**ï¼šæœåŠ¡åœ¨çŠ¶æ€å˜æ›´æ—¶å‘é€è½»é‡çº§é€šçŸ¥äº‹ä»¶ï¼Œæ¶ˆè´¹è€…æ”¶åˆ°é€šçŸ¥åè‡ªè¡ŒæŸ¥è¯¢è¯¦ç»†ä¿¡æ¯ã€‚

**é€‚ç”¨åœºæ™¯**ï¼š

- æ¾è€¦åˆé€šçŸ¥
- äº‹ä»¶è´Ÿè½½è¾ƒå°

**ç¤ºä¾‹**ï¼š

```text
OrderService â”€â”€[OrderCreated {orderId: 123}]â”€â”€> EventBus
                                                      â”‚
                                                      â””â”€â”€> EmailService (æŸ¥è¯¢ OrderService è·å–è®¢å•è¯¦æƒ…)
```

### 3.2 Event-Carried State Transfer (äº‹ä»¶æºå¸¦çŠ¶æ€)

**å®šä¹‰**ï¼šäº‹ä»¶åŒ…å«å®Œæ•´çš„çŠ¶æ€æ•°æ®ï¼Œæ¶ˆè´¹è€…æ— éœ€å›æŸ¥ç”Ÿäº§è€…ã€‚

**é€‚ç”¨åœºæ™¯**ï¼š

- å‡å°‘æœåŠ¡é—´è°ƒç”¨
- æ„å»ºæœ¬åœ°ç¼“å­˜ï¼ˆCQRS Read Modelï¼‰

**ç¤ºä¾‹**ï¼š

```json
{
  "eventType": "OrderCreated",
  "orderId": "123",
  "customer": { "id": "C1", "name": "Alice", "email": "alice@example.com" },
  "items": [
    { "productId": "P1", "quantity": 2, "price": 50.0 }
  ],
  "totalAmount": 100.0,
  "timestamp": "2025-10-29T10:00:00Z"
}
```

### 3.3 Event Sourcing (äº‹ä»¶æº¯æº)

è§å‰æ–‡ Â§2.2.1ã€‚

### 3.4 CQRS + Event Sourcing (å‘½ä»¤æŸ¥è¯¢è´£ä»»åˆ†ç¦» + äº‹ä»¶æº¯æº)

**æ¶æ„**ï¼š

```text
Command Side (å†™):
  Command â†’ CommandHandler â†’ Domain Model â†’ Event Store
                                                  â”‚
                                                  â””â”€â”€> Event Bus
  
Query Side (è¯»):
  Event Bus â”€â”€> Projection Builder â”€â”€> Read Database (MongoDB, Elasticsearch, etc.)
                                                  â”‚
                                                  â””â”€â”€> Query API
```

**ä¼˜åŠ¿**ï¼š

- **è¯»å†™åˆ†ç¦»**ï¼šè¯»å†™æ•°æ®åº“ç‹¬ç«‹ä¼˜åŒ–ï¼ˆå†™ç”¨äº‹ä»¶å­˜å‚¨ï¼Œè¯»ç”¨é’ˆå¯¹æŸ¥è¯¢ä¼˜åŒ–çš„æ•°æ®åº“ï¼‰
- **å¤šç§æŠ•å½±**ï¼šä»åŒä¸€äº‹ä»¶æµæ„å»ºä¸åŒçš„è¯»æ¨¡å‹

**Rust ç¤ºä¾‹ï¼šCQRS å‘½ä»¤å¤„ç†**:

```rust
use serde::{Serialize, Deserialize};
use std::sync::Arc;
use tokio::sync::Mutex;

#[derive(Serialize, Deserialize)]
enum OrderCommand {
    CreateOrder { order_id: String, amount: f64 },
    CancelOrder { order_id: String },
}

#[derive(Serialize, Deserialize)]
enum OrderEvent {
    OrderCreated { order_id: String, amount: f64, timestamp: i64 },
    OrderCancelled { order_id: String, timestamp: i64 },
}

struct CommandHandler {
    event_store: Arc<Mutex<Vec<OrderEvent>>>,
}

impl CommandHandler {
    async fn handle(&self, cmd: OrderCommand) -> Result<(), String> {
        let event = match cmd {
            OrderCommand::CreateOrder { order_id, amount } => {
                // ä¸šåŠ¡é€»è¾‘éªŒè¯
                if amount <= 0.0 {
                    return Err("Invalid amount".to_string());
                }
                OrderEvent::OrderCreated {
                    order_id,
                    amount,
                    timestamp: chrono::Utc::now().timestamp(),
                }
            }
            OrderCommand::CancelOrder { order_id } => {
                OrderEvent::OrderCancelled {
                    order_id,
                    timestamp: chrono::Utc::now().timestamp(),
                }
            }
        };
        
        // ä¿å­˜åˆ°äº‹ä»¶å­˜å‚¨
        self.event_store.lock().await.push(event);
        Ok(())
    }
}
```

---

## 4. å½¢å¼åŒ–éªŒè¯ (Formal Verification)

### 4.1 ä½¿ç”¨ TLA+ éªŒè¯äº‹ä»¶é¡ºåºæ€§

**é—®é¢˜**ï¼šéªŒè¯åˆ†å¸ƒå¼ç³»ç»Ÿä¸­äº‹ä»¶çš„å› æœé¡ºåºæ˜¯å¦ä¿æŒã€‚

**TLA+ è§„èŒƒ**ï¼š

```text
--------------------------- MODULE EventOrdering ---------------------------
EXTENDS Naturals, Sequences

VARIABLES events, delivered

EventOrdering ==
  /\ events = <<>>         \* åˆå§‹äº‹ä»¶åºåˆ—ä¸ºç©º
  /\ delivered = {}        \* å·²äº¤ä»˜äº‹ä»¶é›†åˆä¸ºç©º

Produce(e) ==
  /\ events' = Append(events, e)
  /\ UNCHANGED delivered

Deliver(e) ==
  /\ e \in Range(events)
  /\ \A e2 \in Range(events) : 
       (e2.causedBy = e.id) => (e2 \in delivered)  \* å› æœå‰é©±å¿…é¡»å·²äº¤ä»˜
  /\ delivered' = delivered \union {e}
  /\ UNCHANGED events

Next == \E e : Produce(e) \/ Deliver(e)

Spec == EventOrdering /\ [][Next]_<<events, delivered>>

CausalConsistency ==
  \A e1, e2 \in delivered :
    (e1.causedBy = e2.id) => (e1.timestamp > e2.timestamp)

THEOREM Spec => []CausalConsistency
=============================================================================
```

### 4.2 ä½¿ç”¨ mCRL2 éªŒè¯äº‹ä»¶å¤„ç†æ— æ­»é”

**é—®é¢˜**ï¼šéªŒè¯å¤šä¸ªäº‹ä»¶å¤„ç†å™¨ä¹‹é—´çš„å¹¶å‘å¤„ç†ä¸ä¼šå¯¼è‡´æ­»é”ã€‚

**mCRL2 è§„èŒƒ**ï¼š

```text
sort Event = struct OrderCreated | PaymentProcessed | OrderShipped;

act produce, consume: Event;

proc
  Producer = sum e:Event . produce(e) . Producer;
  
  Consumer(id: Nat) = 
    sum e:Event . consume(e) . 
      (e == OrderCreated -> consume(PaymentProcessed) . Consumer(id)
       <> Consumer(id));

init
  allow({produce, consume},
    comm({},
      Producer || Consumer(1) || Consumer(2)
    )
  );
```

**éªŒè¯å‘½ä»¤**ï¼š

```bash
# ç¼–è¯‘è§„èŒƒ
mcrl22lps event_processing.mcrl2 event.lps

# ç”ŸæˆçŠ¶æ€ç©ºé—´
lps2lts event.lps event.lts

# æ£€æŸ¥æ­»é”
ltsinfo event.lts
# è¾“å‡ºï¼šæ£€æŸ¥æ˜¯å¦æœ‰ deadlock states
```

---

## 5. å¯è§‚æµ‹æ€§ (Observability)

### 5.1 åˆ†å¸ƒå¼è¿½è¸ª (Distributed Tracing)

**ç›®æ ‡**ï¼šè¿½è¸ªäº‹ä»¶åœ¨ç³»ç»Ÿä¸­çš„ä¼ æ’­è·¯å¾„ã€‚

**OpenTelemetry ç¤ºä¾‹** (Python):

```python
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.jaeger.thrift import JaegerExporter

# é…ç½® Jaeger exporter
jaeger_exporter = JaegerExporter(
    agent_host_name="localhost",
    agent_port=6831,
)

provider = TracerProvider()
provider.add_span_processor(BatchSpanProcessor(jaeger_exporter))
trace.set_tracer_provider(provider)

tracer = trace.get_tracer(__name__)

def publish_event(event):
    with tracer.start_as_current_span("publish_event") as span:
        span.set_attribute("event.type", event["type"])
        span.set_attribute("event.id", event["id"])
        
        # å°† trace context åµŒå…¥äº‹ä»¶çš„ metadata
        event["metadata"]["trace_id"] = format(span.get_span_context().trace_id, '032x')
        event["metadata"]["span_id"] = format(span.get_span_context().span_id, '016x')
        
        kafka_producer.send("events", event)

def consume_event(event):
    # ä»äº‹ä»¶ metadata æå– trace context
    trace_id = int(event["metadata"]["trace_id"], 16)
    span_id = int(event["metadata"]["span_id"], 16)
    
    # åˆ›å»º child span
    with tracer.start_as_current_span(
        "consume_event",
        links=[trace.Link(trace.SpanContext(trace_id, span_id, is_remote=True))]
    ) as span:
        span.set_attribute("consumer.id", "payment-service")
        process_payment(event)
```

### 5.2 äº‹ä»¶ç›‘æ§æŒ‡æ ‡

**å…³é”®æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | è¯´æ˜ | Prometheus æŸ¥è¯¢ |
|------|------|-----------------|
| **äº‹ä»¶ç”Ÿäº§é€Ÿç‡** | æ¯ç§’äº§ç”Ÿçš„äº‹ä»¶æ•° | `rate(events_produced_total[5m])` |
| **äº‹ä»¶æ¶ˆè´¹å»¶è¿Ÿ** | äº‹ä»¶å‘å¸ƒåˆ°æ¶ˆè´¹çš„æ—¶é—´å·® | `histogram_quantile(0.99, event_lag_seconds_bucket)` |
| **æ¶ˆè´¹è€…å¤„ç†æ—¶é—´** | äº‹ä»¶å¤„ç†è€—æ—¶ | `histogram_quantile(0.95, event_processing_duration_seconds_bucket)` |
| **æ­»ä¿¡é˜Ÿåˆ—å¤§å°** | å¤±è´¥äº‹ä»¶ç´¯ç§¯æ•° | `kafka_consumer_group_lag{topic="dlq"}` |

---

## 6. å®æˆ˜æ¡ˆä¾‹ï¼šç”µå•†è®¢å•ç³»ç»Ÿ

### 6.1 ç³»ç»Ÿæ¶æ„

```text
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   API Gateway   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                â”‚                â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
     â”‚OrderService â”‚  â”‚PaymentSvc â”‚  â”‚InventorySvc â”‚
     â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
            â”‚                â”‚                â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Event Bus     â”‚
                    â”‚    (Kafka)      â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚                â”‚                â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
     â”‚EmailService â”‚  â”‚ Warehouse â”‚  â”‚  Analytics  â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 äº‹ä»¶æµè®¾è®¡

**Topic: `order-events`**

```text
OrderCreated â†’ InventoryReserved â†’ PaymentProcessed â†’ OrderShipped â†’ OrderCompleted
     â”‚               â”‚                   â”‚                  â”‚              â”‚
     â””â”€> Email: Confirmation             â”‚                  â”‚              â”‚
                     â””â”€> Warehouse: Pick â”‚                  â”‚              â”‚
                                          â””â”€> Payment Gateway              â”‚
                                                             â””â”€> Email: Tracking
```

**äº‹ä»¶å®šä¹‰**ï¼š

```json
{
  "eventId": "uuid-1234",
  "eventType": "OrderCreated",
  "aggregateId": "order-12345",
  "aggregateType": "Order",
  "timestamp": "2025-10-29T10:00:00Z",
  "version": 1,
  "payload": {
    "customerId": "C001",
    "items": [
      { "productId": "P001", "quantity": 2 }
    ],
    "totalAmount": 100.0
  },
  "metadata": {
    "correlationId": "req-9999",
    "causationId": "event-8888",
    "userId": "admin"
  }
}
```

### 6.3 æ•…éšœå¤„ç†ï¼šSaga æ¨¡å¼

**åœºæ™¯**ï¼šåº“å­˜ä¸è¶³æ—¶éœ€è¦å–æ¶ˆè®¢å•å¹¶é€€æ¬¾ã€‚

**Saga åè°ƒ** (ä½¿ç”¨ Choreography æ¨¡å¼):

```text
OrderService: OrderCreated
     â”‚
     â–¼
InventoryService: InventoryReserved (æˆåŠŸ)
     â”‚
     â–¼
PaymentService: PaymentFailed (ä½™é¢ä¸è¶³)
     â”‚
     â–¼
InventoryService: InventoryReleased (è¡¥å¿)
     â”‚
     â–¼
OrderService: OrderCancelled
```

**Golang ç¤ºä¾‹ï¼šè¡¥å¿å¤„ç†**:

```go
package main

import (
    "encoding/json"
    "github.com/Shopify/sarama"
)

type EventHandler struct {
    producer sarama.SyncProducer
}

func (h *EventHandler) HandlePaymentFailed(event PaymentFailedEvent) {
    // å‘å¸ƒè¡¥å¿äº‹ä»¶
    compensationEvent := InventoryReleasedEvent{
        OrderID:   event.OrderID,
        Reason:    "PaymentFailed",
        Timestamp: time.Now(),
    }
    
    data, _ := json.Marshal(compensationEvent)
    msg := &sarama.ProducerMessage{
        Topic: "inventory-events",
        Key:   sarama.StringEncoder(event.OrderID),
        Value: sarama.ByteEncoder(data),
    }
    
    partition, offset, err := h.producer.SendMessage(msg)
    if err != nil {
        log.Printf("Failed to send compensation event: %v", err)
        // é‡è¯•é€»è¾‘æˆ–å‘Šè­¦
    } else {
        log.Printf("Compensation event sent to partition %d at offset %d", partition, offset)
    }
}
```

---

## 7. æœ€ä½³å®è·µ (Best Practices)

### 7.1 äº‹ä»¶è®¾è®¡åŸåˆ™

1. **äº‹ä»¶å‘½å**ï¼šä½¿ç”¨è¿‡å»æ—¶æ€ï¼ˆOrderCreated è€Œé CreateOrderï¼‰
2. **äº‹ä»¶ä¸å¯å˜**ï¼šäº‹ä»¶ä¸€æ—¦å‘å¸ƒä¸å¯ä¿®æ”¹ï¼ˆé€šè¿‡æ–°äº‹ä»¶ä¿®æ­£ï¼‰
3. **åŒ…å«ä¸Šä¸‹æ–‡**ï¼šäº‹ä»¶åº”æºå¸¦è¶³å¤Ÿä¿¡æ¯ä¾›æ¶ˆè´¹è€…å¤„ç†ï¼ˆé¿å…å›æŸ¥ï¼‰
4. **ç‰ˆæœ¬ç®¡ç†**ï¼šäº‹ä»¶æ¨¡å¼æ¼”è¿›éœ€ä¿æŒå‘åå…¼å®¹

**äº‹ä»¶ç‰ˆæœ¬ç­–ç•¥**ï¼š

```json
{
  "eventType": "OrderCreated",
  "version": 2,
  "payload": {
    "orderId": "123",
    "customerId": "C001",
    "totalAmount": 100.0,
    "currency": "USD"  // v2 æ–°å¢å­—æ®µ
  }
}
```

**æ¶ˆè´¹è€…å…¼å®¹å¤„ç†**ï¼š

```python
def handle_order_created(event):
    version = event.get("version", 1)  # é»˜è®¤ç‰ˆæœ¬1
    
    if version == 1:
        currency = "USD"  # é»˜è®¤å€¼
    elif version == 2:
        currency = event["payload"]["currency"]
    
    process_order(event["payload"], currency)
```

### 7.2 å¹‚ç­‰æ€§ä¿è¯

**é—®é¢˜**ï¼šæ¶ˆè´¹è€…å¯èƒ½é‡å¤æ¶ˆè´¹äº‹ä»¶ï¼ˆç½‘ç»œé‡ä¼ ã€Kafka rebalanceï¼‰ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š

#### æ–¹æ¡ˆ1ï¼šåŸºäºäº‹ä»¶IDå»é‡

```python
import redis

redis_client = redis.Redis(host='localhost', port=6379)

def consume_event(event):
    event_id = event["eventId"]
    
    # æ£€æŸ¥äº‹ä»¶æ˜¯å¦å·²å¤„ç†
    if redis_client.sismember("processed_events", event_id):
        print(f"Event {event_id} already processed, skipping")
        return
    
    # å¤„ç†äº‹ä»¶
    process_event(event)
    
    # æ ‡è®°ä¸ºå·²å¤„ç†ï¼ˆè®¾ç½® 24 å°æ—¶è¿‡æœŸï¼‰
    redis_client.sadd("processed_events", event_id)
    redis_client.expire("processed_events", 86400)
```

#### æ–¹æ¡ˆ2ï¼šä¸šåŠ¡é€»è¾‘å¹‚ç­‰

```sql
-- æ•°æ®åº“å±‚é¢ä¿è¯å¹‚ç­‰ï¼ˆä½¿ç”¨ ON CONFLICT æˆ– INSERT IGNOREï¼‰
INSERT INTO orders (order_id, customer_id, amount)
VALUES ('order-123', 'C001', 100.0)
ON CONFLICT (order_id) DO NOTHING;
```

### 7.3 ç›‘æ§ä¸å‘Šè­¦

**å…³é”®å‘Šè­¦è§„åˆ™**ï¼š

```yaml
# Prometheus AlertManager é…ç½®
groups:
  - name: event_processing
    rules:
      - alert: HighEventLag
        expr: kafka_consumer_group_lag > 10000
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Consumer lag exceeded 10k events"
          
      - alert: DeadLetterQueueGrowing
        expr: rate(dlq_events_total[5m]) > 10
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "Dead letter queue growing rapidly"
```

---

## 8. æŒ‘æˆ˜ä¸æƒè¡¡ (Challenges & Tradeoffs)

### 8.1 æœ€ç»ˆä¸€è‡´æ€§ (Eventual Consistency)

**é—®é¢˜**ï¼šäº‹ä»¶ä¼ æ’­æœ‰å»¶è¿Ÿï¼ŒçŸ­æœŸå†…æ•°æ®å¯èƒ½ä¸ä¸€è‡´ã€‚

**ç¤ºä¾‹**ï¼š

- ç”¨æˆ·ä¸‹å•åç«‹å³æŸ¥è¯¢è®¢å•çŠ¶æ€ï¼Œå¯èƒ½æ˜¾ç¤º"å¤„ç†ä¸­"è€Œé"å·²åˆ›å»º"ï¼ˆäº‹ä»¶å°šæœªè¢«æŸ¥è¯¢æœåŠ¡æ¶ˆè´¹ï¼‰

**è§£å†³ç­–ç•¥**ï¼š

- **å®¢æˆ·ç«¯é‡è¯•**ï¼šå‰ç«¯è½®è¯¢æˆ– WebSocket æ¨é€æ›´æ–°
- **ä¹è§‚UI**ï¼šå…ˆå±•ç¤ºé¢„æœŸçŠ¶æ€ï¼Œåå°å¼‚æ­¥åŒæ­¥

### 8.2 äº‹ä»¶é¡ºåºé—®é¢˜

**é—®é¢˜**ï¼šKafka åªä¿è¯åˆ†åŒºå†…é¡ºåºï¼Œè·¨åˆ†åŒºæ¶ˆæ¯å¯èƒ½ä¹±åºã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š

- **ä½¿ç”¨ç›¸åŒ Key**ï¼šåŒä¸€è®¢å•çš„æ‰€æœ‰äº‹ä»¶ä½¿ç”¨ `orderId` ä½œä¸º Keyï¼Œä¿è¯è¿›å…¥åŒä¸€åˆ†åŒº
- **Version Vector**ï¼šåœ¨äº‹ä»¶ä¸­æºå¸¦ç‰ˆæœ¬å·ï¼Œæ¶ˆè´¹è€…æ£€æµ‹ä¹±åº

### 8.3 è°ƒè¯•å¤æ‚æ€§

**é—®é¢˜**ï¼šäº‹ä»¶é©±åŠ¨ç³»ç»Ÿçš„è°ƒç”¨é“¾åˆ†æ•£åœ¨å¤šä¸ªæœåŠ¡å’Œäº‹ä»¶æµä¸­ã€‚

**è§£å†³å·¥å…·**ï¼š

- **Distributed Tracing**ï¼šJaeger, Zipkin
- **Event Store UI**ï¼šEventStoreDB Dashboard
- **Kafka UI**ï¼šKafdrop, AKHQ

---

## 9. å¤§å­¦è¯¾ç¨‹æ˜ å°„ (University Course Alignment)

### 9.1 å¯¹åº”è¯¾ç¨‹

| ä¸»é¢˜ | æ¨èè¯¾ç¨‹ | æ•™æ/èµ„æº |
|------|---------|----------|
| **äº‹ä»¶é©±åŠ¨æ¶æ„** | è½¯ä»¶æ¶æ„ (Software Architecture) | [Designing Data-Intensive Applications](https://dataintensive.net) (Martin Kleppmann) |
| **æ¶ˆæ¯é˜Ÿåˆ—** | åˆ†å¸ƒå¼ç³»ç»Ÿ (Distributed Systems) | MIT 6.824 |
| **å¤æ‚äº‹ä»¶å¤„ç†** | æµå¤„ç† (Stream Processing) | [Streaming Systems](https://www.oreilly.com/library/view/streaming-systems/9781491983867/) (Tyler Akidau) |
| **Event Sourcing** | é¢†åŸŸé©±åŠ¨è®¾è®¡ (DDD) | [Event Sourcing Basics](https://eventstore.com/event-sourcing) |
| **å½¢å¼åŒ–éªŒè¯** | å½¢å¼åŒ–æ–¹æ³• (Formal Methods) | TLA+ å®˜æ–¹æ•™ç¨‹ <https://lamport.azurewebsites.net/tla/tla.html> |

### 9.2 å®è·µé¡¹ç›®å»ºè®®

1. **æ„å»ºå¾®å‹ Event Store**
   - ä½¿ç”¨ PostgreSQL å­˜å‚¨äº‹ä»¶æµ
   - å®ç°ä¹è§‚å¹¶å‘æ§åˆ¶
   - æ”¯æŒå¿«ç…§ï¼ˆSnapshotï¼‰ä¼˜åŒ–

2. **å®ç° Saga åè°ƒå™¨**
   - é€‰æ‹© Choreography æˆ– Orchestration æ¨¡å¼
   - å¤„ç†è¡¥å¿é€»è¾‘
   - ä½¿ç”¨ mCRL2 éªŒè¯æ— æ­»é”

3. **æµå¤„ç†å®æ—¶åˆ†æ**
   - ä½¿ç”¨ Apache Flink å¤„ç† Kafka æµ
   - å®ç°æ»‘åŠ¨çª—å£èšåˆ
   - è¾“å‡ºåˆ° Elasticsearch å¯è§†åŒ–

---

## 10. å·¥å…·é“¾æ€»ç»“ (Toolchain Summary)

| ç±»åˆ« | å·¥å…· | ç”¨é€” |
|------|------|------|
| **æ¶ˆæ¯ä¸­é—´ä»¶** | Kafka, RabbitMQ, Pulsar | äº‹ä»¶ä¼ è¾“ |
| **äº‹ä»¶å­˜å‚¨** | EventStoreDB, Axon Server | Event Sourcing |
| **æµå¤„ç†** | Apache Flink, Kafka Streams, Spark Streaming | å®æ—¶è®¡ç®— |
| **CEP** | Esper, Drools Fusion | å¤æ‚äº‹ä»¶æ£€æµ‹ |
| **å½¢å¼åŒ–éªŒè¯** | TLA+, mCRL2, Alloy | æ­£ç¡®æ€§éªŒè¯ |
| **å¯è§‚æµ‹æ€§** | OpenTelemetry, Jaeger, Prometheus | è¿½è¸ªç›‘æ§ |
| **æ¶æ„éªŒè¯** | ArchUnit, Structure101 | æ¶æ„çº¦æŸæ£€æŸ¥ |

---

## 11. æ€»ç»“ (Summary)

äº‹ä»¶é©±åŠ¨æ¶æ„é€šè¿‡å¼‚æ­¥äº‹ä»¶é€šä¿¡å®ç°é«˜åº¦è§£è€¦çš„åˆ†å¸ƒå¼ç³»ç»Ÿï¼Œæ ¸å¿ƒè¦ç´ åŒ…æ‹¬ï¼š

1. **äº‹ä»¶å»ºæ¨¡**ï¼šè®¾è®¡ä¸å¯å˜ã€è¯­ä¹‰æ˜ç¡®çš„äº‹ä»¶
2. **æ¶ˆæ¯ä¸­é—´ä»¶**ï¼šé€‰æ‹©åˆé€‚çš„äº‹ä»¶æ€»çº¿ï¼ˆKafka, RabbitMQï¼‰
3. **Event Sourcing**ï¼šé€šè¿‡äº‹ä»¶æµé‡å»ºçŠ¶æ€
4. **å¤æ‚äº‹ä»¶å¤„ç†**ï¼šå®æ—¶æ£€æµ‹æ¨¡å¼å’Œå¼‚å¸¸
5. **å½¢å¼åŒ–éªŒè¯**ï¼šä½¿ç”¨ TLA+/mCRL2 ä¿è¯ç³»ç»Ÿæ€§è´¨
6. **å¯è§‚æµ‹æ€§**ï¼šåˆ†å¸ƒå¼è¿½è¸ªå’Œç›‘æ§

**é€‚ç”¨åœºæ™¯**ï¼š

- å¾®æœåŠ¡æ¶æ„
- å®æ—¶æ•°æ®å¤„ç†
- éœ€è¦å®¡è®¡æ—¥å¿—çš„ç³»ç»Ÿ
- é«˜å¯ç”¨ã€å¯æ‰©å±•ç³»ç»Ÿ

**å…³é”®æŒ‘æˆ˜**ï¼š

- æœ€ç»ˆä¸€è‡´æ€§
- äº‹ä»¶é¡ºåºä¿è¯
- è°ƒè¯•å¤æ‚æ€§
- è¿ç»´æˆæœ¬

---

## 12. æ‰©å±•é˜…è¯» (Further Reading)

1. **Martin Fowler: Event-Driven Architecture**  
   <https://martinfowler.com/articles/201701-event-driven.html>

2. **Apache Kafka Documentation**  
   <https://kafka.apache.org/documentation/>

3. **Event Sourcing Pattern (Microsoft)**  
   <https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing>

4. **Designing Event-Driven Systems** (Ben Stopford)  
   <https://www.confluent.io/designing-event-driven-systems/>

5. **TLA+ Examples: Kafka Replication**  
   <https://github.com/lemmy/kafka-tlaplus>

---

## 13. æœ¬åœ°é¡¹ç›®äº¤å‰å¼•ç”¨ (Cross-References)

- **å¾®æœåŠ¡æ¶æ„**ï¼š[[04.2_Microservices_Architecture.md]] - äº‹ä»¶é©±åŠ¨æ˜¯å¾®æœåŠ¡é€šä¿¡çš„æ ¸å¿ƒæ¨¡å¼
- **åˆ†å¸ƒå¼æ¨¡å¼**ï¼š[[02.2_Distributed_Patterns.md]] - Saga, CQRS è¯¦è§£
- **å¤æ‚æ€§ç†è®º**ï¼š[[03.1_Multidimensional_Complexity.md]] - é€šä¿¡å¤æ‚åº¦åˆ†æ
- **å½¢å¼åŒ–éªŒè¯**ï¼š[[05_Formal_Verification/]] - TLA+, mCRL2 å·¥å…·è¯¦è§£

---

**ç‰ˆæœ¬ä¿¡æ¯**ï¼š

- åˆ›å»ºæ—¥æœŸï¼š2025-10-29
- æœ€åæ›´æ–°ï¼š2025-10-29
- ç»´æŠ¤è€…ï¼šProgram-Algorithm-Design Perspective Team
