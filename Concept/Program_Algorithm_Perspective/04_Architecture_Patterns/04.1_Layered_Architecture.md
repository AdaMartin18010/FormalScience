# 分层架构（Layered Architecture）

## 📊 核心概念深度分析

<details>
<summary><b>📚🔬 点击展开：分层架构核心洞察</b></summary>

**终极洞察**: 分层=关注点分离的经典实现。核心约束：单向依赖，Lᵢ只能调用Lᵢ₊₁，形成依赖链L₁→L₂→...→Lₙ。经典实例：①OSI七层网络模型：应用→表示→会话→传输→网络→数据链路→物理，每层协议独立演化②三层Web应用：表示层（UI）→业务逻辑层→数据访问层③DDD四层：用户接口→应用层→领域层→基础设施层。优势：①层独立开发测试②接口稳定易替换③关注点清晰。挑战：①层间通信开销②严格分层vs放松分层（允许跨层）权衡③"沉底"反模式（底层承载过多逻辑）。架构变体：①六边形架构（端口-适配器）：业务核心在中心，外围是适配器②洋葱架构：依赖向内，领域模型最核心③清洁架构：依赖规则+测试隔离。形式化验证：用DAG（有向无环图）表示依赖，检测循环依赖、验证无跨层调用。工具：ArchUnit/NDepend实施架构规则。关键：分层架构牺牲性能换取可维护性和演化能力。

</details>

---

## 📋 目录

- [📊 核心概念深度分析](#-核心概念深度分析)
- [📋 目录](#-目录)
- [概述](#概述)
- [1. 经典分层模型](#1-经典分层模型)
  - [1.1 OSI 七层模型（网络协议）](#11-osi-七层模型网络协议)
  - [1.2 三层 Web 应用](#12-三层-web-应用)
    - [示例（Spring MVC）](#示例spring-mvc)
  - [1.3 四层架构（DDD 视角）](#13-四层架构ddd-视角)
- [2. 形式化分层约束](#2-形式化分层约束)
  - [2.1 依赖规则](#21-依赖规则)
  - [2.2 无环性验证](#22-无环性验证)
- [3. 层间通信模式](#3-层间通信模式)
  - [3.1 同步调用](#31-同步调用)
  - [3.2 异步消息](#32-异步消息)
  - [3.3 回调注入](#33-回调注入)
- [4. 分层性能优化](#4-分层性能优化)
  - [4.1 层间缓存](#41-层间缓存)
  - [4.2 批量操作](#42-批量操作)
  - [4.3 层穿透（Bypass）](#43-层穿透bypass)
- [5. 微内核变体（Microkernel + Layers）](#5-微内核变体microkernel--layers)
- [6. 六边形架构（Hexagonal Architecture）](#6-六边形架构hexagonal-architecture)
- [7. 洋葱架构（Onion Architecture）](#7-洋葱架构onion-architecture)
- [8. 形式化验证](#8-形式化验证)
  - [8.1 依赖约束验证](#81-依赖约束验证)
  - [8.2 性能建模](#82-性能建模)
- [9. 实际案例](#9-实际案例)
  - [9.1 Spring Boot 三层架构](#91-spring-boot-三层架构)
  - [9.2 Android 架构组件](#92-android-架构组件)
- [10. 大学课程对应](#10-大学课程对应)
- [11. 教材对应](#11-教材对应)
- [12. 本地项目引用](#12-本地项目引用)
- [13. 总结](#13-总结)
  - [核心洞察](#核心洞察)
  - [工具链推荐](#工具链推荐)
  - [实战建议](#实战建议)
- [附录 A：分层架构 Checklist](#附录-a分层架构-checklist)
- [附录 B：Wikipedia 概念对照](#附录-bwikipedia-概念对照)

---

## 概述

**分层架构**是最经典的架构模式，将系统组织成**层次**，每层只能依赖下层。核心思想：

```text
分层 = 关注点分离 + 单向依赖 + 抽象层次

形式化：
  Layers = ⟨L₁, L₂, ..., Lₙ⟩
  Dependency: ∀i, Lᵢ → Lᵢ₊₁
  Constraint: 无向上依赖、无跨层依赖
```

**优点**：

- 关注点分离
- 层独立演化
- 可替换性
- 可测试性

**缺点**：

- 性能开销（层间调用）
- 过度抽象
- 难以跨层优化

---

## 1. 经典分层模型

### 1.1 OSI 七层模型（网络协议）

```text
7. 应用层 (Application)  - HTTP, FTP, SMTP
6. 表示层 (Presentation) - 加密、编码
5. 会话层 (Session)      - 会话管理
4. 传输层 (Transport)    - TCP, UDP
3. 网络层 (Network)      - IP, 路由
2. 数据链路层 (Data Link) - MAC, 以太网
1. 物理层 (Physical)     - 电信号
```

**形式化**：

```text
Layerᵢ 提供服务接口 Sᵢ
Layerᵢ 使用 Layerᵢ₊₁ 的服务

封装：
  发送：Data → 应用头 + Data → ... → 物理信号
  接收：物理信号 → ... → 应用头 + Data → Data
```

### 1.2 三层 Web 应用

```text
Presentation Layer (展示层)
    ↓
Business Logic Layer (业务逻辑层)
    ↓
Data Access Layer (数据访问层)
    ↓
Database (数据库)
```

**职责分离**：

```text
Presentation：
  - UI 渲染
  - 用户交互
  - 输入验证

Business Logic：
  - 业务规则
  - 事务管理
  - 领域模型

Data Access：
  - SQL 查询
  - ORM 映射
  - 缓存
```

#### 示例（Spring MVC）

```java
// Presentation Layer (Controller)
@RestController
@RequestMapping("/api/users")
public class UserController {
    @Autowired
    private UserService userService;

    @GetMapping("/{id}")
    public UserDTO getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
}

// Business Logic Layer (Service)
@Service
@Transactional
public class UserService {
    @Autowired
    private UserRepository userRepository;

    public UserDTO findById(Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new NotFoundException());
        return UserDTO.from(user);
    }
}

// Data Access Layer (Repository)
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findById(Long id);
}
```

### 1.3 四层架构（DDD 视角）

```text
User Interface Layer (用户接口层)
    ↓
Application Layer (应用层)
    ↓
Domain Layer (领域层)
    ↓
Infrastructure Layer (基础设施层)
```

**职责细化**：

```text
User Interface：
  - REST API
  - GraphQL
  - Web UI

Application：
  - 用例编排
  - DTO 转换
  - 权限检查

Domain：
  - 领域模型
  - 业务规则
  - 领域事件

Infrastructure：
  - 数据库
  - 消息队列
  - 第三方服务
```

---

## 2. 形式化分层约束

### 2.1 依赖规则

**严格分层**（Strict Layering）：

```text
∀层 Lᵢ, 只能调用 Lᵢ₊₁

形式化：
  Dependency Graph G = (V, E)
  V = {L₁, L₂, ..., Lₙ}
  E ⊆ {(Lᵢ, Lᵢ₊₁) | i < n}
```

**宽松分层**（Relaxed Layering）：

```text
∀层 Lᵢ, 可以调用 {Lᵢ₊₁, Lᵢ₊₂, ..., Lₙ}

E ⊆ {(Lᵢ, Lⱼ) | i < j}
```

### 2.2 无环性验证

**定理**（分层必无环）：

```text
若 Dependency Graph 是 DAG，则无循环依赖
```

**验证方法**：拓扑排序

**工具**（静态分析）：

```bash
# 使用 jdeps 分析 Java 依赖
jdeps -verbose:class -recursive my-app.jar

# 使用 ArchUnit 验证架构规则
@ArchTest
static ArchRule layers_should_respect_hierarchy =
    layeredArchitecture()
        .layer("Presentation").definedBy("..controller..")
        .layer("Business").definedBy("..service..")
        .layer("Data").definedBy("..repository..")
        .whereLayer("Presentation").mayNotBeAccessedByAnyLayer()
        .whereLayer("Business").mayOnlyBeAccessedByLayers("Presentation")
        .whereLayer("Data").mayOnlyBeAccessedByLayers("Business");
```

---

## 3. 层间通信模式

### 3.1 同步调用

```text
Layerᵢ → call(method, params) → Layerᵢ₊₁
          ← return(result) ←
```

**优点**：简单、易理解  
**缺点**：阻塞、耦合

### 3.2 异步消息

```text
Layerᵢ → publish(event) → Event Bus
                            ↓
                         Layerᵢ₊₁ ← subscribe
```

**优点**：解耦、并行  
**缺点**：复杂性、最终一致性

### 3.3 回调注入

```text
Layerᵢ 提供接口 I
Layerᵢ₊₁ 实现 I
Layerᵢ₊₁ 注入到 Layerᵢ
```

**示例**（依赖倒置 DIP）：

```java
// Domain Layer (高层)
public interface UserRepository {
    User findById(Long id);
}

// Infrastructure Layer (低层)
public class JpaUserRepository implements UserRepository {
    @Override
    public User findById(Long id) {
        // JPA implementation
    }
}

// 依赖方向：Infrastructure → Domain（倒置！）
```

---

## 4. 分层性能优化

### 4.1 层间缓存

```text
Presentation Layer
    ↓
Cache (L1)
    ↓
Business Layer
    ↓
Cache (L2)
    ↓
Data Access Layer
```

**策略**：

- L1：会话级缓存（用户特定）
- L2：全局缓存（共享数据）

### 4.2 批量操作

**问题**：N+1 查询

```java
// 坏：每个用户单独查询订单
for (User user : users) {
    List<Order> orders = orderService.findByUserId(user.getId());
}
```

**解决**：批量加载

```java
// 好：一次查询所有订单
Set<Long> userIds = users.stream().map(User::getId).collect(toSet());
Map<Long, List<Order>> ordersByUser = orderService.findByUserIds(userIds);
```

### 4.3 层穿透（Bypass）

**场景**：读多写少，绕过业务层直接查询

```text
Query: Presentation → Data (bypass Business)
Command: Presentation → Business → Data
```

**风险**：破坏分层纯度

---

## 5. 微内核变体（Microkernel + Layers）

```text
Core Layer (微内核)
    ↑
Plugin A | Plugin B | Plugin C
```

**特点**：

- Core 提供基础服务
- Plugins 扩展功能
- 插件可独立部署

**示例**：Eclipse IDE

```java
// Core
public interface Extension {
    void execute(Context ctx);
}

// Plugin
public class MyPlugin implements Extension {
    @Override
    public void execute(Context ctx) {
        // Plugin logic
    }
}

// Registry
public class ExtensionRegistry {
    private Map<String, Extension> extensions = new HashMap<>();

    public void register(String id, Extension ext) {
        extensions.put(id, ext);
    }

    public void execute(String id, Context ctx) {
        extensions.get(id).execute(ctx);
    }
}
```

---

## 6. 六边形架构（Hexagonal Architecture）

**核心思想**：端口与适配器

```text
        Adapter (REST)
             ↓
        Port (Interface)
             ↓
    Domain (Business Logic) ← Port → Adapter (DB)
             ↑
        Port
             ↑
        Adapter (Message Queue)
```

**定义**：

```text
Port: 应用的边界接口
Adapter: 外部技术的实现

依赖方向：
  Adapter → Port → Domain
```

**示例**：

```java
// Port (Domain)
public interface PaymentGateway {
    PaymentResult charge(Amount amount);
}

// Adapter (Infrastructure)
public class StripeAdapter implements PaymentGateway {
    private StripeClient client;

    @Override
    public PaymentResult charge(Amount amount) {
        return client.charge(amount.toStripe());
    }
}

// Domain Service
public class OrderService {
    private final PaymentGateway paymentGateway;

    public OrderService(PaymentGateway paymentGateway) {
        this.paymentGateway = paymentGateway;
    }

    public Order checkout(Cart cart) {
        PaymentResult result = paymentGateway.charge(cart.total());
        // ...
    }
}
```

---

## 7. 洋葱架构（Onion Architecture）

```text
              UI
             /  \
        Infrastructure
           /      \
      Application
         /    \
       Domain
```

**特点**：

- 依赖向内（内层不依赖外层）
- Domain 是核心，无依赖
- Infrastructure 在外层

**与分层架构的区别**：

| 维度 | 分层架构 | 洋葱架构 |
|------|----------|----------|
| **依赖方向** | 单向向下 | 向内聚合 |
| **核心** | 数据库 | 领域模型 |
| **可测试性** | 一般 | 高（内层可独立测试） |

---

## 8. 形式化验证

### 8.1 依赖约束验证

**Coq 形式化**：

```coq
Require Import Coq.Lists.List.
Import ListNotations.

(* 层定义 *)
Inductive Layer : Type :=
| Presentation : Layer
| Business : Layer
| Data : Layer.

(* 依赖关系 *)
Definition allowed_dependency (from to : Layer) : Prop :=
  match from, to with
  | Presentation, Business => True
  | Presentation, Data => True  (* 宽松分层 *)
  | Business, Data => True
  | _, _ => False
  end.

(* 依赖图 *)
Definition DependencyGraph := list (Layer * Layer).

(* 验证图是否合法 *)
Fixpoint valid_graph (g : DependencyGraph) : Prop :=
  match g with
  | [] => True
  | (from, to) :: rest =>
      allowed_dependency from to /\ valid_graph rest
  end.

(* 示例 *)
Definition example_graph : DependencyGraph :=
  [(Presentation, Business); (Business, Data)].

Theorem example_valid : valid_graph example_graph.
Proof.
  unfold example_graph, valid_graph.
  split. unfold allowed_dependency. auto.
  split. unfold allowed_dependency. auto.
  auto.
Qed.
```

### 8.2 性能建模

**UPPAAL 建模**（层间延迟）：

```text
// 层模型
process Presentation() {
  clock c;
  state idle, calling;
  
  idle -> calling { c = 0 }
  calling -> idle when c >= 10 { sync Business!call }
}

process Business() {
  clock c;
  state idle, processing;
  
  idle -> processing { sync call? }
  processing -> idle when c >= 50 { sync Data!query }
}

process Data() {
  clock c;
  state idle, querying;
  
  idle -> querying { sync query? }
  querying -> idle when c >= 100 { }
}

// 验证端到端延迟 ≤ 200ms
A[] Presentation.idle imply c <= 200
```

---

## 9. 实际案例

### 9.1 Spring Boot 三层架构

```text
@Controller (Presentation)
    ↓
@Service (Business)
    ↓
@Repository (Data)
    ↓
Database
```

**依赖注入**：

```java
@Configuration
public class AppConfig {
    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();
    }

    @Bean
    public UserRepository userRepository(DataSource ds) {
        return new JpaUserRepository(ds);
    }

    @Bean
    public UserService userService(UserRepository repo) {
        return new UserServiceImpl(repo);
    }

    @Bean
    public UserController userController(UserService svc) {
        return new UserController(svc);
    }
}
```

### 9.2 Android 架构组件

```text
Activity/Fragment (UI)
    ↓
ViewModel (Presentation Logic)
    ↓
Repository (Data Abstraction)
    ↓
Data Source (Local/Remote)
```

**特点**：

- ViewModel 生命周期独立
- Repository 统一数据接口
- LiveData 响应式更新

---

## 10. 大学课程对应

| 课程 | 相关章节 |
|------|----------|
| **CMU 17-313 软件工程** | 分层架构、依赖管理 |
| **Stanford CS 142 Web 应用** | 三层架构 |
| **MIT 6.033 系统工程** | OSI 模型 |
| **UC Berkeley CS 169 软件工程** | MVC、MVVM |

---

## 11. 教材对应

| 教材 | 相关章节 |
|------|----------|
| **Pattern-Oriented Software Architecture** (POSA) | Vol 1, Ch 2 |
| **Domain-Driven Design** (Evans) | Ch 4 (Layered Architecture) |
| **Clean Architecture** (Martin) | Ch 17-22 |
| **Implementing Domain-Driven Design** (Vernon) | Ch 4 |

---

## 12. 本地项目引用

- `04.0_Architecture_Overview.md` - 架构模式总览
- `../02_Design_Patterns/02.1_GoF_Formal_Analysis.md` - 分层中的设计模式
- `../../Software_Perspective/01_Foundational_Theory/01.4_Composability_Modularity.md` - 模块化理论

---

## 13. 总结

### 核心洞察

```text
分层架构 = 关注点分离 + 单向依赖

关键约束：
  1. 层间接口明确
  2. 依赖单向（向下或向内）
  3. 无跨层调用

变体：
  - 严格分层 vs 宽松分层
  - 六边形架构（端口-适配器）
  - 洋葱架构（依赖向内）
```

### 工具链推荐

| 场景 | 推荐工具 |
|------|----------|
| **依赖验证** | ArchUnit (Java), NDepend (.NET) |
| **可视化** | Structure101, Lattix |
| **静态分析** | jdeps, SonarQube |
| **性能建模** | UPPAAL |

### 实战建议

1. **起步**：从标准三层开始
2. **进阶**：引入 DIP（依赖倒置）
3. **优化**：加缓存、批量操作
4. **演进**：按需迁移到六边形/洋葱架构
5. **守护**：用 ArchUnit 持续验证架构约束

---

## 附录 A：分层架构 Checklist

- [ ] 每层职责清晰
- [ ] 依赖方向单一
- [ ] 层间接口稳定
- [ ] 无循环依赖
- [ ] 层可独立测试
- [ ] 性能瓶颈已识别
- [ ] 有监控指标（每层延迟）
- [ ] ArchUnit 测试通过

---

## 附录 B：Wikipedia 概念对照

| 概念 | Wikipedia 条目 | 本文章节 |
|------|----------------|----------|
| Layered Architecture | <https://en.wikipedia.org/wiki/Multitier_architecture> | §1 |
| OSI Model | <https://en.wikipedia.org/wiki/OSI_model> | §1.1 |
| Hexagonal Architecture | <https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)> | §6 |
| Dependency Inversion | <https://en.wikipedia.org/wiki/Dependency_inversion_principle> | §3.3 |

---

**版本**：v1.0  
**最后更新**：2025-10-29  
**维护者**：FormalScience Project  
**许可**：CC BY-SA 4.0
