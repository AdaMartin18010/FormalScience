# 微服务架构

## 📊 核心概念深度分析

<details>
<summary><b>🔬🌐 点击展开：微服务架构核心洞察</b></summary>

**终极洞察**: 微服务=分布式系统的系统化实践。核心原则：①单一职责：每个服务专注一个业务能力②独立部署：服务间解耦，独立发版③数据库分离：Database per Service，避免共享数据库④去中心化：服务自治，没有中央协调器⑤失败隔离：单服务故障不级联。架构组件：①API网关：统一入口，路由/认证/限流②服务发现：动态注册发现（Consul/Eureka）③服务网格：Istio/Linkerd，透明处理通信/安全/可观测性。通信模式：①同步：REST/gRPC，简单直观但耦合强②异步：消息队列/事件总线，解耦但复杂度高。数据一致性：放弃ACID强一致，拥抱最终一致性+Saga补偿。可观测性三支柱：①分布式追踪（Jaeger/Zipkin）：跨服务请求链路②度量监控（Prometheus）：服务健康/性能指标③日志聚合（ELK）：集中式日志分析。形式化验证：用TLA+验证分布式协议（Raft/Paxos），用契约测试验证服务接口。挑战：分布式复杂度、数据一致性、测试难度。关键：微服务用架构复杂度换组织扩展性和系统韧性。

</details>

---

## 📋 目录

- [📊 核心概念深度分析](#核心概念深度分析)
- [📋 目录](#目录)
- [概述](#概述)
- [1. 微服务核心组件](#1-微服务核心组件)
  - [1.1 服务定义](#11-服务定义)
  - [1.2 API 网关](#12-api-网关)
  - [1.3 服务发现](#13-服务发现)
- [2. 通信模式](#2-通信模式)
  - [2.1 同步通信（HTTP REST）](#21-同步通信http-rest)
  - [2.2 异步通信（消息队列）](#22-异步通信消息队列)
  - [2.3 gRPC（高性能 RPC）](#23-grpc高性能-rpc)
- [3. 数据管理](#3-数据管理)
  - [3.1 Database per Service](#31-database-per-service)
  - [3.2 Saga 模式（分布式事务）](#32-saga-模式分布式事务)
- [4. 服务网格（Service Mesh）](#4-服务网格service-mesh)
  - [4.1 Istio 架构](#41-istio-架构)
  - [4.2 Linkerd（轻量级）](#42-linkerd轻量级)
- [5. 可观测性](#5-可观测性)
  - [5.1 分布式追踪（OpenTelemetry）](#51-分布式追踪opentelemetry)
  - [5.2 度量监控（Prometheus + Grafana）](#52-度量监控prometheus-grafana)
  - [5.3 日志聚合（ELK Stack）](#53-日志聚合elk-stack)
- [6. 形式化验证](#6-形式化验证)
  - [6.1 TLA+ 建模（一致性）](#61-tla-建模一致性)
  - [6.2 mCRL2 建模（并发）](#62-mcrl2-建模并发)
- [7. 实际案例](#7-实际案例)
  - [7.1 Netflix](#71-netflix)
  - [7.2 Amazon](#72-amazon)
  - [7.3 Uber](#73-uber)
- [8. 最佳实践](#8-最佳实践)
  - [8.1 服务拆分原则](#81-服务拆分原则)
  - [8.2 API 版本管理](#82-api-版本管理)
  - [8.3 部署策略](#83-部署策略)
- [9. 大学课程对应](#9-大学课程对应)
- [快速参考](#快速参考)
  - [核心组件](#核心组件)
  - [工具链](#工具链)
- [附录：Wikipedia 概念对照](#附录wikipedia-概念对照)

---

## 概述

**微服务架构**（Microservices Architecture）是一种将应用程序构建为**小型、独立、松耦合服务集合**的架构风格，每个服务实现一个**业务能力**，通过**轻量级机制**（通常是 HTTP REST API）通信。

**核心原则**：

```text
微服务 = 独立部署 + 业务隔离 + 去中心化治理

形式化：
  System = ⟨Services, Communication, Data⟩
    Services: {S₁, S₂, ..., Sₙ}
    Communication: API Gateway + Service Mesh
    Data: 每服务独立数据库（Database per Service）

特点：
  - 独立部署：每个服务独立发布
  - 技术异构：服务可用不同语言/框架
  - 故障隔离：服务崩溃不影响全局
  - 可扩展：按需水平扩展
```

**对比单体架构**：

| 维度 | 单体架构 | 微服务架构 |
|------|----------|------------|
| **部署** | 整体打包 | 独立部署 |
| **扩展** | 垂直扩展 | 水平扩展 |
| **技术栈** | 统一 | 异构 |
| **开发团队** | 集中式 | 分布式 |
| **故障影响** | 全局 | 局部 |
| **复杂度** | 低 | 高 |

---

## 1. 微服务核心组件

### 1.1 服务定义

**接口规范**（OpenAPI）：

```yaml
openapi: 3.0.0
info:
  title: Order Service API
  version: 1.0.0

paths:
  /orders:
    post:
      summary: Create order
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Order'
      responses:
        '201':
          description: Order created
        '400':
          description: Invalid request

components:
  schemas:
    Order:
      type: object
      required:
        - customerId
        - items
      properties:
        orderId:
          type: string
          format: uuid
        customerId:
          type: string
        items:
          type: array
          items:
            $ref: '#/components/schemas/OrderItem'
```

**gRPC 定义**：

```protobuf
syntax = "proto3";

package order;

service OrderService {
  rpc CreateOrder (CreateOrderRequest) returns (CreateOrderResponse);
  rpc GetOrder (GetOrderRequest) returns (GetOrderResponse);
  rpc CancelOrder (CancelOrderRequest) returns (CancelOrderResponse);
}

message CreateOrderRequest {
  string customer_id = 1;
  repeated OrderItem items = 2;
}

message CreateOrderResponse {
  string order_id = 1;
  OrderStatus status = 2;
}

enum OrderStatus {
  PENDING = 0;
  CONFIRMED = 1;
  CANCELLED = 2;
  COMPLETED = 3;
}
```

### 1.2 API 网关

**职责**：

```text
API Gateway = 请求路由 + 认证授权 + 限流 + 负载均衡

形式化：
  Request → Gateway → Route(Request.path) → Service

路由规则：
  /api/orders/** → Order Service
  /api/users/** → User Service
  /api/inventory/** → Inventory Service
```

**Kong 配置示例**：

```yaml
services:
  - name: order-service
    url: http://order-service:8080
    routes:
      - name: order-route
        paths:
          - /api/orders
        methods:
          - GET
          - POST
        plugins:
          - name: rate-limiting
            config:
              minute: 100
              policy: local
          - name: jwt
            config:
              key_claim_name: iss
```

**Envoy 配置**（Istio 底层）：

```yaml
static_resources:
  listeners:
  - address:
      socket_address:
        address: 0.0.0.0
        port_value: 10000
    filter_chains:
    - filters:
      - name: envoy.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          stat_prefix: ingress_http
          route_config:
            name: local_route
            virtual_hosts:
            - name: backend
              domains:
              - "*"
              routes:
              - match:
                  prefix: "/api/orders"
                route:
                  cluster: order_service
          http_filters:
          - name: envoy.filters.http.router

  clusters:
  - name: order_service
    connect_timeout: 0.25s
    type: STRICT_DNS
    lb_policy: ROUND_ROBIN
    load_assignment:
      cluster_name: order_service
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: order-service
                port_value: 8080
```

### 1.3 服务发现

**注册中心模式**：

```text
Service Registry = ⟨Services, Health, Discovery⟩

操作：
  - register(service, address): 注册服务
  - deregister(service): 注销服务
  - discover(service): 查询服务地址
  - health_check(service): 健康检查
```

**Consul 示例**（Go 客户端）：

```go
package main

import (
    "github.com/hashicorp/consul/api"
    "log"
)

func registerService() {
    config := api.DefaultConfig()
    client, err := api.NewClient(config)
    if err != nil {
        log.Fatal(err)
    }

    registration := &api.AgentServiceRegistration{
        ID:      "order-service-1",
        Name:    "order-service",
        Port:    8080,
        Address: "192.168.1.100",
        Check: &api.AgentServiceCheck{
            HTTP:     "http://192.168.1.100:8080/health",
            Interval: "10s",
            Timeout:  "1s",
        },
    }

    err = client.Agent().ServiceRegister(registration)
    if err != nil {
        log.Fatal(err)
    }
}

func discoverService(serviceName string) (string, int, error) {
    config := api.DefaultConfig()
    client, err := api.NewClient(config)
    if err != nil {
        return "", 0, err
    }

    services, _, err := client.Health().Service(serviceName, "", true, nil)
    if err != nil || len(services) == 0 {
        return "", 0, err
    }

    service := services[0]
    return service.Service.Address, service.Service.Port, nil
}
```

**Kubernetes Service 发现**：

```yaml
apiVersion: v1
kind: Service
metadata:
  name: order-service
spec:
  selector:
    app: order
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
  type: ClusterIP  # 内部服务发现
```

**客户端调用**：

```go
// Kubernetes 内部 DNS
url := "http://order-service.default.svc.cluster.local/api/orders"
```

---

## 2. 通信模式

### 2.1 同步通信（HTTP REST）

**Spring Boot 示例**：

```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private RestTemplate restTemplate;  // 调用其他服务
    
    @PostMapping
    public ResponseEntity<OrderResponse> createOrder(@RequestBody CreateOrderRequest request) {
        // 调用 Inventory Service 检查库存
        String inventoryUrl = "http://inventory-service/api/inventory/check";
        InventoryResponse inventory = restTemplate.postForObject(
            inventoryUrl, 
            request.getItems(), 
            InventoryResponse.class
        );
        
        if (!inventory.isAvailable()) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new OrderResponse("Insufficient inventory"));
        }
        
        // 创建订单
        Order order = orderService.createOrder(request);
        
        // 调用 Payment Service 处理支付
        String paymentUrl = "http://payment-service/api/payments";
        PaymentResponse payment = restTemplate.postForObject(
            paymentUrl,
            new PaymentRequest(order.getId(), order.getAmount()),
            PaymentResponse.class
        );
        
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(new OrderResponse(order.getId(), payment.getStatus()));
    }
}
```

**问题**：同步调用链过长导致延迟累积

**解决**：异步通信 + 断路器

### 2.2 异步通信（消息队列）

**Kafka 示例**：

```java
// Producer (Order Service)
@Service
public class OrderEventProducer {
    
    @Autowired
    private KafkaTemplate<String, OrderEvent> kafkaTemplate;
    
    public void publishOrderCreated(Order order) {
        OrderEvent event = new OrderEvent(
            order.getId(),
            EventType.ORDER_CREATED,
            order.toJson()
        );
        kafkaTemplate.send("order-events", order.getId(), event);
    }
}

// Consumer (Inventory Service)
@Service
public class InventoryEventConsumer {
    
    @KafkaListener(topics = "order-events", groupId = "inventory-group")
    public void handleOrderCreated(OrderEvent event) {
        if (event.getType() == EventType.ORDER_CREATED) {
            // 更新库存
            inventoryService.reserveItems(event.getOrderId(), event.getItems());
            
            // 发布库存预留事件
            kafkaTemplate.send("inventory-events", 
                new InventoryReservedEvent(event.getOrderId()));
        }
    }
}
```

**优势**：

- 解耦：服务间无直接依赖
- 弹性：消费者离线不影响生产者
- 可扩展：消费者可并行处理

### 2.3 gRPC（高性能 RPC）

**服务端（Golang）**：

```go
type orderServiceServer struct {
    pb.UnimplementedOrderServiceServer
}

func (s *orderServiceServer) CreateOrder(ctx context.Context, 
    req *pb.CreateOrderRequest) (*pb.CreateOrderResponse, error) {
    
    // 验证请求
    if err := validateRequest(req); err != nil {
        return nil, status.Errorf(codes.InvalidArgument, "invalid request: %v", err)
    }
    
    // 创建订单
    order, err := createOrder(ctx, req)
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to create order: %v", err)
    }
    
    return &pb.CreateOrderResponse{
        OrderId: order.ID,
        Status:  pb.OrderStatus_PENDING,
    }, nil
}

func main() {
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }
    
    s := grpc.NewServer()
    pb.RegisterOrderServiceServer(s, &orderServiceServer{})
    
    log.Printf("Server listening on :50051")
    if err := s.Serve(lis); err != nil {
        log.Fatalf("failed to serve: %v", err)
    }
}
```

**客户端**：

```go
conn, err := grpc.Dial("order-service:50051", grpc.WithInsecure())
if err != nil {
    log.Fatalf("did not connect: %v", err)
}
defer conn.Close()

client := pb.NewOrderServiceClient(conn)

resp, err := client.CreateOrder(context.Background(), &pb.CreateOrderRequest{
    CustomerId: "customer-123",
    Items: []*pb.OrderItem{
        {ProductId: "prod-1", Quantity: 2},
    },
})
```

---

## 3. 数据管理

### 3.1 Database per Service

**原则**：每个服务有独立数据库

```text
Order Service → PostgreSQL (orders schema)
Inventory Service → MongoDB (inventory collection)
Payment Service → MySQL (payments table)

禁止：跨服务直接访问数据库
正确：通过 API 调用
```

**Docker Compose 示例**：

```yaml
version: '3'
services:
  order-service:
    image: order-service:latest
    environment:
      DB_HOST: order-db
    depends_on:
      - order-db
  
  order-db:
    image: postgres:14
    environment:
      POSTGRES_DB: orders
      POSTGRES_USER: order_user
      POSTGRES_PASSWORD: password
    volumes:
      - order-data:/var/lib/postgresql/data
  
  inventory-service:
    image: inventory-service:latest
    environment:
      MONGO_URI: mongodb://inventory-db:27017
    depends_on:
      - inventory-db
  
  inventory-db:
    image: mongo:5
    volumes:
      - inventory-data:/data/db

volumes:
  order-data:
  inventory-data:
```

### 3.2 Saga 模式（分布式事务）

**定义**：

```text
Saga = [T₁, T₂, ..., Tₙ]
每个 Tᵢ 是本地事务，配有补偿 Cᵢ

编排模式（Orchestration）：
  Orchestrator 控制执行顺序

协同模式（Choreography）：
  服务通过事件协作
```

**编排模式示例**（创建订单 Saga）：

```java
@Service
public class CreateOrderSagaOrchestrator {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private InventoryClient inventoryClient;
    
    @Autowired
    private PaymentClient paymentClient;
    
    public SagaResult executeCreateOrderSaga(CreateOrderRequest request) {
        String orderId = UUID.randomUUID().toString();
        List<SagaStep> executedSteps = new ArrayList<>();
        
        try {
            // Step 1: Create Order
            Order order = createOrder(orderId, request);
            executedSteps.add(new SagaStep("CreateOrder", () -> deleteOrder(orderId)));
            
            // Step 2: Reserve Inventory
            inventoryClient.reserveItems(orderId, request.getItems());
            executedSteps.add(new SagaStep("ReserveInventory", 
                () -> inventoryClient.releaseReservation(orderId)));
            
            // Step 3: Process Payment
            paymentClient.processPayment(orderId, order.getTotalAmount());
            executedSteps.add(new SagaStep("ProcessPayment", 
                () -> paymentClient.refund(orderId)));
            
            // Step 4: Confirm Order
            orderRepository.updateStatus(orderId, OrderStatus.CONFIRMED);
            
            return SagaResult.success(orderId);
            
        } catch (Exception e) {
            // Compensate in reverse order
            for (int i = executedSteps.size() - 1; i >= 0; i--) {
                try {
                    executedSteps.get(i).compensate();
                } catch (Exception ce) {
                    log.error("Compensation failed for step: {}", 
                        executedSteps.get(i).getName(), ce);
                }
            }
            return SagaResult.failure(e.getMessage());
        }
    }
}
```

**协同模式示例**（事件驱动）：

```java
// Order Service
@Service
public class OrderService {
    @Autowired
    private EventPublisher eventPublisher;
    
    public void createOrder(CreateOrderRequest request) {
        Order order = new Order(request);
        orderRepository.save(order);
        
        // 发布事件
        eventPublisher.publish(new OrderCreatedEvent(order));
    }
}

// Inventory Service
@EventListener
public class InventoryEventHandler {
    public void handle(OrderCreatedEvent event) {
        try {
            inventoryService.reserveItems(event.getOrderId(), event.getItems());
            eventPublisher.publish(new InventoryReservedEvent(event.getOrderId()));
        } catch (InsufficientStockException e) {
            eventPublisher.publish(new InventoryReservationFailedEvent(
                event.getOrderId(), e.getMessage()));
        }
    }
}

// Payment Service
@EventListener
public class PaymentEventHandler {
    public void handle(InventoryReservedEvent event) {
        try {
            paymentService.charge(event.getOrderId(), event.getAmount());
            eventPublisher.publish(new PaymentCompletedEvent(event.getOrderId()));
        } catch (PaymentException e) {
            eventPublisher.publish(new PaymentFailedEvent(event.getOrderId()));
        }
    }
}

// Order Service (Compensate)
@EventListener
public class OrderCompensationHandler {
    public void handle(PaymentFailedEvent event) {
        orderRepository.updateStatus(event.getOrderId(), OrderStatus.CANCELLED);
        eventPublisher.publish(new OrderCancelledEvent(event.getOrderId()));
    }
}
```

---

## 4. 服务网格（Service Mesh）

### 4.1 Istio 架构

```text
Istio = Control Plane + Data Plane

Control Plane:
  - Pilot: 服务发现、流量管理
  - Citadel: 证书管理、mTLS
  - Galley: 配置验证

Data Plane:
  - Envoy Sidecar: 每个 Pod 注入代理
```

**流量管理示例**：

```yaml
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: order-service
spec:
  hosts:
  - order-service
  http:
  - match:
    - headers:
        user-type:
          exact: premium
    route:
    - destination:
        host: order-service
        subset: v2
      weight: 100
  - route:
    - destination:
        host: order-service
        subset: v1
      weight: 90
    - destination:
        host: order-service
        subset: v2
      weight: 10  # 金丝雀发布
```

**断路器配置**：

```yaml
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: order-service
spec:
  host: order-service
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        http1MaxPendingRequests: 50
        http2MaxRequests: 100
        maxRequestsPerConnection: 2
    outlierDetection:
      consecutiveErrors: 5
      interval: 30s
      baseEjectionTime: 30s
      maxEjectionPercent: 50
```

### 4.2 Linkerd（轻量级）

**安装**：

```bash
# 安装 Linkerd CLI
curl -sL https://run.linkerd.io/install | sh

# 检查集群
linkerd check --pre

# 安装 Control Plane
linkerd install | kubectl apply -f -

# 注入 Sidecar
kubectl get deploy order-service -o yaml \
  | linkerd inject - \
  | kubectl apply -f -
```

**优势**：

- 更轻量（Rust 编写）
- 更快（相比 Envoy）
- 更简单（默认配置即可用）

---

## 5. 可观测性

### 5.1 分布式追踪（OpenTelemetry）

**Go 示例**：

```go
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/sdk/trace"
)

func initTracer() (*trace.TracerProvider, error) {
    exporter, err := jaeger.New(jaeger.WithCollectorEndpoint(
        jaeger.WithEndpoint("http://jaeger:14268/api/traces")))
    if err != nil {
        return nil, err
    }
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
        trace.WithResource(resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceNameKey.String("order-service"),
        )),
    )
    otel.SetTracerProvider(tp)
    return tp, nil
}

func handleRequest(w http.ResponseWriter, r *http.Request) {
    ctx, span := otel.Tracer("order-service").Start(r.Context(), "CreateOrder")
    defer span.End()
    
    // 调用下游服务
    inventoryResp := callInventoryService(ctx)
    
    // 业务逻辑
    order := createOrder(ctx, r.Body)
    
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(order)
}
```

**Jaeger UI 效果**：

```text
Trace: 订单创建 [总耗时: 250ms]
  ├─ API Gateway [10ms]
  ├─ Order Service [100ms]
  │   ├─ DB Query [50ms]
  │   └─ Inventory Check [30ms]
  ├─ Inventory Service [80ms]
  │   └─ Cache Lookup [5ms]
  └─ Payment Service [60ms]
      └─ External API [55ms]
```

### 5.2 度量监控（Prometheus + Grafana）

**Prometheus 配置**：

```yaml
scrape_configs:
  - job_name: 'order-service'
    kubernetes_sd_configs:
      - role: pod
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
        action: replace
        target_label: __metrics_path__
        regex: (.+)
```

**应用暴露指标**：

```go
import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
    ordersCreated = promauto.NewCounterVec(prometheus.CounterOpts{
        Name: "orders_created_total",
        Help: "Total number of orders created",
    }, []string{"status"})
    
    orderDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
        Name:    "order_creation_duration_seconds",
        Help:    "Order creation duration",
        Buckets: []float64{0.1, 0.5, 1, 2, 5},
    }, []string{"status"})
)

func handleCreateOrder(w http.ResponseWriter, r *http.Request) {
    timer := prometheus.NewTimer(orderDuration.WithLabelValues("success"))
    defer timer.ObserveDuration()
    
    order, err := createOrder(r.Body)
    if err != nil {
        ordersCreated.WithLabelValues("error").Inc()
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    ordersCreated.WithLabelValues("success").Inc()
    json.NewEncoder(w).Encode(order)
}
```

### 5.3 日志聚合（ELK Stack）

**结构化日志（JSON）**：

```go
import "github.com/sirupsen/logrus"

log := logrus.New()
log.SetFormatter(&logrus.JSONFormatter{})

log.WithFields(logrus.Fields{
    "service":  "order-service",
    "order_id": order.ID,
    "user_id":  order.UserID,
    "amount":   order.Amount,
}).Info("Order created successfully")
```

**Filebeat 配置**：

```yaml
filebeat.inputs:
- type: container
  paths:
    - '/var/log/containers/*.log'
  processors:
    - add_kubernetes_metadata:
        host: ${NODE_NAME}

output.elasticsearch:
  hosts: ["elasticsearch:9200"]
  index: "microservices-%{+yyyy.MM.dd}"
```

---

## 6. 形式化验证

### 6.1 TLA+ 建模（一致性）

**示例**：订单服务最终一致性

```tla
EXTENDS Integers, Sequences

VARIABLES 
  orderState,       \* {"pending", "confirmed", "cancelled"}
  inventoryReserved,  \* Boolean
  paymentProcessed,   \* Boolean
  events              \* 事件队列

TypeOK ==
  /\ orderState \in {"pending", "confirmed", "cancelled"}
  /\ inventoryReserved \in BOOLEAN
  /\ paymentProcessed \in BOOLEAN
  /\ events \in Seq({"OrderCreated", "InventoryReserved", "PaymentProcessed", "OrderCancelled"})

Init ==
  /\ orderState = "pending"
  /\ inventoryReserved = FALSE
  /\ paymentProcessed = FALSE
  /\ events = << >>

ReserveInventory ==
  /\ orderState = "pending"
  /\ ~inventoryReserved
  /\ inventoryReserved' = TRUE
  /\ events' = Append(events, "InventoryReserved")
  /\ UNCHANGED <<orderState, paymentProcessed>>

ProcessPayment ==
  /\ orderState = "pending"
  /\ inventoryReserved
  /\ ~paymentProcessed
  /\ paymentProcessed' = TRUE
  /\ events' = Append(events, "PaymentProcessed")
  /\ UNCHANGED <<orderState, inventoryReserved>>

ConfirmOrder ==
  /\ orderState = "pending"
  /\ inventoryReserved
  /\ paymentProcessed
  /\ orderState' = "confirmed"
  /\ events' = Append(events, "OrderConfirmed")
  /\ UNCHANGED <<inventoryReserved, paymentProcessed>>

CancelOrder ==
  /\ orderState = "pending"
  /\ orderState' = "cancelled"
  /\ inventoryReserved' = FALSE
  /\ paymentProcessed' = FALSE
  /\ events' = Append(events, "OrderCancelled")

Next ==
  \/ ReserveInventory
  \/ ProcessPayment
  \/ ConfirmOrder
  \/ CancelOrder

(* 最终一致性：总会到达终态 *)
EventualConsistency ==
  <>[](orderState \in {"confirmed", "cancelled"})

(* 不变式：确认前必须完成所有步骤 *)
Invariant ==
  orderState = "confirmed" => (inventoryReserved /\ paymentProcessed)
```

**验证**：

```bash
tlc microservices.tla -workers 4
```

### 6.2 mCRL2 建模（并发）

**示例**：服务间通信死锁检测

```mcrl2
sort Service = struct OrderService | InventoryService | PaymentService;
     Message = struct CreateOrder | ReserveInventory | ProcessPayment | Response;

act send, receive : Service # Service # Message;
    process : Service # Message;

proc OrderService =
  receive(API, OrderService, CreateOrder) .
  send(OrderService, InventoryService, ReserveInventory) .
  receive(InventoryService, OrderService, Response) .
  send(OrderService, PaymentService, ProcessPayment) .
  receive(PaymentService, OrderService, Response) .
  OrderService;

proc InventoryService =
  receive(OrderService, InventoryService, ReserveInventory) .
  process(InventoryService, ReserveInventory) .
  send(InventoryService, OrderService, Response) .
  InventoryService;

proc PaymentService =
  receive(OrderService, PaymentService, ProcessPayment) .
  process(PaymentService, ProcessPayment) .
  send(PaymentService, OrderService, Response) .
  PaymentService;

init allow({send, receive, process},
  comm({send|receive -> sync},
    OrderService || InventoryService || PaymentService));
```

**死锁检测**：

```bash
mcrl22lps microservices.mcrl2 | lps2lts -v
ltsconvert -edead output.lts
# 检查输出：无死锁
```

---

## 7. 实际案例

### 7.1 Netflix

**规模**：

- 700+ 微服务
- 数千台服务器
- 全球 1.9 亿用户

**技术栈**：

- **Spring Boot**：服务框架
- **Eureka**：服务发现
- **Ribbon**：负载均衡
- **Hystrix**：断路器
- **Zuul**：API 网关
- **Archaius**：动态配置

**挑战与解决**：

| 挑战 | 解决方案 |
|------|----------|
| 服务发现 | Eureka + Ribbon |
| 级联失败 | Hystrix 断路器 |
| 流量管理 | Zuul 路由规则 |
| 测试混沌 | Chaos Monkey |

### 7.2 Amazon

**Prime Day 2021**：

- 处理 2.5 亿订单
- 峰值 QPS：250,000
- 99.999% 可用性

**关键技术**：

- **DynamoDB**：NoSQL 数据库
- **SQS**：消息队列
- **Lambda**：无服务器计算
- **API Gateway**：统一入口

### 7.3 Uber

**服务数量**：2200+

**技术栈**：

- **Golang**：高性能服务
- **Cadence**：工作流引擎（Saga）
- **Jaeger**：分布式追踪
- **Envoy**：服务代理

**架构演进**：

```text
单体（2012） → 微服务（2015） → 服务网格（2019）
```

---

## 8. 最佳实践

### 8.1 服务拆分原则

**领域驱动设计（DDD）**：

```text
服务边界 = 限界上下文（Bounded Context）

示例：
  - 订单上下文：Order, OrderItem, OrderStatus
  - 库存上下文：Product, Stock, Reservation
  - 支付上下文：Payment, Transaction, Refund

每个上下文一个微服务
```

**拆分粒度**：

- ✅ **太小**：服务数量爆炸，通信开销大
- ✅ **合适**：按业务能力拆分，团队自治
- ❌ **太大**：退化为分布式单体

### 8.2 API 版本管理

**URL 版本**：

```text
/api/v1/orders
/api/v2/orders
```

**Header 版本**：

```http
GET /api/orders
Accept: application/vnd.company.v1+json
```

**兼容性原则**：

- 向后兼容：新版本支持旧客户端
- 弃用过渡期：至少 6 个月

### 8.3 部署策略

**蓝绿部署**：

```text
Blue (旧版本) ← 100% 流量
Green (新版本) ← 0% 流量

切换：
  1. 部署 Green
  2. 健康检查
  3. 流量切换到 Green
  4. 监控
  5. 若有问题，立即切回 Blue
```

**金丝雀发布**：

```text
v1 ← 90% 流量
v2 ← 10% 流量（金丝雀）

监控指标：
  - 错误率
  - 延迟
  - 资源使用

逐步增加 v2 流量：10% → 25% → 50% → 100%
```

---

## 9. 大学课程对应

| 课程 | 相关章节 |
|------|----------|
| **MIT 6.824 分布式系统** | 一致性、Saga、CAP 定理 |
| **CMU 17-313 软件架构** | 微服务拆分、API 设计 |
| **Stanford CS 253 Web 安全** | API 网关、认证授权 |
| **Berkeley CS 294 云计算** | Kubernetes、服务网格 |

---

## 快速参考

### 核心组件

```text
微服务架构 = Services + Gateway + Discovery + Mesh

通信：REST / gRPC / Kafka
数据：Database per Service + Saga
网格：Istio / Linkerd
可观测性：Prometheus + Jaeger + ELK
```

### 工具链

```bash
# 部署
kubectl apply -f k8s/
docker-compose up

# 服务发现
consul agent -dev

# API 网关
kong start

# 追踪
jaeger all-in-one

# 监控
prometheus --config.file=prometheus.yml
```

---

## 附录：Wikipedia 概念对照

| 概念 | Wikipedia 条目 | 本文章节 |
|------|----------------|----------|
| Microservices | <https://en.wikipedia.org/wiki/Microservices> | §1 |
| Service Mesh | <https://en.wikipedia.org/wiki/Service_mesh> | §4 |
| API Gateway | <https://en.wikipedia.org/wiki/API_management> | §1.2 |
| Saga Pattern | <https://en.wikipedia.org/wiki/Long-running_transaction> | §3.2 |
| CAP Theorem | <https://en.wikipedia.org/wiki/CAP_theorem> | §4.1 |

---

**版本**：v1.0  
**最后更新**：2025-10-29  
**维护者**：FormalScience Project  
**许可**：CC BY-SA 4.0
