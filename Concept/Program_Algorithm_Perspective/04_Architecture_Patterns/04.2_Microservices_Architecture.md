# å¾®æœåŠ¡æ¶æ„

## ğŸ“Š æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ

<details>
<summary><b>ğŸ”¬ğŸŒ ç‚¹å‡»å±•å¼€ï¼šå¾®æœåŠ¡æ¶æ„æ ¸å¿ƒæ´å¯Ÿ</b></summary>

**ç»ˆææ´å¯Ÿ**: å¾®æœåŠ¡=åˆ†å¸ƒå¼ç³»ç»Ÿçš„ç³»ç»ŸåŒ–å®è·µã€‚æ ¸å¿ƒåŸåˆ™ï¼šâ‘ å•ä¸€èŒè´£ï¼šæ¯ä¸ªæœåŠ¡ä¸“æ³¨ä¸€ä¸ªä¸šåŠ¡èƒ½åŠ›â‘¡ç‹¬ç«‹éƒ¨ç½²ï¼šæœåŠ¡é—´è§£è€¦ï¼Œç‹¬ç«‹å‘ç‰ˆâ‘¢æ•°æ®åº“åˆ†ç¦»ï¼šDatabase per Serviceï¼Œé¿å…å…±äº«æ•°æ®åº“â‘£å»ä¸­å¿ƒåŒ–ï¼šæœåŠ¡è‡ªæ²»ï¼Œæ²¡æœ‰ä¸­å¤®åè°ƒå™¨â‘¤å¤±è´¥éš”ç¦»ï¼šå•æœåŠ¡æ•…éšœä¸çº§è”ã€‚æ¶æ„ç»„ä»¶ï¼šâ‘ APIç½‘å…³ï¼šç»Ÿä¸€å…¥å£ï¼Œè·¯ç”±/è®¤è¯/é™æµâ‘¡æœåŠ¡å‘ç°ï¼šåŠ¨æ€æ³¨å†Œå‘ç°ï¼ˆConsul/Eurekaï¼‰â‘¢æœåŠ¡ç½‘æ ¼ï¼šIstio/Linkerdï¼Œé€æ˜å¤„ç†é€šä¿¡/å®‰å…¨/å¯è§‚æµ‹æ€§ã€‚é€šä¿¡æ¨¡å¼ï¼šâ‘ åŒæ­¥ï¼šREST/gRPCï¼Œç®€å•ç›´è§‚ä½†è€¦åˆå¼ºâ‘¡å¼‚æ­¥ï¼šæ¶ˆæ¯é˜Ÿåˆ—/äº‹ä»¶æ€»çº¿ï¼Œè§£è€¦ä½†å¤æ‚åº¦é«˜ã€‚æ•°æ®ä¸€è‡´æ€§ï¼šæ”¾å¼ƒACIDå¼ºä¸€è‡´ï¼Œæ‹¥æŠ±æœ€ç»ˆä¸€è‡´æ€§+Sagaè¡¥å¿ã€‚å¯è§‚æµ‹æ€§ä¸‰æ”¯æŸ±ï¼šâ‘ åˆ†å¸ƒå¼è¿½è¸ªï¼ˆJaeger/Zipkinï¼‰ï¼šè·¨æœåŠ¡è¯·æ±‚é“¾è·¯â‘¡åº¦é‡ç›‘æ§ï¼ˆPrometheusï¼‰ï¼šæœåŠ¡å¥åº·/æ€§èƒ½æŒ‡æ ‡â‘¢æ—¥å¿—èšåˆï¼ˆELKï¼‰ï¼šé›†ä¸­å¼æ—¥å¿—åˆ†æã€‚å½¢å¼åŒ–éªŒè¯ï¼šç”¨TLA+éªŒè¯åˆ†å¸ƒå¼åè®®ï¼ˆRaft/Paxosï¼‰ï¼Œç”¨å¥‘çº¦æµ‹è¯•éªŒè¯æœåŠ¡æ¥å£ã€‚æŒ‘æˆ˜ï¼šåˆ†å¸ƒå¼å¤æ‚åº¦ã€æ•°æ®ä¸€è‡´æ€§ã€æµ‹è¯•éš¾åº¦ã€‚å…³é”®ï¼šå¾®æœåŠ¡ç”¨æ¶æ„å¤æ‚åº¦æ¢ç»„ç»‡æ‰©å±•æ€§å’Œç³»ç»ŸéŸ§æ€§ã€‚

</details>

---

## ğŸ“‹ ç›®å½•

- [ğŸ“Š æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ](#æ ¸å¿ƒæ¦‚å¿µæ·±åº¦åˆ†æ)
- [ğŸ“‹ ç›®å½•](#ç›®å½•)
- [æ¦‚è¿°](#æ¦‚è¿°)
- [1. å¾®æœåŠ¡æ ¸å¿ƒç»„ä»¶](#1-å¾®æœåŠ¡æ ¸å¿ƒç»„ä»¶)
  - [1.1 æœåŠ¡å®šä¹‰](#11-æœåŠ¡å®šä¹‰)
  - [1.2 API ç½‘å…³](#12-api-ç½‘å…³)
  - [1.3 æœåŠ¡å‘ç°](#13-æœåŠ¡å‘ç°)
- [2. é€šä¿¡æ¨¡å¼](#2-é€šä¿¡æ¨¡å¼)
  - [2.1 åŒæ­¥é€šä¿¡ï¼ˆHTTP RESTï¼‰](#21-åŒæ­¥é€šä¿¡http-rest)
  - [2.2 å¼‚æ­¥é€šä¿¡ï¼ˆæ¶ˆæ¯é˜Ÿåˆ—ï¼‰](#22-å¼‚æ­¥é€šä¿¡æ¶ˆæ¯é˜Ÿåˆ—)
  - [2.3 gRPCï¼ˆé«˜æ€§èƒ½ RPCï¼‰](#23-grpcé«˜æ€§èƒ½-rpc)
- [3. æ•°æ®ç®¡ç†](#3-æ•°æ®ç®¡ç†)
  - [3.1 Database per Service](#31-database-per-service)
  - [3.2 Saga æ¨¡å¼ï¼ˆåˆ†å¸ƒå¼äº‹åŠ¡ï¼‰](#32-saga-æ¨¡å¼åˆ†å¸ƒå¼äº‹åŠ¡)
- [4. æœåŠ¡ç½‘æ ¼ï¼ˆService Meshï¼‰](#4-æœåŠ¡ç½‘æ ¼service-mesh)
  - [4.1 Istio æ¶æ„](#41-istio-æ¶æ„)
  - [4.2 Linkerdï¼ˆè½»é‡çº§ï¼‰](#42-linkerdè½»é‡çº§)
- [5. å¯è§‚æµ‹æ€§](#5-å¯è§‚æµ‹æ€§)
  - [5.1 åˆ†å¸ƒå¼è¿½è¸ªï¼ˆOpenTelemetryï¼‰](#51-åˆ†å¸ƒå¼è¿½è¸ªopentelemetry)
  - [5.2 åº¦é‡ç›‘æ§ï¼ˆPrometheus + Grafanaï¼‰](#52-åº¦é‡ç›‘æ§prometheus-grafana)
  - [5.3 æ—¥å¿—èšåˆï¼ˆELK Stackï¼‰](#53-æ—¥å¿—èšåˆelk-stack)
- [6. å½¢å¼åŒ–éªŒè¯](#6-å½¢å¼åŒ–éªŒè¯)
  - [6.1 TLA+ å»ºæ¨¡ï¼ˆä¸€è‡´æ€§ï¼‰](#61-tla-å»ºæ¨¡ä¸€è‡´æ€§)
  - [6.2 mCRL2 å»ºæ¨¡ï¼ˆå¹¶å‘ï¼‰](#62-mcrl2-å»ºæ¨¡å¹¶å‘)
- [7. å®é™…æ¡ˆä¾‹](#7-å®é™…æ¡ˆä¾‹)
  - [7.1 Netflix](#71-netflix)
  - [7.2 Amazon](#72-amazon)
  - [7.3 Uber](#73-uber)
- [8. æœ€ä½³å®è·µ](#8-æœ€ä½³å®è·µ)
  - [8.1 æœåŠ¡æ‹†åˆ†åŸåˆ™](#81-æœåŠ¡æ‹†åˆ†åŸåˆ™)
  - [8.2 API ç‰ˆæœ¬ç®¡ç†](#82-api-ç‰ˆæœ¬ç®¡ç†)
  - [8.3 éƒ¨ç½²ç­–ç•¥](#83-éƒ¨ç½²ç­–ç•¥)
- [9. å¤§å­¦è¯¾ç¨‹å¯¹åº”](#9-å¤§å­¦è¯¾ç¨‹å¯¹åº”)
- [å¿«é€Ÿå‚è€ƒ](#å¿«é€Ÿå‚è€ƒ)
  - [æ ¸å¿ƒç»„ä»¶](#æ ¸å¿ƒç»„ä»¶)
  - [å·¥å…·é“¾](#å·¥å…·é“¾)
- [é™„å½•ï¼šWikipedia æ¦‚å¿µå¯¹ç…§](#é™„å½•wikipedia-æ¦‚å¿µå¯¹ç…§)

---

## æ¦‚è¿°

**å¾®æœåŠ¡æ¶æ„**ï¼ˆMicroservices Architectureï¼‰æ˜¯ä¸€ç§å°†åº”ç”¨ç¨‹åºæ„å»ºä¸º**å°å‹ã€ç‹¬ç«‹ã€æ¾è€¦åˆæœåŠ¡é›†åˆ**çš„æ¶æ„é£æ ¼ï¼Œæ¯ä¸ªæœåŠ¡å®ç°ä¸€ä¸ª**ä¸šåŠ¡èƒ½åŠ›**ï¼Œé€šè¿‡**è½»é‡çº§æœºåˆ¶**ï¼ˆé€šå¸¸æ˜¯ HTTP REST APIï¼‰é€šä¿¡ã€‚

**æ ¸å¿ƒåŸåˆ™**ï¼š

```text
å¾®æœåŠ¡ = ç‹¬ç«‹éƒ¨ç½² + ä¸šåŠ¡éš”ç¦» + å»ä¸­å¿ƒåŒ–æ²»ç†

å½¢å¼åŒ–ï¼š
  System = âŸ¨Services, Communication, DataâŸ©
    Services: {Sâ‚, Sâ‚‚, ..., Sâ‚™}
    Communication: API Gateway + Service Mesh
    Data: æ¯æœåŠ¡ç‹¬ç«‹æ•°æ®åº“ï¼ˆDatabase per Serviceï¼‰

ç‰¹ç‚¹ï¼š
  - ç‹¬ç«‹éƒ¨ç½²ï¼šæ¯ä¸ªæœåŠ¡ç‹¬ç«‹å‘å¸ƒ
  - æŠ€æœ¯å¼‚æ„ï¼šæœåŠ¡å¯ç”¨ä¸åŒè¯­è¨€/æ¡†æ¶
  - æ•…éšœéš”ç¦»ï¼šæœåŠ¡å´©æºƒä¸å½±å“å…¨å±€
  - å¯æ‰©å±•ï¼šæŒ‰éœ€æ°´å¹³æ‰©å±•
```

**å¯¹æ¯”å•ä½“æ¶æ„**ï¼š

| ç»´åº¦ | å•ä½“æ¶æ„ | å¾®æœåŠ¡æ¶æ„ |
|------|----------|------------|
| **éƒ¨ç½²** | æ•´ä½“æ‰“åŒ… | ç‹¬ç«‹éƒ¨ç½² |
| **æ‰©å±•** | å‚ç›´æ‰©å±• | æ°´å¹³æ‰©å±• |
| **æŠ€æœ¯æ ˆ** | ç»Ÿä¸€ | å¼‚æ„ |
| **å¼€å‘å›¢é˜Ÿ** | é›†ä¸­å¼ | åˆ†å¸ƒå¼ |
| **æ•…éšœå½±å“** | å…¨å±€ | å±€éƒ¨ |
| **å¤æ‚åº¦** | ä½ | é«˜ |

---

## 1. å¾®æœåŠ¡æ ¸å¿ƒç»„ä»¶

### 1.1 æœåŠ¡å®šä¹‰

**æ¥å£è§„èŒƒ**ï¼ˆOpenAPIï¼‰ï¼š

```yaml
openapi: 3.0.0
info:
  title: Order Service API
  version: 1.0.0

paths:
  /orders:
    post:
      summary: Create order
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Order'
      responses:
        '201':
          description: Order created
        '400':
          description: Invalid request

components:
  schemas:
    Order:
      type: object
      required:
        - customerId
        - items
      properties:
        orderId:
          type: string
          format: uuid
        customerId:
          type: string
        items:
          type: array
          items:
            $ref: '#/components/schemas/OrderItem'
```

**gRPC å®šä¹‰**ï¼š

```protobuf
syntax = "proto3";

package order;

service OrderService {
  rpc CreateOrder (CreateOrderRequest) returns (CreateOrderResponse);
  rpc GetOrder (GetOrderRequest) returns (GetOrderResponse);
  rpc CancelOrder (CancelOrderRequest) returns (CancelOrderResponse);
}

message CreateOrderRequest {
  string customer_id = 1;
  repeated OrderItem items = 2;
}

message CreateOrderResponse {
  string order_id = 1;
  OrderStatus status = 2;
}

enum OrderStatus {
  PENDING = 0;
  CONFIRMED = 1;
  CANCELLED = 2;
  COMPLETED = 3;
}
```

### 1.2 API ç½‘å…³

**èŒè´£**ï¼š

```text
API Gateway = è¯·æ±‚è·¯ç”± + è®¤è¯æˆæƒ + é™æµ + è´Ÿè½½å‡è¡¡

å½¢å¼åŒ–ï¼š
  Request â†’ Gateway â†’ Route(Request.path) â†’ Service

è·¯ç”±è§„åˆ™ï¼š
  /api/orders/** â†’ Order Service
  /api/users/** â†’ User Service
  /api/inventory/** â†’ Inventory Service
```

**Kong é…ç½®ç¤ºä¾‹**ï¼š

```yaml
services:
  - name: order-service
    url: http://order-service:8080
    routes:
      - name: order-route
        paths:
          - /api/orders
        methods:
          - GET
          - POST
        plugins:
          - name: rate-limiting
            config:
              minute: 100
              policy: local
          - name: jwt
            config:
              key_claim_name: iss
```

**Envoy é…ç½®**ï¼ˆIstio åº•å±‚ï¼‰ï¼š

```yaml
static_resources:
  listeners:
  - address:
      socket_address:
        address: 0.0.0.0
        port_value: 10000
    filter_chains:
    - filters:
      - name: envoy.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          stat_prefix: ingress_http
          route_config:
            name: local_route
            virtual_hosts:
            - name: backend
              domains:
              - "*"
              routes:
              - match:
                  prefix: "/api/orders"
                route:
                  cluster: order_service
          http_filters:
          - name: envoy.filters.http.router

  clusters:
  - name: order_service
    connect_timeout: 0.25s
    type: STRICT_DNS
    lb_policy: ROUND_ROBIN
    load_assignment:
      cluster_name: order_service
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: order-service
                port_value: 8080
```

### 1.3 æœåŠ¡å‘ç°

**æ³¨å†Œä¸­å¿ƒæ¨¡å¼**ï¼š

```text
Service Registry = âŸ¨Services, Health, DiscoveryâŸ©

æ“ä½œï¼š
  - register(service, address): æ³¨å†ŒæœåŠ¡
  - deregister(service): æ³¨é”€æœåŠ¡
  - discover(service): æŸ¥è¯¢æœåŠ¡åœ°å€
  - health_check(service): å¥åº·æ£€æŸ¥
```

**Consul ç¤ºä¾‹**ï¼ˆGo å®¢æˆ·ç«¯ï¼‰ï¼š

```go
package main

import (
    "github.com/hashicorp/consul/api"
    "log"
)

func registerService() {
    config := api.DefaultConfig()
    client, err := api.NewClient(config)
    if err != nil {
        log.Fatal(err)
    }

    registration := &api.AgentServiceRegistration{
        ID:      "order-service-1",
        Name:    "order-service",
        Port:    8080,
        Address: "192.168.1.100",
        Check: &api.AgentServiceCheck{
            HTTP:     "http://192.168.1.100:8080/health",
            Interval: "10s",
            Timeout:  "1s",
        },
    }

    err = client.Agent().ServiceRegister(registration)
    if err != nil {
        log.Fatal(err)
    }
}

func discoverService(serviceName string) (string, int, error) {
    config := api.DefaultConfig()
    client, err := api.NewClient(config)
    if err != nil {
        return "", 0, err
    }

    services, _, err := client.Health().Service(serviceName, "", true, nil)
    if err != nil || len(services) == 0 {
        return "", 0, err
    }

    service := services[0]
    return service.Service.Address, service.Service.Port, nil
}
```

**Kubernetes Service å‘ç°**ï¼š

```yaml
apiVersion: v1
kind: Service
metadata:
  name: order-service
spec:
  selector:
    app: order
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
  type: ClusterIP  # å†…éƒ¨æœåŠ¡å‘ç°
```

**å®¢æˆ·ç«¯è°ƒç”¨**ï¼š

```go
// Kubernetes å†…éƒ¨ DNS
url := "http://order-service.default.svc.cluster.local/api/orders"
```

---

## 2. é€šä¿¡æ¨¡å¼

### 2.1 åŒæ­¥é€šä¿¡ï¼ˆHTTP RESTï¼‰

**Spring Boot ç¤ºä¾‹**ï¼š

```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private RestTemplate restTemplate;  // è°ƒç”¨å…¶ä»–æœåŠ¡
    
    @PostMapping
    public ResponseEntity<OrderResponse> createOrder(@RequestBody CreateOrderRequest request) {
        // è°ƒç”¨ Inventory Service æ£€æŸ¥åº“å­˜
        String inventoryUrl = "http://inventory-service/api/inventory/check";
        InventoryResponse inventory = restTemplate.postForObject(
            inventoryUrl, 
            request.getItems(), 
            InventoryResponse.class
        );
        
        if (!inventory.isAvailable()) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body(new OrderResponse("Insufficient inventory"));
        }
        
        // åˆ›å»ºè®¢å•
        Order order = orderService.createOrder(request);
        
        // è°ƒç”¨ Payment Service å¤„ç†æ”¯ä»˜
        String paymentUrl = "http://payment-service/api/payments";
        PaymentResponse payment = restTemplate.postForObject(
            paymentUrl,
            new PaymentRequest(order.getId(), order.getAmount()),
            PaymentResponse.class
        );
        
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(new OrderResponse(order.getId(), payment.getStatus()));
    }
}
```

**é—®é¢˜**ï¼šåŒæ­¥è°ƒç”¨é“¾è¿‡é•¿å¯¼è‡´å»¶è¿Ÿç´¯ç§¯

**è§£å†³**ï¼šå¼‚æ­¥é€šä¿¡ + æ–­è·¯å™¨

### 2.2 å¼‚æ­¥é€šä¿¡ï¼ˆæ¶ˆæ¯é˜Ÿåˆ—ï¼‰

**Kafka ç¤ºä¾‹**ï¼š

```java
// Producer (Order Service)
@Service
public class OrderEventProducer {
    
    @Autowired
    private KafkaTemplate<String, OrderEvent> kafkaTemplate;
    
    public void publishOrderCreated(Order order) {
        OrderEvent event = new OrderEvent(
            order.getId(),
            EventType.ORDER_CREATED,
            order.toJson()
        );
        kafkaTemplate.send("order-events", order.getId(), event);
    }
}

// Consumer (Inventory Service)
@Service
public class InventoryEventConsumer {
    
    @KafkaListener(topics = "order-events", groupId = "inventory-group")
    public void handleOrderCreated(OrderEvent event) {
        if (event.getType() == EventType.ORDER_CREATED) {
            // æ›´æ–°åº“å­˜
            inventoryService.reserveItems(event.getOrderId(), event.getItems());
            
            // å‘å¸ƒåº“å­˜é¢„ç•™äº‹ä»¶
            kafkaTemplate.send("inventory-events", 
                new InventoryReservedEvent(event.getOrderId()));
        }
    }
}
```

**ä¼˜åŠ¿**ï¼š

- è§£è€¦ï¼šæœåŠ¡é—´æ— ç›´æ¥ä¾èµ–
- å¼¹æ€§ï¼šæ¶ˆè´¹è€…ç¦»çº¿ä¸å½±å“ç”Ÿäº§è€…
- å¯æ‰©å±•ï¼šæ¶ˆè´¹è€…å¯å¹¶è¡Œå¤„ç†

### 2.3 gRPCï¼ˆé«˜æ€§èƒ½ RPCï¼‰

**æœåŠ¡ç«¯ï¼ˆGolangï¼‰**ï¼š

```go
type orderServiceServer struct {
    pb.UnimplementedOrderServiceServer
}

func (s *orderServiceServer) CreateOrder(ctx context.Context, 
    req *pb.CreateOrderRequest) (*pb.CreateOrderResponse, error) {
    
    // éªŒè¯è¯·æ±‚
    if err := validateRequest(req); err != nil {
        return nil, status.Errorf(codes.InvalidArgument, "invalid request: %v", err)
    }
    
    // åˆ›å»ºè®¢å•
    order, err := createOrder(ctx, req)
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to create order: %v", err)
    }
    
    return &pb.CreateOrderResponse{
        OrderId: order.ID,
        Status:  pb.OrderStatus_PENDING,
    }, nil
}

func main() {
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatalf("failed to listen: %v", err)
    }
    
    s := grpc.NewServer()
    pb.RegisterOrderServiceServer(s, &orderServiceServer{})
    
    log.Printf("Server listening on :50051")
    if err := s.Serve(lis); err != nil {
        log.Fatalf("failed to serve: %v", err)
    }
}
```

**å®¢æˆ·ç«¯**ï¼š

```go
conn, err := grpc.Dial("order-service:50051", grpc.WithInsecure())
if err != nil {
    log.Fatalf("did not connect: %v", err)
}
defer conn.Close()

client := pb.NewOrderServiceClient(conn)

resp, err := client.CreateOrder(context.Background(), &pb.CreateOrderRequest{
    CustomerId: "customer-123",
    Items: []*pb.OrderItem{
        {ProductId: "prod-1", Quantity: 2},
    },
})
```

---

## 3. æ•°æ®ç®¡ç†

### 3.1 Database per Service

**åŸåˆ™**ï¼šæ¯ä¸ªæœåŠ¡æœ‰ç‹¬ç«‹æ•°æ®åº“

```text
Order Service â†’ PostgreSQL (orders schema)
Inventory Service â†’ MongoDB (inventory collection)
Payment Service â†’ MySQL (payments table)

ç¦æ­¢ï¼šè·¨æœåŠ¡ç›´æ¥è®¿é—®æ•°æ®åº“
æ­£ç¡®ï¼šé€šè¿‡ API è°ƒç”¨
```

**Docker Compose ç¤ºä¾‹**ï¼š

```yaml
version: '3'
services:
  order-service:
    image: order-service:latest
    environment:
      DB_HOST: order-db
    depends_on:
      - order-db
  
  order-db:
    image: postgres:14
    environment:
      POSTGRES_DB: orders
      POSTGRES_USER: order_user
      POSTGRES_PASSWORD: password
    volumes:
      - order-data:/var/lib/postgresql/data
  
  inventory-service:
    image: inventory-service:latest
    environment:
      MONGO_URI: mongodb://inventory-db:27017
    depends_on:
      - inventory-db
  
  inventory-db:
    image: mongo:5
    volumes:
      - inventory-data:/data/db

volumes:
  order-data:
  inventory-data:
```

### 3.2 Saga æ¨¡å¼ï¼ˆåˆ†å¸ƒå¼äº‹åŠ¡ï¼‰

**å®šä¹‰**ï¼š

```text
Saga = [Tâ‚, Tâ‚‚, ..., Tâ‚™]
æ¯ä¸ª Táµ¢ æ˜¯æœ¬åœ°äº‹åŠ¡ï¼Œé…æœ‰è¡¥å¿ Cáµ¢

ç¼–æ’æ¨¡å¼ï¼ˆOrchestrationï¼‰ï¼š
  Orchestrator æ§åˆ¶æ‰§è¡Œé¡ºåº

ååŒæ¨¡å¼ï¼ˆChoreographyï¼‰ï¼š
  æœåŠ¡é€šè¿‡äº‹ä»¶åä½œ
```

**ç¼–æ’æ¨¡å¼ç¤ºä¾‹**ï¼ˆåˆ›å»ºè®¢å• Sagaï¼‰ï¼š

```java
@Service
public class CreateOrderSagaOrchestrator {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private InventoryClient inventoryClient;
    
    @Autowired
    private PaymentClient paymentClient;
    
    public SagaResult executeCreateOrderSaga(CreateOrderRequest request) {
        String orderId = UUID.randomUUID().toString();
        List<SagaStep> executedSteps = new ArrayList<>();
        
        try {
            // Step 1: Create Order
            Order order = createOrder(orderId, request);
            executedSteps.add(new SagaStep("CreateOrder", () -> deleteOrder(orderId)));
            
            // Step 2: Reserve Inventory
            inventoryClient.reserveItems(orderId, request.getItems());
            executedSteps.add(new SagaStep("ReserveInventory", 
                () -> inventoryClient.releaseReservation(orderId)));
            
            // Step 3: Process Payment
            paymentClient.processPayment(orderId, order.getTotalAmount());
            executedSteps.add(new SagaStep("ProcessPayment", 
                () -> paymentClient.refund(orderId)));
            
            // Step 4: Confirm Order
            orderRepository.updateStatus(orderId, OrderStatus.CONFIRMED);
            
            return SagaResult.success(orderId);
            
        } catch (Exception e) {
            // Compensate in reverse order
            for (int i = executedSteps.size() - 1; i >= 0; i--) {
                try {
                    executedSteps.get(i).compensate();
                } catch (Exception ce) {
                    log.error("Compensation failed for step: {}", 
                        executedSteps.get(i).getName(), ce);
                }
            }
            return SagaResult.failure(e.getMessage());
        }
    }
}
```

**ååŒæ¨¡å¼ç¤ºä¾‹**ï¼ˆäº‹ä»¶é©±åŠ¨ï¼‰ï¼š

```java
// Order Service
@Service
public class OrderService {
    @Autowired
    private EventPublisher eventPublisher;
    
    public void createOrder(CreateOrderRequest request) {
        Order order = new Order(request);
        orderRepository.save(order);
        
        // å‘å¸ƒäº‹ä»¶
        eventPublisher.publish(new OrderCreatedEvent(order));
    }
}

// Inventory Service
@EventListener
public class InventoryEventHandler {
    public void handle(OrderCreatedEvent event) {
        try {
            inventoryService.reserveItems(event.getOrderId(), event.getItems());
            eventPublisher.publish(new InventoryReservedEvent(event.getOrderId()));
        } catch (InsufficientStockException e) {
            eventPublisher.publish(new InventoryReservationFailedEvent(
                event.getOrderId(), e.getMessage()));
        }
    }
}

// Payment Service
@EventListener
public class PaymentEventHandler {
    public void handle(InventoryReservedEvent event) {
        try {
            paymentService.charge(event.getOrderId(), event.getAmount());
            eventPublisher.publish(new PaymentCompletedEvent(event.getOrderId()));
        } catch (PaymentException e) {
            eventPublisher.publish(new PaymentFailedEvent(event.getOrderId()));
        }
    }
}

// Order Service (Compensate)
@EventListener
public class OrderCompensationHandler {
    public void handle(PaymentFailedEvent event) {
        orderRepository.updateStatus(event.getOrderId(), OrderStatus.CANCELLED);
        eventPublisher.publish(new OrderCancelledEvent(event.getOrderId()));
    }
}
```

---

## 4. æœåŠ¡ç½‘æ ¼ï¼ˆService Meshï¼‰

### 4.1 Istio æ¶æ„

```text
Istio = Control Plane + Data Plane

Control Plane:
  - Pilot: æœåŠ¡å‘ç°ã€æµé‡ç®¡ç†
  - Citadel: è¯ä¹¦ç®¡ç†ã€mTLS
  - Galley: é…ç½®éªŒè¯

Data Plane:
  - Envoy Sidecar: æ¯ä¸ª Pod æ³¨å…¥ä»£ç†
```

**æµé‡ç®¡ç†ç¤ºä¾‹**ï¼š

```yaml
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: order-service
spec:
  hosts:
  - order-service
  http:
  - match:
    - headers:
        user-type:
          exact: premium
    route:
    - destination:
        host: order-service
        subset: v2
      weight: 100
  - route:
    - destination:
        host: order-service
        subset: v1
      weight: 90
    - destination:
        host: order-service
        subset: v2
      weight: 10  # é‡‘ä¸é›€å‘å¸ƒ
```

**æ–­è·¯å™¨é…ç½®**ï¼š

```yaml
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: order-service
spec:
  host: order-service
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        http1MaxPendingRequests: 50
        http2MaxRequests: 100
        maxRequestsPerConnection: 2
    outlierDetection:
      consecutiveErrors: 5
      interval: 30s
      baseEjectionTime: 30s
      maxEjectionPercent: 50
```

### 4.2 Linkerdï¼ˆè½»é‡çº§ï¼‰

**å®‰è£…**ï¼š

```bash
# å®‰è£… Linkerd CLI
curl -sL https://run.linkerd.io/install | sh

# æ£€æŸ¥é›†ç¾¤
linkerd check --pre

# å®‰è£… Control Plane
linkerd install | kubectl apply -f -

# æ³¨å…¥ Sidecar
kubectl get deploy order-service -o yaml \
  | linkerd inject - \
  | kubectl apply -f -
```

**ä¼˜åŠ¿**ï¼š

- æ›´è½»é‡ï¼ˆRust ç¼–å†™ï¼‰
- æ›´å¿«ï¼ˆç›¸æ¯” Envoyï¼‰
- æ›´ç®€å•ï¼ˆé»˜è®¤é…ç½®å³å¯ç”¨ï¼‰

---

## 5. å¯è§‚æµ‹æ€§

### 5.1 åˆ†å¸ƒå¼è¿½è¸ªï¼ˆOpenTelemetryï¼‰

**Go ç¤ºä¾‹**ï¼š

```go
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/exporters/jaeger"
    "go.opentelemetry.io/otel/sdk/trace"
)

func initTracer() (*trace.TracerProvider, error) {
    exporter, err := jaeger.New(jaeger.WithCollectorEndpoint(
        jaeger.WithEndpoint("http://jaeger:14268/api/traces")))
    if err != nil {
        return nil, err
    }
    
    tp := trace.NewTracerProvider(
        trace.WithBatcher(exporter),
        trace.WithResource(resource.NewWithAttributes(
            semconv.SchemaURL,
            semconv.ServiceNameKey.String("order-service"),
        )),
    )
    otel.SetTracerProvider(tp)
    return tp, nil
}

func handleRequest(w http.ResponseWriter, r *http.Request) {
    ctx, span := otel.Tracer("order-service").Start(r.Context(), "CreateOrder")
    defer span.End()
    
    // è°ƒç”¨ä¸‹æ¸¸æœåŠ¡
    inventoryResp := callInventoryService(ctx)
    
    // ä¸šåŠ¡é€»è¾‘
    order := createOrder(ctx, r.Body)
    
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(order)
}
```

**Jaeger UI æ•ˆæœ**ï¼š

```text
Trace: è®¢å•åˆ›å»º [æ€»è€—æ—¶: 250ms]
  â”œâ”€ API Gateway [10ms]
  â”œâ”€ Order Service [100ms]
  â”‚   â”œâ”€ DB Query [50ms]
  â”‚   â””â”€ Inventory Check [30ms]
  â”œâ”€ Inventory Service [80ms]
  â”‚   â””â”€ Cache Lookup [5ms]
  â””â”€ Payment Service [60ms]
      â””â”€ External API [55ms]
```

### 5.2 åº¦é‡ç›‘æ§ï¼ˆPrometheus + Grafanaï¼‰

**Prometheus é…ç½®**ï¼š

```yaml
scrape_configs:
  - job_name: 'order-service'
    kubernetes_sd_configs:
      - role: pod
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
        action: replace
        target_label: __metrics_path__
        regex: (.+)
```

**åº”ç”¨æš´éœ²æŒ‡æ ‡**ï¼š

```go
import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
    ordersCreated = promauto.NewCounterVec(prometheus.CounterOpts{
        Name: "orders_created_total",
        Help: "Total number of orders created",
    }, []string{"status"})
    
    orderDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
        Name:    "order_creation_duration_seconds",
        Help:    "Order creation duration",
        Buckets: []float64{0.1, 0.5, 1, 2, 5},
    }, []string{"status"})
)

func handleCreateOrder(w http.ResponseWriter, r *http.Request) {
    timer := prometheus.NewTimer(orderDuration.WithLabelValues("success"))
    defer timer.ObserveDuration()
    
    order, err := createOrder(r.Body)
    if err != nil {
        ordersCreated.WithLabelValues("error").Inc()
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    ordersCreated.WithLabelValues("success").Inc()
    json.NewEncoder(w).Encode(order)
}
```

### 5.3 æ—¥å¿—èšåˆï¼ˆELK Stackï¼‰

**ç»“æ„åŒ–æ—¥å¿—ï¼ˆJSONï¼‰**ï¼š

```go
import "github.com/sirupsen/logrus"

log := logrus.New()
log.SetFormatter(&logrus.JSONFormatter{})

log.WithFields(logrus.Fields{
    "service":  "order-service",
    "order_id": order.ID,
    "user_id":  order.UserID,
    "amount":   order.Amount,
}).Info("Order created successfully")
```

**Filebeat é…ç½®**ï¼š

```yaml
filebeat.inputs:
- type: container
  paths:
    - '/var/log/containers/*.log'
  processors:
    - add_kubernetes_metadata:
        host: ${NODE_NAME}

output.elasticsearch:
  hosts: ["elasticsearch:9200"]
  index: "microservices-%{+yyyy.MM.dd}"
```

---

## 6. å½¢å¼åŒ–éªŒè¯

### 6.1 TLA+ å»ºæ¨¡ï¼ˆä¸€è‡´æ€§ï¼‰

**ç¤ºä¾‹**ï¼šè®¢å•æœåŠ¡æœ€ç»ˆä¸€è‡´æ€§

```tla
EXTENDS Integers, Sequences

VARIABLES 
  orderState,       \* {"pending", "confirmed", "cancelled"}
  inventoryReserved,  \* Boolean
  paymentProcessed,   \* Boolean
  events              \* äº‹ä»¶é˜Ÿåˆ—

TypeOK ==
  /\ orderState \in {"pending", "confirmed", "cancelled"}
  /\ inventoryReserved \in BOOLEAN
  /\ paymentProcessed \in BOOLEAN
  /\ events \in Seq({"OrderCreated", "InventoryReserved", "PaymentProcessed", "OrderCancelled"})

Init ==
  /\ orderState = "pending"
  /\ inventoryReserved = FALSE
  /\ paymentProcessed = FALSE
  /\ events = << >>

ReserveInventory ==
  /\ orderState = "pending"
  /\ ~inventoryReserved
  /\ inventoryReserved' = TRUE
  /\ events' = Append(events, "InventoryReserved")
  /\ UNCHANGED <<orderState, paymentProcessed>>

ProcessPayment ==
  /\ orderState = "pending"
  /\ inventoryReserved
  /\ ~paymentProcessed
  /\ paymentProcessed' = TRUE
  /\ events' = Append(events, "PaymentProcessed")
  /\ UNCHANGED <<orderState, inventoryReserved>>

ConfirmOrder ==
  /\ orderState = "pending"
  /\ inventoryReserved
  /\ paymentProcessed
  /\ orderState' = "confirmed"
  /\ events' = Append(events, "OrderConfirmed")
  /\ UNCHANGED <<inventoryReserved, paymentProcessed>>

CancelOrder ==
  /\ orderState = "pending"
  /\ orderState' = "cancelled"
  /\ inventoryReserved' = FALSE
  /\ paymentProcessed' = FALSE
  /\ events' = Append(events, "OrderCancelled")

Next ==
  \/ ReserveInventory
  \/ ProcessPayment
  \/ ConfirmOrder
  \/ CancelOrder

(* æœ€ç»ˆä¸€è‡´æ€§ï¼šæ€»ä¼šåˆ°è¾¾ç»ˆæ€ *)
EventualConsistency ==
  <>[](orderState \in {"confirmed", "cancelled"})

(* ä¸å˜å¼ï¼šç¡®è®¤å‰å¿…é¡»å®Œæˆæ‰€æœ‰æ­¥éª¤ *)
Invariant ==
  orderState = "confirmed" => (inventoryReserved /\ paymentProcessed)
```

**éªŒè¯**ï¼š

```bash
tlc microservices.tla -workers 4
```

### 6.2 mCRL2 å»ºæ¨¡ï¼ˆå¹¶å‘ï¼‰

**ç¤ºä¾‹**ï¼šæœåŠ¡é—´é€šä¿¡æ­»é”æ£€æµ‹

```mcrl2
sort Service = struct OrderService | InventoryService | PaymentService;
     Message = struct CreateOrder | ReserveInventory | ProcessPayment | Response;

act send, receive : Service # Service # Message;
    process : Service # Message;

proc OrderService =
  receive(API, OrderService, CreateOrder) .
  send(OrderService, InventoryService, ReserveInventory) .
  receive(InventoryService, OrderService, Response) .
  send(OrderService, PaymentService, ProcessPayment) .
  receive(PaymentService, OrderService, Response) .
  OrderService;

proc InventoryService =
  receive(OrderService, InventoryService, ReserveInventory) .
  process(InventoryService, ReserveInventory) .
  send(InventoryService, OrderService, Response) .
  InventoryService;

proc PaymentService =
  receive(OrderService, PaymentService, ProcessPayment) .
  process(PaymentService, ProcessPayment) .
  send(PaymentService, OrderService, Response) .
  PaymentService;

init allow({send, receive, process},
  comm({send|receive -> sync},
    OrderService || InventoryService || PaymentService));
```

**æ­»é”æ£€æµ‹**ï¼š

```bash
mcrl22lps microservices.mcrl2 | lps2lts -v
ltsconvert -edead output.lts
# æ£€æŸ¥è¾“å‡ºï¼šæ— æ­»é”
```

---

## 7. å®é™…æ¡ˆä¾‹

### 7.1 Netflix

**è§„æ¨¡**ï¼š

- 700+ å¾®æœåŠ¡
- æ•°åƒå°æœåŠ¡å™¨
- å…¨çƒ 1.9 äº¿ç”¨æˆ·

**æŠ€æœ¯æ ˆ**ï¼š

- **Spring Boot**ï¼šæœåŠ¡æ¡†æ¶
- **Eureka**ï¼šæœåŠ¡å‘ç°
- **Ribbon**ï¼šè´Ÿè½½å‡è¡¡
- **Hystrix**ï¼šæ–­è·¯å™¨
- **Zuul**ï¼šAPI ç½‘å…³
- **Archaius**ï¼šåŠ¨æ€é…ç½®

**æŒ‘æˆ˜ä¸è§£å†³**ï¼š

| æŒ‘æˆ˜ | è§£å†³æ–¹æ¡ˆ |
|------|----------|
| æœåŠ¡å‘ç° | Eureka + Ribbon |
| çº§è”å¤±è´¥ | Hystrix æ–­è·¯å™¨ |
| æµé‡ç®¡ç† | Zuul è·¯ç”±è§„åˆ™ |
| æµ‹è¯•æ··æ²Œ | Chaos Monkey |

### 7.2 Amazon

**Prime Day 2021**ï¼š

- å¤„ç† 2.5 äº¿è®¢å•
- å³°å€¼ QPSï¼š250,000
- 99.999% å¯ç”¨æ€§

**å…³é”®æŠ€æœ¯**ï¼š

- **DynamoDB**ï¼šNoSQL æ•°æ®åº“
- **SQS**ï¼šæ¶ˆæ¯é˜Ÿåˆ—
- **Lambda**ï¼šæ— æœåŠ¡å™¨è®¡ç®—
- **API Gateway**ï¼šç»Ÿä¸€å…¥å£

### 7.3 Uber

**æœåŠ¡æ•°é‡**ï¼š2200+

**æŠ€æœ¯æ ˆ**ï¼š

- **Golang**ï¼šé«˜æ€§èƒ½æœåŠ¡
- **Cadence**ï¼šå·¥ä½œæµå¼•æ“ï¼ˆSagaï¼‰
- **Jaeger**ï¼šåˆ†å¸ƒå¼è¿½è¸ª
- **Envoy**ï¼šæœåŠ¡ä»£ç†

**æ¶æ„æ¼”è¿›**ï¼š

```text
å•ä½“ï¼ˆ2012ï¼‰ â†’ å¾®æœåŠ¡ï¼ˆ2015ï¼‰ â†’ æœåŠ¡ç½‘æ ¼ï¼ˆ2019ï¼‰
```

---

## 8. æœ€ä½³å®è·µ

### 8.1 æœåŠ¡æ‹†åˆ†åŸåˆ™

**é¢†åŸŸé©±åŠ¨è®¾è®¡ï¼ˆDDDï¼‰**ï¼š

```text
æœåŠ¡è¾¹ç•Œ = é™ç•Œä¸Šä¸‹æ–‡ï¼ˆBounded Contextï¼‰

ç¤ºä¾‹ï¼š
  - è®¢å•ä¸Šä¸‹æ–‡ï¼šOrder, OrderItem, OrderStatus
  - åº“å­˜ä¸Šä¸‹æ–‡ï¼šProduct, Stock, Reservation
  - æ”¯ä»˜ä¸Šä¸‹æ–‡ï¼šPayment, Transaction, Refund

æ¯ä¸ªä¸Šä¸‹æ–‡ä¸€ä¸ªå¾®æœåŠ¡
```

**æ‹†åˆ†ç²’åº¦**ï¼š

- âœ… **å¤ªå°**ï¼šæœåŠ¡æ•°é‡çˆ†ç‚¸ï¼Œé€šä¿¡å¼€é”€å¤§
- âœ… **åˆé€‚**ï¼šæŒ‰ä¸šåŠ¡èƒ½åŠ›æ‹†åˆ†ï¼Œå›¢é˜Ÿè‡ªæ²»
- âŒ **å¤ªå¤§**ï¼šé€€åŒ–ä¸ºåˆ†å¸ƒå¼å•ä½“

### 8.2 API ç‰ˆæœ¬ç®¡ç†

**URL ç‰ˆæœ¬**ï¼š

```text
/api/v1/orders
/api/v2/orders
```

**Header ç‰ˆæœ¬**ï¼š

```http
GET /api/orders
Accept: application/vnd.company.v1+json
```

**å…¼å®¹æ€§åŸåˆ™**ï¼š

- å‘åå…¼å®¹ï¼šæ–°ç‰ˆæœ¬æ”¯æŒæ—§å®¢æˆ·ç«¯
- å¼ƒç”¨è¿‡æ¸¡æœŸï¼šè‡³å°‘ 6 ä¸ªæœˆ

### 8.3 éƒ¨ç½²ç­–ç•¥

**è“ç»¿éƒ¨ç½²**ï¼š

```text
Blue (æ—§ç‰ˆæœ¬) â† 100% æµé‡
Green (æ–°ç‰ˆæœ¬) â† 0% æµé‡

åˆ‡æ¢ï¼š
  1. éƒ¨ç½² Green
  2. å¥åº·æ£€æŸ¥
  3. æµé‡åˆ‡æ¢åˆ° Green
  4. ç›‘æ§
  5. è‹¥æœ‰é—®é¢˜ï¼Œç«‹å³åˆ‡å› Blue
```

**é‡‘ä¸é›€å‘å¸ƒ**ï¼š

```text
v1 â† 90% æµé‡
v2 â† 10% æµé‡ï¼ˆé‡‘ä¸é›€ï¼‰

ç›‘æ§æŒ‡æ ‡ï¼š
  - é”™è¯¯ç‡
  - å»¶è¿Ÿ
  - èµ„æºä½¿ç”¨

é€æ­¥å¢åŠ  v2 æµé‡ï¼š10% â†’ 25% â†’ 50% â†’ 100%
```

---

## 9. å¤§å­¦è¯¾ç¨‹å¯¹åº”

| è¯¾ç¨‹ | ç›¸å…³ç« èŠ‚ |
|------|----------|
| **MIT 6.824 åˆ†å¸ƒå¼ç³»ç»Ÿ** | ä¸€è‡´æ€§ã€Sagaã€CAP å®šç† |
| **CMU 17-313 è½¯ä»¶æ¶æ„** | å¾®æœåŠ¡æ‹†åˆ†ã€API è®¾è®¡ |
| **Stanford CS 253 Web å®‰å…¨** | API ç½‘å…³ã€è®¤è¯æˆæƒ |
| **Berkeley CS 294 äº‘è®¡ç®—** | Kubernetesã€æœåŠ¡ç½‘æ ¼ |

---

## å¿«é€Ÿå‚è€ƒ

### æ ¸å¿ƒç»„ä»¶

```text
å¾®æœåŠ¡æ¶æ„ = Services + Gateway + Discovery + Mesh

é€šä¿¡ï¼šREST / gRPC / Kafka
æ•°æ®ï¼šDatabase per Service + Saga
ç½‘æ ¼ï¼šIstio / Linkerd
å¯è§‚æµ‹æ€§ï¼šPrometheus + Jaeger + ELK
```

### å·¥å…·é“¾

```bash
# éƒ¨ç½²
kubectl apply -f k8s/
docker-compose up

# æœåŠ¡å‘ç°
consul agent -dev

# API ç½‘å…³
kong start

# è¿½è¸ª
jaeger all-in-one

# ç›‘æ§
prometheus --config.file=prometheus.yml
```

---

## é™„å½•ï¼šWikipedia æ¦‚å¿µå¯¹ç…§

| æ¦‚å¿µ | Wikipedia æ¡ç›® | æœ¬æ–‡ç« èŠ‚ |
|------|----------------|----------|
| Microservices | <https://en.wikipedia.org/wiki/Microservices> | Â§1 |
| Service Mesh | <https://en.wikipedia.org/wiki/Service_mesh> | Â§4 |
| API Gateway | <https://en.wikipedia.org/wiki/API_management> | Â§1.2 |
| Saga Pattern | <https://en.wikipedia.org/wiki/Long-running_transaction> | Â§3.2 |
| CAP Theorem | <https://en.wikipedia.org/wiki/CAP_theorem> | Â§4.1 |

---

**ç‰ˆæœ¬**ï¼šv1.0  
**æœ€åæ›´æ–°**ï¼š2025-10-29  
**ç»´æŠ¤è€…**ï¼šFormalScience Project  
**è®¸å¯**ï¼šCC BY-SA 4.0
