# 9.8 实战案例：高并发秒杀系统

## 案例背景

**场景**：双11秒杀活动
- **峰值QPS**：10万/秒
- **商品数量**：100件（库存极少）
- **参与人数**：100万人
- **成功率**：< 0.01%

**核心挑战**：
1. **高并发**：100万请求瞬间涌入
2. **超卖问题**：库存100件，不能卖出101件
3. **系统稳定性**：不能因秒杀影响正常订单
4. **用户体验**：快速响应，避免卡顿

---

## 系统架构

### 整体架构

```
┌────────────────────────────────────────────────────────┐
│  用户层（100万用户）                                    │
└────────────┬───────────────────────────────────────────┘
             │ HTTPS
             ↓
┌────────────────────────────────────────────────────────┐
│  CDN + 静态资源                                         │
│  - 商品详情页（静态化）                                  │
│  - JS/CSS/图片                                          │
└────────────┬───────────────────────────────────────────┘
             │ 动态请求
             ↓
┌────────────────────────────────────────────────────────┐
│  接入层                                                │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐              │
│  │ Nginx    │  │ 限流     │  │ 防刷      │              │
│  │ 负载均衡  │  │ 100K QPS │  │ 验证码   │              │
│  └──────────┘  └──────────┘  └──────────┘              │
└────────────┬───────────────────────────────────────────┘
             │
    ┌────────┴────────┬────────────┐
    ↓                 ↓            ↓
┌─────────┐    ┌─────────┐  ┌─────────┐
│秒杀服务  │    │订单服务  │  │支付服务 │
│(核心)    │    │         │  │        │
└────┬────┘    └─────────┘  └─────────┘
     │
     ↓
┌─────────────────────────────────────┐
│  缓存层（Redis Cluster）             │
│  ┌────────────┐  ┌────────────┐     │
│  │库存缓存     │  │令牌桶限流   │     │
│  │100 → 99... │  │            │     │
│  └────────────┘  └────────────┘     │
└────────────┬────────────────────────┘
             │
             ↓
┌─────────────────────────────────────┐
│  消息队列（Kafka）                   │
│  - 异步削峰                          │
│  - 订单创建解耦                      │
└────────────┬────────────────────────┘
             │
             ↓
┌─────────────────────────────────────┐
│  数据库（MySQL 主从）                │
│  - 订单表                           │
│  - 库存表（最终一致性）               │
└─────────────────────────────────────┘
```

---

## 核心技术方案

### 1. 页面静态化 + CDN

**问题**：商品详情页频繁访问，数据库压力大

**解决**：静态化 + CDN

```html
<!-- 秒杀商品详情页（静态HTML） -->
<!DOCTYPE html>
<html>
<head>
    <title>iPhone 15 Pro 秒杀</title>
    <link rel="stylesheet" href="https://cdn.example.com/css/seckill.css">
</head>
<body>
    <!-- 商品信息（静态） -->
    <div class="product-info">
        <img src="https://cdn.example.com/images/iphone15.jpg" />
        <h1>iPhone 15 Pro 256GB</h1>
        <p class="price">秒杀价：¥5999 <del>原价：¥8999</del></p>
        <p class="stock">库存：<span id="stock">100</span>件</p>
    </div>
    
    <!-- 秒杀按钮 -->
    <button id="seckill-btn" onclick="doSeckill()">立即抢购</button>
    
    <script src="https://cdn.example.com/js/seckill.js"></script>
    <script>
        // 动态加载库存（AJAX）
        fetch('https://api.example.com/seckill/stock/12345')
            .then(res => res.json())
            .then(data => {
                document.getElementById('stock').innerText = data.stock;
            });
        
        // 秒杀倒计时
        let startTime = new Date('2025-11-11 20:00:00');
        setInterval(() => {
            let now = new Date();
            let diff = startTime - now;
            if (diff <= 0) {
                document.getElementById('seckill-btn').disabled = false;
            }
        }, 1000);
        
        function doSeckill() {
            // 防止重复点击
            document.getElementById('seckill-btn').disabled = true;
            
            fetch('https://api.example.com/seckill/purchase', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    productId: 12345,
                    userId: getUserId(),
                    token: getCaptchaToken()  // 验证码token
                })
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    alert('抢购成功！订单号：' + data.orderId);
                    location.href = '/orders/' + data.orderId;
                } else {
                    alert('抢购失败：' + data.message);
                    document.getElementById('seckill-btn').disabled = false;
                }
            });
        }
    </script>
</body>
</html>
```

**效果**：
- 静态页面命中CDN：100% → 不访问服务器
- 库存数据动态加载：延迟加载，减少压力
- **QPS降低**：100万 → 1万（只有动态请求）

### 2. 多级限流

#### Level 1：Nginx限流

```nginx
# nginx.conf
http {
    # 定义限流区域
    limit_req_zone $binary_remote_addr zone=seckill_limit:10m rate=10r/s;
    
    server {
        listen 80;
        server_name api.example.com;
        
        location /seckill/ {
            # 应用限流：每IP每秒10个请求，burst 20
            limit_req zone=seckill_limit burst=20 nodelay;
            
            # 限制并发连接数
            limit_conn_zone $binary_remote_addr zone=addr:10m;
            limit_conn addr 5;
            
            proxy_pass http://seckill_backend;
        }
    }
}
```

**效果**：
- 单IP限流：防止单个用户暴力刷接口
- 总QPS限流：10万 → 5万（Nginx层）

#### Level 2：Redis令牌桶限流

```java
@Service
public class RateLimiterService {
    @Autowired
    private RedisTemplate<String, String> redis;
    
    /**
     * 令牌桶限流
     * @param key 限流key（如：seckill:12345）
     * @param capacity 桶容量
     * @param rate 令牌生成速率（个/秒）
     */
    public boolean tryAcquire(String key, int capacity, int rate) {
        String script =
            "local key = KEYS[1] " +
            "local capacity = tonumber(ARGV[1]) " +
            "local rate = tonumber(ARGV[2]) " +
            "local now = tonumber(ARGV[3]) " +
            
            "local tokens_key = key .. ':tokens' " +
            "local timestamp_key = key .. ':timestamp' " +
            
            // 获取当前令牌数和上次更新时间
            "local tokens = tonumber(redis.call('get', tokens_key) or capacity) " +
            "local last_time = tonumber(redis.call('get', timestamp_key) or now) " +
            
            // 计算新增令牌数
            "local delta = math.max(0, now - last_time) " +
            "local new_tokens = math.min(capacity, tokens + delta * rate) " +
            
            // 尝试消费1个令牌
            "if new_tokens >= 1 then " +
            "  redis.call('set', tokens_key, new_tokens - 1) " +
            "  redis.call('set', timestamp_key, now) " +
            "  return 1 " +
            "else " +
            "  redis.call('set', tokens_key, new_tokens) " +
            "  redis.call('set', timestamp_key, now) " +
            "  return 0 " +
            "end";
        
        Long result = redis.execute(
            new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(key),
            String.valueOf(capacity),
            String.valueOf(rate),
            String.valueOf(System.currentTimeMillis() / 1000)
        );
        
        return result != null && result == 1;
    }
}
```

**使用**：
```java
@RestController
@RequestMapping("/seckill")
public class SeckillController {
    @Autowired
    private RateLimiterService rateLimiter;
    
    @PostMapping("/purchase")
    public Result purchase(@RequestBody SeckillRequest request) {
        String limiterKey = "seckill:" + request.getProductId();
        
        // 限流：每秒1000个令牌
        if (!rateLimiter.tryAcquire(limiterKey, 1000, 1000)) {
            return Result.fail("系统繁忙，请稍后再试");
        }
        
        // 处理秒杀逻辑...
        return seckillService.purchase(request);
    }
}
```

### 3. 库存预扣减（Redis原子操作）

**问题**：100万请求，库存只有100，如何防止超卖？

**方案**：Redis原子操作

```java
@Service
public class StockService {
    @Autowired
    private RedisTemplate<String, String> redis;
    
    /**
     * 预扣减库存
     */
    public boolean deductStock(Long productId, int quantity) {
        String key = "stock:" + productId;
        
        // Lua脚本保证原子性
        String script =
            "local stock = tonumber(redis.call('get', KEYS[1]) or 0) " +
            "local quantity = tonumber(ARGV[1]) " +
            "if stock >= quantity then " +
            "  redis.call('decrby', KEYS[1], quantity) " +
            "  return 1 " +
            "else " +
            "  return 0 " +
            "end";
        
        Long result = redis.execute(
            new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(key),
            String.valueOf(quantity)
        );
        
        return result != null && result == 1;
    }
    
    /**
     * 初始化库存（秒杀前）
     */
    public void initStock(Long productId, int stock) {
        String key = "stock:" + productId;
        redis.opsForValue().set(key, String.valueOf(stock));
    }
    
    /**
     * 回滚库存（订单取消）
     */
    public void rollbackStock(Long productId, int quantity) {
        String key = "stock:" + productId;
        redis.opsForValue().increment(key, quantity);
    }
}
```

**流程**：
```
Step 1: 秒杀前初始化
initStock(12345, 100)
→ Redis: stock:12345 = 100

Step 2: 用户抢购
deductStock(12345, 1)
→ Redis: stock:12345 = 99  (原子操作)

Step 3: 库存耗尽
deductStock(12345, 1)
→ Redis: stock:12345 = 0
→ 再有请求：返回 false（不允许扣减）

Step 4: 订单取消（15分钟未支付）
rollbackStock(12345, 1)
→ Redis: stock:12345 = 1
```

### 4. 异步削峰（消息队列）

**问题**：1秒内100万请求，数据库写入承受不了

**方案**：消息队列削峰

```java
@Service
public class SeckillService {
    @Autowired
    private StockService stockService;
    @Autowired
    private KafkaTemplate<String, SeckillMessage> kafka;
    
    public Result purchase(SeckillRequest request) {
        Long productId = request.getProductId();
        Long userId = request.getUserId();
        
        // 1. 验证用户资格
        if (!validateUser(userId, productId)) {
            return Result.fail("不符合抢购条件");
        }
        
        // 2. 预扣减库存（Redis）
        if (!stockService.deductStock(productId, 1)) {
            return Result.fail("商品已售罄");
        }
        
        // 3. 发送消息到队列（异步创建订单）
        SeckillMessage message = new SeckillMessage();
        message.setProductId(productId);
        message.setUserId(userId);
        message.setTimestamp(System.currentTimeMillis());
        
        kafka.send("seckill-orders", message);
        
        // 4. 立即返回（不等待订单创建）
        return Result.success("抢购成功，正在创建订单...");
    }
}
```

**消费者**（异步创建订单）：
```java
@Service
public class OrderConsumer {
    @KafkaListener(topics = "seckill-orders", concurrency = "10")
    public void handleSeckillOrder(SeckillMessage message) {
        try {
            // 1. 创建订单
            Order order = new Order();
            order.setUserId(message.getUserId());
            order.setProductId(message.getProductId());
            order.setStatus(OrderStatus.UNPAID);
            order.setExpireTime(LocalDateTime.now().plusMinutes(15));
            
            orderRepository.save(order);
            
            // 2. 发送支付通知
            notificationService.sendPaymentNotice(order);
            
            // 3. 设置订单超时取消任务
            scheduleOrderExpiration(order.getId(), 15 * 60 * 1000);
            
        } catch (Exception e) {
            log.error("Failed to create order", e);
            
            // 失败回滚库存
            stockService.rollbackStock(
                message.getProductId(), 
                1
            );
        }
    }
}
```

**效果**：
```
瞬时峰值：100万请求/秒
    ↓
Redis预扣减：100个成功，其余失败
    ↓
Kafka削峰：100个订单消息
    ↓
消费者处理：10 TPS（慢慢写数据库）

结果：
- 数据库压力：10 TPS（可承受）
- 用户体验：秒级响应
```

### 5. 防刷策略

#### 验证码

```java
@Service
public class CaptchaService {
    @Autowired
    private RedisTemplate<String, String> redis;
    
    /**
     * 生成验证码
     */
    public String generateCaptcha(Long userId) {
        // 生成4位数字验证码
        String code = String.format("%04d", new Random().nextInt(10000));
        
        // 存入Redis，5分钟过期
        String key = "captcha:" + userId;
        redis.opsForValue().set(key, code, 5, TimeUnit.MINUTES);
        
        return code;
    }
    
    /**
     * 验证验证码
     */
    public boolean validateCaptcha(Long userId, String code) {
        String key = "captcha:" + userId;
        String stored = redis.opsForValue().get(key);
        
        if (stored == null || !stored.equals(code)) {
            return false;
        }
        
        // 验证成功后删除（防止重复使用）
        redis.delete(key);
        return true;
    }
}
```

#### 防止重复下单

```java
@Service
public class DuplicateCheckService {
    @Autowired
    private RedisTemplate<String, String> redis;
    
    /**
     * 检查是否已参与秒杀
     */
    public boolean isAlreadyPurchased(Long userId, Long productId) {
        String key = String.format("seckill:user:%d:product:%d", userId, productId);
        
        // SETNX：不存在才设置
        Boolean success = redis.opsForValue().setIfAbsent(
            key, 
            "1", 
            24, 
            TimeUnit.HOURS
        );
        
        // success = true: 第一次参与
        // success = false: 已经参与过
        return success == null || !success;
    }
}
```

### 6. 订单超时取消

```java
@Service
public class OrderExpirationService {
    @Autowired
    private RedisTemplate<String, String> redis;
    @Autowired
    private OrderService orderService;
    @Autowired
    private StockService stockService;
    
    /**
     * 延迟任务：15分钟后取消未支付订单
     */
    public void scheduleOrderExpiration(Long orderId, long delayMs) {
        // 使用Redis的过期键 + KeyExpiredListener
        String key = "order:expiration:" + orderId;
        redis.opsForValue().set(key, "1", delayMs, TimeUnit.MILLISECONDS);
    }
    
    @Component
    public static class OrderExpirationListener extends KeyExpirationEventMessageListener {
        @Autowired
        private OrderService orderService;
        @Autowired
        private StockService stockService;
        
        @Override
        public void onMessage(Message message, byte[] pattern) {
            String expiredKey = message.toString();
            
            if (expiredKey.startsWith("order:expiration:")) {
                Long orderId = Long.parseLong(expiredKey.substring(17));
                
                // 查询订单状态
                Order order = orderService.getOrder(orderId);
                
                if (order != null && order.getStatus() == OrderStatus.UNPAID) {
                    // 取消订单
                    order.setStatus(OrderStatus.CANCELLED);
                    order.setCancelReason("超时未支付");
                    orderService.updateOrder(order);
                    
                    // 回滚库存
                    stockService.rollbackStock(order.getProductId(), 1);
                    
                    log.info("Order {} cancelled due to expiration", orderId);
                }
            }
        }
    }
}
```

---

## 完整流程时序图

```
用户    │  Nginx  │  秒杀服务  │  Redis  │  Kafka  │  订单消费者  │  数据库
  │         │         │          │         │         │             │
  ├────────>│限流检查 │          │         │         │             │
  │         ├────────>│防刷验证  │         │         │             │
  │         │         ├─────────>│验证码   │         │             │
  │         │         │<─────────┤         │         │             │
  │         │         │          │         │         │             │
  │         │         ├─────────>│预扣库存 │         │             │
  │         │         │<─────────┤成功/失败│         │             │
  │         │         │          │         │         │             │
  │         │         ├──────────────────>│发送消息 │             │
  │<────────┤<────────┤抢购成功  │         │         │             │
  │         │         │          │         │         │             │
  │         │         │          │         ├────────>│消费消息     │
  │         │         │          │         │         ├────────────>│创建订单
  │         │         │          │         │         │<────────────┤
  │         │         │          │         │         │             │
  │<────────────────────────────────────────────────┤支付通知     │
  │         │         │          │         │         │             │
  ├─────────────────────────────────────────────────────────────>│支付
  │<─────────────────────────────────────────────────────────────┤
  │         │         │          │         │         │             │
  
总耗时：< 200ms（用户感知）
后台异步：创建订单（2-5秒）
```

---

## 性能测试结果

### 压测场景

```
工具：JMeter
并发用户：100万
持续时间：10秒
目标QPS：10万/秒
```

### 测试结果

| 指标 | 优化前 | 优化后 | 提升 |
|-----|--------|--------|------|
| **峰值QPS** | 5K | 10万 | **20倍** |
| **平均响应时间** | 5000ms | 150ms | **33倍** |
| **P95响应时间** | 10000ms | 300ms | **33倍** |
| **成功率** | 60% | 99.9% | **1.6倍** |
| **数据库QPS** | 5K | 10 | **500倍降低** |
| **超卖次数** | 23次 | 0次 | ✅ |

---

## 成本分析

### 资源配置

| 资源 | 数量 | 规格 | 成本/小时 | 秒杀时长 | 总成本 |
|-----|------|------|----------|---------|--------|
| **Nginx** | 10台 | 4核8G | $0.2 | 1小时 | $2 |
| **秒杀服务** | 50台 | 8核16G | $0.4 | 1小时 | $20 |
| **Redis Cluster** | 6节点 | 16核32G | $1 | 1小时 | $6 |
| **Kafka** | 3节点 | 8核16G | $0.4 | 1小时 | $1.2 |
| **数据库** | 主从 | 16核64G | $2 | 24小时 | $48 |
| **带宽** | 1Gbps | - | $10 | 1小时 | $10 |
| **总计** | - | - | - | - | **$87.2** |

**ROI**：
```
秒杀商品：100件 × $1000利润 = $100K
系统成本：$87.2
ROI：1150倍
```

---

## 关键洞察

### 洞察 1：拦截在前，处理在后

```
100万请求：
- 90%拦截在CDN（静态资源）
- 9%拦截在Nginx（限流）
- 0.9%拦截在Redis（库存检查）
- 0.01%真正处理（100个订单）

漏斗效应：减轻后端压力
```

### 洞察 2：空间换时间

```
Redis预扣库存：
- 内存操作（纳秒级）
- 原子操作（无并发问题）
- 最终一致性（异步同步到数据库）

权衡：
- 成本增加：Redis内存
- 性能提升：1000倍
```

### 洞察 3：异步削峰

```
同步处理：
100万请求 → 数据库写入 → 数据库崩溃

异步处理：
100万请求 → 预筛选 → 100个消息 → 慢慢写入

关键：用户不需要立即看到订单，可以异步通知
```

---

## 相关主题

- [09.3 断路器与弹性设计](./09.3_Circuit_Breaker_Resilience.md)
- [09.6 多级缓存架构](./09.6_Multi_Level_Caching.md)
- [05.1 配置管理与自动扩缩容](../05_Configuration_Scaling/05.1_Configuration_Management_Landscape.md)

---

**导航**：[返回云原生模式](./README.md) | [← 上一节：金丝雀发布](./09.5_Canary_Deployment_Practice.md) | [完]

---

## 附录：压测脚本

**JMeter测试计划**：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2">
  <hashTree>
    <TestPlan>
      <stringProp name="TestPlan.comments">秒杀压测</stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
    </TestPlan>
    <hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup">
        <stringProp name="ThreadGroup.num_threads">10000</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.duration">10</longProp>
      </ThreadGroup>
      <hashTree>
        <HTTPSamplerProxy>
          <stringProp name="HTTPSampler.domain">api.example.com</stringProp>
          <stringProp name="HTTPSampler.path">/seckill/purchase</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
        </HTTPSamplerProxy>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
```

