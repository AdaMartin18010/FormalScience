# 9.1 微服务拆分策略

## 核心问题

> 如何将单体应用拆分为微服务？拆分的边界在哪里？粒度如何把握？

## 拆分原则

### 1. 按业务能力拆分（Business Capability）

**定义**：根据业务领域的核心能力划分服务边界

**示例：电商系统**

```
单体应用：
└── E-commerce Monolith

微服务拆分（按业务能力）：
├── 用户服务（User Service）
│   ├── 用户注册
│   ├── 用户登录
│   └── 用户资料管理
├── 商品服务（Product Service）
│   ├── 商品管理
│   ├── 库存管理
│   └── 价格管理
├── 订单服务（Order Service）
│   ├── 订单创建
│   ├── 订单支付
│   └── 订单状态管理
├── 支付服务（Payment Service）
│   ├── 支付处理
│   ├── 退款处理
│   └── 支付通知
└── 物流服务（Logistics Service）
    ├── 物流跟踪
    ├── 配送管理
    └── 签收确认
```

**判断标准**：
```
好的拆分：
✅ 每个服务对应一个业务能力
✅ 服务可独立演进
✅ 团队可独立交付

差的拆分：
❌ 服务边界模糊
❌ 服务间频繁通信
❌ 修改需要多个服务配合
```

### 2. 按领域驱动设计（DDD）

**核心概念**：

| 概念 | 定义 | 示例 |
|-----|------|------|
| **领域（Domain）** | 业务范围 | 电商 |
| **子域（Subdomain）** | 领域细分 | 商品、订单、支付 |
| **有界上下文（Bounded Context）** | 服务边界 | 订单上下文 |
| **聚合（Aggregate）** | 一致性边界 | 订单+订单项 |
| **实体（Entity）** | 有唯一标识 | 订单（Order ID） |
| **值对象（Value Object）** | 无标识，不可变 | 地址（Address） |

**DDD拆分流程**：

```
Step 1: 识别领域
电商领域

Step 2: 划分子域
├── 核心域（Core Domain）
│   └── 订单处理（业务核心竞争力）
├── 支撑域（Supporting Domain）
│   ├── 用户管理
│   └── 库存管理
└── 通用域（Generic Domain）
    ├── 支付（可用第三方）
    └── 物流（可用第三方）

Step 3: 定义有界上下文
订单上下文（Order Context）:
- 聚合：Order, OrderItem
- 实体：Order, Customer
- 值对象：Address, Money

商品上下文（Product Context）:
- 聚合：Product, Inventory
- 实体：Product, Category
- 值对象：Price, SKU

Step 4: 确定上下文映射
Order Context → Product Context: 调用 GetProduct API
Order Context → Payment Context: 发布 OrderCreated 事件
```

**上下文映射模式**：

```
1. 共享内核（Shared Kernel）
   两个上下文共享部分模型
   例：Order 和 Logistics 共享 Address

2. 客户-供应商（Customer-Supplier）
   下游依赖上游
   例：Order 依赖 Product

3. 防腐层（Anti-Corruption Layer）
   隔离外部系统
   例：对接第三方支付，用 ACL 转换数据

4. 开放主机服务（Open Host Service）
   提供标准 API
   例：Product Service 提供 RESTful API
```

### 3. 按团队结构拆分（Conway's Law）

**康威定律**：
> 系统架构反映了组织沟通结构

**示例**：

```
组织结构 → 系统架构

组织：
├── 前端团队（5人）
├── 用户团队（3人）
├── 订单团队（4人）
├── 支付团队（2人）
└── 物流团队（3人）

系统架构（自然对应）：
├── Web/Mobile 前端
├── 用户服务
├── 订单服务
├── 支付服务
└── 物流服务

好处：
✅ 团队自治
✅ 沟通高效
✅ 责任清晰
```

**逆向康威策略（Reverse Conway Maneuver）**：
```
如果想要某种架构：
先调整组织结构

例如：想要微服务架构
→ 先组建小型、跨职能团队
→ 每个团队负责一个服务
```

---

## 拆分粒度

### 服务大小指南

| 粒度 | 代码量 | 团队规模 | 适用场景 | 优缺点 |
|-----|--------|---------|---------|--------|
| **细粒度** | < 1K LOC | 1-2人 | 高变化频率 | ✅敏捷 ❌复杂度高 |
| **中粒度** | 1K-10K LOC | 2-5人 | 平衡场景 | ✅适中 ✅推荐 |
| **粗粒度** | 10K-50K LOC | 5-10人 | 稳定系统 | ✅简单 ❌耦合风险 |
| **迷你单体** | > 50K LOC | 10+人 | 避免 | ❌分布式单体 |

### 拆分信号

**何时应该拆分**：

```
信号 1: 团队冲突
- 多个团队修改同一代码
- 代码合并冲突频繁
→ 按团队边界拆分

信号 2: 部署瓶颈
- 小改动需要全量部署
- 部署时间 > 1小时
→ 拆分高变化模块

信号 3: 扩展瓶颈
- 部分功能需要扩展，但整体性能足够
- 资源浪费
→ 拆分高负载模块

信号 4: 技术栈限制
- 部分功能适合不同技术
- 例：AI推荐用Python，核心业务用Java
→ 拆分技术边界
```

**何时不应该拆分**：

```
信号 1: 过早优化
- 业务未稳定
- 用户量 < 1000
→ 保持单体，快速迭代

信号 2: 团队规模小
- 团队 < 5人
- 无DevOps能力
→ 单体足够

信号 3: 强一致性需求
- 金融交易
- 库存扣减
→ 单体或谨慎拆分
```

---

## 拆分实战：电商案例

### 原始单体架构

```java
// Monolith E-commerce Application

@RestController
public class OrderController {
    @Autowired
    private UserService userService;
    @Autowired
    private ProductService productService;
    @Autowired
    private PaymentService paymentService;
    @Autowired
    private InventoryService inventoryService;
    @Autowired
    private LogisticsService logisticsService;
    
    @PostMapping("/orders")
    @Transactional
    public Order createOrder(OrderRequest request) {
        // 1. 验证用户
        User user = userService.getUser(request.getUserId());
        if (user == null) throw new UserNotFoundException();
        
        // 2. 验证商品和库存
        for (OrderItem item : request.getItems()) {
            Product product = productService.getProduct(item.getProductId());
            if (product == null) throw new ProductNotFoundException();
            
            if (!inventoryService.checkStock(item.getProductId(), item.getQuantity())) {
                throw new InsufficientStockException();
            }
        }
        
        // 3. 创建订单
        Order order = new Order();
        order.setUserId(request.getUserId());
        order.setItems(request.getItems());
        order.setTotalAmount(calculateTotal(request.getItems()));
        orderRepository.save(order);
        
        // 4. 扣减库存
        for (OrderItem item : request.getItems()) {
            inventoryService.deductStock(item.getProductId(), item.getQuantity());
        }
        
        // 5. 调用支付
        Payment payment = paymentService.createPayment(order.getId(), order.getTotalAmount());
        
        // 6. 创建物流单
        logisticsService.createShipment(order.getId(), user.getAddress());
        
        return order;
    }
}
```

**问题**：
- ❌ 所有逻辑在一个事务中（长事务）
- ❌ 服务间紧耦合
- ❌ 无法独立扩展
- ❌ 故障传播（支付慢→整个订单慢）

### 拆分后的微服务架构

#### 服务划分

```
微服务架构：

┌─────────────────┐
│  API Gateway    │
└────────┬────────┘
         │
    ┌────┴────┬────────┬────────┬──────────┐
    ↓         ↓        ↓        ↓          ↓
┌────────┐ ┌─────┐ ┌──────┐ ┌───────┐ ┌─────────┐
│User    │ │Order│ │Product│Payment│ │Logistics│
│Service │ │Svc  │ │Service│Service│ │Service  │
└────────┘ └─────┘ └──────┘ └───────┘ └─────────┘
    │         │        │        │          │
    └─────────┴────────┴────────┴──────────┘
                      │
              ┌───────┴────────┐
              │  Event Bus     │
              │  (Kafka)       │
              └────────────────┘
```

#### Order Service（订单服务）

```java
@RestController
public class OrderController {
    @Autowired
    private OrderService orderService;
    
    @PostMapping("/orders")
    public CompletableFuture<OrderResponse> createOrder(OrderRequest request) {
        return orderService.createOrderAsync(request);
    }
}

@Service
public class OrderService {
    @Autowired
    private OrderRepository orderRepository;
    @Autowired
    private EventPublisher eventPublisher;
    @Autowired
    private ProductServiceClient productClient;
    
    public CompletableFuture<OrderResponse> createOrderAsync(OrderRequest request) {
        // 1. 验证商品（异步调用）
        CompletableFuture<List<Product>> productsFuture = 
            productClient.getProducts(request.getItemIds());
        
        return productsFuture.thenCompose(products -> {
            // 2. 创建订单（仅本地数据）
            Order order = new Order();
            order.setUserId(request.getUserId());
            order.setItems(request.getItems());
            order.setStatus(OrderStatus.PENDING);
            order.setTotalAmount(calculateTotal(products, request.getItems()));
            
            Order savedOrder = orderRepository.save(order);
            
            // 3. 发布事件（异步通知其他服务）
            eventPublisher.publish(new OrderCreatedEvent(
                savedOrder.getId(),
                savedOrder.getUserId(),
                savedOrder.getItems(),
                savedOrder.getTotalAmount()
            ));
            
            return CompletableFuture.completedFuture(
                new OrderResponse(savedOrder.getId(), "PENDING")
            );
        });
    }
}
```

#### Inventory Service（库存服务）

```java
@Service
public class InventoryEventHandler {
    @Autowired
    private InventoryService inventoryService;
    @Autowired
    private EventPublisher eventPublisher;
    
    @KafkaListener(topics = "order-created")
    public void handleOrderCreated(OrderCreatedEvent event) {
        try {
            // 1. 检查库存
            boolean sufficient = inventoryService.checkStock(event.getItems());
            
            if (sufficient) {
                // 2. 扣减库存
                inventoryService.deductStock(event.getItems());
                
                // 3. 发布成功事件
                eventPublisher.publish(new InventoryReservedEvent(
                    event.getOrderId(),
                    event.getItems()
                ));
            } else {
                // 4. 发布失败事件
                eventPublisher.publish(new InventoryInsufficientEvent(
                    event.getOrderId(),
                    "Insufficient stock"
                ));
            }
        } catch (Exception e) {
            // 5. 发布失败事件
            eventPublisher.publish(new InventoryReservationFailedEvent(
                event.getOrderId(),
                e.getMessage()
            ));
        }
    }
}
```

#### SAGA编排（分布式事务）

```java
@Service
public class OrderSagaOrchestrator {
    @Autowired
    private EventPublisher eventPublisher;
    @Autowired
    private OrderRepository orderRepository;
    
    // 监听库存预留成功
    @KafkaListener(topics = "inventory-reserved")
    public void handleInventoryReserved(InventoryReservedEvent event) {
        // 触发支付
        eventPublisher.publish(new PaymentRequestedEvent(
            event.getOrderId(),
            getOrderAmount(event.getOrderId())
        ));
    }
    
    // 监听支付成功
    @KafkaListener(topics = "payment-completed")
    public void handlePaymentCompleted(PaymentCompletedEvent event) {
        // 更新订单状态
        Order order = orderRepository.findById(event.getOrderId());
        order.setStatus(OrderStatus.PAID);
        orderRepository.save(order);
        
        // 触发物流
        eventPublisher.publish(new ShipmentRequestedEvent(
            event.getOrderId(),
            order.getUserId()
        ));
    }
    
    // 监听库存不足（补偿）
    @KafkaListener(topics = "inventory-insufficient")
    public void handleInventoryInsufficient(InventoryInsufficientEvent event) {
        // 取消订单
        Order order = orderRepository.findById(event.getOrderId());
        order.setStatus(OrderStatus.CANCELLED);
        order.setCancelReason("库存不足");
        orderRepository.save(order);
        
        // 通知用户
        eventPublisher.publish(new OrderCancelledEvent(
            event.getOrderId(),
            "库存不足"
        ));
    }
    
    // 监听支付失败（补偿）
    @KafkaListener(topics = "payment-failed")
    public void handlePaymentFailed(PaymentFailedEvent event) {
        // 1. 取消订单
        Order order = orderRepository.findById(event.getOrderId());
        order.setStatus(OrderStatus.CANCELLED);
        order.setCancelReason("支付失败");
        orderRepository.save(order);
        
        // 2. 回滚库存
        eventPublisher.publish(new InventoryReleaseRequestedEvent(
            event.getOrderId(),
            order.getItems()
        ));
    }
}
```

---

## 数据管理

### Database per Service

**原则**：每个服务有自己的数据库

```
User Service → users_db (PostgreSQL)
Order Service → orders_db (PostgreSQL)
Product Service → products_db (PostgreSQL)
Inventory Service → inventory_db (Redis)
```

**数据同步策略**：

```
策略 1: API调用（同步）
Order Service 调用 Product Service API 获取商品信息

策略 2: 事件驱动（异步）
Product Service 发布 ProductUpdated 事件
Order Service 监听事件，更新本地缓存

策略 3: 数据复制（冗余）
Order Service 保存商品快照（订单时的商品信息）
避免商品变更影响历史订单
```

### 数据一致性

**最终一致性示例**：

```
时间线：订单创建流程

T0: User 点击"购买"
T1: Order Service 创建订单（状态：PENDING）
T2: 发布 OrderCreated 事件
T3: Inventory Service 扣减库存
T4: 发布 InventoryReserved 事件
T5: Payment Service 处理支付
T6: 发布 PaymentCompleted 事件
T7: Order Service 更新状态（状态：PAID）

一致性窗口：T0-T7（约 2-5秒）
- T0-T7: 订单状态不一致（PENDING → PAID）
- T7后: 达到一致性
```

---

## 服务通信

### 同步 vs 异步

| 维度 | 同步（REST/gRPC） | 异步（Message Queue） |
|-----|------------------|---------------------|
| **响应时间** | 快（毫秒级） | 慢（秒级） |
| **耦合度** | 高（依赖可用性） | 低（解耦） |
| **一致性** | 强一致 | 最终一致 |
| **复杂度** | 低 | 高 |
| **适用场景** | 查询、实时要求 | 事件通知、异步处理 |

**选择指南**：

```
使用同步（REST）：
✅ 读操作（查询商品详情）
✅ 幂等操作（获取订单状态）
✅ 低延迟要求（< 100ms）

使用异步（MQ）：
✅ 写操作（创建订单）
✅ 非幂等操作（扣款）
✅ 解耦要求（订单→物流）
```

---

## 拆分检查清单

### 拆分前

```
[ ] 业务边界是否清晰？
[ ] 团队是否准备好？（DevOps能力）
[ ] 是否有监控体系？
[ ] 是否有自动化测试？
[ ] 是否有CI/CD？
```

### 拆分中

```
[ ] 是否定义了API契约？
[ ] 是否实现了服务发现？
[ ] 是否实现了配置管理？
[ ] 是否实现了分布式追踪？
[ ] 是否实现了熔断降级？
```

### 拆分后

```
[ ] 服务是否可独立部署？
[ ] 服务是否可独立扩展？
[ ] 服务故障是否隔离？
[ ] 数据是否一致？
[ ] 性能是否满足要求？
```

---

## 关键洞察

### 洞察 1：拆分是演进，不是革命

```
❌ 错误：一次性重写为微服务
✅ 正确：渐进式拆分

步骤：
1. 识别易拆分模块（边缘服务）
2. 先拆分 1-2 个服务
3. 验证、学习、优化
4. 逐步拆分核心服务
```

### 洞察 2：拆分是手段，不是目的

```
目的：解决问题
- 团队扩展
- 技术升级
- 性能瓶颈

手段：微服务
但微服务带来复杂度

权衡：
成本（复杂度）< 收益（解决问题）
```

### 洞察 3：拆分后要"守"

```
拆分后的挑战：
- 防止服务再次耦合
- 防止过度拆分
- 持续优化边界

需要：
- 架构守护（Code Review）
- 定期重构
- 团队培训
```

---

## 相关主题

- [09.2 服务间通信模式](./09.2_Inter_Service_Communication.md)
- [09.4 分布式数据管理](./09.4_Distributed_Data_Management.md)
- [09.7 电商微服务改造案例](./09.7_Case_Study_Ecommerce_Microservices.md)

---

**导航**：[返回云原生模式](./README.md) | [下一节：服务间通信 →](./09.2_Inter_Service_Communication.md)

