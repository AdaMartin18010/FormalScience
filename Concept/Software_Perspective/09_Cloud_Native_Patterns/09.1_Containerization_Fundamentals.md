# 9.1 容器化基础 | Containerization Fundamentals

> **文档版本**: v1.0.0
> **最后更新**: 2025-10-29
> **文档规模**: 容器化技术基础
> **阅读建议**: 本文系统介绍容器化技术的原理、实践和最佳实践

---

## 📋 目录

- [9.1 容器化基础 | Containerization Fundamentals](#91-容器化基础--containerization-fundamentals)
  - [📋 目录](#-目录)
  - [📊 核心概念深度分析](#-核心概念深度分析)
  - [1. 容器化概述](#1-容器化概述)
    - [1.1 什么是容器化](#11-什么是容器化)
    - [1.2 容器 vs 虚拟机](#12-容器-vs-虚拟机)
    - [1.3 容器化的价值](#13-容器化的价值)
  - [2. Docker 基础](#2-docker-基础)
    - [2.1 Docker 架构](#21-docker-架构)
    - [2.2 镜像与容器](#22-镜像与容器)
    - [2.3 Dockerfile 最佳实践](#23-dockerfile-最佳实践)
  - [3. 容器编排](#3-容器编排)
    - [3.1 为什么需要编排](#31-为什么需要编排)
    - [3.2 Kubernetes 核心概念](#32-kubernetes-核心概念)
    - [3.3 容器生命周期管理](#33-容器生命周期管理)
  - [4. 容器网络与存储](#4-容器网络与存储)
    - [4.1 容器网络模型](#41-容器网络模型)
    - [4.2 持久化存储](#42-持久化存储)
  - [5. 容器安全](#5-容器安全)
    - [5.1 镜像安全](#51-镜像安全)
    - [5.2 运行时安全](#52-运行时安全)
  - [6. 最佳实践](#6-最佳实践)
    - [镜像构建](#镜像构建)
    - [容器运行](#容器运行)
    - [安全](#安全)
    - [监控与日志](#监控与日志)
  - [参考文献](#参考文献)
  - [相关主题](#相关主题)
  - [导航](#导航)

---

## 📊 核心概念深度分析

<details>
<summary><b>🐳📦 点击展开：容器化核心洞察</b></summary>

**终极洞察**: 容器化=进程隔离+轻量虚拟化+不可变基础设施的完美结合。核心问题：如何实现应用的标准化打包与部署？容器通过Linux命名空间（Namespace）实现资源隔离，通过控制组（Cgroups）实现资源限制，通过联合文件系统（UnionFS）实现分层镜像。容器vs虚拟机：①启动速度：秒级vs分钟级②资源占用：MB级vs GB级③隔离程度：进程级vs系统级④性能开销：<5% vs 10-20%。容器化价值：①环境一致性："在我机器上能跑"→"在任何地方都能跑"②快速部署：镜像拉取+启动③资源高效：单机运行100+容器④微服务支撑：独立部署、弹性伸缩。Docker架构：Client-Server模型，镜像分层存储，容器运行时（containerd、runc）。Kubernetes编排：Pod（最小调度单元）、Service（服务发现）、Deployment（声明式部署）、StatefulSet（有状态应用）。安全考量：①镜像扫描（Trivy）②运行时限制（AppArmor、SELinux）③最小权限原则④secrets管理。最佳实践：①单进程容器②不可变基础设施③多阶段构建④健康检查⑤资源限制。容器化=云原生基础设施的基石。

</details>

---

## 1. 容器化概述

### 1.1 什么是容器化

**容器化**（Containerization）是一种操作系统级虚拟化技术，它将应用及其依赖打包在一个标准化的单元中，使应用能够在任何环境中一致地运行。

**核心技术**：

- **Linux Namespace**：进程、网络、文件系统隔离
- **Cgroups**：CPU、内存、I/O资源限制
- **UnionFS**：分层文件系统，支持镜像复用

### 1.2 容器 vs 虚拟机

| 维度 | 容器 | 虚拟机 |
|------|------|--------|
| **隔离级别** | 进程级 | 系统级 |
| **启动时间** | 秒级 | 分钟级 |
| **资源占用** | MB级 | GB级 |
| **性能开销** | <5% | 10-20% |
| **密度** | 100+/主机 | 10-20/主机 |
| **移植性** | 高 | 中 |

### 1.3 容器化的价值

1. **环境一致性**："在我机器上能跑" → "在任何地方都能跑"
2. **快速部署**：镜像拉取 + 容器启动（秒级）
3. **资源高效**：共享主机内核，密度高
4. **微服务支撑**：独立部署、弹性伸缩
5. **DevOps加速**：CI/CD流水线标准化

---

## 2. Docker 基础

### 2.1 Docker 架构

```
┌─────────────────────────────────────────┐
│           Docker Client                 │
│  docker build / run / push / pull       │
└──────────────┬──────────────────────────┘
               │ REST API
┌──────────────▼──────────────────────────┐
│           Docker Daemon                 │
│  ├─ Image Management                    │
│  ├─ Container Runtime                   │
│  └─ Network & Volume Management         │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│      Container Runtime (containerd)     │
│  ├─ runc (OCI Runtime)                  │
│  └─ Image Store                         │
└─────────────────────────────────────────┘
```

### 2.2 镜像与容器

**镜像（Image）**：

- 只读模板，包含应用代码、运行时、库、环境变量
- 分层存储：每层只记录差异，节省空间
- 通过Dockerfile构建，可版本化管理

**容器（Container）**：

- 镜像的运行实例
- 可写层（Container Layer）+ 只读镜像层
- 隔离的进程空间

### 2.3 Dockerfile 最佳实践

```dockerfile
# 多阶段构建
FROM golang:1.21 AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o myapp

# 最小化运行镜像
FROM alpine:3.18
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/myapp .
EXPOSE 8080
USER nobody
CMD ["./myapp"]
```

**最佳实践**：

1. ✅ 多阶段构建减小镜像体积
2. ✅ 使用官方基础镜像
3. ✅ 合并RUN命令减少层数
4. ✅ .dockerignore排除不必要文件
5. ✅ 非root用户运行
6. ✅ 明确指定版本标签

---

## 3. 容器编排

### 3.1 为什么需要编排

单机Docker → 生产环境挑战：

- 多容器管理：如何调度100+容器？
- 高可用：容器崩溃如何自动重启？
- 负载均衡：流量如何分发？
- 滚动更新：如何零停机升级？
- 服务发现：容器IP动态变化如何通信？

**容器编排解决方案**：Kubernetes、Docker Swarm、Nomad

### 3.2 Kubernetes 核心概念

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:v1.0
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 5
```

**核心对象**：

- **Pod**：最小调度单元，包含1个或多个容器
- **Deployment**：声明式部署，自动管理副本数
- **Service**：服务发现和负载均衡
- **ConfigMap/Secret**：配置和密钥管理
- **StatefulSet**：有状态应用（数据库、消息队列）
- **Ingress**：HTTP/HTTPS路由

### 3.3 容器生命周期管理

**健康检查**：

```yaml
livenessProbe:   # 存活探针：失败则重启容器
  httpGet:
    path: /health
    port: 8080
  initialDelaySeconds: 10
  periodSeconds: 5

readinessProbe:  # 就绪探针：失败则移出Service
  httpGet:
    path: /ready
    port: 8080
  initialDelaySeconds: 5
  periodSeconds: 3
```

**资源管理**：

- **requests**：调度保证，预留资源
- **limits**：硬限制，防止资源耗尽

---

## 4. 容器网络与存储

### 4.1 容器网络模型

**Docker网络模式**：

- **bridge**：默认，NAT模式，容器间通信
- **host**：使用主机网络栈，性能最优
- **none**：无网络，用于安全隔离
- **overlay**：跨主机容器通信（Swarm、Kubernetes）

**Kubernetes网络**：

- Pod-to-Pod通信：扁平网络，无NAT
- Pod-to-Service通信：通过Service ClusterIP
- External-to-Service：通过NodePort、LoadBalancer或Ingress

### 4.2 持久化存储

**Volume类型**：

- **emptyDir**：临时存储，Pod删除即清除
- **hostPath**：挂载主机目录（开发环境）
- **persistentVolume**：持久化存储（生产环境）
- **configMap/secret**：配置文件和密钥

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: ssd
```

---

## 5. 容器安全

### 5.1 镜像安全

**安全扫描**：

```bash
# Trivy扫描镜像漏洞
trivy image myapp:latest

# 扫描结果
CVE-2023-1234 (HIGH): OpenSSL vulnerability
Fix: Upgrade to openssl 3.0.9
```

**最佳实践**：

1. ✅ 使用官方基础镜像
2. ✅ 定期更新基础镜像
3. ✅ 多阶段构建，最小化攻击面
4. ✅ 签名和验证镜像（Docker Content Trust）
5. ✅ 私有镜像仓库

### 5.2 运行时安全

**安全上下文**：

```yaml
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  readOnlyRootFilesystem: true
  capabilities:
    drop:
      - ALL
    add:
      - NET_BIND_SERVICE
```

**安全策略**：

- **Pod Security Policy**：限制Pod权限（已废弃）
- **Pod Security Standards**：新标准（Restricted、Baseline、Privileged）
- **Network Policy**：网络隔离，限制Pod间通信
- **AppArmor/SELinux**：强制访问控制

---

## 6. 最佳实践

### 镜像构建

1. ✅ 多阶段构建减小体积
2. ✅ 使用.dockerignore
3. ✅ 合并RUN命令
4. ✅ 固定版本标签
5. ✅ 非root用户运行

### 容器运行

1. ✅ 设置资源limits和requests
2. ✅ 配置健康检查
3. ✅ 单进程容器
4. ✅ 12-Factor App原则
5. ✅ 日志输出到stdout/stderr

### 安全

1. ✅ 定期扫描漏洞
2. ✅ 最小权限原则
3. ✅ Secrets管理（不写入镜像）
4. ✅ 网络隔离
5. ✅ 只读文件系统

### 监控与日志

1. ✅ Prometheus + Grafana监控
2. ✅ ELK/Loki日志聚合
3. ✅ Distributed tracing（Jaeger）
4. ✅ 健康检查和自动恢复

---

## 参考文献

1. Docker官方文档. [Docker Overview](https://docs.docker.com/get-started/overview/)
2. Kubernetes官方文档. [Kubernetes Concepts](https://kubernetes.io/docs/concepts/)
3. CNCF. [云原生定义](https://www.cncf.io/about/who-we-are/)
4. Brendan Burns等. _Kubernetes: Up and Running_, O'Reilly, 2022
5. Docker安全最佳实践. [Docker Security](https://docs.docker.com/engine/security/)
6. OCI (Open Container Initiative). [容器标准](https://opencontainers.org/)

---

## 相关主题

**本章相关**：

- [9.3 服务网格](./09.3_Service_Mesh.md) - 服务间通信
- [9.8 案例研究：秒杀系统](./09.8_Case_Study_Flash_Sale_System.md) - 实战案例

**跨章节**：

- [5.1 配置管理全景](../05_Configuration_Scaling/05.1_Configuration_Management_Landscape.md)
- [4.1 自愈架构](../04_Self_Healing_Systems/04.1_Self_Healing_Architecture.md)
- [8.3 内部开发者平台](../08_Platform_Engineering/08.3_Internal_Developer_Platform.md)

**其他视角**：

- [Information Theory: 系统可靠性](../../Information_Theory_Perspective/)
- [Formal Language: 容器编排形式化](../../FormalLanguage_Perspective/)

---

## 导航

**上一章**: [9. 云原生模式 README](./README.md)
**下一章**: [9.3 服务网格](./09.3_Service_Mesh.md)
**返回目录**: [Software Perspective 总目录](../README.md)
