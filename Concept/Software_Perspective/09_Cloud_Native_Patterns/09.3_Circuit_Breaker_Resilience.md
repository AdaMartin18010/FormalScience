# 9.3 断路器与弹性设计

## 核心问题

> 当下游服务故障时，如何防止级联失败？如何快速失败并优雅降级？

## 断路器模式（Circuit Breaker）

### 核心概念

**电路类比**：
```
电路中的保险丝：
- 电流过大 → 保险丝熔断
- 保护整个电路不被烧毁

软件中的断路器：
- 请求失败率过高 → 断路器打开
- 保护系统不被拖垮
```

### 三种状态

```
                 失败率 < 阈值
          ┌─────────────────────┐
          │                     │
          ↓                     │
    ┌──────────┐          ┌──────────┐
    │  Closed  │─────────→│   Open   │
    │  (正常)  │失败率>阈值│  (断开)   │
    └──────────┘          └──────────┘
          ↑                     │
          │                     │ 超时后
          │                     ↓
          │              ┌──────────────┐
          └──────────────│ Half-Open    │
           测试请求成功   │  (半开)      │
                         └──────────────┘
```

**状态说明**：

| 状态 | 行为 | 转换条件 |
|-----|------|---------|
| **Closed**（闭合） | 正常请求通过 | 失败率 > 阈值 → Open |
| **Open**（打开） | 直接返回错误，不调用下游 | 超时后 → Half-Open |
| **Half-Open**（半开） | 允许少量测试请求 | 成功 → Closed；失败 → Open |

---

## 实现方案

### 基础实现（Java）

```java
public class CircuitBreaker {
    private enum State {
        CLOSED, OPEN, HALF_OPEN
    }
    
    private State state = State.CLOSED;
    private int failureCount = 0;
    private int successCount = 0;
    private long openTimestamp = 0;
    
    // 配置参数
    private final int failureThreshold = 5;      // 失败阈值
    private final int successThreshold = 2;      // 成功阈值（半开→闭合）
    private final long timeout = 60000;          // 超时时间（毫秒）
    
    public <T> T call(Supplier<T> supplier) throws Exception {
        if (state == State.OPEN) {
            // 检查是否超时
            if (System.currentTimeMillis() - openTimestamp > timeout) {
                state = State.HALF_OPEN;
                successCount = 0;
            } else {
                throw new CircuitBreakerOpenException("Circuit breaker is OPEN");
            }
        }
        
        try {
            T result = supplier.get();
            onSuccess();
            return result;
        } catch (Exception e) {
            onFailure();
            throw e;
        }
    }
    
    private void onSuccess() {
        failureCount = 0;
        
        if (state == State.HALF_OPEN) {
            successCount++;
            if (successCount >= successThreshold) {
                state = State.CLOSED;
            }
        }
    }
    
    private void onFailure() {
        failureCount++;
        successCount = 0;
        
        if (failureCount >= failureThreshold) {
            state = State.OPEN;
            openTimestamp = System.currentTimeMillis();
        }
    }
}
```

**使用示例**：

```java
CircuitBreaker breaker = new CircuitBreaker();

try {
    User user = breaker.call(() -> {
        return userService.getUser(userId);  // 可能失败的调用
    });
} catch (CircuitBreakerOpenException e) {
    // 断路器打开，返回降级数据
    return getCachedUser(userId);
} catch (Exception e) {
    // 其他异常处理
    log.error("Failed to get user", e);
    return getDefaultUser();
}
```

### Resilience4j 实现（推荐）

**Maven 依赖**：
```xml
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot2</artifactId>
    <version>2.1.0</version>
</dependency>
```

**配置**：
```yaml
resilience4j:
  circuitbreaker:
    instances:
      userService:
        registerHealthIndicator: true
        slidingWindowSize: 10                    # 滑动窗口大小
        minimumNumberOfCalls: 5                  # 最小调用次数
        permittedNumberOfCallsInHalfOpenState: 3 # 半开状态测试次数
        automaticTransitionFromOpenToHalfOpenEnabled: true
        waitDurationInOpenState: 60s             # 打开状态持续时间
        failureRateThreshold: 50                 # 失败率阈值（%）
        eventConsumerBufferSize: 10
        recordExceptions:                        # 记录为失败的异常
          - java.io.IOException
          - java.util.concurrent.TimeoutException
        ignoreExceptions:                        # 忽略的异常
          - com.myapp.BusinessException
```

**代码使用**：
```java
@Service
public class UserService {
    @Autowired
    private RestTemplate restTemplate;
    
    @CircuitBreaker(name = "userService", fallbackMethod = "getUserFallback")
    public User getUser(Long userId) {
        return restTemplate.getForObject(
            "http://user-service/users/" + userId,
            User.class
        );
    }
    
    // 降级方法
    private User getUserFallback(Long userId, Exception e) {
        log.warn("User service is down, returning cached data", e);
        return cache.get("user_" + userId);
    }
}
```

---

## 降级策略

### 1. 返回缓存数据

```java
@Service
public class ProductService {
    @Autowired
    private RedisTemplate<String, Product> redis;
    
    @CircuitBreaker(name = "productService", fallbackMethod = "getProductFromCache")
    public Product getProduct(Long productId) {
        return restTemplate.getForObject(
            "http://product-service/products/" + productId,
            Product.class
        );
    }
    
    private Product getProductFromCache(Long productId, Exception e) {
        Product cached = redis.opsForValue().get("product_" + productId);
        
        if (cached != null) {
            cached.setFromCache(true);  // 标记数据来源
            return cached;
        }
        
        // 缓存也没有，返回默认数据
        return Product.builder()
            .id(productId)
            .name("商品暂时不可用")
            .available(false)
            .build();
    }
}
```

### 2. 返回默认值

```java
@Service
public class RecommendationService {
    @CircuitBreaker(name = "recommendationService", 
                   fallbackMethod = "getDefaultRecommendations")
    public List<Product> getRecommendations(Long userId) {
        return restTemplate.getForObject(
            "http://recommendation-service/recommendations/" + userId,
            List.class
        );
    }
    
    private List<Product> getDefaultRecommendations(Long userId, Exception e) {
        // 返回热门商品作为默认推荐
        return productService.getHotProducts(10);
    }
}
```

### 3. 返回空结果（非核心功能）

```java
@Service
public class CommentService {
    @CircuitBreaker(name = "commentService", fallbackMethod = "getEmptyComments")
    public List<Comment> getComments(Long productId) {
        return restTemplate.getForObject(
            "http://comment-service/comments/" + productId,
            List.class
        );
    }
    
    private List<Comment> getEmptyComments(Long productId, Exception e) {
        // 评论是非核心功能，返回空列表
        log.warn("Comment service is down, returning empty list");
        return Collections.emptyList();
    }
}
```

### 4. 快速失败（核心功能）

```java
@Service
public class PaymentService {
    @CircuitBreaker(name = "paymentService", fallbackMethod = "paymentFallback")
    public PaymentResult processPayment(PaymentRequest request) {
        return restTemplate.postForObject(
            "http://payment-service/payments",
            request,
            PaymentResult.class
        );
    }
    
    private PaymentResult paymentFallback(PaymentRequest request, Exception e) {
        // 支付是核心功能，不能降级，直接失败
        log.error("Payment service is down", e);
        throw new PaymentUnavailableException(
            "支付服务暂时不可用，请稍后重试"
        );
    }
}
```

---

## 舱壁隔离模式（Bulkhead）

### 概念

**船舶舱壁**：
```
船舱被分隔成多个独立舱室
一个舱室进水 → 其他舱室不受影响
```

**软件隔离**：
```
线程池隔离：
- 不同服务使用不同线程池
- 一个服务慢 → 不影响其他服务
```

### 实现（Resilience4j）

**配置**：
```yaml
resilience4j:
  bulkhead:
    instances:
      userService:
        maxConcurrentCalls: 10        # 最大并发数
        maxWaitDuration: 100ms         # 最大等待时间
      
      orderService:
        maxConcurrentCalls: 20
        maxWaitDuration: 200ms
```

**代码**：
```java
@Service
public class UserService {
    @Bulkhead(name = "userService", fallbackMethod = "getUserBulkheadFallback")
    public User getUser(Long userId) {
        return restTemplate.getForObject(
            "http://user-service/users/" + userId,
            User.class
        );
    }
    
    private User getUserBulkheadFallback(Long userId, BulkheadFullException e) {
        log.warn("User service bulkhead is full");
        throw new ServiceUnavailableException("系统繁忙，请稍后重试");
    }
}
```

**效果**：
```
场景：User Service 慢查询导致线程池耗尽

Without Bulkhead:
- User Service 占用所有线程（100个）
- Order Service 也无法调用（无可用线程）
- 整个系统瘫痪

With Bulkhead:
- User Service 只占用 10 个线程
- Order Service 仍有 20 个线程可用
- 部分功能可用
```

---

## 限流模式（Rate Limiting）

### 令牌桶算法（Token Bucket）

**原理**：
```
┌─────────────────┐
│  Token Bucket   │  容量：10个令牌
│  ┌──┬──┬──┬──┐ │
│  │●│●│●│●│ ... │  每秒填充：5个令牌
│  └──┴──┴──┴──┘ │
└────────┬────────┘
         │
    请求到达 → 取出1个令牌 → 处理请求
         │
    令牌不足 → 拒绝请求
```

**实现（Resilience4j）**：
```yaml
resilience4j:
  ratelimiter:
    instances:
      userService:
        limitForPeriod: 10           # 时间窗口内的请求数
        limitRefreshPeriod: 1s       # 时间窗口
        timeoutDuration: 0ms         # 等待时间（0=立即失败）
```

```java
@Service
public class UserService {
    @RateLimiter(name = "userService", fallbackMethod = "rateLimitFallback")
    public User getUser(Long userId) {
        return restTemplate.getForObject(
            "http://user-service/users/" + userId,
            User.class
        );
    }
    
    private User rateLimitFallback(Long userId, RequestNotPermitted e) {
        log.warn("Rate limit exceeded for user service");
        throw new TooManyRequestsException("请求过于频繁，请稍后重试");
    }
}
```

### 漏桶算法（Leaky Bucket）

**原理**：
```
         请求
          ↓
    ┌──────────┐
    │   Bucket │  容量固定
    │   ████   │
    │   ████   │
    └────┬─────┘
         │ 匀速流出
         ↓
      处理请求
```

**特点**：
- 输出速率恒定
- 平滑流量
- 适合需要恒定速率的场景

### 分布式限流（Redis）

```java
@Service
public class RateLimiterService {
    @Autowired
    private RedisTemplate<String, String> redis;
    
    public boolean isAllowed(String key, int limit, int window) {
        String redisKey = "rate_limit:" + key;
        long current = System.currentTimeMillis();
        long windowStart = current - window * 1000;
        
        // 使用 Lua 脚本保证原子性
        String script = 
            "local current = tonumber(ARGV[1]) " +
            "local window_start = tonumber(ARGV[2]) " +
            "local limit = tonumber(ARGV[3]) " +
            
            "redis.call('zremrangebyscore', KEYS[1], 0, window_start) " +
            "local count = redis.call('zcard', KEYS[1]) " +
            
            "if count < limit then " +
            "  redis.call('zadd', KEYS[1], current, current) " +
            "  redis.call('expire', KEYS[1], ARGV[4]) " +
            "  return 1 " +
            "else " +
            "  return 0 " +
            "end";
        
        Long result = redis.execute(
            new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(redisKey),
            String.valueOf(current),
            String.valueOf(windowStart),
            String.valueOf(limit),
            String.valueOf(window + 1)
        );
        
        return result != null && result == 1;
    }
}
```

---

## 重试模式（Retry）

### 指数退避（Exponential Backoff）

**策略**：
```
失败后重试，每次等待时间指数增长

第1次失败 → 等待 1 秒 → 重试
第2次失败 → 等待 2 秒 → 重试
第3次失败 → 等待 4 秒 → 重试
第4次失败 → 等待 8 秒 → 重试
...
最多重试 5 次
```

**实现（Resilience4j）**：
```yaml
resilience4j:
  retry:
    instances:
      userService:
        maxAttempts: 3                          # 最大重试次数
        waitDuration: 1000ms                    # 初始等待时间
        enableExponentialBackoff: true          # 启用指数退避
        exponentialBackoffMultiplier: 2         # 乘数
        retryExceptions:                        # 重试的异常
          - java.io.IOException
          - java.util.concurrent.TimeoutException
        ignoreExceptions:                       # 不重试的异常
          - com.myapp.BusinessException
```

```java
@Service
public class UserService {
    @Retry(name = "userService", fallbackMethod = "getUserRetryFallback")
    public User getUser(Long userId) {
        log.info("Calling user service for user {}", userId);
        return restTemplate.getForObject(
            "http://user-service/users/" + userId,
            User.class
        );
    }
    
    private User getUserRetryFallback(Long userId, Exception e) {
        log.error("Failed after retries", e);
        return getCachedUser(userId);
    }
}
```

### 抖动（Jitter）

**问题**：所有客户端同时重试 → 雪崩

**解决**：加入随机性

```java
public class RetryWithJitter {
    private Random random = new Random();
    
    public void retryWithJitter(Runnable task, int maxRetries) {
        int retries = 0;
        
        while (retries < maxRetries) {
            try {
                task.run();
                return;  // 成功
            } catch (Exception e) {
                retries++;
                
                if (retries >= maxRetries) {
                    throw e;
                }
                
                // 指数退避 + 抖动
                long baseDelay = (long) Math.pow(2, retries) * 1000;
                long jitter = random.nextInt(1000);
                long delay = baseDelay + jitter;
                
                try {
                    Thread.sleep(delay);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException(ie);
                }
            }
        }
    }
}
```

---

## 超时模式（Timeout）

### 设置合理的超时

```java
@Service
public class UserService {
    @Autowired
    private RestTemplate restTemplate;
    
    @TimeLimiter(name = "userService", fallbackMethod = "getUserTimeout")
    public CompletableFuture<User> getUserAsync(Long userId) {
        return CompletableFuture.supplyAsync(() ->
            restTemplate.getForObject(
                "http://user-service/users/" + userId,
                User.class
            )
        );
    }
    
    private CompletableFuture<User> getUserTimeout(Long userId, TimeoutException e) {
        log.warn("User service timeout");
        return CompletableFuture.completedFuture(getCachedUser(userId));
    }
}
```

**配置**：
```yaml
resilience4j:
  timelimiter:
    instances:
      userService:
        timeoutDuration: 3s           # 超时时间
        cancelRunningFuture: true     # 取消正在运行的任务
```

### 超时传播

```
Client → Service A (3s timeout)
             ↓
         Service B (2s timeout)
             ↓
         Service C (1s timeout)

建议：逐层递减，留出处理时间
```

---

## 组合使用

### 完整弹性栈

```java
@Service
public class UserService {
    // 组合多种模式
    @CircuitBreaker(name = "userService")
    @RateLimiter(name = "userService")
    @Retry(name = "userService")
    @Bulkhead(name = "userService")
    @TimeLimiter(name = "userService")
    public CompletableFuture<User> getUser(Long userId) {
        return CompletableFuture.supplyAsync(() ->
            restTemplate.getForObject(
                "http://user-service/users/" + userId,
                User.class
            )
        );
    }
}
```

**执行顺序**：
```
Request
  ↓
RateLimiter（限流）
  ↓
CircuitBreaker（断路器）
  ↓
Bulkhead（隔离）
  ↓
TimeLimiter（超时）
  ↓
Retry（重试）
  ↓
实际调用
```

---

## 监控与告警

### 关键指标

```yaml
断路器状态：
- circuit_breaker.state (0=Closed, 1=Open, 2=Half-Open)
- circuit_breaker.failure_rate
- circuit_breaker.slow_call_rate

调用统计：
- resilience4j.calls.total
- resilience4j.calls.successful
- resilience4j.calls.failed
- resilience4j.calls.duration

限流统计：
- resilience4j.ratelimiter.available_permissions
- resilience4j.ratelimiter.waiting_threads
```

### Grafana 仪表盘

```promql
# 断路器打开次数
increase(resilience4j_circuitbreaker_state{state="open"}[5m])

# 失败率
rate(resilience4j_circuitbreaker_calls_total{kind="failed"}[5m]) /
rate(resilience4j_circuitbreaker_calls_total[5m])

# 限流拒绝率
rate(resilience4j_ratelimiter_calls_total{kind="failed"}[5m]) /
rate(resilience4j_ratelimiter_calls_total[5m])
```

---

## 关键洞察

### 洞察 1：快速失败 > 慢失败

```
慢失败（无断路器）：
- 请求超时：30秒
- 用户体验：等待 30 秒后失败
- 系统资源：线程被占用 30 秒

快速失败（有断路器）：
- 断路器打开：立即返回
- 用户体验：瞬间失败（可降级）
- 系统资源：不占用资源
```

### 洞察 2：降级 > 失败

```
无降级：
服务不可用 → 返回 500 错误 → 用户看到报错

有降级：
服务不可用 → 返回缓存数据 → 用户体验降低但可用
```

### 洞察 3：隔离 > 共享

```
共享线程池：
一个服务慢 → 占满线程池 → 所有服务受影响

隔离线程池：
一个服务慢 → 只占用自己的线程池 → 其他服务正常
```

---

## 相关主题

- [09.1 微服务拆分策略](./09.1_Microservices_Decomposition.md)
- [09.2 服务间通信模式](./09.2_Inter_Service_Communication.md)
- [09.8 秒杀系统案例](./09.8_Case_Study_Flash_Sale_System.md)

---

**导航**：[返回云原生模式](./README.md) | [← 上一节：服务间通信](./09.2_Inter_Service_Communication.md) | [下一节：分布式数据管理 →](./09.4_Distributed_Data_Management.md)

