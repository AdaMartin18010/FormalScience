# 4.4 GitOps 声明式修复

> **文档版本**: v1.0.0  
> **最后更新**: 2025-10-27  
> **文档规模**: 839行 | GitOps与声明式运维  
> **阅读建议**: 本文详解GitOps工作流和Argo CD，是实现基础设施即代码的实战指南

---

## 核心定义

**GitOps**：使用 Git 作为**单一事实来源（Single Source of Truth）**，通过声明式配置和自动同步实现基础设施和应用的管理。

**声明式修复（Declarative Remediation）**：系统自动检测实际状态与期望状态的偏差，并自动修复，无需手动干预。

## 为什么需要 GitOps？

### 传统部署的问题

```
命令式部署：
1. SSH 到服务器
2. 执行命令：kubectl apply -f deployment.yaml
3. 手动验证
4. 记录到文档

问题：
❌ 无版本历史（不知道谁改了什么）
❌ 无法回滚（不知道之前是什么状态）
❌ 难以审计（无法追溯）
❌ 环境不一致（dev/staging/prod 配置各异）
❌ 无法自动修复（需要人工介入）
```

### GitOps 解决方案

```
声明式配置 + Git：
1. 所有配置存在 Git 仓库
2. 修改 = Pull Request
3. 合并 = 自动部署
4. 偏差 = 自动修复

优点：
✅ 完整历史（Git log）
✅ 轻松回滚（Git revert）
✅ 自动审计（PR + Merge）
✅ 环境一致（所有环境用同一套配置，仅参数不同）
✅ 自动修复（持续同步）
```

---

## GitOps 架构

### 核心组件

```
┌────────────────────────────────────────────────┐
│  Git Repository (Single Source of Truth)      │
│  ├── manifests/                               │
│  │   ├── deployment.yaml                      │
│  │   ├── service.yaml                         │
│  │   └── configmap.yaml                       │
│  └── kustomize/                               │
│      ├── base/                                │
│      └── overlays/                            │
│          ├── dev/                             │
│          ├── staging/                         │
│          └── prod/                            │
└────────────────────────────────────────────────┘
                 ↑       │
         Pull    │       │ Webhook (optional)
                 │       ↓
┌────────────────────────────────────────────────┐
│  GitOps Operator (ArgoCD / Flux)              │
│  ┌──────────────────────────────────────────┐ │
│  │  1. 定期 Pull Git 仓库 (every 3 min)     │ │
│  │  2. 对比期望状态 vs 实际状态             │ │
│  │  3. 检测到偏差 → 自动同步               │ │
│  │  4. 验证同步成功                         │ │
│  └──────────────────────────────────────────┘ │
└────────────────────────────────────────────────┘
                 ↓
┌────────────────────────────────────────────────┐
│  Kubernetes Cluster                            │
│  - Deployment (3 replicas)                    │
│  - Service (ClusterIP)                        │
│  - ConfigMap (app config)                     │
└────────────────────────────────────────────────┘
```

---

## ArgoCD 深度解析

### 安装

```bash
# 创建命名空间
kubectl create namespace argocd

# 安装 ArgoCD
kubectl apply -n argocd -f \
  https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

# 暴露 UI
kubectl port-forward svc/argocd-server -n argocd 8080:443

# 获取初始密码
argocd admin initial-password -n argocd
```

### 创建 Application

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: my-app
  namespace: argocd
spec:
  # Git 仓库
  source:
    repoURL: https://github.com/myorg/myapp-config.git
    targetRevision: main
    path: manifests/prod
    
    # Kustomize 配置（可选）
    kustomize:
      images:
      - myapp:v1.2.0
  
  # 目标集群
  destination:
    server: https://kubernetes.default.svc
    namespace: production
  
  # 同步策略
  syncPolicy:
    automated:
      prune: true        # 删除 Git 中不存在的资源
      selfHeal: true     # 自动修复偏差
      allowEmpty: false  # 不允许空部署
    
    syncOptions:
    - CreateNamespace=true  # 自动创建命名空间
    - PruneLast=true        # 最后删除资源
    
    retry:
      limit: 5
      backoff:
        duration: 5s
        factor: 2
        maxDuration: 3m
```

### 自动修复演示

**场景**：人工修改了副本数

```bash
# Git 中的配置：replicas: 3
cat manifests/prod/deployment.yaml
---
spec:
  replicas: 3

# 人工修改（模拟手动扩容或故障）
kubectl scale deployment my-app --replicas=5

# 30 秒后，ArgoCD 检测到偏差
kubectl get deployment my-app
NAME     READY   UP-TO-DATE   AVAILABLE
my-app   5/3     3            5          # 检测到 5 个，期望 3 个

# 又过 30 秒，ArgoCD 自动修复
kubectl get deployment my-app
NAME     READY   UP-TO-DATE   AVAILABLE
my-app   3/3     3            3          # 恢复到 3 个
```

**ArgoCD 日志**：
```
2025-10-27 10:23:45  INFO  Detected drift: deployment.apps/my-app replicas 5 != 3
2025-10-27 10:24:15  INFO  Auto-healing: syncing application my-app
2025-10-27 10:24:16  INFO  Sync successful: deployment.apps/my-app scaled to 3
```

---

## 声明式修复策略

### 策略 1：基于 Git 提交的回滚

**自动回滚流程**：

```yaml
# ArgoCD Application with Auto-Rollback
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: my-app
spec:
  source:
    repoURL: https://github.com/myorg/myapp-config.git
    targetRevision: main  # 始终跟踪 main 分支
  
  syncPolicy:
    automated:
      selfHeal: true
    
    # 失败时自动回滚
    syncOptions:
    - RollbackOnFailure=true
```

**Git 提交触发回滚**：

```bash
# 部署新版本（有 bug）
git commit -m "Deploy v1.2.0"
git push

# ArgoCD 自动同步，但发现健康检查失败
# ArgoCD 自动创建回滚 commit

git log
commit abc123 (HEAD -> main)
Author: ArgoCD <argocd@system>
Date:   2025-10-27 10:25:00
    Auto-rollback: revert to v1.1.0 due to health check failure

commit def456
Author: Developer <dev@company.com>
Date:   2025-10-27 10:20:00
    Deploy v1.2.0
```

### 策略 2：基于 Metric 的自动回滚

**集成 Prometheus + ArgoCD**：

```yaml
# AnalysisTemplate（ArgoCD Rollouts）
apiVersion: argoproj.io/v1alpha1
kind: AnalysisTemplate
metadata:
  name: error-rate-check
spec:
  metrics:
  - name: error-rate
    interval: 1m
    successCondition: result < 0.05  # 错误率 < 5%
    failureLimit: 3  # 连续失败 3 次则回滚
    provider:
      prometheus:
        address: http://prometheus:9090
        query: |
          rate(http_requests_total{status=~"5.."}[5m]) /
          rate(http_requests_total[5m])
```

**Rollout 配置**：

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: my-app
spec:
  replicas: 10
  strategy:
    canary:
      steps:
      - setWeight: 20  # 20% 流量到新版本
      - pause: {duration: 5m}  # 观察 5 分钟
      - analysis:
          templates:
          - templateName: error-rate-check  # 检查错误率
      - setWeight: 50  # 通过检查 → 50% 流量
      - pause: {duration: 5m}
      - analysis:
          templates:
          - templateName: error-rate-check
      - setWeight: 100  # 完全切换
```

**执行效果**：

```
10:00  部署 v1.2.0，20% 流量
10:01  Prometheus 检测到错误率 8% > 5%
10:02  AnalysisRun 失败
10:03  自动回滚到 v1.1.0
10:04  流量 100% 恢复到 v1.1.0
10:05  提交 Git commit: "Auto-rollback to v1.1.0"
10:06  通知 Slack: "v1.2.0 自动回滚，原因：错误率过高"
```

### 策略 3：基于 OTLP 的智能修复

**完整闭环**：

```
1. OTLP 采集指标
   ↓
2. Prometheus 触发告警
   ↓
3. OPA 策略判断：allow_rollback = true
   ↓
4. PR Controller 修改 Git 配置
   ↓
5. ArgoCD 检测到 Git 变化
   ↓
6. ArgoCD 自动同步回滚
   ↓
7. 验证修复效果
```

**Git Commit 自动化**：

```go
// PR Controller（Go）
func handleRollback(service string, targetVersion string) error {
    // 1. Clone Git 仓库
    repo, err := git.PlainClone("/tmp/config", false, &git.CloneOptions{
        URL: "https://github.com/myorg/config.git",
    })
    
    // 2. 修改配置
    manifestPath := fmt.Sprintf("manifests/%s/kustomization.yaml", service)
    content, _ := ioutil.ReadFile(manifestPath)
    
    // 修改镜像版本
    newContent := strings.ReplaceAll(
        string(content),
        "myapp:v1.2.0",
        fmt.Sprintf("myapp:%s", targetVersion),
    )
    ioutil.WriteFile(manifestPath, []byte(newContent), 0644)
    
    // 3. Commit
    w, _ := repo.Worktree()
    w.Add(manifestPath)
    w.Commit(fmt.Sprintf("Auto-rollback %s to %s", service, targetVersion), &git.CommitOptions{
        Author: &object.Signature{
            Name:  "SelfHeal Bot",
            Email: "bot@company.com",
            When:  time.Now(),
        },
    })
    
    // 4. Push
    err = repo.Push(&git.PushOptions{
        Auth: &http.BasicAuth{
            Username: "github-token",
            Password: os.Getenv("GITHUB_TOKEN"),
        },
    })
    
    return err
}
```

---

## Kustomize 多环境管理

### 目录结构

```
config/
├── base/
│   ├── kustomization.yaml
│   ├── deployment.yaml
│   ├── service.yaml
│   └── configmap.yaml
└── overlays/
    ├── dev/
    │   ├── kustomization.yaml
    │   ├── replica-patch.yaml
    │   └── config-patch.yaml
    ├── staging/
    │   ├── kustomization.yaml
    │   └── ...
    └── prod/
        ├── kustomization.yaml
        └── ...
```

### Base 配置

```yaml
# base/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
- deployment.yaml
- service.yaml
- configmap.yaml

commonLabels:
  app: myapp
  managed-by: kustomize
```

```yaml
# base/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
spec:
  replicas: 1  # 默认值，会被 overlay 覆盖
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:latest
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 200m
            memory: 256Mi
```

### Overlay 配置

```yaml
# overlays/prod/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

bases:
- ../../base

namespace: production

commonLabels:
  environment: prod

# 镜像版本
images:
- name: myapp
  newName: registry.company.com/myapp
  newTag: v1.2.0

# 副本数
replicas:
- name: myapp
  count: 10

# 资源配额
patches:
- patch: |-
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: myapp
    spec:
      template:
        spec:
          containers:
          - name: myapp
            resources:
              requests:
                cpu: 500m
                memory: 1Gi
              limits:
                cpu: 1000m
                memory: 2Gi

# ConfigMap 覆盖
configMapGenerator:
- name: myapp-config
  behavior: merge
  literals:
  - LOG_LEVEL=info
  - MAX_CONNECTIONS=1000
```

**生成最终配置**：

```bash
kubectl kustomize overlays/prod

# 输出（合并后的配置）
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  namespace: production
  labels:
    app: myapp
    managed-by: kustomize
    environment: prod
spec:
  replicas: 10  # 来自 overlay
  template:
    spec:
      containers:
      - name: myapp
        image: registry.company.com/myapp:v1.2.0  # 来自 overlay
        resources:
          requests:
            cpu: 500m      # 来自 overlay
            memory: 1Gi    # 来自 overlay
          limits:
            cpu: 1000m     # 来自 overlay
            memory: 2Gi    # 来自 overlay
```

---

## 金丝雀发布 + GitOps

**ArgoCD Rollouts 配置**：

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Rollout
metadata:
  name: myapp
spec:
  replicas: 10
  revisionHistoryLimit: 3
  
  selector:
    matchLabels:
      app: myapp
  
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: myapp
        image: myapp:v1.2.0
  
  strategy:
    canary:
      # 金丝雀服务
      canaryService: myapp-canary
      stableService: myapp-stable
      
      # 流量管理（Istio/Nginx）
      trafficRouting:
        istio:
          virtualService:
            name: myapp-vsvc
            routes:
            - primary
      
      # 发布步骤
      steps:
      - setWeight: 10  # 10% 流量到金丝雀
      - pause: {duration: 2m}
      
      - setWeight: 20
      - pause: {duration: 2m}
      
      - setWeight: 50
      - pause: {duration: 5m}
      
      # 分析
      - analysis:
          templates:
          - templateName: success-rate
          args:
          - name: service-name
            value: myapp-canary
      
      - setWeight: 100  # 完全切换
```

**流量切分（Istio VirtualService）**：

```yaml
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: myapp-vsvc
spec:
  hosts:
  - myapp
  http:
  - name: primary
    route:
    - destination:
        host: myapp-stable
        subset: stable
      weight: 90  # 90% 流量到稳定版本
    - destination:
        host: myapp-canary
        subset: canary
      weight: 10  # 10% 流量到金丝雀
```

**自动回滚示例**：

```bash
# 部署 v1.2.0
git commit -m "Deploy v1.2.0" && git push

# ArgoCD 检测并开始 Rollout
10:00  10% traffic to v1.2.0
10:02  20% traffic to v1.2.0
10:04  50% traffic to v1.2.0
10:09  Analysis started...
10:10  ERROR: Success rate 92% < 95%
10:10  Analysis failed, initiating rollback
10:11  100% traffic back to v1.1.0
10:12  Git commit: "Auto-rollback to v1.1.0"
```

---

## GitOps 最佳实践

### 1. 单一 Git 仓库 vs 多 Git 仓库

**单一仓库**（Monorepo）：

```
config/
├── apps/
│   ├── app1/
│   ├── app2/
│   └── app3/
└── infrastructure/
    ├── ingress/
    ├── monitoring/
    └── storage/
```

**优点**：
- 统一版本管理
- 跨应用配置共享
- 简化权限管理

**缺点**：
- 大仓库性能问题
- 权限粒度粗

**多仓库**（Multi-repo）：

```
app1-config/
app2-config/
app3-config/
infra-config/
```

**优点**：
- 细粒度权限
- 独立版本迭代
- 小仓库性能好

**缺点**：
- 配置分散
- 难以统一管理

**推荐**：
- 小团队（< 10 人）：单一仓库
- 大团队：按团队/服务拆分多仓库

### 2. Git 分支策略

**环境分支**：

```
main     → 生产环境
staging  → 预发环境
develop  → 开发环境
```

**优点**：
- 环境隔离
- 部署直观

**缺点**：
- 合并冲突
- 难以跟踪变更

**目录策略**（推荐）：

```
main 分支：
├── overlays/dev/
├── overlays/staging/
└── overlays/prod/
```

**优点**：
- 无分支冲突
- 变更清晰
- 易于回滚

### 3. Secrets 管理

**不要直接提交 Secret 到 Git！**

```yaml
# ❌ 错误
apiVersion: v1
kind: Secret
metadata:
  name: db-password
data:
  password: cGFzc3dvcmQxMjM=  # base64，不安全
```

**正确方法 1：Sealed Secrets**

```bash
# 加密 Secret
kubeseal --format yaml < secret.yaml > sealed-secret.yaml

# sealed-secret.yaml 可以安全提交到 Git
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: db-password
spec:
  encryptedData:
    password: AgBj7V5...（加密后）
```

**正确方法 2：External Secrets Operator**

```yaml
# 只存引用，不存值
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: db-password
spec:
  secretStoreRef:
    name: aws-secrets-manager
  target:
    name: db-password
  data:
  - secretKey: password
    remoteRef:
      key: prod/db-password  # AWS Secrets Manager 的 key
```

### 4. 审计与合规

**Git Commit 策略**：

```bash
# ❌ 差
git commit -m "fix"

# ✅ 好
git commit -m "fix(prod): rollback to v1.1.0 due to high error rate

- Error rate: 8%
- Duration: 5 minutes
- Auto-rollback by SelfHeal Bot
- Ticket: INC-12345
"
```

**PR 审批流程**：

```yaml
# GitHub CODEOWNERS
/overlays/prod/*  @sre-team @security-team

# 生产环境配置必须 2 人审批
```

---

## 关键洞察

### 洞察 1：Git 是时间机器

```
所有变更可追溯：
git log --oneline overlays/prod/

abc123  Deploy v1.2.0
def456  Rollback to v1.1.0 (auto)
ghi789  Scale replicas to 10
jkl012  Update config: timeout=30s

任意时刻可回滚：
git revert abc123
git push
→ ArgoCD 自动同步回滚
```

### 洞察 2：声明式 > 命令式

```
命令式（脆弱）：
kubectl scale deployment myapp --replicas=10
（如果 Pod 挂了，副本数就不对了）

声明式（健壮）：
# Git 中声明：replicas: 10
# ArgoCD 持续监控，自动修复
```

### 洞察 3：自动化 = 可靠性

```
人工回滚：
1. 发现问题（5 分钟）
2. 找到问题版本（5 分钟）
3. 执行回滚（2 分钟）
4. 验证恢复（3 分钟）
总计：15 分钟

自动回滚：
1. 检测问题（30 秒）
2. 策略判断（10 秒）
3. Git 提交（10 秒）
4. ArgoCD 同步（1 分钟）
总计：2 分钟

可靠性提升：7.5 倍
```

---

## 相关主题

- [4.1 自愈系统架构](./04.1_Self_Healing_Architecture.md)
- [4.2 OTLP 可观测性](./04.2_OTLP_Observability.md)
- [4.3 OPA 策略引擎](./04.3_OPA_Policy_Engine.md)
- [4.5 自愈闭环实现](./04.5_Self_Healing_Loop_Implementation.md)

---

**导航**：[返回自愈系统](./README.md) | [← 上一节：OPA 策略引擎](./04.3_OPA_Policy_Engine.md) | [下一节：自愈闭环实现 →](./04.5_Self_Healing_Loop_Implementation.md)

