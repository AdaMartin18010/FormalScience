# 4.3 OPA 策略引擎

> **文档版本**: v1.0.0  
> **最后更新**: 2025-10-27  
> **文档规模**: 792行 | 策略即代码与Rego语言  
> **阅读建议**: 本文详解OPA策略引擎，是实现策略解耦和自动化决策的关键技术

---

## 核心定义

**OPA**（Open Policy Agent）：通用的策略即代码（Policy-as-Code）引擎，使用声明式语言 Rego 定义策略，用于统一的决策制定。

## 为什么需要 OPA？

### 传统策略管理的问题

```
问题 1：策略散落在代码中
// 业务代码
if (user.role != "admin" && order.amount > 10000) {
    throw new Error("Unauthorized");
}

缺点：
- 策略与业务耦合
- 难以审计
- 修改需要重新部署

问题 2：策略不一致
- API Gateway: 用 Nginx 配置
- 应用层: 用 Java 代码
- 数据库: 用 SQL 权限
- K8s: 用 RBAC

缺点：
- 每个系统不同语法
- 容易遗漏
- 维护成本高

问题 3：无法集中管理
- 谁能访问什么？（不知道）
- 策略是否生效？（不知道）
- 策略变更影响范围？（不知道）
```

### OPA 解决方案

```
统一决策点：
所有策略判断都发到 OPA
    ↓
声明式策略：
用 Rego 语言统一表达
    ↓
集中管理：
策略版本化、可审计
```

---

## OPA 架构

### 部署模式

#### 模式 1：Sidecar（微服务）

```
┌────────────────────────────────┐
│  Pod                            │
│  ┌──────────┐   ┌──────────┐  │
│  │ App      │──→│ OPA      │  │
│  │Container │   │Sidecar   │  │
│  └──────────┘   └──────────┘  │
└────────────────────────────────┘

优点：
- 低延迟（本地调用）
- 高可用（每个 Pod 独立）
- 自动扩容（随 Pod 扩容）

缺点：
- 资源开销（每 Pod 一个 OPA）
- 策略更新需要同步
```

#### 模式 2：Gateway（集中式）

```
┌──────────┐    ┌──────────┐
│ Service  │───→│ OPA      │
│ A        │    │ Gateway  │
└──────────┘    │          │
┌──────────┐    │(Replicas)│
│ Service  │───→│          │
│ B        │    └──────────┘
└──────────┘

优点：
- 资源节省（共享实例）
- 策略统一更新
- 易于审计

缺点：
- 网络延迟
- 单点故障（需高可用）
```

#### 模式 3：Kubernetes Admission Controller

```
kubectl apply → K8s API Server
                     ↓
            Admission Webhook
                     ↓
              OPA Gatekeeper
                     ↓
         Validate/Mutate Resource
                     ↓
       Allow/Deny/Modify
```

**用途**：
- 阻止不符合规范的资源
- 自动注入标签、sidecar
- 强制安全策略

---

## Rego 语言深度解析

### 核心概念

**1. 规则（Rules）**

```rego
# 语法：<name> { <body> }

# 简单规则（布尔值）
allow {
    input.user.role == "admin"
}

# 带值的规则
user_name := input.user.name

# 多条件规则（AND）
allow {
    input.user.role == "admin"
    input.action == "delete"
    input.resource.owner == input.user.id
}

# 多个规则（OR）
allow {
    input.user.role == "admin"
}

allow {
    input.resource.owner == input.user.id
}
```

**2. 数据查询（Queries）**

```rego
# 引用外部数据
users := data.users

# 查询满足条件的用户
admin_users[user] {
    user := data.users[_]
    user.role == "admin"
}

# 带过滤的查询
high_value_orders[order] {
    order := data.orders[_]
    order.amount > 10000
}
```

**3. 函数（Functions）**

```rego
# 定义函数
is_weekend(day) {
    day == "Saturday"
}

is_weekend(day) {
    day == "Sunday"
}

# 使用函数
allow {
    is_weekend(input.day)
}

# 带返回值的函数
discount(amount) = result {
    amount > 1000
    result := amount * 0.9
} else = amount {
    true
}
```

### 实战示例

#### 示例 1：API 授权

**需求**：
- 管理员可以访问所有 API
- 普通用户只能访问自己的资源
- 匿名用户只能 GET 公开资源

```rego
package authz

import future.keywords.if

# 默认拒绝
default allow = false

# 管理员：允许所有操作
allow if {
    input.user.role == "admin"
}

# 普通用户：访问自己的资源
allow if {
    input.user.role == "user"
    input.method == "GET"
    input.path == ["users", input.user.id]
}

allow if {
    input.user.role == "user"
    input.method in ["PUT", "DELETE"]
    input.path == ["users", input.user.id]
}

# 匿名用户：只读公开资源
allow if {
    not input.user
    input.method == "GET"
    input.path[0] == "public"
}

# 禁止访问敏感字段
deny[msg] {
    input.method == "GET"
    input.user.role != "admin"
    "ssn" in input.query_fields
    msg := "Unauthorized to access SSN field"
}
```

**调用**：

```json
// 输入
{
  "user": {"id": "123", "role": "user"},
  "method": "GET",
  "path": ["users", "123"]
}

// 输出
{
  "allow": true,
  "deny": []
}
```

#### 示例 2：Kubernetes 策略（Gatekeeper）

**需求**：
- 所有 Deployment 必须有 resource limits
- 镜像必须来自公司仓库
- 生产环境必须至少 2 个副本

```rego
package kubernetes.admission

import future.keywords.if

# 检查 resource limits
violation[{"msg": msg}] {
    container := input.review.object.spec.template.spec.containers[_]
    not container.resources.limits
    msg := sprintf("Container '%s' missing resource limits", [container.name])
}

# 检查镜像来源
violation[{"msg": msg}] {
    container := input.review.object.spec.template.spec.containers[_]
    image := container.image
    not startswith(image, "registry.company.com/")
    msg := sprintf("Image '%s' not from approved registry", [image])
}

# 检查生产环境副本数
violation[{"msg": msg}] {
    input.review.object.metadata.namespace == "production"
    replicas := input.review.object.spec.replicas
    replicas < 2
    msg := sprintf("Production deployment must have at least 2 replicas, got %d", [replicas])
}
```

**效果**：

```yaml
# 尝试部署（违规）
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test
  namespace: production
spec:
  replicas: 1  # 违规：生产环境至少 2 个
  template:
    spec:
      containers:
      - name: app
        image: nginx:latest  # 违规：镜像来源
        # 违规：缺少 resources.limits

# Gatekeeper 拒绝并返回
Error: admission webhook "validation.gatekeeper.sh" denied the request:
  - Container 'app' missing resource limits
  - Image 'nginx:latest' not from approved registry
  - Production deployment must have at least 2 replicas, got 1
```

#### 示例 3：自愈决策

**需求**：决定是否自动回滚

```rego
package selfheal

import future.keywords.if

# 默认不回滚
default allow_rollback = false

# 允许回滚的条件
allow_rollback if {
    # 错误率高
    input.metrics.error_rate > 0.05
    
    # 持续时间够长（避免瞬时抖动）
    input.alert.duration >= 300  # 5 分钟
    
    # 重启次数多（说明不是偶发）
    input.metrics.restart_count > 3
    
    # 不在维护窗口
    not in_maintenance_window
    
    # 限流：30 分钟内回滚不超过 2 次
    count(recent_rollbacks) < 2
}

# 辅助函数：是否在维护窗口
in_maintenance_window if {
    hour := time.clock([time.now_ns()])[0]
    # 凌晨 2-4 点维护窗口
    hour >= 2
    hour < 4
}

# 辅助函数：获取最近回滚记录
recent_rollbacks[rb] {
    rb := data.rollback_history[_]
    rb.service == input.service
    rb.timestamp > time.now_ns() - 1800000000000  # 30 分钟内
}

# 决策输出
decision := {
    "allow": allow_rollback,
    "action": action,
    "reason": reason,
    "confidence": confidence
}

action := "rollback" if allow_rollback
action := "alert_only" if not allow_rollback

reason := sprintf("Error rate %.2f%% > 5%% for %d seconds with %d restarts",
    [input.metrics.error_rate * 100, input.alert.duration, input.metrics.restart_count]
) if allow_rollback

reason := "Does not meet rollback criteria" if not allow_rollback

confidence := 0.9 if {
    allow_rollback
    input.metrics.restart_count > 5
}

confidence := 0.7 if {
    allow_rollback
    input.metrics.restart_count <= 5
}

confidence := 0.5 if not allow_rollback
```

**测试**：

```json
// 输入
{
  "service": "user-api",
  "metrics": {
    "error_rate": 0.08,
    "restart_count": 5
  },
  "alert": {
    "duration": 400
  }
}

// 输出
{
  "decision": {
    "allow": true,
    "action": "rollback",
    "reason": "Error rate 8.00% > 5% for 400 seconds with 5 restarts",
    "confidence": 0.9
  }
}
```

---

## OPA 集成方式

### 1. HTTP API

**服务端**：

```bash
# 启动 OPA 服务器
opa run --server --addr 0.0.0.0:8181 /policies
```

**客户端**：

```python
import requests

def check_permission(user, resource, action):
    response = requests.post(
        "http://opa:8181/v1/data/authz/allow",
        json={
            "input": {
                "user": user,
                "resource": resource,
                "action": action
            }
        }
    )
    result = response.json()
    return result.get("result", False)

# 使用
if check_permission(current_user, "orders/123", "delete"):
    delete_order(123)
else:
    return error("Unauthorized")
```

### 2. Go 库（嵌入式）

```go
package main

import (
    "context"
    "github.com/open-policy-agent/opa/rego"
)

func checkPermission(user map[string]interface{}, action string) (bool, error) {
    ctx := context.Background()
    
    // 加载策略
    query, err := rego.New(
        rego.Query("data.authz.allow"),
        rego.Load([]string{"policies/authz.rego"}, nil),
    ).PrepareForEval(ctx)
    
    if err != nil {
        return false, err
    }
    
    // 评估
    input := map[string]interface{}{
        "user":   user,
        "action": action,
    }
    
    results, err := query.Eval(ctx, rego.EvalInput(input))
    if err != nil {
        return false, err
    }
    
    if len(results) == 0 || len(results[0].Expressions) == 0 {
        return false, nil
    }
    
    return results[0].Expressions[0].Value.(bool), nil
}
```

### 3. Envoy 外部授权

**Envoy 配置**：

```yaml
static_resources:
  listeners:
  - address:
      socket_address:
        address: 0.0.0.0
        port_value: 8080
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          http_filters:
          # OPA 授权过滤器
          - name: envoy.ext_authz
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
              grpc_service:
                envoy_grpc:
                  cluster_name: opa
                timeout: 0.5s
          
          - name: envoy.filters.http.router
  
  clusters:
  - name: opa
    type: STATIC
    lb_policy: ROUND_ROBIN
    load_assignment:
      cluster_name: opa
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: opa
                port_value: 9191
```

**OPA 策略**（Envoy 专用）：

```rego
package envoy.authz

import input.attributes.request.http as http_request

default allow = false

allow {
    http_request.method == "GET"
    http_request.path == "/public"
}

allow {
    http_request.headers.authorization == "Bearer valid-token"
}
```

---

## OPA Bundle（策略分发）

### Bundle 结构

```
policies/
├── .manifest
├── authz.rego
├── rbac.rego
└── data.json

.manifest:
{
  "revision": "v1.2.0",
  "roots": ["authz", "rbac"]
}
```

### 构建 Bundle

```bash
# 打包
opa build -b policies/ -o bundle.tar.gz

# 上传到服务器
curl -X PUT http://bundle-server/bundles/myapp.tar.gz \
  --data-binary @bundle.tar.gz
```

### OPA 拉取 Bundle

```yaml
# OPA 配置
services:
  bundle-server:
    url: http://bundle-server

bundles:
  myapp:
    service: bundle-server
    resource: /bundles/myapp.tar.gz
    polling:
      min_delay_seconds: 10
      max_delay_seconds: 30
```

**效果**：
- OPA 每 10-30 秒拉取最新策略
- 无需重启 OPA
- 所有 OPA 实例自动更新

---

## OPA 性能优化

### 1. 编译策略

```bash
# 预编译 Rego → Wasm
opa build -t wasm -e 'data.authz.allow' policies/

# OPA 加载编译后的策略（快 10 倍）
opa run --server --bundle bundle.tar.gz
```

### 2. 缓存决策结果

```go
var cache = make(map[string]bool)
var mutex sync.RWMutex

func checkPermissionCached(user, resource, action string) bool {
    key := fmt.Sprintf("%s:%s:%s", user, resource, action)
    
    // 读缓存
    mutex.RLock()
    if result, ok := cache[key]; ok {
        mutex.RUnlock()
        return result
    }
    mutex.RUnlock()
    
    // 调用 OPA
    result := checkPermission(user, resource, action)
    
    // 写缓存（TTL 1 分钟）
    mutex.Lock()
    cache[key] = result
    mutex.Unlock()
    
    go func() {
        time.Sleep(1 * time.Minute)
        mutex.Lock()
        delete(cache, key)
        mutex.Unlock()
    }()
    
    return result
}
```

### 3. 部分评估（Partial Evaluation）

**场景**：查询数据库前先过滤

```rego
package filter

allow[user_id] {
    user := data.users[user_id]
    user.department == input.department
    user.role == "manager"
}
```

**使用**：

```bash
# 部分评估（输入 department）
opa eval --partial -d policies/ -i input.json 'data.filter.allow'

# 输出 SQL 过滤条件
"SELECT * FROM users WHERE department='sales' AND role='manager'"
```

---

## OPA vs 其他策略引擎

| 特性 | OPA | Casbin | AWS IAM | Kyverno |
|-----|-----|--------|---------|---------|
| **语言** | Rego | 配置文件 | JSON | YAML |
| **通用性** | ✅ 通用 | ✅ 通用 | ❌ AWS 专用 | ❌ K8s 专用 |
| **表达能力** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| **学习曲线** | 陡峭 | 平缓 | 平缓 | 平缓 |
| **性能** | 高 | 高 | 高 | 中 |
| **生态** | CNCF 项目 | 开源 | AWS 原生 | CNCF 项目 |

---

## 关键洞察

### 洞察 1：策略即代码 = 可测试

```rego
# 策略
package authz
allow { input.user.role == "admin" }

# 测试（使用 OPA test）
test_admin_allowed {
    allow with input as {"user": {"role": "admin"}}
}

test_user_denied {
    not allow with input as {"user": {"role": "user"}}
}
```

```bash
# 运行测试
opa test policies/
PASS: 2/2
```

### 洞察 2：声明式 > 命令式

```
命令式（代码）：
if (user.role == "admin") {
    return true;
} else if (user.department == "sales" && resource.type == "order") {
    return true;
} else {
    return false;
}

声明式（Rego）：
allow { input.user.role == "admin" }
allow { input.user.department == "sales"; input.resource.type == "order" }
```

好处：
- 易读
- 可组合
- 可验证

### 洞察 3：集中策略 = 安全保障

```
分散策略：
- API Gateway: 部分检查
- 应用: 部分检查
- 数据库: 部分检查
→ 容易遗漏，产生安全漏洞

集中策略：
- 所有请求都经过 OPA
- 统一规则，无遗漏
→ 安全保障
```

---

## 相关主题

- [4.1 自愈系统架构](./04.1_Self_Healing_Architecture.md)
- [4.2 OTLP 可观测性](./04.2_OTLP_Observability.md)
- [4.4 GitOps 声明式修复](./04.4_GitOps_Declarative_Remediation.md)
- [6.2 策略即代码](../06_Observability_Governance/06.2_Policy_as_Code.md)

---

**导航**：[返回自愈系统](./README.md) | [← 上一节：OTLP 可观测性](./04.2_OTLP_Observability.md) | [下一节：GitOps 修复 →](./04.4_GitOps_Declarative_Remediation.md)

