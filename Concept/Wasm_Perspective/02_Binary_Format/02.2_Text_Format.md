# 2.2 文本格式 (Text Format)

## 目录

- [2.2 文本格式 (Text Format)](#22-文本格式-text-format)
  - [目录](#目录)
  - [核心命题](#核心命题)
  - [S-表达式语法](#s-表达式语法)
    - [基本结构](#基本结构)
    - [折叠指令（Folded Instructions）](#折叠指令folded-instructions)
  - [模块声明](#模块声明)
    - [Type Section](#type-section)
    - [Function 声明](#function-声明)
  - [控制流结构](#控制流结构)
    - [Block 与 Label](#block-与-label)
    - [Loop 结构](#loop-结构)
    - [If-Else](#if-else)
  - [内存与表](#内存与表)
    - [Linear Memory](#linear-memory)
    - [Table](#table)
  - [导入与导出](#导入与导出)
    - [Import](#import)
    - [Export](#export)
  - [全局变量](#全局变量)
  - [注释与元数据](#注释与元数据)
    - [注释语法](#注释语法)
    - [Custom Section](#custom-section)
  - [名称解析](#名称解析)
    - [标识符规则](#标识符规则)
    - [索引与名称混用](#索引与名称混用)
  - [工具链集成](#工具链集成)
    - [wat2wasm](#wat2wasm)
    - [wasm2wat](#wasm2wat)
  - [性能考量](#性能考量)
    - [解析复杂度](#解析复杂度)
    - [生产环境策略](#生产环境策略)
  - [批判性分析](#批判性分析)
    - [优势](#优势)
    - [局限性](#局限性)
    - [设计反思](#设计反思)
  - [扩展提案](#扩展提案)
    - [Multi-Memory](#multi-memory)
    - [Component Model](#component-model)
  - [参考文献](#参考文献)
  - [相关文档](#相关文档)

## 核心命题

**同构性定理**：
\[
\forall M : \exists W_{\text{WAT}}, B_{\text{binary}} : \text{parse}(W) = \text{decode}(B) = M
\]

**可读性权衡**：
\[
\text{Size}(W) \approx 3 \times \text{Size}(B) \quad \text{但 } \text{Debuggability}(W) \gg \text{Debuggability}(B)
\]

**非规范性**：
> WAT 是 Wasm 的**语法糖**，不影响语义。工具可自由扩展 WAT，但必须产生规范二进制。

---

## S-表达式语法

### 基本结构

**嵌套表达式**：

```wasm
(module
  (type $t0 (func (param i32) (result i32)))
  (func $f (type $t0)
    local.get 0
    i32.const 42
    i32.add
  )
)
```

**线性指令序列**：

```wasm
(func $example
  i32.const 10
  i32.const 20
  i32.add
  drop
)
```

### 折叠指令（Folded Instructions）

**语法糖**：

```wasm
;; 线性形式
i32.const 1
i32.const 2
i32.add

;; 折叠形式
(i32.add (i32.const 1) (i32.const 2))
```

**转换规则**：
\[
(op \; e_1 \; e_2 \; \ldots) \equiv e_1 \; e_2 \; \ldots \; op
\]

**批判**：
> 折叠指令提高了代码表达力，但增加了解析器复杂度。S-表达式的嵌套深度可能导致栈溢出，工具链需要递归深度限制。

---

## 模块声明

### Type Section

**语法**：

```wasm
(type $sig (func (param i32 i64) (result f32)))
```

**命名约定**：

- `$` 前缀标识符：局部作用域
- 可省略名称，使用索引：`(type (func ...))`

### Function 声明

**完整形式**：

```wasm
(func $add (param $x i32) (param $y i32) (result i32)
  (local $temp i64)
  local.get $x
  local.get $y
  i32.add
)
```

**简写形式**：

```wasm
(func (param i32 i32) (result i32)
  local.get 0
  local.get 1
  i32.add
)
```

**内联类型**：

```wasm
(func $inline (param i32) (result i32)
  ;; 等价于自动生成 type 并引用
)
```

---

## 控制流结构

### Block 与 Label

**语法**：

```wasm
(block $outer (result i32)
  (block $inner
    br $outer (i32.const 42)
  )
  i32.const 0
)
```

**标签作用域**：
\[
\text{Label}(block) := \{ \text{自身}, \text{父级}, \text{祖先} \}
\]

### Loop 结构

**循环**：

```wasm
(loop $continue
  local.get $i
  i32.const 10
  i32.lt_u
  if
    ;; 循环体
    local.get $i
    i32.const 1
    i32.add
    local.set $i
    br $continue  ;; 回到 loop 开头
  end
)
```

**关键差异**：

- `block` 的 label 指向 `end`
- `loop` 的 label 指向 `loop` 开头

### If-Else

**语法**：

```wasm
(if (result i32)
  (i32.const 1)
  (then
    i32.const 42
  )
  (else
    i32.const 0
  )
)
```

**折叠形式**：

```wasm
(i32.eqz (local.get $flag))
(if
  (then (call $branch_a))
  (else (call $branch_b))
)
```

---

## 内存与表

### Linear Memory

**声明**：

```wasm
(memory $mem 1 10)  ;; 初始 1 页，最大 10 页
```

**数据段**：

```wasm
(data (i32.const 0) "Hello")
(data (memory $mem) (i32.const 1024) "\00\01\02\03")
```

**主动 vs 被动段**：

```wasm
;; 主动段：启动时自动初始化
(data (i32.const 0) "active")

;; 被动段：需手动初始化
(data $passive "passive")
(func $init
  i32.const 0      ;; 目标地址
  i32.const 0      ;; 源偏移
  i32.const 7      ;; 长度
  memory.init $passive
)
```

### Table

**声明**：

```wasm
(table $t 10 20 funcref)
```

**元素段**：

```wasm
(elem (i32.const 0) $f1 $f2 $f3)

;; 被动元素
(elem $e funcref (ref.func $f1) (ref.func $f2))
```

---

## 导入与导出

### Import

**语法**：

```wasm
(import "env" "memory" (memory 1))
(import "wasi_snapshot_preview1" "fd_write"
  (func $fd_write (param i32 i32 i32 i32) (result i32))
)
```

**两级命名空间**：
\[
\text{ImportName} := (\text{module}, \text{field})
\]

### Export

**导出声明**：

```wasm
(func $add (param i32 i32) (result i32)
  local.get 0
  local.get 1
  i32.add
)
(export "add" (func $add))

;; 简写
(func (export "add") (param i32 i32) (result i32)
  local.get 0
  local.get 1
  i32.add
)
```

---

## 全局变量

**可变全局**：

```wasm
(global $counter (mut i32) (i32.const 0))

(func $increment
  global.get $counter
  i32.const 1
  i32.add
  global.set $counter
)
```

**不可变全局**：

```wasm
(global $pi f32 (f32.const 3.14159))
```

**初始化约束**：
\[
\text{GlobalInit} \subseteq \{ \text{const}, \text{global.get imported} \}
\]

---

## 注释与元数据

### 注释语法

**行注释**：

```wasm
;; 这是注释
(func $test
  nop  ;; 行尾注释
)
```

**块注释**：

```wasm
(;
  多行注释
  可以嵌套 (; 像这样 ;)
;)
```

### Custom Section

**声明**：

```wasm
(@custom "my-metadata" "arbitrary data")
```

**工具扩展**：

```wasm
(@producers
  (language "C" "11.0.0")
  (processed-by "clang" "11.0.0")
)
```

---

## 名称解析

### 标识符规则

**命名空间**：

- 函数：`$func_name`
- 类型：`$type_name`
- 局部变量：`$local_name`
- 标签：`$label_name`

**作用域规则**：

```wasm
(func $outer
  (block $L
    (block $L  ;; 错误：标签冲突
      br $L
    )
  )
)
```

### 索引与名称混用

**等价形式**：

```wasm
local.get 0
local.get $first_param  ;; 如果 $first_param 是索引 0
```

**批判**：
> WAT 允许索引与名称混用，增加了灵活性但降低了可维护性。大型模块中，索引引用容易因插入新定义而失效。

---

## 工具链集成

### wat2wasm

**命令行**：

```bash
wat2wasm module.wat -o module.wasm --debug-names
```

**选项**：

- `--debug-names`：保留名称段
- `--no-check`：跳过验证
- `--enable-threads`：启用线程提案

### wasm2wat

**反汇编**：

```bash
wasm2wat module.wasm -o module.wat --fold-exprs
```

**选项**：

- `--fold-exprs`：使用折叠指令
- `--inline-exports`：内联导出声明
- `--generate-names`：为未命名项生成名称

---

## 性能考量

### 解析复杂度

**时间复杂度**：
\[
T_{\text{parse}}(W) = O(|W| \cdot \text{depth}(W))
\]

**瓶颈**：

- S-表达式解析：递归下降
- 名称解析：哈希表查找
- 折叠指令展开：树遍历

### 生产环境策略

**最佳实践**：

1. 仅在开发环境使用 WAT
2. CI/CD 流水线转换为二进制
3. 源码映射用于调试

---

## 批判性分析

### 优势

1. **人类可读**：调试和教学友好
2. **工具友好**：标准 S-表达式易解析
3. **可扩展**：Custom Section 支持元数据

### 局限性

1. **冗长**：3倍二进制大小
2. **解析慢**：比二进制慢 10-100 倍
3. **语法糖陷阱**：折叠指令掩盖栈行为

### 设计反思

> WAT 的 S-表达式设计源于 Lisp 传统，但这导致与主流语法（C/Rust）的认知鸿沟。JavaScript 开发者习惯花括号，看到嵌套括号会感到陌生。也许类 C 语法的文本格式能降低学习门槛，但会牺牲 Lisp 工具链的优势。

---

## 扩展提案

### Multi-Memory

**语法**（提案中）：

```wasm
(memory $mem1 1)
(memory $mem2 2)

(func
  i32.const 0
  i32.load (memory $mem2)
)
```

### Component Model

**接口定义**（WIT）：

```wit
interface logger {
  log: func(msg: string)
}

world app {
  import logger
  export run: func()
}
```

**批判**：
> Component Model 试图解决 Wasm 的组合性问题，但引入了新的 IDL（WIT），增加了工具链复杂度。是否真的需要另一种接口语言，还是应该直接用 TypeScript/Protocol Buffers？

---

## 参考文献

1. **[WebAssembly Spec]** Text Format (https://webassembly.github.io/spec/core/text/)
2. **[WABT]** WebAssembly Binary Toolkit (https://github.com/WebAssembly/wabt)
3. **[Watt21]** Conrad Watt. "Mechanising and Verifying the WebAssembly Specification." CPP, 2021.

---

## 相关文档

- **[02.1 二进制编码](02.1_Binary_Encoding.md)** - WAT 到二进制的映射
- **[02.3 模块结构](02.3_Module_Structure.md)** - 模块组织原则
- **[03.1 编译策略](../03_Runtime_Systems/03.1_Compilation_Strategies.md)** - WAT 解析器实现
