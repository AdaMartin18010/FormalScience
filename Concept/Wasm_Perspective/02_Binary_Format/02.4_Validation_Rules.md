# 2.4 验证规则 (Validation Rules)

## 核心命题

**验证完备性**：
\[
\text{Valid}(M) \implies \forall \text{Execution}(M) : \neg \text{UndefinedBehavior}
\]

**单遍验证原则**：
\[
T_{\text{validate}}(M) = O(|M|)
\]

**类型安全定理**：
\[
\text{Valid}(M) \implies (\text{Progress} \wedge \text{Preservation})
\]

---

## 验证层次结构

### Level 1: 结构验证

**模块完整性**：
\[
\begin{aligned}
&\text{Magic} = 0x0061736D \\
&\text{Version} = 0x00000001 \\
&\forall S_i, S_{i+1} : \text{ID}(S_i) < \text{ID}(S_{i+1}) \quad (\text{Custom 除外})
\end{aligned}
\]

**Section 大小**：
\[
\text{declared-size}(S) = \text{actual-size}(S)
\]

**LEB128 规范性**：

- 禁止冗余编码（如 `0x80 0x00` 表示 0）
- 最高字节的高位必须为 0

**批判**：
> 规范性检查增加了验证复杂度，但防止了签名绕过攻击。攻击者可能利用冗余编码构造两个哈希不同但语义相同的模块。

---

### Level 2: 类型验证

#### 类型系统基础

**类型环境**：
\[
C := \langle \text{types}, \text{funcs}, \text{tables}, \text{mems}, \text{globals}, \text{locals}, \text{labels}, \text{return} \rangle
\]

**判断规则**：
\[
C \vdash \text{instr} : [\tau_1^_] \to [\tau_2^_]
\]

#### Value Types 验证

**有效性**：
\[
\text{valtype} \in \{ \text{i32}, \text{i64}, \text{f32}, \text{f64}, \text{v128}, \text{funcref}, \text{externref} \}
\]

**示例**：

```
0x7F => i32 ✓
0x00 => 无效 ✗
```

#### Function Types 验证

**约束**：
\[
\begin{aligned}
&\text{FuncType} = 0x60 \parallel \vec{\text{param}} \parallel \vec{\text{result}} \\
&|\vec{\text{result}}| \leq 1 \quad (\text{MVP; 多返回值在提案中})
\end{aligned}
\]

**批判**：
> MVP 限制单返回值，导致需要返回多值时必须通过内存或全局变量。Multi-Value 提案解决了这个问题，但破坏了早期模块的假设。

---

### Level 3: 指令验证

#### 类型栈模型

**栈状态**：
\[
\Sigma := \text{Stack}[\tau_1, \tau_2, \ldots, \tau_n]
\]

**指令效果**：
\[
\text{instr} : \Sigma \to \Sigma'
\]

#### 算术指令

**i32.add**：
\[
\frac{C \vdash \text{i32.add} : [\text{i32}, \text{i32}] \to [\text{i32}]}{\Sigma \cdot [\text{i32}, \text{i32}] \xrightarrow{\text{i32.add}} \Sigma \cdot [\text{i32}]}
\]

**类型不匹配示例**：

```wasm
i32.const 10
f32.const 3.14
i32.add          ;; 错误：类型不匹配
```

#### 内存指令

**i32.load**：
\[
\frac{
  C.\text{mems}[0] = \text{memtype} \quad 2^{\text{align}} \leq 4
}{
  C \vdash \text{i32.load align offset} : [\text{i32}] \to [\text{i32}]
}
\]

**对齐检查**：
\[
\text{align} \leq \log_2(\text{natural-alignment})
\]

**示例**：

```wasm
i32.load align=3 offset=0  ;; 错误：2^3=8 > 4
```

---

#### 控制流验证

**Block**：
\[
\frac{
  C, \text{label}[[\tau^_]] \vdash \text{instr}^_ : [] \to [\tau^_]
}{
  C \vdash \text{block} \; [\tau^_] \; \text{instr}^_\; \text{end} : [] \to [\tau^_]
}
\]

**Br**：
\[
\frac{
  C.\text{labels}[l] = [\tau^_] \quad C \vdash \tau_1^_ : \tau^_\to \tau_2^_
}{
  C \vdash \text{br} \; l : [\tau_1^_] \to [\tau_2^_]
}
\]

**If-Else**：
\[
\frac{
  C, \text{label}[[\tau^_]] \vdash \text{instr}_1^_ : [] \to [\tau^_] \quad C, \text{label}[[\tau^_]] \vdash \text{instr}_2^*: [] \to [\tau^_]
}{
  C \vdash \text{if} \; [\tau^_] \; \text{instr}_1^* \; \text{else} \; \text{instr}_2^_\; \text{end} : [\text{i32}] \to [\tau^_]
}
\]

**类型多态性**：

```wasm
block (result i32)
  br 0  ;; 栈可以是任意 [t*] ++ [i32]
  i32.const 42
end
```

---

### Level 4: 引用验证

#### 函数引用

**约束**：
\[
\forall \text{funcidx} \in M : \text{funcidx} < |\text{funcs}|
\]

**示例**：

```wasm
(import "env" "log" (func $log (param i32)))
(func $main
  call 999  ;; 错误：索引越界
)
```

#### 表引用

**call_indirect**：
\[
\frac{
  C.\text{tables}[0] = \text{funcref} \quad C.\text{types}[x] = [\tau_1^_] \to [\tau_2^_]
}{
  C \vdash \text{call\_indirect} \; x : [\tau_1^_, \text{i32}] \to [\tau_2^_]
}
\]

**批判**：
> `call_indirect` 的类型检查是动态的，运行时可能陷阱。这打破了"验证即安全"的承诺，引入了隐藏的失败模式。

---

### Level 5: 控制流完整性

#### 可达性分析

**Unreachable 传播**：
\[
\frac{
  C \vdash \text{unreachable} : [\tau_1^_] \to [\tau_2^_]
}{
  \forall \text{instr after unreachable} : \text{StackPolymorphic}
}
\]

**示例**：

```wasm
unreachable
i32.const 42  ;; 类型栈为 unreachable，此指令合法
```

#### 结束块验证

**End 匹配**：
\[
\forall \text{block/loop/if} : \exists \text{matching end}
\]

**栈多态性**：

```wasm
block (result i32)
  return     ;; 栈变为 unreachable
  ;; 后续指令不再类型检查
end
```

**批判**：
> 栈多态性简化了验证器实现，但掩盖了死代码。开发者可能误认为所有路径都执行，实际上某些分支永不可达。

---

## 验证算法实现

### 类型栈验证器

**伪代码**：

```python
class TypeStack:
    def __init__(self):
        self.stack = []
        self.polymorphic = False

    def push(self, ty):
        if not self.polymorphic:
            self.stack.append(ty)

    def pop(self, expected):
        if self.polymorphic:
            return expected
        if not self.stack:
            raise ValidationError("Empty stack")
        actual = self.stack.pop()
        if actual != expected:
            raise ValidationError(f"Type mismatch: {actual} vs {expected}")
        return actual

    def mark_unreachable(self):
        self.stack.clear()
        self.polymorphic = True
```

### 控制流栈

**Label 栈**：

```python
class ControlStack:
    def __init__(self):
        self.frames = []

    def push_label(self, arity, result_types):
        self.frames.append(Label(arity, result_types))

    def pop_label(self):
        if not self.frames:
            raise ValidationError("Unmatched end")
        return self.frames.pop()

    def get_label(self, depth):
        if depth >= len(self.frames):
            raise ValidationError("Label out of range")
        return self.frames[-(depth + 1)]
```

---

## 性能优化

### 快速路径

**常见模式**：

```c
// i32.add 验证
if (stack_size() < 2) goto error;
if (stack_top() != I32) goto error;
if (stack_second() != I32) goto error;
stack_pop();
// 栈顶已经是 i32，无需 push
```

### 批量验证

**指令块**：
\[
\text{Validate}([\text{i32.const}, \text{i32.const}, \text{i32.add}]) = \text{Single-Check}
\]

**批判**：
> 批量验证可提升 30% 性能，但增加了实现复杂度。浏览器供应商有动机优化，但小型 Runtime 可能无法承担。

---

## 常见验证错误

### 类型错误

**示例 1**：

```wasm
f32.const 1.0
i32.add        ;; 错误：期望 i32，得到 f32
```

**示例 2**：

```wasm
i32.const 10
drop
i32.add        ;; 错误：栈下溢
```

### 索引错误

**示例**：

```wasm
call 100       ;; 错误：函数不存在
local.get 999  ;; 错误：局部变量不存在
```

### 控制流错误

**示例**：

```wasm
block
  br 1         ;; 错误：标签深度越界
end
```

---

## 扩展提案的验证

### Multi-Value

**新规则**：
\[
|\vec{\text{result}}| \geq 0 \quad (\text{无限制})
\]

**影响**：

- Block 可以返回多值
- 类型栈需要序列匹配

### Reference Types

**新类型**：
\[
\text{reftype} ::= \text{funcref} \mid \text{externref}
\]

**空引用**：

```wasm
ref.null funcref
```

**验证**：
\[
C \vdash \text{ref.null} \; \tau : [] \to [\tau]
\]

### Threads

**共享内存**：
\[
\text{memtype} := \langle \text{limits}, \text{shared} \rangle
\]

**原子指令**：

```wasm
i32.atomic.load  ;; 要求共享内存
```

**验证**：
\[
C.\text{mems}[0].\text{shared} = \text{true}
\]

---

## 批判性分析

### 验证成本

**时间复杂度**：
\[
O(|M| \cdot \log(|\text{types}|))
\]

**主导因素**：

- 类型栈操作：O(n)
- 控制流图：O(n log n)
- 引用解析：O(m log m)

### 验证局限

**无法检测的错误**：

1. 整数溢出
2. 除以零（整数）
3. 内存越界访问

**批判**：
> Wasm 的验证仅保证类型安全，不保证逻辑正确性。开发者需要额外的静态分析工具（如 KLEE、Infer）来捕获语义错误。

### 形式化保证

**已证明定理**：

- **Type Safety**：Progress + Preservation（Isabelle/HOL）
- **Memory Safety**：无缓冲区溢出（K 框架）

**未证明领域**：

- 并发正确性
- 侧信道安全

---

## 参考文献

1. **[Watt18]** Conrad Watt. "Mechanising and Verifying the WebAssembly Specification." CPP, 2018.
2. **[Rossberg21]** Andreas Rossberg. "WebAssembly Core Specification." W3C, 2021.
3. **[Chlipala]** Adam Chlipala. "Certified Programming with Dependent Types." MIT Press, 2013.

---

## 相关文档

- **[01.2 类型系统](../01_Foundational_Theory/01.2_Type_System.md)** - 类型理论基础
- **[01.3 验证模型](../01_Foundational_Theory/01.3_Verification_Model.md)** - 验证算法细节
- **[02.3 模块结构](02.3_Module_Structure.md)** - 结构验证规则
