# 2.4 验证规则 (Validation Rules)

## 目录

- [2.4 验证规则 (Validation Rules)](#24-验证规则-validation-rules)
  - [目录](#目录)
  - [核心命题](#核心命题)
  - [1 验证层次结构](#1-验证层次结构)
    - [1 Level 1: 结构验证](#1-level-1-结构验证)
    - [1.2 Level 2: 类型验证](#12-level-2-类型验证)
      - [1 类型系统基础](#1-类型系统基础)
      - [2 Value Types 验证](#2-value-types-验证)
      - [3 Function Types 验证](#3-function-types-验证)
    - [1.3 Level 3: 指令验证](#13-level-3-指令验证)
      - [1 类型栈模型](#1-类型栈模型)
      - [2 算术指令](#2-算术指令)
      - [3 内存指令](#3-内存指令)
      - [4 控制流验证](#4-控制流验证)
    - [1.4 Level 4: 引用验证](#14-level-4-引用验证)
      - [1 函数引用](#1-函数引用)
      - [2 表引用](#2-表引用)
    - [1.5 Level 5: 控制流完整性](#15-level-5-控制流完整性)
      - [1 可达性分析](#1-可达性分析)
      - [2 结束块验证](#2-结束块验证)
  - [2 验证算法实现](#2-验证算法实现)
    - [1 类型栈验证器](#1-类型栈验证器)
    - [2.2 控制流栈](#22-控制流栈)
  - [3 性能优化](#3-性能优化)
    - [1 快速路径](#1-快速路径)
    - [3.2 批量验证](#32-批量验证)
  - [4 常见验证错误](#4-常见验证错误)
    - [1 类型错误](#1-类型错误)
    - [4.2 索引错误](#42-索引错误)
    - [4.3 控制流错误](#43-控制流错误)
  - [5 扩展提案的验证](#5-扩展提案的验证)
    - [1 Multi-Value](#1-multi-value)
    - [5.2 Reference Types](#52-reference-types)
    - [5.3 Threads](#53-threads)
  - [6 批判性分析](#6-批判性分析)
    - [1 验证成本](#1-验证成本)
    - [6.2 验证局限](#62-验证局限)
    - [6.3 形式化保证](#63-形式化保证)
  - [参考文献](#参考文献)
  - [7 相关文档](#7-相关文档)

## 核心命题

**验证完备性**：
\[
\text{Valid}(M) \implies \forall \text{Execution}(M) : \neg \text{UndefinedBehavior}
\]

**单遍验证原则**：
\[
T_{\text{validate}}(M) = O(|M|)
\]

**类型安全定理**：
\[
\text{Valid}(M) \implies (\text{Progress} \wedge \text{Preservation})
\]

---

## 1 验证层次结构

### 1 Level 1: 结构验证

**模块完整性**：
\[
\begin{aligned}
&\text{Magic} = 0x0061736D \\
&\text{Version} = 0x00000001 \\
&\forall S_i, S_{i+1} : \text{ID}(S_i) < \text{ID}(S_{i+1}) \quad (\text{Custom 除外})
\end{aligned}
\]

**Section 大小**：
\[
\text{declared-size}(S) = \text{actual-size}(S)
\]

**LEB128 规范性**：

- 禁止冗余编码（如 `0x80 0x00` 表示 0）
- 最高字节的高位必须为 0

**批判**：
> 规范性检查增加了验证复杂度，但防止了签名绕过攻击。攻击者可能利用冗余编码构造两个哈希不同但语义相同的模块。

---

### 1.2 Level 2: 类型验证

#### 1 类型系统基础

**类型环境**：
\[
C := \langle \text{types}, \text{funcs}, \text{tables}, \text{mems}, \text{globals}, \text{locals}, \text{labels}, \text{return} \rangle
\]

**判断规则**：
\[
C \vdash \text{instr} : [\tau_1^_] \to [\tau_2^_]
\]

#### 2 Value Types 验证

**有效性**：
\[
\text{valtype} \in \{ \text{i32}, \text{i64}, \text{f32}, \text{f64}, \text{v128}, \text{funcref}, \text{externref} \}
\]

**示例**：

```text
0x7F => i32 ✓
0x00 => 无效 ✗
```

#### 3 Function Types 验证

**约束**：
\[
\begin{aligned}
&\text{FuncType} = 0x60 \parallel \vec{\text{param}} \parallel \vec{\text{result}} \\
&|\vec{\text{result}}| \leq 1 \quad (\text{MVP; 多返回值在提案中})
\end{aligned}
\]

**批判**：
> MVP 限制单返回值，导致需要返回多值时必须通过内存或全局变量。Multi-Value 提案解决了这个问题，但破坏了早期模块的假设。

---

### 1.3 Level 3: 指令验证

#### 1 类型栈模型

**栈状态**：
\[
\Sigma := \text{Stack}[\tau_1, \tau_2, \ldots, \tau_n]
\]

**指令效果**：
\[
\text{instr} : \Sigma \to \Sigma'
\]

#### 2 算术指令

**i32.add**：
\[
\frac{C \vdash \text{i32.add} : [\text{i32}, \text{i32}] \to [\text{i32}]}{\Sigma \cdot [\text{i32}, \text{i32}] \xrightarrow{\text{i32.add}} \Sigma \cdot [\text{i32}]}
\]

**类型不匹配示例**：

```wasm
i32.const 10
f32.const 3.14
i32.add          ;; 错误：类型不匹配
```

#### 3 内存指令

**i32.load**：
\[
\frac{
  C.\text{mems}[0] = \text{memtype} \quad 2^{\text{align}} \leq 4
}{
  C \vdash \text{i32.load align offset} : [\text{i32}] \to [\text{i32}]
}
\]

**对齐检查**：
\[
\text{align} \leq \log_2(\text{natural-alignment})
\]

**示例**：

```wasm
i32.load align=3 offset=0  ;; 错误：2^3=8 > 4
```

---

#### 4 控制流验证

**Block**：
\[
\frac{
  C, \text{label}[[\tau^_]] \vdash \text{instr}^_ : [] \to [\tau^_]
}{
  C \vdash \text{block} \; [\tau^_] \; \text{instr}^_\; \text{end} : [] \to [\tau^_]
}
\]

**Br**：
\[
\frac{
  C.\text{labels}[l] = [\tau^_] \quad C \vdash \tau_1^_ : \tau^_\to \tau_2^_
}{
  C \vdash \text{br} \; l : [\tau_1^_] \to [\tau_2^_]
}
\]

**If-Else**：
\[
\frac{
  C, \text{label}[[\tau^_]] \vdash \text{instr}_1^_ : [] \to [\tau^_] \quad C, \text{label}[[\tau^_]] \vdash \text{instr}_2^*: [] \to [\tau^_]
}{
  C \vdash \text{if} \; [\tau^_] \; \text{instr}_1^* \; \text{else} \; \text{instr}_2^_\; \text{end} : [\text{i32}] \to [\tau^_]
}
\]

**类型多态性**：

```wasm
block (result i32)
  br 0  ;; 栈可以是任意 [t*] ++ [i32]
  i32.const 42
end
```

---

### 1.4 Level 4: 引用验证

#### 1 函数引用

**约束**：
\[
\forall \text{funcidx} \in M : \text{funcidx} < |\text{funcs}|
\]

**示例**：

```wasm
(import "env" "log" (func $log (param i32)))
(func $main
  call 999  ;; 错误：索引越界
)
```

#### 2 表引用

**call_indirect**：
\[
\frac{
  C.\text{tables}[0] = \text{funcref} \quad C.\text{types}[x] = [\tau_1^_] \to [\tau_2^_]
}{
  C \vdash \text{call\_indirect} \; x : [\tau_1^_, \text{i32}] \to [\tau_2^_]
}
\]

**批判**：
> `call_indirect` 的类型检查是动态的，运行时可能陷阱。这打破了"验证即安全"的承诺，引入了隐藏的失败模式。

---

### 1.5 Level 5: 控制流完整性

#### 1 可达性分析

**Unreachable 传播**：
\[
\frac{
  C \vdash \text{unreachable} : [\tau_1^_] \to [\tau_2^_]
}{
  \forall \text{instr after unreachable} : \text{StackPolymorphic}
}
\]

**示例**：

```wasm
unreachable
i32.const 42  ;; 类型栈为 unreachable，此指令合法
```

#### 2 结束块验证

**End 匹配**：
\[
\forall \text{block/loop/if} : \exists \text{matching end}
\]

**栈多态性**：

```wasm
block (result i32)
  return     ;; 栈变为 unreachable
  ;; 后续指令不再类型检查
end
```

**批判**：
> 栈多态性简化了验证器实现，但掩盖了死代码。开发者可能误认为所有路径都执行，实际上某些分支永不可达。

---

## 2 验证算法实现

### 1 类型栈验证器

**伪代码**：

```python
class TypeStack:
    def __init__(self):
        self.stack = []
        self.polymorphic = False

    def push(self, ty):
        if not self.polymorphic:
            self.stack.append(ty)

    def pop(self, expected):
        if self.polymorphic:
            return expected
        if not self.stack:
            raise ValidationError("Empty stack")
        actual = self.stack.pop()
        if actual != expected:
            raise ValidationError(f"Type mismatch: {actual} vs {expected}")
        return actual

    def mark_unreachable(self):
        self.stack.clear()
        self.polymorphic = True
```

### 2.2 控制流栈

**Label 栈**：

```python
class ControlStack:
    def __init__(self):
        self.frames = []

    def push_label(self, arity, result_types):
        self.frames.append(Label(arity, result_types))

    def pop_label(self):
        if not self.frames:
            raise ValidationError("Unmatched end")
        return self.frames.pop()

    def get_label(self, depth):
        if depth >= len(self.frames):
            raise ValidationError("Label out of range")
        return self.frames[-(depth + 1)]
```

---

## 3 性能优化

### 1 快速路径

**常见模式**：

```c
// i32.add 验证
if (stack_size() < 2) goto error;
if (stack_top() != I32) goto error;
if (stack_second() != I32) goto error;
stack_pop();
// 栈顶已经是 i32，无需 push
```

### 3.2 批量验证

**指令块**：
\[
\text{Validate}([\text{i32.const}, \text{i32.const}, \text{i32.add}]) = \text{Single-Check}
\]

**批判**：
> 批量验证可提升 30% 性能，但增加了实现复杂度。浏览器供应商有动机优化，但小型 Runtime 可能无法承担。

---

## 4 常见验证错误

### 1 类型错误

**示例 1**：

```wasm
f32.const 1.0
i32.add        ;; 错误：期望 i32，得到 f32
```

**示例 2**：

```wasm
i32.const 10
drop
i32.add        ;; 错误：栈下溢
```

### 4.2 索引错误

**示例**：

```wasm
call 100       ;; 错误：函数不存在
local.get 999  ;; 错误：局部变量不存在
```

### 4.3 控制流错误

**示例**：

```wasm
block
  br 1         ;; 错误：标签深度越界
end
```

---

## 5 扩展提案的验证

### 1 Multi-Value

**新规则**：
\[
|\vec{\text{result}}| \geq 0 \quad (\text{无限制})
\]

**影响**：

- Block 可以返回多值
- 类型栈需要序列匹配

### 5.2 Reference Types

**新类型**：
\[
\text{reftype} ::= \text{funcref} \mid \text{externref}
\]

**空引用**：

```wasm
ref.null funcref
```

**验证**：
\[
C \vdash \text{ref.null} \; \tau : [] \to [\tau]
\]

### 5.3 Threads

**共享内存**：
\[
\text{memtype} := \langle \text{limits}, \text{shared} \rangle
\]

**原子指令**：

```wasm
i32.atomic.load  ;; 要求共享内存
```

**验证**：
\[
C.\text{mems}[0].\text{shared} = \text{true}
\]

---

## 6 批判性分析

### 1 验证成本

**时间复杂度**：
\[
O(|M| \cdot \log(|\text{types}|))
\]

**主导因素**：

- 类型栈操作：O(n)
- 控制流图：O(n log n)
- 引用解析：O(m log m)

### 6.2 验证局限

**无法检测的错误**：

1. 整数溢出
2. 除以零（整数）
3. 内存越界访问

**批判**：
> Wasm 的验证仅保证类型安全，不保证逻辑正确性。开发者需要额外的静态分析工具（如 KLEE、Infer）来捕获语义错误。

### 6.3 形式化保证

**已证明定理**：

- **Type Safety**：Progress + Preservation（Isabelle/HOL）
- **Memory Safety**：无缓冲区溢出（K 框架）

**未证明领域**：

- 并发正确性
- 侧信道安全

---

## 参考文献

1. **[Watt18]** Conrad Watt. "Mechanising and Verifying the WebAssembly Specification." CPP, 2018.
2. **[Rossberg21]** Andreas Rossberg. "WebAssembly Core Specification." W3C, 2021.
3. **[Chlipala]** Adam Chlipala. "Certified Programming with Dependent Types." MIT Press, 2013.

---

## 7 相关文档

- **[01.2 类型系统](../01_Foundational_Theory/01.2_Type_System.md)** - 类型理论基础
- **[01.3 验证模型](../01_Foundational_Theory/01.3_Verification_Model.md)** - 验证算法细节
- **[02.3 模块结构](02.3_Module_Structure.md)** - 结构验证规则
