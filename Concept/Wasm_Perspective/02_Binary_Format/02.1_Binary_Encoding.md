# 2.1 二进制编码 (Binary Encoding)

## 核心命题

**编码唯一性定理**：
\[
\forall M : \text{Module}, \exists! B : \text{bytes} \text{ s.t. } \text{decode}(B) = M
\]

**紧凑性原则**：
\[
|\text{encode}(M)|_{\text{Wasm}} \leq |\text{encode}(M)|_{\text{JSON}} \cdot 0.3
\]

**流式解码性**：
\[
\text{decode}(B_1 \parallel B_2) = \text{decode}(B_1) \oplus \text{decode}(B_2)
\]

---

## 文件格式结构

### Magic Number 与版本

**文件头**：

```
0x00 0x61 0x73 0x6D  // "\0asm"
0x01 0x00 0x00 0x00  // version 1
```

**版本策略**：

- 主版本号：破坏性变更
- 次版本号：保留（当前为 0）
- 向后兼容性通过新 section 实现

### Section 布局

**通用格式**：
\[
\text{Section} := \langle \text{ID}, \text{Size}, \text{Content} \rangle
\]

**Section ID 映射**：

```
0: Custom      (可选，可重复)
1: Type        (函数签名表)
2: Import      (导入声明)
3: Function    (函数类型索引)
4: Table       (表定义)
5: Memory      (线性内存定义)
6: Global      (全局变量)
7: Export      (导出声明)
8: Start       (启动函数索引)
9: Element     (表初始化)
10: Code       (函数体)
11: Data       (内存初始化)
12: DataCount  (数据段计数 - MVP 后引入)
```

**严格顺序约束**：
\[
\text{ID}(S_i) < \text{ID}(S_{i+1}) \quad (\text{除 Custom Section})
\]

---

## LEB128 编码

### 无符号 LEB128

**算法**：

```python
def encode_unsigned_leb128(value: int) -> bytes:
    result = []
    while True:
        byte = value & 0x7F
        value >>= 7
        if value != 0:
            byte |= 0x80  # 继续位
        result.append(byte)
        if value == 0:
            break
    return bytes(result)
```

**解码**：

```python
def decode_unsigned_leb128(data: bytes, offset: int) -> (int, int):
    result = 0
    shift = 0
    i = offset
    while True:
        byte = data[i]
        result |= (byte & 0x7F) << shift
        i += 1
        if (byte & 0x80) == 0:
            break
        shift += 7
    return result, i
```

**性质**：

- 小值优化：1 字节编码 0-127
- 无冗余：唯一编码
- 流式友好：自描述长度

### 有符号 LEB128

**符号扩展规则**：
\[
\text{value} = \begin{cases}
\text{raw} & \text{if bit}_6 = 0 \\
\text{raw} - 2^{7n} & \text{if bit}_6 = 1
\end{cases}
\]

**示例**：

```
0x7F => +127
0xFF 0x00 => +127 (冗余，规范拒绝)
0x7E => -2
```

---

## 类型编码

### Value Types

**编码表**：

```
0x7F: i32
0x7E: i64
0x7D: f32
0x7C: f64
0x7B: v128   (SIMD)
0x70: funcref
0x6F: externref
```

**设计批判**：
> 使用负数编码类型是为未来扩展预留正数空间，但导致类型解码需要符号处理，增加了验证器复杂度。

### Function Types

**结构**：
\[
\text{FuncType} := 0x60 \parallel \vec{\text{param}} \parallel \vec{\text{result}}
\]

**示例**：

```
[i32, i32] -> [i64]

编码:
0x60           // functype tag
0x02           // param count
0x7F 0x7F      // i32 i32
0x01           // result count
0x7E           // i64
```

---

## 指令编码

### 固定长度指令

**单字节指令**：

```
0x00: unreachable
0x01: nop
0x0B: end
0x45: i32.eqz
```

### 可变长度指令

**内存指令**：

```
i32.load {align: 2, offset: 8}

编码:
0x28           // opcode
0x02           // align (log2)
0x08           // offset (LEB128)
```

**分支指令**：

```
br_table [L0, L1, L2] default: L3

编码:
0x0E           // br_table opcode
0x03           // vector length
0x00 0x01 0x02 // label indices (LEB128)
0x03           // default label
```

---

## 代码段结构

### Function Body

**布局**：
\[
\text{Code} := \langle \text{size}, \vec{\text{locals}}, \vec{\text{instr}} \rangle
\]

**示例**：

```wasm
(func $add (param i32 i32) (result i32)
  (local i64)
  local.get 0
  local.get 1
  i32.add
)

编码:
// size (整个函数体字节数)
0x0A
// locals
0x01          // 局部变量声明数量
0x01 0x7E     // 1 个 i64
// instructions
0x20 0x00     // local.get 0
0x20 0x01     // local.get 1
0x6A          // i32.add
0x0B          // end
```

---

## 名称段 (Name Section)

### Custom Section 结构

**格式**：

```
Section ID: 0
Name: "name"
Payload:
  Subsection ID: 1 (function names)
  Size: ...
  Count: N
  [Index, UTF-8 Name]*
```

**用途**：

- 调试符号
- 反汇编友好
- 不影响执行语义

**设计权衡**：
> Name Section 可被嵌入器任意剥离，但这损害了可调试性。生产环境与开发环境的二进制可能完全不同，增加了排查难度。

---

## 模块验证

### 结构完整性

**不变量**：
\[
\begin{aligned}
&\forall i : \text{Function}[i].\text{type} < |\text{Type}| \\
&\forall i : \text{Export}[i].\text{index} < |\text{对应表}|
\end{aligned}
\]

### 字节对齐

**内存对齐语义**：

- `align` 参数是**提示**，非强制
- 未对齐访问合法但可能慢
- 验证器仅检查 `align ≤ \log_2(\text{natural alignment})`

**批判**：
> Wasm 的"软对齐"策略避免了 SIGBUS，但掩盖了性能陷阱。开发者误以为任意对齐都高效，实则在某些 ARM 芯片上触发模拟路径。

---

## 性能考量

### 解码热路径

**瓶颈**：

- LEB128 解码（80% 时间）
- 分支表验证（O(n²) 最坏）

**优化策略**：

```c
// 快速路径：一字节 LEB128
if (byte < 0x80) {
    return byte;
}
// 慢路径：多字节
return decode_multi_byte_leb128(data, offset);
```

### 流式编译窗口

**定理**：
\[
\text{StreamCompile}(B) \implies \max(\text{memory}) = O(\text{largest function})
\]

**实现**：

- Firefox: 64KB 分块
- Chrome: 逐函数编译

---

## 批判性分析

### 优势

1. **紧凑性**：比 JSON 小 3-5 倍
2. **验证速度**：单遍解码即可验证
3. **确定性**：唯一编码避免了签名问题

### 局限性

1. **调试性差**：二进制难以手动检查
2. **差异更新难**：缺乏结构化 diff
3. **版本升级僵化**：Section 顺序约束限制灵活性

### 设计反思

> Wasm 的二进制格式优化了"首次加载"场景，但牺牲了增量更新和热修复的便利性。对于需要频繁更新的边缘计算场景，缺乏块级哈希和结构化差异机制是重大缺陷。

---

## 参考文献

1. **[WebAssembly Spec]** Binary Format (https://webassembly.github.io/spec/core/binary/)
2. **[DWARF]** LEB128 Encoding Standard
3. **[Haas17]** Andreas Haas et al. "Bringing the Web up to Speed with WebAssembly." PLDI, 2017.
4. **[Rossberg]** Andreas Rossberg. "WebAssembly Specification." W3C, 2024.

---

## 相关文档

- **[02.2 文本格式](02.2_Text_Format.md)** - WAT 与 S-表达式
- **[02.3 模块结构](02.3_Module_Structure.md)** - Section 依赖关系
- **[01.3 验证模型](../01_Foundational_Theory/01.3_Verification_Model.md)** - 验证算法详解
