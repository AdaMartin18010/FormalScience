# 2.3 模块结构 (Module Structure)

## 目录

- [2.3 模块结构 (Module Structure)](#23-模块结构-module-structure)
  - [目录](#目录)
  - [核心命题](#核心命题)
  - [Section 类型详解](#section-类型详解)
    - [0. Custom Section](#0-custom-section)
    - [1. Type Section](#1-type-section)
    - [2. Import Section](#2-import-section)
    - [3. Function Section](#3-function-section)
    - [4. Table Section](#4-table-section)
    - [5. Memory Section](#5-memory-section)
    - [6. Global Section](#6-global-section)
    - [7. Export Section](#7-export-section)
    - [8. Start Section](#8-start-section)
    - [9. Element Section](#9-element-section)
    - [10. Code Section](#10-code-section)
    - [11. Data Section](#11-data-section)
    - [12. DataCount Section](#12-datacount-section)
  - [依赖关系图](#依赖关系图)
  - [模块实例化](#模块实例化)
    - [实例化步骤](#实例化步骤)
    - [失败处理](#失败处理)
  - [性能分析](#性能分析)
    - [验证成本](#验证成本)
    - [实例化成本](#实例化成本)
  - [批判性分析](#批判性分析)
    - [设计优势](#设计优势)
    - [设计缺陷](#设计缺陷)
    - [演化方向](#演化方向)
  - [参考文献](#参考文献)
  - [相关文档](#相关文档)

## 核心命题

**模块完整性定理**：
\[
\text{Valid}(M) \iff \forall \text{Ref} \in M : \text{Ref}.\text{target} \in M.\text{namespace}
\]

**最小模块**：
\[
M_{\min} := \langle \text{Magic}, \text{Version} \rangle \quad (8 \text{ bytes})
\]

**Section 依赖偏序**：
\[
\text{Import} \prec \text{Function} \prec \text{Export} \prec \text{Code}
\]

---

## Section 类型详解

### 0. Custom Section

**用途**：

- 调试信息（name, source map）
- 工具元数据（producers, build info）
- 任意应用数据

**结构**：
\[
\text{CustomSection} := \langle 0, \text{size}, \text{name}, \text{payload} \rangle
\]

**位置规则**：

- 可出现在任何 Section 之间
- 可重复
- 验证器**必须忽略**

**示例**：

```text
00           // section ID
0E           // size
04           // name length
6E 61 6D 65  // "name"
...          // payload
```

**批判**：
> Custom Section 的"忽略"语义导致了元数据碎片化。不同工具生成不兼容的 Custom Section，却无法被检测。缺乏标准化的元数据 schema 是生态系统的隐患。

---

### 1. Type Section

**内容**：
\[
\text{Types} := \vec{\text{FuncType}}
\]

**函数类型**：
\[
\text{FuncType} := 0x60 \parallel \vec{\text{valtype}}^{\text{params}} \parallel \vec{\text{valtype}}^{\text{results}}
\]

**示例**：

```wasm
(type $t0 (func (param i32) (result i32)))
(type $t1 (func (param i32 i32) (result i64)))
```

**编码**：

```text
01           // section ID
0A           // size
02           // type count

// Type 0: [i32] -> [i32]
60 01 7F 01 7F

// Type 1: [i32, i32] -> [i64]
60 02 7F 7F 01 7E
```

**类型去重**：
> 规范不要求类型去重，但实践中相同签名会被合并。这导致模块大小不可预测。

---

### 2. Import Section

**结构**：
\[
\text{Import} := \langle \text{module}, \text{name}, \text{importdesc} \rangle
\]

**导入描述符**：
\[
\text{ImportDesc} := \begin{cases}
\text{func} & : \text{typeidx} \\
\text{table} & : \text{tabletype} \\
\text{mem} & : \text{memtype} \\
\text{global} & : \text{globaltype}
\end{cases}
\]

**示例**：

```wasm
(import "env" "memory" (memory 1))
(import "wasi_snapshot_preview1" "fd_write"
  (func $fd_write (param i32 i32 i32 i32) (result i32)))
```

**索引分配**：
\[
\text{FuncIndex} := \text{ImportedFuncs} \parallel \text{LocalFuncs}
\]

**批判**：
> 导入的索引在本地定义之前分配，导致函数索引在导入变化时不稳定。这使得增量编译缓存失效，每次导入修改都需要重新验证整个模块。

---

### 3. Function Section

**内容**：
\[
\text{Functions} := \vec{\text{typeidx}}
\]

**语义**：

- 仅声明函数签名
- 函数体在 Code Section
- 长度必须与 Code Section 匹配

**验证规则**：
\[
|\text{FunctionSection}| = |\text{CodeSection}|
\]

**示例**：

```text
03           // section ID
03           // size
02           // function count
00 01        // typeidx 0, 1
```

**设计批判**：
> 分离 Function 和 Code Section 是为了流式编译，但增加了验证负担。必须缓存整个 Function Section 才能验证后续 Code，违背了"单遍"目标。

---

### 4. Table Section

**表类型**：
\[
\text{TableType} := \langle \text{limits}, \text{elemtype} \rangle
\]

**元素类型**：

- `funcref`：函数引用
- `externref`：外部引用（GC 提案）

**示例**：

```wasm
(table $t 10 20 funcref)
```

**编码**：

```text
04           // section ID
05           // size
01           // table count
70 01 0A 14  // funcref, flags=1(max), initial=10, max=20
```

**多表提案**：
> MVP 限制单个表，后续提案支持多表。但这破坏了"表索引=0"的假设，需要修改所有 `call_indirect` 的默认行为。

---

### 5. Memory Section

**内存类型**：
\[
\text{MemType} := \text{Limits}(2^{16} \text{ bytes/page})
\]

**限制**：

- MVP：单个线性内存
- 最大：65536 页（4GB）
- Memory64 提案：2^64 字节

**示例**：

```wasm
(memory 1 10)  ;; 初始 64KB，最大 640KB
```

**编码**：

```text
05           // section ID
03           // size
01           // memory count
01 01 0A     // flags=1(max), initial=1, max=10
```

---

### 6. Global Section

**全局变量**：
\[
\text{Global} := \langle \text{globaltype}, \text{init} \rangle
\]

**初始化表达式**：
\[
\text{InitExpr} \subseteq \{ \text{const}, \text{global.get} \}
\]

**示例**：

```wasm
(global $g (mut i32) (i32.const 42))
(global $h i64 (i64.const 0))
```

**可变性**：

- 导入的全局可以是可变的
- 导出的可变全局允许外部修改

**批判**：
> 可变全局打破了沙箱不变量。Host 可以在任意时刻修改全局，Wasm 代码无法防御。这在多租户环境中是安全漏洞。

---

### 7. Export Section

**导出**：
\[
\text{Export} := \langle \text{name}, \text{exportdesc} \rangle
\]

**导出描述符**：
\[
\text{ExportDesc} := \begin{cases}
\text{func} & : \text{funcidx} \\
\text{table} & : \text{tableidx} \\
\text{mem} & : \text{memidx} \\
\text{global} & : \text{globalidx}
\end{cases}
\]

**示例**：

```wasm
(export "add" (func $add))
(export "memory" (memory 0))
```

**名称唯一性**：
\[
\forall e_1, e_2 \in \text{Exports} : e_1.\text{name} \neq e_2.\text{name}
\]

---

### 8. Start Section

**启动函数**：
\[
\text{Start} := \text{funcidx}
\]

**约束**：
\[
\text{Type}(\text{Start}) = [] \to []
\]

**用途**：

- 全局初始化
- 构造函数逻辑
- 单次执行保证

**批判**：
> Start 函数在实例化时自动执行，但无法传递参数或返回值。复杂初始化需要依赖全局变量通信，破坏了函数式纯度。

---

### 9. Element Section

**元素段**：
\[
\text{Elem} := \langle \text{mode}, \text{tableidx}, \text{offset}, \vec{\text{funcidx}} \rangle
\]

**模式**：

- **Active**：实例化时自动初始化
- **Passive**：需手动 `table.init`
- **Declarative**：仅声明（用于验证）

**示例**：

```wasm
(elem (i32.const 0) $f1 $f2)
```

**间接调用**：
\[
\text{call\_indirect} \; \tau := \text{Table}[\text{pop}()] : \tau
\]

---

### 10. Code Section

**函数体**：
\[
\text{Code} := \langle \text{size}, \vec{\text{locals}}, \vec{\text{instr}} \rangle
\]

**局部变量压缩**：

```text
// 3 个 i32, 2 个 i64
02          // locals count
03 7F       // 3 × i32
02 7E       // 2 × i64
```

**指令流**：

- 以 `0x0B (end)` 终止
- 验证时需类型栈

**流式验证**：
\[
\text{Validate}(\text{Code}_i) \text{ depends on } \text{Type}[\text{Function}[i]]
\]

---

### 11. Data Section

**数据段**：
\[
\text{Data} := \langle \text{mode}, \text{memidx}, \text{offset}, \vec{\text{byte}} \rangle
\]

**模式**：

- **Active**：启动时复制到内存
- **Passive**：需手动 `memory.init`

**示例**：

```wasm
(data (i32.const 0) "Hello, Wasm!")
```

**安全性**：
\[
\text{offset} + |\text{data}| \leq \text{Memory.size}
\]

---

### 12. DataCount Section

**引入原因**：

- 批量内存提案需要预先知道数据段数量
- 优化流式编译

**内容**：
\[
\text{DataCount} := |\text{DataSection}|
\]

**批判**：
> DataCount Section 是后期补丁，破坏了"自描述"原则。验证器需要在看到 DataCount 之前假设数据段数量，导致两阶段验证。

---

## 依赖关系图

**Section 依赖**：

```text
Type ───→ Import
  │         │
  ↓         ↓
Function ←─ Import
  │
  ↓
Export → Code
         ↓
       Element → Table
       Data → Memory
```

**验证顺序**：
\[
\text{Type} \to \text{Import} \to \text{Function} \to \text{Table} \to \text{Memory} \to \ldots
\]

---

## 模块实例化

### 实例化步骤

1. **分配**：
   \[
   \text{Allocate}(M) := \langle \text{funcs}, \text{tables}, \text{mems}, \text{globals} \rangle
   \]

2. **链接**：
   \[
   \text{Link}(M, \text{imports}) := \text{resolve all importdesc}
   \]

3. **初始化**：
   - 执行 Global 初始化表达式
   - 复制 Element 段到 Table
   - 复制 Data 段到 Memory
   - 调用 Start 函数（如果有）

### 失败处理

**陷阱条件**：

- 数据段越界
- 元素段越界
- Start 函数陷阱

**原子性**：
\[
\text{Instantiate}(M) = \text{Success} \vee \text{Rollback}
\]

**批判**：
> 实例化失败后的回滚语义未明确定义。某些 Runtime 可能泄漏部分初始化的内存，导致安全漏洞。

---

## 性能分析

### 验证成本

**时间复杂度**：
\[
T_{\text{validate}} = O(|\text{Code}| \cdot \text{avg-function-size})
\]

**瓶颈**：

- 控制流图构建：O(n log n)
- 类型栈验证：O(n)
- 引用解析：O(m)（m = 引用数量）

### 实例化成本

**主导项**：
\[
T_{\text{instantiate}} \approx O(|\text{Data}| + |\text{Element}|)
\]

**优化**：

- Lazy 表初始化
- Copy-on-Write 数据段

---

## 批判性分析

### 设计优势

1. **流式友好**：Section 顺序支持管道化
2. **可扩展**：Custom Section 允许元数据
3. **紧凑**：二进制格式避免冗余

### 设计缺陷

1. **依赖脆弱**：导入变更导致全局索引失效
2. **验证冗余**：Function 和 Code 的分离需要二次遍历
3. **初始化陷阱**：数据段越界导致实例化失败

### 演化方向

**Component Model**：

- 模块间类型安全链接
- 接口版本管理
- 虚拟文件系统

**批判**：
> Component Model 试图解决 Wasm 的组合性问题，但引入了新的复杂度。是否应该在 Wasm 层面解决，还是留给上层编排工具（如 Docker Compose）？

---

## 参考文献

1. **[WebAssembly Spec]** Module Structure (https://webassembly.github.io/spec/core/binary/modules.html)
2. **[Rossberg]** Andreas Rossberg. "WebAssembly Specification." W3C, 2024.
3. **[Haas17]** Andreas Haas et al. "Bringing the Web up to Speed with WebAssembly." PLDI, 2017.

---

## 相关文档

- **[02.1 二进制编码](02.1_Binary_Encoding.md)** - Section 编码细节
- **[01.3 验证模型](../01_Foundational_Theory/01.3_Verification_Model.md)** - 模块验证算法
- **[03.2 WasmEdge 架构](../03_Runtime_Systems/03.2_WasmEdge_Architecture.md)** - 实例化实现
