# 3.3 浏览器集成 (Browser Integration)

## 目录

- [核心命题](#核心命题)
- [安全沙箱](#安全沙箱)
- [编译管道](#编译管道)
- [内存管理](#内存管理)
- [与 JavaScript 互操作](#与-javascript-互操作)
- [流式编译](#流式编译)
- [批判性分析](#批判性分析)

---

## 核心命题

### 主定理

**同源策略保证**：
\[
\forall M_{\text{wasm}} : \text{SameOrigin}(M, \text{host}) \vee \text{CORS-Allow}(M)
\]

**进程隔离定理**：
\[
\text{Wasm-Module} \in \text{Sandboxed-Process} \implies \neg \text{Access}(\text{Host-Memory})
\]

**性能目标**：
\[
\begin{align*}
T_{\text{streaming-compile}} &< \text{Download-Time} \\
\text{Perf}_{\text{peak}} &> 0.90 \times \text{native} \\
\text{Startup} &< 50\text{ms（中等模块）}
\end{align*}
\]

---

## 安全沙箱

### 进程架构

**多进程模型（Chromium）**：

```
┌──────────────────────────────────────┐
│       Browser Process (Trusted)       │
│  ┌─────────────────────────────────┐ │
│  │    Renderer Process (Sandboxed) │ │
│  │  ┌──────────────────────────┐   │ │
│  │  │  Wasm VM (Double-Boxed)  │   │ │
│  │  └──────────────────────────┘   │ │
│  └─────────────────────────────────┘ │
└──────────────────────────────────────┘
```

**隔离层次**：
\[
\text{Isolation} = \text{OS-Process} \wedge \text{Wasm-Sandbox} \wedge \text{Site-Isolation}
\]

### 系统调用限制

**Seccomp 白名单**（Linux）：

```c
// 仅允许的系统调用
允许: read, write, mmap, munmap, exit
禁止: open, socket, execve, ptrace, ...
```

**权限模型**：
\[
\text{Capability} = \emptyset \quad \text{（无文件系统、网络访问）}
\]

**通信通道**：
\[
\text{Wasm} \xleftrightarrow{\text{PostMessage}} \text{JavaScript} \xleftrightarrow{\text{IPC}} \text{Browser}
\]

### 内存隔离

**虚拟内存布局**：

```
0x0000_0000   ┌──────────────┐
              │  Guard Page  │  (trap on access)
0x0001_0000   ├──────────────┤
              │ Wasm Memory  │  (linear memory)
0x8000_0000   ├──────────────┤
              │  Guard Page  │
0x8001_0000   ├──────────────┤
              │   Code JIT   │  (W^X protection)
              └──────────────┘
```

**写保护（W^X）**：
\[
\forall \text{page} : (\text{Writable}(\text{page}) \implies \neg \text{Executable}(\text{page}))
\]

**边界检查**：

```c
// Explicit bounds check (baseline)
if (addr + size > memory.size) trap();

// Implicit check (optimized)
mprotect(guard_page, PROT_NONE); // hardware trap
```

---

## 编译管道

### V8 TurboFan 架构

**流程**：

```
Wasm Bytecode
    ↓
Liftoff (Baseline JIT) ──────→ 执行
    ↓ (热路径检测)
TurboFan (Optimizing JIT)
    ↓
Machine Code
    ↓
执行（峰值性能）
```

**Liftoff 特性**：

- 单遍编译
- 无 SSA 构建
- 简单寄存器分配

**编译速度**：
\[
T_{\text{Liftoff}} = O(n) \approx 8-10 \text{ MB/s}
\]

**TurboFan 优化**：
\[
\begin{align*}
&\text{1. 内联（Inlining）} \\
&\text{2. 逃逸分析（Escape Analysis）} \\
&\text{3. 边界检查消除（BCE）} \\
&\text{4. 寄存器分配（Linear Scan）}
\end{align*}
\]

**编译时间**：
\[
T_{\text{TurboFan}} = O(n \log n) \approx 50-100 \text{ ms/MB}
\]

### SpiderMonkey Baseline + Ion

**Baseline 特点**：

- 快速生成代码
- 类型反馈收集

**Ion 优化**：

- 类型特化（Type Specialization）
- 范围分析（Range Analysis）
- LICM（循环不变代码外提）

**性能对比**：

| 引擎 | Baseline | Optimized | 启动 |
|------|---------|-----------|------|
| **V8** | 60% | 92% | 5ms |
| **SpiderMonkey** | 55% | 88% | 8ms |
| **JavaScriptCore** | 50% | 85% | 12ms |

---

## 内存管理

### 线性内存

**分配策略**：

```javascript
// JavaScript API
const memory = new WebAssembly.Memory({
    initial: 256,  // 256 * 64KB = 16MB
    maximum: 512   // 512 * 64KB = 32MB
});
```

**增长语义**：
\[
\text{memory.grow}(n) : \text{size} \to \text{size} + n \times 64\text{KiB}
\]

**原子性保证**：
\[
\text{grow}(\text{mem}, n) \text{ is atomic} \quad \text{（所有线程看到一致状态）}
\]

### 共享内存

**创建**：

```javascript
const sharedMemory = new WebAssembly.Memory({
    initial: 1,
    maximum: 10,
    shared: true  // enables SharedArrayBuffer
});
```

**同步原语**：
\[
\begin{align*}
&\texttt{i32.atomic.load} : \text{Acquire 语义} \\
&\texttt{i32.atomic.store} : \text{Release 语义} \\
&\texttt{i32.atomic.rmw.add} : \text{Fetch-and-Add（原子）}
\end{align*}
\]

**Futex 支持**：

```wasm
;; Wait if value at addr equals expected
i32.atomic.wait (param addr expected timeout) (result status)

;; Wake n waiters
i32.atomic.notify (param addr n) (result woken_count)
```

### 垃圾回收（未来）

**GC 提案**：

```wasm
(type $Point (struct
  (field $x f64)
  (field $y f64)))

(func $distance (param $p (ref $Point)) (result f64)
  local.get $p
  struct.get $Point $x
  ;; ...
)
```

**集成策略**：
\[
\text{Wasm-GC} \subseteq \text{JS-GC} \quad \text{（统一堆）}
\]

**挑战**：

- 周期检测
- 跨语言引用
- 性能开销

---

## 与 JavaScript 互操作

### 函数导入/导出

**JavaScript 调用 Wasm**：

```javascript
const wasmModule = await WebAssembly.instantiateStreaming(
    fetch('module.wasm'),
    {
        env: {
            log: (x) => console.log(x)  // 导入函数
        }
    }
);

const result = wasmModule.instance.exports.add(10, 20);
```

**Wasm 调用 JavaScript**：

```wasm
(import "env" "log" (func $log (param i32)))

(func $test
  i32.const 42
  call $log  ;; 调用 JS 函数
)
```

**调用开销**：
\[
C_{\text{JS→Wasm}} \approx 20-50 \text{ns} \quad \text{（优化后）}
\]

### 类型转换

**自动转换表**：

| Wasm 类型 | JS 类型 | 转换规则 |
|-----------|---------|---------|
| `i32` | `Number` | ToInt32 |
| `i64` | `BigInt` | ToBigInt64 |
| `f32/f64` | `Number` | ToNumber |
| `funcref` | `Function` | 包装器 |
| `externref` | `Object` | 直接引用 |

**性能陷阱**：
\[
\text{BigInt-Conversion} \approx 10\times \text{slower than i32}
\]

### 内存共享

**SharedArrayBuffer 接口**：

```javascript
const memory = new WebAssembly.Memory({
    initial: 1,
    shared: true
});

const buffer = memory.buffer;  // SharedArrayBuffer
const view = new Uint8Array(buffer);
```

**并发控制**：

```javascript
// Atomics API (JavaScript side)
Atomics.store(view, index, value);
Atomics.load(view, index);
Atomics.wait(view, index, expected);
Atomics.notify(view, index, count);
```

---

## 流式编译

### 背景问题

**串行瓶颈**：

```
Download (1000ms)
    ↓
Compile (200ms)
    ↓
Execute
```

**总延迟**：
\[
T_{\text{total}} = T_{\text{download}} + T_{\text{compile}} = 1200\text{ms}
\]

### 流式解决方案

**并行流水线**：

```
Download ────────────────────→
    ↓        ↓        ↓        ↓
Compile  ────────→
    ↓        ↓
Execute
```

**延迟降低**：
\[
T_{\text{streaming}} \approx \max(T_{\text{download}}, T_{\text{compile}}) \approx 1000\text{ms}
\]

### 实现机制

**分块编译**：

```javascript
const response = await fetch('large.wasm');
const result = await WebAssembly.instantiateStreaming(response);
```

**内部流程**：

1. 接收前 8 字节（魔数验证）
2. 解析 Type 段 → 开始编译
3. 解析 Function 段 → 并行编译函数体
4. 下载完成前，多数函数已编译

**性能模型**：
\[
T_{\text{overlap}} = T_{\text{download}} - \sum_{i} \min(T_{\text{compile}}^i, T_{\text{download}}^i)
\]

**实测收益**：
\[
\text{Latency-Reduction} \approx 30-70\% \quad \text{（取决于网络速度）}
\]

---

## 性能优化

### 内联缓存（IC）

**问题**：
\[
\texttt{call\_indirect}(i) \text{ 需运行时类型检查}
\]

**优化**：

```c
// Monomorphic IC
if (likely(table[i].type == expected_type)) {
    return table[i].target;  // fast path
} else {
    return slow_check(i);     // slow path
}
```

**加速比**：
\[
\text{IC-Hit} : 5 \text{cycles} \quad \text{vs} \quad \text{Full-Check} : 30 \text{cycles}
\]

### Tier-Up 策略

**触发条件**：
\[
\text{Tier-Up}(f) \iff \text{CallCount}(f) > \theta \vee \text{LoopCount}(f) > \theta_{\text{loop}}
\]

**典型阈值**：
\[
\begin{align*}
\theta_{\text{function}} &= 1000 \\
\theta_{\text{loop}} &= 10000
\end{align*}
\]

**后台编译**：

```
Main Thread:  Execute Baseline Code
Background:   TurboFan Optimize
    ↓ (完成后)
Main Thread:  Swap to Optimized Code
```

### SIMD 自动向量化

**检测模式**：

```wasm
;; Scalar loop
(loop $i
  local.get $ptr
  i32.load
  i32.const 2
  i32.mul
  local.get $ptr
  i32.store
  ...
)
```

**向量化后**：

```wasm
;; SIMD (v128)
(loop $i
  local.get $ptr
  v128.load
  i32x4.const 2 2 2 2
  i32x4.mul
  local.get $ptr
  v128.store
  ...
)
```

**加速比**：
\[
\text{Speedup}_{\text{SIMD}} \approx 4\times \quad \text{（理想情况）}
\]

---

## 批判性分析

### 双重沙箱的代价

**命题**：
\[
\text{Security} = \text{Process-Isolation} + \text{Wasm-Sandbox}
\]

**成本**：
\[
\begin{align*}
\text{Memory-Overhead} &\approx 10-30\text{MB/Process} \\
\text{IPC-Latency} &\approx 1-5\text{ms} \\
\text{Context-Switch} &\approx 2-10\mu\text{s}
\end{align*}
\]

**批判**：
> 多进程架构是"矫枉过正"：为防御极端攻击，付出了普遍的性能代价。单进程 + 强沙箱可能是更优解（如 Deno）。

### 流式编译的局限

**网络条件依赖**：
\[
\text{Benefit}_{\text{streaming}} \propto \frac{T_{\text{download}}}{T_{\text{compile}}}
\]

**快速网络场景**：
\[
\frac{100\text{ms}}{200\text{ms}} = 0.5 \implies \text{收益有限}
\]

**批判**：
> 流式编译优化了"下载慢、编译快"场景，但无法解决"下载快、编译慢"（大型复杂模块）。

### JavaScript 互操作的陷阱

**类型转换开销**：

```javascript
// 高频调用场景（反模式）
for (let i = 0; i < 1000000; i++) {
    wasmModule.exports.process(i);  // 每次调用 50ns 开销
}
```

**优化建议**：

```javascript
// 批量处理（正确模式）
const inputPtr = wasmModule.exports.allocate(1000000 * 4);
// ... 写入数据到 Wasm 内存
wasmModule.exports.processBatch(inputPtr, 1000000);
```

**批判**：
> JS-Wasm 边界是"微服务边界"：跨越成本高。设计应最小化跨越次数，而非单次调用速度。

---

## 实证数据

### 编译性能（V8）

| 模块大小 | Liftoff | TurboFan | 流式 |
|---------|---------|----------|------|
| **100KB** | 10ms | 50ms | 10ms |
| **1MB** | 100ms | 500ms | 150ms |
| **10MB** | 1000ms | 5000ms | 1800ms |

### 执行性能（相对 Native）

| 测试 | Baseline | Optimized |
|------|---------|-----------|
| **计算密集** | 0.55× | 0.92× |
| **内存密集** | 0.60× | 0.85× |
| **调用密集** | 0.40× | 0.70× |

---

## 未来方向

### 1. 组件模型集成

```javascript
import { component } from 'wasm-component';
```

### 2. WebGPU 集成

```wasm
(import "webgpu" "compute"
  (func $compute (param buffer) (result buffer)))
```

### 3. 零成本异常

- 替代 trap 机制
- 降低错误处理开销

---

## 参考文献

1. **[V8]** V8 WebAssembly Compiler. https://v8.dev/docs/wasm-compilation-pipeline
2. **[SpiderMonkey]** Mozilla SpiderMonkey. https://spidermonkey.dev/
3. **[Reis19]** Charles Reis et al. "Site Isolation: Process Separation for Web Sites." USENIX Security, 2019.

---

**结论**：
> 浏览器中的 Wasm 是"安全优先"的设计典范：多层沙箱、流式编译、进程隔离，每一项都是性能与安全的精密权衡。它证明了高性能与强安全并非不可兼得，但也揭示了这种兼得的高昂成本——复杂性、内存、延迟，无一幸免。
