# 4.3 内存共享 (Memory Sharing)

## 目录

- [4.3 内存共享 (Memory Sharing)](#43-内存共享-memory-sharing)
  - [目录](#目录)
  - [核心命题](#核心命题)
    - [主定理](#主定理)
  - [线性内存模型](#线性内存模型)
    - [基本结构](#基本结构)
    - [内存布局](#内存布局)
  - [共享内存语义](#共享内存语义)
    - [SharedArrayBuffer 基础](#sharedarraybuffer-基础)
    - [内存模型](#内存模型)
    - [同步语义](#同步语义)
  - [零拷贝技术](#零拷贝技术)
    - [直接内存访问](#直接内存访问)
    - [Bulk Memory Operations](#bulk-memory-operations)
    - [DMA 与外设](#dma-与外设)
  - [内存导入导出](#内存导入导出)
    - [内存导出](#内存导出)
    - [内存导入](#内存导入)
  - [性能分析](#性能分析)
    - [内存访问延迟](#内存访问延迟)
    - [内存带宽](#内存带宽)
  - [批判性分析](#批判性分析)
    - [共享内存的复杂性](#共享内存的复杂性)
    - [线性内存的局限](#线性内存的局限)
    - [零拷贝的安全隐患](#零拷贝的安全隐患)
  - [实践案例](#实践案例)
    - [案例1：图像处理（零拷贝）](#案例1图像处理零拷贝)
    - [案例2：多模块共享内存](#案例2多模块共享内存)
  - [未来方向](#未来方向)
    - [1. Memory64](#1-memory64)
    - [2. 多内存](#2-多内存)
    - [3. 自定义页大小](#3-自定义页大小)
  - [参考文献](#参考文献)

---

## 核心命题

### 主定理

**线性内存隔离定理**：
\[
\forall M_1, M_2 : \text{LinearMemory}(M_1) \cap \text{LinearMemory}(M_2) = \emptyset
\]
_默认情况下，模块内存完全隔离。_

**共享内存可选性**：
\[
\text{SharedMemory} \subseteq \text{LinearMemory} \wedge \text{requires-explicit-opt-in}
\]

**零拷贝定理**：
\[
\exists \text{SharedBuffer} : \text{Wasm} \xleftrightarrow{\text{pointer}} \text{Host}
\implies C_{\text{copy}} = 0
\]

---

## 线性内存模型

### 基本结构

**定义**：
\[
\text{Memory} = (\text{min-pages}, \text{max-pages}, \text{shared-flag})
\]

**页大小**：
\[
\text{PageSize} = 64\text{KiB} = 65536 \text{ bytes}
\]

**地址空间**：
\[
\text{AddressSpace} = [0, \text{current-size})
\]

**增长语义**：
\[
\text{memory.grow}(n) : \text{size} \to
\begin{cases}
\text{size} + n & \text{if success} \\
\text{size} & \text{if fail (返回 -1)}
\end{cases}
\]

### 内存布局

**典型布局**：

```
0x0000_0000  ┌────────────────────┐
             │  Null Guard         │  (避免空指针)
0x0000_1000  ├────────────────────┤
             │  .data (全局数据)   │
0x0001_0000  ├────────────────────┤
             │  Heap (动态分配)    │
0x0080_0000  ├────────────────────┤
             │  Stack (向下增长)   │
0x00FF_FFFF  └────────────────────┘
```

**内存初始化**：

```wasm
(memory 1)  ;; 初始 1 页
(data (i32.const 0x1000) "Hello")  ;; 数据段
```

**形式化**：
\[
\text{Initialize}(\text{mem}, \text{offset}, \text{data}) : \forall i \in [0, |\text{data}|) : \text{mem}[\text{offset} + i] = \text{data}[i]
\]

---

## 共享内存语义

### SharedArrayBuffer 基础

**声明共享内存**：

```wasm
(memory 1 10 shared)  ;; 初始1页，最大10页，共享
```

**JavaScript 视图**：

```javascript
const memory = new WebAssembly.Memory({
    initial: 1,
    maximum: 10,
    shared: true  // 对应 SharedArrayBuffer
});

const buffer = memory.buffer;  // SharedArrayBuffer
const view = new Int32Array(buffer);
```

**约束**：
\[
\text{Shared-Memory} \implies \exists \text{maximum} \quad \text{（必须有上界）}
\]

### 内存模型

**C++11 内存模型适配**：
\[
\text{Wasm-Memory-Order} \subseteq \text{C++11-Memory-Order}
\]

**支持的顺序**：

- `SeqCst`（顺序一致）
- `AcqRel`（获取-释放）

**不支持**：

- `Relaxed`（过于复杂，未纳入 MVP）

**原子操作**：

```wasm
;; 原子加载
i32.atomic.load (param addr) (result i32)

;; 原子存储
i32.atomic.store (param addr i32)

;; 原子 RMW
i32.atomic.rmw.add (param addr i32) (result i32)
i32.atomic.rmw.cmpxchg (param addr expected desired) (result i32)
```

### 同步语义

**Happens-Before 关系**：
\[
\text{Store}(a, v) \xrightarrow{\text{hb}} \text{Load}(a) \implies \text{Load}(a) \text{ 看到 } v
\]

**顺序一致性保证**：
\[
\forall \text{ops} : \exists \text{total-order} : \text{consistent}(\text{total-order})
\]

**示例**（Peterson 锁）：

```wasm
;; 线程 1
i32.const 1
i32.store $flag1         ;; flag1 = 1
i32.const 0
i32.store $turn          ;; turn = 0
(loop $spin
  i32.load $flag2
  i32.load $turn
  i32.and
  br_if $spin)           ;; while (flag2 && turn == 0)
;; 临界区
i32.const 0
i32.store $flag1         ;; flag1 = 0
```

**正确性保证**：
\[
\text{SeqCst} \implies \text{MutualExclusion}
\]

---

## 零拷贝技术

### 直接内存访问

**问题**：数据拷贝开销

```
Host Data → Copy → Wasm Memory → Process → Copy → Host Result
    (5ms)            (10ms)           (2ms)
```

**零拷贝方案**：

```
Host Data → Pointer → Wasm (direct access)
    (0ms)               (10ms)
```

**实现**：

```rust
// Rust 宿主
fn process_buffer(
    mut caller: Caller<'_, ()>,
    ptr: i32,
    len: i32
) -> i32 {
    let memory = caller.get_export("memory")
        .unwrap()
        .into_memory()
        .unwrap();

    // 直接访问 Wasm 内存（零拷贝）
    let data = memory.data_mut(&mut caller);
    let slice = &mut data[ptr as usize..(ptr + len) as usize];

    // 原地处理
    for byte in slice.iter_mut() {
        *byte = byte.wrapping_add(1);
    }

    0  // success
}
```

**性能对比**：
\[
\begin{align*}
T_{\text{copy}} &= 2 \times \frac{\text{size}}{\text{memcpy-bandwidth}} \approx 10\text{ms (1MB)} \\
T_{\text{zero-copy}} &= 0\text{ms}
\end{align*}
\]

### Bulk Memory Operations

**提案背景**：高效内存操作

```wasm
;; 传统方式（循环拷贝，慢）
(loop $copy
  local.get $dst
  local.get $src
  i32.load8_u
  i32.store8
  ;; 递增指针
  br_if $copy
)

;; Bulk-ops（一条指令，快）
local.get $dst
local.get $src
i32.const $len
memory.copy  ;; 等价 memcpy
```

**指令**：
\[
\begin{align*}
&\texttt{memory.copy} : (\text{dst}, \text{src}, \text{len}) \\
&\texttt{memory.fill} : (\text{dst}, \text{val}, \text{len}) \\
&\texttt{memory.init} : (\text{dst}, \text{data-idx}, \text{offset}, \text{len})
\end{align*}
\]

**性能提升**：
\[
\text{Speedup}_{\text{bulk}} \approx 10-100\times \quad \text{（vs 循环）}
\]

### DMA 与外设

**场景**：嵌入式系统直接访问硬件

```c
// 宿主提供 DMA 映射
uint8_t* dma_buffer = map_dma_region();

// Wasm 可直接访问（通过共享内存）
void wasm_dma_write(int32_t offset, int32_t value) {
    dma_buffer[offset] = value;  // 直接写入硬件
}
```

**约束**：
\[
\text{Safety} : \text{DMA-Region} \subseteq \text{Wasm-Memory}
\]

---

## 内存导入导出

### 内存导出

**Wasm 模块导出内存**：

```wasm
(module
  (memory (export "mem") 1)  ;; 导出内存

  (func (export "alloc") (param $size i32) (result i32)
    ;; 实现内存分配器
    ...
  )
)
```

**JavaScript 访问**：

```javascript
const instance = await WebAssembly.instantiate(wasmBytes);
const memory = instance.exports.mem;
const buffer = memory.buffer;  // ArrayBuffer

// 分配并写入
const ptr = instance.exports.alloc(100);
const view = new Uint8Array(buffer, ptr, 100);
view.set([1, 2, 3, 4]);
```

**用途**：

- 宿主读取 Wasm 计算结果
- 宿主准备 Wasm 输入数据

### 内存导入

**宿主提供内存**：

```javascript
// 宿主创建内存
const memory = new WebAssembly.Memory({
    initial: 10,
    maximum: 100
});

// Wasm 导入内存
const instance = await WebAssembly.instantiate(wasmBytes, {
    env: { memory }  // 传入内存
});
```

**Wasm 端**：

```wasm
(module
  (import "env" "memory" (memory 10))  ;; 导入内存

  (func $use_memory
    i32.const 0
    i32.load  ;; 访问导入的内存
  )
)
```

**多模块共享**：
\[
\text{Module}_1, \text{Module}_2 \xrightarrow{\text{import}} \text{SharedMemory}
\]

**应用**：

- 模块间通信
- 避免跨边界拷贝

---

## 性能分析

### 内存访问延迟

**层次**：
\[
\begin{align*}
\text{L1-Cache} &: 4 \text{ cycles} \\
\text{L2-Cache} &: 12 \text{ cycles} \\
\text{L3-Cache} &: 36 \text{ cycles} \\
\text{DRAM} &: 200 \text{ cycles}
\end{align*}
\]

**Wasm vs Native 对比**：

| 操作 | Native | Wasm | 开销 |
|------|--------|------|------|
| **i32.load (L1)** | 4 cycles | 4-5 cycles | ~0% |
| **i32.store** | 4 cycles | 5-6 cycles | ~25% |
| **边界检查** | - | 3 cycles | 额外开销 |

**显式边界检查**：

```wasm
;; 编译器生成
local.get $addr
i32.const 4
i32.add
memory.size
i32.const 65536
i32.mul
i32.gt_u
br_if $trap  ;; if (addr + 4 > mem_size) trap
```

**隐式陷阱（优化）**：

```rust
// 使用虚拟内存保护
mprotect(guard_pages, PROT_NONE);  // 守卫页不可访问
// 访问越界 → SIGSEGV → 转换为 Wasm Trap
```

**性能提升**：
\[
\text{Implicit} : 0 \text{ cycles} \quad \text{vs} \quad \text{Explicit} : 3 \text{ cycles}
\]

### 内存带宽

**顺序访问**：
\[
\text{Bandwidth}_{\text{sequential}} \approx 20-30 \text{ GB/s} \quad \text{（DDR4）}
\]

**随机访问**：
\[
\text{Bandwidth}_{\text{random}} \approx 2-5 \text{ GB/s} \quad \text{（TLB miss）}
\]

**Wasm 影响**：

- 线性内存布局 → 有利顺序访问
- 无指针运算 → 减少随机访问

---

## 批判性分析

### 共享内存的复杂性

**命题**：
\[
\text{SharedMemory} \implies \text{Complexity}_{\text{concurrency}}
\]

**问题**：

1. **数据竞争**：难以调试
2. **内存顺序**：程序员难理解
3. **性能陷阱**：False Sharing

**False Sharing 示例**：

```wasm
;; 两个线程访问相邻变量（同一缓存行）
thread1: i32.store $var1  ;; offset 0
thread2: i32.store $var2  ;; offset 4（同一缓存行！）

;; 性能下降 10×（缓存行乒乓）
```

**批判**：
> SharedArrayBuffer 是"潘多拉魔盒"：释放了性能，也释放了并发 bug。JavaScript 社区在 Spectre 后暂停它非偶然。

### 线性内存的局限

**32 位地址限制**：
\[
|\text{Memory}| \leq 2^{32} = 4\text{GiB}
\]

**后果**：

- 大数据场景受限
- 需分段处理

**Memory64 提案**：
\[
|\text{Memory}| \leq 2^{64} \quad \text{（理论上）}
\]

**挑战**：

- 指针大小翻倍 → 内存占用↑
- 索引计算变慢（64 位运算）

**批判**：
> 4GB 限制是"工程妥协"：99% 场景够用，但 1% 极端场景无解。这是最小可行规范（MVP）的代价。

### 零拷贝的安全隐患

**问题**：悬空指针

```rust
let mut buffer = vec![0u8; 1000];
let ptr = buffer.as_mut_ptr();

// 传给 Wasm
wasm_process(ptr, 1000);

// 危险：buffer 可能已被移动/释放！
drop(buffer);
// ptr 现在是悬空指针
```

**解决方案**：Pin

```rust
use std::pin::Pin;

let buffer = Box::pin(vec![0u8; 1000]);
let ptr = buffer.as_ptr();  // 固定地址
```

**批判**：
> 零拷贝是"安全的放弃"：为了性能，将内存安全责任转移给用户。这是 Rust 哲学的延续。

---

## 实践案例

### 案例1：图像处理（零拷贝）

**架构**：

```
JavaScript (Canvas ImageData)
    ↓ (传递 SharedArrayBuffer)
Wasm (SIMD 处理)
    ↓ (原地修改)
JavaScript (显示结果)
```

**性能数据**：

- 图像大小：1920×1080 RGBA
- 拷贝版本：150ms（2×拷贝 + 处理）
- 零拷贝版本：50ms（纯处理）
- 提升：3×

### 案例2：多模块共享内存

**场景**：编解码流水线

```
[Demuxer Module] → Shared Memory → [Decoder Module] → Shared Memory → [Renderer Module]
```

**配置**：

```javascript
const sharedMemory = new WebAssembly.Memory({
    initial: 100,
    maximum: 500,
    shared: true
});

const demuxer = await instantiate(demuxerWasm, { env: { memory: sharedMemory } });
const decoder = await instantiate(decoderWasm, { env: { memory: sharedMemory } });
const renderer = await instantiate(rendererWasm, { env: { memory: sharedMemory } });
```

**收益**：

- 零拷贝传递
- 流水线并行
- 吞吐提升 4×

---

## 未来方向

### 1. Memory64

```wasm
(memory i64 1 1000)  ;; 64 位索引
i64.load (param i64) (result i64)
```

### 2. 多内存

```wasm
(memory $heap 10)
(memory $stack 1)
$heap.load ...
$stack.load ...
```

### 3. 自定义页大小

```wasm
(memory 1 (page-size 4096))  ;; 4KB 页（vs 64KB）
```

---

## 参考文献

1. **[Wasm-Threads]** WebAssembly. "Threads Proposal." https://github.com/WebAssembly/threads
2. **[BulkMemory]** WebAssembly. "Bulk Memory Operations." https://github.com/WebAssembly/bulk-memory-operations
3. **[Boehm08]** Hans-J. Boehm. "Foundations of the C++ Concurrency Memory Model." PLDI, 2008.

---

**结论**：
> 内存共享是 Wasm 性能优化的"核武器"：威力巨大，但使用需谨慎。零拷贝消除了开销，共享内存解锁了并发，但两者都打破了沙箱的完美隔离。性能与安全，再次在边界处妥协。
