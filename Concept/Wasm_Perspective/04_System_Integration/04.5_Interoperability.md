# 4.5 Interoperability

> **子主题编号**: 04.5
> **主题**: Wasm视角

## 目录

- [4.5 互操作性 (Interoperability)](#45-互操作性-interoperability)
  - [目录](#目录)
  - [1 核心命题](#1-核心命题)
    - [1 主定理](#1-主定理)
  - [2 语言绑定](#2-语言绑定)
    - [1 C/C++ ↔ Wasm](#1-cc--wasm)
    - [2.2 Rust ↔ Wasm](#22-rust--wasm)
    - [2.3 JavaScript ↔ Wasm](#23-javascript--wasm)
    - [2.4 Go ↔ Wasm](#24-go--wasm)
  - [3 接口类型提案](#3-接口类型提案)
    - [1 动机](#1-动机)
    - [3.2 WIT (WebAssembly Interface Types)](#32-wit-webassembly-interface-types)
  - [4 组件模型](#4-组件模型)
    - [1 概念](#1-概念)
    - [4.2 WIT 定义](#42-wit-定义)
    - [4.3 实例化](#43-实例化)
  - [5 工具链集成](#5-工具链集成)
    - [1 wit-bindgen](#1-wit-bindgen)
    - [5.2 wasm-tools](#52-wasm-tools)
    - [5.3 虚拟化（Virtualization）](#53-虚拟化virtualization)
  - [6 性能分析](#6-性能分析)
    - [1 类型转换开销](#1-类型转换开销)
    - [6.2 组件链接开销](#62-组件链接开销)
  - [7 批判性分析](#7-批判性分析)
    - [1 接口类型的复杂性](#1-接口类型的复杂性)
    - [7.2 组件模型的野心](#72-组件模型的野心)
    - [7.3 语言绑定的碎片化](#73-语言绑定的碎片化)
  - [8 实践案例](#8-实践案例)
    - [1 案例1：Rust + JavaScript（wasm-bindgen）](#1-案例1rust--javascriptwasm-bindgen)
    - [8.2 案例2：多语言组件组合](#82-案例2多语言组件组合)
  - [9 未来方向](#9-未来方向)
    - [1 . 异步接口](#1--异步接口)
    - [2 . 流式处理](#2--流式处理)
    - [3 . 资源类型](#3--资源类型)
  - [参考文献](#参考文献)

---

## 1 核心命题

### 1 主定理

**通用二进制接口定理**：
\[
\forall L_1, L_2 : \exists \text{Wasm-ABI} : L_1 \xrightarrow{\text{compile}} \text{Wasm} \xleftarrow{\text{compile}} L_2
\]

**类型系统鸿沟**：
\[
\text{Rich-Type-System} \xrightarrow{\text{lower}} \{\texttt{i32}, \texttt{i64}, \texttt{f32}, \texttt{f64}\}
\]

**多语言兼容性目标**：
\[
\text{Interop-Cost} = O(1) \quad \text{（常量开销）}
\]

---

## 2 语言绑定

### 1 C/C++ ↔ Wasm

**编译工具链**：

```bash
# Emscripten
emcc source.c -o output.wasm -s STANDALONE_WASM

# WASI SDK
clang --target=wasm32-wasi source.c -o output.wasm

# Clang + wasm-ld
clang --target=wasm32 -c source.c
wasm-ld -o output.wasm source.o
```

**导出函数**：

```c
// C 代码
__attribute__((export_name("add")))
int add(int a, int b) {
    return a + b;
}
```

**编译后 Wasm**：

```wasm
(func $add (export "add") (param i32 i32) (result i32)
  local.get 0
  local.get 1
  i32.add
)
```

**类型映射**：

| C/C++ | Wasm |
|-------|------|
| `int32_t` | `i32` |
| `int64_t` | `i64` |
| `float` | `f32` |
| `double` | `f64` |
| `T*` | `i32`（线性内存偏移）|
| `struct` | 内存布局 + 指针 |

### 2.2 Rust ↔ Wasm

**编译目标**：

```bash
# 浏览器目标
rustc --target wasm32-unknown-unknown

# WASI 目标
rustc --target wasm32-wasi
```

**wasm-bindgen**（浏览器互操作）：

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn greet(name: &str) -> String {
    format!("Hello, {}!", name)
}

#[wasm_bindgen]
extern "C" {
    fn alert(s: &str);  // 导入 JavaScript 函数
}
```

**生成的胶水代码**：

```javascript
export function greet(name) {
    const ptr0 = passStringToWasm(name);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.greet(ptr0, len0);
    return takeString FromWasm(ret);
}
```

**性能开销**：
\[
\begin{align*}
C_{\text{type-conversion}} &\approx 50\text{ns/call} \\
C_{\text{string-copy}} &\approx \frac{\text{len}}{10\text{GB/s}}
\end{align*}
\]

### 2.3 JavaScript ↔ Wasm

**AssemblyScript**（TypeScript 子集）：

```typescript
// AssemblyScript
export function fibonacci(n: i32): i32 {
    if (n < 2) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

**编译**：

```bash
asc fibonacci.ts -o fibonacci.wasm
```

**类型对应**：

| AssemblyScript | Wasm | JavaScript |
|---------------|------|-----------|
| `i32` | `i32` | `Number` |
| `i64` | `i64` | `BigInt` |
| `f64` | `f64` | `Number` |
| `string` | `(ptr, len)` | `String` |

**批判**：
> AssemblyScript 是"JavaScript 程序员的 Wasm 入口"，但类型限制严格。它证明了"类似 JS 的语法 ≠ JS 语义"。

### 2.4 Go ↔ Wasm

**编译**：

```bash
GOOS=js GOARCH=wasm go build -o main.wasm
```

**导出函数（需 syscall/js）**：

```go
package main

import (
    "syscall/js"
)

func add(this js.Value, args []js.Value) interface{} {
    return args[0].Int() + args[1].Int()
}

func main() {
    js.Global().Set("add", js.FuncOf(add))
    select {}  // 保持运行
}
```

**问题**：
\[
\begin{align*}
\text{Binary-Size} &\approx 2\text{MB}（包含 Go runtime）\\
\text{Startup-Time} &\approx 50\text{ms}
\end{align*}
\]

**TinyGo 替代**：

```bash
tinygo build -o main.wasm -target wasm
```

**优势**：
\[
\begin{align*}
\text{Binary-Size} &\approx 50\text{KB} \\
\text{Startup-Time} &\approx 1\text{ms}
\end{align*}
\]

**批判**：
> Go 的 Wasm 支持是"勉强可用"：runtime 膨胀严重，GC 开销大。TinyGo 是实用选择，但限制多（如无反射）。

---

## 3 接口类型提案

### 1 动机

**问题**：当前类型系统贫乏
\[
\text{Wasm-Types} = \{\texttt{i32}, \texttt{i64}, \texttt{f32}, \texttt{f64}\}
\]

**后果**：

- 字符串需 `(ptr, len)` 传递
- 结构体需序列化
- 对象引用需句柄管理

**目标**：
\[
\text{Interface-Types} = \text{Wasm-Types} \cup \{\text{string}, \text{list}, \text{record}, \text{variant}, \ldots\}
\]

### 3.2 WIT (WebAssembly Interface Types)

**语法**：

```wit
// 类型定义
record point {
    x: f32,
    y: f32,
}

variant option<T> {
    some(T),
    none,
}

// 函数签名
interface math {
    add: func(a: s32, b: s32) -> s32
    sqrt: func(x: f64) -> f64
    parse-point: func(s: string) -> result<point, string>
}
```

**编译策略**：
\[
\text{WIT} \xrightarrow{\text{lower}} \text{Wasm Core Types} + \text{Adapter Functions}
\]

**示例转换**：

```wit
parse-point: func(s: string) -> result<point, string>

↓ (lowering)

parse-point-lowered: func(
    s_ptr: i32,
    s_len: i32,
    ret_ptr: i32   // 输出参数
) -> i32  // 0=ok, 1=err
```

**适配器生成**：

```wasm
(func $parse-point-adapter (param $s_ptr i32) (param $s_len i32) (result i32)
  ;; 分配返回值空间
  i32.const 12  ;; sizeof(result<point, string>)
  call $malloc
  local.set $ret_ptr

  ;; 调用核心函数
  local.get $s_ptr
  local.get $s_len
  local.get $ret_ptr
  call $parse-point-lowered

  ;; 返回结果指针
  local.get $ret_ptr
)
```

---

## 4 组件模型

### 1 概念

**组件 vs 模块**：
\[
\begin{align*}
\text{Module} &: \text{Wasm 核心（低级）} \\
\text{Component} &: \text{高级接口 + 组合}
\end{align*}
\]

**组件结构**：

```text
Component
  ├── Imports (依赖)
  │   ├── wasi:filesystem
  │   └── wasi:sockets
  ├── Core Modules (内部实现)
  │   ├── module1.wasm
  │   └── module2.wasm
  └── Exports (对外接口)
      └── app:main
```

### 4.2 WIT 定义

**接口声明**：

```wit
// 依赖
import wasi:filesystem/types@0.2.0
import wasi:filesystem/preopens@0.2.0

// 导出
interface app {
    run: func(args: list<string>) -> result<_, error>
}

world my-app {
    import wasi:cli/environment@0.2.0
    import wasi:cli/exit@0.2.0
    import wasi:filesystem/*@0.2.0

    export app
}
```

**组合示例**：

```wit
// 组件 A 提供数据库接口
export interface database {
    query: func(sql: string) -> result<list<record>, error>
}

// 组件 B 使用数据库
import database

interface api {
    get-user: func(id: u32) -> result<user, error>
}
```

**链接**：
\[
\text{Component}_A \xrightarrow{\text{exports}} \text{Database} \xrightarrow{\text{imports}} \text{Component}_B
\]

### 4.3 实例化

**传统模块**：

```javascript
const imports = {
    env: { /* 手工提供所有导入 */ }
};
const instance = await WebAssembly.instantiate(module, imports);
```

**组件模型**：

```javascript
const component = await Component.instantiate(componentBytes, {
    // 自动解析依赖
    'wasi:filesystem': wasiFilesystem,
    'wasi:sockets': wasiSockets,
});

// 类型安全的导出
const result = await component.exports.run(["arg1", "arg2"]);
```

---

## 5 工具链集成

### 1 wit-bindgen

**自动生成绑定**：

```bash
wit-bindgen rust --import my-interface.wit
wit-bindgen c --export my-interface.wit
```

**生成的 Rust 代码**：

```rust
// 自动生成
mod bindings {
    wit_bindgen::generate!({
        world: "my-app",
        exports: {
            "app": App,
        }
    });
}

struct App;

impl bindings::Guest for App {
    fn run(args: Vec<String>) -> Result<(), bindings::Error> {
        // 实现
    }
}
```

### 5.2 wasm-tools

**组件操作**：

```bash
# 验证组件
wasm-tools component validate app.wasm

# 打印接口
wasm-tools component wit app.wasm

# 组合组件
wasm-tools component compose \
    --component engine=engine.wasm \
    --component app=app.wasm \
    -o combined.wasm
```

### 5.3 虚拟化（Virtualization）

**代理接口**：

```wit
// 虚拟文件系统
interface virt-filesystem {
    // 转发到真实文件系统或内存文件系统
    open: func(path: string, flags: open-flags) -> result<descriptor, errno>
}
```

**用途**：

- 测试隔离
- 权限控制
- 性能监控

---

## 6 性能分析

### 1 类型转换开销

**简单类型**：
\[
C_{\text{i32}} \approx 0\text{ns} \quad \text{（直接传递）}
\]

**字符串**：
\[
C_{\text{string}} \approx 50\text{ns} + \frac{\text{len}}{10\text{GB/s}}
\]

**复杂结构**：
\[
C_{\text{struct}} \approx 100\text{ns} + \sum C_{\text{field}}
\]

**对比数据（1KB 字符串）**：

| 方法 | 开销 |
|------|------|
| **直接指针（零拷贝）** | 0ns |
| **Wasm → JS 拷贝** | 100ns |
| **JSON 序列化** | 5000ns |

### 6.2 组件链接开销

**静态链接**：
\[
T_{\text{link}} = 0\text{ms} \quad \text{（编译时完成）}
\]

**动态链接（运行时）**：
\[
T_{\text{dynamic-link}} \approx 1-5\text{ms/component}
\]

**调用开销**：
\[
C_{\text{cross-component}} \approx 10-30\text{ns} \quad \text{（内联后可降至 0）}
\]

---

## 7 批判性分析

### 1 接口类型的复杂性

**命题**：
\[
\text{Rich-Types} \implies \text{Complex-Lowering} \implies \text{Overhead}
\]

**示例**：

```wit
// 简单签名
add: func(a: s32, b: s32) -> s32

// 复杂签名
process: func(
    data: list<record<field1: string, field2: option<u64>>>,
    config: variant<mode-a(settings), mode-b(flags)>
) -> result<list<output>, error-info>
```

**生成的适配器代码**：~500 行（vs 简单函数 5 行）

**批判**：
> 接口类型是"便利的税收"：开发者写法简洁，但编译器生成大量样板代码。复杂度隐藏，而非消除。

### 7.2 组件模型的野心

**目标**：
\[
\text{Component-Model} = \text{Wasm 的 NPM/Docker}
\]

**现状（2025）**：

- 规范未稳定
- 工具链不成熟
- 生态几乎为零

**批判**：
> 组件模型是"技术远见"，但距离工程实践还有多年距离。接口类型提案已推进 5 年仍未进入 Stage 4。标准化的慢，正是设计的难。

### 7.3 语言绑定的碎片化

**观察**：
\[
\begin{align*}
\text{C++} &: \text{Emscripten embind} \\
\text{Rust} &: \text{wasm-bindgen} \\
\text{Go} &: \text{syscall/js} \\
\text{Python} &: \text{Pyodide}
\end{align*}
\]

**问题**：每种语言自成体系，互操作困难

**批判**：
> Wasm 承诺"通用二进制"，但语言绑定各自为政。组件模型试图统一，但推进缓慢。碎片化是当前最大挑战。

---

## 8 实践案例

### 1 案例1：Rust + JavaScript（wasm-bindgen）

**Rust 库**：

```rust
#[wasm_bindgen]
pub fn process_image(data: &[u8], width: u32, height: u32) -> Vec<u8> {
    // 图像处理算法（Rust 实现）
    // ...
    result
}
```

**JavaScript 调用**：

```javascript
import init, { process_image } from './pkg/image_processor.js';

await init();
const input = new Uint8Array(width * height * 4);
const output = process_image(input, width, height);
```

**性能**：

- Rust 处理：15ms
- JS → Rust 传递：2ms
- Rust → JS 传递：2ms
- **总计**：19ms（vs 纯 JS 150ms）

### 8.2 案例2：多语言组件组合

**架构**：

```text
[C++ 解码器] → [Rust 滤镜] → [JavaScript 渲染]
      ↓              ↓              ↓
   Wasm 组件    Wasm 组件      Web API
```

**接口**：

```wit
// 解码器导出
interface decoder {
    decode: func(data: list<u8>) -> result<frame, error>
}

// 滤镜导入解码器，导出处理接口
interface filter {
    import decoder
    apply: func(frame: frame, effect: effect-type) -> frame
}
```

**收益**：

- 模块化开发
- 语言选择自由
- 性能接近单体应用

---

## 9 未来方向

### 1 . 异步接口

```wit
interface async-io {
    read: async func(fd: descriptor) -> result<list<u8>, errno>
}
```

### 2 . 流式处理

```wit
interface streaming {
    process: func(input: stream<u8>) -> stream<u8>
}
```

### 3 . 资源类型

```wit
resource file {
    open: static func(path: string) -> result<file, errno>
    read: func() -> result<list<u8>, errno>
    close: func()
}
```

---

## 参考文献

1. **[Interface-Types]** WebAssembly. "Interface Types Proposal." https://github.com/WebAssembly/interface-types
2. **[Component-Model]** WebAssembly. "Component Model." https://github.com/WebAssembly/component-model
3. **[wasm-bindgen]** Rust WebAssembly. https://rustwasm.github.io/wasm-bindgen/

---

**结论**：
> 互操作性是 Wasm"通用计算平台"愿景的关键。当前的语言绑定实现了"可用"，但接口类型与组件模型才是"优雅"的未来。从碎片化走向标准化，是技术演进的必然，但这条路还很长——规范、工具、生态，缺一不可。
