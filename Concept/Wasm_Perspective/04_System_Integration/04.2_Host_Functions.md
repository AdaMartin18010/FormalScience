# 4.2 宿主函数 (Host Functions)

## 目录

- [核心命题](#核心命题)
- [FFI 语义](#ffi-语义)
- [类型映射](#类型映射)
- [调用约定](#调用约定)
- [性能优化](#性能优化)
- [安全边界](#安全边界)
- [批判性分析](#批判性分析)

---

## 核心命题

### 主定理

**边界跨越成本定理**：
\[
C_{\text{host-call}} = C_{\text{type-check}} + C_{\text{marshaling}} + C_{\text{call}} + C_{\text{unmarshal}}
\]

**类型安全保证**：
\[
\forall \text{HostFunc} : \text{TypeMatch}(\text{Import}, \text{Actual}) \vee \text{InstantiationFail}
\]

**最小信任边界**：
\[
\text{Wasm-Sandbox} \cap \text{Host-Environment} = \{\text{Host-Functions}\}
\]

---

## FFI 语义

### 导入机制

**模块导入声明**：
```wasm
(module
  ;; 导入宿主函数
  (import "env" "log" (func $log (param i32 i32)))
  (import "env" "allocate" (func $alloc (param i32) (result i32)))
  (import "Math" "sqrt" (func $sqrt (param f64) (result f64)))

  ;; 使用导入函数
  (func $main
    i32.const 0
    i32.const 10
    call $log  ;; 调用宿主函数
  )
)
```

**实例化绑定**：
```javascript
// JavaScript 宿主
const imports = {
  env: {
    log: (ptr, len) => {
      const bytes = new Uint8Array(memory.buffer, ptr, len);
      console.log(new TextDecoder().decode(bytes));
    },
    allocate: (size) => {
      return malloc(size);  // 调用 Wasm 内存分配器
    }
  },
  Math: {
    sqrt: Math.sqrt
  }
};

WebAssembly.instantiate(wasmBytes, imports);
```

### 类型检查

**签名匹配**：
\[
\text{Import-Sig} \equiv \text{Actual-Sig} \iff
\begin{cases}
\text{params-match} \wedge \\
\text{results-match}
\end{cases}
\]

**示例**：
```rust
// Rust 宿主（Wasmtime）
let mut store = Store::new(&engine, ());
let log_func = Func::wrap(&mut store, |ptr: i32, len: i32| {
    // 实现
});

let instance = Instance::new(
    &mut store,
    &module,
    &[log_func.into()]  // 类型自动检查
)?;
```

**错误处理**：
\[
\text{TypeError} \implies \text{LinkingError} \quad \text{（实例化阶段）}
\]

---

## 类型映射

### 基本类型对应

**Wasm ↔ Host 类型表**：

| Wasm 类型 | C/C++ | Rust | JavaScript | Python |
|-----------|-------|------|-----------|--------|
| `i32` | `int32_t` | `i32` | `Number` (i32) | `int` |
| `i64` | `int64_t` | `i64` | `BigInt` | `int` |
| `f32` | `float` | `f32` | `Number` | `float` |
| `f64` | `double` | `f64` | `Number` | `float` |
| `funcref` | `void(*)()` | `Func` | `Function` | `Callable` |
| `externref` | `void*` | `Extern` | `Object` | `Any` |

### 复杂类型传递

**问题**：Wasm 无法直接传递结构体
\[
\text{Wasm-Params} \subseteq \{\texttt{i32}, \texttt{i64}, \texttt{f32}, \texttt{f64}\}
\]

**解决方案1：指针传递**
```c
// 宿主端
typedef struct {
    int32_t x;
    int32_t y;
} Point;

void process_point(int32_t ptr) {
    Point* p = (Point*)(&wasm_memory[ptr]);
    // 访问 p->x, p->y
}
```

```wasm
;; Wasm 端
(func $main
  i32.const 0      ;; Point 结构体在内存偏移 0
  call $process_point
)
```

**解决方案2：扁平化参数**
```c
void process_point_flat(int32_t x, int32_t y) {
    // 直接接收展开的字段
}
```

**性能对比**：
\[
\begin{align*}
C_{\text{pointer}} &\approx 10 \text{ns} + C_{\text{memory-access}} \\
C_{\text{flat}} &\approx 5 \text{ns} \quad \text{（无内存访问）}
\end{align*}
\]

### 字符串传递

**Wasm 无原生字符串类型**：
\[
\text{String} = (\text{ptr}: \texttt{i32}, \text{len}: \texttt{i32})
\]

**示例**：
```rust
// Rust 宿主
fn print_string(mut caller: Caller<'_, ()>, ptr: i32, len: i32) {
    let memory = caller.get_export("memory").unwrap().into_memory().unwrap();
    let data = memory.data(&caller);

    let slice = &data[ptr as usize..(ptr + len) as usize];
    let s = std::str::from_utf8(slice).unwrap();
    println!("{}", s);
}
```

**零拷贝优化**：
\[
\text{Wasm-Memory} \xrightarrow{\text{直接访问}} \text{Host-String}
\]

---

## 调用约定

### 栈管理

**Wasm 调用栈 vs 原生栈**：
```
┌──────────────────┐
│  Wasm Function   │
├──────────────────┤
│  Trampoline      │  ← 边界转换层
├──────────────────┤
│  Host Function   │
├──────────────────┤
│  Native Stack    │
└──────────────────┘
```

**Trampoline 职责**：
\[
\begin{align*}
&\text{1. 参数类型转换} \\
&\text{2. 栈帧切换} \\
&\text{3. 错误处理} \\
&\text{4. 返回值转换}
\end{align*}
\]

**开销**：
\[
C_{\text{trampoline}} \approx 20-50 \text{ns}
\]

### 寄存器分配

**调用约定示例（x86_64）**：

| 参数顺序 | Wasm 栈 | Native 寄存器 |
|---------|---------|--------------|
| 第1个 | TOS (top) | `rdi` |
| 第2个 | TOS-1 | `rsi` |
| 第3个 | TOS-2 | `rdx` |
| 第4个 | TOS-3 | `rcx` |
| 溢出 | 栈 | 栈 |

**转换伪代码**：
```nasm
; Wasm → Host 调用
mov rdi, [wasm_stack]        ; 参数1
mov rsi, [wasm_stack - 8]    ; 参数2
call host_function
mov [wasm_stack], rax        ; 返回值
```

### 异常处理

**Wasm 陷阱 vs 宿主异常**：
\[
\text{Wasm-Trap} \not\equiv \text{Host-Exception}
\]

**桥接机制**：
```rust
// Rust 示例
fn fallible_host_func(x: i32) -> Result<i32, anyhow::Error> {
    if x < 0 {
        anyhow::bail!("negative value");  // Rust 异常
    }
    Ok(x * 2)
}

// Wasmtime 包装
let func = Func::wrap(&mut store, |x: i32| -> Result<i32, Trap> {
    fallible_host_func(x)
        .map_err(|e| Trap::new(e.to_string()))  // 转换为 Trap
});
```

**语义**：
\[
\text{Host-Exception} \xrightarrow{\text{convert}} \text{Wasm-Trap} \xrightarrow{\text{unwind}} \text{Host-Context}
\]

---

## 性能优化

### 内联宿主函数

**问题**：调用开销主导
\[
\frac{C_{\text{call}}}{C_{\text{compute}}} > 1 \implies \text{开销不可接受}
\]

**优化**：JIT 内联宿主函数
```
;; Before
call $host_simple_add

;; After (内联)
i32.add  ;; 直接生成原生指令
```

**条件**：
\[
\text{Inline}(\text{HostFunc}) \iff
\begin{cases}
\text{Simple}(\text{HostFunc}) \wedge \\
\text{Pure}(\text{HostFunc})
\end{cases}
\]

**收益**：
\[
\text{Speedup}_{\text{inline}} \approx 10-100\times \quad \text{（小函数）}
\]

### 批量调用

**反模式**：
```javascript
// 高频小调用
for (let i = 0; i < 1000000; i++) {
    wasmInstance.exports.process(i);  // 每次 50ns 开销
}
```

**优化模式**：
```javascript
// 批量处理
const buffer = new Int32Array(1000000);
for (let i = 0; i < 1000000; i++) {
    buffer[i] = i;
}
wasmInstance.exports.processBatch(buffer.byteOffset, 1000000);
```

**性能对比**：
\[
\frac{N \times C_{\text{call}}}{C_{\text{call}} + N \times C_{\text{compute}}} \approx N \quad \text{（当 } N \gg 1 \text{）}
\]

### 持久化绑定

**问题**：重复类型检查
```rust
// 每次调用都检查类型（低效）
for _ in 0..1000 {
    let func: Func = instance.get_func(&mut store, "add").unwrap();
    func.call(&mut store, &[Val::I32(1), Val::I32(2)])?;
}
```

**优化**：
```rust
// 一次查找，多次使用
let add_func = instance
    .get_typed_func::<(i32, i32), i32>(&mut store, "add")?;

for _ in 0..1000 {
    add_func.call(&mut store, (1, 2))?;  // 无类型检查开销
}
```

**收益**：
\[
\text{Overhead}_{\text{typed}} \approx 10\text{ns} \quad \text{vs} \quad \text{Overhead}_{\text{dynamic}} \approx 100\text{ns}
\]

---

## 安全边界

### 内存安全

**问题**：野指针
```c
// Wasm 传递无效指针
void host_read(int32_t ptr) {
    // 未检查：ptr 可能越界！
    int32_t value = *(int32_t*)(&wasm_memory[ptr]);
}
```

**防御**：
```c
void host_read_safe(int32_t ptr) {
    if (ptr + 4 > wasm_memory_size) {
        return ERROR_OUT_OF_BOUNDS;
    }
    int32_t value = *(int32_t*)(&wasm_memory[ptr]);
}
```

**形式化约束**：
\[
\forall \text{ptr} : \text{Access}(\text{ptr}, \text{size}) \implies \text{ptr} + \text{size} \leq |\text{memory}|
\]

### 重入问题

**场景**：
```
Wasm-A
  └─> Host-Func
        └─> Wasm-B (同一实例)
              └─> ... (死锁风险)
```

**互斥保护**：
```rust
struct InstanceGuard {
    lock: Mutex<()>,
}

fn host_reentrant_call(guard: &InstanceGuard) {
    let _lock = guard.lock.try_lock()
        .expect("reentrant call detected!");  // 检测重入
    // ... 执行
}
```

**替代方案**：消息传递
\[
\text{Wasm} \xrightarrow{\text{message}} \text{Host} \xrightarrow{\text{async}} \text{Wasm}
\]

### 时间侧信道

**问题**：
```c
bool check_password(const char* input) {
    for (int i = 0; i < strlen(input); i++) {
        if (input[i] != correct[i]) {
            return false;  // 提前返回！
        }
    }
    return true;
}
```

**攻击**：
\[
T(\text{input}) \propto \text{correct-prefix-length}(\text{input})
\]

**防御**：常量时间比较
```c
bool check_password_ct(const char* input) {
    int diff = 0;
    for (int i = 0; i < MAX_LEN; i++) {
        diff |= (input[i] ^ correct[i]);
    }
    return diff == 0;
}
```

---

## 批判性分析

### FFI 的本质困境

**命题**：
\[
\text{Type-Safety} \wedge \text{Zero-Cost} \implies \text{Contradiction}
\]

**证明**：
- 类型安全需运行时检查
- 零成本需编译时消除检查
- 两者不可兼得（除非全静态类型）

**实践妥协**：
\[
\text{Typed-FFI} = \text{启动检查} + \text{运行时最小验证}
\]

### 宿主函数的语义陷阱

**问题**：副作用不可控
```rust
// 宿主函数可任意修改全局状态
fn host_evil(global_state: &mut State) {
    global_state.corrupt();  // Wasm 无法检测！
}
```

**批判**：
> 宿主函数是"信任的假设"：我们相信它行为正确，但无法验证。沙箱在边界处戛然而止。

### 性能不可预测性

**观察**：
\[
\text{Variance}(T_{\text{host-call}}) \gg \text{Variance}(T_{\text{wasm-instr}})
\]

**原因**：
- 宿主函数可能触发 GC
- 可能涉及系统调用
- 可能有锁竞争

**批判**：
> 宿主函数调用是"黑盒延迟"：无法静态分析，无法形式化证明。实时系统需谨慎使用。

---

## 实践案例

### 案例1：Lucet (Fastly)

**特化宿主函数**：
```rust
// 为特定宿主函数生成优化代码
#[lucet_hostcall]
fn fast_memcpy(dst: u32, src: u32, len: u32) {
    // 直接内联为 Wasm 指令
}
```

**收益**：
- 调用开销：<5ns
- 吞吐：10M calls/sec

### 案例2：Node.js N-API

**稳定 ABI**：
```c
// N-API 宿主函数（ABI 稳定）
napi_value Add(napi_env env, napi_callback_info info) {
    size_t argc = 2;
    napi_value args[2];
    napi_get_cb_info(env, info, &argc, args, NULL, NULL);

    int32_t a, b;
    napi_get_value_int32(env, args[0], &a);
    napi_get_value_int32(env, args[1], &b);

    napi_value result;
    napi_create_int32(env, a + b, &result);
    return result;
}
```

**开销**：~80ns/call（较高，但 ABI 稳定）

---

## 未来方向

### 组件模型接口类型

**WIT 定义**：
```wit
interface math {
    add: func(a: s32, b: s32) -> s32
    sqrt: func(x: f64) -> f64
}
```

**自动生成绑定**：
\[
\text{WIT} \xrightarrow{\text{codegen}} \{\text{Rust}, \text{C++}, \text{JS}, \ldots\}
\]

### 异步宿主函数

**提案**：
```wit
interface async-io {
    read: async func(fd: fd) -> result<list<u8>, errno>
}
```

**挑战**：
- Wasm 栈与异步调度
- 挂起点管理
- 错误处理

---

## 参考文献

1. **[Wasmtime]** Bytecode Alliance. "Wasmtime Embedding Guide." https://docs.wasmtime.dev/
2. **[ComponentModel]** WebAssembly. "Component Model Proposal." https://github.com/WebAssembly/component-model

---

**结论**：
> 宿主函数是 Wasm 沙箱的"必要之恶"：它打破隔离以获取能力，但每次跨越都是信任的消耗。性能优化可降低开销，但无法消除本质成本。FFI 永远是"速度-安全-简洁"三角的妥协点——追求一项，必失其他。
