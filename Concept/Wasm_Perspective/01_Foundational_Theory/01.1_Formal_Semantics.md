# 1.1 形式化语义 (Formal Semantics)

## 目录

- [1.1 形式化语义 (Formal Semantics)](#11-形式化语义-formal-semantics)
  - [目录](#目录)
  - [核心命题](#核心命题)
    - [主定理](#主定理)
    - [语义设计目标](#语义设计目标)
  - [操作语义 (Operational Semantics)](#操作语义-operational-semantics)
    - [小步语义 (Small-Step Semantics)](#小步语义-small-step-semantics)
      - [抽象机器模型](#抽象机器模型)
      - [核心指令语义](#核心指令语义)
    - [大步语义 (Big-Step Semantics)](#大步语义-big-step-semantics)
  - [指称语义 (Denotational Semantics)](#指称语义-denotational-semantics)
    - [语义域](#语义域)
    - [组合子语义](#组合子语义)
  - [公理语义 (Axiomatic Semantics)](#公理语义-axiomatic-semantics)
    - [Hoare 逻辑](#hoare-逻辑)
    - [分离逻辑 (Separation Logic)](#分离逻辑-separation-logic)
  - [语义等价性](#语义等价性)
    - [行为等价](#行为等价)
    - [优化正确性](#优化正确性)
  - [批判性分析](#批判性分析)
    - [形式化的边界](#形式化的边界)
    - [抽象的成本](#抽象的成本)
    - [规范的政治经济学](#规范的政治经济学)
  - [案例研究：`select` 指令](#案例研究select-指令)
    - [语义定义](#语义定义)
    - [等价性定理](#等价性定理)
  - [形式化工具链](#形式化工具链)
  - [参考文献](#参考文献)

---

## 核心命题

### 主定理
>
> **WebAssembly 的执行语义可通过小步操作语义完整形式化，且该形式化在数学上是确定的、可判定的。**

**形式化陈述**：
\[
\forall S, I : (S, I) \rightarrow_{\text{wasm}} (S', I') \implies \exists! (S', I')
\]
其中：

- \( S \)：状态（栈、内存、全局变量）
- \( I \)：指令序列
- \( \rightarrow_{\text{wasm}} \)：单步转移关系

### 语义设计目标

| 目标 | 形式化要求 | 验证方法 |
|------|-----------|---------|
| **确定性** | \( \forall s : \|\{\text{next}(s)\}\| \leq 1 \) | 转移函数唯一性证明 |
| **完备性** | \( \forall I \in \text{ValidInstr} : \exists \text{semantics}(I) \) | 归纳构造 |
| **可组合性** | \( \llbracket I_1; I_2 \rrbracket = \llbracket I_2 \rrbracket \circ \llbracket I_1 \rrbracket \) | 同态性证明 |
| **可验证性** | 语义验证在 \( O(n) \) 时间内完成 | 算法复杂度分析 |

---

## 操作语义 (Operational Semantics)

### 小步语义 (Small-Step Semantics)

#### 抽象机器模型

**配置 (Configuration)**：
\[
\langle S, F, I \rangle
\]
其中：

- \( S = (\text{stack}, \text{memory}, \text{globals}, \text{table}) \)：存储
- \( F \)：当前栈帧 (locals, module instance)
- \( I \)：待执行指令序列

**转移规则模板**：
\[
\frac{\text{前提条件}}{\langle S, F, I \rangle \rightarrow \langle S', F', I' \rangle} \text{[规则名]}
\]

#### 核心指令语义

**1. 算术指令**

```
[i32.add]
─────────────────────────────────────────────────
  ⟨ v₂ : v₁ : S, F, (i32.add) :: I ⟩
→ ⟨ (v₁ + v₂ mod 2³²) : S, F, I ⟩
```

**形式化**：
\[
\llbracket \texttt{i32.add} \rrbracket_{\text{op}}(v_1, v_2) = (v_1 + v_2) \bmod 2^{32}
\]

**关键性质**：

- 溢出语义：环绕（wrap），非陷阱
- 交换律：\( v_1 + v_2 \equiv v_2 + v_1 \)
- 结合律：\( (v_1 + v_2) + v_3 \equiv v_1 + (v_2 + v_3) \)

**2. 控制流指令**

```
[block]
────────────────────────────────────────────────────
  ⟨ S, F, (block [t*] I₀ end) :: I ⟩
→ ⟨ S, F, (label_n {} I₀) :: I ⟩
```

其中 \( n = |t^*| \) 为返回值数量。

**形式化标签栈**：
\[
L ::= \epsilon \mid \text{label}_n \{ I_{\text{cont}} \} L
\]

**跳转语义**：
\[
\frac{i < |L|}{\langle \text{label}_m \{I_c\} L, \text{br } i \rangle \rightarrow \langle L', I_t \rangle}
\]
其中 \( I_t \) 为第 \( i \) 层标签的延续指令。

**3. 内存指令**

```
[i32.load]
──────────────────────────────────────────────────────────────
  ⟨ i : S, F, (i32.load offset align) :: I ⟩
→ ⟨ load_i32(mem, i + offset) : S, F, I ⟩   if i + offset + 3 < |mem|
→ trap                                        otherwise
```

**内存访问函数**：
\[
\text{load}_{i32}(\text{mem}, a) = \sum_{k=0}^{3} \text{mem}[a+k] \times 256^k
\]
（小端序）

**安全性约束**：
\[
\forall a : \text{load}(\text{mem}, a) \text{ defined} \iff a + \text{sizeof}(t) \leq |\text{mem}|
\]

### 大步语义 (Big-Step Semantics)

**终止状态判断**：
\[
\langle S, F, I \rangle \Downarrow V
\]
表示从配置 \( \langle S, F, I \rangle \) 执行到返回值 \( V \)。

**递归规则示例**：
\[
\frac{
  \langle S, F, I_1 \rangle \Downarrow v_1 \quad
  \langle v_1 : S, F, I_2 \rangle \Downarrow v_2
}{
  \langle S, F, I_1; I_2 \rangle \Downarrow v_2
}
\]

---

## 指称语义 (Denotational Semantics)

### 语义域

**值域**：
\[
\mathcal{V} = \mathbb{Z}_{32} \cup \mathbb{Z}_{64} \cup \mathbb{F}_{32} \cup \mathbb{F}_{64} \cup \{\bot\}
\]
其中 \( \bot \) 表示 trap。

**存储域**：
\[
\mathcal{S} = \mathcal{M} \times \mathcal{G} \times \mathcal{T}
\]

- \( \mathcal{M} = \text{Addr} \rightharpoonup \mathbb{Z}_8 \)：内存（部分函数）
- \( \mathcal{G} = \text{GlobId} \to \mathcal{V} \)：全局变量
- \( \mathcal{T} = \text{TableId} \to (\mathbb{N} \rightharpoonup \text{FuncRef}) \)：表

**指令语义函数**：
\[
\llbracket \cdot \rrbracket : \text{Instr} \to (\mathcal{S} \to \mathcal{V}^* \times \mathcal{S}_\bot)
\]

### 组合子语义

**顺序组合**：
\[
\llbracket I_1; I_2 \rrbracket = \lambda s. \text{let } (v, s') = \llbracket I_1 \rrbracket(s) \text{ in } \llbracket I_2 \rrbracket(v :: s')
\]

**条件分支**：
\[
\llbracket \texttt{if} \rrbracket = \lambda s. \text{case pop}(s) \text{ of }
\begin{cases}
0 & \Rightarrow \llbracket I_{\text{else}} \rrbracket(s) \\
\_ & \Rightarrow \llbracket I_{\text{then}} \rrbracket(s)
\end{cases}
\]

**循环语义**（不动点）：
\[
\llbracket \texttt{loop } I \rrbracket = \mu f. \lambda s. \llbracket I; \texttt{br } 0 \rrbracket(s)
\]
其中 \( \mu \) 为最小不动点算子。

**定理（Scott 连续性）**：
\[
\llbracket \texttt{loop} \rrbracket = \bigsqcup_{n=0}^\infty f^n(\bot)
\]
证明循环语义的良定义性。

---

## 公理语义 (Axiomatic Semantics)

### Hoare 逻辑

**判断形式**：
\[
\{P\} \; I \; \{Q\}
\]
表示：若前置条件 \( P \) 成立，执行指令 \( I \) 后，后置条件 \( Q \) 成立。

**算术指令规则**：
\[
\frac{Q[e_1 + e_2 / v]}{
  \{\text{stack} = [e_2, e_1 | S] \wedge P\} \; \texttt{i32.add} \; \{\text{stack} = [v | S] \wedge Q\}
}
\]

**内存访问规则**：
\[
\frac{a + 4 \leq |\text{mem}|}{
  \{\text{stack} = [a | S] \wedge P\} \; \texttt{i32.load} \; \{\text{stack} = [\text{mem}[a..a+3] | S] \wedge P\}
}
\]

**循环不变式**：
\[
\frac{
  \{I \wedge B\} \; \text{body} \; \{I\}
}{
  \{I\} \; \texttt{loop body end} \; \{I \wedge \neg B\}
}
\]

### 分离逻辑 (Separation Logic)

**线性内存分离**：
\[
(a_1 \mapsto v_1) * (a_2 \mapsto v_2) \iff a_1 + 4 \leq a_2 \vee a_2 + 4 \leq a_1
\]

**帧规则**：
\[
\frac{\{P\} \; I \; \{Q\}}{\{P _R\} \; I \; \{Q_ R\}} \quad (\text{modifies}(I) \cap \text{fv}(R) = \emptyset)
\]

---

## 语义等价性

### 行为等价

**定义（轨迹等价）**：
\[
I_1 \sim I_2 \iff \forall S : \text{traces}(S, I_1) = \text{traces}(S, I_2)
\]

**定理（确定性蕴含等价的可判定性）**：
\[
\text{deterministic} \implies (I_1 \sim I_2 \iff \text{bisimilar}(I_1, I_2))
\]

### 优化正确性

**代数等式示例**：
\[
\begin{align*}
\texttt{i32.const } 0; \texttt{i32.add} &\sim \texttt{nop} \\
\texttt{i32.const } c; \texttt{i32.mul} &\sim \texttt{i32.const } 0 \quad (c = 0) \\
\texttt{block } \emptyset \; \texttt{end} &\sim \texttt{nop}
\end{align*}
\]

**验证方法**：

1. 符号执行
2. 等价性检查
3. 互模拟证明

---

## 批判性分析

### 形式化的边界

**命题（哥德尔限制）**：
\[
\exists P : \text{valid-wasm}(P) \wedge \neg \exists \text{proof-in-PA}(\text{terminates}(P))
\]
（存在无法在 Peano 算术中证明终止的合法 Wasm 程序）

**实践影响**：

- 全程序验证的不可达性
- 有界模型检测的必要性

### 抽象的成本

**语义抽象税**：
\[
\text{Overhead}_{\text{validation}} = O(n) \times k_{\text{check}}
\]
其中 \( k_{\text{check}} \approx 1-2 \) CPU 周期/字节。

**哲学反思**：
> 形式化语义提供了数学确定性，但这种确定性是否能映射到物理硬件的不确定性（如 Spectre、Rowhammer）？

### 规范的政治经济学

**标准化困境**：

- W3C 流程：共识优先 vs 技术优越性
- 向后兼容的枷锁：历史包袱的累积

**批判性问题**：

1. 谁决定语义？（厂商利益 vs 学术理想）
2. 形式化是否成为进入壁垒？（工具链垄断）

---

## 案例研究：`select` 指令

### 语义定义

**操作语义**：
\[
\frac{c \neq 0}{\langle v_2 : v_1 : c : S, \texttt{select} \rangle \rightarrow \langle v_1 : S \rangle} \quad
\frac{c = 0}{\langle v_2 : v_1 : c : S, \texttt{select} \rangle \rightarrow \langle v_2 : S \rangle}
\]

**指称语义**：
\[
\llbracket \texttt{select} \rrbracket = \lambda (c, v_1, v_2). \text{if } c \neq 0 \text{ then } v_1 \text{ else } v_2
\]

**公理语义**：
\[
\{\text{stack} = [c, v_1, v_2 | S]\} \; \texttt{select} \; \{\text{stack} = [(c \neq 0 ? v_1 : v_2) | S]\}
\]

### 等价性定理

\[
\texttt{select} \sim \texttt{if (result t) (then local.get 1) (else local.get 2) end}
\]

**证明（互模拟）**：

1. 构造双向模拟关系 \( R \)
2. 证明 \( R \) 满足模拟条件
3. 应用 Park-Milner 定理

---

## 形式化工具链

| 工具 | 方法 | 覆盖度 |
|------|------|--------|
| **Isabelle/Wasm** | 定理证明 | 核心规范 100% |
| **K-Wasm** | 可执行语义 | MVP + SIMD |
| **Wasm-Coq** | Coq 机械化 | MVP 完整 |
| **Wasmtime Cranelift** | 编译器验证 | 部分（IR 层） |

**开放挑战**：

- 端到端验证：源码 → Wasm → 原生代码
- 并发语义：线程 + 原子指令的形式化

---

## 参考文献

1. **[Wasm Spec]** WebAssembly Working Group. "WebAssembly Core Specification." W3C, 2019.
2. **[Watt17]** Conrad Watt. "Mechanising and Verifying the WebAssembly Specification." CPP, 2018.
3. **[Rossberg]** Andreas Rossberg. "WebAssembly Specification: Type System." 2023.
4. **[Pierce02]** Benjamin Pierce. _Types and Programming Languages._ MIT Press, 2002.

---

**结论**：
> WebAssembly 的形式化语义在理论上实现了确定性、可组合性和可验证性的三位一体，但从数学模型到硬件执行的映射仍存在不可消除的语义鸿沟。形式化是必要的安全保障，却非充分的正确性证明。
