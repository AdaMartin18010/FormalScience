# 1.2 类型系统 (Type System)

## 目录

- [1.2 类型系统 (Type System)](#12-类型系统-type-system)
  - [目录](#目录)
  - [核心命题](#核心命题)
    - [主定理（类型安全性）](#主定理类型安全性)
  - [类型语法](#类型语法)
    - [值类型 (Value Types)](#值类型-value-types)
    - [函数类型 (Function Types)](#函数类型-function-types)
    - [限制类型 (Limits)](#限制类型-limits)
  - [类型规则](#类型规则)
    - [指令类型](#指令类型)
    - [核心规则](#核心规则)
    - [内存指令](#内存指令)
  - [类型安全性](#类型安全性)
    - [证明框架](#证明框架)
    - [Progress 证明](#progress-证明)
    - [Preservation 证明](#preservation-证明)
    - [类型擦除](#类型擦除)
  - [类型推导](#类型推导)
    - [栈类型推导算法](#栈类型推导算法)
    - [类型检查器的正确性](#类型检查器的正确性)
  - [子类型与多态](#子类型与多态)
    - [栈多态性](#栈多态性)
    - [引用类型（Reference Types Proposal）](#引用类型reference-types-proposal)
  - [批判性分析](#批判性分析)
    - [类型系统的局限](#类型系统的局限)
    - [类型擦除的哲学困境](#类型擦除的哲学困境)
    - [标准化的权衡](#标准化的权衡)
  - [案例研究：`select` 类型多态](#案例研究select-类型多态)
    - [问题](#问题)
    - [类型规则](#类型规则-1)
    - [实现挑战](#实现挑战)
  - [形式化验证工具](#形式化验证工具)
  - [参考文献](#参考文献)

---

## 核心命题

### 主定理（类型安全性）

**Progress（进展性）**：
\[
\forall e, \tau : \vdash e : \tau \implies (e \text{ is value} \vee \exists e' : e \rightarrow e')
\]
_良类型表达式要么是值，要么可以进一步归约。_

**Preservation（保持性）**：
\[
\forall e, e', \tau : (\vdash e : \tau \wedge e \rightarrow e') \implies \vdash e' : \tau
\]
_归约保持类型不变。_

**安全性定理**：
\[
\text{Progress} \wedge \text{Preservation} \implies \neg \text{UndefinedBehavior}
\]

---

## 类型语法

### 值类型 (Value Types)

**基础类型**：
\[
\text{valtype} ::= \texttt{i32} \mid \texttt{i64} \mid \texttt{f32} \mid \texttt{f64} \mid \texttt{v128}
\]

**类型代数**：
\[
\begin{align*}
\texttt{i32} &: \mathbb{Z}_{2^{32}} \quad \text{（32位整数环）} \\
\texttt{i64} &: \mathbb{Z}_{2^{64}} \\
\texttt{f32} &: \mathbb{F}_{\text{IEEE-754-binary32}} \\
\texttt{f64} &: \mathbb{F}_{\text{IEEE-754-binary64}} \\
\texttt{v128} &: (\text{valtype}_{\text{lane}})^{n_{\text{lanes}}}
\end{align*}
\]

**批判性观察**：
> 为何没有 `i16`、`i8` 作为一等值类型？设计决策：栈式机器的对齐考量 vs 内存表示的灵活性。

### 函数类型 (Function Types)

**签名定义**：
\[
\text{functype} ::= [\text{valtype}^_] \to [\text{valtype}^_]
\]

**结构化规则**：
\[
\frac{
  \vdash t_1^_: \text{valtype}^_ \quad
  \vdash t_2^_: \text{valtype}^_
}{
  \vdash [t_1^_] \to [t_2^_] : \text{functype}
}
\]

**多返回值约束**：
\[
|t_2^_| \geq 0 \quad \text{（MVP 限制为 } |t_2^_| \leq 1 \text{，已解除）}
\]

### 限制类型 (Limits)

**内存/表大小**：
\[
\text{limits} ::= \{\text{min} : \mathbb{N}, \text{max} : \mathbb{N} \cup \{\infty\}\} \quad (\text{min} \leq \text{max})
\]

**类型谓词**：
\[
\text{valid-limits}(l) \iff l.\text{min} \leq l.\text{max} \wedge l.\text{min} \times 64\text{KiB} \leq 2^{32} \text{ （32位寻址）}
\]

---

## 类型规则

### 指令类型

**类型判断形式**：
\[
C \vdash I : [t_1^_] \to [t_2^_]
\]
读作："在上下文 \( C \) 下，指令 \( I \) 从类型栈 \( [t_1^_] \) 转换到 \( [t_2^_] \)"。

**上下文结构**：
\[
C = \{
  \text{types} : \text{functype}^_,
  \text{funcs} : \text{functype}^_,
  \text{locals} : \text{valtype}^_,
  \text{labels} : \text{resulttype}^_
\}
\]

### 核心规则

**1. 常量指令**

\[
\frac{}{
  C \vdash \texttt{i32.const } n : [] \to [\texttt{i32}]
} \; \text{[T-Const]}
\]

**2. 二元运算**

\[
\frac{
  \text{op} \in \{\texttt{add}, \texttt{sub}, \texttt{mul}, \ldots\}
}{
  C \vdash \texttt{i32.}\text{op} : [\texttt{i32}, \texttt{i32}] \to [\texttt{i32}]
} \; \text{[T-Binop]}
\]

**3. 局部变量**

\[
\frac{
  C.\text{locals}[x] = t
}{
  C \vdash \texttt{local.get } x : [] \to [t]
} \; \text{[T-LocalGet]}
\]

\[
\frac{
  C.\text{locals}[x] = t
}{
  C \vdash \texttt{local.set } x : [t] \to []
} \; \text{[T-LocalSet]}
\]

**4. 控制流**

\[
\frac{
  C, \text{label} \; [t^_] \vdash I^_ : [] \to [t^_]
}{
  C \vdash \texttt{block } [t^_] \; I^_\; \texttt{end} : [] \to [t^_]
} \; \text{[T-Block]}
\]

\[
\frac{
  C.\text{labels}[i] = [t^_] \quad
  |t^_| = n
}{
  C \vdash \texttt{br } i : [t_1^_, t^_] \to [t_2^*]
} \; \text{[T-Br]}
\]

**批判性观察**：
> `br` 的类型多态性：\( [t_1^_, t^_] \to [t_2^_] \) 中 \( t_1^_ \) 和 \( t_2^* \) 任意，体现了栈多态（stack polymorphism）。这是类型系统的优雅之处，但也增加了验证复杂度。

**5. 函数调用**

\[
\frac{
  C.\text{funcs}[x] = [t_1^_] \to [t_2^_]
}{
  C \vdash \texttt{call } x : [t_1^_] \to [t_2^_]
} \; \text{[T-Call]}
\]

**6. 间接调用**

\[
\frac{
  C.\text{types}[x] = [t_1^_] \to [t_2^_] \quad
  C.\text{table} = \text{funcref}
}{
  C \vdash \texttt{call\_indirect } x : [t_1^_, \texttt{i32}] \to [t_2^_]
} \; \text{[T-CallIndirect]}
\]

**运行时检查**：
\[
\text{call\_indirect}(i, [t_1^_] \to [t_2^_]) \rightarrow
\begin{cases}
\text{call}(f) & \text{if table}[i] = f \wedge \text{type}(f) = [t_1^_] \to [t_2^_] \\
\text{trap} & \text{otherwise}
\end{cases}
\]

### 内存指令

\[
\frac{
  C.\text{mems}[0] = \text{memtype}
}{
  C \vdash \texttt{i32.load} : [\texttt{i32}] \to [\texttt{i32}]
} \; \text{[T-Load]}
\]

\[
\frac{
  C.\text{mems}[0] = \text{memtype}
}{
  C \vdash \texttt{i32.store} : [\texttt{i32}, \texttt{i32}] \to []
} \; \text{[T-Store]}
\]

**对齐约束**（非类型规则，运行时）：
\[
\text{align} \in \{0, 1, 2, 4\} \quad (\text{建议} \leq \log_2(\text{sizeof}(t)))
\]

---

## 类型安全性

### 证明框架

**引理1（类型推导的唯一性）**：
\[
(C \vdash I : \tau_1 \wedge C \vdash I : \tau_2) \implies \tau_1 = \tau_2
\]

**证明**：对指令结构归纳，每条规则确定唯一类型。□

**引理2（替换引理）**：
\[
(\Gamma, x : \tau_1 \vdash e : \tau_2 \wedge \vdash v : \tau_1) \implies \Gamma \vdash e[v/x] : \tau_2
\]

**证明**：对 \( e \) 的类型推导树归纳。□

**引理3（上下文扩展）**：
\[
(\Gamma \vdash e : \tau \wedge \Gamma \subseteq \Gamma') \implies \Gamma' \vdash e : \tau
\]

### Progress 证明

**定理**：
\[
\forall S, I : (\vdash \langle S, I \rangle : \tau) \implies (\langle S, I \rangle \text{ is final} \vee \exists \langle S', I' \rangle : \langle S, I \rangle \rightarrow \langle S', I' \rangle)
\]

**证明**：

1. 对 \( I \) 的形式分类讨论：
   - 若 \( I = \texttt{i32.const } n \)：已是值，final。
   - 若 \( I = \texttt{i32.add} \)：栈顶必有两个 `i32`（由类型规则保证），可归约。
   - 若 \( I = \texttt{br } i \)：标签栈第 \( i \) 层存在（由类型规则保证），可跳转。
2. 其他指令类似。□

### Preservation 证明

**定理**：
\[
(\vdash \langle S, I \rangle : \tau \wedge \langle S, I \rangle \rightarrow \langle S', I' \rangle) \implies \vdash \langle S', I' \rangle : \tau
\]

**证明**：
对归约规则归纳：

- **Case** \( \texttt{i32.add} \)：
  \[
  \begin{align*}
  &\vdash \langle v_2 : v_1 : S, \texttt{i32.add} :: I \rangle : \tau \\
  &\implies \vdash v_1 : \texttt{i32} \wedge \vdash v_2 : \texttt{i32} \wedge \vdash \langle S, I \rangle : \tau' \quad (\tau = \texttt{i32} :: \tau') \\
  &\implies \vdash (v_1 + v_2) : \texttt{i32} \quad \text{（整数环封闭性）} \\
  &\implies \vdash \langle (v_1 + v_2) : S, I \rangle : \tau
  \end{align*}
  \]
- 其他指令类似。□

### 类型擦除

**定理（类型不影响语义）**：
\[
\text{erase}(e_1) = \text{erase}(e_2) \implies \text{behavior}(e_1) = \text{behavior}(e_2)
\]

**证明**：类型仅用于静态验证，运行时已擦除。□

**实践意义**：

- 字节码不携带类型标注（除函数签名）
- 验证一次，执行无开销

---

## 类型推导

### 栈类型推导算法

**输入**：指令序列 \( I^* \)，上下文 \( C \)
**输出**：类型 \( [t_1^_] \to [t_2^_] \) 或 type error

**算法**：

```
function inferType(I*, C):
    stack_type = []
    for each I in I*:
        match I:
            case i32.const n:
                stack_type.push(i32)
            case i32.add:
                if stack_type.length < 2 or stack_type.top_two() != [i32, i32]:
                    return error
                stack_type.pop(); stack_type.pop()
                stack_type.push(i32)
            case block [t*] body end:
                body_type = inferType(body, C with label [t*])
                if body_type != [] -> [t*]:
                    return error
                stack_type.push_all(t*)
            case br i:
                if i >= C.labels.length:
                    return error
                stack_type = [t1*, C.labels[i]]  // polymorphic
            ...
    return [] -> stack_type
```

**复杂度**：
\[
T(n) = O(n) \quad \text{（单遍扫描）}
\]

### 类型检查器的正确性

**定理（算法健全性）**：
\[
\text{inferType}(I^_, C) = \tau \implies C \vdash I^_ : \tau
\]

**定理（算法完备性）**：
\[
C \vdash I^_: \tau \implies \text{inferType}(I^_, C) = \tau
\]

**证明**：对推导规则与算法步骤建立双射。□

---

## 子类型与多态

### 栈多态性

**观察**：
\[
C \vdash \texttt{br } i : [t_1^_, t^_] \to [t_2^_]
\]
其中 \( t_1^_ \) 和 \( t_2^* \) 任意（不可达代码）。

**形式化**：
\[
\frac{
  C.\text{labels}[i] = [t^_]
}{
  C \vdash \texttt{br } i : \forall t_1^_, t_2^_. [t_1^_, t^_] \to [t_2^_]
} \; \text{[T-Br-Poly]}
\]

**批判**：
> 这种多态性是类型系统的"逃逸口"，允许验证器接受死代码。但过度依赖会掩盖潜在错误。

### 引用类型（Reference Types Proposal）

**扩展类型**：
\[
\text{reftype} ::= \texttt{funcref} \mid \texttt{externref} \mid \texttt{nullref}
\]

**子类型关系**：
\[
\texttt{nullref} <: \texttt{funcref} <: \texttt{anyref}
\]

**规则**：
\[
\frac{
  \tau_1 <: \tau_2
}{
  C \vdash e : \tau_1 \implies C \vdash e : \tau_2
} \; \text{[T-Subsume]}
\]

**挑战**：

- 子类型判定的复杂度
- 协变/逆变的语义

---

## 批判性分析

### 类型系统的局限

**问题1：缺乏依赖类型**

当前系统无法表达：
\[
\text{load}(a) : \{v : \texttt{i32} \mid a + 4 \leq |\text{mem}|\}
\]

**后果**：

- 运行时检查不可避免
- 验证成本永久存在

**问题2：线性性丢失**

Wasm 未强制线性类型（affine types）：
\[
\neg (\text{use-once}(\text{funcref}))
\]

**安全隐患**：

- 外部引用的双重释放风险
- 需运行时 GC 补偿

### 类型擦除的哲学困境

**命题**：
\[
\text{TypeErased}(e) \wedge \text{TypeSafe}(e) \overset{?}{\implies} \text{Safe}(e)
\]

**反例**：

- Spectre 攻击：类型安全不保证信息流安全
- 侧信道泄漏：控制流依然可观测

**哲学反思**：
> 类型系统保证的是"语法安全"，而非"语义安全"。从类型到安全的跳跃，需要更深层的形式化（如信息流类型、安全类型）。

### 标准化的权衡

**历史包袱**：

- 为何 `i16` 不是一等类型？（栈对齐历史决策）
- 多返回值为何延迟至 2020？（浏览器实现复杂度）

**批判**：
> W3C 共识驱动的标准化，优先兼容性而非理论优雅性。类型系统被迫承载工程折衷的痕迹。

---

## 案例研究：`select` 类型多态

### 问题

`select` 指令的类型？
\[
\texttt{select} : [t, t, \texttt{i32}] \to [t] \quad (\forall t)
\]

### 类型规则

\[
\frac{
  t \in \text{numtype}
}{
  C \vdash \texttt{select} : [t, t, \texttt{i32}] \to [t]
} \; \text{[T-Select]}
\]

**限制**：\( t \) 必须是数值类型（排除 `funcref`）。

**扩展提案**：
\[
\frac{
  t = \text{valtype}
}{
  C \vdash \texttt{select } t : [t, t, \texttt{i32}] \to [t]
} \; \text{[T-Select-Typed]}
\]

### 实现挑战

**问题**：如何在擦除类型的字节码中保证多态正确性？

**解决方案**：

1. 编码时显式携带类型（`select` → `select i32`）
2. 验证时重建类型信息

---

## 形式化验证工具

| 工具 | 方法 | 覆盖度 |
|------|------|--------|
| **Isabelle/Wasm** | 定理证明器 | Progress + Preservation 完整证明 |
| **Wasm-Coq** | Coq 机械化 | 类型系统形式化 |
| **Cranelift** | 编译器验证 | 类型检查器验证（部分） |

---

## 参考文献

1. **[Rossberg23]** Andreas Rossberg. "WebAssembly Type System Specification." W3C, 2023.
2. **[Watt18]** Conrad Watt. "Mechanising and Verifying the WebAssembly Specification." CPP, 2018.
3. **[Pierce02]** Benjamin Pierce. _Types and Programming Languages._ MIT Press, 2002.
4. **[Haas17]** Andreas Haas et al. "Bringing the Web up to Speed with WebAssembly." PLDI, 2017.

---

**结论**：
> WebAssembly 的类型系统在工程简洁性与理论严密性之间取得了微妙平衡：通过栈多态避免过度限制，通过类型擦除消除运行时开销，但也付出了无法表达依赖关系、需运行时检查的代价。这是实用主义与形式化的妥协产物，而非理论完美的追求。
