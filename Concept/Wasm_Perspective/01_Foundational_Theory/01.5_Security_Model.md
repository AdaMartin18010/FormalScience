# 1.5 安全模型 (Security Model)

## 目录

- [核心命题](#核心命题)
- [沙箱模型](#沙箱模型)
- [能力安全](#能力安全)
- [内存安全](#内存安全)
- [控制流完整性](#控制流完整性)
- [批判性分析](#批判性分析)

---

## 核心命题

### 主定理

**沙箱隔离**：
\[
\forall M_{\text{wasm}}, M_{\text{host}} : \text{Memory}(M_{\text{wasm}}) \cap \text{Memory}(M_{\text{host}}) = \emptyset
\]

**能力约束**：
\[
\text{Access}(R) \iff \exists c \in \text{Capabilities} : \text{grants}(c, R)
\]

**控制流完整性**：
\[
\forall \text{jump} : \text{ValidTarget}(\text{jump}) \vee \text{trap}
\]

**安全性定理**：
\[
\text{Sandbox} \wedge \text{Capability} \wedge \text{CFI} \implies \neg \text{Exploit}
\]

**批判**：
> 这是理论安全性，实践中仍受 Spectre、侧信道、实现漏洞威胁。

---

## 沙箱模型

### 隔离边界

**内存隔离**：
\[
\text{LinearMemory}_{\text{wasm}} : [0, N) \quad (N \leq 2^{32})
\]

**不可访问区域**：
\[
\forall a \notin [0, N) : \text{access}(a) \rightarrow \text{trap}
\]

**宿主内存不可见**：
\[
\neg \exists \text{pointer} : \text{wasm-visible}(\text{pointer} \to \text{host-memory})
\]

**形式化**：
\[
\frac{
  a + \text{sizeof}(t) > |\text{mem}|
}{
  \langle \text{mem}, a, t \rangle \vdash \text{load}(a, t) \rightarrow \text{trap}
} \; \text{[SafeLoad]}
\]

### 栈隔离

**调用栈独立**：
\[
\text{CallStack}_{\text{wasm}} \not\subset \text{CallStack}_{\text{host}}
\]

**返回地址保护**：

- Wasm 函数无法读取/修改返回地址
- 间接跳转仅限表内函数

**形式化保证**：
\[
\forall \text{func-call} : \text{RetAddr} \notin \text{LinearMemory}
\]

### 寄存器隔离

**不可访问寄存器**：

- 指令指针（RIP/EIP）
- 栈指针（RSP/ESP）
- 段寄存器（CS, DS, SS）

**可访问寄存器**：

- 通用寄存器（仅通过局部变量抽象）
- SIMD 寄存器（通过 v128 抽象）

**批判**：
> 寄存器抽象消除了 ROP/JOP 攻击，但编译器仍可能生成易受 Spectre 攻击的代码。

---

## 能力安全

### 能力模型

**定义**：
\[
\text{Capability} = (\text{Resource}, \text{Rights})
\]

**权限**：
\[
\text{Rights} \subseteq \{\text{read}, \text{write}, \text{execute}, \text{grow}, \ldots\}
\]

**授予关系**：
\[
\text{grants}(c, r) \iff c.\text{Resource} = r \wedge c.\text{Rights} \ni \text{op}(r)
\]

### WASI 能力系统

**文件描述符 = 能力句柄**：
\[
\text{fd} : \mathbb{N} \to (\text{Path}, \text{Rights})
\]

**示例**：

```wat
(import "wasi_snapshot_preview1" "fd_read"
  (func $fd_read (param i32 i32 i32 i32) (result i32)))
```

**访问控制**：
\[
\frac{
  \text{fd} \in \text{Capabilities} \wedge \text{read} \in \text{Rights}(\text{fd})
}{
  \text{fd\_read}(\text{fd}, \ldots) \rightarrow \text{success}
} \; \text{[CapRead]}
\]

\[
\frac{
  \text{fd} \notin \text{Capabilities} \vee \text{read} \notin \text{Rights}(\text{fd})
}{
  \text{fd\_read}(\text{fd}, \ldots) \rightarrow \text{error}(EBADF)
} \; \text{[CapDenied]}
\]

### 最小权限原则

**形式化**：
\[
\text{Caps}_{\text{granted}} = \min\{\text{Caps} : \text{Functionality}(\text{Caps})\}
\]

**实践**：

- 默认无能力（白名单）
- 显式传递（`--dir` flag）
- 不可伪造（句柄验证）

**批判**：
> 能力模型优雅但易误用：传递能力句柄 = 传递权限，程序员需理解安全边界。

---

## 内存安全

### 边界检查

**插桩策略**：
\[
\text{load}(a, t) \rightarrow
\begin{cases}
\text{checked-load}(a, t) & \text{if } a + \text{sizeof}(t) \leq |\text{mem}| \\
\text{trap} & \text{otherwise}
\end{cases}
\]

**硬件加速**：

- Intel MPX（已弃用）
- ARM MTE（内存标记扩展）

**开销**：
\[
\text{Overhead}_{\text{bounds-check}} \approx 5-10\%
\]

**优化**：

1. **消除冗余检查**（循环不变量）
2. **合并检查**（连续访问）
3. **信号处理**（页保护 + trap）

### 类型混淆防护

**问题**：间接调用类型不匹配
\[
\text{call\_indirect}(i, \tau) \text{ where table}[i] : \tau' \neq \tau
\]

**防御**：
\[
\frac{
  \text{table}[i] = f \wedge \text{type}(f) = \tau
}{
  \text{call\_indirect}(i, \tau) \rightarrow \text{call}(f)
} \; \text{[TypeMatch]}
\]

\[
\frac{
  \text{table}[i] = f \wedge \text{type}(f) \neq \tau
}{
  \text{call\_indirect}(i, \tau) \rightarrow \text{trap}
} \; \text{[TypeMismatch]}
\]

**批判**：
> 运行时类型检查无法消除，是沙箱安全的必要税。但 C++ 虚函数表攻击的 Wasm 等价物依然存在（表投毒）。

### 无悬垂指针

**保证**：
\[
\forall p : \text{pointer}(p) \implies p \in [0, |\text{mem}|)
\]

**原因**：

- 无指针类型（仅整数索引）
- 内存只能增长（无缩容）

**例外**：

- 外部引用（`externref`）需 GC

---

## 控制流完整性

### 前向边保护

**直接调用**：
\[
\text{call } x : x \in \text{FuncIdx}(M)
\]
（编译期验证，无运行时开销）

**间接调用**：
\[
\text{call\_indirect } x : \text{table}[x] \in \text{FuncRef}
\]
（运行时验证类型签名）

**防御**：

- 表内仅存函数引用（无数据）
- 类型签名匹配检查

### 后向边保护

**返回地址不可修改**：
\[
\text{RetAddr} \notin \text{LinearMemory}
\]

**影子栈**：

- 调用栈与数据栈分离
- 返回时验证返回地址完整性

**批判**：
> CFI 阻止了 ROP/JOP，但无法防御数据流攻击（DOP）。

### 结构化控制流

**定理**：
\[
\forall M : \text{Validate}(M) \implies \text{CFG}(M) \text{ 可归约}
\]

**性质**：

- 无任意 `goto`
- 所有分支目标静态可知
- 循环可嵌套表示

**安全意义**：

- 静态分析可行
- 代码混淆难度增加

---

## 侧信道防御

### 时序侧信道

**问题**：
\[
\text{Time}(\text{strcmp}(s_1, s_2)) \propto \text{CommonPrefix}(s_1, s_2)
\]

**缓解**：

- 常量时间算法（libsodium）
- 防御性编程指南

**局限**：
> Wasm 无法强制常量时间，依赖程序员实现。

### Spectre 防御

**问题**：推测执行泄漏秘密
\[
\text{if (secret < array.length)} \rightarrow \text{推测加载} \rightarrow \text{缓存侧信道}
\]

**缓解**：

1. **禁用 SharedArrayBuffer**（限制高精度定时器）
2. **站点隔离**（浏览器进程隔离）
3. **lfence 插入**（编译器插桩）

**批判**：
> 硬件漏洞无法通过软件完全修复。Wasm 沙箱在 Spectre 面前依然脆弱。

### 缓存侧信道

**攻击向量**：

- Prime+Probe
- Flush+Reload

**防御**：

- 缓存分区（硬件支持）
- 随机化内存布局
- 禁用高精度定时器

---

## 形式化验证

### 安全性质

**P1（内存安全）**：
\[
\forall M, s : \text{Exec}(M, s) \not\rightarrow \text{SegFault}
\]

**P2（控制流完整性）**：
\[
\forall M : \text{JumpTargets}(M) \subseteq \text{ValidLabels}(M)
\]

**P3（类型安全）**：
\[
\forall M : \text{Validate}(M) \implies \neg \text{TypeConfusion}(M)
\]

### 定理证明

**Isabelle/Wasm 证明**：

```isabelle
theorem memory_safety:
  "⟦ valid_module M; exec M s s' ⟧ ⟹ ¬ segfault s'"
```

**Coq 证明**：

```coq
Theorem cfi_preserved : forall M pc,
  validated M ->
  jump_target M pc ->
  valid_label M pc.
```

---

## 攻击面分析

### 攻击向量分类

| 向量 | 威胁 | 防御 | 剩余风险 |
|------|------|------|---------|
| **栈溢出** | ROP | 栈隔离 | 无 |
| **堆溢出** | 任意写 | 边界检查 | 低 |
| **UAF** | 悬垂指针 | 无指针类型 | 外部引用需 GC |
| **类型混淆** | 虚表劫持 | 运行时检查 | 表投毒 |
| **Spectre** | 推测泄漏 | 站点隔离 + lfence | 高 |
| **侧信道** | 时序泄漏 | 程序员责任 | 高 |
| **DoS** | 资源耗尽 | 燃料限制（区块链） | 中 |

### 实际漏洞案例

**CVE-2019-5825**（Chrome V8）：

- 类型混淆 → RCE
- 根源：JIT 优化错误
- 教训：JIT 是复杂攻击面

**CVE-2020-16012**（Firefox）：

- Wasm 代码生成溢出
- 根源：AOT 编译器缓冲区管理
- 教训：编译器也需验证

**批判**：
> Wasm 规范安全，实现未必安全。攻击面从字节码转移到运行时。

---

## 安全审计清单

### 设计审计

- [ ] 所有系统调用通过 WASI 能力化
- [ ] 默认无权限（白名单）
- [ ] 敏感操作需显式导入
- [ ] 线性内存大小限制
- [ ] 调用栈深度限制

### 实现审计

- [ ] 边界检查无遗漏
- [ ] 整数溢出检查（`div_s`, `trunc`）
- [ ] 间接调用类型验证
- [ ] 内存增长原子性
- [ ] 异常处理路径安全

### 部署审计

- [ ] 沙箱进程隔离（浏览器）
- [ ] 资源配额（CPU、内存）
- [ ] 日志审计
- [ ] 安全更新机制

---

## 批判性分析

### 沙箱的本质局限

**命题**：
\[
\text{StrongIsolation} \implies \text{HighOverhead} \vee \text{LimitedFunctionality}
\]

**论证**：

- 完美隔离 → 无系统调用 → 无用
- 有限隔离 → 能力泄漏 → 不安全
- 权衡：能力安全 + 运行时检查

**哲学反思**：
> 安全与功能本质对立。沙箱是"最小不安全"的妥协，而非"绝对安全"的承诺。

### 信任边界

**信任链**：

```
源码 → 编译器 → 字节码 → 验证器 → JIT → 硬件
  ↓       ↓         ↓         ↓        ↓       ↓
 信任    信任      验证      信任     信任   不信任
```

**批判**：

- 编译器可插入后门
- JIT 可有漏洞
- 硬件有 Spectre

**结论**：
> Wasm 安全性依赖整条信任链。任何一环断裂，沙箱随之失效。

### 形式化的盲区

**未覆盖领域**：

1. **侧信道**：形式化难以建模物理泄漏
2. **DoS**：资源耗尽难以静态分析
3. **社会工程**：钓鱼、欺骗

**批判**：
> 形式化验证保证"符合规范"，不保证"规范正确"。规范本身可能有设计缺陷。

---

## 案例研究：OPA 策略沙箱

### 问题

如何安全执行用户上传的 Rego 策略？

### 解决方案

1. **编译为 Wasm**：`opa build -t wasm policy.rego`
2. **资源限制**：限制内存（1 MB）、时间（100 ms）
3. **能力限制**：仅导入 `opa_eval`、`opa_malloc`
4. **隔离执行**：每策略独立实例

### 安全性分析

**威胁模型**：

- 恶意策略 DoS
- 策略间信息泄漏
- 策略逃逸沙箱

**防御机制**：

- Wasm 沙箱隔离
- 资源配额
- 超时 trap

**剩余风险**：

- 侧信道时序泄漏
- 恶意策略影响其他租户性能

---

## 未来方向

### 内存标记（Memory Tagging）

**提案**：为内存字节附加标签
\[
\text{Tagged-Memory} : \text{Addr} \to (\mathbb{Z}_8, \text{Tag})
\]

**安全性**：

- 防 UAF
- 防堆溢出

### 线性类型（Linear Types）

**目标**：保证资源使用一次
\[
\text{use-once}(r)
\]

**应用**：

- 外部引用生命周期
- 零拷贝内存管理

### 信息流控制（IFC）

**目标**：防止秘密泄漏
\[
\text{Secret} \not\leadsto \text{Public}
\]

**挑战**：

- 标签传播
- 隐式流检测

---

## 参考文献

1. **[Miller06]** Mark S. Miller et al. "Capability Myths Demolished." Technical Report SRL 2003-02, 2003.
2. **[Szekeres13]** Laszlo Szekeres et al. "SoK: Eternal War in Memory." Oakland, 2013.
3. **[Kocher18]** Paul Kocher et al. "Spectre Attacks: Exploiting Speculative Execution." Oakland, 2019.
4. **[Watt18]** Conrad Watt et al. "CT-Wasm: Type-driven Secure Cryptography for the Web." POPL, 2019.

---

**结论**：
> WebAssembly 的安全模型通过沙箱、能力控制和 CFI 构建了多层防御，但非银弹：侧信道、硬件漏洞、实现错误仍是威胁。安全是持续的博弈，而非一劳永逸的状态。从形式化到实践，存在不可消除的语义鸿沟。
