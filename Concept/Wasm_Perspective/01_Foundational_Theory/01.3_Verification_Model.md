# 1.3 验证模型 (Verification Model)

## 目录

- [核心命题](#核心命题)
- [验证算法](#验证算法)
- [符号执行](#符号执行)
- [抽象解释](#抽象解释)
- [模型检测](#模型检测)
- [批判性分析](#批判性分析)

---

## 核心命题

### 主定理

**验证完备性**：
\[
\forall M : \text{Validate}(M) = \top \iff \forall \text{exec-path} : \neg \text{UndefinedBehavior}(\text{exec-path})
\]

**验证复杂度**：
\[
\text{Time}(\text{Validate}) = O(|M|) \quad \text{（线性时间）}
\]

**可判定性**：
\[
\exists \text{决策算法} : \text{ValidModule} \in \text{PTIME}
\]

---

## 验证算法

### 模块验证流程

**输入**：字节码模块 \( M = \langle \text{sections} \rangle \)
**输出**：\( \top \)（合法）或 \( \bot \)（拒绝）+ 错误信息

**五阶段验证**：

```
┌──────────────┐
│ 1. 结构验证  │  → 段顺序、魔数、版本
└──────┬───────┘
       ↓
┌──────────────┐
│ 2. 类型验证  │  → 函数签名、类型一致性
└──────┬───────┘
       ↓
┌──────────────┐
│ 3. 栈验证    │  → 操作数栈平衡、深度
└──────┬───────┘
       ↓
┌──────────────┐
│ 4. 控制流验证│  → 标签匹配、跳转合法性
└──────┬───────┘
       ↓
┌──────────────┐
│ 5. 初始化验证│  → 全局变量、表、内存初始化
└──────┬───────┘
       ↓
     accept / reject
```

### 类型栈验证器

**抽象状态**：
\[
\Sigma = \{\text{栈类型}, \text{标签栈}, \text{不可达标志}\}
\]

**转移函数**：
\[
\delta : \Sigma \times \text{Instr} \to \Sigma \cup \{\bot\}
\]

**算法伪代码**：

```python
def validate_instruction_sequence(instrs, context):
    stack = []
    label_stack = []
    unreachable = False

    for instr in instrs:
        match instr:
            case I32Const(n):
                stack.push(I32)

            case I32Add:
                if len(stack) < 2 or stack[-2:] != [I32, I32]:
                    return error("type mismatch")
                stack.pop(); stack.pop()
                stack.push(I32)

            case Block(blocktype, body):
                label_type = blocktype.results
                label_stack.push(label_type)
                validate_instruction_sequence(body, context)
                label_stack.pop()
                stack.extend(label_type)

            case Br(labelidx):
                if labelidx >= len(label_stack):
                    return error("unknown label")
                target_type = label_stack[-(labelidx+1)]
                if stack[-len(target_type):] != target_type:
                    return error("type mismatch")
                stack = []  # unreachable
                unreachable = True

            case End:
                if label_stack.is_empty():
                    return error("unmatched end")

            ...

    return success
```

**不变式**：
\[
\forall i : \text{valid}(\text{state}_i) \implies \text{valid}(\delta(\text{state}_i, \text{instr}_i))
\]

### 控制流完整性

**标签栈不变性**：
\[
\forall \texttt{block} \cdots \texttt{end} : |\text{labels}_{\text{enter}}| + 1 = |\text{labels}_{\text{exit}}|
\]

**跳转合法性**：
\[
\texttt{br } i \text{ valid} \iff i < |\text{labels}| \wedge \text{stack-match}(\text{labels}[i])
\]

**结构化控制流定理**：
\[
\forall M : \text{Validate}(M) \implies \text{structured}(\text{CFG}(M))
\]
其中结构化 = 无任意 `goto`，所有控制流可嵌套表示。

---

## 符号执行

### 符号状态

**状态空间**：
\[
\text{SymState} = \text{SymStack} \times \text{SymMem} \times \text{SymGlobals}
\]

**符号值**：
\[
\text{SymVal} ::= \text{Concrete}(v) \mid \text{Symbolic}(\alpha) \mid \text{SymOp}(\text{op}, \text{SymVal}^*)
\]

**路径条件**：
\[
\Phi = \bigwedge \text{constraints}
\]

### 符号执行规则

**算术指令**：
\[
\frac{
  \text{stack} = [s_2, s_1 | S] \quad
  s' = \text{SymAdd}(s_1, s_2)
}{
  \langle [s_2, s_1 | S], \Phi \rangle \xrightarrow{\texttt{i32.add}} \langle [s' | S], \Phi \rangle
}
\]

**分支指令**：
\[
\frac{
  \text{stack} = [s | S]
}{
  \begin{align*}
  &\langle [s | S], \Phi \rangle \xrightarrow{\texttt{if}} \\
  &\quad \{\langle S_{\text{then}}, \Phi \wedge (s \neq 0) \rangle, \langle S_{\text{else}}, \Phi \wedge (s = 0) \rangle\}
  \end{align*}
}
\]

**路径爆炸问题**：
\[
|\text{Paths}(n_{\text{branches}})| = 2^{n_{\text{branches}}}
\]

**缓解策略**：

1. **路径合并**（Path Merging）：合并等价路径
2. **懒惰约束求解**：延迟 SAT/SMT 查询
3. **有界符号执行**：限制展开深度

### 可满足性检查

**路径可行性**：
\[
\text{Feasible}(\Phi) \iff \exists \sigma : \text{SAT}(\Phi[\sigma])
\]

**SMT 编码示例**：

```smt2
(declare-const a Int)
(declare-const b Int)
(assert (bvslt a b))              ; symbolic i32.lt_s
(assert (= (bvadd a b) #x00000000))  ; symbolic i32.add
(check-sat)  ; sat / unsat
```

**复杂度**：
\[
\text{SMT-Solving} \in \text{NP-complete} \text{（对线性算术）}
\]

---

## 抽象解释

### 抽象域设计

**符号抽象域**（Sign Analysis）：
\[
\text{Sign} = \{\bot, -, 0, +, \top\}
\]

**格结构**：

```
        ⊤
       /|\
      / | \
     -  0  +
      \ | /
       \|/
        ⊥
```

**抽象运算**：
\[
\begin{align*}

- \oplus^{\#} + &= + \\

- \oplus^{\#} - &= - \\

- \oplus^{\#} - &= \top \\
0 \oplus^{\#} a &= a
\end{align*}
\]

### 区间抽象

**区间域**：
\[
\text{Interval} = \{[a, b] \mid a, b \in \mathbb{Z} \cup \{-\infty, +\infty\}, a \leq b\}
\]

**抽象加法**：
\[
[a_1, b_1] +^{\#} [a_2, b_2] = [a_1 + a_2, b_1 + b_2]
\]

**抽象乘法**：
\[
[a_1, b_1] \times^{\#} [a_2, b_2] = [\min(S), \max(S)]
\]
其中 \( S = \{a_1 a_2, a_1 b_2, b_1 a_2, b_1 b_2\} \)

**环绕处理**（Wasm 特有）：
\[
[a, b] +_{\text{wrap}}^{\#} [c, d] =
\begin{cases}
[a+c \bmod 2^{32}, b+d \bmod 2^{32}] & \text{if no overflow} \\
[0, 2^{32}-1] & \text{otherwise （保守过近似）}
\end{cases}
\]

### Widening 算子

**问题**：循环导致不动点迭代不终止。

**解决方案**（Widening）：
\[
\nabla : D \times D \to D
\]
满足：

1. \( x \sqsubseteq x \nabla y \)
2. \( y \sqsubseteq x \nabla y \)
3. 升链有限

**区间 Widening**：
\[
[a, b] \nabla [c, d] =
\begin{cases}
[-\infty, b] & \text{if } c < a \\
[a, +\infty] & \text{if } d > b \\
[a, b] & \text{otherwise}
\end{cases}
\]

### 不动点计算

**Kleene 迭代**：
\[
X_0 = \bot, \quad X_{n+1} = F(X_n)
\]

**加速策略**：
\[
X_{n+1} = X_n \nabla F(X_n) \quad \text{（应用 Widening）}
\]

**收敛保证**：
\[
\exists N : X_N = X_{N+1} \quad (N \leq \text{格高度})
\]

---

## 模型检测

### 有界模型检测 (BMC)

**问题**：验证性质 \( \phi \) 在深度 \( k \) 内成立？

**编码**：
\[
\text{BMC}(M, \phi, k) = \bigwedge_{i=0}^{k} T(s_i, s_{i+1}) \wedge \neg \phi(s_k)
\]

**可满足性**：
\[
\text{SAT}(\text{BMC}) \implies \exists \text{反例路径}
\]

**示例：内存安全检查**

性质：
\[
\phi_{\text{safe}} = \forall a : \text{load}(a) \implies a < |\text{mem}|
\]

BMC 编码：

```smt2
(assert (forall ((addr Int))
  (=> (load addr) (< addr mem-size))))
```

### 归纳不变式推断

**目标**：找到 \( \text{Inv} \) 使得：
\[
\begin{align*}
&\text{Init}(s_0) \implies \text{Inv}(s_0) \\
&\text{Inv}(s) \wedge T(s, s') \implies \text{Inv}(s') \\
&\text{Inv}(s) \implies \phi(s)
\end{align*}
\]

**推断技术**：

1. **模板推断**：预定义不变式形式（如 \( x \leq c \)）
2. **插值**：从反例路径提取分离性质
3. **数据驱动**：机器学习辅助

**挑战**：
\[
\text{InvariantInference} \in \text{undecidable} \quad \text{（一般情况）}
\]

---

## 验证工具链

| 工具 | 方法 | 覆盖范围 | 完备性 |
|------|------|---------|--------|
| **wasp** | 轻量验证器 | 类型 + 栈 | 100% (MVP) |
| **WAVM** | 即时验证 | 类型 + 控制流 | 100% (MVP + SIMD) |
| **Wasm-Verify** | 符号执行 | 函数级性质 | 有界完备 |
| **K-Wasm** | 可达性分析 | 全程序 | 理论完备，实践受限 |
| **Wasm-Coq** | 定理证明 | 规范一致性 | 数学完备 |

---

## 批判性分析

### 验证的语义鸿沟

**问题**：
\[
\text{Validate}(M) = \top \not\Rightarrow \text{CorrectBehavior}(M)
\]

**原因**：

1. **类型安全 ≠ 内存安全**：可通过验证的越界访问
2. **控制流完整 ≠ 逻辑正确**：死锁、活锁无法检测
3. **确定性 ≠ 安全**：侧信道攻击依然可行

**案例**：

```wasm
(func $oob
  i32.const 0xFFFFFFFF  ;; 接近上界
  i32.const 10
  i32.add               ;; 环绕到 9，通过验证
  i32.load              ;; 但实际访问非法地址，trap
)
```

### 完备性 vs 可判定性

**哥德尔障碍**：
\[
\exists P : \text{Halts}(P) \text{ 不可判定}
\]

**实践影响**：

- 全程序验证不可行
- 必须退回有界验证

**哲学反思**：
> 形式化验证承诺"绝对安全"，但哥德尔不完备性定理揭示：任何足够强的形式系统都有无法证明的真命题。验证的终极追求终将碰壁。

### 验证成本的经济学

**时间成本**：
\[
T_{\text{validate}} = O(n) \approx 1-2 \text{ ms/MB}
\]

**空间成本**：
\[
\text{Memory}_{\text{validator}} \approx 2 \times \text{Size}(M)
\]

**权衡**：

- 浏览器：每次加载验证（安全优先）
- 边缘计算：离线 AOT（性能优先）

**批判**：
> 验证税是沙箱安全的必要代价，但在资源受限环境（IoT）可能成为瓶颈。这是安全与性能永恒博弈的缩影。

---

## 案例研究：多返回值验证

### 问题

函数 `f : [i32] -> [i32, i32]` 的验证？

### 类型规则

\[
\frac{
  C.\text{types}[x] = [t_1^_] \to [t_2^_]
}{
  C \vdash \texttt{call } x : [t_1^_] \to [t_2^_]
}
\]

### 栈验证

**调用前**：

```
stack = [arg : S]
```

**调用后**：

```
stack = [ret2 : ret1 : S]  // 注意顺序！
```

**验证器状态转移**：

```python
def validate_call(funcidx, stack):
    func_type = context.types[funcidx]
    param_types, result_types = func_type

    # 检查参数
    if stack[-len(param_types):] != param_types:
        return error("type mismatch")

    # 弹出参数，压入返回值
    stack = stack[:-len(param_types)]
    stack.extend(result_types)

    return stack
```

**边界情况**：

- 0 返回值：`[] -> []` （可能的副作用）
- 多返回值顺序：栈顶为最后返回值

---

## 未来方向

### 依赖类型扩展

**提案**：精化类型（Refinement Types）
\[
\{v : \texttt{i32} \mid 0 \leq v < n\}
\]

**挑战**：

- SMT 求解器集成
- 验证复杂度爆炸

### 线性类型

**目标**：保证资源使用一次
\[
\text{use-once}(\text{resource})
\]

**应用**：

- 外部引用生命周期
- 零拷贝内存管理

---

## 参考文献

1. **[Cousot77]** Patrick Cousot and Radhia Cousot. "Abstract Interpretation: A Unified Lattice Model." POPL, 1977.
2. **[King76]** James C. King. "Symbolic Execution and Program Testing." CACM, 1976.
3. **[Clarke00]** Edmund Clarke et al. "Model Checking." MIT Press, 2000.
4. **[Watt18]** Conrad Watt. "Mechanising and Verifying the WebAssembly Specification." CPP, 2018.

---

**结论**：
> WebAssembly 的线性时间验证算法在工程上是奇迹，但在逻辑上是妥协：它选择了可判定的子集，放弃了全程序正确性证明。验证的边界，即是理论完备性与工程可行性的边界。
