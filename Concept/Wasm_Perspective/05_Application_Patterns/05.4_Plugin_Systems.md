# 5.4 插件系统 (Plugin Systems)

## 目录

- [5.4 插件系统 (Plugin Systems)](#54-插件系统-plugin-systems)
  - [目录](#目录)
  - [核心命题](#核心命题)
  - [1 架构模式](#1-架构模式)
    - [1 宿主-插件接口](#1-宿主-插件接口)
    - [1.2 生命周期管理](#12-生命周期管理)
  - [2 实践案例](#2-实践案例)
    - [1 VS Code Extensions](#1-vs-code-extensions)
    - [2.2 Figma Plugins](#22-figma-plugins)
  - [3 批判性分析](#3-批判性分析)
  - [参考文献](#参考文献)

## 核心命题

**沙箱隔离定理**：
\[
\text{Plugin-Fault} \not\Rightarrow \text{Host-Crash}
\]

**接口稳定性**：
\[
\text{ABI-Stable} \implies \text{Plugin-Compatible}(\text{v1}, \text{v2})
\]

**性能目标**：
\[
C_{\text{plugin-call}} < 1\mu\text{s}
\]

---

## 1 架构模式

### 1 宿主-插件接口

**双向调用**：

```text
┌────────────┐
│   Host     │
│  (Rust)    │
└─────┬──────┘
      │ ↕ (import/export)
┌─────┴──────┐
│  Plugin    │
│  (Wasm)    │
└────────────┘
```

**接口定义（WIT）**：

```wit
interface plugin {
    // 插件实现
    init: func(config: string) -> result<_, error>
    process: func(input: list<u8>) -> result<list<u8>, error>
    shutdown: func()
}

interface host {
    // 宿主提供
    log: func(level: log-level, message: string)
    get-config: func(key: string) -> option<string>
    allocate: func(size: u32) -> u32
}
```

### 1.2 生命周期管理

**状态转移**：

```
[Loaded] → [Initialized] → [Active] → [Suspended] → [Unloaded]
  加载        初始化        运行中      挂起          卸载
```

**代码示例**：

```rust
struct PluginManager {
    plugins: HashMap<String, Plugin>,
}

impl PluginManager {
    fn load_plugin(&mut self, path: &str) -> Result<()> {
        let module = Module::from_file(&self.engine, path)?;
        let instance = Instance::new(&mut self.store, &module, &[])?;

        // 调用插件初始化
        let init = instance.get_typed_func::<(), ()>(&mut self.store, "init")?;
        init.call(&mut self.store, ())?;

        self.plugins.insert(path.to_string(), Plugin { instance });
        Ok(())
    }

    fn unload_plugin(&mut self, name: &str) -> Result<()> {
        if let Some(plugin) = self.plugins.get(name) {
            // 调用清理
            let shutdown = plugin.instance.get_typed_func::<(), ()>(...)?;
            shutdown.call(&mut self.store, ())?;
        }
        self.plugins.remove(name);
        Ok(())
    }
}
```

---

## 2 实践案例

### 1 VS Code Extensions

**架构**（假设 Wasm 支持）：

```typescript
// 宿主 API
const vscode = {
    window: {
        showInformationMessage(msg: string): void;
    },
    workspace: {
        openTextDocument(uri: Uri): TextDocument;
    }
};

// 插件实现
export function activate(context: ExtensionContext) {
    const command = vscode.commands.registerCommand('extension.hello', () => {
        vscode.window.showInformationMessage('Hello from Wasm!');
    });
    context.subscriptions.push(command);
}
```

**优势**：

- 隔离：插件崩溃不影响 IDE
- 安全：无法访问文件系统（除授权）
- 性能：启动快，内存占用小

### 2.2 Figma Plugins

**沙箱限制**：

```javascript
// 允许
figma.createRectangle();
figma.currentPage.appendChild(rect);

// 禁止
fetch('https://evil.com');  // 网络访问受限
require('fs');               // 无 Node.js API
```

**性能数据**：

- 插件启动：<100ms
- 调用延迟：<1ms
- 内存隔离：独立堆

---

## 3 批判性分析

**命题**：
\[
\text{Plugin-Safety} \propto \frac{1}{\text{Plugin-Capability}}
\]

**权衡**：

- 安全 ↑ ⇒ 功能 ↓
- 性能 ↑ ⇒ 隔离 ↓

**批判**：
> 插件系统是"受控的开放性"：允许扩展，但限制危险操作。Wasm 提供了技术基础，但策略设计依然困难——哪些 API 应暴露？如何审计插件行为？

---

## 参考文献

1. **[Extism]** "The Universal Plug-in System." https://extism.org/
2. **[Shopify]** "Wasm Functions." 2023.
