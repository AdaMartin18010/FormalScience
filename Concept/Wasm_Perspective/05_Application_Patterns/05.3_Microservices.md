# 5.3 微服务网格 (Microservices & Service Mesh)

## 目录

- [5.3 微服务网格 (Microservices \& Service Mesh)](#53-微服务网格-microservices--service-mesh)
  - [目录](#目录)
  - [核心命题](#核心命题)
  - [Envoy Proxy 集成](#envoy-proxy-集成)
    - [架构](#架构)
    - [过滤器实现](#过滤器实现)
  - [服务治理](#服务治理)
    - [灰度发布](#灰度发布)
    - [熔断器](#熔断器)
  - [批判性分析](#批判性分析)
  - [参考文献](#参考文献)

## 核心命题

**Sidecar 模式**：
\[
\text{Service} + \text{Wasm-Proxy} = \text{可扩展网关}
\]

**性能目标**：
\[
\text{Overhead}_{\text{wasm-filter}} < 100\mu\text{s/request}
\]

**隔离保证**：
\[
\text{Plugin-Crash} \not\Rightarrow \text{Proxy-Crash}
\]

---

## Envoy Proxy 集成

### 架构

**请求流**：

```
Client → Envoy Listener
       ↓
     HTTP Filter (Wasm)
       ↓ (可选修改)
     Upstream Service
```

**配置示例**：

```yaml
http_filters:
  - name: envoy.filters.http.wasm
    typed_config:
      "@type": type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm
      config:
        vm_config:
          runtime: "envoy.wasm.runtime.v8"
          code:
            local: { filename: "filter.wasm" }
        configuration:
          "@type": type.googleapis.com/google.protobuf.StringValue
          value: |
            {}
```

### 过滤器实现

**Rust 示例（proxy-wasm）**：

```rust
use proxy_wasm::traits::*;
use proxy_wasm::types::*;

struct RateLimitFilter;

impl HttpContext for RateLimitFilter {
    fn on_http_request_headers(&mut self, _: usize) -> Action {
        let path = self.get_http_request_header(":path").unwrap();

        if !check_rate_limit(&path) {
            self.send_http_response(
                429,
                vec![("content-type", "text/plain")],
                Some(b"Too Many Requests"),
            );
            return Action::Pause;
        }
        Action::Continue
    }
}
```

**性能数据**：

- 过滤器延迟：50-200μs
- 吞吐影响：<5%
- 内存占用：+10MB

---

## 服务治理

### 灰度发布

**流量分配**：
\[
\text{Traffic}(\text{v1}) = (1 - \alpha) \times \text{Total}
\]
\[
\text{Traffic}(\text{v2}) = \alpha \times \text{Total}
\]

**Wasm 实现**：

```rust
fn route_request(&self, headers: &Headers) -> &str {
    let canary_header = headers.get("x-canary-user");

    if canary_header.is_some() {
        return "v2-backend";  // 金丝雀用户
    }

    let random = rand::random::<f32>();
    if random < 0.05 {  // 5% 流量
        "v2-backend"
    } else {
        "v1-backend"
    }
}
```

### 熔断器

**状态机**：

```
[Closed] ─(failures > threshold)→ [Open]
    ↑                                 │
    └──(success after timeout)────────┘
```

**实现**：

```rust
struct CircuitBreaker {
    state: State,
    failure_count: u32,
    threshold: u32,
    timeout: Duration,
}

impl CircuitBreaker {
    fn allow_request(&mut self) -> bool {
        match self.state {
            State::Closed => true,
            State::Open => {
                if Instant::now() - self.open_time > self.timeout {
                    self.state = State::HalfOpen;
                    true
                } else {
                    false
                }
            },
            State::HalfOpen => true,
        }
    }
}
```

---

## 批判性分析

**命题**：
\[
\text{Wasm-Filter} = \text{灵活性} + \text{隔离} - \text{性能}
\]

**开销来源**：

- 跨边界调用：每次请求 2-4 次
- 序列化成本：Header 转换
- 沙箱限制：无法直接访问网络

**批判**：
> Wasm 过滤器是"可接受的折衷"：牺牲微秒级性能换取动态扩展与安全隔离。适合策略逻辑，不适合高频数据转换。

---

## 参考文献

1. **[Envoy]** "Envoy Wasm." https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/wasm_filter
2. **[Istio]** "Wasm Plugin Development." 2024.
