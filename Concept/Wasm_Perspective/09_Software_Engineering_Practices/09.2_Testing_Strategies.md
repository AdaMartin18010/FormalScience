# 9.2 测试策略 (Testing Strategies)

## 核心命题

**测试覆盖定理**：
\[
\text{BugDetection}(\text{TestSuite}) \leq f(\text{Coverage}, \text{Quality}, \text{Diversity})
\]

**测试成本方程**：
\[
\text{Cost}_{\text{bug in production}} \gg \text{Cost}_{\text{testing}} + \text{Cost}_{\text{bug in dev}}
\]

**Wasm 测试挑战**：
\[
\text{Testability}_{\text{Wasm}} < \text{Testability}_{\text{Native}} \quad (\text{工具链限制})
\]

---

## 单元测试

### Rust + wasm-bindgen-test

**测试框架**：

```rust
// src/lib.rs
#[wasm_bindgen]
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

// tests/web.rs
#[cfg(test)]
mod tests {
    use super::*;
    use wasm_bindgen_test::*;

    wasm_bindgen_test_configure!(run_in_browser);

    #[wasm_bindgen_test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }

    #[wasm_bindgen_test]
    async fn test_async_operation() {
        let result = async_fetch_data().await;
        assert!(result.is_ok());
    }
}
```

**运行测试**：

```bash
# 浏览器测试
wasm-pack test --headless --firefox

# Node.js 测试
wasm-pack test --node

# 指定浏览器
wasm-pack test --chrome --geckodriver
```

**覆盖率收集**：

```bash
# 安装 tarpaulin
cargo install cargo-tarpaulin

# 生成覆盖率报告
cargo tarpaulin --target wasm32-wasi --out Html --output-dir coverage
```

### C++ + Google Test

**测试代码**：

```cpp
// test.cpp
#include <gtest/gtest.h>
#include <emscripten.h>

extern "C" int calculate(int a, int b);

TEST(CalculateTest, BasicOperation) {
    EXPECT_EQ(calculate(2, 3), 5);
}

TEST(CalculateTest, NegativeNumbers) {
    EXPECT_EQ(calculate(-1, -2), -3);
}

int main(int argc, char **argv) {
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

**编译测试**：

```bash
# 编译为 Wasm
emcc test.cpp -s WASM=1 -s NODERAWFS=1 \
    -lgtest -lgtest_main -pthread \
    -o test.js

# 运行测试
node test.js
```

### AssemblyScript + as-pect

**测试代码**：

```typescript
// assembly/__tests__/example.spec.ts
import { fibonacci } from "../index";

describe("Fibonacci", () => {
  it("should return 0 for n=0", () => {
    expect(fibonacci(0)).toBe(0);
  });

  it("should return 1 for n=1", () => {
    expect(fibonacci(1)).toBe(1);
  });

  it("should calculate correctly", () => {
    expect(fibonacci(10)).toBe(55);
  });
});
```

**运行测试**：

```bash
npm test
```

---

## 集成测试

### JavaScript/TypeScript 集成测试

**Vitest 示例**：

```typescript
// tests/integration.test.ts
import { describe, it, expect, beforeAll } from 'vitest';
import init, { greet, process_data } from '../pkg/mylib';

describe('Wasm Integration', () => {
  beforeAll(async () => {
    await init();
  });

  it('should greet correctly', () => {
    expect(greet('World')).toBe('Hello, World!');
  });

  it('should process large data', () => {
    const input = new Uint8Array(1000000);
    const output = process_data(input);
    expect(output.length).toBe(1000000);
  });

  it('should handle errors gracefully', () => {
    expect(() => process_data(null)).toThrow();
  });
});
```

**性能基准测试**：

```typescript
// tests/benchmark.test.ts
import { bench } from 'vitest';
import { wasmFunction, jsFunction } from '../src';

bench('Wasm implementation', () => {
  wasmFunction(largeInput);
});

bench('JS implementation', () => {
  jsFunction(largeInput);
});
```

### 跨运行时测试

**测试矩阵**：

```yaml
# .github/workflows/test.yml
strategy:
  matrix:
    runtime:
      - wasmtime
      - wasmer
      - wasmedge
      - nodejs
      - deno
      - chrome
      - firefox
```

**统一测试接口**：

```bash
#!/bin/bash
# test_all_runtimes.sh

echo "Testing with Wasmtime..."
wasmtime module.wasm --invoke main

echo "Testing with Wasmer..."
wasmer run module.wasm

echo "Testing with WasmEdge..."
wasmedge module.wasm

echo "Testing in Node.js..."
node test.js

echo "Testing in Deno..."
deno run --allow-read test.ts
```

---

## 端到端测试

### Playwright + Wasm

**E2E 测试**：

```typescript
// tests/e2e/app.spec.ts
import { test, expect } from '@playwright/test';

test('Wasm app loads and functions', async ({ page }) => {
  await page.goto('http://localhost:3000');

  // 等待 Wasm 加载
  await page.waitForFunction(() => window.wasmReady === true);

  // 测试交互
  await page.click('#compute-button');

  // 验证结果
  const result = await page.textContent('#result');
  expect(result).toBe('42');

  // 性能测试
  const metrics = await page.evaluate(() => performance.getEntriesByType('measure'));
  const wasmLoad = metrics.find(m => m.name === 'wasm-load');
  expect(wasmLoad.duration).toBeLessThan(1000); // < 1秒
});

test('handles large file upload', async ({ page }) => {
  await page.goto('http://localhost:3000');

  // 上传 10MB 文件
  const fileInput = await page.locator('input[type="file"]');
  await fileInput.setInputFiles({
    name: 'test.bin',
    mimeType: 'application/octet-stream',
    buffer: Buffer.alloc(10 * 1024 * 1024),
  });

  // Wasm 处理
  await page.click('#process-button');
  await page.waitForSelector('#progress[value="100"]');

  // 验证输出
  const output = await page.getAttribute('#download-link', 'href');
  expect(output).toMatch(/^blob:/);
});
```

### Selenium + Wasm

**跨浏览器测试**：

```python
# tests/test_cross_browser.py
from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait

def test_chrome():
    driver = webdriver.Chrome()
    run_wasm_tests(driver)

def test_firefox():
    driver = webdriver.Firefox()
    run_wasm_tests(driver)

def test_safari():
    driver = webdriver.Safari()
    run_wasm_tests(driver)

def run_wasm_tests(driver):
    driver.get("http://localhost:3000")

    # 等待 Wasm 加载
    WebDriverWait(driver, 10).until(
        lambda d: d.execute_script("return window.wasmLoaded")
    )

    # 执行测试
    result = driver.execute_script("return window.wasmModule.compute(42)")
    assert result == 1764
```

---

## 性能测试

### Benchmark 框架

**Criterion (Rust)**：

```rust
// benches/benchmark.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use mylib::expensive_function;

fn bench_expensive(c: &mut Criterion) {
    c.bench_function("expensive 1000", |b| {
        b.iter(|| expensive_function(black_box(1000)))
    });
}

criterion_group!(benches, bench_expensive);
criterion_main!(benches);
```

**运行基准**：

```bash
cargo bench --target wasm32-wasi
```

### 内存性能测试

**内存泄漏检测**：

```javascript
// tests/memory-leak.test.js
import { test } from 'vitest';

test('no memory leak in repeated operations', async () => {
  const iterations = 10000;
  const measurements = [];

  for (let i = 0; i < iterations; i++) {
    wasmModule.allocate_and_process();

    if (i % 1000 === 0) {
      // 强制 GC（仅 Node.js）
      if (global.gc) global.gc();

      const usage = process.memoryUsage();
      measurements.push(usage.heapUsed);
    }
  }

  // 检查内存是否持续增长
  const slope = linearRegression(measurements);
  expect(Math.abs(slope)).toBeLessThan(1000); // 每千次操作 < 1KB 增长
});
```

**WebAssembly 内存增长测试**：

```javascript
test('Wasm linear memory grows correctly', () => {
  const module = new WebAssembly.Module(wasmBytes);
  const memory = new WebAssembly.Memory({ initial: 1, maximum: 10 });
  const instance = new WebAssembly.Instance(module, { env: { memory } });

  expect(memory.buffer.byteLength).toBe(65536); // 1 page

  instance.exports.allocate_large_buffer();

  expect(memory.buffer.byteLength).toBeGreaterThan(65536);
  expect(memory.buffer.byteLength).toBeLessThanOrEqual(655360); // ≤ 10 pages
});
```

### 启动性能测试

**冷启动测试**：

```javascript
test('cold start performance', async () => {
  const start = performance.now();

  // 加载 + 编译 + 实例化
  const module = await WebAssembly.compileStreaming(fetch('module.wasm'));
  const instance = await WebAssembly.instantiate(module);

  const end = performance.now();
  const loadTime = end - start;

  console.log(`Cold start: ${loadTime}ms`);
  expect(loadTime).toBeLessThan(100); // < 100ms
});
```

---

## 模糊测试 (Fuzzing)

### Cargo-fuzz

**模糊测试目标**：

```rust
// fuzz/fuzz_targets/parser.rs
#![no_main]
use libfuzzer_sys::fuzz_target;
use mylib::parse_input;

fuzz_target!(|data: &[u8]| {
    // 测试解析器不会 panic
    let _ = parse_input(data);
});
```

**运行模糊测试**：

```bash
cargo fuzz run parser -- -max_total_time=3600
```

### wasm-tools smith

**生成随机 Wasm 模块**：

```bash
# 生成 1000 个随机模块
for i in {1..1000}; do
  wasm-tools smith -o fuzz_$i.wasm

  # 验证生成的模块
  wasm-validate fuzz_$i.wasm

  # 测试运行时
  wasmtime fuzz_$i.wasm || echo "Failed: fuzz_$i.wasm"
done
```

### 差异测试 (Differential Testing)

**对比不同运行时**：

```python
# diff_test.py
import subprocess

def run_in_runtime(wasm_file, runtime):
    cmd = [runtime, wasm_file]
    result = subprocess.run(cmd, capture_output=True, text=True)
    return result.stdout

runtimes = ['wasmtime', 'wasmer', 'wasmedge']
results = [run_in_runtime('module.wasm', rt) for rt in runtimes]

# 所有运行时应该返回相同结果
assert all(r == results[0] for r in results), \
    f"Inconsistent results: {results}"
```

---

## 回归测试

### 快照测试

**Jest 快照**：

```javascript
// tests/snapshot.test.js
import { renderWasmOutput } from '../src/wasm-render';

test('renders consistent output', () => {
  const input = { data: [1, 2, 3, 4, 5] };
  const output = renderWasmOutput(input);

  expect(output).toMatchSnapshot();
});
```

**性能回归测试**：

```bash
# perf_regression.sh
#!/bin/bash

# 运行基准测试
cargo bench --target wasm32-wasi > current_bench.txt

# 与基线对比
if diff -u baseline_bench.txt current_bench.txt > bench_diff.txt; then
  echo "No performance regression"
else
  echo "Performance regression detected!"
  cat bench_diff.txt
  exit 1
fi
```

### 金标准测试 (Golden Tests)

**文件对比**：

```rust
#[test]
fn golden_test_output() {
    let input = include_bytes!("fixtures/input.bin");
    let expected = include_bytes!("fixtures/expected_output.bin");

    let actual = process_data(input);

    assert_eq!(actual.as_slice(), expected.as_slice());
}
```

---

## 属性测试 (Property-Based Testing)

### QuickCheck (Rust)

**属性测试**：

```rust
#[cfg(test)]
mod property_tests {
    use quickcheck::{QuickCheck, TestResult};
    use quickcheck_macros::quickcheck;

    #[quickcheck]
    fn prop_addition_commutative(a: i32, b: i32) -> bool {
        add(a, b) == add(b, a)
    }

    #[quickcheck]
    fn prop_reverse_twice_is_identity(vec: Vec<i32>) -> bool {
        let reversed_twice = reverse(reverse(vec.clone()));
        vec == reversed_twice
    }

    #[quickcheck]
    fn prop_sort_is_idempotent(mut vec: Vec<i32>) -> bool {
        sort(&mut vec);
        let first_sort = vec.clone();
        sort(&mut vec);
        first_sort == vec
    }
}
```

---

## 测试隔离与Mock

### Wasm 模块 Mock

**模拟导入**：

```javascript
// tests/mock-imports.test.js
const mockImports = {
  env: {
    log: (ptr, len) => {
      // 捕获日志而非打印
      logBuffer.push(readString(ptr, len));
    },
    fetch_data: () => {
      // 返回测试数据而非真实请求
      return mockResponsePtr;
    },
  },
};

const instance = await WebAssembly.instantiate(wasmBytes, mockImports);
```

### WASI Mock

**虚拟文件系统**：

```rust
// tests/wasi_mock.rs
use wasi_common::pipe::{ReadPipe, WritePipe};
use wasmtime_wasi::WasiCtxBuilder;

#[test]
fn test_with_mock_fs() {
    let stdin = ReadPipe::from(b"test input");
    let stdout = WritePipe::new_in_memory();

    let wasi = WasiCtxBuilder::new()
        .stdin(Box::new(stdin))
        .stdout(Box::new(stdout.clone()))
        .preopened_dir(Dir::from_std_file(test_dir), "/")
        .build();

    let mut store = Store::new(&engine, wasi);
    let instance = linker.instantiate(&mut store, &module)?;

    // 运行测试
    instance.get_typed_func::<(), ()>(&mut store, "main")?
        .call(&mut store, ())?;

    // 检查输出
    let output = String::from_utf8(stdout.try_into_inner().unwrap())?;
    assert_eq!(output, "expected output\n");
}
```

---

## 持续集成测试

### GitHub Actions 工作流

**.github/workflows/test.yml**：

```yaml
name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        rust: [stable, nightly]

    steps:
      - uses: actions/checkout@v3

      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: ${{ matrix.rust }}
          target: wasm32-wasi

      - name: Install wasm-tools
        run: |
          cargo install wasm-pack wasm-bindgen-cli
          curl -LO https://github.com/WebAssembly/wabt/releases/download/1.0.32/wabt-1.0.32-ubuntu.tar.gz
          tar xzf wabt-1.0.32-ubuntu.tar.gz
          echo "$PWD/wabt-1.0.32/bin" >> $GITHUB_PATH

      - name: Build
        run: cargo build --target wasm32-wasi --release

      - name: Run tests
        run: |
          cargo test --target wasm32-wasi
          wasm-pack test --headless --firefox
          wasm-pack test --node

      - name: Validate Wasm
        run: wasm-validate target/wasm32-wasi/release/*.wasm

      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: wasm-module-${{ matrix.os }}
          path: target/wasm32-wasi/release/*.wasm
```

### 测试覆盖率报告

**Codecov 集成**：

```yaml
- name: Generate coverage
  run: |
    cargo install cargo-tarpaulin
    cargo tarpaulin --target wasm32-wasi --out Xml

- name: Upload coverage
  uses: codecov/codecov-action@v3
  with:
    files: ./cobertura.xml
    flags: unittests
```

---

## 测试数据管理

### Fixture 管理

**目录结构**：

```
tests/
├── fixtures/
│   ├── valid_inputs/
│   │   ├── simple.bin
│   │   ├── complex.bin
│   │   └── edge_case.bin
│   ├── invalid_inputs/
│   │   ├── corrupted.bin
│   │   └── malformed.bin
│   └── expected_outputs/
│       ├── simple_output.bin
│       └── complex_output.bin
└── integration/
    └── test_with_fixtures.rs
```

**数据生成器**：

```python
# scripts/generate_test_data.py
import struct
import random

def generate_test_case(size, pattern):
    data = bytearray(size)
    if pattern == 'random':
        for i in range(size):
            data[i] = random.randint(0, 255)
    elif pattern == 'sequential':
        for i in range(size):
            data[i] = i % 256

    with open(f'tests/fixtures/{pattern}_{size}.bin', 'wb') as f:
        f.write(data)

# 生成多种测试数据
for size in [100, 1000, 10000, 100000]:
    for pattern in ['random', 'sequential', 'zeros', 'ones']:
        generate_test_case(size, pattern)
```

---

## 批判性分析

### Wasm 测试的局限性

**问题清单**：

1. **调试困难**：
   - 优化后的 Wasm 难以设置断点
   - 变量检查受限（类型信息丢失）
   - 调用栈不完整

2. **覆盖率盲区**：
   - 标准覆盖率工具不支持 Wasm
   - 需要自定义插桩（性能开销大）
   - 跨语言边界的覆盖率缺失

3. **性能测试不稳定**：
   - JIT 预热时间不确定
   - 浏览器 GC 干扰
   - 多核调度不可控

**批判**：
> Wasm 的测试生态远落后于主流语言。开发者被迫在多个工具间拼凑，缺乏统一的测试框架。

### 测试成本分析

**时间成本**：

| 测试类型 | 单次时间 | 频率 | 年成本 (工时) |
|---------|---------|------|--------------|
| 单元测试 | 5 min | 10/天 | 200 h |
| 集成测试 | 30 min | 2/天 | 240 h |
| E2E 测试 | 2 h | 1/周 | 100 h |
| 性能测试 | 4 h | 1/月 | 50 h |
| 总计 | - | - | **590 h/年** |

**批判**：
> 测试成本高昂，但 Wasm 的工具支持不足，投入产出比低。很多团队选择减少测试，增加了生产环境风险。

---

## 最佳实践

### 测试金字塔

```
       /\
      /E2E\         10% (慢、脆弱、昂贵)
     /------\
    /整合测试 \      20% (中速、较稳定)
   /----------\
  /  单元测试   \    70% (快、稳定、廉价)
 /--------------\
```

**Wasm 应用**：

- **70%** 单元测试：纯 Wasm 函数逻辑
- **20%** 集成测试：Wasm ↔ JS 交互
- **10%** E2E 测试：完整用户流程

### 测试先行 (TDD)

**Red-Green-Refactor**：

```rust
// 1. Red: 写失败的测试
#[test]
fn test_parse_json() {
    let input = r#"{"key": "value"}"#;
    let result = parse_json(input);
    assert_eq!(result.get("key"), Some("value"));
}

// 2. Green: 最小实现
fn parse_json(input: &str) -> HashMap<String, String> {
    // 简单实现通过测试
}

// 3. Refactor: 优化实现
fn parse_json(input: &str) -> HashMap<String, String> {
    // 完整、健壮的实现
}
```

### 测试文档化

**测试即文档**：

```rust
/// Parses JSON input and returns a HashMap
///
/// # Examples
/// ```
/// use mylib::parse_json;
/// let input = r#"{"name": "Alice", "age": "30"}"#;
/// let parsed = parse_json(input);
/// assert_eq!(parsed.get("name"), Some("Alice"));
/// ```
#[wasm_bindgen]
pub fn parse_json(input: &str) -> HashMap<String, String> {
    // 实现
}
```

---

## 参考文献

1. **[wasm-bindgen-test]** Testing Wasm in Rust (https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/)
2. **[Playwright]** End-to-End Testing (https://playwright.dev/)
3. **[Fuzzing Book]** The Fuzzing Book (https://www.fuzzingbook.org/)

---

## 相关文档

- **[09.1 开发工具链](09.1_Development_Toolchain.md)** - 测试工具详解
- **[09.3 调试技术](09.3_Debugging_Techniques.md)** - 调试与问题定位
- **[03.5 性能分析](../03_Runtime_Systems/03.5_Performance_Analysis.md)** - 性能测试方法
