# ç®—æœ¯è°±ç³»çš„å½¢å¼åŒ– (Coq)

> **å®šç†**: Postå®šç† - Î£â‚â° = RE
> **æ ¸å¿ƒ**: é€’å½’å¯æšä¸¾ = å­˜åœ¨é‡è¯
> **å·¥å…·**: Coq
> **éš¾åº¦**: â­â­â­â­â­

---

## ğŸ“‹ ç›®å½•

- [ç®—æœ¯è°±ç³»çš„å½¢å¼åŒ– (Coq)](#ç®—æœ¯è°±ç³»çš„å½¢å¼åŒ–-coq)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ç®—æœ¯è°±ç³»å®šä¹‰](#1-ç®—æœ¯è°±ç³»å®šä¹‰)
  - [2. Coqå½¢å¼åŒ–](#2-coqå½¢å¼åŒ–)
  - [3. Postå®šç†](#3-postå®šç†)
  - [4. è¯æ˜è¦ç‚¹](#4-è¯æ˜è¦ç‚¹)
  - [ğŸ“š å‚è€ƒæ–‡çŒ®](#-å‚è€ƒæ–‡çŒ®)

---

## 1. ç®—æœ¯è°±ç³»å®šä¹‰

**Kleeneç®—æœ¯å±‚çº§**:

```text
Î£â‚€â° = Î â‚€â° = é€’å½’é›†åˆ
Î£â‚â° = {x | âˆƒy R(x,y)}, Ré€’å½’
Î â‚â° = {x | âˆ€y R(x,y)}, Ré€’å½’
Î£â‚‚â° = {x | âˆƒyâˆ€z R(x,y,z)}
...

Postå®šç†: Î£â‚â° = RE (é€’å½’å¯æšä¸¾)
```

---

## 2. Coqå½¢å¼åŒ–

```coq
(* é€’å½’è°“è¯ *)
Definition Recursive (R : nat -> Prop) : Prop :=
  exists f : nat -> bool,
    forall n, R n <-> f n = true.

(* Î£â‚â° *)
Definition Sigma1 (S : nat -> Prop) : Prop :=
  exists R : nat -> nat -> Prop,
    Recursive (fun p => R (fst p) (snd p)) /\
    forall x, S x <-> exists y, R x y.

(* RE *)
Definition RE (S : nat -> Prop) : Prop :=
  exists enum : nat -> option nat,
    forall x, S x <-> exists n, enum n = Some x.
```

---

## 3. Postå®šç†

```coq
Theorem Post_theorem :
  forall S : nat -> Prop,
    Sigma1 S <-> RE S.
Proof.
  intro S; split.

  (* Î£â‚â° â†’ RE *)
  - intro [R [hRec hS]].
    destruct hRec as [f hf].

    (* æšä¸¾: å¯¹æ‰€æœ‰(x,y), æµ‹è¯•R(x,y) *)
    exists (fun n =>
      let x := fst (decode n) in
      let y := snd (decode n) in
      if f (encode (x, y))
      then Some x
      else None).

    intro x; split.
    + (* S x â†’ æšä¸¾åˆ°x *)
      intro hSx.
      destruct (hS x) as [_ hEx]; clear hS.
      destruct (hEx hSx) as [y hRxy].
      exists (encode (x, y)).
      (* ... *)
    + (* æšä¸¾åˆ°x â†’ S x *)
      (* ... *)

  (* RE â†’ Î£â‚â° *)
  - intro [enum hEnum].
    exists (fun x y => enum y = Some x).
    split.
    + (* Ræ˜¯é€’å½’çš„ *)
      exists (fun p =>
        match enum (snd p) with
        | Some x => Nat.eqb x (fst p)
        | None => false
        end).
      (* ... *)
    + (* âˆ€x. S x â†” âˆƒy. R x y *)
      intro x; split.
      * exact (hEnum x).1.
      * exact (hEnum x).2.
Qed.
```

---

## 4. è¯æ˜è¦ç‚¹

**å…³é”®æ´å¯Ÿ**:

```text
Î£â‚â°: xâˆˆS âŸº âˆƒy. R(x,y) (å­˜åœ¨è§è¯)
RE:  xâˆˆS âŸº âˆƒn. enum(n)=x (æšä¸¾åˆ°)

è¿æ¥:
y = enumçš„ç´¢å¼•
æšä¸¾ = æœç´¢è§è¯
```

**å½¢å¼åŒ–æŒ‘æˆ˜**:

```text
1. é…å¯¹å‡½æ•° (encode/decode)
2. æšä¸¾çš„æ„é€ æ€§
3. é‡è¯çš„è®¡ç®—æ€§

Coqä¸­ç”¨:
- nat * nat é…å¯¹
- å®šä¹‰å¯è®¡ç®—æšä¸¾å™¨
- existsç”¨Î£ç±»å‹
```

---

## ğŸ“š å‚è€ƒæ–‡çŒ®

[1] **Post, E. L.** (1944). "Recursively Enumerable Sets of Positive Integers"
     _Bulletin of the AMS_ 50: 284-316.

[2] **Kleene, S. C.** (1943). "Recursive Predicates and Quantifiers"
     _Transactions of the AMS_ 53(1): 41-73.

[3] **Rogers, H. Jr.** (1987). _Theory of Recursive Functions and Effective Computability_
     MIT Press. ISBN 978-0262680523.

---

**æœ€åæ›´æ–°**: 2025-12-02
**å·¥å…·**: Coq 8.18
**éš¾åº¦**: â­â­â­â­â­
