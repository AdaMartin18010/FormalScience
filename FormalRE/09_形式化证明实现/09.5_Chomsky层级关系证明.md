# Chomskyå±‚çº§å…³ç³»çš„å½¢å¼åŒ–

> **å®šç†**: REG âŠ‚ CFL âŠ‚ CSL âŠ‚ REC âŠ‚ RE
> **è¯æ˜**: æ³µå¼•ç† + å¯¹è§’åŒ–
> **å·¥å…·**: Coq
> **éš¾åº¦**: â­â­â­â­

---

## ğŸ“‹ ç›®å½•

- [Chomskyå±‚çº§å…³ç³»çš„å½¢å¼åŒ–](#chomskyå±‚çº§å…³ç³»çš„å½¢å¼åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å±‚çº§å®šä¹‰](#1-å±‚çº§å®šä¹‰)
  - [2. æ³µå¼•ç†å½¢å¼åŒ–](#2-æ³µå¼•ç†å½¢å¼åŒ–)
    - [2.1 æ­£åˆ™è¯­è¨€æ³µå¼•ç†](#21-æ­£åˆ™è¯­è¨€æ³µå¼•ç†)
    - [2.2 ä¸Šä¸‹æ–‡æ— å…³æ³µå¼•ç†](#22-ä¸Šä¸‹æ–‡æ— å…³æ³µå¼•ç†)
  - [3. ä¸¥æ ¼åŒ…å«è¯æ˜](#3-ä¸¥æ ¼åŒ…å«è¯æ˜)
    - [3.1 REG âŠŠ CFL](#31-reg--cfl)
    - [3.2 CFL âŠŠ CSL](#32-cfl--csl)
  - [4. Coqå®ç°](#4-coqå®ç°)
  - [ğŸ“š å‚è€ƒæ–‡çŒ®](#-å‚è€ƒæ–‡çŒ®)

---

## 1. å±‚çº§å®šä¹‰

**Coqå®šä¹‰**:

```coq
(* è¯­è¨€ = å­—ç¬¦ä¸²é›†åˆ *)
Definition Language := list nat -> Prop.

(* æ­£åˆ™è¯­è¨€ *)
Inductive REG : Language -> Prop :=
  | reg_from_dfa : forall L dfa,
      L = language_of_dfa dfa ->
      REG L.

(* ä¸Šä¸‹æ–‡æ— å…³ *)
Inductive CFL : Language -> Prop :=
  | cfl_from_cfg : forall L cfg,
      L = language_of_cfg cfg ->
      CFL L.

(* å±‚çº§ *)
Definition proper_subset (C1 C2 : Language -> Prop) : Prop :=
  (forall L, C1 L -> C2 L) /\
  (exists L, C2 L /\ ~ C1 L).
```

---

## 2. æ³µå¼•ç†å½¢å¼åŒ–

### 2.1 æ­£åˆ™è¯­è¨€æ³µå¼•ç†

```coq
Theorem pumping_lemma_reg :
  forall L : Language,
    REG L ->
    exists p : nat,  (* æ³µé•¿åº¦ *)
      forall w : list nat,
        L w ->
        length w >= p ->
        exists x y z : list nat,
          w = x ++ y ++ z /\
          length (x ++ y) <= p /\
          length y >= 1 /\
          forall i : nat,
            L (x ++ repeat y i ++ z).
Proof.
  intros L [dfa hL].

  (* p = DFAçŠ¶æ€æ•° *)
  exists (num_states dfa).

  intros w hLw hLen.

  (* é¸½ç¬¼åŸç†: å¿…æœ‰çŠ¶æ€é‡å¤ *)
  destruct (pigeonhole_path dfa w) as [x [y [z [...]]]].

  exists x, y, z.
  (* yå¯¹åº”å¾ªç¯,å¯é‡å¤ä»»æ„æ¬¡ *)
Qed.
```

### 2.2 ä¸Šä¸‹æ–‡æ— å…³æ³µå¼•ç†

```coq
Theorem pumping_lemma_cfl :
  forall L : Language,
    CFL L ->
    exists p : nat,
      forall w : list nat,
        L w ->
        length w >= p ->
        exists u v x y z : list nat,
          w = u ++ v ++ x ++ y ++ z /\
          length (v ++ y) >= 1 /\
          length (v ++ x ++ y) <= p /\
          forall i : nat,
            L (u ++ repeat v i ++ x ++ repeat y i ++ z).
Proof.
  (* CFGæ¨å¯¼æ ‘æ·±åº¦ â†’ å¿…æœ‰éç»ˆç»“ç¬¦é‡å¤ *)
Admitted.
```

---

## 3. ä¸¥æ ¼åŒ…å«è¯æ˜

### 3.1 REG âŠŠ CFL

```coq
(* {0â¿1â¿ | nâ‰¥0} ä¸æ˜¯æ­£åˆ™çš„ *)
Definition L_0n1n : Language :=
  fun w => exists n, w = repeat 0 n ++ repeat 1 n.

Theorem L_0n1n_not_regular :
  ~ REG L_0n1n.
Proof.
  intro hREG.

  (* åº”ç”¨æ³µå¼•ç† *)
  destruct (pumping_lemma_reg _ hREG) as [p hPump].

  (* å–w = 0^p 1^p *)
  set (w := repeat 0 p ++ repeat 1 p).

  assert (L_0n1n w) by (exists p; reflexivity).
  assert (length w >= p) by (simpl; lia).

  (* å¾—åˆ°åˆ†è§£ w = xyz *)
  destruct (hPump w) as [x [y [z [...]]]]; auto.

  (* yåªåŒ…å«0 (å› ä¸ºlength(xy)â‰¤p) *)
  (* æ³µä¸€æ¬¡: xyÂ²z = 0^(p+|y|) 1^p *)
  (* â†’ ä¸åœ¨Lä¸­ â†’ çŸ›ç›¾! *)
Qed.

(* ä½†{0â¿1â¿}æ˜¯CFL *)
Theorem L_0n1n_is_cfl :
  CFL L_0n1n.
Proof.
  (* CFG: S â†’ 0S1 | Îµ *)
Admitted.

(* å› æ­¤REG âŠŠ CFL *)
Theorem REG_proper_CFL :
  proper_subset REG CFL.
Proof.
  split.
  - (* REG âŠ† CFL *)
    intros L hREG.
    (* ä»»ä½•DFAå¯è½¬CFG *)
  - (* å­˜åœ¨CFLéREG *)
    exists L_0n1n.
    split.
    + exact L_0n1n_is_cfl.
    + exact L_0n1n_not_regular.
Qed.
```

### 3.2 CFL âŠŠ CSL

```coq
(* {0â¿1â¿2â¿ | nâ‰¥0} ä¸æ˜¯CFL *)
Definition L_0n1n2n : Language :=
  fun w => exists n,
    w = repeat 0 n ++ repeat 1 n ++ repeat 2 n.

Theorem L_0n1n2n_not_cfl :
  ~ CFL L_0n1n2n.
Proof.
  intro hCFL.

  (* åº”ç”¨CFLæ³µå¼•ç† *)
  destruct (pumping_lemma_cfl _ hCFL) as [p hPump].

  (* w = 0^p 1^p 2^p *)
  set (w := repeat 0 p ++ repeat 1 p ++ repeat 2 p).

  (* æ³µå¼•ç†ç»™å‡ºuvxyzåˆ†è§£ *)
  (* vyä¸èƒ½åŒæ—¶åŒ…å«0,1,2 *)
  (* æ³µä¸€æ¬¡ç ´ån:n:næ¯”ä¾‹ â†’ çŸ›ç›¾ *)
Qed.

(* ä½†{0â¿1â¿2â¿}æ˜¯CSL *)
Theorem L_0n1n2n_is_csl :
  CSL L_0n1n2n.
Proof.
  (* çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºå¯è¯†åˆ« *)
Admitted.
```

---

## 4. Coqå®ç°

**å®Œæ•´æ–‡ä»¶**: `Chomsky.v`

```coq
(* ========================================
   Chomskyå±‚çº§çš„Coqå½¢å¼åŒ–
   ======================================== *)

Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Import ListNotations.

(* è¯­è¨€å®šä¹‰ (è§ä¸Š) *)

(* æ‰€æœ‰å±‚çº§å®šä¹‰ *)
(* REG, CFL, CSL, REC, RE *)

(* åŒ…å«å…³ç³» *)
Theorem hierarchy_chain :
  (forall L, REG L -> CFL L) /\
  (forall L, CFL L -> CSL L) /\
  (forall L, CSL L -> REC L) /\
  (forall L, REC L -> RE L).
Proof.
  repeat split; intros L hL.
  (* ... *)
Qed.

(* ä¸¥æ ¼åŒ…å« *)
Theorem strict_hierarchy :
  proper_subset REG CFL /\
  proper_subset CFL CSL /\
  proper_subset CSL REC /\
  proper_subset REC RE.
Proof.
  repeat split.
  - exact REG_proper_CFL.
  - exact CFL_proper_CSL.
  - (* CSL âŠŠ REC: å¯¹è§’åŒ– *)
  - (* REC âŠŠ RE: åœæœºé—®é¢˜ *)
Qed.
```

---

## ğŸ“š å‚è€ƒæ–‡çŒ®

[1] **Chomsky, N.** (1956). "Three Models for the Description of Language"
     _IRE Transactions on Information Theory_ 2(3): 113-124.

[2] **Hopcroft, J. E., Motwani, R., & Ullman, J. D.** (2006). _Introduction to Automata Theory, Languages, and Computation_ (3rd ed.)
     Pearson. ISBN 978-0321455369.
     **è‡ªåŠ¨æœºç†è®ºç»å…¸** â­

[3] **Sipser, M.** (2012). _Introduction to the Theory of Computation_ (3rd ed.)
     Cengage. ISBN 978-1133187790.

---

**æœ€åæ›´æ–°**: 2025-12-02
**å·¥å…·**: Coq 8.18
**éš¾åº¦**: â­â­â­â­
