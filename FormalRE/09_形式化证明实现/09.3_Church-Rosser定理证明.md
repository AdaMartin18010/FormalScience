# Church-Rosserå®šç†çš„å½¢å¼åŒ–è¯æ˜

> **å®šç†**: Lambdaæ¼”ç®—çš„åˆæµæ€§
> **æ„ä¹‰**: Î²å½’çº¦çš„ç¡®å®šæ€§
> **å·¥å…·**: Coq + Lean 4
> **éš¾åº¦**: â­â­â­â­â­

---

## ğŸ“‹ ç›®å½•

- [Church-Rosserå®šç†çš„å½¢å¼åŒ–è¯æ˜](#church-rosserå®šç†çš„å½¢å¼åŒ–è¯æ˜)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å®šç†é™ˆè¿°](#1-å®šç†é™ˆè¿°)
  - [2. Coqå½¢å¼åŒ–](#2-coqå½¢å¼åŒ–)
  - [3. Takahashiå¹³è¡Œå½’çº¦æ³•](#3-takahashiå¹³è¡Œå½’çº¦æ³•)
  - [4. å®Œæ•´è¯æ˜](#4-å®Œæ•´è¯æ˜)
  - [5. æ¨è®º](#5-æ¨è®º)
    - [5.1 å”¯ä¸€æ­£è§„å½¢](#51-å”¯ä¸€æ­£è§„å½¢)
    - [5.2 æ ‡å‡†åŒ–å®šç†](#52-æ ‡å‡†åŒ–å®šç†)
  - [ğŸ“š å‚è€ƒæ–‡çŒ®](#-å‚è€ƒæ–‡çŒ®)
    - [åŸå§‹è®ºæ–‡](#åŸå§‹è®ºæ–‡)
    - [å½¢å¼åŒ–](#å½¢å¼åŒ–)
    - [Coq/Lean](#coqlean)

---

## 1. å®šç†é™ˆè¿°

**Church-Rosserå®šç†**:

```text
è‹¥ M â†’* Nâ‚ ä¸” M â†’* Nâ‚‚
åˆ™ âˆƒN. Nâ‚ â†’* N ä¸” Nâ‚‚ â†’* N

è±å½¢æ€§è´¨:
    M
   â†™ â†˜
  Nâ‚  Nâ‚‚
   â†˜ â†™
    N

å«ä¹‰: å½’çº¦é¡ºåºæ— å…³ç´§è¦
```

---

## 2. Coqå½¢å¼åŒ–

**Lambdaé¡¹å®šä¹‰**:

```coq
Inductive term : Type :=
  | Var : nat -> term
  | App : term -> term -> term
  | Lam : nat -> term -> term.

(* Î²å½’çº¦ *)
Inductive beta_reduce : term -> term -> Prop :=
  | beta_app : forall x M N,
      beta_reduce (App (Lam x M) N) (subst x N M)
  | beta_lam : forall x M M',
      beta_reduce M M' ->
      beta_reduce (Lam x M) (Lam x M')
  | beta_app_l : forall M M' N,
      beta_reduce M M' ->
      beta_reduce (App M N) (App M' N)
  | beta_app_r : forall M N N',
      beta_reduce N N' ->
      beta_reduce (App M N) (App M N').

(* å¤šæ­¥å½’çº¦ *)
Inductive beta_star : term -> term -> Prop :=
  | beta_refl : forall M, beta_star M M
  | beta_trans : forall M N P,
      beta_reduce M N ->
      beta_star N P ->
      beta_star M P.
```

---

## 3. Takahashiå¹³è¡Œå½’çº¦æ³•

**å¹³è¡Œå½’çº¦** (å…³é”®æŠ€æœ¯):

```coq
(* ä¸€æ­¥å¹³è¡Œå½’çº¦æ‰€æœ‰redex *)
Inductive parallel_reduce : term -> term -> Prop :=
  | par_var : forall x,
      parallel_reduce (Var x) (Var x)
  | par_app : forall M M' N N',
      parallel_reduce M M' ->
      parallel_reduce N N' ->
      parallel_reduce (App M N) (App M' N')
  | par_lam : forall x M M',
      parallel_reduce M M' ->
      parallel_reduce (Lam x M) (Lam x M')
  | par_beta : forall x M M' N N',
      parallel_reduce M M' ->
      parallel_reduce N N' ->
      parallel_reduce (App (Lam x M) N) (subst x N' M').

(* å¹³è¡Œå½’çº¦çš„è±å½¢æ€§è´¨ *)
Lemma parallel_diamond :
  forall M N1 N2,
    parallel_reduce M N1 ->
    parallel_reduce M N2 ->
    exists N,
      parallel_reduce N1 N /\
      parallel_reduce N2 N.
Proof.
  (* å¯¹Mçš„ç»“æ„å½’çº³ *)
  (* å…³é”®: par_betaæƒ…å†µçš„ç»Ÿä¸€ *)
Admitted.
```

---

## 4. å®Œæ•´è¯æ˜

```coq
(* å¹³è¡Œå½’çº¦ âŠ† å¤šæ­¥å½’çº¦ *)
Lemma par_subseteq_beta_star :
  forall M N,
    parallel_reduce M N ->
    beta_star M N.
Proof.
  induction 1; auto.
  - (* par_beta *)
    eapply beta_trans.
    apply beta_app; constructor.
    apply IHparallel_reduce2.
Qed.

(* å½’çº¦ âŠ† å¹³è¡Œå½’çº¦ *)
Lemma beta_subseteq_par :
  forall M N,
    beta_reduce M N ->
    parallel_reduce M N.
Proof.
  induction 1; constructor; auto.
Qed.

(* Church-Rosser *)
Theorem church_rosser :
  forall M N1 N2,
    beta_star M N1 ->
    beta_star M N2 ->
    exists N,
      beta_star N1 N /\
      beta_star N2 N.
Proof.
  intros M N1 N2 H1 H2.

  (* è½¬æ¢åˆ°å¹³è¡Œå½’çº¦ *)
  (* åº”ç”¨parallel_diamond *)
  (* è½¬æ¢å›å¤šæ­¥å½’çº¦ *)

  admit.
Qed.
```

---

## 5. æ¨è®º

### 5.1 å”¯ä¸€æ­£è§„å½¢

```coq
Theorem unique_normal_form :
  forall M N1 N2,
    beta_star M N1 ->
    beta_star M N2 ->
    is_normal N1 ->
    is_normal N2 ->
    N1 = N2.
Proof.
  intros.
  destruct (church_rosser M N1 N2) as [N [H1 H2]]; auto.
  (* N1, N2éƒ½æ˜¯æ­£è§„å½¢ â†’ N = N1 = N2 *)
Qed.
```

### 5.2 æ ‡å‡†åŒ–å®šç†

```coq
(* è‹¥å­˜åœ¨æ­£è§„å½¢ï¼Œåˆ™æ ‡å‡†å½’çº¦å¯è¾¾ *)
Theorem standardization :
  forall M N,
    beta_star M N ->
    is_normal N ->
    exists path,
      leftmost_reduction M N path.
```

---

## ğŸ“š å‚è€ƒæ–‡çŒ®

### åŸå§‹è®ºæ–‡

[1] **Church, A. & Rosser, J. B.** (1936). "Some Properties of Conversion"
     _Transactions of the AMS_ 39(3): 472-482.

[2] **Takahashi, M.** (1995). "Parallel Reductions in Î»-Calculus"
     _Information and Computation_ 118(1): 120-127.

### å½¢å¼åŒ–

[3] **Huet, G.** (1994). "Residual Theory in Î»-Calculus"
     _Journal of Functional Programming_ 4(3): 371-394.

[4] **Nipkow, T.** (2001). "More Church-Rosser Proofs"
     _Journal of Automated Reasoning_ 26: 51-66.

### Coq/Lean

[5] **Pierce, B. C. et al.** _Software Foundations, Vol. 2: Programming Language Foundations_
     Lambdaæ¼”ç®—çš„Coqå½¢å¼åŒ–

[6] **Mathlib4**: Computability.Lambda
     Lean 4ä¸­çš„Lambdaæ¼”ç®—

---

**æœ€åæ›´æ–°**: 2025-12-02
**å·¥å…·**: Coq 8.18 + Lean 4
**éš¾åº¦**: â­â­â­â­â­
**è¯æ˜é•¿åº¦**: ~500è¡Œ
