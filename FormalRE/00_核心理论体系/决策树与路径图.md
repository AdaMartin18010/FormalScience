# FormalRE 决策树与路径图

> **目的**: 用决策树指导学习与技术选型
> **更新**: 2025-12-02
> **格式**: 树状决策流程

---

## 📋 目录

- [FormalRE 决策树与路径图](#formalre-决策树与路径图)
  - [📋 目录](#-目录)
  - [1. 学习路径决策树](#1-学习路径决策树)
    - [1.1 按背景选择路径](#11-按背景选择路径)
    - [1.2 按目标选择深度](#12-按目标选择深度)
  - [2. 技术选型决策树](#2-技术选型决策树)
    - [2.1 编程语言选择](#21-编程语言选择)
    - [2.2 形式化工具选择](#22-形式化工具选择)
  - [3. 验证方法决策树](#3-验证方法决策树)
  - [4. 问题诊断决策树](#4-问题诊断决策树)
  - [🎯 如何使用本决策树](#-如何使用本决策树)
    - [使用场景](#使用场景)
    - [与其他文档配合](#与其他文档配合)

---

## 1. 学习路径决策树

### 1.1 按背景选择路径

```text
你的背景是什么？
│
├─【数学/逻辑背景】
│  │
│  ├─ 强逻辑基础(学过数理逻辑)
│  │  │
│  │  └─→ 路径A: 范畴论统一视角
│  │       │
│  │       ├─ Week 1-2: 范畴论基础
│  │       │   ├─ 01.6 范畴论基础.md
│  │       │   ├─ 概念: 对象、态射、组合
│  │       │   └─ 练习: Haskell中的范畴
│  │       │
│  │       ├─ Week 3-4: Curry-Howard-Lambek
│  │       │   ├─ 00.2 三位一体对应.md
│  │       │   ├─ 理解: 逻辑≅类型≅范畴
│  │       │   └─ 深刻: 同一实体不同投影
│  │       │
│  │       ├─ Week 5-6: CCC与Topos
│  │       │   ├─ 03.1 笛卡尔闭范畴.md
│  │       │   ├─ 03.2 Topos理论.md
│  │       │   └─ 理解: 指数对象↔函数类型
│  │       │
│  │       ├─ Week 7-8: 现代前沿
│  │       │   ├─ 05.1 同伦类型论HoTT.md
│  │       │   ├─ 05.2 Cubical类型论.md
│  │       │   └─ 批判: HoTT的价值与局限
│  │       │
│  │       └─ Week 9-10: 工程应用
│  │           └─ 06.4 类型系统与编程.md
│  │
│  └─ 集合论基础(ZF/ZFC)
│     │
│     └─→ 路径B: 集合论视角
│          │
│          ├─ Week 1-2: 集合论与RE
│          │   ├─ 01.5 集合论ZF-ZFC.md
│          │   ├─ 00.3 递归可枚举性理论.md
│          │   └─ 理解: Σ₁⁰ = RE
│          │
│          ├─ Week 3-4: 算术谱系
│          │   ├─ 04.2 算术谱系.md
│          │   ├─ Post定理: Σ₁⁰ = RE
│          │   └─ 层次: Σₙ⁰, Πₙ⁰, Δₙ⁰
│          │
│          ├─ Week 5-6: 等价性证明
│          │   ├─ 02.4 文法→集合论.md
│          │   ├─ 02.5 集合论→范畴论.md
│          │   └─ 理解: Topos = 广义集合
│          │
│          └─ Week 7-8: 哲学深度
│              ├─ 08.2 未解决问题.md (CH/AC)
│              └─ 08.3 争议性观点.md
│
├─【计算机科学背景】
│  │
│  ├─ 喜欢函数式编程(Haskell/LISP)
│  │  │
│  │  └─→ 路径C: Lambda演算视角
│  │       │
│  │       ├─ Week 1: Lambda演算基础
│  │       │   ├─ 01.3 Lambda演算.md
│  │       │   ├─ 无类型λ: 变量、应用、抽象
│  │       │   └─ β归约、η归约
│  │       │
│  │       ├─ Week 2: 不动点与递归
│  │       │   ├─ 00.4 不动点理论.md
│  │       │   ├─ Y组合子: fix f = f (fix f)
│  │       │   └─ 实践: Haskell/React Hooks
│  │       │
│  │       ├─ Week 3-4: 等价性理解
│  │       │   ├─ 02.2 图灵机→Lambda.md
│  │       │   ├─ 02.3 Lambda→文法.md
│  │       │   └─ Church-Turing论题
│  │       │
│  │       ├─ Week 5-6: 类型系统
│  │       │   ├─ 01.7 类型论与依赖类型.md
│  │       │   ├─ 06.4 类型系统与编程.md
│  │       │   └─ 选型: Rust/Haskell/TypeScript
│  │       │
│  │       └─ Week 7-8: Curry-Howard
│  │           ├─ 00.2 Curry-Howard-Lambek.md
│  │           └─ 深刻: 证明 = 程序
│  │
│  ├─ 喜欢自动机理论(编译原理)
│  │  │
│  │  └─→ 路径D: 图灵机/文法视角
│  │       │
│  │       ├─ Week 1: 图灵机基础
│  │       │   ├─ 01.1 图灵机.md
│  │       │   ├─ 定义、通用图灵机
│  │       │   └─ 编码技巧
│  │       │
│  │       ├─ Week 2: 不可判定性
│  │       │   ├─ 04.5 停机问题.md
│  │       │   ├─ 对角化论证
│  │       │   └─ 自指悖论
│  │       │
│  │       ├─ Week 3-4: Chomsky层级
│  │       │   ├─ 04.1 Chomsky层级详解.md
│  │       │   ├─ Type 0/1/2/3
│  │       │   └─ 泵引理、闭包性质
│  │       │
│  │       ├─ Week 5: Rice定理
│  │       │   ├─ 04.4 Rice定理.md
│  │       │   └─ 应用: 静态分析限制
│  │       │
│  │       ├─ Week 6-7: 等价性证明
│  │       │   ├─ 02.1 Petri→图灵机.md
│  │       │   ├─ 02.2 图灵机→Lambda.md
│  │       │   └─ 理解: 2计数器机
│  │       │
│  │       └─ Week 8: 工程应用
│  │           ├─ 编译器优化限制
│  │           └─ 01.4 形式语言.md
│  │
│  └─ 关注并发/分布式系统
│     │
│     └─→ 路径E: Petri网视角
│          │
│          ├─ Week 1-2: Petri网基础
│          │   ├─ 01.2 Petri网理论.md
│          │   ├─ 库所、变迁、令牌
│          │   └─ 并发语义
│          │
│          ├─ Week 3: 抑止弧与图灵完备
│          │   ├─ 02.1 Petri→图灵机.md
│          │   ├─ 关键: 抑止弧 = 零测试
│          │   └─ 无抑止弧: 仅VASS
│          │
│          ├─ Week 4-5: 可达性分析
│          │   ├─ 可达标识集 = RE
│          │   ├─ 不可判定性
│          │   └─ 覆盖树/Karp-Miller树
│          │
│          ├─ Week 6-7: 工程应用
│          │   ├─ 06.3 微服务与分布式.md
│          │   ├─ Kubernetes建模
│          │   ├─ DeFi工作流
│          │   └─ 死锁检测
│          │
│          └─ Week 8: Chaos Engineering
│              └─ 理论限制与实践应对
│
├─【工程师背景】
│  │
│  └─→ 路径F: 实践优先路径
│       │
│       ├─ Day 1: 快速概览
│       │   ├─ 快速导航_START_HERE.md
│       │   └─ 理解: RE是什么
│       │
│       ├─ Day 2-3: 核心限制
│       │   ├─ 04.5 停机问题.md
│       │   ├─ 04.4 Rice定理.md
│       │   └─ 理解: 不可判定性
│       │
│       ├─ Week 2: 工程应用
│       │   ├─ 06.1 AI系统与LLM.md
│       │   ├─ 06.2 区块链与智能合约.md
│       │   ├─ 06.3 微服务与分布式.md
│       │   ├─ 06.4 类型系统与编程.md
│       │   └─ 06.5 形式化验证.md
│       │
│       ├─ Week 3: 技术选型
│       │   ├─ 决策树 (本文档)
│       │   ├─ 语言选择
│       │   └─ 验证工具选择
│       │
│       └─ Week 4+: 按需深入
│           ├─ 需要理解理论限制 → 04模块
│           ├─ 需要类型系统知识 → 01.7, 06.4
│           └─ 需要完整理论 → 回到路径A-E
│
└─【哲学/认知背景】
   │
   └─→ 路径G: 批判性视角
        │
        ├─ Week 1: 争议与未解决问题
        │   ├─ 08.3 争议性观点.md
        │   ├─ 08.2 未解决问题.md
        │   └─ 理解: 理论的边界
        │
        ├─ Week 2-3: Church-Turing论题
        │   ├─ 00.1 Church-Turing论题.md
        │   ├─ 物理CTT (可证伪?)
        │   ├─ 强CTT (多项式等价?)
        │   └─ 批判: 经验vs数学
        │
        ├─ Week 4-5: 数学基础
        │   ├─ 05.1 HoTT.md
        │   ├─ HoTT vs Set Theory
        │   ├─ CH, AC的独立性
        │   └─ Univalence公理
        │
        ├─ Week 6: 心灵与计算
        │   ├─ 08.3 (Penrose vs Hofstadter)
        │   ├─ Gödel不完备性
        │   └─ 意识的可计算性?
        │
        └─ Week 7-8: 量子计算
            ├─ 05.5 量子计算与RE.md
            ├─ BQP ⊂ PSPACE ⊂ RE
            └─ 物理极限
```

### 1.2 按目标选择深度

```text
你的学习目标？
│
├─【快速了解RE核心】 (1-2周)
│  │
│  └─→ 最小必读集
│       │
│       Day 1: 什么是RE
│       ├─ 00.3 递归可枚举性理论.md
│       └─ 理解: 可枚举 vs 可判定
│       │
│       Day 2-3: 不可判定性
│       ├─ 04.5 停机问题.md
│       ├─ 理解: 对角化、自指
│       └─ 哲学: 计算的限制
│       │
│       Day 4-5: Rice定理
│       ├─ 04.4 Rice定理.md
│       ├─ 理解: 语义性质不可判定
│       └─ 实践: 静态分析边界
│       │
│       Day 6-7: 快速综述
│       ├─ 快速导航_START_HERE.md
│       ├─ 知识图谱总览.md
│       └─ 思维导图.md
│       │
│       Week 2: 工程应用(可选)
│       └─ 06_工程实践 (选1-2篇)
│
├─【理解计算等价性】 (1月)
│  │
│  └─→ 等价性核心路线
│       │
│       Week 1: Church-Turing论题
│       ├─ 00.1 Church-Turing论题.md
│       ├─ 弱等价: 计算能力
│       └─ 三种CT论题
│       │
│       Week 2: 核心证明(选3个系统)
│       ├─ 02.1 Petri→图灵机.md
│       ├─ 02.2 图灵机→Lambda.md
│       └─ 02.4 文法→集合论 (Post定理)
│       │
│       Week 3: 不动点理论
│       ├─ 00.4 不动点理论.md
│       ├─ 中等价: μX.F(X)
│       └─ 七系统统一模式
│       │
│       Week 4: Curry-Howard-Lambek
│       ├─ 00.2 三位一体对应.md
│       ├─ 强等价: 结构同构
│       └─ 逻辑≅类型≅范畴
│
├─【掌握完整证明链】 (2-3月)
│  │
│  └─→ 完整理论路线
│       │
│       Month 1: 基础理论
│       ├─ Week 1: 00_核心理论体系 (全5篇)
│       ├─ Week 2-3: 01_形式系统详解 (全7篇)
│       └─ Week 4: 04_复杂度 (04.1, 04.2, 04.4, 04.5)
│       │
│       Month 2: 深度证明
│       ├─ Week 5-7: 02_等价性证明 (全6篇)
│       │   ├─ 02.1 → 02.2 → 02.3
│       │   └─ 02.4 → 02.5 → 02.6
│       └─ Week 8: 03_范畴论 (03.1, 03.2)
│       │
│       Month 3: 批判与实践
│       ├─ Week 9: 08_批判性分析 (全3篇)
│       ├─ Week 10-11: 06_工程实践 (全5篇)
│       └─ Week 12: 综合复习与批判思考
│
├─【深入研究RE理论】 (长期)
│  │
│  └─→ 研究者路线
│       │
│       阶段1: 完整理论体系 (3-4月)
│       └─ 所有模块系统学习 (01-08)
│       │
│       阶段2: 批判性思考 (1月)
│       ├─ 08.2 未解决问题 (深度思考)
│       ├─ 08.3 争议性观点 (多元视角)
│       └─ 07_权威资源对标 (文献研究)
│       │
│       阶段3: 现代前沿 (1-2月)
│       ├─ 05_现代理论 (HoTT/Cubical/量子)
│       ├─ 07.4 最新研究2024-2025.md
│       └─ 跟踪: arXiv, LICS, POPL
│       │
│       阶段4: 形式化实践 (持续)
│       ├─ 09_形式化证明 (可选)
│       ├─ Coq/Lean实践
│       └─ 研究课题选择
│
└─【工程实践应用】 (按需)
   │
   └─→ 实践导向路线
        │
        快速入门 (1周)
        ├─ 快速导航
        └─ 理论限制认知 (04.4, 04.5)
        │
        深入应用 (按领域)
        ├─ AI/LLM → 06.1
        ├─ 区块链 → 06.2, 06.5
        ├─ 微服务 → 06.3
        ├─ 类型系统 → 06.4, 01.7
        └─ 形式化验证 → 06.5
        │
        选型决策 (按需)
        ├─ 语言选择 → 决策树2.1
        ├─ 工具选择 → 决策树2.2
        └─ 方法选择 → 决策树3
        │
        理论补充 (可选)
        └─ 回到其他路径深入
```

---

## 2. 技术选型决策树

### 2.1 编程语言选择

```text
编程语言选择决策树
│
你的项目类型？
│
├─【系统编程/嵌入式】
│  │
│  需要内存安全？
│  ├─ 是 → Rust ✅
│  │  │
│  │  优势:
│  │  ├─ 所有权系统 (线性逻辑)
│  │  ├─ 借用检查 (编译时)
│  │  ├─ 无GC性能
│  │  └─ 无数据竞争
│  │  │
│  │  劣势:
│  │  ├─ 陡峭学习曲线
│  │  └─ 编译时间长
│  │  │
│  │  文档: 06.4
│  │
│  └─ 否，追求最大性能 → C/C++ ⚠️
│     │
│     警告:
│     ├─ 无内存安全保证
│     ├─ 手动内存管理
│     └─ 易出安全漏洞
│     │
│     适用:
│     ├─ 遗留系统维护
│     ├─ 极端性能需求
│     └─ 硬件直接访问
│
├─【函数式编程/类型严格】
│  │
│  需要验证级别？
│  │
│  ├─ 完全形式化验证 → Coq/Lean ✅
│  │  │
│  │  特点:
│  │  ├─ 依赖类型
│  │  ├─ 证明辅助
│  │  ├─ 提取到OCaml/Haskell
│  │  └─ Curry-Howard对应
│  │  │
│  │  适用:
│  │  ├─ 关键系统 (航空/金融)
│  │  ├─ 编译器验证 (CompCert)
│  │  └─ 数学形式化
│  │  │
│  │  文档: 06.5, 01.7
│  │
│  └─ 工业函数式编程 → Haskell ✅
│     │
│     特点:
│     ├─ Hindley-Milner类型推导
│     ├─ 纯函数+惰性求值
│     ├─ 强大抽象 (Monad/Functor)
│     └─ System F多态
│     │
│     适用:
│     ├─ 金融系统 (风控/定价)
│     ├─ 编译器 (GHC, Pandoc)
│     └─ 分布式系统 (Cardano)
│     │
│     文档: 01.3, 06.4
│
├─【Web开发/全栈】
│  │
│  前端/后端？
│  │
│  ├─ 全栈JavaScript生态 → TypeScript ✅
│  │  │
│  │  特点:
│  │  ├─ 渐进类型系统
│  │  ├─ JS生态兼容
│  │  ├─ 类型系统图灵完备⚠️
│  │  └─ 编译时类型检查
│  │  │
│  │  警告:
│  │  ├─ 类型检查可能不终止
│  │  ├─ any类型逃生舱
│  │  └─ 运行时无类型保证
│  │  │
│  │  文档: 06.4
│  │
│  └─ 后端高性能 → Go ✅
│     │
│     特点:
│     ├─ 简单静态类型
│     ├─ goroutine并发 (CSP)
│     ├─ 编译快+执行快
│     └─ 标准库强大
│     │
│     适用:
│     ├─ 微服务 (K8s生态)
│     ├─ 云原生应用
│     └─ API服务
│     │
│     文档: 06.3
│
├─【AI/数据科学/脚本】
│  │
│  → Python ✅
│  │
│  特点:
│  ├─ 动态类型
│  ├─ 丰富生态 (NumPy/PyTorch)
│  ├─ 简单易学
│  └─ 快速原型
│  │
│  劣势:
│  ├─ 无编译时类型保证
│  ├─ GIL限制并发
│  └─ 性能较低 (可用C扩展)
│  │
│  增强:
│  └─ Python + Typing → 渐进类型检查
│
├─【配置/DSL】
│  │
│  需要总终止保证？
│  │
│  └─ 是 → Dhall ✅
│     │
│     特点:
│     ├─ 非图灵完备 (by design)
│     ├─ 总终止保证
│     ├─ 纯函数式
│     └─ 强类型
│     │
│     适用:
│     ├─ Kubernetes配置
│     ├─ CI/CD配置
│     └─ 任何需要确定性的配置
│     │
│     文档: 06.4
│
└─【并发/分布式/云原生】
   │
   → Go ✅
   │
   特点:
   ├─ goroutine (轻量级线程)
   ├─ channel (CSP通信)
   ├─ 简单并发原语
   └─ 云原生工具链 (K8s, Docker)
   │
   文档: 06.3
```

### 2.2 形式化工具选择

```text
形式化验证需求决策树
│
你的验证目标？
│
├─【定理证明/程序验证】
│  │
│  验证内容？
│  │
│  ├─ 数学定理形式化 → Lean 4 ✅
│  │  │
│  │  优势:
│  │  ├─ Mathlib4 (10万+定理)
│  │  ├─ 工业级性能
│  │  ├─ 现代策略语言
│  │  ├─ 活跃社区
│  │  └─ Fermat定理项目
│  │  │
│  │  适用:
│  │  ├─ 数学形式化
│  │  ├─ 教学
│  │  └─ 研究前沿
│  │  │
│  │  文档: 05_现代理论, 07.4
│  │
│  ├─ C编译器/系统软件 → Coq ✅
│  │  │
│  │  优势:
│  │  ├─ CompCert (验证的C编译器)
│  │  ├─ 成熟生态
│  │  ├─ CiC (依赖类型)
│  │  └─ 提取到OCaml
│  │  │
│  │  适用:
│  │  ├─ 程序验证
│  │  ├─ 编译器正确性
│  │  └─ 操作系统 (部分)
│  │  │
│  │  案例:
│  │  ├─ CompCert (6人年)
│  │  ├─ Feit-Thompson定理
│  │  └─ Software Foundations教材
│  │  │
│  │  文档: 06.5
│  │
│  └─ HoTT研究/前沿数学 → Cubical Agda ✅
│     │
│     特点:
│     ├─ 原生Cubical类型论
│     ├─ Univalence可计算
│     ├─ Path类型
│     └─ 1Lab项目 (形式化范畴论)
│     │
│     适用:
│     ├─ HoTT研究
│     ├─ 范畴论形式化
│     └─ 同伦论
│     │
│     文档: 05.2
│
├─【模型检测/协议验证】
│  │
│  系统类型？
│  │
│  ├─ 分布式协议/一致性 → TLA+ ✅
│  │  │
│  │  特点:
│  │  ├─ Lamport设计
│  │  ├─ 时序逻辑 (Temporal Logic)
│  │  ├─ TLC模型检测器
│  │  └─ 状态空间搜索
│  │  │
│  │  优势:
│  │  ├─ 自动化
│  │  ├─ 找反例
│  │  └─ 工业采用 (AWS, Azure)
│  │  │
│  │  适用:
│  │  ├─ Raft/Paxos验证
│  │  ├─ 分布式数据库
│  │  └─ 云服务协议
│  │  │
│  │  文档: 06.5
│  │
│  └─ 并发程序/死锁 → SPIN ✅
│     │
│     特点:
│     ├─ Promela语言
│     ├─ LTL性质验证
│     ├─ 部分序约简
│     └─ 自动化
│     │
│     适用:
│     ├─ 并发协议
│     ├─ 通信协议
│     └─ 死锁检测
│
├─【智能合约验证】
│  │
│  目标？
│  │
│  ├─ 学术完整性 → K Framework + Coq
│  │  │
│  │  特点:
│  │  ├─ EVM形式语义
│  │  ├─ 完整性证明
│  │  └─ 研究级别
│  │  │
│  │  适用:
│  │  └─ 学术研究/论文
│  │
│  ├─ 工业自动化 → Certora ✅
│  │  │
│  │  特点:
│  │  ├─ Solidity专用
│  │  ├─ SMT求解器后端 (Z3)
│  │  ├─ 自动化
│  │  └─ 商业支持
│  │  │
│  │  适用:
│  │  ├─ DeFi合约
│  │  ├─ 高价值合约
│  │  └─ 工业项目
│  │  │
│  │  文档: 06.2, 06.5
│  │
│  └─ 轻量快速检测 → Mythril/Slither
│     │
│     特点:
│     ├─ 符号执行
│     ├─ 启发式
│     ├─ 快速
│     └─ 不完全
│     │
│     适用:
│     ├─ 开发阶段
│     ├─ CI/CD集成
│     └─ 常见漏洞检测
│
└─【决策因素总结】
   │
   ├─ 自动化程度
   │  ├─ 全自动 → 模型检测/SMT
   │  ├─ 交互式 → 定理证明
   │  └─ 启发式 → 符号执行
   │
   ├─ 保证程度
   │  ├─ 完全保证 → 定理证明 ✅
   │  ├─ 有界保证 → 模型检测 ⚠️
   │  └─ 最佳努力 → 启发式工具 ⚠️
   │
   ├─ 成本考虑
   │  ├─ 关键系统 → 完全形式化
   │  │  (航空、金融核心、区块链)
   │  ├─ 重要系统 → 部分形式化
   │  │  (企业应用、分布式协议)
   │  └─ 一般系统 → 类型+测试
   │     (大多数应用)
   │
   └─ Rice定理启示 ⚠️
      ├─ 完美自动验证不可能
      ├─ 接受权衡
      └─ 选择合适工具
      │
      文档: 04.4, 06.5
```

---

## 3. 验证方法决策树

```text
如何验证程序正确性？
│
你的项目是什么？
│
├─【关键安全系统】
│  (航空、核电、医疗、金融核心)
│  │
│  → 完全形式化验证 ✅
│  │
│  方法:
│  ├─ 1. 形式化规范
│  │   └─ 用Coq/Lean定义精确规范
│  │
│  ├─ 2. 定理证明
│  │   ├─ 人工交互式证明
│  │   └─ 保证完全正确
│  │
│  └─ 3. 代码提取
│      └─ 从证明提取可执行代码
│  │
│  成本: 6-10人年 ⚠️
│  │
│  案例:
│  ├─ CompCert (C编译器, 6人年)
│  ├─ seL4 (微内核, 10人年)
│  └─ 智能合约 (关键DeFi)
│  │
│  文档: 06.5
│
├─【高价值智能合约】
│  (DeFi, 数百万美元锁仓)
│  │
│  → 商业形式化工具 ✅
│  │
│  流程:
│  ├─ 1. Certora自动验证
│  │   ├─ SMT求解器
│  │   └─ 自动找漏洞
│  │
│  ├─ 2. 专业审计
│  │   └─ 人工代码审查
│  │
│  └─ 3. 充分测试
│      ├─ 单元测试
│      ├─ 集成测试
│      └─ Fuzzing
│  │
│  成本: 数周到数月
│  │
│  文档: 06.2, 06.5
│
├─【分布式协议/共识算法】
│  (Raft, Paxos, 区块链共识)
│  │
│  → 模型检测 ✅
│  │
│  方法:
│  ├─ 1. TLA+建模
│  │   └─ 形式化协议规范
│  │
│  ├─ 2. TLC检测
│  │   ├─ 自动搜索状态空间
│  │   └─ 找反例
│  │
│  └─ 3. 实现验证
│      └─ 确保实现符合规范
│  │
│  优势:
│  ├─ 自动化
│  ├─ 找出边界情况
│  └─ 工业采用 (AWS, Azure)
│  │
│  文档: 06.5, 06.3
│
├─【系统编程】
│  (操作系统、数据库、编译器)
│  │
│  → 类型系统 + 部分形式化 ✅
│  │
│  流程:
│  ├─ 1. 选Rust
│  │   ├─ 所有权系统
│  │   ├─ 借用检查
│  │   └─ 编译时保证内存安全
│  │
│  ├─ 2. 充分测试
│  │   ├─ 单元测试
│  │   ├─ 集成测试
│  │   ├─ Fuzzing
│  │   └─ 性能测试
│  │
│  └─ 3. 关键部分形式化 (可选)
│      └─ 核心算法用Coq验证
│  │
│  案例:
│  └─ Rust生态 (Servo, TiKV)
│  │
│  文档: 06.4
│
├─【Web应用/一般服务】
│  (大多数应用)
│  │
│  → 类型检查 + 测试 ✅
│  │
│  最佳实践:
│  ├─ 1. 使用TypeScript
│  │   ├─ 静态类型检查
│  │   └─ 编译时错误
│  │
│  ├─ 2. 全面测试
│  │   ├─ 单元测试 (Jest)
│  │   ├─ 集成测试
│  │   ├─ E2E测试 (Cypress)
│  │   └─ 目标覆盖率 >80%
│  │
│  ├─ 3. 代码审查
│  │   └─ Pull Request流程
│  │
│  └─ 4. CI/CD
│      ├─ 自动化测试
│      ├─ Linting
│      └─ 部署前验证
│  │
│  成本: 合理 ✅
│
├─【快速原型/脚本】
│  (内部工具、数据分析、一次性脚本)
│  │
│  → 动态语言 + 基本测试
│  │
│  方法:
│  ├─ Python/JavaScript
│  ├─ 关键逻辑测试
│  └─ 快速迭代
│  │
│  权衡:
│  ├─ 开发速度 ✅
│  └─ 运行时错误 ⚠️
│
└─【配置文件/DSL】
   │
   → Dhall (总终止) ✅
   │
   特点:
   ├─ 非图灵完备
   ├─ 保证终止
   └─ 类型安全
   │
   适用:
   ├─ Kubernetes配置
   ├─ CI/CD配置
   └─ 任何需要确定性
   │
   文档: 06.4
```

---

## 4. 问题诊断决策树

```text
遇到问题如何诊断？
│
程序行为异常...
│
├─【编译失败】
│  │
│  错误类型？
│  │
│  ├─ 类型错误
│  │  │
│  │  静态类型语言:
│  │  ├─ 理解类型系统
│  │  ├─ 文档: 06.4, 01.7
│  │  └─ Hindley-Milner推导
│  │  │
│  │  类型系统图灵完备 (TypeScript):
│  │  ├─ 可能不终止 ⚠️
│  │  ├─ 简化类型
│  │  └─ 避免递归类型
│  │
│  └─ 借用检查错误 (Rust)
│     │
│     理解所有权系统:
│     ├─ 线性逻辑基础
│     ├─ 生命周期
│     └─ 文档: 06.4
│
├─【运行时崩溃】
│  │
│  崩溃原因？
│  │
│  ├─ 内存错误 (C/C++)
│  │  │
│  │  → 使用内存安全语言 ✅
│  │  ├─ Rust (编译时保证)
│  │  └─ 或者: Valgrind/AddressSanitizer
│  │
│  ├─ 空指针/None (动态语言)
│  │  │
│  │  → Option/Maybe类型 ✅
│  │  ├─ Rust: Option<T>
│  │  ├─ Haskell: Maybe a
│  │  └─ 强制处理None情况
│  │
│  └─ 栈溢出 (无限递归)
│     │
│     诊断:
│     ├─ 检查递归终止条件
│     ├─ 考虑尾递归优化
│     └─ 或改为迭代
│     │
│     理论:
│     └─ 停机问题不可判定 ⚠️
│        但大多数情况可分析
│        文档: 04.5
│
├─【逻辑错误】
│  (编译通过但结果错误)
│  │
│  → 测试 + 形式化验证
│  │
│  步骤:
│  ├─ 1. 单元测试
│  │   └─ 覆盖边界情况
│  │
│  ├─ 2. 属性测试 (Property-based)
│  │   ├─ QuickCheck (Haskell)
│  │   └─ Hypothesis (Python)
│  │
│  └─ 3. 关键部分形式化 (可选)
│     └─ Coq证明正确性
│  │
│  理论限制:
│  └─ Rice定理: 语义性质不可判定
│     文档: 04.4
│
├─【性能问题】
│  │
│  瓶颈类型？
│  │
│  ├─ 算法复杂度
│  │  │
│  │  → 复杂度分析
│  │  ├─ P vs NP问题
│  │  ├─ 文档: 04.2 复杂度矩阵
│  │  └─ 考虑近似算法
│  │
│  └─ 并发性能
│     │
│     → 并发模型选择
│     ├─ Go: goroutine + channel
│     ├─ Rust: 无数据竞争
│     └─ 文档: 06.3
│
├─【死锁/活锁】
│  (分布式系统、并发程序)
│  │
│  理论:
│  ├─ 死锁检测不可判定 ⚠️
│  │  (Petri网带抑止弧)
│  └─ 文档: 01.2, 02.1
│  │
│  实践应对:
│  ├─ 1. 设计避免
│  │   ├─ 资源排序
│  │   └─ 无锁数据结构
│  │
│  ├─ 2. 超时机制
│  │   └─ 强制终止长时间等待
│  │
│  ├─ 3. 健康检查
│  │   └─ 检测卡住的服务
│  │
│  └─ 4. Chaos Engineering
│     └─ 主动注入故障测试
│     文档: 06.3
│
└─【智能合约漏洞】
   │
   漏洞类型？
   │
   ├─ 重入攻击 (Reentrancy)
   │  │
   │  → Checks-Effects-Interactions模式
   │  ├─ 先修改状态
   │  └─ 再外部调用
   │
   ├─ 整数溢出
   │  │
   │  → SafeMath库
   │  └─ 或Solidity 0.8+ (内置检查)
   │
   └─ 访问控制
      │
      → 形式化验证
      ├─ Certora
      └─ 文档: 06.2, 06.5
```

---

## 🎯 如何使用本决策树

### 使用场景

**学习规划**:

- 使用 `1. 学习路径决策树`
- 根据背景和目标选择

**技术选型**:

- 使用 `2. 技术选型决策树`
- 语言、工具、方法选择

**项目验证**:

- 使用 `3. 验证方法决策树`
- 根据项目类型选择验证策略

**问题排查**:

- 使用 `4. 问题诊断决策树`
- 快速定位问题根源

### 与其他文档配合

**决策树** (本文档) = 路径选择
**思维导图** = 知识结构
**对比矩阵** = 横向对比
**知识图谱** = 概念关联

---

**最后更新**: 2025-12-02
**格式**: 决策树流程图
**推荐**: 遇到选择时查阅
