# 不动点理论与最小语义

> **主题**: 递归定义的数学基础
> **创建日期**: 2025-12-02
> **难度**: ⭐⭐⭐⭐
> **前置知识**: 偏序集、格论基础

---

## 📋 目录

- [不动点理论与最小语义](#不动点理论与最小语义)
  - [📋 目录](#-目录)
  - [1. 不动点的直觉](#1-不动点的直觉)
    - [1.1 什么是不动点？](#11-什么是不动点)
    - [1.2 为什么不动点重要？](#12-为什么不动点重要)
    - [1.3 递归可枚举性与不动点](#13-递归可枚举性与不动点)
  - [2. Knaster-Tarski不动点定理](#2-knaster-tarski不动点定理)
    - [2.1 完备格基础](#21-完备格基础)
    - [2.2 单调函数](#22-单调函数)
    - [2.3 Knaster-Tarski定理](#23-knaster-tarski定理)
    - [2.4 Kleene不动点定理](#24-kleene不动点定理)
  - [3. Scott不动点定理](#3-scott不动点定理)
    - [3.1 完备偏序集 (CPO)](#31-完备偏序集-cpo)
    - [3.2 Scott连续函数](#32-scott连续函数)
    - [3.3 Scott不动点定理](#33-scott不动点定理)
  - [4. Y组合子与递归](#4-y组合子与递归)
    - [4.1 λ演算中的不动点](#41-λ演算中的不动点)
    - [4.2 Y组合子](#42-y组合子)
    - [4.3 不动点组合子的多样性](#43-不动点组合子的多样性)
  - [5. 最小不动点语义](#5-最小不动点语义)
    - [5.1 为什么要"最小"？](#51-为什么要最小)
    - [5.2 归纳定义的语义](#52-归纳定义的语义)
    - [5.3 余归纳定义的语义](#53-余归纳定义的语义)
  - [6. 应用实例](#6-应用实例)
    - [6.1 文法语言生成](#61-文法语言生成)
    - [6.2 Petri网可达标识](#62-petri网可达标识)
    - [6.3 λ项的范式](#63-λ项的范式)
    - [6.4 程序语义](#64-程序语义)
  - [7. 深刻洞察](#7-深刻洞察)
    - [7.1 递归 = 不动点](#71-递归--不动点)
    - [7.2 构造性 vs 存在性](#72-构造性-vs-存在性)
    - [7.3 归纳 vs 余归纳](#73-归纳-vs-余归纳)
  - [8. 习题与思考](#8-习题与思考)
    - [习题1 (容易)](#习题1-容易)
    - [习题2 (中等)](#习题2-中等)
    - [习题3 (困难)](#习题3-困难)
    - [思考题](#思考题)
  - [9. 参考资源](#9-参考资源)
    - [经典论文](#经典论文)
    - [教材](#教材)


---

## 1. 不动点的直觉

### 1.1 什么是不动点？

**定义1.1 (不动点)**: 设 f: X → X 是集合 X 上的函数，x ∈ X 是 f 的**不动点**，如果：

```text
f(x) = x
```

**直觉例子**:

1. **恒等函数**: f(x) = x
   - 每个点都是不动点

2. **平方函数**: f(x) = x²
   - 不动点: x = 0, x = 1

3. **余弦函数**: f(x) = cos(x)
   - 不动点: x ≈ 0.739085（Dottie数）

### 1.2 为什么不动点重要？

**核心洞察**: **递归定义 = 寻找不动点**

**例子**: 阶乘函数的递归定义

```text
fact(n) = if n = 0 then 1 else n * fact(n-1)
```

可以写成不动点形式：

```text
fact = F(fact)
```

其中 F 是函数的函数（高阶函数）：

```text
F(f) = λn. if n = 0 then 1 else n * f(n-1)
```

**关键**: fact 是 F 的不动点！

### 1.3 递归可枚举性与不动点

**view00.md的核心洞察**:

> "所有'递归可枚举'的构造，本质上都在寻找函数的最小不动点"

**实例**:

| 系统 | 递归定义 | 不动点形式 |
|------|----------|-----------|
| 文法 | L(G) = T ∪ {αβγ \| A→β ∈ P, αAγ ∈ L(G)} | L(G) = μX. (T ∪ derive(X)) |
| Petri网 | Reach(N) = M₀ ∪ {m' \| ∃m∈Reach(N), m→m'} | Reach = μX. (M₀ ∪ next(X)) |
| λ演算 | Eval(M) = {M} ∪ {N \| ∃P∈Eval(M), P→ᵦN} | Eval = μX. ({M} ∪ reduce(X)) |

---

## 2. Knaster-Tarski不动点定理

### 2.1 完备格基础

**定义2.1 (偏序集 Poset)**: (L, ≤) 是偏序集，如果 ≤ 满足：

1. **自反性**: x ≤ x
2. **反对称性**: x ≤ y ∧ y ≤ x ⟹ x = y
3. **传递性**: x ≤ y ∧ y ≤ z ⟹ x ≤ z

**定义2.2 (完备格 Complete Lattice)**: (L, ≤) 是完备格，如果：

- 每个子集 S ⊆ L 都有**最小上界** ⋁S (supremum)
- 每个子集 S ⊆ L 都有**最大下界** ⋀S (infimum)

**推论**: 完备格必有：

- **最小元** ⊥ = ⋀L
- **最大元** ⊤ = ⋁L

**例子**:

1. **幂集格** (P(X), ⊆):
   - ⊥ = ∅
   - ⊤ = X
   - ⋁ = 并集
   - ⋀ = 交集

2. **真值格** ({⊥, ⊤}, ≤):
   - 布尔值的偏序

3. **函数格** (X → Y, ⊑):
   - 逐点序: f ⊑ g ⟺ ∀x. f(x) ≤ g(x)

### 2.2 单调函数

**定义2.3 (单调函数)**: f: L → L 是单调的，如果：

```text
∀x, y ∈ L. x ≤ y ⟹ f(x) ≤ f(y)
```

**例子**:

- f(x) = x ∪ {0} 在 (P(ℕ), ⊆) 上单调
- f(x) = x + 1 在 (ℕ, ≤) 上单调
- f(x) = -x 在 (ℝ, ≤) 上**不**单调

### 2.3 Knaster-Tarski定理

**定理2.1 (Knaster-Tarski, 1955)**:

设 (L, ≤) 是完备格，f: L → L 单调，则：

1. **f 有不动点**
2. **不动点集合形成完备格**
3. **最小不动点存在**: μf = ⋀{x ∈ L | f(x) ≤ x}
4. **最大不动点存在**: νf = ⋁{x ∈ L | x ≤ f(x)}

**证明思路** (最小不动点):

```text
设 P = {x ∈ L | f(x) ≤ x}  (不动点的前后一致集)
设 p = ⋀P                   (P的最大下界)

关键步骤:
1. 证明 f(p) ≤ p:
   ∀x ∈ P. p ≤ x ⟹ f(p) ≤ f(x) ≤ x  (单调性)
   ∴ f(p) 是 P 的下界
   ∴ f(p) ≤ p                        (p是最大下界)

2. 证明 p ≤ f(p):
   由 f(p) ≤ p 知 f(f(p)) ≤ f(p)    (单调性)
   ∴ f(p) ∈ P
   ∴ p ≤ f(p)                        (p是下界)

3. 结合: f(p) = p  □
```

### 2.4 Kleene不动点定理

**定理2.2 (Kleene迭代)**: 在完备格上，最小不动点可通过迭代获得：

```text
μf = ⋁{fⁿ(⊥) | n ∈ ℕ}
```

其中：

- f⁰(⊥) = ⊥
- fⁿ⁺¹(⊥) = f(fⁿ(⊥))

**直觉**: 从"空"开始，不断应用 f，直到达到不动点

**例子**: 计算文法的语言

```text
f(X) = {ε} ∪ {aw | w ∈ X}  (生成 {aⁿ | n ≥ 0})

f⁰(∅) = ∅
f¹(∅) = {ε}
f²(∅) = {ε, a}
f³(∅) = {ε, a, aa}
...
μf = {ε, a, aa, aaa, ...} = {aⁿ | n ≥ 0}
```

---

## 3. Scott不动点定理

### 3.1 完备偏序集 (CPO)

**定义3.1 (CPO)**: (D, ⊑) 是完备偏序集，如果：

1. D 是偏序集
2. D 有最小元 ⊥
3. 每个**递增链** x₀ ⊑ x₁ ⊑ x₂ ⊑ ... 都有最小上界 ⋁ᵢxᵢ

**与完备格的区别**:

- 完备格: **所有**子集有上下界
- CPO: 只要求**链**有上界（更弱）

**例子**:

1. **平坦CPO** (Flat domain):

   ```text
   D = {⊥} ∪ {a, b, c, ...}
   ⊥ ⊑ a, ⊥ ⊑ b, ... (但 a, b 不可比)
   ```

2. **函数空间** [D → E]:
   - (D → E, ⊑) 是CPO，如果 E 是CPO
   - 逐点序: f ⊑ g ⟺ ∀x. f(x) ⊑ g(x)

3. **部分函数** (ℕ ⇀ ℕ):
   - 定义域的扩张形成递增链

### 3.2 Scott连续函数

**定义3.2 (Scott连续)**: f: D → E 是Scott连续的，如果：

```text
对任意递增链 x₀ ⊑ x₁ ⊑ ..., 有:
f(⋁ᵢ xᵢ) = ⋁ᵢ f(xᵢ)
```

**直觉**: 连续函数**保持极限**

**性质**:

- Scott连续 ⟹ 单调
- 反之不成立（单调不一定连续）

**例子**:

1. **连续**: f(x) = x ∪ {0}
   - f(⋁ᵢ Xᵢ) = (⋁ᵢ Xᵢ) ∪ {0} = ⋁ᵢ (Xᵢ ∪ {0}) = ⋁ᵢ f(Xᵢ)

2. **不连续**: f(X) = if |X| < ∞ then X else ℕ
   - 单调但不连续（在无限集处跳跃）

### 3.3 Scott不动点定理

**定理3.1 (Scott)**: 设 D 是 CPO，f: D → D Scott连续，则：

```text
μf = ⋁{fⁿ(⊥) | n ∈ ℕ}
```

存在且是最小不动点。

**证明**:

```text
设链: ⊥ ⊑ f(⊥) ⊑ f²(⊥) ⊑ ...
设 x = ⋁ₙ fⁿ(⊥)

关键: f(x) = f(⋁ₙ fⁿ(⊥))
            = ⋁ₙ f(fⁿ(⊥))      (连续性)
            = ⋁ₙ fⁿ⁺¹(⊥)
            = ⋁ₙ fⁿ(⊥)         (重新索引)
            = x

∴ x 是不动点  □
```

**应用**: Domain理论，指称语义

---

## 4. Y组合子与递归

### 4.1 λ演算中的不动点

**问题**: λ演算中如何定义递归函数？

**不能写**:

```text
fact = λn. if n=0 then 1 else n * fact(n-1)
```

因为 fact 出现在右边（自指）！

**解决**: 用**不动点组合子** (Fixed-Point Combinator)

### 4.2 Y组合子

**定义4.1 (Curry的Y组合子)**:

```text
Y = λf. (λx. f(x x)) (λx. f(x x))
```

**神奇性质**: 对任何 F:

```text
Y F = F (Y F)
```

**验证**:

```text
Y F = (λf. (λx. f(x x)) (λx. f(x x))) F
    →ᵦ (λx. F(x x)) (λx. F(x x))
    →ᵦ F((λx. F(x x)) (λx. F(x x)))
    = F(Y F)  ✓
```

**应用**: 定义递归函数

```text
fact = Y (λf. λn. if n=0 then 1 else n*f(n-1))

fact 5 →* Y F 5
       →* F(Y F) 5
       →* 5 * (Y F 4)
       →* 5 * 4 * (Y F 3)
       ...
       →* 120
```

### 4.3 不动点组合子的多样性

**其他不动点组合子**:

1. **Turing组合子**:

   ```text
   Θ = (λx. λy. y(x x y)) (λx. λy. y(x x y))
   ```

2. **call/cc实现** (Scheme):

   ```scheme
   (define Y
     (lambda (f)
       (call/cc (lambda (k) (f (k (Y f)))))))
   ```

3. **简单类型λ演算**: Y组合子**不可类型化**！
   - 需要递归类型: μα. (α → α)

---

## 5. 最小不动点语义

### 5.1 为什么要"最小"？

**问题**: 方程可能有多个解（不动点）

**例子**: f(x) = x 在 P(ℕ) 上

- ∅ 是不动点: f(∅) = ∅
- ℕ 是不动点: f(ℕ) = ℕ
- 任何集合都是不动点！

**选择**: 最小不动点 = **最少信息**的解

### 5.2 归纳定义的语义

**原则**: 归纳定义的含义 = 其生成算子的最小不动点

**例子1: 偶数的归纳定义**

```text
基础: 0 是偶数
归纳: 如果 n 是偶数，则 n+2 是偶数
```

**生成算子**:

```text
F(S) = {0} ∪ {n+2 | n ∈ S}
```

**最小不动点**:

```text
μF = ⋁ₙ Fⁿ(∅)
   = F⁰(∅) ∪ F¹(∅) ∪ F²(∅) ∪ ...
   = ∅ ∪ {0} ∪ {0,2} ∪ {0,2,4} ∪ ...
   = {0, 2, 4, 6, ...}
```

**例子2: 列表的归纳定义**

```haskell
data List a = Nil | Cons a (List a)
```

**生成算子**:

```text
F(X) = {Nil} ∪ {Cons(a, x) | a ∈ A, x ∈ X}
```

**最小不动点** = 所有有限列表

### 5.3 余归纳定义的语义

**对偶**: 余归纳定义的含义 = 其生成算子的**最大不动点**

**例子: 无限流**

```haskell
data Stream a = Cons a (Stream a)  -- 没有 Nil!
```

**生成算子**:

```text
F(X) = {Cons(a, x) | a ∈ A, x ∈ X}
```

**最大不动点** νF = 所有有限**和**无限列表

**区别**:

- **归纳** (μF): 有限构造（最小）
- **余归纳** (νF): 可能无限（最大）

---

## 6. 应用实例

### 6.1 文法语言生成

**文法**: S → ε | aSb

**生成算子**:

```text
F(L) = {ε} ∪ {aub | u ∈ L}
```

**Kleene迭代**:

```text
L₀ = ∅
L₁ = {ε}
L₂ = {ε, ab}
L₃ = {ε, ab, aabb}
...
L(G) = μF = {aⁿbⁿ | n ≥ 0}
```

### 6.2 Petri网可达标识

**Petri网**: N = (P, T, F, M₀)

**后继算子**:

```text
post(M) = {M' | ∃t ∈ T, M →ᵗ M'}
```

**可达集**:

```text
Reach(N) = μX. M₀ ∪ post(X)
         = ⋁ₙ postⁿ(M₀)
```

### 6.3 λ项的范式

**归约算子**:

```text
reduce(S) = S ∪ {N | ∃M ∈ S, M →ᵦ N}
```

**从M可达的项**:

```text
Reach(M) = μX. {M} ∪ reduce(X)
```

**范式**: 如果 Reach(M) 包含范式，则 M 可规约

### 6.4 程序语义

**While语言**: `while B do C`

**指称语义** (Denotational Semantics):

```text
⟦while B do C⟧ = μf. λσ. if ⟦B⟧σ then f(⟦C⟧σ) else σ
```

**操作语义** = 不动点的迭代逼近

---

## 7. 深刻洞察

### 7.1 递归 = 不动点

**统一视角**:

| 概念 | 不动点形式 |
|------|-----------|
| 递归函数 | f = F(f) |
| 归纳定义 | X = F(X) 的最小解 |
| 循环程序 | σ = F(σ) |
| 文法语言 | L = F(L) |

**哲学**: 所有"自指"都是寻找不动点

### 7.2 构造性 vs 存在性

**Knaster-Tarski**: 存在性证明（非构造性）

- 证明不动点存在，但不告诉你怎么算

**Scott定理**: 构造性证明

- 通过迭代 fⁿ(⊥) 显式构造
- 可计算！

### 7.3 归纳 vs 余归纳

**归纳** (μ): 从内向外构造

- 有限、可终止
- 例: 自然数、有限列表

**余归纳** (ν): 从外向内观察

- 可能无限
- 例: 无限流、进程

**Lambek引理**: μF ≅ F(μF) 且 νF ≅ F(νF)

- 不动点与其展开同构

---

## 8. 习题与思考

### 习题1 (容易)

证明: 在完备格上，f(x) = x ∪ {0} 有最小不动点 {0}。

### 习题2 (中等)

计算以下文法的语言（用不动点迭代）:

```text
S → a | bS
```

### 习题3 (困难)

证明: Y组合子在简单类型λ演算中不可类型化。

### 思考题

为什么归纳定义选择最小不动点，而不是最大不动点？

---

## 9. 参考资源

### 经典论文

1. **Tarski, A. (1955)**. "A Lattice-Theoretical Fixpoint Theorem"
2. **Scott, D. (1970)**. "Outline of a Mathematical Theory of Computation"
3. **Curry, H. (1958)**. _Combinatory Logic_

### 教材

1. **Winskel, G.** - _The Formal Semantics of Programming Languages_
2. **Sangiorgi, D.** - _Introduction to Bisimulation and Coinduction_

---

**最后更新**: 2025-12-02
**状态**: 初稿完成
