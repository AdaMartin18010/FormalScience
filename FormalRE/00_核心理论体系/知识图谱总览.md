# FormalRE 知识图谱总览

> **目的**: 整体把握RE理论知识体系
> **更新**: 2025-12-02
> **核心**: 概念关联、层次结构、推理路径

---

## 📋 目录

- [FormalRE 知识图谱总览](#formalre-知识图谱总览)
  - [📋 目录](#-目录)
  - [1. 核心概念关系图](#1-核心概念关系图)
    - [1.1 三层等价性架构](#11-三层等价性架构)
    - [1.2 七系统关联网络](#12-七系统关联网络)
  - [2. 概念层次树](#2-概念层次树)
    - [2.1 递归可枚举性分解](#21-递归可枚举性分解)
    - [2.2 计算等价性分解](#22-计算等价性分解)
  - [3. 证明依赖图](#3-证明依赖图)
    - [3.1 等价性证明链](#31-等价性证明链)
    - [3.2 定理依赖关系](#32-定理依赖关系)
  - [4. 多维对比矩阵](#4-多维对比矩阵)
    - [4.1 七系统全维对比](#41-七系统全维对比)
    - [4.2 复杂度分层矩阵](#42-复杂度分层矩阵)
  - [5. 学习路径决策树](#5-学习路径决策树)
    - [5.1 按背景选择路径](#51-按背景选择路径)
    - [5.2 按目标选择深度](#52-按目标选择深度)
  - [6. 技术选型决策树](#6-技术选型决策树)
    - [6.1 编程语言类型系统](#61-编程语言类型系统)
    - [6.2 形式化工具选择](#62-形式化工具选择)
  - [🎯 使用本图谱](#-使用本图谱)
    - [导航建议](#导航建议)
    - [与其他文档的关系](#与其他文档的关系)

---

## 1. 核心概念关系图

### 1.1 三层等价性架构

```text
┌─────────────────────────────────────────────────────────────┐
│                    强等价 (范畴对偶)                        │
│         Curry-Howard-Lambek: 同一实体不同投影               │
│                                                               │
│  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐   │
│  │   逻辑      │≅≅≅≅│   类型论    │≅≅≅≅│   范畴论    │   │
│  │ (命题证明)  │     │ (类型程序)  │     │ (对象态射)  │   │
│  └─────────────┘     └─────────────┘     └─────────────┘   │
│         ║                   ║                   ║            │
└─────────╬═══════════════════╬═══════════════════╬───────────┘
          ║                   ║                   ║
┌─────────╬═══════════════════╬═══════════════════╬───────────┐
│         ║      中等价 (不动点语义)              ║            │
│         ║         μX.F(X) 统一模式              ║            │
│         ║                                        ║            │
│  ┌──────▼──────┐     ┌──────▼──────┐     ┌────▼──────┐     │
│  │ Y组合子     │     │ 初始代数    │     │ 归纳类型  │     │
│  │ fix f       │     │ μF          │     │ data T    │     │
│  └─────────────┘     └─────────────┘     └───────────┘     │
│         ║                   ║                   ║            │
└─────────╬═══════════════════╬═══════════════════╬───────────┘
          ║                   ║                   ║
┌─────────╬═══════════════════╬═══════════════════╬───────────┐
│         ║      弱等价 (计算能力)                 ║           │
│         ║     Church-Turing 论题                ║           │
│         ║                                       ║           │
│  ┌──────▼──────┐     ┌──────▼──────┐     ┌────▼──────┐      │
│  │  图灵机      │═══ │  Lambda演算  │═══  │  Petri网  │      │
│  │   所有七系统都识别相同的RE语言                │     │
│  └─────────────┴─────┴─────────────┴─────┴───────────┘      │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 七系统关联网络

```text
                    递归可枚举性 (RE)
                          │
          ┌───────────────┼───────────────┐
          │               │               │
     计算能力         表达方式         数学基础
          │               │               │
    ┌─────┴─────┐   ┌────┴────┐   ┌─────┴─────┐
    │           │   │         │   │           │
图灵机    Petri网  Lambda  形式文法  集合论  范畴论  类型论
 (1)       (2)     (3)      (4)     (5)     (6)     (7)
  │         │       │        │       │       │       │
  │         │       │        │       │       │       │
  └─────────┴───────┴────────┴───────┴───────┴───────┘
              │                 │                │
         并发/资源          语言生成          证明结构
              │                 │                │
          ┌───┴───┐         ┌───┴───┐       ┌───┴───┐
          │       │         │       │       │       │
       微服务  区块链    编译器  NLP    Coq   Lean

关键关联:
━━━ 证明链 (02模块)
─── 应用领域
··· 理论基础
```

---

## 2. 概念层次树

### 2.1 递归可枚举性分解

```text
递归可枚举性 (RE)
├─ 定义方式
│  ├─ 枚举器定义: ∃程序枚举语言
│  ├─ 接受器定义: ∃图灵机半判定
│  ├─ 逻辑定义: Σ₁⁰ (Post定理)
│  └─ 不动点定义: μX.(初始∪step(X))
│
├─ 性质特征
│  ├─ 可枚举但不一定可判定
│  ├─ 在补运算下不封闭
│  ├─ 并、交封闭
│  └─ 存在RE但非递归语言
│
├─ 层次关系
│  ├─ 递归 ⊂ RE
│  ├─ RE ⊂ co-RE = ∅ (不可判定)
│  ├─ Σ₁⁰ (RE) ⊂ Σ₂⁰ ⊂ ... (算术谱系)
│  └─ RE ⊂ P ⊂ NP ⊂ PSPACE ⊂ EXP
│
├─ 不可判定性根源
│  ├─ 自指 (对角化论证)
│  ├─ 停机问题 (Turing 1936)
│  ├─ Rice定理 (语义性质)
│  └─ Gödel不完备 (数学基础)
│
├─ 七系统体现
│  ├─ 图灵机: 停机配置集
│  ├─ Petri网: 可达标识集
│  ├─ Lambda: βη-范式集
│  ├─ 文法: 生成语言
│  ├─ 集合论: Σ₁⁰公式
│  ├─ 范畴论: 初始代数载体
│  └─ 类型论: well-typed项集
│
└─ 实践意义
   ├─ 计算限制理论基础
   ├─ 类型系统可判定性权衡
   ├─ 静态分析工具边界
   └─ 形式化验证范围
```

### 2.2 计算等价性分解

```text
计算等价性
├─ 弱等价 (能力层)
│  ├─ Church-Turing论题
│  │  ├─ 物理CT: 物理可计算=图灵可计算
│  │  ├─ 经验CT: 所有已知模型等价
│  │  └─ 强CT: 多项式时间等价(存疑)
│  │
│  ├─ 等价证明方法
│  │  ├─ 模拟构造 (直接编码)
│  │  ├─ 中间模型 (如2计数器机)
│  │  └─ 归约 (可计算性归约)
│  │
│  └─ 七系统等价链 (02模块)
│     ├─ Petri → TM (抑止弧)
│     ├─ TM → Lambda (Y组合子)
│     ├─ Lambda → 文法 (枚举器)
│     ├─ 文法 → 集合论 (Post定理)
│     ├─ 集合论 → 范畴论 (Topos)
│     ├─ 范畴论 → 类型论 (Lambek)
│     └─ 类型论 → Petri (逆向)
│
├─ 中等价 (语义层)
│  ├─ 不动点理论 (00.4)
│  │  ├─ Y组合子: fix f = f (fix f)
│  │  ├─ 初始代数: μF 的泛性质
│  │  ├─ 最小不动点: μX.F(X) = ⋃Fⁿ(⊥)
│  │  └─ Knaster-Tarski: 单调函数不动点
│  │
│  ├─ Domain理论 (00.5)
│  │  ├─ CPO (完全偏序)
│  │  ├─ Scott连续
│  │  ├─ 最小元⊥ (未定义)
│  │  └─ 不动点语义
│  │
│  └─ 七系统不动点体现
│     ├─ Lambda: Y = λf.(λx.f(x x))(λx.f(x x))
│     ├─ 范畴论: 初始 F-代数
│     ├─ 类型论: 归纳类型
│     ├─ 集合论: V = ⋃V_α
│     ├─ 图灵机: Halt = fix(step)
│     ├─ Petri: Reach = μR.(M₀∪post(R))
│     └─ 文法: L(G) = μL.(T∪derive(L))
│
└─ 强等价 (结构层)
   ├─ Curry-Howard (逻辑↔类型)
   │  ├─ 命题 ↔ 类型
   │  ├─ 证明 ↔ 程序
   │  ├─ 证明正规化 ↔ 程序终止
   │  └─ 命题逻辑 ↔ STLC
   │
   ├─ Lambek (类型↔范畴)
   │  ├─ 类型 ↔ 对象
   │  ├─ 项 ↔ 态射
   │  ├─ 函数类型 ↔ 指数对象
   │  └─ STLC ↔ CCC
   │
   ├─ Curry-Howard-Lambek三位一体
   │  └─ 逻辑 ≅ 类型论 ≅ 范畴论(CCC)
   │
   └─ 扩展: Topos理论
      ├─ 逻辑 ≅ 类型 ≅ 范畴(Topos)
      ├─ 内蕴逻辑 (直觉主义)
      └─ 集合论的范畴模型
```

---

## 3. 证明依赖图

### 3.1 等价性证明链

```text
完整证明链 (02模块)
════════════════════

       ┌───────────┐
       │  Petri网  │
       │(抑止弧PN)│
       └─────┬─────┘
             │ 02.1
             │ 关键: 抑止弧 = 零测试
             │ 方法: Petri → 2计数器机 → TM
             ↓
       ┌─────────────┐
       │  图灵机 (TM)│
       │  通用计算   │
       └──────┬──────┘
              │ 02.2
              │ 关键: Y组合子实现循环
              │ 方法: 状态编码 + 转移函数
              ↓
       ┌──────────────┐
       │ Lambda演算(λ)│
       │  函数式计算  │
       └──────┬───────┘
              │ 02.3
              │ 关键: 枚举器构造
              │ 方法: λ项 → 产生式规则
              ↓
       ┌──────────────┐
       │  形式文法(G) │
       │   语言生成   │
       └──────┬───────┘
              │ 02.4
              │ 关键: Post定理 (Σ₁⁰=RE)
              │ 方法: RE语言 ↔ 算术谱系
              ↓
       ┌──────────────┐
       │ 集合论(ZF/C) │
       │   数学基础   │
       └──────┬───────┘
              │ 02.5
              │ 关键: Topos = 广义集合宇宙
              │ 方法: Set范畴 → 初等Topos
              ↓
       ┌──────────────┐
       │  范畴论(CCC) │
       │    元理论    │
       └──────┬───────┘
              │ 02.6
              │ 关键: Lambek定理 (CCC≅STLC)
              │ 方法: 指数对象 ↔ 函数类型
              ↓
       ┌──────────────┐
       │ 类型论(Type) │
       │  证明即程序  │
       └──────────────┘
              │
              └─→ (逆向回Petri网)

每个箭头对应一篇完整证明文档
所有证明构造性且双向
```

### 3.2 定理依赖关系

```text
核心定理依赖树
══════════════

Church-Turing论题 (00.1)
    │
    ├─→ Turing (1936): 图灵机定义
    ├─→ Church (1936): λ演算
    ├─→ Post (1944): 递归可枚举性
    │
    ├─ 不可判定性基础
    │   │
    │   ├─→ 停机问题 (04.5)
    │   │    ├─ 对角化论证
    │   │    ├─ 自指悖论
    │   │    └─ 应用: 编译器优化限制
    │   │
    │   └─→ Rice定理 (04.4)
    │        ├─ 依赖: 停机问题
    │        ├─ 证明: 归约
    │        └─ 应用: 静态分析边界
    │
    ├─ 复杂度层次
    │   │
    │   ├─→ Chomsky层级 (04.1)
    │   │    ├─ Type 0 (RE) = TM
    │   │    ├─ Type 1 (CSL) = LBA
    │   │    ├─ Type 2 (CFL) = PDA
    │   │    └─ Type 3 (Reg) = FA
    │   │
    │   └─→ 算术谱系 (04.2)
    │        ├─ Σ₁⁰ = RE (Post定理)
    │        ├─ Π₁⁰ = co-RE
    │        └─ Δ₂⁰ = 递归
    │
    └─ 语义等价
        │
        ├─→ 不动点理论 (00.4)
        │    ├─ Y组合子
        │    ├─ 初始代数
        │    └─ Knaster-Tarski
        │
        └─→ Domain理论 (00.5)
             ├─ CPO
             ├─ Scott连续
             └─ 不动点语义

Curry-Howard-Lambek (00.2)
    │
    ├─→ Curry (1934): 组合子逻辑
    ├─→ Howard (1969): 公式即类型
    ├─→ Lambek (1980): CCC≅STLC
    │
    ├─ 范畴论扩展
    │   │
    │   ├─→ CCC (03.1)
    │   │    ├─ 终对象
    │   │    ├─ 积
    │   │    └─ 指数对象
    │   │
    │   ├─→ Topos理论 (03.2)
    │   │    ├─ 子对象分类器
    │   │    ├─ 内蕴逻辑
    │   │    └─ 集合论模型
    │   │
    │   └─→ 伴随函子 (03.4)
    │        ├─ 自由/遗忘
    │        ├─ Hom同构
    │        └─ 单位/余单位
    │
    └─ 类型系统
        │
        ├─→ 简单类型 (STLC)
        ├─→ System F (多态)
        ├─→ 依赖类型 (01.7)
        │    ├─ Π类型
        │    ├─ Σ类型
        │    └─ 应用: Coq/Lean
        │
        └─→ HoTT (05.1)
             ├─ 同一性类型=路径
             ├─ Univalence公理
             └─ Cubical (05.2)
```

---

## 4. 多维对比矩阵

### 4.1 七系统全维对比

```text
┌──────────┬────────┬──────┬──────┬──────┬────────┬──────┬──────┐
│  系统     │ 图灵机 │Petri │Lambda│ 文法 │ 集合论  │ 范畴 │ 类型 │
├──────────┼────────┼──────┼──────┼──────┼────────┼──────┼──────┤
│**直觉**  │ 纸带   │ 令牌 │ 函数 │ 产生 │ 元素   │ 态射 │ 程序 │
│          │ 状态   │ 流动 │ 应用 │ 规则 │ 集合   │ 对象 │ 类型 │
├──────────┼────────┼──────┼──────┼──────┼────────┼──────┼──────┤
│**计算**  │ 转移   │ 发射 │ β归约│ 推导 │ 公式   │ 函子 │ 项   │
│**方式**  │        │      │      │      │ 求值   │ 组合 │ 规约 │
├──────────┼────────┼──────┼──────┼──────┼────────┼──────┼──────┤
│**并发**  │ 否     │ 是✅ │ 否   │ 否   │ 否     │ 否   │ 部分 │
├──────────┼────────┼──────┼──────┼──────┼────────┼──────┼──────┤
│**图灵**  │ 是✅   │ 是✅ │ 是✅ │ 是✅ │ 是✅   │ 是✅ │ 取决 │
│**完备**  │        │(抑止)│      │(T0)  │        │(CCC) │ 于   │
├──────────┼────────┼──────┼──────┼──────┼────────┼──────┼──────┤
│**RE**    │ 停机   │ 可达 │ 范式 │ 生成 │ Σ₁⁰   │ 初始 │well- │
│**体现**  │ 配置   │ 标识 │      │ 语言 │        │ 代数 │typed │
├──────────┼────────┼──────┼──────┼──────┼────────┼──────┼──────┤
│**不动点**│ fix    │ μR=  │ Y组  │ μL=  │ V=     │ μF   │ Ind  │
│**模式**  │(step)  │M₀∪.  │ 合子 │T∪.   │ ⋃V_α  │      │ Type │
├──────────┼────────┼──────┼──────┼──────┼────────┼──────┼──────┤
│**类型**  │ 无     │ 无   │ 可选 │ 无   │ 一阶   │ 高阶 │ 原生 │
│**系统**  │        │      │ STLC │      │ 逻辑   │      │      │
├──────────┼────────┼──────┼──────┼──────┼────────┼──────┼──────┤
│**应用**  │ 理论   │ 并发 │ 函数 │ 编译 │ 数学   │ 元   │ 验证 │
│**领域**  │ 基础   │ 系统 │ 式   │ 器   │ 基础   │ 理论 │ 证明 │
├──────────┼────────┼──────┼──────┼──────┼────────┼──────┼──────┤
│**工程**  │ 通用   │ K8s  │Haskell│ ANTLR│ Proof  │ 设计 │ Rust │
│**实例**  │ 计算   │ DeFi │ React│ GPT  │ Asst.  │ 模式 │ Coq  │
├──────────┼────────┼──────┼──────┼──────┼────────┼──────┼──────┤
│**优势**  │ 通用   │ 可视 │ 优雅 │ 语法 │ 数学   │ 抽象 │ 安全 │
│          │ 简单   │ 并发 │ 组合 │ 分析 │ 严格   │ 统一 │ 证明 │
├──────────┼────────┼──────┼──────┼──────┼────────┼──────┼──────┤
│**劣势**  │ 低级   │ 状态 │ 数学 │ 表达 │ 复杂   │ 抽象 │ 学习 │
│          │ 抽象   │ 爆炸 │ 门槛 │ 受限 │ 难懂   │ 难懂 │ 曲线 │
├──────────┼────────┼──────┼──────┼──────┼────────┼──────┼──────┤
│**可判定**│ 否     │ 部分 │ STLC │ 部分 │ 一阶   │ 看   │ 取决 │
│**性**    │        │(无抑)│ 是✅ │ 是   │ 是✅   │ 系统 │ 类型 │
└──────────┴────────┴──────┴──────┴──────┴────────┴──────┴──────┘
```

### 4.2 复杂度分层矩阵

```text
┌─────────┬──────────┬────────┬──────────┬────────────┐
│ 层级    │ 时间复杂度│ 自动机 │ 文法      │ 典型问题   │
├─────────┼──────────┼────────┼──────────┼────────────┤
│**Reg**  │ O(n)     │ FA     │ Type 3   │ 词法分析   │
│正则     │ 线性     │        │ 右线性   │ 正则匹配   │
├─────────┼──────────┼────────┼──────────┼────────────┤
│**CFL**  │ O(n³)    │ PDA    │ Type 2   │ 语法分析   │
│上下文无关│ 多项式   │ 栈     │ 上下文无 │ 括号匹配   │
├─────────┼──────────┼────────┼──────────┼────────────┤
│**CSL**  │ PSPACE   │ LBA    │ Type 1   │ 自然语言   │
│上下文相关│ 指数     │ 线性界 │ 上下文敏 │            │
├─────────┼──────────┼────────┼──────────┼────────────┤
│**RE**   │ 不保证   │ TM     │ Type 0   │ 通用计算   │
│递归可枚举│ 可能∞    │        │ 无限制   │ 停机问题   │
├─────────┼──────────┼────────┼──────────┼────────────┤
│**P**    │ poly(n)  │ DTM    │ -        │ 排序       │
│多项式   │ 可行     │        │          │ 最短路径   │
├─────────┼──────────┼────────┼──────────┼────────────┤
│**NP**   │ poly(n)  │ NTM    │ -        │ SAT        │
│非确定P  │ 验证可行 │        │          │ TSP        │
├─────────┼──────────┼────────┼──────────┼────────────┤
│**PSPACE**│ poly    │ TM     │ -        │ 博弈       │
│多项式空间│ 空间    │ poly   │          │ QBF        │
├─────────┼──────────┼────────┼──────────┼────────────┤
│**EXP**  │ 2^poly   │ TM     │ -        │ 国际象棋   │
│指数时间 │ 指数     │        │          │ (n×n棋盘)  │
├─────────┼──────────┼────────┼──────────┼────────────┤
│**BQP**  │ poly     │ QTM    │ -        │ 因数分解   │
│量子P    │ (量子)   │        │          │ (Shor)     │
└─────────┴──────────┴────────┴──────────┴────────────┘

包含关系:
Reg ⊂ CFL ⊂ CSL ⊂ RE
P ⊆ NP ⊆ PSPACE ⊆ EXP ⊆ RE
BQP ⊆ PSPACE

未解决:
P vs NP ❓
NP vs PSPACE ❓
BQP vs NP ❓
```

---

## 5. 学习路径决策树

### 5.1 按背景选择路径

```text
你的背景是？
    │
    ├─ 【数学/逻辑】
    │   │
    │   ├─ 强逻辑基础
    │   │   └─→ 路径A: 范畴论视角
    │   │        ├─ 00.2 Curry-Howard-Lambek
    │   │        ├─ 03.1 CCC
    │   │        ├─ 03.2 Topos
    │   │        ├─ 01.6 范畴论基础
    │   │        └─ 05.1 HoTT
    │   │
    │   └─ 重集合论
    │       └─→ 路径B: 集合论视角
    │            ├─ 01.5 ZF-ZFC
    │            ├─ 04.2 算术谱系
    │            ├─ 02.4 文法→集合论
    │            └─ 00.3 RE理论
    │
    ├─ 【计算机科学】
    │   │
    │   ├─ 喜欢函数式
    │   │   └─→ 路径C: Lambda演算视角
    │   │        ├─ 01.3 Lambda演算
    │   │        ├─ 00.4 不动点理论
    │   │        ├─ 02.2 TM→Lambda
    │   │        ├─ 06.4 类型系统
    │   │        └─ 01.7 依赖类型
    │   │
    │   ├─ 喜欢自动机
    │   │   └─→ 路径D: 图灵机视角
    │   │        ├─ 01.1 图灵机
    │   │        ├─ 04.5 停机问题
    │   │        ├─ 04.4 Rice定理
    │   │        ├─ 04.1 Chomsky层级
    │   │        └─ 00.1 Church-Turing
    │   │
    │   └─ 喜欢并发
    │       └─→ 路径E: Petri网视角
    │            ├─ 01.2 Petri网理论
    │            ├─ 02.1 Petri→TM
    │            ├─ 06.3 微服务
    │            └─ 06.2 区块链
    │
    ├─ 【工程师】
    │   │
    │   └─→ 路径F: 实践优先
    │        ├─ 快速导航_START_HERE
    │        ├─ 06_工程实践应用 (全部)
    │        ├─ 04.4 Rice定理 (限制理解)
    │        ├─ 06.4 类型系统 (选型指南)
    │        └─ 08_批判性分析
    │
    └─ 【哲学/认知】
        │
        └─→ 路径G: 批判性视角
             ├─ 08.3 争议性观点
             ├─ 08.2 未解决问题
             ├─ 00.1 Church-Turing (物理CTT)
             ├─ 05.1 HoTT (数学基础)
             └─ 08.1 理论局限
```

### 5.2 按目标选择深度

```text
你的目标？
    │
    ├─ 【快速了解RE核心】 (1-2周)
    │   └─→ 最小必读集
    │        ├─ 00.3 RE理论 (核心概念)
    │        ├─ 04.5 停机问题 (不可判定)
    │        ├─ 04.4 Rice定理 (实践限制)
    │        └─ 快速导航_START_HERE
    │
    ├─ 【理解计算等价性】 (1月)
    │   └─→ 等价性路线
    │        ├─ 00.1 Church-Turing
    │        ├─ 02_等价性证明 (选3篇)
    │        ├─ 00.2 Curry-Howard-Lambek
    │        └─ 00.4 不动点理论
    │
    ├─ 【掌握完整证明链】 (2-3月)
    │   └─→ 完整理论路线
    │        ├─ 01_形式系统详解 (全7篇)
    │        ├─ 02_等价性证明 (全6篇)
    │        ├─ 00_核心理论 (全5篇)
    │        └─ 04_复杂度与表达力 (全部)
    │
    ├─ 【深入研究RE理论】 (长期)
    │   └─→ 研究者路线
    │        ├─ 全部模块系统学习
    │        ├─ 08_批判性分析 (深度)
    │        ├─ 05_现代理论 (HoTT/Cubical)
    │        ├─ 07_权威资源对标
    │        └─ 09_形式化证明 (可选)
    │
    └─ 【工程实践应用】 (按需)
        └─→ 实践导向路线
             ├─ 06_工程实践 (全5篇)
             ├─ 04.4 Rice定理 (边界认知)
             ├─ 06.4 类型系统 (选型)
             └─ 08.1 理论局限 (现实认知)
```

---

## 6. 技术选型决策树

### 6.1 编程语言类型系统

```text
如何选择语言？
    │
    ├─ 系统编程/性能关键
    │   │
    │   ├─ 需要内存安全
    │   │   └─→ Rust ✅
    │   │        ├─ 所有权系统 (线性逻辑)
    │   │        ├─ 借用检查器
    │   │        ├─ 无GC
    │   │        └─ 文档: 06.4 类型系统
    │   │
    │   └─ 最大性能
    │       └─→ C/C++ ⚠️
    │            └─ 无类型安全保证
    │
    ├─ 函数式编程/形式化
    │   │
    │   ├─ 纯函数式
    │   │   └─→ Haskell ✅
    │   │        ├─ Hindley-Milner类型推导
    │   │        ├─ 惰性求值
    │   │        ├─ 强类型
    │   │        └─ 文档: 01.3 Lambda
    │   │
    │   └─ 验证/证明
    │       └─→ Coq/Lean ✅
    │            ├─ 依赖类型
    │            ├─ 全形式化
    │            └─ 文档: 01.7, 06.5
    │
    ├─ Web/通用开发
    │   │
    │   ├─ 需要类型安全
    │   │   └─→ TypeScript ⚠️
    │   │        ├─ 渐进类型
    │   │        ├─ 类型系统图灵完备
    │   │        │  (可能不终止)
    │   │        └─ 文档: 06.4
    │   │
    │   └─ 快速原型
    │       └─→ Python ⚠️
    │            └─ 动态类型，无编译时保证
    │
    ├─ 配置/DSL
    │   │
    │   └─→ Dhall ✅
    │        ├─ 总终止保证
    │        ├─ 强类型
    │        ├─ 非图灵完备(by design)
    │        └─ 文档: 06.4
    │
    └─ 决策因素
        │
        ├─ 可判定性需求
        │   ├─ 必须终止 → Dhall
        │   ├─ 希望终止 → Rust/Haskell
        │   └─ 无要求 → Python/JS
        │
        ├─ 表达力需求
        │   ├─ 最大表达力 → Python/无类型λ
        │   ├─ 平衡 → Rust/Haskell
        │   └─ 受限但安全 → Dhall
        │
        └─ 验证需求
            ├─ 完全形式化 → Coq/Lean
            ├─ 类型安全 → Rust/Haskell
            └─ 动态验证 → Python+测试
```

### 6.2 形式化工具选择

```text
形式化验证需求？
    │
    ├─ 【定理证明】
    │   │
    │   ├─ 数学形式化
    │   │   └─→ Lean 4 ✅
    │   │        ├─ Mathlib4 (10万+定理)
    │   │        ├─ 工业级性能
    │   │        ├─ 现代策略语言
    │   │        └─ 文档: 05_现代理论, 07.4
    │   │
    │   ├─ 程序验证
    │   │   └─→ Coq ✅
    │   │        ├─ CompCert (C编译器)
    │   │        ├─ 成熟生态
    │   │        ├─ CiC (依赖类型)
    │   │        └─ 文档: 06.5, 01.7
    │   │
    │   └─ HoTT研究
    │       └─→ Cubical Agda ✅
    │            ├─ 原生Cubical类型
    │            ├─ Univalence可计算
    │            └─ 文档: 05.2
    │
    ├─ 【模型检测】
    │   │
    │   ├─ 分布式协议
    │   │   └─→ TLA+ ✅
    │   │        ├─ Lamport设计
    │   │        ├─ 时序逻辑
    │   │        ├─ TLC检测器
    │   │        └─ 文档: 06.5
    │   │
    │   ├─ 并发系统
    │   │   └─→ SPIN ✅
    │   │        ├─ Promela语言
    │   │        ├─ LTL验证
    │   │        └─ 部分序约简
    │   │
    │   └─ 硬件验证
    │       └─→ NuSMV
    │            └─ 符号模型检测
    │
    ├─ 【智能合约】
    │   │
    │   ├─ 学术研究
    │   │   └─→ Coq + K Framework
    │   │        ├─ EVM形式语义
    │   │        └─ 完整性证明
    │   │
    │   ├─ 工业应用
    │   │   └─→ Certora ✅
    │   │        ├─ 自动化
    │   │        ├─ SMT后端
    │   │        ├─ Solidity专用
    │   │        └─ 文档: 06.2, 06.5
    │   │
    │   └─ 轻量检测
    │       └─→ Mythril/Slither
    │            ├─ 符号执行
    │            ├─ 启发式
    │            └─ 不完全
    │
    └─ 【决策因素】
        │
        ├─ 自动化程度
        │   ├─ 全自动 → 模型检测(有界)
        │   ├─ 交互式 → 定理证明(完全)
        │   └─ 启发式 → 符号执行
        │
        ├─ 保证程度
        │   ├─ 完全保证 → 定理证明
        │   ├─ 有界保证 → 模型检测
        │   └─ 最佳努力 → 启发式工具
        │
        ├─ 成本考虑
        │   ├─ 关键系统 → 完全形式化
        │   │  (航空、金融、核心区块链)
        │   ├─ 重要系统 → 部分形式化
        │   │  (企业应用)
        │   └─ 一般系统 → 类型+测试
        │      (大多数应用)
        │
        └─ Rice定理启示
            └─ 完美自动验证不可能
                → 接受权衡
                → 选择合适工具
                → 文档: 04.4, 06.5
```

---

## 🎯 使用本图谱

### 导航建议

**首次阅读**:

1. 从 `1.1 三层等价性架构` 建立整体认知
2. 看 `2.1 递归可枚举性分解` 理解核心概念
3. 用 `5.1 按背景选择路径` 找到适合自己的路线

**深度学习**:

1. 跟随 `3.1 等价性证明链` 完整学习
2. 参考 `3.2 定理依赖关系` 理解逻辑
3. 对照 `4.1 七系统全维对比` 横向理解

**实践应用**:

1. 使用 `6.1 编程语言选择` 指导技术选型
2. 参考 `6.2 形式化工具` 选择验证方法
3. 对照 `4.2 复杂度分层` 理解问题边界

### 与其他文档的关系

**本图谱** = 整体导航 + 结构化表征

**快速导航** = 入门引导
**研究路线图** = 任务规划
**知识图谱** = 概念关联 (本文档)
**各模块README** = 具体内容

---

**最后更新**: 2025-12-02
**性质**: 元文档，结构化知识
**推荐**: 打印或保存，作为学习地图
