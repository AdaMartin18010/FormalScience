# 初始代数与终结余代数

> **主题**: 归纳与余归纳的范畴论本质
> **创建日期**: 2025-12-02
> **难度**: ⭐⭐⭐⭐⭐
> **核心**: Lambek引理

---

## 📋 目录

- [初始代数与终结余代数](#初始代数与终结余代数)
  - [📋 目录](#-目录)
  - [1. F-代数](#1-f-代数)
    - [1.1 定义](#11-定义)
    - [1.2 F-代数态射](#12-f-代数态射)
  - [2. 初始代数](#2-初始代数)
    - [2.1 定义](#21-定义)
    - [2.2 例子: 自然数](#22-例子-自然数)
  - [3. Lambek引理](#3-lambek引理)
    - [3.1 定理陈述](#31-定理陈述)
    - [3.2 证明](#32-证明)
    - [3.3 深刻含义](#33-深刻含义)
  - [4. 归纳类型](#4-归纳类型)
    - [4.1 归纳类型的范畴论定义](#41-归纳类型的范畴论定义)
    - [4.2 递归函数 = fold](#42-递归函数--fold)
  - [5. 余归纳类型](#5-余归纳类型)
    - [5.1 终结余代数](#51-终结余代数)
    - [5.2 无限数据结构](#52-无限数据结构)
  - [6. 深刻洞察](#6-深刻洞察)
    - [μF vs νF](#μf-vs-νf)

---

## 1. F-代数

### 1.1 定义

**函子**: F: C → C

**F-代数**: 对 (A, α)，其中：

- A: 对象（载体 carrier）
- α: F(A) → A（结构态射 structure map）

**例子**: 自然数

```text
F(X) = 1 + X  (要么是零，要么是后继)

(ℕ, α): F(ℕ) → ℕ
α: 1 + ℕ → ℕ
α(inl(*)) = 0
α(inr(n)) = n + 1
```

### 1.2 F-代数态射

**定义**: f: (A, α) → (B, β) 是F-代数态射，如果：

```text
F(A) ─^F(f)→ F(B)
  │            │
  α│            │β
  ↓            ↓
  A ─────^f──→ B

commutes
```

---

## 2. 初始代数

### 2.1 定义

**(μF, in)** 是**初始F-代数**，如果：

对任意 F-代数 (A, α)，存在唯一态射 fold_α: μF → A 使得：

```text
F(μF) ─^F(fold)→ F(A)
   │               │
  in│               │α
   ↓               ↓
  μF ─────^fold──→ A
```

### 2.2 例子: 自然数

**F(X) = 1 + X**

**初始代数**: (ℕ, [zero, succ])

```text
in: 1 + ℕ → ℕ
in(inl(*)) = 0
in(inr(n)) = n+1
```

**fold (归约)**: 给定 (A, α)，fold: ℕ → A

```text
fold(0) = α(inl(*))  (零的情况)
fold(n+1) = α(inr(fold(n)))  (归纳步)
```

**例子**: 加法

```text
plus_m: ℕ → ℕ
plus_m = fold_{(ℕ, [m, succ])}

plus_m(0) = m
plus_m(n+1) = succ(plus_m(n)) = plus_m(n) + 1
```

---

## 3. Lambek引理

### 3.1 定理陈述

**定理3.1 (Lambek)**:

如果 (μF, in) 是初始F-代数，则：

```text
in: F(μF) ≅ μF  (同构!)
```

**含义**: 初始代数与其"展开"**同构**

### 3.2 证明

**构造逆**: out = fold_{(F(μF), id)} : μF → F(μF)

**验证** in ∘ out = id:

```text
F(μF) ─^F(out)→ F(F(μF))
   │               │
  in│               │F(in)
   ↓               ↓
  μF ─────^out──→ F(μF)
   ↓               ↓
   in ∘ out       F(in) ∘ F(out) = F(in ∘ out)

由初始性: in ∘ out = id  □
```

### 3.3 深刻含义

**递归类型 = 不动点**:

```text
List A = 1 + (A × List A)
       = F(List A)  其中 F(X) = 1 + A×X
```

**Lambek**: List A ≅ F(List A)

- 列表同构于其"展开"

---

## 4. 归纳类型

### 4.1 归纳类型的范畴论定义

**归纳类型** = 初始代数 μF

**例子**:

| 类型 | 函子F | 初始代数 |
|------|-------|----------|
| ℕ | 1 + X | (ℕ, [0, succ]) |
| List A | 1 + A×X | ([A], [[], cons]) |
| Tree A | A + X×X | (Tree, [leaf, node]) |

### 4.2 递归函数 = fold

**原理**: 归纳类型上的函数 = F-代数态射

```haskell
-- Haskell的foldr就是范畴论的fold!
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f z = fold_{(b, [z, f])}
```

---

## 5. 余归纳类型

### 5.1 终结余代数

**对偶**: (νF, out) 是**终结F-余代数**

对任意余代数 (A, α: A → F(A))，存在唯一 unfold: A → νF

**Lambek对偶**: out: νF ≅ F(νF)

### 5.2 无限数据结构

**Stream = 余归纳类型**:

```text
F(X) = A × X  (总有头和尾)
νF = Stream A = A × A × A × ... (无限流)
```

**unfold (对偶fold)**:

```haskell
unfold :: (b -> (a, b)) -> b -> Stream a
unfold f seed = out(seed) : unfold f (snd (f seed))
  where out = fst ∘ f
```

---

## 6. 深刻洞察

### μF vs νF

| | 归纳μF | 余归纳νF |
|---|-------|---------|
| 构造 | 有限递归构造 | 可能无限 |
| 原理 | 从内向外 | 从外向内 |
| 函数 | fold (消费) | unfold (生成) |
| 例子 | 有限列表 | 无限流 |

**统一**: 都是不动点！

- μF = 最小不动点
- νF = 最大不动点

---

**最后更新**: 2025-12-02
**状态**: 初稿完成
