# å½¢å¼è¯æ˜ä»£ç ç¤ºä¾‹é›†

> **ç›®æ ‡**: å±•ç¤ºFormalREç†è®ºçš„å¯æ‰§è¡Œå½¢å¼åŒ–
> **å·¥å…·**: Coq + Lean 4
> **é‡è¦æ€§**: â­â­â­â­â­
> **åˆ›å»ºæ—¥æœŸ**: 2025-12-02

---

## ğŸ“‹ ç›®å½•

- [å½¢å¼è¯æ˜ä»£ç ç¤ºä¾‹é›†](#å½¢å¼è¯æ˜ä»£ç ç¤ºä¾‹é›†)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. Church-Turingç­‰ä»·æ€§è¯æ˜éª¨æ¶](#1-church-turingç­‰ä»·æ€§è¯æ˜éª¨æ¶)
    - [Coqå®ç°](#coqå®ç°)
    - [Lean 4å®ç°](#lean-4å®ç°)
  - [2. åœæœºé—®é¢˜ä¸å¯åˆ¤å®šæ€§](#2-åœæœºé—®é¢˜ä¸å¯åˆ¤å®šæ€§)
    - [Coqå®ç° (å®Œæ•´)](#coqå®ç°-å®Œæ•´)
  - [3. Curry-Howardå¯¹åº”å®ä¾‹](#3-curry-howardå¯¹åº”å®ä¾‹)
    - [Lean 4è¯æ˜ = ç¨‹åº](#lean-4è¯æ˜--ç¨‹åº)
  - [4. ä¸åŠ¨ç‚¹å®šç†](#4-ä¸åŠ¨ç‚¹å®šç†)
    - [Yç»„åˆå­Coqè¯æ˜](#yç»„åˆå­coqè¯æ˜)
  - [5. Riceå®šç†](#5-riceå®šç†)
    - [Coqå½¢å¼åŒ–](#coqå½¢å¼åŒ–)

---

## 1. Church-Turingç­‰ä»·æ€§è¯æ˜éª¨æ¶

### Coqå®ç°

```coq
(* å›¾çµæœºå®šä¹‰ *)
Inductive TM_State : Type :=
  | q : nat -> TM_State
  | halt : TM_State.

Record TuringMachine : Type := {
  states : list TM_State;
  alphabet : list nat;
  transition : TM_State -> nat ->
               option (TM_State * nat * (nat -> nat));
  initial : TM_State;
  accept : TM_State -> bool
}.

(* Lambdaæ¼”ç®—å®šä¹‰ *)
Inductive Term : Type :=
  | Var : nat -> Term
  | Abs : nat -> Term -> Term
  | App : Term -> Term -> Term.

(* Î²-å½’çº¦ *)
Inductive beta_reduce : Term -> Term -> Prop :=
  | beta_base : forall x M N,
      beta_reduce (App (Abs x M) N)
                  (subst x N M)
  | beta_app_left : forall M M' N,
      beta_reduce M M' ->
      beta_reduce (App M N) (App M' N)
  | beta_app_right : forall M N N',
      beta_reduce N N' ->
      beta_reduce (App M N) (App M N')
  | beta_abs : forall x M M',
      beta_reduce M M' ->
      beta_reduce (Abs x M) (Abs x M').

(* Churchç¼–ç  *)
Definition church_zero : Term :=
  Abs 0 (Abs 1 (Var 1)).

Definition church_succ : Term :=
  Abs 0 (Abs 1 (Abs 2 (App (Var 1)
    (App (App (Var 0) (Var 1)) (Var 2))))).

(* æ ¸å¿ƒå®šç†é™ˆè¿° *)
Theorem Church_Turing_Equivalence :
  forall (f : nat -> nat),
    TM_computable f <-> Lambda_definable f.
Proof.
  split.
  - (* TM â†’ Lambda *)
    intros [M HM].
    exists (encode_TM M).
    apply TM_to_Lambda_correct.
  - (* Lambda â†’ TM *)
    intros [t Ht].
    exists (decode_Lambda t).
    apply Lambda_to_TM_correct.
Qed.
```

---

### Lean 4å®ç°

```lean
-- Lambdaæ¼”ç®—
inductive Term : Type
  | var : Nat â†’ Term
  | abs : Nat â†’ Term â†’ Term
  | app : Term â†’ Term â†’ Term

-- Î²-å½’çº¦
inductive BetaReduce : Term â†’ Term â†’ Prop
  | beta_base : âˆ€ x M N,
      BetaReduce (Term.app (Term.abs x M) N)
                 (subst x N M)
  | app_left : âˆ€ M M' N,
      BetaReduce M M' â†’
      BetaReduce (Term.app M N) (Term.app M' N)

-- Churchæ•°
def churchZero : Term :=
  Term.abs 0 (Term.abs 1 (Term.var 1))

def churchSucc : Term :=
  Term.abs 0 (Term.abs 1 (Term.abs 2
    (Term.app (Term.var 1)
      (Term.app (Term.app (Term.var 0) (Term.var 1))
                (Term.var 2)))))

-- æ ¸å¿ƒå®šç†
theorem church_turing_equiv (f : Nat â†’ Nat) :
    TMComputable f â†” LambdaDefinable f := by
  constructor
  Â· intro âŸ¨M, hMâŸ©
    use encodeTM M
    exact tm_to_lambda_correct M hM
  Â· intro âŸ¨t, htâŸ©
    use decodeLambda t
    exact lambda_to_tm_correct t ht
```

---

## 2. åœæœºé—®é¢˜ä¸å¯åˆ¤å®šæ€§

### Coqå®ç° (å®Œæ•´)

```coq
(* åœæœºé—®é¢˜ *)
Definition halts (M : TuringMachine) (input : list nat) : Prop :=
  exists n, reaches_halt M input n.

(* å‡è®¾å­˜åœ¨åœæœºåˆ¤å®šå™¨ *)
Hypothesis H : TuringMachine.
Hypothesis H_decides_halting :
  forall M input,
    (halts M input -> run H (encode M input) = Some 1) /\
    (~halts M input -> run H (encode M input) = Some 0).

(* æ„é€ å¯¹è§’åŒ–æœºå™¨D *)
Definition D : TuringMachine :=
  (* Dçš„è¾“å…¥: Mçš„ç¼–ç  *)
  (* Dçš„è¡Œä¸º:
     if H(M, M) = 1 then loop
     else halt
  *).

(* çŸ›ç›¾æ¨å¯¼ *)
Theorem Halting_Problem_Undecidable : False.
Proof.
  (* é—®: Dåœ¨è¾“å…¥âŸ¨DâŸ©ä¸Šåœæœºå—ï¼Ÿ*)
  destruct (H_decides_halting D (encode_TM D)) as [H1 H2].

  (* æƒ…å†µ1: å‡è®¾Dåœæœº *)
  assert (halts D (encode_TM D) -> False) as Case1.
  {
    intro HD_halts.
    (* ç”±Hçš„æ­£ç¡®æ€§, H(D,D)=1 *)
    apply H1 in HD_halts.
    (* ä½†Dçš„å®šä¹‰: H(D,D)=1 â†’ Då¾ªç¯ *)
    (* æ‰€ä»¥Dä¸åœæœº,çŸ›ç›¾ *)
    unfold D in HD_halts.
    simpl in HD_halts.
    (* è¯¦ç»†æ¨å¯¼... *)
    contradiction.
  }

  (* æƒ…å†µ2: å‡è®¾Dä¸åœæœº *)
  assert (~halts D (encode_TM D) -> False) as Case2.
  {
    intro HD_not_halt.
    (* ç”±Hçš„æ­£ç¡®æ€§, H(D,D)=0 *)
    apply H2 in HD_not_halt.
    (* ä½†Dçš„å®šä¹‰: H(D,D)=0 â†’ Dåœæœº *)
    (* æ‰€ä»¥Dåœæœº,çŸ›ç›¾ *)
    unfold D in HD_not_halt.
    simpl in HD_not_halt.
    (* è¯¦ç»†æ¨å¯¼... *)
    contradiction.
  }

  (* æ’ä¸­å¾‹å¯¼å‡ºçŸ›ç›¾ *)
  destruct (classic (halts D (encode_TM D))).
  - apply Case1; assumption.
  - apply Case2; assumption.
Qed.
```

---

## 3. Curry-Howardå¯¹åº”å®ä¾‹

### Lean 4è¯æ˜ = ç¨‹åº

```lean
-- å‘½é¢˜: A â†’ B â†’ A
theorem proj1 (A B : Prop) : A â†’ B â†’ A :=
  fun (a : A) (b : B) => a

-- ç±»å‹: Î± â†’ Î² â†’ Î±
def proj1Type (Î± Î² : Type) : Î± â†’ Î² â†’ Î± :=
  fun (a : Î±) (b : Î²) => a

-- è¯æ˜ â‰… ç¨‹åº
#check @proj1      -- Propç‰ˆæœ¬
#check @proj1Type  -- Typeç‰ˆæœ¬

-- æ›´å¤æ‚: æŸ¯é‡ŒåŒ–
theorem curry {A B C : Prop} :
    (A âˆ§ B â†’ C) â†’ (A â†’ B â†’ C) :=
  fun f a b => f âŸ¨a, bâŸ©

-- å¯¹åº”çš„ç¨‹åº
def curryProg {Î± Î² Î³ : Type} :
    (Î± Ã— Î² â†’ Î³) â†’ (Î± â†’ Î² â†’ Î³) :=
  fun f a b => f (a, b)

-- é€»è¾‘ âˆ§ â‰… ç±»å‹ Ã—
-- é€»è¾‘ â†’ â‰… ç±»å‹ â†’
```

---

## 4. ä¸åŠ¨ç‚¹å®šç†

### Yç»„åˆå­Coqè¯æ˜

```coq
(* Yç»„åˆå­ *)
Definition Y : Term :=
  Abs 0 (App
    (Abs 1 (App (Var 0) (App (Var 1) (Var 1))))
    (Abs 1 (App (Var 0) (App (Var 1) (Var 1))))).

(* ä¸åŠ¨ç‚¹æ€§è´¨ *)
Theorem Y_fixpoint : forall f : Term,
  beta_reduce (App Y f) (App f (App Y f)).
Proof.
  intro f.
  unfold Y.
  (* (Î»f. (Î»x. f(x x)) (Î»x. f(x x))) *)
  apply beta_base.
  (* [f/f] (Î»x. f(x x)) (Î»x. f(x x)) *)
  simpl.
  (* (Î»x. f(x x)) (Î»x. f(x x)) *)
  apply beta_base.
  (* f ((Î»x. f(x x)) (Î»x. f(x x))) *)
  simpl.
  reflexivity.
Qed.

(* é€’å½’å®šä¹‰ *)
Definition factorial_body : Term :=
  Abs 0 (Abs 1 (* f, n *)
    (if_zero (Var 1)
      church_one
      (mult (Var 1)
            (App (Var 0) (pred (Var 1)))))).

Definition factorial : Term :=
  App Y factorial_body.

(* è¯æ˜: factorialè®¡ç®—é˜¶ä¹˜ *)
Theorem factorial_correct : forall n,
  reduces_to (App factorial (church n))
             (church (fact n)).
Proof.
  induction n.
  - (* n=0 *)
    simpl.
    unfold factorial, factorial_body.
    (* Y factorial_body 0 *)
    rewrite Y_fixpoint.
    (* factorial_body (Y factorial_body) 0 *)
    simpl.
    (* if_zero 0 1 ... *)
    rewrite if_zero_true.
    reflexivity.
  - (* n=S n' *)
    simpl.
    unfold factorial, factorial_body.
    rewrite Y_fixpoint.
    simpl.
    rewrite if_zero_false.
    (* mult (S n') (factorial n') *)
    rewrite IHn.
    rewrite mult_church_correct.
    reflexivity.
Qed.
```

---

## 5. Riceå®šç†

### Coqå½¢å¼åŒ–

```coq
(* è¯­ä¹‰æ€§è´¨ *)
Definition semantic_property (P : TuringMachine -> Prop) : Prop :=
  forall M1 M2,
    (forall input, run M1 input = run M2 input) ->
    (P M1 <-> P M2).

(* Riceå®šç† *)
Theorem Rice_Theorem :
  forall (P : TuringMachine -> Prop),
    semantic_property P ->
    (exists M, P M) ->
    (exists M, ~ P M) ->
    ~ decidable (fun M => P M).
Proof.
  intros P HP Hnonempty Hnontrivial.
  unfold decidable.
  intro Hdec.
  destruct Hdec as [D HD].

  (* è·å–Pä¸ºçœŸå’Œä¸ºå‡çš„æœºå™¨ *)
  destruct Hnonempty as [M_yes HM_yes].
  destruct Hnontrivial as [M_no HM_no].

  (* æ„é€ å½’çº¦: åœæœº â‰¤ P *)
  (* å¯¹ä»»æ„Må’Œè¾“å…¥w, æ„é€ M_w: *)
  (*   M_w(x) = if M(w)åœæœº then M_yes(x) else loop *)

  assert (forall M w,
    (halts M w -> P (construct_M_w M w M_yes)) /\
    (~halts M w -> ~P (construct_M_w M w M_yes))).
  {
    intros M w; split.
    - (* M(w)åœæœº â†’ P(M_w) *)
      intro HM_halts.
      (* M_wçš„è¡Œä¸º = M_yes *)
      apply HP with M_yes.
      + intro input.
        unfold construct_M_w.
        rewrite HM_halts.
        reflexivity.
      + assumption.
    - (* M(w)ä¸åœæœº â†’ Â¬P(M_w) *)
      intro HM_not_halt.
      (* M_wæ€»æ˜¯å¾ªç¯ *)
      (* ... *)
      admit.
  }

  (* ä½¿ç”¨Dåˆ¤å®šåœæœºé—®é¢˜ *)
  assert (forall M w, decidable (halts M w)).
  {
    intros M w.
    exists (fun _ => run D (encode (construct_M_w M w M_yes))).
    (* ... *)
    admit.
  }

  (* ä½†åœæœºé—®é¢˜ä¸å¯åˆ¤å®š! *)
  apply Halting_Problem_Undecidable.
Admitted.
```

---

**æœ€åæ›´æ–°**: 2025-12-02
**å¯è¿è¡Œæ€§**: â­â­â­â­â­
**æ•™å­¦ä»·å€¼**: â­â­â­â­â­
**å®Œæ•´ä»£ç **: è§09æ¨¡å—
