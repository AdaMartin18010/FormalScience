# 图灵机：计算的基础模型

> **主题**: Alan Turing的通用计算模型
> **创建日期**: 2025-12-02
> **难度**: ⭐⭐⭐
> **前置知识**: 有限自动机、基本离散数学

---

## 📋 目录

- [图灵机：计算的基础模型](#图灵机计算的基础模型)
  - [📋 目录](#-目录)
  - [1. 图灵机的定义](#1-图灵机的定义)
    - [1.1 经典定义](#11-经典定义)
    - [1.2 配置与计算](#12-配置与计算)
    - [1.3 识别的语言](#13-识别的语言)
  - [2. 图灵机的变体](#2-图灵机的变体)
    - [2.1 多带图灵机](#21-多带图灵机)
    - [2.2 非确定性图灵机 (NTM)](#22-非确定性图灵机-ntm)
    - [2.3 双向无限带图灵机](#23-双向无限带图灵机)
    - [2.4 多维图灵机](#24-多维图灵机)
    - [2.5 Oracle图灵机](#25-oracle图灵机)
  - [3. 通用图灵机](#3-通用图灵机)
    - [3.1 通用性的概念](#31-通用性的概念)
    - [3.2 编码方案](#32-编码方案)
    - [3.3 通用图灵机的构造](#33-通用图灵机的构造)
  - [4. 停机问题](#4-停机问题)
    - [4.1 精确定义](#41-精确定义)
    - [4.2 不可判定性证明](#42-不可判定性证明)
    - [4.3 停机问题是RE的](#43-停机问题是re的)
  - [5. 图灵可计算函数](#5-图灵可计算函数)
    - [5.1 定义](#51-定义)
    - [5.2 Church-Turing论题的含义](#52-church-turing论题的含义)
    - [5.3 计算复杂度](#53-计算复杂度)
  - [6. 现代应用](#6-现代应用)
    - [6.1 虚拟机与解释器](#61-虚拟机与解释器)
    - [6.2 云函数 (AWS Lambda)](#62-云函数-aws-lambda)
    - [6.3 自动驾驶决策](#63-自动驾驶决策)
  - [7. 习题](#7-习题)
    - [习题1](#习题1)
    - [习题2](#习题2)
    - [习题3](#习题3)
  - [8. 参考资源](#8-参考资源)
    - [经典论文](#经典论文)
    - [教材](#教材)
    - [在线工具](#在线工具)


---

## 1. 图灵机的定义

### 1.1 经典定义

**定义1.1 (确定性单带图灵机)**:

一个图灵机 M 是一个七元组：

```text
M = (Q, Σ, Γ, δ, q₀, q_accept, q_reject)
```

其中：

- **Q**: 有限状态集
- **Σ**: 输入字母表（Σ ⊂ Γ）
- **Γ**: 磁带字母表（包含空白符号 ␣）
- **δ**: Q × Γ → Q × Γ × {L, R} — 转移函数
- **q₀ ∈ Q**: 初始状态
- **q_accept ∈ Q**: 接受状态
- **q_reject ∈ Q**: 拒绝状态（q_accept ≠ q_reject）

### 1.2 配置与计算

**配置 (Configuration)**:

```text
C = αqβ
```

表示：

- 磁带内容: α···β
- 读写头位置: 在 β 的第一个符号
- 当前状态: q

**一步转移**: C ⊢ C'

**例子**: 转移 δ(q₁, a) = (q₂, b, R)

```text
uaq₁av  ⊢  ubq₂v
```

**接受**: C₀ ⊢* q_accept···

**拒绝**: C₀ ⊢* q_reject··· 或 永不停机

### 1.3 识别的语言

**定义1.2**: 图灵机 M **识别**语言 L，如果：

```text
∀w ∈ Σ*. w ∈ L  ⟺  M 接受 w
```

**定义1.3**: 图灵机 M **判定**语言 L，如果：

- M 识别 L
- M 在所有输入上**都停机**

**关键区别**:

- **识别** → 递归可枚举 (RE)
- **判定** → 递归 (Recursive)

---

## 2. 图灵机的变体

### 2.1 多带图灵机

**定义**: k条磁带，k个独立读写头

**转移函数**:

```text
δ: Q × Γᵏ → Q × Γᵏ × {L,R,S}ᵏ
```

**定理2.1**: k带图灵机 ≡ 单带图灵机（计算能力）

**证明思路**: 用单带模拟k带

- 磁带格式: #a₁#a₂#···#aₖ#
- 状态编码读写头位置

**复杂度差异**: 多带可以**多项式**加速

### 2.2 非确定性图灵机 (NTM)

**转移函数**:

```text
δ: Q × Γ → P(Q × Γ × {L,R})
```

**接受**: 存在一条接受的计算路径

**定理2.2**: NTM ≡ DTM（确定性图灵机）

**证明**: DTM可以枚举NTM的所有计算路径（广度优先搜索）

**复杂度**: NP vs P 的问题！

### 2.3 双向无限带图灵机

**磁带**: ···␣␣␣ (−∞) ··· a b c ··· (+∞) ␣␣␣···

**定理2.3**: 双向无限带 ≡ 单向无限带

**技巧**: 将磁带折叠

```text
单向:  0  1  2  3  4  5  ...
       ↓  ↓  ↓  ↓  ↓  ↓
双向:  0 -1  1 -2  2 -3  ...
```

### 2.4 多维图灵机

**二维磁带**: 无限网格

**定理2.4**: 二维图灵机 ≡ 一维图灵机

**Cantor配对**: (x, y) ↦ 单个自然数

### 2.5 Oracle图灵机

**定义**: 图灵机 + 神谕（oracle）

**神谕**: 可以在O(1)时间内回答某个特定问题

**例子**: M^K = 带停机问题神谕的图灵机

**算术谱系**:

```text
Δ₀ ⊂ Σ₁ ⊂ Δ₁^K ⊂ Σ₂ ⊂ ...
```

---

## 3. 通用图灵机

### 3.1 通用性的概念

**定理3.1 (Turing, 1936)**: 存在**通用图灵机** U，使得：

```text
U(⟨M⟩, w) = M(w)
```

其中 ⟨M⟩ 是 M 的编码（字符串形式）

**意义**:

- **可编程性**: 程序即数据
- **存储程序**: 现代计算机的基础
- **自指**: 可以输入自己的代码

### 3.2 编码方案

**编码图灵机** M = (Q, Σ, Γ, δ, q₀, q_a, q_r):

**方法1 (Gödel numbering)**:

```text
Q = {q₀, q₁, ..., qₙ}
Γ = {γ₀, γ₁, ..., γₘ}
δ(qᵢ, γⱼ) = (qₖ, γₗ, D) → 编码为 0ⁱ10ʲ10ᵏ10ˡ10^d
```

**方法2 (Binary encoding)**:

- 状态用二进制: q₅ → 101
- 转移表直接序列化

### 3.3 通用图灵机的构造

**U 的磁带布局**:

```text
| ⟨M⟩ | # | w | # | 工作区 |
```

**U 的算法**:

1. 读取当前状态（从工作区）
2. 读取当前符号（从w的模拟位置）
3. 查找⟨M⟩中对应的转移
4. 更新工作区状态
5. 模拟移动读写头
6. 重复

**定理3.2**: U 可以用确定性单带图灵机实现

---

## 4. 停机问题

### 4.1 精确定义

**停机问题集**:

```text
K = {⟨M, w⟩ | M 是图灵机, M 在输入 w 上停机}
```

**对角化问题**:

```text
K₀ = {⟨M⟩ | M 在输入 ⟨M⟩ 上停机}
```

### 4.2 不可判定性证明

**定理4.1 (Turing)**: K 和 K₀ 都不可判定

**证明 (对角化)**:

```text
假设存在判定器 H:
  H(⟨M⟩, w) = {
    接受, 如果 M 在 w 上停机
    拒绝, 如果 M 在 w 上不停机
  }

构造 D:
  D(⟨M⟩) = {
    循环, 如果 H(⟨M⟩, ⟨M⟩) 接受
    停机, 如果 H(⟨M⟩, ⟨M⟩) 拒绝
  }

矛盾:
  D(⟨D⟩) 停机 ⟺ H(⟨D⟩, ⟨D⟩) 拒绝
              ⟺ D(⟨D⟩) 不停机  ❌

∴ H 不存在  □
```

**现代解释**: 这是**自指悖论**的计算版本

- Russell悖论: {x | x ∉ x}
- 停机问题: D(⟨D⟩)

### 4.3 停机问题是RE的

**定理4.2**: K 是递归可枚举的

**证明**: 通用图灵机 U 识别 K

```text
U(⟨M⟩, w) = 模拟 M(w)
  如果 M 停机 → U 停机并接受
  如果 M 不停机 → U 不停机
```

**但** K̄ 不是RE！（对角化）

---

## 5. 图灵可计算函数

### 5.1 定义

**定义5.1**: 函数 f: ℕᵏ → ℕ 是**图灵可计算的**，如果存在图灵机 M：

```text
M(bin(n₁), ..., bin(nₖ)) = bin(f(n₁, ..., nₖ))
```

且 M 在所有输入上停机。

**部分函数**: 如果 M 可能不停机，f 是**部分可计算**的

### 5.2 Church-Turing论题的含义

**CT论题**: 直觉上可计算的 = 图灵可计算的

**经验证据**:

1. 所有提出的计算模型都等价于图灵机
2. 80年来无反例
3. 量子计算也不超越（虽然更快）

### 5.3 计算复杂度

**时间复杂度**: TIME(f(n)) = 可在 f(n) 步内判定的语言类

**空间复杂度**: SPACE(f(n)) = 可用 f(n) 格子判定的语言类

**复杂度类**:

- P = ⋃ₖ TIME(nᵏ)
- NP = NTM 的多项式时间
- PSPACE = ⋃ₖ SPACE(nᵏ)

---

## 6. 现代应用

### 6.1 虚拟机与解释器

**现代计算机 = 通用图灵机**:

- CPU = 状态机
- RAM = 无限磁带的近似
- 程序 = 图灵机编码

**JVM, Python解释器**:

- 本质上是通用图灵机
- 执行字节码 = 模拟另一个图灵机

### 6.2 云函数 (AWS Lambda)

**映射**:

- Lambda函数代码 = 图灵机 ⟨M⟩
- 输入事件 = 输入字符串 w
- 执行 = 模拟 M(w)
- 超时限制 = 承认停机问题不可判定

### 6.3 自动驾驶决策

**状态机视角**:

```text
感知输入 → [状态转移] → 控制输出
   (w)    →    (δ)     →   (动作)
```

**停机问题的现实版**:

- "汽车会不会陷入决策循环？" → 不可判定
- 实践: 超时 + 安全默认行为

---

## 7. 习题

### 习题1

设计一个图灵机识别语言 {0ⁿ1ⁿ | n ≥ 0}。

### 习题2

证明: 2带图灵机可以在 O(n) 时间内判定 {ww | w ∈ {0,1}*}，而单带需要 O(n²)。

### 习题3

编码一个简单的图灵机（如识别 {0*}）为字符串。

---

## 8. 参考资源

### 经典论文

1. **Turing, A. (1936)**. "On Computable Numbers"

### 教材

1. **Sipser, M.** - _Introduction to the Theory of Computation_, Ch. 3-5
2. **Hopcroft & Ullman** - _Introduction to Automata Theory_, Ch. 8-9

### 在线工具

- [Turing Machine Simulator](http://morphett.info/turing/turing.html)

---

**最后更新**: 2025-12-02
**状态**: 初稿完成
