# 编译器理论与递归深度专题

> **目标**: 深度分析编译器设计的递归理论基础
> **覆盖**: 词法/语法/语义/优化/代码生成/JIT
> **重要性**: ⭐⭐⭐⭐⭐
> **创建日期**: 2025-12-02

---

## 📋 目录

- [编译器理论与递归深度专题](#编译器理论与递归深度专题)
  - [📋 目录](#-目录)
  - [1. 词法分析的递归自动机](#1-词法分析的递归自动机)
    - [正则表达式到DFA](#正则表达式到dfa)
    - [词法分析器生成决策树](#词法分析器生成决策树)
  - [2. 语法分析的递归下降](#2-语法分析的递归下降)
    - [递归下降解析](#递归下降解析)
    - [解析技术对比](#解析技术对比)
  - [5. 优化的不动点算法](#5-优化的不动点算法)
    - [数据流分析](#数据流分析)
    - [优化递归模式](#优化递归模式)
    - [优化等级对比](#优化等级对比)
  - [7. JIT编译的复杂度权衡](#7-jit编译的复杂度权衡)
    - [JIT vs AOT对比](#jit-vs-aot对比)
    - [JIT优化决策树](#jit优化决策树)
    - [V8 (Chrome JS) JIT架构](#v8-chrome-js-jit架构)

---

## 1. 词法分析的递归自动机

### 正则表达式到DFA

```text
编译器前端:
源代码 → 词法分析 → Token流

正则表达式:
r ::= ε | a | r₁r₂ | r₁|r₂ | r*

NFA构造 (Thompson 1968):
递归构造规则:
- Base: ε, a
- Concat: NFA(r₁r₂) = NFA(r₁) · NFA(r₂)
- Union: NFA(r₁|r₂) = NFA(r₁) ∪ NFA(r₂)
- Star: NFA(r*) = (NFA(r))*

DFA转换 (子集构造):
States(DFA) = P(States(NFA))
→ 指数爆炸 ⚠️

复杂度:
- NFA: O(|r|)构造, O(nm)识别
- DFA: O(2^n)构造, O(m)识别
- 权衡: 编译时 vs 运行时
```

---

### 词法分析器生成决策树

```text
生成词法分析器
    |
    ├─ 手写还是生成？
    │   ├─ 手写 (C风格)
    │   │   ├─ 优势: 性能✓, 控制精确
    │   │   └─ 劣势: 易错, 难维护
    │   │
    │   └─ 生成 (Flex/Lex)
    │       ├─ 优势: 声明式, 自动化
    │       └─ 劣势: 性能略低
    │
    ├─ NFA还是DFA？
    │   ├─ NFA → 简洁
    │   └─ DFA → 快速✓
    │
    └─ 处理歧义？
        ├─ 最长匹配
        ├─ 优先级规则
        └─ 回溯 (慢⚠️)

实践:
✓ 生成DFA (Flex等)
✓ 手工优化关键路径
```

---

## 2. 语法分析的递归下降

### 递归下降解析

```text
文法:
E → E + T | T
T → T * F | F
F → (E) | num

消除左递归:
E → T E'
E' → + T E' | ε
T → F T'
T' → * F T' | ε

递归下降代码:
def parse_E():
  parse_T()
  parse_E_prime()

def parse_E_prime():
  if token == '+':
    match('+')
    parse_T()
    parse_E_prime()  # 递归!
  # else: ε

递归性质:
✓ 文法 = 递归定义
✓ 解析器 = 递归函数
✓ 调用栈 = 下推栈
```

---

### 解析技术对比

| 技术 | 复杂度 | 表达力 | 易实现 | 错误恢复 | 应用 |
|------|--------|--------|--------|---------|------|
| **递归下降** | O(n) | LL(k) | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 手写编译器 |
| **LL(1)** | O(n) | LL(1) | ⭐⭐⭐⭐ | ⭐⭐⭐ | ANTLR |
| **LR(1)** | O(n) | LR(1) ⊃ LL | ⭐⭐ | ⭐⭐ | Yacc/Bison |
| **GLR** | O(n³) | 任意CFG | ⭐ | ⭐⭐⭐⭐ | 歧义文法 |
| **Earley** | O(n³) | 任意CFG | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | NLP |
| **PEG** | O(n) | PEG | ⭐⭐⭐⭐ | ⭐⭐⭐ | 现代工具 |

**递归理论**:

- LL/LR ⊂ CFG ⊂ Type 1 ⊂ RE
- 实践选择LL/LR (O(n))
- 递归下降最直观

---

## 5. 优化的不动点算法

### 数据流分析

```text
数据流方程:
Out[B] = Gen[B] ∪ (In[B] - Kill[B])
In[B] = ∪_{P是B前驱} Out[P]

递归依赖!

解法: 不动点迭代
1. 初始化: Out[B] = ∅
2. 迭代: 计算新Out[B]
3. 直到: 不动点 (Out[B]不变)

终止性:
✓ 半格 + 单调 → 必终止
✓ 最多2^n迭代
✓ 实践中快速收敛 (< 10轮)

递归理论:
✓ 不动点 = 递归定义的最小解
✓ Tarski不动点定理应用
```

---

### 优化递归模式

```text
编译器优化 = 多轮不动点

Phase 1: 局部优化
  ├─ 常量折叠
  ├─ 死代码消除
  └─ 代数简化

Phase 2: 全局优化
  ├─ 公共子表达式消除 (CSE)
  ├─ 循环不变式外提
  └─ 函数内联

Phase 3: 再次局部
  └─ 新机会涌现

迭代直到不动点:
Code₀ → Opt(Code₀) → Code₁ → ... → Codeₙ
where Opt(Codeₙ) = Codeₙ

递归性质:
✓ 优化 = 递归函数
✓ 不动点 = 最优代码
✓ 必终止 (单调下降)
```

---

### 优化等级对比

| 等级 | 优化 | 编译时间 | 代码质量 | 递归轮数 |
|------|------|---------|---------|---------|
| **-O0** | 无 | 快✓ | 差 | 0 |
| **-O1** | 基础 | 快 | 可用 | 2-3 |
| **-O2** | 标准 | 中 | 好✓ | 5-10 |
| **-O3** | 激进 | 慢 | 很好 | 15-20 |
| **-Os** | 大小 | 中 | 小✓ | 5-10 |

---

## 7. JIT编译的复杂度权衡

### JIT vs AOT对比

```text
                编译策略
                    |
        ┌───────────┼───────────┐
        |           |           |
      解释        JIT         AOT
      (慢)        (平衡)      (快)
        |           |           |
        ↓           ↓           ↓
    启动快✓     启动中      启动慢
    运行慢      运行快✓     运行最快✓
    无优化      热点优化    全优化
        |           |           |
    Python     JavaScript   Rust
    Ruby         JVM        C++
```

---

### JIT优化决策树

```text
JIT编译决策
    |
    ├─ 函数热吗 (执行频繁)?
    │   ├─ 是 → 编译+优化
    │   │   ├─ Tier 1: 快速编译 (模板)
    │   │   └─ Tier 2: 激进优化 (OSR)
    │   │
    │   └─ 否 → 解释执行
    │       └─ 节省编译时间
    │
    ├─ 类型稳定吗？
    │   ├─ 是 → 单态化 (monomorphize)
    │   │   └─ 内联+特化
    │   │
    │   └─ 否 → 保守编译
    │       └─ 保留类型检查
    │
    └─ 去优化？
        ├─ 类型改变 → 回退解释
        └─ 假设失效 → 重新编译

递归性质:
✓ 递归分层编译
✓ 递归优化提升
✗ 不保证停机 (可能无限重编)
```

---

### V8 (Chrome JS) JIT架构

```text
V8分层编译:

Ignition (解释器)
  ↓ 热点检测
Sparkplug (快速JIT)
  ↓ 更热
TurboFan (优化JIT)
  ↓ 类型变化
去优化 → Ignition

递归过程:
Code → Interpret → Profile → JIT₁ → Profile → JIT₂ → ...
可能循环! (去优化)

复杂度:
- 解释: O(n)
- JIT₁: O(n) 快速
- JIT₂: O(n log n) 优化
- 去优化: O(1)

递归理论:
✓ 整个过程 ∈ RE
✗ 最优性不可判定
→ 启发式策略
```

---

**最后更新**: 2025-12-02
**立场**: 编译器=递归转换的层次化应用
**关键**: 递归下降+不动点优化+分层JIT
**工具**: LLVM/GCC/Cranelift
