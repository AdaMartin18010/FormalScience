# 递归下降解析器实现

> **主题**: 递归下降解析的理论与实践
> **核心**: LL(k)文法+递归函数+回溯
> **重要性**: ⭐⭐⭐⭐⭐
> **创建日期**: 2025-12-02

---

## 1. 递归下降基础

### 文法到代码

```text
文法:
E → T E'
E' → + T E' | ε
T → F T'
T' → * F T' | ε
F → ( E ) | num

递归下降代码 (Python):
def parse_E():
    parse_T()
    parse_E_prime()

def parse_E_prime():
    if current_token() == '+':
        match('+')
        parse_T()
        parse_E_prime()  # 递归!
    # else: ε

def parse_T():
    parse_F()
    parse_T_prime()

def parse_F():
    if current_token() == '(':
        match('(')
        parse_E()  # 递归!
        match(')')
    elif is_number():
        match(NUMBER)
```

---

## 2. 左递归消除

```text
问题: 左递归导致无限循环

左递归文法:
E → E + T | T

消除:
E → T E'
E' → + T E' | ε

一般规则:
A → Aα₁ | ... | Aαₙ | β₁ | ... | βₘ

变换为:
A → β₁A' | ... | βₘA'
A' → α₁A' | ... | αₙA' | ε

递归理论:
✓ 文法等价性保持
✓ 识别能力不变
✓ 但解析策略改变
```

---

## 3. LL(k)条件

```text
LL(k):
- 从左到右 (Left-to-right)
- 最左推导 (Leftmost)
- k个前看符号

条件:
∀产生式 A → α | β:
  FIRST_k(αFOLLOW(A)) ∩ FIRST_k(βFOLLOW(A)) = ∅

复杂度:
✓ O(n)解析
✓ O(1)决策 (k符号)
✓ 无回溯

递归下降要求:
✓ 必须LL(k)
✗ 不能左递归
✗ 不能左公因子 (需要提取)
```

---

## 4. 错误恢复

```text
递归下降优势: 优雅错误恢复

策略:
1. Panic模式
   - 跳到同步符号 (;, })
   - 继续解析

2. 短语级恢复
   - 插入缺失符号
   - 删除多余符号

3. 错误产生式
   - 预测常见错误
   - 给出友好提示

示例:
def parse_statement():
    try:
        if current == 'if':
            parse_if()
        elif current == 'while':
            parse_while()
        else:
            raise SyntaxError()
    except SyntaxError as e:
        report_error(e)
        skip_to_semicolon()  # 恢复
```

---

## 5. 实践案例

```text
使用递归下降的编译器:
✓ GCC (C前端)
✓ Clang (部分)
✓ Go编译器
✓ Rust编译器 (初期)

优势:
✓ 实现简单
✓ 易于调试
✓ 错误恢复好
✓ 性能O(n)

劣势:
✗ 不支持所有CFG
✗ 需要文法改写
→ 但实践中足够
```

---

**最后更新**: 2025-12-02
**定位**: 编译器前端核心技术
**递归**: 文法递归→函数递归
