# 依赖类型实践指南

> **主题**: 依赖类型语言的实践应用
> **创建日期**: 2025-12-02
> **难度**: ⭐⭐⭐⭐⭐
> **前置知识**: 函数式编程、类型理论

---

## 📋 目录

- [依赖类型实践指南](#依赖类型实践指南)
  - [📋 目录](#-目录)
  - [1. 依赖类型入门](#1-依赖类型入门)
    - [1.1 核心思想](#11-核心思想)
    - [1.2 与普通类型的区别](#12-与普通类型的区别)
  - [2. 长度索引向量](#2-长度索引向量)
    - [2.1 Agda实现](#21-agda实现)
    - [2.2 Idris实现](#22-idris实现)
  - [3. 证明驱动开发](#3-证明驱动开发)
    - [3.1 工作流](#31-工作流)
    - [3.2 排序算法案例](#32-排序算法案例)
  - [4. 复杂度权衡](#4-复杂度权衡)

---

## 1. 依赖类型入门

### 1.1 核心思想

```text
依赖类型 = 类型依赖于值

普通类型:
List : Type → Type
List Int

依赖类型:
Vec : Type → Nat → Type
Vec Int 5  // 长度为5的整数向量

关键:
类型中包含值信息 ⭐
```

---

### 1.2 与普通类型的区别

```text
普通类型:
head : List a -> a
-- 运行时可能错误 (空列表) ⚠️

依赖类型:
head : Vec a (S n) -> a
-- 类型保证非空! ✓

编译器: "Vec a 0无法匹配Vec a (S n)"
→ 编译时拒绝head([]) ✓
```

---

## 2. 长度索引向量

### 2.1 Agda实现

```agda
data Vec (A : Set) : ℕ → Set where
  []  : Vec A 0
  _∷_ : {n : ℕ} → A → Vec A n → Vec A (suc n)

head : {A : Set} {n : ℕ} → Vec A (suc n) → A
head (x ∷ xs) = x

append : {A : Set} {m n : ℕ} →
         Vec A m → Vec A n → Vec A (m + n)
append [] ys = ys
append (x ∷ xs) ys = x ∷ append xs ys

-- 类型级算术!
-- m + n在类型中计算
```

---

### 2.2 Idris实现

```idris
data Vect : Nat -> Type -> Type where
  Nil  : Vect Z a
  (::) : a -> Vect k a -> Vect (S k) a

head : Vect (S n) a -> a
head (x :: xs) = x

safeDiv : (x : Int) -> (y : Int) -> {auto p : Not (y = 0)} -> Int
-- 依赖类型保证y≠0!
```

---

## 3. 证明驱动开发

### 3.1 工作流

```text
1. 指定精确类型 (= 规范)
   sort : (l : List a) →
          (l' : List a **
           (Sorted l', Permutation l l'))

2. 实现函数 (= 证明构造)
   sort l = (mergeSort l, (sortedProof, permProof))

3. 类型检查 (= 证明验证)
   类型检查通过 = 证明正确 ✓

4. 运行
   保证: sorted ✓, permutation ✓
```

---

### 3.2 排序算法案例

```text
类型签名 = 完整规范:

sort : (l : List Nat) →
       Σ (l' : List Nat),
         Sorted l' × Permutation l l'

其中:
- Sorted : List → Type
- Permutation : List → List → Type

实现必须构造:
1. 排序后的列表l'
2. l'有序的证明
3. l'是l的排列的证明

→ 类型即规范 ⭐⭐⭐⭐⭐
```

---

## 4. 复杂度权衡

| 操作 | STLC | System F | 依赖类型 |
|------|------|----------|---------|
| **类型检查** | O(n)✓ | O(n)✓ | 不可判定✗ |
| **类型推导** | O(n)✓ | 不可判定✗ | 不可判定✗ |
| **表达力** | 低 | 高 | 极高⭐ |
| **证明能力** | 无 | 无 | 完整⭐ |

**不可判定原因**:

- 类型检查 = 程序执行
- 类型 = 命题
- 检查 = 证明搜索
→ 停机问题 ✗

**实践对策**:

- 终止性检查器
- 结构递归要求
- 用户标注辅助
