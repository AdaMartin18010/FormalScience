# 09.2 基本对应关系详解

> **来源**: view08.md

## 📋 内容概览

本文档详细阐述Curry-Howard同构中五个基本对应关系的逻辑、范畴和编程实现。

## 📊 完整对应关系表

| 逻辑 | 范畴 | 编程语言 | 证明 |
|------|------|----------|------|
| ∧ (与) | 积 | Tuple (A, B) | 对构造 |
| ∨ (或) | 余积 | Either A B | 情况分析 |
| ⇒ (蕴含) | 指数 | Function A -> B | λ抽象 |
| ∀ | Π-对象 | Dep Function | 泛证 |
| ∃ | Σ-对象 | Dep Pair | 见证提取 |

## 🔗 1. ∧ (与) ↔ 积类型 (A × B) ↔ Tuple

### 逻辑侧：合取

**命题**：`A ∧ B` 表示"A与B同时为真"

**证明规则**：
- **引入**：若 ⊢ A 且 ⊢ B，则 ⊢ A ∧ B
- **消去**：若 ⊢ A ∧ B，则 ⊢ A；若 ⊢ A ∧ B，则 ⊢ B

### 范畴侧：积（Product）

**定义**：对象A和B的**积** A × B 满足**泛性质**

**交换图**：
```
      C
      |
      | f
      v
A <---π₁--- A × B ---π₂---> B
```

**存在唯一态射** ⟨f,g⟩: C → A×B 使得 π₁∘⟨f,g⟩ = f, π₂∘⟨f,g⟩ = g

### 编程侧：Tuple

```haskell
-- 构造子（introduction）
pair :: A -> B -> (A, B)
pair a b = (a, b)

-- 消去子（elimination）
fst :: (A, B) -> A
fst (a, b) = a

snd :: (A, B) -> B
snd (a, b) = b

-- β-规约（计算规则）
fst (pair a b) = a
snd (pair a b) = b

-- η-规约（唯一性规则）
pair (fst p) (snd p) = p
```

**关键同构**：
- `pair` = **合取引入**
- `fst/snd` = **合取消去**
- `β-规约` = **证明规约**

## 🔀 2. ∨ (或) ↔ 余积类型 (A + B) ↔ Either

### 逻辑侧：析取

**命题**：`A ∨ B` 表示"A或B至少一个为真"

**证明规则**：
- **引入**：若 ⊢ A，则 ⊢ A ∨ B；若 ⊢ B，则 ⊢ A ∨ B
- **消去**：若 ⊢ A ∨ B，且从A可证C，从B可证C，则 ⊢ C

### 范畴侧：余积（Coproduct）

**定义**：对象A和B的**余积** A + B 满足**对偶泛性质**

**交换图**：
```
A ---i₁---> A + B <---i₂--- B
           ↑
           | [f,g]
           |
           C
```

**存在唯一态射** [f,g]: A+B → C 使得 [f,g]∘i₁ = f, [f,g]∘i₂ = g

### 编程侧：Either

```haskell
data Either a b = Left a | Right b

-- 构造子
left  :: A -> Either A B
left a = Left a

right :: B -> Either A B
right b = Right b

-- 消去子（模式匹配 = 证明分情况）
caseEither :: Either A B -> (A -> C) -> (B -> C) -> C
caseEither (Left a)  f g = f a
caseEither (Right b) f g = g b

-- β-规约
caseEither (left a)  f g = f a
caseEither (right b) f g = g b
```

**关键同构**：
- `Left/Right` = **析取引入**
- `caseEither` = **析取消去**
- **模式匹配** = **证明分支**

## ➡️ 3. ⇒ (蕴含) ↔ 指数类型 (A ⇒ B) ↔ Function

### 逻辑侧：蕴含

**命题**：`A ⇒ B` 表示"若A为真，则B为真"

**证明规则**：
- **引入**：在假设A下证明了B，则 ⊢ A ⇒ B
- **消去**：若 ⊢ A ⇒ B 且 ⊢ A，则 ⊢ B（**Modus Ponens**）

### 范畴侧：指数对象（Exponential）

**定义**：对象Bᴬ = A ⇒ B 满足**currying**同构：

```
Hom(C × A, B) ≅ Hom(C, Bᴬ)
```

**评估态射** eval: Bᴬ × A → B

### 编程侧：Function类型

```haskell
-- 构造子（λ抽象 = 蕴含引入）
lambda :: (A -> B) -> (A -> B)
lambda f = f

-- 消去子（函数应用 = 蕴含消去）
apply :: (A -> B) -> A -> B
apply f a = f a

-- β-规约（函数调用 = Modus Ponens）
apply (lambda f) a = f a

-- curry/uncurry同构
curry :: ((A, B) -> C) -> (A -> B -> C)
curry f = \a -> \b -> f (a, b)

uncurry :: (A -> B -> C) -> ((A, B) -> C)
uncurry f = \(a, b) -> f a b
```

**关键同构**：
- **λ抽象** = **假设A，证明B**
- **函数应用** = **肯定前件**（Modus Ponens）
- `curry` = **证明转换**

## 🔄 4. ∀ ↔ Π-类型 ↔ Dependent Function

### 逻辑侧：全称量词

**命题**：`∀x:A. P(x)` 表示"对所有A中的x，P(x)为真"

**证明规则**：
- **引入**：对任意a:A，证明了P(a)，则 ⊢ ∀x:A. P(x)
- **消去**：若 ⊢ ∀x:A. P(x) 且 ⊢ a:A，则 ⊢ P(a)

### 范畴侧：Π-构造（Dependent Product）

**定义**：给定纤维化 p: ℰ → ℬ，**Π-类型**是将纤维上的族**积**到基

**通配态射**：**截面**（section）s: A → Π_A P，满足 p∘s = id_A

### 编程侧：Dependent Function

```idris
-- 依赖类型：向量的长度依赖其元素类型
Vec : (n : Nat) -> (a : Type) -> Type
Vec n a = ...  -- 长度为n的a向量

-- Π-类型：证明∀n:Nat. Vec n A → Vec n A
reverse : (n : Nat) -> Vec n a -> Vec n a
reverse n xs = ...  -- 对任意n都成立

-- 构造子（∀引入）
forallIntro : ((a : A) -> P a) -> (x : A) -> P x
forallIntro f a = f a

-- 消去子（∀消去）
applyForall : ((x : A) -> P x) -> (a : A) -> P a
applyForall f a = f a
```

**关键同构**：
- `reverse : (n : Nat) → Vec n a → Vec n a` = **对任意自然数n，存在向量反转操作**
- **类型检查** = **全称量词的证明检查**

## 🔍 5. ∃ ↔ Σ-类型 ↔ Dependent Pair

### 逻辑侧：存在量词

**命题**：`∃x:A. P(x)` 表示"存在A中的x，使P(x)为真"

**证明规则**：
- **引入**：给定a:A和P(a)的证明，则 ⊢ ∃x:A. P(x)
- **消去**：若 ⊢ ∃x:A. P(x)，则可假设某个x₀:A满足P(x₀)

### 范畴侧：Σ-构造（Dependent Sum）

**定义**：纤维化 p: ℰ → ℬ 的**Σ-类型** = **余积到基的聚合**

**配对对象**：(a, p) 其中 a:A, p:P(a)

### 编程侧：Dependent Pair

```idris
-- Σ-类型：证明"存在非空向量"
data ExistsNonEmpty : (a : Type) -> Type where
  MkNonEmpty : (n : Nat) -> (vec : Vec (S n) a) -> ExistsNonEmpty a
  -- S n = n+1, 确保长度>0

-- 构造子（∃引入）
existsIntro : (a : A) -> P a -> Σ A P
existsIntro a pa = (a, pa)

-- 消去子（∃消去）
elimExists : Σ A P -> ( (a : A) -> P a -> C ) -> C
elimExists (a, pa) cont = cont a pa
```

**关键同构**：
- `Σ Nat (\n => Vec n a)` = **存在某个长度的向量**
- **模式匹配** = **存在消去**（提取见证a和证明pa）

## 🎯 统一视角：伴随立方

### 伴随关系

```
         Π
        / \
       /   \
      /     \
   ⇒        ×
    \     /
     \   /
      ∨ +
       \ /
         Σ
```

- **右伴随**：×, Π, ⇒
- **左伴随**：+, Σ
- **双重否定延续（CNF）**：Curry-Howard-Lambek三重同构

## 🔗 相关文档

- [09.1_逻辑与类型的对应.md](09.1_逻辑与类型的对应.md)
- [09.3_范畴论视角.md](09.3_范畴论视角.md)
- [03_范畴论与形式化方法/README.md](../03_范畴论与形式化方法/README.md)

## 📖 扩展阅读

- 《Types and Programming Languages》- Benjamin C. Pierce
- 《Proofs and Types》- Jean-Yves Girard
- Wikipedia: [Curry-Howard Correspondence](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence)
