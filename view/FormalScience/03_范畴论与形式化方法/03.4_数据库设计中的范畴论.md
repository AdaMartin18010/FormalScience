# 03.4 数据库设计中的范畴论

> **来源**: view08.md

## 📋 内容概览

本文档阐述如何用范畴论的观点理解和设计数据库Schema，将数据库设计提升到形式化层面。

## 📚 Schema作为范畴

### 基本对应

**一个数据库Schema = 一个有限范畴ℬ**

- **对象 Ob(ℬ)** = 表（Table₁, Table₂, ...）
- **态射 Hom(ℬ)** = 外键约束（FK: Table₁ → Table₂）

### 外键约束的传递性 = 交换图

```
Table₁ --FK₁₂--> Table₂ --FK₂₃--> Table₃
   \                /
    \              /
     FK₁₃==========/
```

**要求**：FK₁₃ = FK₂₃ ∘ FK₁₂ （**态射复合律**）

### 实例：订单-用户-地址三表

- 外键：Orders.user_id → Users.id
- 外键：Users.address_id → Addresses.id
- **传递闭包**：Orders.user_address 应等于 Users表的地址
- **范畴约束**：若传递闭包违反，ℬ不是范畴（**无交换图**）

## 🔍 查询 = 函子

### 关系代数查询 = 函子

**关系代数查询 = 函子** Q: ℬ → **Set**

- **Set** = 集合的范畴（对象是集合，态射是函数）
- **Q(Table)** = 表的所有行（**对象映射**）
- **Q(FK)** = 外键连接操作（**态射映射**）

### 函子保持结构

```
Q(FK₂₃ ∘ FK₁₂) = Q(FK₂₃) ∘ Q(FK₁₂)
```

即：**先Join Users→Addresses，再Join Orders→Users** = **直接Join Orders→Addresses**

**数据库正确性 = 函子性**

## 🔗 JOIN = 拉回（Pullback）

### 场景：查询"订单+用户+地址"

**范畴构造**：

```
          Orders
          /   \
    FK₁₂ /     \ FK₁₃'
        /       \
    Users      Addresses
        \       /
         \     /
          \   /
           ???  (拉回)
```

**拉回** = 最大的表，满足同时兼容两个外键映射

### SQL实现

```sql
SELECT * FROM Orders
JOIN Users ON Orders.user_id = Users.id
JOIN Addresses ON Users.address_id = Addresses.id
```

**范畴语言**：**拉回 = 极限（Limit）**

- **泛性质**：任何其他能连Orders/Users/Addresses的表，都有唯一态射**穿过**这个拉回

### 重要推论

- **自然Join** = **拉回**
- **INNER JOIN** = **拉回+投影**
- **LEFT JOIN** = **拉回+余单位**

## 📐 规范化 = 寻找伴随函子

### 问题：数据冗余 = 范畴的非单态射（non-monic）

**实例**：Users表包含address_street, address_city（冗余）

### 规范化的范畴本质

**遗忘函子** U: ℬ_norm → ℬ_unnorm
**左伴随** F ⊣ U （F = 添加外键，U = 遗忘冗余列）

### 伴随单位-余单位

```
η: Id → U∘F    （添加外键，消除冗余）
ε: F∘U → Id    （投影回范式）
```

### 3NF = 左伴随F的泛性质

- **存在**：任何冗余表，存在唯一的3NF分解
- **最优**：F是"最自由"的范式化（**余自由函子**）

### 实例工具

**dbt**（data build tool）的**ref()**函数 = **函子F的显式构造**

## 🔄 视图 = 自然变换

### 物化视图 = 自然变换

**物化视图** = **自然变换** α: Q₁ → Q₂

```
Table₁ --Q₁--> ResultSet₁
  |              |
FK |              | α（数据同步）
  v              v
Table₂ --Q₂--> ResultSet₂
```

**α保持交换**：α(ResultSet₁) = ResultSet₂

### 物化视图刷新失败 = 自然变换不自然

**范畴诊断**：Q₁∘FK ≠ Q₂∘α （**Nat(α)被破坏**）

### 实例

PostgreSQL的**REFRESH MATERIALIZED VIEW** = **强制自然性条件**

## 🏗️ 实际应用

### 1. Schema设计原则

- **保持交换图**：确保外键传递性
- **使用伴随分解**：规范化设计
- **函子性验证**：查询优化

### 2. 查询优化

- **利用拉回性质**：优化JOIN顺序
- **函子组合**：查询分解与重组
- **自然变换**：视图物化策略

### 3. 数据一致性

- **交换图验证**：检查外键一致性
- **函子性检查**：验证查询正确性
- **自然性维护**：保持视图同步

## 🔗 相关文档

- [03.1_范畴论基础.md](03.1_范畴论基础.md)
- [03.2_函子与自然变换.md](03.2_函子与自然变换.md)
- [03.3_极限与余极限.md](03.3_极限与余极限.md)
- [09_Curry-Howard同构/09.1_逻辑与类型的对应.md](../09_Curry-Howard同构/09.1_逻辑与类型的对应.md)

## 📖 扩展阅读

- 《Category Theory for the Sciences》- David Spivak
- Wikipedia: [Category Theory](https://en.wikipedia.org/wiki/Category_theory)
