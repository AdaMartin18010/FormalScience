# 10.6 Petri网与并发系统

> **子主题编号**: 10.6
> **主题**: Petri网理论
> **最后更新**: 2025-12-02
> **文档状态**: ✅ 完成

---

## 📋 目录

- [10.6 Petri网与并发系统](#106-petri网与并发系统)
  - [📋 目录](#-目录)
  - [1 概述](#1-概述)
    - [1.1 核心洞察](#11-核心洞察)
    - [1.2 并发系统建模优势](#12-并发系统建模优势)
    - [1.3 设计原理与动机](#13-设计原理与动机)
  - [2 并发建模](#2-并发建模)
    - [2.1 并发表示](#21-并发表示)
    - [2.2 并发度](#22-并发度)
  - [3 同步机制](#3-同步机制)
    - [3.1 同步模式](#31-同步模式)
    - [3.2 同步Petri网](#32-同步petri网)
  - [4 冲突检测](#4-冲突检测)
    - [4.1 冲突定义](#41-冲突定义)
    - [4.2 冲突解决策略](#42-冲突解决策略)
  - [5 资源竞争](#5-资源竞争)
    - [5.1 资源建模](#51-资源建模)
    - [5.2 资源竞争分析](#52-资源竞争分析)
    - [5.3 关系属性与依赖分析](#53-关系属性与依赖分析)
  - [6 跨视角链接](#6-跨视角链接)
    - [6.1 形式语言视角关联](#61-形式语言视角关联)
    - [6.2 调度视角关联](#62-调度视角关联)

---

## 1 概述

### 1.1 核心洞察

Petri网天然适合建模并发系统，通过库所和变迁的自然表示，可以清晰地描述**并发、同步、冲突**等并发系统特性。Petri网的并发语义使其成为并发系统建模的理想工具。

### 1.2 并发系统建模优势

**Petri网在并发系统建模中的优势**：

1. **自然并发表示**：多个变迁可以同时点火，无需显式枚举所有并发状态
2. **同步机制直观**：通过共享库所自然表示同步
3. **冲突自动显现**：资源竞争和冲突自动显现
4. **形式化分析**：可以形式化分析并发系统的性质

### 1.3 设计原理与动机

**为什么Petri网适合并发系统？**

1. **状态空间优势**：传统状态机需要显式枚举所有并发状态组合，Petri网通过多个库所自然表示并发
2. **同步直观**：同步通过共享库所实现，比消息传递更直观
3. **冲突检测**：冲突自动显现，便于分析和解决

---

## 2 并发建模

### 2.1 并发表示

**定义 2.1**（并发）：

```text
两个变迁t₁和t₂在标记M下并发，记作t₁ ||_M t₂，当且仅当：
  1. M[t₁⟩ 且 M[t₂⟩（都使能）
  2. •t₁ ∩ •t₂ = ∅（不共享输入库所）

可以同时点火，顺序无关。

形式化：
  t₁ ||_M t₂ ⟺ M[t₁⟩ ∧ M[t₂⟩ ∧ (•t₁ ∩ •t₂ = ∅)
```

**并发执行语义**：

```text
如果t₁ ||_M t₂，则：
  - 可以同时点火：M[t₁, t₂⟩M'
  - 顺序无关：M[t₁⟩M₁[t₂⟩M' 等价于 M[t₂⟩M₂[t₁⟩M'
  - 结果相同：M' = fire(fire(M, t₁), t₂) = fire(fire(M, t₂), t₁)
```

**定理 2.1**（并发交换性）：

```text
如果t₁ ||_M t₂，则：
  fire(fire(M, t₁), t₂) = fire(fire(M, t₂), t₁)

证明：
  由于•t₁ ∩ •t₂ = ∅，两个变迁不共享输入库所。
  因此，t₁的点火不影响t₂的使能条件，反之亦然。
  结果标记M' = M - W(•t₁, t₁) - W(•t₂, t₂) + W(t₁, t₁•) + W(t₂, t₂•)
  与点火顺序无关。
```

### 2.2 并发度

**定义 2.2**（并发度）：

```text
标记M下的并发度：
  Concurrency(M) = max{|S| | S ⊆ T_enabled, ∀t₁, t₂ ∈ S. t₁ ||_M t₂}

即：可以同时点火的最大变迁数量。
```

**并发度分析**：

```text
1. 高并发度：
   - 系统可以充分利用并行性
   - 提高系统吞吐量

2. 低并发度：
   - 系统串行化程度高
   - 可能存在瓶颈
```

---

## 3 同步机制

### 3.1 同步模式

**定义 3.1**（同步）：

```text
同步通过共享库所实现：
  多个变迁等待同一库所的标记
  当标记可用时，变迁可以并发执行

形式化：
  变迁t₁和t₂在库所p上同步，当且仅当：
    p ∈ •t₁ ∩ •t₂（共享输入库所）
```

**同步类型**：

```text
1. 会合同步（Rendezvous）：
   - 多个变迁必须同时等待同一标记
   - 标记到达时，所有变迁同时点火
   - 例如：p →[t₁, t₂]→（两个变迁同时等待p）

2. 广播同步（Broadcast）：
   - 一个变迁产生标记，多个变迁可以接收
   - 例如：p →[t₁]→ p₁, p →[t₂]→ p₂（t₁产生标记，t₂和t₃可以接收）

3. 条件同步（Conditional）：
   - 变迁在特定条件下才能点火
   - 例如：G(t) = condition（守卫函数）
```

### 3.2 同步Petri网

**定义 3.2**（同步Petri网）：

```text
同步Petri网通过共享库所实现同步：

结构：
  p_sync →[t₁]→ p₁
  p_sync →[t₂]→ p₂
  p_sync →[t₃]→ p₃

语义：
  - t₁, t₂, t₃在p_sync上同步
  - 当p_sync有标记时，t₁, t₂, t₃可以并发执行
  - 如果p_sync的标记数 < 3，则存在竞争
```

**同步与并发的关系**：

```text
1. 同步是并发的前提：
   - 同步确保多个变迁在正确时机执行
   - 并发是同步的结果

2. 同步可能限制并发：
   - 如果同步资源有限，可能限制并发度
   - 需要平衡同步和并发
```

---

## 4 冲突检测

### 4.1 冲突定义

**定义 4.1**（冲突）：

```text
两个变迁t₁和t₂在标记M下冲突，记作t₁ #_M t₂，当且仅当：
  1. M[t₁⟩ 且 M[t₂⟩（都使能）
  2. •t₁ ∩ •t₂ ≠ ∅（共享输入库所）
  3. ∃p ∈ •t₁ ∩ •t₂. M(p) < W(p, t₁) + W(p, t₂)（标记不足）

只能选择一个变迁执行。

形式化：
  t₁ #_M t₂ ⟺ M[t₁⟩ ∧ M[t₂⟩ ∧ (•t₁ ∩ •t₂ ≠ ∅) ∧
              (∃p ∈ •t₁ ∩ •t₂. M(p) < W(p, t₁) + W(p, t₂))
```

**冲突类型**：

```text
1. 完全冲突：
   - 两个变迁完全互斥
   - 只能选择一个执行
   - 例如：p →[t₁]→ p₁, p →[t₂]→ p₂（p只有1个标记）

2. 部分冲突：
   - 两个变迁部分互斥
   - 可能可以并发执行（如果标记足够）
   - 例如：p →[t₁]→ p₁, p →[t₂]→ p₂（p有2个标记，可以并发）

3. 优先级冲突：
   - 冲突通过优先级解决
   - 高优先级变迁优先执行
```

### 4.2 冲突解决策略

**定义 4.2**（冲突解决策略）：

```text
1. 非确定性选择：
   - 随机选择一个变迁执行
   - 适用于非确定性系统

2. 优先级选择：
   - 根据优先级选择变迁
   - 高优先级变迁优先执行

3. 公平选择：
   - 公平地选择变迁
   - 避免某些变迁永远不被选择

4. 外部决策：
   - 由外部环境决定选择哪个变迁
   - 适用于交互式系统
```

**冲突检测算法**：

```text
算法4.1（冲突检测）：
  输入：Petri网N，标记M
  输出：冲突集合C

  1. 计算使能变迁集合T_enabled
  2. 初始化C = ∅
  3. 对于每对变迁(t₁, t₂) ∈ T_enabled × T_enabled：
     a. 如果t₁ #_M t₂：
        * 添加(t₁, t₂)到C
  4. 返回C
```

---

## 5 资源竞争

### 5.1 资源建模

**定义 5.1**（资源竞争）：

```text
资源通过库所建模：
  - 库所中的标记表示可用资源
  - 变迁消耗标记（获取资源）
  - 变迁产生标记（释放资源）

形式化：
  资源库所p_resource：
    - M(p_resource)表示可用资源数量
    - 变迁t获取资源：W(p_resource, t) = resource_required
    - 变迁t释放资源：W(t, p_resource) = resource_released
```

**资源竞争模式**：

```text
1. 独占资源：
   - 资源一次只能被一个任务使用
   - 例如：p_resource →[t₁]→ p_allocated_1
            p_resource →[t₂]→ p_allocated_2
   - 如果M(p_resource) < 2，则t₁和t₂竞争资源

2. 共享资源：
   - 资源可以被多个任务共享
   - 例如：p_resource →[t₁]→ p_allocated_1（需要1个资源）
            p_resource →[t₂]→ p_allocated_2（需要1个资源）
   - 如果M(p_resource) ≥ 2，则t₁和t₂可以并发执行

3. 资源池：
   - 多个资源组成资源池
   - 任务从资源池中获取资源
   - 例如：p_resource_pool →[t]→ p_allocated（获取资源）
```

### 5.2 资源竞争分析

**定义 5.2**（资源竞争度）：

```text
资源p的竞争度：
  Competition(p, M) = |{t | t ∈ T_enabled, p ∈ •t, M(p) < W(p, t)}|

即：需要资源p但资源不足的变迁数量。
```

**资源竞争解决**：

```text
1. 资源预分配：
   - 任务开始前分配所有资源
   - 避免资源竞争
   - 可能造成资源浪费

2. 资源排序：
   - 对所有资源排序
   - 按顺序请求资源
   - 避免死锁

3. 超时机制：
   - 资源请求设置超时
   - 超时后释放资源
   - 避免无限等待
```

### 5.3 关系属性与依赖分析

**定理 5.1**（并发、同步、冲突的关系）：

```text
对于变迁t₁和t₂：
  1. 如果t₁ ||_M t₂，则t₁和t₂并发（无冲突）
  2. 如果t₁ #_M t₂，则t₁和t₂冲突（不能并发）
  3. 如果t₁和t₂在p上同步，则可能并发或冲突（取决于标记数）

关系：
  并发 ⟹ 无冲突
  冲突 ⟹ 无并发
  同步 ⟹ 可能并发或冲突
```

---

## 6 跨视角链接

### 6.1 形式语言视角关联

- [效应系统](../07_效应系统/) - 并发控制
- [程序控制](../03_程序控制/) - 控制流

### 6.2 调度视角关联

- [同步通信机制](../../schedule_formal_view/04_同步通信机制/) - 同步机制

---

**返回**: [Petri网理论主索引](./README.md) | [形式语言视角主索引](../README.md)
