# 9.4 Â∫îÁî®ËåÉÁï¥ËÆ∫

> **Â≠ê‰∏ªÈ¢òÁºñÂè∑**: 09.4
> **‰∏ªÈ¢ò**: ÂΩ¢ÂºèÂåñÁêÜËÆ∫
> **ÊúÄÂêéÊõ¥Êñ∞**: 2025-12-02
> **ÊñáÊ°£Áä∂ÊÄÅ**: ‚úÖ ÂÆåÊàê

---

## üìã ÁõÆÂΩï

- [9.4 Â∫îÁî®ËåÉÁï¥ËÆ∫](#94-Â∫îÁî®ËåÉÁï¥ËÆ∫)
  - [üìã ÁõÆÂΩï](#-ÁõÆÂΩï)
  - [1 Ê¶ÇËø∞](#1-Ê¶ÇËø∞)
    - [1.1 Ê†∏ÂøÉÊ¥ûÂØü](#11-Ê†∏ÂøÉÊ¥ûÂØü)
    - [1.2 Ê†∏ÂøÉÊ¶ÇÂøµÊò†Â∞Ñ](#12-Ê†∏ÂøÉÊ¶ÇÂøµÊò†Â∞Ñ)
    - [1.3 Ê†∏ÂøÉÊ¶ÇÂøµÁ≤æÁ°ÆÂÆö‰πâ](#13-Ê†∏ÂøÉÊ¶ÇÂøµÁ≤æÁ°ÆÂÆö‰πâ)
      - [1.3.1 ËåÉÁï¥ÔºàCategoryÔºâ](#131-ËåÉÁï¥category)
      - [1.3.2 ÂáΩÂ≠êÔºàFunctorÔºâ](#132-ÂáΩÂ≠êfunctor)
      - [1.3.3 Ëá™ÁÑ∂ÂèòÊç¢ÔºàNatural TransformationÔºâ](#133-Ëá™ÁÑ∂ÂèòÊç¢natural-transformation)
    - [1.4 ËÆæËÆ°ÂéüÁêÜ‰∏éÂä®Êú∫](#14-ËÆæËÆ°ÂéüÁêÜ‰∏éÂä®Êú∫)
      - [1.4.1 ‰∏∫‰ªÄ‰πà‰ΩøÁî®ËåÉÁï¥ËÆ∫Ôºü](#141-‰∏∫‰ªÄ‰πà‰ΩøÁî®ËåÉÁï¥ËÆ∫)
      - [1.4.2 ËåÉÁï¥ËÆ∫Âú®Ë∞ÉÂ∫¶‰∏≠ÁöÑÂÖ∑‰ΩìÂ∫îÁî®](#142-ËåÉÁï¥ËÆ∫Âú®Ë∞ÉÂ∫¶‰∏≠ÁöÑÂÖ∑‰ΩìÂ∫îÁî®)
  - [2 ÊÄùÁª¥ÂØºÂõæ](#2-ÊÄùÁª¥ÂØºÂõæ)
  - [3 ÂáΩÂ≠ê‰∏éËá™ÁÑ∂ÂèòÊç¢](#3-ÂáΩÂ≠ê‰∏éËá™ÁÑ∂ÂèòÊç¢)
    - [3.1 ÂáΩÂ≠êÂÆö‰πâ](#31-ÂáΩÂ≠êÂÆö‰πâ)
    - [3.2 Ëá™ÁÑ∂ÂèòÊç¢](#32-Ëá™ÁÑ∂ÂèòÊç¢)
    - [3.3 Á±ªÂûã-Ë∞ÉÂ∫¶ÂáΩÂ≠ê](#33-Á±ªÂûã-Ë∞ÉÂ∫¶ÂáΩÂ≠ê)
  - [4 Monad‰∏éComonad](#4-monad‰∏écomonad)
    - [4.1 MonadÂÆö‰πâ](#41-monadÂÆö‰πâ)
    - [4.2 Ë∞ÉÂ∫¶Monad](#42-Ë∞ÉÂ∫¶monad)
    - [4.3 Free Monad](#43-free-monad)
  - [5 Ë∞ÉÂ∫¶Á≥ªÁªüÁöÑËåÉÁï¥ËØ≠‰πâ](#5-Ë∞ÉÂ∫¶Á≥ªÁªüÁöÑËåÉÁï¥ËØ≠‰πâ)
    - [5.1 Ë∞ÉÂ∫¶ËåÉÁï¥](#51-Ë∞ÉÂ∫¶ËåÉÁï¥)
    - [5.2 Á≠ñÁï•ÂáΩÂ≠ê](#52-Á≠ñÁï•ÂáΩÂ≠ê)
    - [5.3 Ë∞ÉÂ∫¶MonadËØ≠‰πâ](#53-Ë∞ÉÂ∫¶monadËØ≠‰πâ)
  - [6 ÂÆûË∑µÂ∫îÁî®](#6-ÂÆûË∑µÂ∫îÁî®)
    - [6.1 HaskellË∞ÉÂ∫¶Â∫ì](#61-haskellË∞ÉÂ∫¶Â∫ì)
    - [6.2 K8s OperatorËåÉÁï¥](#62-k8s-operatorËåÉÁï¥)
  - [7 Ë∑®ËßÜËßíÈìæÊé•](#7-Ë∑®ËßÜËßíÈìæÊé•)
    - [7.1 ÂΩ¢ÂºèËØ≠Ë®ÄËßÜËßíÂÖ≥ËÅî](#71-ÂΩ¢ÂºèËØ≠Ë®ÄËßÜËßíÂÖ≥ËÅî)
    - [7.2 Ë∞ÉÂ∫¶ËßÜËßíÂÖ≥ËÅî](#72-Ë∞ÉÂ∫¶ËßÜËßíÂÖ≥ËÅî)
  - [ÂèÇËÄÉËµÑÊ∫ê](#ÂèÇËÄÉËµÑÊ∫ê)

---

## 1 Ê¶ÇËø∞

### 1.1 Ê†∏ÂøÉÊ¥ûÂØü

Â∫îÁî®ËåÉÁï¥ËÆ∫Â∞ÜÊäΩË±°ÁöÑËåÉÁï¥ËÆ∫Ê¶ÇÂøµÂ∫îÁî®‰∫éÂÖ∑‰ΩìÁöÑËÆ°ÁÆóÊú∫ÁßëÂ≠¶ÈóÆÈ¢ò„ÄÇ
Âú®Á±ªÂûãÁ≥ªÁªü‰∏éË∞ÉÂ∫¶Á≥ªÁªüÁöÑÁªü‰∏ÄËßÜËßí‰∏ãÔºåËåÉÁï¥ËÆ∫Êèê‰æõ‰∫Ü**ÁªÑÂêàÊÄß**„ÄÅ**ÂèØÈÄÜÊÄß**Âíå**ÊäΩË±°ÊÄß**ÁöÑÂΩ¢ÂºèÂåñÂü∫Á°Ä„ÄÇ

### 1.2 Ê†∏ÂøÉÊ¶ÇÂøµÊò†Â∞Ñ

| ËåÉÁï¥ËÆ∫Ê¶ÇÂøµ | Á±ªÂûãÁ≥ªÁªü | Ë∞ÉÂ∫¶Á≥ªÁªü |
|-----------|---------|---------|
| **ÂØπË±°** | Á±ªÂûã | ËµÑÊ∫êÁä∂ÊÄÅ |
| **ÊÄÅÂ∞Ñ** | ÂáΩÊï∞ | Áä∂ÊÄÅËΩ¨Êç¢ |
| **ÂáΩÂ≠ê** | Á±ªÂûãÊûÑÈÄ†Âô® | ËµÑÊ∫êÊò†Â∞Ñ |
| **Ëá™ÁÑ∂ÂèòÊç¢** | Â§öÊÄÅÂáΩÊï∞ | Á≠ñÁï•ËΩ¨Êç¢ |
| **Monad** | ËÆ°ÁÆó‰∏ä‰∏ãÊñá | Ë∞ÉÂ∫¶‰∏ä‰∏ãÊñá |

### 1.3 Ê†∏ÂøÉÊ¶ÇÂøµÁ≤æÁ°ÆÂÆö‰πâ

#### 1.3.1 ËåÉÁï¥ÔºàCategoryÔºâ

**ÂÆö‰πâ 1.1**ÔºöËåÉÁï¥CÁî±‰ª•‰∏ãÁªÑÊàêÔºö

```text
C = (Ob(C), Hom(C), ‚àò, id)

ÂÖ∂‰∏≠Ôºö
  - Ob(C)ÔºöÂØπË±°ÈõÜÂêà
  - Hom(C)ÔºöÊÄÅÂ∞ÑÈõÜÂêàÔºåHom(A, B)Ë°®Á§∫‰ªéAÂà∞BÁöÑÊÄÅÂ∞Ñ
  - ‚àòÔºöÊÄÅÂ∞ÑÁªÑÂêàËøêÁÆó
  - idÔºöÊÅíÁ≠âÊÄÅÂ∞Ñ

Êª°Ë∂≥Ôºö
  1. ÁªìÂêàÂæãÔºö(f ‚àò g) ‚àò h = f ‚àò (g ‚àò h)
  2. Âçï‰ΩçÂæãÔºöid_B ‚àò f = f = f ‚àò id_A
```

**Ë∞ÉÂ∫¶Á≥ªÁªüÂØπÂ∫î**Ôºö

- **ÂØπË±°**ÔºöÁ≥ªÁªüÁä∂ÊÄÅÔºàËµÑÊ∫êÁä∂ÊÄÅ„ÄÅÈòüÂàóÁä∂ÊÄÅÔºâ
- **ÊÄÅÂ∞Ñ**ÔºöË∞ÉÂ∫¶Âä®‰ΩúÔºàÂàÜÈÖç„ÄÅÊä¢Âç†„ÄÅËøÅÁßªÔºâ
- **ÁªÑÂêà**ÔºöË∞ÉÂ∫¶Âä®‰ΩúÁöÑÂ∫èÂàóÊâßË°å
- **ÊÅíÁ≠â**ÔºöÊó†Êìç‰ΩúË∞ÉÂ∫¶

#### 1.3.2 ÂáΩÂ≠êÔºàFunctorÔºâ

**ÂÆö‰πâ 1.2**ÔºöÂáΩÂ≠êF: C ‚Üí DÊòØËåÉÁï¥‰πãÈó¥ÁöÑÊò†Â∞ÑÔºå‰øùÊåÅÁªìÊûÑÔºö

```text
F: C ‚Üí D

ÂØπË±°Êò†Â∞ÑÔºöF: Ob(C) ‚Üí Ob(D)
ÊÄÅÂ∞ÑÊò†Â∞ÑÔºöF: Hom_C(A, B) ‚Üí Hom_D(F(A), F(B))

Êª°Ë∂≥Ôºö
  1. F(id_A) = id_{F(A)}
  2. F(f ‚àò g) = F(f) ‚àò F(g)
```

**Ë∞ÉÂ∫¶Á≥ªÁªüÂØπÂ∫î**Ôºö

- **Á±ªÂûã-Ë∞ÉÂ∫¶ÂáΩÂ≠ê**ÔºöÂ∞ÜÁ±ªÂûãÊò†Â∞ÑÂà∞Ë∞ÉÂ∫¶ËµÑÊ∫ê
- **Á≠ñÁï•ÂáΩÂ≠ê**ÔºöÂ∞ÜÈÖçÁΩÆÊò†Â∞ÑÂà∞Ë∞ÉÂ∫¶Á≠ñÁï•

#### 1.3.3 Ëá™ÁÑ∂ÂèòÊç¢ÔºàNatural TransformationÔºâ

**ÂÆö‰πâ 1.3**ÔºöËá™ÁÑ∂ÂèòÊç¢Œ∑: F ‚Üí GÊòØÂáΩÂ≠ê‰πãÈó¥ÁöÑÊÄÅÂ∞ÑÔºö

```text
ÂØπ‰∫éÊØè‰∏™ÂØπË±°AÔºåÊúâÊÄÅÂ∞ÑŒ∑_A: F(A) ‚Üí G(A)

Êª°Ë∂≥Ëá™ÁÑ∂ÊÄßÊù°‰ª∂Ôºö
  ÂØπ‰∫é‰ªª‰ΩïÊÄÅÂ∞Ñf: A ‚Üí BÔºö
    G(f) ‚àò Œ∑_A = Œ∑_B ‚àò F(f)
```

**Ë∞ÉÂ∫¶Á≥ªÁªüÂØπÂ∫î**Ôºö

- **Á≠ñÁï•ËΩ¨Êç¢**Ôºö‰ªé‰∏Ä‰∏™Ë∞ÉÂ∫¶Á≠ñÁï•ËΩ¨Êç¢Âà∞Âè¶‰∏Ä‰∏™
- **Á≠ñÁï•ÁªÑÂêà**ÔºöÂ§ö‰∏™Á≠ñÁï•ÁöÑËá™ÁÑ∂ÁªÑÂêà

### 1.4 ËÆæËÆ°ÂéüÁêÜ‰∏éÂä®Êú∫

#### 1.4.1 ‰∏∫‰ªÄ‰πà‰ΩøÁî®ËåÉÁï¥ËÆ∫Ôºü

**ÊäΩË±°‰ºòÂäø**Ôºö

1. **Áªü‰∏ÄËßÜËßí**ÔºöÁ±ªÂûãÁ≥ªÁªüÂíåË∞ÉÂ∫¶Á≥ªÁªüÂÖ±‰∫´Áõ∏ÂêåÁöÑÊï∞Â≠¶ÁªìÊûÑ
2. **ÁªÑÂêàÊÄß‰øùËØÅ**ÔºöËåÉÁï¥ËÆ∫‰øùËØÅÁªÑÂêàÁöÑÊ≠£Á°ÆÊÄß
3. **ÂèØËØÅÊòéÊÄß**ÔºöÂΩ¢ÂºèÂåñÁªìÊûÑÊîØÊåÅ‰∏•Ê†ºËØÅÊòé

**ÂΩ¢ÂºèÂåñË°®Ëø∞**Ôºö

```text
Á±ªÂûãÁ≥ªÁªüËåÉÁï¥ Type:
  - ÂØπË±°ÔºöÁ±ªÂûã
  - ÊÄÅÂ∞ÑÔºöÂáΩÊï∞

Ë∞ÉÂ∫¶Á≥ªÁªüËåÉÁï¥ Schedule:
  - ÂØπË±°ÔºöÁ≥ªÁªüÁä∂ÊÄÅ
  - ÊÄÅÂ∞ÑÔºöË∞ÉÂ∫¶Âä®‰Ωú

Á±ªÂûã-Ë∞ÉÂ∫¶ÂáΩÂ≠ê F: Type ‚Üí Schedule:
  - F(Int) = CPUËµÑÊ∫ê
  - F(Bytes) = MemoryËµÑÊ∫ê
  - F(f: A ‚Üí B) = ËµÑÊ∫êËΩ¨Êç¢Ë∞ÉÂ∫¶
```

#### 1.4.2 ËåÉÁï¥ËÆ∫Âú®Ë∞ÉÂ∫¶‰∏≠ÁöÑÂÖ∑‰ΩìÂ∫îÁî®

**Â∫îÁî®1ÔºöË∞ÉÂ∫¶Á≠ñÁï•ÁªÑÂêà**

```text
Á≠ñÁï•ÁªÑÂêà‰Ωú‰∏∫ÂáΩÂ≠êÁªÑÂêàÔºö
  compose(FIFO, Priority) = FIFO ‚àò Priority

‰øùËØÅÔºöÁªÑÂêàÂêéÁöÑÁ≠ñÁï•Êª°Ë∂≥ÂáΩÂ≠êÂæãÔºåÂç≥ÁªÑÂêàÊòØÁªìÂêàÁöÑ
```

**Â∫îÁî®2ÔºöÁ≠ñÁï•ËΩ¨Êç¢**

```text
Á≠ñÁï•ËΩ¨Êç¢‰Ωú‰∏∫Ëá™ÁÑ∂ÂèòÊç¢Ôºö
  transform: OldStrategy ‚Üí NewStrategy

‰øùËØÅÔºöËΩ¨Êç¢‰øùÊåÅË∞ÉÂ∫¶ËØ≠‰πâÁöÑ‰∏ÄËá¥ÊÄß
```

**Â∫îÁî®3ÔºöËµÑÊ∫êÊò†Â∞Ñ**

```text
ËµÑÊ∫êÊò†Â∞Ñ‰Ωú‰∏∫ÂáΩÂ≠êÔºö
  Resource: Type ‚Üí ResourceState

‰øùËØÅÔºöÁ±ªÂûãÂà∞ËµÑÊ∫êÁöÑÊò†Â∞Ñ‰øùÊåÅÁªìÊûÑ
```

---

## 2 ÊÄùÁª¥ÂØºÂõæ

```mermaid
mindmap
  root((Â∫îÁî®ËåÉÁï¥ËÆ∫))
    Âü∫Á°ÄÊ¶ÇÂøµ
      ËåÉÁï¥
        ÂØπË±°
        ÊÄÅÂ∞Ñ
        ÁªÑÂêàÂæã
      ÂáΩÂ≠ê
        ÂçèÂèò/ÈÄÜÂèò
        Êª°Âø†ÂÆû
      Ëá™ÁÑ∂ÂèòÊç¢
        Â§öÊÄÅÊÄß
        ÂèÇÊï∞ÊÄß
    È´òÁ∫ßÊ¶ÇÂøµ
      Monad
        unit
        bind
        Âæã
      Comonad
        extract
        extend
      Adjunction
        Â∑¶/Âè≥‰º¥Èöè
        Âçï‰Ωç/‰ΩôÂçï‰Ωç
    Â∫îÁî®
      Á±ªÂûãÁ≥ªÁªü
        Maybe/Either
        IO/State
        Free Monad
      Ë∞ÉÂ∫¶Á≥ªÁªü
        ËµÑÊ∫êMonad
        Ë∞ÉÂ∫¶ÂáΩÂ≠ê
        Á≠ñÁï•ÁªÑÂêà
```

---

## 3 ÂáΩÂ≠ê‰∏éËá™ÁÑ∂ÂèòÊç¢

### 3.1 ÂáΩÂ≠êÂÆö‰πâ

```haskell
-- Haskell‰∏≠ÁöÑFunctor
class Functor f where
    fmap :: (a -> b) -> f a -> f b

    -- ÂáΩÂ≠êÂæã
    -- fmap id = id
    -- fmap (g . h) = fmap g . fmap h

-- ËµÑÊ∫êÂáΩÂ≠ê
newtype Resource a = Resource { runResource :: IO a }

instance Functor Resource where
    fmap f (Resource io) = Resource (fmap f io)

-- Ë∞ÉÂ∫¶ÂáΩÂ≠êÔºöÂ∞ÜÁ±ªÂûãÊò†Â∞ÑÂà∞Ë∞ÉÂ∫¶‰∏ä‰∏ãÊñá
data Scheduled a = Scheduled {
    task :: a,
    priority :: Int,
    resources :: ResourceSpec
}

instance Functor Scheduled where
    fmap f (Scheduled t p r) = Scheduled (f t) p r
```

### 3.2 Ëá™ÁÑ∂ÂèòÊç¢

```haskell
-- Ëá™ÁÑ∂ÂèòÊç¢ÔºöÂáΩÂ≠êÈó¥ÁöÑÊÄÅÂ∞Ñ
type Nat f g = forall a. f a -> g a

-- ‰æãÔºö‰ªéMaybeÂà∞ListÁöÑËá™ÁÑ∂ÂèòÊç¢
maybeToList :: Nat Maybe []
maybeToList Nothing  = []
maybeToList (Just x) = [x]

-- Ë∞ÉÂ∫¶Á≠ñÁï•‰Ωú‰∏∫Ëá™ÁÑ∂ÂèòÊç¢
type SchedulingStrategy = Nat PendingQueue ScheduledQueue

-- FIFOÁ≠ñÁï•
fifoStrategy :: SchedulingStrategy
fifoStrategy = scheduleInOrder

-- ‰ºòÂÖàÁ∫ßÁ≠ñÁï•
priorityStrategy :: SchedulingStrategy
priorityStrategy = scheduleByPriority

-- Ëá™ÁÑ∂ÊÄßÊù°‰ª∂Ôºö
-- scheduleByPriority . fmap f = fmap f . scheduleByPriority
```

### 3.3 Á±ªÂûã-Ë∞ÉÂ∫¶ÂáΩÂ≠ê

```text
Á±ªÂûã-Ë∞ÉÂ∫¶ÂáΩÂ≠ê F: Type ‚Üí Schedule

ÂØπË±°Êò†Â∞Ñ:
  F(Unit) = Idle
  F(Int) = CPU
  F(Bytes) = Memory
  F(A √ó B) = F(A) ‚äó F(B)  (ËµÑÊ∫êÁªÑÂêà)
  F(A ‚Üí B) = F(A) ‚ä∏ F(B)  (ÊúçÂä°Êò†Â∞Ñ)
  F(‚àÄŒ±.T) = Parameterized(F(T))

ÊÄÅÂ∞ÑÊò†Â∞Ñ:
  F(f: A ‚Üí B) = schedule_transform: F(A) ‚Üí F(B)

ÂáΩÂ≠êÂæãÈ™åËØÅ:
  F(id_A) = id_{F(A)}  ‚úì
  F(g ‚àò f) = F(g) ‚àò F(f)  ‚úì
```

---

## 4 Monad‰∏éComonad

### 4.1 MonadÂÆö‰πâ

```haskell
-- MonadÂÆö‰πâ
class Functor m => Monad m where
    return :: a -> m a
    (>>=)  :: m a -> (a -> m b) -> m b

    -- MonadÂæã
    -- return a >>= f  =  f a                  (Â∑¶Âçï‰Ωç)
    -- m >>= return    =  m                    (Âè≥Âçï‰Ωç)
    -- (m >>= f) >>= g =  m >>= (\x -> f x >>= g)  (ÁªìÂêà)

-- ËµÑÊ∫êMonad
data ResourceM a = ResourceM {
    runRM :: ResourcePool -> (a, ResourcePool)
}

instance Monad ResourceM where
    return x = ResourceM (\pool -> (x, pool))
    m >>= f  = ResourceM (\pool ->
        let (a, pool') = runRM m pool
        in runRM (f a) pool')

-- ‰ΩøÁî®ËµÑÊ∫êMonad
allocateAndUse :: ResourceM Result
allocateAndUse = do
    cpu <- allocate CPU 4
    mem <- allocate Memory (2 * GB)
    result <- compute cpu mem
    release cpu
    release mem
    return result
```

### 4.2 Ë∞ÉÂ∫¶Monad

```haskell
-- Ë∞ÉÂ∫¶Monad
newtype ScheduleM a = ScheduleM {
    runSchedule :: Scheduler -> IO (a, ScheduleLog)
}

instance Monad ScheduleM where
    return x = ScheduleM (\_ -> return (x, mempty))
    m >>= f = ScheduleM (\sched -> do
        (a, log1) <- runSchedule m sched
        (b, log2) <- runSchedule (f a) sched
        return (b, log1 <> log2))

-- Ë∞ÉÂ∫¶Êìç‰Ωú
schedule :: Task -> ScheduleM TaskId
schedule task = ScheduleM (\sched -> do
    taskId <- submitTask sched task
    return (taskId, ScheduleLog [Scheduled taskId]))

await :: TaskId -> ScheduleM Result
await taskId = ScheduleM (\sched -> do
    result <- waitForTask sched taskId
    return (result, ScheduleLog [Completed taskId]))

-- ÁªÑÂêàË∞ÉÂ∫¶
pipeline :: ScheduleM FinalResult
pipeline = do
    t1 <- schedule preprocess
    r1 <- await t1
    t2 <- schedule (process r1)
    r2 <- await t2
    t3 <- schedule (postprocess r2)
    await t3
```

### 4.3 Free Monad

```haskell
-- Free Monad for Ë∞ÉÂ∫¶DSL
data ScheduleF next
    = Schedule Task (TaskId -> next)
    | Await TaskId (Result -> next)
    | Allocate ResourceSpec (ResourceHandle -> next)
    | Release ResourceHandle next
    deriving Functor

type Schedule = Free ScheduleF

-- Êô∫ËÉΩÊûÑÈÄ†Âô®
schedule' :: Task -> Schedule TaskId
schedule' task = liftF (Schedule task id)

await' :: TaskId -> Schedule Result
await' tid = liftF (Await tid id)

allocate' :: ResourceSpec -> Schedule ResourceHandle
allocate' spec = liftF (Allocate spec id)

release' :: ResourceHandle -> Schedule ()
release' h = liftF (Release h ())

-- DSLÁ®ãÂ∫è
mySchedule :: Schedule Result
mySchedule = do
    h <- allocate' (CPU 4 <> Memory (2 * GB))
    tid <- schedule' (Task "compute" h)
    result <- await' tid
    release' h
    return result

-- Ëß£ÈáäÂô®1: ÁúüÂÆûË∞ÉÂ∫¶
runReal :: Schedule a -> IO a
runReal = iterM interpret
  where
    interpret (Schedule task next) = do
        tid <- submitToCluster task
        next tid
    interpret (Await tid next) = do
        result <- waitCluster tid
        next result
    interpret (Allocate spec next) = do
        h <- allocateReal spec
        next h
    interpret (Release h next) = do
        releaseReal h
        next

-- Ëß£ÈáäÂô®2: Ê®°ÊãüË∞ÉÂ∫¶
runSimulation :: Schedule a -> Simulation a
runSimulation = iterM interpretSim
```

---

## 5 Ë∞ÉÂ∫¶Á≥ªÁªüÁöÑËåÉÁï¥ËØ≠‰πâ

### 5.1 Ë∞ÉÂ∫¶ËåÉÁï¥

```text
Ë∞ÉÂ∫¶ËåÉÁï¥ Sched:

ÂØπË±°: Á≥ªÁªüÁä∂ÊÄÅ S = (R, Q, A)
  R: ËµÑÊ∫êÁä∂ÊÄÅ
  Q: ÈòüÂàóÁä∂ÊÄÅ
  A: ÂàÜÈÖçÁä∂ÊÄÅ

ÊÄÅÂ∞Ñ: Ë∞ÉÂ∫¶Âä®‰Ωú œÉ: S‚ÇÅ ‚Üí S‚ÇÇ
  schedule: Ë∞ÉÂ∫¶‰Ωú‰∏ö
  preempt: Êä¢Âç†
  migrate: ËøÅÁßª
  scale: Êâ©Áº©ÂÆπ

ÁªÑÂêà: œÉ‚ÇÇ ‚àò œÉ‚ÇÅ = ‰æùÊ¨°ÊâßË°å
ÊÅíÁ≠â: id_S = Êó†Êìç‰Ωú

ËåÉÁï¥Âæã:
  (œÉ‚ÇÉ ‚àò œÉ‚ÇÇ) ‚àò œÉ‚ÇÅ = œÉ‚ÇÉ ‚àò (œÉ‚ÇÇ ‚àò œÉ‚ÇÅ)  (ÁªìÂêàÂæã)
  id ‚àò œÉ = œÉ = œÉ ‚àò id              (Âçï‰ΩçÂæã)
```

### 5.2 Á≠ñÁï•ÂáΩÂ≠ê

```text
Á≠ñÁï•ÂáΩÂ≠ê P: Config ‚Üí Sched

Â∞ÜÈÖçÁΩÆËåÉÁï¥Êò†Â∞ÑÂà∞Ë∞ÉÂ∫¶ËåÉÁï¥:

P(FIFOConfig) = FIFOË∞ÉÂ∫¶Á≠ñÁï•
P(PriorityConfig) = ‰ºòÂÖàÁ∫ßË∞ÉÂ∫¶Á≠ñÁï•
P(FairShareConfig) = ÂÖ¨Âπ≥‰ªΩÈ¢ùÁ≠ñÁï•

ÂáΩÂ≠êÊÄß:
  ÈÖçÁΩÆÁªÑÂêà ‚Üí Á≠ñÁï•ÁªÑÂêà
  P(C‚ÇÅ ‚äï C‚ÇÇ) ‚âÖ P(C‚ÇÅ) √ó P(C‚ÇÇ)
```

### 5.3 Ë∞ÉÂ∫¶MonadËØ≠‰πâ

```text
Ë∞ÉÂ∫¶Monad T: Sched ‚Üí Sched

T(S) = Â∏¶ÊïàÂ∫îÁöÑÁä∂ÊÄÅ
  T(S) = S √ó Effect

unit: S ‚Üí T(S)
  unit(s) = (s, Œµ)  -- Êó†ÊïàÂ∫î

bind: T(S) √ó (S ‚Üí T(S')) ‚Üí T(S')
  (s, e‚ÇÅ) >>= f = let (s', e‚ÇÇ) = f(s) in (s', e‚ÇÅ ¬∑ e‚ÇÇ)

ÊïàÂ∫îÁªÑÂêà:
  e‚ÇÅ ¬∑ e‚ÇÇ = ÊïàÂ∫îÂ∫èÂàó

MonadÂæã‰øùËØÅ:
  - Ë∞ÉÂ∫¶Âä®‰ΩúÂèØÂÆâÂÖ®ÁªÑÂêà
  - ÊïàÂ∫îÊ≠£Á°Æ‰º†Êí≠
  - Áä∂ÊÄÅ‰∏ÄËá¥ÊÄß
```

---

## 6 ÂÆûË∑µÂ∫îÁî®

### 6.1 HaskellË∞ÉÂ∫¶Â∫ì

```haskell
-- ‰ΩøÁî®ËåÉÁï¥ËÆ∫ËÆæËÆ°ÁöÑË∞ÉÂ∫¶Â∫ì
module Scheduler.Category where

import Control.Monad.Free
import Control.Category
import Prelude hiding (id, (.))

-- Ë∞ÉÂ∫¶ËåÉÁï¥
newtype Sched a b = Sched { runSched :: a -> IO b }

instance Category Sched where
    id = Sched return
    Sched f . Sched g = Sched (g >=> f)

-- Ë∞ÉÂ∫¶ÊÄÅÂ∞Ñ
schedule :: Task -> Sched () TaskId
schedule task = Sched (\_ -> submitTask task)

waitComplete :: Sched TaskId Result
waitComplete = Sched waitForCompletion

-- ÁªÑÂêàË∞ÉÂ∫¶
fullPipeline :: Sched () Result
fullPipeline = waitComplete . schedule preprocessTask
           >>> waitComplete . schedule processTask
           >>> waitComplete . schedule postprocessTask

-- ArrowÈ£éÊ†º
instance Arrow Sched where
    arr f = Sched (return . f)
    first (Sched f) = Sched (\(a, c) -> do
        b <- f a
        return (b, c))
```

### 6.2 K8s OperatorËåÉÁï¥

```go
// Go‰∏≠ÁöÑËåÉÁï¥ËÆ∫È£éÊ†ºËÆæËÆ°
package operator

// ÊÄÅÂ∞ÑÔºöReconciler
type Reconciler func(State) (State, error)

// ÁªÑÂêà
func Compose(f, g Reconciler) Reconciler {
    return func(s State) (State, error) {
        s1, err := g(s)
        if err != nil {
            return s, err
        }
        return f(s1)
    }
}

// ÊÅíÁ≠â
func Identity() Reconciler {
    return func(s State) (State, error) {
        return s, nil
    }
}

// Ëá™ÁÑ∂ÂèòÊç¢ÔºöÁ≠ñÁï•ÂàáÊç¢
type StrategyTransform func(OldStrategy) NewStrategy

// Â∫îÁî®
func ApplyTransform(transform StrategyTransform, old OldStrategy) NewStrategy {
    return transform(old)
}
```

---

## 7 Ë∑®ËßÜËßíÈìæÊé•

### 7.1 ÂΩ¢ÂºèËØ≠Ë®ÄËßÜËßíÂÖ≥ËÅî

- [ËåÉÁï¥ËÆ∫ËßÜËßí](./09.1_ËåÉÁï¥ËÆ∫ËßÜËßí.md) - Âü∫Á°ÄËåÉÁï¥ËÆ∫
- [ÊïàÂ∫îÁ≥ªÁªü](../07_ÊïàÂ∫îÁ≥ªÁªü/) - MonadÂ∫îÁî®
- [Á±ªÂûã-Ë∞ÉÂ∫¶ÂêåÊûÑ](../../Á±ªÂûã-Ë∞ÉÂ∫¶ÂêåÊûÑÁêÜËÆ∫.md) - Áªü‰∏ÄÁêÜËÆ∫

### 7.2 Ë∞ÉÂ∫¶ËßÜËßíÂÖ≥ËÅî

| Ë∞ÉÂ∫¶Ê¶ÇÂøµ | ËåÉÁï¥ËÆ∫ÂØπÂ∫î | Êò†Â∞ÑËØ¥Êòé |
|---------|-----------|---------|
| **Ë∞ÉÂ∫¶ÁªÑÂêà** | ÊÄÅÂ∞ÑÁªÑÂêà | Âä®‰ΩúÂ∫èÂàó |
| **Á≠ñÁï•ÂàáÊç¢** | Ëá™ÁÑ∂ÂèòÊç¢ | Â§öÊÄÅÁ≠ñÁï• |
| **ËµÑÊ∫ê‰∏ä‰∏ãÊñá** | Monad | ÊïàÂ∫îÁÆ°ÁêÜ |
| **Áä∂ÊÄÅËßÇÂØü** | Comonad | ÂéÜÂè≤ÊÑüÁü• |

---

## ÂèÇËÄÉËµÑÊ∫ê

1. [Category Theory for Programmers](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/)
2. [Haskell Wiki - Category Theory](https://wiki.haskell.org/Category_theory)
3. [nLab](https://ncatlab.org/)
4. [Applied Category Theory](https://arxiv.org/abs/1809.05923)

---

**ËøîÂõû**: [ÂΩ¢ÂºèÂåñÁêÜËÆ∫‰∏ªÁ¥¢Âºï](./README.md) | [ÂΩ¢ÂºèËØ≠Ë®ÄËßÜËßí‰∏ªÁ¥¢Âºï](../README.md)
