# 7.4 ä»£æ•°æ•ˆåº”ä¸è°ƒåº¦æ§åˆ¶

> **å­ä¸»é¢˜ç¼–å·**: 07.4
> **ä¸»é¢˜**: æ•ˆåº”ç³»ç»Ÿ
> **æœ€åæ›´æ–°**: 2025-12-02
> **æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ

---

## ğŸ“‹ ç›®å½•

- [7.4 ä»£æ•°æ•ˆåº”ä¸è°ƒåº¦æ§åˆ¶](#74-ä»£æ•°æ•ˆåº”ä¸è°ƒåº¦æ§åˆ¶)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 æ ¸å¿ƒæ´å¯Ÿ](#11-æ ¸å¿ƒæ´å¯Ÿ)
    - [1.2 æ•ˆåº”ç³»ç»Ÿç‰¹æ€§](#12-æ•ˆåº”ç³»ç»Ÿç‰¹æ€§)
    - [1.3 å½¢å¼åŒ–å®šä¹‰](#13-å½¢å¼åŒ–å®šä¹‰)
  - [2 æ€ç»´å¯¼å›¾](#2-æ€ç»´å¯¼å›¾)
  - [3 ä»£æ•°æ•ˆåº”ç†è®º](#3-ä»£æ•°æ•ˆåº”ç†è®º)
    - [3.1 æ•ˆåº”ç­¾åå®šä¹‰](#31-æ•ˆåº”ç­¾åå®šä¹‰)
    - [3.2 æ•ˆåº”è¯­ä¹‰](#32-æ•ˆåº”è¯­ä¹‰)
    - [3.3 ç±»å‹ç³»ç»Ÿ](#33-ç±»å‹ç³»ç»Ÿ)
  - [4 æ•ˆåº”å¤„ç†å™¨](#4-æ•ˆåº”å¤„ç†å™¨)
    - [4.1 å¤„ç†å™¨å®šä¹‰](#41-å¤„ç†å™¨å®šä¹‰)
    - [4.2 æ·±æµ…å¤„ç†å™¨](#42-æ·±æµ…å¤„ç†å™¨)
    - [4.3 å¤„ç†å™¨ç»„åˆ](#43-å¤„ç†å™¨ç»„åˆ)
  - [5 è°ƒåº¦æ§åˆ¶æ•ˆåº”](#5-è°ƒåº¦æ§åˆ¶æ•ˆåº”)
    - [5.1 èµ„æºåˆ†é…æ•ˆåº”](#51-èµ„æºåˆ†é…æ•ˆåº”)
    - [5.2 å¹¶å‘æ§åˆ¶æ•ˆåº”](#52-å¹¶å‘æ§åˆ¶æ•ˆåº”)
    - [5.3 çŠ¶æ€ç®¡ç†æ•ˆåº”](#53-çŠ¶æ€ç®¡ç†æ•ˆåº”)
  - [6 å®è·µåº”ç”¨](#6-å®è·µåº”ç”¨)
    - [6.1 K8sæ§åˆ¶å™¨æ•ˆåº”æ¨¡å‹](#61-k8sæ§åˆ¶å™¨æ•ˆåº”æ¨¡å‹)
    - [6.2 Serverlesså‡½æ•°æ•ˆåº”](#62-serverlesså‡½æ•°æ•ˆåº”)
  - [7 çŸ¥è¯†çŸ©é˜µ](#7-çŸ¥è¯†çŸ©é˜µ)
    - [7.1 æ•ˆåº”ç³»ç»Ÿå¯¹æ¯”](#71-æ•ˆåº”ç³»ç»Ÿå¯¹æ¯”)
    - [7.2 æ•ˆåº”-è°ƒåº¦æ˜ å°„](#72-æ•ˆåº”-è°ƒåº¦æ˜ å°„)
  - [8 è·¨è§†è§’é“¾æ¥](#8-è·¨è§†è§’é“¾æ¥)
    - [8.1 å½¢å¼è¯­è¨€è§†è§’å…³è”](#81-å½¢å¼è¯­è¨€è§†è§’å…³è”)
    - [8.2 è°ƒåº¦è§†è§’å…³è”](#82-è°ƒåº¦è§†è§’å…³è”)
  - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)


---

## 1 æ¦‚è¿°

### 1.1 æ ¸å¿ƒæ´å¯Ÿ

ä»£æ•°æ•ˆåº”ï¼ˆAlgebraic Effectsï¼‰æ˜¯ä¸€ç§å¼ºå¤§çš„æ§åˆ¶æµæŠ½è±¡ï¼Œå°†**æ•ˆåº”çš„è§¦å‘**ä¸**æ•ˆåº”çš„å¤„ç†**åˆ†ç¦»ã€‚
åœ¨è°ƒåº¦ç³»ç»Ÿä¸­ï¼Œè¿™ç§åˆ†ç¦»å¯¹åº”äº**è°ƒåº¦è¯·æ±‚**ä¸**è°ƒåº¦ç­–ç•¥**çš„è§£è€¦ã€‚

### 1.2 æ•ˆåº”ç³»ç»Ÿç‰¹æ€§

| ç‰¹æ€§ | æè¿° | è°ƒåº¦å¯¹åº” |
|------|------|---------|
| **æ•ˆåº”å£°æ˜** | å£°æ˜å¯èƒ½çš„å‰¯ä½œç”¨ | å£°æ˜èµ„æºéœ€æ±‚ |
| **æ•ˆåº”è§¦å‘** | performæ“ä½œ | è°ƒåº¦è¯·æ±‚ |
| **æ•ˆåº”å¤„ç†** | handlerå®šä¹‰ | è°ƒåº¦ç­–ç•¥ |
| **æ•ˆåº”ç»„åˆ** | å¤šæ•ˆåº”ç»„åˆ | å¤šç­–ç•¥ç»„åˆ |
| **æ•ˆåº”æ¨æ–­** | ç±»å‹çº§æ•ˆåº”è¿½è¸ª | ä¾èµ–åˆ†æ |

### 1.3 å½¢å¼åŒ–å®šä¹‰

```text
ä»£æ•°æ•ˆåº”ç³»ç»Ÿ E = (Î£, Op, H, âŠ¢)

å…¶ä¸­ï¼š
  Î£: æ•ˆåº”ç­¾åé›†åˆ {Îµâ‚, Îµâ‚‚, ..., Îµâ‚™}
  Op: æ“ä½œé›†åˆ {opâ‚: Aâ‚ â†’ Bâ‚, opâ‚‚: Aâ‚‚ â†’ Bâ‚‚, ...}
  H: å¤„ç†å™¨é›†åˆ {hâ‚, hâ‚‚, ...}
  âŠ¢: ç±»å‹åˆ¤æ–­å…³ç³»

æ•ˆåº”ç±»å‹:
  Ï„ ::= Ï„â‚ â†’ Ï„â‚‚ ! Îµ        -- å¸¦æ•ˆåº”çš„å‡½æ•°ç±»å‹
  Îµ ::= âˆ… | Îµâ‚ âˆª Îµâ‚‚ | {op}  -- æ•ˆåº”é›†åˆ

ç±»å‹è§„åˆ™:
  Î“ âŠ¢ e : Ï„ ! Îµ
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Î“ âŠ¢ perform op(e) : Ï„' ! Îµ âˆª {op}
```

---

## 2 æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((ä»£æ•°æ•ˆåº”))
    æ•ˆåº”å£°æ˜
      effectå…³é”®å­—
      æ“ä½œç­¾å
      æ•ˆåº”å‚æ•°
    æ•ˆåº”è§¦å‘
      perform
      yield
      raise
    æ•ˆåº”å¤„ç†
      handler
        returnåˆ†æ”¯
        æ“ä½œåˆ†æ”¯
      resumeç»§ç»­
      æ·±/æµ…å¤„ç†
    æ•ˆåº”ç»„åˆ
      æ•ˆåº”å¤šæ€
      æ•ˆåº”è¡Œ
      æ•ˆåº”å­ç±»å‹
    è°ƒåº¦æ˜ å°„
      èµ„æºæ•ˆåº”
      çŠ¶æ€æ•ˆåº”
      å¼‚æ­¥æ•ˆåº”
      å¹¶å‘æ•ˆåº”
```

---

## 3 ä»£æ•°æ•ˆåº”ç†è®º

### 3.1 æ•ˆåº”ç­¾åå®šä¹‰

```ocaml
(* OCaml 5.0+ ä»£æ•°æ•ˆåº”ç¤ºä¾‹ *)

(* æ•ˆåº”å£°æ˜ *)
effect Yield : unit
effect Async : 'a promise -> 'a
effect Fork : (unit -> unit) -> unit
effect GetState : 'a
effect SetState : 'a -> unit

(* è°ƒåº¦ç›¸å…³æ•ˆåº” *)
effect Allocate : resource_spec -> resource_handle
effect Release : resource_handle -> unit
effect Schedule : task -> task_id
effect Preempt : task_id -> unit
```

### 3.2 æ•ˆåº”è¯­ä¹‰

```text
æ•ˆåº”æ“ä½œè¯­ä¹‰:

performè§„åˆ™:
  E[perform op v] â†’ E[k] where handler handles op with k

handlerè§„åˆ™:
  handle e with H â†’
    match e with
    | return v â†’ H.return v
    | perform op v k â†’ H.op v (Î»x. handle (k x) with H)

resumeè¯­ä¹‰:
  resume: (Î± â†’ Î²!Îµ) â†’ Î± â†’ Î²!Îµ
  resume k v = k v  -- ç»§ç»­æ‰§è¡Œè¢«æš‚åœçš„è®¡ç®—
```

### 3.3 ç±»å‹ç³»ç»Ÿ

```text
æ•ˆåº”ç±»å‹è§„åˆ™:

(T-Perform)
  Î“ âŠ¢ e : A    op : A â†’ B âˆˆ Î£
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Î“ âŠ¢ perform op e : B ! {op}

(T-Handle)
  Î“ âŠ¢ e : Ï„ ! Îµ âˆª {op}
  Î“ âŠ¢ H : handler(op, Ï„, Ï„')
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Î“ âŠ¢ handle e with H : Ï„' ! Îµ

(T-Return)
  Î“ âŠ¢ e : Ï„ ! âˆ…
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Î“ âŠ¢ return e : Ï„ ! âˆ…

æ•ˆåº”å­ç±»å‹:
  Îµâ‚ âŠ† Îµâ‚‚
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Ï„ ! Îµâ‚ <: Ï„ ! Îµâ‚‚
```

---

## 4 æ•ˆåº”å¤„ç†å™¨

### 4.1 å¤„ç†å™¨å®šä¹‰

```ocaml
(* åŸºæœ¬å¤„ç†å™¨ç»“æ„ *)
type ('a, 'b) handler = {
  return: 'a -> 'b;
  ops: effect_handlers
}

(* çŠ¶æ€æ•ˆåº”å¤„ç†å™¨ *)
let state_handler init = {
  return = (fun x -> fun _s -> x);
  ops = function
    | GetState -> (fun k -> fun s -> k s s)
    | SetState s' -> (fun k -> fun _s -> k () s')
}

(* è°ƒåº¦æ•ˆåº”å¤„ç†å™¨ *)
let scheduler_handler queue = {
  return = (fun x -> x);
  ops = function
    | Yield -> (fun k ->
        Queue.push k queue;
        match Queue.pop queue with
        | Some k' -> k' ()
        | None -> ())
    | Fork f -> (fun k ->
        Queue.push k queue;
        f ())
}
```

### 4.2 æ·±æµ…å¤„ç†å™¨

```text
æ·±å¤„ç†å™¨ (Deep Handler):
  - é€’å½’å¤„ç†æ‰€æœ‰åç»­æ•ˆåº”
  - å¤„ç†å™¨åŒ…è£¹æ•´ä¸ªè®¡ç®—
  - ç±»ä¼¼try-catch

æµ…å¤„ç†å™¨ (Shallow Handler):
  - åªå¤„ç†ä¸€æ¬¡æ•ˆåº”
  - éœ€è¦æ˜¾å¼é‡æ–°å®‰è£…
  - æ›´ç»†ç²’åº¦æ§åˆ¶

æ·±å¤„ç†å™¨è¯­ä¹‰:
  handle^deep e with H =
    match e with
    | return v â†’ H.return v
    | perform op v k â†’
        H.op v (Î»x. handle^deep (k x) with H)

æµ…å¤„ç†å™¨è¯­ä¹‰:
  handle^shallow e with H =
    match e with
    | return v â†’ H.return v
    | perform op v k â†’ H.op v k  -- kä¸åŒ…è£…
```

### 4.3 å¤„ç†å™¨ç»„åˆ

```ocaml
(* å¤„ç†å™¨ç»„åˆ *)
let compose_handlers h1 h2 = {
  return = (fun x -> h2.return (h1.return x));
  ops = (fun eff ->
    try h1.ops eff
    with Unhandled -> h2.ops eff)
}

(* æ•ˆåº”éš§é“ - é€ä¼ æœªå¤„ç†æ•ˆåº” *)
let tunnel_handler handled_effect other_handler = {
  return = other_handler.return;
  ops = function
    | eff when eff = handled_effect ->
        handle_specific eff
    | eff ->
        (* é€ä¼ ç»™å¤–å±‚ *)
        perform eff
}
```

---

## 5 è°ƒåº¦æ§åˆ¶æ•ˆåº”

### 5.1 èµ„æºåˆ†é…æ•ˆåº”

```ocaml
(* èµ„æºæ•ˆåº”å®šä¹‰ *)
effect Allocate : resource_request -> resource_handle
effect Release : resource_handle -> unit
effect Resize : resource_handle * int -> unit

(* èµ„æºçº¦æŸæ•ˆåº” *)
type resource_constraint = {
  cpu_limit: float;
  memory_limit: int;
  gpu_count: int;
}

effect WithConstraint : resource_constraint -> unit

(* èµ„æºè°ƒåº¦å¤„ç†å™¨ *)
let resource_scheduler cluster = {
  return = (fun x -> x);
  ops = function
    | Allocate req -> (fun k ->
        match find_available_node cluster req with
        | Some node ->
            let handle = allocate_on_node node req in
            k handle
        | None ->
            (* æ’é˜Ÿç­‰å¾… *)
            enqueue_request req k)
    | Release handle -> (fun k ->
        deallocate handle;
        (* å”¤é†’ç­‰å¾…çš„è¯·æ±‚ *)
        process_pending_requests cluster;
        k ())
}
```

### 5.2 å¹¶å‘æ§åˆ¶æ•ˆåº”

```ocaml
(* å¹¶å‘æ•ˆåº” *)
effect Spawn : (unit -> 'a) -> 'a fiber
effect Await : 'a fiber -> 'a
effect Yield : unit
effect Cancel : 'a fiber -> unit

(* åä½œå¼è°ƒåº¦å™¨ *)
let cooperative_scheduler () =
  let run_queue = Queue.create () in
  let blocked = Hashtbl.create 16 in

  {
    return = (fun x -> x);
    ops = function
      | Spawn f -> (fun k ->
          let fiber_id = fresh_id () in
          Queue.push (fiber_id, f) run_queue;
          k fiber_id)
      | Await fiber_id -> (fun k ->
          Hashtbl.add blocked fiber_id k;
          schedule_next run_queue)
      | Yield -> (fun k ->
          Queue.push (current_fiber (), k) run_queue;
          schedule_next run_queue)
      | Cancel fiber_id -> (fun k ->
          remove_fiber fiber_id;
          k ())
  }

(* æŠ¢å å¼è°ƒåº¦å™¨ *)
let preemptive_scheduler time_slice =
  effect TimeSliceExpired : unit

  {
    return = (fun x -> x);
    ops = function
      | TimeSliceExpired -> (fun k ->
          Queue.push k run_queue;
          schedule_next run_queue)
      | other -> cooperative_scheduler().ops other
  }
```

### 5.3 çŠ¶æ€ç®¡ç†æ•ˆåº”

```ocaml
(* çŠ¶æ€æ•ˆåº” *)
effect Get : 'a
effect Put : 'a -> unit
effect Modify : ('a -> 'a) -> unit

(* åˆ†å¸ƒå¼çŠ¶æ€æ•ˆåº” *)
effect DistGet : key -> value option
effect DistPut : key * value -> unit
effect DistCAS : key * value * value -> bool

(* StatefulSetçŠ¶æ€å¤„ç†å™¨ *)
let statefulset_handler etcd_client = {
  return = (fun x -> x);
  ops = function
    | DistGet key -> (fun k ->
        let value = Etcd.get etcd_client key in
        k value)
    | DistPut (key, value) -> (fun k ->
        Etcd.put etcd_client key value;
        k ())
    | DistCAS (key, expected, new_val) -> (fun k ->
        let success = Etcd.cas etcd_client key expected new_val in
        k success)
}
```

---

## 6 å®è·µåº”ç”¨

### 6.1 K8sæ§åˆ¶å™¨æ•ˆåº”æ¨¡å‹

```ocaml
(* K8sæ§åˆ¶å™¨æ•ˆåº” *)
effect Watch : resource_type -> resource_event stream
effect Create : resource -> resource
effect Update : resource -> resource
effect Delete : resource -> unit
effect GetStatus : resource -> status

(* Reconcileræ•ˆåº”å¤„ç†å™¨ *)
let reconciler_handler api_client = {
  return = (fun x -> x);
  ops = function
    | Watch res_type -> (fun k ->
        let stream = Api.watch api_client res_type in
        k stream)
    | Create res -> (fun k ->
        let created = Api.create api_client res in
        k created)
    | Update res -> (fun k ->
        let updated = Api.update api_client res in
        k updated)
    | Delete res -> (fun k ->
        Api.delete api_client res;
        k ())
}

(* ä½¿ç”¨æ•ˆåº”çš„æ§åˆ¶å™¨ *)
let deployment_controller () =
  let events = perform (Watch Deployment) in
  Stream.iter (fun event ->
    match event with
    | Added dep -> reconcile_deployment dep
    | Modified dep -> reconcile_deployment dep
    | Deleted dep -> cleanup_deployment dep
  ) events

and reconcile_deployment dep =
  let current_replicas = perform (GetStatus dep) in
  let desired = dep.spec.replicas in
  if current_replicas < desired then
    for _ = 1 to (desired - current_replicas) do
      let pod = create_pod_spec dep in
      perform (Create pod)
    done
  else if current_replicas > desired then
    (* ç¼©å®¹é€»è¾‘ *)
    scale_down dep (current_replicas - desired)
```

### 6.2 Serverlesså‡½æ•°æ•ˆåº”

```ocaml
(* Serverlessæ•ˆåº” *)
effect Invoke : function_name * input -> output
effect Sleep : duration -> unit
effect Log : string -> unit
effect GetSecret : secret_name -> string

(* å†·å¯åŠ¨ä¼˜åŒ–å¤„ç†å™¨ *)
let serverless_handler pool = {
  return = (fun x -> x);
  ops = function
    | Invoke (fname, input) -> (fun k ->
        match Pool.get_warm pool fname with
        | Some instance ->
            let result = Instance.invoke instance input in
            k result
        | None ->
            (* å†·å¯åŠ¨ *)
            let instance = Pool.cold_start pool fname in
            let result = Instance.invoke instance input in
            Pool.keep_warm pool fname instance;
            k result)
    | Sleep duration -> (fun k ->
        (* æŒ‚èµ·å‡½æ•°ï¼Œé‡Šæ”¾èµ„æº *)
        suspend_function duration k)
}
```

---

## 7 çŸ¥è¯†çŸ©é˜µ

### 7.1 æ•ˆåº”ç³»ç»Ÿå¯¹æ¯”

| è¯­è¨€/ç³»ç»Ÿ | æ•ˆåº”ç±»å‹ | å¤„ç†å™¨ | ç»„åˆæ€§ | æ€§èƒ½ |
|---------|---------|-------|-------|------|
| **OCaml 5** | ä»£æ•°æ•ˆåº” | æ·±/æµ… | é«˜ | é«˜ |
| **Koka** | è¡Œå¤šæ€æ•ˆåº” | æ·± | é«˜ | ä¸­ |
| **Eff** | ä»£æ•°æ•ˆåº” | æ·± | é«˜ | ä½ |
| **Haskell** | Monad | Transformer | ä¸­ | ä¸­ |
| **Rust** | async/await | è¿è¡Œæ—¶ | ä¸­ | é«˜ |

### 7.2 æ•ˆåº”-è°ƒåº¦æ˜ å°„

| æ•ˆåº”ç±»å‹ | è°ƒåº¦æ¦‚å¿µ | K8så¯¹åº” |
|---------|---------|---------|
| **State** | æœ‰çŠ¶æ€è°ƒåº¦ | StatefulSet |
| **Async** | å¼‚æ­¥è°ƒåº¦ | Job/CronJob |
| **Resource** | èµ„æºè°ƒåº¦ | ResourceQuota |
| **Concurrency** | å¹¶å‘æ§åˆ¶ | HPA |
| **Error** | æ•…éšœå¤„ç† | Restart Policy |

---

## 8 è·¨è§†è§’é“¾æ¥

### 8.1 å½¢å¼è¯­è¨€è§†è§’å…³è”

- [æ•ˆåº”ç®¡ç†åŸºç¡€](./07.1_æ•ˆåº”ç®¡ç†åŸºç¡€.md) - æ•ˆåº”ç†è®ºåŸºç¡€
- [Monadicè®¡ç®—](./07.3_StatefulSetä¸Monadicè®¡ç®—.md) - Monadä¸æ•ˆåº”
- [èŒƒç•´è®ºè§†è§’](../09_å½¢å¼åŒ–ç†è®º/09.1_èŒƒç•´è®ºè§†è§’.md) - æ•ˆåº”çš„èŒƒç•´è¯­ä¹‰

### 8.2 è°ƒåº¦è§†è§’å…³è”

| è°ƒåº¦æ¦‚å¿µ | æ•ˆåº”å¯¹åº” | æ˜ å°„è¯´æ˜ |
|---------|---------|---------|
| **è°ƒåº¦è¯·æ±‚** | perform | è§¦å‘è°ƒåº¦æ•ˆåº” |
| **è°ƒåº¦ç­–ç•¥** | handler | å®šä¹‰è°ƒåº¦è¡Œä¸º |
| **çŠ¶æ€ç®¡ç†** | Stateæ•ˆåº” | åˆ†å¸ƒå¼çŠ¶æ€ |
| **å¹¶å‘æ§åˆ¶** | Concurrencyæ•ˆåº” | å¹¶è¡Œè°ƒåº¦ |

---

## å‚è€ƒèµ„æº

1. [Algebraic Effects for the Rest of Us](https://overreacted.io/algebraic-effects-for-the-rest-of-us/)
2. [OCaml 5 Effect Handlers](https://v2.ocaml.org/manual/effects.html)
3. [Koka Language](https://koka-lang.github.io/)
4. [Eff Programming Language](https://www.eff-lang.org/)

---

**è¿”å›**: [æ•ˆåº”ç³»ç»Ÿä¸»ç´¢å¼•](./README.md) | [å½¢å¼è¯­è¨€è§†è§’ä¸»ç´¢å¼•](../README.md)
