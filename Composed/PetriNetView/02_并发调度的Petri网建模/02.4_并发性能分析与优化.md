# 02.4 å¹¶å‘æ€§èƒ½åˆ†æä¸ä¼˜åŒ–

> **å­ä¸»é¢˜**: 02.4
> **æ‰€å±ä¸»é¢˜**: 02 å¹¶å‘è°ƒåº¦çš„Petriç½‘å»ºæ¨¡
> **æœ€åæ›´æ–°**: 2025-12-02

---

## ğŸ“‹ ç›®å½•

- [02.4 å¹¶å‘æ€§èƒ½åˆ†æä¸ä¼˜åŒ–](#024-å¹¶å‘æ€§èƒ½åˆ†æä¸ä¼˜åŒ–)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 Amdahlå®šå¾‹çš„Petriç½‘è§†è§’](#1-amdahlå®šå¾‹çš„petriç½‘è§†è§’)
  - [2 å¹¶å‘ç“¶é¢ˆè¯†åˆ«](#2-å¹¶å‘ç“¶é¢ˆè¯†åˆ«)
  - [3 å¹¶å‘ä¼˜åŒ–ç­–ç•¥](#3-å¹¶å‘ä¼˜åŒ–ç­–ç•¥)
  - [4 å®é™…æ¡ˆä¾‹ï¼šå¤šæ ¸CPUä»»åŠ¡è°ƒåº¦ä¼˜åŒ–](#4-å®é™…æ¡ˆä¾‹å¤šæ ¸cpuä»»åŠ¡è°ƒåº¦ä¼˜åŒ–)

---

## 1 Amdahlå®šå¾‹çš„Petriç½‘è§†è§’

**Amdahlå®šå¾‹**ï¼š

$$
\text{Speedup} = \frac{1}{(1-p) + \frac{p}{n}}
$$

å…¶ä¸­ $p$ æ˜¯å¯å¹¶è¡Œéƒ¨åˆ†æ¯”ä¾‹ï¼Œ$n$ æ˜¯å¹¶è¡Œåº¦ã€‚

**Petriç½‘è¡¨ç¤º**ï¼š

- **ä¸²è¡Œéƒ¨åˆ†**ï¼šé¡ºåºå˜è¿é“¾
- **å¹¶è¡Œéƒ¨åˆ†**ï¼šå¹¶è¡Œå˜è¿
- **å¹¶è¡Œåº¦** $n$ï¼šæœ€å¤§åŒæ—¶ä½¿èƒ½çš„å˜è¿æ•°

**Pythonåˆ†æ**ï¼š

```python
def analyze_amdahl_law(pn, M0):
    """
    åŸºäºPetriç½‘åˆ†æAmdahlå®šå¾‹
    """
    # è¯†åˆ«ä¸²è¡Œå’Œå¹¶è¡Œéƒ¨åˆ†
    RG = construct_reachability_graph(pn, M0)

    total_transitions = len(pn.transitions)
    max_concurrent = 0

    for M in RG.nodes():
        enabled = [t for t in pn.transitions if is_enabled(pn, M, t)]
        max_concurrent = max(max_concurrent, len(enabled))

    # ä¼°ç®—å¯å¹¶è¡Œæ¯”ä¾‹
    parallel_ratio = max_concurrent / total_transitions

    # è®¡ç®—ç†è®ºåŠ é€Ÿæ¯”
    speedups = {}
    for n in [1, 2, 4, 8, 16]:
        speedup = 1 / ((1 - parallel_ratio) + parallel_ratio / n)
        speedups[n] = speedup

    return {
        'parallel_ratio': parallel_ratio,
        'max_concurrent': max_concurrent,
        'speedups': speedups
    }

# ä½¿ç”¨ç¤ºä¾‹
results = analyze_amdahl_law(pn, initial_marking)
print(f"å¹¶è¡Œéƒ¨åˆ†æ¯”ä¾‹: {results['parallel_ratio']:.2%}")
print(f"ç†è®ºåŠ é€Ÿæ¯”ï¼š")
for cores, speedup in results['speedups'].items():
    print(f"  {cores}æ ¸: {speedup:.2f}x")
```

---

## 2 å¹¶å‘ç“¶é¢ˆè¯†åˆ«

**ç“¶é¢ˆå®šä¹‰**ï¼šé™åˆ¶å¹¶å‘åº¦çš„å…³é”®èµ„æºæˆ–åŒæ­¥ç‚¹ã€‚

**è¯†åˆ«æ–¹æ³•**ï¼š

```python
def identify_concurrency_bottleneck(pn, M0):
    """
    è¯†åˆ«å¹¶å‘ç“¶é¢ˆ

    Returns:
        ç“¶é¢ˆåº“æ‰€å’Œå˜è¿åˆ—è¡¨
    """
    RG = construct_reachability_graph(pn, M0)

    # ç»Ÿè®¡æ¯ä¸ªåº“æ‰€çš„å¹³å‡æ ‡è®°æ•°
    place_utilization = {p: 0 for p in pn.places}

    for M in RG.nodes():
        for p in pn.places:
            place_utilization[p] += M[p]

    for p in pn.places:
        place_utilization[p] /= len(RG.nodes())

    # è¯†åˆ«ç“¶é¢ˆï¼ˆæ ‡è®°æ•°æœ€å°‘çš„èµ„æºåº“æ‰€ï¼‰
    resource_places = [p for p in pn.places if 'resource' in p or 'cpu' in p]
    bottleneck_places = sorted(resource_places, key=lambda p: place_utilization[p])[:3]

    # è¯†åˆ«ç“¶é¢ˆå˜è¿ï¼ˆç‚¹ç«é¢‘ç‡æœ€ä½çš„ï¼‰
    transition_firings = {t: 0 for t in pn.transitions}

    for M in RG.nodes():
        for t in pn.transitions:
            if is_enabled(pn, M, t):
                transition_firings[t] += 1

    bottleneck_transitions = sorted(self.pn.transitions,
                                     key=lambda t: transition_firings[t])[:3]

    return {
        'bottleneck_places': bottleneck_places,
        'bottleneck_transitions': bottleneck_transitions,
        'place_utilization': place_utilization,
        'transition_firings': transition_firings
    }

# ä½¿ç”¨ç¤ºä¾‹
bottlenecks = identify_concurrency_bottleneck(pn, initial_marking)
print("å¹¶å‘ç“¶é¢ˆåˆ†æï¼š")
print(f"  ç“¶é¢ˆåº“æ‰€: {bottlenecks['bottleneck_places']}")
print(f"  ç“¶é¢ˆå˜è¿: {bottlenecks['bottleneck_transitions']}")
```

---

## 3 å¹¶å‘ä¼˜åŒ–ç­–ç•¥

**ä¼˜åŒ–ç­–ç•¥æ¸…å•**ï¼š

1. **å¢åŠ èµ„æº**ï¼šå¢åŠ ç“¶é¢ˆåº“æ‰€çš„æ ‡è®°æ•°
2. **ä»»åŠ¡é‡ç»„**ï¼šå‡å°‘ä¾èµ–ï¼Œå¢åŠ ç‹¬ç«‹ä»»åŠ¡
3. **æµæ°´çº¿åŒ–**ï¼šå°†é¡ºåºä»»åŠ¡è½¬æ¢ä¸ºæµæ°´çº¿
4. **ç¼“å†²ä¼˜åŒ–**ï¼šå¢åŠ ä¸­é—´ç¼“å†²åº“æ‰€

**Pythonä¼˜åŒ–å·¥å…·**ï¼š

```python
class ConcurrencyOptimizer:
    """å¹¶å‘ä¼˜åŒ–å™¨"""

    def __init__(self, pn, M0):
        self.pn = pn
        self.M0 = M0

    def suggest_optimizations(self):
        """å»ºè®®ä¼˜åŒ–æ–¹æ¡ˆ"""
        bottlenecks = identify_concurrency_bottleneck(self.pn, self.M0)
        suggestions = []

        # å»ºè®®1ï¼šå¢åŠ ç“¶é¢ˆèµ„æº
        for p in bottlenecks['bottleneck_places']:
            current_tokens = self.M0[p]
            suggested_tokens = current_tokens * 2
            suggestions.append({
                'type': 'increase_resource',
                'place': p,
                'current': current_tokens,
                'suggested': suggested_tokens,
                'expected_improvement': '50% concurrency increase'
            })

        # å»ºè®®2ï¼šä»»åŠ¡é‡ç»„
        # åˆ†æä»»åŠ¡ä¾èµ–ï¼Œå»ºè®®å‡å°‘ä¸å¿…è¦çš„ä¾èµ–

        return suggestions

    def apply_optimization(self, optimization):
        """åº”ç”¨ä¼˜åŒ–"""
        if optimization['type'] == 'increase_resource':
            place = optimization['place']
            self.M0[place] = optimization['suggested']
            print(f"ä¼˜åŒ–ï¼š{place}èµ„æºä»{optimization['current']}å¢åŠ åˆ°{optimization['suggested']}")

# ä½¿ç”¨ä¼˜åŒ–å™¨
optimizer = ConcurrencyOptimizer(pn, initial_marking)
suggestions = optimizer.suggest_optimizations()

print("å¹¶å‘ä¼˜åŒ–å»ºè®®ï¼š")
for i, sug in enumerate(suggestions, 1):
    print(f"  {i}. {sug['type']}: {sug['place']}")
    print(f"     å½“å‰: {sug['current']}, å»ºè®®: {sug['suggested']}")
    print(f"     é¢„æœŸæå‡: {sug['expected_improvement']}")
```

---

## 4 å®é™…æ¡ˆä¾‹ï¼šå¤šæ ¸CPUä»»åŠ¡è°ƒåº¦ä¼˜åŒ–

**ä¼˜åŒ–å‰åå¯¹æ¯”**ï¼š

```python
# ä¼˜åŒ–å‰ï¼š2æ ¸CPUï¼Œ8ä¸ªä»»åŠ¡
pn_before = create_multicore_scheduling(num_cores=2, tasks=[f'T{i}' for i in range(1, 9)])
analyzer_before = ConcurrencyAnalyzer(pn_before, pn_before.marking)
results_before = analyzer_before.analyze()

print("ä¼˜åŒ–å‰ï¼š")
print(f"  CPUæ ¸å¿ƒæ•°: 2")
print(f"  æœ€å¤§å¹¶å‘: {results_before['static_concurrency']}")
print(f"  å¹¶è¡Œåº¦: {results_before['parallelism_metrics']['parallelism_ratio']:.2%}")

# ä¼˜åŒ–åï¼š4æ ¸CPU
pn_after = create_multicore_scheduling(num_cores=4, tasks=[f'T{i}' for i in range(1, 9)])
analyzer_after = ConcurrencyAnalyzer(pn_after, pn_after.marking)
results_after = analyzer_after.analyze()

print("\nä¼˜åŒ–åï¼š")
print(f"  CPUæ ¸å¿ƒæ•°: 4")
print(f"  æœ€å¤§å¹¶å‘: {results_after['static_concurrency']}")
print(f"  å¹¶è¡Œåº¦: {results_after['parallelism_metrics']['parallelism_ratio']:.2%}")

# æ€§èƒ½æå‡
improvement = (results_after['parallelism_metrics']['theoretical_speedup'] /
               results_before['parallelism_metrics']['theoretical_speedup'] - 1) * 100
print(f"\næ€§èƒ½æå‡: {improvement:.1f}%")
```

---

**è¿”å›**: [02 å¹¶å‘è°ƒåº¦çš„Petriç½‘å»ºæ¨¡](README.md)
