# 02.3 å†²çªæ£€æµ‹ä¸è§£å†³ç­–ç•¥

> **å­ä¸»é¢˜**: 02.3
> **æ‰€å±ä¸»é¢˜**: 02 å¹¶å‘è°ƒåº¦çš„Petriç½‘å»ºæ¨¡
> **æœ€åæ›´æ–°**: 2025-12-02

---

## ğŸ“‹ ç›®å½•

- [02.3 å†²çªæ£€æµ‹ä¸è§£å†³ç­–ç•¥](#023-å†²çªæ£€æµ‹ä¸è§£å†³ç­–ç•¥)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 å†²çªçš„å½¢å¼åŒ–å®šä¹‰](#1-å†²çªçš„å½¢å¼åŒ–å®šä¹‰)
  - [2 ç»“æ„å†²çªvs.æœ‰æ•ˆå†²çª](#2-ç»“æ„å†²çªvsæœ‰æ•ˆå†²çª)
  - [3 å†²çªæ£€æµ‹ç®—æ³•](#3-å†²çªæ£€æµ‹ç®—æ³•)
  - [4 å†²çªè§£å†³ç­–ç•¥](#4-å†²çªè§£å†³ç­–ç•¥)
    - [4.1 ä¼˜å…ˆçº§ç­–ç•¥](#41-ä¼˜å…ˆçº§ç­–ç•¥)
    - [4.2 å…¬å¹³ç­–ç•¥ï¼ˆRound Robinï¼‰](#42-å…¬å¹³ç­–ç•¥round-robin)
    - [4.3 éšæœºç­–ç•¥](#43-éšæœºç­–ç•¥)
    - [4.4 å®ˆå«ç­–ç•¥ï¼ˆColored Petri Netsï¼‰](#44-å®ˆå«ç­–ç•¥colored-petri-nets)
  - [5 CPN Toolså®è·µ](#5-cpn-toolså®è·µ)
  - [6 å®é™…æ¡ˆä¾‹ï¼šæ•°æ®åº“äº‹åŠ¡å¹¶å‘æ§åˆ¶](#6-å®é™…æ¡ˆä¾‹æ•°æ®åº“äº‹åŠ¡å¹¶å‘æ§åˆ¶)

---

## 1 å†²çªçš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰2.31ï¼ˆç»“æ„å†²çªï¼‰**ï¼š

ä¸¤ä¸ªå˜è¿ $t_1, t_2$ **ç»“æ„å†²çª**ï¼Œå¦‚æœå®ƒä»¬å…±äº«è‡³å°‘ä¸€ä¸ªè¾“å…¥åº“æ‰€ï¼š

$$
\bullet t_1 \cap \bullet t_2 \neq \emptyset
$$

**å®šä¹‰2.32ï¼ˆæœ‰æ•ˆå†²çªï¼‰**ï¼š

åœ¨æ ‡è®° $M$ ä¸‹ï¼Œ$t_1, t_2$ **æœ‰æ•ˆå†²çª**ï¼Œå¦‚æœï¼š

1. ä¸¤è€…éƒ½ä½¿èƒ½ï¼š$M[t_1\rangle$ ä¸” $M[t_2\rangle$
2. å…±äº«è¾“å…¥åº“æ‰€çš„æ ‡è®°ä¸è¶³ä»¥åŒæ—¶ç‚¹ç«

$$
\exists p \in \bullet t_1 \cap \bullet t_2: M(p) < W(p, t_1) + W(p, t_2)
$$

---

## 2 ç»“æ„å†²çªvs.æœ‰æ•ˆå†²çª

**Pythonå®ç°**ï¼š

```python
def detect_structural_conflict(pn, t1, t2):
    """æ£€æµ‹ç»“æ„å†²çª"""
    input_t1 = {p for p in pn.places if (p, t1) in pn.arcs}
    input_t2 = {p for p in pn.places if (p, t2) in pn.arcs}
    return bool(input_t1 & input_t2)

def detect_effective_conflict(pn, M, t1, t2):
    """æ£€æµ‹æœ‰æ•ˆå†²çª"""
    if not (is_enabled(pn, M, t1) and is_enabled(pn, M, t2)):
        return False

    input_t1 = {p for p in pn.places if (p, t1) in pn.arcs}
    input_t2 = {p for p in pn.places if (p, t2) in pn.arcs}
    shared = input_t1 & input_t2

    for p in shared:
        required = pn.arcs.get((p, t1), 0) + pn.arcs.get((p, t2), 0)
        if M[p] < required:
            return True

    return False
```

---

## 3 å†²çªæ£€æµ‹ç®—æ³•

**å®Œæ•´çš„å†²çªæ£€æµ‹å™¨**ï¼š

```python
class ConflictDetector:
    """Petriç½‘å†²çªæ£€æµ‹å™¨"""

    def __init__(self, pn):
        self.pn = pn
        self.structural_conflicts = self._compute_structural_conflicts()

    def _compute_structural_conflicts(self):
        """é¢„è®¡ç®—æ‰€æœ‰ç»“æ„å†²çªå¯¹"""
        conflicts = []
        transitions = list(self.pn.transitions)

        for i, t1 in enumerate(transitions):
            for t2 in transitions[i+1:]:
                if detect_structural_conflict(self.pn, t1, t2):
                    conflicts.append((t1, t2))

        return conflicts

    def get_conflicts_at_marking(self, M):
        """è·å–å½“å‰æ ‡è®°ä¸‹çš„æœ‰æ•ˆå†²çª"""
        effective_conflicts = []

        for t1, t2 in self.structural_conflicts:
            if detect_effective_conflict(self.pn, M, t1, t2):
                effective_conflicts.append((t1, t2))

        return effective_conflicts

    def visualize_conflicts(self):
        """å¯è§†åŒ–å†²çªå…³ç³»"""
        import networkx as nx
        import matplotlib.pyplot as plt

        G = nx.Graph()
        G.add_nodes_from(self.pn.transitions)
        G.add_edges_from(self.structural_conflicts)

        pos = nx.spring_layout(G)
        nx.draw(G, pos, with_labels=True, node_color='lightblue',
                node_size=800, font_size=10)
        plt.title("Transition Conflict Graph")
        plt.show()

# ä½¿ç”¨ç¤ºä¾‹
detector = ConflictDetector(pn)
print(f"Structural conflicts: {len(detector.structural_conflicts)}")
conflicts = detector.get_conflicts_at_marking(current_marking)
print(f"Effective conflicts at current state: {len(conflicts)}")
```

---

## 4 å†²çªè§£å†³ç­–ç•¥

**å››ç§ä¸»è¦ç­–ç•¥**ï¼š

### 4.1 ä¼˜å…ˆçº§ç­–ç•¥

```python
class PriorityConflictResolver:
    """åŸºäºä¼˜å…ˆçº§çš„å†²çªè§£å†³"""

    def __init__(self, priorities):
        self.priorities = priorities  # {transition: priority}

    def resolve(self, pn, M, conflict_set):
        """é€‰æ‹©ä¼˜å…ˆçº§æœ€é«˜çš„å˜è¿"""
        enabled = [t for t in conflict_set if is_enabled(pn, M, t)]
        if not enabled:
            return None
        return max(enabled, key=lambda t: self.priorities.get(t, 0))
```

### 4.2 å…¬å¹³ç­–ç•¥ï¼ˆRound Robinï¼‰

```python
class FairConflictResolver:
    """å…¬å¹³å†²çªè§£å†³ï¼ˆè½®è¯¢ï¼‰"""

    def __init__(self):
        self.fire_count = {}

    def resolve(self, pn, M, conflict_set):
        """é€‰æ‹©ç‚¹ç«æ¬¡æ•°æœ€å°‘çš„å˜è¿"""
        enabled = [t for t in conflict_set if is_enabled(pn, M, t)]
        if not enabled:
            return None

        # é€‰æ‹©ç‚¹ç«æ¬¡æ•°æœ€å°‘çš„
        min_fires = min(self.fire_count.get(t, 0) for t in enabled)
        candidates = [t for t in enabled if self.fire_count.get(t, 0) == min_fires]

        selected = candidates[0]
        self.fire_count[selected] = self.fire_count.get(selected, 0) + 1
        return selected
```

### 4.3 éšæœºç­–ç•¥

```python
class RandomConflictResolver:
    """éšæœºå†²çªè§£å†³"""

    def resolve(self, pn, M, conflict_set):
        import random
        enabled = [t for t in conflict_set if is_enabled(pn, M, t)]
        return random.choice(enabled) if enabled else None
```

### 4.4 å®ˆå«ç­–ç•¥ï¼ˆColored Petri Netsï¼‰

```python
class GuardedConflictResolver:
    """åŸºäºå®ˆå«æ¡ä»¶çš„å†²çªè§£å†³"""

    def __init__(self, guards):
        self.guards = guards  # {transition: guard_function}

    def resolve(self, pn, M, conflict_set, context):
        """é€‰æ‹©å®ˆå«æ¡ä»¶ä¸ºçœŸçš„å˜è¿"""
        enabled = [t for t in conflict_set if is_enabled(pn, M, t)]

        for t in enabled:
            if t in self.guards:
                if self.guards[t](M, context):
                    return t

        return enabled[0] if enabled else None
```

---

## 5 CPN Toolså®è·µ

**CPN MLä»£ç ç¤ºä¾‹**ï¼š

```sml
(* ç€è‰²Petriç½‘ä¸­çš„å†²çªè§£å†³ *)
colset TaskID = int;
colset Priority = int timed;

var task : TaskID;
var prio : Priority;

(* èµ„æºåº“æ‰€ *)
place CPU : INT;

(* ä»»åŠ¡åº“æ‰€ï¼ˆå¸¦ä¼˜å…ˆçº§ï¼‰*)
place TaskQueue : Priority;

(* è°ƒåº¦å˜è¿ï¼ˆå¸¦å®ˆå«ï¼‰ *)
trans Schedule
  in   TaskQueue 1`prio
  out  CPU 1`task
  guard prio > 5;  (* åªè°ƒåº¦é«˜ä¼˜å…ˆçº§ä»»åŠ¡ *)
```

---

## 6 å®é™…æ¡ˆä¾‹ï¼šæ•°æ®åº“äº‹åŠ¡å¹¶å‘æ§åˆ¶

**åœºæ™¯**ï¼šå¤šä¸ªäº‹åŠ¡ç«äº‰æ•°æ®åº“é”

```python
def create_database_transaction_petri_net():
    """
    æ•°æ®åº“äº‹åŠ¡å¹¶å‘æ§åˆ¶Petriç½‘æ¨¡å‹

    åœºæ™¯ï¼š
    - 3ä¸ªäº‹åŠ¡ï¼ˆT1ã€T2ã€T3ï¼‰
    - 2ä¸ªæ•°æ®é¡¹é”ï¼ˆLock_Aã€Lock_Bï¼‰
    - äº‹åŠ¡éœ€è¦è·å–é”æ‰èƒ½æ‰§è¡Œ
    """
    pn = PetriNet()

    # é”èµ„æº
    pn.add_place('p_lock_A', tokens=1)
    pn.add_place('p_lock_B', tokens=1)

    transactions = ['T1', 'T2', 'T3']
    lock_requirements = {
        'T1': ['lock_A'],
        'T2': ['lock_B'],
        'T3': ['lock_A', 'lock_B']  # éœ€è¦ä¸¤ä¸ªé”
    }

    for trans in transactions:
        # äº‹åŠ¡å°±ç»ª
        pn.add_place(f'p_{trans}_ready', tokens=1)

        # è·å–é”å˜è¿
        pn.add_transition(f't_{trans}_acquire')
        pn.add_arc(f'p_{trans}_ready', f't_{trans}_acquire')

        for lock in lock_requirements[trans]:
            pn.add_arc(f'p_{lock}', f't_{trans}_acquire')

        # äº‹åŠ¡æ‰§è¡Œ
        pn.add_place(f'p_{trans}_executing', tokens=0)
        pn.add_arc(f't_{trans}_acquire', f'p_{trans}_executing')

        # é‡Šæ”¾é”å˜è¿
        pn.add_transition(f't_{trans}_release')
        pn.add_arc(f'p_{trans}_executing', f't_{trans}_release')

        for lock in lock_requirements[trans]:
            pn.add_arc(f't_{trans}_release', f'p_{lock}')

        # äº‹åŠ¡å®Œæˆ
        pn.add_place(f'p_{trans}_completed', tokens=0)
        pn.add_arc(f't_{trans}_release', f'p_{trans}_completed')

    return pn

# åˆ†æå†²çª
db_pn = create_database_transaction_petri_net()
detector = ConflictDetector(db_pn)

print("æ•°æ®åº“äº‹åŠ¡å†²çªåˆ†æï¼š")
print(f"  ç»“æ„å†²çªå¯¹æ•°ï¼š{len(detector.structural_conflicts)}")
print(f"  å†²çªè¯¦æƒ…ï¼š{detector.structural_conflicts}")

# æ¨¡æ‹Ÿæ‰§è¡Œï¼ˆå¸¦å†²çªè§£å†³ï¼‰
resolver = PriorityConflictResolver({'t_T1_acquire': 3, 't_T2_acquire': 2, 't_T3_acquire': 1})

current_M = db_pn.marking
enabled = [t for t in db_pn.transitions if is_enabled(db_pn, current_M, t)]
if enabled:
    selected = resolver.resolve(db_pn, current_M, enabled)
    print(f"é€‰æ‹©æ‰§è¡Œï¼š{selected}ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰")
```

---

**è¿”å›**: [02 å¹¶å‘è°ƒåº¦çš„Petriç½‘å»ºæ¨¡](README.md)
