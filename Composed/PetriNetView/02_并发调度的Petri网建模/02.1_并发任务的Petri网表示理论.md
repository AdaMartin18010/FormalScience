# 02.1 å¹¶å‘ä»»åŠ¡çš„Petriç½‘è¡¨ç¤ºç†è®º

> **å­ä¸»é¢˜**: 02.1
> **æ‰€å±ä¸»é¢˜**: 02 å¹¶å‘è°ƒåº¦çš„Petriç½‘å»ºæ¨¡
> **æœ€åæ›´æ–°**: 2025-12-02
> **æ–‡æ¡£çŠ¶æ€**: âœ… æ–°å¢

---

## ğŸ“‹ ç›®å½•

- [02.1 å¹¶å‘ä»»åŠ¡çš„Petriç½‘è¡¨ç¤ºç†è®º](#021-å¹¶å‘ä»»åŠ¡çš„petriç½‘è¡¨ç¤ºç†è®º)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 å¹¶å‘çš„åŸºæœ¬æ¦‚å¿µ](#1-å¹¶å‘çš„åŸºæœ¬æ¦‚å¿µ)
  - [2 å¹¶å‘åº¦çš„å½¢å¼åŒ–å®šä¹‰](#2-å¹¶å‘åº¦çš„å½¢å¼åŒ–å®šä¹‰)
    - [2.1 é™æ€å¹¶å‘åº¦](#21-é™æ€å¹¶å‘åº¦)
    - [2.2 åŠ¨æ€å¹¶å‘åº¦](#22-åŠ¨æ€å¹¶å‘åº¦)
    - [2.3 æœ€å¤§å¹¶å‘åº¦è®¡ç®—](#23-æœ€å¤§å¹¶å‘åº¦è®¡ç®—)
  - [3 å¹¶å‘ä»»åŠ¡çš„ç‹¬ç«‹æ€§åˆ†æ](#3-å¹¶å‘ä»»åŠ¡çš„ç‹¬ç«‹æ€§åˆ†æ)
    - [3.1 ç»“æ„ç‹¬ç«‹æ€§](#31-ç»“æ„ç‹¬ç«‹æ€§)
    - [3.2 å› æœç‹¬ç«‹æ€§](#32-å› æœç‹¬ç«‹æ€§)
  - [4 å¹¶å‘ä¸å¯è¾¾æ€§å›¾](#4-å¹¶å‘ä¸å¯è¾¾æ€§å›¾)
  - [5 çœŸå¹¶å‘vs.äº¤é”™è¯­ä¹‰](#5-çœŸå¹¶å‘vsäº¤é”™è¯­ä¹‰)
  - [6 Pythonå®ç°ï¼šå¹¶å‘åº¦åˆ†æ](#6-pythonå®ç°å¹¶å‘åº¦åˆ†æ)
  - [7 å®é™…æ¡ˆä¾‹ï¼šå¤šçº¿ç¨‹ä»»åŠ¡è°ƒåº¦](#7-å®é™…æ¡ˆä¾‹å¤šçº¿ç¨‹ä»»åŠ¡è°ƒåº¦)
  - [8 è·¨è§†è§’é“¾æ¥](#8-è·¨è§†è§’é“¾æ¥)

---

## 1 å¹¶å‘çš„åŸºæœ¬æ¦‚å¿µ

**å¹¶å‘ï¼ˆConcurrencyï¼‰** æ˜¯è°ƒåº¦ç³»ç»Ÿçš„æ ¸å¿ƒç‰¹å¾ï¼ŒPetriç½‘æä¾›äº†è‡ªç„¶çš„å¹¶å‘è¡¨ç¤ºã€‚

**å¹¶å‘çš„ä¸¤ç§ç†è§£**ï¼š

1. **çœŸå¹¶å‘ï¼ˆTrue Concurrencyï¼‰**ï¼šäº‹ä»¶çœŸæ­£åŒæ—¶å‘ç”Ÿ
   - å¤šæ ¸CPUä¸Šçš„å¹¶è¡Œæ‰§è¡Œ
   - Petriç½‘è¡¨ç¤ºï¼šå¹¶è¡Œå˜è¿åŒæ—¶ç‚¹ç«

2. **äº¤é”™å¹¶å‘ï¼ˆInterleaving Concurrencyï¼‰**ï¼šäº‹ä»¶äº¤é”™æ‰§è¡Œ
   - å•æ ¸CPUä¸Šçš„æ—¶é—´ç‰‡è½®è½¬
   - Petriç½‘è¡¨ç¤ºï¼šå˜è¿éç¡®å®šæ€§é€‰æ‹©ç‚¹ç«

**Petriç½‘çš„ä¼˜åŠ¿**ï¼š

- è‡ªç„¶æ”¯æŒçœŸå¹¶å‘è¯­ä¹‰
- é¿å…çŠ¶æ€ç©ºé—´çˆ†ç‚¸ï¼ˆç›¸æ¯”æ˜¾å¼çŠ¶æ€æœºï¼‰
- ç›´è§‚çš„å›¾å½¢è¡¨ç¤º

---

## 2 å¹¶å‘åº¦çš„å½¢å¼åŒ–å®šä¹‰

### 2.1 é™æ€å¹¶å‘åº¦

**å®šä¹‰2.11ï¼ˆé™æ€å¹¶å‘åº¦ï¼‰**ï¼š

Petriç½‘çš„**é™æ€å¹¶å‘åº¦**æ˜¯æœ€å¤šå¯ä»¥åŒæ—¶ä½¿èƒ½çš„å˜è¿æ•°é‡ï¼š

$$
\text{StaticConcurrency}(PN) = \max_{M \in R(M_0)} |\{t \in T \mid M[t\rangle\}|
$$

**è®¡ç®—æ–¹æ³•**ï¼š

```python
def compute_static_concurrency(pn, M0):
    """
    è®¡ç®—é™æ€å¹¶å‘åº¦

    Args:
        pn: Petriç½‘
        M0: åˆå§‹æ ‡è®°

    Returns:
        æœ€å¤§å¹¶å‘åº¦
    """
    RG = construct_reachability_graph(pn, M0)

    max_concurrency = 0

    for M in RG.nodes():
        # è®¡ç®—å½“å‰æ ‡è®°ä¸‹ä½¿èƒ½çš„å˜è¿æ•°
        enabled = [t for t in pn.transitions if is_enabled(pn, M, t)]
        concurrency = len(enabled)

        if concurrency > max_concurrency:
            max_concurrency = concurrency

    return max_concurrency

# ç¤ºä¾‹
pn = create_parallel_tasks_petri_net(num_tasks=8)
static_concurrency = compute_static_concurrency(pn, pn.marking)
print(f"Static concurrency: {static_concurrency}")
```

### 2.2 åŠ¨æ€å¹¶å‘åº¦

**å®šä¹‰2.12ï¼ˆåŠ¨æ€å¹¶å‘åº¦ï¼‰**ï¼š

åœ¨ç‚¹ç«åºåˆ— $\sigma$ ä¸­ï¼Œ**åŠ¨æ€å¹¶å‘åº¦**æ˜¯å®é™…åŒæ—¶ç‚¹ç«çš„å˜è¿æ•°é‡çš„å¹³å‡å€¼ï¼š

$$
\text{DynamicConcurrency}(\sigma) = \frac{1}{|\sigma|} \sum_{i=1}^{|\sigma|} |\text{step}_i|
$$

å…¶ä¸­ $\text{step}_i$ æ˜¯ç¬¬ $i$ æ­¥åŒæ—¶ç‚¹ç«çš„å˜è¿é›†åˆã€‚

### 2.3 æœ€å¤§å¹¶å‘åº¦è®¡ç®—

**å®šç†2.11ï¼ˆå¹¶å‘åº¦ä¸Šç•Œï¼‰**ï¼š

å¯¹äºæœ‰ç•ŒPetriç½‘ï¼Œé™æ€å¹¶å‘åº¦æœ‰ä¸Šç•Œï¼š

$$
\text{StaticConcurrency}(PN) \leq |T|
$$

**æ›´ç´§çš„ä¸Šç•Œ**ï¼š

å¦‚æœPetriç½‘æ˜¯å®‰å…¨çš„ï¼ˆ1-æœ‰ç•Œï¼‰ï¼Œåˆ™ï¼š

$$
\text{StaticConcurrency}(PN) \leq \min(|T|, |P|)
$$

**Pythonå®ç°**ï¼š

```python
def analyze_concurrency(pn, M0):
    """
    åˆ†æPetriç½‘çš„å¹¶å‘ç‰¹æ€§

    Returns:
        å¹¶å‘åº¦åˆ†æç»“æœ
    """
    RG = construct_reachability_graph(pn, M0)

    # é™æ€å¹¶å‘åº¦
    max_concurrent = 0
    min_concurrent = float('inf')
    avg_concurrent = 0

    concurrency_distribution = {}

    for M in RG.nodes():
        enabled = [t for t in pn.transitions if is_enabled(pn, M, t)]
        concurrent = len(enabled)

        max_concurrent = max(max_concurrent, concurrent)
        min_concurrent = min(min_concurrent, concurrent)
        avg_concurrent += concurrent

        if concurrent not in concurrency_distribution:
            concurrency_distribution[concurrent] = 0
        concurrency_distribution[concurrent] += 1

    avg_concurrent /= len(RG.nodes())

    return {
        'max': max_concurrent,
        'min': min_concurrent,
        'avg': avg_concurrent,
        'distribution': concurrency_distribution,
        'parallelism_ratio': max_concurrent / len(pn.transitions)
    }

# ä½¿ç”¨ç¤ºä¾‹
analysis = analyze_concurrency(pn, initial_marking)
print(f"Concurrency Analysis:")
print(f"  Max concurrent transitions: {analysis['max']}")
print(f"  Min concurrent transitions: {analysis['min']}")
print(f"  Avg concurrent transitions: {analysis['avg']:.2f}")
print(f"  Parallelism ratio: {analysis['parallelism_ratio']:.2%}")
```

---

## 3 å¹¶å‘ä»»åŠ¡çš„ç‹¬ç«‹æ€§åˆ†æ

### 3.1 ç»“æ„ç‹¬ç«‹æ€§

**å®šä¹‰2.13ï¼ˆç»“æ„ç‹¬ç«‹ï¼‰**ï¼š

ä¸¤ä¸ªå˜è¿ $t_1, t_2$ **ç»“æ„ç‹¬ç«‹**ï¼Œå¦‚æœå®ƒä»¬ä¸å…±äº«è¾“å…¥åº“æ‰€ï¼š

$$
\bullet t_1 \cap \bullet t_2 = \emptyset
$$

**æ€§è´¨**ï¼šç»“æ„ç‹¬ç«‹çš„å˜è¿å¯ä»¥åŒæ—¶ä½¿èƒ½å’Œç‚¹ç«ï¼Œä¸å­˜åœ¨å†²çªã€‚

**Pythonæ£€æµ‹**ï¼š

```python
def are_structurally_independent(pn, t1, t2):
    """
    æ£€æŸ¥ä¸¤ä¸ªå˜è¿æ˜¯å¦ç»“æ„ç‹¬ç«‹
    """
    input_t1 = {p for p in pn.places if (p, t1) in pn.arcs}
    input_t2 = {p for p in pn.places if (p, t2) in pn.arcs}

    # æ£€æŸ¥æ˜¯å¦æœ‰å…±äº«è¾“å…¥åº“æ‰€
    shared_inputs = input_t1 & input_t2

    return len(shared_inputs) == 0

# ä½¿ç”¨ç¤ºä¾‹
independent = are_structurally_independent(pn, 't_task1', 't_task2')
if independent:
    print("âœ“ Tasks are structurally independent - can run truly in parallel")
else:
    print("âœ— Tasks share resources - potential conflict")
```

### 3.2 å› æœç‹¬ç«‹æ€§

**å®šä¹‰2.14ï¼ˆå› æœç‹¬ç«‹ï¼‰**ï¼š

ä¸¤ä¸ªå˜è¿ $t_1, t_2$ **å› æœç‹¬ç«‹**ï¼Œå¦‚æœå®ƒä»¬ä¹‹é—´æ²¡æœ‰å› æœä¾èµ–å…³ç³»ï¼ˆä¸å­˜åœ¨è·¯å¾„è¿æ¥ï¼‰ã€‚

**æ£€æµ‹ç®—æ³•**ï¼š

```python
def are_causally_independent(pn, t1, t2):
    """
    æ£€æŸ¥ä¸¤ä¸ªå˜è¿æ˜¯å¦å› æœç‹¬ç«‹
    ä½¿ç”¨å¯è¾¾æ€§åˆ†æ
    """
    # æ„é€ Petriç½‘çš„å› æœå›¾
    causality_graph = nx.DiGraph()

    for t in pn.transitions:
        causality_graph.add_node(t)

    # å¦‚æœt1çš„è¾“å‡ºåº“æ‰€æ˜¯t2çš„è¾“å…¥åº“æ‰€ï¼Œåˆ™t1å› æœå…ˆäºt2
    for t1 in pn.transitions:
        output_places = {p for p in pn.places if (t1, p) in pn.arcs}
        for t2 in pn.transitions:
            if t1 != t2:
                input_places = {p for p in pn.places if (p, t2) in pn.arcs}
                if output_places & input_places:
                    causality_graph.add_edge(t1, t2)

    # æ£€æŸ¥æ˜¯å¦å­˜åœ¨è·¯å¾„
    has_path_t1_t2 = nx.has_path(causality_graph, t1, t2)
    has_path_t2_t1 = nx.has_path(causality_graph, t2, t1)

    return not (has_path_t1_t2 or has_path_t2_t1)
```

---

## 4 å¹¶å‘ä¸å¯è¾¾æ€§å›¾

**å®šç†2.12ï¼ˆå¹¶å‘åº¦ä¸å¯è¾¾æ€§å›¾çš„å…³ç³»ï¼‰**ï¼š

è®¾Petriç½‘ $PN$ çš„å¯è¾¾æ€§å›¾ä¸º $RG = (V, E)$ï¼Œåˆ™ï¼š

$$
\text{MaxConcurrency} = \max_{M \in V} |\{t \mid M[t\rangle\}|
$$

**å¹¶å‘é›†åˆ**ï¼š

åœ¨æ ‡è®° $M$ ä¸‹ï¼Œ**å¹¶å‘é›†åˆ**å®šä¹‰ä¸ºï¼š

$$
\text{Concurrent}(M) = \{t \in T \mid M[t\rangle\}
$$

**æœ€å¤§å¹¶å‘é›†åˆ**ï¼š

$$
\text{MaxConcurrentSet} = \arg\max_{M \in R(M_0)} |\text{Concurrent}(M)|
$$

---

## 5 çœŸå¹¶å‘vs.äº¤é”™è¯­ä¹‰

**çœŸå¹¶å‘è¯­ä¹‰ï¼ˆProcess Semanticsï¼‰**ï¼š

å¹¶å‘äº‹ä»¶ä½œä¸ºä¸€ä¸ª**æ­¥éª¤ï¼ˆStepï¼‰**åŒæ—¶å‘ç”Ÿï¼š

$$
M[T'\rangle M' \text{ where } T' \subseteq T \text{ is a set of transitions}
$$

**äº¤é”™è¯­ä¹‰ï¼ˆInterleaving Semanticsï¼‰**ï¼š

å¹¶å‘äº‹ä»¶é€šè¿‡**åºåˆ—åŒ–**è¡¨ç¤ºï¼š

$$
M[t_1\rangle M_1[t_2\rangle M_2 \quad \text{or} \quad M[t_2\rangle M'_1[t_1\rangle M_2
$$

**å¯¹æ¯”**ï¼š

| ç‰¹æ€§ | çœŸå¹¶å‘ | äº¤é”™ |
|------|--------|------|
| è¯­ä¹‰ | åŒæ—¶å‘ç”Ÿ | åºåˆ—åŒ– |
| çŠ¶æ€æ•° | å°‘ | å¤šï¼ˆçŠ¶æ€çˆ†ç‚¸ï¼‰ |
| è¡¨è¾¾åŠ› | å¼º | å¼± |
| å®ç° | Petriç½‘ | çŠ¶æ€æœº |

**Pythonå®ç°çœŸå¹¶å‘**ï¼š

```python
def fire_concurrent_step(pn, M, transition_set):
    """
    æ­¥éª¤è¯­ä¹‰ï¼šåŒæ—¶ç‚¹ç«å¤šä¸ªå˜è¿

    Args:
        pn: Petriç½‘
        M: å½“å‰æ ‡è®°
        transition_set: è¦åŒæ—¶ç‚¹ç«çš„å˜è¿é›†åˆ

    Returns:
        æ–°æ ‡è®°
    """
    # æ£€æŸ¥æ‰€æœ‰å˜è¿éƒ½ä½¿èƒ½
    for t in transition_set:
        if not is_enabled(pn, M, t):
            raise ValueError(f"Transition {t} is not enabled")

    # æ£€æŸ¥å˜è¿ä¹‹é—´æ²¡æœ‰å†²çª
    for t1 in transition_set:
        for t2 in transition_set:
            if t1 != t2:
                # æ£€æŸ¥æ˜¯å¦å…±äº«è¾“å…¥åº“æ‰€
                input_t1 = {p for p in pn.places if (p, t1) in pn.arcs}
                input_t2 = {p for p in pn.places if (p, t2) in pn.arcs}
                shared = input_t1 & input_t2

                if shared:
                    # æ£€æŸ¥èµ„æºæ˜¯å¦è¶³å¤Ÿ
                    for p in shared:
                        required = pn.arcs.get((p, t1), 0) + pn.arcs.get((p, t2), 0)
                        if M[p] < required:
                            raise ValueError(f"Insufficient tokens in {p} for concurrent firing")

    # åŒæ—¶ç‚¹ç«æ‰€æœ‰å˜è¿
    M_new = M.copy()
    for t in transition_set:
        # æ¶ˆè€—è¾“å…¥
        for p in pn.places:
            if (p, t) in pn.arcs:
                M_new[p] -= pn.arcs[(p, t)]

        # äº§ç”Ÿè¾“å‡º
        for p in pn.places:
            if (t, p) in pn.arcs:
                M_new[p] += pn.arcs[(t, p)]

    return M_new

# ç¤ºä¾‹ï¼šå¹¶å‘ç‚¹ç«
concurrent_tasks = {'t_task1', 't_task2', 't_task3'}
M_new = fire_concurrent_step(pn, current_marking, concurrent_tasks)
print(f"Fired {len(concurrent_tasks)} transitions concurrently")
```

---

## 6 Pythonå®ç°ï¼šå¹¶å‘åº¦åˆ†æ

**å®Œæ•´çš„å¹¶å‘åº¦åˆ†æå·¥å…·**ï¼š

```python
class ConcurrencyAnalyzer:
    """Petriç½‘å¹¶å‘åº¦åˆ†æå·¥å…·"""

    def __init__(self, pn, M0):
        self.pn = pn
        self.M0 = M0
        self.RG = construct_reachability_graph(pn, M0)

    def analyze(self):
        """æ‰§è¡Œå®Œæ•´çš„å¹¶å‘åº¦åˆ†æ"""
        results = {
            'static_concurrency': self.compute_static_concurrency(),
            'independence_matrix': self.compute_independence_matrix(),
            'concurrent_sets': self.find_maximal_concurrent_sets(),
            'parallelism_metrics': self.compute_parallelism_metrics()
        }

        return results

    def compute_static_concurrency(self):
        """è®¡ç®—é™æ€å¹¶å‘åº¦"""
        max_concurrent = 0

        for M in self.RG.nodes():
            enabled = [t for t in self.pn.transitions if is_enabled(self.pn, M, t)]
            max_concurrent = max(max_concurrent, len(enabled))

        return max_concurrent

    def compute_independence_matrix(self):
        """
        è®¡ç®—å˜è¿ç‹¬ç«‹æ€§çŸ©é˜µ

        Returns:
            independence_matrix[i][j] = True if t_i and t_j are independent
        """
        transitions = list(self.pn.transitions)
        n = len(transitions)
        matrix = [[False] * n for _ in range(n)]

        for i, t1 in enumerate(transitions):
            for j, t2 in enumerate(transitions):
                if i == j:
                    matrix[i][j] = True
                else:
                    # æ£€æŸ¥ç»“æ„ç‹¬ç«‹æ€§
                    matrix[i][j] = are_structurally_independent(self.pn, t1, t2)

        return matrix

    def find_maximal_concurrent_sets(self):
        """
        æ‰¾åˆ°æ‰€æœ‰æœ€å¤§å¹¶å‘é›†åˆ

        Returns:
            æœ€å¤§å¹¶å‘é›†åˆåˆ—è¡¨
        """
        maximal_sets = []

        for M in self.RG.nodes():
            enabled = [t for t in self.pn.transitions if is_enabled(self.pn, M, t)]

            # æ‰¾åˆ°å¯ä»¥åŒæ—¶ç‚¹ç«çš„æœ€å¤§å­é›†
            concurrent_set = self._find_maximal_concurrent_subset(enabled)

            if concurrent_set and concurrent_set not in maximal_sets:
                maximal_sets.append(concurrent_set)

        return maximal_sets

    def _find_maximal_concurrent_subset(self, enabled_transitions):
        """æ‰¾åˆ°å¯ä»¥åŒæ—¶ç‚¹ç«çš„æœ€å¤§å­é›†"""
        # ä½¿ç”¨è´ªå¿ƒç®—æ³•ï¼ˆç®€åŒ–å®ç°ï¼‰
        concurrent = []

        for t in enabled_transitions:
            # æ£€æŸ¥tæ˜¯å¦ä¸å·²é€‰å˜è¿ç‹¬ç«‹
            can_add = all(
                are_structurally_independent(self.pn, t, t_selected)
                for t_selected in concurrent
            )

            if can_add:
                concurrent.append(t)

        return frozenset(concurrent)

    def compute_parallelism_metrics(self):
        """è®¡ç®—å¹¶è¡Œåº¦æŒ‡æ ‡"""
        total_transitions = len(self.pn.transitions)
        max_concurrent = self.compute_static_concurrency()

        # å¹¶è¡Œåº¦æ¯”ç‡
        parallelism_ratio = max_concurrent / total_transitions

        # Amdahlå®šå¾‹ï¼šç†è®ºåŠ é€Ÿæ¯”
        # S = 1 / ((1 - p) + p / n)
        # å…¶ä¸­pæ˜¯å¯å¹¶è¡Œéƒ¨åˆ†ï¼Œnæ˜¯å¹¶è¡Œåº¦
        p = parallelism_ratio  # å‡è®¾å¯å¹¶è¡Œéƒ¨åˆ†æ¯”ä¾‹
        theoretical_speedup = 1 / ((1 - p) + p / max_concurrent)

        return {
            'max_concurrent_transitions': max_concurrent,
            'total_transitions': total_transitions,
            'parallelism_ratio': parallelism_ratio,
            'theoretical_speedup': theoretical_speedup
        }

# ä½¿ç”¨åˆ†æå™¨
analyzer = ConcurrencyAnalyzer(pn, initial_marking)
results = analyzer.analyze()

print("Concurrency Analysis Results:")
print(f"  Max concurrent: {results['static_concurrency']}")
print(f"  Parallelism ratio: {results['parallelism_metrics']['parallelism_ratio']:.2%}")
print(f"  Theoretical speedup: {results['parallelism_metrics']['theoretical_speedup']:.2f}x")
```

---

## 7 å®é™…æ¡ˆä¾‹ï¼šå¤šçº¿ç¨‹ä»»åŠ¡è°ƒåº¦

**åœºæ™¯**ï¼š4æ ¸CPUä¸Šè°ƒåº¦8ä¸ªç‹¬ç«‹ä»»åŠ¡

**Petriç½‘å»ºæ¨¡**ï¼š

```python
def create_multicore_concurrent_scheduling():
    """
    å¤šæ ¸å¹¶å‘è°ƒåº¦Petriç½‘æ¨¡å‹

    ç³»ç»Ÿé…ç½®ï¼š
    - 4ä¸ªCPUæ ¸å¿ƒ
    - 8ä¸ªç‹¬ç«‹ä»»åŠ¡
    - ä»»åŠ¡å¯ä»¥å¹¶è¡Œæ‰§è¡Œ
    """
    pn = PetriNet()

    num_cores = 4
    tasks = [f'Task{i}' for i in range(1, 9)]

    # CPUèµ„æºåº“æ‰€
    pn.add_place('p_cpu_cores', tokens=num_cores)

    # ä»»åŠ¡é˜Ÿåˆ—åº“æ‰€
    pn.add_place('p_task_queue', tokens=len(tasks))

    for task in tasks:
        # ä»»åŠ¡è°ƒåº¦å˜è¿
        pn.add_transition(f't_schedule_{task}')
        pn.add_arc('p_task_queue', f't_schedule_{task}')
        pn.add_arc('p_cpu_cores', f't_schedule_{task}')

        # ä»»åŠ¡æ‰§è¡Œåº“æ‰€
        pn.add_place(f'p_{task}_running', tokens=0)
        pn.add_arc(f't_schedule_{task}', f'p_{task}_running')

        # ä»»åŠ¡å®Œæˆå˜è¿
        pn.add_transition(f't_complete_{task}')
        pn.add_arc(f'p_{task}_running', f't_complete_{task}')
        pn.add_arc(f't_complete_{task}', 'p_cpu_cores')  # é‡Šæ”¾CPU

        # å®Œæˆåº“æ‰€
        pn.add_place(f'p_{task}_done', tokens=0)
        pn.add_arc(f't_complete_{task}', f'p_{task}_done')

    return pn

# åˆ›å»ºå¹¶åˆ†æ
pn = create_multicore_concurrent_scheduling()
analyzer = ConcurrencyAnalyzer(pn, pn.marking)
results = analyzer.analyze()

print("Multi-core Scheduling Analysis:")
print(f"  Max concurrent tasks: {results['static_concurrency']}")
print(f"  Expected: 4 (number of cores)")
print(f"  Match: {results['static_concurrency'] == 4}")

# æ¨¡æ‹Ÿå¹¶å‘æ‰§è¡Œ
print("\nSimulation:")
initial_state = pn.marking.copy()

# ç¬¬ä¸€æ‰¹ï¼šåŒæ—¶è°ƒåº¦4ä¸ªä»»åŠ¡
batch1 = ['Task1', 'Task2', 'Task3', 'Task4']
concurrent_set1 = {f't_schedule_{t}' for t in batch1}
M1 = fire_concurrent_step(pn, initial_state, concurrent_set1)
print(f"Batch 1: Scheduled {batch1} (4 cores used)")

# æ¨¡æ‹Ÿä»»åŠ¡å®Œæˆ
for task in batch1[:2]:  # å‡è®¾å‰ä¸¤ä¸ªå…ˆå®Œæˆ
    M1 = fire_transition(pn, M1, f't_complete_{task}')
    print(f"  âœ“ {task} completed (2 cores free)")

# ç¬¬äºŒæ‰¹ï¼šè°ƒåº¦å‰©ä½™ä»»åŠ¡
batch2 = ['Task5', 'Task6']
concurrent_set2 = {f't_schedule_{t}' for t in batch2}
M2 = fire_concurrent_step(pn, M1, concurrent_set2)
print(f"Batch 2: Scheduled {batch2} (4 cores used again)")
```

**å¹¶å‘åº¦åˆ†æç»“æœ**ï¼š

```text
ç†è®ºåˆ†æï¼š
- æ€»ä»»åŠ¡æ•°ï¼š8
- CPUæ ¸å¿ƒæ•°ï¼š4
- æœ€å¤§å¹¶å‘åº¦ï¼š4ï¼ˆå—CPUæ ¸å¿ƒæ•°é™åˆ¶ï¼‰
- ç†è®ºåŠ é€Ÿæ¯”ï¼š4xï¼ˆç†æƒ³æƒ…å†µï¼‰
- å®é™…åŠ é€Ÿæ¯”ï¼š~3.5xï¼ˆè€ƒè™‘è°ƒåº¦å¼€é”€ï¼‰

Petriç½‘æ€§è´¨ï¼š
- æœ‰ç•Œï¼šâœ“ (æ¯ä¸ªåº“æ‰€æœ€å¤š8ä¸ªæ ‡è®°ï¼‰
- æ´»ï¼šâœ“ (æ‰€æœ‰ä»»åŠ¡æœ€ç»ˆéƒ½èƒ½æ‰§è¡Œï¼‰
- å®‰å…¨ï¼šâœ— (p_task_queueå¯ä»¥æœ‰>1ä¸ªæ ‡è®°)
- å¯é€†ï¼šâœ— (ä»»åŠ¡å®Œæˆåä¸å¯é€†)
```

---

## 8 è·¨è§†è§’é“¾æ¥

**Petriç½‘åŸºç¡€**ï¼š

- [01.1 Petriç½‘åŸºæœ¬æ¦‚å¿µä¸å®šä¹‰](../01_è°ƒåº¦ç³»ç»Ÿçš„Petriç½‘åŸºç¡€/01.1_Petriç½‘åŸºæœ¬æ¦‚å¿µä¸å®šä¹‰.md)

**å¹¶å‘ç³»ç»Ÿ**ï¼š

- [10_Petriç½‘ç†è®º/10.6 Petriç½‘ä¸å¹¶å‘ç³»ç»Ÿ](../../../formal_lang_view/10_Petriç½‘ç†è®º/10.6_Petriç½‘ä¸å¹¶å‘ç³»ç»Ÿ.md)

**å®é™…è°ƒåº¦**ï¼š

- [06_è°ƒåº¦æ¨¡å‹/06.3 ç¼–ç¨‹è¯­è¨€å±‚è°ƒåº¦](../../06_è°ƒåº¦æ¨¡å‹/06.3_ç¼–ç¨‹è¯­è¨€å±‚è°ƒåº¦.md)

---

**è¿”å›**: [02 å¹¶å‘è°ƒåº¦çš„Petriç½‘å»ºæ¨¡](README.md)

**å‚è€ƒæ–‡çŒ®**ï¼š

1. Mazurkiewicz, A. (1986). "Trace theory"
2. Nielsen, M., Plotkin, G., & Winskel, G. (1981). "Petri nets, event structures and domains"
3. Best, E., & Devillers, R. (1987). "Sequential and concurrent behaviour in Petri net theory"

---

**æœ€åæ›´æ–°**: 2025-12-02
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
