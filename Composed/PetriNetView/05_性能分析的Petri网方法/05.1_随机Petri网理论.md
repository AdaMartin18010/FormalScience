# 05.1 随机Petri网理论

> **子主题**: 05.1
> **所属主题**: 05 性能分析的Petri网方法
> **最后更新**: 2025-12-02

---

## 📋 目录

- [05.1 随机Petri网理论](#051-随机petri网理论)
  - [📋 目录](#-目录)
  - [1 随机Petri网（SPN）定义](#1-随机petri网spn定义)
  - [2 广义随机Petri网（GSPN）](#2-广义随机petri网gspn)
  - [3 确定性与随机Petri网（DSPN）](#3-确定性与随机petri网dspn)
  - [4 可达性图与马尔可夫链](#4-可达性图与马尔可夫链)
  - [5 稳态分析](#5-稳态分析)

---

## 1 随机Petri网（SPN）定义

**定义5.11（SPN）**：

随机Petri网在普通Petri网基础上，为每个变迁关联一个**随机延迟**：

$$
SPN = (P, T, F, W, M_0, \Lambda)
$$

其中 $\Lambda: T \to \mathbb{R}^+$ 是变迁的**点火率**（指数分布）。

**点火时间**：变迁 $t$ 的点火时间服从指数分布 $\text{Exp}(\lambda_t)$。

---

## 2 广义随机Petri网（GSPN）

**GSPN扩展**：

- **立即变迁**（Immediate）：点火率 $\lambda = \infty$，立即点火
- **定时变迁**（Timed）：点火率 $\lambda < \infty$，延迟点火

```python
class GSPNTransition:
    """GSPN变迁"""

    def __init__(self, name, trans_type='timed', rate=1.0, priority=0, weight=1.0):
        self.name = name
        self.type = trans_type  # 'immediate' or 'timed'
        self.rate = rate  # 点火率（指数分布参数）
        self.priority = priority  # 立即变迁优先级
        self.weight = weight  # 冲突时的权重

    def sample_firing_time(self):
        """采样点火时间"""
        if self.type == 'immediate':
            return 0.0
        else:
            import random
            return random.expovariate(self.rate)
```

---

## 3 确定性与随机Petri网（DSPN）

**DSPN**：结合确定性延迟和随机延迟

- **确定性变迁**：固定延迟 $d$
- **随机变迁**：指数分布延迟

---

## 4 可达性图与马尔可夫链

**定理5.11**：GSPN的可达性图对应一个**连续时间马尔可夫链（CTMC）**。

**状态转移率**：

$$
q(M, M') = \sum_{t: M[t\rangle M'} \lambda_t \cdot P(\text{choose } t)
$$

**Python实现**：

```python
def construct_ctmc_from_gspn(gspn, M0):
    """从GSPN构造CTMC"""
    import networkx as nx

    # 构造可达性图
    RG = construct_reachability_graph(gspn, M0)

    # 构造CTMC（加权有向图）
    CTMC = nx.DiGraph()

    for M in RG.nodes():
        CTMC.add_node(M)

        # 计算从M出发的转移率
        enabled = [t for t in gspn.transitions if is_enabled(gspn, M, t)]

        for t in enabled:
            M_next = fire_transition(gspn, M, t)

            # 转移率 = 点火率
            rate = gspn.transitions[t].rate

            if (M, M_next) in CTMC.edges():
                # 累加率（如果有多个变迁导致相同转移）
                CTMC[M][M_next]['rate'] += rate
            else:
                CTMC.add_edge(M, M_next, rate=rate)

    return CTMC
```

---

## 5 稳态分析

**稳态概率**：

$$
\pi_M = \lim_{t \to \infty} P(\text{state} = M \mid \text{time} = t)
$$

满足平衡方程：

$$
\pi Q = 0, \quad \sum_M \pi_M = 1
$$

```python
def compute_steady_state(ctmc):
    """计算CTMC稳态分布"""
    import numpy as np
    from scipy.linalg import null_space

    # 构造Q矩阵（生成矩阵）
    states = list(ctmc.nodes())
    n = len(states)
    Q = np.zeros((n, n))

    state_to_idx = {s: i for i, s in enumerate(states)}

    for i, M in enumerate(states):
        for M_next in ctmc.successors(M):
            j = state_to_idx[M_next]
            Q[i][j] = ctmc[M][M_next]['rate']

        # 对角线元素
        Q[i][i] = -sum(Q[i])

    # 求解 πQ = 0
    # 添加归一化约束
    A = np.vstack([Q.T, np.ones(n)])
    b = np.zeros(n+1)
    b[-1] = 1

    # 最小二乘求解
    pi, _, _, _ = np.linalg.lstsq(A, b, rcond=None)

    return {states[i]: pi[i] for i in range(n)}

# 使用
ctmc = construct_ctmc_from_gspn(gspn, initial_marking)
steady_state = compute_steady_state(ctmc)

print("稳态分布：")
for M, prob in sorted(steady_state.items(), key=lambda x: -x[1])[:5]:
    print(f"  {M}: {prob:.4f}")
```

---

**返回**: [05 性能分析的Petri网方法](README.md)
