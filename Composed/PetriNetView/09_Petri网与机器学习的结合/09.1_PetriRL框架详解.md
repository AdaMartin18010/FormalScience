# 09.1 PetriRLæ¡†æ¶è¯¦è§£

> **å­ä¸»é¢˜**: 09.1
> **æ‰€å±ä¸»é¢˜**: 09 Petriç½‘ä¸æœºå™¨å­¦ä¹ çš„ç»“åˆ
> **æœ€åæ›´æ–°**: 2025-12-02

---

## ğŸ“‹ ç›®å½•

- [09.1 PetriRLæ¡†æ¶è¯¦è§£](#091-petrirlæ¡†æ¶è¯¦è§£)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 PetriRLæ¡†æ¶æ¦‚è¿°](#1-petrirlæ¡†æ¶æ¦‚è¿°)
  - [2 Petriç½‘+æ·±åº¦å¼ºåŒ–å­¦ä¹ ](#2-petriç½‘æ·±åº¦å¼ºåŒ–å­¦ä¹ )
  - [3 ä½œä¸šè½¦é—´è°ƒåº¦é—®é¢˜ï¼ˆJSSPï¼‰](#3-ä½œä¸šè½¦é—´è°ƒåº¦é—®é¢˜jssp)
  - [4 PyTorchå®ç°](#4-pytorchå®ç°)

---

## 1 PetriRLæ¡†æ¶æ¦‚è¿°

**PetriRL** (arXiv:2402.00046, 2024)ï¼šé¦–ä¸ªå°†Petriç½‘ä¸æ·±åº¦å¼ºåŒ–å­¦ä¹ ç»“åˆçš„æ¡†æ¶ã€‚

**æ ¸å¿ƒæ€æƒ³**ï¼š

- **Petriç½‘**ï¼šå»ºæ¨¡è°ƒåº¦é—®é¢˜çš„ç»“æ„å’Œçº¦æŸ
- **DRL**ï¼šå­¦ä¹ æœ€ä¼˜è°ƒåº¦ç­–ç•¥

---

## 2 Petriç½‘+æ·±åº¦å¼ºåŒ–å­¦ä¹ 

**RLç»„ä»¶**ï¼š

- **çŠ¶æ€** $s$ï¼šPetriç½‘å½“å‰æ ‡è®° $M$
- **åŠ¨ä½œ** $a$ï¼šé€‰æ‹©ç‚¹ç«çš„å˜è¿ $t$
- **å¥–åŠ±** $r$ï¼šå®Œæˆä»»åŠ¡æ•°ã€å»¶è¿Ÿç­‰
- **ç­–ç•¥** $\pi(a|s)$ï¼šç¥ç»ç½‘ç»œ

---

## 3 ä½œä¸šè½¦é—´è°ƒåº¦é—®é¢˜ï¼ˆJSSPï¼‰

**JSSP**ï¼š$n$ ä¸ªä½œä¸šï¼Œ$m$ å°æœºå™¨ï¼Œæ¯ä¸ªä½œä¸šæœ‰å›ºå®šçš„æœºå™¨é¡ºåºã€‚

**Petriç½‘å»ºæ¨¡**ï¼š

```python
def create_jssp_petri_net(jobs, machines):
    """JSSPçš„Petriç½‘æ¨¡å‹"""
    pn = PetriNet()

    # æœºå™¨èµ„æº
    for machine in machines:
        pn.add_place(f'p_{machine}_idle', tokens=1)

    # ä½œä¸šæ“ä½œ
    for job in jobs:
        for i, (machine, duration) in enumerate(job['operations']):
            if i == 0:
                pn.add_place(f'p_{job["id"]}_op{i}_ready', tokens=1)
            else:
                pn.add_place(f'p_{job["id"]}_op{i}_ready', tokens=0)

            # æ“ä½œå˜è¿
            pn.add_transition(f't_{job["id"]}_op{i}')
            pn.add_arc(f'p_{job["id"]}_op{i}_ready', f't_{job["id"]}_op{i}')
            pn.add_arc(f'p_{machine}_idle', f't_{job["id"]}_op{i}')

            # å®Œæˆå
            if i < len(job['operations']) - 1:
                pn.add_place(f'p_{job["id"]}_op{i+1}_ready', tokens=0)
                pn.add_arc(f't_{job["id"]}_op{i}', f'p_{job["id"]}_op{i+1}_ready')

            pn.add_arc(f't_{job["id"]}_op{i}', f'p_{machine}_idle')

    return pn
```

---

## 4 PyTorchå®ç°

```python
import torch
import torch.nn as nn
import torch.optim as optim

class PetriRLNetwork(nn.Module):
    """PetriRLç¥ç»ç½‘ç»œ"""

    def __init__(self, state_dim, action_dim):
        super().__init__()
        self.fc1 = nn.Linear(state_dim, 256)
        self.fc2 = nn.Linear(256, 128)
        self.fc3 = nn.Linear(128, action_dim)

    def forward(self, state):
        x = torch.relu(self.fc1(state))
        x = torch.relu(self.fc2(x))
        return self.fc3(x)

class PetriRLAgent:
    """PetriRLä»£ç†"""

    def __init__(self, pn, state_dim, action_dim):
        self.pn = pn
        self.policy_net = PetriRLNetwork(state_dim, action_dim)
        self.target_net = PetriRLNetwork(state_dim, action_dim)
        self.optimizer = optim.Adam(self.policy_net.parameters())

    def encode_state(self, M):
        """ç¼–ç Petriç½‘æ ‡è®°ä¸ºçŠ¶æ€å‘é‡"""
        state = []
        for p in sorted(self.pn.places):
            state.append(M.get(p, 0))
        return torch.tensor(state, dtype=torch.float32)

    def select_action(self, M, epsilon=0.1):
        """é€‰æ‹©åŠ¨ä½œï¼ˆÎµ-greedyï¼‰"""
        enabled = [t for t in self.pn.transitions if is_enabled(self.pn, M, t)]

        if random.random() < epsilon or not enabled:
            return random.choice(enabled) if enabled else None

        state = self.encode_state(M)
        with torch.no_grad():
            q_values = self.policy_net(state)

        # é€‰æ‹©Qå€¼æœ€é«˜çš„ä½¿èƒ½å˜è¿
        best_transition = None
        best_q = float('-inf')

        for t in enabled:
            t_idx = list(sorted(self.pn.transitions)).index(t)
            if q_values[t_idx] > best_q:
                best_q = q_values[t_idx]
                best_transition = t

        return best_transition

# ä½¿ç”¨PetriRLè§£å†³JSSP
jobs = [
    {'id': 'J1', 'operations': [('M1', 3), ('M2', 2), ('M3', 2)]},
    {'id': 'J2', 'operations': [('M2', 2), ('M1', 4), ('M3', 1)]},
]
machines = ['M1', 'M2', 'M3']

jssp_pn = create_jssp_petri_net(jobs, machines)
agent = PetriRLAgent(jssp_pn, state_dim=20, action_dim=6)

# è®­ç»ƒä»£ç†
# agent.train(episodes=1000)

print("PetriRL JSSPæ±‚è§£å®Œæˆ")
```

---

**è¿”å›**: [09 Petriç½‘ä¸æœºå™¨å­¦ä¹ çš„ç»“åˆ](README.md)

**å‚è€ƒæ–‡çŒ®**ï¼š

1. arXiv:2402.00046 (2024). "PetriRL: Deep Reinforcement Learning for Job Shop Scheduling using Petri Nets"
