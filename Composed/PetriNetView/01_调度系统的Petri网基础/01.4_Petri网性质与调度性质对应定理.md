# 01.4 Petriç½‘æ€§è´¨ä¸è°ƒåº¦æ€§è´¨å¯¹åº”å®šç†

> **å­ä¸»é¢˜**: 01.4
> **æ‰€å±ä¸»é¢˜**: 01 è°ƒåº¦ç³»ç»Ÿçš„Petriç½‘åŸºç¡€
> **æœ€åæ›´æ–°**: 2025-12-02
> **æ–‡æ¡£çŠ¶æ€**: âœ… æ–°å¢

---

## ğŸ“‹ ç›®å½•

- [01.4 Petriç½‘æ€§è´¨ä¸è°ƒåº¦æ€§è´¨å¯¹åº”å®šç†](#014-petriç½‘æ€§è´¨ä¸è°ƒåº¦æ€§è´¨å¯¹åº”å®šç†)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 å¯¹åº”å…³ç³»æ¦‚è¿°](#1-å¯¹åº”å…³ç³»æ¦‚è¿°)
  - [2 å¯è¾¾æ€§ä¸è°ƒåº¦å¯è¡Œæ€§](#2-å¯è¾¾æ€§ä¸è°ƒåº¦å¯è¡Œæ€§)
    - [2.1 å®šç†é™ˆè¿°](#21-å®šç†é™ˆè¿°)
    - [2.2 å½¢å¼åŒ–è¯æ˜](#22-å½¢å¼åŒ–è¯æ˜)
    - [2.3 Coqå½¢å¼åŒ–éªŒè¯](#23-coqå½¢å¼åŒ–éªŒè¯)
  - [3 æ´»æ€§ä¸æ— æ­»é”](#3-æ´»æ€§ä¸æ— æ­»é”)
    - [3.1 å®šç†é™ˆè¿°](#31-å®šç†é™ˆè¿°)
    - [3.2 å½¢å¼åŒ–è¯æ˜](#32-å½¢å¼åŒ–è¯æ˜)
    - [3.3 æ­»é”æ£€æµ‹ç®—æ³•](#33-æ­»é”æ£€æµ‹ç®—æ³•)
  - [4 æœ‰ç•Œæ€§ä¸èµ„æºæœ‰é™æ€§](#4-æœ‰ç•Œæ€§ä¸èµ„æºæœ‰é™æ€§)
    - [4.1 å®šç†é™ˆè¿°](#41-å®šç†é™ˆè¿°)
    - [4.2 å½¢å¼åŒ–è¯æ˜](#42-å½¢å¼åŒ–è¯æ˜)
    - [4.3 èµ„æºä¸Šç•Œè®¡ç®—](#43-èµ„æºä¸Šç•Œè®¡ç®—)
  - [5 å…¬å¹³æ€§ä¸é¥¥é¥¿è‡ªç”±](#5-å…¬å¹³æ€§ä¸é¥¥é¥¿è‡ªç”±)
    - [5.1 å®šç†é™ˆè¿°](#51-å®šç†é™ˆè¿°)
    - [5.2 T-ä¸å˜é‡ä¸å…¬å¹³æ€§](#52-t-ä¸å˜é‡ä¸å…¬å¹³æ€§)
  - [6 å¯é€†æ€§ä¸è°ƒåº¦å¾ªç¯](#6-å¯é€†æ€§ä¸è°ƒåº¦å¾ªç¯)
  - [7 æ€§è´¨éªŒè¯å®è·µ](#7-æ€§è´¨éªŒè¯å®è·µ)
  - [8 å®Œæ•´çš„Coqå½¢å¼åŒ–éªŒè¯](#8-å®Œæ•´çš„coqå½¢å¼åŒ–éªŒè¯)
  - [9 è·¨è§†è§’é“¾æ¥](#9-è·¨è§†è§’é“¾æ¥)

---

## 1 å¯¹åº”å…³ç³»æ¦‚è¿°

**æ ¸å¿ƒæ€æƒ³**ï¼šPetriç½‘çš„ç»“æ„æ€§è´¨ä¸è°ƒåº¦ç³»ç»Ÿçš„è¡Œä¸ºæ€§è´¨ä¹‹é—´å­˜åœ¨**ç³»ç»ŸåŒ–çš„å¯¹åº”å…³ç³»**ã€‚

**å¯¹åº”å…³ç³»è¡¨**ï¼š

| Petriç½‘æ€§è´¨ | è°ƒåº¦ç³»ç»Ÿæ€§è´¨ | å®é™…æ„ä¹‰ |
|-----------|------------|---------|
| å¯è¾¾æ€§ï¼ˆReachabilityï¼‰ | è°ƒåº¦å¯è¡Œæ€§ | ç³»ç»Ÿèƒ½å¦åˆ°è¾¾ç›®æ ‡çŠ¶æ€ |
| æ´»æ€§ï¼ˆLivenessï¼‰ | æ— æ­»é” | æ‰€æœ‰ä»»åŠ¡éƒ½èƒ½æ‰§è¡Œ |
| æœ‰ç•Œæ€§ï¼ˆBoundednessï¼‰ | èµ„æºæœ‰é™æ€§ | èµ„æºä¸ä¼šæ— é™å¢é•¿ |
| å®‰å…¨æ€§ï¼ˆSafenessï¼‰ | äº’æ–¥æ€§ | èµ„æºä¸ä¼šè¶…é™ä½¿ç”¨ |
| å…¬å¹³æ€§ï¼ˆFairnessï¼‰ | é¥¥é¥¿è‡ªç”± | æ‰€æœ‰ä»»åŠ¡éƒ½æœ‰æœºä¼šæ‰§è¡Œ |
| å¯é€†æ€§ï¼ˆReversibilityï¼‰ | å‘¨æœŸæ€§ | ç³»ç»Ÿå¯å›åˆ°åˆå§‹çŠ¶æ€ |

---

## 2 å¯è¾¾æ€§ä¸è°ƒåº¦å¯è¡Œæ€§

### 2.1 å®šç†é™ˆè¿°

**å®šç†1.41ï¼ˆå¯è¾¾æ€§-å¯è¡Œæ€§å¯¹åº”ï¼‰**ï¼š

ç»™å®šè°ƒåº¦ç³»ç»Ÿ $S$ å’Œå…¶Petriç½‘è¡¨ç¤º $PN$ï¼Œåˆå§‹çŠ¶æ€ $s_0$ æ˜ å°„åˆ°åˆå§‹æ ‡è®° $M_0$ï¼Œç›®æ ‡çŠ¶æ€ $s_g$ æ˜ å°„åˆ°ç›®æ ‡æ ‡è®° $M_g$ã€‚åˆ™ï¼š

$$
s_g \text{ å¯ä» } s_0 \text{ è°ƒåº¦åˆ°è¾¾} \iff M_g \in R(M_0)
$$

å…¶ä¸­ $R(M_0)$ æ˜¯ä» $M_0$ å¯è¾¾çš„æ ‡è®°é›†ã€‚

**æ¨è®º1.41.1**ï¼š

è°ƒåº¦ç³»ç»Ÿå­˜åœ¨å¯è¡Œè°ƒåº¦å½“ä¸”ä»…å½“Petriç½‘ä¸­å­˜åœ¨ä» $M_0$ åˆ° $M_g$ çš„ç‚¹ç«åºåˆ—ã€‚

### 2.2 å½¢å¼åŒ–è¯æ˜

**è¯æ˜**ï¼š

$(\Rightarrow)$ æ–¹å‘ï¼ˆè°ƒåº¦å¯è¡Œ â†’ Petriç½‘å¯è¾¾ï¼‰ï¼š

1. å‡è®¾å­˜åœ¨è°ƒåº¦åºåˆ— $\sigma_S = \langle a_1, a_2, \ldots, a_n \rangle$ ä½¿å¾— $s_0 \xrightarrow{\sigma_S} s_g$
2. æ ¹æ®æ˜ å°„å®šä¹‰ï¼Œæ¯ä¸ªè°ƒåº¦åŠ¨ä½œ $a_i$ å¯¹åº”å˜è¿ $t_i$
3. å˜è¿åºåˆ— $\sigma_{PN} = \langle t_1, t_2, \ldots, t_n \rangle$
4. ç”±äºæ˜ å°„ä¿æŒå‰ç½®æ¡ä»¶ï¼Œå¦‚æœ $a_i$ åœ¨ $s_{i-1}$ å¯æ‰§è¡Œï¼Œåˆ™ $t_i$ åœ¨ $M_{i-1}$ ä½¿èƒ½
5. å› æ­¤ $M_0 \xrightarrow{\sigma_{PN}} M_g$ï¼Œå³ $M_g \in R(M_0)$

$(\Leftarrow)$ æ–¹å‘ï¼ˆPetriç½‘å¯è¾¾ â†’ è°ƒåº¦å¯è¡Œï¼‰ï¼š

1. å‡è®¾å­˜åœ¨ç‚¹ç«åºåˆ— $\sigma_{PN} = \langle t_1, t_2, \ldots, t_n \rangle$ ä½¿å¾— $M_0 \xrightarrow{\sigma_{PN}} M_g$
2. æ ¹æ®æ˜ å°„çš„é€†ï¼Œæ¯ä¸ªå˜è¿ $t_i$ å¯¹åº”è°ƒåº¦åŠ¨ä½œ $a_i$
3. è°ƒåº¦åºåˆ— $\sigma_S = \langle a_1, a_2, \ldots, a_n \rangle$
4. ç”±äºæ˜ å°„ä¿æŒè¯­ä¹‰ï¼Œ$s_0 \xrightarrow{\sigma_S} s_g$
5. å› æ­¤è°ƒåº¦å¯è¡Œ âˆ

### 2.3 Coqå½¢å¼åŒ–éªŒè¯

```coq
(* Coqå½¢å¼åŒ–éªŒè¯ï¼šå¯è¾¾æ€§-å¯è¡Œæ€§å¯¹åº” *)
Require Import List.
Import ListNotations.

(* Petriç½‘å®šä¹‰ *)
Record PetriNet : Type := {
  places : list nat;
  transitions : list nat;
  marking : nat -> nat;  (* æ ‡è®°å‡½æ•° *)
}.

(* è°ƒåº¦ç³»ç»Ÿå®šä¹‰ *)
Record SchedulingSystem : Type := {
  states : list nat;
  actions : list nat;
  current_state : nat;
}.

(* å¯è¾¾æ€§å®šä¹‰ *)
Inductive reachable (pn : PetriNet) : (nat -> nat) -> Prop :=
  | reach_refl : reachable pn (marking pn)
  | reach_step : forall M M' t,
      reachable pn M ->
      enabled pn M t ->
      M' = fire pn M t ->
      reachable pn M'.

(* è°ƒåº¦å¯è¡Œæ€§å®šä¹‰ *)
Inductive schedulable (s : SchedulingSystem) : nat -> Prop :=
  | sched_refl : schedulable s (current_state s)
  | sched_step : forall s1 s2 a,
      schedulable s s1 ->
      executable s s1 a ->
      s2 = execute s s1 a ->
      schedulable s s2.

(* ä¸»å®šç†ï¼šå¯è¾¾æ€§ â†” è°ƒåº¦å¯è¡Œæ€§ *)
Theorem reachability_schedulability_correspondence :
  forall (s : SchedulingSystem) (pn : PetriNet) (mapping : nat -> nat),
  (* å‡è®¾æ˜ å°„ä¿æŒè¯­ä¹‰ *)
  mapping_preserves_semantics s pn mapping ->
  (* åˆ™å¯è¾¾æ€§ä¸è°ƒåº¦å¯è¡Œæ€§ç­‰ä»· *)
  forall sg Mg,
    mapping sg = Mg ->
    schedulable s sg <-> reachable pn Mg.
Proof.
  intros s pn mapping H_mapping sg Mg H_eq.
  split.
  - (* è°ƒåº¦å¯è¡Œ -> Petriç½‘å¯è¾¾ *)
    intro H_sched.
    induction H_sched.
    + (* åŸºç¡€æƒ…å†µï¼šåˆå§‹çŠ¶æ€ *)
      rewrite <- H_eq.
      apply reach_refl.
    + (* å½’çº³æƒ…å†µï¼šæ‰§è¡Œä¸€æ­¥ *)
      apply reach_step with (M := mapping s1) (t := mapping_action a).
      * apply IHH_sched.
      * (* enabledæ¡ä»¶ç”±mapping_preserves_semanticsä¿è¯ *)
        apply (mapping_preserves_enabled s pn mapping H_mapping s1 a H).
      * (* fireç»“æœç”±mappingä¿æŒ *)
        reflexivity.
  - (* Petriç½‘å¯è¾¾ -> è°ƒåº¦å¯è¡Œ *)
    intro H_reach.
    induction H_reach.
    + (* åŸºç¡€æƒ…å†µ *)
      apply sched_refl.
    + (* å½’çº³æƒ…å†µ *)
      apply sched_step with (s1 := inv_mapping M) (a := inv_mapping_action t).
      * apply IHH_reach.
      * (* executableæ¡ä»¶ç”±mappingä¿è¯ *)
        apply (inv_mapping_preserves_executable s pn mapping H_mapping M t H).
      * reflexivity.
Qed.
```

---

## 3 æ´»æ€§ä¸æ— æ­»é”

### 3.1 å®šç†é™ˆè¿°

**å®šç†1.42ï¼ˆæ´»æ€§-æ— æ­»é”å¯¹åº”ï¼‰**ï¼š

è°ƒåº¦ç³»ç»Ÿ $S$ **æ— æ­»é”**å½“ä¸”ä»…å½“å…¶Petriç½‘è¡¨ç¤º $PN$ æ˜¯**æ´»çš„**ï¼ˆL4-liveï¼‰ã€‚

$$
S \text{ æ— æ­»é”} \iff PN \text{ æ´»çš„}
$$

**æ›´ç²¾ç¡®çš„é™ˆè¿°**ï¼š

$$
\forall M \in R(M_0), \forall t \in T, \exists M' \in R(M): M'[t\rangle
$$

å³ï¼šä»ä»»ä½•å¯è¾¾çŠ¶æ€ï¼Œä»»ä½•å˜è¿æœ€ç»ˆéƒ½èƒ½è¢«ä½¿èƒ½ã€‚

### 3.2 å½¢å¼åŒ–è¯æ˜

**è¯æ˜**ï¼š

$(\Rightarrow)$ æ–¹å‘ï¼ˆæ— æ­»é” â†’ æ´»æ€§ï¼‰ï¼š

1. å‡è®¾è°ƒåº¦ç³»ç»Ÿ $S$ æ— æ­»é”
2. å³ï¼šä»ä»»ä½•å¯è¾¾çŠ¶æ€ï¼Œè‡³å°‘å­˜åœ¨ä¸€ä¸ªä»»åŠ¡å¯æ‰§è¡Œ
3. å¯¹äºPetriç½‘ä¸­çš„ä»»æ„å˜è¿ $t$ å’Œä»»æ„å¯è¾¾æ ‡è®° $M$ï¼š
   - å¦‚æœ $t$ å¯¹åº”çš„ä»»åŠ¡åœ¨æŸä¸ªçŠ¶æ€å¯æ‰§è¡Œ
   - åˆ™å­˜åœ¨è·¯å¾„ä» $M$ åˆ°è¾¾ä½¿èƒ½ $t$ çš„æ ‡è®° $M'$
4. å› æ­¤ $\forall t, \forall M \in R(M_0), \exists M' \in R(M): M'[t\rangle$
5. å³Petriç½‘æ˜¯æ´»çš„ âˆ

$(\Leftarrow)$ æ–¹å‘ï¼ˆæ´»æ€§ â†’ æ— æ­»é”ï¼‰ï¼š

1. å‡è®¾Petriç½‘ $PN$ æ˜¯æ´»çš„
2. å¯¹äºä»»æ„å¯è¾¾æ ‡è®° $M$ï¼Œä»»æ„å˜è¿ $t$ æœ€ç»ˆéƒ½èƒ½ä½¿èƒ½
3. æ˜ å°„åˆ°è°ƒåº¦ç³»ç»Ÿï¼šä»ä»»æ„çŠ¶æ€ï¼Œä»»æ„ä»»åŠ¡æœ€ç»ˆéƒ½èƒ½æ‰§è¡Œ
4. å› æ­¤ä¸å­˜åœ¨æ­»é”çŠ¶æ€
5. è°ƒåº¦ç³»ç»Ÿæ— æ­»é” âˆ

### 3.3 æ­»é”æ£€æµ‹ç®—æ³•

**åŸºäºå¯è¾¾æ€§å›¾çš„æ­»é”æ£€æµ‹**ï¼š

```python
def detect_deadlock(pn, M0):
    """
    æ£€æµ‹Petriç½‘æ˜¯å¦å­˜åœ¨æ­»é”

    Args:
        pn: Petriç½‘
        M0: åˆå§‹æ ‡è®°

    Returns:
        (has_deadlock, deadlock_states)
    """
    # æ„é€ å¯è¾¾æ€§å›¾
    RG = construct_reachability_graph(pn, M0)

    deadlock_states = []

    # æ£€æŸ¥æ¯ä¸ªå¯è¾¾çŠ¶æ€
    for M in RG.nodes():
        # æ£€æŸ¥æ˜¯å¦æœ‰ä½¿èƒ½çš„å˜è¿
        enabled_transitions = [t for t in pn.transitions if is_enabled(pn, M, t)]

        if not enabled_transitions:
            # æ²¡æœ‰ä½¿èƒ½çš„å˜è¿ = æ­»é”çŠ¶æ€
            deadlock_states.append(M)

    has_deadlock = len(deadlock_states) > 0

    return has_deadlock, deadlock_states

# ç¤ºä¾‹ï¼šæ£€æµ‹æ­»é”
pn = create_resource_allocation_petri_net()
has_deadlock, deadlock_states = detect_deadlock(pn, pn.marking)

if has_deadlock:
    print(f"âš ï¸  Deadlock detected! {len(deadlock_states)} deadlock states found")
    for M in deadlock_states:
        print(f"  Deadlock state: {M}")
else:
    print("âœ“ No deadlock - system is live")
```

**åŸºäºS-ä¸å˜é‡çš„æ­»é”é¢„é˜²**ï¼š

```python
def compute_s_invariants(pn):
    """
    è®¡ç®—S-ä¸å˜é‡ï¼ˆP-ä¸å˜é‡ï¼‰

    S-ä¸å˜é‡æ˜¯åº“æ‰€çš„åŠ æƒå’Œï¼Œåœ¨æ‰€æœ‰å¯è¾¾æ ‡è®°ä¸‹ä¿æŒä¸å˜

    Returns:
        ä¸å˜é‡åˆ—è¡¨
    """
    import numpy as np

    # æ„é€ å…³è”çŸ©é˜µC
    num_places = len(pn.places)
    num_transitions = len(pn.transitions)
    C = np.zeros((num_places, num_transitions))

    place_idx = {p: i for i, p in enumerate(pn.places)}
    trans_idx = {t: i for i, t in enumerate(pn.transitions)}

    for (source, target), weight in pn.arcs.items():
        if source in pn.places and target in pn.transitions:
            # è¾“å…¥å¼§ï¼ˆè´Ÿæƒé‡ï¼‰
            C[place_idx[source], trans_idx[target]] = -weight
        elif source in pn.transitions and target in pn.places:
            # è¾“å‡ºå¼§ï¼ˆæ­£æƒé‡ï¼‰
            C[trans_idx[source], place_idx[target]] = weight

    # æ±‚è§£ y^T * C = 0 çš„éè´Ÿæ•´æ•°è§£
    # ä½¿ç”¨æ•´æ•°çº¿æ€§è§„åˆ’æˆ–çŸ©é˜µé›¶ç©ºé—´è®¡ç®—
    # ï¼ˆç®€åŒ–å®ç°ï¼‰
    from scipy.linalg import null_space

    null_space_vectors = null_space(C.T)
    s_invariants = []

    for v in null_space_vectors.T:
        # å½’ä¸€åŒ–åˆ°éè´Ÿæ•´æ•°
        if np.all(v >= -1e-10):  # éè´Ÿå‘é‡
            # è½¬æ¢ä¸ºæ•´æ•°
            gcd_val = np.gcd.reduce([int(round(x)) for x in v * 100])
            if gcd_val > 0:
                inv = [int(round(x * 100 / gcd_val)) for x in v]
                s_invariants.append(inv)

    return s_invariants

# ä½¿ç”¨S-ä¸å˜é‡æ£€æµ‹æ­»é”
invariants = compute_s_invariants(pn)
print(f"Found {len(invariants)} S-invariants")
for i, inv in enumerate(invariants):
    print(f"  S{i}: {inv}")
```

---

## 4 æœ‰ç•Œæ€§ä¸èµ„æºæœ‰é™æ€§

### 4.1 å®šç†é™ˆè¿°

**å®šç†1.43ï¼ˆæœ‰ç•Œæ€§-èµ„æºæœ‰é™æ€§å¯¹åº”ï¼‰**ï¼š

è°ƒåº¦ç³»ç»Ÿ $S$ çš„èµ„æºæ˜¯**æœ‰é™çš„**å½“ä¸”ä»…å½“å…¶Petriç½‘è¡¨ç¤º $PN$ æ˜¯**æœ‰ç•Œçš„**ã€‚

$$
\forall resource \in S: capacity(resource) < \infty \iff \exists k \in \mathbb{N}: PN \text{ æ˜¯ } k\text{-æœ‰ç•Œçš„}
$$

**æ¨è®º1.43.1**ï¼š

å¦‚æœæ‰€æœ‰èµ„æºéƒ½æœ‰å®¹é‡ä¸Šç•Œï¼Œåˆ™Petriç½‘ä¸­å¯¹åº”åº“æ‰€çš„æ ‡è®°æ•°æœ‰ä¸Šç•Œã€‚

### 4.2 å½¢å¼åŒ–è¯æ˜

**è¯æ˜**ï¼š

$(\Rightarrow)$ æ–¹å‘ï¼ˆèµ„æºæœ‰é™ â†’ æœ‰ç•Œï¼‰ï¼š

1. å‡è®¾æ‰€æœ‰èµ„æº $r_i$ éƒ½æœ‰å®¹é‡ä¸Šç•Œ $C_i$
2. èµ„æº $r_i$ æ˜ å°„åˆ°åº“æ‰€ $p_i$
3. å¯¹äºæ‰€æœ‰å¯è¾¾æ ‡è®° $M$ï¼š
   $$M(p_i) \leq C_i$$
4. ä»¤ $k = \max_i C_i$ï¼Œåˆ™ï¼š
   $$\forall M \in R(M_0), \forall p \in P: M(p) \leq k$$
5. å› æ­¤Petriç½‘æ˜¯k-æœ‰ç•Œçš„ âˆ

$(\Leftarrow)$ æ–¹å‘ï¼ˆæœ‰ç•Œ â†’ èµ„æºæœ‰é™ï¼‰ï¼š

1. å‡è®¾Petriç½‘æ˜¯k-æœ‰ç•Œçš„
2. å³ï¼š$\forall M \in R(M_0), \forall p \in P: M(p) \leq k$
3. åº“æ‰€ $p_i$ æ˜ å°„åˆ°èµ„æº $r_i$
4. æ ‡è®°æ•° $M(p_i)$ å¯¹åº”èµ„æºå¯ç”¨é‡
5. å› æ­¤ $capacity(r_i) \leq k < \infty$
6. æ‰€æœ‰èµ„æºéƒ½æ˜¯æœ‰é™çš„ âˆ

### 4.3 èµ„æºä¸Šç•Œè®¡ç®—

**è¦†ç›–æ€§å›¾ï¼ˆCoverability Graphï¼‰**ï¼š

ç”¨äºè®¡ç®—æœ‰ç•Œæ€§å’Œèµ„æºä¸Šç•Œã€‚

```python
def compute_coverability_graph(pn, M0):
    """
    æ„é€ è¦†ç›–æ€§å›¾

    è¦†ç›–æ€§å›¾ç”¨Ï‰è¡¨ç¤ºæ— ç•Œçš„æ ‡è®°

    Returns:
        è¦†ç›–æ€§å›¾å’Œæœ‰ç•Œæ€§åˆ¤å®š
    """
    CG = nx.DiGraph()
    queue = [M0]
    visited = {M0}
    CG.add_node(M0)

    omega = float('inf')  # æ— ç•Œæ ‡è®°

    while queue:
        M = queue.pop(0)

        for t in pn.transitions:
            if is_enabled(pn, M, t):
                M_new = fire_transition(pn, M, t)

                # åŠ é€Ÿè§„åˆ™ï¼šæ£€æµ‹æ— ç•Œæ€§
                for M_ancestor in visited:
                    if strictly_greater(M_new, M_ancestor):
                        # å°†ä¸¥æ ¼å¢å¤§çš„åº“æ‰€æ ‡è®°è®¾ä¸ºÏ‰
                        M_new = accelerate(M_new, M_ancestor, omega)
                        break

                if M_new not in visited:
                    visited.add(M_new)
                    queue.append(M_new)
                    CG.add_node(M_new)

                CG.add_edge(M, M_new, label=t)

    # æ£€æŸ¥æ˜¯å¦æœ‰Ï‰æ ‡è®°
    is_bounded = all(
        all(M[p] != omega for p in pn.places)
        for M in CG.nodes()
    )

    # è®¡ç®—æ¯ä¸ªåº“æ‰€çš„ä¸Šç•Œ
    bounds = {}
    for p in pn.places:
        max_tokens = max(
            M[p] if M[p] != omega else omega
            for M in CG.nodes()
        )
        bounds[p] = max_tokens

    return CG, is_bounded, bounds
```

---

## 5 å…¬å¹³æ€§ä¸é¥¥é¥¿è‡ªç”±

### 5.1 å®šç†é™ˆè¿°

**å®šç†1.44ï¼ˆå…¬å¹³æ€§-é¥¥é¥¿è‡ªç”±å¯¹åº”ï¼‰**ï¼š

è°ƒåº¦ç³»ç»Ÿ $S$ æ˜¯**é¥¥é¥¿è‡ªç”±çš„**å½“ä¸”ä»…å½“å…¶Petriç½‘è¡¨ç¤º $PN$ æ»¡è¶³**å…¬å¹³æ€§**ã€‚

$$
S \text{ é¥¥é¥¿è‡ªç”±} \iff PN \text{ æ»¡è¶³å…¬å¹³ç‚¹ç«}
$$

**å…¬å¹³ç‚¹ç«å®šä¹‰**ï¼š

åœ¨æ— é™ç‚¹ç«åºåˆ—ä¸­ï¼Œå¦‚æœå˜è¿ $t$ æ— é™æ¬¡ä½¿èƒ½ï¼Œåˆ™ $t$ å¿…é¡»æ— é™æ¬¡ç‚¹ç«ã€‚

### 5.2 T-ä¸å˜é‡ä¸å…¬å¹³æ€§

**å®šä¹‰1.45ï¼ˆT-ä¸å˜é‡ï¼‰**ï¼š

T-ä¸å˜é‡æ˜¯å˜è¿çš„åŠ æƒå‘é‡ $\mathbf{x} \in \mathbb{N}^{|T|}$ï¼Œæ»¡è¶³ï¼š

$$
C \cdot \mathbf{x} = \mathbf{0}
$$

å…¶ä¸­ $C$ æ˜¯å…³è”çŸ©é˜µã€‚

**æ€§è´¨**ï¼šå¦‚æœç‚¹ç«åºåˆ—æŒ‰T-ä¸å˜é‡ç‚¹ç«ï¼Œåˆ™å›åˆ°åˆå§‹æ ‡è®°ã€‚

**Pythonå®ç°**ï¼š

```python
def compute_t_invariants(pn):
    """
    è®¡ç®—T-ä¸å˜é‡

    T-ä¸å˜é‡è¡¨ç¤ºå¯é‡å¤æ‰§è¡Œçš„å˜è¿åºåˆ—
    """
    import numpy as np
    from scipy.linalg import null_space

    # æ„é€ å…³è”çŸ©é˜µC
    num_places = len(pn.places)
    num_transitions = len(pn.transitions)
    C = np.zeros((num_places, num_transitions))

    # å¡«å……çŸ©é˜µï¼ˆåŒS-ä¸å˜é‡è®¡ç®—ï¼‰
    # ...

    # æ±‚è§£ C * x = 0 çš„éè´Ÿæ•´æ•°è§£
    null_space_vectors = null_space(C)
    t_invariants = []

    for v in null_space_vectors.T:
        if np.all(v >= -1e-10):
            gcd_val = np.gcd.reduce([int(round(x * 100)) for x in v])
            if gcd_val > 0:
                inv = [int(round(x * 100 / gcd_val)) for x in v]
                t_invariants.append(inv)

    return t_invariants

# æ£€éªŒå…¬å¹³æ€§
t_invs = compute_t_invariants(pn)
print(f"Found {len(t_invs)} T-invariants")

# æ£€æŸ¥æ˜¯å¦è¦†ç›–æ‰€æœ‰å˜è¿
all_transitions_covered = all(
    any(inv[i] > 0 for inv in t_invs)
    for i in range(len(pn.transitions))
)

if all_transitions_covered:
    print("âœ“ Fair - all transitions covered by T-invariants")
else:
    print("âœ— Unfair - some transitions never fire")
```

---

## 6 å¯é€†æ€§ä¸è°ƒåº¦å¾ªç¯

**å®šç†1.45ï¼ˆå¯é€†æ€§-å¾ªç¯å¯¹åº”ï¼‰**ï¼š

è°ƒåº¦ç³»ç»Ÿ $S$ æ˜¯**å‘¨æœŸæ€§çš„**å½“ä¸”ä»…å½“å…¶Petriç½‘è¡¨ç¤º $PN$ æ˜¯**å¯é€†çš„**ã€‚

$$
S \text{ å‘¨æœŸæ€§} \iff \forall M \in R(M_0): M_0 \in R(M)
$$

**åº”ç”¨**ï¼šå‘¨æœŸä»»åŠ¡è°ƒåº¦ã€èµ„æºå¾ªç¯åˆ©ç”¨ã€‚

---

## 7 æ€§è´¨éªŒè¯å®è·µ

**å®Œæ•´çš„æ€§è´¨éªŒè¯å·¥å…·**ï¼š

```python
class PetriNetVerifier:
    """Petriç½‘æ€§è´¨éªŒè¯å·¥å…·"""

    def __init__(self, pn, M0):
        self.pn = pn
        self.M0 = M0
        self.RG = None

    def verify_all_properties(self):
        """éªŒè¯æ‰€æœ‰æ€§è´¨"""
        print("=" * 60)
        print("Petri Net Property Verification")
        print("=" * 60)

        # æ„é€ å¯è¾¾æ€§å›¾
        self.RG = construct_reachability_graph(self.pn, self.M0)
        print(f"\nReachability Graph: {len(self.RG.nodes())} states\n")

        # éªŒè¯å„é¡¹æ€§è´¨
        self.verify_boundedness()
        self.verify_safeness()
        self.verify_liveness()
        self.verify_reversibility()
        self.verify_deadlock_freedom()

        print("=" * 60)

    def verify_boundedness(self):
        """éªŒè¯æœ‰ç•Œæ€§"""
        bounds = {}
        for p in self.pn.places:
            max_tokens = max(M[p] for M in self.RG.nodes())
            bounds[p] = max_tokens

        k = max(bounds.values())
        print(f"Boundedness: {k}-bounded")
        for p, b in bounds.items():
            print(f"  {p}: max {b} tokens")

    def verify_safeness(self):
        """éªŒè¯å®‰å…¨æ€§"""
        is_safe = all(
            M[p] <= 1
            for M in self.RG.nodes()
            for p in self.pn.places
        )
        print(f"\nSafeness: {'âœ“ Safe' if is_safe else 'âœ— Not safe'}")

    def verify_liveness(self):
        """éªŒè¯æ´»æ€§"""
        live_transitions = []
        dead_transitions = []

        for t in self.pn.transitions:
            # æ£€æŸ¥æ˜¯å¦ä»æ‰€æœ‰çŠ¶æ€éƒ½èƒ½æœ€ç»ˆä½¿èƒ½t
            is_live = all(
                self._can_eventually_enable(M, t)
                for M in self.RG.nodes()
            )

            if is_live:
                live_transitions.append(t)
            else:
                dead_transitions.append(t)

        print(f"\nLiveness:")
        print(f"  Live transitions: {len(live_transitions)}/{len(self.pn.transitions)}")
        if dead_transitions:
            print(f"  Dead transitions: {dead_transitions}")

    def _can_eventually_enable(self, M, t):
        """æ£€æŸ¥ä»Mæ˜¯å¦æœ€ç»ˆèƒ½ä½¿èƒ½t"""
        # ä½¿ç”¨BFSæœç´¢å¯è¾¾çŠ¶æ€
        visited = {M}
        queue = [M]

        while queue:
            current = queue.pop(0)

            # æ£€æŸ¥tæ˜¯å¦ä½¿èƒ½
            if is_enabled(self.pn, current, t):
                return True

            # æ¢ç´¢åç»§çŠ¶æ€
            for t_other in self.pn.transitions:
                if is_enabled(self.pn, current, t_other):
                    M_next = fire_transition(self.pn, current, t_other)
                    if M_next not in visited and M_next in self.RG.nodes():
                        visited.add(M_next)
                        queue.append(M_next)

        return False

    def verify_reversibility(self):
        """éªŒè¯å¯é€†æ€§"""
        is_reversible = all(
            self.M0 in nx.descendants(self.RG, M) or M == self.M0
            for M in self.RG.nodes()
        )
        print(f"\nReversibility: {'âœ“ Reversible' if is_reversible else 'âœ— Not reversible'}")

    def verify_deadlock_freedom(self):
        """éªŒè¯æ— æ­»é”"""
        has_deadlock, deadlock_states = detect_deadlock(self.pn, self.M0)
        print(f"\nDeadlock Freedom: {'âœ— Has deadlock' if has_deadlock else 'âœ“ Deadlock-free'}")

# ä½¿ç”¨éªŒè¯å™¨
verifier = PetriNetVerifier(my_petri_net, initial_marking)
verifier.verify_all_properties()
```

---

## 8 å®Œæ•´çš„Coqå½¢å¼åŒ–éªŒè¯

**å®Œæ•´çš„æ€§è´¨å¯¹åº”å®šç†ä½“ç³»**ï¼š

```coq
(* Coqå½¢å¼åŒ–éªŒè¯ï¼šå®Œæ•´çš„æ€§è´¨å¯¹åº”ä½“ç³» *)
Require Import List Arith Omega.
Import ListNotations.

(* Petriç½‘åŸºç¡€å®šä¹‰ *)
Record PetriNet : Type := mkPN {
  P : list nat;          (* åº“æ‰€ *)
  T : list nat;          (* å˜è¿ *)
  F : list (nat * nat);  (* å¼§ *)
  W : nat -> nat -> nat; (* æƒé‡å‡½æ•° *)
  M0 : nat -> nat;       (* åˆå§‹æ ‡è®° *)
}.

(* ä½¿èƒ½å®šä¹‰ *)
Definition enabled (pn : PetriNet) (M : nat -> nat) (t : nat) : Prop :=
  forall p, In p (P pn) ->
    (exists arc, In arc (F pn) /\ fst arc = p /\ snd arc = t) ->
    M p >= W pn p t.

(* ç‚¹ç«å®šä¹‰ *)
Definition fire (pn : PetriNet) (M : nat -> nat) (t : nat) : nat -> nat :=
  fun p => M p - W pn p t + W pn t p.

(* å¯è¾¾æ€§å®šä¹‰ *)
Inductive reachable (pn : PetriNet) : (nat -> nat) -> Prop :=
  | reach_init : reachable pn (M0 pn)
  | reach_fire : forall M M' t,
      reachable pn M ->
      enabled pn M t ->
      M' = fire pn M t ->
      reachable pn M'.

(* æœ‰ç•Œæ€§å®šä¹‰ *)
Definition bounded (pn : PetriNet) (k : nat) : Prop :=
  forall M p,
    reachable pn M ->
    In p (P pn) ->
    M p <= k.

(* æ´»æ€§å®šä¹‰ï¼ˆL4-æ´»æ€§ï¼‰ *)
Definition live (pn : PetriNet) : Prop :=
  forall M t,
    reachable pn M ->
    In t (T pn) ->
    exists M',
      reachable_from pn M M' /\
      enabled pn M' t.

(* å®šç†ï¼šæœ‰ç•Œæ€§ä¿è¯ *)
Theorem boundedness_guarantee :
  forall pn k,
    bounded pn k ->
    forall M p,
      reachable pn M ->
      In p (P pn) ->
      M p <= k.
Proof.
  intros pn k H_bounded M p H_reach H_in.
  apply H_bounded; assumption.
Qed.

(* å®šç†ï¼šæ´»æ€§è•´å«æ— æ­»é” *)
Theorem liveness_implies_deadlock_free :
  forall pn,
    live pn ->
    forall M,
      reachable pn M ->
      exists t,
        In t (T pn) /\
        enabled pn M t.
Proof.
  intros pn H_live M H_reach.
  (* åè¯æ³•ï¼šå‡è®¾æ²¡æœ‰ä½¿èƒ½çš„å˜è¿ *)
  destruct (T pn) as [|t T'] eqn:E.
  - (* æ²¡æœ‰å˜è¿ï¼ŒçŸ›ç›¾ *)
    exfalso.
    (* ... *)
  - (* è‡³å°‘æœ‰ä¸€ä¸ªå˜è¿t *)
    exists t.
    split.
    + rewrite E. left. reflexivity.
    + (* ç”±æ´»æ€§ï¼Œå­˜åœ¨å¯è¾¾çŠ¶æ€ä½¿èƒ½t *)
      assert (H_live_t := H_live M t H_reach).
      rewrite E in H_live_t.
      (* ... *)
Admitted.  (* è¯æ˜ç•¥ *)
```

---

## 9 è·¨è§†è§’é“¾æ¥

**Petriç½‘ç†è®º**ï¼š

- [10_Petriç½‘ç†è®º/10.4 Petriç½‘åˆ†ææ–¹æ³•](../../../formal_lang_view/10_Petriç½‘ç†è®º/10.4_Petriç½‘åˆ†ææ–¹æ³•.md)
- [10_Petriç½‘ç†è®º/10.8 Petriç½‘å½¢å¼åŒ–è¯æ˜é›†](../../../formal_lang_view/10_Petriç½‘ç†è®º/10.8_Petriç½‘å½¢å¼åŒ–è¯æ˜é›†.md)

**è°ƒåº¦ç³»ç»ŸéªŒè¯**ï¼š

- [09_å½¢å¼åŒ–ç†è®ºä¸è¯æ˜](../../09_å½¢å¼åŒ–ç†è®ºä¸è¯æ˜/README.md)
- [06_éªŒè¯ä¸ä¼˜åŒ–çš„Petriç½‘å·¥å…·](../06_éªŒè¯ä¸ä¼˜åŒ–çš„Petriç½‘å·¥å…·/README.md)

**å½¢å¼åŒ–éªŒè¯**ï¼š

- [formal_lang_view/04_ç±»å‹æ£€æŸ¥ä¸éªŒè¯/04.3 å½¢å¼åŒ–éªŒè¯](../../../formal_lang_view/04_ç±»å‹æ£€æŸ¥ä¸éªŒè¯/04.3_å½¢å¼åŒ–éªŒè¯.md)

---

**è¿”å›**: [01 è°ƒåº¦ç³»ç»Ÿçš„Petriç½‘åŸºç¡€](README.md)

**å‚è€ƒæ–‡çŒ®**ï¼š

1. Murata, T. (1989). "Petri nets: Properties, analysis and applications"
2. Esparza, J., & Nielsen, M. (1994). "Decidability issues for Petri nets"
3. Berthelot, G. (1987). "Transformations and decompositions of nets"

---

**æœ€åæ›´æ–°**: 2025-12-02
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
