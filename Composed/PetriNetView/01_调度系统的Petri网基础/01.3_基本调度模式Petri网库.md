# 01.3 åŸºæœ¬è°ƒåº¦æ¨¡å¼Petriç½‘åº“

> **å­ä¸»é¢˜**: 01.3
> **æ‰€å±ä¸»é¢˜**: 01 è°ƒåº¦ç³»ç»Ÿçš„Petriç½‘åŸºç¡€
> **æœ€åæ›´æ–°**: 2025-12-02
> **æ–‡æ¡£çŠ¶æ€**: âœ… æ–°å¢

---

## ğŸ“‹ ç›®å½•

- [01.3 åŸºæœ¬è°ƒåº¦æ¨¡å¼Petriç½‘åº“](#013-åŸºæœ¬è°ƒåº¦æ¨¡å¼petriç½‘åº“)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 è°ƒåº¦æ¨¡å¼æ¦‚è¿°](#1-è°ƒåº¦æ¨¡å¼æ¦‚è¿°)
  - [2 é¡ºåºè°ƒåº¦æ¨¡å¼ï¼ˆSequential Patternï¼‰](#2-é¡ºåºè°ƒåº¦æ¨¡å¼sequential-pattern)
  - [3 å¹¶è¡Œè°ƒåº¦æ¨¡å¼ï¼ˆParallel Patternï¼‰](#3-å¹¶è¡Œè°ƒåº¦æ¨¡å¼parallel-pattern)
  - [4 é€‰æ‹©è°ƒåº¦æ¨¡å¼ï¼ˆChoice Patternï¼‰](#4-é€‰æ‹©è°ƒåº¦æ¨¡å¼choice-pattern)
  - [5 å¾ªç¯è°ƒåº¦æ¨¡å¼ï¼ˆLoop Patternï¼‰](#5-å¾ªç¯è°ƒåº¦æ¨¡å¼loop-pattern)
  - [6 åŒæ­¥è°ƒåº¦æ¨¡å¼ï¼ˆSynchronization Patternï¼‰](#6-åŒæ­¥è°ƒåº¦æ¨¡å¼synchronization-pattern)
  - [7 åˆå¹¶è°ƒåº¦æ¨¡å¼ï¼ˆMerge Patternï¼‰](#7-åˆå¹¶è°ƒåº¦æ¨¡å¼merge-pattern)
  - [8 å¯å¤ç”¨Petriç½‘æ¨¡å¼åº“](#8-å¯å¤ç”¨petriç½‘æ¨¡å¼åº“)
  - [9 æ¨¡å¼ç»„åˆä¸å¤æ‚è°ƒåº¦](#9-æ¨¡å¼ç»„åˆä¸å¤æ‚è°ƒåº¦)
  - [10 å®é™…åº”ç”¨åœºæ™¯](#10-å®é™…åº”ç”¨åœºæ™¯)
    - [åœºæ™¯1ï¼šCI/CDæµæ°´çº¿](#åœºæ™¯1cicdæµæ°´çº¿)
    - [åœºæ™¯2ï¼šè®¢å•å¤„ç†æµç¨‹](#åœºæ™¯2è®¢å•å¤„ç†æµç¨‹)
    - [åœºæ™¯3ï¼šå¤šæ ¸CPUä»»åŠ¡è°ƒåº¦](#åœºæ™¯3å¤šæ ¸cpuä»»åŠ¡è°ƒåº¦)
  - [11 è·¨è§†è§’é“¾æ¥](#11-è·¨è§†è§’é“¾æ¥)

---

## 1 è°ƒåº¦æ¨¡å¼æ¦‚è¿°

**è°ƒåº¦æ¨¡å¼**æ˜¯è°ƒåº¦ç³»ç»Ÿä¸­å¸¸è§çš„ä»»åŠ¡æ‰§è¡Œæ¨¡å¼ï¼Œæ¯ç§æ¨¡å¼éƒ½æœ‰å¯¹åº”çš„Petriç½‘è¡¨ç¤ºã€‚

**åŸºæœ¬æ¨¡å¼åˆ†ç±»**ï¼š

| æ¨¡å¼ | ç¬¦å· | Petriç½‘ç‰¹å¾ | åº”ç”¨åœºæ™¯ |
|------|------|------------|---------|
| é¡ºåºï¼ˆSequentialï¼‰ | `A ; B` | ä¸²è”å˜è¿ | æµæ°´çº¿ã€ä¾èµ–ä»»åŠ¡ |
| å¹¶è¡Œï¼ˆParallelï¼‰ | `A âˆ¥ B` | å¹¶è¡Œå˜è¿ | å¤šæ ¸å¹¶è¡Œã€ç‹¬ç«‹ä»»åŠ¡ |
| é€‰æ‹©ï¼ˆChoiceï¼‰ | `A âŠ• B` | å†²çªå˜è¿ | æ¡ä»¶åˆ†æ”¯ã€ç­–ç•¥é€‰æ‹© |
| å¾ªç¯ï¼ˆLoopï¼‰ | `A*` | ç¯è·¯ç»“æ„ | å‘¨æœŸä»»åŠ¡ã€è¿­ä»£ç®—æ³• |
| åŒæ­¥ï¼ˆSyncï¼‰ | `A âŠ— B â†’ C` | æ±‡èšå˜è¿ | Joinæ“ä½œã€å±éšœåŒæ­¥ |
| åˆå¹¶ï¼ˆMergeï¼‰ | `A + B â†’ C` | æ±‡èšåº“æ‰€ | ç»“æœèšåˆã€å¤šè·¯è¾“å…¥ |

---

## 2 é¡ºåºè°ƒåº¦æ¨¡å¼ï¼ˆSequential Patternï¼‰

**å®šä¹‰1.31ï¼ˆé¡ºåºæ¨¡å¼ï¼‰**ï¼š

ä»»åŠ¡æŒ‰é¡ºåºæ‰§è¡Œï¼š$A \to B \to C$

**Petriç½‘è¡¨ç¤º**ï¼š

```text
[p_start] â†’(1)â†’ [t_A] â†’(1)â†’ [p_AB] â†’(1)â†’ [t_B] â†’(1)â†’ [p_BC] â†’(1)â†’ [t_C] â†’(1)â†’ [p_end]
```

**Pythonå®ç°**ï¼š

```python
class SequentialPattern:
    """é¡ºåºè°ƒåº¦æ¨¡å¼çš„å¯å¤ç”¨Petriç½‘"""

    @staticmethod
    def create(tasks):
        """
        åˆ›å»ºé¡ºåºè°ƒåº¦Petriç½‘

        Args:
            tasks: ä»»åŠ¡åˆ—è¡¨ ['A', 'B', 'C', ...]

        Returns:
            PetriNetå¯¹è±¡
        """
        pn = PetriNet()

        # åˆå§‹åº“æ‰€
        pn.add_place('p_start', tokens=1)

        for i, task in enumerate(tasks):
            # ä»»åŠ¡å˜è¿
            pn.add_transition(f't_{task}')

            if i == 0:
                # ç¬¬ä¸€ä¸ªä»»åŠ¡
                pn.add_arc('p_start', f't_{task}')
            else:
                # åç»­ä»»åŠ¡
                prev_place = f'p_after_{tasks[i-1]}'
                pn.add_arc(prev_place, f't_{task}')

            # ä¸­é—´åº“æ‰€
            if i < len(tasks) - 1:
                next_place = f'p_after_{task}'
                pn.add_place(next_place, tokens=0)
                pn.add_arc(f't_{task}', next_place)
            else:
                # æœ€åä¸€ä¸ªä»»åŠ¡
                pn.add_place('p_end', tokens=0)
                pn.add_arc(f't_{task}', 'p_end')

        return pn

# ä½¿ç”¨ç¤ºä¾‹ï¼šETLæµç¨‹
etl_pipeline = SequentialPattern.create(['Extract', 'Transform', 'Load'])
etl_pipeline.visualize()

# æ‰§è¡Œæµç¨‹
print("ETL Pipeline Execution:")
etl_pipeline.fire('t_Extract')
print("  âœ“ Extracted data")
etl_pipeline.fire('t_Transform')
print("  âœ“ Transformed data")
etl_pipeline.fire('t_Load')
print("  âœ“ Loaded data")
print(f"Final state: {etl_pipeline.marking['p_end']} tasks completed")
```

**æ€§è´¨åˆ†æ**ï¼š

- **æ´»æ€§**ï¼šå¦‚æœåˆå§‹æ ‡è®°æ­£ç¡®ï¼Œæ‰€æœ‰å˜è¿éƒ½èƒ½ç‚¹ç«
- **æœ‰ç•Œæ€§**ï¼šæ¯ä¸ªåº“æ‰€æœ€å¤š1ä¸ªæ ‡è®°ï¼ˆå®‰å…¨ç½‘ï¼‰
- **å¯è¾¾æ€§**ï¼šå­˜åœ¨å”¯ä¸€çš„æ‰§è¡Œè·¯å¾„

---

## 3 å¹¶è¡Œè°ƒåº¦æ¨¡å¼ï¼ˆParallel Patternï¼‰

**å®šä¹‰1.32ï¼ˆå¹¶è¡Œæ¨¡å¼ï¼‰**ï¼š

å¤šä¸ªä»»åŠ¡åŒæ—¶æ‰§è¡Œï¼š$A \parallel B \parallel C$

**Petriç½‘è¡¨ç¤º**ï¼š

```text
           â”Œâ†’ [t_A] â†’â”
[p_start] â†’â”œâ†’ [t_B] â†’â”œâ†’ [p_end]
           â””â†’ [t_C] â†’â”˜
```

**Pythonå®ç°**ï¼š

```python
class ParallelPattern:
    """å¹¶è¡Œè°ƒåº¦æ¨¡å¼çš„å¯å¤ç”¨Petriç½‘"""

    @staticmethod
    def create(tasks):
        """
        åˆ›å»ºå¹¶è¡Œè°ƒåº¦Petriç½‘ï¼ˆFork-Joinï¼‰

        Args:
            tasks: å¹¶è¡Œä»»åŠ¡åˆ—è¡¨ ['A', 'B', 'C', ...]

        Returns:
            PetriNetå¯¹è±¡
        """
        pn = PetriNet()

        # Forkï¼šåˆ†å‘æ ‡è®°
        pn.add_place('p_start', tokens=1)
        pn.add_transition('t_fork')
        pn.add_arc('p_start', 't_fork')

        # å¹¶è¡Œä»»åŠ¡åˆ†æ”¯
        for task in tasks:
            # ä»»åŠ¡å‰åº“æ‰€
            pn.add_place(f'p_{task}_ready', tokens=0)
            pn.add_arc('t_fork', f'p_{task}_ready')

            # ä»»åŠ¡å˜è¿
            pn.add_transition(f't_{task}')
            pn.add_arc(f'p_{task}_ready', f't_{task}')

            # ä»»åŠ¡ååº“æ‰€
            pn.add_place(f'p_{task}_done', tokens=0)
            pn.add_arc(f't_{task}', f'p_{task}_done')

        # Joinï¼šæ±‡èšæ ‡è®°
        pn.add_transition('t_join')
        for task in tasks:
            pn.add_arc(f'p_{task}_done', 't_join')

        pn.add_place('p_end', tokens=0)
        pn.add_arc('t_join', 'p_end')

        return pn

# ä½¿ç”¨ç¤ºä¾‹ï¼šMapReduce
map_tasks = ['Map1', 'Map2', 'Map3']
map_reduce_pn = ParallelPattern.create(map_tasks)

# æ‰§è¡ŒFork
map_reduce_pn.fire('t_fork')
print("Forked to parallel Map tasks")

# å¹¶è¡Œæ‰§è¡ŒMapä»»åŠ¡
for task in map_tasks:
    if map_reduce_pn.is_enabled(f't_{task}'):
        map_reduce_pn.fire(f't_{task}')
        print(f"  âœ“ Completed {task}")

# Join
if map_reduce_pn.is_enabled('t_join'):
    map_reduce_pn.fire('t_join')
    print("Joined all Map results")
```

**æ€§è´¨åˆ†æ**ï¼š

- **å¹¶å‘åº¦**ï¼šæœ€å¤§å¹¶å‘åº¦ = å¹¶è¡Œä»»åŠ¡æ•°é‡
- **åŒæ­¥ç‚¹**ï¼šJoinå˜è¿éœ€è¦æ‰€æœ‰åˆ†æ”¯å®Œæˆ
- **å…¬å¹³æ€§**ï¼šæ‰€æœ‰å¹¶è¡Œåˆ†æ”¯éƒ½ä¼šæ‰§è¡Œ

---

## 4 é€‰æ‹©è°ƒåº¦æ¨¡å¼ï¼ˆChoice Patternï¼‰

**å®šä¹‰1.33ï¼ˆé€‰æ‹©æ¨¡å¼ï¼‰**ï¼š

æ ¹æ®æ¡ä»¶é€‰æ‹©æ‰§è¡ŒæŸä¸ªä»»åŠ¡ï¼š$A \oplus B$ï¼ˆäº’æ–¥ï¼‰

**Petriç½‘è¡¨ç¤º**ï¼š

```text
          â”Œâ†’ [t_A] â†’â”
[p_start] â”¤         â”œâ†’ [p_end]
          â””â†’ [t_B] â†’â”˜
```

**Pythonå®ç°**ï¼š

```python
class ChoicePattern:
    """é€‰æ‹©è°ƒåº¦æ¨¡å¼çš„å¯å¤ç”¨Petriç½‘"""

    @staticmethod
    def create(choices):
        """
        åˆ›å»ºé€‰æ‹©è°ƒåº¦Petriç½‘ï¼ˆäº’æ–¥é€‰æ‹©ï¼‰

        Args:
            choices: é€‰æ‹©åˆ†æ”¯åˆ—è¡¨ ['A', 'B', 'C', ...]

        Returns:
            PetriNetå¯¹è±¡
        """
        pn = PetriNet()

        # åˆå§‹åº“æ‰€ï¼ˆæ ‡è®°åœ¨è¿™é‡Œï¼Œé€‰æ‹©å¼€å§‹ï¼‰
        pn.add_place('p_choice_point', tokens=1)

        # æ¯ä¸ªé€‰æ‹©åˆ†æ”¯
        for choice in choices:
            # é€‰æ‹©å˜è¿ï¼ˆå†²çªå˜è¿ï¼‰
            pn.add_transition(f't_choose_{choice}')
            pn.add_arc('p_choice_point', f't_choose_{choice}')

            # é€‰æ‹©åçš„æ‰§è¡Œ
            pn.add_place(f'p_{choice}_executing', tokens=0)
            pn.add_arc(f't_choose_{choice}', f'p_{choice}_executing')

            # æ‰§è¡Œå˜è¿
            pn.add_transition(f't_execute_{choice}')
            pn.add_arc(f'p_{choice}_executing', f't_execute_{choice}')

            # å®Œæˆåæ±‡èšåˆ°ç»“æŸåº“æ‰€
            pn.add_arc(f't_execute_{choice}', 'p_end')

        # ç»“æŸåº“æ‰€
        pn.add_place('p_end', tokens=0)

        return pn

# ä½¿ç”¨ç¤ºä¾‹ï¼šè°ƒåº¦ç­–ç•¥é€‰æ‹©
strategies = ['FCFS', 'SJF', 'RoundRobin']
strategy_choice_pn = ChoicePattern.create(strategies)

# éç¡®å®šæ€§é€‰æ‹©ï¼ˆå®é™…ç³»ç»Ÿä¸­ç”±æ¡ä»¶å†³å®šï¼‰
import random
chosen_strategy = random.choice(strategies)
strategy_choice_pn.fire(f't_choose_{chosen_strategy}')
print(f"Chosen strategy: {chosen_strategy}")

strategy_choice_pn.fire(f't_execute_{chosen_strategy}')
print(f"Executed {chosen_strategy} strategy")
```

**å†²çªè§£å†³æœºåˆ¶**ï¼š

```python
class ConflictResolution:
    """å†²çªè§£å†³ç­–ç•¥"""

    @staticmethod
    def priority_based(pn, conflicts, priorities):
        """
        åŸºäºä¼˜å…ˆçº§çš„å†²çªè§£å†³

        Args:
            pn: Petriç½‘
            conflicts: å†²çªå˜è¿åˆ—è¡¨
            priorities: ä¼˜å…ˆçº§å­—å…¸ {transition: priority}
        """
        enabled = [t for t in conflicts if pn.is_enabled(t)]
        if enabled:
            # é€‰æ‹©ä¼˜å…ˆçº§æœ€é«˜çš„å˜è¿
            return max(enabled, key=lambda t: priorities.get(t, 0))
        return None

    @staticmethod
    def random_choice(pn, conflicts):
        """éšæœºé€‰æ‹©"""
        enabled = [t for t in conflicts if pn.is_enabled(t)]
        return random.choice(enabled) if enabled else None

    @staticmethod
    def round_robin(pn, conflicts, last_fired):
        """è½®è¯¢é€‰æ‹©"""
        enabled = [t for t in conflicts if pn.is_enabled(t)]
        if not enabled:
            return None

        # æ‰¾åˆ°ä¸Šæ¬¡ç‚¹ç«åçš„ä¸‹ä¸€ä¸ª
        try:
            idx = conflicts.index(last_fired)
            next_idx = (idx + 1) % len(conflicts)
            for i in range(len(conflicts)):
                candidate = conflicts[(next_idx + i) % len(conflicts)]
                if candidate in enabled:
                    return candidate
        except ValueError:
            return enabled[0]

        return enabled[0]
```

---

## 5 å¾ªç¯è°ƒåº¦æ¨¡å¼ï¼ˆLoop Patternï¼‰

**å®šä¹‰1.34ï¼ˆå¾ªç¯æ¨¡å¼ï¼‰**ï¼š

ä»»åŠ¡é‡å¤æ‰§è¡Œï¼š$\text{while}(condition) \{ A \}$

**Petriç½‘è¡¨ç¤º**ï¼š

```text
[p_ready] â†’(1)â†’ [t_A] â†’(1)â†’ [p_done]
              â†–____________â†™ (å¾ªç¯å¼§)
```

**Pythonå®ç°**ï¼š

```python
class LoopPattern:
    """å¾ªç¯è°ƒåº¦æ¨¡å¼çš„å¯å¤ç”¨Petriç½‘"""

    @staticmethod
    def create(task, loop_condition='always', max_iterations=None):
        """
        åˆ›å»ºå¾ªç¯è°ƒåº¦Petriç½‘

        Args:
            task: å¾ªç¯æ‰§è¡Œçš„ä»»åŠ¡åç§°
            loop_condition: å¾ªç¯æ¡ä»¶
            max_iterations: æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼ˆå¯é€‰ï¼‰

        Returns:
            PetriNetå¯¹è±¡
        """
        pn = PetriNet()

        # å¾ªç¯å‡†å¤‡åº“æ‰€
        pn.add_place('p_loop_ready', tokens=1)

        # å¾ªç¯ä½“å˜è¿
        pn.add_transition(f't_{task}')
        pn.add_arc('p_loop_ready', f't_{task}')
        pn.add_arc(f't_{task}', 'p_loop_ready')  # å¾ªç¯å¼§

        # å¦‚æœæœ‰æœ€å¤§è¿­ä»£æ¬¡æ•°ï¼Œæ·»åŠ è®¡æ•°æœºåˆ¶
        if max_iterations:
            pn.add_place('p_iterations_left', tokens=max_iterations)
            pn.add_arc('p_iterations_left', f't_{task}')

            # ç»ˆæ­¢æ¡ä»¶
            pn.add_transition('t_terminate')
            pn.add_arc('p_loop_ready', 't_terminate')
            pn.add_place('p_terminated', tokens=0)
            pn.add_arc('t_terminate', 'p_terminated')

        return pn

# ä½¿ç”¨ç¤ºä¾‹ï¼šå‘¨æœŸä»»åŠ¡è°ƒåº¦
periodic_task = LoopPattern.create('PeriodicBackup', max_iterations=5)

# æ‰§è¡Œ5æ¬¡è¿­ä»£
for i in range(5):
    if periodic_task.is_enabled('t_PeriodicBackup'):
        periodic_task.fire('t_PeriodicBackup')
        print(f"Iteration {i+1}: Backup completed")
    else:
        print("Loop terminated")
        break
```

**æœ‰ç•Œå¾ªç¯å®ç°**ï¼š

```python
class BoundedLoopPattern:
    """æœ‰ç•Œå¾ªç¯æ¨¡å¼ï¼ˆå¸¦è®¡æ•°å™¨ï¼‰"""

    @staticmethod
    def create(task, iterations):
        """
        åˆ›å»ºæœ‰ç•Œå¾ªç¯Petriç½‘
        ä½¿ç”¨è®¡æ•°åº“æ‰€é™åˆ¶è¿­ä»£æ¬¡æ•°
        """
        pn = PetriNet()

        # è®¡æ•°å™¨åº“æ‰€
        pn.add_place('p_counter', tokens=iterations)

        # å¾ªç¯ä½“
        pn.add_place('p_ready', tokens=1)
        pn.add_transition(f't_{task}')

        # å¼§ï¼šæ¯æ¬¡å¾ªç¯æ¶ˆè€—ä¸€ä¸ªè®¡æ•°
        pn.add_arc('p_ready', f't_{task}')
        pn.add_arc('p_counter', f't_{task}')
        pn.add_arc(f't_{task}', 'p_ready')

        # å®Œæˆåº“æ‰€ï¼ˆè®¡æ•°ç”¨å°½åï¼‰
        pn.add_place('p_completed', tokens=0)
        pn.add_transition('t_complete')
        pn.add_arc('p_ready', 't_complete')
        pn.add_arc('t_complete', 'p_completed')

        return pn
```

---

## 6 åŒæ­¥è°ƒåº¦æ¨¡å¼ï¼ˆSynchronization Patternï¼‰

**å®šä¹‰1.35ï¼ˆåŒæ­¥æ¨¡å¼ï¼‰**ï¼š

å¤šä¸ªä»»åŠ¡å®Œæˆåæ‰§è¡ŒåŒæ­¥æ“ä½œï¼š$(A \parallel B) \to C$

**Petriç½‘è¡¨ç¤ºï¼ˆAND-Joinï¼‰**ï¼š

```text
[t_A] â†’(1)â†’ [p_A_done] â†˜
                        [t_sync] â†’(1)â†’ [p_end]
[t_B] â†’(1)â†’ [p_B_done] â†—
```

**Pythonå®ç°**ï¼š

```python
class SynchronizationPattern:
    """åŒæ­¥è°ƒåº¦æ¨¡å¼çš„å¯å¤ç”¨Petriç½‘"""

    @staticmethod
    def create(parallel_tasks, sync_task):
        """
        åˆ›å»ºåŒæ­¥è°ƒåº¦Petriç½‘ï¼ˆBarrier Synchronizationï¼‰

        Args:
            parallel_tasks: å¹¶è¡Œä»»åŠ¡åˆ—è¡¨
            sync_task: åŒæ­¥ä»»åŠ¡åç§°

        Returns:
            PetriNetå¯¹è±¡
        """
        pn = PetriNet()

        # Forké˜¶æ®µ
        pn.add_place('p_start', tokens=1)
        pn.add_transition('t_fork')
        pn.add_arc('p_start', 't_fork')

        # å¹¶è¡Œä»»åŠ¡
        for task in parallel_tasks:
            # Readyåº“æ‰€
            pn.add_place(f'p_{task}_ready', tokens=0)
            pn.add_arc('t_fork', f'p_{task}_ready')

            # ä»»åŠ¡å˜è¿
            pn.add_transition(f't_{task}')
            pn.add_arc(f'p_{task}_ready', f't_{task}')

            # Doneåº“æ‰€ï¼ˆç”¨äºåŒæ­¥ï¼‰
            pn.add_place(f'p_{task}_done', tokens=0)
            pn.add_arc(f't_{task}', f'p_{task}_done')

        # åŒæ­¥å˜è¿ï¼ˆéœ€è¦æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼‰
        pn.add_transition(f't_{sync_task}')
        for task in parallel_tasks:
            pn.add_arc(f'p_{task}_done', f't_{sync_task}')

        # åŒæ­¥åçš„åº“æ‰€
        pn.add_place('p_sync_done', tokens=0)
        pn.add_arc(f't_{sync_task}', 'p_sync_done')

        return pn

# ä½¿ç”¨ç¤ºä¾‹ï¼šMapReduce
mappers = ['Mapper1', 'Mapper2', 'Mapper3']
mapreduce_pn = SynchronizationPattern.create(mappers, 'Reduce')

# Fork
mapreduce_pn.fire('t_fork')
print("Forked to parallel mappers")

# å¹¶è¡ŒMap
for mapper in mappers:
    mapreduce_pn.fire(f't_{mapper}')
    print(f"  âœ“ {mapper} completed")

# Reduceï¼ˆéœ€è¦ç­‰å¾…æ‰€æœ‰Mapperå®Œæˆï¼‰
if mapreduce_pn.is_enabled('t_Reduce'):
    mapreduce_pn.fire('t_Reduce')
    print("âœ“ Reduce completed (synchronized)")
else:
    print("âœ— Reduce waiting for all mappers")
```

---

## 7 åˆå¹¶è°ƒåº¦æ¨¡å¼ï¼ˆMerge Patternï¼‰

**å®šä¹‰1.36ï¼ˆåˆå¹¶æ¨¡å¼ï¼‰**ï¼š

å¤šä¸ªä»»åŠ¡çš„è¾“å‡ºåˆå¹¶ï¼š$A + B \to C$ï¼ˆOR-Joinï¼‰

**Petriç½‘è¡¨ç¤º**ï¼š

```text
[t_A] â†’(1)â†’ â†˜
            [p_merge] â†’(1)â†’ [t_C] â†’(1)â†’ [p_end]
[t_B] â†’(1)â†’ â†—
```

**Pythonå®ç°**ï¼š

```python
class MergePattern:
    """åˆå¹¶è°ƒåº¦æ¨¡å¼çš„å¯å¤ç”¨Petriç½‘"""

    @staticmethod
    def create(input_tasks, merge_task):
        """
        åˆ›å»ºåˆå¹¶è°ƒåº¦Petriç½‘ï¼ˆOR-Joinï¼‰

        Args:
            input_tasks: è¾“å…¥ä»»åŠ¡åˆ—è¡¨
            merge_task: åˆå¹¶ä»»åŠ¡åç§°

        Returns:
            PetriNetå¯¹è±¡
        """
        pn = PetriNet()

        # åˆå¹¶åº“æ‰€ï¼ˆæ¥æ”¶ä»»æ„è¾“å…¥ï¼‰
        pn.add_place('p_merge', tokens=0)

        # è¾“å…¥ä»»åŠ¡
        for task in input_tasks:
            pn.add_place(f'p_{task}_ready', tokens=1)
            pn.add_transition(f't_{task}')
            pn.add_arc(f'p_{task}_ready', f't_{task}')
            pn.add_arc(f't_{task}', 'p_merge')

        # åˆå¹¶ä»»åŠ¡ï¼ˆåªè¦æœ‰ä¸€ä¸ªè¾“å…¥å°±èƒ½æ‰§è¡Œï¼‰
        pn.add_transition(f't_{merge_task}')
        pn.add_arc('p_merge', f't_{merge_task}')

        pn.add_place('p_end', tokens=0)
        pn.add_arc(f't_{merge_task}', 'p_end')

        return pn

# ä½¿ç”¨ç¤ºä¾‹ï¼šå¤šæ•°æ®æºèšåˆ
data_sources = ['DB1', 'DB2', 'Cache']
aggregate_pn = MergePattern.create(data_sources, 'Aggregate')

# ä»»æ„æ•°æ®æºå®Œæˆå³å¯è§¦å‘èšåˆ
aggregate_pn.fire('t_DB1')
print("DB1 data ready")

if aggregate_pn.is_enabled('t_Aggregate'):
    aggregate_pn.fire('t_Aggregate')
    print("Aggregated results")
```

---

## 8 å¯å¤ç”¨Petriç½‘æ¨¡å¼åº“

**å®Œæ•´çš„æ¨¡å¼åº“å®ç°**ï¼š

```python
class PetriNetPatternLibrary:
    """Petriç½‘è°ƒåº¦æ¨¡å¼åº“"""

    def __init__(self):
        self.patterns = {
            'sequential': SequentialPattern,
            'parallel': ParallelPattern,
            'choice': ChoicePattern,
            'loop': LoopPattern,
            'synchronization': SynchronizationPattern,
            'merge': MergePattern
        }

    def create_pattern(self, pattern_type, **kwargs):
        """
        æ ¹æ®æ¨¡å¼ç±»å‹åˆ›å»ºPetriç½‘

        Args:
            pattern_type: æ¨¡å¼ç±»å‹
            **kwargs: æ¨¡å¼å‚æ•°

        Returns:
            PetriNetå¯¹è±¡
        """
        if pattern_type not in self.patterns:
            raise ValueError(f"Unknown pattern: {pattern_type}")

        pattern_class = self.patterns[pattern_type]
        return pattern_class.create(**kwargs)

    def compose_patterns(self, pattern_specs):
        """
        ç»„åˆå¤šä¸ªæ¨¡å¼

        Args:
            pattern_specs: æ¨¡å¼è§„èŒƒåˆ—è¡¨
                [('sequential', {'tasks': ['A', 'B']}),
                 ('parallel', {'tasks': ['C', 'D']})]

        Returns:
            ç»„åˆåçš„PetriNetå¯¹è±¡
        """
        pn = PetriNet()

        for i, (pattern_type, params) in enumerate(pattern_specs):
            sub_pn = self.create_pattern(pattern_type, **params)
            # åˆå¹¶å­ç½‘åˆ°ä¸»ç½‘ï¼ˆå®ç°ç•¥ï¼‰
            # pn.merge(sub_pn, merge_strategy)

        return pn

# ä½¿ç”¨æ¨¡å¼åº“
library = PetriNetPatternLibrary()

# åˆ›å»ºä¸åŒæ¨¡å¼
seq_pn = library.create_pattern('sequential', tasks=['A', 'B', 'C'])
par_pn = library.create_pattern('parallel', tasks=['X', 'Y', 'Z'])
choice_pn = library.create_pattern('choice', choices=['Option1', 'Option2'])
```

---

## 9 æ¨¡å¼ç»„åˆä¸å¤æ‚è°ƒåº¦

**å¤æ‚è°ƒåº¦ç³»ç»Ÿ = åŸºæœ¬æ¨¡å¼ç»„åˆ**

**ç¤ºä¾‹ï¼šå¤æ‚å·¥ä½œæµ**

```text
Sequential(
    Parallel(A, B, C),
    Choice(X, Y),
    Loop(Z)
)
```

**Pythonå®ç°**ï¼š

```python
class ComplexSchedulingPattern:
    """å¤æ‚è°ƒåº¦æ¨¡å¼ç»„åˆ"""

    @staticmethod
    def create_complex_workflow():
        """
        åˆ›å»ºå¤æ‚å·¥ä½œæµï¼š
        1. å¹¶è¡Œæ‰§è¡ŒAã€Bã€C
        2. é€‰æ‹©æ‰§è¡ŒXæˆ–Y
        3. å¾ªç¯æ‰§è¡ŒZï¼ˆ3æ¬¡ï¼‰
        """
        pn = PetriNet()

        # é˜¶æ®µ1ï¼šå¹¶è¡Œæ‰§è¡Œ
        pn.add_place('p_start', tokens=1)
        pn.add_transition('t_fork')
        pn.add_arc('p_start', 't_fork')

        parallel_tasks = ['A', 'B', 'C']
        for task in parallel_tasks:
            pn.add_place(f'p_{task}_ready', tokens=0)
            pn.add_arc('t_fork', f'p_{task}_ready')

            pn.add_transition(f't_{task}')
            pn.add_arc(f'p_{task}_ready', f't_{task}')

            pn.add_place(f'p_{task}_done', tokens=0)
            pn.add_arc(f't_{task}', f'p_{task}_done')

        # Joinå¹¶è¡Œç»“æœ
        pn.add_transition('t_join')
        for task in parallel_tasks:
            pn.add_arc(f'p_{task}_done', 't_join')

        # é˜¶æ®µ2ï¼šé€‰æ‹©æ‰§è¡Œ
        pn.add_place('p_choice', tokens=0)
        pn.add_arc('t_join', 'p_choice')

        choices = ['X', 'Y']
        for choice in choices:
            pn.add_transition(f't_{choice}')
            pn.add_arc('p_choice', f't_{choice}')
            pn.add_arc(f't_{choice}', 'p_after_choice')

        # é˜¶æ®µ3ï¼šå¾ªç¯æ‰§è¡Œ
        pn.add_place('p_after_choice', tokens=0)
        pn.add_place('p_loop_counter', tokens=3)

        pn.add_transition('t_Z')
        pn.add_arc('p_after_choice', 't_Z')
        pn.add_arc('p_loop_counter', 't_Z')
        pn.add_arc('t_Z', 'p_after_choice')  # å¾ªç¯

        # å®Œæˆ
        pn.add_place('p_end', tokens=0)
        pn.add_transition('t_complete')
        pn.add_arc('p_after_choice', 't_complete')
        pn.add_arc('t_complete', 'p_end')

        return pn

# ä½¿ç”¨å¤æ‚æ¨¡å¼
complex_wf = ComplexSchedulingPattern.create_complex_workflow()
complex_wf.visualize()
```

---

## 10 å®é™…åº”ç”¨åœºæ™¯

### åœºæ™¯1ï¼šCI/CDæµæ°´çº¿

```python
def create_cicd_pipeline():
    """
    CI/CDæµæ°´çº¿Petriç½‘å»ºæ¨¡

    æµç¨‹ï¼š
    1. Code Commit
    2. Parallel: [Build, Test, Lint]
    3. Merge results
    4. Deploy (if all passed)
    """
    library = PetriNetPatternLibrary()

    pn = PetriNet()

    # 1. é¡ºåºï¼šCommit
    pn.add_place('p_start', tokens=1)
    pn.add_transition('t_commit')
    pn.add_arc('p_start', 't_commit')

    # 2. å¹¶è¡Œï¼šBuild, Test, Lint
    pn.add_place('p_after_commit', tokens=0)
    pn.add_arc('t_commit', 'p_after_commit')

    pn.add_transition('t_fork')
    pn.add_arc('p_after_commit', 't_fork')

    tasks = ['Build', 'Test', 'Lint']
    for task in tasks:
        pn.add_place(f'p_{task}_ready', tokens=0)
        pn.add_arc('t_fork', f'p_{task}_ready')

        pn.add_transition(f't_{task}')
        pn.add_arc(f'p_{task}_ready', f't_{task}')

        pn.add_place(f'p_{task}_done', tokens=0)
        pn.add_arc(f't_{task}', f'p_{task}_done')

    # 3. åŒæ­¥ï¼šç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    pn.add_transition('t_sync')
    for task in tasks:
        pn.add_arc(f'p_{task}_done', 't_sync')

    # 4. é€‰æ‹©ï¼šDeployæˆ–Fail
    pn.add_place('p_all_passed', tokens=0)
    pn.add_arc('t_sync', 'p_all_passed')

    # Deployåˆ†æ”¯
    pn.add_transition('t_deploy')
    pn.add_arc('p_all_passed', 't_deploy')
    pn.add_place('p_deployed', tokens=0)
    pn.add_arc('t_deploy', 'p_deployed')

    # Failåˆ†æ”¯
    pn.add_transition('t_rollback')
    pn.add_arc('p_all_passed', 't_rollback')
    pn.add_place('p_failed', tokens=0)
    pn.add_arc('t_rollback', 'p_failed')

    return pn

# è¿è¡ŒCI/CD
cicd_pn = create_cicd_pipeline()
cicd_pn.visualize()
```

### åœºæ™¯2ï¼šè®¢å•å¤„ç†æµç¨‹

```python
def create_order_processing():
    """
    ç”µå•†è®¢å•å¤„ç†Petriç½‘å»ºæ¨¡

    æµç¨‹ï¼š
    1. æ¥æ”¶è®¢å•
    2. å¹¶è¡Œï¼š[éªŒè¯åº“å­˜, éªŒè¯æ”¯ä»˜, éªŒè¯åœ°å€]
    3. é€‰æ‹©ï¼šå…¨éƒ¨é€šè¿‡â†’å‘è´§ï¼Œå¦åˆ™â†’å–æ¶ˆ
    4. å¾ªç¯ï¼šé‡è¯•æœºåˆ¶
    """
    pn = PetriNet()

    # æ¥æ”¶è®¢å•
    pn.add_place('p_order_received', tokens=1)
    pn.add_transition('t_receive_order')
    pn.add_arc('p_order_received', 't_receive_order')

    # å¹¶è¡ŒéªŒè¯
    pn.add_place('p_validating', tokens=0)
    pn.add_arc('t_receive_order', 'p_validating')

    pn.add_transition('t_fork_validation')
    pn.add_arc('p_validating', 't_fork_validation')

    validations = ['CheckInventory', 'CheckPayment', 'CheckAddress']
    for val in validations:
        pn.add_place(f'p_{val}_ready', tokens=0)
        pn.add_arc('t_fork_validation', f'p_{val}_ready')

        pn.add_transition(f't_{val}')
        pn.add_arc(f'p_{val}_ready', f't_{val}')

        pn.add_place(f'p_{val}_done', tokens=0)
        pn.add_arc(f't_{val}', f'p_{val}_done')

    # JoinéªŒè¯ç»“æœ
    pn.add_transition('t_join_validation')
    for val in validations:
        pn.add_arc(f'p_{val}_done', 't_join_validation')

    # é€‰æ‹©ï¼šå‘è´§æˆ–å–æ¶ˆ
    pn.add_place('p_validated', tokens=0)
    pn.add_arc('t_join_validation', 'p_validated')

    # å‘è´§åˆ†æ”¯
    pn.add_transition('t_ship')
    pn.add_arc('p_validated', 't_ship')
    pn.add_place('p_shipped', tokens=0)
    pn.add_arc('t_ship', 'p_shipped')

    # å–æ¶ˆåˆ†æ”¯
    pn.add_transition('t_cancel')
    pn.add_arc('p_validated', 't_cancel')
    pn.add_place('p_cancelled', tokens=0)
    pn.add_arc('t_cancel', 'p_cancelled')

    return pn
```

### åœºæ™¯3ï¼šå¤šæ ¸CPUä»»åŠ¡è°ƒåº¦

```python
def create_multicore_scheduling(num_cores=4, tasks=None):
    """
    å¤šæ ¸CPUä»»åŠ¡è°ƒåº¦Petriç½‘å»ºæ¨¡

    Args:
        num_cores: CPUæ ¸å¿ƒæ•°
        tasks: ä»»åŠ¡åˆ—è¡¨

    Returns:
        PetriNetå¯¹è±¡
    """
    if tasks is None:
        tasks = [f'Task{i}' for i in range(1, 11)]  # é»˜è®¤10ä¸ªä»»åŠ¡

    pn = PetriNet()

    # CPUèµ„æºåº“æ‰€ï¼ˆå¯ç”¨æ ¸å¿ƒæ•°ï¼‰
    pn.add_place('p_cpu_cores', tokens=num_cores)

    # ä»»åŠ¡é˜Ÿåˆ—
    pn.add_place('p_task_queue', tokens=len(tasks))

    for task in tasks:
        # ä»»åŠ¡è°ƒåº¦å˜è¿ï¼ˆéœ€è¦1ä¸ªCPUæ ¸å¿ƒï¼‰
        pn.add_transition(f't_schedule_{task}')
        pn.add_arc('p_task_queue', f't_schedule_{task}')
        pn.add_arc('p_cpu_cores', f't_schedule_{task}')

        # ä»»åŠ¡æ‰§è¡Œä¸­
        pn.add_place(f'p_{task}_running', tokens=0)
        pn.add_arc(f't_schedule_{task}', f'p_{task}_running')

        # ä»»åŠ¡å®Œæˆå˜è¿ï¼ˆé‡Šæ”¾CPUæ ¸å¿ƒï¼‰
        pn.add_transition(f't_complete_{task}')
        pn.add_arc(f'p_{task}_running', f't_complete_{task}')
        pn.add_arc(f't_complete_{task}', 'p_cpu_cores')  # é‡Šæ”¾æ ¸å¿ƒ

        # å®Œæˆåº“æ‰€
        pn.add_place(f'p_{task}_done', tokens=0)
        pn.add_arc(f't_complete_{task}', f'p_{task}_done')

    return pn

# æ¨¡æ‹Ÿ4æ ¸CPUè°ƒåº¦10ä¸ªä»»åŠ¡
cpu_scheduling = create_multicore_scheduling(num_cores=4, tasks=[f'T{i}' for i in range(1, 11)])

print("Starting 4-core CPU scheduling:")
print(f"Available cores: {cpu_scheduling.marking['p_cpu_cores']}")
print(f"Task queue: {cpu_scheduling.marking['p_task_queue']}")

# æœ€å¤šåŒæ—¶è¿è¡Œ4ä¸ªä»»åŠ¡
for i in range(10):
    task_name = f'T{i+1}'
    if cpu_scheduling.is_enabled(f't_schedule_{task_name}'):
        cpu_scheduling.fire(f't_schedule_{task_name}')
        print(f"  âœ“ Scheduled {task_name}, cores available: {cpu_scheduling.marking['p_cpu_cores']}")
```

---

## 11 è·¨è§†è§’é“¾æ¥

**Petriç½‘åŸºç¡€**ï¼š

- [01.1 Petriç½‘åŸºæœ¬æ¦‚å¿µä¸å®šä¹‰](01.1_Petriç½‘åŸºæœ¬æ¦‚å¿µä¸å®šä¹‰.md)
- [01.2 è°ƒåº¦ç³»ç»Ÿå…ƒç´ åˆ°Petriç½‘çš„æ˜ å°„](01.2_è°ƒåº¦ç³»ç»Ÿå…ƒç´ åˆ°Petriç½‘çš„æ˜ å°„.md)

**å·¥ä½œæµæ¨¡å¼**ï¼š

- [04_å·¥ä½œæµè°ƒåº¦çš„Petriç½‘åˆ†æ](../04_å·¥ä½œæµè°ƒåº¦çš„Petriç½‘åˆ†æ/README.md)
- [30_å·¥ä½œæµè°ƒåº¦/30.2 å·¥ä½œæµæ¨¡å¼](../../30_å·¥ä½œæµè°ƒåº¦/30.2_å·¥ä½œæµæ¨¡å¼.md)

**å®é™…è°ƒåº¦ç³»ç»Ÿ**ï¼š

- [06_è°ƒåº¦æ¨¡å‹](../../06_è°ƒåº¦æ¨¡å‹/README.md)
- [03_OSæŠ½è±¡å±‚/03.1 è¿›ç¨‹è°ƒåº¦æ¨¡å‹](../../03_OSæŠ½è±¡å±‚/03.1_è¿›ç¨‹è°ƒåº¦æ¨¡å‹.md)

---

**è¿”å›**: [01 è°ƒåº¦ç³»ç»Ÿçš„Petriç½‘åŸºç¡€](README.md)

**å‚è€ƒæ–‡çŒ®**ï¼š

1. van der Aalst, W.M.P., et al. (2003). "Workflow Patterns"
2. Russell, N., et al. (2006). "Workflow Control-Flow Patterns: A Revised View"
3. Jensen, K. (2009). "Coloured Petri Nets: Modelling and Validation"

---

**æœ€åæ›´æ–°**: 2025-12-02
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
