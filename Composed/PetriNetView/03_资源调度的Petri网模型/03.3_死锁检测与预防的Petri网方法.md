# 03.3 æ­»é”æ£€æµ‹ä¸é¢„é˜²çš„Petriç½‘æ–¹æ³•

> **å­ä¸»é¢˜**: 03.3
> **æ‰€å±ä¸»é¢˜**: 03 èµ„æºè°ƒåº¦çš„Petriç½‘æ¨¡å‹
> **æœ€åæ›´æ–°**: 2025-12-02

---

## ğŸ“‹ ç›®å½•

- [03.3 æ­»é”æ£€æµ‹ä¸é¢„é˜²çš„Petriç½‘æ–¹æ³•](#033-æ­»é”æ£€æµ‹ä¸é¢„é˜²çš„petriç½‘æ–¹æ³•)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 æ­»é”çš„Petriç½‘å®šä¹‰](#1-æ­»é”çš„petriç½‘å®šä¹‰)
  - [2 Bankerç®—æ³•çš„Petriç½‘è¡¨ç¤º](#2-bankerç®—æ³•çš„petriç½‘è¡¨ç¤º)
  - [3 S-ä¸å˜é‡ä¸æ­»é”é¢„é˜²](#3-s-ä¸å˜é‡ä¸æ­»é”é¢„é˜²)
  - [4 TINAå·¥å…·æ­»é”æ£€æµ‹å®è·µ](#4-tinaå·¥å…·æ­»é”æ£€æµ‹å®è·µ)
  - [5 å®é™…æ¡ˆä¾‹ï¼šå“²å­¦å®¶å°±é¤é—®é¢˜](#5-å®é™…æ¡ˆä¾‹å“²å­¦å®¶å°±é¤é—®é¢˜)

---

## 1 æ­»é”çš„Petriç½‘å®šä¹‰

**å®šä¹‰3.31ï¼ˆæ­»é”çŠ¶æ€ï¼‰**ï¼š

æ ‡è®° $M$ æ˜¯**æ­»é”çŠ¶æ€**ï¼Œå¦‚æœï¼š

$$
\not\exists t \in T: M[t\rangle
$$

å³ï¼šæ²¡æœ‰ä»»ä½•å˜è¿ä½¿èƒ½ã€‚

**æ­»é”æ£€æµ‹**ï¼š

```python
def is_deadlock(pn, M):
    """æ£€æŸ¥æ ‡è®°Mæ˜¯å¦ä¸ºæ­»é”çŠ¶æ€"""
    for t in pn.transitions:
        if is_enabled(pn, M, t):
            return False
    return True

def find_all_deadlocks(pn, M0):
    """æ‰¾åˆ°æ‰€æœ‰å¯è¾¾çš„æ­»é”çŠ¶æ€"""
    RG = construct_reachability_graph(pn, M0)
    deadlocks = [M for M in RG.nodes() if is_deadlock(pn, M)]
    return deadlocks
```

---

## 2 Bankerç®—æ³•çš„Petriç½‘è¡¨ç¤º

**Bankerç®—æ³•æ ¸å¿ƒæ€æƒ³**ï¼šåªåˆ†é…èµ„æºå¦‚æœç³»ç»Ÿä¿æŒåœ¨å®‰å…¨çŠ¶æ€ã€‚

**Petriç½‘å»ºæ¨¡**ï¼š

```python
def create_banker_algorithm_petri_net():
    """Bankerç®—æ³•çš„Petriç½‘æ¨¡å‹"""
    pn = PetriNet()

    # ç³»ç»Ÿèµ„æºï¼ˆ3ä¸ªèµ„æºç±»å‹ï¼‰
    pn.add_place('p_resource_A', tokens=10)
    pn.add_place('p_resource_B', tokens=5)
    pn.add_place('p_resource_C', tokens=7)

    # 3ä¸ªè¿›ç¨‹
    processes = ['P1', 'P2', 'P3']
    max_need = {
        'P1': {'A': 7, 'B': 5, 'C': 3},
        'P2': {'A': 3, 'B': 2, 'C': 2},
        'P3': {'A': 9, 'B': 0, 'C': 2}
    }

    for proc in processes:
        # è¯·æ±‚èµ„æºå˜è¿ï¼ˆå¸¦å®‰å…¨æ€§æ£€æŸ¥ï¼‰
        pn.add_transition(f't_{proc}_request')

        # è¿›ç¨‹çŠ¶æ€åº“æ‰€
        pn.add_place(f'p_{proc}_allocated', tokens=0)

        # èµ„æºåˆ†é…å¼§
        for res in ['A', 'B', 'C']:
            if max_need[proc][res] > 0:
                pn.add_arc(f'p_resource_{res}', f't_{proc}_request',
                          weight=1)  # ç®€åŒ–ï¼šæ¯æ¬¡è¯·æ±‚1ä¸ª
                pn.add_arc(f't_{proc}_request', f'p_{proc}_allocated')

    return pn
```

---

## 3 S-ä¸å˜é‡ä¸æ­»é”é¢„é˜²

**å®šç†3.31**ï¼šå¦‚æœPetriç½‘çš„S-ä¸å˜é‡è¦†ç›–æ‰€æœ‰èµ„æºåº“æ‰€ï¼Œåˆ™å¯ä»¥ç”¨äºæ­»é”é¢„é˜²ã€‚

**Pythonå®ç°**ï¼š

```python
def check_deadlock_freedom_via_invariants(pn):
    """é€šè¿‡S-ä¸å˜é‡æ£€æŸ¥æ— æ­»é”"""
    invariants = compute_s_invariants(pn)

    # æ£€æŸ¥æ¯ä¸ªä¸å˜é‡
    for inv in invariants:
        # è®¡ç®—ä¸å˜é‡åœ¨åˆå§‹æ ‡è®°ä¸‹çš„å€¼
        inv_value = sum(inv[i] * M0[pn.places[i]] for i in range(len(pn.places)))

        # æ£€æŸ¥æ‰€æœ‰å¯è¾¾æ ‡è®°ä¸‹ä¸å˜é‡ä¿æŒä¸å˜
        # ï¼ˆç®€åŒ–æ£€æŸ¥ï¼‰

    return len(invariants) > 0
```

---

## 4 TINAå·¥å…·æ­»é”æ£€æµ‹å®è·µ

**TINAå‘½ä»¤è¡Œç”¨æ³•**ï¼š

```bash
# æ£€æŸ¥æ­»é”
tina -d model.net

# è¾“å‡ºå¯è¾¾æ€§å›¾
tina -R model.net > reachability.ktz

# æ£€æŸ¥æ´»æ€§
tina -L model.net
```

---

## 5 å®é™…æ¡ˆä¾‹ï¼šå“²å­¦å®¶å°±é¤é—®é¢˜

**ç»å…¸æ­»é”é—®é¢˜çš„Petriç½‘è§£å†³**ï¼š

```python
def create_dining_philosophers(n=5):
    """
    nä¸ªå“²å­¦å®¶å°±é¤é—®é¢˜

    ç»å…¸æ­»é”åœºæ™¯çš„Petriç½‘å»ºæ¨¡ä¸è§£å†³
    """
    pn = PetriNet()

    # nä¸ªç­·å­ï¼ˆå‰å­ï¼‰
    for i in range(n):
        pn.add_place(f'p_fork_{i}', tokens=1)

    # nä¸ªå“²å­¦å®¶
    for i in range(n):
        left_fork = i
        right_fork = (i + 1) % n

        # æ€è€ƒçŠ¶æ€
        pn.add_place(f'p_philosopher_{i}_thinking', tokens=1)

        # æ‹¿èµ·ç­·å­å˜è¿
        pn.add_transition(f't_philosopher_{i}_pickup')
        pn.add_arc(f'p_philosopher_{i}_thinking', f't_philosopher_{i}_pickup')
        pn.add_arc(f'p_fork_{left_fork}', f't_philosopher_{i}_pickup')
        pn.add_arc(f'p_fork_{right_fork}', f't_philosopher_{i}_pickup')

        # å°±é¤çŠ¶æ€
        pn.add_place(f'p_philosopher_{i}_eating', tokens=0)
        pn.add_arc(f't_philosopher_{i}_pickup', f'p_philosopher_{i}_eating')

        # æ”¾ä¸‹ç­·å­å˜è¿
        pn.add_transition(f't_philosopher_{i}_putdown')
        pn.add_arc(f'p_philosopher_{i}_eating', f't_philosopher_{i}_putdown')
        pn.add_arc(f't_philosopher_{i}_putdown', f'p_fork_{left_fork}')
        pn.add_arc(f't_philosopher_{i}_putdown', f'p_fork_{right_fork}')
        pn.add_arc(f't_philosopher_{i}_putdown', f'p_philosopher_{i}_thinking')

    return pn

# æ­»é”æ£€æµ‹
philosophers_pn = create_dining_philosophers(5)
deadlocks = find_all_deadlocks(philosophers_pn, philosophers_pn.marking)

if deadlocks:
    print(f"âš ï¸  å‘ç°{len(deadlocks)}ä¸ªæ­»é”çŠ¶æ€")
else:
    print("âœ“ æ— æ­»é”")

# è§£å†³æ–¹æ¡ˆï¼šé™åˆ¶åŒæ—¶å°±é¤äººæ•°
def create_deadlock_free_philosophers(n=5):
    """æ— æ­»é”çš„å“²å­¦å®¶å°±é¤"""
    pn = create_dining_philosophers(n)

    # æ·»åŠ é™åˆ¶ï¼šæœ€å¤šn-1äººåŒæ—¶æ‹¿ç­·å­
    pn.add_place('p_room', tokens=n-1)

    for i in range(n):
        pn.add_arc('p_room', f't_philosopher_{i}_pickup')
        pn.add_arc(f't_philosopher_{i}_putdown', 'p_room')

    return pn

# éªŒè¯æ— æ­»é”
safe_pn = create_deadlock_free_philosophers(5)
deadlocks = find_all_deadlocks(safe_pn, safe_pn.marking)
print(f"è§£å†³æ–¹æ¡ˆï¼š{'æ— æ­»é”' if not deadlocks else 'ä»æœ‰æ­»é”'}")
```

---

**è¿”å›**: [03 èµ„æºè°ƒåº¦çš„Petriç½‘æ¨¡å‹](README.md)

**å‚è€ƒæ–‡çŒ®**ï¼š

1. Dijkstra, E.W. (1971). "Hierarchical ordering of sequential processes"
2. Coffman, E.G., et al. (1971). "System deadlocks"
