# 27.1 TEEè°ƒåº¦åŸºç¡€

> **ä¸»é¢˜**: 27. æœºå¯†è®¡ç®—è°ƒåº¦ - 27.1 TEEè°ƒåº¦åŸºç¡€
> **è¦†ç›–**: Intel SGXã€AMD SEVã€Intel TDXã€ARM TrustZone

---

## ğŸ“‹ ç›®å½•

- [27.1 TEEè°ƒåº¦åŸºç¡€](#271-teeè°ƒåº¦åŸºç¡€)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 TEEæ¦‚è¿°](#1-teeæ¦‚è¿°)
    - [1.1 ä»€ä¹ˆæ˜¯TEE](#11-ä»€ä¹ˆæ˜¯tee)
    - [1.2 TEEçš„æ ¸å¿ƒå®‰å…¨å±æ€§](#12-teeçš„æ ¸å¿ƒå®‰å…¨å±æ€§)
    - [1.3 TEEçš„åº”ç”¨åœºæ™¯](#13-teeçš„åº”ç”¨åœºæ™¯)
  - [2 Intel SGXè°ƒåº¦æ¨¡å‹](#2-intel-sgxè°ƒåº¦æ¨¡å‹)
    - [2.1 SGXæ¶æ„](#21-sgxæ¶æ„)
    - [2.2 Enclaveç”Ÿå‘½å‘¨æœŸ](#22-enclaveç”Ÿå‘½å‘¨æœŸ)
    - [2.3 SGXè°ƒåº¦å¼€é”€](#23-sgxè°ƒåº¦å¼€é”€)
    - [2.4 EPCï¼ˆEnclave Page Cacheï¼‰ç®¡ç†](#24-epcenclave-page-cacheç®¡ç†)
  - [3 AMD SEVè°ƒåº¦æœºåˆ¶](#3-amd-sevè°ƒåº¦æœºåˆ¶)
    - [3.1 SEV-SNPæ¶æ„](#31-sev-snpæ¶æ„)
    - [3.2 è™šæ‹ŸæœºåŠ å¯†è°ƒåº¦](#32-è™šæ‹ŸæœºåŠ å¯†è°ƒåº¦)
    - [3.3 SEVæ€§èƒ½å¼€é”€](#33-sevæ€§èƒ½å¼€é”€)
  - [4 Intel TDXè°ƒåº¦æ¶æ„](#4-intel-tdxè°ƒåº¦æ¶æ„)
    - [4.1 TDXä¸SGXçš„åŒºåˆ«](#41-tdxä¸sgxçš„åŒºåˆ«)
    - [4.2 Trust Domainè°ƒåº¦](#42-trust-domainè°ƒåº¦)
    - [4.3 TDXæ€§èƒ½ä¼˜åŒ–](#43-tdxæ€§èƒ½ä¼˜åŒ–)
  - [5 ARM TrustZoneè°ƒåº¦](#5-arm-trustzoneè°ƒåº¦)
    - [5.1 TrustZoneæ¶æ„](#51-trustzoneæ¶æ„)
    - [5.2 å®‰å…¨ä¸–ç•Œä¸æ­£å¸¸ä¸–ç•Œåˆ‡æ¢](#52-å®‰å…¨ä¸–ç•Œä¸æ­£å¸¸ä¸–ç•Œåˆ‡æ¢)
    - [5.3 ç§»åŠ¨è®¾å¤‡TEEè°ƒåº¦](#53-ç§»åŠ¨è®¾å¤‡teeè°ƒåº¦)
  - [6 TEEè°ƒåº¦çš„å½¢å¼åŒ–æ¨¡å‹](#6-teeè°ƒåº¦çš„å½¢å¼åŒ–æ¨¡å‹)
    - [6.1 å®‰å…¨è°ƒåº¦æ¨¡å‹](#61-å®‰å…¨è°ƒåº¦æ¨¡å‹)
    - [6.2 æ€§èƒ½-å®‰å…¨æƒè¡¡](#62-æ€§èƒ½-å®‰å…¨æƒè¡¡)
    - [6.3 TLA+è§„çº¦](#63-tlaè§„çº¦)
  - [7 TEEè°ƒåº¦å®è·µ](#7-teeè°ƒåº¦å®è·µ)
    - [7.1 SGXåº”ç”¨éƒ¨ç½²](#71-sgxåº”ç”¨éƒ¨ç½²)
    - [7.2 SEVè™šæ‹Ÿæœºé…ç½®](#72-sevè™šæ‹Ÿæœºé…ç½®)
    - [7.3 æ€§èƒ½åŸºå‡†æµ‹è¯•](#73-æ€§èƒ½åŸºå‡†æµ‹è¯•)
  - [8 è·¨è§†è§’é“¾æ¥](#8-è·¨è§†è§’é“¾æ¥)

---

## 1 TEEæ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯TEE

**Trusted Execution Environment (TEE)** æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å®‰å…¨æ‰§è¡Œç¯å¢ƒï¼Œå³ä½¿åœ¨æ“ä½œç³»ç»Ÿè¢«æ”»ç ´çš„æƒ…å†µä¸‹ï¼Œä¹Ÿèƒ½ä¿æŠ¤æ•æ„Ÿæ•°æ®å’Œä»£ç çš„æœºå¯†æ€§å’Œå®Œæ•´æ€§ã€‚

**TEEçš„æ ¸å¿ƒç‰¹æ€§**:

```text
TEE = (éš”ç¦»æ‰§è¡Œ, å†…å­˜åŠ å¯†, è¿œç¨‹è®¤è¯, å®‰å…¨å­˜å‚¨)
```

**ä¸»æµTEEæŠ€æœ¯å¯¹æ¯”**:

| TEEæŠ€æœ¯ | å‚å•† | éš”ç¦»ç²’åº¦ | å†…å­˜åŠ å¯† | æ€§èƒ½å¼€é”€ | åº”ç”¨åœºæ™¯ |
|---------|------|----------|----------|----------|----------|
| **Intel SGX** | Intel | è¿›ç¨‹çº§ (Enclave) | âœ… | 10-50% | äº‘è®¡ç®—ã€åŒºå—é“¾ |
| **AMD SEV** | AMD | VMçº§ | âœ… | 5-15% | æœºå¯†è™šæ‹Ÿæœº |
| **Intel TDX** | Intel | VMçº§ | âœ… | 5-10% | æœºå¯†å®¹å™¨ |
| **ARM TrustZone** | ARM | CPUæ¨¡å¼ | âœ… | <5% | ç§»åŠ¨è®¾å¤‡ã€IoT |

### 1.2 TEEçš„æ ¸å¿ƒå®‰å…¨å±æ€§

**å®šä¹‰27.11ï¼ˆTEEå®‰å…¨å±æ€§ï¼‰**:

TEEå¿…é¡»æä¾›ä»¥ä¸‹å®‰å…¨ä¿è¯:

1. **æœºå¯†æ€§ï¼ˆConfidentialityï¼‰**:
   $$\forall d \in \text{Data}_{TEE}, \text{Accessible}(d, \text{Attacker}) = \bot$$

2. **å®Œæ•´æ€§ï¼ˆIntegrityï¼‰**:
   $$\forall c \in \text{Code}_{TEE}, \text{Modifiable}(c, \text{Attacker}) = \bot$$

3. **è®¤è¯æ€§ï¼ˆAuthenticityï¼‰**:
   $$\text{RemoteAttestation}(TEE) \to \text{VerifiedState}(TEE)$$

### 1.3 TEEçš„åº”ç”¨åœºæ™¯

**å…¸å‹åº”ç”¨**:

1. **äº‘è®¡ç®—**: æœºå¯†è™šæ‹Ÿæœºï¼ˆConfidential Computingï¼‰
2. **åŒºå—é“¾**: éšç§æ™ºèƒ½åˆçº¦
3. **é‡‘è**: å®‰å…¨æ”¯ä»˜ã€å¯†é’¥ç®¡ç†
4. **åŒ»ç–—**: éšç§æ•°æ®åˆ†æ
5. **AI**: æœºå¯†MLè®­ç»ƒå’Œæ¨ç†

---

## 2 Intel SGXè°ƒåº¦æ¨¡å‹

### 2.1 SGXæ¶æ„

**Intel SGX (Software Guard Extensions)** æä¾›è¿›ç¨‹çº§TEEï¼Œé€šè¿‡Enclaveéš”ç¦»æ•æ„Ÿä»£ç å’Œæ•°æ®ã€‚

**SGXæ¶æ„å›¾**:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         User Application                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Untrusted Part  â”‚   Enclave (Trusted)     â”‚
â”‚                  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚   â”‚  Trusted Code    â”‚  â”‚
â”‚  â”‚Untrust â”‚ ECALLâ”‚   â”‚  Trusted Data    â”‚  â”‚
â”‚  â”‚ Code   â”‚â”€â”€â”€â”€â”€>â”‚   â”‚  (Encrypted)     â”‚  â”‚
â”‚  â”‚        â”‚<â”€â”€â”€â”€â”€â”‚   â”‚                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ OCALLâ”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              Operating System              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Hardware (CPU + Memory)            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  EPC (Enclave Page Cache)          â”‚   â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚   â”‚  â”‚ Enclave1 â”‚ Enclave2 â”‚ ...    â”‚  â”‚   â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å…³é”®ç»„ä»¶**:

- **Enclave**: å—ä¿æŠ¤çš„æ‰§è¡ŒåŒºåŸŸ
- **EPC**: Enclave Page Cacheï¼ŒåŠ å¯†å†…å­˜åŒºåŸŸï¼ˆé»˜è®¤128MBï¼‰
- **ECALL**: ä»éä¿¡ä»»åŒºåŸŸè¿›å…¥Enclave
- **OCALL**: ä»Enclaveè°ƒç”¨éä¿¡ä»»ä»£ç 

### 2.2 Enclaveç”Ÿå‘½å‘¨æœŸ

**ç”Ÿå‘½å‘¨æœŸçŠ¶æ€æœº**:

```text
[Initialized] --ECREATE--> [Created]
                              |
                           EADD (æ·»åŠ é¡µé¢)
                              |
                          EINIT (åˆå§‹åŒ–)
                              |
                           [Active]
                              |
                        EENTER (è¿›å…¥)
                              |
                          [Running]
                              |
                       EEXIT (é€€å‡º)
                              |
                         [Active]
                              |
                      EREMOVE (é”€æ¯)
                              |
                        [Destroyed]
```

**Pythonæ¨¡æ‹Ÿ**:

```python
from enum import Enum
from dataclasses import dataclass
from typing import List, Optional

class EnclaveState(Enum):
    INITIALIZED = "initialized"
    CREATED = "created"
    ACTIVE = "active"
    RUNNING = "running"
    DESTROYED = "destroyed"

@dataclass
class Enclave:
    enclave_id: int
    state: EnclaveState
    epc_pages: List[int]  # EPCé¡µé¢åˆ—è¡¨
    code_size: int  # KB
    data_size: int  # KB

    def create(self):
        """ECREATE: åˆ›å»ºEnclave"""
        if self.state == EnclaveState.INITIALIZED:
            self.state = EnclaveState.CREATED
            print(f"Enclave {self.enclave_id}: Created")

    def add_pages(self, pages: List[int]):
        """EADD: æ·»åŠ é¡µé¢åˆ°Enclave"""
        if self.state == EnclaveState.CREATED:
            self.epc_pages.extend(pages)
            print(f"Enclave {self.enclave_id}: Added {len(pages)} pages")

    def init(self):
        """EINIT: åˆå§‹åŒ–Enclaveï¼ˆåº¦é‡å¹¶ç­¾åï¼‰"""
        if self.state == EnclaveState.CREATED:
            self.state = EnclaveState.ACTIVE
            print(f"Enclave {self.enclave_id}: Initialized and Active")

    def enter(self):
        """EENTER: è¿›å…¥Enclave"""
        if self.state == EnclaveState.ACTIVE:
            self.state = EnclaveState.RUNNING
            print(f"Enclave {self.enclave_id}: Entered (Running)")

    def exit(self):
        """EEXIT: é€€å‡ºEnclave"""
        if self.state == EnclaveState.RUNNING:
            self.state = EnclaveState.ACTIVE
            print(f"Enclave {self.enclave_id}: Exited (Active)")

    def destroy(self):
        """EREMOVE: é”€æ¯Enclave"""
        if self.state in [EnclaveState.CREATED, EnclaveState.ACTIVE]:
            self.state = EnclaveState.DESTROYED
            self.epc_pages.clear()
            print(f"Enclave {self.enclave_id}: Destroyed")

# ä½¿ç”¨ç¤ºä¾‹
enclave = Enclave(
    enclave_id=1,
    state=EnclaveState.INITIALIZED,
    epc_pages=[],
    code_size=1024,  # 1MB
    data_size=512    # 512KB
)

# ç”Ÿå‘½å‘¨æœŸæ¼”ç¤º
enclave.create()
enclave.add_pages([1, 2, 3, 4, 5])
enclave.init()
enclave.enter()
# ... æ‰§è¡Œæ•æ„Ÿè®¡ç®— ...
enclave.exit()
enclave.destroy()
```

### 2.3 SGXè°ƒåº¦å¼€é”€

**æ€§èƒ½å¼€é”€æ¥æº**:

1. **Enclaveè¿›å…¥/é€€å‡º**: 2,000-8,000ä¸ªCPUå‘¨æœŸ
2. **å†…å­˜åŠ å¯†**: 5-15%æ€§èƒ½æŸå¤±
3. **EPCåˆ†é¡µ**: å¦‚æœEPCä¸è¶³ï¼Œæ¢é¡µå¼€é”€å·¨å¤§ï¼ˆ>100xï¼‰

**å®šç†27.12ï¼ˆSGXè°ƒåº¦å¼€é”€ï¼‰**:

ç»™å®šEnclaveè°ƒç”¨é¢‘ç‡$f$å’Œå•æ¬¡è¿›å…¥/é€€å‡ºå¼€é”€$c$ï¼Œæ€»å¼€é”€ä¸º:

$$
\text{Overhead}_{SGX} = f \cdot c + \alpha \cdot \text{EncryptionCost} + \beta \cdot \text{PagingCost}
$$

å…¶ä¸­:
- $\alpha$: å†…å­˜åŠ å¯†å¼€é”€ç³»æ•°ï¼ˆ5-15%ï¼‰
- $\beta$: EPCåˆ†é¡µå¼€é”€ç³»æ•°ï¼ˆ0å¦‚æœEPCè¶³å¤Ÿï¼Œå¦åˆ™>100ï¼‰

### 2.4 EPCï¼ˆEnclave Page Cacheï¼‰ç®¡ç†

**EPCç®¡ç†ç­–ç•¥**:

```python
class EPCManager:
    def __init__(self, total_epc_size_mb=128):
        self.total_size = total_epc_size_mb * 1024  # KB
        self.used_size = 0
        self.enclaves = {}

    def allocate(self, enclave_id: int, size_kb: int) -> bool:
        """ä¸ºEnclaveåˆ†é…EPC"""
        if self.used_size + size_kb <= self.total_size:
            self.enclaves[enclave_id] = size_kb
            self.used_size += size_kb
            print(f"EPC allocated {size_kb}KB for Enclave {enclave_id}")
            return True
        else:
            print(f"EPC allocation failed: insufficient space")
            return False

    def deallocate(self, enclave_id: int):
        """é‡Šæ”¾Enclaveçš„EPC"""
        if enclave_id in self.enclaves:
            size = self.enclaves[enclave_id]
            del self.enclaves[enclave_id]
            self.used_size -= size
            print(f"EPC deallocated {size}KB from Enclave {enclave_id}")

    def get_fragmentation(self) -> float:
        """è®¡ç®—EPCç¢ç‰‡ç‡"""
        return (self.total_size - self.used_size) / self.total_size

# ä½¿ç”¨ç¤ºä¾‹
epc_manager = EPCManager(total_epc_size_mb=128)
epc_manager.allocate(enclave_id=1, size_kb=40960)  # 40MB
epc_manager.allocate(enclave_id=2, size_kb=20480)  # 20MB
print(f"EPC Fragmentation: {epc_manager.get_fragmentation():.2%}")
```

---

## 3 AMD SEVè°ƒåº¦æœºåˆ¶

### 3.1 SEV-SNPæ¶æ„

**AMD SEV (Secure Encrypted Virtualization)** æä¾›è™šæ‹Ÿæœºçº§TEEï¼Œæ”¯æŒVMå†…å­˜åŠ å¯†ã€‚

**SEVæ¶æ„**:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Confidential VM 1    â”‚    VM 2        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚                â”‚
â”‚  â”‚ Guest OS         â”‚     â”‚                â”‚
â”‚  â”‚ (Encrypted Mem)  â”‚     â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           Hypervisor (KVM/Xen)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       Hardware (AMD EPYC CPU)              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ SEV Memory Encryption Engine       â”‚   â”‚
â”‚   â”‚  - VM Key (per-VM)                 â”‚   â”‚
â”‚   â”‚  - AES-128 Encryption              â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**SEVæ¼”è¿›**:

- **SEV**: VMå†…å­˜åŠ å¯†
- **SEV-ES**: + å¯„å­˜å™¨åŠ å¯†
- **SEV-SNP** (Secure Nested Paging): + å®Œæ•´æ€§ä¿æŠ¤

### 3.2 è™šæ‹ŸæœºåŠ å¯†è°ƒåº¦

**VMåŠ å¯†ç”Ÿå‘½å‘¨æœŸ**:

```python
from enum import Enum
from dataclasses import dataclass

class SEVState(Enum):
    UNENCRYPTED = "unencrypted"
    LAUNCH_START = "launch_start"
    LAUNCH_UPDATE = "launch_update"
    LAUNCH_FINISH = "launch_finish"
    RUNNING = "running"
    SEND_START = "send_start"
    RECEIVE_START = "receive_start"

@dataclass
class SEV_VM:
    vm_id: int
    state: SEVState
    vm_key: bytes  # 128-bit AES key
    memory_size_gb: int

    def launch_start(self):
        """SEV_LAUNCH_START: å¼€å§‹VMåŠ å¯†å¯åŠ¨"""
        if self.state == SEVState.UNENCRYPTED:
            # ç”ŸæˆVMä¸“å±å¯†é’¥
            import os
            self.vm_key = os.urandom(16)  # 128-bit key
            self.state = SEVState.LAUNCH_START
            print(f"SEV VM {self.vm_id}: Launch started")

    def launch_update(self, data: bytes):
        """SEV_LAUNCH_UPDATE: æ›´æ–°VMå†…å­˜ï¼ˆåŠ å¯†ï¼‰"""
        if self.state == SEVState.LAUNCH_START:
            # ä½¿ç”¨VMå¯†é’¥åŠ å¯†å†…å­˜
            encrypted_data = self._encrypt(data, self.vm_key)
            self.state = SEVState.LAUNCH_UPDATE
            print(f"SEV VM {self.vm_id}: Memory encrypted")
            return encrypted_data

    def launch_finish(self):
        """SEV_LAUNCH_FINISH: å®ŒæˆVMå¯åŠ¨"""
        if self.state == SEVState.LAUNCH_UPDATE:
            self.state = SEVState.RUNNING
            print(f"SEV VM {self.vm_id}: Running (encrypted)")

    def _encrypt(self, data: bytes, key: bytes) -> bytes:
        """AES-128åŠ å¯†ï¼ˆç®€åŒ–ï¼‰"""
        from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
        from cryptography.hazmat.backends import default_backend

        cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())
        encryptor = cipher.encryptor()
        return encryptor.update(data) + encryptor.finalize()

# ä½¿ç”¨ç¤ºä¾‹
sev_vm = SEV_VM(
    vm_id=1,
    state=SEVState.UNENCRYPTED,
    vm_key=b'',
    memory_size_gb=8
)

sev_vm.launch_start()
encrypted_mem = sev_vm.launch_update(b'sensitive data' * 1000)
sev_vm.launch_finish()
```

### 3.3 SEVæ€§èƒ½å¼€é”€

**å®šç†27.13ï¼ˆSEVæ€§èƒ½å¼€é”€ï¼‰**:

SEVçš„æ€§èƒ½å¼€é”€ä¸»è¦æ¥è‡ªå†…å­˜åŠ å¯†ï¼š

$$
\text{Overhead}_{SEV} = \alpha \cdot \text{MemoryBandwidth} + \beta \cdot \text{CPUOverhead}
$$

å…¶ä¸­:
- $\alpha \approx 5-10\%$: å†…å­˜å¸¦å®½å¼€é”€
- $\beta \approx 2-5\%$: CPUå¼€é”€

**å®æµ‹æ•°æ®ï¼ˆAMD EPYC 7003ï¼‰**:

- å†…å­˜å¯†é›†å‹åº”ç”¨: 8-12%æ€§èƒ½æŸå¤±
- è®¡ç®—å¯†é›†å‹åº”ç”¨: 2-5%æ€§èƒ½æŸå¤±
- I/Oå¯†é›†å‹åº”ç”¨: <3%æ€§èƒ½æŸå¤±

---

## 4 Intel TDXè°ƒåº¦æ¶æ„

### 4.1 TDXä¸SGXçš„åŒºåˆ«

**Intel TDX (Trust Domain Extensions)** æ˜¯VMçº§TEEï¼Œä¸SGXäº’è¡¥ã€‚

| ç‰¹æ€§ | SGX | TDX |
|------|-----|-----|
| **éš”ç¦»ç²’åº¦** | è¿›ç¨‹çº§ï¼ˆEnclaveï¼‰ | VMçº§ï¼ˆTrust Domainï¼‰ |
| **å†…å­˜é™åˆ¶** | 128MB (EPC) | æ— é™åˆ¶ï¼ˆå…¨éƒ¨å†…å­˜ï¼‰ |
| **OSæ”¯æŒ** | éœ€è¦SDKä¿®æ”¹ | æ— éœ€ä¿®æ”¹Guest OS |
| **åº”ç”¨åœºæ™¯** | äº‘å‡½æ•°ã€è¾¹ç¼˜è®¡ç®— | æœºå¯†å®¹å™¨ã€Kubernetes |

### 4.2 Trust Domainè°ƒåº¦

**TDXæ¶æ„**:

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Trust Domain (TD)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Guest OS (Unmodified Linux)        â”‚  â”‚
â”‚  â”‚   Application Containers             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    TDX Module (CPUå¾®ä»£ç )                  â”‚
â”‚   - Memory Encryption (MKTME)             â”‚
â”‚   - Integrity Protection                   â”‚
â”‚   - Remote Attestation                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           VMM (KVM/Qemu)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.3 TDXæ€§èƒ½ä¼˜åŒ–

**ä¼˜åŒ–ç­–ç•¥**:

1. **å‡å°‘TDé€€å‡º**: ä½¿ç”¨virtio-vsockè€Œéä¼ ç»ŸI/O
2. **æ‰¹é‡æ“ä½œ**: èšåˆç³»ç»Ÿè°ƒç”¨
3. **ç›´æ¥èµ‹å€¼**: ä½¿ç”¨SR-IOVé¿å…è™šæ‹ŸåŒ–å¼€é”€

**æ€§èƒ½å¯¹æ¯”ï¼ˆç›¸å¯¹åŸç”ŸVMï¼‰**:

- è®¡ç®—æ€§èƒ½: 95-98%
- å†…å­˜å¸¦å®½: 90-95%
- ç½‘ç»œåå: 85-92%
- å­˜å‚¨I/O: 88-93%

---

## 5 ARM TrustZoneè°ƒåº¦

### 5.1 TrustZoneæ¶æ„

**ARM TrustZone** å°†CPUåˆ’åˆ†ä¸ºä¸¤ä¸ªä¸–ç•Œï¼šå®‰å…¨ä¸–ç•Œï¼ˆSecure Worldï¼‰å’Œæ­£å¸¸ä¸–ç•Œï¼ˆNormal Worldï¼‰ã€‚

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Normal World                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Rich OS (Android/Linux)             â”‚  â”‚
â”‚  â”‚  Applications                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Secure Monitor                     â”‚
â”‚   SMC (Secure Monitor Call)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Secure World                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Secure OS (OP-TEE)                  â”‚  â”‚
â”‚  â”‚  Trusted Applications (TAs)          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 å®‰å…¨ä¸–ç•Œä¸æ­£å¸¸ä¸–ç•Œåˆ‡æ¢

**åˆ‡æ¢æœºåˆ¶**:

```c
// ARM TrustZone SMCè°ƒç”¨ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
#include <stdint.h>

// SMCæŒ‡ä»¤
#define SMC_CALL(func_id, arg1, arg2, arg3) \
    asm volatile( \
        "mov x0, %0\n" \
        "mov x1, %1\n" \
        "mov x2, %2\n" \
        "mov x3, %3\n" \
        "smc #0\n" \
        : \
        : "r"((uint64_t)(func_id)), \
          "r"((uint64_t)(arg1)), \
          "r"((uint64_t)(arg2)), \
          "r"((uint64_t)(arg3)) \
        : "x0", "x1", "x2", "x3" \
    )

// è°ƒç”¨å®‰å…¨æœåŠ¡
void call_secure_service(uint32_t service_id, uint64_t param) {
    SMC_CALL(service_id, param, 0, 0);
}

// ç¤ºä¾‹ï¼šè¯·æ±‚å®‰å…¨å¯†é’¥
void request_secure_key() {
    call_secure_service(0x1000, 0);  // æœåŠ¡ID: 0x1000
}
```

### 5.3 ç§»åŠ¨è®¾å¤‡TEEè°ƒåº¦

**ç§»åŠ¨åœºæ™¯ä¼˜åŒ–**:

- **å¿«é€Ÿåˆ‡æ¢**: SMCåˆ‡æ¢<1000 CPUå‘¨æœŸ
- **ä½åŠŸè€—**: å®‰å…¨ä¸–ç•Œåªåœ¨éœ€è¦æ—¶æ¿€æ´»
- **åº”ç”¨åœºæ™¯**: æŒ‡çº¹è¯†åˆ«ã€æ”¯ä»˜ã€DRM

---

## 6 TEEè°ƒåº¦çš„å½¢å¼åŒ–æ¨¡å‹

### 6.1 å®‰å…¨è°ƒåº¦æ¨¡å‹

**å®šä¹‰27.14ï¼ˆTEEå®‰å…¨è°ƒåº¦æ¨¡å‹ï¼‰**:

TEEè°ƒåº¦ç³»ç»Ÿ$\mathcal{S} = (T, R, \phi, \psi)$ï¼Œå…¶ä¸­:

- $T = \{t_1, \ldots, t_n\}$: ä»»åŠ¡é›†åˆ
- $R = \{r_1, \ldots, r_m\}$: TEEèµ„æºé›†åˆï¼ˆEnclaveã€TDã€TrustZoneï¼‰
- $\phi: T \to R$: è°ƒåº¦å‡½æ•°
- $\psi: T \times R \to \{0, 1\}$: å®‰å…¨æ€§è°“è¯

**å®‰å…¨æ€§ä¿è¯**:

$$
\forall t \in T, \psi(t, \phi(t)) = 1 \implies \text{Secure}(t)
$$

### 6.2 æ€§èƒ½-å®‰å…¨æƒè¡¡

**å¤šç›®æ ‡ä¼˜åŒ–**:

$$
\min_{\phi} \left( w_1 \cdot \text{Latency}(\phi) - w_2 \cdot \text{Security}(\phi) \right)
$$

### 6.3 TLA+è§„çº¦

```tla
----------------------- MODULE TEEScheduling -----------------------
EXTENDS Naturals, Sequences

CONSTANTS Tasks, TEEs, MaxLatency

VARIABLES scheduled, running, completed

vars == <<scheduled, running, completed>>

Init ==
    /\ scheduled = {}
    /\ running = [t \in Tasks |-> FALSE]
    /\ completed = {}

ScheduleTask(t, tee) ==
    /\ t \in Tasks
    /\ t \notin scheduled
    /\ tee \in TEEs
    /\ scheduled' = scheduled \cup {t}
    /\ running' = [running EXCEPT ![t] = TRUE]
    /\ UNCHANGED <<completed>>

CompleteTask(t) ==
    /\ t \in scheduled
    /\ running[t]
    /\ running' = [running EXCEPT ![t] = FALSE]
    /\ completed' = completed \cup {t}
    /\ UNCHANGED <<scheduled>>

Next ==
    \/ \E t \in Tasks, tee \in TEEs : ScheduleTask(t, tee)
    \/ \E t \in Tasks : CompleteTask(t)

Spec == Init /\ [][Next]_vars

TypeOK ==
    /\ scheduled \subseteq Tasks
    /\ completed \subseteq Tasks

====================================================================
```

---

## 7 TEEè°ƒåº¦å®è·µ

### 7.1 SGXåº”ç”¨éƒ¨ç½²

**ä½¿ç”¨Open Enclave SDK**:

```bash
# å®‰è£…Open Enclave
sudo apt install open-enclave

# åˆ›å»ºEnclaveåº”ç”¨
oe create helloworld

# ç¼–è¯‘
cd helloworld
make

# è¿è¡Œ
./host/helloworldhost ./enclave/helloworldenc.signed
```

### 7.2 SEVè™šæ‹Ÿæœºé…ç½®

**ä½¿ç”¨libvirtå¯åŠ¨SEV VM**:

```xml
<domain type='kvm'>
  <name>sev-guest</name>
  <memory unit='GiB'>4</memory>
  <launchSecurity type='sev'>
    <cbitpos>47</cbitpos>
    <reducedPhysBits>1</reducedPhysBits>
    <policy>0x0003</policy>
  </launchSecurity>
  <devices>
    <disk type='file' device='disk'>
      <source file='/var/lib/libvirt/images/sev-guest.qcow2'/>
      <target dev='vda' bus='virtio'/>
    </disk>
  </devices>
</domain>
```

### 7.3 æ€§èƒ½åŸºå‡†æµ‹è¯•

```bash
# SGXæ€§èƒ½æµ‹è¯•
sgx-test --benchmark enclave-creation
sgx-test --benchmark ecall-latency

# SEVæ€§èƒ½æµ‹è¯•
kvm-sev-bench --workload memory-intensive
kvm-sev-bench --workload cpu-intensive
```

---

## 8 è·¨è§†è§’é“¾æ¥

**å½¢å¼è¯­è¨€è§†è§’**:
- [04.3 å½¢å¼åŒ–éªŒè¯](../../formal_lang_view/04_ç±»å‹æ£€æŸ¥ä¸éªŒè¯/04.3_å½¢å¼åŒ–éªŒè¯.md) - TEEå®‰å…¨æ€§éªŒè¯
- [09.4 åº”ç”¨èŒƒç•´è®º](../../formal_lang_view/09_å½¢å¼åŒ–ç†è®º/09.4_åº”ç”¨èŒƒç•´è®º.md) - TEEå®‰å…¨æ¨¡å‹

**è°ƒåº¦è§†è§’**:
- [03.1 è¿›ç¨‹è°ƒåº¦æ¨¡å‹](../03_OSæŠ½è±¡å±‚/03.1_è¿›ç¨‹è°ƒåº¦æ¨¡å‹.md) - OSè°ƒåº¦ä¸TEEååŒ
- [06.5 è°ƒåº¦æ¨¡å‹ç»Ÿä¸€ç†è®º](../06_è°ƒåº¦æ¨¡å‹/06.5_è°ƒåº¦æ¨¡å‹ç»Ÿä¸€ç†è®º.md) - TEEè°ƒåº¦å½¢å¼åŒ–

**ç›¸å…³ä¸»é¢˜**:
- [27.2 æœºå¯†å®¹å™¨è°ƒåº¦](27.2_æœºå¯†å®¹å™¨è°ƒåº¦.md) - TEEåœ¨å®¹å™¨ä¸­çš„åº”ç”¨
- [07.3 å®‰å…¨æœºåˆ¶](../07_æ€§èƒ½ä¼˜åŒ–ä¸å®‰å…¨/07.3_å®‰å…¨æœºåˆ¶.md) - å®‰å…¨æœºåˆ¶å¯¹æ¯”

---

**å‚è€ƒæ–‡çŒ®**:

1. Intel SGX Developer Reference: https://software.intel.com/sgx
2. AMD SEV-SNP White Paper: https://www.amd.com/system/files/TechDocs/SEV-SNP-strengthening-vm-isolation-with-integrity-protection-and-more.pdf
3. Intel TDX Documentation: https://www.intel.com/content/www/us/en/developer/tools/trust-domain-extensions/overview.html
4. ARM TrustZone Technology: https://www.arm.com/technologies/trustzone-for-cortex-a
5. Confidential Computing Consortium: https://confidentialcomputing.io/

---

**æœ€åæ›´æ–°**: 2025-12-02
**æ–‡æ¡£çŠ¶æ€**: âœ… å·²å®Œæˆ
