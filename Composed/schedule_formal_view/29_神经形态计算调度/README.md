# 29 ç¥ç»å½¢æ€è®¡ç®—è°ƒåº¦

> **ä¸»é¢˜ç¼–å·**: 29
> **ä¸»é¢˜**: ç¥ç»å½¢æ€è®¡ç®—è°ƒåº¦
> **æœ€åæ›´æ–°**: 2025-12-02
> **æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ

---

## ğŸ“‹ ç›®å½•

- [29 ç¥ç»å½¢æ€è®¡ç®—è°ƒåº¦](#29-ç¥ç»å½¢æ€è®¡ç®—è°ƒåº¦)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 æ¦‚è¿°](#1-æ¦‚è¿°)
    - [1.1 æ ¸å¿ƒæ´å¯Ÿ](#11-æ ¸å¿ƒæ´å¯Ÿ)
    - [1.2 ç¥ç»å½¢æ€è°ƒåº¦ç‰¹æ€§](#12-ç¥ç»å½¢æ€è°ƒåº¦ç‰¹æ€§)
    - [1.3 å½¢å¼åŒ–å®šä¹‰](#13-å½¢å¼åŒ–å®šä¹‰)
  - [2 æ€ç»´å¯¼å›¾](#2-æ€ç»´å¯¼å›¾)
  - [3 ç¥ç»å½¢æ€ç¡¬ä»¶](#3-ç¥ç»å½¢æ€ç¡¬ä»¶)
    - [3.1 Intel Loihiæ¶æ„](#31-intel-loihiæ¶æ„)
    - [3.2 ç¥ç»æ ¸å¿ƒèµ„æºæ¨¡å‹](#32-ç¥ç»æ ¸å¿ƒèµ„æºæ¨¡å‹)
  - [4 è„‰å†²ç¥ç»ç½‘ç»œè°ƒåº¦](#4-è„‰å†²ç¥ç»ç½‘ç»œè°ƒåº¦)
    - [4.1 äº‹ä»¶é©±åŠ¨è°ƒåº¦å™¨](#41-äº‹ä»¶é©±åŠ¨è°ƒåº¦å™¨)
    - [4.2 ç¥ç»å…ƒåˆ†é…ç­–ç•¥](#42-ç¥ç»å…ƒåˆ†é…ç­–ç•¥)
    - [4.3 è„‰å†²è·¯ç”±](#43-è„‰å†²è·¯ç”±)
  - [5 æ—¶é—´ç¼–ç è°ƒåº¦](#5-æ—¶é—´ç¼–ç è°ƒåº¦)
    - [5.1 æ—¶é—´ç¼–ç ç­–ç•¥](#51-æ—¶é—´ç¼–ç ç­–ç•¥)
    - [5.2 STDPå­¦ä¹ è°ƒåº¦](#52-stdpå­¦ä¹ è°ƒåº¦)
  - [6 çŸ¥è¯†çŸ©é˜µ](#6-çŸ¥è¯†çŸ©é˜µ)
    - [6.1 ç¥ç»å½¢æ€ç¡¬ä»¶å¯¹æ¯”](#61-ç¥ç»å½¢æ€ç¡¬ä»¶å¯¹æ¯”)
    - [6.2 è°ƒåº¦ç­–ç•¥å¯¹æ¯”](#62-è°ƒåº¦ç­–ç•¥å¯¹æ¯”)
  - [7 è·¨è§†è§’é“¾æ¥](#7-è·¨è§†è§’é“¾æ¥)
    - [7.1 è°ƒåº¦è§†è§’å…³è”](#71-è°ƒåº¦è§†è§’å…³è”)
    - [7.2 å½¢å¼è¯­è¨€è§†è§’å…³è”](#72-å½¢å¼è¯­è¨€è§†è§’å…³è”)
  - [å‚è€ƒèµ„æº](#å‚è€ƒèµ„æº)

---

## 1 æ¦‚è¿°

### 1.1 æ ¸å¿ƒæ´å¯Ÿ

ç¥ç»å½¢æ€è®¡ç®—ï¼ˆNeuromorphic Computingï¼‰æ¨¡æ‹Ÿç”Ÿç‰©ç¥ç»ç³»ç»Ÿï¼Œé‡‡ç”¨**äº‹ä»¶é©±åŠ¨**çš„è„‰å†²ç¥ç»ç½‘ç»œï¼ˆSNNï¼‰ã€‚è°ƒåº¦ç­–ç•¥å¿…é¡»é€‚åº”**æ—¶é—´ç¼–ç **ã€**å¼‚æ­¥é€šä¿¡**å’Œ**ç¨€ç–æ¿€æ´»**çš„ç‰¹æ€§ã€‚

### 1.2 ç¥ç»å½¢æ€è°ƒåº¦ç‰¹æ€§

| ç‰¹æ€§ | æè¿° | è°ƒåº¦æŒ‘æˆ˜ |
|------|------|---------|
| **äº‹ä»¶é©±åŠ¨** | è„‰å†²è§¦å‘è®¡ç®— | å¼‚æ­¥è°ƒåº¦ |
| **æ—¶é—´ç¼–ç ** | ä¿¡æ¯åœ¨è„‰å†²æ—¶é—´ä¸­ | æ—¶åºä¿æŒ |
| **ç¨€ç–æ¿€æ´»** | ä½æ´»åŠ¨ç‡ | åŠ¨æ€èµ„æºåˆ†é… |
| **æœ¬åœ°å­¦ä¹ ** | STDPç­‰è§„åˆ™ | åœ¨çº¿æ›´æ–° |
| **ä½åŠŸè€—** | ç±»è„‘æ•ˆç‡ | èƒ½æ•ˆä¼˜åŒ– |

### 1.3 å½¢å¼åŒ–å®šä¹‰

```text
ç¥ç»å½¢æ€è°ƒåº¦ç³»ç»Ÿ N = (S, C, T, L, Ïƒ)

å…¶ä¸­ï¼š
  S: è„‰å†²äº‹ä»¶é›†åˆ {(neuron_id, time, weight)}
  C: ç¥ç»æ ¸å¿ƒé›†åˆ {coreâ‚, coreâ‚‚, ..., coreâ‚™}
  T: è·¯ç”±æ‹“æ‰‘
  L: å­¦ä¹ è§„åˆ™ï¼ˆSTDP, Reward-modulatedï¼‰
  Ïƒ: è°ƒåº¦å‡½æ•° Ïƒ: S Ã— C Ã— T â†’ Schedule

çº¦æŸï¼š
  âˆ€ spike s: latency(s) â‰¤ time_constant
  âˆ€ core c: spikes_per_tick(c) â‰¤ bandwidth_limit
```

---

## 2 æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((ç¥ç»å½¢æ€è°ƒåº¦))
    ç¡¬ä»¶å¹³å°
      Intel Loihi
        ç¥ç»æ ¸å¿ƒ
        å­¦ä¹ å¼•æ“
      IBM TrueNorth
        ç¥ç»çªè§¦æ ¸å¿ƒ
        ä½åŠŸè€—
      SpiNNaker
        ARMæ ¸å¿ƒ
        å¯æ‰©å±•
      BrainScaleS
        æ¨¡æ‹Ÿç”µè·¯
        åŠ é€Ÿä»¿çœŸ
    è„‰å†²è°ƒåº¦
      äº‹ä»¶é˜Ÿåˆ—
        ä¼˜å…ˆçº§é˜Ÿåˆ—
        æ—¶é—´æ¡¶
      è·¯ç”±
        ç»´åº¦é¡ºåº
        è‡ªé€‚åº”
      è´Ÿè½½å‡è¡¡
        ç¥ç»å…ƒåˆ†å¸ƒ
        è„‰å†²åˆ†æµ
    æ—¶é—´ç¼–ç 
      é€Ÿç‡ç¼–ç 
      æ—¶é—´ç¼–ç 
      ç¾¤ä½“ç¼–ç 
    å­¦ä¹ è°ƒåº¦
      STDP
      åœ¨çº¿å­¦ä¹ 
      æ‰¹é‡æ›´æ–°
```

---

## 3 ç¥ç»å½¢æ€ç¡¬ä»¶

### 3.1 Intel Loihiæ¶æ„

```text
Loihi 2 æ¶æ„:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Loihi 2 èŠ¯ç‰‡                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ ç¥ç»æ ¸å¿ƒ â”‚  â”‚ ç¥ç»æ ¸å¿ƒ â”‚  â”‚ ç¥ç»æ ¸å¿ƒ â”‚  ...        â”‚
â”‚  â”‚ (128ä¸ª) â”‚  â”‚         â”‚  â”‚         â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜             â”‚
â”‚       â”‚            â”‚            â”‚                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”             â”‚
â”‚  â”‚           ç½‘æ ¼è·¯ç”±ç½‘ç»œ              â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                   â”‚                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚           å­¦ä¹ å¼•æ“ (Lakemont)       â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ¯ä¸ªç¥ç»æ ¸å¿ƒ:
  - æœ€å¤š1024ä¸ªç¥ç»å…ƒ
  - æœ¬åœ°SRAMå­˜å‚¨çªè§¦æƒé‡
  - å¯ç¼–ç¨‹ç¥ç»å…ƒæ¨¡å‹
  - ç‰‡ä¸Šå­¦ä¹ ï¼ˆSTDPï¼‰
```

### 3.2 ç¥ç»æ ¸å¿ƒèµ„æºæ¨¡å‹

```python
# ç¥ç»æ ¸å¿ƒèµ„æºæ¨¡å‹
class NeuromorphicCore:
    def __init__(self, core_id, capacity):
        self.core_id = core_id
        self.max_neurons = capacity['neurons']  # 1024
        self.max_synapses = capacity['synapses']  # 128K
        self.max_axons = capacity['axons']  # 4096

        self.neurons = []
        self.synapses = []
        self.spike_queue = PriorityQueue()

    def allocate_neuron(self, neuron_config):
        """åˆ†é…ç¥ç»å…ƒèµ„æº"""
        if len(self.neurons) >= self.max_neurons:
            return None

        neuron_id = len(self.neurons)
        self.neurons.append(Neuron(neuron_id, neuron_config))
        return neuron_id

    def process_tick(self, current_time):
        """å¤„ç†ä¸€ä¸ªæ—¶é—´ç‰‡"""
        # æ”¶é›†åˆ°è¾¾çš„è„‰å†²
        incoming_spikes = []
        while not self.spike_queue.empty():
            spike_time, spike = self.spike_queue.peek()
            if spike_time <= current_time:
                self.spike_queue.get()
                incoming_spikes.append(spike)
            else:
                break

        # æ›´æ–°ç¥ç»å…ƒçŠ¶æ€
        output_spikes = []
        for neuron in self.neurons:
            # ç´¯ç§¯è¾“å…¥
            neuron.integrate(incoming_spikes)

            # æ£€æŸ¥æ˜¯å¦å‘æ”¾è„‰å†²
            if neuron.should_fire():
                output_spikes.append(Spike(
                    source=neuron.id,
                    time=current_time,
                    targets=neuron.axon_targets
                ))
                neuron.reset()

            # æ³„æ¼
            neuron.leak()

        return output_spikes
```

---

## 4 è„‰å†²ç¥ç»ç½‘ç»œè°ƒåº¦

### 4.1 äº‹ä»¶é©±åŠ¨è°ƒåº¦å™¨

```python
# SNNäº‹ä»¶é©±åŠ¨è°ƒåº¦å™¨
class SNNScheduler:
    def __init__(self, network, hardware):
        self.network = network
        self.hardware = hardware
        self.event_queue = PriorityQueue()  # (time, event)
        self.current_time = 0

    def run(self, duration, input_spikes):
        """è¿è¡ŒSNNä»¿çœŸ"""
        # åˆå§‹åŒ–è¾“å…¥è„‰å†²
        for spike in input_spikes:
            self.event_queue.put((spike.time, spike))

        # äº‹ä»¶é©±åŠ¨ä¸»å¾ªç¯
        while self.current_time < duration:
            if self.event_queue.empty():
                self.current_time += 1
                continue

            # è·å–ä¸‹ä¸€ä¸ªäº‹ä»¶æ—¶é—´
            next_time, _ = self.event_queue.peek()

            # å¤„ç†å½“å‰æ—¶é—´ç‰‡çš„æ‰€æœ‰äº‹ä»¶
            if next_time <= self.current_time:
                events = self._collect_events(self.current_time)
                output_spikes = self._process_events(events)

                # è°ƒåº¦è¾“å‡ºè„‰å†²
                for spike in output_spikes:
                    self._route_spike(spike)

            self.current_time += 1

    def _process_events(self, events):
        """å¤„ç†ä¸€æ‰¹äº‹ä»¶"""
        output_spikes = []

        # æŒ‰ç›®æ ‡æ ¸å¿ƒåˆ†ç»„
        core_events = defaultdict(list)
        for event in events:
            core_id = self._get_core(event.target)
            core_events[core_id].append(event)

        # å¹¶è¡Œå¤„ç†å„æ ¸å¿ƒ
        for core_id, spikes in core_events.items():
            core = self.hardware.cores[core_id]
            output = core.process_spikes(spikes, self.current_time)
            output_spikes.extend(output)

        return output_spikes

    def _route_spike(self, spike):
        """è·¯ç”±è„‰å†²åˆ°ç›®æ ‡"""
        for target in spike.targets:
            # è®¡ç®—ä¼ æ’­å»¶è¿Ÿ
            source_core = self._get_core(spike.source)
            target_core = self._get_core(target)
            delay = self._routing_delay(source_core, target_core)

            # åˆ›å»ºåˆ°è¾¾äº‹ä»¶
            arrival_time = self.current_time + delay
            arrival_event = SpikeArrival(
                source=spike.source,
                target=target,
                time=arrival_time,
                weight=self._get_weight(spike.source, target)
            )

            self.event_queue.put((arrival_time, arrival_event))
```

### 4.2 ç¥ç»å…ƒåˆ†é…ç­–ç•¥

```python
# ç¥ç»å…ƒåˆ°æ ¸å¿ƒçš„æ˜ å°„ç­–ç•¥
class NeuronMapper:
    def __init__(self, hardware_topology):
        self.topology = hardware_topology
        self.core_assignments = {}

    def map_network(self, snn_network):
        """æ˜ å°„SNNåˆ°ç¡¬ä»¶"""
        # ç­–ç•¥1: æœ€å°åŒ–é€šä¿¡
        self._locality_aware_mapping(snn_network)

        # ç­–ç•¥2: è´Ÿè½½å‡è¡¡
        self._balance_load()

        return self.core_assignments

    def _locality_aware_mapping(self, network):
        """å±€éƒ¨æ€§æ„ŸçŸ¥æ˜ å°„"""
        # æ„å»ºç¥ç»å…ƒè¿æ¥å›¾
        connectivity = self._build_connectivity_graph(network)

        # ä½¿ç”¨å›¾åˆ†åŒºç®—æ³•
        partitions = self._partition_graph(
            connectivity,
            num_parts=len(self.topology.cores)
        )

        # åˆ†é…åˆ°æ ¸å¿ƒ
        for partition_id, neurons in enumerate(partitions):
            core = self.topology.cores[partition_id]
            for neuron in neurons:
                if core.has_capacity():
                    self.core_assignments[neuron] = core.id
                else:
                    # æº¢å‡ºåˆ°é‚»è¿‘æ ¸å¿ƒ
                    neighbor = self._find_neighbor_with_capacity(core)
                    self.core_assignments[neuron] = neighbor.id

    def _balance_load(self):
        """è´Ÿè½½å‡è¡¡è°ƒæ•´"""
        core_loads = defaultdict(int)
        for neuron, core_id in self.core_assignments.items():
            core_loads[core_id] += 1

        avg_load = len(self.core_assignments) / len(self.topology.cores)

        # ä»è¿‡è½½æ ¸å¿ƒè¿ç§»ç¥ç»å…ƒ
        for core_id, load in core_loads.items():
            if load > avg_load * 1.2:  # è¶…è½½20%
                excess = int(load - avg_load)
                self._migrate_neurons(core_id, excess)
```

### 4.3 è„‰å†²è·¯ç”±

```python
# ç¥ç»å½¢æ€èŠ¯ç‰‡è„‰å†²è·¯ç”±
class SpikeRouter:
    def __init__(self, mesh_topology):
        self.topology = mesh_topology
        self.routing_tables = self._build_routing_tables()

    def route_spike(self, spike, source_core, target_cores):
        """è·¯ç”±è„‰å†²åˆ°å¤šä¸ªç›®æ ‡"""
        # å¤šæ’­è·¯ç”±
        routing_tree = self._build_multicast_tree(
            source_core, target_cores
        )

        # ç”Ÿæˆè·¯ç”±åŒ…
        packets = []
        for path in routing_tree:
            packet = SpikePacket(
                spike=spike,
                path=path,
                hops=len(path) - 1
            )
            packets.append(packet)

        return packets

    def _build_multicast_tree(self, source, targets):
        """æ„å»ºå¤šæ’­è·¯ç”±æ ‘"""
        # ä½¿ç”¨ç»´åº¦é¡ºåºè·¯ç”± (DOR)
        paths = []
        for target in targets:
            path = self._dimension_order_route(source, target)
            paths.append(path)

        # åˆå¹¶å…±åŒå‰ç¼€
        return self._merge_paths(paths)

    def _dimension_order_route(self, source, target):
        """XYç»´åº¦é¡ºåºè·¯ç”±"""
        path = [source]
        current = source

        # å…ˆXæ–¹å‘
        while current.x != target.x:
            if current.x < target.x:
                current = self.topology.get_neighbor(current, 'east')
            else:
                current = self.topology.get_neighbor(current, 'west')
            path.append(current)

        # å†Yæ–¹å‘
        while current.y != target.y:
            if current.y < target.y:
                current = self.topology.get_neighbor(current, 'north')
            else:
                current = self.topology.get_neighbor(current, 'south')
            path.append(current)

        return path
```

---

## 5 æ—¶é—´ç¼–ç è°ƒåº¦

### 5.1 æ—¶é—´ç¼–ç ç­–ç•¥

```text
æ—¶é—´ç¼–ç æ–¹å¼:

1. é€Ÿç‡ç¼–ç  (Rate Coding):
   ä¿¡æ¯ âˆ è„‰å†²é¢‘ç‡
   ç®€å•ä½†æ•ˆç‡ä½

2. æ—¶é—´ç¼–ç  (Temporal Coding):
   ä¿¡æ¯åœ¨è„‰å†²ç²¾ç¡®æ—¶é—´
   é«˜æ•ˆä½†å¯¹å™ªå£°æ•æ„Ÿ

3. æ—¶é—´åˆ°é¦–è„‰å†² (Time-to-First-Spike):
   ä¿¡æ¯åœ¨é¦–ä¸ªè„‰å†²æ—¶é—´
   å¿«é€Ÿå“åº”

4. ç¾¤ä½“ç¼–ç  (Population Coding):
   ä¿¡æ¯åœ¨ç¥ç»å…ƒç¾¤ä½“æ´»åŠ¨æ¨¡å¼
   é²æ£’æ€§é«˜

è°ƒåº¦å½±å“:
- é€Ÿç‡ç¼–ç : éœ€è¦è¾ƒé•¿æ—¶é—´çª—å£
- æ—¶é—´ç¼–ç : éœ€è¦ç²¾ç¡®æ—¶é—´åŒæ­¥
- ç¾¤ä½“ç¼–ç : éœ€è¦å¹¶è¡Œå¤„ç†èƒ½åŠ›
```

### 5.2 STDPå­¦ä¹ è°ƒåº¦

```python
# STDP (Spike-Timing-Dependent Plasticity) è°ƒåº¦
class STDPScheduler:
    def __init__(self, tau_plus=20, tau_minus=20, a_plus=0.1, a_minus=0.12):
        self.tau_plus = tau_plus    # LTPæ—¶é—´å¸¸æ•°
        self.tau_minus = tau_minus  # LTDæ—¶é—´å¸¸æ•°
        self.a_plus = a_plus        # LTPå¹…åº¦
        self.a_minus = a_minus      # LTDå¹…åº¦

        self.spike_history = defaultdict(list)  # ç¥ç»å…ƒè„‰å†²å†å²

    def record_spike(self, neuron_id, time):
        """è®°å½•è„‰å†²"""
        self.spike_history[neuron_id].append(time)

        # ä¿æŒå†å²çª—å£
        window = max(self.tau_plus, self.tau_minus) * 5
        self.spike_history[neuron_id] = [
            t for t in self.spike_history[neuron_id]
            if time - t < window
        ]

    def compute_weight_update(self, pre_id, post_id, synapse):
        """è®¡ç®—æƒé‡æ›´æ–°"""
        pre_spikes = self.spike_history[pre_id]
        post_spikes = self.spike_history[post_id]

        delta_w = 0.0

        for t_pre in pre_spikes:
            for t_post in post_spikes:
                dt = t_post - t_pre

                if dt > 0:
                    # LTP: å‰è„‰å†²å…ˆäºåè„‰å†²
                    delta_w += self.a_plus * exp(-dt / self.tau_plus)
                elif dt < 0:
                    # LTD: åè„‰å†²å…ˆäºå‰è„‰å†²
                    delta_w -= self.a_minus * exp(dt / self.tau_minus)

        return delta_w

    def batch_update(self, network, batch_size=1000):
        """æ‰¹é‡æƒé‡æ›´æ–°"""
        updates = []

        for synapse in network.synapses:
            delta_w = self.compute_weight_update(
                synapse.pre, synapse.post, synapse
            )
            if abs(delta_w) > 1e-6:
                updates.append((synapse, delta_w))

        # æ‰¹é‡åº”ç”¨æ›´æ–°
        for synapse, delta_w in updates[:batch_size]:
            synapse.weight = clip(
                synapse.weight + delta_w,
                synapse.w_min, synapse.w_max
            )
```

---

## 6 çŸ¥è¯†çŸ©é˜µ

### 6.1 ç¥ç»å½¢æ€ç¡¬ä»¶å¯¹æ¯”

| å¹³å° | ç¥ç»å…ƒæ•° | çªè§¦æ•° | åŠŸè€— | ç‰¹ç‚¹ |
|------|---------|-------|------|------|
| **Loihi 2** | 1M | 120M | <1W | å¯ç¼–ç¨‹å­¦ä¹  |
| **TrueNorth** | 1M | 256M | 70mW | è¶…ä½åŠŸè€— |
| **SpiNNaker 2** | å¯æ‰©å±• | å¯æ‰©å±• | å˜åŒ– | å¤§è§„æ¨¡ |
| **BrainScaleS 2** | 512 | 130K | ~W | æ¨¡æ‹ŸåŠ é€Ÿ |

### 6.2 è°ƒåº¦ç­–ç•¥å¯¹æ¯”

| ç­–ç•¥ | ç›®æ ‡ | é€‚ç”¨åœºæ™¯ | å¤æ‚åº¦ |
|------|------|---------|-------|
| **äº‹ä»¶é©±åŠ¨** | å»¶è¿Ÿ | ç¨€ç–ç½‘ç»œ | O(events) |
| **æ—¶é’Ÿé©±åŠ¨** | åå | å¯†é›†ç½‘ç»œ | O(neurons) |
| **æ··åˆ** | å¹³è¡¡ | ä¸€èˆ¬åº”ç”¨ | O(n log n) |

---

## 7 è·¨è§†è§’é“¾æ¥

### 7.1 è°ƒåº¦è§†è§’å…³è”

| ç›¸å…³ä¸»é¢˜ | å…³è”å†…å®¹ | é“¾æ¥ |
|---------|---------|------|
| GPUè°ƒåº¦ | å¼‚æ„è®¡ç®— | [16_GPUä¸åŠ é€Ÿå™¨è°ƒåº¦](../16_GPUä¸åŠ é€Ÿå™¨è°ƒåº¦/) |
| AIè°ƒåº¦ | ç¥ç»ç½‘ç»œ | [10_AIé©±åŠ¨è°ƒåº¦](../10_AIé©±åŠ¨è°ƒåº¦/) |
| é‡å­è°ƒåº¦ | æ–°å‹è®¡ç®— | [28_é‡å­è®¡ç®—è°ƒåº¦](../28_é‡å­è®¡ç®—è°ƒåº¦/) |

### 7.2 å½¢å¼è¯­è¨€è§†è§’å…³è”

| å½¢å¼è¯­è¨€æ¦‚å¿µ | ç¥ç»å½¢æ€å¯¹åº” | æ˜ å°„è¯´æ˜ |
|------------|-------------|---------|
| **äº‹ä»¶ç±»å‹** | è„‰å†²äº‹ä»¶ | å¼‚æ­¥é€šä¿¡ |
| **æ—¶åºç±»å‹** | æ—¶é—´ç¼–ç  | æ—¶é—´çº¦æŸ |
| **æ¦‚ç‡ç±»å‹** | éšæœºè„‰å†² | ä¸ç¡®å®šæ€§ |

---

## å‚è€ƒèµ„æº

1. [Intel Loihi](https://www.intel.com/content/www/us/en/research/neuromorphic-computing.html)
2. [SpiNNaker Project](http://apt.cs.manchester.ac.uk/projects/SpiNNaker/)
3. [Nengo Framework](https://www.nengo.ai/)
4. [Brian2 Simulator](https://brian2.readthedocs.io/)

---

**è¿”å›**: [è°ƒåº¦è§†è§’ä¸»ç´¢å¼•](../README.md)
