# 07.1 ç»Ÿä¸€è§‚æµ‹æ¨¡å‹

> **æ‰€å±ä¸»é¢˜**: 07_ç›‘æ§ä¸åé¦ˆ
> **æœ€åæ›´æ–°**: 2025-01-27

## ğŸ“‹ ç›®å½•

- [07.1 ç»Ÿä¸€è§‚æµ‹æ¨¡å‹](#071-ç»Ÿä¸€è§‚æµ‹æ¨¡å‹)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ç»Ÿä¸€ç›‘æ§æ–¹ç¨‹](#1-ç»Ÿä¸€ç›‘æ§æ–¹ç¨‹)
  - [2. å¡å°”æ›¼æ»¤æ³¢å™¨](#2-å¡å°”æ›¼æ»¤æ³¢å™¨)
    - [2.1. å¡å°”æ›¼æ»¤æ³¢å™¨çš„ç†è®ºåŸºç¡€](#21-å¡å°”æ›¼æ»¤æ³¢å™¨çš„ç†è®ºåŸºç¡€)
      - [æ­¥éª¤1ï¼šæœ€å°å‡æ–¹è¯¯å·®ä¼°è®¡](#æ­¥éª¤1æœ€å°å‡æ–¹è¯¯å·®ä¼°è®¡)
      - [æ­¥éª¤2ï¼šè´å¶æ–¯ä¼°è®¡](#æ­¥éª¤2è´å¶æ–¯ä¼°è®¡)
      - [æ­¥éª¤3ï¼šå¡å°”æ›¼æ»¤æ³¢å™¨é€’æ¨å…¬å¼](#æ­¥éª¤3å¡å°”æ›¼æ»¤æ³¢å™¨é€’æ¨å…¬å¼)
      - [æ­¥éª¤4ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤4ä¸»å®šç†è¯æ˜)
    - [2.2. å¡å°”æ›¼å¢ç›Šçš„æ¨å¯¼](#22-å¡å°”æ›¼å¢ç›Šçš„æ¨å¯¼)
  - [3. ä¸‰å±‚ç³»ç»Ÿè§‚æµ‹æ˜ å°„](#3-ä¸‰å±‚ç³»ç»Ÿè§‚æµ‹æ˜ å°„)
    - [3.1. åŸºç¡€è§‚æµ‹æ˜ å°„è¡¨](#31-åŸºç¡€è§‚æµ‹æ˜ å°„è¡¨)
    - [3.2. è¯¦ç»†è§‚æµ‹å‚æ•°å¯¹æ¯”](#32-è¯¦ç»†è§‚æµ‹å‚æ•°å¯¹æ¯”)
    - [3.3. è§‚æµ‹ç‰¹ç‚¹è¯¦ç»†å¯¹æ¯”](#33-è§‚æµ‹ç‰¹ç‚¹è¯¦ç»†å¯¹æ¯”)
  - [4. ç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„å®é™…åº”ç”¨](#4-ç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„å®é™…åº”ç”¨)
    - [Golangå®ç°](#golangå®ç°)
      - [Pythonå®ç°](#pythonå®ç°)
      - [Rustå®ç°](#rustå®ç°)
    - [4.1. ç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„æ”¶æ•›æ€§](#41-ç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„æ”¶æ•›æ€§)
      - [æ­¥éª¤1ï¼šå¯è§‚æµ‹æ€§æ¡ä»¶](#æ­¥éª¤1å¯è§‚æµ‹æ€§æ¡ä»¶)
      - [æ­¥éª¤2ï¼šæ”¶æ•›æ€§è¯æ˜](#æ­¥éª¤2æ”¶æ•›æ€§è¯æ˜)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜)
    - [4.2. ç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„æœ€ä¼˜æ€§](#42-ç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„æœ€ä¼˜æ€§)
      - [æ­¥éª¤1ï¼šæœ€ä¼˜æ€§å®šä¹‰](#æ­¥éª¤1æœ€ä¼˜æ€§å®šä¹‰)
      - [æ­¥éª¤2ï¼šæœ€ä¼˜æ€§è¯æ˜](#æ­¥éª¤2æœ€ä¼˜æ€§è¯æ˜)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜-1)
    - [4.3. è§‚æµ‹æ¨¡å‹çš„é²æ£’æ€§](#43-è§‚æµ‹æ¨¡å‹çš„é²æ£’æ€§)
      - [æ­¥éª¤1ï¼šé²æ£’æ€§å®šä¹‰](#æ­¥éª¤1é²æ£’æ€§å®šä¹‰)
      - [æ­¥éª¤2ï¼šé²æ£’æ€§è¯æ˜](#æ­¥éª¤2é²æ£’æ€§è¯æ˜)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜-2)
    - [4.4. ç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„å®é™…åº”ç”¨](#44-ç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„å®é™…åº”ç”¨)
      - [4.4.1. ç³»ç»ŸçŠ¶æ€ä¼°è®¡](#441-ç³»ç»ŸçŠ¶æ€ä¼°è®¡)
  - [5. ç›¸å…³æ–‡æ¡£](#5-ç›¸å…³æ–‡æ¡£)

---

## 1. ç»Ÿä¸€ç›‘æ§æ–¹ç¨‹

**è§‚æµ‹æ¨¡å‹**ï¼š

```text
è§‚æµ‹å€¼ = çœŸå®çŠ¶æ€ + å™ªå£° + é‡‡æ ·è¯¯å·®
y[k] = Hx[k] + v[k] + Îµ[k]
```

å…¶ä¸­ï¼š

- $y[k]$: ç¬¬ $k$ æ—¶åˆ»çš„è§‚æµ‹å€¼
- $x[k]$: ç¬¬ $k$ æ—¶åˆ»çš„çœŸå®çŠ¶æ€
- $H$: è§‚æµ‹çŸ©é˜µ
- $v[k]$: è§‚æµ‹å™ªå£°
- $\varepsilon[k]$: é‡‡æ ·è¯¯å·®

---

## 2. å¡å°”æ›¼æ»¤æ³¢å™¨

**å¡å°”æ›¼æ»¤æ³¢å™¨ä¼°è®¡çœŸå®çŠ¶æ€**ï¼š

$$
\hat{x}[k|k] = \hat{x}[k|k-1] + K[k](y[k] - H\hat{x}[k|k-1])
$$

å…¶ä¸­ï¼š

- $\hat{x}[k|k-1]$: é¢„æµ‹çŠ¶æ€
- $\hat{x}[k|k]$: æ›´æ–°åçš„çŠ¶æ€ä¼°è®¡
- $K[k]$: å¡å°”æ›¼å¢ç›Š

### 2.1. å¡å°”æ›¼æ»¤æ³¢å™¨çš„ç†è®ºåŸºç¡€

**å®šç†7**ï¼ˆå¡å°”æ›¼æ»¤æ³¢å™¨æœ€ä¼˜æ€§ï¼‰ï¼š
åœ¨è§‚æµ‹å™ªå£°å’Œè¿‡ç¨‹å™ªå£°å‡ä¸ºé«˜æ–¯ç™½å™ªå£°çš„æ¡ä»¶ä¸‹ï¼Œå¡å°”æ›¼æ»¤æ³¢å™¨æä¾›æœ€å°å‡æ–¹è¯¯å·®ï¼ˆMMSEï¼‰ä¼°è®¡ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šæœ€å°å‡æ–¹è¯¯å·®ä¼°è®¡

**å®šä¹‰**ï¼ˆæœ€å°å‡æ–¹è¯¯å·®ä¼°è®¡ï¼‰ï¼š
å¯¹äºçŠ¶æ€ $x[k]$ å’Œè§‚æµ‹ $y[1:k]$ï¼Œæœ€å°å‡æ–¹è¯¯å·®ä¼°è®¡ä¸ºï¼š

$$
\hat{x}[k|k] = \arg\min_{\hat{x}} \mathbb{E}[\|x[k] - \hat{x}\|^2 | y[1:k]]
$$

#### æ­¥éª¤2ï¼šè´å¶æ–¯ä¼°è®¡

**å¼•ç†7.1**ï¼ˆè´å¶æ–¯ä¼°è®¡ï¼‰ï¼š
åœ¨æ­£æ€åˆ†å¸ƒå‡è®¾ä¸‹ï¼Œæœ€å°å‡æ–¹è¯¯å·®ä¼°è®¡ç­‰äºåéªŒå‡å€¼ï¼š

$$
\hat{x}[k|k] = \mathbb{E}[x[k] | y[1:k]]
$$

**è¯æ˜**ï¼š
å¯¹äºæ­£æ€åˆ†å¸ƒï¼ŒåéªŒåˆ†å¸ƒä¹Ÿæ˜¯æ­£æ€åˆ†å¸ƒï¼Œå…¶å‡å€¼æ˜¯æœ€å°å‡æ–¹è¯¯å·®ä¼°è®¡ã€‚ âˆ

#### æ­¥éª¤3ï¼šå¡å°”æ›¼æ»¤æ³¢å™¨é€’æ¨å…¬å¼

**å¼•ç†7.2**ï¼ˆå¡å°”æ›¼æ»¤æ³¢å™¨é€’æ¨ï¼‰ï¼š
å¡å°”æ›¼æ»¤æ³¢å™¨çš„é€’æ¨å…¬å¼ç»™å‡ºåéªŒå‡å€¼å’Œåæ–¹å·®ã€‚

**è¯æ˜**ï¼š
ç”±çŠ¶æ€ç©ºé—´æ¨¡å‹å’Œè´å¶æ–¯æ›´æ–°è§„åˆ™ï¼Œå¯ä»¥æ¨å¯¼å‡ºå¡å°”æ›¼æ»¤æ³¢å™¨çš„é€’æ¨å…¬å¼ã€‚ âˆ

#### æ­¥éª¤4ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†7.1å’Œ7.2ï¼Œå¡å°”æ›¼æ»¤æ³¢å™¨æä¾›æœ€å°å‡æ–¹è¯¯å·®ä¼°è®¡ã€‚ âˆ

### 2.2. å¡å°”æ›¼å¢ç›Šçš„æ¨å¯¼

**æ»¤æ³¢æ­¥éª¤**ï¼š

1. é¢„æµ‹ï¼š$\hat{x}[k|k-1] = A\hat{x}[k-1|k-1]$
2. æ›´æ–°ï¼š$\hat{x}[k|k] = \hat{x}[k|k-1] + K[k](y[k] - H\hat{x}[k|k-1])$

---

## 3. ä¸‰å±‚ç³»ç»Ÿè§‚æµ‹æ˜ å°„

### 3.1. åŸºç¡€è§‚æµ‹æ˜ å°„è¡¨

| å±‚çº§ | çŠ¶æ€ x | è§‚æµ‹çŸ©é˜µ H | å™ªå£° v | é‡‡æ ·é¢‘ç‡ | å»¶è¿Ÿ |
|------|--------|-----------|--------|---------|------|
| OSå±‚ | è¿›ç¨‹çŠ¶æ€ | å†…æ ¸æ¢é’ˆ | ä¸­æ–­å»¶è¿Ÿ | 1Hz | <1Î¼s |
| VMå±‚ | è™šæ‹ŸæœºæŒ‡æ ‡ | hypercall | steal time | 5s | ~10Î¼s |
| å®¹å™¨å±‚ | åº”ç”¨æŒ‡æ ‡ | cAdvisor | cgroupç»Ÿè®¡å»¶è¿Ÿ | 15s | ~1ms |

### 3.2. è¯¦ç»†è§‚æµ‹å‚æ•°å¯¹æ¯”

| å‚æ•°ç±»å‹ | OSå±‚ | VMå±‚ | å®¹å™¨å±‚ | ç»Ÿä¸€æŠ½è±¡ | æ•°å­¦è¡¨è¾¾ |
|---------|------|------|--------|---------|---------|
| **çŠ¶æ€å‘é‡** | [è¿›ç¨‹æ•°, CPUé˜Ÿåˆ—, ç¼ºé¡µç‡] | [VMå¯†åº¦, è¿ç§»å¼€é”€, ç¢ç‰‡ç‡] | [Podå‰¯æœ¬æ•°, è¯·æ±‚ç§¯å‹, èŠ‚ç‚¹è´Ÿè½½] | `StateVector` | $\mathbf{x} \in \mathbb{R}^n$ |
| **è§‚æµ‹çŸ©é˜µ** | å†…æ ¸æ¢é’ˆ | hypercallæ¥å£ | cAdvisor API | `ObservationMatrix` | $H \in \mathbb{R}^{m \times n}$ |
| **è§‚æµ‹å™ªå£°** | ä¸­æ–­å»¶è¿Ÿ (~1Î¼s) | steal time (~10Î¼s) | cgroupç»Ÿè®¡å»¶è¿Ÿ (~1ms) | `ObservationNoise` | $v \sim \mathcal{N}(0, R)$ |
| **è¿‡ç¨‹å™ªå£°** | è¿›ç¨‹åˆ›å»º/ç»ˆæ­¢ | VMè¿ç§» | Podè°ƒåº¦ | `ProcessNoise` | $w \sim \mathcal{N}(0, Q)$ |

### 3.3. è§‚æµ‹ç‰¹ç‚¹è¯¦ç»†å¯¹æ¯”

**è§‚æµ‹ç‰¹ç‚¹**ï¼š

- **OSå±‚**ï¼šç›´æ¥å†…æ ¸è®¿é—®ï¼Œå»¶è¿Ÿä½ï¼ˆ<1Î¼sï¼‰ï¼Œç²¾åº¦é«˜
- **VMå±‚**ï¼šé€šè¿‡hypercallï¼Œæœ‰è™šæ‹ŸåŒ–å¼€é”€ï¼ˆ~10Î¼sï¼‰ï¼Œç²¾åº¦ä¸­ç­‰
- **å®¹å™¨å±‚**ï¼šé€šè¿‡cgroupæ¥å£ï¼Œæœ‰é‡‡æ ·å»¶è¿Ÿï¼ˆ~1msï¼‰ï¼Œç²¾åº¦è¾ƒä½

**è§‚æµ‹è¯¯å·®æ¥æº**ï¼š

1. **é‡‡æ ·è¯¯å·®** $\varepsilon[k]$ï¼šç¦»æ•£é‡‡æ ·å¯¼è‡´çš„è¯¯å·®
   - OSå±‚ï¼šé‡‡æ ·é¢‘ç‡é«˜ï¼Œè¯¯å·®å°
   - VMå±‚ï¼šé‡‡æ ·é¢‘ç‡ä¸­ç­‰ï¼Œè¯¯å·®ä¸­ç­‰
   - å®¹å™¨å±‚ï¼šé‡‡æ ·é¢‘ç‡ä½ï¼Œè¯¯å·®è¾ƒå¤§
2. **å™ªå£°** $v[k]$ï¼šç³»ç»Ÿå™ªå£°å’Œæµ‹é‡å™ªå£°
   - OSå±‚ï¼šä¸»è¦æ˜¯ä¸­æ–­å»¶è¿Ÿå™ªå£°
   - VMå±‚ï¼šä¸»è¦æ˜¯steal timeå™ªå£°
   - å®¹å™¨å±‚ï¼šä¸»è¦æ˜¯cgroupç»Ÿè®¡å»¶è¿Ÿå™ªå£°
3. **å»¶è¿Ÿ**ï¼šä»çŠ¶æ€å˜åŒ–åˆ°è§‚æµ‹å€¼æ›´æ–°çš„å»¶è¿Ÿ
   - OSå±‚ï¼šå»¶è¿Ÿæœ€å°ï¼ˆ<1Î¼sï¼‰
   - VMå±‚ï¼šå»¶è¿Ÿä¸­ç­‰ï¼ˆ~10Î¼sï¼‰
   - å®¹å™¨å±‚ï¼šå»¶è¿Ÿæœ€å¤§ï¼ˆ~1msï¼‰

**è¯¯å·®æ§åˆ¶**ï¼š
ä½¿ç”¨å¡å°”æ›¼æ»¤æ³¢å™¨å¯ä»¥æœ€å°åŒ–è§‚æµ‹è¯¯å·®ï¼š
$$
\hat{x}[k|k] = \arg\min_{x} \mathbb{E}[\|x - x[k]\|^2 | y[1:k]]
$$

**å¡å°”æ›¼å¢ç›Š**ï¼š
$$
K[k] = P[k|k-1]H^T(HP[k|k-1]H^T + R)^{-1}
$$

å…¶ä¸­ï¼š

- $P[k|k-1]$: é¢„æµ‹è¯¯å·®åæ–¹å·®
- $R$: è§‚æµ‹å™ªå£°åæ–¹å·®
- $K[k]$: å¡å°”æ›¼å¢ç›Šï¼Œå¹³è¡¡é¢„æµ‹å’Œè§‚æµ‹çš„æƒé‡

---

## 4. ç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„å®é™…åº”ç”¨

**ç›‘æ§ç³»ç»Ÿè®¾è®¡**ï¼š

1. **Prometheus**ï¼šåœ¨å®¹å™¨å±‚å®ç°äº†ç±»ä¼¼OSå±‚procfsçš„ç›‘æ§æ¥å£
2. **cAdvisor**ï¼šæä¾›äº†ç±»ä¼¼OSå±‚taskstatsçš„å®¹å™¨æŒ‡æ ‡
3. **Metrics API**ï¼šç»Ÿä¸€äº†ä¸‰å±‚ç³»ç»Ÿçš„ç›‘æ§æ•°æ®æ ¼å¼

**æ€§èƒ½ä¼˜åŒ–**ï¼š

- å‡å°‘é‡‡æ ·é¢‘ç‡ä»¥é™ä½å¼€é”€
- ä½¿ç”¨é¢„æµ‹æ¨¡å‹å‡å°‘å»¶è¿Ÿ
- é‡‡ç”¨è‡ªé€‚åº”é‡‡æ ·ç­–ç•¥å¹³è¡¡ç²¾åº¦å’Œå¼€é”€

**å®é™…ç³»ç»Ÿå®ç°å¯¹æ¯”**ï¼š

| ç³»ç»Ÿ | è§‚æµ‹æ¥å£ | é‡‡æ ·é¢‘ç‡ | å»¶è¿Ÿ | ç²¾åº¦ |
|------|---------|---------|------|------|
| Linux procfs | å†…æ ¸æ¢é’ˆ | 1Hz | <1Î¼s | é«˜ |
| vSphere | hypercall | 5s | ~10Î¼s | ä¸­ |
| Prometheus | cAdvisor | 15s | ~1ms | ä¸­ |
| Kubernetes Metrics API | cgroup | 1s | ~10ms | ä½ |

**å¡å°”æ›¼æ»¤æ³¢å™¨çš„å®é™…åº”ç”¨**ï¼š

- **çŠ¶æ€ä¼°è®¡**ï¼šä¼°è®¡ç³»ç»ŸçœŸå®çŠ¶æ€ï¼Œå‡å°‘è§‚æµ‹å™ªå£°å½±å“
- **é¢„æµ‹**ï¼šé¢„æµ‹ç³»ç»Ÿæœªæ¥çŠ¶æ€ï¼Œæå‰åšå‡ºå†³ç­–
- **ä¼˜åŒ–**ï¼šä¼˜åŒ–è§‚æµ‹ç­–ç•¥ï¼Œå¹³è¡¡ç²¾åº¦å’Œå¼€é”€

**å·¥ç¨‹å®ç°ç¤ºä¾‹**ï¼š

### Golangå®ç°

```go
package observation

import (
    "gonum.org/v1/gonum/mat"
    "math"
)

// å¡å°”æ›¼æ»¤æ³¢å™¨
type KalmanFilter struct {
    A *mat.Dense // çŠ¶æ€è½¬ç§»çŸ©é˜µ
    B *mat.Dense // æ§åˆ¶è¾“å…¥çŸ©é˜µ
    H *mat.Dense // è§‚æµ‹çŸ©é˜µ
    Q *mat.Dense // è¿‡ç¨‹å™ªå£°åæ–¹å·®
    R *mat.Dense // è§‚æµ‹å™ªå£°åæ–¹å·®
    P *mat.Dense // è¯¯å·®åæ–¹å·®
    x *mat.VecDense // çŠ¶æ€ä¼°è®¡
}

func NewKalmanFilter(A, B, H, Q, R, P0 *mat.Dense, x0 *mat.VecDense) *KalmanFilter {
    return &KalmanFilter{
        A: A,
        B: B,
        H: H,
        Q: Q,
        R: R,
        P: mat.DenseCopyOf(P0),
        x: mat.VecDenseCopyOf(x0),
    }
}

// é¢„æµ‹æ­¥éª¤
func (kf *KalmanFilter) Predict(u *mat.VecDense) *mat.VecDense {
    // çŠ¶æ€é¢„æµ‹ï¼šx = A*x + B*u
    var Ax, Bu mat.VecDense
    Ax.MulVec(kf.A, kf.x)

    if u != nil {
        Bu.MulVec(kf.B, u)
        kf.x.AddVec(&Ax, &Bu)
    } else {
        kf.x = &Ax
    }

    // è¯¯å·®åæ–¹å·®é¢„æµ‹ï¼šP = A*P*A^T + Q
    var AP, APAT mat.Dense
    AP.Mul(kf.A, kf.P)
    APAT.Mul(&AP, kf.A.T())
    kf.P.Add(&APAT, kf.Q)

    return mat.VecDenseCopyOf(kf.x)
}

// æ›´æ–°æ­¥éª¤
func (kf *KalmanFilter) Update(y *mat.VecDense) *mat.VecDense {
    // è®¡ç®—å¡å°”æ›¼å¢ç›Šï¼šK = P*H^T*(H*P*H^T + R)^(-1)
    var HP, HPHt, S, K mat.Dense
    HP.Mul(kf.H, kf.P)
    HPHt.Mul(&HP, kf.H.T())
    S.Add(&HPHt, kf.R)

    var SInv mat.Dense
    SInv.Inverse(&S)

    var PHT mat.Dense
    PHT.Mul(kf.P, kf.H.T())
    K.Mul(&PHT, &SInv)

    // çŠ¶æ€æ›´æ–°ï¼šx = x + K*(y - H*x)
    var Hx, innovation mat.VecDense
    Hx.MulVec(kf.H, kf.x)
    innovation.SubVec(y, &Hx)

    var KInnovation mat.VecDense
    KInnovation.MulVec(&K, &innovation)
    kf.x.AddVec(kf.x, &KInnovation)

    // è¯¯å·®åæ–¹å·®æ›´æ–°ï¼šP = (I - K*H)*P
    var I, KH, IKH mat.Dense
    I.CloneFrom(kf.P)
    for i := 0; i < I.RawMatrix().Rows; i++ {
        I.Set(i, i, 1.0)
    }
    KH.Mul(&K, kf.H)
    IKH.Sub(&I, &KH)
    kf.P.Mul(&IKH, kf.P)

    return mat.VecDenseCopyOf(kf.x)
}

// ç»Ÿä¸€è§‚æµ‹æ¨¡å‹
type UnifiedObservationModel struct {
    filter *KalmanFilter
    layer  string
}

func NewUnifiedObservationModel(layer string, A, B, H, Q, R, P0 *mat.Dense, x0 *mat.VecDense) *UnifiedObservationModel {
    return &UnifiedObservationModel{
        filter: NewKalmanFilter(A, B, H, Q, R, P0, x0),
        layer:  layer,
    }
}

// è§‚æµ‹ç³»ç»ŸçŠ¶æ€
func (uom *UnifiedObservationModel) Observe(measurement *mat.VecDense) *mat.VecDense {
    // é¢„æµ‹
    uom.filter.Predict(nil)

    // æ›´æ–°
    return uom.filter.Update(measurement)
}
```

#### Pythonå®ç°

```python
import numpy as np
from typing import Optional
import threading

class KalmanFilter:
    """å¡å°”æ›¼æ»¤æ³¢å™¨"""
    def __init__(self, A, B, H, Q, R, P0, x0):
        self.A = np.array(A)  # çŠ¶æ€è½¬ç§»çŸ©é˜µ
        self.B = np.array(B)  # æ§åˆ¶è¾“å…¥çŸ©é˜µ
        self.H = np.array(H)  # è§‚æµ‹çŸ©é˜µ
        self.Q = np.array(Q)  # è¿‡ç¨‹å™ªå£°åæ–¹å·®
        self.R = np.array(R)  # è§‚æµ‹å™ªå£°åæ–¹å·®
        self.P = np.array(P0)  # è¯¯å·®åæ–¹å·®
        self.x = np.array(x0)  # çŠ¶æ€ä¼°è®¡
        self._lock = threading.Lock()

    def predict(self, u: Optional[np.ndarray] = None) -> np.ndarray:
        """é¢„æµ‹æ­¥éª¤"""
        with self._lock:
            # çŠ¶æ€é¢„æµ‹ï¼šx = A*x + B*u
            if u is not None:
                self.x = self.A @ self.x + self.B @ u
            else:
                self.x = self.A @ self.x

            # è¯¯å·®åæ–¹å·®é¢„æµ‹ï¼šP = A*P*A^T + Q
            self.P = self.A @ self.P @ self.A.T + self.Q

            return self.x.copy()

    def update(self, y: np.ndarray) -> np.ndarray:
        """æ›´æ–°æ­¥éª¤"""
        with self._lock:
            # è®¡ç®—å¡å°”æ›¼å¢ç›Šï¼šK = P*H^T*(H*P*H^T + R)^(-1)
            S = self.H @ self.P @ self.H.T + self.R
            K = self.P @ self.H.T @ np.linalg.inv(S)

            # çŠ¶æ€æ›´æ–°ï¼šx = x + K*(y - H*x)
            y_pred = self.H @ self.x
            innovation = y - y_pred
            self.x = self.x + K @ innovation

            # è¯¯å·®åæ–¹å·®æ›´æ–°ï¼šP = (I - K*H)*P
            I = np.eye(self.P.shape[0])
            self.P = (I - K @ self.H) @ self.P

            return self.x.copy()

class UnifiedObservationModel:
    """ç»Ÿä¸€è§‚æµ‹æ¨¡å‹"""
    def __init__(self, layer: str, A, B, H, Q, R, P0, x0):
        self.filter = KalmanFilter(A, B, H, Q, R, P0, x0)
        self.layer = layer

    def observe(self, measurement: np.ndarray) -> np.ndarray:
        """è§‚æµ‹ç³»ç»ŸçŠ¶æ€"""
        # é¢„æµ‹
        self.filter.predict()

        # æ›´æ–°
        return self.filter.update(measurement)

    def get_state_estimate(self) -> np.ndarray:
        """è·å–çŠ¶æ€ä¼°è®¡"""
        return self.filter.x.copy()

    def get_uncertainty(self) -> np.ndarray:
        """è·å–ä¸ç¡®å®šæ€§ï¼ˆè¯¯å·®åæ–¹å·®ï¼‰"""
        return self.filter.P.copy()

# OSå±‚è§‚æµ‹æ¨¡å‹
def create_os_observation_model():
    """åˆ›å»ºOSå±‚è§‚æµ‹æ¨¡å‹"""
    # çŠ¶æ€ï¼šè¿›ç¨‹æ•°ã€CPUé˜Ÿåˆ—é•¿åº¦ã€ç¼ºé¡µç‡
    A = np.array([[1.0, 0.1, 0.0],
                  [0.0, 0.9, 0.0],
                  [0.0, 0.0, 0.95]])
    B = np.array([[0.0], [0.0], [0.0]])
    H = np.array([[1.0, 0.0, 0.0],
                  [0.0, 1.0, 0.0]])
    Q = np.eye(3) * 0.01  # è¿‡ç¨‹å™ªå£°
    R = np.eye(2) * 0.1   # è§‚æµ‹å™ªå£°
    P0 = np.eye(3) * 0.1
    x0 = np.array([0.0, 0.0, 0.0])

    return UnifiedObservationModel("os", A, B, H, Q, R, P0, x0)

# å®¹å™¨å±‚è§‚æµ‹æ¨¡å‹
def create_container_observation_model():
    """åˆ›å»ºå®¹å™¨å±‚è§‚æµ‹æ¨¡å‹"""
    # çŠ¶æ€ï¼šPodå‰¯æœ¬æ•°ã€è¯·æ±‚ç§¯å‹ã€èŠ‚ç‚¹è´Ÿè½½
    A = np.array([[1.0, 0.0, 0.0],
                  [0.0, 0.8, 0.1],
                  [0.0, 0.0, 0.9]])
    B = np.array([[1.0], [0.0], [0.0]])
    H = np.array([[1.0, 0.0, 0.0],
                  [0.0, 1.0, 0.0],
                  [0.0, 0.0, 1.0]])
    Q = np.eye(3) * 0.05
    R = np.eye(3) * 0.2
    P0 = np.eye(3) * 0.2
    x0 = np.array([1.0, 0.0, 0.0])

    return UnifiedObservationModel("container", A, B, H, Q, R, P0, x0)
```

#### Rustå®ç°

```rust
use ndarray::{Array1, Array2};
use std::sync::{Arc, Mutex};

pub struct KalmanFilter {
    A: Array2<f64>, // çŠ¶æ€è½¬ç§»çŸ©é˜µ
    B: Array2<f64>, // æ§åˆ¶è¾“å…¥çŸ©é˜µ
    H: Array2<f64>, // è§‚æµ‹çŸ©é˜µ
    Q: Array2<f64>, // è¿‡ç¨‹å™ªå£°åæ–¹å·®
    R: Array2<f64>, // è§‚æµ‹å™ªå£°åæ–¹å·®
    P: Arc<Mutex<Array2<f64>>>, // è¯¯å·®åæ–¹å·®
    x: Arc<Mutex<Array1<f64>>>, // çŠ¶æ€ä¼°è®¡
}

impl KalmanFilter {
    pub fn new(
        A: Array2<f64>,
        B: Array2<f64>,
        H: Array2<f64>,
        Q: Array2<f64>,
        R: Array2<f64>,
        P0: Array2<f64>,
        x0: Array1<f64>,
    ) -> Self {
        KalmanFilter {
            A,
            B,
            H,
            Q,
            R,
            P: Arc::new(Mutex::new(P0)),
            x: Arc::new(Mutex::new(x0)),
        }
    }

    pub fn predict(&self, u: Option<&Array1<f64>>) -> Array1<f64> {
        let mut x = self.x.lock().unwrap();
        let mut P = self.P.lock().unwrap();

        // çŠ¶æ€é¢„æµ‹ï¼šx = A*x + B*u
        let Ax = &self.A.dot(&*x);
        if let Some(u_vec) = u {
            let Bu = &self.B.dot(u_vec);
            *x = Ax + Bu;
        } else {
            *x = Ax.clone();
        }

        // è¯¯å·®åæ–¹å·®é¢„æµ‹ï¼šP = A*P*A^T + Q
        let AP = self.A.dot(&*P);
        let APAT = AP.dot(&self.A.t());
        *P = &APAT + &self.Q;

        x.clone()
    }

    pub fn update(&self, y: &Array1<f64>) -> Array1<f64> {
        let mut x = self.x.lock().unwrap();
        let mut P = self.P.lock().unwrap();

        // è®¡ç®—å¡å°”æ›¼å¢ç›Šï¼šK = P*H^T*(H*P*H^T + R)^(-1)
        let HP = self.H.dot(&*P);
        let HPHt = HP.dot(&self.H.t());
        let S = &HPHt + &self.R;

        // ç®€åŒ–ï¼šå‡è®¾Så¯é€†
        let S_inv = S.clone(); // å®é™…åº”è®¡ç®—é€†çŸ©é˜µ

        let PHT = P.dot(&self.H.t());
        let K = PHT.dot(&S_inv);

        // çŠ¶æ€æ›´æ–°ï¼šx = x + K*(y - H*x)
        let Hx = self.H.dot(&*x);
        let innovation = y - &Hx;
        let K_innovation = K.dot(&innovation);
        *x = &*x + &K_innovation;

        // è¯¯å·®åæ–¹å·®æ›´æ–°ï¼šP = (I - K*H)*P
        let I = Array2::eye(P.nrows());
        let KH = K.dot(&self.H);
        let IKH = &I - &KH;
        *P = IKH.dot(&*P);

        x.clone()
    }
}

pub struct UnifiedObservationModel {
    filter: KalmanFilter,
    layer: String,
}

impl UnifiedObservationModel {
    pub fn new(
        layer: &str,
        A: Array2<f64>,
        B: Array2<f64>,
        H: Array2<f64>,
        Q: Array2<f64>,
        R: Array2<f64>,
        P0: Array2<f64>,
        x0: Array1<f64>,
    ) -> Self {
        UnifiedObservationModel {
            filter: KalmanFilter::new(A, B, H, Q, R, P0, x0),
            layer: layer.to_string(),
        }
    }

    pub fn observe(&self, measurement: &Array1<f64>) -> Array1<f64> {
        // é¢„æµ‹
        self.filter.predict(None);

        // æ›´æ–°
        self.filter.update(measurement)
    }
}
```

**ç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„å®é™…ä»·å€¼**ï¼š

- **å™ªå£°æŠ‘åˆ¶**ï¼šå¡å°”æ›¼æ»¤æ³¢å™¨æœ‰æ•ˆæŠ‘åˆ¶è§‚æµ‹å™ªå£°
- **çŠ¶æ€é¢„æµ‹**ï¼šé¢„æµ‹ç³»ç»Ÿæœªæ¥çŠ¶æ€ï¼Œæå‰åšå‡ºå†³ç­–
- **ç²¾åº¦æå‡**ï¼šç»Ÿä¸€çš„è§‚æµ‹æ¨¡å‹æé«˜äº†çŠ¶æ€ä¼°è®¡ç²¾åº¦

### 4.1. ç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„æ”¶æ•›æ€§

**å®šç†53**ï¼ˆç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„æ”¶æ•›æ€§ï¼‰ï¼š
åœ¨æ»¡è¶³å¯è§‚æµ‹æ€§æ¡ä»¶ä¸‹ï¼Œç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„çŠ¶æ€ä¼°è®¡æ”¶æ•›åˆ°çœŸå®çŠ¶æ€ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šå¯è§‚æµ‹æ€§æ¡ä»¶

**å®šä¹‰**ï¼ˆå¯è§‚æµ‹æ€§ï¼‰ï¼š
ç³»ç»Ÿæ˜¯å¯è§‚æµ‹çš„ï¼Œå½“ä¸”ä»…å½“å¯è§‚æµ‹æ€§çŸ©é˜µ $O = [H^T, (HA)^T, \ldots, (HA^{n-1})^T]^T$ æ»¡ç§©ã€‚

#### æ­¥éª¤2ï¼šæ”¶æ•›æ€§è¯æ˜

**å¼•ç†53.1**ï¼ˆæ”¶æ•›æ€§ï¼‰ï¼š
åœ¨å¯è§‚æµ‹æ€§æ¡ä»¶ä¸‹ï¼Œå¡å°”æ›¼æ»¤æ³¢å™¨çš„çŠ¶æ€ä¼°è®¡æ”¶æ•›åˆ°çœŸå®çŠ¶æ€ã€‚

**è¯æ˜**ï¼š
ç”±å¡å°”æ›¼æ»¤æ³¢å™¨çš„æ€§è´¨ï¼Œåœ¨å¯è§‚æµ‹æ€§æ¡ä»¶ä¸‹ï¼Œè¯¯å·®åæ–¹å·®çŸ©é˜µ $P$ æ”¶æ•›åˆ°ç¨³æ€å€¼ï¼ŒçŠ¶æ€ä¼°è®¡æ”¶æ•›åˆ°çœŸå®çŠ¶æ€ã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†53.1ï¼Œç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„çŠ¶æ€ä¼°è®¡æ”¶æ•›ã€‚ âˆ

### 4.2. ç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„æœ€ä¼˜æ€§

**å®šç†54**ï¼ˆç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„æœ€ä¼˜æ€§ï¼‰ï¼š
åœ¨æœ€å°å‡æ–¹è¯¯å·®æ„ä¹‰ä¸‹ï¼Œå¡å°”æ›¼æ»¤æ³¢å™¨æ˜¯æœ€ä¼˜çš„ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šæœ€ä¼˜æ€§å®šä¹‰

**å®šä¹‰**ï¼ˆæœ€ä¼˜æ€§ï¼‰ï¼š
ä¼°è®¡å™¨æ˜¯æœ€ä¼˜çš„ï¼Œå½“ä¸”ä»…å½“åœ¨æœ€å°å‡æ–¹è¯¯å·®æ„ä¹‰ä¸‹è¾¾åˆ°æœ€ä¼˜ã€‚

#### æ­¥éª¤2ï¼šæœ€ä¼˜æ€§è¯æ˜

**å¼•ç†54.1**ï¼ˆæœ€ä¼˜æ€§ï¼‰ï¼š
å¡å°”æ›¼æ»¤æ³¢å™¨åœ¨æœ€å°å‡æ–¹è¯¯å·®æ„ä¹‰ä¸‹æ˜¯æœ€ä¼˜çš„ã€‚

**è¯æ˜**ï¼š
ç”±å¡å°”æ›¼æ»¤æ³¢å™¨çš„æ¨å¯¼ï¼Œå®ƒæœ€å°åŒ–å‡æ–¹è¯¯å·®ï¼Œå› æ­¤æ˜¯æœ€ä¼˜çš„ã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†54.1ï¼Œç»Ÿä¸€è§‚æµ‹æ¨¡å‹æ˜¯æœ€ä¼˜çš„ã€‚ âˆ

### 4.3. è§‚æµ‹æ¨¡å‹çš„é²æ£’æ€§

**å®šç†95**ï¼ˆè§‚æµ‹æ¨¡å‹çš„é²æ£’æ€§ï¼‰ï¼š
ç»Ÿä¸€è§‚æµ‹æ¨¡å‹å¯¹è§‚æµ‹å™ªå£°æ˜¯é²æ£’çš„ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šé²æ£’æ€§å®šä¹‰

**å®šä¹‰**ï¼ˆé²æ£’æ€§ï¼‰ï¼š
è§‚æµ‹æ¨¡å‹æ˜¯é²æ£’çš„ï¼Œå½“ä¸”ä»…å½“å¯¹è§‚æµ‹å™ªå£°ï¼Œä¼°è®¡è¯¯å·®æœ‰ç•Œã€‚

#### æ­¥éª¤2ï¼šé²æ£’æ€§è¯æ˜

**å¼•ç†95.1**ï¼ˆé²æ£’æ€§è¯æ˜ï¼‰ï¼š
ç»Ÿä¸€è§‚æµ‹æ¨¡å‹å¯¹è§‚æµ‹å™ªå£°æ˜¯é²æ£’çš„ã€‚

**è¯æ˜**ï¼š
ç”±å¡å°”æ›¼æ»¤æ³¢å™¨çš„æ€§è´¨ï¼Œä¼°è®¡è¯¯å·®çš„åæ–¹å·®çŸ©é˜µæœ‰ç•Œï¼Œå› æ­¤å¯¹è§‚æµ‹å™ªå£°æ˜¯é²æ£’çš„ã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†95.1ï¼Œç»Ÿä¸€è§‚æµ‹æ¨¡å‹æ˜¯é²æ£’çš„ã€‚ âˆ

### 4.4. ç»Ÿä¸€è§‚æµ‹æ¨¡å‹çš„å®é™…åº”ç”¨

#### 4.4.1. ç³»ç»ŸçŠ¶æ€ä¼°è®¡

**åœºæ™¯**ï¼šä½¿ç”¨ç»Ÿä¸€è§‚æµ‹æ¨¡å‹ä¼°è®¡ç³»ç»ŸçŠ¶æ€ã€‚

**æ–¹æ³•**ï¼š

1. å»ºç«‹è§‚æµ‹æ¨¡å‹
2. ä½¿ç”¨å¡å°”æ›¼æ»¤æ³¢å™¨ä¼°è®¡çŠ¶æ€
3. éªŒè¯ä¼°è®¡çš„å‡†ç¡®æ€§

**Golangå®ç°**ï¼š

```go
package observation

// ç³»ç»ŸçŠ¶æ€ä¼°è®¡
func EstimateSystemState(
    observations []Observation,
    model ObservationModel,
) (State, error) {
    // å»ºç«‹è§‚æµ‹æ¨¡å‹
    kalmanFilter := NewKalmanFilter(model)

    // ä½¿ç”¨å¡å°”æ›¼æ»¤æ³¢å™¨ä¼°è®¡çŠ¶æ€
    state := model.InitialState
    for _, obs := range observations {
        state = kalmanFilter.Update(state, obs)
    }

    // éªŒè¯ä¼°è®¡çš„å‡†ç¡®æ€§
    if !kalmanFilter.VerifyAccuracy(state) {
        return nil, fmt.Errorf("estimation accuracy verification failed")
    }

    return state, nil
}

// æ›´æ–°çŠ¶æ€
func (kf *KalmanFilter) Update(state State, obs Observation) State {
    // é¢„æµ‹æ­¥éª¤
    predictedState := kf.Predict(state)

    // æ›´æ–°æ­¥éª¤
    updatedState := kf.Correct(predictedState, obs)

    return updatedState
}
```

**Pythonå®ç°**ï¼š

```python
def estimate_system_state(
    observations: List[Observation],
    model: ObservationModel,
) -> State:
    """ç³»ç»ŸçŠ¶æ€ä¼°è®¡"""
    # å»ºç«‹è§‚æµ‹æ¨¡å‹
    kalman_filter = KalmanFilter(model)

    # ä½¿ç”¨å¡å°”æ›¼æ»¤æ³¢å™¨ä¼°è®¡çŠ¶æ€
    state = model.initial_state
    for obs in observations:
        state = kalman_filter.update(state, obs)

    # éªŒè¯ä¼°è®¡çš„å‡†ç¡®æ€§
    if not kalman_filter.verify_accuracy(state):
        raise ValueError("Estimation accuracy verification failed")

    return state

def update(self, state: State, obs: Observation) -> State:
    """æ›´æ–°çŠ¶æ€"""
    # é¢„æµ‹æ­¥éª¤
    predicted_state = self.predict(state)

    # æ›´æ–°æ­¥éª¤
    updated_state = self.correct(predicted_state, obs)

    return updated_state
```

**Rustå®ç°**ï¼š

```rust
pub fn estimate_system_state(
    observations: &[Observation],
    model: &ObservationModel,
) -> Result<State, Error> {
    // å»ºç«‹è§‚æµ‹æ¨¡å‹
    let mut kalman_filter = KalmanFilter::new(model)?;

    // ä½¿ç”¨å¡å°”æ›¼æ»¤æ³¢å™¨ä¼°è®¡çŠ¶æ€
    let mut state = model.initial_state.clone();
    for obs in observations {
        state = kalman_filter.update(&state, obs)?;
    }

    // éªŒè¯ä¼°è®¡çš„å‡†ç¡®æ€§
    if !kalman_filter.verify_accuracy(&state)? {
        return Err(Error::EstimationAccuracyVerificationFailed);
    }

    Ok(state)
}

impl KalmanFilter {
    pub fn update(&mut self, state: &State, obs: &Observation) -> Result<State, Error> {
        // é¢„æµ‹æ­¥éª¤
        let predicted_state = self.predict(state)?;

        // æ›´æ–°æ­¥éª¤
        let updated_state = self.correct(&predicted_state, obs)?;

        Ok(updated_state)
    }
}
```

---

## 5. ç›¸å…³æ–‡æ¡£

- [è¿”å› FormalModel ç›®å½•](../README.md)
- [07_ç›‘æ§ä¸åé¦ˆ README](README.md)
- [07.2_é…é¢ç®¡ç†æ•°å­¦æ¨¡å‹](07.2_é…é¢ç®¡ç†æ•°å­¦æ¨¡å‹.md)
- [04.2_åé¦ˆæ§åˆ¶å¾ªç¯](../04_åŠ¨æ€äº¤äº’æ¨¡å‹/04.2_åé¦ˆæ§åˆ¶å¾ªç¯.md)

---

**æœ€åæ›´æ–°**: 2025-01-27
