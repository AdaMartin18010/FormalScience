# 04.1 çŠ¶æ€è½¬ç§»ç³»ç»Ÿ

> **æ‰€å±ä¸»é¢˜**: 04_åŠ¨æ€äº¤äº’æ¨¡å‹
> **æœ€åæ›´æ–°**: 2025-01-27

## ğŸ“‹ ç›®å½•

- [04.1 çŠ¶æ€è½¬ç§»ç³»ç»Ÿ](#041-çŠ¶æ€è½¬ç§»ç³»ç»Ÿ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ç»Ÿä¸€çŠ¶æ€æœº](#1-ç»Ÿä¸€çŠ¶æ€æœº)
  - [2. çŠ¶æ€è½¬ç§»å®šä¹‰](#2-çŠ¶æ€è½¬ç§»å®šä¹‰)
  - [3. ä¸‰å±‚ç³»ç»ŸçŠ¶æ€æ˜ å°„](#3-ä¸‰å±‚ç³»ç»ŸçŠ¶æ€æ˜ å°„)
  - [4. çŠ¶æ€è½¬ç§»çš„å½¢å¼åŒ–æ€§è´¨](#4-çŠ¶æ€è½¬ç§»çš„å½¢å¼åŒ–æ€§è´¨)
    - [4.1 é©¬å°”å¯å¤«æ€§è´¨çš„è¯æ˜](#41-é©¬å°”å¯å¤«æ€§è´¨çš„è¯æ˜)
      - [æ­¥éª¤1ï¼šçŠ¶æ€è½¬ç§»çš„å®šä¹‰](#æ­¥éª¤1çŠ¶æ€è½¬ç§»çš„å®šä¹‰)
      - [æ­¥éª¤2ï¼šé©¬å°”å¯å¤«æ€§è´¨çš„å½¢å¼åŒ–](#æ­¥éª¤2é©¬å°”å¯å¤«æ€§è´¨çš„å½¢å¼åŒ–)
      - [æ­¥éª¤3ï¼šå†å²æ— å…³æ€§](#æ­¥éª¤3å†å²æ— å…³æ€§)
      - [æ­¥éª¤4ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤4ä¸»å®šç†è¯æ˜)
    - [4.2 çŠ¶æ€è½¬ç§»çš„æ€§è´¨è¯æ˜](#42-çŠ¶æ€è½¬ç§»çš„æ€§è´¨è¯æ˜)
    - [4.3 çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å…¶ä»–æ€§è´¨](#43-çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å…¶ä»–æ€§è´¨)
  - [5. çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®é™…åº”ç”¨](#5-çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®é™…åº”ç”¨)
    - [5.1 çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„åŒæ„æ€§](#51-çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„åŒæ„æ€§)
      - [æ­¥éª¤1ï¼šçŠ¶æ€ç©ºé—´åŒæ„](#æ­¥éª¤1çŠ¶æ€ç©ºé—´åŒæ„)
      - [æ­¥éª¤2ï¼šè½¬ç§»å‡½æ•°åŒæ„](#æ­¥éª¤2è½¬ç§»å‡½æ•°åŒæ„)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜)
    - [5.2 çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å¯è¾¾æ€§åˆ†æ](#52-çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å¯è¾¾æ€§åˆ†æ)
      - [æ­¥éª¤1ï¼šå¯è¾¾æ€§å®šä¹‰](#æ­¥éª¤1å¯è¾¾æ€§å®šä¹‰)
      - [æ­¥éª¤2ï¼šå¯è¾¾æ€§è¯æ˜](#æ­¥éª¤2å¯è¾¾æ€§è¯æ˜)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜-1)
    - [5.3 çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®‰å…¨æ€§](#53-çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®‰å…¨æ€§)
      - [æ­¥éª¤1ï¼šå®‰å…¨æ€§å®šä¹‰](#æ­¥éª¤1å®‰å…¨æ€§å®šä¹‰)
      - [æ­¥éª¤2ï¼šä¸å˜å¼è¯æ˜](#æ­¥éª¤2ä¸å˜å¼è¯æ˜)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜-2)
    - [5.4 çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®é™…åº”ç”¨](#54-çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®é™…åº”ç”¨)
      - [5.4.1 æ­»é”æ£€æµ‹](#541-æ­»é”æ£€æµ‹)
    - [6.1 çŠ¶æ€è½¬ç§»çš„å¯è¾¾æ€§](#61-çŠ¶æ€è½¬ç§»çš„å¯è¾¾æ€§)
      - [æ­¥éª¤1ï¼šå¯è¾¾æ€§å®šä¹‰](#æ­¥éª¤1å¯è¾¾æ€§å®šä¹‰-1)
      - [æ­¥éª¤2ï¼šå¯è¾¾é›†æ„é€ ](#æ­¥éª¤2å¯è¾¾é›†æ„é€ )
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜-3)
    - [6.2 çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®é™…åº”ç”¨](#62-çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®é™…åº”ç”¨)
      - [6.2.1 æ­»é”æ£€æµ‹](#621-æ­»é”æ£€æµ‹)
  - [6. ç›¸å…³æ–‡æ¡£](#6-ç›¸å…³æ–‡æ¡£)

---

## 1. ç»Ÿä¸€çŠ¶æ€æœº

```python
# ç»Ÿä¸€çŠ¶æ€æœº
class UnifiedStateMachine:
    def __init__(self):
        self.states = {INIT, PENDING, RUNNING, SUSPENDED, TERMINATED}
        self.transitions = {
            (INIT, PENDING):   "create_entity",
            (PENDING, RUNNING): "scheduler_activate",
            (RUNNING, SUSPENDED): "preempt_or_migrate",
            (ANY, TERMINATED):  "release_resources"
        }

    def step(self, event):
        # é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹
        # P(s'|s, a) = transition_prob(state, action)
        return self.policy.select_action(self.current_state)
```

---

## 2. çŠ¶æ€è½¬ç§»å®šä¹‰

**çŠ¶æ€é›†åˆ**ï¼š

- `INIT`: åˆå§‹çŠ¶æ€
- `PENDING`: ç­‰å¾…çŠ¶æ€
- `RUNNING`: è¿è¡ŒçŠ¶æ€
- `SUSPENDED`: æŒ‚èµ·çŠ¶æ€
- `TERMINATED`: ç»ˆæ­¢çŠ¶æ€

**è½¬ç§»æ“ä½œ**ï¼š

- `create_entity`: åˆ›å»ºå®ä½“ (INIT â†’ PENDING)
- `scheduler_activate`: è°ƒåº¦å™¨æ¿€æ´» (PENDING â†’ RUNNING)
- `preempt_or_migrate`: æŠ¢å æˆ–è¿ç§» (RUNNING â†’ SUSPENDED)
- `release_resources`: é‡Šæ”¾èµ„æº (ANY â†’ TERMINATED)

---

## 3. ä¸‰å±‚ç³»ç»ŸçŠ¶æ€æ˜ å°„

| çŠ¶æ€ | OSå±‚ | VMå±‚ | å®¹å™¨å±‚ |
|------|------|------|--------|
| INIT | è¿›ç¨‹åˆ›å»ºå‰ | VMå®šä¹‰ | Podå®šä¹‰ |
| PENDING | TASK_INTERRUPTIBLE | VMå…³æœº | Pod Pending |
| RUNNING | TASK_RUNNING | VMè¿è¡Œ | Pod Running |
| SUSPENDED | TASK_STOPPED | VMæš‚åœ | Pod Suspended |
| TERMINATED | è¿›ç¨‹é€€å‡º | VMåˆ é™¤ | Pod Terminated |

---

## 4. çŠ¶æ€è½¬ç§»çš„å½¢å¼åŒ–æ€§è´¨

**å®šä¹‰**ï¼ˆçŠ¶æ€è½¬ç§»ç³»ç»Ÿï¼‰ï¼š
çŠ¶æ€è½¬ç§»ç³»ç»Ÿæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $(S, \Sigma, \delta, s_0, F)$ï¼Œå…¶ä¸­ï¼š

- $S$: çŠ¶æ€é›†åˆ
- $\Sigma$: äº‹ä»¶/åŠ¨ä½œé›†åˆ
- $\delta: S \times \Sigma \to S$: è½¬ç§»å‡½æ•°
- $s_0 \in S$: åˆå§‹çŠ¶æ€
- $F \subseteq S$: ç»ˆæ­¢çŠ¶æ€é›†åˆ

**æ€§è´¨**ï¼š

1. **ç¡®å®šæ€§**ï¼šå¯¹ä»»æ„çŠ¶æ€ $s$ å’Œäº‹ä»¶ $a$ï¼Œè½¬ç§»å‡½æ•° $\delta(s, a)$ æ˜¯ç¡®å®šçš„
2. **å¯è¾¾æ€§**ï¼šä»åˆå§‹çŠ¶æ€ $s_0$ å¯ä»¥åˆ°è¾¾æ‰€æœ‰çŠ¶æ€
3. **å®‰å…¨æ€§**ï¼šç³»ç»Ÿä¸ä¼šè¿›å…¥æ­»é”çŠ¶æ€
4. **æ´»æ€§**ï¼šç³»ç»Ÿæœ€ç»ˆä¼šåˆ°è¾¾ç»ˆæ­¢çŠ¶æ€

**é©¬å°”å¯å¤«æ€§è´¨**ï¼š
çŠ¶æ€è½¬ç§»æ»¡è¶³é©¬å°”å¯å¤«æ€§è´¨ï¼Œå³ï¼š

$$
P(s_{t+1} | s_t, a_t, s_{t-1}, a_{t-1}, \ldots) = P(s_{t+1} | s_t, a_t)
$$

æœªæ¥çŠ¶æ€åªä¾èµ–äºå½“å‰çŠ¶æ€å’ŒåŠ¨ä½œï¼Œä¸å†å²æ— å…³ã€‚

### 4.1 é©¬å°”å¯å¤«æ€§è´¨çš„è¯æ˜

**å®šç†10**ï¼ˆçŠ¶æ€è½¬ç§»çš„é©¬å°”å¯å¤«æ€§è´¨ï¼‰ï¼š
åœ¨ç»Ÿä¸€çŠ¶æ€æœºä¸­ï¼ŒçŠ¶æ€è½¬ç§»æ»¡è¶³é©¬å°”å¯å¤«æ€§è´¨ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šçŠ¶æ€è½¬ç§»çš„å®šä¹‰

**å®šä¹‰**ï¼ˆçŠ¶æ€è½¬ç§»ï¼‰ï¼š
çŠ¶æ€è½¬ç§»å‡½æ•° $\delta: S \times \Sigma \to S$ å®šä¹‰äº†ä»çŠ¶æ€ $s$ åœ¨äº‹ä»¶ $a$ ä¸‹è½¬ç§»åˆ°çŠ¶æ€ $s'$ çš„æ˜ å°„ã€‚

#### æ­¥éª¤2ï¼šé©¬å°”å¯å¤«æ€§è´¨çš„å½¢å¼åŒ–

**å¼•ç†10.1**ï¼ˆçŠ¶æ€è½¬ç§»çš„ç¡®å®šæ€§ï¼‰ï¼š
å¯¹äºç¡®å®šæ€§çŠ¶æ€æœºï¼ŒçŠ¶æ€è½¬ç§»æ˜¯ç¡®å®šçš„ï¼Œå³ï¼š

$$
P(s_{t+1} = s' | s_t = s, a_t = a) = \begin{cases}
1 & \text{è‹¥ } \delta(s, a) = s' \\
0 & \text{å¦åˆ™}
\end{cases}
$$

**è¯æ˜**ï¼š
ç”±çŠ¶æ€è½¬ç§»å‡½æ•°çš„å®šä¹‰ï¼Œå¯¹äºç»™å®šçš„çŠ¶æ€ $s$ å’Œäº‹ä»¶ $a$ï¼Œä¸‹ä¸€ä¸ªçŠ¶æ€ $s' = \delta(s, a)$ æ˜¯å”¯ä¸€ç¡®å®šçš„ã€‚å› æ­¤è½¬ç§»æ¦‚ç‡æ˜¯ç¡®å®šçš„ã€‚ âˆ

#### æ­¥éª¤3ï¼šå†å²æ— å…³æ€§

**å¼•ç†10.2**ï¼ˆå†å²æ— å…³æ€§ï¼‰ï¼š
çŠ¶æ€è½¬ç§»ä¸ä¾èµ–äºå†å²çŠ¶æ€å’Œäº‹ä»¶ã€‚

**è¯æ˜**ï¼š
ç”±çŠ¶æ€è½¬ç§»å‡½æ•°çš„å®šä¹‰ï¼Œ$\delta(s, a)$ åªä¾èµ–äºå½“å‰çŠ¶æ€ $s$ å’Œå½“å‰äº‹ä»¶ $a$ï¼Œä¸ä¾èµ–äºå†å²çŠ¶æ€ $s_{t-1}, s_{t-2}, \ldots$ å’Œå†å²äº‹ä»¶ $a_{t-1}, a_{t-2}, \ldots$ã€‚

å› æ­¤ï¼š

$$
P(s_{t+1} | s_t, a_t, s_{t-1}, a_{t-1}, \ldots) = P(s_{t+1} | s_t, a_t)
$$

âˆ

#### æ­¥éª¤4ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†10.1å’Œ10.2ï¼ŒçŠ¶æ€è½¬ç§»æ»¡è¶³é©¬å°”å¯å¤«æ€§è´¨ã€‚ âˆ

### 4.2 çŠ¶æ€è½¬ç§»çš„æ€§è´¨è¯æ˜

**å®šç†10.1**ï¼ˆå¯è¾¾æ€§ï¼‰ï¼š
ä»åˆå§‹çŠ¶æ€ $s_0$ å¯ä»¥åˆ°è¾¾æ‰€æœ‰çŠ¶æ€ã€‚

**è¯æ˜**ï¼š
ç”±çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®šä¹‰ï¼Œæ‰€æœ‰çŠ¶æ€éƒ½æ˜¯å¯è¾¾çš„ã€‚ä½¿ç”¨BFSæˆ–DFSå¯ä»¥éªŒè¯å¯è¾¾æ€§ã€‚ âˆ

**å®šç†10.2**ï¼ˆå®‰å…¨æ€§ï¼‰ï¼š
ç³»ç»Ÿä¸ä¼šè¿›å…¥æ­»é”çŠ¶æ€ã€‚

**è¯æ˜**ï¼š
æ­»é”çŠ¶æ€æ˜¯æŒ‡æ— æ³•è½¬ç§»åˆ°å…¶ä»–çŠ¶æ€çš„çŠ¶æ€ã€‚ç”±çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®šä¹‰ï¼Œæ¯ä¸ªéç»ˆæ­¢çŠ¶æ€éƒ½æœ‰è‡³å°‘ä¸€ä¸ªå‡ºè¾¹ï¼Œå› æ­¤ä¸ä¼šæ­»é”ã€‚ âˆ

**å®šç†10.3**ï¼ˆæ´»æ€§ï¼‰ï¼š
ç³»ç»Ÿæœ€ç»ˆä¼šåˆ°è¾¾ç»ˆæ­¢çŠ¶æ€ã€‚

**è¯æ˜**ï¼š
ç”±çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®šä¹‰ï¼Œå­˜åœ¨ä»ä»»æ„çŠ¶æ€åˆ°ç»ˆæ­¢çŠ¶æ€çš„è·¯å¾„ã€‚ç”±äºçŠ¶æ€ç©ºé—´æœ‰é™ï¼Œç³»ç»Ÿæœ€ç»ˆä¼šåˆ°è¾¾ç»ˆæ­¢çŠ¶æ€ã€‚ âˆ

### 4.3 çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å…¶ä»–æ€§è´¨

**å®šç†10.4**ï¼ˆçŠ¶æ€è½¬ç§»çš„ç¡®å®šæ€§ï¼‰ï¼š
å¯¹äºç¡®å®šæ€§çŠ¶æ€æœºï¼ŒçŠ¶æ€è½¬ç§»æ˜¯ç¡®å®šçš„ã€‚

**è¯æ˜**ï¼š
ç”±çŠ¶æ€è½¬ç§»å‡½æ•°çš„å®šä¹‰ï¼Œå¯¹äºç»™å®šçš„çŠ¶æ€ $s$ å’Œäº‹ä»¶ $a$ï¼Œä¸‹ä¸€ä¸ªçŠ¶æ€ $s' = \delta(s, a)$ æ˜¯å”¯ä¸€ç¡®å®šçš„ã€‚ âˆ

**å®šç†10.5**ï¼ˆçŠ¶æ€è½¬ç§»çš„å¯é€†æ€§ï¼‰ï¼š
è‹¥çŠ¶æ€è½¬ç§»ç³»ç»Ÿæ˜¯å¯é€†çš„ï¼Œåˆ™å­˜åœ¨é€†è½¬ç§»å‡½æ•° $\delta^{-1}$ã€‚

**è¯æ˜**ï¼š
è‹¥å¯¹äºä»»æ„çŠ¶æ€ $s$ å’Œäº‹ä»¶ $a$ï¼Œå­˜åœ¨å”¯ä¸€çš„çŠ¶æ€ $s'$ ä½¿å¾— $\delta(s', a) = s$ï¼Œåˆ™ç³»ç»Ÿæ˜¯å¯é€†çš„ï¼Œä¸” $\delta^{-1}(s, a) = s'$ã€‚ âˆ

**å®šç†10.6**ï¼ˆçŠ¶æ€è½¬ç§»çš„ç­‰ä»·æ€§ï¼‰ï¼š
ä¸¤ä¸ªçŠ¶æ€è½¬ç§»ç³»ç»Ÿç­‰ä»·ï¼Œå½“ä¸”ä»…å½“å®ƒä»¬çš„çŠ¶æ€å›¾åŒæ„ã€‚

**è¯æ˜**ï¼š
çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„ç­‰ä»·æ€§ç”±çŠ¶æ€å›¾çš„ç»“æ„å†³å®šã€‚è‹¥ä¸¤ä¸ªç³»ç»Ÿçš„çŠ¶æ€å›¾åŒæ„ï¼Œåˆ™å®ƒä»¬çš„è¡Œä¸ºç­‰ä»·ã€‚ âˆ

**çŠ¶æ€è½¬ç§»çš„å®é™…åº”ç”¨**ï¼š

| åº”ç”¨åœºæ™¯ | çŠ¶æ€è½¬ç§» | è§¦å‘æ¡ä»¶ | ç³»ç»Ÿå®ç° |
|---------|---------|---------|---------|
| è¿›ç¨‹è°ƒåº¦ | PENDINGâ†’RUNNING | è°ƒåº¦å™¨é€‰æ‹© | Linux CFS |
| VMè¿ç§» | RUNNINGâ†’SUSPENDED | vMotionè§¦å‘ | vSphere DRS |
| Podè°ƒåº¦ | PENDINGâ†’RUNNING | kube-scheduler | Kubernetes |
| å®¹å™¨é‡å¯ | TERMINATEDâ†’INIT | é‡å¯ç­–ç•¥ | Docker/K8s |

**çŠ¶æ€æœºéªŒè¯**ï¼š

- ä½¿ç”¨å½¢å¼åŒ–æ–¹æ³•éªŒè¯çŠ¶æ€è½¬ç§»çš„æ­£ç¡®æ€§
- æ£€æµ‹æ­»é”å’Œæ´»é”
- ä¿è¯ç³»ç»Ÿå®‰å…¨æ€§

---

## 5. çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®é™…åº”ç”¨

**ç³»ç»Ÿè®¾è®¡**ï¼š

- ä½¿ç”¨ç»Ÿä¸€çŠ¶æ€æœºè®¾è®¡å®ä½“ç”Ÿå‘½å‘¨æœŸ
- ä¿è¯çŠ¶æ€è½¬ç§»çš„ä¸€è‡´æ€§
- ç®€åŒ–ç³»ç»Ÿå®ç°å’Œç»´æŠ¤

**æ•…éšœè¯Šæ–­**ï¼š

- é€šè¿‡çŠ¶æ€è½¬ç§»è¿½è¸ªç³»ç»Ÿè¡Œä¸º
- è¯†åˆ«å¼‚å¸¸çŠ¶æ€è½¬ç§»
- å¿«é€Ÿå®šä½é—®é¢˜æ ¹æº

**æ€§èƒ½ä¼˜åŒ–**ï¼š

- ä¼˜åŒ–çŠ¶æ€è½¬ç§»è·¯å¾„
- å‡å°‘çŠ¶æ€è½¬ç§»å¼€é”€
- æé«˜ç³»ç»Ÿå“åº”é€Ÿåº¦

**å·¥ç¨‹å®ç°ç¤ºä¾‹**ï¼š

```python
# çŠ¶æ€è½¬ç§»ç³»ç»Ÿå®ç°
class StateTransitionSystem:
    def __init__(self, states, transitions, initial_state, final_states):
        self.states = states  # çŠ¶æ€é›†åˆ S
        self.transitions = transitions  # è½¬ç§»å‡½æ•° Î´
        self.current_state = initial_state  # åˆå§‹çŠ¶æ€ s0
        self.final_states = final_states  # ç»ˆæ­¢çŠ¶æ€é›†åˆ F

    def transition(self, event):
        """æ‰§è¡ŒçŠ¶æ€è½¬ç§»"""
        if (self.current_state, event) in self.transitions:
            next_state = self.transitions[(self.current_state, event)]
            self.current_state = next_state
            return next_state
        else:
            raise ValueError(f"Invalid transition: {self.current_state} --{event}--> ?")

    def is_reachable(self, target_state):
        """æ£€æŸ¥çŠ¶æ€æ˜¯å¦å¯è¾¾"""
        # ä½¿ç”¨BFSæ£€æŸ¥å¯è¾¾æ€§
        visited = set()
        queue = [self.current_state]
        while queue:
            state = queue.pop(0)
            if state == target_state:
                return True
            if state not in visited:
                visited.add(state)
                for (s, e), next_s in self.transitions.items():
                    if s == state and next_s not in visited:
                        queue.append(next_s)
        return False

    def detect_deadlock(self):
        """æ£€æµ‹æ­»é”çŠ¶æ€"""
        # æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ— æ³•åˆ°è¾¾ç»ˆæ­¢çŠ¶æ€çš„å¾ªç¯
        for state in self.states:
            if state not in self.final_states:
                if not self.is_reachable(self.final_states[0]):
                    return True, state
        return False, None
```

**çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®é™…ä»·å€¼**ï¼š

- **ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šç»Ÿä¸€çš„çŠ¶æ€æœºæ¨¡å‹ç®€åŒ–äº†å®ä½“ç”Ÿå‘½å‘¨æœŸç®¡ç†
- **æ•…éšœè¯Šæ–­**ï¼šçŠ¶æ€è½¬ç§»è¿½è¸ªä¾¿äºå¿«é€Ÿå®šä½é—®é¢˜
- **ç³»ç»ŸéªŒè¯**ï¼šå½¢å¼åŒ–çŠ¶æ€æœºä¾¿äºéªŒè¯ç³»ç»Ÿæ­£ç¡®æ€§

### 5.1 çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„åŒæ„æ€§

**å®šç†45**ï¼ˆçŠ¶æ€è½¬ç§»ç³»ç»ŸåŒæ„æ€§ï¼‰ï¼š
ä¸‰å±‚ç³»ç»Ÿçš„çŠ¶æ€è½¬ç§»ç³»ç»Ÿåœ¨æ•°å­¦ä¸ŠåŒæ„ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šçŠ¶æ€ç©ºé—´åŒæ„

**å¼•ç†45.1**ï¼ˆçŠ¶æ€ç©ºé—´åŒæ„ï¼‰ï¼š
ä¸‰å±‚ç³»ç»Ÿçš„çŠ¶æ€ç©ºé—´åŒæ„ã€‚

**è¯æ˜**ï¼š
ä¸‰å±‚ç³»ç»Ÿçš„çŠ¶æ€ç©ºé—´éƒ½åŒ…å«ç›¸åŒçš„çŠ¶æ€ç±»å‹ï¼ˆINIT, PENDING, RUNNING, SUSPENDED, TERMINATEDï¼‰ï¼Œå› æ­¤åŒæ„ã€‚ âˆ

#### æ­¥éª¤2ï¼šè½¬ç§»å‡½æ•°åŒæ„

**å¼•ç†45.2**ï¼ˆè½¬ç§»å‡½æ•°åŒæ„ï¼‰ï¼š
ä¸‰å±‚ç³»ç»Ÿçš„è½¬ç§»å‡½æ•°åŒæ„ã€‚

**è¯æ˜**ï¼š
ä¸‰å±‚ç³»ç»Ÿçš„è½¬ç§»å‡½æ•°éƒ½å®šä¹‰äº†ç›¸åŒçš„è½¬ç§»æ“ä½œï¼Œå› æ­¤åŒæ„ã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†45.1å’Œ45.2ï¼ŒçŠ¶æ€è½¬ç§»ç³»ç»ŸåŒæ„ã€‚ âˆ

### 5.2 çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å¯è¾¾æ€§åˆ†æ

**å®šç†46**ï¼ˆçŠ¶æ€å¯è¾¾æ€§ï¼‰ï¼š
åœ¨çŠ¶æ€è½¬ç§»ç³»ç»Ÿä¸­ï¼Œä»åˆå§‹çŠ¶æ€ $s_0$ å¯ä»¥åˆ°è¾¾æ‰€æœ‰çŠ¶æ€ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šå¯è¾¾æ€§å®šä¹‰

**å®šä¹‰**ï¼ˆå¯è¾¾æ€§ï¼‰ï¼š
çŠ¶æ€ $s'$ ä»çŠ¶æ€ $s$ å¯è¾¾ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨çŠ¶æ€åºåˆ— $s_0 = s, s_1, \ldots, s_n = s'$ å’Œäº‹ä»¶åºåˆ— $e_1, \ldots, e_n$ï¼Œä½¿å¾— $\delta(s_{i-1}, e_i) = s_i$ã€‚

#### æ­¥éª¤2ï¼šå¯è¾¾æ€§è¯æ˜

**å¼•ç†46.1**ï¼ˆå¯è¾¾æ€§ï¼‰ï¼š
ä»åˆå§‹çŠ¶æ€ $s_0$ å¯ä»¥åˆ°è¾¾æ‰€æœ‰çŠ¶æ€ã€‚

**è¯æ˜**ï¼š
ç”±çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®šä¹‰ï¼Œæ‰€æœ‰çŠ¶æ€éƒ½æ˜¯å¯è¾¾çš„ã€‚ä½¿ç”¨BFSæˆ–DFSå¯ä»¥éªŒè¯å¯è¾¾æ€§ã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†46.1ï¼ŒçŠ¶æ€å¯è¾¾æ€§å®šç†æˆç«‹ã€‚ âˆ

### 5.3 çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®‰å…¨æ€§

**å®šç†60**ï¼ˆçŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®‰å…¨æ€§ï¼‰ï¼š
çŠ¶æ€è½¬ç§»ç³»ç»Ÿæ»¡è¶³å®‰å…¨æ€§æ€§è´¨ï¼Œå³ä¸ä¼šè¿›å…¥ä¸å®‰å…¨çŠ¶æ€ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šå®‰å…¨æ€§å®šä¹‰

**å®šä¹‰**ï¼ˆå®‰å…¨æ€§ï¼‰ï¼š
çŠ¶æ€è½¬ç§»ç³»ç»Ÿæ˜¯å®‰å…¨çš„ï¼Œå½“ä¸”ä»…å½“ä»åˆå§‹çŠ¶æ€ $s_0$ å¯è¾¾çš„æ‰€æœ‰çŠ¶æ€éƒ½åœ¨å®‰å…¨é›†åˆ $S_{\text{safe}}$ ä¸­ã€‚

#### æ­¥éª¤2ï¼šä¸å˜å¼è¯æ˜

**å¼•ç†60.1**ï¼ˆä¸å˜å¼ï¼‰ï¼š
å­˜åœ¨ä¸å˜å¼ $I(s)$ï¼Œä½¿å¾—å¯¹æ‰€æœ‰å¯è¾¾çŠ¶æ€ $s$ï¼Œ$I(s)$ æˆç«‹ã€‚

**è¯æ˜**ï¼š
ä¸å˜å¼ $I(s)$ å®šä¹‰ä¸ºï¼š$s \in S_{\text{safe}}$ã€‚ç”±çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„æ„é€ ï¼Œæ‰€æœ‰è½¬ç§»éƒ½ä¿æŒè¯¥ä¸å˜å¼ã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†60.1ï¼Œç³»ç»Ÿæ»¡è¶³å®‰å…¨æ€§æ€§è´¨ã€‚ âˆ

### 5.4 çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®é™…åº”ç”¨

#### 5.4.1 æ­»é”æ£€æµ‹

**åœºæ™¯**ï¼šæ£€æµ‹è°ƒåº¦ç³»ç»Ÿä¸­çš„æ­»é”çŠ¶æ€ã€‚

**æ–¹æ³•**ï¼š

1. å°†ç³»ç»Ÿå»ºæ¨¡ä¸ºçŠ¶æ€è½¬ç§»ç³»ç»Ÿ
2. æ£€æŸ¥æ˜¯å¦å­˜åœ¨æ— æ³•è½¬ç§»çš„çŠ¶æ€
3. ä½¿ç”¨å¯è¾¾æ€§åˆ†ææ‰¾åˆ°æ­»é”çŠ¶æ€

**Golangå®ç°**ï¼š

```go
package statetransition

// æ£€æµ‹æ­»é”
func DetectDeadlock(system *StateTransitionSystem) []State {
    deadlockStates := []State{}

    // éå†æ‰€æœ‰çŠ¶æ€
    for _, state := range system.States {
        // æ£€æŸ¥æ˜¯å¦æœ‰å‡ºè¾¹
        if len(system.Transitions[state]) == 0 {
            // æ£€æŸ¥æ˜¯å¦å¯è¾¾
            if IsReachable(system, system.InitialState, state) {
                deadlockStates = append(deadlockStates, state)
            }
        }
    }

    return deadlockStates
}

// æ£€æŸ¥å¯è¾¾æ€§
func IsReachable(system *StateTransitionSystem, from, to State) bool {
    visited := make(map[State]bool)
    queue := []State{from}

    for len(queue) > 0 {
        current := queue[0]
        queue = queue[1:]

        if current == to {
            return true
        }

        if visited[current] {
            continue
        }
        visited[current] = true

        // æ·»åŠ æ‰€æœ‰å¯è¾¾çŠ¶æ€
        for _, next := range system.Transitions[current] {
            queue = append(queue, next)
        }
    }

    return false
}
```

**Pythonå®ç°**ï¼š

```python
from collections import deque
from typing import List, Set, Dict

def detect_deadlock(system: StateTransitionSystem) -> List[State]:
    """æ£€æµ‹æ­»é”"""
    deadlock_states = []

    # éå†æ‰€æœ‰çŠ¶æ€
    for state in system.states:
        # æ£€æŸ¥æ˜¯å¦æœ‰å‡ºè¾¹
        if len(system.transitions.get(state, [])) == 0:
            # æ£€æŸ¥æ˜¯å¦å¯è¾¾
            if is_reachable(system, system.initial_state, state):
                deadlock_states.append(state)

    return deadlock_states

def is_reachable(
    system: StateTransitionSystem,
    from_state: State,
    to_state: State
) -> bool:
    """æ£€æŸ¥å¯è¾¾æ€§ï¼ˆBFSï¼‰"""
    visited: Set[State] = set()
    queue = deque([from_state])

    while queue:
        current = queue.popleft()

        if current == to_state:
            return True

        if current in visited:
            continue
        visited.add(current)

        # æ·»åŠ æ‰€æœ‰å¯è¾¾çŠ¶æ€
        for next_state in system.transitions.get(current, []):
            queue.append(next_state)

    return False
```

**Rustå®ç°**ï¼š

```rust
use std::collections::{HashMap, HashSet, VecDeque};

pub fn detect_deadlock(system: &StateTransitionSystem) -> Vec<State> {
    let mut deadlock_states = Vec::new();

    // éå†æ‰€æœ‰çŠ¶æ€
    for state in &system.states {
        // æ£€æŸ¥æ˜¯å¦æœ‰å‡ºè¾¹
        if system.transitions.get(state).map_or(0, |v| v.len()) == 0 {
            // æ£€æŸ¥æ˜¯å¦å¯è¾¾
            if is_reachable(system, &system.initial_state, state) {
                deadlock_states.push(state.clone());
            }
        }
    }

    deadlock_states
}

fn is_reachable(
    system: &StateTransitionSystem,
    from: &State,
    to: &State,
) -> bool {
    let mut visited = HashSet::new();
    let mut queue = VecDeque::new();
    queue.push_back(from.clone());

    while let Some(current) = queue.pop_front() {
        if current == *to {
            return true;
        }

        if visited.contains(&current) {
            continue;
        }
        visited.insert(current.clone());

        // æ·»åŠ æ‰€æœ‰å¯è¾¾çŠ¶æ€
        if let Some(next_states) = system.transitions.get(&current) {
            for next_state in next_states {
                queue.push_back(next_state.clone());
            }
        }
    }

    false
}
```

### 6.1 çŠ¶æ€è½¬ç§»çš„å¯è¾¾æ€§

**å®šç†89**ï¼ˆçŠ¶æ€è½¬ç§»çš„å¯è¾¾æ€§ï¼‰ï¼š
åœ¨çŠ¶æ€è½¬ç§»ç³»ç»Ÿä¸­ï¼Œä»åˆå§‹çŠ¶æ€å¯è¾¾çš„æ‰€æœ‰çŠ¶æ€æ„æˆå¯è¾¾é›†ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šå¯è¾¾æ€§å®šä¹‰

**å®šä¹‰**ï¼ˆå¯è¾¾æ€§ï¼‰ï¼š
çŠ¶æ€ $s'$ ä»çŠ¶æ€ $s$ å¯è¾¾ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨çŠ¶æ€åºåˆ— $s_0, s_1, \ldots, s_n$ï¼Œä½¿å¾— $s_0 = s$ï¼Œ$s_n = s'$ï¼Œä¸”å¯¹ $i = 0, 1, \ldots, n-1$ï¼Œæœ‰ $(s_i, s_{i+1}) \in T$ã€‚

#### æ­¥éª¤2ï¼šå¯è¾¾é›†æ„é€ 

**å¼•ç†89.1**ï¼ˆå¯è¾¾é›†æ„é€ ï¼‰ï¼š
å¯è¾¾é›†æ˜¯çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å­é›†ï¼Œä¸”æ˜¯ä¼ é€’é—­åŒ…ã€‚

**è¯æ˜**ï¼š
ç”±å¯è¾¾æ€§çš„å®šä¹‰ï¼Œå¯è¾¾é›†æ˜¯ä¼ é€’é—­åŒ…ï¼Œå³æ‰€æœ‰ä»åˆå§‹çŠ¶æ€å¯è¾¾çš„çŠ¶æ€çš„é›†åˆã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†89.1ï¼Œå¯è¾¾é›†æ˜¯ä¼ é€’é—­åŒ…ã€‚ âˆ

### 6.2 çŠ¶æ€è½¬ç§»ç³»ç»Ÿçš„å®é™…åº”ç”¨

#### 6.2.1 æ­»é”æ£€æµ‹

**åœºæ™¯**ï¼šä½¿ç”¨çŠ¶æ€è½¬ç§»ç³»ç»Ÿæ£€æµ‹æ­»é”ã€‚

**æ–¹æ³•**ï¼š

1. å»ºç«‹çŠ¶æ€è½¬ç§»å›¾
2. æ£€æµ‹ä¸å¯è¾¾çŠ¶æ€
3. è¯†åˆ«æ­»é”çŠ¶æ€

**Golangå®ç°**ï¼š

```go
package statetransition

// æ­»é”æ£€æµ‹
func DetectDeadlock(
    system StateTransitionSystem,
) ([]State, error) {
    // å»ºç«‹çŠ¶æ€è½¬ç§»å›¾
    graph := buildStateGraph(system)

    // æ£€æµ‹ä¸å¯è¾¾çŠ¶æ€
    unreachableStates := findUnreachableStates(graph, system.InitialState)

    // è¯†åˆ«æ­»é”çŠ¶æ€
    deadlockStates := []State{}
    for _, state := range unreachableStates {
        if isDeadlockState(state, system) {
            deadlockStates = append(deadlockStates, state)
        }
    }

    return deadlockStates, nil
}

// æ£€æµ‹æ­»é”çŠ¶æ€
func isDeadlockState(state State, system StateTransitionSystem) bool {
    // æ­»é”çŠ¶æ€ï¼šæ²¡æœ‰å‡ºè¾¹ä¸”ä¸æ˜¯ç»ˆæ­¢çŠ¶æ€
    transitions := system.Transitions[state]
    return len(transitions) == 0 && !system.IsTerminalState(state)
}
```

**Pythonå®ç°**ï¼š

```python
def detect_deadlock(
    system: StateTransitionSystem,
) -> List[State]:
    """æ­»é”æ£€æµ‹"""
    # å»ºç«‹çŠ¶æ€è½¬ç§»å›¾
    graph = build_state_graph(system)

    # æ£€æµ‹ä¸å¯è¾¾çŠ¶æ€
    unreachable_states = find_unreachable_states(
        graph, system.initial_state
    )

    # è¯†åˆ«æ­»é”çŠ¶æ€
    deadlock_states = []
    for state in unreachable_states:
        if is_deadlock_state(state, system):
            deadlock_states.append(state)

    return deadlock_states

def is_deadlock_state(
    state: State,
    system: StateTransitionSystem,
) -> bool:
    """æ£€æµ‹æ­»é”çŠ¶æ€"""
    # æ­»é”çŠ¶æ€ï¼šæ²¡æœ‰å‡ºè¾¹ä¸”ä¸æ˜¯ç»ˆæ­¢çŠ¶æ€
    transitions = system.transitions.get(state, [])
    return len(transitions) == 0 and not system.is_terminal_state(state)
```

**Rustå®ç°**ï¼š

```rust
pub fn detect_deadlock(
    system: &StateTransitionSystem,
) -> Result<Vec<State>, Error> {
    // å»ºç«‹çŠ¶æ€è½¬ç§»å›¾
    let graph = build_state_graph(system)?;

    // æ£€æµ‹ä¸å¯è¾¾çŠ¶æ€
    let unreachable_states = find_unreachable_states(
        &graph, &system.initial_state
    )?;

    // è¯†åˆ«æ­»é”çŠ¶æ€
    let mut deadlock_states = Vec::new();
    for state in unreachable_states {
        if is_deadlock_state(&state, system)? {
            deadlock_states.push(state);
        }
    }

    Ok(deadlock_states)
}

fn is_deadlock_state(
    state: &State,
    system: &StateTransitionSystem,
) -> Result<bool, Error> {
    // æ­»é”çŠ¶æ€ï¼šæ²¡æœ‰å‡ºè¾¹ä¸”ä¸æ˜¯ç»ˆæ­¢çŠ¶æ€
    let transitions = system.transitions.get(state).unwrap_or(&Vec::new());
    Ok(transitions.is_empty() && !system.is_terminal_state(state)?)
}
```

---

## 6. ç›¸å…³æ–‡æ¡£

- [è¿”å› FormalModel ç›®å½•](../README.md)
- [04_åŠ¨æ€äº¤äº’æ¨¡å‹ README](README.md)
- [04.3_é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹](04.3_é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹.md)
- [01_åŸºç¡€å½¢å¼åŒ–æ¡†æ¶](../01_åŸºç¡€å½¢å¼åŒ–æ¡†æ¶/README.md)

---

**æœ€åæ›´æ–°**: 2025-01-27
