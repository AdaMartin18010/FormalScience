# 04.4 ç”Ÿç­è¿‡ç¨‹æ¨¡å‹

> **æ‰€å±ä¸»é¢˜**: 04_åŠ¨æ€äº¤äº’æ¨¡å‹
> **æœ€åæ›´æ–°**: 2025-01-27

## ğŸ“‹ ç›®å½•

- [04.4 ç”Ÿç­è¿‡ç¨‹æ¨¡å‹](#044-ç”Ÿç­è¿‡ç¨‹æ¨¡å‹)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. å®ä½“ç”Ÿå‘½å‘¨æœŸ](#1-å®ä½“ç”Ÿå‘½å‘¨æœŸ)
  - [2. ç¨³æ€åˆ†å¸ƒ](#2-ç¨³æ€åˆ†å¸ƒ)
    - [2.1 ç¨³æ€åˆ†å¸ƒçš„å®Œæ•´è¯æ˜](#21-ç¨³æ€åˆ†å¸ƒçš„å®Œæ•´è¯æ˜)
      - [æ­¥éª¤1ï¼šå¹³è¡¡æ–¹ç¨‹](#æ­¥éª¤1å¹³è¡¡æ–¹ç¨‹)
      - [æ­¥éª¤2ï¼šé€’æ¨å…³ç³»](#æ­¥éª¤2é€’æ¨å…³ç³»)
      - [æ­¥éª¤3ï¼šå½’ä¸€åŒ–æ¡ä»¶](#æ­¥éª¤3å½’ä¸€åŒ–æ¡ä»¶)
      - [æ­¥éª¤4ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤4ä¸»å®šç†è¯æ˜)
    - [2.2 ç¨³æ€æ¡ä»¶](#22-ç¨³æ€æ¡ä»¶)
  - [3. ä¸´ç•Œç°è±¡åˆ†æ](#3-ä¸´ç•Œç°è±¡åˆ†æ)
    - [3.1 ä¸´ç•Œç°è±¡çš„å®Œæ•´è¯æ˜](#31-ä¸´ç•Œç°è±¡çš„å®Œæ•´è¯æ˜)
      - [æ­¥éª¤1ï¼šæµé‡å¼ºåº¦çš„å®šä¹‰](#æ­¥éª¤1æµé‡å¼ºåº¦çš„å®šä¹‰)
      - [æ­¥éª¤2ï¼šå“åº”æ—¶é—´å…¬å¼](#æ­¥éª¤2å“åº”æ—¶é—´å…¬å¼)
      - [æ­¥éª¤3ï¼šä¸´ç•Œè¡Œä¸º](#æ­¥éª¤3ä¸´ç•Œè¡Œä¸º)
      - [æ­¥éª¤4ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤4ä¸»å®šç†è¯æ˜-1)
  - [4. ç”Ÿç­è¿‡ç¨‹æ¨¡å‹çš„å®é™…åº”ç”¨](#4-ç”Ÿç­è¿‡ç¨‹æ¨¡å‹çš„å®é™…åº”ç”¨)
    - [Golangå®ç°](#golangå®ç°)
      - [Pythonå®ç°](#pythonå®ç°)
      - [Rustå®ç°](#rustå®ç°)
    - [5.1 ç”Ÿç­è¿‡ç¨‹çš„ä¸´ç•Œç°è±¡](#51-ç”Ÿç­è¿‡ç¨‹çš„ä¸´ç•Œç°è±¡)
      - [æ­¥éª¤1ï¼šä¸´ç•Œç°è±¡å®šä¹‰](#æ­¥éª¤1ä¸´ç•Œç°è±¡å®šä¹‰)
      - [æ­¥éª¤2ï¼šå“åº”æ—¶é—´å‘æ•£](#æ­¥éª¤2å“åº”æ—¶é—´å‘æ•£)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜)
    - [5.2 ç”Ÿç­è¿‡ç¨‹çš„å®é™…åº”ç”¨](#52-ç”Ÿç­è¿‡ç¨‹çš„å®é™…åº”ç”¨)
      - [5.2.1 ç³»ç»Ÿå®¹é‡è§„åˆ’](#521-ç³»ç»Ÿå®¹é‡è§„åˆ’)
  - [5. ç›¸å…³æ–‡æ¡£](#5-ç›¸å…³æ–‡æ¡£)

---

## 1. å®ä½“ç”Ÿå‘½å‘¨æœŸ

**å®šä¹‰6**ï¼ˆå®ä½“ç”Ÿå‘½å‘¨æœŸï¼‰ï¼š
å®ä½“æ•°é‡ $N(t)$ æœä»ç”Ÿç­è¿‡ç¨‹ï¼š

$$
\begin{cases}
P(N(t+dt)=n+1 \mid N(t)=n) = \lambda_n dt + o(dt) \\
P(N(t+dt)=n-1 \mid N(t)=n) = \mu_n dt + o(dt)
\end{cases}
$$

å…¶ä¸­ï¼š

- $\lambda_n$: å‡ºç”Ÿç‡ï¼ˆå®ä½“åˆ›å»ºé€Ÿç‡ï¼‰
- $\mu_n$: æ­»äº¡ç‡ï¼ˆå®ä½“ç»ˆæ­¢é€Ÿç‡ï¼‰

**è¿‡ç¨‹ç‰¹ç‚¹**ï¼š

- çŠ¶æ€ç©ºé—´ï¼šéè´Ÿæ•´æ•° $\{0, 1, 2, \ldots\}$
- è½¬ç§»ï¼šä»…ç›¸é‚»çŠ¶æ€é—´è½¬ç§»
- é©¬å°”å¯å¤«æ€§ï¼šæœªæ¥çŠ¶æ€ä»…ä¾èµ–å½“å‰çŠ¶æ€

---

## 2. ç¨³æ€åˆ†å¸ƒ

**ç¨³æ€åˆ†å¸ƒ**ï¼ˆä¸‰å±‚é€šç”¨ï¼‰ï¼š

$$
\pi_n = \pi_0 \prod_{k=0}^{n-1} \frac{\lambda_k}{\mu_{k+1}}
$$

å…¶ä¸­ $\pi_0$ ç”±å½’ä¸€åŒ–æ¡ä»¶ç¡®å®šï¼š

$$
\pi_0 = \left(1 + \sum_{n=1}^{\infty} \prod_{k=0}^{n-1} \frac{\lambda_k}{\mu_{k+1}}\right)^{-1}
$$

### 2.1 ç¨³æ€åˆ†å¸ƒçš„å®Œæ•´è¯æ˜

**å®šç†19**ï¼ˆç”Ÿç­è¿‡ç¨‹çš„ç¨³æ€åˆ†å¸ƒï¼‰ï¼š
å¯¹äºç”Ÿç­è¿‡ç¨‹ï¼Œè‹¥ç¨³æ€å­˜åœ¨ï¼Œåˆ™ç¨³æ€åˆ†å¸ƒç”±ä¸Šè¿°å…¬å¼ç»™å‡ºã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šå¹³è¡¡æ–¹ç¨‹

**å¼•ç†19.1**ï¼ˆå¹³è¡¡æ–¹ç¨‹ï¼‰ï¼š
ç¨³æ€åˆ†å¸ƒæ»¡è¶³å¹³è¡¡æ–¹ç¨‹ï¼š

$$
\pi_n(\lambda_n + \mu_n) = \pi_{n-1}\lambda_{n-1} + \pi_{n+1}\mu_{n+1}
$$

**è¯æ˜**ï¼š
åœ¨ç¨³æ€ä¸‹ï¼Œè¿›å…¥çŠ¶æ€ $n$ çš„é€Ÿç‡ç­‰äºç¦»å¼€çŠ¶æ€ $n$ çš„é€Ÿç‡ï¼š

- è¿›å…¥é€Ÿç‡ï¼šä»çŠ¶æ€ $n-1$ è½¬ç§»åˆ° $n$ï¼ˆ$\pi_{n-1}\lambda_{n-1}$ï¼‰å’Œä»çŠ¶æ€ $n+1$ è½¬ç§»åˆ° $n$ï¼ˆ$\pi_{n+1}\mu_{n+1}$ï¼‰
- ç¦»å¼€é€Ÿç‡ï¼šä»çŠ¶æ€ $n$ è½¬ç§»åˆ°å…¶ä»–çŠ¶æ€ï¼ˆ$\pi_n(\lambda_n + \mu_n)$ï¼‰

å› æ­¤å¹³è¡¡æ–¹ç¨‹æˆç«‹ã€‚ âˆ

#### æ­¥éª¤2ï¼šé€’æ¨å…³ç³»

**å¼•ç†19.2**ï¼ˆé€’æ¨å…³ç³»ï¼‰ï¼š
ç¨³æ€åˆ†å¸ƒæ»¡è¶³é€’æ¨å…³ç³»ï¼š

$$
\pi_n = \pi_0 \prod_{k=0}^{n-1} \frac{\lambda_k}{\mu_{k+1}}
$$

**è¯æ˜**ï¼š
ç”±å¹³è¡¡æ–¹ç¨‹ï¼Œå¯¹äºçŠ¶æ€ $n$ï¼š

$$
\pi_n \mu_n = \pi_{n-1} \lambda_{n-1}
$$

å› æ­¤ï¼š

$$
\pi_n = \pi_{n-1} \frac{\lambda_{n-1}}{\mu_n}
$$

é€’æ¨å¾—åˆ°ï¼š

$$
\pi_n = \pi_0 \prod_{k=0}^{n-1} \frac{\lambda_k}{\mu_{k+1}}
$$

âˆ

#### æ­¥éª¤3ï¼šå½’ä¸€åŒ–æ¡ä»¶

**å¼•ç†19.3**ï¼ˆå½’ä¸€åŒ–ï¼‰ï¼š
å½’ä¸€åŒ–å¸¸æ•° $\pi_0$ ç”±ä¸‹å¼ç¡®å®šï¼š

$$
\pi_0 = \left(1 + \sum_{n=1}^{\infty} \prod_{k=0}^{n-1} \frac{\lambda_k}{\mu_{k+1}}\right)^{-1}
$$

**è¯æ˜**ï¼š
ç”±æ¦‚ç‡åˆ†å¸ƒçš„å½’ä¸€åŒ–æ¡ä»¶ï¼š

$$
\sum_{n=0}^{\infty} \pi_n = 1
$$

ä»£å…¥é€’æ¨å…³ç³»ï¼š

$$
\pi_0 \left(1 + \sum_{n=1}^{\infty} \prod_{k=0}^{n-1} \frac{\lambda_k}{\mu_{k+1}}\right) = 1
$$

å› æ­¤ï¼š

$$
\pi_0 = \left(1 + \sum_{n=1}^{\infty} \prod_{k=0}^{n-1} \frac{\lambda_k}{\mu_{k+1}}\right)^{-1}
$$

âˆ

#### æ­¥éª¤4ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†19.1-19.3ï¼Œç¨³æ€åˆ†å¸ƒç”±ä¸Šè¿°å…¬å¼ç»™å‡ºã€‚ âˆ

### 2.2 ç¨³æ€æ¡ä»¶

**ç¨³æ€æ¡ä»¶**ï¼š

- **å­˜åœ¨æ€§**ï¼š$\sum_{n=0}^{\infty} \pi_n = 1$ï¼Œå³çº§æ•°æ”¶æ•›
- **å”¯ä¸€æ€§**ï¼šä¸å¯çº¦ä¸”æ­£å¸¸è¿”

---

## 3. ä¸´ç•Œç°è±¡åˆ†æ

**ä¸´ç•Œç°è±¡**ï¼š
å½“ $\lambda_n \approx \mu_n$ æ—¶ï¼Œç³»ç»Ÿå¤„äº**ç›¸å˜ä¸´ç•Œç‚¹**ï¼Œå“åº”æ—¶é—´å‘æ•£ï¼š

$$
\mathbb{E}[T] \sim (1 - \rho)^{-1}, \quad \rho = \lim_{n \to \infty} \frac{\lambda_n}{\mu_n}
$$

### 3.1 ä¸´ç•Œç°è±¡çš„å®Œæ•´è¯æ˜

**å®šç†20**ï¼ˆä¸´ç•Œç°è±¡ï¼‰ï¼š
å½“æµé‡å¼ºåº¦ $\rho = 1$ æ—¶ï¼Œç³»ç»Ÿå¤„äºä¸´ç•Œç‚¹ï¼Œå“åº”æ—¶é—´å‘æ•£ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šæµé‡å¼ºåº¦çš„å®šä¹‰

**å®šä¹‰**ï¼ˆæµé‡å¼ºåº¦ï¼‰ï¼š
æµé‡å¼ºåº¦å®šä¹‰ä¸ºï¼š

$$
\rho = \lim_{n \to \infty} \frac{\lambda_n}{\mu_n}
$$

#### æ­¥éª¤2ï¼šå“åº”æ—¶é—´å…¬å¼

**å¼•ç†20.1**ï¼ˆå“åº”æ—¶é—´å…¬å¼ï¼‰ï¼š
åœ¨ç¨³æ€ä¸‹ï¼Œå¹³å‡å“åº”æ—¶é—´ä¸ºï¼š

$$
\mathbb{E}[T] = \frac{\sum_{n=0}^{\infty} n \pi_n}{\lambda_{\text{eff}}}
$$

å…¶ä¸­ $\lambda_{\text{eff}} = \sum_{n=0}^{\infty} \lambda_n \pi_n$ æ˜¯æœ‰æ•ˆåˆ°è¾¾ç‡ã€‚

**è¯æ˜**ï¼š
ç”±Littleå®šå¾‹ï¼Œå¹³å‡å“åº”æ—¶é—´ç­‰äºå¹³å‡é˜Ÿåˆ—é•¿åº¦é™¤ä»¥æœ‰æ•ˆåˆ°è¾¾ç‡ã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸´ç•Œè¡Œä¸º

**å¼•ç†20.2**ï¼ˆä¸´ç•Œè¡Œä¸ºï¼‰ï¼š
å½“ $\rho \to 1$ æ—¶ï¼Œ$\mathbb{E}[T] \to \infty$ã€‚

**è¯æ˜**ï¼š
å½“ $\rho \to 1$ æ—¶ï¼Œç¨³æ€åˆ†å¸ƒ $\pi_n$ çš„å°¾éƒ¨å˜é‡ï¼Œå¹³å‡é˜Ÿåˆ—é•¿åº¦ $\sum_{n=0}^{\infty} n \pi_n$ å‘æ•£ï¼Œå› æ­¤ $\mathbb{E}[T] \to \infty$ã€‚ âˆ

#### æ­¥éª¤4ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†20.1å’Œ20.2ï¼Œå½“ $\rho = 1$ æ—¶ï¼Œå“åº”æ—¶é—´å‘æ•£ã€‚ âˆ

**ä¸´ç•Œè¡Œä¸º**ï¼š

- $\rho < 1$: ç³»ç»Ÿç¨³å®šï¼Œç¨³æ€åˆ†å¸ƒå­˜åœ¨
- $\rho = 1$: ä¸´ç•Œç‚¹ï¼Œå“åº”æ—¶é—´å‘æ•£
- $\rho > 1$: ç³»ç»Ÿä¸ç¨³å®šï¼Œé˜Ÿåˆ—é•¿åº¦æ— é™å¢é•¿

**ä¸‰å±‚ç³»ç»Ÿè¡¨ç°**ï¼š

- OSå±‚ï¼šè¿›ç¨‹åˆ›å»º/ç»ˆæ­¢é€Ÿç‡å¹³è¡¡
- VMå±‚ï¼šVMåˆ›å»º/åˆ é™¤é€Ÿç‡å¹³è¡¡
- å®¹å™¨å±‚ï¼šPodåˆ›å»º/åˆ é™¤é€Ÿç‡å¹³è¡¡

**ä¸´ç•Œç°è±¡çš„å®é™…æ„ä¹‰**ï¼š

- **ç¨³å®šçŠ¶æ€**ï¼ˆ$\rho < 1$ï¼‰ï¼šç³»ç»Ÿå¯ä»¥å¤„ç†æ‰€æœ‰è¯·æ±‚ï¼Œå“åº”æ—¶é—´æœ‰é™
- **ä¸´ç•ŒçŠ¶æ€**ï¼ˆ$\rho = 1$ï¼‰ï¼šç³»ç»Ÿå¤„äºé¥±å’ŒçŠ¶æ€ï¼Œå“åº”æ—¶é—´å¯èƒ½å¾ˆé•¿
- **ä¸ç¨³å®šçŠ¶æ€**ï¼ˆ$\rho > 1$ï¼‰ï¼šç³»ç»Ÿæ— æ³•å¤„ç†æ‰€æœ‰è¯·æ±‚ï¼Œé˜Ÿåˆ—é•¿åº¦æ— é™å¢é•¿

**ç³»ç»Ÿè®¾è®¡æŒ‡å¯¼**ï¼š

- è®¾è®¡ç³»ç»Ÿæ—¶åº”ä¿æŒ $\rho < 1$ï¼Œç•™æœ‰å®‰å…¨ä½™é‡
- ç›‘æ§æµé‡å¼ºåº¦ï¼ŒåŠæ—¶æ‰©å®¹æˆ–é™æµ
- ä½¿ç”¨è´Ÿè½½å‡è¡¡é¿å…å•ç‚¹è¿‡è½½

---

## 4. ç”Ÿç­è¿‡ç¨‹æ¨¡å‹çš„å®é™…åº”ç”¨

**å®¹é‡è§„åˆ’**ï¼š

- æ ¹æ®åˆ°è¾¾ç‡å’ŒæœåŠ¡æ—¶é—´è®¡ç®—æ‰€éœ€èµ„æº
- é¢„æµ‹ç³»ç»Ÿåœ¨ä¸åŒè´Ÿè½½ä¸‹çš„æ€§èƒ½
- ä¼˜åŒ–èµ„æºé…ç½®æé«˜æ•ˆç‡

**æ€§èƒ½ä¼˜åŒ–**ï¼š

- è¯†åˆ«ç³»ç»Ÿç“¶é¢ˆï¼ˆé«˜æµé‡å¼ºåº¦ï¼‰
- ä¼˜åŒ–æœåŠ¡æ—¶é—´åˆ†å¸ƒ
- å‡å°‘ç³»ç»Ÿå“åº”æ—¶é—´

**æ•…éšœé¢„é˜²**ï¼š

- ç›‘æ§æµé‡å¼ºåº¦ï¼Œé¢„é˜²ç³»ç»Ÿè¿‡è½½
- è®¾ç½®å‘Šè­¦é˜ˆå€¼ï¼ŒåŠæ—¶å¤„ç†
- å®ç°è‡ªåŠ¨æ‰©å®¹æœºåˆ¶

**å®é™…åº”ç”¨æ¡ˆä¾‹**ï¼š

| ç³»ç»Ÿ | å‡ºç”Ÿç‡ $\lambda$ | æ­»äº¡ç‡ $\mu$ | æµé‡å¼ºåº¦ $\rho$ | ç¨³æ€å®ä½“æ•° | æ•ˆæœ |
|------|----------------|-------------|---------------|-----------|------|
| Linuxè¿›ç¨‹ | 100/s | 95/s | 0.95 | ~20 | ç³»ç»Ÿç¨³å®š |
| VMåˆ›å»º | 10/min | 9/min | 0.90 | ~10 | èµ„æºå……è¶³ |
| Podè°ƒåº¦ | 50/min | 48/min | 0.96 | ~25 | æ¥è¿‘ä¸´ç•Œ |

**å·¥ç¨‹å®ç°ç¤ºä¾‹**ï¼š

### Golangå®ç°

```go
package simulation

import (
    "math"
    "math/rand"
    "time"
)

// ç”Ÿç­è¿‡ç¨‹
type BirthDeathProcess struct {
    lambdaFunc func(int) float64 // å‡ºç”Ÿç‡å‡½æ•°
    muFunc     func(int) float64 // æ­»äº¡ç‡å‡½æ•°
    rng        *rand.Rand
}

func NewBirthDeathProcess(lambdaFunc, muFunc func(int) float64) *BirthDeathProcess {
    return &BirthDeathProcess{
        lambdaFunc: lambdaFunc,
        muFunc:     muFunc,
        rng:        rand.New(rand.NewSource(time.Now().UnixNano())),
    }
}

// æ¨¡æ‹Ÿç”Ÿç­è¿‡ç¨‹
func (bdp *BirthDeathProcess) Simulate(n0 int, duration, dt float64) []int {
    n := n0
    trajectory := []int{n0}

    steps := int(duration / dt)
    for t := 0; t < steps; t++ {
        lambdaN := bdp.lambdaFunc(n)
        muN := bdp.muFunc(n)

        // è®¡ç®—è½¬ç§»æ¦‚ç‡
        pBirth := lambdaN * dt
        pDeath := muN * dt

        // éšæœºè½¬ç§»
        r := bdp.rng.Float64()
        if r < pBirth {
            n++
        } else if r < pBirth+pDeath && n > 0 {
            n--
        }

        trajectory = append(trajectory, n)
    }

    return trajectory
}

// è®¡ç®—ç¨³æ€åˆ†å¸ƒ
func (bdp *BirthDeathProcess) ComputeSteadyState(maxN int) []float64 {
    pi := []float64{1.0} // pi[0] = 1

    for n := 1; n <= maxN; n++ {
        piN := 1.0
        for k := 0; k < n; k++ {
            lambdaK := bdp.lambdaFunc(k)
            muK1 := bdp.muFunc(k + 1)
            if muK1 > 0 {
                piN *= lambdaK / muK1
            }
        }
        pi = append(pi, piN)
    }

    // å½’ä¸€åŒ–
    total := 0.0
    for _, p := range pi {
        total += p
    }

    normalized := make([]float64, len(pi))
    for i, p := range pi {
        normalized[i] = p / total
    }

    return normalized
}

// è®¡ç®—æµé‡å¼ºåº¦
func (bdp *BirthDeathProcess) ComputeTrafficIntensity(n int) float64 {
    lambdaN := bdp.lambdaFunc(n)
    muN := bdp.muFunc(n)
    if muN > 0 {
        return lambdaN / muN
    }
    return math.Inf(1)
}

// æ£€æµ‹ä¸´ç•ŒçŠ¶æ€
func (bdp *BirthDeathProcess) DetectCriticalState(maxN int) (bool, float64) {
    for n := 0; n <= maxN; n++ {
        rho := bdp.ComputeTrafficIntensity(n)
        if math.Abs(rho-1.0) < 0.01 {
            return true, rho
        }
    }
    return false, 0.0
}
```

#### Pythonå®ç°

```python
import numpy as np
import random
from typing import Callable, List, Tuple

class BirthDeathProcess:
    def __init__(self, lambda_func: Callable[[int], float], mu_func: Callable[[int], float]):
        self.lambda_func = lambda_func  # å‡ºç”Ÿç‡å‡½æ•°
        self.mu_func = mu_func          # æ­»äº¡ç‡å‡½æ•°

    def simulate(self, n0: int, duration: float, dt: float) -> List[int]:
        """æ¨¡æ‹Ÿç”Ÿç­è¿‡ç¨‹"""
        n = n0
        trajectory = [n0]

        steps = int(duration / dt)
        for _ in range(steps):
            lambda_n = self.lambda_func(n)
            mu_n = self.mu_func(n)

            # è®¡ç®—è½¬ç§»æ¦‚ç‡
            p_birth = lambda_n * dt
            p_death = mu_n * dt

            # éšæœºè½¬ç§»
            r = random.random()
            if r < p_birth:
                n += 1
            elif r < p_birth + p_death and n > 0:
                n -= 1

            trajectory.append(n)

        return trajectory

    def compute_steady_state(self, max_n: int = 100) -> List[float]:
        """è®¡ç®—ç¨³æ€åˆ†å¸ƒï¼šÏ€_n = Ï€_0 * âˆ(Î»_k / Î¼_{k+1})"""
        pi = [1.0]  # Ï€[0] = 1

        for n in range(1, max_n + 1):
            pi_n = 1.0
            for k in range(n):
                lambda_k = self.lambda_func(k)
                mu_k1 = self.mu_func(k + 1)
                if mu_k1 > 0:
                    pi_n *= lambda_k / mu_k1
            pi.append(pi_n)

        # å½’ä¸€åŒ–
        total = sum(pi)
        return [p / total for p in pi]

    def compute_traffic_intensity(self, n: int) -> float:
        """è®¡ç®—æµé‡å¼ºåº¦ï¼šÏ = Î»_n / Î¼_n"""
        lambda_n = self.lambda_func(n)
        mu_n = self.mu_func(n)
        return lambda_n / mu_n if mu_n > 0 else float('inf')

    def detect_critical_state(self, max_n: int = 100) -> Tuple[bool, float]:
        """æ£€æµ‹ä¸´ç•ŒçŠ¶æ€ï¼šÏ â‰ˆ 1"""
        for n in range(max_n + 1):
            rho = self.compute_traffic_intensity(n)
            if abs(rho - 1.0) < 0.01:
                return True, rho
        return False, 0.0

    def predict_response_time(self, n: int) -> float:
        """é¢„æµ‹å“åº”æ—¶é—´ï¼šT ~ (1 - Ï)^(-1)"""
        rho = self.compute_traffic_intensity(n)
        if rho >= 1.0:
            return float('inf')
        return 1.0 / (1.0 - rho)

# ä¸‰å±‚ç³»ç»Ÿç”Ÿç­è¿‡ç¨‹å¯¹æ¯”
def compare_layers():
    """å¯¹æ¯”ä¸‰å±‚ç³»ç»Ÿçš„ç”Ÿç­è¿‡ç¨‹"""
    # OSå±‚ï¼šè¿›ç¨‹åˆ›å»º/ç»ˆæ­¢
    os_process = BirthDeathProcess(
        lambda_func=lambda n: 100.0,  # 100 processes/s
        mu_func=lambda n: 95.0,        # 95 processes/s
    )

    # VMå±‚ï¼šVMåˆ›å»º/åˆ é™¤
    vm_process = BirthDeathProcess(
        lambda_func=lambda n: 10.0 / 60.0,  # 10 VMs/min
        mu_func=lambda n: 9.0 / 60.0,        # 9 VMs/min
    )

    # å®¹å™¨å±‚ï¼šPodåˆ›å»º/åˆ é™¤
    ctr_process = BirthDeathProcess(
        lambda_func=lambda n: 50.0 / 60.0,  # 50 Pods/min
        mu_func=lambda n: 48.0 / 60.0,       # 48 Pods/min
    )

    # è®¡ç®—ç¨³æ€åˆ†å¸ƒ
    os_steady = os_process.compute_steady_state()
    vm_steady = vm_process.compute_steady_state()
    ctr_steady = ctr_process.compute_steady_state()

    return {
        'os': os_steady,
        'vm': vm_steady,
        'ctr': ctr_steady,
    }
```

#### Rustå®ç°

```rust
use rand::Rng;
use std::f64;

pub struct BirthDeathProcess {
    lambda_func: Box<dyn Fn(i32) -> f64>,
    mu_func: Box<dyn Fn(i32) -> f64>,
    rng: rand::rngs::ThreadRng,
}

impl BirthDeathProcess {
    pub fn new<F1, F2>(lambda_func: F1, mu_func: F2) -> Self
    where
        F1: Fn(i32) -> f64 + 'static,
        F2: Fn(i32) -> f64 + 'static,
    {
        BirthDeathProcess {
            lambda_func: Box::new(lambda_func),
            mu_func: Box::new(mu_func),
            rng: rand::thread_rng(),
        }
    }

    pub fn simulate(&mut self, n0: i32, duration: f64, dt: f64) -> Vec<i32> {
        let mut n = n0;
        let mut trajectory = vec![n0];

        let steps = (duration / dt) as usize;
        for _ in 0..steps {
            let lambda_n = (self.lambda_func)(n);
            let mu_n = (self.mu_func)(n);

            // è®¡ç®—è½¬ç§»æ¦‚ç‡
            let p_birth = lambda_n * dt;
            let p_death = mu_n * dt;

            // éšæœºè½¬ç§»
            let r: f64 = self.rng.gen();
            if r < p_birth {
                n += 1;
            } else if r < p_birth + p_death && n > 0 {
                n -= 1;
            }

            trajectory.push(n);
        }

        trajectory
    }

    pub fn compute_steady_state(&self, max_n: i32) -> Vec<f64> {
        let mut pi = vec![1.0]; // Ï€[0] = 1

        for n in 1..=max_n {
            let mut pi_n = 1.0;
            for k in 0..n {
                let lambda_k = (self.lambda_func)(k);
                let mu_k1 = (self.mu_func)(k + 1);
                if mu_k1 > 0.0 {
                    pi_n *= lambda_k / mu_k1;
                }
            }
            pi.push(pi_n);
        }

        // å½’ä¸€åŒ–
        let total: f64 = pi.iter().sum();
        pi.iter().map(|p| p / total).collect()
    }

    pub fn compute_traffic_intensity(&self, n: i32) -> f64 {
        let lambda_n = (self.lambda_func)(n);
        let mu_n = (self.mu_func)(n);
        if mu_n > 0.0 {
            lambda_n / mu_n
        } else {
            f64::INFINITY
        }
    }

    pub fn detect_critical_state(&self, max_n: i32) -> (bool, f64) {
        for n in 0..=max_n {
            let rho = self.compute_traffic_intensity(n);
            if (rho - 1.0).abs() < 0.01 {
                return (true, rho);
            }
        }
        (false, 0.0)
    }

    pub fn predict_response_time(&self, n: i32) -> f64 {
        let rho = self.compute_traffic_intensity(n);
        if rho >= 1.0 {
            return f64::INFINITY;
        }
        1.0 / (1.0 - rho)
    }
}
```

**ç”Ÿç­è¿‡ç¨‹åˆ†æçš„å®é™…ä»·å€¼**ï¼š

- **å®¹é‡è§„åˆ’**ï¼šé€šè¿‡ç¨³æ€åˆ†å¸ƒé¢„æµ‹ç³»ç»Ÿå®¹é‡éœ€æ±‚
- **æ€§èƒ½é¢„æµ‹**ï¼šé€šè¿‡æµé‡å¼ºåº¦é¢„æµ‹ç³»ç»Ÿæ€§èƒ½
- **æ•…éšœé¢„é˜²**ï¼šè¯†åˆ«ä¸´ç•ŒçŠ¶æ€ï¼Œæå‰é¢„é˜²ç³»ç»Ÿè¿‡è½½

### 5.1 ç”Ÿç­è¿‡ç¨‹çš„ä¸´ç•Œç°è±¡

**å®šç†74**ï¼ˆç”Ÿç­è¿‡ç¨‹çš„ä¸´ç•Œç°è±¡ï¼‰ï¼š
å½“æµé‡å¼ºåº¦ $\rho \to 1$ æ—¶ï¼Œç³»ç»Ÿå“åº”æ—¶é—´å‘æ•£ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šä¸´ç•Œç°è±¡å®šä¹‰

**å®šä¹‰**ï¼ˆä¸´ç•Œç°è±¡ï¼‰ï¼š
ç³»ç»Ÿå¤„äºä¸´ç•ŒçŠ¶æ€ï¼Œå½“ä¸”ä»…å½“ $\rho = 1$ï¼Œæ­¤æ—¶å“åº”æ—¶é—´ $T \to \infty$ã€‚

#### æ­¥éª¤2ï¼šå“åº”æ—¶é—´å‘æ•£

**å¼•ç†74.1**ï¼ˆå“åº”æ—¶é—´å‘æ•£ï¼‰ï¼š
å½“ $\rho \to 1$ æ—¶ï¼Œå“åº”æ—¶é—´ $T \sim (1 - \rho)^{-1}$ã€‚

**è¯æ˜**ï¼š
ç”±Pollaczek-Khinchineå…¬å¼ï¼Œå“åº”æ—¶é—´ $T = \frac{\lambda E[S^2]}{2(1-\rho)} + E[S]$ã€‚å½“ $\rho \to 1$ æ—¶ï¼Œç¬¬ä¸€é¡¹å‘æ•£ï¼Œå› æ­¤ $T \to \infty$ã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†74.1ï¼Œå½“ $\rho \to 1$ æ—¶ï¼Œç³»ç»Ÿå“åº”æ—¶é—´å‘æ•£ã€‚ âˆ

### 5.2 ç”Ÿç­è¿‡ç¨‹çš„å®é™…åº”ç”¨

#### 5.2.1 ç³»ç»Ÿå®¹é‡è§„åˆ’

**åœºæ™¯**ï¼šåŸºäºç”Ÿç­è¿‡ç¨‹æ¨¡å‹è¿›è¡Œç³»ç»Ÿå®¹é‡è§„åˆ’ã€‚

**æ–¹æ³•**ï¼š

1. å»ºç«‹ç”Ÿç­è¿‡ç¨‹æ¨¡å‹
2. è®¡ç®—ç¨³æ€åˆ†å¸ƒ
3. æ ¹æ®SLAè¦æ±‚ç¡®å®šå®¹é‡

**Golangå®ç°**ï¼š

```go
package birthdeath

// ç³»ç»Ÿå®¹é‡è§„åˆ’
func CapacityPlanning(
    arrivalRate float64,
    serviceRate float64,
    targetUtilization float64,
) int {
    // è®¡ç®—æ‰€éœ€æœåŠ¡å™¨æ•°é‡
    for s := 1; s <= 100; s++ {
        rho := arrivalRate / (float64(s) * serviceRate)

        if rho <= targetUtilization {
            return s
        }
    }

    return -1 // æ— æ³•æ»¡è¶³è¦æ±‚
}

// è®¡ç®—ç¨³æ€åˆ†å¸ƒ
func ComputeSteadyState(
    arrivalRate float64,
    serviceRate float64,
    maxStates int,
) []float64 {
    rho := arrivalRate / serviceRate
    pi := make([]float64, maxStates+1)

    // è®¡ç®—å½’ä¸€åŒ–å¸¸æ•°
    sum := 0.0
    for n := 0; n <= maxStates; n++ {
        sum += math.Pow(rho, float64(n))
    }

    // è®¡ç®—ç¨³æ€æ¦‚ç‡
    for n := 0; n <= maxStates; n++ {
        pi[n] = math.Pow(rho, float64(n)) / sum
    }

    return pi
}
```

**Pythonå®ç°**ï¼š

```python
import math

def capacity_planning(
    arrival_rate: float,
    service_rate: float,
    target_utilization: float,
) -> int:
    """ç³»ç»Ÿå®¹é‡è§„åˆ’"""
    # è®¡ç®—æ‰€éœ€æœåŠ¡å™¨æ•°é‡
    for s in range(1, 101):
        rho = arrival_rate / (s * service_rate)

        if rho <= target_utilization:
            return s

    return -1  # æ— æ³•æ»¡è¶³è¦æ±‚

def compute_steady_state(
    arrival_rate: float,
    service_rate: float,
    max_states: int,
) -> list[float]:
    """è®¡ç®—ç¨³æ€åˆ†å¸ƒ"""
    rho = arrival_rate / service_rate
    pi = [0.0] * (max_states + 1)

    # è®¡ç®—å½’ä¸€åŒ–å¸¸æ•°
    total = sum(rho ** n for n in range(max_states + 1))

    # è®¡ç®—ç¨³æ€æ¦‚ç‡
    for n in range(max_states + 1):
        pi[n] = (rho ** n) / total

    return pi
```

**Rustå®ç°**ï¼š

```rust
pub fn capacity_planning(
    arrival_rate: f64,
    service_rate: f64,
    target_utilization: f64,
) -> Option<usize> {
    // è®¡ç®—æ‰€éœ€æœåŠ¡å™¨æ•°é‡
    for s in 1..=100 {
        let rho = arrival_rate / (s as f64 * service_rate);

        if rho <= target_utilization {
            return Some(s);
        }
    }

    None // æ— æ³•æ»¡è¶³è¦æ±‚
}

pub fn compute_steady_state(
    arrival_rate: f64,
    service_rate: f64,
    max_states: usize,
) -> Vec<f64> {
    let rho = arrival_rate / service_rate;
    let mut pi = vec![0.0; max_states + 1];

    // è®¡ç®—å½’ä¸€åŒ–å¸¸æ•°
    let total: f64 = (0..=max_states)
        .map(|n| rho.powi(n as i32))
        .sum();

    // è®¡ç®—ç¨³æ€æ¦‚ç‡
    for n in 0..=max_states {
        pi[n] = rho.powi(n as i32) / total;
    }

    pi
}
```

---

## 5. ç›¸å…³æ–‡æ¡£

- [è¿”å› FormalModel ç›®å½•](../README.md)
- [04_åŠ¨æ€äº¤äº’æ¨¡å‹ README](README.md)
- [04.3_é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹](04.3_é©¬å°”å¯å¤«å†³ç­–è¿‡ç¨‹.md)
- [03.2_æ’é˜Ÿè®ºè§†è§’](../03_å¤šæ¨¡å‹è§†è§’/03.2_æ’é˜Ÿè®ºè§†è§’.md)

---

**æœ€åæ›´æ–°**: 2025-01-27
