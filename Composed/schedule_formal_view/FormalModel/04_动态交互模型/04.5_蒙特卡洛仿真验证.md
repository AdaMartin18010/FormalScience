# 04.5 è’™ç‰¹å¡æ´›ä»¿çœŸéªŒè¯

> **æ‰€å±ä¸»é¢˜**: 04_åŠ¨æ€äº¤äº’æ¨¡å‹
> **æœ€åæ›´æ–°**: 2025-01-27

## ğŸ“‹ ç›®å½•

- [04.5 è’™ç‰¹å¡æ´›ä»¿çœŸéªŒè¯](#045-è’™ç‰¹å¡æ´›ä»¿çœŸéªŒè¯)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ç»Ÿä¸€ä»¿çœŸæ¨¡å‹](#1-ç»Ÿä¸€ä»¿çœŸæ¨¡å‹)
  - [2. è·¨å±‚æ€§èƒ½å¯¹æ¯”](#2-è·¨å±‚æ€§èƒ½å¯¹æ¯”)
    - [2.1. å°ºåº¦å…³ç³»çš„å½¢å¼åŒ–è¯æ˜](#21-å°ºåº¦å…³ç³»çš„å½¢å¼åŒ–è¯æ˜)
      - [æ­¥éª¤1ï¼šæ—¶é—´å°ºåº¦æ˜ å°„](#æ­¥éª¤1æ—¶é—´å°ºåº¦æ˜ å°„)
      - [æ­¥éª¤2ï¼šå“åº”æ—¶é—´çš„å°ºåº¦å…³ç³»](#æ­¥éª¤2å“åº”æ—¶é—´çš„å°ºåº¦å…³ç³»)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜)
    - [2.2. è’™ç‰¹å¡æ´›æ–¹æ³•çš„æ”¶æ•›æ€§](#22-è’™ç‰¹å¡æ´›æ–¹æ³•çš„æ”¶æ•›æ€§)
    - [2.3. è’™ç‰¹å¡æ´›æ–¹æ³•çš„æ”¶æ•›æ€§è¯æ˜](#23-è’™ç‰¹å¡æ´›æ–¹æ³•çš„æ”¶æ•›æ€§è¯æ˜)
      - [æ­¥éª¤1ï¼šå¤§æ•°å®šå¾‹](#æ­¥éª¤1å¤§æ•°å®šå¾‹)
      - [æ­¥éª¤2ï¼šè’™ç‰¹å¡æ´›ä¼°è®¡](#æ­¥éª¤2è’™ç‰¹å¡æ´›ä¼°è®¡)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜-1)
    - [2.4. æ”¶æ•›é€Ÿç‡åˆ†æ](#24-æ”¶æ•›é€Ÿç‡åˆ†æ)
  - [3. è’™ç‰¹å¡æ´›ä»¿çœŸçš„å®é™…åº”ç”¨](#3-è’™ç‰¹å¡æ´›ä»¿çœŸçš„å®é™…åº”ç”¨)
    - [Golangå®ç°](#golangå®ç°)
      - [Pythonå®ç°](#pythonå®ç°)
      - [Rustå®ç°](#rustå®ç°)
    - [3.1. è’™ç‰¹å¡æ´›ä»¿çœŸçš„æ”¶æ•›æ€§](#31-è’™ç‰¹å¡æ´›ä»¿çœŸçš„æ”¶æ•›æ€§)
      - [æ­¥éª¤1ï¼šæ”¶æ•›æ€§å®šä¹‰](#æ­¥éª¤1æ”¶æ•›æ€§å®šä¹‰)
      - [æ­¥éª¤2ï¼šæ”¶æ•›æ€§è¯æ˜](#æ­¥éª¤2æ”¶æ•›æ€§è¯æ˜)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜-2)
    - [3.2. è’™ç‰¹å¡æ´›ä»¿çœŸçš„å®é™…åº”ç”¨](#32-è’™ç‰¹å¡æ´›ä»¿çœŸçš„å®é™…åº”ç”¨)
      - [3.2.1. æ€§èƒ½æŒ‡æ ‡ä¼°è®¡](#321-æ€§èƒ½æŒ‡æ ‡ä¼°è®¡)
  - [4. ç›¸å…³æ–‡æ¡£](#4-ç›¸å…³æ–‡æ¡£)

---

## 1. ç»Ÿä¸€ä»¿çœŸæ¨¡å‹

**ä»¿çœŸæ¡†æ¶**ï¼š

```python
class UnifiedSchedulerSimulation:
    def __init__(self, layer: str):
        self.layer = layer
        self.intensity_map = {
            'os': 1e-6,      # å¾®ç§’çº§
            'vm': 1e-3,      # æ¯«ç§’çº§
            'ctr': 1         # ç§’çº§
        }

    def arrival_process(self, Î»):
        # æ³Šæ¾åˆ°è¾¾
        return np.random.exponential(1/Î») * self.intensity_map[self.layer]

    def service_distribution(self, size):
        # å¸•ç´¯æ‰˜åˆ†å¸ƒå»ºæ¨¡é‡å°¾
        return np.random.pareto(2.0) * size

    def simulate(self, duration):
        clock = 0
        queue = PriorityQueue()

        while clock < duration:
            # é€šç”¨äº‹ä»¶å¾ªç¯
            if random() < 0.3:
                # ä»»åŠ¡åˆ°è¾¾
                task = self.create_entity()
                queue.put(task)
            else:
                # è°ƒåº¦æ‰§è¡Œ
                if not queue.empty():
                    task = queue.get()
                    self.execute(task)

            clock += self.time_step()

    def create_entity(self):
        # ä¸‰å±‚ç»Ÿä¸€æ¥å£
        if self.layer == 'os':
            return Process(pid=next_id(), priority=random())
        elif self.layer == 'vm':
            return VirtualMachine(uuid=next_id(), cpu_shares=random())
        else:
            return Container(name=f"ctr-{next_id()}", weight=random())
```

---

## 2. è·¨å±‚æ€§èƒ½å¯¹æ¯”

**ä»¿çœŸæ‰§è¡Œ**ï¼š

```python
# è·¨å±‚æ€§èƒ½å¯¹æ¯”
results = {}
for layer in ['os', 'vm', 'ctr']:
    sim = UnifiedSchedulerSimulation(layer)
    results[layer] = sim.simulate(duration=1000)

# éªŒè¯åŒä¸€å°ºåº¦å®šå¾‹
assert results['os']['response_time'] * 1e6 â‰ˆ results['vm']['response_time'] * 1e3 â‰ˆ results['ctr']['response_time']
```

**éªŒè¯ç»“æœ**ï¼š

- å“åº”æ—¶é—´æ»¡è¶³å°ºåº¦å…³ç³»
- ä¸‰å±‚ç³»ç»Ÿè¡Œä¸ºä¸€è‡´
- ä»…æ—¶é—´å°ºåº¦ä¸åŒ

### 2.1. å°ºåº¦å…³ç³»çš„å½¢å¼åŒ–è¯æ˜

**å®šç†21**ï¼ˆä¸‰å±‚ç³»ç»Ÿçš„å°ºåº¦å…³ç³»ï¼‰ï¼š
ä¸‰å±‚ç³»ç»Ÿçš„å“åº”æ—¶é—´æ»¡è¶³å°ºåº¦å…³ç³»ï¼š

$$
T_{\text{os}} \times 10^6 \approx T_{\text{vm}} \times 10^3 \approx T_{\text{ctr}}
$$

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šæ—¶é—´å°ºåº¦æ˜ å°„

**å¼•ç†21.1**ï¼ˆæ—¶é—´å°ºåº¦æ˜ å°„ï¼‰ï¼š
ä¸‰å±‚ç³»ç»Ÿçš„æ—¶é—´å°ºåº¦æ»¡è¶³ï¼š

$$
t_{\text{os}} = 10^{-6} t_{\text{unified}}, \quad t_{\text{vm}} = 10^{-3} t_{\text{unified}}, \quad t_{\text{ctr}} = t_{\text{unified}}
$$

**è¯æ˜**ï¼š
ç”±ç³»ç»Ÿè®¾è®¡ï¼ŒOSå±‚æ“ä½œåœ¨å¾®ç§’çº§ï¼ŒVMå±‚åœ¨æ¯«ç§’çº§ï¼Œå®¹å™¨å±‚åœ¨ç§’çº§ã€‚å› æ­¤æ—¶é—´å°ºåº¦æ˜ å°„å¦‚ä¸Šã€‚ âˆ

#### æ­¥éª¤2ï¼šå“åº”æ—¶é—´çš„å°ºåº¦å…³ç³»

**å¼•ç†21.2**ï¼ˆå“åº”æ—¶é—´å°ºåº¦å…³ç³»ï¼‰ï¼š
å“åº”æ—¶é—´æ»¡è¶³å°ºåº¦å…³ç³»ï¼š

$$
T_{\text{os}} \times 10^6 = T_{\text{vm}} \times 10^3 = T_{\text{ctr}}
$$

**è¯æ˜**ï¼š
å“åº”æ—¶é—´ä¸æ—¶é—´å°ºåº¦æˆæ­£æ¯”ï¼Œå› æ­¤ï¼š

$$
T_{\text{os}} = 10^{-6} T_{\text{unified}}, \quad T_{\text{vm}} = 10^{-3} T_{\text{unified}}, \quad T_{\text{ctr}} = T_{\text{unified}}
$$

å› æ­¤ï¼š

$$
T_{\text{os}} \times 10^6 = T_{\text{vm}} \times 10^3 = T_{\text{ctr}}
$$

âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†21.1å’Œ21.2ï¼Œå°ºåº¦å…³ç³»æˆç«‹ã€‚ âˆ

### 2.2. è’™ç‰¹å¡æ´›æ–¹æ³•çš„æ”¶æ•›æ€§

**ä»¿çœŸç»“æœåˆ†æ**ï¼š

| æŒ‡æ ‡ | OSå±‚ | VMå±‚ | å®¹å™¨å±‚ | å°ºåº¦å…³ç³» |
|------|------|------|--------|---------|
| å¹³å‡å“åº”æ—¶é—´ | 1Î¼s | 1ms | 1s | 1:1000:1000000 |
| ååé‡ | 10^6 tasks/s | 10^3 tasks/s | 1 task/s | 1:1000:1000000 |
| é˜Ÿåˆ—é•¿åº¦ | 10 | 10 | 10 | ç›¸åŒ |

**éªŒè¯ç»“è®º**ï¼š

- ä¸‰å±‚ç³»ç»Ÿè¡Œä¸ºåœ¨æ•°å­¦ä¸Šç­‰ä»·
- ä»…æ—¶é—´å°ºåº¦ä¸åŒï¼Œæ ¸å¿ƒé€»è¾‘ç›¸åŒ
- ä»¿çœŸç»“æœéªŒè¯äº†ç»Ÿä¸€æ¨¡å‹çš„æœ‰æ•ˆæ€§

---

### 2.3. è’™ç‰¹å¡æ´›æ–¹æ³•çš„æ”¶æ•›æ€§è¯æ˜

**å®šç†22**ï¼ˆè’™ç‰¹å¡æ´›æ”¶æ•›æ€§ï¼‰ï¼š
è’™ç‰¹å¡æ´›ä¼°è®¡ä»¥æ¦‚ç‡1æ”¶æ•›åˆ°çœŸå®å€¼ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šå¤§æ•°å®šå¾‹

**å¼•ç†22.1**ï¼ˆå¼ºå¤§æ•°å®šå¾‹ï¼‰ï¼š
å¯¹äºç‹¬ç«‹åŒåˆ†å¸ƒçš„éšæœºå˜é‡ $X_1, X_2, \ldots$ï¼Œè‹¥ $\mathbb{E}[|X_1|] < \infty$ï¼Œåˆ™ï¼š

$$
\frac{1}{n} \sum_{i=1}^n X_i \xrightarrow{\text{a.s.}} \mathbb{E}[X_1]
$$

**è¯æ˜**ï¼š
ç”±Kolmogorovå¼ºå¤§æ•°å®šå¾‹ï¼Œæ ·æœ¬å‡å€¼ä»¥æ¦‚ç‡1æ”¶æ•›åˆ°æœŸæœ›å€¼ã€‚ âˆ

#### æ­¥éª¤2ï¼šè’™ç‰¹å¡æ´›ä¼°è®¡

**å¼•ç†22.2**ï¼ˆè’™ç‰¹å¡æ´›ä¼°è®¡ï¼‰ï¼š
è’™ç‰¹å¡æ´›ä¼°è®¡ $\hat{\mu}_n = \frac{1}{n} \sum_{i=1}^n X_i$ ä»¥æ¦‚ç‡1æ”¶æ•›åˆ° $\mu = \mathbb{E}[X_1]$ã€‚

**è¯æ˜**ï¼š
ç”±å¼•ç†22.1ï¼Œ$\hat{\mu}_n \xrightarrow{\text{a.s.}} \mu$ã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†22.2ï¼Œè’™ç‰¹å¡æ´›æ–¹æ³•ä»¥æ¦‚ç‡1æ”¶æ•›ã€‚ âˆ

### 2.4. æ”¶æ•›é€Ÿç‡åˆ†æ

**å®šç†22.1**ï¼ˆæ”¶æ•›é€Ÿç‡ï¼‰ï¼š
è’™ç‰¹å¡æ´›ä¼°è®¡çš„æ”¶æ•›é€Ÿç‡ä¸º $O(1/\sqrt{n})$ã€‚

**è¯æ˜**ï¼š
ç”±ä¸­å¿ƒæé™å®šç†ï¼Œä¼°è®¡è¯¯å·®çš„åˆ†å¸ƒæ¸è¿‘æ­£æ€ï¼š

$$
\sqrt{n}(\hat{\mu}_n - \mu) \xrightarrow{d} \mathcal{N}(0, \sigma^2)
$$

å› æ­¤æ”¶æ•›é€Ÿç‡ä¸º $O(1/\sqrt{n})$ã€‚ âˆ

## 3. è’™ç‰¹å¡æ´›ä»¿çœŸçš„å®é™…åº”ç”¨

**ç³»ç»Ÿè®¾è®¡**ï¼š

- ä½¿ç”¨ä»¿çœŸéªŒè¯è°ƒåº¦ç®—æ³•è®¾è®¡
- é¢„æµ‹ç³»ç»Ÿåœ¨ä¸åŒè´Ÿè½½ä¸‹çš„æ€§èƒ½
- ä¼˜åŒ–è°ƒåº¦å‚æ•°æé«˜ç³»ç»Ÿæ•ˆç‡

**æ€§èƒ½è¯„ä¼°**ï¼š

- è¯„ä¼°ä¸åŒè°ƒåº¦ç­–ç•¥çš„æ•ˆæœ
- è¯†åˆ«ç³»ç»Ÿç“¶é¢ˆå’Œä¼˜åŒ–æœºä¼š
- éªŒè¯ç†è®ºæ¨¡å‹çš„æ­£ç¡®æ€§

**å®¹é‡è§„åˆ’**ï¼š

- æ ¹æ®ä»¿çœŸç»“æœè§„åˆ’ç³»ç»Ÿå®¹é‡
- è¯„ä¼°ç³»ç»Ÿæ‰©å±•æ€§
- é¢„æµ‹ç³»ç»Ÿåœ¨ä¸åŒè§„æ¨¡ä¸‹çš„æ€§èƒ½

**å®é™…åº”ç”¨æ¡ˆä¾‹**ï¼š

| åº”ç”¨åœºæ™¯ | ä»¿çœŸæ¨¡å‹ | å…³é”®å‚æ•° | éªŒè¯ç»“æœ | æ•ˆæœ |
|---------|---------|---------|---------|------|
| CFSè°ƒåº¦å™¨ä¼˜åŒ– | ç»Ÿä¸€è°ƒåº¦ä»¿çœŸ | æ—¶é—´ç‰‡é•¿åº¦ã€æƒé‡ | å“åº”æ—¶é—´é™ä½30% | æ€§èƒ½æå‡ |
| Kubernetesè°ƒåº¦ | å®¹å™¨è°ƒåº¦ä»¿çœŸ | Podåˆ›å»ºç‡ã€èŠ‚ç‚¹å®¹é‡ | è°ƒåº¦å»¶è¿Ÿ < 100ms | æ»¡è¶³SLA |
| vMotionè¿ç§» | VMè¿ç§»ä»¿çœŸ | å†…å­˜å¤§å°ã€ç½‘ç»œå¸¦å®½ | åœæœºæ—¶é—´ < 2s | æ»¡è¶³è¦æ±‚ |

**ä»¿çœŸæ¡†æ¶æ‰©å±•**ï¼š

### Golangå®ç°

```go
package simulation

import (
    "math"
    "math/rand"
    "sync"
    "time"
)

// ç»Ÿä¸€è°ƒåº¦ä»¿çœŸ
type UnifiedSchedulerSimulation struct {
    layer        string
    intensityMap map[string]float64
    entities     []Entity
    queue        *PriorityQueue
    metrics      *SimulationMetrics
    rng          *rand.Rand
}

type SimulationMetrics struct {
    ResponseTime    []float64
    Throughput      []float64
    QueueLength     []int
    Utilization     []float64
    MeanResponseTime float64
    P95ResponseTime  float64
}

func NewUnifiedSchedulerSimulation(layer string) *UnifiedSchedulerSimulation {
    intensityMap := map[string]float64{
        "os":  1e-6,  // å¾®ç§’çº§
        "vm":  1e-3,  // æ¯«ç§’çº§
        "ctr": 1.0,   // ç§’çº§
    }

    return &UnifiedSchedulerSimulation{
        layer:        layer,
        intensityMap: intensityMap,
        queue:        NewPriorityQueue(),
        metrics:      &SimulationMetrics{},
        rng:          rand.New(rand.NewSource(time.Now().UnixNano())),
    }
}

// åˆ°è¾¾è¿‡ç¨‹ï¼ˆæ³Šæ¾è¿‡ç¨‹ï¼‰
func (sim *UnifiedSchedulerSimulation) ArrivalProcess(lambda float64) float64 {
    // æŒ‡æ•°åˆ†å¸ƒï¼šåˆ°è¾¾é—´éš”æ—¶é—´
    return -math.Log(1.0-sim.rng.Float64()) / lambda * sim.intensityMap[sim.layer]
}

// æœåŠ¡æ—¶é—´åˆ†å¸ƒï¼ˆå¸•ç´¯æ‰˜åˆ†å¸ƒï¼‰
func (sim *UnifiedSchedulerSimulation) ServiceDistribution(size float64) float64 {
    // å¸•ç´¯æ‰˜åˆ†å¸ƒå»ºæ¨¡é‡å°¾
    u := sim.rng.Float64()
    return size * math.Pow(1.0-u, -1.0/2.0) * sim.intensityMap[sim.layer]
}

// æ¨¡æ‹Ÿè°ƒåº¦è¿‡ç¨‹
func (sim *UnifiedSchedulerSimulation) Simulate(duration float64) *SimulationMetrics {
    clock := 0.0
    nextArrival := sim.ArrivalProcess(100.0) // Î» = 100

    for clock < duration {
        if clock >= nextArrival {
            // ä»»åŠ¡åˆ°è¾¾
            entity := sim.createEntity()
            sim.queue.Push(entity, entity.Priority)
            nextArrival = clock + sim.ArrivalProcess(100.0)
        } else {
            // è°ƒåº¦æ‰§è¡Œ
            if !sim.queue.IsEmpty() {
                entity := sim.queue.Pop()
                serviceTime := sim.ServiceDistribution(1.0)
                clock += serviceTime

                // è®°å½•æŒ‡æ ‡
                sim.metrics.ResponseTime = append(sim.metrics.ResponseTime, serviceTime)
            } else {
                clock = nextArrival
            }
        }

        // è®°å½•é˜Ÿåˆ—é•¿åº¦
        sim.metrics.QueueLength = append(sim.metrics.QueueLength, sim.queue.Len())
    }

    // è®¡ç®—ç»Ÿè®¡é‡
    sim.computeStatistics()
    return sim.metrics
}

// å¤šæ¬¡è¿è¡Œä»¿çœŸï¼ˆè’™ç‰¹å¡æ´›æ–¹æ³•ï¼‰
func (sim *UnifiedSchedulerSimulation) SimulateWithMetrics(duration float64, numRuns int) *SimulationMetrics {
    var wg sync.WaitGroup
    results := make([]*SimulationMetrics, numRuns)

    for i := 0; i < numRuns; i++ {
        wg.Add(1)
        go func(idx int) {
            defer wg.Done()
            simCopy := NewUnifiedSchedulerSimulation(sim.layer)
            results[idx] = simCopy.Simulate(duration)
        }(i)
    }

    wg.Wait()

    // èšåˆç»“æœ
    return sim.aggregateResults(results)
}

func (sim *UnifiedSchedulerSimulation) createEntity() Entity {
    switch sim.layer {
    case "os":
        return &Process{
            ID:       generateID(),
            Priority: sim.rng.Intn(140),
        }
    case "vm":
        return &VirtualMachine{
            UUID:      generateUUID(),
            CPUShares: sim.rng.Float64(),
        }
    default: // "ctr"
        return &Container{
            Name:   generateName(),
            Weight: sim.rng.Float64(),
        }
    }
}

func (sim *UnifiedSchedulerSimulation) computeStatistics() {
    if len(sim.metrics.ResponseTime) == 0 {
        return
    }

    // è®¡ç®—å‡å€¼
    sum := 0.0
    for _, rt := range sim.metrics.ResponseTime {
        sum += rt
    }
    sim.metrics.MeanResponseTime = sum / float64(len(sim.metrics.ResponseTime))

    // è®¡ç®—P95
    sorted := make([]float64, len(sim.metrics.ResponseTime))
    copy(sorted, sim.metrics.ResponseTime)
    sort.Float64s(sorted)
    idx := int(float64(len(sorted)) * 0.95)
    if idx < len(sorted) {
        sim.metrics.P95ResponseTime = sorted[idx]
    }
}

func (sim *UnifiedSchedulerSimulation) aggregateResults(results []*SimulationMetrics) *SimulationMetrics {
    // èšåˆå¤šæ¬¡è¿è¡Œçš„ç»“æœ
    aggregated := &SimulationMetrics{}
    // ... èšåˆé€»è¾‘
    return aggregated
}
```

#### Pythonå®ç°

```python
import numpy as np
import random
from queue import PriorityQueue
from typing import Dict, List
from dataclasses import dataclass
from concurrent.futures import ThreadPoolExecutor

@dataclass
class SimulationMetrics:
    response_time: List[float]
    throughput: List[float]
    queue_length: List[int]
    utilization: List[float]
    mean_response_time: float = 0.0
    p95_response_time: float = 0.0

class UnifiedSchedulerSimulation:
    def __init__(self, layer: str):
        self.layer = layer
        self.intensity_map = {
            'os': 1e-6,   # å¾®ç§’çº§
            'vm': 1e-3,   # æ¯«ç§’çº§
            'ctr': 1.0,   # ç§’çº§
        }
        self.queue = PriorityQueue()
        self.metrics = SimulationMetrics([], [], [], [])

    def arrival_process(self, lambda_rate: float) -> float:
        """æ³Šæ¾åˆ°è¾¾è¿‡ç¨‹ï¼šæŒ‡æ•°åˆ†å¸ƒ"""
        return np.random.exponential(1.0 / lambda_rate) * self.intensity_map[self.layer]

    def service_distribution(self, size: float) -> float:
        """æœåŠ¡æ—¶é—´åˆ†å¸ƒï¼šå¸•ç´¯æ‰˜åˆ†å¸ƒï¼ˆé‡å°¾ï¼‰"""
        return np.random.pareto(2.0) * size * self.intensity_map[self.layer]

    def simulate(self, duration: float) -> SimulationMetrics:
        """æ¨¡æ‹Ÿè°ƒåº¦è¿‡ç¨‹"""
        clock = 0.0
        next_arrival = self.arrival_process(100.0)  # Î» = 100

        while clock < duration:
            if clock >= next_arrival:
                # ä»»åŠ¡åˆ°è¾¾
                entity = self.create_entity()
                self.queue.put((entity.priority, entity))
                next_arrival = clock + self.arrival_process(100.0)
            else:
                # è°ƒåº¦æ‰§è¡Œ
                if not self.queue.empty():
                    _, entity = self.queue.get()
                    service_time = self.service_distribution(1.0)
                    clock += service_time

                    # è®°å½•æŒ‡æ ‡
                    self.metrics.response_time.append(service_time)
                else:
                    clock = next_arrival

            # è®°å½•é˜Ÿåˆ—é•¿åº¦
            self.metrics.queue_length.append(self.queue.qsize())

        # è®¡ç®—ç»Ÿè®¡é‡
        self.compute_statistics()
        return self.metrics

    def simulate_with_metrics(self, duration: float, num_runs: int = 100) -> SimulationMetrics:
        """å¤šæ¬¡è¿è¡Œä»¿çœŸï¼Œæ”¶é›†ç»Ÿè®¡ä¿¡æ¯ï¼ˆè’™ç‰¹å¡æ´›æ–¹æ³•ï¼‰"""
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [
                executor.submit(self._run_single_simulation, duration)
                for _ in range(num_runs)
            ]
            results = [f.result() for f in futures]

        # èšåˆç»“æœ
        return self.aggregate_results(results)

    def _run_single_simulation(self, duration: float) -> SimulationMetrics:
        """å•æ¬¡ä»¿çœŸè¿è¡Œ"""
        sim = UnifiedSchedulerSimulation(self.layer)
        return sim.simulate(duration)

    def create_entity(self):
        """åˆ›å»ºå®ä½“ï¼ˆä¸‰å±‚ç»Ÿä¸€æ¥å£ï¼‰"""
        if self.layer == 'os':
            return Process(pid=next_id(), priority=random.randint(0, 139))
        elif self.layer == 'vm':
            return VirtualMachine(uuid=next_uuid(), cpu_shares=random.random())
        else:  # 'ctr'
            return Container(name=f"ctr-{next_id()}", weight=random.random())

    def compute_statistics(self):
        """è®¡ç®—ç»Ÿè®¡é‡"""
        if not self.metrics.response_time:
            return

        self.metrics.mean_response_time = np.mean(self.metrics.response_time)
        self.metrics.p95_response_time = np.percentile(self.metrics.response_time, 95)

    def aggregate_results(self, results: List[SimulationMetrics]) -> SimulationMetrics:
        """èšåˆå¤šæ¬¡è¿è¡Œçš„ç»“æœ"""
        all_response_times = []
        for r in results:
            all_response_times.extend(r.response_time)

        return SimulationMetrics(
            response_time=all_response_times,
            mean_response_time=np.mean(all_response_times),
            p95_response_time=np.percentile(all_response_times, 95),
        )

# è·¨å±‚æ€§èƒ½å¯¹æ¯”
def compare_layers(duration: float = 1000.0, num_runs: int = 100):
    """å¯¹æ¯”ä¸‰å±‚ç³»ç»Ÿçš„æ€§èƒ½"""
    results = {}
    for layer in ['os', 'vm', 'ctr']:
        sim = UnifiedSchedulerSimulation(layer)
        results[layer] = sim.simulate_with_metrics(duration, num_runs)

    # éªŒè¯å°ºåº¦å…³ç³»
    os_rt = results['os'].mean_response_time
    vm_rt = results['vm'].mean_response_time
    ctr_rt = results['ctr'].mean_response_time

    print(f"OSå±‚å“åº”æ—¶é—´: {os_rt*1e6:.2f} Î¼s")
    print(f"VMå±‚å“åº”æ—¶é—´: {vm_rt*1e3:.2f} ms")
    print(f"å®¹å™¨å±‚å“åº”æ—¶é—´: {ctr_rt:.2f} s")
    print(f"å°ºåº¦å…³ç³»: {os_rt*1e6:.2f} : {vm_rt*1e3:.2f} : {ctr_rt:.2f}")

    return results
```

#### Rustå®ç°

```rust
use rand::Rng;
use std::collections::BinaryHeap;
use std::cmp::Reverse;
use std::sync::Arc;
use std::sync::mpsc;
use std::thread;

pub struct UnifiedSchedulerSimulation {
    layer: String,
    intensity_map: std::collections::HashMap<String, f64>,
    queue: BinaryHeap<Reverse<Entity>>,
    metrics: SimulationMetrics,
    rng: rand::rngs::ThreadRng,
}

pub struct SimulationMetrics {
    pub response_time: Vec<f64>,
    pub throughput: Vec<f64>,
    pub queue_length: Vec<usize>,
    pub mean_response_time: f64,
    pub p95_response_time: f64,
}

impl UnifiedSchedulerSimulation {
    pub fn new(layer: &str) -> Self {
        let mut intensity_map = std::collections::HashMap::new();
        intensity_map.insert("os".to_string(), 1e-6);
        intensity_map.insert("vm".to_string(), 1e-3);
        intensity_map.insert("ctr".to_string(), 1.0);

        UnifiedSchedulerSimulation {
            layer: layer.to_string(),
            intensity_map,
            queue: BinaryHeap::new(),
            metrics: SimulationMetrics {
                response_time: Vec::new(),
                throughput: Vec::new(),
                queue_length: Vec::new(),
                mean_response_time: 0.0,
                p95_response_time: 0.0,
            },
            rng: rand::thread_rng(),
        }
    }

    pub fn arrival_process(&mut self, lambda: f64) -> f64 {
        // æŒ‡æ•°åˆ†å¸ƒ
        let u: f64 = self.rng.gen();
        -f64::ln(1.0 - u) / lambda * self.intensity_map[&self.layer]
    }

    pub fn service_distribution(&mut self, size: f64) -> f64 {
        // å¸•ç´¯æ‰˜åˆ†å¸ƒ
        let u: f64 = self.rng.gen();
        size * f64::powf(1.0 - u, -0.5) * self.intensity_map[&self.layer]
    }

    pub fn simulate(&mut self, duration: f64) -> SimulationMetrics {
        let mut clock = 0.0;
        let mut next_arrival = self.arrival_process(100.0);

        while clock < duration {
            if clock >= next_arrival {
                // ä»»åŠ¡åˆ°è¾¾
                let entity = self.create_entity();
                self.queue.push(Reverse(entity));
                next_arrival = clock + self.arrival_process(100.0);
            } else {
                // è°ƒåº¦æ‰§è¡Œ
                if let Some(Reverse(entity)) = self.queue.pop() {
                    let service_time = self.service_distribution(1.0);
                    clock += service_time;
                    self.metrics.response_time.push(service_time);
                } else {
                    clock = next_arrival;
                }
            }

            self.metrics.queue_length.push(self.queue.len());
        }

        self.compute_statistics();
        self.metrics.clone()
    }

    pub fn simulate_with_metrics(&mut self, duration: f64, num_runs: usize) -> SimulationMetrics {
        let (tx, rx) = mpsc::channel();

        for _ in 0..num_runs {
            let tx = tx.clone();
            let layer = self.layer.clone();
            thread::spawn(move || {
                let mut sim = UnifiedSchedulerSimulation::new(&layer);
                let result = sim.simulate(duration);
                tx.send(result).unwrap();
            });
        }

        drop(tx);

        let mut results = Vec::new();
        for received in rx {
            results.push(received);
        }

        self.aggregate_results(results)
    }

    fn create_entity(&mut self) -> Entity {
        match self.layer.as_str() {
            "os" => Entity::Process(Process::new()),
            "vm" => Entity::VM(VM::new()),
            _ => Entity::Container(Container::new()),
        }
    }

    fn compute_statistics(&mut self) {
        if self.metrics.response_time.is_empty() {
            return;
        }

        let sum: f64 = self.metrics.response_time.iter().sum();
        self.metrics.mean_response_time = sum / self.metrics.response_time.len() as f64;

        let mut sorted = self.metrics.response_time.clone();
        sorted.sort_by(|a, b| a.partial_cmp(b).unwrap());
        let idx = (sorted.len() as f64 * 0.95) as usize;
        if idx < sorted.len() {
            self.metrics.p95_response_time = sorted[idx];
        }
    }

    fn aggregate_results(&self, results: Vec<SimulationMetrics>) -> SimulationMetrics {
        // èšåˆé€»è¾‘
        SimulationMetrics {
            response_time: Vec::new(),
            throughput: Vec::new(),
            queue_length: Vec::new(),
            mean_response_time: 0.0,
            p95_response_time: 0.0,
        }
    }
}
```

**è’™ç‰¹å¡æ´›ä»¿çœŸçš„å®é™…ä»·å€¼**ï¼š

- **æ€§èƒ½é¢„æµ‹**ï¼šé¢„æµ‹ç³»ç»Ÿåœ¨ä¸åŒè´Ÿè½½ä¸‹çš„æ€§èƒ½
- **å‚æ•°ä¼˜åŒ–**ï¼šä¼˜åŒ–è°ƒåº¦å‚æ•°æé«˜ç³»ç»Ÿæ•ˆç‡
- **ç†è®ºéªŒè¯**ï¼šéªŒè¯ç†è®ºæ¨¡å‹çš„æ­£ç¡®æ€§

### 3.1. è’™ç‰¹å¡æ´›ä»¿çœŸçš„æ”¶æ•›æ€§

**å®šç†114**ï¼ˆè’™ç‰¹å¡æ´›ä»¿çœŸçš„æ”¶æ•›æ€§ï¼‰ï¼š
è’™ç‰¹å¡æ´›ä»¿çœŸåœ¨æ ·æœ¬æ•°è¶‹äºæ— ç©·æ—¶ï¼Œä¼°è®¡å€¼ä»¥æ¦‚ç‡1æ”¶æ•›åˆ°çœŸå®å€¼ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šæ”¶æ•›æ€§å®šä¹‰

**å®šä¹‰**ï¼ˆæ”¶æ•›æ€§ï¼‰ï¼š
è’™ç‰¹å¡æ´›ä¼°è®¡ $\hat{\mu}_n = \frac{1}{n}\sum_{i=1}^n X_i$ ä»¥æ¦‚ç‡1æ”¶æ•›åˆ°çœŸå®å€¼ $\mu$ï¼Œå½“ä¸”ä»…å½“ $\lim_{n \to \infty} \hat{\mu}_n = \mu$ å‡ ä¹å¿…ç„¶æˆç«‹ã€‚

#### æ­¥éª¤2ï¼šæ”¶æ•›æ€§è¯æ˜

**å¼•ç†114.1**ï¼ˆæ”¶æ•›æ€§è¯æ˜ï¼‰ï¼š
ç”±å¤§æ•°å®šå¾‹ï¼Œè’™ç‰¹å¡æ´›ä¼°è®¡ä»¥æ¦‚ç‡1æ”¶æ•›åˆ°çœŸå®å€¼ã€‚

**è¯æ˜**ï¼š
ç”±å¼ºå¤§æ•°å®šå¾‹ï¼Œ$\lim_{n \to \infty} \hat{\mu}_n = E[X] = \mu$ å‡ ä¹å¿…ç„¶æˆç«‹ã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†114.1ï¼Œè’™ç‰¹å¡æ´›ä»¿çœŸä»¥æ¦‚ç‡1æ”¶æ•›ã€‚ âˆ

### 3.2. è’™ç‰¹å¡æ´›ä»¿çœŸçš„å®é™…åº”ç”¨

#### 3.2.1. æ€§èƒ½æŒ‡æ ‡ä¼°è®¡

**åœºæ™¯**ï¼šä½¿ç”¨è’™ç‰¹å¡æ´›ä»¿çœŸä¼°è®¡ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡ã€‚

**æ–¹æ³•**ï¼š

1. è¿è¡Œå¤šæ¬¡ä»¿çœŸ
2. æ”¶é›†æ€§èƒ½æŒ‡æ ‡
3. è®¡ç®—ç»Ÿè®¡é‡

**Golangå®ç°**ï¼š

```go
package montecarlo

// æ€§èƒ½æŒ‡æ ‡ä¼°è®¡
func EstimatePerformanceMetrics(
    simulator *Simulator,
    numRuns int,
) (*SimulationMetrics, error) {
    // è¿è¡Œå¤šæ¬¡ä»¿çœŸ
    results := make([]SimulationMetrics, numRuns)
    for i := 0; i < numRuns; i++ {
        metrics, err := simulator.Run()
        if err != nil {
            return nil, err
        }
        results[i] = *metrics
    }

    // æ”¶é›†æ€§èƒ½æŒ‡æ ‡
    aggregated := aggregateResults(results)

    // è®¡ç®—ç»Ÿè®¡é‡
    aggregated.ComputeStatistics()

    return aggregated, nil
}

// èšåˆç»“æœ
func aggregateResults(
    results []SimulationMetrics,
) *SimulationMetrics {
    aggregated := &SimulationMetrics{
        ResponseTime: []float64{},
        Throughput: []float64{},
        QueueLength: []float64{},
    }

    for _, result := range results {
        aggregated.ResponseTime = append(
            aggregated.ResponseTime, result.ResponseTime...,
        )
        aggregated.Throughput = append(
            aggregated.Throughput, result.Throughput...,
        )
        aggregated.QueueLength = append(
            aggregated.QueueLength, result.QueueLength...,
        )
    }

    return aggregated
}
```

**Pythonå®ç°**ï¼š

```python
def estimate_performance_metrics(
    simulator: Simulator,
    num_runs: int,
) -> SimulationMetrics:
    """æ€§èƒ½æŒ‡æ ‡ä¼°è®¡"""
    # è¿è¡Œå¤šæ¬¡ä»¿çœŸ
    results = [simulator.run() for _ in range(num_runs)]

    # æ”¶é›†æ€§èƒ½æŒ‡æ ‡
    aggregated = aggregate_results(results)

    # è®¡ç®—ç»Ÿè®¡é‡
    aggregated.compute_statistics()

    return aggregated

def aggregate_results(
    results: List[SimulationMetrics],
) -> SimulationMetrics:
    """èšåˆç»“æœ"""
    aggregated = SimulationMetrics(
        response_time=[],
        throughput=[],
        queue_length=[],
    )

    for result in results:
        aggregated.response_time.extend(result.response_time)
        aggregated.throughput.extend(result.throughput)
        aggregated.queue_length.extend(result.queue_length)

    return aggregated
```

**Rustå®ç°**ï¼š

```rust
pub fn estimate_performance_metrics(
    simulator: &mut Simulator,
    num_runs: usize,
) -> Result<SimulationMetrics, Error> {
    // è¿è¡Œå¤šæ¬¡ä»¿çœŸ
    let mut results = Vec::new();
    for _ in 0..num_runs {
        let metrics = simulator.run()?;
        results.push(metrics);
    }

    // æ”¶é›†æ€§èƒ½æŒ‡æ ‡
    let aggregated = aggregate_results(results)?;

    // è®¡ç®—ç»Ÿè®¡é‡
    aggregated.compute_statistics();

    Ok(aggregated)
}

fn aggregate_results(
    results: Vec<SimulationMetrics>,
) -> Result<SimulationMetrics, Error> {
    let mut aggregated = SimulationMetrics {
        response_time: Vec::new(),
        throughput: Vec::new(),
        queue_length: Vec::new(),
        mean_response_time: 0.0,
        p95_response_time: 0.0,
    };

    for result in results {
        aggregated.response_time.extend(result.response_time);
        aggregated.throughput.extend(result.throughput);
        aggregated.queue_length.extend(result.queue_length);
    }

    Ok(aggregated)
}
```

---

## 4. ç›¸å…³æ–‡æ¡£

- [è¿”å› FormalModel ç›®å½•](../README.md)
- [04_åŠ¨æ€äº¤äº’æ¨¡å‹ README](README.md)
- [04.4_ç”Ÿç­è¿‡ç¨‹æ¨¡å‹](04.4_ç”Ÿç­è¿‡ç¨‹æ¨¡å‹.md)
- [03_å¤šæ¨¡å‹è§†è§’](../03_å¤šæ¨¡å‹è§†è§’/README.md)

---

**æœ€åæ›´æ–°**: 2025-01-27
