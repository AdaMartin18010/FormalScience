# 04.2 åé¦ˆæ§åˆ¶å¾ªç¯

> **æ‰€å±ä¸»é¢˜**: 04_åŠ¨æ€äº¤äº’æ¨¡å‹
> **æœ€åæ›´æ–°**: 2025-01-27

## ğŸ“‹ ç›®å½•

- [04.2 åé¦ˆæ§åˆ¶å¾ªç¯](#042-åé¦ˆæ§åˆ¶å¾ªç¯)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. é€šç”¨æ§åˆ¶æ–¹ç¨‹](#1-é€šç”¨æ§åˆ¶æ–¹ç¨‹)
  - [2. PIDæ§åˆ¶å™¨](#2-pidæ§åˆ¶å™¨)
    - [2.1. PIDæ§åˆ¶å™¨çš„ç¨³å®šæ€§è¯æ˜](#21-pidæ§åˆ¶å™¨çš„ç¨³å®šæ€§è¯æ˜)
      - [æ­¥éª¤1ï¼šé—­ç¯ç³»ç»Ÿç‰¹å¾æ–¹ç¨‹](#æ­¥éª¤1é—­ç¯ç³»ç»Ÿç‰¹å¾æ–¹ç¨‹)
      - [æ­¥éª¤2ï¼šRouth-Hurwitzåˆ¤æ®](#æ­¥éª¤2routh-hurwitzåˆ¤æ®)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜)
  - [3. ä¸‰å±‚ç³»ç»Ÿæ§åˆ¶å‚æ•°](#3-ä¸‰å±‚ç³»ç»Ÿæ§åˆ¶å‚æ•°)
    - [3.1. åŸºç¡€æ§åˆ¶å‚æ•°è¡¨](#31-åŸºç¡€æ§åˆ¶å‚æ•°è¡¨)
    - [3.2. è¯¦ç»†æ§åˆ¶å‚æ•°å¯¹æ¯”](#32-è¯¦ç»†æ§åˆ¶å‚æ•°å¯¹æ¯”)
    - [3.3. PIDå‚æ•°è¯¦ç»†å¯¹æ¯”](#33-pidå‚æ•°è¯¦ç»†å¯¹æ¯”)
  - [4. åé¦ˆæ§åˆ¶å¾ªç¯çš„å®é™…åº”ç”¨](#4-åé¦ˆæ§åˆ¶å¾ªç¯çš„å®é™…åº”ç”¨)
    - [Golangå®ç°](#golangå®ç°)
      - [Pythonå®ç°](#pythonå®ç°)
      - [Rustå®ç°](#rustå®ç°)
    - [4.1. PIDæ§åˆ¶å™¨çš„å‚æ•°ä¼˜åŒ–](#41-pidæ§åˆ¶å™¨çš„å‚æ•°ä¼˜åŒ–)
      - [æ­¥éª¤1ï¼šæœ€ä¼˜æ€§å®šä¹‰](#æ­¥éª¤1æœ€ä¼˜æ€§å®šä¹‰)
      - [æ­¥éª¤2ï¼šæœ€ä¼˜å‚æ•°å­˜åœ¨æ€§](#æ­¥éª¤2æœ€ä¼˜å‚æ•°å­˜åœ¨æ€§)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜-1)
    - [4.2. åé¦ˆæ§åˆ¶çš„å®é™…åº”ç”¨](#42-åé¦ˆæ§åˆ¶çš„å®é™…åº”ç”¨)
      - [4.2.1. å‚æ•°è‡ªåŠ¨è°ƒä¼˜](#421-å‚æ•°è‡ªåŠ¨è°ƒä¼˜)
  - [5. ç›¸å…³æ–‡æ¡£](#5-ç›¸å…³æ–‡æ¡£)

---

## 1. é€šç”¨æ§åˆ¶æ–¹ç¨‹

```text
e(t) = r(t) - y(t)          # è¯¯å·®ä¿¡å·
u(t) = Kâ‚še(t) + Káµ¢âˆ«e(Ï„)dÏ„   # PIDæ§åˆ¶å™¨è¾“å‡º
Î¾(t+1) = f(Î¾(t), u(t), w(t)) # çŠ¶æ€æ›´æ–°
```

å…¶ä¸­ï¼š

- `e(t)`: è¯¯å·®ä¿¡å·
- `r(t)`: å‚è€ƒå€¼ï¼ˆæœŸæœ›å€¼ï¼‰
- `y(t)`: å®é™…è¾“å‡ºå€¼
- `u(t)`: æ§åˆ¶é‡
- `Kâ‚š`: æ¯”ä¾‹ç³»æ•°
- `Káµ¢`: ç§¯åˆ†ç³»æ•°
- `Î¾(t)`: ç³»ç»ŸçŠ¶æ€
- `w(t)`: æ‰°åŠ¨

---

## 2. PIDæ§åˆ¶å™¨

**PIDæ§åˆ¶å™¨ç»„æˆ**ï¼š

- **P (æ¯”ä¾‹é¡¹)**: $Kâ‚še(t)$ - å½“å‰è¯¯å·®çš„å“åº”
- **I (ç§¯åˆ†é¡¹)**: $Káµ¢âˆ«e(Ï„)dÏ„$ - å†å²è¯¯å·®ç´¯ç§¯
- **D (å¾®åˆ†é¡¹)**: $K_d \frac{de(t)}{dt}$ - æœªæ¥è¯¯å·®è¶‹åŠ¿é¢„æµ‹

**PIDæ§åˆ¶å™¨è¾“å‡º**ï¼š

$$
u(t) = K_p e(t) + K_i \int_0^t e(\tau) \,d\tau + K_d \frac{de(t)}{dt}
$$

### 2.1. PIDæ§åˆ¶å™¨çš„ç¨³å®šæ€§è¯æ˜

**å®šç†24**ï¼ˆPIDæ§åˆ¶å™¨ç¨³å®šæ€§ï¼‰ï¼š
å¯¹äºä¸€é˜¶ç³»ç»Ÿ $G(s) = \frac{K}{s + a}$ï¼ŒPIDæ§åˆ¶å™¨ $C(s) = K_p + \frac{K_i}{s} + K_d s$ åœ¨æ»¡è¶³ä»¥ä¸‹æ¡ä»¶æ—¶ç³»ç»Ÿç¨³å®šï¼š

$$
K_p > 0, \quad K_i > 0, \quad K_d > -\frac{1}{K}
$$

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šé—­ç¯ç³»ç»Ÿç‰¹å¾æ–¹ç¨‹

**å¼•ç†24.1**ï¼ˆç‰¹å¾æ–¹ç¨‹ï¼‰ï¼š
é—­ç¯ç³»ç»Ÿçš„ç‰¹å¾æ–¹ç¨‹ä¸ºï¼š

$$
s^2 + (a + KK_d)s + KK_p s + KK_i = 0
$$

**è¯æ˜**ï¼š
é—­ç¯ä¼ é€’å‡½æ•°ä¸ºï¼š

$$
T(s) = \frac{C(s)G(s)}{1 + C(s)G(s)} = \frac{K(K_p s + K_i + K_d s^2)}{s(s + a) + K(K_p s + K_i + K_d s^2)}
$$

ç‰¹å¾æ–¹ç¨‹ä¸ºï¼š

$$
s(s + a) + K(K_p s + K_i + K_d s^2) = 0
$$

æ•´ç†å¾—ï¼š

$$
(1 + KK_d)s^2 + (a + KK_p)s + KK_i = 0
$$

âˆ

#### æ­¥éª¤2ï¼šRouth-Hurwitzåˆ¤æ®

**å¼•ç†24.2**ï¼ˆRouth-Hurwitzåˆ¤æ®ï¼‰ï¼š
ç³»ç»Ÿç¨³å®šçš„å……è¦æ¡ä»¶æ˜¯ç‰¹å¾æ–¹ç¨‹çš„æ‰€æœ‰ç³»æ•°ä¸ºæ­£ã€‚

**è¯æ˜**ï¼š
å¯¹äºäºŒé˜¶ç³»ç»Ÿï¼ŒRouth-Hurwitzåˆ¤æ®è¦æ±‚ï¼š

- $1 + KK_d > 0$ï¼Œå³ $K_d > -\frac{1}{K}$
- $a + KK_p > 0$ï¼Œå³ $K_p > -\frac{a}{K}$ï¼ˆé€šå¸¸ $a > 0$ï¼Œå› æ­¤ $K_p > 0$ï¼‰
- $KK_i > 0$ï¼Œå³ $K_i > 0$

âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†24.1å’Œ24.2ï¼ŒPIDæ§åˆ¶å™¨åœ¨æ»¡è¶³æ¡ä»¶æ—¶ç³»ç»Ÿç¨³å®šã€‚ âˆ

- **D (å¾®åˆ†é¡¹)**: $K_d\frac{de(t)}{dt}$ - è¯¯å·®å˜åŒ–ç‡ï¼ˆå¯é€‰ï¼‰

**å®Œæ•´PIDæ–¹ç¨‹**ï¼š
$$
u(t) = Kâ‚še(t) + Káµ¢\int_0^t e(\tau)d\tau + K_d\frac{de(t)}{dt}
$$

---

## 3. ä¸‰å±‚ç³»ç»Ÿæ§åˆ¶å‚æ•°

### 3.1. åŸºç¡€æ§åˆ¶å‚æ•°è¡¨

| å±‚çº§ | å‚è€ƒå€¼ r(t) | å®é™…è¾“å‡º y(t) | æ§åˆ¶é‡ u(t) | æ§åˆ¶å‘¨æœŸ | å“åº”æ—¶é—´ |
|------|------------|--------------|------------|---------|---------|
| OSå±‚ | CPUé…é¢ | å®é™…ä½¿ç”¨ç‡ | ä¼˜å…ˆçº§è°ƒæ•´ | 1ms | <10ms |
| VMå±‚ | SLAæŒ‡æ ‡ | æ€§èƒ½è®¡æ•°å™¨ | èµ„æºçƒ­è¿ç§» | 5min | <2min |
| å®¹å™¨å±‚ | è¯·æ±‚é€Ÿç‡ | QPS | å‰¯æœ¬æ•°ä¼¸ç¼© | 15s | <1min |

### 3.2. è¯¦ç»†æ§åˆ¶å‚æ•°å¯¹æ¯”

| å‚æ•°ç±»å‹ | OSå±‚ | VMå±‚ | å®¹å™¨å±‚ | ç»Ÿä¸€æŠ½è±¡ | æ•°å­¦è¡¨è¾¾ |
|---------|------|------|--------|---------|---------|
| **å‚è€ƒå€¼** | CPUé…é¢ (0-1) | SLAæŒ‡æ ‡ (å¯ç”¨æ€§>99.9%) | è¯·æ±‚é€Ÿç‡ (QPS) | `setpoint` | $r(t) \in \mathbb{R}$ |
| **å®é™…è¾“å‡º** | CPUä½¿ç”¨ç‡ | æ€§èƒ½è®¡æ•°å™¨ | QPS | `current_value` | $y(t) \in \mathbb{R}$ |
| **æ§åˆ¶é‡** | ä¼˜å…ˆçº§è°ƒæ•´ | èµ„æºçƒ­è¿ç§» | å‰¯æœ¬æ•°ä¼¸ç¼© | `control_output` | $u(t) \in \mathbb{R}^m$ |
| **è¯¯å·®ä¿¡å·** | $e = quota - usage$ | $e = SLA - actual$ | $e = target - current$ | `error` | $e(t) = r(t) - y(t)$ |

### 3.3. PIDå‚æ•°è¯¦ç»†å¯¹æ¯”

| ç³»ç»Ÿ | $K_p$ | $K_i$ | $K_d$ | è°ƒä¼˜æ–¹æ³• | æ•ˆæœ |
|------|-------|-------|-------|---------|------|
| **Linux CFS** | 1.0 | 0.1 | 0.05 | ç»éªŒè°ƒä¼˜ | å“åº”æ—¶é—´ < 10ms |
| **Kubernetes HPA** | 2.0 | 0.5 | 0.1 | Ziegler-Nichols | å‰¯æœ¬æ•°ç¨³å®šåœ¨ç›®æ ‡å€¼Â±5% |
| **vSphere DRS** | 1.5 | 0.3 | 0.2 | è‡ªé€‚åº”è°ƒä¼˜ | è´Ÿè½½å‡è¡¡åº¦ > 90% |
| **Docker Swarm** | 1.2 | 0.4 | 0.15 | ç»éªŒè°ƒä¼˜ | æœåŠ¡å¯ç”¨æ€§ > 99% |

**æ§åˆ¶ç›®æ ‡**ï¼š

- **OSå±‚**: ç»´æŒCPUä½¿ç”¨ç‡åœ¨é…é¢èŒƒå›´å†…ï¼Œå“åº”å¿«é€Ÿ
- **VMå±‚**: æ»¡è¶³SLAè¦æ±‚ï¼ˆå¯ç”¨æ€§ã€æ€§èƒ½ï¼‰ï¼Œä¿è¯ç¨³å®šæ€§
- **å®¹å™¨å±‚**: ç»´æŒQPSåœ¨ç›®æ ‡èŒƒå›´å†…ï¼Œå‡å°‘æŒ¯è¡

**æ§åˆ¶å‚æ•°é€‰æ‹©**ï¼š

- **æ¯”ä¾‹ç³»æ•°** $K_p$ï¼šå†³å®šå¯¹å½“å‰è¯¯å·®çš„å“åº”é€Ÿåº¦
  - OSå±‚ï¼š$K_p$ è¾ƒå¤§ï¼ˆ1.0-2.0ï¼‰ï¼Œå“åº”å¿«é€Ÿ
  - VMå±‚ï¼š$K_p$ ä¸­ç­‰ï¼ˆ1.0-1.5ï¼‰ï¼Œå¹³è¡¡å“åº”å’Œç¨³å®šæ€§
  - å®¹å™¨å±‚ï¼š$K_p$ è¾ƒå¤§ï¼ˆ1.5-2.0ï¼‰ï¼Œå¿«é€Ÿå“åº”è´Ÿè½½å˜åŒ–
- **ç§¯åˆ†ç³»æ•°** $K_i$ï¼šæ¶ˆé™¤ç¨³æ€è¯¯å·®ï¼Œä½†å¯èƒ½å¼•èµ·æŒ¯è¡
  - OSå±‚ï¼š$K_i$ è¾ƒå°ï¼ˆ0.05-0.1ï¼‰ï¼Œé¿å…è¿‡åº¦è°ƒæ•´
  - VMå±‚ï¼š$K_i$ è¾ƒå¤§ï¼ˆ0.3-0.5ï¼‰ï¼Œä¿è¯SLA
  - å®¹å™¨å±‚ï¼š$K_i$ ä¸­ç­‰ï¼ˆ0.3-0.5ï¼‰ï¼Œå¹³è¡¡ç¨³æ€ç²¾åº¦å’Œç¨³å®šæ€§
- **å¾®åˆ†ç³»æ•°** $K_d$ï¼šé¢„æµ‹æœªæ¥è¯¯å·®è¶‹åŠ¿ï¼Œæé«˜ç¨³å®šæ€§
  - OSå±‚ï¼š$K_d$ è¾ƒå°ï¼ˆ0.05-0.1ï¼‰ï¼Œå¿«é€Ÿå“åº”ä¼˜å…ˆ
  - VMå±‚ï¼š$K_d$ ä¸­ç­‰ï¼ˆ0.1-0.2ï¼‰ï¼Œæé«˜ç¨³å®šæ€§
  - å®¹å™¨å±‚ï¼š$K_d$ è¾ƒå¤§ï¼ˆ0.1-0.2ï¼‰ï¼Œå‡å°‘æŒ¯è¡

**å‚æ•°è°ƒä¼˜æ–¹æ³•**ï¼š

1. **Ziegler-Nicholsæ–¹æ³•**ï¼š
   - é€æ­¥å¢åŠ $K_p$ç›´åˆ°ç³»ç»ŸæŒ¯è¡
   - è®°å½•ä¸´ç•Œå¢ç›Š$K_u$å’Œä¸´ç•Œå‘¨æœŸ$T_u$
   - è®¡ç®—ï¼š$K_p = 0.6K_u$, $K_i = 1.2K_u/T_u$, $K_d = 3K_uT_u/40$

2. **ç»éªŒæ³•åˆ™**ï¼š
   - æ ¹æ®ç³»ç»Ÿå“åº”ç‰¹æ€§é€‰æ‹©åˆå§‹å‚æ•°
   - é€æ­¥è°ƒæ•´ç›´åˆ°è¾¾åˆ°æœŸæœ›æ€§èƒ½

3. **è‡ªé€‚åº”è°ƒä¼˜**ï¼š
   - æ ¹æ®ç³»ç»Ÿè´Ÿè½½åŠ¨æ€è°ƒæ•´å‚æ•°
   - ä½¿ç”¨æœºå™¨å­¦ä¹ æ–¹æ³•ä¼˜åŒ–å‚æ•°

---

## 4. åé¦ˆæ§åˆ¶å¾ªç¯çš„å®é™…åº”ç”¨

**åº”ç”¨åœºæ™¯**ï¼š

1. **CPUé™æµ**ï¼šå½“CPUä½¿ç”¨ç‡è¶…è¿‡é˜ˆå€¼æ—¶ï¼Œé™ä½ä¼˜å…ˆçº§æˆ–é™åˆ¶é…é¢
2. **å†…å­˜å›æ”¶**ï¼šå½“å†…å­˜å‹åŠ›é«˜æ—¶ï¼Œè§¦å‘OOM Killeræˆ–å®¹å™¨é©±é€
3. **è´Ÿè½½å‡è¡¡**ï¼šæ ¹æ®èŠ‚ç‚¹è´Ÿè½½åŠ¨æ€è°ƒæ•´Podåˆ†å¸ƒ

**æ§åˆ¶æ•ˆæœ**ï¼š

- æé«˜ç³»ç»Ÿç¨³å®šæ€§
- ä¿è¯æœåŠ¡è´¨é‡ï¼ˆQoSï¼‰
- ä¼˜åŒ–èµ„æºåˆ©ç”¨ç‡

**å®é™…ç³»ç»Ÿå®ç°**ï¼š

| ç³»ç»Ÿ | æ§åˆ¶ç›®æ ‡ | PIDå‚æ•° | æ•ˆæœ |
|------|---------|---------|------|
| Linux CFS | CPUé…é¢ | Kp=1.0, Ki=0.1 | å“åº”æ—¶é—´ < 10ms |
| Kubernetes HPA | Podå‰¯æœ¬æ•° | Kp=2.0, Ki=0.5 | å‰¯æœ¬æ•°ç¨³å®šåœ¨ç›®æ ‡å€¼Â±5% |
| vSphere DRS | ä¸»æœºè´Ÿè½½ | Kp=1.5, Ki=0.3 | è´Ÿè½½å‡è¡¡åº¦ > 90% |

**å‚æ•°è°ƒä¼˜æ–¹æ³•**ï¼š

1. **Ziegler-Nicholsæ–¹æ³•**ï¼šé€æ­¥å¢åŠ Kpç›´åˆ°ç³»ç»ŸæŒ¯è¡ï¼Œç„¶åè°ƒæ•´Kiå’ŒKd
2. **ç»éªŒæ³•åˆ™**ï¼šæ ¹æ®ç³»ç»Ÿå“åº”ç‰¹æ€§é€‰æ‹©åˆå§‹å‚æ•°
3. **è‡ªé€‚åº”è°ƒä¼˜**ï¼šæ ¹æ®ç³»ç»Ÿè´Ÿè½½åŠ¨æ€è°ƒæ•´å‚æ•°

**å·¥ç¨‹å®ç°ç¤ºä¾‹**ï¼š

### Golangå®ç°

```go
package control

import (
    "math"
    "sync"
    "time"
)

// PIDæ§åˆ¶å™¨
type PIDController struct {
    kp        float64 // æ¯”ä¾‹ç³»æ•°
    ki        float64 // ç§¯åˆ†ç³»æ•°
    kd        float64 // å¾®åˆ†ç³»æ•°
    setpoint  float64 // ç›®æ ‡å€¼
    integral  float64 // ç§¯åˆ†ç´¯ç§¯
    lastError float64 // ä¸Šæ¬¡è¯¯å·®
    lastTime  time.Time
    mu        sync.Mutex
}

func NewPIDController(kp, ki, kd, setpoint float64) *PIDController {
    return &PIDController{
        kp:       kp,
        ki:       ki,
        kd:       kd,
        setpoint: setpoint,
        lastTime: time.Now(),
    }
}

// æ›´æ–°æ§åˆ¶é‡
func (pid *PIDController) Update(currentValue float64) float64 {
    pid.mu.Lock()
    defer pid.mu.Unlock()

    now := time.Now()
    dt := now.Sub(pid.lastTime).Seconds()
    if dt <= 0 {
        dt = 1.0
    }
    pid.lastTime = now

    // è®¡ç®—è¯¯å·®
    error := pid.setpoint - currentValue

    // æ¯”ä¾‹é¡¹
    pTerm := pid.kp * error

    // ç§¯åˆ†é¡¹ï¼ˆå¸¦æŠ—é¥±å’Œï¼‰
    pid.integral += error * dt
    // ç§¯åˆ†é™å¹…
    maxIntegral := 100.0
    if pid.integral > maxIntegral {
        pid.integral = maxIntegral
    } else if pid.integral < -maxIntegral {
        pid.integral = -maxIntegral
    }
    iTerm := pid.ki * pid.integral

    // å¾®åˆ†é¡¹
    dError := (error - pid.lastError) / dt
    dTerm := pid.kd * dError
    pid.lastError = error

    // PIDè¾“å‡º
    output := pTerm + iTerm + dTerm

    return output
}

// CPUé…é¢æ§åˆ¶å™¨
type CPUQuotaController struct {
    pid         *PIDController
    currentQuota float64
    mu          sync.RWMutex
}

func NewCPUQuotaController(targetUsage float64) *CPUQuotaController {
    return &CPUQuotaController{
        pid:         NewPIDController(1.0, 0.1, 0.05, targetUsage),
        currentQuota: 1.0,
    }
}

// æ ¹æ®å½“å‰ä½¿ç”¨ç‡è°ƒæ•´CPUé…é¢
func (c *CPUQuotaController) AdjustQuota(currentUsage float64) float64 {
    adjustment := c.pid.Update(currentUsage)

    c.mu.Lock()
    defer c.mu.Unlock()

    // é™å¹…ï¼šé…é¢åœ¨[0.1, 1.0]èŒƒå›´å†…
    c.currentQuota = math.Max(0.1, math.Min(1.0, c.currentQuota+adjustment*0.01))

    return c.currentQuota
}

// Kubernetes HPAæ§åˆ¶å™¨
type HPAController struct {
    pid         *PIDController
    currentReplicas int
    minReplicas     int
    maxReplicas     int
    mu          sync.RWMutex
}

func NewHPAController(targetQPS float64, minReplicas, maxReplicas int) *HPAController {
    return &HPAController{
        pid:           NewPIDController(2.0, 0.5, 0.1, targetQPS),
        currentReplicas: minReplicas,
        minReplicas:     minReplicas,
        maxReplicas:     maxReplicas,
    }
}

// æ ¹æ®å½“å‰QPSè°ƒæ•´å‰¯æœ¬æ•°
func (h *HPAController) AdjustReplicas(currentQPS float64) int {
    adjustment := h.pid.Update(currentQPS)

    h.mu.Lock()
    defer h.mu.Unlock()

    // è®¡ç®—æ–°å‰¯æœ¬æ•°
    newReplicas := h.currentReplicas + int(math.Round(adjustment))

    // é™å¹…
    if newReplicas < h.minReplicas {
        newReplicas = h.minReplicas
    } else if newReplicas > h.maxReplicas {
        newReplicas = h.maxReplicas
    }

    h.currentReplicas = newReplicas
    return newReplicas
}

// vSphere DRSè´Ÿè½½å‡è¡¡æ§åˆ¶å™¨
type DRSController struct {
    pid         *PIDController
    currentLoad float64
    mu          sync.RWMutex
}

func NewDRSController(targetLoad float64) *DRSController {
    return &DRSController{
        pid:         NewPIDController(1.5, 0.3, 0.2, targetLoad),
        currentLoad: targetLoad,
    }
}

// æ ¹æ®å½“å‰è´Ÿè½½è°ƒæ•´èµ„æºåˆ†é…
func (d *DRSController) AdjustLoad(currentLoad float64) float64 {
    adjustment := d.pid.Update(currentLoad)

    d.mu.Lock()
    defer d.mu.Unlock()

    // è´Ÿè½½è°ƒæ•´ï¼ˆé€šè¿‡è¿ç§»VMï¼‰
    d.currentLoad += adjustment * 0.1

    return d.currentLoad
}
```

#### Pythonå®ç°

```python
import threading
import time
from typing import Optional
import numpy as np

class PIDController:
    """PIDæ§åˆ¶å™¨"""
    def __init__(self, kp: float, ki: float, kd: float, setpoint: float = 0.0):
        self.kp = kp  # æ¯”ä¾‹ç³»æ•°
        self.ki = ki  # ç§¯åˆ†ç³»æ•°
        self.kd = kd  # å¾®åˆ†ç³»æ•°
        self.setpoint = setpoint  # ç›®æ ‡å€¼
        self.integral = 0.0  # ç§¯åˆ†ç´¯ç§¯
        self.last_error = 0.0  # ä¸Šæ¬¡è¯¯å·®
        self.last_time = time.time()
        self._lock = threading.Lock()

    def update(self, current_value: float) -> float:
        """æ›´æ–°æ§åˆ¶é‡"""
        with self._lock:
            now = time.time()
            dt = now - self.last_time
            if dt <= 0:
                dt = 1.0
            self.last_time = now

            # è®¡ç®—è¯¯å·®
            error = self.setpoint - current_value

            # æ¯”ä¾‹é¡¹
            p_term = self.kp * error

            # ç§¯åˆ†é¡¹ï¼ˆå¸¦æŠ—é¥±å’Œï¼‰
            self.integral += error * dt
            # ç§¯åˆ†é™å¹…
            max_integral = 100.0
            self.integral = max(-max_integral, min(max_integral, self.integral))
            i_term = self.ki * self.integral

            # å¾®åˆ†é¡¹
            d_error = (error - self.last_error) / dt
            d_term = self.kd * d_error
            self.last_error = error

            # PIDè¾“å‡º
            output = p_term + i_term + d_term

            return output

    def reset(self):
        """é‡ç½®æ§åˆ¶å™¨"""
        with self._lock:
            self.integral = 0.0
            self.last_error = 0.0
            self.last_time = time.time()

class CPUQuotaController:
    """CPUé…é¢æ§åˆ¶å™¨"""
    def __init__(self, target_usage: float = 0.8):
        self.pid = PIDController(kp=1.0, ki=0.1, kd=0.05, setpoint=target_usage)
        self.current_quota = 1.0
        self._lock = threading.Lock()

    def adjust_quota(self, current_usage: float) -> float:
        """æ ¹æ®å½“å‰ä½¿ç”¨ç‡è°ƒæ•´CPUé…é¢"""
        adjustment = self.pid.update(current_usage)

        with self._lock:
            # é™å¹…ï¼šé…é¢åœ¨[0.1, 1.0]èŒƒå›´å†…
            self.current_quota = max(0.1, min(1.0, self.current_quota + adjustment * 0.01))
            return self.current_quota

class HPAController:
    """Kubernetes HPAæ§åˆ¶å™¨"""
    def __init__(self, target_qps: float, min_replicas: int = 1, max_replicas: int = 10):
        self.pid = PIDController(kp=2.0, ki=0.5, kd=0.1, setpoint=target_qps)
        self.current_replicas = min_replicas
        self.min_replicas = min_replicas
        self.max_replicas = max_replicas
        self._lock = threading.Lock()

    def adjust_replicas(self, current_qps: float) -> int:
        """æ ¹æ®å½“å‰QPSè°ƒæ•´å‰¯æœ¬æ•°"""
        adjustment = self.pid.update(current_qps)

        with self._lock:
            # è®¡ç®—æ–°å‰¯æœ¬æ•°
            new_replicas = self.current_replicas + int(round(adjustment))

            # é™å¹…
            new_replicas = max(self.min_replicas, min(self.max_replicas, new_replicas))

            self.current_replicas = new_replicas
            return new_replicas

class DRSController:
    """vSphere DRSè´Ÿè½½å‡è¡¡æ§åˆ¶å™¨"""
    def __init__(self, target_load: float = 0.7):
        self.pid = PIDController(kp=1.5, ki=0.3, kd=0.2, setpoint=target_load)
        self.current_load = target_load
        self._lock = threading.Lock()

    def adjust_load(self, current_load: float) -> float:
        """æ ¹æ®å½“å‰è´Ÿè½½è°ƒæ•´èµ„æºåˆ†é…"""
        adjustment = self.pid.update(current_load)

        with self._lock:
            # è´Ÿè½½è°ƒæ•´ï¼ˆé€šè¿‡è¿ç§»VMï¼‰
            self.current_load += adjustment * 0.1
            return self.current_load

# Ziegler-Nicholså‚æ•°è°ƒä¼˜æ–¹æ³•
def ziegler_nichols_tuning(ku: float, tu: float) -> tuple:
    """
    Ziegler-Nicholsæ–¹æ³•è°ƒä¼˜PIDå‚æ•°
    ku: ä¸´ç•Œå¢ç›Šï¼ˆç³»ç»Ÿå¼€å§‹æŒ¯è¡æ—¶çš„å¢ç›Šï¼‰
    tu: ä¸´ç•Œå‘¨æœŸï¼ˆæŒ¯è¡å‘¨æœŸï¼‰
    """
    kp = 0.6 * ku
    ki = 1.2 * ku / tu
    kd = 3 * ku * tu / 40
    return kp, ki, kd
```

#### Rustå®ç°

```rust
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

pub struct PIDController {
    kp: f64,
    ki: f64,
    kd: f64,
    setpoint: f64,
    integral: Arc<Mutex<f64>>,
    last_error: Arc<Mutex<f64>>,
    last_time: Arc<Mutex<Instant>>,
}

impl PIDController {
    pub fn new(kp: f64, ki: f64, kd: f64, setpoint: f64) -> Self {
        PIDController {
            kp,
            ki,
            kd,
            setpoint,
            integral: Arc::new(Mutex::new(0.0)),
            last_error: Arc::new(Mutex::new(0.0)),
            last_time: Arc::new(Mutex::new(Instant::now())),
        }
    }

    pub fn update(&self, current_value: f64) -> f64 {
        let now = Instant::now();
        let dt = {
            let last_time = self.last_time.lock().unwrap();
            now.duration_since(*last_time).as_secs_f64().max(0.001)
        };
        *self.last_time.lock().unwrap() = now;

        // è®¡ç®—è¯¯å·®
        let error = self.setpoint - current_value;

        // æ¯”ä¾‹é¡¹
        let p_term = self.kp * error;

        // ç§¯åˆ†é¡¹ï¼ˆå¸¦æŠ—é¥±å’Œï¼‰
        let mut integral = self.integral.lock().unwrap();
        *integral += error * dt;
        let max_integral = 100.0;
        *integral = integral.max(-max_integral).min(max_integral);
        let i_term = self.ki * *integral;
        drop(integral);

        // å¾®åˆ†é¡¹
        let mut last_error = self.last_error.lock().unwrap();
        let d_error = (error - *last_error) / dt;
        let d_term = self.kd * d_error;
        *last_error = error;
        drop(last_error);

        // PIDè¾“å‡º
        p_term + i_term + d_term
    }

    pub fn reset(&self) {
        *self.integral.lock().unwrap() = 0.0;
        *self.last_error.lock().unwrap() = 0.0;
        *self.last_time.lock().unwrap() = Instant::now();
    }
}

pub struct CPUQuotaController {
    pid: PIDController,
    current_quota: Arc<Mutex<f64>>,
}

impl CPUQuotaController {
    pub fn new(target_usage: f64) -> Self {
        CPUQuotaController {
            pid: PIDController::new(1.0, 0.1, 0.05, target_usage),
            current_quota: Arc::new(Mutex::new(1.0)),
        }
    }

    pub fn adjust_quota(&self, current_usage: f64) -> f64 {
        let adjustment = self.pid.update(current_usage);

        let mut quota = self.current_quota.lock().unwrap();
        // é™å¹…ï¼šé…é¢åœ¨[0.1, 1.0]èŒƒå›´å†…
        *quota = (*quota + adjustment * 0.01).max(0.1).min(1.0);
        *quota
    }
}

pub struct HPAController {
    pid: PIDController,
    current_replicas: Arc<Mutex<i32>>,
    min_replicas: i32,
    max_replicas: i32,
}

impl HPAController {
    pub fn new(target_qps: f64, min_replicas: i32, max_replicas: i32) -> Self {
        HPAController {
            pid: PIDController::new(2.0, 0.5, 0.1, target_qps),
            current_replicas: Arc::new(Mutex::new(min_replicas)),
            min_replicas,
            max_replicas,
        }
    }

    pub fn adjust_replicas(&self, current_qps: f64) -> i32 {
        let adjustment = self.pid.update(current_qps);

        let mut replicas = self.current_replicas.lock().unwrap();
        let new_replicas = *replicas + adjustment.round() as i32;
        *replicas = new_replicas.max(self.min_replicas).min(self.max_replicas);
        *replicas
    }
}
```

**åé¦ˆæ§åˆ¶å¾ªç¯çš„å®é™…ä»·å€¼**ï¼š

- **ç¨³å®šæ€§ä¿è¯**ï¼šPIDæ§åˆ¶å™¨ä¿è¯äº†ç³»ç»Ÿçš„ç¨³å®šæ€§
- **å“åº”é€Ÿåº¦**ï¼šæ¯”ä¾‹é¡¹æä¾›å¿«é€Ÿå“åº”
- **ç¨³æ€ç²¾åº¦**ï¼šç§¯åˆ†é¡¹æ¶ˆé™¤ç¨³æ€è¯¯å·®
- **é¢„æµ‹æ€§**ï¼šå¾®åˆ†é¡¹é¢„æµ‹æœªæ¥è¶‹åŠ¿

### 4.1. PIDæ§åˆ¶å™¨çš„å‚æ•°ä¼˜åŒ–

**å®šç†75**ï¼ˆPIDå‚æ•°ä¼˜åŒ–çš„æœ€ä¼˜æ€§ï¼‰ï¼š
åœ¨æ»¡è¶³ç¨³å®šæ€§æ¡ä»¶ä¸‹ï¼Œå­˜åœ¨æœ€ä¼˜PIDå‚æ•°ä½¿å¾—ç³»ç»Ÿæ€§èƒ½æœ€ä¼˜ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šæœ€ä¼˜æ€§å®šä¹‰

**å®šä¹‰**ï¼ˆæœ€ä¼˜æ€§ï¼‰ï¼š
PIDå‚æ•° $(K_p^*, K_i^*, K_d^*)$ æ˜¯æœ€ä¼˜çš„ï¼Œå½“ä¸”ä»…å½“å¯¹æ‰€æœ‰å‚æ•° $(K_p, K_i, K_d)$ï¼Œæœ‰ $J(K_p^*, K_i^*, K_d^*) \leq J(K_p, K_i, K_d)$ï¼Œå…¶ä¸­ $J$ æ˜¯æ€§èƒ½æŒ‡æ ‡ã€‚

#### æ­¥éª¤2ï¼šæœ€ä¼˜å‚æ•°å­˜åœ¨æ€§

**å¼•ç†75.1**ï¼ˆæœ€ä¼˜å‚æ•°å­˜åœ¨æ€§ï¼‰ï¼š
åœ¨æ»¡è¶³ç¨³å®šæ€§çº¦æŸä¸‹ï¼Œå­˜åœ¨æœ€ä¼˜PIDå‚æ•°ã€‚

**è¯æ˜**ï¼š
æ€§èƒ½æŒ‡æ ‡ $J$ æ˜¯è¿ç»­çš„ï¼Œç¨³å®šæ€§çº¦æŸå®šä¹‰äº†ä¸€ä¸ªç´§é›†ï¼Œå› æ­¤å­˜åœ¨æœ€ä¼˜è§£ã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†75.1ï¼Œå­˜åœ¨æœ€ä¼˜PIDå‚æ•°ã€‚ âˆ

### 4.2. åé¦ˆæ§åˆ¶çš„å®é™…åº”ç”¨

#### 4.2.1. å‚æ•°è‡ªåŠ¨è°ƒä¼˜

**åœºæ™¯**ï¼šä½¿ç”¨ä¼˜åŒ–ç®—æ³•è‡ªåŠ¨è°ƒä¼˜PIDå‚æ•°ã€‚

**æ–¹æ³•**ï¼š

1. å®šä¹‰æ€§èƒ½æŒ‡æ ‡
2. ä½¿ç”¨ä¼˜åŒ–ç®—æ³•æœç´¢æœ€ä¼˜å‚æ•°
3. éªŒè¯ç¨³å®šæ€§å’Œæ€§èƒ½

**Golangå®ç°**ï¼š

```go
package control

// PIDå‚æ•°è‡ªåŠ¨è°ƒä¼˜
func AutoTunePID(system System, target Target) (PIDParams, error) {
    // å®šä¹‰æ€§èƒ½æŒ‡æ ‡
    costFunc := func(params PIDParams) float64 {
        return evaluatePerformance(system, params, target)
    }

    // ä½¿ç”¨ä¼˜åŒ–ç®—æ³•æœç´¢æœ€ä¼˜å‚æ•°
    optimalParams := optimize(costFunc, stabilityConstraint)

    // éªŒè¯ç¨³å®šæ€§
    if !verifyStability(system, optimalParams) {
        return PIDParams{}, fmt.Errorf("unstable parameters")
    }

    return optimalParams, nil
}

// è¯„ä¼°æ€§èƒ½
func evaluatePerformance(system System, params PIDParams, target Target) float64 {
    // æ¨¡æ‹Ÿç³»ç»Ÿå“åº”
    response := simulateSystem(system, params, target)

    // è®¡ç®—æ€§èƒ½æŒ‡æ ‡ï¼ˆå¦‚ISEã€IAEç­‰ï¼‰
    ise := computeISE(response, target)
    iae := computeIAE(response, target)

    // ç»¼åˆæ€§èƒ½æŒ‡æ ‡
    return ise + 0.1*iae
}
```

**Pythonå®ç°**ï¼š

```python
from scipy.optimize import minimize

def auto_tune_pid(system: System, target: Target) -> PIDParams:
    """PIDå‚æ•°è‡ªåŠ¨è°ƒä¼˜"""
    # å®šä¹‰æ€§èƒ½æŒ‡æ ‡
    def cost_func(params: PIDParams) -> float:
        return evaluate_performance(system, params, target)

    # ä½¿ç”¨ä¼˜åŒ–ç®—æ³•æœç´¢æœ€ä¼˜å‚æ•°
    result = minimize(
        cost_func,
        x0=[1.0, 0.1, 0.01],  # åˆå§‹å‚æ•°
        method='SLSQP',
        constraints=stability_constraint,
    )

    optimal_params = PIDParams(*result.x)

    # éªŒè¯ç¨³å®šæ€§
    if not verify_stability(system, optimal_params):
        raise ValueError("Unstable parameters")

    return optimal_params

def evaluate_performance(
    system: System,
    params: PIDParams,
    target: Target,
) -> float:
    """è¯„ä¼°æ€§èƒ½"""
    # æ¨¡æ‹Ÿç³»ç»Ÿå“åº”
    response = simulate_system(system, params, target)

    # è®¡ç®—æ€§èƒ½æŒ‡æ ‡ï¼ˆå¦‚ISEã€IAEç­‰ï¼‰
    ise = compute_ise(response, target)
    iae = compute_iae(response, target)

    # ç»¼åˆæ€§èƒ½æŒ‡æ ‡
    return ise + 0.1 * iae
```

**Rustå®ç°**ï¼š

```rust
pub fn auto_tune_pid(
    system: &System,
    target: &Target,
) -> Result<PIDParams, Error> {
    // å®šä¹‰æ€§èƒ½æŒ‡æ ‡
    let cost_func = |params: &PIDParams| -> f64 {
        evaluate_performance(system, params, target)
    };

    // ä½¿ç”¨ä¼˜åŒ–ç®—æ³•æœç´¢æœ€ä¼˜å‚æ•°
    let optimal_params = optimize(cost_func, &stability_constraint)?;

    // éªŒè¯ç¨³å®šæ€§
    if !verify_stability(system, &optimal_params)? {
        return Err(Error::UnstableParameters);
    }

    Ok(optimal_params)
}

fn evaluate_performance(
    system: &System,
    params: &PIDParams,
    target: &Target,
) -> f64 {
    // æ¨¡æ‹Ÿç³»ç»Ÿå“åº”
    let response = simulate_system(system, params, target);

    // è®¡ç®—æ€§èƒ½æŒ‡æ ‡ï¼ˆå¦‚ISEã€IAEç­‰ï¼‰
    let ise = compute_ise(&response, target);
    let iae = compute_iae(&response, target);

    // ç»¼åˆæ€§èƒ½æŒ‡æ ‡
    ise + 0.1 * iae
}
```

---

## 5. ç›¸å…³æ–‡æ¡£

- [è¿”å› FormalModel ç›®å½•](../README.md)
- [04_åŠ¨æ€äº¤äº’æ¨¡å‹ README](README.md)
- [04.1_çŠ¶æ€è½¬ç§»ç³»ç»Ÿ](04.1_çŠ¶æ€è½¬ç§»ç³»ç»Ÿ.md)
- [07_ç›‘æ§ä¸åé¦ˆ](../07_ç›‘æ§ä¸åé¦ˆ/README.md)

---

**æœ€åæ›´æ–°**: 2025-01-27
