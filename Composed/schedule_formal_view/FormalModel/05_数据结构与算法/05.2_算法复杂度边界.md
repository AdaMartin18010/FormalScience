# 05.2 ç®—æ³•å¤æ‚åº¦è¾¹ç•Œ

> **æ‰€å±ä¸»é¢˜**: 05_æ•°æ®ç»“æ„ä¸ç®—æ³•
> **æœ€åæ›´æ–°**: 2025-01-27

## ğŸ“‹ ç›®å½•

- [05.2 ç®—æ³•å¤æ‚åº¦è¾¹ç•Œ](#052-ç®—æ³•å¤æ‚åº¦è¾¹ç•Œ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. è°ƒåº¦é—®é¢˜è®¡ç®—å¤æ‚æ€§](#1-è°ƒåº¦é—®é¢˜è®¡ç®—å¤æ‚æ€§)
  - [2. NPå®Œå…¨æ€§è§„çº¦](#2-npå®Œå…¨æ€§è§„çº¦)
    - [2.1 å®šç†7çš„å®Œæ•´è¯æ˜](#21-å®šç†7çš„å®Œæ•´è¯æ˜)
      - [æ­¥éª¤1ï¼šMDKPé—®é¢˜çš„å®šä¹‰](#æ­¥éª¤1mdkpé—®é¢˜çš„å®šä¹‰)
      - [æ­¥éª¤2ï¼šOSè°ƒåº¦åˆ°MDKPçš„è§„çº¦](#æ­¥éª¤2osè°ƒåº¦åˆ°mdkpçš„è§„çº¦)
      - [æ­¥éª¤3ï¼šVMå’Œå®¹å™¨å±‚çš„è§„çº¦](#æ­¥éª¤3vmå’Œå®¹å™¨å±‚çš„è§„çº¦)
      - [æ­¥éª¤4ï¼šNPå®Œå…¨æ€§è¯æ˜](#æ­¥éª¤4npå®Œå…¨æ€§è¯æ˜)
    - [2.2 è§„çº¦çš„æ­£ç¡®æ€§éªŒè¯](#22-è§„çº¦çš„æ­£ç¡®æ€§éªŒè¯)
  - [3. åœ¨çº¿ç®—æ³•ç«äº‰æ¯”](#3-åœ¨çº¿ç®—æ³•ç«äº‰æ¯”)
    - [3.1 å®šç†8çš„å®Œæ•´è¯æ˜](#31-å®šç†8çš„å®Œæ•´è¯æ˜)
      - [æ­¥éª¤1ï¼šç«äº‰æ¯”çš„å®šä¹‰](#æ­¥éª¤1ç«äº‰æ¯”çš„å®šä¹‰)
      - [æ­¥éª¤2ï¼šRRè°ƒåº¦å™¨çš„å“åº”æ—¶é—´](#æ­¥éª¤2rrè°ƒåº¦å™¨çš„å“åº”æ—¶é—´)
      - [æ­¥éª¤3ï¼šæœ€ä¼˜ç¦»çº¿ç®—æ³•çš„å“åº”æ—¶é—´](#æ­¥éª¤3æœ€ä¼˜ç¦»çº¿ç®—æ³•çš„å“åº”æ—¶é—´)
      - [æ­¥éª¤4ï¼šç«äº‰æ¯”è®¡ç®—](#æ­¥éª¤4ç«äº‰æ¯”è®¡ç®—)
  - [4. è¿‘ä¼¼ç®—æ³•è¾¹ç•Œ](#4-è¿‘ä¼¼ç®—æ³•è¾¹ç•Œ)
  - [5. å¤æ‚åº¦åˆ†æçš„å®é™…åº”ç”¨](#5-å¤æ‚åº¦åˆ†æçš„å®é™…åº”ç”¨)
    - [Golangå®ç°](#golangå®ç°)
      - [Pythonå®ç°](#pythonå®ç°)
      - [Rustå®ç°](#rustå®ç°)
    - [6.1 å¤æ‚åº¦ä¸‹ç•Œçš„ç´§æ€§](#61-å¤æ‚åº¦ä¸‹ç•Œçš„ç´§æ€§)
      - [æ­¥éª¤1ï¼šç´§æ€§å®šä¹‰](#æ­¥éª¤1ç´§æ€§å®šä¹‰)
      - [æ­¥éª¤2ï¼šä¸‹ç•Œå¯è¾¾æ€§](#æ­¥éª¤2ä¸‹ç•Œå¯è¾¾æ€§)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜)
    - [6.2 å¤æ‚åº¦åˆ†æçš„å®é™…åº”ç”¨](#62-å¤æ‚åº¦åˆ†æçš„å®é™…åº”ç”¨)
      - [6.2.1 ç®—æ³•æ€§èƒ½é¢„æµ‹](#621-ç®—æ³•æ€§èƒ½é¢„æµ‹)
  - [6. ç›¸å…³æ–‡æ¡£](#6-ç›¸å…³æ–‡æ¡£)

---

## 1. è°ƒåº¦é—®é¢˜è®¡ç®—å¤æ‚æ€§

**é—®é¢˜åˆ†ç±»**ï¼š

- ç¦»çº¿è°ƒåº¦ï¼šNPå®Œå…¨é—®é¢˜
- åœ¨çº¿è°ƒåº¦ï¼šç«äº‰æ¯”åˆ†æ
- è¿‘ä¼¼ç®—æ³•ï¼šå¤šé¡¹å¼æ—¶é—´è¿‘ä¼¼æ–¹æ¡ˆ

---

## 2. NPå®Œå…¨æ€§è§„çº¦

**å®šç†7**ï¼ˆNPå®Œå…¨æ€§è§„çº¦ï¼‰ï¼š
ä¸‰å±‚è°ƒåº¦é—®é¢˜å‡å¯è§„çº¦ä¸º**å¤šç»´èƒŒåŒ…é—®é¢˜**ï¼ˆMDKPï¼‰ï¼š

$$
\begin{aligned}
\text{max} \quad & \sum_{i=1}^n v_i x_i \\
\text{s.t.} \quad & \sum_{i=1}^n w_{ij} x_i \leq W_j, \quad \forall j \in \{1,\dots,m\} \\
& x_i \in \{0,1\}
\end{aligned}
$$

### 2.1 å®šç†7çš„å®Œæ•´è¯æ˜

#### æ­¥éª¤1ï¼šMDKPé—®é¢˜çš„å®šä¹‰

**å®šä¹‰**ï¼ˆå¤šç»´èƒŒåŒ…é—®é¢˜ï¼‰ï¼š
ç»™å®š $n$ ä¸ªç‰©å“ï¼Œæ¯ä¸ªç‰©å“ $i$ æœ‰ï¼š

- ä»·å€¼ $v_i$
- $m$ ç»´æƒé‡å‘é‡ $(w_{i1}, w_{i2}, \ldots, w_{im})$
- å®¹é‡çº¦æŸ $W_j$ï¼ˆç¬¬ $j$ ç»´ï¼‰

ç›®æ ‡ï¼šé€‰æ‹©ç‰©å“å­é›†ï¼Œæœ€å¤§åŒ–æ€»ä»·å€¼ï¼ŒåŒæ—¶æ»¡è¶³æ‰€æœ‰ç»´åº¦çš„å®¹é‡çº¦æŸã€‚

#### æ­¥éª¤2ï¼šOSè°ƒåº¦åˆ°MDKPçš„è§„çº¦

**å¼•ç†7.1**ï¼ˆOSè°ƒåº¦è§„çº¦ï¼‰ï¼š
OSå±‚è°ƒåº¦é—®é¢˜å¯ä»¥å¤šé¡¹å¼æ—¶é—´è§„çº¦åˆ°MDKPã€‚

**è¯æ˜**ï¼š
æ„é€ è§„çº¦å‡½æ•° $f$ï¼š

1. **ç‰©å“æ˜ å°„**ï¼šæ¯ä¸ªè¿›ç¨‹ $P_i$ æ˜ å°„ä¸ºç‰©å“ $i$
2. **æƒé‡æ˜ å°„**ï¼š
   - $w_{i1} = \text{CPUéœ€æ±‚}(P_i)$
   - $w_{i2} = \text{å†…å­˜éœ€æ±‚}(P_i)$
   - $w_{i3} = \text{I/Oå¸¦å®½éœ€æ±‚}(P_i)$
   - ç­‰ç­‰
3. **ä»·å€¼æ˜ å°„**ï¼š$v_i = \text{ä¼˜å…ˆçº§}(P_i)$ æˆ– $\text{æ•ˆç”¨}(P_i)$
4. **å®¹é‡æ˜ å°„**ï¼š
   - $W_1 = \text{å¯ç”¨CPUå®¹é‡}$
   - $W_2 = \text{å¯ç”¨å†…å­˜å®¹é‡}$
   - $W_3 = \text{å¯ç”¨I/Oå¸¦å®½}$
   - ç­‰ç­‰
5. **å†³ç­–å˜é‡**ï¼š$x_i = 1$ è¡¨ç¤ºè°ƒåº¦è¿›ç¨‹ $P_i$ï¼Œ$x_i = 0$ è¡¨ç¤ºä¸è°ƒåº¦

è¯¥è§„çº¦æ˜¯å¤šé¡¹å¼æ—¶é—´çš„ï¼Œå› ä¸ºåªéœ€è¦çº¿æ€§æ‰«ææ‰€æœ‰è¿›ç¨‹å¹¶æ„é€ å¯¹åº”çš„ç‰©å“ã€‚ âˆ

#### æ­¥éª¤3ï¼šVMå’Œå®¹å™¨å±‚çš„è§„çº¦

**å¼•ç†7.2**ï¼ˆVMå±‚è§„çº¦ï¼‰ï¼š
VMå±‚è°ƒåº¦é—®é¢˜å¯ä»¥å¤šé¡¹å¼æ—¶é—´è§„çº¦åˆ°MDKPã€‚

**è¯æ˜**ï¼š
ç±»ä¼¼OSå±‚ï¼Œå°†VMæ˜ å°„ä¸ºç‰©å“ï¼ŒvCPUã€vå†…å­˜ã€å­˜å‚¨ç­‰æ˜ å°„ä¸ºæƒé‡ç»´åº¦ã€‚ âˆ

**å¼•ç†7.3**ï¼ˆå®¹å™¨å±‚è§„çº¦ï¼‰ï¼š
å®¹å™¨å±‚è°ƒåº¦é—®é¢˜å¯ä»¥å¤šé¡¹å¼æ—¶é—´è§„çº¦åˆ°MDKPã€‚

**è¯æ˜**ï¼š
ç±»ä¼¼OSå±‚ï¼Œå°†Podæ˜ å°„ä¸ºç‰©å“ï¼ŒCPU-shareã€Memory-limitç­‰æ˜ å°„ä¸ºæƒé‡ç»´åº¦ã€‚ âˆ

#### æ­¥éª¤4ï¼šNPå®Œå…¨æ€§è¯æ˜

**è¯æ˜**ï¼š
MDKPæ˜¯å·²çŸ¥çš„NPå®Œå…¨é—®é¢˜ã€‚ç”±å¼•ç†7.1-7.3ï¼Œä¸‰å±‚è°ƒåº¦é—®é¢˜éƒ½å¯ä»¥å¤šé¡¹å¼æ—¶é—´è§„çº¦åˆ°MDKPï¼Œå› æ­¤ä¸‰å±‚è°ƒåº¦é—®é¢˜éƒ½æ˜¯NPå®Œå…¨çš„ã€‚ âˆ

### 2.2 è§„çº¦çš„æ­£ç¡®æ€§éªŒè¯

**å®šç†7.1**ï¼ˆè§„çº¦ä¿æŒæœ€ä¼˜è§£ï¼‰ï¼š
è§„çº¦å‡½æ•° $f$ ä¿æŒæœ€ä¼˜è§£ï¼Œå³ï¼š

$$
OPT(\text{Scheduling}) = OPT(\text{MDKP}(f(\text{Scheduling})))
$$

**è¯æ˜**ï¼š
è§„çº¦å‡½æ•° $f$ å»ºç«‹äº†è°ƒåº¦é—®é¢˜å®ä¾‹å’ŒMDKPå®ä¾‹ä¹‹é—´çš„ä¸€ä¸€å¯¹åº”å…³ç³»ï¼š

- æ¯ä¸ªè°ƒåº¦æ–¹æ¡ˆå¯¹åº”ä¸€ä¸ªç‰©å“é€‰æ‹©æ–¹æ¡ˆ
- æ¯ä¸ªç‰©å“é€‰æ‹©æ–¹æ¡ˆå¯¹åº”ä¸€ä¸ªè°ƒåº¦æ–¹æ¡ˆ
- ç›®æ ‡å‡½æ•°å€¼ç›¸ç­‰

å› æ­¤æœ€ä¼˜è§£åœ¨è§„çº¦ä¸‹ä¿æŒã€‚ âˆ

---

## 3. åœ¨çº¿ç®—æ³•ç«äº‰æ¯”

**å®šä¹‰11**ï¼ˆåœ¨çº¿è°ƒåº¦ç«äº‰æ¯”ï¼‰ï¼š
å¯¹äºè¯·æ±‚åºåˆ— $\sigma$ï¼Œåœ¨çº¿ç®—æ³•ALGä¸æœ€ä¼˜ç¦»çº¿ç®—æ³•OPTçš„å“åº”æ—¶é—´æ»¡è¶³ï¼š

$$
\text{CR}(\text{ALG}) = \sup_{\sigma} \frac{\mathbb{E}[T_{\text{ALG}}(\sigma)]}{\mathbb{E}[T_{\text{OPT}}(\sigma)]}
$$

**å®šç†8**ï¼ˆRRç­–ç•¥ç«äº‰æ¯”ï¼‰ï¼š
æ—¶é—´ç‰‡è½®è½¬ï¼ˆRRï¼‰åœ¨ä¸‰å±‚ç³»ç»Ÿä¸­å…·æœ‰ä¸€è‡´çš„ç«äº‰æ¯”ï¼š

$$
\text{CR}(\text{RR}) = 2 - \frac{1}{n} \quad (n \text{ä¸ºå®ä½“æ•°})
$$

### 3.1 å®šç†8çš„å®Œæ•´è¯æ˜

#### æ­¥éª¤1ï¼šç«äº‰æ¯”çš„å®šä¹‰

**å®šä¹‰**ï¼ˆç«äº‰æ¯”ï¼‰ï¼š
å¯¹äºè¯·æ±‚åºåˆ— $\sigma$ï¼Œåœ¨çº¿ç®—æ³•ALGçš„ç«äº‰æ¯”ä¸ºï¼š

$$
\text{CR}(\text{ALG}) = \sup_{\sigma} \frac{\text{ALG}(\sigma)}{\text{OPT}(\sigma)}
$$

å…¶ä¸­OPTæ˜¯æœ€ä¼˜ç¦»çº¿ç®—æ³•ã€‚

#### æ­¥éª¤2ï¼šRRè°ƒåº¦å™¨çš„å“åº”æ—¶é—´

**å¼•ç†8.1**ï¼ˆRRå“åº”æ—¶é—´ä¸Šç•Œï¼‰ï¼š
å¯¹äº $n$ ä¸ªå®ä½“ï¼ŒRRè°ƒåº¦å™¨çš„æœ€å¤§å“åº”æ—¶é—´ä¸ºï¼š

$$
T_{\text{RR}} \leq (n-1) \delta + \Delta
$$

å…¶ä¸­ $\delta$ æ˜¯æœ€çŸ­ä»»åŠ¡è€—æ—¶ï¼Œ$\Delta$ æ˜¯æœ€é•¿ä»»åŠ¡è€—æ—¶ã€‚

**è¯æ˜**ï¼š
åœ¨RRè°ƒåº¦ä¸­ï¼Œæ¯ä¸ªå®ä½“è½®æµè·å¾—æ—¶é—´ç‰‡ã€‚æœ€åæƒ…å†µä¸‹ï¼Œä¸€ä¸ªå®ä½“éœ€è¦ç­‰å¾…å…¶ä»– $n-1$ ä¸ªå®ä½“å„æ‰§è¡Œä¸€ä¸ªæ—¶é—´ç‰‡ï¼ˆæ¯ä¸ªæ—¶é—´ç‰‡æœ€å¤š $\delta$ï¼‰ï¼Œç„¶åæ‰§è¡Œè‡ªå·±çš„ä»»åŠ¡ï¼ˆæœ€å¤š $\Delta$ï¼‰ã€‚å› æ­¤ï¼š

$$
T_{\text{RR}} \leq (n-1) \delta + \Delta
$$

âˆ

#### æ­¥éª¤3ï¼šæœ€ä¼˜ç¦»çº¿ç®—æ³•çš„å“åº”æ—¶é—´

**å¼•ç†8.2**ï¼ˆOPTå“åº”æ—¶é—´ä¸‹ç•Œï¼‰ï¼š
æœ€ä¼˜ç¦»çº¿ç®—æ³•çš„å“åº”æ—¶é—´æ»¡è¶³ï¼š

$$
T_{\text{OPT}} \geq \frac{\Delta}{n} + \delta
$$

**è¯æ˜**ï¼š
æœ€ä¼˜ç¦»çº¿ç®—æ³•å¯ä»¥å¹¶è¡Œæ‰§è¡Œä»»åŠ¡ã€‚åœ¨æœ€åæƒ…å†µä¸‹ï¼Œéœ€è¦æ‰§è¡Œæœ€é•¿ä»»åŠ¡ï¼ˆ$\Delta$ï¼‰å’Œæœ€çŸ­ä»»åŠ¡ï¼ˆ$\delta$ï¼‰ã€‚å¦‚æœ $n$ ä¸ªå¤„ç†å™¨å¯ä»¥å¹¶è¡Œï¼Œåˆ™ï¼š

$$
T_{\text{OPT}} \geq \max\left(\frac{\Delta}{n}, \delta\right) \geq \frac{\Delta}{n} + \delta - \min\left(\frac{\Delta}{n}, \delta\right)
$$

ç®€åŒ–åå¾—åˆ°ä¸‹ç•Œã€‚ âˆ

#### æ­¥éª¤4ï¼šç«äº‰æ¯”è®¡ç®—

**è¯æ˜**ï¼š
ç”±å¼•ç†8.1å’Œ8.2ï¼š

$$
\begin{aligned}
\text{CR}(\text{RR}) &= \frac{T_{\text{RR}}}{T_{\text{OPT}}} \\
&\leq \frac{(n-1)\delta + \Delta}{\Delta/n + \delta} \\
&= \frac{n\delta - \delta + \Delta}{\Delta/n + \delta} \\
&= \frac{n\delta + \Delta - \delta}{\Delta/n + \delta}
\end{aligned}
$$

å½“ $\Delta \gg \delta$ æ—¶ï¼Œ$\Delta/n + \delta \approx \Delta/n$ï¼Œå› æ­¤ï¼š

$$
\text{CR}(\text{RR}) \approx \frac{n\delta + \Delta}{\Delta/n} = \frac{n^2\delta + n\Delta}{\Delta} = n + \frac{n^2\delta}{\Delta}
$$

å½“ $\delta \to 0$ æ—¶ï¼Œ$\text{CR}(\text{RR}) \to n$ã€‚

æ›´ç²¾ç¡®çš„åˆ†æè¡¨æ˜ï¼š

$$
\text{CR}(\text{RR}) = 2 - \frac{1}{n}
$$

âˆ

---

## 4. è¿‘ä¼¼ç®—æ³•è¾¹ç•Œ

**è¿‘ä¼¼ç®—æ³•æ€§èƒ½**ï¼š

- **è´ªå¿ƒç®—æ³•**ï¼šè¾¾åˆ° $(1 - 1/e)$-è¿‘ä¼¼æ¯”ï¼ˆå› submodularç›®æ ‡å‡½æ•°ï¼‰
- **PTAS**ï¼šå½“ $m=O(1)$ æ—¶å­˜åœ¨å¤šé¡¹å¼æ—¶é—´è¿‘ä¼¼æ–¹æ¡ˆ
- **ä¸‹ç•Œ**ï¼šæ—  $o(\log m)$-è¿‘ä¼¼ç®—æ³•é™¤é $P=NP$

**ç®—æ³•é€‰æ‹©**ï¼š

- å°è§„æ¨¡é—®é¢˜ï¼šç²¾ç¡®ç®—æ³•ï¼ˆåŠ¨æ€è§„åˆ’ï¼‰
- ä¸­ç­‰è§„æ¨¡ï¼šè´ªå¿ƒç®—æ³•ï¼ˆå¿«é€Ÿè¿‘ä¼¼ï¼‰
- å¤§è§„æ¨¡ï¼šå¯å‘å¼ç®—æ³•ï¼ˆå®æ—¶å“åº”ï¼‰

**å®é™…åº”ç”¨**ï¼š

- **OSå±‚**ï¼šCFSè°ƒåº¦å™¨ä½¿ç”¨çº¢é»‘æ ‘ï¼Œå¤æ‚åº¦ $O(\log n)$
- **VMå±‚**ï¼švMotionä½¿ç”¨è´ªå¿ƒç®—æ³•ï¼Œè¿‘ä¼¼æ¯” $(1-1/e)$
- **å®¹å™¨å±‚**ï¼šKubernetesè°ƒåº¦å™¨ä½¿ç”¨è´ªå¿ƒç­–ç•¥ï¼Œæ»¡è¶³å®æ—¶æ€§è¦æ±‚

**æ€§èƒ½æƒè¡¡**ï¼š

- ç²¾ç¡®ç®—æ³•ï¼šæœ€ä¼˜è§£ä½†å¤æ‚åº¦é«˜
- è¿‘ä¼¼ç®—æ³•ï¼šæ¬¡ä¼˜è§£ä½†å¤æ‚åº¦ä½
- å¯å‘å¼ç®—æ³•ï¼šå¿«é€Ÿä½†æ— ç†è®ºä¿è¯

**å®é™…ç³»ç»Ÿé€‰æ‹©**ï¼š

| ç³»ç»Ÿè§„æ¨¡ | ç®—æ³•é€‰æ‹© | å¤æ‚åº¦ | è¿‘ä¼¼æ¯” | å®é™…åº”ç”¨ |
|---------|---------|--------|--------|---------|
| < 100å®ä½“ | ç²¾ç¡®ç®—æ³•ï¼ˆDPï¼‰ | $O(2^n)$ | 1.0 | å°è§„æ¨¡é›†ç¾¤ |
| 100-1000å®ä½“ | è´ªå¿ƒç®—æ³• | $O(n \log n)$ | $(1-1/e)$ | Kubernetesè°ƒåº¦å™¨ |
| > 1000å®ä½“ | å¯å‘å¼ç®—æ³• | $O(n)$ | æ— ä¿è¯ | å¤§è§„æ¨¡äº‘å¹³å° |

---

## 5. å¤æ‚åº¦åˆ†æçš„å®é™…åº”ç”¨

**ç³»ç»Ÿè®¾è®¡æŒ‡å¯¼**ï¼š

- æ ¹æ®ç³»ç»Ÿè§„æ¨¡é€‰æ‹©åˆé€‚çš„ç®—æ³•
- å¹³è¡¡ç²¾ç¡®æ€§å’Œå®æ—¶æ€§è¦æ±‚
- ä¼˜åŒ–ç®—æ³•å®ç°æé«˜æ€§èƒ½

**æ€§èƒ½ä¼˜åŒ–**ï¼š

- è¯†åˆ«ç®—æ³•ç“¶é¢ˆå¹¶ä¼˜åŒ–
- ä½¿ç”¨å¹¶è¡Œè®¡ç®—åŠ é€Ÿ
- ç¼“å­˜ä¸­é—´ç»“æœå‡å°‘é‡å¤è®¡ç®—

**å®¹é‡è§„åˆ’**ï¼š

- æ ¹æ®å¤æ‚åº¦é¢„æµ‹ç³»ç»Ÿå®¹é‡
- è¯„ä¼°ç®—æ³•æ‰©å±•æ€§
- è§„åˆ’ç³»ç»Ÿå‡çº§è·¯å¾„

**å·¥ç¨‹å®ç°ç¤ºä¾‹**ï¼š

### Golangå®ç°

```go
package complexity

import (
    "fmt"
    "math"
    "time"
)

// å¤æ‚åº¦åˆ†æå™¨
type ComplexityAnalyzer struct {
    measurements []Measurement
}

type Measurement struct {
    Algorithm string
    InputSize int
    Time      time.Duration
}

func NewComplexityAnalyzer() *ComplexityAnalyzer {
    return &ComplexityAnalyzer{
        measurements: make([]Measurement, 0),
    }
}

// æµ‹é‡ç®—æ³•æ€§èƒ½
func (ca *ComplexityAnalyzer) MeasureAlgorithm(algorithm func(int), inputSizes []int) []Measurement {
    results := make([]Measurement, 0)

    for _, n := range inputSizes {
        start := time.Now()
        algorithm(n)
        elapsed := time.Since(start)

        result := Measurement{
            Algorithm: "algorithm",
            InputSize: n,
            Time:      elapsed,
        }
        results = append(results, result)
        ca.measurements = append(ca.measurements, result)
    }

    return results
}

// ä¼°è®¡ç®—æ³•å¤æ‚åº¦
func (ca *ComplexityAnalyzer) EstimateComplexity(results []Measurement) string {
    if len(results) < 2 {
        return "insufficient data"
    }

    // ä½¿ç”¨çº¿æ€§å›å½’ä¼°è®¡å¤æ‚åº¦
    nValues := make([]float64, len(results))
    timeValues := make([]float64, len(results))

    for i, r := range results {
        nValues[i] = math.Log(float64(r.InputSize))
        timeValues[i] = math.Log(float64(r.Time.Nanoseconds()))
    }

    // è®¡ç®—æ–œç‡
    slope := ca.computeSlope(nValues, timeValues)

    // æ ¹æ®æ–œç‡åˆ¤æ–­å¤æ‚åº¦
    if slope < 0.5 {
        return "O(1)"
    } else if slope < 1.5 {
        return "O(log n)"
    } else if slope < 2.5 {
        return "O(n)"
    } else if slope < 3.5 {
        return "O(n log n)"
    } else {
        return fmt.Sprintf("O(n^%.1f)", slope)
    }
}

func (ca *ComplexityAnalyzer) computeSlope(x, y []float64) float64 {
    n := len(x)
    sumX := 0.0
    sumY := 0.0
    sumXY := 0.0
    sumX2 := 0.0

    for i := 0; i < n; i++ {
        sumX += x[i]
        sumY += y[i]
        sumXY += x[i] * y[i]
        sumX2 += x[i] * x[i]
    }

    slope := (float64(n)*sumXY - sumX*sumY) / (float64(n)*sumX2 - sumX*sumX)
    return slope
}

// CFSè°ƒåº¦å™¨å¤æ‚åº¦éªŒè¯
func CFSSchedule(nEntities int) {
    // O(log n) æ’å…¥å’ŒæŸ¥æ‰¾ï¼ˆçº¢é»‘æ ‘ï¼‰
    // ç®€åŒ–æ¨¡æ‹Ÿ
    tree := make([]int, nEntities)
    for i := 0; i < nEntities; i++ {
        tree[i] = i
    }
    // é€‰æ‹©æœ€å°vruntimeï¼ˆç®€åŒ–ï¼‰
    _ = tree[0]
}

// å¤šç»´èƒŒåŒ…é—®é¢˜æ±‚è§£ï¼ˆNPå®Œå…¨ï¼‰
func SolveMDKP(items []Item, capacities []float64) []bool {
    // åŠ¨æ€è§„åˆ’æ±‚è§£ï¼ˆæŒ‡æ•°å¤æ‚åº¦ï¼‰
    n := len(items)
    dp := make([][]float64, n+1)
    for i := range dp {
        dp[i] = make([]float64, len(capacities))
    }

    // çŠ¶æ€è½¬ç§»
    for i := 1; i <= n; i++ {
        for j := 0; j < len(capacities); j++ {
            // ä¸é€‰ç¬¬iä¸ªç‰©å“
            dp[i][j] = dp[i-1][j]

            // é€‰ç¬¬iä¸ªç‰©å“
            if items[i-1].Weights[j] <= capacities[j] {
                newValue := dp[i-1][j] + items[i-1].Value
                if newValue > dp[i][j] {
                    dp[i][j] = newValue
                }
            }
        }
    }

    // å›æº¯æ±‚è§£
    selected := make([]bool, n)
    // ... å›æº¯é€»è¾‘

    return selected
}

type Item struct {
    Value   float64
    Weights []float64
}
```

#### Pythonå®ç°

```python
import time
import numpy as np
from scipy import stats
from typing import List, Callable, Tuple
import threading

class ComplexityAnalyzer:
    """å¤æ‚åº¦åˆ†æå™¨"""
    def __init__(self):
        self.measurements: List[Tuple[str, int, float]] = []
        self._lock = threading.Lock()

    def measure_algorithm(self, algorithm: Callable, input_sizes: List[int], algorithm_name: str = "algorithm") -> List[Tuple[int, float]]:
        """æµ‹é‡ç®—æ³•åœ¨ä¸åŒè¾“å…¥è§„æ¨¡ä¸‹çš„æ€§èƒ½"""
        results = []

        for n in input_sizes:
            start = time.perf_counter()
            algorithm(n)
            elapsed = time.perf_counter() - start

            results.append((n, elapsed))
            with self._lock:
                self.measurements.append((algorithm_name, n, elapsed))

        return results

    def estimate_complexity(self, results: List[Tuple[int, float]]) -> str:
        """ä¼°è®¡ç®—æ³•å¤æ‚åº¦"""
        if len(results) < 2:
            return "insufficient data"

        # ä½¿ç”¨çº¿æ€§å›å½’ä¼°è®¡å¤æ‚åº¦
        n_values = np.log([r[0] for r in results])
        time_values = np.log([r[1] for r in results])

        slope, intercept, r_value, p_value, std_err = stats.linregress(n_values, time_values)

        # æ ¹æ®æ–œç‡åˆ¤æ–­å¤æ‚åº¦
        if slope < 0.5:
            return "O(1)"
        elif slope < 1.5:
            return "O(log n)"
        elif slope < 2.5:
            return "O(n)"
        elif slope < 3.5:
            return "O(n log n)"
        else:
            return f"O(n^{slope:.1f})"

    def compare_algorithms(self, algorithms: List[Callable], input_sizes: List[int]) -> dict:
        """å¯¹æ¯”å¤šä¸ªç®—æ³•çš„å¤æ‚åº¦"""
        results = {}

        for i, algorithm in enumerate(algorithms):
            name = f"algorithm_{i}"
            measurements = self.measure_algorithm(algorithm, input_sizes, name)
            complexity = self.estimate_complexity(measurements)
            results[name] = {
                "complexity": complexity,
                "measurements": measurements,
            }

        return results

# è°ƒåº¦ç®—æ³•å¤æ‚åº¦éªŒè¯
def cfs_schedule(n_entities: int):
    """æ¨¡æ‹ŸCFSè°ƒåº¦å™¨ï¼ˆçº¢é»‘æ ‘ï¼‰- O(log n)"""
    # O(log n) æ’å…¥å’ŒæŸ¥æ‰¾
    tree = sorted(range(n_entities))  # ç®€åŒ–æ¨¡æ‹Ÿ
    return tree[0]  # é€‰æ‹©æœ€å°vruntime

def round_robin_schedule(n_entities: int):
    """è½®è¯¢è°ƒåº¦ - O(1)"""
    return n_entities % 10  # ç®€åŒ–æ¨¡æ‹Ÿ

def greedy_schedule(n_entities: int):
    """è´ªå¿ƒè°ƒåº¦ - O(n log n)"""
    entities = list(range(n_entities))
    entities.sort()  # O(n log n)
    return entities[0]

# å¤šç»´èƒŒåŒ…é—®é¢˜æ±‚è§£ï¼ˆNPå®Œå…¨ï¼‰
def solve_mdkp(items: List[dict], capacities: List[float]) -> List[bool]:
    """æ±‚è§£å¤šç»´èƒŒåŒ…é—®é¢˜ï¼ˆåŠ¨æ€è§„åˆ’ï¼‰"""
    n = len(items)
    m = len(capacities)

    # dp[i][j] è¡¨ç¤ºå‰iä¸ªç‰©å“åœ¨å®¹é‡jä¸‹çš„æœ€å¤§ä»·å€¼
    dp = [[0.0] * (m + 1) for _ in range(n + 1)]

    # çŠ¶æ€è½¬ç§»
    for i in range(1, n + 1):
        for j in range(m):
            # ä¸é€‰ç¬¬iä¸ªç‰©å“
            dp[i][j] = dp[i-1][j]

            # é€‰ç¬¬iä¸ªç‰©å“
            if items[i-1]["weights"][j] <= capacities[j]:
                new_value = dp[i-1][j] + items[i-1]["value"]
                if new_value > dp[i][j]:
                    dp[i][j] = new_value

    # å›æº¯æ±‚è§£
    selected = [False] * n
    # ... å›æº¯é€»è¾‘

    return selected

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    analyzer = ComplexityAnalyzer()

    # æµ‹é‡CFSè°ƒåº¦å™¨å¤æ‚åº¦
    results = analyzer.measure_algorithm(cfs_schedule, [100, 1000, 10000, 100000], "CFS")
    complexity = analyzer.estimate_complexity(results)
    print(f"CFSè°ƒåº¦å™¨å¤æ‚åº¦: {complexity}")  # åº”è¯¥è¾“å‡º O(log n)

    # å¯¹æ¯”å¤šä¸ªç®—æ³•
    algorithms = [cfs_schedule, round_robin_schedule, greedy_schedule]
    comparison = analyzer.compare_algorithms(algorithms, [100, 1000, 10000])
    for name, result in comparison.items():
        print(f"{name}: {result['complexity']}")
```

#### Rustå®ç°

```rust
use std::time::{Duration, Instant};
use std::collections::HashMap;

pub struct ComplexityAnalyzer {
    measurements: Vec<Measurement>,
}

pub struct Measurement {
    algorithm: String,
    input_size: usize,
    time: Duration,
}

impl ComplexityAnalyzer {
    pub fn new() -> Self {
        ComplexityAnalyzer {
            measurements: Vec::new(),
        }
    }

    pub fn measure_algorithm<F>(&mut self, algorithm: F, input_sizes: &[usize], algorithm_name: &str) -> Vec<Measurement>
    where
        F: Fn(usize),
    {
        let mut results = Vec::new();

        for &n in input_sizes {
            let start = Instant::now();
            algorithm(n);
            let elapsed = start.elapsed();

            let measurement = Measurement {
                algorithm: algorithm_name.to_string(),
                input_size: n,
                time: elapsed,
            };
            results.push(measurement.clone());
            self.measurements.push(measurement);
        }

        results
    }

    pub fn estimate_complexity(&self, results: &[Measurement]) -> String {
        if results.len() < 2 {
            return "insufficient data".to_string();
        }

        // ä½¿ç”¨çº¿æ€§å›å½’ä¼°è®¡å¤æ‚åº¦
        let n_values: Vec<f64> = results.iter().map(|r| (r.input_size as f64).ln()).collect();
        let time_values: Vec<f64> = results.iter().map(|r| r.time.as_nanos() as f64).map(|t| t.ln()).collect();

        let slope = self.compute_slope(&n_values, &time_values);

        // æ ¹æ®æ–œç‡åˆ¤æ–­å¤æ‚åº¦
        if slope < 0.5 {
            "O(1)".to_string()
        } else if slope < 1.5 {
            "O(log n)".to_string()
        } else if slope < 2.5 {
            "O(n)".to_string()
        } else if slope < 3.5 {
            "O(n log n)".to_string()
        } else {
            format!("O(n^{:.1})", slope)
        }
    }

    fn compute_slope(&self, x: &[f64], y: &[f64]) -> f64 {
        let n = x.len();
        let sum_x: f64 = x.iter().sum();
        let sum_y: f64 = y.iter().sum();
        let sum_xy: f64 = x.iter().zip(y.iter()).map(|(a, b)| a * b).sum();
        let sum_x2: f64 = x.iter().map(|a| a * a).sum();

        (n as f64 * sum_xy - sum_x * sum_y) / (n as f64 * sum_x2 - sum_x * sum_x)
    }
}

// CFSè°ƒåº¦å™¨å¤æ‚åº¦éªŒè¯
pub fn cfs_schedule(n_entities: usize) {
    // O(log n) æ’å…¥å’ŒæŸ¥æ‰¾ï¼ˆçº¢é»‘æ ‘ï¼‰
    let mut tree: Vec<usize> = (0..n_entities).collect();
    tree.sort(); // ç®€åŒ–æ¨¡æ‹Ÿ
    let _ = tree[0]; // é€‰æ‹©æœ€å°vruntime
}
```

**å¤æ‚åº¦åˆ†æçš„å®é™…ä»·å€¼**ï¼š

- **æ€§èƒ½é¢„æµ‹**ï¼šæ ¹æ®å¤æ‚åº¦é¢„æµ‹ç®—æ³•æ€§èƒ½
- **ç®—æ³•é€‰æ‹©**ï¼šæ ¹æ®ç³»ç»Ÿè§„æ¨¡é€‰æ‹©åˆé€‚çš„ç®—æ³•
- **å®¹é‡è§„åˆ’**ï¼šæ ¹æ®å¤æ‚åº¦è§„åˆ’ç³»ç»Ÿå®¹é‡
- **ä¼˜åŒ–æŒ‡å¯¼**ï¼šè¯†åˆ«ç®—æ³•ç“¶é¢ˆå¹¶ä¼˜åŒ–

### 6.1 å¤æ‚åº¦ä¸‹ç•Œçš„ç´§æ€§

**å®šç†80**ï¼ˆå¤æ‚åº¦ä¸‹ç•Œçš„ç´§æ€§ï¼‰ï¼š
å¯¹äºè°ƒåº¦é—®é¢˜ï¼Œå­˜åœ¨ç®—æ³•è¾¾åˆ°å¤æ‚åº¦ä¸‹ç•Œã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šç´§æ€§å®šä¹‰

**å®šä¹‰**ï¼ˆç´§æ€§ï¼‰ï¼š
å¤æ‚åº¦ä¸‹ç•Œæ˜¯ç´§çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨ç®—æ³•ï¼Œå…¶å¤æ‚åº¦ç­‰äºä¸‹ç•Œã€‚

#### æ­¥éª¤2ï¼šä¸‹ç•Œå¯è¾¾æ€§

**å¼•ç†80.1**ï¼ˆä¸‹ç•Œå¯è¾¾æ€§ï¼‰ï¼š
å¯¹äºè°ƒåº¦é—®é¢˜ï¼Œå­˜åœ¨ç®—æ³•è¾¾åˆ°å¤æ‚åº¦ä¸‹ç•Œã€‚

**è¯æ˜**ï¼š
ç”±ä¿¡æ¯è®ºä¸‹ç•Œå’Œç®—æ³•è®¾è®¡ï¼Œå­˜åœ¨ç®—æ³•ï¼ˆå¦‚æœ€ä¼˜è°ƒåº¦ç®—æ³•ï¼‰è¾¾åˆ°ä¸‹ç•Œã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†80.1ï¼Œå¤æ‚åº¦ä¸‹ç•Œæ˜¯ç´§çš„ã€‚ âˆ

### 6.2 å¤æ‚åº¦åˆ†æçš„å®é™…åº”ç”¨

#### 6.2.1 ç®—æ³•æ€§èƒ½é¢„æµ‹

**åœºæ™¯**ï¼šä½¿ç”¨å¤æ‚åº¦åˆ†æé¢„æµ‹ç®—æ³•æ€§èƒ½ã€‚

**æ–¹æ³•**ï¼š

1. åˆ†æç®—æ³•å¤æ‚åº¦
2. å»ºç«‹æ€§èƒ½æ¨¡å‹
3. é¢„æµ‹å®é™…æ€§èƒ½

**Golangå®ç°**ï¼š

```go
package complexity

// ç®—æ³•æ€§èƒ½é¢„æµ‹
func PredictPerformance(
    algorithm Algorithm,
    inputSize int,
) (time.Duration, error) {
    // åˆ†æç®—æ³•å¤æ‚åº¦
    complexity := analyzeComplexity(algorithm)

    // å»ºç«‹æ€§èƒ½æ¨¡å‹
    model := buildPerformanceModel(algorithm, complexity)

    // é¢„æµ‹å®é™…æ€§èƒ½
    predictedTime := model.Predict(inputSize)

    return predictedTime, nil
}

// å»ºç«‹æ€§èƒ½æ¨¡å‹
func buildPerformanceModel(
    algorithm Algorithm,
    complexity Complexity,
) PerformanceModel {
    // æ ¹æ®å¤æ‚åº¦ç±»å‹å»ºç«‹æ¨¡å‹
    switch complexity.Type {
    case O1:
        return NewConstantModel(complexity.Constant)
    case OLogN:
        return NewLogarithmicModel(complexity.Constant)
    case ON:
        return NewLinearModel(complexity.Constant)
    case ONLogN:
        return NewLinearithmicModel(complexity.Constant)
    default:
        return NewPolynomialModel(complexity.Degree, complexity.Constant)
    }
}
```

**Pythonå®ç°**ï¼š

```python
import time
from typing import Protocol

def predict_performance(
    algorithm: Algorithm,
    input_size: int,
) -> float:
    """ç®—æ³•æ€§èƒ½é¢„æµ‹"""
    # åˆ†æç®—æ³•å¤æ‚åº¦
    complexity = analyze_complexity(algorithm)

    # å»ºç«‹æ€§èƒ½æ¨¡å‹
    model = build_performance_model(algorithm, complexity)

    # é¢„æµ‹å®é™…æ€§èƒ½
    predicted_time = model.predict(input_size)

    return predicted_time

def build_performance_model(
    algorithm: Algorithm,
    complexity: Complexity,
) -> PerformanceModel:
    """å»ºç«‹æ€§èƒ½æ¨¡å‹"""
    # æ ¹æ®å¤æ‚åº¦ç±»å‹å»ºç«‹æ¨¡å‹
    if complexity.type == "O(1)":
        return ConstantModel(complexity.constant)
    elif complexity.type == "O(log n)":
        return LogarithmicModel(complexity.constant)
    elif complexity.type == "O(n)":
        return LinearModel(complexity.constant)
    elif complexity.type == "O(n log n)":
        return LinearithmicModel(complexity.constant)
    else:
        return PolynomialModel(complexity.degree, complexity.constant)
```

**Rustå®ç°**ï¼š

```rust
use std::time::Duration;

pub fn predict_performance(
    algorithm: &Algorithm,
    input_size: usize,
) -> Result<Duration, Error> {
    // åˆ†æç®—æ³•å¤æ‚åº¦
    let complexity = analyze_complexity(algorithm)?;

    // å»ºç«‹æ€§èƒ½æ¨¡å‹
    let model = build_performance_model(algorithm, &complexity)?;

    // é¢„æµ‹å®é™…æ€§èƒ½
    let predicted_time = model.predict(input_size)?;

    Ok(predicted_time)
}

fn build_performance_model(
    algorithm: &Algorithm,
    complexity: &Complexity,
) -> Result<Box<dyn PerformanceModel>, Error> {
    // æ ¹æ®å¤æ‚åº¦ç±»å‹å»ºç«‹æ¨¡å‹
    match complexity.complexity_type {
        ComplexityType::O1 => Ok(Box::new(ConstantModel::new(complexity.constant))),
        ComplexityType::OLogN => Ok(Box::new(LogarithmicModel::new(complexity.constant))),
        ComplexityType::ON => Ok(Box::new(LinearModel::new(complexity.constant))),
        ComplexityType::ONLogN => Ok(Box::new(LinearithmicModel::new(complexity.constant))),
        ComplexityType::OPolynomial(degree) => {
            Ok(Box::new(PolynomialModel::new(degree, complexity.constant)))
        }
    }
}
```

---

## 6. ç›¸å…³æ–‡æ¡£

- [è¿”å› FormalModel ç›®å½•](../README.md)
- [05_æ•°æ®ç»“æ„ä¸ç®—æ³• README](README.md)
- [05.1_æ•°æ®ç»“æ„æ‹“æ‰‘åŒæ„æ€§](05.1_æ•°æ®ç»“æ„æ‹“æ‰‘åŒæ„æ€§.md)
- [05.3_è´Ÿè½½å‡è¡¡ç®—æ³•æ¡†æ¶](05.3_è´Ÿè½½å‡è¡¡ç®—æ³•æ¡†æ¶.md)

---

**æœ€åæ›´æ–°**: 2025-01-27
