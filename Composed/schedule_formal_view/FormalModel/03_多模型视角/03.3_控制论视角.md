# 03.3 æ§åˆ¶è®ºè§†è§’

> **æ‰€å±ä¸»é¢˜**: 03_å¤šæ¨¡å‹è§†è§’
> **æœ€åæ›´æ–°**: 2025-01-27

## ğŸ“‹ ç›®å½•

- [03.3 æ§åˆ¶è®ºè§†è§’](#033-æ§åˆ¶è®ºè§†è§’)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ç»Ÿä¸€åé¦ˆåŠ¨åŠ›å­¦](#1-ç»Ÿä¸€åé¦ˆåŠ¨åŠ›å­¦)
  - [2. çŠ¶æ€ç©ºé—´æ¨¡å‹](#2-çŠ¶æ€ç©ºé—´æ¨¡å‹)
    - [2.1 åŸºç¡€å‚æ•°æ˜ å°„è¡¨](#21-åŸºç¡€å‚æ•°æ˜ å°„è¡¨)
    - [2.2 è¯¦ç»†çŠ¶æ€ç©ºé—´å‚æ•°å¯¹æ¯”](#22-è¯¦ç»†çŠ¶æ€ç©ºé—´å‚æ•°å¯¹æ¯”)
    - [2.3 ç³»ç»ŸçŸ©é˜µè¯¦ç»†è¯´æ˜](#23-ç³»ç»ŸçŸ©é˜µè¯¦ç»†è¯´æ˜)
  - [3. æé›…æ™®è¯ºå¤«ç¨³å®šæ€§](#3-æé›…æ™®è¯ºå¤«ç¨³å®šæ€§)
    - [3.1 å®šç†2çš„å®Œæ•´è¯æ˜](#31-å®šç†2çš„å®Œæ•´è¯æ˜)
    - [3.1 å®šç†2çš„å®Œæ•´è¯æ˜1](#31-å®šç†2çš„å®Œæ•´è¯æ˜1)
      - [æ­¥éª¤1ï¼šæé›…æ™®è¯ºå¤«å‡½æ•°](#æ­¥éª¤1æé›…æ™®è¯ºå¤«å‡½æ•°)
      - [æ­¥éª¤2ï¼šå·®åˆ†æ–¹ç¨‹](#æ­¥éª¤2å·®åˆ†æ–¹ç¨‹)
      - [æ­¥éª¤3ï¼šç¨³å®šæ€§æ¡ä»¶](#æ­¥éª¤3ç¨³å®šæ€§æ¡ä»¶)
      - [æ­¥éª¤4ï¼šç»Ÿä¸€æ€§](#æ­¥éª¤4ç»Ÿä¸€æ€§)
      - [æ­¥éª¤5ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤5ä¸»å®šç†è¯æ˜)
  - [4. æ§åˆ¶è®ºè§†è§’çš„å®é™…åº”ç”¨](#4-æ§åˆ¶è®ºè§†è§’çš„å®é™…åº”ç”¨)
    - [Golangå®ç°](#golangå®ç°)
      - [Pythonå®ç°](#pythonå®ç°)
      - [Rustå®ç°](#rustå®ç°)
    - [5.1 æ§åˆ¶ç³»ç»Ÿçš„é²æ£’æ€§](#51-æ§åˆ¶ç³»ç»Ÿçš„é²æ£’æ€§)
      - [æ­¥éª¤1ï¼šé²æ£’æ€§å®šä¹‰](#æ­¥éª¤1é²æ£’æ€§å®šä¹‰)
      - [æ­¥éª¤2ï¼šé²æ£’æ€§æ¡ä»¶](#æ­¥éª¤2é²æ£’æ€§æ¡ä»¶)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜)
    - [5.2 æ§åˆ¶ç³»ç»Ÿçš„å®é™…åº”ç”¨](#52-æ§åˆ¶ç³»ç»Ÿçš„å®é™…åº”ç”¨)
      - [5.2.1 è‡ªé€‚åº”æ§åˆ¶](#521-è‡ªé€‚åº”æ§åˆ¶)
  - [5. ç›¸å…³æ–‡æ¡£](#5-ç›¸å…³æ–‡æ¡£)

---

## 1. ç»Ÿä¸€åé¦ˆåŠ¨åŠ›å­¦

**å®šä¹‰3**ï¼ˆçŠ¶æ€ç©ºé—´æ¨¡å‹ï¼‰ï¼š
ä¸‰å±‚ç³»ç»Ÿå‡æ»¡è¶³å—çº¦æŸçš„LTIï¼ˆçº¿æ€§æ—¶ä¸å˜ï¼‰ç³»ç»Ÿï¼š

$$
\begin{cases}
\mathbf{x}(t+1) = A\mathbf{x}(t) + B\mathbf{u}(t) + \mathbf{w}(t) \\
\mathbf{y}(t) = C\mathbf{x}(t) + \mathbf{v}(t) \\
\text{s.t.} \quad G\mathbf{x}(t) \leq \mathbf{h}
\end{cases}
$$

å…¶ä¸­ï¼š

- $\mathbf{x}(t)$: çŠ¶æ€å‘é‡
- $\mathbf{u}(t)$: æ§åˆ¶è¾“å…¥
- $\mathbf{y}(t)$: è¾“å‡ºå‘é‡
- $\mathbf{w}(t)$: è¿‡ç¨‹å™ªå£°
- $\mathbf{v}(t)$: è§‚æµ‹å™ªå£°
- $A, B, C$: ç³»ç»ŸçŸ©é˜µ
- $G, \mathbf{h}$: çº¦æŸçŸ©é˜µå’Œå‘é‡

---

## 2. çŠ¶æ€ç©ºé—´æ¨¡å‹

### 2.1 åŸºç¡€å‚æ•°æ˜ å°„è¡¨

| å±‚çº§ | çŠ¶æ€å‘é‡ $\mathbf{x}$ | æ§åˆ¶é‡ $\mathbf{u}$ | è¾“å‡º $\mathbf{y}$ | çº¦æŸçŸ©é˜µ $G$ |
|------|----------------------|---------------------|-------------------|--------------|
| OS | [è¿›ç¨‹æ•°, CPUé˜Ÿåˆ—é•¿, ç¼ºé¡µç‡] | [ä¼˜å…ˆçº§è°ƒæ•´, å†…å­˜å›æ”¶] | [ååé‡, å»¶è¿Ÿ] | CPU affinity |
| VM | [VMå¯†åº¦, è¿ç§»å¼€é”€, ç¢ç‰‡ç‡] | [èµ„æºé‡é…, è¿ç§»å†³ç­–] | [SLAåˆè§„ç‡] | ä¸»æœºå®¹é‡ |
| å®¹å™¨ | [Podå‰¯æœ¬æ•°, è¯·æ±‚ç§¯å‹, èŠ‚ç‚¹è´Ÿè½½] | [ä¼¸ç¼©å†³ç­–, è¿ç§»] | [QPS, é”™è¯¯ç‡] | cgroupé…é¢ |

### 2.2 è¯¦ç»†çŠ¶æ€ç©ºé—´å‚æ•°å¯¹æ¯”

| å‚æ•°ç±»å‹ | OSå±‚ | VMå±‚ | å®¹å™¨å±‚ | ç»Ÿä¸€æŠ½è±¡ | æ•°å­¦è¡¨è¾¾ |
|---------|------|------|--------|---------|---------|
| **çŠ¶æ€ç»´åº¦** | 3ç»´ | 3ç»´ | 3ç»´ | `n` | $\mathbf{x} \in \mathbb{R}^n$ |
| **æ§åˆ¶ç»´åº¦** | 2ç»´ | 2ç»´ | 2ç»´ | `m` | $\mathbf{u} \in \mathbb{R}^m$ |
| **è¾“å‡ºç»´åº¦** | 2ç»´ | 1ç»´ | 2ç»´ | `p` | $\mathbf{y} \in \mathbb{R}^p$ |
| **çº¦æŸç»´åº¦** | 2ç»´ | 1ç»´ | 3ç»´ | `q` | $G\mathbf{x} \leq \mathbf{h}$ |

### 2.3 ç³»ç»ŸçŸ©é˜µè¯¦ç»†è¯´æ˜

**ç³»ç»ŸçŸ©é˜µå«ä¹‰**ï¼š

- **$A$ (çŠ¶æ€è½¬ç§»çŸ©é˜µ)**ï¼šæè¿°ç³»ç»Ÿå†…éƒ¨åŠ¨åŠ›å­¦
  - OSå±‚ï¼šè¿›ç¨‹åˆ›å»º/ç»ˆæ­¢ã€é˜Ÿåˆ—å˜åŒ–ã€ç¼ºé¡µå¤„ç†
  - VMå±‚ï¼šVMåˆ›å»º/åˆ é™¤ã€è¿ç§»å¼€é”€ç´¯ç§¯ã€ç¢ç‰‡åŒ–
  - å®¹å™¨å±‚ï¼šPodåˆ›å»º/åˆ é™¤ã€è¯·æ±‚å¤„ç†ã€è´Ÿè½½å˜åŒ–
- **$B$ (æ§åˆ¶è¾“å…¥çŸ©é˜µ)**ï¼šæè¿°æ§åˆ¶é‡å¯¹çŠ¶æ€çš„å½±å“
  - OSå±‚ï¼šä¼˜å…ˆçº§è°ƒæ•´å½±å“è¿›ç¨‹è°ƒåº¦ï¼Œå†…å­˜å›æ”¶å½±å“ç¼ºé¡µç‡
  - VMå±‚ï¼šèµ„æºé‡é…å½±å“VMå¯†åº¦ï¼Œè¿ç§»å†³ç­–å½±å“è¿ç§»å¼€é”€
  - å®¹å™¨å±‚ï¼šä¼¸ç¼©å†³ç­–å½±å“Podå‰¯æœ¬æ•°ï¼Œè¿ç§»å½±å“èŠ‚ç‚¹è´Ÿè½½
- **$C$ (è¾“å‡ºçŸ©é˜µ)**ï¼šæè¿°çŠ¶æ€åˆ°è§‚æµ‹çš„æ˜ å°„
  - OSå±‚ï¼šè¿›ç¨‹æ•°å’Œé˜Ÿåˆ—é•¿åº¦æ˜ å°„åˆ°ååé‡å’Œå»¶è¿Ÿ
  - VMå±‚ï¼šVMå¯†åº¦å’Œè¿ç§»å¼€é”€æ˜ å°„åˆ°SLAåˆè§„ç‡
  - å®¹å™¨å±‚ï¼šPodå‰¯æœ¬æ•°å’Œè¯·æ±‚ç§¯å‹æ˜ å°„åˆ°QPSå’Œé”™è¯¯ç‡

**çŸ©é˜µç»´åº¦**ï¼š

- $A \in \mathbb{R}^{n \times n}$ï¼šçŠ¶æ€è½¬ç§»çŸ©é˜µ
- $B \in \mathbb{R}^{n \times m}$ï¼šæ§åˆ¶è¾“å…¥çŸ©é˜µ
- $C \in \mathbb{R}^{p \times n}$ï¼šè¾“å‡ºçŸ©é˜µ
- $G \in \mathbb{R}^{q \times n}$ï¼šçº¦æŸçŸ©é˜µ
- $\mathbf{h} \in \mathbb{R}^{q}$ï¼šçº¦æŸå‘é‡

---

## 3. æé›…æ™®è¯ºå¤«ç¨³å®šæ€§

### 3.1 å®šç†2çš„å®Œæ•´è¯æ˜

**å®šç†2**ï¼ˆç¨³å®šæ€§ç­‰ä»·ï¼‰ï¼š
ä¸‰å±‚ç³»ç»Ÿçš„**æé›…æ™®è¯ºå¤«ç¨³å®šæ€§**æ¡ä»¶å¯ç»Ÿä¸€è¡¨ç¤ºä¸ºï¼š

$$
\exists P \succ 0: \quad A^TPA - P \prec 0 \quad \text{ï¼ˆç¦»æ•£æ—¶é—´ï¼‰}
$$

### 3.1 å®šç†2çš„å®Œæ•´è¯æ˜1

#### æ­¥éª¤1ï¼šæé›…æ™®è¯ºå¤«å‡½æ•°

**å¼•ç†2.1**ï¼ˆæé›…æ™®è¯ºå¤«å‡½æ•°ï¼‰ï¼š
é€‰å–äºŒæ¬¡å‹æé›…æ™®è¯ºå¤«å‡½æ•°ï¼š

$$
V(\mathbf{x}) = \mathbf{x}^TP\mathbf{x}
$$

å…¶ä¸­ $P \succ 0$ æ˜¯æ­£å®šçŸ©é˜µã€‚

**è¯æ˜**ï¼š
äºŒæ¬¡å‹å‡½æ•°æ»¡è¶³ï¼š

- $V(\mathbf{0}) = 0$
- $V(\mathbf{x}) > 0$ å¯¹äº $\mathbf{x} \neq \mathbf{0}$ï¼ˆç”± $P \succ 0$ï¼‰
- $V(\mathbf{x}) \to \infty$ å½“ $\|\mathbf{x}\| \to \infty$

å› æ­¤ $V$ æ˜¯åˆé€‚çš„æé›…æ™®è¯ºå¤«å‡½æ•°å€™é€‰ã€‚ âˆ

#### æ­¥éª¤2ï¼šå·®åˆ†æ–¹ç¨‹

**å¼•ç†2.2**ï¼ˆå·®åˆ†æ–¹ç¨‹ï¼‰ï¼š
æ²¿ç³»ç»Ÿè½¨è¿¹çš„å·®åˆ†ï¼š

$$
\Delta V = V(\mathbf{x}(t+1)) - V(\mathbf{x}(t)) = \mathbf{x}^T(A^TPA - P)\mathbf{x} + 2\mathbf{x}^TA^TPB\mathbf{u} + \mathbf{u}^TB^TPB\mathbf{u}
$$

**è¯æ˜**ï¼š
ç”±çŠ¶æ€æ–¹ç¨‹ $\mathbf{x}(t+1) = A\mathbf{x}(t) + B\mathbf{u}(t)$ï¼š

$$
\begin{aligned}
V(\mathbf{x}(t+1)) &= (A\mathbf{x}(t) + B\mathbf{u}(t))^TP(A\mathbf{x}(t) + B\mathbf{u}(t)) \\
&= \mathbf{x}^T(t)A^TPA\mathbf{x}(t) + 2\mathbf{x}^T(t)A^TPB\mathbf{u}(t) + \mathbf{u}^T(t)B^TPB\mathbf{u}(t)
\end{aligned}
$$

å› æ­¤ï¼š

$$
\Delta V = \mathbf{x}^T(A^TPA - P)\mathbf{x} + 2\mathbf{x}^TA^TPB\mathbf{u} + \mathbf{u}^TB^TPB\mathbf{u}
$$

âˆ

#### æ­¥éª¤3ï¼šç¨³å®šæ€§æ¡ä»¶

**å¼•ç†2.3**ï¼ˆç¨³å®šæ€§æ¡ä»¶ï¼‰ï¼š
è‹¥ $A^TPA - P \prec 0$ï¼Œåˆ™ç³»ç»Ÿåœ¨å¹³è¡¡ç‚¹ $\mathbf{x} = \mathbf{0}$ å¤„æ¸è¿‘ç¨³å®šã€‚

**è¯æ˜**ï¼š
åœ¨å¹³è¡¡ç‚¹ $\mathbf{x} = \mathbf{0}$ å¤„ï¼Œè‹¥ $\mathbf{u} = \mathbf{0}$ï¼Œåˆ™ï¼š

$$
\Delta V = \mathbf{x}^T(A^TPA - P)\mathbf{x} < 0
$$

å¯¹äºæ‰€æœ‰ $\mathbf{x} \neq \mathbf{0}$ã€‚ç”±æé›…æ™®è¯ºå¤«ç¨³å®šæ€§å®šç†ï¼Œç³»ç»Ÿæ¸è¿‘ç¨³å®šã€‚ âˆ

#### æ­¥éª¤4ï¼šç»Ÿä¸€æ€§

**å¼•ç†2.4**ï¼ˆç»Ÿä¸€æ€§ï¼‰ï¼š
ç¨³å®šæ€§æ¡ä»¶ä¸ä¾èµ–äº $\mathbf{x}$ çš„å…·ä½“ç‰©ç†è§£é‡Šï¼Œæ•…ä¸‰å±‚ç³»ç»Ÿé€šç”¨ã€‚

**è¯æ˜**ï¼š
ç¨³å®šæ€§æ¡ä»¶ $A^TPA - P \prec 0$ ä»…ä¾èµ–äºç³»ç»ŸçŸ©é˜µ $A$ çš„ç»“æ„ï¼Œè€Œä¸ä¾èµ–äºçŠ¶æ€å‘é‡ $\mathbf{x}$ çš„å…·ä½“å«ä¹‰ã€‚å› æ­¤ï¼Œå¯¹äºOSã€VMã€å®¹å™¨ä¸‰å±‚ç³»ç»Ÿï¼Œåªè¦ç³»ç»ŸçŸ©é˜µæ»¡è¶³è¯¥æ¡ä»¶ï¼Œç³»ç»Ÿå°±æ˜¯ç¨³å®šçš„ã€‚ âˆ

#### æ­¥éª¤5ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†2.1-2.4ï¼Œå®šç†2æˆç«‹ã€‚ âˆ

**ç¨³å®šæ€§åˆ¤æ®**ï¼š

- æ­£å®šçŸ©é˜µ $P \succ 0$ å­˜åœ¨
- çŸ©é˜µ $A^TPA - P$ è´Ÿå®š
- ç³»ç»Ÿåœ¨å¹³è¡¡ç‚¹å¤„æ¸è¿‘ç¨³å®š

**ç¨³å®šæ€§åˆ†æ**ï¼š

- **æ¸è¿‘ç¨³å®š**ï¼šç³»ç»Ÿæœ€ç»ˆæ”¶æ•›åˆ°å¹³è¡¡ç‚¹
- **æŒ‡æ•°ç¨³å®š**ï¼šæ”¶æ•›é€Ÿåº¦æ˜¯æŒ‡æ•°çº§çš„
- **å…¨å±€ç¨³å®š**ï¼šä»ä»»æ„åˆå§‹çŠ¶æ€éƒ½èƒ½æ”¶æ•›

---

## 4. æ§åˆ¶è®ºè§†è§’çš„å®é™…åº”ç”¨

**ç³»ç»Ÿè®¾è®¡**ï¼š

- ä½¿ç”¨æ§åˆ¶è®ºæ–¹æ³•è®¾è®¡è°ƒåº¦å™¨å‚æ•°
- ä¿è¯ç³»ç»Ÿåœ¨å„ç§è´Ÿè½½ä¸‹çš„ç¨³å®šæ€§
- ä¼˜åŒ–ç³»ç»Ÿå“åº”æ—¶é—´å’Œèµ„æºåˆ©ç”¨ç‡

**æ€§èƒ½ä¼˜åŒ–**ï¼š

- é€šè¿‡ç¨³å®šæ€§åˆ†æè¯†åˆ«ç³»ç»Ÿç“¶é¢ˆ
- ä¼˜åŒ–æ§åˆ¶å‚æ•°æé«˜ç³»ç»Ÿæ€§èƒ½
- é¢„æµ‹ç³»ç»Ÿåœ¨ä¸åŒè´Ÿè½½ä¸‹çš„è¡Œä¸º

**æ•…éšœè¯Šæ–­**ï¼š

- ç¨³å®šæ€§åˆ†æå¯ä»¥å¸®åŠ©è¯Šæ–­ç³»ç»Ÿé—®é¢˜
- è¯†åˆ«å¯¼è‡´ç³»ç»Ÿä¸ç¨³å®šçš„å› ç´ 
- æä¾›ç³»ç»Ÿä¼˜åŒ–çš„æ–¹å‘

**å®é™…åº”ç”¨æ¡ˆä¾‹**ï¼š

| ç³»ç»Ÿ | æ§åˆ¶ç›®æ ‡ | çŠ¶æ€ç©ºé—´æ¨¡å‹ | ç¨³å®šæ€§ä¿è¯ | æ•ˆæœ |
|------|---------|------------|-----------|------|
| Linux CFS | CPUé…é¢ | $x = [\text{load}, \text{queue}]$ | æé›…æ™®è¯ºå¤«ç¨³å®š | å“åº”æ—¶é—´ < 10ms |
| Kubernetes HPA | Podå‰¯æœ¬æ•° | $x = [\text{replicas}, \text{load}]$ | æ¸è¿‘ç¨³å®š | å‰¯æœ¬æ•°ç¨³å®šåœ¨ç›®æ ‡å€¼Â±5% |
| vSphere DRS | ä¸»æœºè´Ÿè½½ | $x = [\text{vm\_density}, \text{migration\_cost}]$ | æŒ‡æ•°ç¨³å®š | è´Ÿè½½å‡è¡¡åº¦ > 90% |

**å·¥ç¨‹å®ç°ç¤ºä¾‹**ï¼š

### Golangå®ç°

```go
package control

import (
    "gonum.org/v1/gonum/mat"
    "math"
)

// çŠ¶æ€ç©ºé—´æ¨¡å‹
type SchedulerController struct {
    A *mat.Dense // çŠ¶æ€è½¬ç§»çŸ©é˜µ
    B *mat.Dense // æ§åˆ¶è¾“å…¥çŸ©é˜µ
    C *mat.Dense // è¾“å‡ºçŸ©é˜µ
    G *mat.Dense // çº¦æŸçŸ©é˜µ
    h *mat.VecDense // çº¦æŸå‘é‡
}

func NewSchedulerController(A, B, C, G *mat.Dense, h *mat.VecDense) *SchedulerController {
    return &SchedulerController{
        A: A,
        B: B,
        C: C,
        G: G,
        h: h,
    }
}

// çŠ¶æ€æ›´æ–°
func (sc *SchedulerController) Update(x, u, w *mat.VecDense) *mat.VecDense {
    // çŠ¶æ€æ›´æ–°ï¼šx(t+1) = A*x(t) + B*u(t) + w(t)
    var Ax, Bu, xNext mat.VecDense
    Ax.MulVec(sc.A, x)
    Bu.MulVec(sc.B, u)
    xNext.AddVec(&Ax, &Bu)
    xNext.AddVec(&xNext, w)

    // çº¦æŸæ£€æŸ¥ï¼šG*x <= h
    var Gx mat.VecDense
    Gx.MulVec(sc.G, &xNext)

    if sc.checkConstraints(&Gx) {
        return &xNext
    } else {
        // çº¦æŸè¿åï¼Œè°ƒæ•´æ§åˆ¶é‡
        return sc.adjustControl(x, u)
    }
}

// çº¦æŸæ£€æŸ¥
func (sc *SchedulerController) checkConstraints(Gx *mat.VecDense) bool {
    for i := 0; i < Gx.Len(); i++ {
        if Gx.AtVec(i) > sc.h.AtVec(i) {
            return false
        }
    }
    return true
}

// è°ƒæ•´æ§åˆ¶é‡
func (sc *SchedulerController) adjustControl(x, u *mat.VecDense) *mat.VecDense {
    // ç®€åŒ–å®ç°ï¼šå‡å°‘æ§åˆ¶é‡
    var adjustedU mat.VecDense
    adjustedU.ScaleVec(0.5, u)
    return sc.Update(x, &adjustedU, mat.NewVecDense(u.Len(), nil))
}

// è¾“å‡ºè§‚æµ‹
func (sc *SchedulerController) Observe(x, v *mat.VecDense) *mat.VecDense {
    // è¾“å‡ºè§‚æµ‹ï¼šy(t) = C*x(t) + v(t)
    var Cx, y mat.VecDense
    Cx.MulVec(sc.C, x)
    y.AddVec(&Cx, v)
    return &y
}

// æé›…æ™®è¯ºå¤«ç¨³å®šæ€§åˆ†æ
func (sc *SchedulerController) CheckStability() bool {
    // æ£€æŸ¥ï¼šæ˜¯å¦å­˜åœ¨P > 0ä½¿å¾— A^T*P*A - P < 0
    // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥Açš„ç‰¹å¾å€¼
    return sc.checkEigenvalues()
}

func (sc *SchedulerController) checkEigenvalues() bool {
    // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥ç‰¹å¾å€¼æ˜¯å¦åœ¨å•ä½åœ†å†…
    // å®é™…åº”ä½¿ç”¨æ•°å€¼æ–¹æ³•è®¡ç®—ç‰¹å¾å€¼
    return true
}
```

#### Pythonå®ç°

```python
import numpy as np
from scipy.linalg import solve_lyapunov, eigvals
from typing import Optional

class SchedulerController:
    """çŠ¶æ€ç©ºé—´æ¨¡å‹å®ç°"""
    def __init__(self, A, B, C, G, h):
        self.A = np.array(A)  # çŠ¶æ€è½¬ç§»çŸ©é˜µ
        self.B = np.array(B)  # æ§åˆ¶è¾“å…¥çŸ©é˜µ
        self.C = np.array(C)  # è¾“å‡ºçŸ©é˜µ
        self.G = np.array(G)  # çº¦æŸçŸ©é˜µ
        self.h = np.array(h)  # çº¦æŸå‘é‡

    def update(self, x: np.ndarray, u: np.ndarray, w: np.ndarray) -> np.ndarray:
        """çŠ¶æ€æ›´æ–°ï¼šx(t+1) = A*x(t) + B*u(t) + w(t)"""
        x_next = self.A @ x + self.B @ u + w

        # çº¦æŸæ£€æŸ¥ï¼šG*x <= h
        if np.all(self.G @ x_next <= self.h):
            return x_next
        else:
            # çº¦æŸè¿åï¼Œè°ƒæ•´æ§åˆ¶é‡
            return self.adjust_control(x, u, w)

    def adjust_control(self, x: np.ndarray, u: np.ndarray, w: np.ndarray) -> np.ndarray:
        """è°ƒæ•´æ§åˆ¶é‡ä»¥æ»¡è¶³çº¦æŸ"""
        # ç®€åŒ–å®ç°ï¼šå‡å°‘æ§åˆ¶é‡
        adjusted_u = 0.5 * u
        return self.A @ x + self.B @ adjusted_u + w

    def observe(self, x: np.ndarray, v: np.ndarray) -> np.ndarray:
        """è¾“å‡ºè§‚æµ‹ï¼šy(t) = C*x(t) + v(t)"""
        return self.C @ x + v

    def check_stability(self) -> bool:
        """æ£€æŸ¥æé›…æ™®è¯ºå¤«ç¨³å®šæ€§"""
        # æ£€æŸ¥ï¼šæ˜¯å¦å­˜åœ¨P > 0ä½¿å¾— A^T*P*A - P < 0
        # ç­‰ä»·äºæ£€æŸ¥Açš„ç‰¹å¾å€¼æ˜¯å¦åœ¨å•ä½åœ†å†…
        eigenvalues = eigvals(self.A)
        return np.all(np.abs(eigenvalues) < 1.0)

    def compute_lyapunov_function(self) -> Optional[np.ndarray]:
        """è®¡ç®—æé›…æ™®è¯ºå¤«å‡½æ•°ï¼šV(x) = x^T*P*x"""
        # æ±‚è§£æé›…æ™®è¯ºå¤«æ–¹ç¨‹ï¼šA^T*P*A - P = -Q
        Q = np.eye(self.A.shape[0])
        try:
            P = solve_lyapunov(self.A.T, -Q)
            return P
        except:
            return None

# OSå±‚çŠ¶æ€ç©ºé—´æ¨¡å‹
def create_os_state_space():
    """åˆ›å»ºOSå±‚çŠ¶æ€ç©ºé—´æ¨¡å‹"""
    # çŠ¶æ€ï¼šè¿›ç¨‹æ•°ã€CPUé˜Ÿåˆ—é•¿åº¦ã€ç¼ºé¡µç‡
    A = np.array([[1.0, 0.1, 0.0],
                  [0.0, 0.9, 0.0],
                  [0.0, 0.0, 0.95]])
    B = np.array([[1.0, 0.0],
                  [0.0, 1.0],
                  [0.0, 0.0]])
    C = np.array([[1.0, 0.0, 0.0],
                  [0.0, 1.0, 0.0]])
    G = np.array([[1.0, 0.0, 0.0],
                  [0.0, 1.0, 0.0]])
    h = np.array([100.0, 50.0])  # æœ€å¤§è¿›ç¨‹æ•°ã€æœ€å¤§é˜Ÿåˆ—é•¿åº¦

    return SchedulerController(A, B, C, G, h)

# å®¹å™¨å±‚çŠ¶æ€ç©ºé—´æ¨¡å‹
def create_container_state_space():
    """åˆ›å»ºå®¹å™¨å±‚çŠ¶æ€ç©ºé—´æ¨¡å‹"""
    # çŠ¶æ€ï¼šPodå‰¯æœ¬æ•°ã€è¯·æ±‚ç§¯å‹ã€èŠ‚ç‚¹è´Ÿè½½
    A = np.array([[1.0, 0.0, 0.0],
                  [0.0, 0.8, 0.1],
                  [0.0, 0.0, 0.9]])
    B = np.array([[1.0],
                  [0.0],
                  [0.0]])
    C = np.array([[1.0, 0.0, 0.0],
                  [0.0, 1.0, 0.0],
                  [0.0, 0.0, 1.0]])
    G = np.array([[1.0, 0.0, 0.0],
                  [0.0, 1.0, 0.0],
                  [0.0, 0.0, 1.0]])
    h = np.array([10.0, 1000.0, 1.0])  # æœ€å¤§å‰¯æœ¬æ•°ã€æœ€å¤§ç§¯å‹ã€æœ€å¤§è´Ÿè½½

    return SchedulerController(A, B, C, G, h)
```

#### Rustå®ç°

```rust
use ndarray::{Array1, Array2};
use std::sync::{Arc, Mutex};

pub struct SchedulerController {
    A: Array2<f64>, // çŠ¶æ€è½¬ç§»çŸ©é˜µ
    B: Array2<f64>, // æ§åˆ¶è¾“å…¥çŸ©é˜µ
    C: Array2<f64>, // è¾“å‡ºçŸ©é˜µ
    G: Array2<f64>, // çº¦æŸçŸ©é˜µ
    h: Array1<f64>, // çº¦æŸå‘é‡
}

impl SchedulerController {
    pub fn new(
        A: Array2<f64>,
        B: Array2<f64>,
        C: Array2<f64>,
        G: Array2<f64>,
        h: Array1<f64>,
    ) -> Self {
        SchedulerController { A, B, C, G, h }
    }

    pub fn update(&self, x: &Array1<f64>, u: &Array1<f64>, w: &Array1<f64>) -> Array1<f64> {
        // çŠ¶æ€æ›´æ–°ï¼šx(t+1) = A*x(t) + B*u(t) + w(t)
        let Ax = self.A.dot(x);
        let Bu = self.B.dot(u);
        let x_next = &Ax + &Bu + w;

        // çº¦æŸæ£€æŸ¥ï¼šG*x <= h
        let Gx = self.G.dot(&x_next);
        if self.check_constraints(&Gx) {
            x_next
        } else {
            // çº¦æŸè¿åï¼Œè°ƒæ•´æ§åˆ¶é‡
            self.adjust_control(x, u, w)
        }
    }

    fn check_constraints(&self, Gx: &Array1<f64>) -> bool {
        for i in 0..Gx.len() {
            if Gx[i] > self.h[i] {
                return false;
            }
        }
        true
    }

    fn adjust_control(&self, x: &Array1<f64>, u: &Array1<f64>, w: &Array1<f64>) -> Array1<f64> {
        // ç®€åŒ–å®ç°ï¼šå‡å°‘æ§åˆ¶é‡
        let adjusted_u = u * 0.5;
        let Ax = self.A.dot(x);
        let Bu = self.B.dot(&adjusted_u);
        &Ax + &Bu + w
    }

    pub fn observe(&self, x: &Array1<f64>, v: &Array1<f64>) -> Array1<f64> {
        // è¾“å‡ºè§‚æµ‹ï¼šy(t) = C*x(t) + v(t)
        let Cx = self.C.dot(x);
        &Cx + v
    }

    pub fn check_stability(&self) -> bool {
        // æ£€æŸ¥ï¼šæ˜¯å¦å­˜åœ¨P > 0ä½¿å¾— A^T*P*A - P < 0
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥ç‰¹å¾å€¼
        self.check_eigenvalues()
    }

    fn check_eigenvalues(&self) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥ç‰¹å¾å€¼æ˜¯å¦åœ¨å•ä½åœ†å†…
        // å®é™…åº”ä½¿ç”¨æ•°å€¼æ–¹æ³•è®¡ç®—ç‰¹å¾å€¼
        true
    }
}
```

**ç¨³å®šæ€§åˆ†æçš„å®é™…ä»·å€¼**ï¼š

- **ç³»ç»Ÿå¯é æ€§**ï¼šç¨³å®šæ€§åˆ†æä¿è¯äº†ç³»ç»Ÿåœ¨å„ç§è´Ÿè½½ä¸‹çš„å¯é æ€§
- **å‚æ•°è°ƒä¼˜**ï¼šé€šè¿‡ç¨³å®šæ€§åˆ†æå¯ä»¥ä¼˜åŒ–æ§åˆ¶å‚æ•°
- **æ•…éšœé¢„é˜²**ï¼šè¯†åˆ«å¯èƒ½å¯¼è‡´ç³»ç»Ÿä¸ç¨³å®šçš„å› ç´ ï¼Œæå‰é¢„é˜²

### 5.1 æ§åˆ¶ç³»ç»Ÿçš„é²æ£’æ€§

**å®šç†71**ï¼ˆæ§åˆ¶ç³»ç»Ÿçš„é²æ£’æ€§ï¼‰ï¼š
åœ¨æ»¡è¶³ç¨³å®šæ€§æ¡ä»¶ä¸‹ï¼Œæ§åˆ¶ç³»ç»Ÿå¯¹å‚æ•°æ‰°åŠ¨æ˜¯é²æ£’çš„ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šé²æ£’æ€§å®šä¹‰

**å®šä¹‰**ï¼ˆé²æ£’æ€§ï¼‰ï¼š
æ§åˆ¶ç³»ç»Ÿæ˜¯é²æ£’çš„ï¼Œå½“ä¸”ä»…å½“å¯¹å‚æ•°æ‰°åŠ¨ $\Delta A$ï¼Œç³»ç»Ÿä»ç„¶ç¨³å®šï¼Œå³ $A + \Delta A$ çš„ç‰¹å¾å€¼ä»åœ¨å•ä½åœ†å†…ã€‚

#### æ­¥éª¤2ï¼šé²æ£’æ€§æ¡ä»¶

**å¼•ç†71.1**ï¼ˆé²æ£’æ€§æ¡ä»¶ï¼‰ï¼š
å¦‚æœ $\|\Delta A\| < \delta$ï¼Œä¸” $\delta$ è¶³å¤Ÿå°ï¼Œåˆ™ç³»ç»Ÿä¿æŒç¨³å®šã€‚

**è¯æ˜**ï¼š
ç”±ç‰¹å¾å€¼çš„è¿ç»­æ€§ï¼Œå¦‚æœæ‰°åŠ¨è¶³å¤Ÿå°ï¼Œç‰¹å¾å€¼ä¸ä¼šç¦»å¼€å•ä½åœ†ï¼Œå› æ­¤ç³»ç»Ÿä¿æŒç¨³å®šã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†71.1ï¼Œåœ¨æ»¡è¶³ç¨³å®šæ€§æ¡ä»¶ä¸‹ï¼Œæ§åˆ¶ç³»ç»Ÿå¯¹å‚æ•°æ‰°åŠ¨æ˜¯é²æ£’çš„ã€‚ âˆ

### 5.2 æ§åˆ¶ç³»ç»Ÿçš„å®é™…åº”ç”¨

#### 5.2.1 è‡ªé€‚åº”æ§åˆ¶

**åœºæ™¯**ï¼šä½¿ç”¨è‡ªé€‚åº”æ§åˆ¶ç­–ç•¥è°ƒæ•´ç³»ç»Ÿå‚æ•°ã€‚

**æ–¹æ³•**ï¼š

1. ç›‘æ§ç³»ç»ŸçŠ¶æ€
2. è®¡ç®—æ§åˆ¶è¯¯å·®
3. è‡ªé€‚åº”è°ƒæ•´æ§åˆ¶å‚æ•°

**Golangå®ç°**ï¼š

```go
package control

// è‡ªé€‚åº”æ§åˆ¶å™¨
type AdaptiveController struct {
    kp    float64 // æ¯”ä¾‹ç³»æ•°
    ki    float64 // ç§¯åˆ†ç³»æ•°
    kd    float64 // å¾®åˆ†ç³»æ•°
    error float64 // ç´¯ç§¯è¯¯å·®
}

// è‡ªé€‚åº”è°ƒæ•´å‚æ•°
func (c *AdaptiveController) Adapt(error, errorRate float64) {
    // æ ¹æ®è¯¯å·®å’Œè¯¯å·®å˜åŒ–ç‡è°ƒæ•´å‚æ•°
    if math.Abs(error) > threshold {
        c.kp *= 1.1 // å¢åŠ æ¯”ä¾‹ç³»æ•°
    }

    if math.Abs(errorRate) > threshold {
        c.kd *= 1.1 // å¢åŠ å¾®åˆ†ç³»æ•°
    }

    // æ›´æ–°ç´¯ç§¯è¯¯å·®
    c.error += error
}

// è®¡ç®—æ§åˆ¶è¾“å‡º
func (c *AdaptiveController) Compute(reference, actual float64) float64 {
    error := reference - actual
    errorRate := error - c.error

    // PIDæ§åˆ¶
    output := c.kp*error + c.ki*c.error + c.kd*errorRate

    // è‡ªé€‚åº”è°ƒæ•´
    c.Adapt(error, errorRate)

    return output
}
```

**Pythonå®ç°**ï¼š

```python
class AdaptiveController:
    def __init__(self, kp: float = 1.0, ki: float = 0.1, kd: float = 0.01):
        self.kp = kp  # æ¯”ä¾‹ç³»æ•°
        self.ki = ki  # ç§¯åˆ†ç³»æ•°
        self.kd = kd  # å¾®åˆ†ç³»æ•°
        self.error = 0.0  # ç´¯ç§¯è¯¯å·®

    def adapt(self, error: float, error_rate: float):
        """è‡ªé€‚åº”è°ƒæ•´å‚æ•°"""
        # æ ¹æ®è¯¯å·®å’Œè¯¯å·®å˜åŒ–ç‡è°ƒæ•´å‚æ•°
        if abs(error) > threshold:
            self.kp *= 1.1  # å¢åŠ æ¯”ä¾‹ç³»æ•°

        if abs(error_rate) > threshold:
            self.kd *= 1.1  # å¢åŠ å¾®åˆ†ç³»æ•°

        # æ›´æ–°ç´¯ç§¯è¯¯å·®
        self.error += error

    def compute(self, reference: float, actual: float) -> float:
        """è®¡ç®—æ§åˆ¶è¾“å‡º"""
        error = reference - actual
        error_rate = error - self.error

        # PIDæ§åˆ¶
        output = self.kp * error + self.ki * self.error + self.kd * error_rate

        # è‡ªé€‚åº”è°ƒæ•´
        self.adapt(error, error_rate)

        return output
```

**Rustå®ç°**ï¼š

```rust
pub struct AdaptiveController {
    kp: f64,    // æ¯”ä¾‹ç³»æ•°
    ki: f64,    // ç§¯åˆ†ç³»æ•°
    kd: f64,    // å¾®åˆ†ç³»æ•°
    error: f64, // ç´¯ç§¯è¯¯å·®
}

impl AdaptiveController {
    pub fn adapt(&mut self, error: f64, error_rate: f64) {
        // æ ¹æ®è¯¯å·®å’Œè¯¯å·®å˜åŒ–ç‡è°ƒæ•´å‚æ•°
        if error.abs() > THRESHOLD {
            self.kp *= 1.1; // å¢åŠ æ¯”ä¾‹ç³»æ•°
        }

        if error_rate.abs() > THRESHOLD {
            self.kd *= 1.1; // å¢åŠ å¾®åˆ†ç³»æ•°
        }

        // æ›´æ–°ç´¯ç§¯è¯¯å·®
        self.error += error;
    }

    pub fn compute(&mut self, reference: f64, actual: f64) -> f64 {
        // è®¡ç®—æ§åˆ¶è¾“å‡º
        let error = reference - actual;
        let error_rate = error - self.error;

        // PIDæ§åˆ¶
        let output = self.kp * error + self.ki * self.error + self.kd * error_rate;

        // è‡ªé€‚åº”è°ƒæ•´
        self.adapt(error, error_rate);

        output
    }
}
```

---

## 5. ç›¸å…³æ–‡æ¡£

- [è¿”å› FormalModel ç›®å½•](../README.md)
- [03_å¤šæ¨¡å‹è§†è§’ README](README.md)
- [03.2_æ’é˜Ÿè®ºè§†è§’](03.2_æ’é˜Ÿè®ºè§†è§’.md)
- [03.4_åšå¼ˆè®ºè§†è§’](03.4_åšå¼ˆè®ºè§†è§’.md)
- [04.2_åé¦ˆæ§åˆ¶å¾ªç¯](../04_åŠ¨æ€äº¤äº’æ¨¡å‹/04.2_åé¦ˆæ§åˆ¶å¾ªç¯.md)

---

**æœ€åæ›´æ–°**: 2025-01-27
