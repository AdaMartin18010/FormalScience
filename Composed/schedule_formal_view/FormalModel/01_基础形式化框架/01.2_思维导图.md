# 01.2 æ€ç»´å¯¼å›¾

> **æ‰€å±ä¸»é¢˜**: 01_åŸºç¡€å½¢å¼åŒ–æ¡†æ¶
> **æœ€åæ›´æ–°**: 2025-01-27

## ğŸ“‹ ç›®å½•

- [01.2 æ€ç»´å¯¼å›¾](#012-æ€ç»´å¯¼å›¾)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ä¸‰å±‚è°ƒåº¦ç³»ç»Ÿå®Œæ•´æ€ç»´å¯¼å›¾](#1-ä¸‰å±‚è°ƒåº¦ç³»ç»Ÿå®Œæ•´æ€ç»´å¯¼å›¾)
    - [å®Œæ•´æ€ç»´å¯¼å›¾ç»“æ„](#å®Œæ•´æ€ç»´å¯¼å›¾ç»“æ„)
    - [1.1 æ ¸å¿ƒæŠ½è±¡å±‚ï¼ˆè¯¦ç»†å±•å¼€ï¼‰](#11-æ ¸å¿ƒæŠ½è±¡å±‚è¯¦ç»†å±•å¼€)
      - [èµ„æºæŠ½è±¡è¯¦ç»†å¯¹æ¯”](#èµ„æºæŠ½è±¡è¯¦ç»†å¯¹æ¯”)
      - [å®ä½“æŠ½è±¡è¯¦ç»†å¯¹æ¯”](#å®ä½“æŠ½è±¡è¯¦ç»†å¯¹æ¯”)
      - [çº¦æŸæŠ½è±¡è¯¦ç»†å¯¹æ¯”](#çº¦æŸæŠ½è±¡è¯¦ç»†å¯¹æ¯”)
    - [1.2 è°ƒåº¦ç®—æ³•å…±æ€§ï¼ˆè¯¦ç»†å±•å¼€ï¼‰](#12-è°ƒåº¦ç®—æ³•å…±æ€§è¯¦ç»†å±•å¼€)
      - [åŸºç¡€ç®—æ³•è¯¦ç»†å¯¹æ¯”](#åŸºç¡€ç®—æ³•è¯¦ç»†å¯¹æ¯”)
      - [é«˜çº§ç­–ç•¥è¯¦ç»†å¯¹æ¯”](#é«˜çº§ç­–ç•¥è¯¦ç»†å¯¹æ¯”)
    - [1.3 æ•°æ®ç»“æ„å…±æ€§ï¼ˆè¯¦ç»†å±•å¼€ï¼‰](#13-æ•°æ®ç»“æ„å…±æ€§è¯¦ç»†å±•å¼€)
      - [æ ¸å¿ƒç»“æ„è¯¦ç»†å¯¹æ¯”](#æ ¸å¿ƒç»“æ„è¯¦ç»†å¯¹æ¯”)
    - [1.4 é€šä¿¡ä¸åŒæ­¥ï¼ˆè¯¦ç»†å±•å¼€ï¼‰](#14-é€šä¿¡ä¸åŒæ­¥è¯¦ç»†å±•å¼€)
      - [æ§åˆ¶å¹³é¢è¯¦ç»†å¯¹æ¯”](#æ§åˆ¶å¹³é¢è¯¦ç»†å¯¹æ¯”)
      - [æ•°æ®å¹³é¢è¯¦ç»†å¯¹æ¯”](#æ•°æ®å¹³é¢è¯¦ç»†å¯¹æ¯”)
    - [1.5 ç›‘æ§ä¸åé¦ˆï¼ˆè¯¦ç»†å±•å¼€ï¼‰](#15-ç›‘æ§ä¸åé¦ˆè¯¦ç»†å±•å¼€)
      - [ç›‘æ§æŒ‡æ ‡è¯¦ç»†å¯¹æ¯”](#ç›‘æ§æŒ‡æ ‡è¯¦ç»†å¯¹æ¯”)
    - [1.6 æ€§èƒ½ä¼˜åŒ–ï¼ˆè¯¦ç»†å±•å¼€ï¼‰](#16-æ€§èƒ½ä¼˜åŒ–è¯¦ç»†å±•å¼€)
      - [ä¼˜åŒ–ç­–ç•¥è¯¦ç»†å¯¹æ¯”](#ä¼˜åŒ–ç­–ç•¥è¯¦ç»†å¯¹æ¯”)
  - [2. ä¸‰å±‚ç³»ç»Ÿè¯¦ç»†å¯¹æ¯”çŸ©é˜µ](#2-ä¸‰å±‚ç³»ç»Ÿè¯¦ç»†å¯¹æ¯”çŸ©é˜µ)
    - [2.1 å®Œæ•´åŠŸèƒ½å¯¹æ¯”çŸ©é˜µ](#21-å®Œæ•´åŠŸèƒ½å¯¹æ¯”çŸ©é˜µ)
    - [2.2 æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”çŸ©é˜µ](#22-æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”çŸ©é˜µ)
    - [2.3 ç®—æ³•å¤æ‚åº¦å¯¹æ¯”çŸ©é˜µ](#23-ç®—æ³•å¤æ‚åº¦å¯¹æ¯”çŸ©é˜µ)
  - [3. å¤šè¯­è¨€å®ç°ç¤ºä¾‹](#3-å¤šè¯­è¨€å®ç°ç¤ºä¾‹)
    - [3.1 Golangå®ç°](#31-golangå®ç°)
      - [ç»Ÿä¸€èµ„æºæŠ½è±¡æ¥å£](#ç»Ÿä¸€èµ„æºæŠ½è±¡æ¥å£)
      - [çŠ¶æ€æœºå®ç°](#çŠ¶æ€æœºå®ç°)
    - [3.2 Pythonå®ç°](#32-pythonå®ç°)
      - [ç»Ÿä¸€èµ„æºæŠ½è±¡æ¨¡å‹](#ç»Ÿä¸€èµ„æºæŠ½è±¡æ¨¡å‹)
    - [3.3 Rustå®ç°](#33-rustå®ç°)
      - [ç»Ÿä¸€èµ„æºæŠ½è±¡æ¨¡å‹](#ç»Ÿä¸€èµ„æºæŠ½è±¡æ¨¡å‹-1)
  - [4. æ€ç»´å¯¼å›¾çš„å®é™…åº”ç”¨](#4-æ€ç»´å¯¼å›¾çš„å®é™…åº”ç”¨)
    - [4.1 ç³»ç»Ÿè®¾è®¡æŒ‡å¯¼](#41-ç³»ç»Ÿè®¾è®¡æŒ‡å¯¼)
    - [4.2 ç®—æ³•ç§»æ¤](#42-ç®—æ³•ç§»æ¤)
    - [4.3 æ€§èƒ½ä¼˜åŒ–](#43-æ€§èƒ½ä¼˜åŒ–)
    - [4.4 æ•™å­¦ä¸ç ”ç©¶](#44-æ•™å­¦ä¸ç ”ç©¶)
    - [4.5 ä¸‰å±‚ç³»ç»ŸåŠ¨æ€äº¤äº’æµ](#45-ä¸‰å±‚ç³»ç»ŸåŠ¨æ€äº¤äº’æµ)
      - [4.5.1 å®ä½“ç”Ÿå‘½å‘¨æœŸçŠ¶æ€æœº](#451-å®ä½“ç”Ÿå‘½å‘¨æœŸçŠ¶æ€æœº)
      - [4.5.2 èµ„æºåˆ†é…å†³ç­–æ ‘](#452-èµ„æºåˆ†é…å†³ç­–æ ‘)
  - [5. ç›¸å…³æ–‡æ¡£](#5-ç›¸å…³æ–‡æ¡£)

---

## 1. ä¸‰å±‚è°ƒåº¦ç³»ç»Ÿå®Œæ•´æ€ç»´å¯¼å›¾

### å®Œæ•´æ€ç»´å¯¼å›¾ç»“æ„

```text
ä¸‰å±‚è°ƒåº¦ç³»ç»Ÿç»Ÿä¸€æ¨¡å‹
â”‚
â”œâ”€â”€ 1. æ ¸å¿ƒæŠ½è±¡å±‚
â”‚   â”œâ”€â”€ 1.1 èµ„æºæŠ½è±¡
â”‚   â”‚   â”œâ”€â”€ 1.1.1 å¯åˆ†èµ„æº
â”‚   â”‚   â”‚   â”œâ”€â”€ CPUæ—¶é—´ç‰‡
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: jiffies (1-10ms)
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: vCPUå‘¨æœŸ (50-100Î¼s)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: cgroupå‘¨æœŸ (100ms)
â”‚   â”‚   â”‚   â”œâ”€â”€ å†…å­˜é¡µ
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: 4KB/2MB/1GB pages
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: balloon pages
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: cgroup memory.limit
â”‚   â”‚   â”‚   â””â”€â”€ ç½‘ç»œå¸¦å®½
â”‚   â”‚   â”‚       â”œâ”€â”€ OSå±‚: tc (traffic control)
â”‚   â”‚   â”‚       â”œâ”€â”€ VMå±‚: vSwitch QoS
â”‚   â”‚   â”‚       â””â”€â”€ å®¹å™¨å±‚: CNI bandwidth plugin
â”‚   â”‚   â”œâ”€â”€ 1.1.2 ä¸å¯åˆ†èµ„æº
â”‚   â”‚   â”‚   â”œâ”€â”€ GPUè®¾å¤‡
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: /dev/nvidia0
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: GPU passthrough
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: device plugin
â”‚   â”‚   â”‚   â”œâ”€â”€ ç½‘ç»œç«¯å£
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: bind()ç³»ç»Ÿè°ƒç”¨
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: ç«¯å£æ˜ å°„
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: Service/Ingress
â”‚   â”‚   â”‚   â””â”€â”€ å­˜å‚¨å·
â”‚   â”‚   â”‚       â”œâ”€â”€ OSå±‚: mount()ç³»ç»Ÿè°ƒç”¨
â”‚   â”‚   â”‚       â”œâ”€â”€ VMå±‚: è™šæ‹Ÿç£ç›˜
â”‚   â”‚   â”‚       â””â”€â”€ å®¹å™¨å±‚: PersistentVolume
â”‚   â”‚   â””â”€â”€ 1.1.3 æ‹“æ‰‘æ„ŸçŸ¥
â”‚   â”‚       â”œâ”€â”€ NUMAæ‹“æ‰‘
â”‚   â”‚       â”‚   â”œâ”€â”€ OSå±‚: numa_node
â”‚   â”‚       â”‚   â”œâ”€â”€ VMå±‚: NUMAé…ç½®
â”‚   â”‚       â”‚   â””â”€â”€ å®¹å™¨å±‚: TopologyManager
â”‚   â”‚       â”œâ”€â”€ CPUäº²å’Œæ€§
â”‚   â”‚       â”‚   â”œâ”€â”€ OSå±‚: sched_setaffinity()
â”‚   â”‚       â”‚   â”œâ”€â”€ VMå±‚: vCPU pinning
â”‚   â”‚       â”‚   â””â”€â”€ å®¹å™¨å±‚: cpuManagerPolicy
â”‚   â”‚       â””â”€â”€ èŠ‚ç‚¹äº²å’Œæ€§
â”‚   â”‚           â”œâ”€â”€ OSå±‚: è¿›ç¨‹è¿ç§»
â”‚   â”‚           â”œâ”€â”€ VMå±‚: DRSè§„åˆ™
â”‚   â”‚           â””â”€â”€ å®¹å™¨å±‚: nodeAffinity
â”‚   â”‚
â”‚   â”œâ”€â”€ 1.2 å®ä½“æŠ½è±¡
â”‚   â”‚   â”œâ”€â”€ 1.2.1 ç”Ÿå‘½å‘¨æœŸç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ åˆ›å»ºé˜¶æ®µ
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: fork()/clone()
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: clone_vm()
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: docker create/kubectl create
â”‚   â”‚   â”‚   â”œâ”€â”€ è¿è¡Œé˜¶æ®µ
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: execve()
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: vm_start()
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: docker start/kubectl apply
â”‚   â”‚   â”‚   â”œâ”€â”€ æš‚åœé˜¶æ®µ
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: SIGSTOP
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: vm_suspend()
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: docker pause
â”‚   â”‚   â”‚   â””â”€â”€ ç»ˆæ­¢é˜¶æ®µ
â”‚   â”‚   â”‚       â”œâ”€â”€ OSå±‚: exit()/kill()
â”‚   â”‚   â”‚       â”œâ”€â”€ VMå±‚: vm_destroy()
â”‚   â”‚   â”‚       â””â”€â”€ å®¹å™¨å±‚: docker rm/kubectl delete
â”‚   â”‚   â”œâ”€â”€ 1.2.2 çŠ¶æ€æœºæ¨¡å‹
â”‚   â”‚   â”‚   â”œâ”€â”€ çŠ¶æ€å®šä¹‰
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ INIT: åˆå§‹çŠ¶æ€
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PENDING: ç­‰å¾…è°ƒåº¦
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RUNNING: è¿è¡Œä¸­
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SUSPENDED: æŒ‚èµ·
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ TERMINATED: ç»ˆæ­¢
â”‚   â”‚   â”‚   â”œâ”€â”€ çŠ¶æ€è½¬ç§»
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ INIT â†’ PENDING: create_entity()
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PENDING â†’ RUNNING: scheduler_activate()
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RUNNING â†’ SUSPENDED: preempt_or_migrate()
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ANY â†’ TERMINATED: release_resources()
â”‚   â”‚   â”‚   â””â”€â”€ çŠ¶æ€æŸ¥è¯¢
â”‚   â”‚   â”‚       â”œâ”€â”€ OSå±‚: /proc/[pid]/stat
â”‚   â”‚   â”‚       â”œâ”€â”€ VMå±‚: libvirt API
â”‚   â”‚   â”‚       â””â”€â”€ å®¹å™¨å±‚: kubectl get pod
â”‚   â”‚   â””â”€â”€ 1.2.3 ä¼˜å…ˆçº§/æƒé‡æœºåˆ¶
â”‚   â”‚       â”œâ”€â”€ é™æ€ä¼˜å…ˆçº§
â”‚   â”‚       â”‚   â”œâ”€â”€ OSå±‚: niceå€¼ (-20åˆ°19)
â”‚   â”‚       â”‚   â”œâ”€â”€ VMå±‚: CPU shares
â”‚   â”‚       â”‚   â””â”€â”€ å®¹å™¨å±‚: priorityClassName
â”‚   â”‚       â”œâ”€â”€ åŠ¨æ€ä¼˜å…ˆçº§
â”‚   â”‚       â”‚   â”œâ”€â”€ OSå±‚: CFS vruntime
â”‚   â”‚       â”‚   â”œâ”€â”€ VMå±‚: EEVDFç®—æ³•
â”‚   â”‚       â”‚   â””â”€â”€ å®¹å™¨å±‚: cgroup cpu.shares
â”‚   â”‚       â””â”€â”€ æƒé‡è®¡ç®—
â”‚   â”‚           â”œâ”€â”€ OSå±‚: load.weight = 1024 * 1.25^(-nice)
â”‚   â”‚           â”œâ”€â”€ VMå±‚: weight = cpu_shares / total_shares
â”‚   â”‚           â””â”€â”€ å®¹å™¨å±‚: weight = cpu.shares / sum(cpu.shares)
â”‚   â”‚
â”‚   â””â”€â”€ 1.3 çº¦æŸæŠ½è±¡
â”‚       â”œâ”€â”€ 1.3.1 ç¡¬çº¦æŸ
â”‚       â”‚   â”œâ”€â”€ èµ„æºä¸Šé™
â”‚       â”‚   â”‚   â”œâ”€â”€ OSå±‚: RLIMIT_CPU, RLIMIT_MEMLOCK
â”‚       â”‚   â”‚   â”œâ”€â”€ VMå±‚: vCPUæ•°é‡, å†…å­˜ä¸Šé™
â”‚       â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: resources.limits
â”‚       â”‚   â”œâ”€â”€ éš”ç¦»æ€§è¦æ±‚
â”‚       â”‚   â”‚   â”œâ”€â”€ OSå±‚: namespaceéš”ç¦»
â”‚       â”‚   â”‚   â”œâ”€â”€ VMå±‚: ç¡¬ä»¶éš”ç¦»
â”‚       â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: cgroupéš”ç¦»
â”‚       â”‚   â””â”€â”€ å®‰å…¨çº¦æŸ
â”‚       â”‚       â”œâ”€â”€ OSå±‚: SELinux, AppArmor
â”‚       â”‚       â”œâ”€â”€ VMå±‚: TPM, secure boot
â”‚       â”‚       â””â”€â”€ å®¹å™¨å±‚: PodSecurityPolicy
â”‚       â”œâ”€â”€ 1.3.2 è½¯çº¦æŸ
â”‚       â”‚   â”œâ”€â”€ èµ„æºåå¥½
â”‚       â”‚   â”‚   â”œâ”€â”€ OSå±‚: CPU affinityåå¥½
â”‚       â”‚   â”‚   â”œâ”€â”€ VMå±‚: ä¸»æœºåå¥½
â”‚       â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: preferredDuringScheduling
â”‚       â”‚   â”œâ”€â”€ QoSç­‰çº§
â”‚       â”‚   â”‚   â”œâ”€â”€ OSå±‚: å®æ—¶è¿›ç¨‹ä¼˜å…ˆçº§
â”‚       â”‚   â”‚   â”œâ”€â”€ VMå±‚: SLAç­‰çº§
â”‚       â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: Guaranteed/Burstable/BestEffort
â”‚       â”‚   â””â”€â”€ æ€§èƒ½ç›®æ ‡
â”‚       â”‚       â”œâ”€â”€ OSå±‚: å»¶è¿Ÿç›®æ ‡
â”‚       â”‚       â”œâ”€â”€ VMå±‚: ååé‡ç›®æ ‡
â”‚       â”‚       â””â”€â”€ å®¹å™¨å±‚: HPAç›®æ ‡
â”‚       â””â”€â”€ 1.3.3 æ—¶åºçº¦æŸ
â”‚           â”œâ”€â”€ æˆªæ­¢æ—¶é—´
â”‚           â”‚   â”œâ”€â”€ OSå±‚: SCHED_DEADLINE
â”‚           â”‚   â”œâ”€â”€ VMå±‚: è¿ç§»æ—¶é—´çª—å£
â”‚           â”‚   â””â”€â”€ å®¹å™¨å±‚: PodDisruptionBudget
â”‚           â”œâ”€â”€ ä¾èµ–å…³ç³»
â”‚           â”‚   â”œâ”€â”€ OSå±‚: wait()ç³»ç»Ÿè°ƒç”¨
â”‚           â”‚   â”œâ”€â”€ VMå±‚: å¯åŠ¨é¡ºåº
â”‚           â”‚   â””â”€â”€ å®¹å™¨å±‚: initContainers
â”‚           â””â”€â”€ å‘¨æœŸæ€§ä»»åŠ¡
â”‚               â”œâ”€â”€ OSå±‚: cron
â”‚               â”œâ”€â”€ VMå±‚: å®šæ—¶å¿«ç…§
â”‚               â””â”€â”€ å®¹å™¨å±‚: CronJob
â”‚
â”œâ”€â”€ 2. è°ƒåº¦ç®—æ³•å…±æ€§
â”‚   â”œâ”€â”€ 2.1 åŸºç¡€ç®—æ³•
â”‚   â”‚   â”œâ”€â”€ 2.1.1 æ—¶é—´ç‰‡è½®è½¬ (RR)
â”‚   â”‚   â”‚   â”œâ”€â”€ ç®—æ³•åŸç†
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ å…¬å¹³åˆ†é…CPUæ—¶é—´ï¼Œæ¯ä¸ªå®ä½“è·å¾—ç›¸ç­‰æ—¶é—´ç‰‡
â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚å®ç°
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SCHED_RRç­–ç•¥
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ æ—¶é—´ç‰‡: 6ms (RR_INTERVAL)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ å®ç°: kernel/sched/rt.c
â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚å®ç°
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Creditè°ƒåº¦å™¨
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ æ—¶é—´ç‰‡: 30ms
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ å®ç°: xen/common/sched_credit.c
â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚å®ç°
â”‚   â”‚   â”‚       â”œâ”€â”€ cgroup cpu.cfs_period_us
â”‚   â”‚   â”‚       â”œâ”€â”€ æ—¶é—´ç‰‡: 100ms
â”‚   â”‚   â”‚       â””â”€â”€ å®ç°: kernel/cgroup/cpu.c
â”‚   â”‚   â”œâ”€â”€ 2.1.2 ä¼˜å…ˆçº§è°ƒåº¦
â”‚   â”‚   â”‚   â”œâ”€â”€ ç®—æ³•åŸç†
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ é«˜ä¼˜å…ˆçº§å®ä½“ä¼˜å…ˆè·å¾—èµ„æº
â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚å®ç°
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SCHED_FIFO/SCHED_RR
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ä¼˜å…ˆçº§: 1-99 (å®æ—¶), 100-139 (æ™®é€š)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ å®ç°: kernel/sched/rt.c
â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚å®ç°
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CPUä¼˜å…ˆçº§
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ä¼˜å…ˆçº§: 1-100
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ å®ç°: libvirt CPUé…ç½®
â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚å®ç°
â”‚   â”‚   â”‚       â”œâ”€â”€ priorityClassName
â”‚   â”‚   â”‚       â”œâ”€â”€ ä¼˜å…ˆçº§: 0-1000
â”‚   â”‚   â”‚       â””â”€â”€ å®ç°: kube-scheduler
â”‚   â”‚   â””â”€â”€ 2.1.3 æˆªæ­¢æœŸè°ƒåº¦ (EDF)
â”‚   â”‚       â”œâ”€â”€ ç®—æ³•åŸç†
â”‚   â”‚       â”‚   â””â”€â”€ æœ€æ—©æˆªæ­¢æœŸä¼˜å…ˆæ‰§è¡Œ
â”‚   â”‚       â”œâ”€â”€ OSå±‚å®ç°
â”‚   â”‚       â”‚   â”œâ”€â”€ SCHED_DEADLINE
â”‚   â”‚       â”‚   â”œâ”€â”€ æˆªæ­¢æœŸ: deadlineå‚æ•°
â”‚   â”‚       â”‚   â””â”€â”€ å®ç°: kernel/sched/deadline.c
â”‚   â”‚       â”œâ”€â”€ VMå±‚å®ç°
â”‚   â”‚       â”‚   â”œâ”€â”€ è¿ç§»æˆªæ­¢æœŸ
â”‚   â”‚       â”‚   â”œâ”€â”€ æˆªæ­¢æœŸ: SLAè¦æ±‚
â”‚   â”‚       â”‚   â””â”€â”€ å®ç°: vMotionè°ƒåº¦
â”‚   â”‚       â””â”€â”€ å®¹å™¨å±‚å®ç°
â”‚   â”‚           â”œâ”€â”€ PodDisruptionBudget
â”‚   â”‚           â”œâ”€â”€ æˆªæ­¢æœŸ: minAvailableæ—¶é—´
â”‚   â”‚           â””â”€â”€ å®ç°: kube-controller-manager
â”‚   â”‚
â”‚   â”œâ”€â”€ 2.2 é«˜çº§ç­–ç•¥
â”‚   â”‚   â”œâ”€â”€ 2.2.1 ä¸¤çº§è°ƒåº¦
â”‚   â”‚   â”‚   â”œâ”€â”€ å…¨å±€åˆ†é…å±‚
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: è´Ÿè½½å‡è¡¡å™¨
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: DRS (Distributed Resource Scheduler)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: kube-scheduler
â”‚   â”‚   â”‚   â””â”€â”€ æœ¬åœ°æ‰§è¡Œå±‚
â”‚   â”‚   â”‚       â”œâ”€â”€ OSå±‚: æœ¬åœ°CPUè°ƒåº¦å™¨
â”‚   â”‚   â”‚       â”œâ”€â”€ VMå±‚: æœ¬åœ°vCPUè°ƒåº¦
â”‚   â”‚   â”‚       â””â”€â”€ å®¹å™¨å±‚: kubelet
â”‚   â”‚   â”œâ”€â”€ 2.2.2 é¢„ç®—é…é¢
â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: cgroup cpu.cfs_quota_us
â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: CPU reservation/limit
â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: resources.requests/limits
â”‚   â”‚   â””â”€â”€ 2.2.3 è´Ÿè½½å‡è¡¡
â”‚   â”‚       â”œâ”€â”€ OSå±‚: sched_balance_work()
â”‚   â”‚       â”œâ”€â”€ VMå±‚: DRSè´Ÿè½½å‡è¡¡
â”‚   â”‚       â””â”€â”€ å®¹å™¨å±‚: HPA (Horizontal Pod Autoscaler)
â”‚   â”‚
â”‚   â””â”€â”€ 2.3 æ•°å­¦æ¨¡å‹
â”‚       â”œâ”€â”€ 2.3.1 æ’é˜Ÿè®ºæ¨¡å‹
â”‚       â”‚   â”œâ”€â”€ M/G/1-PSæ¨¡å‹
â”‚       â”‚   â”œâ”€â”€ å“åº”æ—¶é—´å…¬å¼: T = W + S
â”‚       â”‚   â””â”€â”€ åˆ©ç‰¹å°”å®šå¾‹: L = Î»W
â”‚       â”œâ”€â”€ 2.3.2 æ§åˆ¶ç†è®º
â”‚       â”‚   â”œâ”€â”€ PIDæ§åˆ¶å™¨
â”‚       â”‚   â”œâ”€â”€ çŠ¶æ€ç©ºé—´æ¨¡å‹
â”‚       â”‚   â””â”€â”€ æé›…æ™®è¯ºå¤«ç¨³å®šæ€§
â”‚       â””â”€â”€ 2.3.3 åšå¼ˆè®º
â”‚           â”œâ”€â”€ çº³ä»€å‡è¡¡
â”‚           â”œâ”€â”€ åŠ¿å‡½æ•°
â”‚           â””â”€â”€ å¸•ç´¯æ‰˜æœ€ä¼˜
â”‚
â”œâ”€â”€ 3. æ•°æ®ç»“æ„å…±æ€§
â”‚   â”œâ”€â”€ 3.1 æ ¸å¿ƒç»“æ„
â”‚   â”‚   â”œâ”€â”€ 3.1.1 çº¢é»‘æ ‘
â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: CFSè°ƒåº¦å®ä½“
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ é”®å€¼: vruntime
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ æ“ä½œ: O(log n)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ å®ç°: kernel/sched/fair.c
â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: ä¼˜å…ˆçº§é˜Ÿåˆ—
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ é”®å€¼: priority
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ æ“ä½œ: O(log n)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ å®ç°: è™šæ‹ŸåŒ–å±‚è°ƒåº¦å™¨
â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: æœåŠ¡ä¼˜å…ˆçº§
â”‚   â”‚   â”‚       â”œâ”€â”€ é”®å€¼: priority
â”‚   â”‚   â”‚       â”œâ”€â”€ æ“ä½œ: O(log n)
â”‚   â”‚   â”‚       â””â”€â”€ å®ç°: kube-scheduler
â”‚   â”‚   â”œâ”€â”€ 3.1.2 æœ€å°å †
â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: æˆªæ­¢æœŸé˜Ÿåˆ—
â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: äº‹ä»¶å®šæ—¶å™¨
â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: è°ƒåº¦é˜Ÿåˆ—
â”‚   â”‚   â””â”€â”€ 3.1.3 ä½å›¾
â”‚   â”‚       â”œâ”€â”€ OSå±‚: CPU affinity (cpumask_t)
â”‚   â”‚       â”œâ”€â”€ VMå±‚: å¯ç”¨èµ„æºä½å›¾
â”‚   â”‚       â””â”€â”€ å®¹å™¨å±‚: èŠ‚ç‚¹é€‰æ‹©ä½å›¾
â”‚   â”‚
â”‚   â”œâ”€â”€ 3.2 èµ„æºç®¡ç†
â”‚   â”‚   â”œâ”€â”€ 3.2.1 ä¼™ä¼´ç³»ç»Ÿ
â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: å†…å­˜é¡µåˆ†é…
â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: è™šæ‹Ÿå†…å­˜ç®¡ç†
â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: å­˜å‚¨å±‚åˆ†é…
â”‚   â”‚   â”œâ”€â”€ 3.2.2 slabåˆ†é…å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: å†…æ ¸å¯¹è±¡ç¼“å­˜
â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: å…ƒæ•°æ®ç¼“å­˜
â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: å®¹å™¨å…ƒæ•°æ®
â”‚   â”‚   â””â”€â”€ 3.2.3 äº‹åŠ¡æ—¥å¿—
â”‚   â”‚       â”œâ”€â”€ OSå±‚: Journalingæ–‡ä»¶ç³»ç»Ÿ
â”‚   â”‚       â”œâ”€â”€ VMå±‚: å¿«ç…§æ—¥å¿—
â”‚   â”‚       â””â”€â”€ å®¹å™¨å±‚: etcdä¸€è‡´æ€§æ—¥å¿—
â”‚   â”‚
â”‚   â””â”€â”€ 3.3 ç´¢å¼•ç»“æ„
â”‚       â”œâ”€â”€ 3.3.1 å“ˆå¸Œè¡¨
â”‚       â”‚   â”œâ”€â”€ OSå±‚: PID â†’ task_structæ˜ å°„
â”‚       â”‚   â”œâ”€â”€ VMå±‚: UUID â†’ VMå¯¹è±¡æ˜ å°„
â”‚       â”‚   â””â”€â”€ å®¹å™¨å±‚: Pod UID â†’ Podå¯¹è±¡æ˜ å°„
â”‚       â”œâ”€â”€ 3.3.2 Radixæ ‘
â”‚       â”‚   â”œâ”€â”€ OSå±‚: è™šæ‹Ÿåœ°å€æ˜ å°„
â”‚       â”‚   â”œâ”€â”€ VMå±‚: è™šæ‹Ÿå†…å­˜æ˜ å°„
â”‚       â”‚   â””â”€â”€ å®¹å™¨å±‚: å­˜å‚¨å·æ˜ å°„
â”‚       â””â”€â”€ 3.3.3 B+æ ‘
â”‚           â”œâ”€â”€ OSå±‚: æ–‡ä»¶ç³»ç»Ÿç´¢å¼•
â”‚           â”œâ”€â”€ VMå±‚: è™šæ‹Ÿç£ç›˜ç´¢å¼•
â”‚           â””â”€â”€ å®¹å™¨å±‚: é•œåƒåˆ†å±‚ç´¢å¼•
â”‚
â”œâ”€â”€ 4. é€šä¿¡ä¸åŒæ­¥
â”‚   â”œâ”€â”€ 4.1 æ§åˆ¶å¹³é¢
â”‚   â”‚   â”œâ”€â”€ 4.1.1 äº‹ä»¶é©±åŠ¨æ¨¡å‹
â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: epoll/kqueue
â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: äº‹ä»¶é€šé“
â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: watch API
â”‚   â”‚   â”œâ”€â”€ 4.1.2 çŠ¶æ€å¹¿æ’­
â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: procfs/sysfs
â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: libvirtäº‹ä»¶
â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: Metrics API
â”‚   â”‚   â””â”€â”€ 4.1.3 ä¸€è‡´æ€§åè®®
â”‚   â”‚       â”œâ”€â”€ OSå±‚: futex (å¿«é€Ÿç”¨æˆ·ç©ºé—´äº’æ–¥)
â”‚   â”‚       â”œâ”€â”€ VMå±‚: åˆ†å¸ƒå¼é”
â”‚   â”‚       â””â”€â”€ å®¹å™¨å±‚: Raft (etcd)
â”‚   â”‚
â”‚   â”œâ”€â”€ 4.2 æ•°æ®å¹³é¢
â”‚   â”‚   â”œâ”€â”€ 4.2.1 å…±äº«å†…å­˜
â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: shmget()/mmap()
â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: virtioå…±äº«å†…å­˜
â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: tmpfs/emptyDir
â”‚   â”‚   â”œâ”€â”€ 4.2.2 æ¶ˆæ¯é˜Ÿåˆ—
â”‚   â”‚   â”‚   â”œâ”€â”€ OSå±‚: POSIXæ¶ˆæ¯é˜Ÿåˆ—
â”‚   â”‚   â”‚   â”œâ”€â”€ VMå±‚: RabbitMQ/Kafka
â”‚   â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: NATS/Redis Streams
â”‚   â”‚   â””â”€â”€ 4.2.3 è¿œç¨‹è°ƒç”¨
â”‚   â”‚       â”œâ”€â”€ OSå±‚: ç³»ç»Ÿè°ƒç”¨ (syscall)
â”‚   â”‚       â”œâ”€â”€ VMå±‚: hypercall
â”‚   â”‚       â””â”€â”€ å®¹å™¨å±‚: gRPC/HTTP
â”‚   â”‚
â”‚   â””â”€â”€ 4.3 ç½‘ç»œæ¨¡å‹
â”‚       â”œâ”€â”€ 4.3.1 å‘½åç©ºé—´éš”ç¦»
â”‚       â”‚   â”œâ”€â”€ OSå±‚: PID/net/mnt namespace
â”‚       â”‚   â”œâ”€â”€ VMå±‚: è™šæ‹Ÿç½‘ç»œ
â”‚       â”‚   â””â”€â”€ å®¹å™¨å±‚: NetworkPolicy
â”‚       â”œâ”€â”€ 4.3.2 è½¯ä»¶å®šä¹‰ç½‘ç»œ
â”‚       â”‚   â”œâ”€â”€ OSå±‚: VLAN
â”‚       â”‚   â”œâ”€â”€ VMå±‚: Open vSwitch
â”‚       â”‚   â””â”€â”€ å®¹å™¨å±‚: CNIæ’ä»¶
â”‚       â””â”€â”€ 4.3.3 æœåŠ¡å‘ç°
â”‚           â”œâ”€â”€ OSå±‚: DNS
â”‚           â”œâ”€â”€ VMå±‚: vCenteræœåŠ¡å‘ç°
â”‚           â””â”€â”€ å®¹å™¨å±‚: Kubernetes DNS/Service Mesh
â”‚
â”œâ”€â”€ 5. ç›‘æ§ä¸åé¦ˆ
â”‚   â”œâ”€â”€ 5.1 æ€§èƒ½ç›‘æ§
â”‚   â”‚   â”œâ”€â”€ OSå±‚: perf, top, htop
â”‚   â”‚   â”œâ”€â”€ VMå±‚: vCenteræ€§èƒ½ç›‘æ§
â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: Prometheus, cAdvisor
â”‚   â”œâ”€â”€ 5.2 èµ„æºç›‘æ§
â”‚   â”‚   â”œâ”€â”€ OSå±‚: /proc/meminfo, /proc/stat
â”‚   â”‚   â”œâ”€â”€ VMå±‚: libvirtç»Ÿè®¡
â”‚   â”‚   â””â”€â”€ å®¹å™¨å±‚: Metrics API
â”‚   â””â”€â”€ 5.3 åé¦ˆæ§åˆ¶
â”‚       â”œâ”€â”€ OSå±‚: CFSè´Ÿè½½åé¦ˆ
â”‚       â”œâ”€â”€ VMå±‚: DRSè‡ªåŠ¨è°ƒæ•´
â”‚       â””â”€â”€ å®¹å™¨å±‚: HPAè‡ªåŠ¨ä¼¸ç¼©
â”‚
â””â”€â”€ 6. æ€§èƒ½ä¼˜åŒ–
    â”œâ”€â”€ 6.1 è°ƒåº¦ä¼˜åŒ–
    â”‚   â”œâ”€â”€ OSå±‚: å”¤é†’è·¯å¾„ä¼˜åŒ–
    â”‚   â”œâ”€â”€ VMå±‚: è¿ç§»ä¼˜åŒ–
    â”‚   â””â”€â”€ å®¹å™¨å±‚: è°ƒåº¦å™¨ä¼˜åŒ–
    â”œâ”€â”€ 6.2 èµ„æºä¼˜åŒ–
    â”‚   â”œâ”€â”€ OSå±‚: å†…å­˜å‹ç¼©
    â”‚   â”œâ”€â”€ VMå±‚: å†…å­˜æ°”çƒ
    â”‚   â””â”€â”€ å®¹å™¨å±‚: èµ„æºé…é¢ä¼˜åŒ–
    â””â”€â”€ 6.3 ç½‘ç»œä¼˜åŒ–
        â”œâ”€â”€ OSå±‚: é›¶æ‹·è´
        â”œâ”€â”€ VMå±‚: SR-IOV
        â””â”€â”€ å®¹å™¨å±‚: eBPFåŠ é€Ÿ
```

### 1.1 æ ¸å¿ƒæŠ½è±¡å±‚ï¼ˆè¯¦ç»†å±•å¼€ï¼‰

#### èµ„æºæŠ½è±¡è¯¦ç»†å¯¹æ¯”

| èµ„æºç±»å‹ | OSå±‚å®ç° | VMå±‚å®ç° | å®¹å™¨å±‚å®ç° | ç»Ÿä¸€æŠ½è±¡æ¥å£ |
|---------|---------|---------|-----------|------------|
| **CPUæ—¶é—´ç‰‡** | `jiffies` (1-10ms) | `vCPUå‘¨æœŸ` (50-100Î¼s) | `cgroupå‘¨æœŸ` (100ms) | `TimeSlice(duration)` |
| **å†…å­˜é¡µ** | `4KB/2MB/1GB pages` | `balloon pages` | `cgroup memory.limit` | `MemoryPage(size)` |
| **ç½‘ç»œå¸¦å®½** | `tc (traffic control)` | `vSwitch QoS` | `CNI bandwidth plugin` | `NetworkBandwidth(rate)` |
| **GPUè®¾å¤‡** | `/dev/nvidia0` | `GPU passthrough` | `device plugin` | `GPUDevice(id)` |
| **å­˜å‚¨å·** | `mount()`ç³»ç»Ÿè°ƒç”¨ | `è™šæ‹Ÿç£ç›˜` | `PersistentVolume` | `StorageVolume(path)` |

#### å®ä½“æŠ½è±¡è¯¦ç»†å¯¹æ¯”

| æŠ½è±¡ç»´åº¦ | OSå±‚ | VMå±‚ | å®¹å™¨å±‚ | ç»Ÿä¸€æ¨¡å‹ |
|---------|------|------|--------|---------|
| **åˆ›å»ºæ¥å£** | `fork()/clone()` | `clone_vm()` | `docker create` | `create_entity(spec)` |
| **çŠ¶æ€æŸ¥è¯¢** | `/proc/[pid]/stat` | `libvirt API` | `kubectl get pod` | `get_state(entity_id)` |
| **ç”Ÿå‘½å‘¨æœŸ** | `fork â†’ exec â†’ exit` | `create â†’ start â†’ destroy` | `create â†’ start â†’ delete` | `INIT â†’ PENDING â†’ RUNNING â†’ TERMINATED` |
| **ä¼˜å…ˆçº§èŒƒå›´** | `-20åˆ°19 (nice)` | `1-100 (shares)` | `0-1000 (priority)` | `normalize_priority(value, layer)` |

#### çº¦æŸæŠ½è±¡è¯¦ç»†å¯¹æ¯”

| çº¦æŸç±»å‹ | OSå±‚ | VMå±‚ | å®¹å™¨å±‚ | æ•°å­¦è¡¨è¾¾ |
|---------|------|------|--------|---------|
| **èµ„æºä¸Šé™** | `RLIMIT_CPU` | `vCPUæ•°é‡` | `resources.limits` | `âˆ€r, allocation(e, r) â‰¤ limit(r)` |
| **éš”ç¦»æ€§** | `namespace` | `ç¡¬ä»¶éš”ç¦»` | `cgroup` | `isolate(eâ‚, eâ‚‚) = true` |
| **QoSç­‰çº§** | `å®æ—¶è¿›ç¨‹ä¼˜å…ˆçº§` | `SLAç­‰çº§` | `Guaranteed/Burstable/BestEffort` | `qos_level(e) âˆˆ {high, medium, low}` |
| **æˆªæ­¢æ—¶é—´** | `SCHED_DEADLINE` | `è¿ç§»æ—¶é—´çª—å£` | `PodDisruptionBudget` | `deadline(e) â‰¥ current_time + duration` |

### 1.2 è°ƒåº¦ç®—æ³•å…±æ€§ï¼ˆè¯¦ç»†å±•å¼€ï¼‰

#### åŸºç¡€ç®—æ³•è¯¦ç»†å¯¹æ¯”

| ç®—æ³• | OSå±‚å®ç° | VMå±‚å®ç° | å®¹å™¨å±‚å®ç° | æ—¶é—´å¤æ‚åº¦ | å…¬å¹³æ€§ä¿è¯ |
|------|---------|---------|-----------|-----------|-----------|
| **æ—¶é—´ç‰‡è½®è½¬** | `SCHED_RR` (6ms) | `Creditè°ƒåº¦å™¨` (30ms) | `cgroup cpu.cfs_period_us` (100ms) | O(1) | å®Œå…¨å…¬å¹³ |
| **ä¼˜å…ˆçº§è°ƒåº¦** | `SCHED_FIFO/RR` | `CPUä¼˜å…ˆçº§` | `priorityClassName` | O(log n) | ä¼˜å…ˆçº§ä¿è¯ |
| **æˆªæ­¢æœŸè°ƒåº¦** | `SCHED_DEADLINE` | `è¿ç§»æˆªæ­¢æœŸ` | `PodDisruptionBudget` | O(log n) | æˆªæ­¢æœŸä¿è¯ |
| **å…¬å¹³è°ƒåº¦** | `CFS (vruntime)` | `EEVDFç®—æ³•` | `cgroup cpu.shares` | O(log n) | æƒé‡æ¯”ä¾‹ |

#### é«˜çº§ç­–ç•¥è¯¦ç»†å¯¹æ¯”

| ç­–ç•¥ | OSå±‚ | VMå±‚ | å®¹å™¨å±‚ | æ•°å­¦æ¨¡å‹ |
|------|------|------|--------|---------|
| **ä¸¤çº§è°ƒåº¦** | è´Ÿè½½å‡è¡¡å™¨ + æœ¬åœ°CPUè°ƒåº¦å™¨ | DRS + æœ¬åœ°vCPUè°ƒåº¦ | kube-scheduler + kubelet | `global_alloc() + local_exec()` |
| **é¢„ç®—é…é¢** | `cgroup cpu.cfs_quota_us` | `CPU reservation/limit` | `resources.requests/limits` | `âˆ«usage(t)dt â‰¤ quota` |
| **è´Ÿè½½å‡è¡¡** | `sched_balance_work()` | `DRSè´Ÿè½½å‡è¡¡` | `HPA` | `minimize(Î£\|load_i - avg_load\|)` |

### 1.3 æ•°æ®ç»“æ„å…±æ€§ï¼ˆè¯¦ç»†å±•å¼€ï¼‰

#### æ ¸å¿ƒç»“æ„è¯¦ç»†å¯¹æ¯”

| æ•°æ®ç»“æ„ | OSå±‚ä½¿ç”¨åœºæ™¯ | VMå±‚ä½¿ç”¨åœºæ™¯ | å®¹å™¨å±‚ä½¿ç”¨åœºæ™¯ | æ“ä½œå¤æ‚åº¦ |
|---------|------------|------------|--------------|-----------|
| **çº¢é»‘æ ‘** | CFSè°ƒåº¦å®ä½“ (vruntime) | ä¼˜å…ˆçº§é˜Ÿåˆ— | æœåŠ¡ä¼˜å…ˆçº§ | O(log n) |
| **æœ€å°å †** | æˆªæ­¢æœŸé˜Ÿåˆ— | äº‹ä»¶å®šæ—¶å™¨ | è°ƒåº¦é˜Ÿåˆ— | O(log n) |
| **ä½å›¾** | CPU affinity (cpumask_t) | å¯ç”¨èµ„æºä½å›¾ | èŠ‚ç‚¹é€‰æ‹©ä½å›¾ | O(1) |
| **å“ˆå¸Œè¡¨** | PID â†’ task_struct | UUID â†’ VMå¯¹è±¡ | Pod UID â†’ Podå¯¹è±¡ | O(1) |
| **Radixæ ‘** | è™šæ‹Ÿåœ°å€æ˜ å°„ | è™šæ‹Ÿå†…å­˜æ˜ å°„ | å­˜å‚¨å·æ˜ å°„ | O(k) k=é”®é•¿åº¦ |
| **B+æ ‘** | æ–‡ä»¶ç³»ç»Ÿç´¢å¼• | è™šæ‹Ÿç£ç›˜ç´¢å¼• | é•œåƒåˆ†å±‚ç´¢å¼• | O(log n) |

### 1.4 é€šä¿¡ä¸åŒæ­¥ï¼ˆè¯¦ç»†å±•å¼€ï¼‰

#### æ§åˆ¶å¹³é¢è¯¦ç»†å¯¹æ¯”

| æœºåˆ¶ | OSå±‚ | VMå±‚ | å®¹å™¨å±‚ | æ€§èƒ½ç‰¹å¾ |
|------|------|------|--------|---------|
| **äº‹ä»¶é©±åŠ¨** | `epoll/kqueue` | äº‹ä»¶é€šé“ | `watch API` | O(1) äº‹ä»¶é€šçŸ¥ |
| **çŠ¶æ€å¹¿æ’­** | `procfs/sysfs` | libvirtäº‹ä»¶ | `Metrics API` | è½®è¯¢æˆ–æ¨é€ |
| **ä¸€è‡´æ€§åè®®** | `futex` | åˆ†å¸ƒå¼é” | `Raft (etcd)` | å¼ºä¸€è‡´æ€§ |

#### æ•°æ®å¹³é¢è¯¦ç»†å¯¹æ¯”

| æœºåˆ¶ | OSå±‚ | VMå±‚ | å®¹å™¨å±‚ | ååé‡ |
|------|------|------|--------|--------|
| **å…±äº«å†…å­˜** | `shmget()/mmap()` | virtioå…±äº«å†…å­˜ | `tmpfs/emptyDir` | é«˜ (GB/s) |
| **æ¶ˆæ¯é˜Ÿåˆ—** | POSIXæ¶ˆæ¯é˜Ÿåˆ— | RabbitMQ/Kafka | NATS/Redis Streams | ä¸­ (MB/s) |
| **è¿œç¨‹è°ƒç”¨** | ç³»ç»Ÿè°ƒç”¨ | hypercall | gRPC/HTTP | ä½ (KB/s) |

### 1.5 ç›‘æ§ä¸åé¦ˆï¼ˆè¯¦ç»†å±•å¼€ï¼‰

#### ç›‘æ§æŒ‡æ ‡è¯¦ç»†å¯¹æ¯”

| æŒ‡æ ‡ç±»å‹ | OSå±‚å·¥å…· | VMå±‚å·¥å…· | å®¹å™¨å±‚å·¥å…· | é‡‡é›†é¢‘ç‡ |
|---------|---------|---------|-----------|---------|
| **CPUä½¿ç”¨ç‡** | `top`, `perf` | `vCenter` | `cAdvisor`, `Prometheus` | 1-10s |
| **å†…å­˜ä½¿ç”¨** | `/proc/meminfo` | `libvirtç»Ÿè®¡` | `Metrics API` | 1-10s |
| **ç½‘ç»œæµé‡** | `iftop`, `nethogs` | `vSwitchç»Ÿè®¡` | `CNIæ’ä»¶` | 1-60s |
| **ç£ç›˜IO** | `iostat` | `å­˜å‚¨ç»Ÿè®¡` | `node-exporter` | 1-10s |

### 1.6 æ€§èƒ½ä¼˜åŒ–ï¼ˆè¯¦ç»†å±•å¼€ï¼‰

#### ä¼˜åŒ–ç­–ç•¥è¯¦ç»†å¯¹æ¯”

| ä¼˜åŒ–é¢†åŸŸ | OSå±‚ä¼˜åŒ– | VMå±‚ä¼˜åŒ– | å®¹å™¨å±‚ä¼˜åŒ– | æ€§èƒ½æå‡ |
|---------|---------|---------|-----------|---------|
| **è°ƒåº¦ä¼˜åŒ–** | å”¤é†’è·¯å¾„ä¼˜åŒ– | è¿ç§»ä¼˜åŒ– | è°ƒåº¦å™¨ä¼˜åŒ– | 10-30% |
| **å†…å­˜ä¼˜åŒ–** | å†…å­˜å‹ç¼© | å†…å­˜æ°”çƒ | èµ„æºé…é¢ä¼˜åŒ– | 20-40% |
| **ç½‘ç»œä¼˜åŒ–** | é›¶æ‹·è´ | SR-IOV | eBPFåŠ é€Ÿ | 50-200% |

---

## 2. ä¸‰å±‚ç³»ç»Ÿè¯¦ç»†å¯¹æ¯”çŸ©é˜µ

### 2.1 å®Œæ•´åŠŸèƒ½å¯¹æ¯”çŸ©é˜µ

| åŠŸèƒ½ç»´åº¦ | OSå±‚ | VMå±‚ | å®¹å™¨å±‚ | ç»Ÿä¸€æŠ½è±¡ |
|---------|------|------|--------|---------|
| **å®ä½“åˆ›å»º** | `fork()/clone()` | `clone_vm()` | `docker create` | `create_entity(spec)` |
| **èµ„æºåˆ†é…** | `sched_setaffinity()` | `vCPUåˆ†é…` | `cgroupé…é¢` | `allocate_resource(entity, resource)` |
| **çŠ¶æ€æŸ¥è¯¢** | `/proc/[pid]/stat` | `libvirt API` | `kubectl get pod` | `get_state(entity_id)` |
| **èµ„æºé™åˆ¶** | `setrlimit()` | `VMé…ç½®` | `ResourceQuota` | `set_limit(entity, resource, limit)` |
| **è°ƒåº¦ç­–ç•¥** | `SCHED_*` | `DRSç­–ç•¥` | `schedulerName` | `set_scheduler(entity, policy)` |
| **è´Ÿè½½å‡è¡¡** | `sched_balance_work()` | `DRS` | `HPA` | `balance_load(nodes)` |
| **è¿ç§»** | `CRIU` | `vMotion` | `Podè¿ç§»` | `migrate(entity, target)` |
| **ç›‘æ§** | `perf`, `top` | `vCenter` | `Prometheus` | `monitor(entity, metrics)` |

### 2.2 æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”çŸ©é˜µ

| æ€§èƒ½æŒ‡æ ‡ | OSå±‚å…¸å‹å€¼ | VMå±‚å…¸å‹å€¼ | å®¹å™¨å±‚å…¸å‹å€¼ | æ•°å­¦å…³ç³» |
|---------|-----------|-----------|------------|---------|
| **åˆ›å»ºå»¶è¿Ÿ** | 5-10Î¼s | 50-100ms | 3-5s | `T_ctr â‰ˆ 10Â³Â·T_vm â‰ˆ 10â¶Â·T_os` |
| **åˆ‡æ¢å¼€é”€** | 1-2Î¼s | 100-200Î¼s | 1-5ms | `CS_ctr â‰ˆ 10Â³Â·CS_vm â‰ˆ 10â¶Â·CS_os` |
| **è°ƒåº¦å»¶è¿Ÿ** | <1ms | <10ms | <100ms | `L_ctr â‰ˆ 10Â²Â·L_vm â‰ˆ 10âµÂ·L_os` |
| **å†…å­˜å¼€é”€** | 8KB (task_struct) | 50-100MB (VM) | 100-500MB (Pod) | `M_ctr â‰ˆ 10â´Â·M_vm â‰ˆ 10â·Â·M_os` |
| **ç½‘ç»œå»¶è¿Ÿ** | <1Î¼s (æœ¬åœ°) | <10Î¼s (è™šæ‹Ÿç½‘ç»œ) | <1ms (CNI) | `N_ctr â‰ˆ 10Â³Â·N_vm â‰ˆ 10â¶Â·N_os` |

### 2.3 ç®—æ³•å¤æ‚åº¦å¯¹æ¯”çŸ©é˜µ

| ç®—æ³•æ“ä½œ | OSå±‚å¤æ‚åº¦ | VMå±‚å¤æ‚åº¦ | å®¹å™¨å±‚å¤æ‚åº¦ | ç»Ÿä¸€å¤æ‚åº¦ |
|---------|-----------|-----------|------------|-----------|
| **å®ä½“æ’å…¥** | O(log n) | O(log n) | O(log n) | O(log n) |
| **å®ä½“æŸ¥æ‰¾** | O(1) (å“ˆå¸Œ) | O(1) (å“ˆå¸Œ) | O(1) (å“ˆå¸Œ) | O(1) |
| **è°ƒåº¦å†³ç­–** | O(log n) | O(log n) | O(nÂ·m) | O(log n) - O(nÂ·m) |
| **è´Ÿè½½å‡è¡¡** | O(n) | O(nÂ²) | O(nÂ·m) | O(n) - O(nÂ²) |
| **è¿ç§»** | O(M) M=å†…å­˜å¤§å° | O(M) | O(M) | O(M) |

---

## 3. å¤šè¯­è¨€å®ç°ç¤ºä¾‹

### 3.1 Golangå®ç°

#### ç»Ÿä¸€èµ„æºæŠ½è±¡æ¥å£

```go
package scheduler

import (
    "context"
    "time"
)

// ç»Ÿä¸€å®ä½“æ¥å£
type Entity interface {
    ID() string
    State() EntityState
    Resources() ResourceVector
    Priority() int
    SetState(EntityState) error
}

// ç»Ÿä¸€èµ„æºå‘é‡
type ResourceVector struct {
    CPU    float64 // CPUä»½é¢ (0-1)
    Memory int64   // å†…å­˜å­—èŠ‚æ•°
    Disk   int64   // ç£ç›˜å­—èŠ‚æ•°
    Network int64  // ç½‘ç»œå¸¦å®½ (bps)
}

// ç»Ÿä¸€çŠ¶æ€æœº
type EntityState int

const (
    StateInit EntityState = iota
    StatePending
    StateRunning
    StateSuspended
    StateTerminated
)

// ç»Ÿä¸€è°ƒåº¦å™¨æ¥å£
type Scheduler interface {
    Schedule(ctx context.Context, entity Entity) error
    Allocate(ctx context.Context, entity Entity, resources ResourceVector) error
    Migrate(ctx context.Context, entity Entity, target string) error
    GetState(ctx context.Context, entityID string) (EntityState, error)
}

// CFSè°ƒåº¦å™¨å®ç° (OSå±‚é£æ ¼)
type CFSScheduler struct {
    entities map[string]*CFSEntity
    rbtree   *RedBlackTree // vruntimeæ’åº
}

type CFSEntity struct {
    entity   Entity
    vruntime float64
    weight   int
}

func (s *CFSScheduler) Schedule(ctx context.Context, entity Entity) error {
    // æ›´æ–°vruntime
    cfsEntity := s.entities[entity.ID()]
    delta := s.calcDeltaFair(cfsEntity)
    cfsEntity.vruntime += delta

    // é€‰æ‹©æœ€å°vruntimeå®ä½“
    minEntity := s.rbtree.Min()
    if minEntity != nil {
        return minEntity.entity.SetState(StateRunning)
    }
    return nil
}

func (s *CFSScheduler) calcDeltaFair(entity *CFSEntity) float64 {
    // vruntimeå¢é‡ = å®é™…è¿è¡Œæ—¶é—´ * (nice_0_weight / entity_weight)
    const nice0Weight = 1024
    return 1.0 * float64(nice0Weight) / float64(entity.weight)
}

// Kubernetesè°ƒåº¦å™¨å®ç° (å®¹å™¨å±‚é£æ ¼)
type K8sScheduler struct {
    nodes   []*Node
    pods    map[string]*Pod
    plugins []Plugin
}

type Node struct {
    ID       string
    Capacity ResourceVector
    Allocated ResourceVector
}

type Pod struct {
    ID        string
    Requests  ResourceVector
    Limits    ResourceVector
    Priority  int
    NodeName  string
}

func (s *K8sScheduler) Schedule(ctx context.Context, pod *Pod) error {
    // è¿‡æ»¤é˜¶æ®µ
    feasibleNodes := s.filterNodes(pod)

    // è¯„åˆ†é˜¶æ®µ
    scores := make(map[string]float64)
    for _, node := range feasibleNodes {
        score := 0.0
        for _, plugin := range s.plugins {
            score += plugin.Score(ctx, pod, node)
        }
        scores[node.ID] = score
    }

    // é€‰æ‹©æœ€é«˜åˆ†èŠ‚ç‚¹
    bestNode := s.selectBestNode(scores)
    pod.NodeName = bestNode
    return nil
}

// è´Ÿè½½å‡è¡¡å™¨å®ç°
type LoadBalancer struct {
    nodes []*Node
}

func (lb *LoadBalancer) Balance() error {
    // è®¡ç®—å¹³å‡è´Ÿè½½
    avgLoad := lb.calculateAverageLoad()

    // è¿ç§»è¿‡è½½èŠ‚ç‚¹ä¸Šçš„å®ä½“
    for _, node := range lb.nodes {
        if node.Load() > avgLoad*1.1 {
            entities := node.GetEntities()
            for _, entity := range entities {
                target := lb.findUnderloadedNode()
                if target != nil {
                    lb.migrateEntity(entity, target)
                }
            }
        }
    }
    return nil
}
```

#### çŠ¶æ€æœºå®ç°

```go
// ç»Ÿä¸€çŠ¶æ€æœº
type StateMachine struct {
    currentState EntityState
    transitions  map[EntityState]map[Event]EntityState
    handlers     map[EntityState]StateHandler
}

type Event string

const (
    EventCreate   Event = "create"
    EventSchedule Event = "schedule"
    EventPreempt  Event = "preempt"
    EventComplete Event = "complete"
    EventKill     Event = "kill"
)

type StateHandler func(ctx context.Context, entity Entity) error

func NewStateMachine() *StateMachine {
    sm := &StateMachine{
        currentState: StateInit,
        transitions: make(map[EntityState]map[Event]EntityState),
        handlers:    make(map[EntityState]StateHandler),
    }

    // å®šä¹‰çŠ¶æ€è½¬ç§»
    sm.transitions[StateInit] = map[Event]EntityState{
        EventCreate: StatePending,
    }
    sm.transitions[StatePending] = map[Event]EntityState{
        EventSchedule: StateRunning,
        EventKill:     StateTerminated,
    }
    sm.transitions[StateRunning] = map[Event]EntityState{
        EventPreempt:  StateSuspended,
        EventComplete: StateTerminated,
        EventKill:     StateTerminated,
    }
    sm.transitions[StateSuspended] = map[Event]EntityState{
        EventSchedule: StateRunning,
        EventKill:     StateTerminated,
    }

    return sm
}

func (sm *StateMachine) Transition(ctx context.Context, event Event, entity Entity) error {
    nextState, ok := sm.transitions[sm.currentState][event]
    if !ok {
        return fmt.Errorf("invalid transition: %v -> %v", sm.currentState, event)
    }

    // æ‰§è¡ŒçŠ¶æ€å¤„ç†
    if handler, exists := sm.handlers[nextState]; exists {
        if err := handler(ctx, entity); err != nil {
            return err
        }
    }

    sm.currentState = nextState
    return entity.SetState(nextState)
}
```

### 3.2 Pythonå®ç°

#### ç»Ÿä¸€èµ„æºæŠ½è±¡æ¨¡å‹

```python
from dataclasses import dataclass
from enum import Enum
from typing import Dict, List, Optional
from abc import ABC, abstractmethod
import time

# ç»Ÿä¸€å®ä½“çŠ¶æ€
class EntityState(Enum):
    INIT = "init"
    PENDING = "pending"
    RUNNING = "running"
    SUSPENDED = "suspended"
    TERMINATED = "terminated"

# ç»Ÿä¸€èµ„æºå‘é‡
@dataclass
class ResourceVector:
    cpu: float = 0.0      # CPUä»½é¢ (0-1)
    memory: int = 0       # å†…å­˜å­—èŠ‚æ•°
    disk: int = 0         # ç£ç›˜å­—èŠ‚æ•°
    network: int = 0      # ç½‘ç»œå¸¦å®½ (bps)

    def __add__(self, other):
        return ResourceVector(
            cpu=self.cpu + other.cpu,
            memory=self.memory + other.memory,
            disk=self.disk + other.disk,
            network=self.network + other.network
        )

    def __le__(self, other):
        return (self.cpu <= other.cpu and
                self.memory <= other.memory and
                self.disk <= other.disk and
                self.network <= other.network)

# ç»Ÿä¸€å®ä½“æ¥å£
class Entity(ABC):
    def __init__(self, entity_id: str, resources: ResourceVector, priority: int = 0):
        self.entity_id = entity_id
        self.resources = resources
        self.priority = priority
        self.state = EntityState.INIT
        self.created_at = time.time()

    @abstractmethod
    def get_state(self) -> EntityState:
        pass

    @abstractmethod
    def set_state(self, state: EntityState) -> None:
        pass

# CFSè°ƒåº¦å™¨å®ç°
class CFSScheduler:
    def __init__(self):
        self.entities: Dict[str, CFSEntity] = {}
        self.rbtree = RedBlackTree()  # vruntimeæ’åº
        self.nice0_weight = 1024

    def add_entity(self, entity: Entity, nice: int = 0):
        weight = int(1024 * (1.25 ** (-nice)))
        cfs_entity = CFSEntity(
            entity=entity,
            vruntime=0.0,
            weight=weight
        )
        self.entities[entity.entity_id] = cfs_entity
        self.rbtree.insert(cfs_entity)

    def schedule(self) -> Optional[Entity]:
        if not self.rbtree:
            return None

        # é€‰æ‹©æœ€å°vruntimeå®ä½“
        min_entity = self.rbtree.min()
        if min_entity:
            min_entity.entity.set_state(EntityState.RUNNING)
            return min_entity.entity
        return None

    def update_vruntime(self, entity_id: str, delta_exec: float):
        cfs_entity = self.entities[entity_id]
        # vruntimeå¢é‡ = å®é™…è¿è¡Œæ—¶é—´ * (nice_0_weight / entity_weight)
        delta_vruntime = delta_exec * (self.nice0_weight / cfs_entity.weight)
        cfs_entity.vruntime += delta_vruntime
        self.rbtree.update(cfs_entity)

class CFSEntity:
    def __init__(self, entity: Entity, vruntime: float, weight: int):
        self.entity = entity
        self.vruntime = vruntime
        self.weight = weight

# Kubernetesè°ƒåº¦å™¨å®ç°
class K8sScheduler:
    def __init__(self, nodes: List['Node'], plugins: List['Plugin']):
        self.nodes = nodes
        self.plugins = plugins
        self.pods: Dict[str, 'Pod'] = {}

    def schedule(self, pod: 'Pod') -> Optional['Node']:
        # è¿‡æ»¤é˜¶æ®µï¼šæ‰¾å‡ºå¯è¡ŒèŠ‚ç‚¹
        feasible_nodes = self.filter_nodes(pod)

        if not feasible_nodes:
            return None

        # è¯„åˆ†é˜¶æ®µï¼šä¸ºæ¯ä¸ªèŠ‚ç‚¹æ‰“åˆ†
        scores = {}
        for node in feasible_nodes:
            score = 0.0
            for plugin in self.plugins:
                score += plugin.score(pod, node)
            scores[node.node_id] = score

        # é€‰æ‹©æœ€é«˜åˆ†èŠ‚ç‚¹
        best_node_id = max(scores, key=scores.get)
        return next(node for node in self.nodes if node.node_id == best_node_id)

    def filter_nodes(self, pod: 'Pod') -> List['Node']:
        feasible = []
        for node in self.nodes:
            # æ£€æŸ¥èµ„æºæ˜¯å¦è¶³å¤Ÿ
            available = node.capacity - node.allocated
            if pod.requests <= available:
                feasible.append(node)
        return feasible

# è´Ÿè½½å‡è¡¡å™¨å®ç°
class LoadBalancer:
    def __init__(self, nodes: List['Node']):
        self.nodes = nodes

    def balance(self):
        # è®¡ç®—å¹³å‡è´Ÿè½½
        total_load = sum(node.load() for node in self.nodes)
        avg_load = total_load / len(self.nodes) if self.nodes else 0

        # è¿ç§»è¿‡è½½èŠ‚ç‚¹ä¸Šçš„å®ä½“
        for node in self.nodes:
            if node.load() > avg_load * 1.1:
                entities = node.get_entities()
                for entity in entities:
                    target = self.find_underloaded_node(avg_load)
                    if target:
                        self.migrate_entity(entity, node, target)

# çŠ¶æ€æœºå®ç°
class StateMachine:
    def __init__(self):
        self.current_state = EntityState.INIT
        self.transitions = {
            EntityState.INIT: {
                'create': EntityState.PENDING
            },
            EntityState.PENDING: {
                'schedule': EntityState.RUNNING,
                'kill': EntityState.TERMINATED
            },
            EntityState.RUNNING: {
                'preempt': EntityState.SUSPENDED,
                'complete': EntityState.TERMINATED,
                'kill': EntityState.TERMINATED
            },
            EntityState.SUSPENDED: {
                'schedule': EntityState.RUNNING,
                'kill': EntityState.TERMINATED
            }
        }
        self.handlers = {}

    def transition(self, event: str, entity: Entity) -> bool:
        next_state = self.transitions.get(self.current_state, {}).get(event)
        if not next_state:
            return False

        # æ‰§è¡ŒçŠ¶æ€å¤„ç†
        if next_state in self.handlers:
            self.handlers[next_state](entity)

        self.current_state = next_state
        entity.set_state(next_state)
        return True
```

### 3.3 Rustå®ç°

#### ç»Ÿä¸€èµ„æºæŠ½è±¡æ¨¡å‹

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

// ç»Ÿä¸€å®ä½“çŠ¶æ€
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum EntityState {
    Init,
    Pending,
    Running,
    Suspended,
    Terminated,
}

// ç»Ÿä¸€èµ„æºå‘é‡
#[derive(Debug, Clone, Copy)]
pub struct ResourceVector {
    pub cpu: f64,        // CPUä»½é¢ (0-1)
    pub memory: u64,     // å†…å­˜å­—èŠ‚æ•°
    pub disk: u64,       // ç£ç›˜å­—èŠ‚æ•°
    pub network: u64,    // ç½‘ç»œå¸¦å®½ (bps)
}

impl ResourceVector {
    pub fn new(cpu: f64, memory: u64, disk: u64, network: u64) -> Self {
        ResourceVector { cpu, memory, disk, network }
    }

    pub fn can_satisfy(&self, request: &ResourceVector) -> bool {
        self.cpu >= request.cpu &&
        self.memory >= request.memory &&
        self.disk >= request.disk &&
        self.network >= request.network
    }
}

impl std::ops::Add for ResourceVector {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        ResourceVector {
            cpu: self.cpu + other.cpu,
            memory: self.memory + other.memory,
            disk: self.disk + other.disk,
            network: self.network + other.network,
        }
    }
}

impl std::ops::Sub for ResourceVector {
    type Output = Self;

    fn sub(self, other: Self) -> Self {
        ResourceVector {
            cpu: (self.cpu - other.cpu).max(0.0),
            memory: self.memory.saturating_sub(other.memory),
            disk: self.disk.saturating_sub(other.disk),
            network: self.network.saturating_sub(other.network),
        }
    }
}

// ç»Ÿä¸€å®ä½“æ¥å£
pub trait Entity: Send + Sync {
    fn id(&self) -> &str;
    fn state(&self) -> EntityState;
    fn resources(&self) -> ResourceVector;
    fn priority(&self) -> i32;
    fn set_state(&mut self, state: EntityState) -> Result<(), String>;
}

// CFSè°ƒåº¦å™¨å®ç°
pub struct CFSScheduler {
    entities: Arc<Mutex<HashMap<String, CFSEntity>>>,
    rbtree: Arc<Mutex<RedBlackTree<CFSEntity>>>,
    nice0_weight: i32,
}

struct CFSEntity {
    entity: Box<dyn Entity>,
    vruntime: f64,
    weight: i32,
}

impl PartialEq for CFSEntity {
    fn eq(&self, other: &Self) -> bool {
        self.vruntime == other.vruntime
    }
}

impl PartialOrd for CFSEntity {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        self.vruntime.partial_cmp(&other.vruntime)
    }
}

impl CFSScheduler {
    pub fn new() -> Self {
        CFSScheduler {
            entities: Arc::new(Mutex::new(HashMap::new())),
            rbtree: Arc::new(Mutex::new(RedBlackTree::new())),
            nice0_weight: 1024,
        }
    }

    pub fn add_entity(&self, mut entity: Box<dyn Entity>, nice: i32) -> Result<(), String> {
        let weight = (1024.0 * (1.25_f64).powf(-nice as f64)) as i32;
        let cfs_entity = CFSEntity {
            entity,
            vruntime: 0.0,
            weight,
        };

        let entity_id = cfs_entity.entity.id().to_string();
        let mut entities = self.entities.lock().unwrap();
        entities.insert(entity_id.clone(), cfs_entity);

        let mut rbtree = self.rbtree.lock().unwrap();
        if let Some(entity) = entities.get(&entity_id) {
            rbtree.insert(entity.clone());
        }

        Ok(())
    }

    pub fn schedule(&self) -> Result<Option<String>, String> {
        let mut rbtree = self.rbtree.lock().unwrap();
        if let Some(min_entity) = rbtree.min() {
            let entity_id = min_entity.entity.id().to_string();
            drop(rbtree);

            let mut entities = self.entities.lock().unwrap();
            if let Some(cfs_entity) = entities.get_mut(&entity_id) {
                cfs_entity.entity.set_state(EntityState::Running)?;
                return Ok(Some(entity_id));
            }
        }
        Ok(None)
    }

    pub fn update_vruntime(&self, entity_id: &str, delta_exec: f64) -> Result<(), String> {
        let mut entities = self.entities.lock().unwrap();
        if let Some(cfs_entity) = entities.get_mut(entity_id) {
            let delta_vruntime = delta_exec * (self.nice0_weight as f64 / cfs_entity.weight as f64);
            cfs_entity.vruntime += delta_vruntime;

            // æ›´æ–°çº¢é»‘æ ‘
            let mut rbtree = self.rbtree.lock().unwrap();
            rbtree.update(cfs_entity.clone());
        }
        Ok(())
    }
}

// Kubernetesè°ƒåº¦å™¨å®ç°
pub struct K8sScheduler {
    nodes: Vec<Node>,
    plugins: Vec<Box<dyn Plugin>>,
    pods: Arc<Mutex<HashMap<String, Pod>>>,
}

pub trait Plugin: Send + Sync {
    fn score(&self, pod: &Pod, node: &Node) -> f64;
    fn filter(&self, pod: &Pod, node: &Node) -> bool;
}

impl K8sScheduler {
    pub fn new(nodes: Vec<Node>, plugins: Vec<Box<dyn Plugin>>) -> Self {
        K8sScheduler {
            nodes,
            plugins,
            pods: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    pub fn schedule(&self, pod: &Pod) -> Result<Option<String>, String> {
        // è¿‡æ»¤é˜¶æ®µ
        let feasible_nodes: Vec<&Node> = self.nodes
            .iter()
            .filter(|node| {
                self.plugins.iter().all(|plugin| plugin.filter(pod, node))
            })
            .collect();

        if feasible_nodes.is_empty() {
            return Ok(None);
        }

        // è¯„åˆ†é˜¶æ®µ
        let mut scores: Vec<(String, f64)> = feasible_nodes
            .iter()
            .map(|node| {
                let score: f64 = self.plugins
                    .iter()
                    .map(|plugin| plugin.score(pod, node))
                    .sum();
                (node.node_id.clone(), score)
            })
            .collect();

        // é€‰æ‹©æœ€é«˜åˆ†èŠ‚ç‚¹
        scores.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
        Ok(scores.first().map(|(node_id, _)| node_id.clone()))
    }
}

// çŠ¶æ€æœºå®ç°
pub struct StateMachine {
    current_state: EntityState,
    transitions: HashMap<(EntityState, &'static str), EntityState>,
    handlers: HashMap<EntityState, Box<dyn Fn(&mut dyn Entity) -> Result<(), String>>>,
}

impl StateMachine {
    pub fn new() -> Self {
        let mut transitions = HashMap::new();
        transitions.insert((EntityState::Init, "create"), EntityState::Pending);
        transitions.insert((EntityState::Pending, "schedule"), EntityState::Running);
        transitions.insert((EntityState::Pending, "kill"), EntityState::Terminated);
        transitions.insert((EntityState::Running, "preempt"), EntityState::Suspended);
        transitions.insert((EntityState::Running, "complete"), EntityState::Terminated);
        transitions.insert((EntityState::Running, "kill"), EntityState::Terminated);
        transitions.insert((EntityState::Suspended, "schedule"), EntityState::Running);
        transitions.insert((EntityState::Suspended, "kill"), EntityState::Terminated);

        StateMachine {
            current_state: EntityState::Init,
            transitions,
            handlers: HashMap::new(),
        }
    }

    pub fn transition(&mut self, event: &'static str, entity: &mut dyn Entity) -> Result<(), String> {
        let key = (self.current_state, event);
        if let Some(&next_state) = self.transitions.get(&key) {
            // æ‰§è¡ŒçŠ¶æ€å¤„ç†
            if let Some(handler) = self.handlers.get(&next_state) {
                handler(entity)?;
            }

            self.current_state = next_state;
            entity.set_state(next_state)?;
            Ok(())
        } else {
            Err(format!("Invalid transition: {:?} -> {}", self.current_state, event))
        }
    }
}

// è¾…åŠ©ç»“æ„
pub struct Node {
    pub node_id: String,
    pub capacity: ResourceVector,
    pub allocated: ResourceVector,
}

pub struct Pod {
    pub pod_id: String,
    pub requests: ResourceVector,
    pub limits: ResourceVector,
    pub priority: i32,
}

// ç®€åŒ–çš„çº¢é»‘æ ‘å®ç°ï¼ˆå®é™…åº”ä½¿ç”¨æ ‡å‡†åº“æˆ–ç¬¬ä¸‰æ–¹åº“ï¼‰
pub struct RedBlackTree<T> {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”ä½¿ç”¨å®Œæ•´çš„çº¢é»‘æ ‘
    nodes: Vec<T>,
}

impl<T: PartialOrd + Clone> RedBlackTree<T> {
    pub fn new() -> Self {
        RedBlackTree { nodes: Vec::new() }
    }

    pub fn insert(&mut self, value: T) {
        self.nodes.push(value);
        self.nodes.sort_by(|a, b| a.partial_cmp(b).unwrap());
    }

    pub fn min(&self) -> Option<T> {
        self.nodes.first().cloned()
    }

    pub fn update(&mut self, value: T) {
        // ç®€åŒ–å®ç°
        self.nodes.sort_by(|a, b| a.partial_cmp(b).unwrap());
    }
}
```

---

## 4. æ€ç»´å¯¼å›¾çš„å®é™…åº”ç”¨

### 4.1 ç³»ç»Ÿè®¾è®¡æŒ‡å¯¼

**ä½¿ç”¨æ€ç»´å¯¼å›¾æŒ‡å¯¼ç³»ç»Ÿæ¶æ„è®¾è®¡**ï¼š

- **è¯†åˆ«å…±æ€§**ï¼šé€šè¿‡æ€ç»´å¯¼å›¾è¯†åˆ«ä¸‰å±‚ç³»ç»Ÿçš„å…±æ€§ï¼Œè®¾è®¡ç»Ÿä¸€æ¥å£
- **ç†è§£å·®å¼‚**ï¼šç†è§£ä¸åŒå±‚çš„å®ç°å·®å¼‚ï¼Œè®¾è®¡é€‚é…å±‚
- **ç®€åŒ–å®ç°**ï¼šåŸºäºç»Ÿä¸€æŠ½è±¡ç®€åŒ–ç³»ç»Ÿå®ç°

### 4.2 ç®—æ³•ç§»æ¤

**åŸºäºæ€ç»´å¯¼å›¾è¯†åˆ«å¯ç§»æ¤çš„ç®—æ³•**ï¼š

- **CFSç®—æ³•ç§»æ¤**ï¼šä»OSå±‚ç§»æ¤åˆ°å®¹å™¨å±‚
- **è´Ÿè½½å‡è¡¡ç®—æ³•**ï¼šè·¨å±‚å¤ç”¨ç›¸åŒçš„è´Ÿè½½å‡è¡¡ç­–ç•¥
- **çŠ¶æ€æœºæ¨¡å‹**ï¼šç»Ÿä¸€çš„çŠ¶æ€æœºå¯ä»¥åœ¨ä¸åŒå±‚ä½¿ç”¨

### 4.3 æ€§èƒ½ä¼˜åŒ–

**é€šè¿‡æ€ç»´å¯¼å›¾è¯†åˆ«æ€§èƒ½ç“¶é¢ˆ**ï¼š

- **è°ƒåº¦è·¯å¾„ä¼˜åŒ–**ï¼šä¼˜åŒ–å…³é”®è°ƒåº¦è·¯å¾„
- **èµ„æºåˆ†é…ä¼˜åŒ–**ï¼šä¼˜åŒ–èµ„æºåˆ†é…ç®—æ³•
- **ç½‘ç»œé€šä¿¡ä¼˜åŒ–**ï¼šä¼˜åŒ–è·¨å±‚ç½‘ç»œé€šä¿¡

### 4.4 æ•™å­¦ä¸ç ”ç©¶

**ä½¿ç”¨æ€ç»´å¯¼å›¾æ•™å­¦è°ƒåº¦ç³»ç»ŸåŸç†**ï¼š

- **ç³»ç»ŸåŒ–çŸ¥è¯†æ¡†æ¶**ï¼šæä¾›å®Œæ•´çš„çŸ¥è¯†ä½“ç³»
- **è·¨é¢†åŸŸäº¤æµ**ï¼šä¿ƒè¿›ä¸åŒé¢†åŸŸé—´çš„çŸ¥è¯†äº¤æµ
- **ç ”ç©¶æŒ‡å¯¼**ï¼šä¸ºç ”ç©¶æä¾›ç³»ç»ŸåŒ–çš„ç ”ç©¶æ–¹å‘

### 4.5 ä¸‰å±‚ç³»ç»ŸåŠ¨æ€äº¤äº’æµ

#### 4.5.1 å®ä½“ç”Ÿå‘½å‘¨æœŸçŠ¶æ€æœº

**æ–‡æœ¬åŒ–å›¾å½¢è¡¨ç¤º**ï¼š

```text
[INIT] --fork/exec--> [READY] --scheduler.pick()--> [RUNNING]
  |                      |                           |
  | wait()               |                           | preemption/timeout
  v                      v                           v
[ZOMBIE] <---exit()--- TERMINATED <---kill()--- [STOPPED]
                                                 ^
                                                 |
                                        cgroup freezer / SIGSTOP
```

**è·¨å±‚æ˜ å°„**ï¼š

```text
OSå±‚: task_struct.state = TASK_RUNNING
         â†“ å‡½å­ F (è™šæ‹ŸåŒ–)
VMå±‚: kvm_vcpu.run->exit_reason = VCPU_EXIT_INTR
         â†“ å‡½å­ G (å®¹å™¨åŒ–)
å®¹å™¨å±‚: container.Status = "Running" (containerd)
         â†“ ç›‘æ§å•å­ M
è§‚æµ‹å€¼: {cpu_usage: 0.1, memory_rss: 1GB}
```

**å½¢å¼åŒ–è¯æ˜**ï¼š
è¯¥çŠ¶æ€è½¬æ¢æ˜¯ **F-ä»£æ•°** $(S, \alpha)$ï¼Œå…¶ä¸­ $\alpha: F(S) \to S$ ç”± `schedule()` å®ç°ï¼š

- **åˆå§‹ä»£æ•°**ï¼š$\mu F$ æ˜¯æ‰€æœ‰å¯èƒ½çš„çŠ¶æ€åºåˆ—
- **å½’çº³**ï¼š$\text{state}_{n+1} = \alpha(F(\text{state}_n))$
- **ç»ˆæ­¢è¯­ä¹‰**ï¼š$\text{TERMINATED}$ æ˜¯**ç»ˆå¯¹è±¡**ï¼ˆterminal objectï¼‰ï¼Œä»»ä½•çŠ¶æ€éƒ½æœ‰å”¯ä¸€æ€å°„åˆ°å®ƒ

#### 4.5.2 èµ„æºåˆ†é…å†³ç­–æ ‘

**åˆ†æ”¯é€»è¾‘è¡¨ç¤º**ï¼š

```text
æ ¹èŠ‚ç‚¹: èµ„æºè¯·æ±‚ (Resource Request)
â”‚
â”œâ”€ ç¡¬çº¦æŸæ£€æŸ¥ (Hard Constraints)
â”‚  â”œâ”€ CPU: cpuset.cpus âˆˆ allowed_cpus ? [True/False]
â”‚  â”œâ”€ å†…å­˜: memory.limit â‰¥ memory.request ? [True/False]
â”‚  â””â”€ å­˜å‚¨: ephemeral-storage.limit â‰¥ request ?
â”‚
â”œâ”€ è½¯çº¦æŸè¯„åˆ† (Soft Constraints Score)
â”‚  â”œâ”€ èŠ‚ç‚¹äº²å’Œæ€§: score += weight * matchExpression
â”‚  â”œâ”€ Podåäº²å’Œæ€§: score -= weight * conflict_count
â”‚  â”œâ”€ æ‹“æ‰‘åˆ†å¸ƒ: score -= std_dev(zone_spread)
â”‚  â””â”€ èµ„æºå‡è¡¡: score -= abs(cpu_ratio - memory_ratio)
â”‚
â””â”€ é€‰æ‹©å†³ç­– (Selection)
   â””â”€ argmax_node(score) ä¸”æ»¡è¶³ ç¡¬çº¦æŸ
```

**èŒƒç•´è®ºè¯­ä¹‰**ï¼š
è¯¥å†³ç­–æ ‘æ˜¯**ä½™ç§¯**ï¼ˆcoproductï¼‰çš„**guard**è¡¨è¾¾å¼ï¼š
$$
\text{Decision} = \bigsqcup_{c \in \text{Constraints}} \text{Guard}(c) \cdot \text{Score}(c)
$$

**ä¸‰å±‚ç³»ç»Ÿå®ç°å¯¹æ¯”**ï¼š

| å±‚çº§ | ç¡¬çº¦æŸæ£€æŸ¥ | è½¯çº¦æŸè¯„åˆ† | é€‰æ‹©å†³ç­– |
|------|-----------|-----------|---------|
| **OSå±‚** | CPU affinity, å†…å­˜é™åˆ¶ | ä¼˜å…ˆçº§ã€niceå€¼ | CFS vruntimeæœ€å° |
| **VMå±‚** | ä¸»æœºå®¹é‡ã€SLAçº¦æŸ | è´Ÿè½½å‡è¡¡ã€è¿ç§»æˆæœ¬ | DRSè¯„åˆ†æœ€é«˜ |
| **å®¹å™¨å±‚** | èŠ‚ç‚¹èµ„æºã€PodDisruptionBudget | èŠ‚ç‚¹äº²å’Œæ€§ã€èµ„æºå‡è¡¡ | kube-scheduler Scoreæœ€é«˜ |

---

## 5. ç›¸å…³æ–‡æ¡£

- [è¿”å› FormalModel ç›®å½•](../README.md)
- [01_åŸºç¡€å½¢å¼åŒ–æ¡†æ¶ README](README.md)
- [01.1_èµ„æºæŠ½è±¡æ¨¡å‹](01.1_èµ„æºæŠ½è±¡æ¨¡å‹.md)
- [01.3_ç¨‹åºè®¾è®¡èŒƒå¼æ˜ å°„](01.3_ç¨‹åºè®¾è®¡èŒƒå¼æ˜ å°„.md)
- [04_åŠ¨æ€äº¤äº’æ¨¡å‹](../04_åŠ¨æ€äº¤äº’æ¨¡å‹/README.md)

---

**æœ€åæ›´æ–°**: 2025-01-27
