# 01.3 ç¨‹åºè®¾è®¡èŒƒå¼æ˜ å°„

> **æ‰€å±ä¸»é¢˜**: 01_åŸºç¡€å½¢å¼åŒ–æ¡†æ¶
> **æœ€åæ›´æ–°**: 2025-01-27

## ğŸ“‹ ç›®å½•

- [01.3 ç¨‹åºè®¾è®¡èŒƒå¼æ˜ å°„](#013-ç¨‹åºè®¾è®¡èŒƒå¼æ˜ å°„)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. è®¾è®¡æ¨¡å¼å¯¹åº”è¡¨](#1-è®¾è®¡æ¨¡å¼å¯¹åº”è¡¨)
  - [2. å¹¶å‘åŸè¯­æ¼”è¿›](#2-å¹¶å‘åŸè¯­æ¼”è¿›)
    - [2.1 æ¼”è¿›è·¯å¾„](#21-æ¼”è¿›è·¯å¾„)
    - [2.2 è¯¦ç»†åŸè¯­æ˜ å°„](#22-è¯¦ç»†åŸè¯­æ˜ å°„)
    - [2.3 åŸè¯­æ˜ å°„è¯¦ç»†å¯¹æ¯”](#23-åŸè¯­æ˜ å°„è¯¦ç»†å¯¹æ¯”)
  - [3. ç¨‹åºè®¾è®¡èŒƒå¼æ˜ å°„çš„å®é™…åº”ç”¨](#3-ç¨‹åºè®¾è®¡èŒƒå¼æ˜ å°„çš„å®é™…åº”ç”¨)
    - [Golangå®ç°](#golangå®ç°)
      - [Pythonå®ç°](#pythonå®ç°)
      - [Rustå®ç°](#rustå®ç°)
    - [4.1 èŒƒå¼æ˜ å°„çš„åŒæ„æ€§](#41-èŒƒå¼æ˜ å°„çš„åŒæ„æ€§)
      - [æ­¥éª¤1ï¼šåŒæ„æ€§å®šä¹‰](#æ­¥éª¤1åŒæ„æ€§å®šä¹‰)
      - [æ­¥éª¤2ï¼šåŒæ„æ€§è¯æ˜](#æ­¥éª¤2åŒæ„æ€§è¯æ˜)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜)
    - [4.2 èŒƒå¼æ˜ å°„çš„å®é™…åº”ç”¨](#42-èŒƒå¼æ˜ å°„çš„å®é™…åº”ç”¨)
      - [4.2.1 è·¨å±‚æ¨¡å¼å¤ç”¨](#421-è·¨å±‚æ¨¡å¼å¤ç”¨)
  - [4. ç›¸å…³æ–‡æ¡£](#4-ç›¸å…³æ–‡æ¡£)

---

## 1. è®¾è®¡æ¨¡å¼å¯¹åº”è¡¨

| æ¨¡å¼ | æ“ä½œç³»ç»Ÿå®ç° | è™šæ‹ŸåŒ–å®ç° | å®¹å™¨åŒ–å®ç° | å½¢å¼åŒ–è¯­ä¹‰ |
|------|--------------|------------|------------|------------|
| **å·¥å‚æ¨¡å¼** | fork()åˆ›å»ºè¿›ç¨‹ | clone_vm()å…‹éš†VM | docker create | Î»x. create(x) |
| **ç­–ç•¥æ¨¡å¼** | sched_classç»“æ„ä½“ | è°ƒåº¦ç­–ç•¥æ’ä»¶ | kube-scheduler Extender | Strategyæ¥å£ |
| **è§‚å¯Ÿè€…æ¨¡å¼** | wait()/signal() | è™šæ‹Ÿæœºç›‘æ§äº‹ä»¶ | watch API + informer | Pub/Sub: (Event â†’ Handler) |
| **äº«å…ƒæ¨¡å¼** | å†™æ—¶å¤åˆ¶(COW) | é“¾æ¥å…‹éš† | é•œåƒåˆ†å±‚UnionFS | âˆƒx: shared(x) âˆ§ ref_cnt(x) > 1 |
| **ä»£ç†æ¨¡å¼** | ç³»ç»Ÿè°ƒç”¨å°è£… | è™šæ‹Ÿè®¾å¤‡é©±åŠ¨ | sidecarå®¹å™¨ | Proxy(p) = forward(p.target) |

**æ¨¡å¼å…±æ€§**ï¼š

- ä¸‰å±‚ç³»ç»Ÿä½¿ç”¨ç›¸åŒçš„è®¾è®¡æ¨¡å¼
- å®ç°æ–¹å¼ä¸åŒï¼Œä½†è¯­ä¹‰ä¸€è‡´
- å½¢å¼åŒ–æè¿°ç»Ÿä¸€

---

## 2. å¹¶å‘åŸè¯­æ¼”è¿›

### 2.1 æ¼”è¿›è·¯å¾„

```text
è¿›ç¨‹é”(futex)  â†’  VMå†…å­˜é¡µå…±äº«é”  â†’  åˆ†å¸ƒå¼é”(etcd lease)
ä¿¡å·é‡        â†’  è™šæ‹Ÿæœºèµ„æºé…é¢    â†’  Kubernetes ResourceQuota
RCUæœºåˆ¶       â†’  è™šæ‹Ÿæœºå¿«ç…§åˆå¹¶    â†’  å®¹å™¨é•œåƒå±‚åˆå¹¶
```

### 2.2 è¯¦ç»†åŸè¯­æ˜ å°„

| å¹¶å‘åŸè¯­ | OSå±‚å®ç° | VMå±‚å®ç° | å®¹å™¨å±‚å®ç° | ç»Ÿä¸€æŠ½è±¡ | æ€§èƒ½ç‰¹å¾ |
|---------|---------|---------|-----------|---------|---------|
| **é”æœºåˆ¶** | futex (å¿«é€Ÿç”¨æˆ·ç©ºé—´äº’æ–¥) | å†…å­˜é¡µå…±äº«é” | etcd lease | `Lock(lockID)` | OS: <1Î¼s, VM: <10Î¼s, K8s: <100ms |
| **ä¿¡å·é‡** | sem_t (POSIXä¿¡å·é‡) | è™šæ‹Ÿæœºèµ„æºé…é¢ | ResourceQuota | `Semaphore(count)` | OS: <1Î¼s, VM: <1ms, K8s: <10ms |
| **RCUæœºåˆ¶** | Read-Copy-Update | è™šæ‹Ÿæœºå¿«ç…§åˆå¹¶ | é•œåƒå±‚åˆå¹¶ | `RCURead()` | OS: æ— é”è¯»å–, VM: å¿«ç…§åˆå¹¶, K8s: å±‚åˆå¹¶ |
| **æ¡ä»¶å˜é‡** | pthread_cond_t | è™šæ‹ŸæœºçŠ¶æ€ç­‰å¾… | Podæ¡ä»¶ç­‰å¾… | `ConditionWait()` | OS: <1Î¼s, VM: <10Î¼s, K8s: <100ms |
| **å±éšœ** | pthread_barrier_t | è™šæ‹ŸæœºåŒæ­¥ç‚¹ | PodåŒæ­¥ç‚¹ | `Barrier(count)` | OS: <1Î¼s, VM: <10Î¼s, K8s: <100ms |

### 2.3 åŸè¯­æ˜ å°„è¯¦ç»†å¯¹æ¯”

**é”æœºåˆ¶æ¼”è¿›**ï¼š

- **OSå±‚**ï¼š`futex` - å¿«é€Ÿç”¨æˆ·ç©ºé—´äº’æ–¥ï¼Œé¿å…ç³»ç»Ÿè°ƒç”¨å¼€é”€
- **VMå±‚**ï¼šå†…å­˜é¡µå…±äº«é” - ä¿æŠ¤å…±äº«å†…å­˜é¡µçš„è®¿é—®
- **å®¹å™¨å±‚**ï¼š`etcd lease` - åˆ†å¸ƒå¼é”ï¼Œä¿è¯è·¨èŠ‚ç‚¹ä¸€è‡´æ€§

**èµ„æºæ§åˆ¶æ¼”è¿›**ï¼š

- **OSå±‚**ï¼š`sem_t` - POSIXä¿¡å·é‡ï¼Œæ§åˆ¶èµ„æºè®¿é—®æ•°é‡
- **VMå±‚**ï¼šè™šæ‹Ÿæœºèµ„æºé…é¢ - é™åˆ¶VMçš„èµ„æºä½¿ç”¨
- **å®¹å™¨å±‚**ï¼š`ResourceQuota` - Kubernetesèµ„æºé…é¢ï¼Œé™åˆ¶å‘½åç©ºé—´èµ„æº

**ä¸€è‡´æ€§æ¼”è¿›**ï¼š

- **OSå±‚**ï¼š`RCU` - Read-Copy-Updateï¼Œæ— é”è¯»å–æœºåˆ¶
- **VMå±‚**ï¼šè™šæ‹Ÿæœºå¿«ç…§åˆå¹¶ - åˆå¹¶å¤šä¸ªå¿«ç…§
- **å®¹å™¨å±‚**ï¼šé•œåƒå±‚åˆå¹¶ - UnionFSå±‚åˆå¹¶

**å½¢å¼åŒ–å¯¹åº”**ï¼š

- **é”**ï¼šäº’æ–¥è®¿é—®ä¿è¯ $\forall t, \text{Lock}(r, t) \implies \neg \text{Lock}(r', t)$
- **ä¿¡å·é‡**ï¼šèµ„æºè®¡æ•° $\text{Sem}(r, n) \iff |\{e \mid \text{using}(e, r)\}| \leq n$
- **RCU**ï¼šæ— é”è¯»å– $\text{RCURead}(r) \implies \text{no write lock required}$

**å®é™…åº”ç”¨æ¡ˆä¾‹**ï¼š

| è®¾è®¡æ¨¡å¼ | OSå±‚å®ç° | VMå±‚å®ç° | å®¹å™¨å±‚å®ç° | åº”ç”¨åœºæ™¯ |
|---------|---------|---------|-----------|---------|
| å·¥å‚æ¨¡å¼ | fork() | clone_vm() | docker create | å®ä½“åˆ›å»º |
| ç­–ç•¥æ¨¡å¼ | sched_class | è°ƒåº¦æ’ä»¶ | kube-scheduler | è°ƒåº¦ç­–ç•¥åˆ‡æ¢ |
| è§‚å¯Ÿè€…æ¨¡å¼ | wait/signal | ç›‘æ§äº‹ä»¶ | watch API | çŠ¶æ€å˜åŒ–é€šçŸ¥ |
| äº«å…ƒæ¨¡å¼ | COW | é“¾æ¥å…‹éš† | é•œåƒåˆ†å±‚ | èµ„æºå…±äº« |
| ä»£ç†æ¨¡å¼ | syscall | è™šæ‹Ÿè®¾å¤‡ | sidecar | åŠŸèƒ½ä»£ç† |

**å¹¶å‘åŸè¯­æ¼”è¿›çš„å®é™…æ„ä¹‰**ï¼š

- **é”æœºåˆ¶æ¼”è¿›**ï¼šä»è¿›ç¨‹çº§äº’æ–¥åˆ°åˆ†å¸ƒå¼ä¸€è‡´æ€§
- **èµ„æºæ§åˆ¶æ¼”è¿›**ï¼šä»ä¿¡å·é‡åˆ°é…é¢ç®¡ç†
- **ä¸€è‡´æ€§æ¼”è¿›**ï¼šä»RCUåˆ°åˆ†å¸ƒå¼ä¸€è‡´æ€§åè®®

---

## 3. ç¨‹åºè®¾è®¡èŒƒå¼æ˜ å°„çš„å®é™…åº”ç”¨

**ç³»ç»Ÿè®¾è®¡**ï¼š

- ä½¿ç”¨ç»Ÿä¸€çš„è®¾è®¡æ¨¡å¼æŒ‡å¯¼ç³»ç»Ÿè®¾è®¡
- ä¿è¯ä¸åŒå±‚çš„ä¸€è‡´æ€§
- ç®€åŒ–ç³»ç»Ÿå®ç°å’Œç»´æŠ¤

**ä»£ç å¤ç”¨**ï¼š

- åŸºäºèŒƒå¼æ˜ å°„å®ç°ä»£ç å¤ç”¨
- è·¨å±‚ç§»æ¤è®¾è®¡æ¨¡å¼
- æé«˜å¼€å‘æ•ˆç‡

**ç³»ç»Ÿä¼˜åŒ–**ï¼š

- è¯†åˆ«å¯ä»¥ä¼˜åŒ–çš„è®¾è®¡æ¨¡å¼
- æ”¹è¿›ç³»ç»Ÿæ¶æ„
- æé«˜ç³»ç»Ÿæ€§èƒ½

**å·¥ç¨‹å®ç°ç¤ºä¾‹**ï¼š

### Golangå®ç°

```go
package patterns

import (
    "fmt"
    "sync"
)

// ========== å·¥å‚æ¨¡å¼ ==========
type EntityFactory interface {
    CreateEntity(spec EntitySpec) (Entity, error)
}

type OSFactory struct{}

func (f *OSFactory) CreateEntity(spec EntitySpec) (Entity, error) {
    // fork()åˆ›å»ºè¿›ç¨‹
    pid := fork()
    return &Process{
        PID:  pid,
        Spec: spec,
    }, nil
}

type VMFactory struct{}

func (f *VMFactory) CreateEntity(spec EntitySpec) (Entity, error) {
    // clone_vm()å…‹éš†VM
    uuid := generateUUID()
    return &VM{
        UUID: uuid,
        Spec: spec,
    }, nil
}

type ContainerFactory struct{}

func (f *ContainerFactory) CreateEntity(spec EntitySpec) (Entity, error) {
    // docker create
    return &Container{
        Name: spec.Name,
        Spec: spec,
    }, nil
}

// ========== ç­–ç•¥æ¨¡å¼ ==========
type SchedulerStrategy interface {
    Schedule(entities []Entity) []Entity
    Name() string
}

type CFSStrategy struct{}

func (s *CFSStrategy) Name() string {
    return "CFS"
}

func (s *CFSStrategy) Schedule(entities []Entity) []Entity {
    // CFSè°ƒåº¦é€»è¾‘ï¼šæŒ‰vruntimeæ’åº
    return sortByVruntime(entities)
}

type EEVDFStrategy struct{}

func (s *EEVDFStrategy) Name() string {
    return "EEVDF"
}

func (s *EEVDFStrategy) Schedule(entities []Entity) []Entity {
    // EEVDFè°ƒåº¦é€»è¾‘ï¼šæŒ‰è™šæ‹Ÿèµ·å§‹æ—¶é—´æ’åº
    return sortByVirtualStartTime(entities)
}

type RoundRobinStrategy struct{}

func (s *RoundRobinStrategy) Name() string {
    return "RoundRobin"
}

func (s *RoundRobinStrategy) Schedule(entities []Entity) []Entity {
    // è½®è¯¢è°ƒåº¦
    return entities // ç®€å•å®ç°
}

// ========== è§‚å¯Ÿè€…æ¨¡å¼ ==========
type EventObserver interface {
    OnEvent(event Event)
}

type EventNotifier struct {
    observers []EventObserver
    mu        sync.RWMutex
}

func NewEventNotifier() *EventNotifier {
    return &EventNotifier{
        observers: make([]EventObserver, 0),
    }
}

func (n *EventNotifier) Subscribe(observer EventObserver) {
    n.mu.Lock()
    defer n.mu.Unlock()
    n.observers = append(n.observers, observer)
}

func (n *EventNotifier) Notify(event Event) {
    n.mu.RLock()
    defer n.mu.RUnlock()
    for _, observer := range n.observers {
        observer.OnEvent(event)
    }
}

// OSå±‚ï¼šwait()/signal()
type OSWaitObserver struct{}

func (o *OSWaitObserver) OnEvent(event Event) {
    if event.Type == "process_ready" {
        signal(event.ProcessID)
    }
}

// å®¹å™¨å±‚ï¼šwatch API + informer
type K8sWatchObserver struct {
    informer Informer
}

func (o *K8sWatchObserver) OnEvent(event Event) {
    o.informer.Handle(event)
}

// ========== äº«å…ƒæ¨¡å¼ ==========
type SharedResource struct {
    data     []byte
    refCount int
    mu       sync.Mutex
}

func (sr *SharedResource) Acquire() {
    sr.mu.Lock()
    defer sr.mu.Unlock()
    sr.refCount++
}

func (sr *SharedResource) Release() {
    sr.mu.Lock()
    defer sr.mu.Unlock()
    sr.refCount--
    if sr.refCount == 0 {
        // é‡Šæ”¾èµ„æº
    }
}

// OSå±‚ï¼šå†™æ—¶å¤åˆ¶(COW)
type COWPage struct {
    *SharedResource
}

// VMå±‚ï¼šé“¾æ¥å…‹éš†
type LinkedClone struct {
    *SharedResource
}

// å®¹å™¨å±‚ï¼šé•œåƒåˆ†å±‚UnionFS
type ImageLayer struct {
    *SharedResource
}

// ========== ä»£ç†æ¨¡å¼ ==========
type Proxy interface {
    Forward(request Request) Response
}

// OSå±‚ï¼šç³»ç»Ÿè°ƒç”¨å°è£…
type SyscallProxy struct {
    kernel Kernel
}

func (p *SyscallProxy) Forward(request Request) Response {
    return p.kernel.Syscall(request)
}

// VMå±‚ï¼šè™šæ‹Ÿè®¾å¤‡é©±åŠ¨
type VirtioProxy struct {
    device Device
}

func (p *VirtioProxy) Forward(request Request) Response {
    return p.device.Handle(request)
}

// å®¹å™¨å±‚ï¼šsidecarå®¹å™¨
type SidecarProxy struct {
    sidecar Container
}

func (p *SidecarProxy) Forward(request Request) Response {
    return p.sidecar.Process(request)
}
```

#### Pythonå®ç°

```python
from abc import ABC, abstractmethod
from typing import List
import threading

# ========== å·¥å‚æ¨¡å¼ ==========
class EntityFactory(ABC):
    @abstractmethod
    def create_entity(self, spec: EntitySpec) -> Entity:
        pass

class OSFactory(EntityFactory):
    def create_entity(self, spec: EntitySpec) -> Entity:
        # fork()åˆ›å»ºè¿›ç¨‹
        pid = fork()
        return Process(pid=pid, spec=spec)

class VMFactory(EntityFactory):
    def create_entity(self, spec: EntitySpec) -> Entity:
        # clone_vm()å…‹éš†VM
        uuid = generate_uuid()
        return VM(uuid=uuid, spec=spec)

class ContainerFactory(EntityFactory):
    def create_entity(self, spec: EntitySpec) -> Entity:
        # docker create
        return Container(name=spec.name, spec=spec)

# ========== ç­–ç•¥æ¨¡å¼ ==========
class SchedulerStrategy(ABC):
    @abstractmethod
    def schedule(self, entities: List[Entity]) -> List[Entity]:
        pass

class CFSStrategy(SchedulerStrategy):
    def schedule(self, entities: List[Entity]) -> List[Entity]:
        # CFSè°ƒåº¦é€»è¾‘ï¼šæŒ‰vruntimeæ’åº
        return sorted(entities, key=lambda e: e.vruntime)

class EEVDFStrategy(SchedulerStrategy):
    def schedule(self, entities: List[Entity]) -> List[Entity]:
        # EEVDFè°ƒåº¦é€»è¾‘ï¼šæŒ‰è™šæ‹Ÿèµ·å§‹æ—¶é—´æ’åº
        return sorted(entities, key=lambda e: e.virtual_start_time)

class RoundRobinStrategy(SchedulerStrategy):
    def schedule(self, entities: List[Entity]) -> List[Entity]:
        # è½®è¯¢è°ƒåº¦
        return entities

# ========== è§‚å¯Ÿè€…æ¨¡å¼ ==========
class EventObserver(ABC):
    @abstractmethod
    def on_event(self, event: Event):
        pass

class EventNotifier:
    def __init__(self):
        self._observers: List[EventObserver] = []
        self._lock = threading.Lock()

    def subscribe(self, observer: EventObserver):
        with self._lock:
            self._observers.append(observer)

    def notify(self, event: Event):
        with self._lock:
            for observer in self._observers:
                observer.on_event(event)

# OSå±‚ï¼šwait()/signal()
class OSWaitObserver(EventObserver):
    def on_event(self, event: Event):
        if event.type == "process_ready":
            signal(event.process_id)

# å®¹å™¨å±‚ï¼šwatch API + informer
class K8sWatchObserver(EventObserver):
    def __init__(self, informer):
        self.informer = informer

    def on_event(self, event: Event):
        self.informer.handle(event)

# ========== äº«å…ƒæ¨¡å¼ ==========
class SharedResource:
    def __init__(self, data: bytes):
        self.data = data
        self._ref_count = 0
        self._lock = threading.Lock()

    def acquire(self):
        with self._lock:
            self._ref_count += 1

    def release(self):
        with self._lock:
            self._ref_count -= 1
            if self._ref_count == 0:
                # é‡Šæ”¾èµ„æº
                pass

# OSå±‚ï¼šå†™æ—¶å¤åˆ¶(COW)
class COWPage(SharedResource):
    pass

# VMå±‚ï¼šé“¾æ¥å…‹éš†
class LinkedClone(SharedResource):
    pass

# å®¹å™¨å±‚ï¼šé•œåƒåˆ†å±‚UnionFS
class ImageLayer(SharedResource):
    pass

# ========== ä»£ç†æ¨¡å¼ ==========
class Proxy(ABC):
    @abstractmethod
    def forward(self, request: Request) -> Response:
        pass

# OSå±‚ï¼šç³»ç»Ÿè°ƒç”¨å°è£…
class SyscallProxy(Proxy):
    def __init__(self, kernel):
        self.kernel = kernel

    def forward(self, request: Request) -> Response:
        return self.kernel.syscall(request)

# VMå±‚ï¼šè™šæ‹Ÿè®¾å¤‡é©±åŠ¨
class VirtioProxy(Proxy):
    def __init__(self, device):
        self.device = device

    def forward(self, request: Request) -> Response:
        return self.device.handle(request)

# å®¹å™¨å±‚ï¼šsidecarå®¹å™¨
class SidecarProxy(Proxy):
    def __init__(self, sidecar):
        self.sidecar = sidecar

    def forward(self, request: Request) -> Response:
        return self.sidecar.process(request)
```

#### Rustå®ç°

```rust
use std::sync::{Arc, Mutex};
use std::collections::VecDeque;

// ========== å·¥å‚æ¨¡å¼ ==========
pub trait EntityFactory {
    fn create_entity(&self, spec: EntitySpec) -> Result<Box<dyn Entity>, String>;
}

pub struct OSFactory;

impl EntityFactory for OSFactory {
    fn create_entity(&self, spec: EntitySpec) -> Result<Box<dyn Entity>, String> {
        // fork()åˆ›å»ºè¿›ç¨‹
        let pid = fork();
        Ok(Box::new(Process { pid, spec }))
    }
}

pub struct VMFactory;

impl EntityFactory for VMFactory {
    fn create_entity(&self, spec: EntitySpec) -> Result<Box<dyn Entity>, String> {
        // clone_vm()å…‹éš†VM
        let uuid = generate_uuid();
        Ok(Box::new(VM { uuid, spec }))
    }
}

pub struct ContainerFactory;

impl EntityFactory for ContainerFactory {
    fn create_entity(&self, spec: EntitySpec) -> Result<Box<dyn Entity>, String> {
        // docker create
        Ok(Box::new(Container {
            name: spec.name.clone(),
            spec,
        }))
    }
}

// ========== ç­–ç•¥æ¨¡å¼ ==========
pub trait SchedulerStrategy {
    fn schedule(&self, entities: &mut Vec<Box<dyn Entity>>) -> Vec<Box<dyn Entity>>;
    fn name(&self) -> &str;
}

pub struct CFSStrategy;

impl SchedulerStrategy for CFSStrategy {
    fn name(&self) -> &str {
        "CFS"
    }

    fn schedule(&self, entities: &mut Vec<Box<dyn Entity>>) -> Vec<Box<dyn Entity>> {
        // CFSè°ƒåº¦é€»è¾‘ï¼šæŒ‰vruntimeæ’åº
        entities.sort_by(|a, b| a.vruntime().partial_cmp(&b.vruntime()).unwrap());
        entities.clone()
    }
}

pub struct EEVDFStrategy;

impl SchedulerStrategy for EEVDFStrategy {
    fn name(&self) -> &str {
        "EEVDF"
    }

    fn schedule(&self, entities: &mut Vec<Box<dyn Entity>>) -> Vec<Box<dyn Entity>> {
        // EEVDFè°ƒåº¦é€»è¾‘ï¼šæŒ‰è™šæ‹Ÿèµ·å§‹æ—¶é—´æ’åº
        entities.sort_by(|a, b| {
            a.virtual_start_time()
                .partial_cmp(&b.virtual_start_time())
                .unwrap()
        });
        entities.clone()
    }
}

// ========== è§‚å¯Ÿè€…æ¨¡å¼ ==========
pub trait EventObserver: Send + Sync {
    fn on_event(&self, event: &Event);
}

pub struct EventNotifier {
    observers: Arc<Mutex<Vec<Box<dyn EventObserver>>>>,
}

impl EventNotifier {
    pub fn new() -> Self {
        EventNotifier {
            observers: Arc::new(Mutex::new(Vec::new())),
        }
    }

    pub fn subscribe(&self, observer: Box<dyn EventObserver>) {
        self.observers.lock().unwrap().push(observer);
    }

    pub fn notify(&self, event: &Event) {
        let observers = self.observers.lock().unwrap();
        for observer in observers.iter() {
            observer.on_event(event);
        }
    }
}

// OSå±‚ï¼šwait()/signal()
pub struct OSWaitObserver;

impl EventObserver for OSWaitObserver {
    fn on_event(&self, event: &Event) {
        if event.event_type == "process_ready" {
            signal(event.process_id);
        }
    }
}

// å®¹å™¨å±‚ï¼šwatch API + informer
pub struct K8sWatchObserver {
    informer: Arc<dyn Informer>,
}

impl EventObserver for K8sWatchObserver {
    fn on_event(&self, event: &Event) {
        self.informer.handle(event);
    }
}

// ========== äº«å…ƒæ¨¡å¼ ==========
pub struct SharedResource {
    data: Vec<u8>,
    ref_count: Arc<Mutex<usize>>,
}

impl SharedResource {
    pub fn new(data: Vec<u8>) -> Self {
        SharedResource {
            data,
            ref_count: Arc::new(Mutex::new(0)),
        }
    }

    pub fn acquire(&self) {
        *self.ref_count.lock().unwrap() += 1;
    }

    pub fn release(&self) {
        let mut count = self.ref_count.lock().unwrap();
        *count -= 1;
        if *count == 0 {
            // é‡Šæ”¾èµ„æº
        }
    }
}

// ========== ä»£ç†æ¨¡å¼ ==========
pub trait Proxy {
    fn forward(&self, request: &Request) -> Response;
}

// OSå±‚ï¼šç³»ç»Ÿè°ƒç”¨å°è£…
pub struct SyscallProxy {
    kernel: Arc<dyn Kernel>,
}

impl Proxy for SyscallProxy {
    fn forward(&self, request: &Request) -> Response {
        self.kernel.syscall(request)
    }
}

// VMå±‚ï¼šè™šæ‹Ÿè®¾å¤‡é©±åŠ¨
pub struct VirtioProxy {
    device: Arc<dyn Device>,
}

impl Proxy for VirtioProxy {
    fn forward(&self, request: &Request) -> Response {
        self.device.handle(request)
    }
}

// å®¹å™¨å±‚ï¼šsidecarå®¹å™¨
pub struct SidecarProxy {
    sidecar: Arc<dyn Container>,
}

impl Proxy for SidecarProxy {
    fn forward(&self, request: &Request) -> Response {
        self.sidecar.process(request)
    }
}
```

**èŒƒå¼æ˜ å°„çš„å®é™…ä»·å€¼**ï¼š

- **ä»£ç å¤ç”¨**ï¼šç»Ÿä¸€çš„è®¾è®¡æ¨¡å¼æ”¯æŒä»£ç å¤ç”¨
- **æ¶æ„ä¸€è‡´æ€§**ï¼šä¿è¯ä¸åŒå±‚çš„æ¶æ„ä¸€è‡´æ€§
- **ç»´æŠ¤ç®€åŒ–**ï¼šç»Ÿä¸€çš„æ¨¡å¼ç®€åŒ–äº†ç³»ç»Ÿç»´æŠ¤

### 4.1 èŒƒå¼æ˜ å°„çš„åŒæ„æ€§

**å®šç†100**ï¼ˆèŒƒå¼æ˜ å°„çš„åŒæ„æ€§ï¼‰ï¼š
ç¨‹åºè®¾è®¡èŒƒå¼åœ¨ä¸‰å±‚è°ƒåº¦ç³»ç»Ÿä¸­æ˜¯åŒæ„çš„ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šåŒæ„æ€§å®šä¹‰

**å®šä¹‰**ï¼ˆåŒæ„æ€§ï¼‰ï¼š
èŒƒå¼æ˜ å°„æ˜¯åŒæ„çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨åŒå°„æ˜ å°„ä¿æŒèŒƒå¼çš„ç»“æ„ã€‚

#### æ­¥éª¤2ï¼šåŒæ„æ€§è¯æ˜

**å¼•ç†100.1**ï¼ˆåŒæ„æ€§è¯æ˜ï¼‰ï¼š
ç¨‹åºè®¾è®¡èŒƒå¼åœ¨ä¸‰å±‚ç³»ç»Ÿä¸­ä¿æŒç›¸åŒçš„ç»“æ„ã€‚

**è¯æ˜**ï¼š
ç”±ç»Ÿä¸€å½¢å¼åŒ–å®šç†ï¼Œä¸‰å±‚ç³»ç»Ÿçš„èŒƒå¼æ˜ å°„ä¿æŒç›¸åŒçš„æ•°å­¦ç»“æ„ï¼Œå› æ­¤æ˜¯åŒæ„çš„ã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†100.1ï¼ŒèŒƒå¼æ˜ å°„æ˜¯åŒæ„çš„ã€‚ âˆ

### 4.2 èŒƒå¼æ˜ å°„çš„å®é™…åº”ç”¨

#### 4.2.1 è·¨å±‚æ¨¡å¼å¤ç”¨

**åœºæ™¯**ï¼šä½¿ç”¨èŒƒå¼æ˜ å°„å®ç°è·¨å±‚æ¨¡å¼å¤ç”¨ã€‚

**æ–¹æ³•**ï¼š

1. è¯†åˆ«è®¾è®¡æ¨¡å¼
2. å»ºç«‹èŒƒå¼æ˜ å°„
3. åº”ç”¨æ¨¡å¼åˆ°ä¸åŒå±‚

**Golangå®ç°**ï¼š

```go
package paradigm

// è·¨å±‚æ¨¡å¼å¤ç”¨
func ReusePatternAcrossLayers(
    pattern DesignPattern,
    layers []Layer,
) (map[Layer]Implementation, error) {
    // è¯†åˆ«è®¾è®¡æ¨¡å¼
    patternType := identifyPatternType(pattern)

    // å»ºç«‹èŒƒå¼æ˜ å°„
    mapper := NewParadigmMapper()

    // åº”ç”¨æ¨¡å¼åˆ°ä¸åŒå±‚
    implementations := make(map[Layer]Implementation)
    for _, layer := range layers {
        impl, err := mapper.MapPattern(pattern, layer)
        if err != nil {
            return nil, err
        }
        implementations[layer] = impl
    }

    return implementations, nil
}

// æ˜ å°„æ¨¡å¼
func (pm *ParadigmMapper) MapPattern(
    pattern DesignPattern,
    layer Layer,
) (Implementation, error) {
    // æ ¹æ®å±‚ç±»å‹åº”ç”¨æ¨¡å¼
    switch layer {
    case OSLayer:
        return pm.mapToOS(pattern)
    case VMLayer:
        return pm.mapToVM(pattern)
    case ContainerLayer:
        return pm.mapToContainer(pattern)
    default:
        return nil, fmt.Errorf("unsupported layer")
    }
}
```

**Pythonå®ç°**ï¼š

```python
def reuse_pattern_across_layers(
    pattern: DesignPattern,
    layers: List[Layer],
) -> Dict[Layer, Implementation]:
    """è·¨å±‚æ¨¡å¼å¤ç”¨"""
    # è¯†åˆ«è®¾è®¡æ¨¡å¼
    pattern_type = identify_pattern_type(pattern)

    # å»ºç«‹èŒƒå¼æ˜ å°„
    mapper = ParadigmMapper()

    # åº”ç”¨æ¨¡å¼åˆ°ä¸åŒå±‚
    implementations = {}
    for layer in layers:
        impl = mapper.map_pattern(pattern, layer)
        implementations[layer] = impl

    return implementations

def map_pattern(
    self, pattern: DesignPattern, layer: Layer
) -> Implementation:
    """æ˜ å°„æ¨¡å¼"""
    # æ ¹æ®å±‚ç±»å‹åº”ç”¨æ¨¡å¼
    if layer == Layer.OS:
        return self.map_to_os(pattern)
    elif layer == Layer.VM:
        return self.map_to_vm(pattern)
    elif layer == Layer.CONTAINER:
        return self.map_to_container(pattern)
    else:
        raise ValueError("Unsupported layer")
```

**Rustå®ç°**ï¼š

```rust
pub fn reuse_pattern_across_layers(
    pattern: &DesignPattern,
    layers: &[Layer],
) -> Result<HashMap<Layer, Implementation>, Error> {
    // è¯†åˆ«è®¾è®¡æ¨¡å¼
    let pattern_type = identify_pattern_type(pattern)?;

    // å»ºç«‹èŒƒå¼æ˜ å°„
    let mapper = ParadigmMapper::new();

    // åº”ç”¨æ¨¡å¼åˆ°ä¸åŒå±‚
    let mut implementations = HashMap::new();
    for layer in layers {
        let impl = mapper.map_pattern(pattern, layer)?;
        implementations.insert(*layer, impl);
    }

    Ok(implementations)
}

impl ParadigmMapper {
    pub fn map_pattern(
        &self,
        pattern: &DesignPattern,
        layer: &Layer,
    ) -> Result<Implementation, Error> {
        // æ ¹æ®å±‚ç±»å‹åº”ç”¨æ¨¡å¼
        match layer {
            Layer::OS => self.map_to_os(pattern),
            Layer::VM => self.map_to_vm(pattern),
            Layer::Container => self.map_to_container(pattern),
        }
    }
}
```

---

## 4. ç›¸å…³æ–‡æ¡£

- [è¿”å› FormalModel ç›®å½•](../README.md)
- [01_åŸºç¡€å½¢å¼åŒ–æ¡†æ¶ README](README.md)
- [01.2_æ€ç»´å¯¼å›¾](01.2_æ€ç»´å¯¼å›¾.md)
- [09_å·¥ç¨‹æ•°å­¦ç»Ÿä¸€](../09_å·¥ç¨‹æ•°å­¦ç»Ÿä¸€/README.md)

---

**æœ€åæ›´æ–°**: 2025-01-27
