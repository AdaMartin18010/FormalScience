# 09.2 æ ¸å¿ƒç®—æ³•æ•°å­¦ç»“æ„

> **æ‰€å±ä¸»é¢˜**: 09_å·¥ç¨‹æ•°å­¦ç»Ÿä¸€
> **æœ€åæ›´æ–°**: 2025-01-27

## ğŸ“‹ ç›®å½•

- [09.2 æ ¸å¿ƒç®—æ³•æ•°å­¦ç»“æ„](#092-æ ¸å¿ƒç®—æ³•æ•°å­¦ç»“æ„)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. æ—¶é—´ç‰‡è½®è½¬ä¸‰å±‚å®ç°](#1-æ—¶é—´ç‰‡è½®è½¬ä¸‰å±‚å®ç°)
    - [1.1 å®šç†1çš„å®Œæ•´è¯æ˜](#11-å®šç†1çš„å®Œæ•´è¯æ˜)
      - [æ­¥éª¤1ï¼šä¿¡ç”¨å‡½æ•°çš„å®šä¹‰](#æ­¥éª¤1ä¿¡ç”¨å‡½æ•°çš„å®šä¹‰)
      - [æ­¥éª¤2ï¼šç¨³æ€æ¡ä»¶](#æ­¥éª¤2ç¨³æ€æ¡ä»¶)
      - [æ­¥éª¤3ï¼šä»½é¢æ”¶æ•›](#æ­¥éª¤3ä»½é¢æ”¶æ•›)
      - [æ­¥éª¤4ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤4ä¸»å®šç†è¯æ˜)
  - [2. è´Ÿè½½å‡è¡¡ç®—æ³•è¯æ˜](#2-è´Ÿè½½å‡è¡¡ç®—æ³•è¯æ˜)
    - [2.1 å®šç†2çš„å®Œæ•´è¯æ˜](#21-å®šç†2çš„å®Œæ•´è¯æ˜)
      - [æ­¥éª¤1ï¼šå¹³è¡¡åŠ¿èƒ½å‡½æ•°](#æ­¥éª¤1å¹³è¡¡åŠ¿èƒ½å‡½æ•°)
      - [æ­¥éª¤2ï¼šæ¢¯åº¦ä¸‹é™](#æ­¥éª¤2æ¢¯åº¦ä¸‹é™)
      - [æ­¥éª¤3ï¼šä¸€é˜¶æ¡ä»¶](#æ­¥éª¤3ä¸€é˜¶æ¡ä»¶)
      - [æ­¥éª¤4ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤4ä¸»å®šç†è¯æ˜-1)
  - [3. CFSç®—æ³•å½¢å¼åŒ–](#3-cfsç®—æ³•å½¢å¼åŒ–)
  - [4. ç®—æ³•ç»Ÿä¸€æ€§çš„å®é™…æ„ä¹‰](#4-ç®—æ³•ç»Ÿä¸€æ€§çš„å®é™…æ„ä¹‰)
    - [Golangå®ç°](#golangå®ç°)
      - [Pythonå®ç°](#pythonå®ç°)
      - [Rustå®ç°](#rustå®ç°)
    - [5.1 æ ¸å¿ƒç®—æ³•çš„ç»Ÿä¸€æ€§](#51-æ ¸å¿ƒç®—æ³•çš„ç»Ÿä¸€æ€§)
      - [æ­¥éª¤1ï¼šç®—æ³•ç»“æ„å®šä¹‰](#æ­¥éª¤1ç®—æ³•ç»“æ„å®šä¹‰)
      - [æ­¥éª¤2ï¼šç»Ÿä¸€æ€§è¯æ˜](#æ­¥éª¤2ç»Ÿä¸€æ€§è¯æ˜)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜)
    - [5.2 ç®—æ³•ä¼˜åŒ–çš„å®é™…åº”ç”¨](#52-ç®—æ³•ä¼˜åŒ–çš„å®é™…åº”ç”¨)
      - [5.2.1 è·¨å±‚ç®—æ³•ä¼˜åŒ–](#521-è·¨å±‚ç®—æ³•ä¼˜åŒ–)
    - [5.1 ç®—æ³•ç»“æ„çš„åŒæ„æ€§](#51-ç®—æ³•ç»“æ„çš„åŒæ„æ€§)
      - [æ­¥éª¤1ï¼šåŒæ„æ€§å®šä¹‰](#æ­¥éª¤1åŒæ„æ€§å®šä¹‰)
      - [æ­¥éª¤2ï¼šåŒæ„æ€§è¯æ˜](#æ­¥éª¤2åŒæ„æ€§è¯æ˜)
      - [æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜](#æ­¥éª¤3ä¸»å®šç†è¯æ˜-1)
    - [5.2 æ ¸å¿ƒç®—æ³•çš„å®é™…åº”ç”¨](#52-æ ¸å¿ƒç®—æ³•çš„å®é™…åº”ç”¨)
      - [5.2.1 ç®—æ³•æ€§èƒ½å¯¹æ¯”](#521-ç®—æ³•æ€§èƒ½å¯¹æ¯”)
  - [5. ç›¸å…³æ–‡æ¡£](#5-ç›¸å…³æ–‡æ¡£)

---

## 1. æ—¶é—´ç‰‡è½®è½¬ä¸‰å±‚å®ç°

**å·¥ç¨‹å‚æ•°**ï¼š

| å±‚çº§ | æ—¶é—´ç‰‡é•¿åº¦ | æ—¶é—´æˆ³ç²¾åº¦ | æŠ¢å ç‚¹ | å¼€é”€ |
|------|------------|------------|--------|------|
| OS | `RR_INTERVAL=6ms` | `jiffies` (4.15å`ktime`) | æ—¶é’Ÿä¸­æ–­ (`timer_interrupt`) | ~1Î¼s |
| VM | `kvm_halt_poll_ns=50000` (50Î¼s) | `kvm_clock` | VM-Exit | ~200Î¼s |
| å®¹å™¨ | `cpu.cfs_period_us=100ms` | `cgroup.stat` é‡‡æ · | cgroup throttling | ~10ms |

**ç»Ÿä¸€æ•°å­¦æ¨¡å‹**ï¼š

**å®šä¹‰1**ï¼ˆåŠ æƒè½®è½¬è°ƒåº¦å™¨ï¼‰ï¼š
ç»™å®šå®ä½“é›† $E$ å’Œæƒé‡å‡½æ•° $w: E \to \mathbb{R}_{>0}$ï¼Œå®šä¹‰**ä¿¡ç”¨å‡½æ•°**ï¼š

$$
\text{credit}_i(t) = \int_0^t \frac{w_i}{\sum_{j \in \text{active}(t)} w_j} \,dt - \sum_{k: \text{è°ƒåº¦}_i^k} \Delta \tau
$$

**å®šç†1**ï¼ˆä¿¡ç”¨æ”¶æ•›æ€§ï¼‰ï¼š
åœ¨ç¨³æ€ä¸‹ï¼Œå®ä½“ $i$ è·å¾—çš„CPUä»½é¢æ”¶æ•›äºï¼š

$$
\lim_{T \to \infty} \frac{\sum_{k} \Delta \tau_i^k}{T} = \frac{w_i}{\sum_{j \in E} w_j}
$$

### 1.1 å®šç†1çš„å®Œæ•´è¯æ˜

#### æ­¥éª¤1ï¼šä¿¡ç”¨å‡½æ•°çš„å®šä¹‰

**å¼•ç†1.1**ï¼ˆä¿¡ç”¨å‡½æ•°ï¼‰ï¼š
ä¿¡ç”¨å‡½æ•°å®šä¹‰ä¸ºï¼š

$$
\text{credit}_i(t) = \int_0^t \frac{w_i}{\sum_{j \in \text{active}(t)} w_j} \,dt - \sum_{k: \text{è°ƒåº¦}_i^k} \Delta \tau
$$

**è¯æ˜**ï¼š
ä¿¡ç”¨å‡½æ•°çš„ç¬¬ä¸€é¡¹è¡¨ç¤ºåº”è·å¾—çš„CPUæ—¶é—´ï¼Œç¬¬äºŒé¡¹è¡¨ç¤ºå®é™…è·å¾—çš„CPUæ—¶é—´ã€‚ âˆ

#### æ­¥éª¤2ï¼šç¨³æ€æ¡ä»¶

**å¼•ç†1.2**ï¼ˆç¨³æ€æ¡ä»¶ï¼‰ï¼š
åœ¨ç¨³æ€ä¸‹ï¼Œä¿¡ç”¨å‡½æ•°æ»¡è¶³ï¼š

$$
\lim_{t \to \infty} \frac{\text{credit}_i(t)}{t} = 0
$$

**è¯æ˜**ï¼š
åœ¨ç¨³æ€ä¸‹ï¼Œåº”è·å¾—çš„CPUæ—¶é—´ç­‰äºå®é™…è·å¾—çš„CPUæ—¶é—´ï¼Œå› æ­¤ä¿¡ç”¨å‡½æ•°çš„å¢é•¿ç‡è¶‹äº0ã€‚ âˆ

#### æ­¥éª¤3ï¼šä»½é¢æ”¶æ•›

**å¼•ç†1.3**ï¼ˆä»½é¢æ”¶æ•›ï¼‰ï¼š
åœ¨ç¨³æ€ä¸‹ï¼Œå®ä½“ $i$ è·å¾—çš„CPUä»½é¢æ”¶æ•›äºæƒé‡æ¯”ä¾‹ã€‚

**è¯æ˜**ï¼š
ç”±å¼•ç†1.2ï¼Œåœ¨ç¨³æ€ä¸‹ï¼š

$$
\lim_{t \to \infty} \frac{\int_0^t \frac{w_i}{\sum_{j \in \text{active}(t)} w_j} \,dt}{t} = \lim_{t \to \infty} \frac{\sum_{k: \text{è°ƒåº¦}_i^k} \Delta \tau}{t}
$$

åœ¨ç¨³æ€ä¸‹ï¼Œæ´»è·ƒå®ä½“é›†åˆè¶‹äºç¨³å®šï¼Œå› æ­¤ï¼š

$$
\lim_{T \to \infty} \frac{\sum_{k} \Delta \tau_i^k}{T} = \frac{w_i}{\sum_{j \in E} w_j}
$$

âˆ

#### æ­¥éª¤4ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†1.1-1.3ï¼Œå®šç†1æˆç«‹ã€‚ âˆ

---

## 2. è´Ÿè½½å‡è¡¡ç®—æ³•è¯æ˜

**å·¥ç¨‹åœºæ™¯**ï¼š

- **OSå±‚**ï¼š`sched_balance_work()` åœ¨ `SCHED_SOFTIRQ` ä¸­ï¼Œæ¯4msæ£€æŸ¥è·¨æ ¸è´Ÿè½½
- **VMå±‚**ï¼švSphere DRS æ¯5åˆ†é’Ÿè®¡ç®— **Standard Deviation of CPU Demand**ï¼Œé˜ˆå€¼3çº§
- **å®¹å™¨å±‚**ï¼š`kubelet` çš„ **Topology Manager** åœ¨ Admit é˜¶æ®µå¯¹é½ NUMA äº²å’Œæ€§

**ç»Ÿä¸€æ¨¡å‹**ï¼š

**å®šä¹‰2**ï¼ˆè´Ÿè½½ä¸å¹³è¡¡åº¦ï¼‰ï¼š
åœ¨èŠ‚ç‚¹é›†åˆ $N$ ä¸Šï¼Œè´Ÿè½½å‘é‡ $\mathbf{L} = (L_1, \dots, L_n)$ï¼Œå®šä¹‰**å¹³è¡¡åŠ¿èƒ½**ï¼š

$$
\Phi(\mathbf{L}) = \sum_{i=1}^n \Phi_i(L_i) + \sum_{i<j} \Phi_{ij}(L_i, L_j)
$$

**å®šç†2**ï¼ˆLBå†³ç­–çš„æœ€ä¼˜æ€§ï¼‰ï¼š
è´Ÿè½½è¿ç§»å†³ç­– $m: i \to j$ æ˜¯**æ¢¯åº¦ä¸‹é™æ­¥**å½“ä¸”ä»…å½“ï¼š

$$
\langle \nabla \Phi(\mathbf{L}), \Delta \mathbf{L}(m) \rangle < 0
$$

### 2.1 å®šç†2çš„å®Œæ•´è¯æ˜

#### æ­¥éª¤1ï¼šå¹³è¡¡åŠ¿èƒ½å‡½æ•°

**å¼•ç†2.1**ï¼ˆå¹³è¡¡åŠ¿èƒ½ï¼‰ï¼š
å¹³è¡¡åŠ¿èƒ½å‡½æ•°å®šä¹‰ä¸ºï¼š

$$
\Phi(\mathbf{L}) = \sum_{i=1}^n \Phi_i(L_i) + \sum_{i<j} \Phi_{ij}(L_i, L_j)
$$

å…¶ä¸­ $\Phi_i$ æ˜¯èŠ‚ç‚¹ $i$ çš„åŠ¿èƒ½ï¼Œ$\Phi_{ij}$ æ˜¯èŠ‚ç‚¹ $i$ å’Œ $j$ ä¹‹é—´çš„äº¤äº’åŠ¿èƒ½ã€‚

**è¯æ˜**ï¼š
å¹³è¡¡åŠ¿èƒ½å‡½æ•°è¡¡é‡ç³»ç»Ÿçš„è´Ÿè½½ä¸å¹³è¡¡ç¨‹åº¦ã€‚ âˆ

#### æ­¥éª¤2ï¼šæ¢¯åº¦ä¸‹é™

**å¼•ç†2.2**ï¼ˆæ¢¯åº¦ä¸‹é™ï¼‰ï¼š
è´Ÿè½½è¿ç§»å†³ç­– $m: i \to j$ æ˜¯æ¢¯åº¦ä¸‹é™æ­¥ï¼Œå½“ä¸”ä»…å½“ï¼š

$$
\Phi(\mathbf{L} + \Delta \mathbf{L}(m)) < \Phi(\mathbf{L})
$$

**è¯æ˜**ï¼š
æ¢¯åº¦ä¸‹é™è¦æ±‚åŠ¿èƒ½å‡½æ•°å‡å°ã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸€é˜¶æ¡ä»¶

**å¼•ç†2.3**ï¼ˆä¸€é˜¶æ¡ä»¶ï¼‰ï¼š
å¯¹äºå°çš„è´Ÿè½½å˜åŒ– $\Delta \mathbf{L}$ï¼ŒåŠ¿èƒ½å˜åŒ–ä¸ºï¼š

$$
\Delta \Phi \approx \langle \nabla \Phi(\mathbf{L}), \Delta \mathbf{L} \rangle
$$

**è¯æ˜**ï¼š
ç”±æ³°å‹’å±•å¼€ï¼Œä¸€é˜¶é¡¹ä¸º $\langle \nabla \Phi(\mathbf{L}), \Delta \mathbf{L} \rangle$ã€‚ âˆ

#### æ­¥éª¤4ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†2.1-2.3ï¼Œè´Ÿè½½è¿ç§»å†³ç­–æ˜¯æ¢¯åº¦ä¸‹é™æ­¥å½“ä¸”ä»…å½“ $\langle \nabla \Phi(\mathbf{L}), \Delta \mathbf{L}(m) \rangle < 0$ã€‚ âˆ

---

## 3. CFSç®—æ³•å½¢å¼åŒ–

**å·¥ç¨‹éªŒè¯**ï¼š
åœ¨ Linux 5.15 å†…æ ¸ä¸­ï¼ŒCFSçš„ `vruntime` æ›´æ–°ï¼š

```c
static void update_curr(struct cfs_rq *cfs_rq) {
    struct sched_entity *curr = cfs_rq->curr;
    u64 now = rq_clock_task(rq_of(cfs_rq));
    u64 delta_exec = now - curr->exec_start;
    curr->vruntime += calc_delta_fair(delta_exec, curr);
}
```

å…¶ä¸­ `calc_delta_fair` å®ç°ï¼š

$$
\Delta \text{vruntime} = \Delta \text{exec\_time} \times \frac{\text{weight}_{\text{nice}_0}}{\text{weight}_{\text{curr}}}
$$

è¿™ä¸å®šç†1ä¸­ä¿¡ç”¨ç´¯ç§¯å…¬å¼å®Œå…¨ä¸€è‡´ï¼Œæƒé‡æ¯”å†³å®šå®é™…åˆ†é…ã€‚

**ä¸‰å±‚å®ç°å¯¹æ¯”**ï¼š

| å±‚çº§ | å®ç°æ–¹å¼ | æƒé‡è¡¨ç¤º | ä¿¡ç”¨æœºåˆ¶ |
|------|---------|---------|---------|
| OSå±‚ | CFSçº¢é»‘æ ‘ | `load.weight` | `vruntime`ç´¯ç§¯ |
| VMå±‚ | EEVDFç®—æ³• | CPUä»½é¢ | è™šæ‹Ÿèµ·å§‹æ—¶é—´ |
| å®¹å™¨å±‚ | cgroupé…é¢ | `cpu.shares` | é…é¢å‘¨æœŸåˆ†é… |

---

## 4. ç®—æ³•ç»Ÿä¸€æ€§çš„å®é™…æ„ä¹‰

**è·¨å±‚ç®—æ³•ç§»æ¤**ï¼š

- CFSç®—æ³•æ€æƒ³å¯ä»¥åº”ç”¨åˆ°Kubernetes CPU Manager
- EEVDFç®—æ³•å¯ä»¥åº”ç”¨åˆ°å®¹å™¨è°ƒåº¦å™¨
- è´Ÿè½½å‡è¡¡ç®—æ³•å¯ä»¥åœ¨ä¸‰å±‚é—´å…±äº«

**æ€§èƒ½ä¼˜åŒ–**ï¼š

- ç»Ÿä¸€çš„ç®—æ³•æ¡†æ¶ç®€åŒ–äº†æ€§èƒ½è°ƒä¼˜
- è·¨å±‚ç»éªŒå¯ä»¥ç›¸äº’å€Ÿé‰´
- ç»Ÿä¸€çš„ç›‘æ§æŒ‡æ ‡ä¾¿äºå¯¹æ¯”åˆ†æ

**å®é™…åº”ç”¨æ¡ˆä¾‹**ï¼š

| ç®—æ³• | OSå±‚å®ç° | VMå±‚å®ç° | å®¹å™¨å±‚å®ç° | ç»Ÿä¸€æ€§ |
|------|---------|---------|-----------|--------|
| åŠ æƒè½®è½¬ | CFS vruntime | EEVDF | cgroupé…é¢ | ä¿¡ç”¨ç´¯ç§¯æœºåˆ¶ç›¸åŒ |
| è´Ÿè½½å‡è¡¡ | sched_balance_work | vSphere DRS | kubelet TopologyManager | æ¢¯åº¦ä¸‹é™ç­–ç•¥ç›¸åŒ |
| å…¬å¹³è°ƒåº¦ | çº¢é»‘æ ‘æ’åº | CPUä»½é¢åˆ†é… | Podä¼˜å…ˆçº§ | æƒé‡æ¯”ä¾‹ç›¸åŒ |

**ç®—æ³•ç§»æ¤ç¤ºä¾‹**ï¼š

### Golangå®ç°

```go
package algorithms

import (
    "math"
    "time"
)

// CFSç®—æ³•å®ç°
type CFS struct {
    entities []Entity
    vruntime map[string]float64
}

type Entity struct {
    ID     string
    Weight float64
    ExecStart time.Time
}

const NICE0_WEIGHT = 1024.0

// è®¡ç®—vruntimeå¢é‡ï¼ˆä¸Linuxå†…æ ¸calc_delta_fairä¸€è‡´ï¼‰
func calcDeltaFair(deltaExec time.Duration, weight float64) float64 {
    // Î”vruntime = Î”exec_time Ã— (weight_nice0 / weight_curr)
    return float64(deltaExec.Nanoseconds()) * (NICE0_WEIGHT / weight)
}

// æ›´æ–°vruntimeï¼ˆOSå±‚CFSç®—æ³•ï¼‰
func (cfs *CFS) UpdateVruntime(entityID string, now time.Time) {
    entity := cfs.findEntity(entityID)
    if entity == nil {
        return
    }

    deltaExec := now.Sub(entity.ExecStart)
    deltaVruntime := calcDeltaFair(deltaExec, entity.Weight)

    cfs.vruntime[entityID] += deltaVruntime
    entity.ExecStart = now
}

// å®¹å™¨å±‚ç§»æ¤
type Container struct {
    ID        string
    Weight    float64
    ExecStart time.Time
    Vruntime  float64
}

func UpdateContainerVruntime(container *Container, now time.Time) {
    deltaExec := now.Sub(container.ExecStart)
    deltaVruntime := calcDeltaFair(deltaExec, container.Weight)
    container.Vruntime += deltaVruntime
    container.ExecStart = now
    // ä¸OSå±‚ç®—æ³•ç»“æ„å®Œå…¨ç›¸åŒ
}

// è´Ÿè½½å‡è¡¡ç®—æ³•
type LoadBalancer struct {
    nodes []Node
}

type Node struct {
    ID    string
    Load  float64
}

// è®¡ç®—è´Ÿè½½ä¸å¹³è¡¡åº¦
func (lb *LoadBalancer) ComputeImbalance() float64 {
    if len(lb.nodes) == 0 {
        return 0.0
    }

    // è®¡ç®—å¹³å‡è´Ÿè½½
    totalLoad := 0.0
    for _, node := range lb.nodes {
        totalLoad += node.Load
    }
    avgLoad := totalLoad / float64(len(lb.nodes))

    // è®¡ç®—æ ‡å‡†å·®
    variance := 0.0
    for _, node := range lb.nodes {
        diff := node.Load - avgLoad
        variance += diff * diff
    }
    stdDev := math.Sqrt(variance / float64(len(lb.nodes)))

    return stdDev
}

// è´Ÿè½½è¿ç§»å†³ç­–ï¼ˆæ¢¯åº¦ä¸‹é™ï¼‰
func (lb *LoadBalancer) DecideMigration() (string, string, bool) {
    // æ‰¾åˆ°è´Ÿè½½æœ€é«˜å’Œæœ€ä½çš„èŠ‚ç‚¹
    maxLoad := -1.0
    minLoad := math.Inf(1)
    var maxNode, minNode string

    for _, node := range lb.nodes {
        if node.Load > maxLoad {
            maxLoad = node.Load
            maxNode = node.ID
        }
        if node.Load < minLoad {
            minLoad = node.Load
            minNode = node.ID
        }
    }

    // æ£€æŸ¥æ˜¯å¦éœ€è¦è¿ç§»ï¼ˆæ¢¯åº¦ä¸‹é™æ¡ä»¶ï¼‰
    if maxLoad-minLoad > 0.1 { // é˜ˆå€¼
        return maxNode, minNode, true
    }

    return "", "", false
}
```

#### Pythonå®ç°

```python
from typing import List, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import math

NICE0_WEIGHT = 1024.0

@dataclass
class Entity:
    id: str
    weight: float
    exec_start: datetime

class CFS:
    """CFSç®—æ³•å®ç°"""
    def __init__(self):
        self.entities: List[Entity] = []
        self.vruntime: dict = {}

    def calc_delta_fair(self, delta_exec: timedelta, weight: float) -> float:
        """è®¡ç®—vruntimeå¢é‡ï¼ˆä¸Linuxå†…æ ¸calc_delta_fairä¸€è‡´ï¼‰"""
        # Î”vruntime = Î”exec_time Ã— (weight_nice0 / weight_curr)
        delta_ns = delta_exec.total_seconds() * 1e9
        return delta_ns * (NICE0_WEIGHT / weight)

    def update_vruntime(self, entity_id: str, now: datetime):
        """æ›´æ–°vruntimeï¼ˆOSå±‚CFSç®—æ³•ï¼‰"""
        entity = self.find_entity(entity_id)
        if entity is None:
            return

        delta_exec = now - entity.exec_start
        delta_vruntime = self.calc_delta_fair(delta_exec, entity.weight)

        self.vruntime[entity_id] = self.vruntime.get(entity_id, 0.0) + delta_vruntime
        entity.exec_start = now

    def find_entity(self, entity_id: str) -> Optional[Entity]:
        for entity in self.entities:
            if entity.id == entity_id:
                return entity
        return None

@dataclass
class Container:
    """å®¹å™¨å±‚å®ä½“"""
    id: str
    weight: float
    exec_start: datetime
    vruntime: float = 0.0

def update_container_vruntime(container: Container, now: datetime):
    """å®¹å™¨å±‚ç§»æ¤"""
    delta_exec = now - container.exec_start
    delta_vruntime = calc_delta_fair(delta_exec, container.weight)
    container.vruntime += delta_vruntime
    container.exec_start = now
    # ä¸OSå±‚ç®—æ³•ç»“æ„å®Œå…¨ç›¸åŒ

def calc_delta_fair(delta_exec: timedelta, weight: float) -> float:
    """è®¡ç®—vruntimeå¢é‡"""
    delta_ns = delta_exec.total_seconds() * 1e9
    return delta_ns * (NICE0_WEIGHT / weight)

@dataclass
class Node:
    id: str
    load: float

class LoadBalancer:
    """è´Ÿè½½å‡è¡¡ç®—æ³•"""
    def __init__(self, nodes: List[Node]):
        self.nodes = nodes

    def compute_imbalance(self) -> float:
        """è®¡ç®—è´Ÿè½½ä¸å¹³è¡¡åº¦"""
        if not self.nodes:
            return 0.0

        # è®¡ç®—å¹³å‡è´Ÿè½½
        avg_load = sum(node.load for node in self.nodes) / len(self.nodes)

        # è®¡ç®—æ ‡å‡†å·®
        variance = sum((node.load - avg_load) ** 2 for node in self.nodes) / len(self.nodes)
        std_dev = math.sqrt(variance)

        return std_dev

    def decide_migration(self) -> tuple:
        """è´Ÿè½½è¿ç§»å†³ç­–ï¼ˆæ¢¯åº¦ä¸‹é™ï¼‰"""
        if not self.nodes:
            return None, None, False

        # æ‰¾åˆ°è´Ÿè½½æœ€é«˜å’Œæœ€ä½çš„èŠ‚ç‚¹
        max_node = max(self.nodes, key=lambda n: n.load)
        min_node = min(self.nodes, key=lambda n: n.load)

        # æ£€æŸ¥æ˜¯å¦éœ€è¦è¿ç§»
        if max_node.load - min_node.load > 0.1:  # é˜ˆå€¼
            return max_node.id, min_node.id, True

        return None, None, False
```

#### Rustå®ç°

```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};

const NICE0_WEIGHT: f64 = 1024.0;

pub struct Entity {
    pub id: String,
    pub weight: f64,
    pub exec_start: Instant,
}

pub struct CFS {
    entities: Vec<Entity>,
    vruntime: HashMap<String, f64>,
}

impl CFS {
    pub fn new() -> Self {
        CFS {
            entities: Vec::new(),
            vruntime: HashMap::new(),
        }
    }

    fn calc_delta_fair(&self, delta_exec: Duration, weight: f64) -> f64 {
        // Î”vruntime = Î”exec_time Ã— (weight_nice0 / weight_curr)
        let delta_ns = delta_exec.as_nanos() as f64;
        delta_ns * (NICE0_WEIGHT / weight)
    }

    pub fn update_vruntime(&mut self, entity_id: &str, now: Instant) {
        if let Some(entity) = self.entities.iter_mut().find(|e| e.id == entity_id) {
            let delta_exec = now.duration_since(entity.exec_start);
            let delta_vruntime = self.calc_delta_fair(delta_exec, entity.weight);

            *self.vruntime.entry(entity_id.to_string()).or_insert(0.0) += delta_vruntime;
            entity.exec_start = now;
        }
    }
}

pub struct Container {
    pub id: String,
    pub weight: f64,
    pub exec_start: Instant,
    pub vruntime: f64,
}

pub fn update_container_vruntime(container: &mut Container, now: Instant) {
    let delta_exec = now.duration_since(container.exec_start);
    let delta_vruntime = calc_delta_fair(delta_exec, container.weight);
    container.vruntime += delta_vruntime;
    container.exec_start = now;
}

fn calc_delta_fair(delta_exec: Duration, weight: f64) -> f64 {
    let delta_ns = delta_exec.as_nanos() as f64;
    delta_ns * (NICE0_WEIGHT / weight)
}
```

**ç®—æ³•ç»Ÿä¸€æ€§çš„å®é™…ä»·å€¼**ï¼š

- **ä»£ç å¤ç”¨**ï¼šç›¸åŒçš„ç®—æ³•ç»“æ„å¯ä»¥åœ¨ä¸åŒå±‚é—´å¤ç”¨
- **æ€§èƒ½ä¸€è‡´æ€§**ï¼šç»Ÿä¸€çš„ç®—æ³•ä¿è¯äº†æ€§èƒ½çš„ä¸€è‡´æ€§
- **ç»´æŠ¤ç®€åŒ–**ï¼šç»Ÿä¸€çš„ç®—æ³•æ¡†æ¶ç®€åŒ–äº†ç³»ç»Ÿç»´æŠ¤

### 5.1 æ ¸å¿ƒç®—æ³•çš„ç»Ÿä¸€æ€§

**å®šç†68**ï¼ˆæ ¸å¿ƒç®—æ³•çš„ç»Ÿä¸€æ€§ï¼‰ï¼š
ä¸‰å±‚ç³»ç»Ÿçš„æ ¸å¿ƒè°ƒåº¦ç®—æ³•åœ¨æ•°å­¦ç»“æ„ä¸Šæ˜¯ç»Ÿä¸€çš„ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šç®—æ³•ç»“æ„å®šä¹‰

**å®šä¹‰**ï¼ˆç®—æ³•ç»“æ„ï¼‰ï¼š
ç®—æ³•ç»“æ„ $A = (S, T, O)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯çŠ¶æ€ç©ºé—´
- $T$ æ˜¯è½¬ç§»å‡½æ•°
- $O$ æ˜¯è¾“å‡ºå‡½æ•°

#### æ­¥éª¤2ï¼šç»Ÿä¸€æ€§è¯æ˜

**å¼•ç†68.1**ï¼ˆç»Ÿä¸€æ€§ï¼‰ï¼š
ä¸‰å±‚ç³»ç»Ÿçš„æ ¸å¿ƒç®—æ³•å…·æœ‰ç›¸åŒçš„æ•°å­¦ç»“æ„ã€‚

**è¯æ˜**ï¼š
ç”±è°ƒåº¦ç­‰ä»·æ€§ç†è®ºï¼Œä¸‰å±‚ç³»ç»Ÿçš„æ ¸å¿ƒç®—æ³•éƒ½å¯ä»¥è¡¨ç¤ºä¸ºç›¸åŒçš„æ•°å­¦ç»“æ„ï¼Œå› æ­¤æ˜¯ç»Ÿä¸€çš„ã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†68.1ï¼Œæ ¸å¿ƒç®—æ³•åœ¨æ•°å­¦ç»“æ„ä¸Šæ˜¯ç»Ÿä¸€çš„ã€‚ âˆ

### 5.2 ç®—æ³•ä¼˜åŒ–çš„å®é™…åº”ç”¨

#### 5.2.1 è·¨å±‚ç®—æ³•ä¼˜åŒ–

**åœºæ™¯**ï¼šåŸºäºç»Ÿä¸€çš„ç®—æ³•ç»“æ„è¿›è¡Œè·¨å±‚ä¼˜åŒ–ã€‚

**æ–¹æ³•**ï¼š

1. è¯†åˆ«ç®—æ³•çš„ç»Ÿä¸€ç»“æ„
2. åº”ç”¨ç»Ÿä¸€çš„ä¼˜åŒ–ç­–ç•¥
3. éªŒè¯ä¼˜åŒ–æ•ˆæœ

**Golangå®ç°**ï¼š

```go
package algorithm

// è·¨å±‚ç®—æ³•ä¼˜åŒ–
func OptimizeAlgorithm(algorithm Algorithm, layer Layer) (Algorithm, error) {
    // è¯†åˆ«ç®—æ³•ç»“æ„
    structure := identifyStructure(algorithm)

    // åº”ç”¨ä¼˜åŒ–ç­–ç•¥
    optimized := applyOptimization(structure, layer)

    // éªŒè¯ä¼˜åŒ–æ•ˆæœ
    if err := verifyOptimization(optimized); err != nil {
        return nil, err
    }

    return optimized, nil
}

// è¯†åˆ«ç®—æ³•ç»“æ„
func identifyStructure(algorithm Algorithm) Structure {
    return Structure{
        StateSpace:    algorithm.GetStateSpace(),
        Transition:    algorithm.GetTransition(),
        Output:        algorithm.GetOutput(),
    }
}
```

**Pythonå®ç°**ï¼š

```python
def optimize_algorithm(algorithm: Algorithm, layer: Layer) -> Algorithm:
    """è·¨å±‚ç®—æ³•ä¼˜åŒ–"""
    # è¯†åˆ«ç®—æ³•ç»“æ„
    structure = identify_structure(algorithm)

    # åº”ç”¨ä¼˜åŒ–ç­–ç•¥
    optimized = apply_optimization(structure, layer)

    # éªŒè¯ä¼˜åŒ–æ•ˆæœ
    verify_optimization(optimized)

    return optimized

def identify_structure(algorithm: Algorithm) -> Structure:
    """è¯†åˆ«ç®—æ³•ç»“æ„"""
    return Structure(
        state_space=algorithm.get_state_space(),
        transition=algorithm.get_transition(),
        output=algorithm.get_output(),
    )
```

**Rustå®ç°**ï¼š

```rust
pub fn optimize_algorithm(
    algorithm: &Algorithm,
    layer: Layer,
) -> Result<Algorithm, Error> {
    // è¯†åˆ«ç®—æ³•ç»“æ„
    let structure = identify_structure(algorithm)?;

    // åº”ç”¨ä¼˜åŒ–ç­–ç•¥
    let optimized = apply_optimization(&structure, layer)?;

    // éªŒè¯ä¼˜åŒ–æ•ˆæœ
    verify_optimization(&optimized)?;

    Ok(optimized)
}

fn identify_structure(algorithm: &Algorithm) -> Result<Structure, Error> {
    Ok(Structure {
        state_space: algorithm.get_state_space()?,
        transition: algorithm.get_transition()?,
        output: algorithm.get_output()?,
    })
}
```

### 5.1 ç®—æ³•ç»“æ„çš„åŒæ„æ€§

**å®šç†102**ï¼ˆç®—æ³•ç»“æ„çš„åŒæ„æ€§ï¼‰ï¼š
æ ¸å¿ƒè°ƒåº¦ç®—æ³•çš„æ•°å­¦ç»“æ„æ˜¯åŒæ„çš„ã€‚

**è¯æ˜**ï¼š

#### æ­¥éª¤1ï¼šåŒæ„æ€§å®šä¹‰

**å®šä¹‰**ï¼ˆåŒæ„æ€§ï¼‰ï¼š
ç®—æ³•ç»“æ„æ˜¯åŒæ„çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨åŒå°„æ˜ å°„ä¿æŒç®—æ³•çš„ç»“æ„ã€‚

#### æ­¥éª¤2ï¼šåŒæ„æ€§è¯æ˜

**å¼•ç†102.1**ï¼ˆåŒæ„æ€§è¯æ˜ï¼‰ï¼š
æ ¸å¿ƒè°ƒåº¦ç®—æ³•éƒ½ä½¿ç”¨ç›¸åŒçš„æ•°å­¦ç»“æ„ï¼ˆçŠ¶æ€ç©ºé—´ã€è½¬ç§»å‡½æ•°ã€è¾“å‡ºå‡½æ•°ï¼‰ã€‚

**è¯æ˜**ï¼š
ç”±ç»Ÿä¸€å½¢å¼åŒ–å®šç†ï¼Œæ‰€æœ‰æ ¸å¿ƒè°ƒåº¦ç®—æ³•éƒ½å¯ä»¥æ˜ å°„åˆ°ç»Ÿä¸€çš„æ•°å­¦ç»“æ„ï¼Œå› æ­¤æ˜¯åŒæ„çš„ã€‚ âˆ

#### æ­¥éª¤3ï¼šä¸»å®šç†è¯æ˜

**è¯æ˜**ï¼š
ç”±å¼•ç†102.1ï¼Œç®—æ³•ç»“æ„æ˜¯åŒæ„çš„ã€‚ âˆ

### 5.2 æ ¸å¿ƒç®—æ³•çš„å®é™…åº”ç”¨

#### 5.2.1 ç®—æ³•æ€§èƒ½å¯¹æ¯”

**åœºæ™¯**ï¼šä½¿ç”¨ç»Ÿä¸€çš„æ•°å­¦ç»“æ„å¯¹æ¯”ç®—æ³•æ€§èƒ½ã€‚

**æ–¹æ³•**ï¼š

1. å»ºç«‹ç®—æ³•çš„æ•°å­¦ç»“æ„
2. åˆ†æç»“æ„ç‰¹å¾
3. å¯¹æ¯”æ€§èƒ½æŒ‡æ ‡

**Golangå®ç°**ï¼š

```go
package algorithm

// ç®—æ³•æ€§èƒ½å¯¹æ¯”
func CompareAlgorithmPerformance(
    algorithms []Algorithm,
) (map[string]PerformanceMetrics, error) {
    // å»ºç«‹ç®—æ³•çš„æ•°å­¦ç»“æ„
    structures := make(map[string]Structure)
    for _, alg := range algorithms {
        structures[alg.Name] = buildStructure(alg)
    }

    // åˆ†æç»“æ„ç‰¹å¾
    features := make(map[string]Features)
    for name, structure := range structures {
        features[name] = analyzeFeatures(structure)
    }

    // å¯¹æ¯”æ€§èƒ½æŒ‡æ ‡
    metrics := make(map[string]PerformanceMetrics)
    for name, feat := range features {
        metrics[name] = computePerformanceMetrics(feat)
    }

    return metrics, nil
}

// åˆ†æç‰¹å¾
func analyzeFeatures(structure Structure) Features {
    return Features{
        StateSpaceSize: len(structure.StateSpace),
        TransitionComplexity: estimateComplexity(structure.Transition),
        OutputComplexity: estimateComplexity(structure.Output),
    }
}
```

**Pythonå®ç°**ï¼š

```python
def compare_algorithm_performance(
    algorithms: List[Algorithm],
) -> Dict[str, PerformanceMetrics]:
    """ç®—æ³•æ€§èƒ½å¯¹æ¯”"""
    # å»ºç«‹ç®—æ³•çš„æ•°å­¦ç»“æ„
    structures = {
        alg.name: build_structure(alg) for alg in algorithms
    }

    # åˆ†æç»“æ„ç‰¹å¾
    features = {
        name: analyze_features(structure)
        for name, structure in structures.items()
    }

    # å¯¹æ¯”æ€§èƒ½æŒ‡æ ‡
    metrics = {
        name: compute_performance_metrics(feat)
        for name, feat in features.items()
    }

    return metrics

def analyze_features(structure: Structure) -> Features:
    """åˆ†æç‰¹å¾"""
    return Features(
        state_space_size=len(structure.state_space),
        transition_complexity=estimate_complexity(structure.transition),
        output_complexity=estimate_complexity(structure.output),
    )
```

**Rustå®ç°**ï¼š

```rust
pub fn compare_algorithm_performance(
    algorithms: &[Algorithm],
) -> Result<HashMap<String, PerformanceMetrics>, Error> {
    // å»ºç«‹ç®—æ³•çš„æ•°å­¦ç»“æ„
    let mut structures = HashMap::new();
    for alg in algorithms {
        structures.insert(alg.name.clone(), build_structure(alg)?);
    }

    // åˆ†æç»“æ„ç‰¹å¾
    let mut features = HashMap::new();
    for (name, structure) in &structures {
        features.insert(name.clone(), analyze_features(structure)?);
    }

    // å¯¹æ¯”æ€§èƒ½æŒ‡æ ‡
    let mut metrics = HashMap::new();
    for (name, feat) in &features {
        metrics.insert(name.clone(), compute_performance_metrics(feat)?);
    }

    Ok(metrics)
}

fn analyze_features(structure: &Structure) -> Result<Features, Error> {
    Ok(Features {
        state_space_size: structure.state_space.len(),
        transition_complexity: estimate_complexity(&structure.transition)?,
        output_complexity: estimate_complexity(&structure.output)?,
    })
}
```

---

## 5. ç›¸å…³æ–‡æ¡£

- [è¿”å› FormalModel ç›®å½•](../README.md)
- [09_å·¥ç¨‹æ•°å­¦ç»Ÿä¸€ README](README.md)
- [09.1_å·¥ç¨‹å®ä½“ä¸æ•°å­¦å¯¹è±¡å¯¹åº”](09.1_å·¥ç¨‹å®ä½“ä¸æ•°å­¦å¯¹è±¡å¯¹åº”.md)
- [05.3_è´Ÿè½½å‡è¡¡ç®—æ³•æ¡†æ¶](../05_æ•°æ®ç»“æ„ä¸ç®—æ³•/05.3_è´Ÿè½½å‡è¡¡ç®—æ³•æ¡†æ¶.md)

---

**æœ€åæ›´æ–°**: 2025-01-27
