# 系统软件层调度：调度在操作系统上的应用与体现

> **文档版本**: v1.0.0
> **最后更新**: 2025-01-XX
> **归纳来源**: 整合多个文档的OS层调度内容，去重合并，保持语义一致性

---

## 📋 目录

- [系统软件层调度：调度在操作系统上的应用与体现](#系统软件层调度调度在操作系统上的应用与体现)
  - [📋 目录](#-目录)
  - [一、进程调度](#一进程调度)
    - [1.1 CFS完全公平调度器](#11-cfs完全公平调度器)
    - [1.2 实时调度](#12-实时调度)
    - [1.3 负载均衡](#13-负载均衡)
  - [二、内存管理调度](#二内存管理调度)
    - [2.1 虚拟内存调度](#21-虚拟内存调度)
    - [2.2 页面置换算法](#22-页面置换算法)
    - [2.3 NUMA内存调度](#23-numa内存调度)
  - [三、文件系统调度](#三文件系统调度)
    - [3.1 块IO调度](#31-块io调度)
    - [3.2 日志机制调度](#32-日志机制调度)
  - [四、设备驱动调度](#四设备驱动调度)
    - [4.1 中断处理调度](#41-中断处理调度)
    - [4.2 DMA调度](#42-dma调度)
  - [五、网络栈调度](#五网络栈调度)
    - [5.1 网络包调度](#51-网络包调度)
    - [5.2 NAPI机制](#52-napi机制)
  - [📊 系统软件层调度性能指标](#-系统软件层调度性能指标)
  - [🔗 相关文档](#-相关文档)

---

## 一、进程调度

### 1.1 CFS完全公平调度器

**核心思想**：CFS通过虚拟运行时间（vruntime）实现完全公平调度，保证每个进程按权重比例获得CPU时间。

**虚拟运行时间**：

$$
vruntime_i = \sum_{k=1}^{n} \frac{actual\_runtime_i(k) \times weight\_nice0}{weight_i}
$$

其中：

- $actual\_runtime_i(k)$：进程$i$在第$k$个调度周期内的实际运行时间
- $weight\_nice0$：nice值为0的进程权重（基准权重）
- $weight_i$：进程$i$的权重

**调度决策函数**：

$$
\text{PickNext}() = \arg\min_{t \in ReadyQueue} vruntime(t)
$$

**定理3.1（CFS公平性）**：

CFS调度器保证进程公平性：

$$
\forall t_i, t_j, \quad \lim_{T\to\infty} \frac{runtime_i(T)}{weight_i} = \frac{runtime_j(T)}{weight_j}
$$

**证明**：

- 构造离散时间系统，每个调度周期更新vruntime
- 使用数学归纳法证明vruntime差值有界
- 由红黑树数据结构保证 $O(\log n)$ 查找复杂度

### 1.2 实时调度

**实时任务定义**：

任务$\tau_i = (C_i, D_i, T_i)$，其中：

- $C_i$：执行时间（Worst Case Execution Time, WCET）
- $D_i$：截止时间（Deadline）
- $T_i$：周期（Period）

**EDF可调度性条件**：

$$
\sum_{i=1}^{n} \frac{C_i}{T_i} \leq 1
$$

**响应时间分析（RTA）**：

$$
R_i^{(k+1)} = C_i + \sum_{j \in hp(i)} \left\lceil \frac{R_i^{(k)}}{T_j} \right\rceil C_j
$$

其中 $hp(i)$ 表示优先级高于 $\tau_i$ 的任务集合。

### 1.3 负载均衡

**调度域（Sched Domain）**：

Linux内核通过调度域实现层次化负载均衡：

- **Socket域**：跨Socket负载均衡
- **NUMA域**：跨NUMA节点负载均衡
- **Core域**：跨核心负载均衡
- **Thread域**：跨线程负载均衡

**负载均衡触发条件**：

$$
\text{LoadImbalance} = \frac{\max Load - \min Load}{\text{avg } Load} > \text{threshold}
$$

---

## 二、内存管理调度

### 2.1 虚拟内存调度

**页表层次**：

现代x86-64系统采用5级页表：

- **PML4**（Page Map Level 4）
- **PDPT**（Page Directory Pointer Table）
- **PD**（Page Directory）
- **PT**（Page Table）
- **PTE**（Page Table Entry）

**TLB管理**：

TLB（Translation Lookaside Buffer）缓存虚拟地址到物理地址的映射，减少页表遍历开销。

**TLB未命中处理**：

当TLB未命中时，CPU硬件自动遍历页表，或触发页错误异常由OS处理。

### 2.2 页面置换算法

**LRU近似算法**：

由于精确LRU实现成本高，Linux采用近似LRU算法：

- **Active/Inactive链表**：将页面分为活跃和非活跃两类
- **二次机会算法**：给页面第二次机会避免被立即换出
- **Refault Distance**：基于访问距离预测页面热度

**页面回收策略**：

$$
\text{Reclaim} = \begin{cases}
\text{kswapd} & \text{if } \text{内存压力 < 阈值} \\
\text{direct reclaim} & \text{if } \text{内存压力 > 阈值}
\end{cases}
$$

### 2.3 NUMA内存调度

**NUMA平衡（NUMA Balancing）**：

Linux内核通过NUMA平衡机制，自动将页面迁移到访问该页面的进程所在的NUMA节点。

**迁移策略**：

$$
\text{Migrate}(page, node) \iff \text{AccessCount}(page, node) > \text{threshold} \land \text{RemoteAccess}(page)
$$

---

## 三、文件系统调度

### 3.1 块IO调度

**多队列块IO调度（blk-mq）**：

现代Linux内核采用多队列块IO调度，每个CPU核心有独立的提交队列和完成队列。

**IO调度算法**：

- **Noop**：简单的FIFO队列
- **Deadline**：保证IO请求的截止时间
- **CFQ（Completely Fair Queuing）**：公平队列调度
- **BFQ（Budget Fair Queuing）**：预算公平队列调度

**IO优先级**：

$$
\text{IOWeight}(cgroup) = \frac{\text{weight}(cgroup)}{\sum \text{weight}(all cgroups)} \times \text{TotalIOPS}
$$

### 3.2 日志机制调度

**日志文件系统**：

通过日志机制保证文件系统一致性，日志写入顺序影响性能。

**日志调度策略**：

- **Ordered模式**：数据先于元数据写入
- **Journal模式**：数据和元数据都写入日志
- **Writeback模式**：仅元数据写入日志

---

## 四、设备驱动调度

### 4.1 中断处理调度

**中断处理流程**：

1. **硬件中断**：设备触发中断信号
2. **中断路由**：APIC将中断路由到目标CPU
3. **中断处理**：CPU执行中断处理程序（ISR）
4. **软中断**：ISR触发软中断，由ksoftirqd线程处理

**中断亲和性**：

通过`/proc/irq/<irq>/smp_affinity`设置中断亲和性，将中断绑定到特定CPU核心。

### 4.2 DMA调度

**DMA描述符环**：

设备通过DMA描述符环与CPU通信，CPU填充描述符，设备DMA引擎异步处理。

**IOMMU调度**：

IOMMU（Input-Output Memory Management Unit）提供设备DMA的地址转换和访问控制。

---

## 五、网络栈调度

### 5.1 网络包调度

**网络包处理流程**：

1. **硬件接收**：网卡接收数据包到接收队列
2. **中断触发**：网卡触发中断通知CPU
3. **NAPI处理**：CPU轮询处理数据包
4. **协议栈处理**：数据包经过TCP/IP协议栈
5. **应用交付**：数据包交付给应用程序

### 5.2 NAPI机制

**NAPI（New API）**：

NAPI通过轮询机制减少中断开销，提高网络包处理效率。

**NAPI调度**：

$$
\text{NAPI\_Poll}() = \begin{cases}
\text{Continue} & \text{if } \text{包数量 > 阈值} \\
\text{Disable} & \text{if } \text{包数量 < 阈值}
\end{cases}
$$

**RSS（Receive Side Scaling）**：

网卡硬件将数据包哈希分发到多个接收队列，每个队列绑定到不同CPU核心，实现并行处理。

---

## 📊 系统软件层调度性能指标

| 调度对象 | 调度粒度 | 延迟范围 | 主要约束 | 典型实现 |
|---------|---------|---------|---------|---------|
| **进程** | 进程/线程 | 1ms-20ms | 公平性、优先级 | CFS调度器 |
| **内存页** | 4KB页 | 100ns-1ms | 容量限制 | LRU近似 |
| **块IO** | 扇区/块 | 100μs-10ms | 寻道时间 | Deadline调度 |
| **网络包** | 数据包 | 10μs-1ms | 带宽限制 | NAPI机制 |
| **中断** | 中断向量 | 1μs-10μs | 实时性 | 中断亲和性 |

---

## 🔗 相关文档

- [硬件层调度](./01_硬件层调度.md)
- [编程模型层调度](./03_编程模型层调度.md)
- [跨层次调度协同](./11_跨层次调度协同.md)

---

**最后更新**: 2025-01-XX
**文档状态**: ✅ 归纳整理完成
