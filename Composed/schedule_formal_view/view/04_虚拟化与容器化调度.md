# 虚拟化与容器化调度：调度在虚拟化环境上的应用与体现

> **文档版本**: v1.0.0
> **最后更新**: 2025-01-XX

---

## 📋 目录

- [虚拟化与容器化调度：调度在虚拟化环境上的应用与体现](#虚拟化与容器化调度调度在虚拟化环境上的应用与体现)
  - [📋 目录](#-目录)
  - [一、虚拟化调度](#一虚拟化调度)
    - [1.1 Hypervisor调度](#11-hypervisor调度)
    - [1.2 IO虚拟化调度](#12-io虚拟化调度)
    - [1.3 内存虚拟化调度](#13-内存虚拟化调度)
  - [二、容器化调度](#二容器化调度)
    - [2.1 Cgroup资源调度](#21-cgroup资源调度)
    - [2.2 Namespace隔离](#22-namespace隔离)
    - [2.3 Kubernetes调度](#23-kubernetes调度)
    - [2.4 容器网络调度](#24-容器网络调度)
  - [三、沙盒化调度](#三沙盒化调度)
    - [3.1 gVisor调度](#31-gvisor调度)
    - [3.2 WASM调度](#32-wasm调度)
    - [3.3 Firecracker微VM调度](#33-firecracker微vm调度)
  - [四、隔离技术对比](#四隔离技术对比)
  - [五、性能优化与最佳实践](#五性能优化与最佳实践)
    - [5.1 虚拟化优化](#51-虚拟化优化)
    - [5.2 容器化优化](#52-容器化优化)
    - [5.3 沙盒化优化](#53-沙盒化优化)
  - [📊 虚拟化与容器化调度性能指标](#-虚拟化与容器化调度性能指标)
  - [🔗 相关文档](#-相关文档)

---

## 一、虚拟化调度

### 1.1 Hypervisor调度

**虚拟化架构**：

- **Type-1（裸机虚拟化）**：Hypervisor直接运行在硬件上（KVM、Xen、VMware ESXi）
- **Type-2（托管虚拟化）**：Hypervisor运行在OS上（VirtualBox、VMware Workstation）

**vCPU调度**：

Hypervisor将物理CPU时间片分配给虚拟机的vCPU，调度策略包括：

- **Credit调度**：按权重分配CPU时间
- **CFS调度**：Linux KVM采用CFS调度vCPU

**VM-Exit/Entry开销**：

虚拟机执行特权指令时触发VM-Exit，由Hypervisor处理，然后VM-Entry返回，开销约1000-2000 CPU周期。

### 1.2 IO虚拟化调度

**IOMMU虚拟化**：

通过IOMMU实现设备DMA的地址转换和访问控制，支持SR-IOV（Single Root I/O Virtualization）。

**SR-IOV调度**：

将物理设备虚拟化为多个VF（Virtual Function），每个VF可分配给不同虚拟机，实现硬件级IO隔离。

**性能提升**：

- SR-IOV相比软件虚拟化，IO延迟降低60-80%
- 吞吐量提升2-3倍

### 1.3 内存虚拟化调度

**EPT（Extended Page Tables）**：

Intel VT-x通过EPT实现二级地址转换，减少VM-Exit频率。

**内存调度策略**：

$$
\text{MemoryAllocation}(VM_i) = \frac{\text{weight}(VM_i)}{\sum_j \text{weight}(VM_j)} \times \text{TotalMemory}
$$

**内存气球（Ballooning）**：

通过动态调整虚拟机内存分配，实现内存超分配（Overcommit）。

---

## 二、容器化调度

### 2.1 Cgroup资源调度

**Cgroup层次结构**：

Linux Cgroup通过层次化结构管理资源，支持CPU、内存、IO等资源的限制和调度。

**CPU调度**：

$$
\text{cpu.cfs\_quota\_us} = \frac{\text{CPU核数} \times 100000}{\text{容器权重}}
$$

### 2.2 Namespace隔离

**Namespace类型**：

- **PID Namespace**：进程ID隔离
- **NET Namespace**：网络栈隔离
- **IPC Namespace**：进程间通信隔离
- **MNT Namespace**：文件系统挂载点隔离
- **UTS Namespace**：主机名隔离

### 2.3 Kubernetes调度

**调度决策**：

$$
\text{Schedule}(p, n) \iff \text{Predicates}(p, n) \land \text{Priorities}(p, n) = \max_{n' \in N} \text{Priorities}(p, n')
$$

**调度策略**：

- **LeastRequestedPriority**：优先选择资源使用率低的节点
- **BalancedResourceAllocation**：平衡CPU和内存使用率
- **NodeAffinity**：节点亲和性调度
- **PodAffinity/AntiAffinity**：Pod亲和性和反亲和性调度
- **Taint/Toleration**：节点污点和Pod容忍度

**调度器扩展**：

- **Volcano**：批量计算调度器，支持Gang调度
- **Kube-batch**：批处理任务调度器
- **Descheduler**：Pod重调度器，优化集群资源利用率

### 2.4 容器网络调度

**CNI（Container Network Interface）**：

容器网络通过CNI插件实现，支持多种网络模型。

**网络调度策略**：

- **Flannel**：Overlay网络，使用VXLAN封装
- **Calico**：BGP路由，无Overlay开销
- **Cilium**：eBPF加速，高性能网络策略

**网络性能对比**：

| 网络方案 | 延迟开销 | 吞吐量 | 适用场景 |
|---------|---------|--------|---------|
| **Flannel** | +5-10μs | 中等 | 中小规模集群 |
| **Calico** | +2-5μs | 高 | 大规模集群 |
| **Cilium** | +1-3μs | 最高 | 高性能场景 |

---

## 三、沙盒化调度

### 3.1 gVisor调度

**gVisor架构**：

- **Sentry**：用户态内核，实现Linux ABI
- **Gofer**：文件系统代理

**安全定理**：

$$
\text{EscapeProbability}_{gvisor} \approx P(\text{bug in sentry}) \ll P(\text{bug in host kernel})
$$

### 3.2 WASM调度

**WASM运行时**：

WebAssembly提供沙盒化执行环境，通过线性内存模型实现安全隔离。

**调度特性**：

- 启动时间：<10ms
- 内存隔离：线性内存模型
- 性能开销：5-10%

**WASM调度模型**：

$$
\text{WASMInstance} = (\text{LinearMemory}, \text{Stack}, \text{Table}, \text{Globals})
$$

### 3.3 Firecracker微VM调度

**Firecracker架构**：

Firecracker是AWS开发的轻量级虚拟化技术，专为Serverless场景优化。

**性能指标**：

- 启动时间：<125ms
- 内存开销：<5MB/VM
- 性能开销：<2%

**调度优化**：

$$
T_{startup} = T_{kernel\_boot} + T_{init} + T_{app\_start} \approx 100ms
$$

---

## 四、隔离技术对比

| 技术 | 隔离级别 | 性能开销 | 启动时间 | 内存开销 | 适用场景 |
|------|---------|---------|---------|---------|---------|
| **虚拟化** | 硬件级 | 10-15% | 30-120s | 100MB-1GB | 传统应用、强合规 |
| **容器化** | OS级 | 1-3% | 1-5s | 10-50MB | 微服务、云原生 |
| **gVisor** | 用户态内核 | 5-10% | 100-500ms | 50-100MB | 多租户隔离 |
| **WASM** | 应用级 | 5-10% | 10-100ms | 1-10MB | Serverless、边缘计算 |
| **Firecracker** | 微VM | 2-5% | 100-200ms | 5-20MB | Serverless、函数计算 |

**选择建议**：

- **强隔离需求**：选择虚拟化或gVisor
- **高性能需求**：选择容器化或Firecracker
- **快速启动需求**：选择WASM或Firecracker
- **资源受限**：选择WASM

---

## 五、性能优化与最佳实践

### 5.1 虚拟化优化

**CPU亲和性**：

将vCPU绑定到物理CPU核心，减少跨核心迁移开销。

**IO优化**：

- 使用SR-IOV减少IO虚拟化开销
- 使用DPDK加速网络IO
- 使用SPDK加速存储IO

### 5.2 容器化优化

**资源限制**：

合理设置CPU和内存限制，避免资源争抢。

**镜像优化**：

- 使用多阶段构建减小镜像体积
- 使用Alpine等轻量级基础镜像
- 合理使用缓存层

### 5.3 沙盒化优化

**预热策略**：

通过预热减少冷启动延迟。

**资源池化**：

复用沙盒实例，减少创建开销。

---

## 📊 虚拟化与容器化调度性能指标

| 调度对象 | 调度粒度 | 延迟范围 | 主要约束 | 典型实现 |
|---------|---------|---------|---------|---------|
| **vCPU** | vCPU线程 | 1-10ms | CPU亲和性 | CFS调度器 |
| **容器** | Pod/容器 | 100ms-1s | 资源配额 | Kubernetes调度器 |
| **沙盒** | 沙盒实例 | 10-100ms | 资源限制 | gVisor/WASM |

---

## 🔗 相关文档

- [系统软件层调度](./02_系统软件层调度.md)
- [分布式与云原生调度](./05_分布式与云原生调度.md)
- [跨层次调度协同](./11_跨层次调度协同.md)

---

**最后更新**: 2025-01-XX
**文档状态**: ✅ 归纳整理完成
