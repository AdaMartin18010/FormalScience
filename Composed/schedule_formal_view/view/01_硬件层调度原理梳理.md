# 硬件层调度原理梳理

> **文档版本**: v1.0.0
> **创建时间**: 2025-11-14
> **最后更新**: 2025-11-14
> **文档状态**: ✅ 硬件层调度原理梳理完成

---

## 📋 目录

- [硬件层调度原理梳理](#硬件层调度原理梳理)
  - [📋 目录](#-目录)
  - [一、指令级并行调度](#一指令级并行调度)
    - [1.1 动态调度算法形式化描述](#11-动态调度算法形式化描述)
    - [1.2 分支预测性能分析](#12-分支预测性能分析)
    - [1.3 流水线CPI定量分析](#13-流水线cpi定量分析)
  - [二、缓存层次调度](#二缓存层次调度)
    - [2.1 缓存替换策略](#21-缓存替换策略)
    - [2.2 缓存一致性协议](#22-缓存一致性协议)
  - [三、内存子系统调度](#三内存子系统调度)
    - [3.1 DRAM时序调度](#31-dram时序调度)
    - [3.2 NUMA架构调度](#32-numa架构调度)
  - [四、相关主题链接](#四相关主题链接)
    - [四.1 跨视角链接](#四1-跨视角链接)

---

## 一、指令级并行调度

### 1.1 动态调度算法形式化描述

**Tomasulo算法核心机制**：

设指令状态为四元组 $I = (op, dst, src1, src2)$，保留站 $RS$ 和重排序缓冲区 $ROB$ 构成调度核心。

**寄存器重命名函数**：

$$
Rename: \text{逻辑寄存器} \to \text{保留站ID} \cup \text{ROB条目}
$$

$$
\text{若 } src_i \text{ 在 } ROB \text{ 中未提交, 则 } src_i \leftarrow ROB[id].value
$$

**发射条件形式化**：

$$
\text{Issue}(I) \iff \forall src_i \in I, \text{ Ready}(src_i) \land \exists r \in RS_{\text{free}}
$$

**执行完成谓词**：

$$
\text{Complete}(I) \iff \text{CDB广播结果} \land \forall I_j \in \text{等待该结果的指令}, \text{Ready}(I_j)
$$

**形式化证明：Tomasulo算法保持程序序语义**

_证明思路_：

1. **引理1（数据流保持）**：通过寄存器重命名消除WAR/WAW冲突，保留RAW真依赖。
   - 对于任意两条指令 $I_i, I_j$ 且 $i < j$，若 $I_i$ 写寄存器 $R$ 且 $I_j$ 读 $R$，则 $I_j$ 的源操作数始终读取 $I_i$ 写入的值（通过CDB旁路）。
2. **引理2（提交原子性）**：ROB按程序序提交，确保精确中断。
   - 提交函数 $\text{Commit}(ROB_{head})$ 仅在指令位于ROB头部时执行，保证状态更新顺序与程序序一致。
3. **定理（正确性）**：乱序执行结果与顺序执行相同。
   - 由引理1和引理2，通过结构归纳法可得，所有可见状态变化与顺序执行模型等价。

**性能模型**：

$$
CPI_{tomasulo} = CPI_{ideal} + \frac{N_{structural}}{N_{total}} \times \frac{1}{throughput_{RS}} + (1-p_{predict}) \times m_{branch}
$$

其中 $p_{predict}$ 为分支预测准确率，$m_{branch}$ 为分支惩罚周期。

### 1.2 分支预测性能分析

**分支预测准确率模型**：

$$
p_{predict} = f(\text{BTB大小}, \text{BHT历史位}, \text{分支模式})
$$

**误预测惩罚**：

$$
\text{Penalty} = (1-p_{predict}) \times m_{branch} \times \text{分支频率}
$$

现代CPU通过BTB+BHT实现 $p > 95\%$，$m \approx 17$ 周期。

### 1.3 流水线CPI定量分析

**核心公式**：

$$
CPI_{pipeline} = CPI_{ideal} + \underbrace{Stalls_{structural}}_{\text{结构冒险}} + \underbrace{Stalls_{data}}_{\text{数据冒险}} + \underbrace{Stalls_{control}}_{\text{控制冒险}}
$$

**分支预测性能**：

设分支预测准确率 $p$，分支惩罚 $m$ 周期，则：

$$
CPI_{branch} = (1-p) \times m \times \text{分支频率}
$$

现代CPU通过BTB+BHT实现 $p > 95\%$，$m \approx 17$ 周期。

**动态调度优化**：

记分牌算法将数据冒险导致的停顿从 **阻塞发射** 转为 **乱序执行**，有效CPI降低为：

$$
CPI_{scoreboard} = \frac{N_{stalls}^{static} - N_{resolved}^{dynamic}}{N_{instructions}}
$$

Tomasulo算法通过寄存器重命名消除WAR/WAW，理论加速比：

$$
Speedup_{tomasulo} \approx \frac{1}{1 - \frac{N_{false-deps}}{N_{total-deps}}}
$$

---

## 二、缓存层次调度

### 2.1 缓存替换策略

**LRU替换策略**：

最近最少使用（Least Recently Used）策略，基于时间局部性原理。

**LFU替换策略**：

最少使用频率（Least Frequently Used）策略，基于访问频率统计。

**ARC替换策略**：

自适应替换缓存（Adaptive Replacement Cache），结合LRU和LFU的优势。

### 2.2 缓存一致性协议

**MESI协议**：

- **M（Modified）**：已修改，仅当前核心有最新副本
- **E（Exclusive）**：独占，仅当前核心有副本，未修改
- **S（Shared）**：共享，多个核心有副本，未修改
- **I（Invalid）**：无效，缓存行无效

**MESIF协议**：

在MESI基础上增加F（Forward）状态，用于优化多核系统中的数据转发。

---

## 三、内存子系统调度

### 3.1 DRAM时序调度

**DRAM时序参数**：

- **CL（CAS Latency）**：列地址选通延迟
- **tRCD（RAS to CAS Delay）**：行到列延迟
- **tRP（RAS Precharge）**：行预充电时间
- **刷新周期**：64ms

**行缓冲局部性**：

利用DRAM的行缓冲（Row Buffer）局部性，减少行激活次数。

### 3.2 NUMA架构调度

**NUMA拓扑**：

非统一内存访问（Non-Uniform Memory Access）架构，不同CPU核心访问不同内存节点的延迟不同。

**本地/远程内存延迟**：

- **本地内存延迟**：~80ns
- **远程内存延迟**：~150ns

**NUMA感知调度**：

操作系统和应用程序需要感知NUMA拓扑，将任务调度到合适的内存节点，减少跨节点访问。

---

## 四、相关主题链接

- [01_CPU硬件层](../01_CPU硬件层/README.md) - CPU微架构、缓存层次、内存子系统详细文档
- [16_GPU与加速器调度](../16_GPU与加速器调度/README.md) - GPU调度、AI加速器调度
- [00_调度原理核心理论梳理](./00_调度原理核心理论梳理.md) - 调度原理核心理论

### 四.1 跨视角链接

- [概念交叉索引（七视角版）](../../../Concept/CONCEPT_CROSS_INDEX.md) - 查看相关概念的七视角分析：
  - [P vs NP问题](../../../Concept/CONCEPT_CROSS_INDEX.md#104-p-vs-np问题-p-vs-np-problem-七视角) - 硬件调度的计算复杂性
  - [并行复杂度类](../../../Concept/CONCEPT_CROSS_INDEX.md#105-并行复杂度类-nc-p-完全性-七视角) - 硬件调度的并行复杂性
  - [Landauer极限](../../../Concept/CONCEPT_CROSS_INDEX.md#106-landauer极限-landauer-limit-七视角) - 硬件调度的物理极限

---

**最后更新**: 2025-11-14
**文档状态**: ✅ 硬件层调度原理梳理完成
