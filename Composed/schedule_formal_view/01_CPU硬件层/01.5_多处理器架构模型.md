# 1.5 å¤šå¤„ç†å™¨æ¶æ„æ¨¡å‹

> **ä¸»é¢˜**: 01. CPUç¡¬ä»¶å±‚ - 1.5 å¤šå¤„ç†å™¨æ¶æ„æ¨¡å‹
> **è¦†ç›–**: SMPã€UMAã€NUMAæ¶æ„ã€å¤šæ ¸è°ƒåº¦æ¨¡å‹ã€ç¼“å­˜ä¸€è‡´æ€§

---

## ğŸ“‹ ç›®å½•

- [1.5 å¤šå¤„ç†å™¨æ¶æ„æ¨¡å‹](#15-å¤šå¤„ç†å™¨æ¶æ„æ¨¡å‹)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 å¤šå¤„ç†å™¨æ¶æ„æ¦‚è¿°](#1-å¤šå¤„ç†å™¨æ¶æ„æ¦‚è¿°)
    - [1.1 æ¶æ„åˆ†ç±»](#11-æ¶æ„åˆ†ç±»)
    - [1.2 è°ƒåº¦æ¨¡å‹å¯¹æ¯”](#12-è°ƒåº¦æ¨¡å‹å¯¹æ¯”)
  - [2 UMAæ¶æ„ï¼ˆç»Ÿä¸€å†…å­˜è®¿é—®ï¼‰](#2-umaæ¶æ„ç»Ÿä¸€å†…å­˜è®¿é—®)
    - [2.1 æ¶æ„ç‰¹å¾](#21-æ¶æ„ç‰¹å¾)
    - [2.2 è°ƒåº¦æ¨¡å‹](#22-è°ƒåº¦æ¨¡å‹)
    - [2.3 æ€§èƒ½åˆ†æ](#23-æ€§èƒ½åˆ†æ)
  - [3 SMPæ¶æ„ï¼ˆå¯¹ç§°å¤šå¤„ç†ï¼‰](#3-smpæ¶æ„å¯¹ç§°å¤šå¤„ç†)
    - [3.1 æ¶æ„ç‰¹å¾](#31-æ¶æ„ç‰¹å¾)
    - [3.2 è°ƒåº¦æ¨¡å‹](#32-è°ƒåº¦æ¨¡å‹)
    - [3.3 ç¼“å­˜ä¸€è‡´æ€§](#33-ç¼“å­˜ä¸€è‡´æ€§)
  - [4 NUMAæ¶æ„ï¼ˆéç»Ÿä¸€å†…å­˜è®¿é—®ï¼‰](#4-numaæ¶æ„éç»Ÿä¸€å†…å­˜è®¿é—®)
    - [4.1 æ¶æ„ç‰¹å¾](#41-æ¶æ„ç‰¹å¾)
    - [4.2 è°ƒåº¦æ¨¡å‹](#42-è°ƒåº¦æ¨¡å‹)
    - [4.3 å†…å­˜è®¿é—®æ¨¡å‹](#43-å†…å­˜è®¿é—®æ¨¡å‹)
  - [5 å¤šæ ¸è°ƒåº¦æ¨¡å‹](#5-å¤šæ ¸è°ƒåº¦æ¨¡å‹)
    - [5.1 è´Ÿè½½å‡è¡¡](#51-è´Ÿè½½å‡è¡¡)
    - [5.2 äº²å’Œæ€§è°ƒåº¦](#52-äº²å’Œæ€§è°ƒåº¦)
    - [5.3 è°ƒåº¦åŸŸå±‚æ¬¡](#53-è°ƒåº¦åŸŸå±‚æ¬¡)
  - [6 å®è·µæ¡ˆä¾‹](#6-å®è·µæ¡ˆä¾‹)
    - [6.1 SMPç³»ç»Ÿä¼˜åŒ–](#61-smpç³»ç»Ÿä¼˜åŒ–)
    - [6.2 NUMAç³»ç»Ÿä¼˜åŒ–](#62-numaç³»ç»Ÿä¼˜åŒ–)
  - [7 æ€ç»´å¯¼å›¾ï¼šå¤šå¤„ç†å™¨æ¶æ„å†³ç­–](#7-æ€ç»´å¯¼å›¾å¤šå¤„ç†å™¨æ¶æ„å†³ç­–)
  - [8 æ‰¹åˆ¤æ€§æ€»ç»“](#8-æ‰¹åˆ¤æ€§æ€»ç»“)
    - [8.1 æ¶æ„é€‰æ‹©çš„æ ¹æœ¬çŸ›ç›¾](#81-æ¶æ„é€‰æ‹©çš„æ ¹æœ¬çŸ›ç›¾)
    - [8.2 2025å¹´å¤šå¤„ç†å™¨æ¶æ„è¶‹åŠ¿](#82-2025å¹´å¤šå¤„ç†å™¨æ¶æ„è¶‹åŠ¿)
  - [9 è·¨é¢†åŸŸæ´å¯Ÿ](#9-è·¨é¢†åŸŸæ´å¯Ÿ)
    - [9.1 æ‰©å±•æ€§vsä¸€è‡´æ€§çš„æƒè¡¡](#91-æ‰©å±•æ€§vsä¸€è‡´æ€§çš„æƒè¡¡)
    - [9.2 è°ƒåº¦å¤æ‚åº¦çš„å±‚çº§æ€§](#92-è°ƒåº¦å¤æ‚åº¦çš„å±‚çº§æ€§)
  - [10 å¤šç»´åº¦å¯¹æ¯”](#10-å¤šç»´åº¦å¯¹æ¯”)
    - [10.1 æ¶æ„æ¨¡å‹å¯¹æ¯”](#101-æ¶æ„æ¨¡å‹å¯¹æ¯”)
    - [10.2 è°ƒåº¦ç­–ç•¥å¯¹æ¯”](#102-è°ƒåº¦ç­–ç•¥å¯¹æ¯”)
  - [11 ç›¸å…³ä¸»é¢˜](#11-ç›¸å…³ä¸»é¢˜)

---

## 1 å¤šå¤„ç†å™¨æ¶æ„æ¦‚è¿°

### 1.1 æ¶æ„åˆ†ç±»

**æ¡ˆä¾‹1.5.1ï¼ˆå¤šå¤„ç†å™¨æ¶æ„åˆ†ç±»ï¼‰**ï¼š

å¤šå¤„ç†å™¨ç³»ç»Ÿæ ¹æ®å†…å­˜è®¿é—®æ¨¡å¼åˆ†ä¸ºUMAã€SMPå’ŒNUMAä¸‰ç§ä¸»è¦æ¶æ„ã€‚

**æ¶æ„åˆ†ç±»**ï¼š

**1. UMAï¼ˆUniform Memory Accessï¼‰ç»Ÿä¸€å†…å­˜è®¿é—®**ï¼š

- **ç‰¹å¾**ï¼šæ‰€æœ‰CPUè®¿é—®å†…å­˜çš„å»¶è¿Ÿç›¸åŒ
- **æ‹“æ‰‘**ï¼šå…±äº«æ€»çº¿æˆ–äº¤å‰å¼€å…³
- **é€‚ç”¨**ï¼šå°è§„æ¨¡ç³»ç»Ÿï¼ˆ2-4æ ¸ï¼‰
- **ä¼˜åŠ¿**ï¼šç®€å•ã€ä¸€è‡´æ€§å¥½
- **åŠ£åŠ¿**ï¼šæ‰©å±•æ€§å·®ã€æ€»çº¿ç“¶é¢ˆ

**2. SMPï¼ˆSymmetric Multi-Processingï¼‰å¯¹ç§°å¤šå¤„ç†**ï¼š

- **ç‰¹å¾**ï¼šæ‰€æœ‰CPUåœ°ä½å¹³ç­‰ï¼Œå…±äº«å†…å­˜å’ŒIO
- **æ‹“æ‰‘**ï¼šå…±äº«å†…å­˜æ€»çº¿
- **é€‚ç”¨**ï¼šä¸­ç­‰è§„æ¨¡ç³»ç»Ÿï¼ˆ4-16æ ¸ï¼‰
- **ä¼˜åŠ¿**ï¼šè´Ÿè½½å‡è¡¡å¥½ã€ç¼–ç¨‹ç®€å•
- **åŠ£åŠ¿**ï¼šæ€»çº¿ç«äº‰ã€ç¼“å­˜ä¸€è‡´æ€§å¼€é”€

**3. NUMAï¼ˆNon-Uniform Memory Accessï¼‰éç»Ÿä¸€å†…å­˜è®¿é—®**ï¼š

- **ç‰¹å¾**ï¼šä¸åŒCPUè®¿é—®ä¸åŒå†…å­˜åŒºåŸŸçš„å»¶è¿Ÿä¸åŒ
- **æ‹“æ‰‘**ï¼šåˆ†å¸ƒå¼å†…å­˜ï¼Œé€šè¿‡äº’è¿ç½‘ç»œè¿æ¥
- **é€‚ç”¨**ï¼šå¤§è§„æ¨¡ç³»ç»Ÿï¼ˆ16+æ ¸ï¼‰
- **ä¼˜åŠ¿**ï¼šæ‰©å±•æ€§å¥½ã€å¸¦å®½é«˜
- **åŠ£åŠ¿**ï¼šç¼–ç¨‹å¤æ‚ã€éœ€è¦OSæ„ŸçŸ¥

**æ¶æ„æ¼”è¿›**ï¼š

```text
å•æ ¸ç³»ç»Ÿ
  â†“
UMAï¼ˆ2-4æ ¸ï¼‰
  â†“
SMPï¼ˆ4-16æ ¸ï¼‰
  â†“
NUMAï¼ˆ16+æ ¸ï¼‰
  â†“
ccNUMAï¼ˆç¼“å­˜ä¸€è‡´æ€§NUMAï¼‰
```

### 1.2 è°ƒåº¦æ¨¡å‹å¯¹æ¯”

**è°ƒåº¦æ¨¡å‹çš„å½¢å¼åŒ–å®šä¹‰**ï¼š

**å®šä¹‰1.5.1ï¼ˆå¤šå¤„ç†å™¨è°ƒåº¦æ¨¡å‹ï¼‰**ï¼š

å¤šå¤„ç†å™¨è°ƒåº¦æ¨¡å‹æ˜¯ä¸€ä¸ªå››å…ƒç»„$(P, M, A, S)$ï¼Œå…¶ä¸­ï¼š

- $P = \{p_1, p_2, ..., p_n\}$ï¼šå¤„ç†å™¨é›†åˆ
- $M = \{m_1, m_2, ..., m_k\}$ï¼šå†…å­˜æ¨¡å—é›†åˆ
- $A: P \times M \rightarrow \mathbb{R}^+$ï¼šè®¿é—®å»¶è¿Ÿå‡½æ•°
- $S: T \times P \rightarrow \{0, 1\}$ï¼šè°ƒåº¦å‡½æ•°ï¼ˆä»»åŠ¡åˆ°å¤„ç†å™¨çš„æ˜ å°„ï¼‰

**ä¸åŒæ¶æ„çš„è®¿é—®å»¶è¿Ÿå‡½æ•°**ï¼š

**UMAæ¶æ„**ï¼š

$$
A_{\text{UMA}}(p_i, m_j) = t_{\text{base}} \quad \forall i, j
$$

æ‰€æœ‰å¤„ç†å™¨è®¿é—®æ‰€æœ‰å†…å­˜çš„å»¶è¿Ÿç›¸åŒã€‚

**SMPæ¶æ„**ï¼š

$$
A_{\text{SMP}}(p_i, m_j) = t_{\text{base}} + t_{\text{bus}}(n)
$$

å…¶ä¸­$t_{\text{bus}}(n)$æ˜¯æ€»çº¿ç«äº‰å»¶è¿Ÿï¼Œéšå¤„ç†å™¨æ•°$n$å¢åŠ ã€‚

**NUMAæ¶æ„**ï¼š

$$
A_{\text{NUMA}}(p_i, m_j) = \begin{cases}
t_{\text{local}} & \text{if } \text{node}(p_i) = \text{node}(m_j) \\
t_{\text{remote}} & \text{otherwise}
\end{cases}
$$

æœ¬åœ°è®¿é—®å»¶è¿Ÿ$t_{\text{local}}$ï¼Œè¿œç¨‹è®¿é—®å»¶è¿Ÿ$t_{\text{remote}} > t_{\text{local}}$ã€‚

---

## 2 UMAæ¶æ„ï¼ˆç»Ÿä¸€å†…å­˜è®¿é—®ï¼‰

### 2.1 æ¶æ„ç‰¹å¾

**æ¡ˆä¾‹1.5.2ï¼ˆUMAæ¶æ„ï¼‰**ï¼š

UMAæ¶æ„æ˜¯æœ€ç®€å•çš„å¤šå¤„ç†å™¨æ¶æ„ï¼Œæ‰€æœ‰CPUé€šè¿‡å…±äº«æ€»çº¿è®¿é—®ç»Ÿä¸€çš„å†…å­˜ç©ºé—´ã€‚

**UMAæ‹“æ‰‘ç»“æ„**ï¼š

```text
        CPU0    CPU1    CPU2    CPU3
          |       |       |       |
          â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
                    |
             å…±äº«å†…å­˜æ€»çº¿
                    |
          â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
          |       |       |
        Memory  Memory  Memory
```

**UMAç‰¹å¾**ï¼š

**1. ç»Ÿä¸€è®¿é—®å»¶è¿Ÿ**ï¼š

- **æ‰€æœ‰CPUè®¿é—®æ‰€æœ‰å†…å­˜çš„å»¶è¿Ÿç›¸åŒ**
- **å»¶è¿Ÿ**ï¼š~80nsï¼ˆå…¸å‹å€¼ï¼‰
- **æ— æœ¬åœ°/è¿œç¨‹åŒºåˆ«**

**2. å…±äº«æ€»çº¿**ï¼š

- **æ€»çº¿å¸¦å®½**ï¼šå…±äº«ï¼ŒéšCPUæ•°å¢åŠ è€Œç«äº‰åŠ å‰§
- **æ€»çº¿ä»²è£**ï¼šéœ€è¦ä»²è£æœºåˆ¶é¿å…å†²çª
- **æ‰©å±•æ€§é™åˆ¶**ï¼šæ€»çº¿å¸¦å®½æˆä¸ºç“¶é¢ˆ

**3. ç®€å•ä¸€è‡´æ€§**ï¼š

- **ç¼“å­˜ä¸€è‡´æ€§**ï¼šé€šè¿‡æ€»çº¿ç›‘å¬å®ç°
- **ä¸€è‡´æ€§åè®®**ï¼šMESI/MOESI
- **å¼€é”€**ï¼šç›¸å¯¹è¾ƒä½

**UMAå®ç°**ï¼š

```c
// UMAæ¶æ„å®ç°ï¼ˆä¼ªä»£ç ï¼‰
typedef struct {
    // CPUé›†åˆ
    cpu_t cpus[MAX_CPUS];
    int cpu_count;

    // å…±äº«å†…å­˜æ€»çº¿
    bus_t *shared_bus;

    // å†…å­˜æ¨¡å—
    memory_t memories[MAX_MEMORIES];
    int memory_count;
} uma_system_t;

// UMAå†…å­˜è®¿é—®
bool uma_memory_access(uma_system_t *uma, int cpu_id, uint64_t addr,
                       bool is_write, uint8_t *data) {
    // 1. è·å–æ€»çº¿è®¿é—®æƒ
    bus_acquire(uma->shared_bus, cpu_id);

    // 2. é€šè¿‡æ€»çº¿è®¿é—®å†…å­˜
    bool success = bus_memory_access(uma->shared_bus, addr, is_write, data);

    // 3. é‡Šæ”¾æ€»çº¿
    bus_release(uma->shared_bus, cpu_id);

    return success;
}

// æ€»çº¿ä»²è£
void bus_acquire(bus_t *bus, int cpu_id) {
    // 1. è¯·æ±‚æ€»çº¿
    bus->request[cpu_id] = true;

    // 2. ç­‰å¾…ä»²è£
    while (bus->grant != cpu_id) {
        cpu_pause();
    }
}

// æ€»çº¿é‡Šæ”¾
void bus_release(bus_t *bus, int cpu_id) {
    bus->request[cpu_id] = false;
    bus->grant = -1;
}
```

### 2.2 è°ƒåº¦æ¨¡å‹

**UMAè°ƒåº¦æ¨¡å‹**ï¼š

**1. ç®€å•è´Ÿè½½å‡è¡¡**ï¼š

- **æ‰€æœ‰CPUåœ°ä½å¹³ç­‰**
- **ä»»åŠ¡å¯ä»¥è°ƒåº¦åˆ°ä»»æ„CPU**
- **æ— éœ€è€ƒè™‘å†…å­˜ä½ç½®**

**2. è°ƒåº¦ç­–ç•¥**ï¼š

```c
// UMAè°ƒåº¦ç­–ç•¥
int uma_schedule_task(uma_system_t *uma, task_t *task) {
    // 1. é€‰æ‹©è´Ÿè½½æœ€è½»çš„CPU
    int min_load_cpu = 0;
    int min_load = uma->cpus[0].load;

    for (int i = 1; i < uma->cpu_count; i++) {
        if (uma->cpus[i].load < min_load) {
            min_load = uma->cpus[i].load;
            min_load_cpu = i;
        }
    }

    // 2. è°ƒåº¦ä»»åŠ¡åˆ°é€‰å®šçš„CPU
    schedule_task_to_cpu(task, min_load_cpu);

    return min_load_cpu;
}
```

### 2.3 æ€§èƒ½åˆ†æ

**UMAæ€§èƒ½æ¨¡å‹**ï¼š

**æ€»çº¿å¸¦å®½åˆ©ç”¨ç‡**ï¼š

$$
U_{\text{bus}} = \frac{\sum_{i=1}^{n} B_i}{B_{\text{max}}}
$$

å…¶ä¸­$B_i$æ˜¯CPU $i$çš„å¸¦å®½éœ€æ±‚ï¼Œ$B_{\text{max}}$æ˜¯æ€»çº¿æœ€å¤§å¸¦å®½ã€‚

**é‡åŒ–åˆ†æ**ï¼šä¸åŒCPUæ•°ä¸‹çš„æ€»çº¿åˆ©ç”¨ç‡

| **CPUæ•°** | **æ€»çº¿åˆ©ç”¨ç‡** | **å¹³å‡å»¶è¿Ÿ** | **æ€§èƒ½ç“¶é¢ˆ** |
|----------|--------------|------------|------------|
| **2** | 40% | 80ns | CPU |
| **4** | 80% | 85ns | æ€»çº¿ |
| **8** | 160% | 120ns | æ€»çº¿ä¸¥é‡ç“¶é¢ˆ |
| **16** | 320% | 200ns | æ€»çº¿å®Œå…¨é¥±å’Œ |

**å…³é”®æ´å¯Ÿ**ï¼šUMAæ¶æ„åœ¨**4æ ¸ä»¥ä¸Š**æ—¶ï¼Œæ€»çº¿æˆä¸ºä¸¥é‡ç“¶é¢ˆï¼Œæ‰©å±•æ€§å·®ã€‚

---

## 3 SMPæ¶æ„ï¼ˆå¯¹ç§°å¤šå¤„ç†ï¼‰

### 3.1 æ¶æ„ç‰¹å¾

**æ¡ˆä¾‹1.5.3ï¼ˆSMPæ¶æ„ï¼‰**ï¼š

SMPæ¶æ„æ˜¯UMAçš„æ‰©å±•ï¼Œæ‰€æœ‰CPUåœ°ä½å¹³ç­‰ï¼Œå…±äº«å†…å­˜å’ŒIOèµ„æºã€‚

**SMPæ‹“æ‰‘ç»“æ„**ï¼š

```text
        CPU0    CPU1    CPU2    CPU3
          |       |       |       |
          â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
                    |
             å…±äº«å†…å­˜æ€»çº¿/äº¤å‰å¼€å…³
                    |
          â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
          |       |       |
        Memory  Memory  Memory
          |       |       |
          â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
                    |
                  IOæ€»çº¿
```

**SMPç‰¹å¾**ï¼š

**1. å¯¹ç§°æ€§**ï¼š

- **æ‰€æœ‰CPUåœ°ä½å¹³ç­‰**
- **å…±äº«å†…å­˜å’ŒIO**
- **ä»»ä½•CPUå¯ä»¥æ‰§è¡Œä»»ä½•ä»»åŠ¡**

**2. ç¼“å­˜ä¸€è‡´æ€§**ï¼š

- **æ‰€æœ‰CPUçš„ç¼“å­˜ä¿æŒä¸€è‡´**
- **é€šè¿‡MESI/MOESIåè®®ç»´æŠ¤**
- **ä¸€è‡´æ€§å¼€é”€éšCPUæ•°å¢åŠ **

**3. è´Ÿè½½å‡è¡¡**ï¼š

- **OSå¯ä»¥ä»»æ„è°ƒåº¦ä»»åŠ¡**
- **æ— éœ€è€ƒè™‘CPUå·®å¼‚**
- **ç¼–ç¨‹æ¨¡å‹ç®€å•**

**SMPå®ç°**ï¼š

```c
// SMPæ¶æ„å®ç°ï¼ˆä¼ªä»£ç ï¼‰
typedef struct {
    // CPUé›†åˆï¼ˆå¯¹ç§°ï¼‰
    cpu_t cpus[MAX_CPUS];
    int cpu_count;

    // å…±äº«å†…å­˜
    memory_t *shared_memory;

    // ç¼“å­˜ä¸€è‡´æ€§æ§åˆ¶å™¨
    cache_coherence_t *coherence;

    // IOæ§åˆ¶å™¨
    io_controller_t *io;
} smp_system_t;

// SMPå†…å­˜è®¿é—®
bool smp_memory_access(smp_system_t *smp, int cpu_id, uint64_t addr,
                       bool is_write, uint8_t *data) {
    // 1. æ£€æŸ¥æœ¬åœ°ç¼“å­˜
    if (cache_lookup(smp->cpus[cpu_id].cache, addr, data)) {
        return true;  // ç¼“å­˜å‘½ä¸­
    }

    // 2. ç¼“å­˜æœªå‘½ä¸­ï¼Œè®¿é—®å…±äº«å†…å­˜
    // 2.1 è·å–æ€»çº¿è®¿é—®æƒ
    bus_acquire(smp->shared_memory->bus, cpu_id);

    // 2.2 æ£€æŸ¥å…¶ä»–CPUçš„ç¼“å­˜ï¼ˆç¼“å­˜ä¸€è‡´æ€§ï¼‰
    cache_coherence_check(smp->coherence, cpu_id, addr);

    // 2.3 è®¿é—®å†…å­˜
    bool success = memory_access(smp->shared_memory, addr, is_write, data);

    // 2.4 æ›´æ–°ç¼“å­˜
    if (success) {
        cache_update(smp->cpus[cpu_id].cache, addr, data);
    }

    // 2.5 é‡Šæ”¾æ€»çº¿
    bus_release(smp->shared_memory->bus, cpu_id);

    return success;
}
```

### 3.2 è°ƒåº¦æ¨¡å‹

**SMPè°ƒåº¦æ¨¡å‹**ï¼š

**1. å¯¹ç§°è°ƒåº¦**ï¼š

- **æ‰€æœ‰CPUè¿è¡Œç›¸åŒçš„è°ƒåº¦å™¨**
- **ä»»åŠ¡å¯ä»¥è°ƒåº¦åˆ°ä»»æ„CPU**
- **è´Ÿè½½å‡è¡¡åœ¨CPUé—´è¿›è¡Œ**

**2. è°ƒåº¦ç­–ç•¥**ï¼š

```c
// SMPè°ƒåº¦ç­–ç•¥
int smp_schedule_task(smp_system_t *smp, task_t *task) {
    // 1. é€‰æ‹©è´Ÿè½½æœ€è½»çš„CPU
    int min_load_cpu = 0;
    int min_load = smp->cpus[0].load;

    for (int i = 1; i < smp->cpu_count; i++) {
        if (smp->cpus[i].load < min_load) {
            min_load = smp->cpus[i].load;
            min_load_cpu = i;
        }
    }

    // 2. è€ƒè™‘ç¼“å­˜äº²å’Œæ€§ï¼ˆå¯é€‰ï¼‰
    int preferred_cpu = task->last_cpu;
    if (preferred_cpu >= 0 && smp->cpus[preferred_cpu].load < min_load + 10) {
        min_load_cpu = preferred_cpu;  // ä¼˜å…ˆä½¿ç”¨ä¸Šæ¬¡è¿è¡Œçš„CPU
    }

    // 3. è°ƒåº¦ä»»åŠ¡
    schedule_task_to_cpu(task, min_load_cpu);

    return min_load_cpu;
}
```

### 3.3 ç¼“å­˜ä¸€è‡´æ€§

**SMPç¼“å­˜ä¸€è‡´æ€§æ¨¡å‹**ï¼š

**1. MESIåè®®**ï¼š

- **Modifiedï¼ˆMï¼‰**ï¼šå·²ä¿®æ”¹ï¼Œç‹¬å 
- **Exclusiveï¼ˆEï¼‰**ï¼šç‹¬å ï¼Œå¹²å‡€
- **Sharedï¼ˆSï¼‰**ï¼šå…±äº«ï¼Œå¹²å‡€
- **Invalidï¼ˆIï¼‰**ï¼šæ— æ•ˆ

**2. ä¸€è‡´æ€§å¼€é”€**ï¼š

$$
C_{\text{coherence}} = n \times (t_{\text{snoop}} + t_{\text{response}})
$$

å…¶ä¸­$n$æ˜¯CPUæ•°ï¼Œ$t_{\text{snoop}}$æ˜¯ç›‘å¬å»¶è¿Ÿï¼Œ$t_{\text{response}}$æ˜¯å“åº”å»¶è¿Ÿã€‚

**é‡åŒ–åˆ†æ**ï¼šä¸åŒCPUæ•°ä¸‹çš„ä¸€è‡´æ€§å¼€é”€

| **CPUæ•°** | **ç›‘å¬æ¶ˆæ¯æ•°** | **ä¸€è‡´æ€§å»¶è¿Ÿ** | **æ€§èƒ½å½±å“** |
|----------|--------------|--------------|------------|
| **2** | 1 | 5ns | å¯å¿½ç•¥ |
| **4** | 3 | 15ns | è½»å¾® |
| **8** | 7 | 35ns | ä¸­ç­‰ |
| **16** | 15 | 75ns | æ˜¾è‘— |

**å…³é”®æ´å¯Ÿ**ï¼šSMPæ¶æ„åœ¨**8æ ¸ä»¥ä¸Š**æ—¶ï¼Œç¼“å­˜ä¸€è‡´æ€§å¼€é”€æ˜¾è‘—å¢åŠ ï¼Œæ‰©å±•æ€§å—é™ã€‚

---

## 4 NUMAæ¶æ„ï¼ˆéç»Ÿä¸€å†…å­˜è®¿é—®ï¼‰

### 4.1 æ¶æ„ç‰¹å¾

**æ¡ˆä¾‹1.5.4ï¼ˆNUMAæ¶æ„ï¼‰**ï¼š

NUMAæ¶æ„é€šè¿‡åˆ†å¸ƒå¼å†…å­˜è§£å†³SMPçš„æ‰©å±•æ€§é—®é¢˜ï¼Œä¸åŒCPUè®¿é—®ä¸åŒå†…å­˜åŒºåŸŸçš„å»¶è¿Ÿä¸åŒã€‚

**NUMAæ‹“æ‰‘ç»“æ„**ï¼š

```text
Socket 0                    Socket 1
  CPU0  CPU1                  CPU2  CPU3
    |     |                     |     |
    â””â”€â”€â”€â”¬â”€â”˜                     â””â”€â”€â”€â”¬â”€â”˜
        |                           |
    IMC0 (æœ¬åœ°)                  IMC1 (æœ¬åœ°)
        |                           |
    Memory0                      Memory1
        |                           |
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ QPI/UPI â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              (è¿œç¨‹è®¿é—®è·¯å¾„)
```

**NUMAç‰¹å¾**ï¼š

**1. éç»Ÿä¸€è®¿é—®å»¶è¿Ÿ**ï¼š

- **æœ¬åœ°å†…å­˜è®¿é—®**ï¼š~80ns
- **è¿œç¨‹å†…å­˜è®¿é—®**ï¼š~150nsï¼ˆ2è·¯NUMAï¼‰
- **å»¶è¿Ÿæ¯”**ï¼š1.9x

**2. åˆ†å¸ƒå¼å†…å­˜**ï¼š

- **æ¯ä¸ªSocketæœ‰æœ¬åœ°å†…å­˜**
- **é€šè¿‡äº’è¿ç½‘ç»œè¿æ¥**
- **æ‰©å±•æ€§å¥½**

**3. OSæ„ŸçŸ¥**ï¼š

- **éœ€è¦NUMAæ„ŸçŸ¥çš„è°ƒåº¦å™¨**
- **å†…å­˜åˆ†é…è€ƒè™‘ä½ç½®**
- **è´Ÿè½½å‡è¡¡è€ƒè™‘å†…å­˜äº²å’Œæ€§**

### 4.2 è°ƒåº¦æ¨¡å‹

**NUMAè°ƒåº¦æ¨¡å‹**ï¼š

**1. NUMAæ„ŸçŸ¥è°ƒåº¦**ï¼š

- **è€ƒè™‘CPUå’Œå†…å­˜çš„ä½ç½®å…³ç³»**
- **ä¼˜å…ˆåœ¨æœ¬åœ°èŠ‚ç‚¹è°ƒåº¦**
- **å‡å°‘è¿œç¨‹å†…å­˜è®¿é—®**

**2. è°ƒåº¦ç­–ç•¥**ï¼š

```c
// NUMAè°ƒåº¦ç­–ç•¥
int numa_schedule_task(numa_system_t *numa, task_t *task) {
    // 1. ç¡®å®šä»»åŠ¡çš„å†…å­˜èŠ‚ç‚¹
    int mem_node = get_task_memory_node(task);

    // 2. é€‰æ‹©åŒä¸€èŠ‚ç‚¹çš„CPU
    int preferred_cpu = -1;
    int min_load = INT_MAX;

    for (int i = 0; i < numa->cpu_count; i++) {
        int cpu_node = get_cpu_numa_node(i);

        if (cpu_node == mem_node) {
            // æœ¬åœ°èŠ‚ç‚¹CPU
            if (numa->cpus[i].load < min_load) {
                min_load = numa->cpus[i].load;
                preferred_cpu = i;
            }
        }
    }

    // 3. å¦‚æœæœ¬åœ°èŠ‚ç‚¹CPUè´Ÿè½½è¿‡é«˜ï¼Œè€ƒè™‘è¿œç¨‹èŠ‚ç‚¹
    if (preferred_cpu < 0 || min_load > LOAD_THRESHOLD) {
        // é€‰æ‹©è´Ÿè½½æœ€è½»çš„CPUï¼ˆå¯èƒ½è¿œç¨‹ï¼‰
        for (int i = 0; i < numa->cpu_count; i++) {
            if (numa->cpus[i].load < min_load) {
                min_load = numa->cpus[i].load;
                preferred_cpu = i;
            }
        }
    }

    // 4. è°ƒåº¦ä»»åŠ¡
    schedule_task_to_cpu(task, preferred_cpu);

    return preferred_cpu;
}
```

### 4.3 å†…å­˜è®¿é—®æ¨¡å‹

**NUMAå†…å­˜è®¿é—®æ¨¡å‹**ï¼š

**è®¿é—®å»¶è¿Ÿå‡½æ•°**ï¼š

$$
L_{\text{NUMA}}(p_i, m_j) = \begin{cases}
t_{\text{local}} & \text{if } \text{node}(p_i) = \text{node}(m_j) \\
t_{\text{remote}} = t_{\text{local}} + t_{\text{interconnect}} & \text{otherwise}
\end{cases}
$$

**é‡åŒ–åˆ†æ**ï¼šä¸åŒNUMAé…ç½®çš„å»¶è¿Ÿ

| **é…ç½®** | **æœ¬åœ°å»¶è¿Ÿ** | **è¿œç¨‹å»¶è¿Ÿ** | **å»¶è¿Ÿæ¯”** | **æ‰©å±•æ€§** |
|---------|------------|------------|-----------|-----------|
| **2è·¯NUMA** | 80ns | 150ns | 1.9x | å¥½ |
| **4è·¯NUMA** | 80ns | 200ns | 2.5x | å¾ˆå¥½ |
| **8è·¯NUMA** | 80ns | 300ns | 3.8x | ä¼˜ç§€ |

**å…³é”®æ´å¯Ÿ**ï¼šNUMAæ¶æ„åœ¨**å¤§è§„æ¨¡ç³»ç»Ÿ**ä¸­æ‰©å±•æ€§å¥½ï¼Œä½†éœ€è¦**OSå’Œåº”ç”¨çš„NUMAæ„ŸçŸ¥**ã€‚

---

## 5 å¤šæ ¸è°ƒåº¦æ¨¡å‹

### 5.1 è´Ÿè½½å‡è¡¡

**æ¡ˆä¾‹1.5.5ï¼ˆå¤šæ ¸è´Ÿè½½å‡è¡¡ï¼‰**ï¼š

å¤šæ ¸ç³»ç»Ÿçš„è´Ÿè½½å‡è¡¡éœ€è¦è€ƒè™‘CPUè´Ÿè½½ã€ç¼“å­˜äº²å’Œæ€§å’Œå†…å­˜ä½ç½®ã€‚

**è´Ÿè½½å‡è¡¡ç®—æ³•**ï¼š

```c
// å¤šæ ¸è´Ÿè½½å‡è¡¡
void multi_core_load_balance(system_t *sys) {
    // 1. è®¡ç®—å¹³å‡è´Ÿè½½
    int total_load = 0;
    for (int i = 0; i < sys->cpu_count; i++) {
        total_load += sys->cpus[i].load;
    }
    int avg_load = total_load / sys->cpu_count;

    // 2. è¯†åˆ«è¿‡è½½å’Œæ¬ è½½CPU
    int overloaded_cpus[MAX_CPUS];
    int underloaded_cpus[MAX_CPUS];
    int overloaded_count = 0;
    int underloaded_count = 0;

    for (int i = 0; i < sys->cpu_count; i++) {
        if (sys->cpus[i].load > avg_load + THRESHOLD) {
            overloaded_cpus[overloaded_count++] = i;
        } else if (sys->cpus[i].load < avg_load - THRESHOLD) {
            underloaded_cpus[underloaded_count++] = i;
        }
    }

    // 3. è¿ç§»ä»»åŠ¡
    for (int i = 0; i < overloaded_count; i++) {
        int src_cpu = overloaded_cpus[i];

        // é€‰æ‹©è¦è¿ç§»çš„ä»»åŠ¡
        task_t *task = select_task_to_migrate(sys->cpus[src_cpu]);

        if (task != NULL) {
            // é€‰æ‹©ç›®æ ‡CPUï¼ˆè€ƒè™‘NUMAï¼‰
            int dst_cpu = select_target_cpu(sys, task, underloaded_cpus,
                                            underloaded_count);

            if (dst_cpu >= 0) {
                migrate_task(task, src_cpu, dst_cpu);
            }
        }
    }
}
```

### 5.2 äº²å’Œæ€§è°ƒåº¦

**ç¼“å­˜äº²å’Œæ€§è°ƒåº¦**ï¼š

**1. CPUäº²å’Œæ€§**ï¼š

- **ä»»åŠ¡ä¼˜å…ˆè°ƒåº¦åˆ°ä¸Šæ¬¡è¿è¡Œçš„CPU**
- **åˆ©ç”¨ç¼“å­˜å±€éƒ¨æ€§**
- **å‡å°‘ç¼“å­˜å¤±æ•ˆ**

**2. å†…å­˜äº²å’Œæ€§**ï¼š

- **ä»»åŠ¡ä¼˜å…ˆè°ƒåº¦åˆ°å†…å­˜æ‰€åœ¨çš„èŠ‚ç‚¹**
- **å‡å°‘è¿œç¨‹å†…å­˜è®¿é—®**
- **æé«˜æ€§èƒ½**

**äº²å’Œæ€§è°ƒåº¦å®ç°**ï¼š

```c
// äº²å’Œæ€§è°ƒåº¦
int affinity_schedule(system_t *sys, task_t *task) {
    // 1. æ£€æŸ¥CPUäº²å’Œæ€§
    int last_cpu = task->last_cpu;
    if (last_cpu >= 0 && sys->cpus[last_cpu].load < AFFINITY_THRESHOLD) {
        return last_cpu;  // ä½¿ç”¨ä¸Šæ¬¡çš„CPU
    }

    // 2. æ£€æŸ¥å†…å­˜äº²å’Œæ€§ï¼ˆNUMAï¼‰
    int mem_node = get_task_memory_node(task);
    int preferred_cpu = find_cpu_in_node(sys, mem_node);

    if (preferred_cpu >= 0 && sys->cpus[preferred_cpu].load < AFFINITY_THRESHOLD) {
        return preferred_cpu;  // ä½¿ç”¨å†…å­˜èŠ‚ç‚¹çš„CPU
    }

    // 3. å›é€€åˆ°è´Ÿè½½å‡è¡¡
    return load_balance_schedule(sys, task);
}
```

### 5.3 è°ƒåº¦åŸŸå±‚æ¬¡

**è°ƒåº¦åŸŸå±‚æ¬¡ç»“æ„**ï¼š

```text
ç³»ç»Ÿçº§
  â†“
NUMAèŠ‚ç‚¹åŸŸ
  â†“
L3ç¼“å­˜åŸŸ
  â†“
CPUæ ¸å¿ƒåŸŸ
```

**è°ƒåº¦åŸŸå®ç°**ï¼š

```c
// è°ƒåº¦åŸŸ
typedef struct {
    int domain_level;  // åŸŸçº§åˆ«
    int cpu_count;     // CPUæ•°é‡
    int *cpus;         // CPUåˆ—è¡¨
    struct sched_domain *parent;  // çˆ¶åŸŸ
    struct sched_domain *child;   // å­åŸŸ
} sched_domain_t;

// è°ƒåº¦åŸŸè´Ÿè½½å‡è¡¡
void domain_load_balance(sched_domain_t *domain) {
    // 1. åœ¨åŸŸå†…è¿›è¡Œè´Ÿè½½å‡è¡¡
    balance_within_domain(domain);

    // 2. å¦‚æœåŸŸå†…ä¸å¹³è¡¡ï¼Œå‘ä¸Šçº§åŸŸæŠ¥å‘Š
    if (is_domain_imbalanced(domain)) {
        if (domain->parent != NULL) {
            domain_load_balance(domain->parent);
        }
    }
}
```

---

## 6 å®è·µæ¡ˆä¾‹

### 6.1 SMPç³»ç»Ÿä¼˜åŒ–

**æ¡ˆä¾‹1.5.6ï¼ˆSMPç³»ç»Ÿä¼˜åŒ–ï¼‰**ï¼š

æŸSMPç³»ç»Ÿä¼˜åŒ–ç¼“å­˜ä¸€è‡´æ€§å’Œè´Ÿè½½å‡è¡¡ï¼Œæé«˜æ€§èƒ½ã€‚

**ä¼˜åŒ–ç­–ç•¥**ï¼š

**1. å‡å°‘ç¼“å­˜ä¸€è‡´æ€§å¼€é”€**ï¼š

```c
// ä½¿ç”¨æ¯CPUå˜é‡å‡å°‘ç¼“å­˜ä¸€è‡´æ€§
DEFINE_PER_CPU(int, local_counter);

void increment_counter(void) {
    int *counter = this_cpu_ptr(&local_counter);
    (*counter)++;
}
```

**2. ä¼˜åŒ–è´Ÿè½½å‡è¡¡**ï¼š

```c
// è€ƒè™‘ç¼“å­˜äº²å’Œæ€§çš„è´Ÿè½½å‡è¡¡
int smp_load_balance_with_affinity(smp_system_t *smp, task_t *task) {
    // 1. ä¼˜å…ˆä½¿ç”¨ä¸Šæ¬¡çš„CPU
    int last_cpu = task->last_cpu;
    if (last_cpu >= 0 && smp->cpus[last_cpu].load < AFFINITY_THRESHOLD) {
        return last_cpu;
    }

    // 2. é€‰æ‹©è´Ÿè½½æœ€è½»çš„CPU
    return smp_load_balance(smp, task);
}
```

**ä¼˜åŒ–æ•ˆæœ**ï¼š

| **æŒ‡æ ‡** | **ä¼˜åŒ–å‰** | **ä¼˜åŒ–å** | **æ”¹å–„** |
|---------|-----------|-----------|---------|
| **ç¼“å­˜ä¸€è‡´æ€§å¼€é”€** | 35ns | 20ns | -43% |
| **è´Ÿè½½å‡è¡¡æ•ˆç‡** | 75% | 90% | +20% |
| **æ•´ä½“æ€§èƒ½** | åŸºå‡† | +15% | æå‡ |

### 6.2 NUMAç³»ç»Ÿä¼˜åŒ–

**æ¡ˆä¾‹1.5.7ï¼ˆNUMAç³»ç»Ÿä¼˜åŒ–ï¼‰**ï¼š

æŸNUMAç³»ç»Ÿä¼˜åŒ–å†…å­˜åˆ†é…å’Œä»»åŠ¡è°ƒåº¦ï¼Œæé«˜æ€§èƒ½ã€‚

**ä¼˜åŒ–ç­–ç•¥**ï¼š

**1. NUMAæ„ŸçŸ¥å†…å­˜åˆ†é…**ï¼š

```c
// NUMAæ„ŸçŸ¥å†…å­˜åˆ†é…
void *numa_aware_malloc(size_t size, int cpu_id) {
    // 1. ç¡®å®šCPUæ‰€åœ¨çš„NUMAèŠ‚ç‚¹
    int node = get_cpu_numa_node(cpu_id);

    // 2. åœ¨æœ¬åœ°èŠ‚ç‚¹åˆ†é…å†…å­˜
    return numa_alloc_onnode(size, node);
}
```

**2. NUMAæ„ŸçŸ¥ä»»åŠ¡è°ƒåº¦**ï¼š

```c
// NUMAæ„ŸçŸ¥ä»»åŠ¡è°ƒåº¦
int numa_aware_schedule(numa_system_t *numa, task_t *task) {
    // 1. ç¡®å®šä»»åŠ¡çš„å†…å­˜èŠ‚ç‚¹
    int mem_node = get_task_memory_node(task);

    // 2. é€‰æ‹©åŒä¸€èŠ‚ç‚¹çš„CPU
    return numa_schedule_task(numa, task, mem_node);
}
```

**ä¼˜åŒ–æ•ˆæœ**ï¼š

| **æŒ‡æ ‡** | **ä¼˜åŒ–å‰** | **ä¼˜åŒ–å** | **æ”¹å–„** |
|---------|-----------|-----------|---------|
| **æœ¬åœ°è®¿é—®ç‡** | 60% | 95% | +58% |
| **å¹³å‡å†…å­˜å»¶è¿Ÿ** | 120ns | 85ns | -29% |
| **æ•´ä½“æ€§èƒ½** | åŸºå‡† | +25% | æå‡ |

---

## 7 æ€ç»´å¯¼å›¾ï¼šå¤šå¤„ç†å™¨æ¶æ„å†³ç­–

```mermaid
mindmap
  root((å¤šå¤„ç†å™¨æ¶æ„))
    æ¶æ„é€‰æ‹©
      UMA
        ç®€å•
        2-4æ ¸
        æ€»çº¿ç“¶é¢ˆ
      SMP
        å¯¹ç§°
        4-16æ ¸
        ä¸€è‡´æ€§å¼€é”€
      NUMA
        æ‰©å±•æ€§å¥½
        16+æ ¸
        ç¼–ç¨‹å¤æ‚
    è°ƒåº¦æ¨¡å‹
      è´Ÿè½½å‡è¡¡
        ç®€å•å‡è¡¡
        ç¼“å­˜äº²å’Œæ€§
        å†…å­˜äº²å’Œæ€§
      è°ƒåº¦åŸŸ
        NUMAåŸŸ
        L3ç¼“å­˜åŸŸ
        CPUæ ¸å¿ƒåŸŸ
    æ€§èƒ½ä¼˜åŒ–
      å‡å°‘ä¸€è‡´æ€§å¼€é”€
        æ¯CPUå˜é‡
        å‡å°‘å…±äº«
      æé«˜å±€éƒ¨æ€§
        ç¼“å­˜äº²å’Œæ€§
        å†…å­˜äº²å’Œæ€§
      æ‰©å±•æ€§
        NUMAæ„ŸçŸ¥
        åˆ†å¸ƒå¼è°ƒåº¦
```

---

## 8 æ‰¹åˆ¤æ€§æ€»ç»“

### 8.1 æ¶æ„é€‰æ‹©çš„æ ¹æœ¬çŸ›ç›¾

1. **ç®€å•æ€§vsæ‰©å±•æ€§**ï¼šUMA/SMPç®€å•ä½†æ‰©å±•æ€§å·®ï¼ŒNUMAæ‰©å±•æ€§å¥½ä½†å¤æ‚ã€‚

2. **ä¸€è‡´æ€§vsæ€§èƒ½**ï¼šä¸¥æ ¼ä¸€è‡´æ€§ä¿è¯æ­£ç¡®æ€§ï¼Œä½†å¢åŠ å»¶è¿Ÿå’Œå¼€é”€ã€‚

3. **é€šç”¨æ€§vsä¸“ç”¨æ€§**ï¼šé€šç”¨æ¶æ„çµæ´»ï¼Œä½†ä¸“ç”¨æ¶æ„ï¼ˆå¦‚ccNUMAï¼‰æ€§èƒ½æ›´å¥½ã€‚

### 8.2 2025å¹´å¤šå¤„ç†å™¨æ¶æ„è¶‹åŠ¿

- **å¼‚æ„å¤šæ ¸**ï¼šå¤§å°æ ¸æ··åˆï¼Œ**æŒ‘æˆ˜ä¼ ç»Ÿå¯¹ç§°æ¶æ„**ã€‚
- **CXLç»Ÿä¸€**ï¼šCXLç»Ÿä¸€å†…å­˜å’ŒIOï¼Œ**æŒ‘æˆ˜ä¼ ç»ŸNUMAè¾¹ç•Œ**ã€‚
- **AIåŠ é€Ÿ**ï¼šä¸“ç”¨AIæ ¸å¿ƒï¼Œ**éœ€è¦æ–°çš„è°ƒåº¦æ¨¡å‹**ã€‚

---

## 9 è·¨é¢†åŸŸæ´å¯Ÿ

### 9.1 æ‰©å±•æ€§vsä¸€è‡´æ€§çš„æƒè¡¡

**æ ¸å¿ƒçŸ›ç›¾**ï¼šæ‰©å±•æ€§éœ€è¦åˆ†å¸ƒå¼ï¼Œä½†ä¸€è‡´æ€§éœ€è¦é›†ä¸­å¼ã€‚

**é‡åŒ–åˆ†æ**ï¼š

| **æ¶æ„** | **æ‰©å±•æ€§** | **ä¸€è‡´æ€§å¼€é”€** | **é€‚ç”¨è§„æ¨¡** |
|---------|-----------|--------------|------------|
| **UMA** | â­ | â­ | 2-4æ ¸ |
| **SMP** | â­â­ | â­â­ | 4-16æ ¸ |
| **NUMA** | â­â­â­â­â­ | â­â­â­ | 16+æ ¸ |

**å…³é”®æ´å¯Ÿ**ï¼š**æ²¡æœ‰å®Œç¾çš„æ¶æ„**ï¼Œéœ€è¦åœ¨æ‰©å±•æ€§å’Œä¸€è‡´æ€§ä¹‹é—´æƒè¡¡ã€‚

### 9.2 è°ƒåº¦å¤æ‚åº¦çš„å±‚çº§æ€§

**æ ¸å¿ƒå‘½é¢˜**ï¼šè°ƒåº¦å¤æ‚åº¦éšæ¶æ„å¤æ‚åº¦å¢åŠ ã€‚

**å¤æ‚åº¦å¯¹æ¯”**ï¼š

- **UMAè°ƒåº¦**ï¼šO(n) - ç®€å•è´Ÿè½½å‡è¡¡
- **SMPè°ƒåº¦**ï¼šO(n log n) - è€ƒè™‘ç¼“å­˜äº²å’Œæ€§
- **NUMAè°ƒåº¦**ï¼šO(nÂ²) - è€ƒè™‘å†…å­˜ä½ç½®å’Œè´Ÿè½½

**å…³é”®æ´å¯Ÿ**ï¼š**è°ƒåº¦å¤æ‚åº¦**åæ˜ äº†æ¶æ„çš„**å†…åœ¨å¤æ‚æ€§**ã€‚

---

## 10 å¤šç»´åº¦å¯¹æ¯”

### 10.1 æ¶æ„æ¨¡å‹å¯¹æ¯”

| **æ¶æ„** | **CPUæ•°** | **å†…å­˜å»¶è¿Ÿ** | **æ‰©å±•æ€§** | **ç¼–ç¨‹å¤æ‚åº¦** | **é€‚ç”¨åœºæ™¯** |
|---------|----------|------------|-----------|--------------|------------|
| **UMA** | 2-4 | ç»Ÿä¸€80ns | â­ | â­ | åµŒå…¥å¼ |
| **SMP** | 4-16 | ç»Ÿä¸€80ns | â­â­ | â­ | é€šç”¨è®¡ç®— |
| **NUMA** | 16+ | æœ¬åœ°80ns/è¿œç¨‹150ns | â­â­â­â­â­ | â­â­â­ | æœåŠ¡å™¨/HPC |

### 10.2 è°ƒåº¦ç­–ç•¥å¯¹æ¯”

| **ç­–ç•¥** | **å¤æ‚åº¦** | **æ€§èƒ½** | **é€‚ç”¨æ¶æ„** |
|---------|-----------|---------|------------|
| **ç®€å•è´Ÿè½½å‡è¡¡** | O(n) | ä¸­ | UMA |
| **ç¼“å­˜äº²å’Œæ€§** | O(n log n) | é«˜ | SMP |
| **NUMAæ„ŸçŸ¥** | O(nÂ²) | å¾ˆé«˜ | NUMA |

---

## 11 ç›¸å…³ä¸»é¢˜

- [1.3 å†…å­˜å­ç³»ç»Ÿ](./01.3_å†…å­˜å­ç³»ç»Ÿ.md) - NUMAå†…å­˜è®¿é—®
- [1.2 ç¼“å­˜å±‚æ¬¡ç»“æ„](./01.2_ç¼“å­˜å±‚æ¬¡ç»“æ„.md) - ç¼“å­˜ä¸€è‡´æ€§åè®®
- [03.1 è¿›ç¨‹è°ƒåº¦æ¨¡å‹](../03_OSæŠ½è±¡å±‚/03.1_è¿›ç¨‹è°ƒåº¦æ¨¡å‹.md) - OSè°ƒåº¦å®ç°
- [04.1 ç¡¬ä»¶åŒæ­¥åŸè¯­](../04_åŒæ­¥é€šä¿¡æœºåˆ¶/04.1_ç¡¬ä»¶åŒæ­¥åŸè¯­.md) - å¤šæ ¸åŒæ­¥
- [ä¸»æ–‡æ¡£ï¼šè°ƒåº¦æ¨¡å‹ç»Ÿä¸€ç†è®º](../06_è°ƒåº¦æ¨¡å‹/06.5_è°ƒåº¦æ¨¡å‹ç»Ÿä¸€ç†è®º.md) - ç»Ÿä¸€è°ƒåº¦æ¡†æ¶

---

**æœ€åæ›´æ–°**: 2025-01-XX
