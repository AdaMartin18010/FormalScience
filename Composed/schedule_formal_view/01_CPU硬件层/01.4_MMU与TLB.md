# 1.4 MMUä¸TLB

> **ä¸»é¢˜**: 01. CPUç¡¬ä»¶å±‚ - 1.4 MMUä¸TLB
> **è¦†ç›–**: é¡µè¡¨å±‚æ¬¡ã€åœ°å€è½¬æ¢ã€TLBç®¡ç†

---

## ğŸ“‹ ç›®å½•

- [1.4 MMUä¸TLB](#14-mmuä¸tlb)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 MMUæ¶æ„](#1-mmuæ¶æ„)
    - [1.1 åŠŸèƒ½](#11-åŠŸèƒ½)
    - [1.2 ç¡¬ä»¶å®ç°](#12-ç¡¬ä»¶å®ç°)
  - [2 é¡µè¡¨å±‚æ¬¡](#2-é¡µè¡¨å±‚æ¬¡)
    - [2.1 x86-64äº”çº§é¡µè¡¨](#21-x86-64äº”çº§é¡µè¡¨)
    - [2.2 å¤§é¡µæ”¯æŒ](#22-å¤§é¡µæ”¯æŒ)
  - [3 TLBç®¡ç†](#3-tlbç®¡ç†)
    - [3.1 TLBå±‚æ¬¡çš„ä¸¥æ ¼åˆ†æ](#31-tlbå±‚æ¬¡çš„ä¸¥æ ¼åˆ†æ)
    - [3.2 TLBæœªå‘½ä¸­æƒ©ç½šçš„ä¸¥æ ¼å»ºæ¨¡](#32-tlbæœªå‘½ä¸­æƒ©ç½šçš„ä¸¥æ ¼å»ºæ¨¡)
  - [4 åœ°å€è½¬æ¢æµç¨‹](#4-åœ°å€è½¬æ¢æµç¨‹)
    - [4.1 æ­£å¸¸æµç¨‹](#41-æ­£å¸¸æµç¨‹)
    - [4.2 ç¼ºé¡µå¼‚å¸¸](#42-ç¼ºé¡µå¼‚å¸¸)
  - [5 å®è·µæ¡ˆä¾‹](#5-å®è·µæ¡ˆä¾‹)
    - [5.1 é«˜æ€§èƒ½åº”ç”¨TLBä¼˜åŒ–](#51-é«˜æ€§èƒ½åº”ç”¨tlbä¼˜åŒ–)
    - [5.2 æ•°æ®åº“MMUä¼˜åŒ–](#52-æ•°æ®åº“mmuä¼˜åŒ–)
  - [6 æ€ç»´å¯¼å›¾ï¼šMMU/TLBè®¾è®¡å†³ç­–](#6-æ€ç»´å¯¼å›¾mmutlbè®¾è®¡å†³ç­–)
  - [7 æ‰¹åˆ¤æ€§æ€»ç»“](#7-æ‰¹åˆ¤æ€§æ€»ç»“)
    - [5.1 MMU/TLBè®¾è®¡çš„æ ¹æœ¬çŸ›ç›¾](#51-mmutlbè®¾è®¡çš„æ ¹æœ¬çŸ›ç›¾)
    - [5.2 2025å¹´MMU/TLBæŠ€æœ¯è¶‹åŠ¿](#52-2025å¹´mmutlbæŠ€æœ¯è¶‹åŠ¿)
  - [8 è·¨é¢†åŸŸæ´å¯Ÿ](#8-è·¨é¢†åŸŸæ´å¯Ÿ)
    - [6.1 TLBæœªå‘½ä¸­çš„æ€§èƒ½æƒ©ç½š](#61-tlbæœªå‘½ä¸­çš„æ€§èƒ½æƒ©ç½š)
    - [6.2 åœ°å€ç©ºé—´vsæ€§èƒ½çš„æƒè¡¡](#62-åœ°å€ç©ºé—´vsæ€§èƒ½çš„æƒè¡¡)
  - [9 å¤šç»´åº¦å¯¹æ¯”](#9-å¤šç»´åº¦å¯¹æ¯”)
    - [7.1 MMUæ¶æ„å¯¹æ¯”ï¼ˆ2025å¹´ï¼‰](#71-mmuæ¶æ„å¯¹æ¯”2025å¹´)
    - [7.2 TLBç®¡ç†ç­–ç•¥å¯¹æ¯”](#72-tlbç®¡ç†ç­–ç•¥å¯¹æ¯”)
  - [10 ç›¸å…³ä¸»é¢˜](#10-ç›¸å…³ä¸»é¢˜)

---

## 1 MMUæ¶æ„

### 1.1 åŠŸèƒ½

**æ¡ˆä¾‹1.4.1ï¼ˆMMUåŠŸèƒ½ï¼‰**ï¼š

MMUï¼ˆMemory Management Unitï¼‰æ˜¯CPUçš„é‡è¦ç»„ä»¶ï¼Œè´Ÿè´£è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„è½¬æ¢ã€‚

**åœ°å€è½¬æ¢**ï¼š

- **è™šæ‹Ÿåœ°å€ï¼ˆVAï¼‰â†’ ç‰©ç†åœ°å€ï¼ˆPAï¼‰**ï¼šå°†ç¨‹åºä½¿ç”¨çš„è™šæ‹Ÿåœ°å€è½¬æ¢ä¸ºç‰©ç†å†…å­˜åœ°å€
- **48-bit VA â†’ 52-bit PAï¼ˆx86-64ï¼‰**ï¼šx86-64æ¶æ„æ”¯æŒ48ä½è™šæ‹Ÿåœ°å€å’Œ52ä½ç‰©ç†åœ°å€

**æƒé™æ£€æŸ¥**ï¼š

- **è¯»/å†™/æ‰§è¡Œæƒé™**ï¼šæ£€æŸ¥é¡µè¡¨é¡¹ä¸­çš„æƒé™ä½
- **ç”¨æˆ·/å†…æ ¸æ¨¡å¼**ï¼šåŒºåˆ†ç”¨æˆ·æ€å’Œå†…æ ¸æ€è®¿é—®

**MMUå®ç°**ï¼š

```c
// MMUå®ç°ï¼ˆä¼ªä»£ç ï¼‰
typedef struct {
    // CR3å¯„å­˜å™¨ï¼ˆé¡µè¡¨åŸºå€ï¼‰
    uint64_t cr3;

    // PCIDï¼ˆProcess Context IDï¼‰
    uint16_t pcid;

    // TLB
    tlb_t *tlb;

    // é¡µè¡¨éå†å™¨
    ptw_t *ptw;
} mmu_t;

// åœ°å€è½¬æ¢
bool mmu_translate(mmu_t *mmu, uint64_t vaddr, uint64_t *paddr,
                   access_type_t access) {
    // 1. æ£€æŸ¥TLB
    tlb_entry_t *entry = tlb_lookup(mmu->tlb, vaddr, mmu->pcid);

    if (entry != NULL) {
        // 2. TLBå‘½ä¸­ï¼Œæ£€æŸ¥æƒé™
        if (check_permission(entry, access)) {
            *paddr = entry->paddr | (vaddr & 0xFFF);  // é¡µå†…åç§»
            return true;
        } else {
            // æƒé™ä¸è¶³ï¼Œè§¦å‘å¼‚å¸¸
            raise_page_fault(PERMISSION_FAULT);
            return false;
        }
    }

    // 3. TLBæœªå‘½ä¸­ï¼Œé¡µè¡¨éå†
    return mmu_page_walk(mmu, vaddr, paddr, access);
}

// æƒé™æ£€æŸ¥
bool check_permission(tlb_entry_t *entry, access_type_t access) {
    switch (access) {
    case READ:
        return entry->readable;
    case WRITE:
        return entry->writable;
    case EXECUTE:
        return entry->executable;
    default:
        return false;
    }
}
```

### 1.2 ç¡¬ä»¶å®ç°

**æ¡ˆä¾‹1.4.2ï¼ˆç¡¬ä»¶é¡µè¡¨éå†å™¨ï¼‰**ï¼š

ç¡¬ä»¶é¡µè¡¨éå†å™¨ï¼ˆPTWï¼‰æ˜¯ç°ä»£CPUçš„å…³é”®ä¼˜åŒ–ï¼Œè‡ªåŠ¨éå†é¡µè¡¨å¹¶ç¼“å­˜ç»“æœã€‚

**é¡µè¡¨éå†å™¨ï¼ˆPTWï¼‰åŠŸèƒ½**ï¼š

- **ç¡¬ä»¶è‡ªåŠ¨éå†é¡µè¡¨**ï¼šæ— éœ€è½¯ä»¶å¹²é¢„
- **å¹¶è¡ŒæŸ¥æ‰¾å¤šçº§é¡µè¡¨**ï¼šå¹¶è¡Œè®¿é—®å¤šçº§é¡µè¡¨ï¼Œå‡å°‘å»¶è¿Ÿ
- **ç¼“å­˜è½¬æ¢ç»“æœåˆ°TLB**ï¼šè‡ªåŠ¨æ›´æ–°TLB

**ç¡¬ä»¶PTWå®ç°**ï¼š

```c
// ç¡¬ä»¶é¡µè¡¨éå†å™¨å®ç°ï¼ˆä¼ªä»£ç ï¼‰
typedef struct {
    // é¡µè¡¨éå†çŠ¶æ€
    struct {
        uint64_t vaddr;
        uint64_t cr3;
        int level;
        uint64_t pte_addr;
        bool in_progress;
    } walk_state;

    // å¹¶è¡Œè®¿é—®ç¼“å†²
    struct {
        uint64_t pte_addr[5];  // 5çº§é¡µè¡¨
        bool valid[5];
    } parallel_buf;

    // ç»Ÿè®¡ä¿¡æ¯
    uint64_t walks_completed;
    uint64_t walks_failed;
} ptw_t;

// é¡µè¡¨éå†
bool mmu_page_walk(mmu_t *mmu, uint64_t vaddr, uint64_t *paddr,
                   access_type_t access) {
    ptw_t *ptw = mmu->ptw;

    // 1. åˆå§‹åŒ–éå†çŠ¶æ€
    ptw->walk_state.vaddr = vaddr;
    ptw->walk_state.cr3 = mmu->cr3;
    ptw->walk_state.level = 0;
    ptw->walk_state.in_progress = true;

    // 2. è®¡ç®—å„çº§é¡µè¡¨ç´¢å¼•
    uint64_t indices[5];
    indices[0] = (vaddr >> 39) & 0x1FF;  // PML4
    indices[1] = (vaddr >> 30) & 0x1FF;  // PDPT
    indices[2] = (vaddr >> 21) & 0x1FF;  // PD
    indices[3] = (vaddr >> 12) & 0x1FF;  // PT
    indices[4] = vaddr & 0xFFF;          // é¡µå†…åç§»

    // 3. å¹¶è¡Œè®¿é—®å¤šçº§é¡µè¡¨
    uint64_t base = ptw->walk_state.cr3;

    for (int level = 0; level < 5; level++) {
        // 3.1 è®¡ç®—é¡µè¡¨é¡¹åœ°å€
        uint64_t pte_addr = base + indices[level] * 8;

        // 3.2 å¹¶è¡Œè¯»å–é¡µè¡¨é¡¹ï¼ˆå¦‚æœå¯èƒ½ï¼‰
        if (level < 4) {
            ptw->parallel_buf.pte_addr[level] = pte_addr;
            ptw->parallel_buf.valid[level] = true;
        }

        // 3.3 è¯»å–é¡µè¡¨é¡¹
        uint64_t pte = read_physical_memory(pte_addr);

        // 3.4 æ£€æŸ¥é¡µè¡¨é¡¹
        if (!(pte & PTE_PRESENT)) {
            // é¡µè¡¨é¡¹ä¸å­˜åœ¨ï¼Œè§¦å‘ç¼ºé¡µå¼‚å¸¸
            raise_page_fault(NOT_PRESENT);
            ptw->walks_failed++;
            return false;
        }

        // 3.5 æ£€æŸ¥æƒé™ï¼ˆæœ€åä¸€çº§ï¼‰
        if (level == 3) {
            if (!check_pte_permission(pte, access)) {
                raise_page_fault(PERMISSION_FAULT);
                ptw->walks_failed++;
                return false;
            }
        }

        // 3.6 æå–ä¸‹ä¸€çº§åŸºå€æˆ–ç‰©ç†åœ°å€
        if (level < 3) {
            base = pte & 0xFFFFFFFFFF000;  // ä¸‹ä¸€çº§åŸºå€
        } else {
            // æœ€åä¸€çº§ï¼Œæå–ç‰©ç†åœ°å€
            *paddr = (pte & 0xFFFFFFFFFF000) | indices[4];

            // 4. æ›´æ–°TLB
            tlb_update(mmu->tlb, vaddr, *paddr, pte, mmu->pcid);

            ptw->walks_completed++;
            return true;
        }
    }

    return false;
}
```

**æ·±åº¦è®ºè¯ï¼šç¡¬ä»¶PTWçš„æ€§èƒ½ä¼˜åŠ¿**

**ç¡¬ä»¶PTWçš„å¹¶è¡Œæ¨¡å‹**ï¼š

ç¡¬ä»¶PTWå¯ä»¥**å¹¶è¡Œè®¿é—®**å¤šçº§é¡µè¡¨ï¼š

$$
\text{ç¡¬ä»¶PTWå»¶è¿Ÿ} = t_{\text{ä¸²è¡Œéƒ¨åˆ†}} + \max(t_{\text{å¹¶è¡Œè®¿é—®}}) \approx 30\text{ns}
$$

è€Œè½¯ä»¶éå†éœ€è¦**ä¸²è¡Œè®¿é—®**ï¼š

$$
\text{è½¯ä»¶éå†å»¶è¿Ÿ} = \sum_{i=1}^{d} t_{\text{å†…å­˜è®¿é—®}} = d \times 80\text{ns} = 400\text{ns}
$$

å…¶ä¸­$d$æ˜¯é¡µè¡¨æ·±åº¦ï¼ˆ5çº§ï¼‰ã€‚

**é‡åŒ–å¯¹æ¯”**ï¼šç¡¬ä»¶PTW vs è½¯ä»¶éå†

| **æ–¹å¼** | **å»¶è¿Ÿ** | **CPUå ç”¨** | **å¤æ‚åº¦** |
|---------|---------|-----------|-----------|
| **è½¯ä»¶éå†** | 400ns | é«˜ | ä½ |
| **ç¡¬ä»¶PTW** | 30ns | ä½ | é«˜ |

**å…³é”®æ´å¯Ÿ**ï¼šç¡¬ä»¶PTWå°†é¡µè¡¨éå†å»¶è¿Ÿé™ä½**13å€**ï¼Œæ˜¯ç°ä»£CPUçš„å…³é”®ä¼˜åŒ–ã€‚

---

## 2 é¡µè¡¨å±‚æ¬¡

### 2.1 x86-64äº”çº§é¡µè¡¨

**æ¡ˆä¾‹1.4.3ï¼ˆx86-64é¡µè¡¨å±‚æ¬¡ï¼‰**ï¼š

x86-64ä½¿ç”¨äº”çº§é¡µè¡¨ç»“æ„ï¼Œæ”¯æŒ48ä½è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚

**é¡µè¡¨å±‚æ¬¡ç»“æ„**ï¼š

```text
CR3 (PML4åŸºå€)
  â†“
PML4 (Page Map Level 4) - 9ä½
  â†“
PDPT (Page Directory Pointer Table) - 9ä½
  â†“
PD (Page Directory) - 9ä½
  â†“
PT (Page Table) - 9ä½
  â†“
4KBé¡µ - 12ä½
```

**æ€»ä½æ•°**ï¼š9+9+9+9+12 = 48ä½ï¼ˆè™šæ‹Ÿåœ°å€ï¼‰

**é¡µè¡¨é¡¹ç»“æ„**ï¼š

```c
// é¡µè¡¨é¡¹ï¼ˆPTEï¼‰ç»“æ„
typedef struct {
    uint64_t present:1;        // é¡µæ˜¯å¦åœ¨å†…å­˜ä¸­
    uint64_t writable:1;       // å¯å†™
    uint64_t user:1;           // ç”¨æˆ·å¯è®¿é—®
    uint64_t pwt:1;            // Page Write Through
    uint64_t pcd:1;            // Page Cache Disable
    uint64_t accessed:1;       // å·²è®¿é—®
    uint64_t dirty:1;          // å·²ä¿®æ”¹
    uint64_t page_size:1;      // é¡µå¤§å°ï¼ˆ0=4KB, 1=å¤§é¡µï¼‰
    uint64_t global:1;         // å…¨å±€é¡µ
    uint64_t available:3;      // å¯ç”¨ä½
    uint64_t paddr:40;         // ç‰©ç†åœ°å€ï¼ˆé«˜40ä½ï¼‰
    uint64_t available2:11;    // å¯ç”¨ä½
    uint64_t nx:1;             // No Execute
} pte_t;

// é¡µè¡¨é¡¹è®¿é—®
pte_t read_pte(uint64_t pte_addr) {
    uint64_t pte_value = read_physical_memory(pte_addr);
    return *(pte_t *)&pte_value;
}
```

### 2.2 å¤§é¡µæ”¯æŒ

**æ¡ˆä¾‹1.4.4ï¼ˆå¤§é¡µæ”¯æŒï¼‰**ï¼š

å¤§é¡µï¼ˆHuge Pageï¼‰å¯ä»¥å‡å°‘TLBæœªå‘½ä¸­ï¼Œæé«˜æ€§èƒ½ã€‚

**2MBé¡µ**ï¼š

- **è·³è¿‡PTçº§**ï¼šåœ¨PDçº§ç›´æ¥æ˜ å°„2MBé¡µ
- **å‡å°‘TLBæœªå‘½ä¸­**ï¼šä¸€ä¸ªTLBæ¡ç›®è¦†ç›–2MBåœ°å€ç©ºé—´
- **æé«˜TLBè¦†ç›–ç‡**ï¼šå‡å°‘TLBæ¡ç›®éœ€æ±‚

**1GBé¡µ**ï¼š

- **è·³è¿‡PDå’ŒPTçº§**ï¼šåœ¨PDPTçº§ç›´æ¥æ˜ å°„1GBé¡µ
- **è¿›ä¸€æ­¥å‡å°‘TLBå‹åŠ›**ï¼šä¸€ä¸ªTLBæ¡ç›®è¦†ç›–1GBåœ°å€ç©ºé—´
- **é€‚ç”¨äºå¤§å†…å­˜åº”ç”¨**ï¼šå¦‚æ•°æ®åº“ã€HPC

**å¤§é¡µå®ç°**ï¼š

```c
// å¤§é¡µæ”¯æŒ
bool mmu_translate_huge_page(mmu_t *mmu, uint64_t vaddr, uint64_t *paddr,
                             access_type_t access, int page_size) {
    // 1. æ ¹æ®é¡µå¤§å°ç¡®å®šé¡µè¡¨çº§åˆ«
    int final_level;
    uint64_t page_mask;

    switch (page_size) {
    case 4 * 1024:      // 4KB
        final_level = 3;
        page_mask = 0xFFF;
        break;
    case 2 * 1024 * 1024:  // 2MB
        final_level = 2;
        page_mask = 0x1FFFFF;
        break;
    case 1024 * 1024 * 1024:  // 1GB
        final_level = 1;
        page_mask = 0x3FFFFFFF;
        break;
    default:
        return false;
    }

    // 2. éå†åˆ°æŒ‡å®šçº§åˆ«
    uint64_t base = mmu->cr3;

    for (int level = 0; level <= final_level; level++) {
        // 2.1 è®¡ç®—ç´¢å¼•
        uint64_t index;
        switch (level) {
        case 0: index = (vaddr >> 39) & 0x1FF; break;
        case 1: index = (vaddr >> 30) & 0x1FF; break;
        case 2: index = (vaddr >> 21) & 0x1FF; break;
        case 3: index = (vaddr >> 12) & 0x1FF; break;
        }

        // 2.2 è¯»å–é¡µè¡¨é¡¹
        uint64_t pte_addr = base + index * 8;
        uint64_t pte = read_physical_memory(pte_addr);

        // 2.3 æ£€æŸ¥é¡µè¡¨é¡¹
        if (!(pte & PTE_PRESENT)) {
            raise_page_fault(NOT_PRESENT);
            return false;
        }

        // 2.4 æ£€æŸ¥æ˜¯å¦æ˜¯å¤§é¡µï¼ˆåœ¨PDæˆ–PDPTçº§ï¼‰
        if (level == final_level && (pte & PTE_PAGE_SIZE)) {
            // å¤§é¡µï¼Œç›´æ¥æå–ç‰©ç†åœ°å€
            *paddr = (pte & 0xFFFFFFFFFF000) | (vaddr & page_mask);

            // æ›´æ–°TLBï¼ˆå¤§é¡µæ¡ç›®ï¼‰
            tlb_update_huge(mmu->tlb, vaddr, *paddr, pte, mmu->pcid, page_size);
            return true;
        }

        // 2.5 æå–ä¸‹ä¸€çº§åŸºå€
        base = pte & 0xFFFFFFFFFF000;
    }

    return false;
}
```

---

## 3 TLBç®¡ç†

### 3.1 TLBå±‚æ¬¡çš„ä¸¥æ ¼åˆ†æ

**æ¡ˆä¾‹1.4.5ï¼ˆTLBå±‚æ¬¡ç»“æ„ï¼‰**ï¼š

TLBï¼ˆTranslation Lookaside Bufferï¼‰æ˜¯å¤šçº§ç¼“å­˜ç»“æ„ï¼Œç¼“å­˜è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„è½¬æ¢ã€‚

**Intel Skylake TLBå‚æ•°**ï¼š

- **L1 DTLB**ï¼š64æ¡ç›®ï¼ˆ4KBé¡µï¼‰ï¼Œå»¶è¿Ÿ1å‘¨æœŸ
- **L2 STLB**ï¼š1536æ¡ç›®ï¼ˆç»Ÿä¸€ï¼‰ï¼Œå»¶è¿Ÿ5å‘¨æœŸ
- **L1 ITLB**ï¼š128æ¡ç›®ï¼ˆæŒ‡ä»¤ï¼‰ï¼Œå»¶è¿Ÿ1å‘¨æœŸ

**ARM64 TLBå‚æ•°**ï¼š

- **L1 TLB**ï¼š32-64æ¡ç›®ï¼Œå»¶è¿Ÿ1å‘¨æœŸ
- **L2 TLB**ï¼š512-1024æ¡ç›®ï¼Œå»¶è¿Ÿ3å‘¨æœŸ

**TLBå®ç°**ï¼š

```c
// TLBå®ç°ï¼ˆä¼ªä»£ç ï¼‰
typedef struct {
    // TLBæ¡ç›®
    struct {
        uint64_t vaddr_tag;    // è™šæ‹Ÿåœ°å€æ ‡è®°
        uint64_t paddr;        // ç‰©ç†åœ°å€
        uint16_t pcid;         // Process Context ID
        uint8_t page_size;     // é¡µå¤§å°ï¼ˆ0=4KB, 1=2MB, 2=1GBï¼‰
        bool valid;            // æœ‰æ•ˆä½
        bool global;           // å…¨å±€é¡µ
        uint8_t lru_bits;      // LRUä½
    } entries[TLB_SIZE];

    int size;
    uint64_t hits;
    uint64_t misses;
} tlb_t;

// TLBæŸ¥æ‰¾
tlb_entry_t *tlb_lookup(tlb_t *tlb, uint64_t vaddr, uint16_t pcid) {
    // 1. è®¡ç®—æ ‡è®°ï¼ˆè™šæ‹Ÿåœ°å€é«˜48ä½ï¼‰
    uint64_t tag = vaddr >> 12;

    // 2. å¹¶è¡ŒæŸ¥æ‰¾æ‰€æœ‰æ¡ç›®
    for (int i = 0; i < tlb->size; i++) {
        if (tlb->entries[i].valid &&
            tlb->entries[i].vaddr_tag == tag &&
            (tlb->entries[i].global || tlb->entries[i].pcid == pcid)) {
            // 3. å‘½ä¸­ï¼Œæ›´æ–°LRU
            tlb->hits++;
            update_lru(tlb, i);
            return &tlb->entries[i];
        }
    }

    // 4. æœªå‘½ä¸­
    tlb->misses++;
    return NULL;
}

// TLBæ›´æ–°
void tlb_update(tlb_t *tlb, uint64_t vaddr, uint64_t paddr,
                uint64_t pte, uint16_t pcid) {
    // 1. è®¡ç®—æ ‡è®°
    uint64_t tag = vaddr >> 12;

    // 2. æŸ¥æ‰¾æ›¿æ¢æ¡ç›®ï¼ˆLRUï¼‰
    int replace_idx = find_lru_entry(tlb);

    // 3. æ›´æ–°æ¡ç›®
    tlb->entries[replace_idx].vaddr_tag = tag;
    tlb->entries[replace_idx].paddr = paddr & 0xFFFFFFFFFF000;
    tlb->entries[replace_idx].pcid = pcid;
    tlb->entries[replace_idx].page_size = 0;  // 4KB
    tlb->entries[replace_idx].valid = true;
    tlb->entries[replace_idx].global = (pte & PTE_GLOBAL) != 0;

    // 4. æ›´æ–°LRU
    update_lru(tlb, replace_idx);
}

// PCIDæ”¯æŒï¼ˆé¿å…TLBåˆ·æ–°ï¼‰
void tlb_invalidate_pcid(tlb_t *tlb, uint16_t pcid) {
    // åªä½¿èƒ½æŒ‡å®šPCIDçš„æ¡ç›®å¤±æ•ˆï¼Œä¿ç•™å…¨å±€é¡µ
    for (int i = 0; i < tlb->size; i++) {
        if (tlb->entries[i].valid &&
            !tlb->entries[i].global &&
            tlb->entries[i].pcid == pcid) {
            tlb->entries[i].valid = false;
        }
    }
}
```

### 3.2 TLBæœªå‘½ä¸­æƒ©ç½šçš„ä¸¥æ ¼å»ºæ¨¡

**å®šç†1.8ï¼ˆTLBæœªå‘½ä¸­å»¶è¿Ÿçš„ä¸¥æ ¼åˆ†è§£ï¼‰**ï¼š

å¯¹äºTLBæœªå‘½ä¸­ï¼Œå»¶è¿Ÿæ»¡è¶³ï¼š

$$
L_{\text{TLB miss}} = L_{\text{PTW}} + L_{\text{mem}} \times (d + 1)
$$

å…¶ä¸­ï¼š

- $L_{\text{PTW}}$ï¼šé¡µè¡¨éå†å¼€é”€ï¼ˆ~10å‘¨æœŸï¼‰
- $L_{\text{mem}}$ï¼šå•æ¬¡å†…å­˜è®¿é—®å»¶è¿Ÿï¼ˆ~30nsï¼‰
- $d$ï¼šé¡µè¡¨æ·±åº¦ï¼ˆx86-64ä¸º5çº§ï¼‰

**è¯æ˜**ï¼šé¡µè¡¨éå†éœ€è¦è®¿é—®$d$çº§é¡µè¡¨ï¼Œæ¯çº§ä¸€æ¬¡å†…å­˜è®¿é—®ã€‚å› æ­¤ï¼Œæ€»å»¶è¿Ÿä¸º$L_{\text{PTW}} + d \times L_{\text{mem}}$ã€‚åŠ ä¸Šæœ€ç»ˆé¡µè¡¨é¡¹è®¿é—®ï¼Œæ€»å»¶è¿Ÿä¸º$L_{\text{PTW}} + (d+1) \times L_{\text{mem}}$ã€‚âˆ

**å»¶è¿Ÿåˆ†è§£**ï¼š

- é¡µè¡¨éå†ï¼š8-10å‘¨æœŸï¼ˆç¡¬ä»¶PTWï¼‰
- å†…å­˜è®¿é—®ï¼š~30ns Ã— 5çº§ = 150ns
- **æ€»è®¡**ï¼š~160nsï¼ˆç†è®ºï¼‰vs 30-50nsï¼ˆå®é™…ï¼Œå¹¶è¡Œä¼˜åŒ–ï¼‰

**ä¼˜åŒ–**ï¼š

- **å¤§é¡µå‡å°‘æœªå‘½ä¸­**ï¼š2MBé¡µè¦†ç›–æ›´å¤šåœ°å€ç©ºé—´
- **PCIDé¿å…åˆ·æ–°**ï¼šè¿›ç¨‹åˆ‡æ¢æ—¶ä¿ç•™TLBæ¡ç›®

**æ‰¹åˆ¤æ€§åˆ†æ**ï¼š

1. **TLBå®¹é‡çš„æƒè¡¡**ï¼šæ›´å¤§TLBæé«˜å‘½ä¸­ç‡ï¼Œä½†**å¢åŠ ç¡¬ä»¶å¤æ‚åº¦å’ŒåŠŸè€—**ã€‚

2. **é¡µè¡¨æ·±åº¦çš„ä»£ä»·**ï¼šæ›´æ·±é¡µè¡¨ï¼ˆå¦‚5çº§ï¼‰**å¢åŠ éå†å»¶è¿Ÿ**ï¼Œä½†æ”¯æŒæ›´å¤§åœ°å€ç©ºé—´ã€‚

3. **2025å¹´è¶‹åŠ¿**ï¼š**ç¡¬ä»¶PTWå¹¶è¡Œä¼˜åŒ–**ä½¿å®é™…å»¶è¿Ÿè¿œä½äºç†è®ºå€¼ï¼Œä½†ä»æœ‰ä¼˜åŒ–ç©ºé—´ã€‚

---

## 4 åœ°å€è½¬æ¢æµç¨‹

### 4.1 æ­£å¸¸æµç¨‹

**æ¡ˆä¾‹1.4.6ï¼ˆåœ°å€è½¬æ¢æµç¨‹ï¼‰**ï¼š

åœ°å€è½¬æ¢æ˜¯MMUçš„æ ¸å¿ƒåŠŸèƒ½ï¼Œæ¶‰åŠTLBæŸ¥æ‰¾å’Œé¡µè¡¨éå†ã€‚

**åœ°å€è½¬æ¢æµç¨‹**ï¼š

```text
1. CPUå‘å‡ºè™šæ‹Ÿåœ°å€
2. æ£€æŸ¥L1 TLB
   â”œâ”€ å‘½ä¸­ â†’ ç›´æ¥ä½¿ç”¨ç‰©ç†åœ°å€
   â””â”€ æœªå‘½ä¸­ â†’ ç»§ç»­
3. æ£€æŸ¥L2 TLB
   â”œâ”€ å‘½ä¸­ â†’ æ›´æ–°L1 TLB
   â””â”€ æœªå‘½ä¸­ â†’ ç»§ç»­
4. ç¡¬ä»¶PTWéå†é¡µè¡¨
5. æ›´æ–°TLB
6. è®¿é—®ç‰©ç†å†…å­˜
```

**åœ°å€è½¬æ¢å®ç°**ï¼š

```c
// å®Œæ•´åœ°å€è½¬æ¢æµç¨‹
bool complete_address_translation(mmu_t *mmu, uint64_t vaddr,
                                  uint64_t *paddr, access_type_t access) {
    // 1. æ£€æŸ¥L1 TLB
    tlb_entry_t *entry = tlb_lookup(mmu->tlb_l1, vaddr, mmu->pcid);

    if (entry != NULL) {
        // L1 TLBå‘½ä¸­
        if (check_permission(entry, access)) {
            *paddr = entry->paddr | (vaddr & 0xFFF);
            return true;
        } else {
            raise_page_fault(PERMISSION_FAULT);
            return false;
        }
    }

    // 2. æ£€æŸ¥L2 TLB
    entry = tlb_lookup(mmu->tlb_l2, vaddr, mmu->pcid);

    if (entry != NULL) {
        // L2 TLBå‘½ä¸­ï¼Œæ›´æ–°L1 TLB
        tlb_update(mmu->tlb_l1, vaddr, entry->paddr, entry->pte, mmu->pcid);

        if (check_permission(entry, access)) {
            *paddr = entry->paddr | (vaddr & 0xFFF);
            return true;
        } else {
            raise_page_fault(PERMISSION_FAULT);
            return false;
        }
    }

    // 3. TLBæœªå‘½ä¸­ï¼Œé¡µè¡¨éå†
    uint64_t pte;
    if (mmu_page_walk(mmu, vaddr, paddr, access, &pte)) {
        // 4. æ›´æ–°TLBï¼ˆL1å’ŒL2ï¼‰
        tlb_update(mmu->tlb_l1, vaddr, *paddr, pte, mmu->pcid);
        tlb_update(mmu->tlb_l2, vaddr, *paddr, pte, mmu->pcid);
        return true;
    }

    return false;
}
```

### 4.2 ç¼ºé¡µå¼‚å¸¸

**æ¡ˆä¾‹1.4.7ï¼ˆç¼ºé¡µå¼‚å¸¸å¤„ç†ï¼‰**ï¼š

ç¼ºé¡µå¼‚å¸¸æ˜¯è™šæ‹Ÿå†…å­˜ç³»ç»Ÿçš„å…³é”®æœºåˆ¶ï¼Œç”±OSå¤„ç†ã€‚

**ç¼ºé¡µå¼‚å¸¸è§¦å‘æ¡ä»¶**ï¼š

- **é¡µè¡¨é¡¹ä¸å­˜åœ¨ï¼ˆPresent=0ï¼‰**ï¼šé¡µä¸åœ¨å†…å­˜ä¸­
- **æƒé™ä¸è¶³**ï¼šè®¿é—®æƒé™ä¸åŒ¹é…
- **å†™æ—¶å¤åˆ¶ï¼ˆCOWï¼‰**ï¼šéœ€è¦å¤åˆ¶é¡µ

**ç¼ºé¡µå¼‚å¸¸å¤„ç†æµç¨‹**ï¼š

```c
// ç¼ºé¡µå¼‚å¸¸å¤„ç†ï¼ˆOSä¾§ï¼‰
void handle_page_fault(page_fault_info_t *info) {
    // 1. è·å–è™šæ‹Ÿåœ°å€å’Œé”™è¯¯ç±»å‹
    uint64_t vaddr = info->vaddr;
    fault_type_t type = info->type;

    // 2. æŸ¥æ‰¾VMAï¼ˆVirtual Memory Areaï¼‰
    vma_t *vma = find_vma(current->mm, vaddr);

    if (vma == NULL) {
        // æ— æ•ˆåœ°å€ï¼Œå‘é€SIGSEGV
        send_signal(current, SIGSEGV);
        return;
    }

    // 3. æ£€æŸ¥æƒé™
    if (type == PERMISSION_FAULT) {
        if (!check_vma_permission(vma, info->access)) {
            send_signal(current, SIGSEGV);
            return;
        }
    }

    // 4. åˆ†é…ç‰©ç†é¡µ
    struct page *page = alloc_page(GFP_KERNEL);

    if (page == NULL) {
        // å†…å­˜ä¸è¶³ï¼ŒOOMå¤„ç†
        handle_oom();
        return;
    }

    // 5. å»ºç«‹é¡µè¡¨é¡¹
    pte_t *pte = get_pte(current->mm->pgd, vaddr, true);

    if (pte == NULL) {
        free_page(page);
        return;
    }

    // 6. è®¾ç½®é¡µè¡¨é¡¹
    set_pte(pte, page_to_pfn(page), vma->vm_flags);

    // 7. å¦‚æœæ˜¯å†™æ—¶å¤åˆ¶ï¼Œéœ€è¦å¤åˆ¶é¡µå†…å®¹
    if (vma->vm_flags & VM_COW) {
        copy_page(page, vma->cow_page);
    } else {
        // æ¸…é›¶é¡µ
        clear_page(page_address(page));
    }

    // 8. åˆ·æ–°TLB
    flush_tlb_page(vaddr);
}
```

---

## 5 å®è·µæ¡ˆä¾‹

### 5.1 é«˜æ€§èƒ½åº”ç”¨TLBä¼˜åŒ–

**æ¡ˆä¾‹1.4.8ï¼ˆé«˜æ€§èƒ½åº”ç”¨TLBä¼˜åŒ–ï¼‰**ï¼š

æŸé«˜æ€§èƒ½è®¡ç®—åº”ç”¨ä¼˜åŒ–TLBä½¿ç”¨ï¼Œæé«˜æ€§èƒ½ã€‚

**ä¼˜åŒ–ç­–ç•¥**ï¼š

**1. ä½¿ç”¨å¤§é¡µ**ï¼š

```c
// åˆ†é…2MBå¤§é¡µ
void *allocate_huge_page(size_t size) {
    void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE,
                     MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB,
                     -1, 0);

    if (ptr == MAP_FAILED) {
        // å›é€€åˆ°æ™®é€šé¡µ
        ptr = mmap(NULL, size, PROT_READ | PROT_WRITE,
                   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    }

    return ptr;
}
```

**2. PCIDä¼˜åŒ–**ï¼š

```c
// ä½¿ç”¨PCIDé¿å…TLBåˆ·æ–°
void set_pcid(int pcid) {
    // è®¾ç½®CR4.PCIDE
    uint64_t cr4 = read_cr4();
    cr4 |= CR4_PCIDE;
    write_cr4(cr4);

    // è®¾ç½®CR3.PCID
    uint64_t cr3 = read_cr3();
    cr3 = (cr3 & ~0xFFF) | pcid;
    write_cr3(cr3);
}
```

**ä¼˜åŒ–æ•ˆæœ**ï¼š

| **æŒ‡æ ‡** | **ä¼˜åŒ–å‰** | **ä¼˜åŒ–å** | **æ”¹å–„** |
|---------|-----------|-----------|---------|
| **TLBæœªå‘½ä¸­ç‡** | 5% | 1% | -80% |
| **é¡µè¡¨éå†æ¬¡æ•°** | 1000/s | 200/s | -80% |
| **æ€§èƒ½æå‡** | åŸºå‡† | +15% | æå‡ |

### 5.2 æ•°æ®åº“MMUä¼˜åŒ–

**æ¡ˆä¾‹1.4.9ï¼ˆæ•°æ®åº“MMUä¼˜åŒ–ï¼‰**ï¼š

æŸæ•°æ®åº“ç³»ç»Ÿä¼˜åŒ–MMUä½¿ç”¨ï¼Œæé«˜æŸ¥è¯¢æ€§èƒ½ã€‚

**ä¼˜åŒ–ç­–ç•¥**ï¼š

**1. å¤§é¡µä¼˜åŒ–**ï¼š

```c
// æ•°æ®åº“ç¼“å†²åŒºä½¿ç”¨å¤§é¡µ
void *db_buffer_alloc(size_t size) {
    // ä½¿ç”¨1GBå¤§é¡µ
    void *ptr = mmap(NULL, size, PROT_READ | PROT_WRITE,
                     MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB | MAP_HUGE_1GB,
                     -1, 0);

    return ptr;
}
```

**2. é¡µè¡¨é¢„åŠ è½½**ï¼š

```c
// é¢„åŠ è½½é¡µè¡¨é¡¹
void preload_page_table(uint64_t vaddr, size_t size) {
    for (uint64_t addr = vaddr; addr < vaddr + size; addr += 4096) {
        // è§¦å‘é¡µè¡¨éå†ï¼Œå¡«å……TLB
        volatile char c = *(char *)addr;
        (void)c;  // é¿å…ä¼˜åŒ–
    }
}
```

**ä¼˜åŒ–æ•ˆæœ**ï¼š

| **æŒ‡æ ‡** | **ä¼˜åŒ–å‰** | **ä¼˜åŒ–å** | **æ”¹å–„** |
|---------|-----------|-----------|---------|
| **TLBå‘½ä¸­ç‡** | 85% | 98% | +15% |
| **æŸ¥è¯¢å»¶è¿Ÿ** | 10ms | 8ms | -20% |
| **ååé‡** | 1000 QPS | 1200 QPS | +20% |

## 6 æ€ç»´å¯¼å›¾ï¼šMMU/TLBè®¾è®¡å†³ç­–

```mermaid
mindmap
  root((MMU/TLBè®¾è®¡))
    é¡µè¡¨è®¾è®¡
      é¡µè¡¨æ·±åº¦
        æ›´æ·±æ”¯æŒæ›´å¤§åœ°å€ç©ºé—´
        ä½†éå†å»¶è¿Ÿå¢åŠ 
      é¡µå¤§å°
        æ›´å¤§é¡µå‡å°‘TLBå‹åŠ›
        ä½†å†…å­˜æµªè´¹
      é¡µè¡¨ç»“æ„
        å±‚æ¬¡åŒ–ç®€å•
        ä½†éå†å¼€é”€
    TLBè®¾è®¡
      TLBå®¹é‡
        æ›´å¤§æé«˜å‘½ä¸­ç‡
        ä½†ç¡¬ä»¶å¤æ‚
      TLBå±‚æ¬¡
        L1/L2åˆ†ç¦»
        ä½†ç®¡ç†å¤æ‚
      TLBä¸€è‡´æ€§
        PCIDä¼˜åŒ–
        ä½†ç¡¬ä»¶æ”¯æŒ
    åœ°å€è½¬æ¢
      ç¡¬ä»¶PTW
        è‡ªåŠ¨éå†
        ä½†å»¶è¿Ÿè¾ƒé«˜
      è½¯ä»¶PTW
        çµæ´»æ§åˆ¶
        ä½†å»¶è¿Ÿæ›´é«˜
      å¹¶è¡Œä¼˜åŒ–
        å‡å°‘å»¶è¿Ÿ
        ä½†ç¡¬ä»¶å¤æ‚
```

---

## 7 æ‰¹åˆ¤æ€§æ€»ç»“

### 5.1 MMU/TLBè®¾è®¡çš„æ ¹æœ¬çŸ›ç›¾

1. **åœ°å€ç©ºé—´vsæ€§èƒ½**ï¼šæ›´å¤§åœ°å€ç©ºé—´éœ€è¦æ›´æ·±é¡µè¡¨ï¼Œä½†**å¢åŠ éå†å»¶è¿Ÿ**ã€‚

2. **TLBå®¹é‡vsåŠŸè€—**ï¼šæ›´å¤§TLBæé«˜å‘½ä¸­ç‡ï¼Œä½†**å¢åŠ ç¡¬ä»¶æˆæœ¬å’ŒåŠŸè€—**ã€‚

3. **é€šç”¨æ€§vsä¸“ç”¨æ€§**ï¼šé€šç”¨MMUçµæ´»ï¼Œä½†**æŸäº›åº”ç”¨ï¼ˆå¦‚å®æ—¶ç³»ç»Ÿï¼‰éœ€è¦ä¸“ç”¨è®¾è®¡**ã€‚

### 5.2 2025å¹´MMU/TLBæŠ€æœ¯è¶‹åŠ¿

- **ç¡¬ä»¶åŠ é€ŸPTW**ï¼šæ›´å¿«çš„é¡µè¡¨éå†ï¼Œ**æŒ‘æˆ˜è½¯ä»¶ä¼˜åŒ–**ã€‚
- **å¯å˜é¡µå¤§å°**ï¼šæ ¹æ®å·¥ä½œè´Ÿè½½åŠ¨æ€è°ƒæ•´é¡µå¤§å°ï¼Œ**æå‡æ•ˆç‡**ã€‚
- **å®‰å…¨å¢å¼º**ï¼šå†…å­˜åŠ å¯†ã€å®Œæ•´æ€§ä¿æŠ¤ï¼Œ**å¢åŠ MMUå¤æ‚åº¦**ã€‚

---

## 8 è·¨é¢†åŸŸæ´å¯Ÿ

### 6.1 TLBæœªå‘½ä¸­çš„æ€§èƒ½æƒ©ç½š

**æ ¸å¿ƒå‘½é¢˜**ï¼šTLBæœªå‘½ä¸­å¯¼è‡´é¡µè¡¨éå†ï¼Œå»¶è¿Ÿæ˜¾è‘—å¢åŠ ã€‚

**å»¶è¿Ÿåˆ†è§£**ï¼š

```text
TLBå‘½ä¸­: 1ns (L1 DTLB)
TLBæœªå‘½ä¸­: 30-50ns (é¡µè¡¨éå†)
  - L1 DTLBæŸ¥æ‰¾: 1ns
  - é¡µè¡¨éå†: 20-30ns (5çº§é¡µè¡¨)
  - ç¼“å­˜æœªå‘½ä¸­: 10-20ns
  - TLBæ›´æ–°: 1ns
```

**æ€§èƒ½å½±å“**ï¼šTLBæœªå‘½ä¸­ç‡1%æ—¶ï¼Œå¹³å‡å»¶è¿Ÿå¢åŠ 0.3-0.5nsï¼Œ**æ€§èƒ½ä¸‹é™1-2%**ã€‚

**æ‰¹åˆ¤æ€§åˆ†æ**ï¼š

1. **TLBå®¹é‡çš„é™åˆ¶**ï¼šTLBå®¹é‡æœ‰é™ï¼ˆ64-1536æ¡ç›®ï¼‰ï¼Œ**å¤§å†…å­˜åº”ç”¨æœªå‘½ä¸­ç‡é«˜**ã€‚

2. **å·¨é¡µçš„ä¼˜åŒ–**ï¼šä½¿ç”¨2MB/1GBå·¨é¡µ**å‡å°‘TLBæ¡ç›®æ•°**ï¼Œä½†**å¯èƒ½æµªè´¹å†…å­˜**ã€‚

3. **2025å¹´è¶‹åŠ¿**ï¼š**ç¡¬ä»¶åŠ é€ŸPTW**ï¼ˆå¦‚Intelï¼‰å‡å°‘é¡µè¡¨éå†å»¶è¿Ÿï¼Œä½†**ä»æœ‰ç‰©ç†é™åˆ¶**ã€‚

### 6.2 åœ°å€ç©ºé—´vsæ€§èƒ½çš„æƒè¡¡

**æ ¸å¿ƒçŸ›ç›¾**ï¼šæ›´å¤§åœ°å€ç©ºé—´éœ€è¦æ›´æ·±é¡µè¡¨ï¼Œä½†å¢åŠ éå†å»¶è¿Ÿã€‚

**é‡åŒ–åˆ†æ**ï¼š

| **åœ°å€ç©ºé—´** | **é¡µè¡¨å±‚çº§** | **éå†å»¶è¿Ÿ** | **TLBå®¹é‡éœ€æ±‚** | **é€‚ç”¨åœºæ™¯** |
|------------|------------|------------|---------------|------------|
| **32ä½** | 2çº§ | 10ns | 64æ¡ç›® | åµŒå…¥å¼ |
| **48ä½** | 4çº§ | 30ns | 256æ¡ç›® | é€šç”¨ç³»ç»Ÿ |
| **57ä½** | 5çº§ | 50ns | 1536æ¡ç›® | å¤§å†…å­˜ç³»ç»Ÿ |

**æ‰¹åˆ¤æ€§åˆ†æ**ï¼š

1. **å»¶è¿Ÿçš„å±‚çº§æ€§**ï¼šæ¯å¢åŠ ä¸€çº§é¡µè¡¨ï¼Œ**éå†å»¶è¿Ÿå¢åŠ çº¦10ns**ã€‚

2. **TLBå®¹é‡çš„éœ€æ±‚**ï¼šæ›´å¤§åœ°å€ç©ºé—´éœ€è¦**æ›´å¤šTLBæ¡ç›®**ï¼Œä½†ç¡¬ä»¶æˆæœ¬å¢åŠ ã€‚

3. **2025å¹´è¶‹åŠ¿**ï¼š**å¯å˜é¡µå¤§å°**æ ¹æ®å·¥ä½œè´Ÿè½½åŠ¨æ€è°ƒæ•´ï¼ŒæŒ‘æˆ˜ä¼ ç»Ÿå›ºå®šé¡µå¤§å°ã€‚

---

## 9 å¤šç»´åº¦å¯¹æ¯”

### 7.1 MMUæ¶æ„å¯¹æ¯”ï¼ˆ2025å¹´ï¼‰

| **æ¶æ„** | **é¡µè¡¨å±‚çº§** | **TLBå®¹é‡** | **PTWå»¶è¿Ÿ** | **ç¡¬ä»¶åŠ é€Ÿ** | **ä»£è¡¨å‚å•†** |
|---------|------------|------------|------------|------------|------------|
| **x86-64** | 5çº§ (PML5) | 1536æ¡ç›® | 50ns | Intel PTW | Intel/AMD |
| **ARMv9** | 4çº§ | 1024æ¡ç›® | 30ns | ARM PTW | ARM |
| **RISC-V** | 2-4çº§å¯é… | 64-512æ¡ç›® | 10-30ns | å¯é€‰ | RISC-V |

**æ‰¹åˆ¤æ€§åˆ†æ**ï¼š

1. **æ¶æ„çš„å·®å¼‚**ï¼šx86-64æ”¯æŒæ›´å¤§åœ°å€ç©ºé—´ï¼Œä½†**å»¶è¿Ÿæ›´é«˜**ï¼›RISC-Vçµæ´»ï¼Œä½†**ç”Ÿæ€è¾ƒå¼±**ã€‚

2. **ç¡¬ä»¶åŠ é€Ÿçš„é‡è¦æ€§**ï¼šç¡¬ä»¶PTW**æ˜¾è‘—å‡å°‘å»¶è¿Ÿ**ï¼Œä½†å¢åŠ ç¡¬ä»¶å¤æ‚åº¦ã€‚

3. **2025å¹´è¶‹åŠ¿**ï¼š**ç»Ÿä¸€MMUæ¶æ„**ï¼ˆå¦‚CXLï¼‰å¯èƒ½æŒ‘æˆ˜ä¼ ç»Ÿè¾¹ç•Œã€‚

### 7.2 TLBç®¡ç†ç­–ç•¥å¯¹æ¯”

| **ç­–ç•¥** | **å‘½ä¸­ç‡** | **å»¶è¿Ÿ** | **å¤æ‚åº¦** | **é€‚ç”¨åœºæ™¯** |
|---------|-----------|---------|-----------|------------|
| **å›ºå®šå¤§å°** | ä¸­ | ä½ | â­ | ç®€å•ç³»ç»Ÿ |
| **å¤šçº§TLB** | é«˜ | ä½ | â­â­â­ | é€šç”¨ç³»ç»Ÿ |
| **PCIDä¼˜åŒ–** | é«˜ | ä½ | â­â­â­ | å¤šè¿›ç¨‹ç³»ç»Ÿ |
| **å·¨é¡µä¼˜åŒ–** | é«˜ | ä½ | â­â­ | å¤§å†…å­˜åº”ç”¨ |

**æ‰¹åˆ¤æ€§åˆ†æ**ï¼š

1. **å‘½ä¸­ç‡vså¤æ‚åº¦**ï¼šå¤šçº§TLBå‘½ä¸­ç‡é«˜ï¼Œä½†**å®ç°å¤æ‚**ï¼›å›ºå®šå¤§å°ç®€å•ï¼Œä½†**å‘½ä¸­ç‡ä½**ã€‚

2. **PCIDçš„å¿…è¦æ€§**ï¼šPCIDé¿å…TLBåˆ·æ–°ï¼Œ**æ€§èƒ½æå‡æ˜æ˜¾**ï¼Œä½†éœ€è¦ç¡¬ä»¶æ”¯æŒã€‚

3. **2025å¹´è¶‹åŠ¿**ï¼š**è‡ªé€‚åº”TLBç®¡ç†**æ ¹æ®å·¥ä½œè´Ÿè½½åŠ¨æ€è°ƒæ•´ï¼ŒæŒ‘æˆ˜é™æ€è®¾è®¡ã€‚

---

## 10 ç›¸å…³ä¸»é¢˜

- [1.3 å†…å­˜å­ç³»ç»Ÿ](./01.3_å†…å­˜å­ç³»ç»Ÿ.md) - å†…å­˜ä¸MMUååŒ
- [3.2 å†…å­˜ç®¡ç†æ¨¡å‹](../03_OSæŠ½è±¡å±‚/03.2_å†…å­˜ç®¡ç†æ¨¡å‹.md) - OSé¡µè¡¨ç®¡ç†
- [7.2 å»¶è¿Ÿç©¿é€åˆ†æ](../07_æ€§èƒ½ä¼˜åŒ–ä¸å®‰å…¨/07.2_å»¶è¿Ÿç©¿é€åˆ†æ.md) - TLBå»¶è¿Ÿä¼˜åŒ–
- [9.2 ç¡¬ä»¶-OSæ˜ å°„è¯æ˜](../09_å½¢å¼åŒ–ç†è®ºä¸è¯æ˜/09.2_ç¡¬ä»¶-OSæ˜ å°„è¯æ˜.md) - MMUå½¢å¼åŒ–
- [ä¸»æ–‡æ¡£ï¼šTLBåˆ†æ](../schedule_formal_view.md#çŸ¥è¯†å›¾è°±æ¦‚å¿µå…³ç³»é“¾) - å®Œæ•´åˆ†æ

---

**æœ€åæ›´æ–°**: 2025-01-XX
