# 3.6 eBPFè°ƒåº¦æ‰©å±•

> **å­ä¸»é¢˜ç¼–å·**: 03.6
> **ä¸»é¢˜**: OSæŠ½è±¡å±‚
> **æœ€åæ›´æ–°**: 2025-12-02
> **æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ

---

## ğŸ“‹ ç›®å½•

- [1 æ¦‚è¿°](#1-æ¦‚è¿°)
- [2 æ€ç»´å¯¼å›¾](#2-æ€ç»´å¯¼å›¾)
- [3 sched_extæ¡†æ¶](#3-sched_extæ¡†æ¶)
- [4 BPFè°ƒåº¦å™¨å®ç°](#4-bpfè°ƒåº¦å™¨å®ç°)
- [5 å¯è§‚æµ‹æ€§è°ƒåº¦](#5-å¯è§‚æµ‹æ€§è°ƒåº¦)
- [6 çŸ¥è¯†çŸ©é˜µ](#6-çŸ¥è¯†çŸ©é˜µ)
- [7 å®è·µæ¡ˆä¾‹](#7-å®è·µæ¡ˆä¾‹)
- [8 è·¨è§†è§’é“¾æ¥](#8-è·¨è§†è§’é“¾æ¥)

---

## 1 æ¦‚è¿°

### 1.1 æ ¸å¿ƒæ´å¯Ÿ

eBPFï¼ˆExtended Berkeley Packet Filterï¼‰å·²ä»ç½‘ç»œåŒ…è¿‡æ»¤å‘å±•ä¸ºé€šç”¨çš„å†…æ ¸å¯ç¼–ç¨‹æ¡†æ¶ã€‚åœ¨è°ƒåº¦é¢†åŸŸï¼ŒeBPFå¸¦æ¥äº†é©å‘½æ€§çš„å˜åŒ–ï¼š**ç”¨æˆ·ç©ºé—´å¯ä»¥å®‰å…¨åœ°æ‰©å±•å’Œå®šåˆ¶å†…æ ¸è°ƒåº¦è¡Œä¸º**ã€‚

### 1.2 eBPFè°ƒåº¦ç‰¹æ€§

| ç‰¹æ€§ | æè¿° | è°ƒåº¦åº”ç”¨ |
|------|------|---------|
| **å®‰å…¨æ€§** | éªŒè¯å™¨ä¿è¯ç¨‹åºå®‰å…¨ | å®‰å…¨çš„è°ƒåº¦æ‰©å±• |
| **é«˜æ€§èƒ½** | JITç¼–è¯‘ï¼Œæ¥è¿‘åŸç”Ÿæ€§èƒ½ | ä½å¼€é”€è°ƒåº¦ |
| **åŠ¨æ€æ€§** | è¿è¡Œæ—¶åŠ è½½/å¸è½½ | åŠ¨æ€è°ƒåº¦ç­–ç•¥ |
| **å¯è§‚æµ‹æ€§** | ä¸°å¯Œçš„è¿½è¸ªèƒ½åŠ› | è°ƒåº¦åˆ†æä¼˜åŒ– |
| **å¯ç§»æ¤æ€§** | CO-REè·¨å†…æ ¸ç‰ˆæœ¬ | é€šç”¨è°ƒåº¦å™¨ |

---

## 2 æ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((eBPFè°ƒåº¦æ‰©å±•))
    sched_ext
      å¯æ‰©å±•è°ƒåº¦ç±»
        ç”¨æˆ·å®šä¹‰ç­–ç•¥
        åŠ¨æ€åŠ è½½
      æ ¸å¿ƒå›è°ƒ
        ops.select_cpu
        ops.enqueue
        ops.dispatch
      å®‰å…¨ä¿è¯
        éªŒè¯å™¨æ£€æŸ¥
        èµ„æºé™åˆ¶
    BPFè°ƒåº¦å™¨
      FIFOè°ƒåº¦å™¨
      ä¼˜å…ˆçº§è°ƒåº¦
      NUMAæ„ŸçŸ¥
      è´Ÿè½½å‡è¡¡
    å¯è§‚æµ‹æ€§
      è°ƒåº¦è¿½è¸ª
        sched_switch
        sched_wakeup
      æ€§èƒ½åˆ†æ
        å»¶è¿Ÿåˆ†å¸ƒ
        CPUåˆ©ç”¨ç‡
      å¯è§†åŒ–
        ç«ç„°å›¾
        çƒ­åŠ›å›¾
    LSMè°ƒåº¦å®‰å…¨
      è®¿é—®æ§åˆ¶
      èµ„æºéš”ç¦»
      å®¡è®¡æ—¥å¿—
```

---

## 3 sched_extæ¡†æ¶

### 3.1 sched_extæ¶æ„

```mermaid
graph TB
    subgraph "ç”¨æˆ·ç©ºé—´"
        UP[BPFè°ƒåº¦å™¨ç¨‹åº]
        UC[æ§åˆ¶ç¨‹åº]
    end

    subgraph "å†…æ ¸ç©ºé—´"
        subgraph "sched_ext"
            SE[sched_extè°ƒåº¦ç±»]
            OPS[BPF opså›è°ƒ]
            DSQ[è°ƒåº¦é˜Ÿåˆ—DSQ]
        end

        CFS[CFSè°ƒåº¦ç±»]
        RT[RTè°ƒåº¦ç±»]
    end

    UP -->|åŠ è½½| SE
    UC -->|æ§åˆ¶| UP
    SE --> OPS
    OPS --> DSQ
    SE -.->|å›é€€| CFS
```

### 3.2 æ ¸å¿ƒå›è°ƒå‡½æ•°

```c
/*
 * sched_ext BPFè°ƒåº¦å™¨æ“ä½œç»“æ„
 */
struct sched_ext_ops {
    /* é€‰æ‹©è¿è¡ŒCPU */
    s32 (*select_cpu)(struct task_struct *p, s32 prev_cpu, u64 wake_flags);

    /* å…¥é˜Ÿå›è°ƒ */
    void (*enqueue)(struct task_struct *p, u64 enq_flags);

    /* å‡ºé˜Ÿå›è°ƒ */
    void (*dequeue)(struct task_struct *p, u64 deq_flags);

    /* è°ƒåº¦åˆ†å‘ */
    void (*dispatch)(s32 cpu, struct task_struct *prev);

    /* è¿è¡Œä¸­å›è°ƒ */
    void (*running)(struct task_struct *p);

    /* åœæ­¢è¿è¡Œå›è°ƒ */
    void (*stopping)(struct task_struct *p, bool runnable);

    /* æ—¶é—´ç‰‡è€—å°½ */
    void (*tick)(struct task_struct *p);

    /* ä»»åŠ¡åˆ›å»º */
    s32 (*init_task)(struct task_struct *p, struct scx_init_task_args *args);

    /* ä»»åŠ¡é€€å‡º */
    void (*exit_task)(struct task_struct *p, struct scx_exit_task_args *args);

    /* è°ƒåº¦å™¨åˆå§‹åŒ– */
    s32 (*init)(void);

    /* è°ƒåº¦å™¨é€€å‡º */
    void (*exit)(struct scx_exit_info *info);

    /* è°ƒåº¦å™¨åç§° */
    char name[SCX_OPS_NAME_LEN];

    /* è¶…æ—¶æ—¶é—´(ns) */
    u64 timeout_ms;

    /* è°ƒåº¦ç±»flags */
    u64 flags;
};
```

### 3.3 è°ƒåº¦é˜Ÿåˆ—(DSQ)

```text
DSQ (Dispatch Queue) æ¶æ„:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å…¨å±€DSQ                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚Task1â”‚â†’â”‚Task2â”‚â†’â”‚Task3â”‚â†’â”‚Task4â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â†“               â†“               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”
â”‚CPU 0  â”‚       â”‚CPU 1  â”‚       â”‚CPU N  â”‚
â”‚ DSQ   â”‚       â”‚ DSQ   â”‚       â”‚ DSQ   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”˜

æ“ä½œ:
- scx_bpf_dispatch(): å°†ä»»åŠ¡æ”¾å…¥DSQ
- scx_bpf_consume(): ä»DSQè·å–ä»»åŠ¡
- scx_bpf_dispatch_vtime(): VTIMEæ’åºåˆ†å‘
```

---

## 4 BPFè°ƒåº¦å™¨å®ç°

### 4.1 ç®€å•FIFOè°ƒåº¦å™¨

```c
// simple_fifo.bpf.c - ç®€å•FIFOè°ƒåº¦å™¨
#include <scx/common.bpf.h>

char _license[] SEC("license") = "GPL";

/* å…¨å±€FIFOé˜Ÿåˆ— */
#define SHARED_DSQ 0

/* é€‰æ‹©CPU - ä½¿ç”¨ä¹‹å‰çš„CPU */
s32 BPF_STRUCT_OPS(fifo_select_cpu, struct task_struct *p,
                   s32 prev_cpu, u64 wake_flags)
{
    return prev_cpu;
}

/* å…¥é˜Ÿ - æ”¾å…¥å…±äº«é˜Ÿåˆ— */
void BPF_STRUCT_OPS(fifo_enqueue, struct task_struct *p, u64 enq_flags)
{
    scx_bpf_dispatch(p, SHARED_DSQ, SCX_SLICE_DFL, enq_flags);
}

/* è°ƒåº¦åˆ†å‘ - ä»å…±äº«é˜Ÿåˆ—è·å– */
void BPF_STRUCT_OPS(fifo_dispatch, s32 cpu, struct task_struct *prev)
{
    scx_bpf_consume(SHARED_DSQ);
}

/* åˆå§‹åŒ– */
s32 BPF_STRUCT_OPS_SLEEPABLE(fifo_init)
{
    return scx_bpf_create_dsq(SHARED_DSQ, -1);
}

/* è°ƒåº¦å™¨opså®šä¹‰ */
SCX_OPS_DEFINE(fifo_ops,
    .select_cpu     = (void *)fifo_select_cpu,
    .enqueue        = (void *)fifo_enqueue,
    .dispatch       = (void *)fifo_dispatch,
    .init           = (void *)fifo_init,
    .name           = "fifo");
```

### 4.2 ä¼˜å…ˆçº§è°ƒåº¦å™¨

```c
// priority.bpf.c - ä¼˜å…ˆçº§è°ƒåº¦å™¨
#include <scx/common.bpf.h>

char _license[] SEC("license") = "GPL";

/* ä¼˜å…ˆçº§é˜Ÿåˆ— */
#define HIGH_PRIO_DSQ   0
#define NORMAL_PRIO_DSQ 1
#define LOW_PRIO_DSQ    2

/* ä»»åŠ¡ä¼˜å…ˆçº§æ˜ å°„ */
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __type(key, pid_t);
    __type(value, u32);  /* ä¼˜å…ˆçº§: 0=high, 1=normal, 2=low */
    __uint(max_entries, 10000);
} task_priority SEC(".maps");

/* è·å–ä»»åŠ¡ä¼˜å…ˆçº§ */
static u32 get_priority(struct task_struct *p)
{
    u32 *prio = bpf_map_lookup_elem(&task_priority, &p->pid);
    return prio ? *prio : NORMAL_PRIO_DSQ;
}

/* å…¥é˜Ÿ - æŒ‰ä¼˜å…ˆçº§åˆ†å‘ */
void BPF_STRUCT_OPS(prio_enqueue, struct task_struct *p, u64 enq_flags)
{
    u32 prio = get_priority(p);
    scx_bpf_dispatch(p, prio, SCX_SLICE_DFL, enq_flags);
}

/* è°ƒåº¦åˆ†å‘ - ä¼˜å…ˆé«˜ä¼˜å…ˆçº§é˜Ÿåˆ— */
void BPF_STRUCT_OPS(prio_dispatch, s32 cpu, struct task_struct *prev)
{
    if (scx_bpf_consume(HIGH_PRIO_DSQ))
        return;
    if (scx_bpf_consume(NORMAL_PRIO_DSQ))
        return;
    scx_bpf_consume(LOW_PRIO_DSQ);
}

s32 BPF_STRUCT_OPS_SLEEPABLE(prio_init)
{
    s32 ret;
    ret = scx_bpf_create_dsq(HIGH_PRIO_DSQ, -1);
    if (ret) return ret;
    ret = scx_bpf_create_dsq(NORMAL_PRIO_DSQ, -1);
    if (ret) return ret;
    return scx_bpf_create_dsq(LOW_PRIO_DSQ, -1);
}

SCX_OPS_DEFINE(prio_ops,
    .enqueue    = (void *)prio_enqueue,
    .dispatch   = (void *)prio_dispatch,
    .init       = (void *)prio_init,
    .name       = "priority");
```

### 4.3 NUMAæ„ŸçŸ¥è°ƒåº¦å™¨

```c
// numa_aware.bpf.c - NUMAæ„ŸçŸ¥è°ƒåº¦å™¨
#include <scx/common.bpf.h>

char _license[] SEC("license") = "GPL";

/* æ¯NUMAèŠ‚ç‚¹DSQ */
#define MAX_NUMA_NODES 8
#define NUMA_DSQ_BASE 100

/* NUMAæ‹“æ‰‘ä¿¡æ¯ */
struct numa_info {
    u32 node_id;
    u32 cpu_mask;
};

struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __type(key, u32);
    __type(value, struct numa_info);
    __uint(max_entries, MAX_CPUS);
} cpu_numa_map SEC(".maps");

/* è·å–CPUçš„NUMAèŠ‚ç‚¹ */
static u32 get_numa_node(s32 cpu)
{
    struct numa_info *info = bpf_map_lookup_elem(&cpu_numa_map, &cpu);
    return info ? info->node_id : 0;
}

/* é€‰æ‹©CPU - NUMAäº²å’Œæ€§ */
s32 BPF_STRUCT_OPS(numa_select_cpu, struct task_struct *p,
                   s32 prev_cpu, u64 wake_flags)
{
    u32 prev_node = get_numa_node(prev_cpu);

    /* ä¼˜å…ˆé€‰æ‹©åŒNUMAèŠ‚ç‚¹çš„CPU */
    bpf_for(cpu, 0, nr_cpus) {
        if (get_numa_node(cpu) == prev_node &&
            scx_bpf_cpumask_test_cpu(cpu, p->cpus_ptr)) {
            return cpu;
        }
    }

    return prev_cpu;
}

/* å…¥é˜Ÿ - æŒ‰NUMAèŠ‚ç‚¹åˆ†å‘ */
void BPF_STRUCT_OPS(numa_enqueue, struct task_struct *p, u64 enq_flags)
{
    u32 node = get_numa_node(scx_bpf_task_cpu(p));
    u64 dsq_id = NUMA_DSQ_BASE + node;
    scx_bpf_dispatch(p, dsq_id, SCX_SLICE_DFL, enq_flags);
}

/* è°ƒåº¦åˆ†å‘ - ä¼˜å…ˆæœ¬åœ°NUMAé˜Ÿåˆ— */
void BPF_STRUCT_OPS(numa_dispatch, s32 cpu, struct task_struct *prev)
{
    u32 local_node = get_numa_node(cpu);
    u64 local_dsq = NUMA_DSQ_BASE + local_node;

    /* å…ˆå°è¯•æœ¬åœ°é˜Ÿåˆ— */
    if (scx_bpf_consume(local_dsq))
        return;

    /* éå†å…¶ä»–NUMAèŠ‚ç‚¹ */
    bpf_for(node, 0, MAX_NUMA_NODES) {
        if (node != local_node) {
            if (scx_bpf_consume(NUMA_DSQ_BASE + node))
                return;
        }
    }
}

SCX_OPS_DEFINE(numa_ops,
    .select_cpu = (void *)numa_select_cpu,
    .enqueue    = (void *)numa_enqueue,
    .dispatch   = (void *)numa_dispatch,
    .name       = "numa_aware");
```

---

## 5 å¯è§‚æµ‹æ€§è°ƒåº¦

### 5.1 è°ƒåº¦è¿½è¸ª

```c
// sched_trace.bpf.c - è°ƒåº¦è¿½è¸ª
#include <vmlinux.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>

/* è°ƒåº¦äº‹ä»¶ç»“æ„ */
struct sched_event {
    u64 timestamp;
    u32 prev_pid;
    u32 next_pid;
    u32 cpu;
    u64 prev_runtime;
    char prev_comm[16];
    char next_comm[16];
};

/* äº‹ä»¶ç¯å½¢ç¼“å†²åŒº */
struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 256 * 1024);
} events SEC(".maps");

/* è°ƒåº¦åˆ‡æ¢è¿½è¸ªç‚¹ */
SEC("tp/sched/sched_switch")
int trace_sched_switch(struct trace_event_raw_sched_switch *ctx)
{
    struct sched_event *e;

    e = bpf_ringbuf_reserve(&events, sizeof(*e), 0);
    if (!e)
        return 0;

    e->timestamp = bpf_ktime_get_ns();
    e->prev_pid = ctx->prev_pid;
    e->next_pid = ctx->next_pid;
    e->cpu = bpf_get_smp_processor_id();

    bpf_probe_read_kernel_str(e->prev_comm, sizeof(e->prev_comm), ctx->prev_comm);
    bpf_probe_read_kernel_str(e->next_comm, sizeof(e->next_comm), ctx->next_comm);

    bpf_ringbuf_submit(e, 0);
    return 0;
}

/* å”¤é†’è¿½è¸ªç‚¹ */
SEC("tp/sched/sched_wakeup")
int trace_sched_wakeup(struct trace_event_raw_sched_wakeup *ctx)
{
    // è®°å½•å”¤é†’å»¶è¿Ÿ
    return 0;
}

char LICENSE[] SEC("license") = "GPL";
```

### 5.2 è°ƒåº¦å»¶è¿Ÿåˆ†æ

```c
// sched_latency.bpf.c - è°ƒåº¦å»¶è¿Ÿåˆ†æ
#include <vmlinux.h>
#include <bpf/bpf_helpers.h>

/* å»¶è¿Ÿç›´æ–¹å›¾ */
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __type(key, u32);  /* å»¶è¿Ÿæ¡¶ (log2) */
    __type(value, u64);  /* è®¡æ•° */
    __uint(max_entries, 64);
} latency_hist SEC(".maps");

/* ä»»åŠ¡å”¤é†’æ—¶é—´è®°å½• */
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __type(key, u32);  /* pid */
    __type(value, u64);  /* å”¤é†’æ—¶é—´ */
    __uint(max_entries, 10000);
} wakeup_times SEC(".maps");

SEC("tp/sched/sched_wakeup")
int trace_wakeup(struct trace_event_raw_sched_wakeup *ctx)
{
    u64 ts = bpf_ktime_get_ns();
    u32 pid = ctx->pid;
    bpf_map_update_elem(&wakeup_times, &pid, &ts, BPF_ANY);
    return 0;
}

SEC("tp/sched/sched_switch")
int trace_switch(struct trace_event_raw_sched_switch *ctx)
{
    u32 pid = ctx->next_pid;
    u64 *wakeup_ts = bpf_map_lookup_elem(&wakeup_times, &pid);

    if (wakeup_ts) {
        u64 now = bpf_ktime_get_ns();
        u64 latency = now - *wakeup_ts;

        /* è®¡ç®—log2æ¡¶ */
        u32 bucket = 0;
        u64 temp = latency;
        while (temp > 1) {
            temp >>= 1;
            bucket++;
        }

        /* æ›´æ–°ç›´æ–¹å›¾ */
        u64 *count = bpf_map_lookup_elem(&latency_hist, &bucket);
        if (count) {
            __sync_fetch_and_add(count, 1);
        } else {
            u64 init = 1;
            bpf_map_update_elem(&latency_hist, &bucket, &init, BPF_ANY);
        }

        bpf_map_delete_elem(&wakeup_times, &pid);
    }

    return 0;
}

char LICENSE[] SEC("license") = "GPL";
```

---

## 6 çŸ¥è¯†çŸ©é˜µ

### 6.1 eBPFè°ƒåº¦æŠ€æœ¯å¯¹æ¯”

| æŠ€æœ¯ | é€‚ç”¨åœºæ™¯ | å¤æ‚åº¦ | æ€§èƒ½å¼€é”€ |
|------|---------|-------|---------|
| **sched_ext** | è‡ªå®šä¹‰è°ƒåº¦ç­–ç•¥ | é«˜ | ä½ |
| **è°ƒåº¦è¿½è¸ª** | æ€§èƒ½åˆ†æ | ä½ | ä¸­ |
| **LSMè°ƒåº¦** | å®‰å…¨ç­–ç•¥ | ä¸­ | ä½ |
| **cgroupè°ƒåº¦** | èµ„æºéš”ç¦» | ä¸­ | ä½ |

### 6.2 è°ƒåº¦å™¨å®ç°å¯¹æ¯”

| è°ƒåº¦å™¨ | ç­–ç•¥ | é€‚ç”¨åœºæ™¯ | å¤æ‚åº¦ |
|-------|------|---------|-------|
| **FIFO** | å…ˆè¿›å…ˆå‡º | ç®€å•ä»»åŠ¡ | ä½ |
| **ä¼˜å…ˆçº§** | ä¼˜å…ˆçº§é˜Ÿåˆ— | å·®å¼‚åŒ–æœåŠ¡ | ä¸­ |
| **NUMAæ„ŸçŸ¥** | NUMAäº²å’Œ | å¤§å†…å­˜ç³»ç»Ÿ | é«˜ |
| **è´Ÿè½½å‡è¡¡** | åŠ¨æ€è¿ç§» | å¤šæ ¸ç³»ç»Ÿ | é«˜ |

---

## 7 å®è·µæ¡ˆä¾‹

### 7.1 Google ghOSt

```text
ghOSt (Google Host):
- ç”¨æˆ·ç©ºé—´è°ƒåº¦æ¡†æ¶
- åŸºäºsched_ext
- æ”¯æŒå¤æ‚è°ƒåº¦ç­–ç•¥
- Googleæ•°æ®ä¸­å¿ƒä½¿ç”¨

æ¶æ„:
  ç”¨æˆ·ç©ºé—´Agent â†’ sched_ext â†’ å†…æ ¸è°ƒåº¦

ç‰¹ç‚¹:
- å¾®ç§’çº§è°ƒåº¦å†³ç­–
- æ”¯æŒæœºå™¨å­¦ä¹ è°ƒåº¦
- åŠ¨æ€ç­–ç•¥æ›´æ–°
```

### 7.2 Meta sched_extè°ƒåº¦å™¨

```text
Metaçš„sched_extä½¿ç”¨:
- scx_rusty: Rustå®ç°çš„è´Ÿè½½å‡è¡¡è°ƒåº¦å™¨
- scx_lavd: ä½å»¶è¿ŸéŸ³è§†é¢‘è°ƒåº¦å™¨
- scx_layered: åˆ†å±‚è°ƒåº¦ç­–ç•¥

ä½¿ç”¨æ–¹å¼:
$ sudo scx_rusty  # å¯åŠ¨Rustè°ƒåº¦å™¨
$ sudo scx_lavd   # å¯åŠ¨ä½å»¶è¿Ÿè°ƒåº¦å™¨
```

---

## 8 è·¨è§†è§’é“¾æ¥

### 8.1 è°ƒåº¦è§†è§’å…³è”

- [è¿›ç¨‹è°ƒåº¦æ¨¡å‹](./03.1_è¿›ç¨‹è°ƒåº¦æ¨¡å‹.md) - åŸºç¡€è°ƒåº¦
- [Linuxè°ƒåº¦è§†è§’](./03.0_Linuxè°ƒåº¦è§†è§’å…¨é¢åˆ†æ.md) - Linuxè°ƒåº¦
- [AIé©±åŠ¨è°ƒåº¦](../10_AIé©±åŠ¨è°ƒåº¦/) - æ™ºèƒ½è°ƒåº¦

### 8.2 å½¢å¼è¯­è¨€è§†è§’å…³è”

| å½¢å¼è¯­è¨€æ¦‚å¿µ | eBPFè°ƒåº¦å¯¹åº” | æ˜ å°„è¯´æ˜ |
|------------|-------------|---------|
| **ç±»å‹å®‰å…¨** | éªŒè¯å™¨æ£€æŸ¥ | ç¨‹åºå®‰å…¨ä¿è¯ |
| **æ•ˆåº”ç³»ç»Ÿ** | è¾…åŠ©å‡½æ•° | å‰¯ä½œç”¨æ§åˆ¶ |
| **æ¨¡å—ç³»ç»Ÿ** | BPFç¨‹åºæ¨¡å— | ä»£ç ç»„ç»‡ |

---

**è¿”å›**: [OSæŠ½è±¡å±‚ä¸»ç´¢å¼•](./README.md) | [è°ƒåº¦è§†è§’ä¸»ç´¢å¼•](../README.md)
