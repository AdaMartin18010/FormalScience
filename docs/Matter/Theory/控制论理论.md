# æ§åˆ¶è®ºç†è®º (Control Theory)

## ğŸ“‹ ç›®å½•

- [1 æ¦‚è¿°](#1-æ¦‚è¿°)
- [2 åŸºç¡€æ¦‚å¿µ](#2-åŸºç¡€æ¦‚å¿µ)
  - [2.1 ç³»ç»Ÿå»ºæ¨¡](#21-ç³»ç»Ÿå»ºæ¨¡)
  - [2.2 ç³»ç»Ÿç‰¹æ€§åˆ†æ](#22-ç³»ç»Ÿç‰¹æ€§åˆ†æ)
- [3 æ§åˆ¶å™¨è®¾è®¡](#3-æ§åˆ¶å™¨è®¾è®¡)
  - [3.1 çŠ¶æ€åé¦ˆæ§åˆ¶](#31-çŠ¶æ€åé¦ˆæ§åˆ¶)
  - [3.2 è¾“å‡ºåé¦ˆæ§åˆ¶](#32-è¾“å‡ºåé¦ˆæ§åˆ¶)
  - [3.3 è‡ªé€‚åº”æ§åˆ¶](#33-è‡ªé€‚åº”æ§åˆ¶)
- [4 é²æ£’æ§åˆ¶](#4-é²æ£’æ§åˆ¶)
  - [4.1 Hæ§åˆ¶](#41-hæ§åˆ¶)
  - [4.2 Î¼ç»¼åˆ](#42-Î¼ç»¼åˆ)
- [5 éçº¿æ€§æ§åˆ¶](#5-éçº¿æ€§æ§åˆ¶)
  - [5.1 åé¦ˆçº¿æ€§åŒ–](#51-åé¦ˆçº¿æ€§åŒ–)
  - [5.2 æ»‘æ¨¡æ§åˆ¶](#52-æ»‘æ¨¡æ§åˆ¶)
- [6 æ™ºèƒ½æ§åˆ¶](#6-æ™ºèƒ½æ§åˆ¶)
  - [6.1 æ¨¡ç³Šæ§åˆ¶](#61-æ¨¡ç³Šæ§åˆ¶)
  - [6.2 ç¥ç»ç½‘ç»œæ§åˆ¶](#62-ç¥ç»ç½‘ç»œæ§åˆ¶)
- [7 åº”ç”¨é¢†åŸŸ](#7-åº”ç”¨é¢†åŸŸ)
  - [7.1 å·¥ä¸šæ§åˆ¶](#71-å·¥ä¸šæ§åˆ¶)
  - [7.2 æœºå™¨äººæ§åˆ¶](#72-æœºå™¨äººæ§åˆ¶)
- [8 æ€»ç»“](#8-æ€»ç»“)

---

## 1 æ¦‚è¿°

æ§åˆ¶è®ºæ˜¯ç ”ç©¶åŠ¨æ€ç³»ç»Ÿè¡Œä¸ºè°ƒèŠ‚å’Œä¼˜åŒ–çš„æ•°å­¦ç†è®ºï¼Œå¹¿æ³›åº”ç”¨äºå·¥ç¨‹ã€ç”Ÿç‰©å­¦ã€ç»æµå­¦å’Œç¤¾ä¼šç§‘å­¦ç­‰é¢†åŸŸã€‚æ§åˆ¶è®ºçš„æ ¸å¿ƒç›®æ ‡æ˜¯è®¾è®¡æ§åˆ¶å™¨ï¼Œä½¿ç³»ç»ŸæŒ‰ç…§æœŸæœ›çš„æ–¹å¼è¿è¡Œã€‚

## 2 åŸºç¡€æ¦‚å¿µ

### 2.1 ç³»ç»Ÿå»ºæ¨¡

**å®šä¹‰**ï¼š
ç³»ç»Ÿå»ºæ¨¡æ˜¯æ§åˆ¶è®ºçš„åŸºç¡€ï¼Œå°†å®é™…ç³»ç»ŸæŠ½è±¡ä¸ºæ•°å­¦æè¿°ã€‚

**è¿ç»­æ—¶é—´ç³»ç»Ÿ**ï¼š

```rust
#[derive(Clone, Debug)]
struct ContinuousSystem {
    state_dimension: usize,
    input_dimension: usize,
    output_dimension: usize,
    state_equation: StateEquation,
    output_equation: OutputEquation
}

#[derive(Clone, Debug)]
struct StateEquation {
    function: Box<dyn Fn(&Vector, &Vector, f64) -> Vector>
}

#[derive(Clone, Debug)]
struct OutputEquation {
    function: Box<dyn Fn(&Vector, &Vector) -> Vector>
}

impl ContinuousSystem {
    fn linear_system(a: Matrix, b: Matrix, c: Matrix, d: Matrix) -> Self {
        let state_eq = StateEquation {
            function: Box::new(move |x, u, t| {
                a.clone() * x.clone() + b.clone() * u.clone()
            })
        };
        
        let output_eq = OutputEquation {
            function: Box::new(move |x, u| {
                c.clone() * x.clone() + d.clone() * u.clone()
            })
        };
        
        ContinuousSystem {
            state_dimension: a.rows(),
            input_dimension: b.cols(),
            output_dimension: c.rows(),
            state_equation: state_eq,
            output_equation: output_eq
        }
    }
    
    fn simulate(&self, x0: Vector, u: &[Vector], t: &[f64]) -> Vec<Vector> {
        let mut states = Vec::new();
        let mut current_state = x0;
        
        for (i, &time) in t.iter().enumerate() {
            states.push(current_state.clone());
            
            if i < u.len() {
                let dt = if i + 1 < t.len() { t[i + 1] - time } else { 0.01 };
                let derivative = (self.state_equation.function)(&current_state, &u[i], time);
                current_state = current_state + derivative * dt;
            }
        }
        
        states
    }
}
```

**ç¦»æ•£æ—¶é—´ç³»ç»Ÿ**ï¼š

```rust
#[derive(Clone, Debug)]
struct DiscreteSystem {
    state_dimension: usize,
    input_dimension: usize,
    output_dimension: usize,
    state_matrix: Matrix,
    input_matrix: Matrix,
    output_matrix: Matrix,
    feedthrough_matrix: Matrix
}

impl DiscreteSystem {
    fn new(a: Matrix, b: Matrix, c: Matrix, d: Matrix) -> Self {
        DiscreteSystem {
            state_dimension: a.rows(),
            input_dimension: b.cols(),
            output_dimension: c.rows(),
            state_matrix: a,
            input_matrix: b,
            output_matrix: c,
            feedthrough_matrix: d
        }
    }
    
    fn step(&self, x: &Vector, u: &Vector) -> (Vector, Vector) {
        let next_state = &self.state_matrix * x + &self.input_matrix * u;
        let output = &self.output_matrix * x + &self.feedthrough_matrix * u;
        (next_state, output)
    }
    
    fn simulate(&self, x0: Vector, u: &[Vector]) -> (Vec<Vector>, Vec<Vector>) {
        let mut states = Vec::new();
        let mut outputs = Vec::new();
        let mut current_state = x0;
        
        for input in u {
            let (next_state, output) = self.step(&current_state, input);
            states.push(current_state);
            outputs.push(output);
            current_state = next_state;
        }
        
        (states, outputs)
    }
}
```

### 2.2 ç³»ç»Ÿç‰¹æ€§åˆ†æ

**å¯æ§æ€§**ï¼š

```rust
impl DiscreteSystem {
    fn controllability_matrix(&self) -> Matrix {
        let n = self.state_dimension;
        let mut controllability = Matrix::zeros(n, n * self.input_dimension);
        
        for i in 0..n {
            let power = self.state_matrix.pow(i);
            let column_start = i * self.input_dimension;
            for j in 0..self.input_dimension {
                let column = &power * self.input_matrix.column(j);
                controllability.set_column(column_start + j, &column);
            }
        }
        
        controllability
    }
    
    fn is_controllable(&self) -> bool {
        let controllability = self.controllability_matrix();
        controllability.rank() == self.state_dimension
    }
}
```

**å¯è§‚æ€§**ï¼š

```rust
impl DiscreteSystem {
    fn observability_matrix(&self) -> Matrix {
        let n = self.state_dimension;
        let mut observability = Matrix::zeros(n * self.output_dimension, n);
        
        for i in 0..n {
            let power = self.state_matrix.pow(i);
            let row_start = i * self.output_dimension;
            for j in 0..self.output_dimension {
                let row = self.output_matrix.row(j) * &power;
                observability.set_row(row_start + j, &row);
            }
        }
        
        observability
    }
    
    fn is_observable(&self) -> bool {
        let observability = self.observability_matrix();
        observability.rank() == self.state_dimension
    }
}
```

## 3 æ§åˆ¶å™¨è®¾è®¡

### 3.1 çŠ¶æ€åé¦ˆæ§åˆ¶

**çº¿æ€§äºŒæ¬¡å‹è°ƒèŠ‚å™¨ (LQR)**ï¼š

```rust
#[derive(Clone, Debug)]
struct LQRController {
    gain_matrix: Matrix,
    cost_matrix_q: Matrix,
    cost_matrix_r: Matrix
}

impl LQRController {
    fn design(system: &DiscreteSystem, q: Matrix, r: Matrix) -> Self {
        // æ±‚è§£ç¦»æ•£æ—¶é—´ä»£æ•°Riccatiæ–¹ç¨‹
        let p = solve_discrete_riccati(&system.state_matrix, &system.input_matrix, &q, &r);
        
        // è®¡ç®—æœ€ä¼˜å¢ç›ŠçŸ©é˜µ
        let k = (&r + &system.input_matrix.transpose() * &p * &system.input_matrix).inverse()
            * &system.input_matrix.transpose() * &p * &system.state_matrix;
        
        LQRController {
            gain_matrix: k,
            cost_matrix_q: q,
            cost_matrix_r: r
        }
    }
    
    fn control(&self, state: &Vector) -> Vector {
        -&self.gain_matrix * state
    }
}

fn solve_discrete_riccati(a: &Matrix, b: &Matrix, q: &Matrix, r: &Matrix) -> Matrix {
    // è¿­ä»£æ±‚è§£ç¦»æ•£æ—¶é—´ä»£æ•°Riccatiæ–¹ç¨‹
    let mut p = q.clone();
    let max_iterations = 100;
    let tolerance = 1e-6;
    
    for _ in 0..max_iterations {
        let p_old = p.clone();
        
        let temp = (&r + &b.transpose() * &p * b).inverse();
        let k = &temp * &b.transpose() * &p * a;
        let p_new = q + &a.transpose() * &p * a - &a.transpose() * &p * b * &k;
        
        p = p_new;
        
        if (&p - &p_old).norm() < tolerance {
            break;
        }
    }
    
    p
}
```

### 3.2 è¾“å‡ºåé¦ˆæ§åˆ¶

**è§‚æµ‹å™¨è®¾è®¡**ï¼š

```rust
#[derive(Clone, Debug)]
struct Observer {
    state_matrix: Matrix,
    input_matrix: Matrix,
    output_matrix: Matrix,
    observer_gain: Matrix
}

impl Observer {
    fn design(system: &DiscreteSystem, desired_poles: &[Complex]) -> Self {
        // ä½¿ç”¨æç‚¹é…ç½®æ–¹æ³•è®¾è®¡è§‚æµ‹å™¨
        let l = pole_placement(&system.state_matrix.transpose(), 
                              &system.output_matrix.transpose(), 
                              desired_poles);
        
        Observer {
            state_matrix: system.state_matrix.clone(),
            input_matrix: system.input_matrix.clone(),
            output_matrix: system.output_matrix.clone(),
            observer_gain: l.transpose()
        }
    }
    
    fn estimate(&self, x_hat: &Vector, u: &Vector, y: &Vector) -> Vector {
        let y_hat = &self.output_matrix * x_hat;
        let innovation = y - &y_hat;
        
        &self.state_matrix * x_hat + &self.input_matrix * u + &self.observer_gain * innovation
    }
}

fn pole_placement(a: &Matrix, b: &Matrix, desired_poles: &[Complex]) -> Matrix {
    // æç‚¹é…ç½®ç®—æ³•
    let n = a.rows();
    let controllability = controllability_matrix(a, b);
    
    if controllability.rank() != n {
        panic!("System is not controllable");
    }
    
    // è®¡ç®—æœŸæœ›ç‰¹å¾å¤šé¡¹å¼
    let desired_polynomial = polynomial_from_roots(desired_poles);
    
    // è®¡ç®—åé¦ˆå¢ç›Š
    let transformation = controllability.inverse();
    let k = desired_polynomial.coefficients() * &transformation;
    
    k
}
```

### 3.3 è‡ªé€‚åº”æ§åˆ¶

**æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶ (MRAC)**ï¼š

```rust
#[derive(Clone, Debug)]
struct MRACController {
    reference_model: DiscreteSystem,
    adaptation_gain: f64,
    parameter_estimates: Vector
}

impl MRACController {
    fn new(reference_model: DiscreteSystem, adaptation_gain: f64) -> Self {
        let parameter_dimension = reference_model.state_dimension + reference_model.input_dimension;
        
        MRACController {
            reference_model,
            adaptation_gain,
            parameter_estimates: Vector::zeros(parameter_dimension)
        }
    }
    
    fn update(&mut self, system_output: &Vector, reference_output: &Vector, 
              regressor: &Vector) -> Vector {
        // è®¡ç®—è·Ÿè¸ªè¯¯å·®
        let error = reference_output - system_output;
        
        // æ›´æ–°å‚æ•°ä¼°è®¡
        let parameter_update = self.adaptation_gain * regressor * error.transpose();
        self.parameter_estimates = &self.parameter_estimates + &parameter_update;
        
        // è®¡ç®—æ§åˆ¶è¾“å…¥
        &self.parameter_estimates.transpose() * regressor
    }
}
```

## 4 é²æ£’æ§åˆ¶

### 4.1 Hæ§åˆ¶

**å®šä¹‰**ï¼š
Hâˆæ§åˆ¶æ˜¯ä¸€ç§é²æ£’æ§åˆ¶æ–¹æ³•ï¼Œç”¨äºå¤„ç†ç³»ç»Ÿçš„ä¸ç¡®å®šæ€§å’Œå¤–éƒ¨å¹²æ‰°ã€‚

**å½¢å¼åŒ–è¡¨è¾¾**ï¼š

```rust
#[derive(Clone, Debug)]
struct HInfinityController {
    controller_matrix: Matrix,
    performance_level: f64
}

impl HInfinityController {
    fn design(system: &DiscreteSystem, performance_level: f64) -> Self {
        // æ±‚è§£Hâˆæ§åˆ¶é—®é¢˜
        let (k, gamma) = solve_h_infinity_problem(system, performance_level);
        
        HInfinityController {
            controller_matrix: k,
            performance_level: gamma
        }
    }
    
    fn control(&self, state: &Vector) -> Vector {
        &self.controller_matrix * state
    }
}

fn solve_h_infinity_problem(system: &DiscreteSystem, gamma: f64) -> (Matrix, f64) {
    // ç®€åŒ–çš„Hâˆæ§åˆ¶æ±‚è§£ç®—æ³•
    // å®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„ç®—æ³•
    
    // æ„å»ºå¢å¹¿ç³»ç»Ÿ
    let augmented_system = build_augmented_system(system, gamma);
    
    // æ±‚è§£çº¿æ€§çŸ©é˜µä¸ç­‰å¼ (LMI)
    let solution = solve_lmi(&augmented_system);
    
    // æå–æ§åˆ¶å™¨
    let controller = extract_controller(&solution);
    
    (controller, gamma)
}
```

### 4.2 Î¼ç»¼åˆ

**å®šä¹‰**ï¼š
Î¼ç»¼åˆæ˜¯ä¸€ç§å¤„ç†ç»“æ„ä¸ç¡®å®šæ€§çš„é²æ£’æ§åˆ¶æ–¹æ³•ã€‚

**å½¢å¼åŒ–è¡¨è¾¾**ï¼š

```rust
#[derive(Clone, Debug)]
struct MuSynthesisController {
    nominal_controller: Matrix,
    uncertainty_structure: UncertaintyStructure
}

#[derive(Clone, Debug)]
struct UncertaintyStructure {
    block_structure: Vec<UncertaintyBlock>,
    bounds: Vec<f64>
}

#[derive(Clone, Debug)]
enum UncertaintyBlock {
    Real,
    Complex,
    Repeated
}

impl MuSynthesisController {
    fn design(nominal_system: &DiscreteSystem, 
              uncertainty_structure: UncertaintyStructure) -> Self {
        // Î¼ç»¼åˆç®—æ³•
        let controller = mu_synthesis_algorithm(nominal_system, &uncertainty_structure);
        
        MuSynthesisController {
            nominal_controller: controller,
            uncertainty_structure
        }
    }
    
    fn mu_analysis(&self, system: &DiscreteSystem) -> f64 {
        // è®¡ç®—Î¼å€¼
        let closed_loop = self.form_closed_loop(system);
        let mu_value = compute_mu(&closed_loop, &self.uncertainty_structure);
        mu_value
    }
}
```

## 5 éçº¿æ€§æ§åˆ¶

### 5.1 åé¦ˆçº¿æ€§åŒ–

**å®šä¹‰**ï¼š
åé¦ˆçº¿æ€§åŒ–é€šè¿‡éçº¿æ€§çŠ¶æ€åé¦ˆå°†éçº¿æ€§ç³»ç»Ÿè½¬æ¢ä¸ºçº¿æ€§ç³»ç»Ÿã€‚

**å½¢å¼åŒ–è¡¨è¾¾**ï¼š

```rust
#[derive(Clone, Debug)]
struct FeedbackLinearizationController {
    transformation: NonlinearTransformation,
    linear_controller: LinearController
}

#[derive(Clone, Debug)]
struct NonlinearTransformation {
    state_transform: Box<dyn Fn(&Vector) -> Vector>,
    input_transform: Box<dyn Fn(&Vector, &Vector) -> Vector>
}

impl FeedbackLinearizationController {
    fn design(system: &NonlinearSystem) -> Self {
        // è®¡ç®—ç›¸å¯¹åº¦
        let relative_degree = compute_relative_degree(system);
        
        // æ„é€ åæ ‡å˜æ¢
        let transformation = construct_transformation(system, relative_degree);
        
        // è®¾è®¡çº¿æ€§æ§åˆ¶å™¨
        let linear_controller = design_linear_controller(relative_degree);
        
        FeedbackLinearizationController {
            transformation,
            linear_controller
        }
    }
    
    fn control(&self, state: &Vector, reference: &Vector) -> Vector {
        // åæ ‡å˜æ¢
        let transformed_state = (self.transformation.state_transform)(state);
        let transformed_reference = (self.transformation.state_transform)(reference);
        
        // çº¿æ€§æ§åˆ¶
        let linear_input = self.linear_controller.control(&transformed_state, &transformed_reference);
        
        // é€†å˜æ¢
        (self.transformation.input_transform)(state, &linear_input)
    }
}
```

### 5.2 æ»‘æ¨¡æ§åˆ¶

**å®šä¹‰**ï¼š
æ»‘æ¨¡æ§åˆ¶æ˜¯ä¸€ç§å˜ç»“æ„æ§åˆ¶æ–¹æ³•ï¼Œé€šè¿‡è®¾è®¡æ»‘æ¨¡é¢å®ç°é²æ£’æ§åˆ¶ã€‚

**å½¢å¼åŒ–è¡¨è¾¾**ï¼š

```rust
#[derive(Clone, Debug)]
struct SlidingModeController {
    sliding_surface: SlidingSurface,
    control_gain: f64,
    boundary_layer: f64
}

#[derive(Clone, Debug)]
struct SlidingSurface {
    coefficients: Vector
}

impl SlidingModeController {
    fn design(system: &DiscreteSystem, desired_poles: &[Complex]) -> Self {
        // è®¾è®¡æ»‘æ¨¡é¢
        let surface = design_sliding_surface(system, desired_poles);
        
        // é€‰æ‹©æ§åˆ¶å¢ç›Š
        let gain = select_control_gain(system);
        
        SlidingModeController {
            sliding_surface: surface,
            control_gain: gain,
            boundary_layer: 0.1
        }
    }
    
    fn control(&self, state: &Vector, reference: &Vector) -> Vector {
        // è®¡ç®—æ»‘æ¨¡å˜é‡
        let s = self.sliding_surface.evaluate(state, reference);
        
        // æ»‘æ¨¡æ§åˆ¶å¾‹
        if s.abs() > self.boundary_layer {
            -self.control_gain * s.signum()
        } else {
            -self.control_gain * s / self.boundary_layer
        }
    }
}
```

## 6 æ™ºèƒ½æ§åˆ¶

### 6.1 æ¨¡ç³Šæ§åˆ¶

**å®šä¹‰**ï¼š
æ¨¡ç³Šæ§åˆ¶åŸºäºæ¨¡ç³Šé€»è¾‘ï¼Œå¤„ç†ä¸ç¡®å®šæ€§å’Œéçº¿æ€§ã€‚

**å½¢å¼åŒ–è¡¨è¾¾**ï¼š

```rust
#[derive(Clone, Debug)]
struct FuzzyController {
    rule_base: Vec<FuzzyRule>,
    membership_functions: HashMap<String, Vec<MembershipFunction>>
}

#[derive(Clone, Debug)]
struct FuzzyRule {
    antecedent: Vec<FuzzyCondition>,
    consequent: FuzzyAction
}

#[derive(Clone, Debug)]
struct FuzzyCondition {
    variable: String,
    linguistic_value: String
}

#[derive(Clone, Debug)]
struct FuzzyAction {
    variable: String,
    linguistic_value: String
}

impl FuzzyController {
    fn control(&self, inputs: &HashMap<String, f64>) -> HashMap<String, f64> {
        let mut outputs = HashMap::new();
        
        // æ¨¡ç³ŠåŒ–
        let fuzzy_inputs = self.fuzzify(inputs);
        
        // æ¨ç†
        let fuzzy_outputs = self.inference(&fuzzy_inputs);
        
        // å»æ¨¡ç³ŠåŒ–
        for (variable, fuzzy_output) in fuzzy_outputs {
            let crisp_output = self.defuzzify(&fuzzy_output);
            outputs.insert(variable, crisp_output);
        }
        
        outputs
    }
    
    fn fuzzify(&self, inputs: &HashMap<String, f64>) -> HashMap<String, HashMap<String, f64>> {
        let mut fuzzy_inputs = HashMap::new();
        
        for (variable, value) in inputs {
            let mut membership_values = HashMap::new();
            if let Some(functions) = self.membership_functions.get(variable) {
                for function in functions {
                    let membership = function.evaluate(*value);
                    membership_values.insert(function.linguistic_value.clone(), membership);
                }
            }
            fuzzy_inputs.insert(variable.clone(), membership_values);
        }
        
        fuzzy_inputs
    }
}
```

### 6.2 ç¥ç»ç½‘ç»œæ§åˆ¶

**å®šä¹‰**ï¼š
ç¥ç»ç½‘ç»œæ§åˆ¶åˆ©ç”¨ç¥ç»ç½‘ç»œçš„éçº¿æ€§æ˜ å°„èƒ½åŠ›è¿›è¡Œæ§åˆ¶ã€‚

**å½¢å¼åŒ–è¡¨è¾¾**ï¼š

```rust
#[derive(Clone, Debug)]
struct NeuralNetworkController {
    network: NeuralNetwork,
    learning_rate: f64
}

#[derive(Clone, Debug)]
struct NeuralNetwork {
    layers: Vec<Layer>,
    weights: Vec<Matrix>,
    biases: Vec<Vector>
}

#[derive(Clone, Debug)]
struct Layer {
    neurons: usize,
    activation_function: ActivationFunction
}

#[derive(Clone, Debug)]
enum ActivationFunction {
    Sigmoid,
    Tanh,
    ReLU,
    Linear
}

impl NeuralNetworkController {
    fn control(&self, state: &Vector) -> Vector {
        self.network.forward(state)
    }
    
    fn train(&mut self, training_data: &[(Vector, Vector)]) {
        for (input, target) in training_data {
            // å‰å‘ä¼ æ’­
            let output = self.network.forward(input);
            
            // è®¡ç®—è¯¯å·®
            let error = target - &output;
            
            // åå‘ä¼ æ’­
            let gradients = self.network.backward(input, &error);
            
            // æ›´æ–°æƒé‡
            self.update_weights(&gradients);
        }
    }
}
```

## 7 åº”ç”¨é¢†åŸŸ

### 7.1 å·¥ä¸šæ§åˆ¶

```rust
// PIDæ§åˆ¶å™¨
#[derive(Clone, Debug)]
struct PIDController {
    kp: f64,
    ki: f64,
    kd: f64,
    integral: f64,
    previous_error: f64
}

impl PIDController {
    fn new(kp: f64, ki: f64, kd: f64) -> Self {
        PIDController {
            kp, ki, kd,
            integral: 0.0,
            previous_error: 0.0
        }
    }
    
    fn control(&mut self, error: f64, dt: f64) -> f64 {
        self.integral += error * dt;
        let derivative = (error - self.previous_error) / dt;
        
        let output = self.kp * error + self.ki * self.integral + self.kd * derivative;
        
        self.previous_error = error;
        output
    }
}
```

### 7.2 æœºå™¨äººæ§åˆ¶

```rust
// æœºå™¨äººè¿åŠ¨æ§åˆ¶
#[derive(Clone, Debug)]
struct RobotController {
    kinematics: Kinematics,
    dynamics: Dynamics,
    controller: Box<dyn Controller>
}

impl RobotController {
    fn control(&self, current_state: &RobotState, desired_state: &RobotState) -> JointTorques {
        // è®¡ç®—è¿åŠ¨å­¦
        let current_pose = self.kinematics.forward_kinematics(&current_state.joint_angles);
        let desired_pose = self.kinematics.forward_kinematics(&desired_state.joint_angles);
        
        // è®¡ç®—è¯¯å·®
        let pose_error = desired_pose - current_pose;
        
        // æ§åˆ¶å™¨è¾“å‡º
        let control_input = self.controller.control(&current_state, &pose_error);
        
        // è®¡ç®—å…³èŠ‚åŠ›çŸ©
        let torques = self.dynamics.compute_torques(&current_state, &control_input);
        
        torques
    }
}
```

## 8 æ€»ç»“

æ§åˆ¶è®ºç†è®ºä¸ºåŠ¨æ€ç³»ç»Ÿçš„åˆ†æå’Œè®¾è®¡æä¾›äº†å®Œæ•´çš„ç†è®ºæ¡†æ¶ï¼š

1. **åŸºç¡€ç†è®º**ï¼šç³»ç»Ÿå»ºæ¨¡ã€å¯æ§æ€§ã€å¯è§‚æ€§åˆ†æ
2. **æ§åˆ¶å™¨è®¾è®¡**ï¼šçŠ¶æ€åé¦ˆã€è¾“å‡ºåé¦ˆã€è‡ªé€‚åº”æ§åˆ¶
3. **é²æ£’æ§åˆ¶**ï¼šHâˆæ§åˆ¶ã€Î¼ç»¼åˆ
4. **éçº¿æ€§æ§åˆ¶**ï¼šåé¦ˆçº¿æ€§åŒ–ã€æ»‘æ¨¡æ§åˆ¶
5. **æ™ºèƒ½æ§åˆ¶**ï¼šæ¨¡ç³Šæ§åˆ¶ã€ç¥ç»ç½‘ç»œæ§åˆ¶
6. **åº”ç”¨é¢†åŸŸ**ï¼šå·¥ä¸šæ§åˆ¶ã€æœºå™¨äººæ§åˆ¶ã€èˆªç©ºèˆªå¤©

æ§åˆ¶è®ºä¸ä»…ä¸ºå·¥ç¨‹ç³»ç»Ÿæä¾›äº†è®¾è®¡æ–¹æ³•ï¼Œä¹Ÿä¸ºç†è§£å¤æ‚ç³»ç»Ÿçš„è¡Œä¸ºæä¾›äº†ç†è®ºå·¥å…·ã€‚
