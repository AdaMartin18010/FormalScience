# é«˜çº§çº¿æ€§ç±»åž‹ç†è®ºæ‰©å±• (Advanced Linear Type Theory Extended)

## ðŸ“‹ ç›®å½•

- [1 çº¿æ€§é€»è¾‘æ·±åº¦åˆ†æž](#1-çº¿æ€§é€»è¾‘æ·±åº¦åˆ†æž)
  - [1.1 çº¿æ€§é€»è¾‘å…¬ç†ç³»ç»Ÿ](#11-çº¿æ€§é€»è¾‘å…¬ç†ç³»ç»Ÿ)
  - [1.2 å¼ é‡ç§¯ç±»åž‹](#12-å¼ é‡ç§¯ç±»åž‹)
- [2 æŒ‡æ•°ç±»åž‹ç†è®º](#2-æŒ‡æ•°ç±»åž‹ç†è®º)
  - [2.1 æŒ‡æ•°ç±»åž‹è§„åˆ™](#21-æŒ‡æ•°ç±»åž‹è§„åˆ™)
  - [2.2 æŒ‡æ•°ç±»åž‹è¯­ä¹‰](#22-æŒ‡æ•°ç±»åž‹è¯­ä¹‰)
- [3 èµ„æºç®¡ç†ç†è®º](#3-èµ„æºç®¡ç†ç†è®º)
  - [3.1 èµ„æºç±»åž‹ç³»ç»Ÿ](#31-èµ„æºç±»åž‹ç³»ç»Ÿ)
  - [3.2 å†…å­˜ç®¡ç†](#32-å†…å­˜ç®¡ç†)
- [4 å¹¶å‘å®‰å…¨ç†è®º](#4-å¹¶å‘å®‰å…¨ç†è®º)
  - [4.1 çº¿æ€§ç±»åž‹ä¸Žå¹¶å‘](#41-çº¿æ€§ç±»åž‹ä¸Žå¹¶å‘)
  - [4.2 æ‰€æœ‰æƒç³»ç»Ÿ](#42-æ‰€æœ‰æƒç³»ç»Ÿ)
- [5 çº¿æ€§é€»è¾‘è¯­ä¹‰](#5-çº¿æ€§é€»è¾‘è¯­ä¹‰)
  - [5.1 æŒ‡ç§°è¯­ä¹‰](#51-æŒ‡ç§°è¯­ä¹‰)
  - [5.2 æ“ä½œè¯­ä¹‰](#52-æ“ä½œè¯­ä¹‰)
- [6 é«˜çº§çº¿æ€§ç±»åž‹æž„é€ ](#6-é«˜çº§çº¿æ€§ç±»åž‹æž„é€ )
  - [6.1 çº¿æ€§å•å­](#61-çº¿æ€§å•å­)
  - [6.2 çº¿æ€§æ•ˆåº”ç³»ç»Ÿ](#62-çº¿æ€§æ•ˆåº”ç³»ç»Ÿ)
- [7 å®žé™…åº”ç”¨](#7-å®žé™…åº”ç”¨)
  - [7.1 Rustæ‰€æœ‰æƒç³»ç»Ÿ](#71-rustæ‰€æœ‰æƒç³»ç»Ÿ)
  - [7.2 å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„çº¿æ€§ç±»åž‹](#72-å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„çº¿æ€§ç±»åž‹)
- [8 çº¿æ€§ç±»åž‹ç³»ç»Ÿå…ƒç†è®º](#8-çº¿æ€§ç±»åž‹ç³»ç»Ÿå…ƒç†è®º)
  - [8.1 ç±»åž‹æŽ¨æ–­](#81-ç±»åž‹æŽ¨æ–­)
  - [8.2 ç±»åž‹ç­‰ä»·æ€§](#82-ç±»åž‹ç­‰ä»·æ€§)
- [9 ç»“è®º](#9-ç»“è®º)

---

## 1 çº¿æ€§é€»è¾‘æ·±åº¦åˆ†æž

### 1.1 çº¿æ€§é€»è¾‘å…¬ç†ç³»ç»Ÿ

**å®šä¹‰ 1.1 (çº¿æ€§é€»è¾‘è¿žæŽ¥è¯)**
çº¿æ€§é€»è¾‘åŒ…å«ä»¥ä¸‹è¿žæŽ¥è¯ï¼š

- $\otimes$ (å¼ é‡ç§¯)
- $\multimap$ (çº¿æ€§è•´å«)
- $\&$ (åŠ æ³•ç§¯)
- $\oplus$ (åŠ æ³•å’Œ)
- $!$ (æŒ‡æ•°)
- $?$ (å¯¹å¶æŒ‡æ•°)

**å®šä¹‰ 1.2 (çº¿æ€§ä¸Šä¸‹æ–‡)**
çº¿æ€§ä¸Šä¸‹æ–‡ $\Gamma$ æ˜¯å˜é‡åˆ°ç±»åž‹çš„æ˜ å°„ï¼Œæ»¡è¶³çº¿æ€§æ€§çº¦æŸï¼š
$$\Gamma : \text{Var} \rightarrow \text{Type}$$

**å…¬ç† 1.1 (çº¿æ€§å˜é‡è§„åˆ™)**
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau}$$

**å…¬ç† 1.2 (çº¿æ€§æŠ½è±¡)**
$$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x.e : \tau_1 \multimap \tau_2}$$

**å…¬ç† 1.3 (çº¿æ€§åº”ç”¨)**
$$\frac{\Gamma_1 \vdash e_1 : \tau_1 \multimap \tau_2 \quad \Gamma_2 \vdash e_2 : \tau_1}{\Gamma_1, \Gamma_2 \vdash e_1 e_2 : \tau_2}$$

**å®šç† 1.1 (çº¿æ€§æ€§ä¿æŒ)**
åœ¨çº¿æ€§ç±»åž‹ç³»ç»Ÿä¸­ï¼Œå¦‚æžœ $\Gamma \vdash e : \tau$ï¼Œåˆ™ $\Gamma$ ä¸­çš„æ¯ä¸ªå˜é‡åœ¨ $e$ ä¸­æ°å¥½å‡ºçŽ°ä¸€æ¬¡ã€‚

**è¯æ˜Žï¼š** é€šè¿‡ç»“æž„å½’çº³æ³•ï¼š

1. **å˜é‡æƒ…å†µ**ï¼šç›´æŽ¥æ»¡è¶³çº¿æ€§æ€§
2. **æŠ½è±¡æƒ…å†µ**ï¼šé€šè¿‡å½’çº³å‡è®¾ï¼Œå˜é‡åœ¨ä½“ä¸­æ°å¥½å‡ºçŽ°ä¸€æ¬¡
3. **åº”ç”¨æƒ…å†µ**ï¼šé€šè¿‡ä¸Šä¸‹æ–‡åˆ†ç¦»ï¼Œç¡®ä¿å˜é‡ä¸é‡å¤ä½¿ç”¨

**å®šç† 1.2 (ä¸Šä¸‹æ–‡åˆ†ç¦»)**
å¦‚æžœ $\Gamma_1, \Gamma_2 \vdash e : \tau$ï¼Œåˆ™ $\Gamma_1$ å’Œ $\Gamma_2$ ä¸­çš„å˜é‡é›†åˆä¸ç›¸äº¤ã€‚

**è¯æ˜Žï¼š** é€šè¿‡çº¿æ€§æ€§çº¦æŸï¼š

1. æ¯ä¸ªå˜é‡åªèƒ½ä½¿ç”¨ä¸€æ¬¡
2. åº”ç”¨è§„åˆ™è¦æ±‚ä¸Šä¸‹æ–‡åˆ†ç¦»
3. å› æ­¤å˜é‡é›†åˆå¿…é¡»ä¸ç›¸äº¤

### 1.2 å¼ é‡ç§¯ç±»åž‹

**å®šä¹‰ 1.3 (å¼ é‡ç§¯å¼•å…¥)**
$$\frac{\Gamma_1 \vdash e_1 : \tau_1 \quad \Gamma_2 \vdash e_2 : \tau_2}{\Gamma_1, \Gamma_2 \vdash (e_1, e_2) : \tau_1 \otimes \tau_2}$$

**å®šä¹‰ 1.4 (å¼ é‡ç§¯æ¶ˆé™¤)**
$$\frac{\Gamma_1 \vdash e : \tau_1 \otimes \tau_2 \quad \Gamma_2, x : \tau_1, y : \tau_2 \vdash e' : \tau}{\Gamma_1, \Gamma_2 \vdash \text{let } (x, y) = e \text{ in } e' : \tau}$$

**å®šç† 1.3 (å¼ é‡ç§¯äº¤æ¢æ€§)**
$$\tau_1 \otimes \tau_2 \cong \tau_2 \otimes \tau_1$$

**è¯æ˜Žï¼š** é€šè¿‡åŒæž„æž„é€ ï¼š

1. æž„é€ äº¤æ¢å‡½æ•°ï¼š$\lambda (x, y).(y, x) : \tau_1 \otimes \tau_2 \multimap \tau_2 \otimes \tau_1$
2. æž„é€ é€†å‡½æ•°ï¼š$\lambda (y, x).(x, y) : \tau_2 \otimes \tau_1 \multimap \tau_1 \otimes \tau_2$
3. éªŒè¯å¤åˆå¾—åˆ°æ’ç­‰å‡½æ•°

**å®šç† 1.4 (å¼ é‡ç§¯ç»“åˆæ€§)**
$$(\tau_1 \otimes \tau_2) \otimes \tau_3 \cong \tau_1 \otimes (\tau_2 \otimes \tau_3)$$

**è¯æ˜Žï¼š** é€šè¿‡åŒæž„æž„é€ ï¼š

1. æž„é€ ç»“åˆå‡½æ•°ï¼š$\lambda ((x, y), z).(x, (y, z))$
2. æž„é€ é€†å‡½æ•°ï¼š$\lambda (x, (y, z)).((x, y), z)$
3. éªŒè¯å¤åˆå¾—åˆ°æ’ç­‰å‡½æ•°

## 2 æŒ‡æ•°ç±»åž‹ç†è®º

### 2.1 æŒ‡æ•°ç±»åž‹è§„åˆ™

**å…¬ç† 2.1 (å¼±åŒ–)**
$$\frac{\Gamma \vdash e : \tau}{\Gamma, x : !\tau \vdash e : \tau}$$

**å…¬ç† 2.2 (æ”¶ç¼©)**
$$\frac{\Gamma, x : !\tau, y : !\tau \vdash e : \sigma}{\Gamma, z : !\tau \vdash e[z/x, z/y] : \sigma}$$

**å…¬ç† 2.3 (æå‡)**
$$\frac{!\Gamma \vdash e : \tau}{!\Gamma \vdash !e : !\tau}$$

**å…¬ç† 2.4 (æŒ‡æ•°æ¶ˆé™¤)**
$$\frac{\Gamma_1 \vdash e_1 : !\tau \quad \Gamma_2, x : \tau \vdash e_2 : \sigma}{\Gamma_1, \Gamma_2 \vdash \text{let } !x = e_1 \text{ in } e_2 : \sigma}$$

**å®šç† 2.1 (æŒ‡æ•°ç±»åž‹æ€§è´¨)**
æŒ‡æ•°ç±»åž‹ $!\tau$ æ»¡è¶³ï¼š

1. å¯é‡å¤ä½¿ç”¨ï¼ˆå¼±åŒ–ï¼‰
2. å¯å¤åˆ¶ï¼ˆæ”¶ç¼©ï¼‰
3. å½¢æˆä½™å•å­ç»“æž„

**è¯æ˜Žï¼š** é€šè¿‡ä½™å•å­å…¬ç†ï¼š

1. **ä½™å•ä½**ï¼š$\text{let } !x = e \text{ in } x : \tau \multimap \tau$
2. **ä½™ä¹˜æ³•**ï¼š$\text{let } !x = e \text{ in } !x : !\tau \multimap !!\tau$
3. **è‡ªç„¶æ€§**ï¼šé€šè¿‡ç±»åž‹æŽ¨å¯¼è§„åˆ™

### 2.2 æŒ‡æ•°ç±»åž‹è¯­ä¹‰

**å®šä¹‰ 2.1 (æŒ‡æ•°ç±»åž‹è¯­ä¹‰)**
æŒ‡æ•°ç±»åž‹ $!A$ çš„æŒ‡ç§°è¯­ä¹‰ï¼š
$$\llbracket !A \rrbracket = \text{Comonad}(\llbracket A \rrbracket)$$

**å®šä¹‰ 2.2 (ä½™å•å­æ“ä½œ)**
ä½™å•å­æ“ä½œï¼š

- **ä½™å•ä½**ï¼š$\epsilon : !A \multimap A$
- **ä½™ä¹˜æ³•**ï¼š$\delta : !A \multimap !!A$

**å®šç† 2.2 (ä½™å•å­å¾‹)**
ä½™å•å­æ»¡è¶³ä»¥ä¸‹å¾‹ï¼š

1. $\epsilon \circ \delta = \text{id}$
2. $\delta \circ \delta = !\delta \circ \delta$
3. $\epsilon \circ !\epsilon = \epsilon \circ \delta$

**è¯æ˜Žï¼š** é€šè¿‡ä½™å•å­å®šä¹‰ï¼š

1. ä½™å•ä½å¾‹ï¼šç›´æŽ¥åº”ç”¨å®šä¹‰
2. ä½™ç»“åˆå¾‹ï¼šé€šè¿‡è‡ªç„¶æ€§
3. ä½™æ’ç­‰å¾‹ï¼šé€šè¿‡ä½™å•ä½æ€§è´¨

## 3 èµ„æºç®¡ç†ç†è®º

### 3.1 èµ„æºç±»åž‹ç³»ç»Ÿ

**å®šä¹‰ 3.1 (èµ„æºç±»åž‹)**
èµ„æºç±»åž‹è¡¨ç¤ºéœ€è¦ç²¾ç¡®ç®¡ç†çš„ç³»ç»Ÿèµ„æºï¼š
$$\text{Resource} ::= \text{FileHandle} \mid \text{MemoryRef} \mid \text{NetworkConn} \mid \text{DatabaseConn}$$

**å®šä¹‰ 3.2 (èµ„æºæ“ä½œ)**
èµ„æºæ“ä½œåŒ…æ‹¬åˆ›å»ºã€ä½¿ç”¨å’Œé”€æ¯ï¼š

```haskell
data ResourceOp a where
  Create :: ResourceType -> ResourceOp Resource
  Use    :: Resource -> (a -> b) -> ResourceOp b
  Destroy :: Resource -> ResourceOp ()
```

**å®šç† 3.1 (èµ„æºå®‰å…¨)**
åœ¨çº¿æ€§ç±»åž‹ç³»ç»Ÿä¸­ï¼Œèµ„æºä¸ä¼šè¢«é‡å¤é‡Šæ”¾æˆ–é—å¿˜ã€‚

**è¯æ˜Žï¼š** é€šè¿‡çº¿æ€§æ€§çº¦æŸï¼š

1. æ¯ä¸ªèµ„æºå˜é‡å¿…é¡»æ°å¥½ä½¿ç”¨ä¸€æ¬¡
2. èµ„æºé”€æ¯æ“ä½œæ¶ˆè€—èµ„æºå˜é‡
3. æ— æ³•é‡å¤è®¿é—®å·²é”€æ¯çš„èµ„æº

-**å®šä¹‰ 3.3 (èµ„æºç®¡ç†å™¨)**

```haskell
data ResourceManager r a where
  Return :: a -> ResourceManager r a
  Bind   :: ResourceManager r a -> (a -> ResourceManager r b) -> ResourceManager r b
  Create :: ResourceType -> ResourceManager r Resource
  Use    :: Resource -> (a -> b) -> ResourceManager r b
  Destroy :: Resource -> ResourceManager r ()
```

**å®šç† 3.2 (èµ„æºç®¡ç†å™¨æ­£ç¡®æ€§)**
èµ„æºç®¡ç†å™¨ä¿è¯èµ„æºå®‰å…¨ã€‚

**è¯æ˜Žï¼š** é€šè¿‡çº¿æ€§ç±»åž‹ç³»ç»Ÿï¼š

1. åˆ›å»ºæ“ä½œåˆ†é…æ–°èµ„æº
2. ä½¿ç”¨æ“ä½œæ¶ˆè€—èµ„æº
3. é”€æ¯æ“ä½œé‡Šæ”¾èµ„æº
4. çº¿æ€§æ€§ç¡®ä¿æ¯ä¸ªèµ„æºæ°å¥½ä½¿ç”¨ä¸€æ¬¡

### 3.2 å†…å­˜ç®¡ç†

**å®šä¹‰ 3.4 (çº¿æ€§å¼•ç”¨)**
çº¿æ€§å¼•ç”¨ç¡®ä¿å†…å­˜å®‰å…¨ï¼š

```haskell
data LinearRef a where
  NewRef :: a -> LinearRef a
  ReadRef :: LinearRef a -> (a, LinearRef a)
  WriteRef :: LinearRef a -> a -> LinearRef a
  FreeRef :: LinearRef a -> ()
```

**å®šç† 3.3 (å†…å­˜å®‰å…¨)**
çº¿æ€§å¼•ç”¨ç³»ç»Ÿä¿è¯ï¼š

1. ä¸ä¼šå‡ºçŽ°æ‚¬ç©ºæŒ‡é’ˆ
2. ä¸ä¼šé‡å¤é‡Šæ”¾å†…å­˜
3. ä¸ä¼šå‡ºçŽ°æ•°æ®ç«žäº‰

**è¯æ˜Žï¼š** é€šè¿‡çº¿æ€§ç±»åž‹ç³»ç»Ÿçš„æ€§è´¨ï¼š

1. æ¯ä¸ªå¼•ç”¨æœ€å¤šä½¿ç”¨ä¸€æ¬¡
2. è¯»å–æ“ä½œè¿”å›žæ–°çš„å¼•ç”¨
3. é‡Šæ”¾æ“ä½œæ¶ˆè€—å¼•ç”¨

-**å®šä¹‰ 3.5 (å†…å­˜åˆ†é…å™¨)**

```haskell
data Allocator = Allocator
  { allocate :: Int -> LinearRef [Word8]
  , deallocate :: LinearRef [Word8] -> ()
  , resize :: LinearRef [Word8] -> Int -> LinearRef [Word8]
  }
```

**å®šç† 3.4 (åˆ†é…å™¨å®‰å…¨)**
çº¿æ€§åˆ†é…å™¨ä¿è¯å†…å­˜å®‰å…¨ã€‚

**è¯æ˜Žï¼š** é€šè¿‡çº¿æ€§ç±»åž‹ç³»ç»Ÿï¼š

1. åˆ†é…æ“ä½œè¿”å›žå”¯ä¸€å¼•ç”¨
2. é‡Šæ”¾æ“ä½œæ¶ˆè€—å¼•ç”¨
3. è°ƒæ•´å¤§å°æ“ä½œè¿”å›žæ–°å¼•ç”¨

## 4 å¹¶å‘å®‰å…¨ç†è®º

### 4.1 çº¿æ€§ç±»åž‹ä¸Žå¹¶å‘

**å®šä¹‰ 4.1 (å¹¶å‘å®‰å…¨)**
ç¨‹åºæ˜¯å¹¶å‘å®‰å…¨çš„ï¼Œå¦‚æžœï¼š

1. æ²¡æœ‰æ•°æ®ç«žäº‰
2. æ²¡æœ‰æ­»é”
3. æ²¡æœ‰æ´»é”

**å®šç† 4.1 (çº¿æ€§ç±»åž‹å¹¶å‘å®‰å…¨)**
çº¿æ€§ç±»åž‹ç³»ç»Ÿä¿è¯å¹¶å‘å®‰å…¨ã€‚

**è¯æ˜Žï¼š** é€šè¿‡çº¿æ€§æ€§çº¦æŸï¼š

1. æ¯ä¸ªèµ„æºæœ€å¤šæœ‰ä¸€ä¸ªæ‰€æœ‰è€…
2. æ— æ³•åŒæ—¶è®¿é—®åŒä¸€èµ„æº
3. å› æ­¤ä¸ä¼šå‡ºçŽ°æ•°æ®ç«žäº‰

**å®šä¹‰ 4.2 (çº¿æ€§é€šé“)**
çº¿æ€§é€šé“ç¡®ä¿æ¶ˆæ¯ä¼ é€’å®‰å…¨ï¼š

```haskell
data LinearChannel a where
  NewChannel :: LinearChannel a
  Send :: LinearChannel a -> a -> ()
  Receive :: LinearChannel a -> (a, LinearChannel a)
  Close :: LinearChannel a -> ()
```

**å®šç† 4.2 (é€šé“å®‰å…¨)**
çº¿æ€§é€šé“ä¿è¯æ¶ˆæ¯ä¼ é€’å®‰å…¨ã€‚

**è¯æ˜Žï¼š** é€šè¿‡çº¿æ€§ç±»åž‹ç³»ç»Ÿï¼š

1. æ¯ä¸ªé€šé“æœ€å¤šæœ‰ä¸€ä¸ªå‘é€è€…å’Œä¸€ä¸ªæŽ¥æ”¶è€…
2. å‘é€æ“ä½œæ¶ˆè€—é€šé“
3. æŽ¥æ”¶æ“ä½œè¿”å›žæ–°é€šé“

### 4.2 æ‰€æœ‰æƒç³»ç»Ÿ

**å®šä¹‰ 4.3 (æ‰€æœ‰æƒ)**
æ‰€æœ‰æƒå…³ç³» $R \subseteq \text{Resource} \times \text{Process}$ æ»¡è¶³ï¼š

1. æ¯ä¸ªèµ„æºæœ€å¤šæœ‰ä¸€ä¸ªæ‰€æœ‰è€…
2. æ‰€æœ‰æƒå¯ä»¥è½¬ç§»
3. æ‰€æœ‰è€…è´Ÿè´£èµ„æºç®¡ç†

**å®šç† 4.3 (æ‰€æœ‰æƒå”¯ä¸€æ€§)**
åœ¨çº¿æ€§ç±»åž‹ç³»ç»Ÿä¸­ï¼Œæ¯ä¸ªèµ„æºæœ€å¤šæœ‰ä¸€ä¸ªæ‰€æœ‰è€…ã€‚

**è¯æ˜Žï¼š** é€šè¿‡çº¿æ€§æ€§çº¦æŸï¼š

1. èµ„æºå˜é‡åªèƒ½ä½¿ç”¨ä¸€æ¬¡
2. æ‰€æœ‰æƒè½¬ç§»æ¶ˆè€—åŽŸå˜é‡
3. å› æ­¤æ— æ³•åŒæ—¶æ‹¥æœ‰åŒä¸€èµ„æº

**å®šä¹‰ 4.4 (å€Ÿç”¨æ£€æŸ¥)**
å€Ÿç”¨æ£€æŸ¥ç¡®ä¿ä¸´æ—¶è®¿é—®å®‰å…¨ï¼š

```haskell
data Borrow a where
  Borrow :: LinearRef a -> Borrow a
  Return :: Borrow a -> LinearRef a
  UseBorrow :: Borrow a -> (a -> b) -> b
```

**å®šç† 4.4 (å€Ÿç”¨å®‰å…¨)**
å€Ÿç”¨ç³»ç»Ÿä¿è¯è®¿é—®å®‰å…¨ã€‚

**è¯æ˜Žï¼š** é€šè¿‡å€Ÿç”¨è§„åˆ™ï¼š

1. å€Ÿç”¨æœŸé—´åŽŸå¼•ç”¨ä¸å¯ç”¨
2. å€Ÿç”¨å¿…é¡»è¿”å›ž
3. å› æ­¤ä¸ä¼šå‡ºçŽ°å¹¶å‘è®¿é—®

## 5 çº¿æ€§é€»è¾‘è¯­ä¹‰

### 5.1 æŒ‡ç§°è¯­ä¹‰

**å®šä¹‰ 5.1 (çº¿æ€§å‡½æ•°ç©ºé—´)**
çº¿æ€§å‡½æ•°ç©ºé—´ $A \multimap B$ çš„è¯­ä¹‰ï¼š
$$\llbracket A \multimap B \rrbracket = \llbracket A \rrbracket \rightarrow \llbracket B \rrbracket$$

**å®šä¹‰ 5.2 (å¼ é‡ç§¯è¯­ä¹‰)**
å¼ é‡ç§¯ $A \otimes B$ çš„è¯­ä¹‰ï¼š
$$\llbracket A \otimes B \rrbracket = \llbracket A \rrbracket \times \llbracket B \rrbracket$$

**å®šä¹‰ 5.3 (æŒ‡æ•°ç±»åž‹è¯­ä¹‰)**
æŒ‡æ•°ç±»åž‹ $!A$ çš„è¯­ä¹‰ï¼š
$$\llbracket !A \rrbracket = \text{Comonad}(\llbracket A \rrbracket)$$

**å®šç† 5.1 (è¯­ä¹‰ä¸€è‡´æ€§)**
æŒ‡ç§°è¯­ä¹‰ä¸Žç±»åž‹æŽ¨å¯¼ä¸€è‡´ã€‚

**è¯æ˜Žï¼š** é€šè¿‡ç»“æž„å½’çº³ï¼š

1. å˜é‡ï¼šé€šè¿‡çŽ¯å¢ƒå®šä¹‰
2. æŠ½è±¡ï¼šé€šè¿‡å‡½æ•°ç©ºé—´å®šä¹‰
3. åº”ç”¨ï¼šé€šè¿‡å‡½æ•°åº”ç”¨å®šä¹‰
4. å¼ é‡ç§¯ï¼šé€šè¿‡ç§¯ç±»åž‹å®šä¹‰
5. æŒ‡æ•°ç±»åž‹ï¼šé€šè¿‡ä½™å•å­å®šä¹‰

### 5.2 æ“ä½œè¯­ä¹‰

**å®šä¹‰ 5.4 (çº¿æ€§å½’çº¦)**
çº¿æ€§å½’çº¦è§„åˆ™ï¼š

- $(\lambda x.e)v \rightarrow e[v/x]$ (Î²å½’çº¦)
- $\text{let } (x, y) = (e_1, e_2) \text{ in } e' \rightarrow e'[e_1/x, e_2/y]$ (å¼ é‡ç§¯å½’çº¦)
- $\text{let } !x = !e \text{ in } e' \rightarrow e'[e/x]$ (æŒ‡æ•°å½’çº¦)

**å®šç† 5.2 (çº¿æ€§å½’çº¦ä¿æŒç±»åž‹)**
å¦‚æžœ $\Gamma \vdash e : \tau$ ä¸” $e \rightarrow e'$ï¼Œåˆ™ $\Gamma \vdash e' : \tau$ã€‚

**è¯æ˜Žï¼š** é€šè¿‡å½’çº¦è§„åˆ™ï¼š

1. Î²å½’çº¦ï¼šé€šè¿‡æ›¿æ¢å¼•ç†
2. å¼ é‡ç§¯å½’çº¦ï¼šé€šè¿‡æŠ•å½±
3. æŒ‡æ•°å½’çº¦ï¼šé€šè¿‡å¼±åŒ–

**å®šç† 5.3 (çº¿æ€§å¼ºæ­£è§„åŒ–)**
åœ¨çº¿æ€§ç±»åž‹ç³»ç»Ÿä¸­ï¼Œæ‰€æœ‰è‰¯ç±»åž‹çš„é¡¹éƒ½æ˜¯å¼ºæ­£è§„åŒ–çš„ã€‚

**è¯æ˜Žï¼š** é€šè¿‡çº¿æ€§æ€§çº¦æŸï¼š

1. æ¯ä¸ªå˜é‡åªèƒ½ä½¿ç”¨ä¸€æ¬¡
2. é™åˆ¶äº†å½’çº¦çš„å¤æ‚æ€§
3. å› æ­¤ä¸ä¼šå‡ºçŽ°æ— é™å½’çº¦

## 6 é«˜çº§çº¿æ€§ç±»åž‹æž„é€ 

### 6.1 çº¿æ€§å•å­

**å®šä¹‰ 6.1 (çº¿æ€§å•å­)**
çº¿æ€§å•å­æ˜¯ä¸‰å…ƒç»„ $(M, \text{return}, \text{bind})$ï¼Œå…¶ä¸­ï¼š

- $M : \text{Type} \rightarrow \text{Type}$ æ˜¯çº¿æ€§ç±»åž‹æž„é€ å­
- $\text{return} : A \multimap M(A)$
- $\text{bind} : M(A) \multimap (A \multimap M(B)) \multimap M(B)$

**å®šç† 6.1 (çº¿æ€§å•å­å¾‹)**
çº¿æ€§å•å­æ»¡è¶³ä»¥ä¸‹å¾‹ï¼š

1. $\text{bind}(\text{return}(a), f) = f(a)$ (å·¦å•ä½å¾‹)
2. $\text{bind}(m, \text{return}) = m$ (å³å•ä½å¾‹)
3. $\text{bind}(\text{bind}(m, f), g) = \text{bind}(m, \lambda x.\text{bind}(f(x), g))$ (ç»“åˆå¾‹)

**è¯æ˜Žï¼š** é€šè¿‡çº¿æ€§ç±»åž‹ç³»ç»Ÿï¼š

1. å·¦å•ä½å¾‹ï¼šç›´æŽ¥åº”ç”¨å®šä¹‰
2. å³å•ä½å¾‹ï¼šé€šè¿‡æ’ç­‰å‡½æ•°
3. ç»“åˆå¾‹ï¼šé€šè¿‡å‡½æ•°å¤åˆ

-**å®šä¹‰ 6.2 (çº¿æ€§çŠ¶æ€å•å­)**

```haskell
data LinearState s a where
  LinearState :: (s -> (a, s)) -> LinearState s a

return :: a -> LinearState s a
return a = LinearState (\s -> (a, s))

bind :: LinearState s a -> (a -> LinearState s b) -> LinearState s b
bind (LinearState f) g = LinearState (\s -> 
  let (a, s') = f s
      LinearState h = g a
  in h s')
```

**å®šç† 6.2 (çº¿æ€§çŠ¶æ€å•å­æ­£ç¡®æ€§)**
çº¿æ€§çŠ¶æ€å•å­æ»¡è¶³æ‰€æœ‰å•å­å¾‹ã€‚

**è¯æ˜Žï¼š** é€šè¿‡è®¡ç®—ï¼š

1. å·¦å•ä½å¾‹ï¼š$\text{bind}(\text{return}(a), f) = f(a)$
2. å³å•ä½å¾‹ï¼š$\text{bind}(m, \text{return}) = m$
3. ç»“åˆå¾‹ï¼šé€šè¿‡çŠ¶æ€ä¼ é€’

### 6.2 çº¿æ€§æ•ˆåº”ç³»ç»Ÿ

**å®šä¹‰ 6.3 (çº¿æ€§æ•ˆåº”)**
çº¿æ€§æ•ˆåº”è¡¨ç¤ºéœ€è¦ç²¾ç¡®ç®¡ç†çš„è®¡ç®—æ•ˆåº”ï¼š
$$\text{Effect} ::= \text{IO} \mid \text{State} \mid \text{Exception} \mid \text{Resource}$$

-**å®šä¹‰ 6.4 (çº¿æ€§æ•ˆåº”å¤„ç†)**

```haskell
data LinearEffect e a where
  Pure :: a -> LinearEffect e a
  Effect :: e -> LinearEffect e a
  Bind :: LinearEffect e a -> (a -> LinearEffect e b) -> LinearEffect e b
```

**å®šç† 6.3 (çº¿æ€§æ•ˆåº”å®‰å…¨)**
çº¿æ€§æ•ˆåº”ç³»ç»Ÿä¿è¯æ•ˆåº”å®‰å…¨ã€‚

**è¯æ˜Žï¼š** é€šè¿‡çº¿æ€§ç±»åž‹ç³»ç»Ÿï¼š

1. æ¯ä¸ªæ•ˆåº”æœ€å¤šæ‰§è¡Œä¸€æ¬¡
2. æ•ˆåº”é¡ºåºç¡®å®š
3. ä¸ä¼šå‡ºçŽ°æ•ˆåº”æ³„æ¼

## 7 å®žé™…åº”ç”¨

### 7.1 Rustæ‰€æœ‰æƒç³»ç»Ÿ

**å®šä¹‰ 7.1 (Rustæ‰€æœ‰æƒ)**
Rustçš„æ‰€æœ‰æƒç³»ç»ŸåŸºäºŽçº¿æ€§ç±»åž‹ç†è®ºï¼š

```rust
fn consume_string(s: String) {
    // s è¢«æ¶ˆè´¹ï¼Œæ— æ³•å†æ¬¡ä½¿ç”¨
}

fn main() {
    let s = String::from("hello");
    consume_string(s);
    // è¿™é‡Œæ— æ³•ä½¿ç”¨ sï¼Œå› ä¸ºå®ƒå·²ç»è¢«æ¶ˆè´¹
}
```

**å®šç† 7.1 (Rustå†…å­˜å®‰å…¨)**
Rustçš„æ‰€æœ‰æƒç³»ç»Ÿä¿è¯å†…å­˜å®‰å…¨ã€‚

**è¯æ˜Žï¼š** é€šè¿‡çº¿æ€§ç±»åž‹ç³»ç»Ÿçš„æ€§è´¨ï¼š

1. æ¯ä¸ªå€¼æœ€å¤šæœ‰ä¸€ä¸ªæ‰€æœ‰è€…
2. ç§»åŠ¨æ“ä½œè½¬ç§»æ‰€æœ‰æƒ
3. å€Ÿç”¨æ£€æŸ¥é˜²æ­¢æ•°æ®ç«žäº‰

-**å®šä¹‰ 7.2 (Rustå€Ÿç”¨)**

```rust
fn borrow_string(s: &String) {
    // s æ˜¯å€Ÿç”¨ï¼Œä¸ä¼šè½¬ç§»æ‰€æœ‰æƒ
}

fn main() {
    let s = String::from("hello");
    borrow_string(&s);
    // è¿™é‡Œä»ç„¶å¯ä»¥ä½¿ç”¨ s
}
```

**å®šç† 7.2 (Rustå€Ÿç”¨å®‰å…¨)**
Rustçš„å€Ÿç”¨ç³»ç»Ÿä¿è¯è®¿é—®å®‰å…¨ã€‚

**è¯æ˜Žï¼š** é€šè¿‡å€Ÿç”¨è§„åˆ™ï¼š

1. å€Ÿç”¨æœŸé—´åŽŸå€¼ä¸å¯å˜
2. å€Ÿç”¨å¿…é¡»è¿”å›ž
3. å› æ­¤ä¸ä¼šå‡ºçŽ°å¹¶å‘è®¿é—®

### 7.2 å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„çº¿æ€§ç±»åž‹

-**å®šä¹‰ 7.3 (çº¿æ€§å‡½æ•°)**

```haskell
class Linear a where
  consume :: a -> ()
  duplicate :: a -> (a, a)  -- ä»…å¯¹éžçº¿æ€§ç±»åž‹å¯ç”¨
```

**å®šç† 7.3 (çº¿æ€§å‡½æ•°æ€§è´¨)**
çº¿æ€§å‡½æ•°æ»¡è¶³ï¼š

1. å‚æ•°æ°å¥½ä½¿ç”¨ä¸€æ¬¡
2. æ”¯æŒèµ„æºç®¡ç†
3. ä¿è¯å†…å­˜å®‰å…¨

**è¯æ˜Žï¼š** é€šè¿‡çº¿æ€§ç±»åž‹ç³»ç»Ÿï¼š

1. çº¿æ€§æ€§çº¦æŸç¡®ä¿å‚æ•°ä½¿ç”¨ä¸€æ¬¡
2. èµ„æºç®¡ç†é€šè¿‡çº¿æ€§æ€§ä¿è¯
3. å†…å­˜å®‰å…¨é€šè¿‡æ‰€æœ‰æƒä¿è¯

## 8 çº¿æ€§ç±»åž‹ç³»ç»Ÿå…ƒç†è®º

### 8.1 ç±»åž‹æŽ¨æ–­

-**ç®—æ³• 8.1 (çº¿æ€§ç±»åž‹æŽ¨æ–­)**

```haskell
inferLinear :: Context -> Expr -> Either TypeError (Type, Context)
inferLinear ctx (Var x) = 
  case lookup x ctx of
    Just t -> Right (t, singleton x t)
    Nothing -> Left (UnboundVariable x)

inferLinear ctx (App e1 e2) = do
  (t1, ctx1) <- inferLinear ctx e1
  (t2, ctx2) <- inferLinear (applySubst ctx1 ctx) e2
  case t1 of
    LinearArrow t1' t2' | t1' == t2 -> Right (t2', ctx1 `union` ctx2)
    _ -> Left TypeMismatch

inferLinear ctx (Abs x e) = do
  alpha <- freshVar
  (t, ctx') <- inferLinear ((x, alpha) : ctx) e
  return (LinearArrow alpha t, remove x ctx')
```

**å®šç† 8.1 (çº¿æ€§ç±»åž‹æŽ¨æ–­æ­£ç¡®æ€§)**
çº¿æ€§ç±»åž‹æŽ¨æ–­ç®—æ³•æ­£ç¡®ã€‚

**è¯æ˜Žï¼š** é€šè¿‡å½’çº³æ³•ï¼š

1. å˜é‡æƒ…å†µï¼šç›´æŽ¥æ»¡è¶³
2. åº”ç”¨æƒ…å†µï¼šé€šè¿‡ä¸Šä¸‹æ–‡åˆ†ç¦»
3. æŠ½è±¡æƒ…å†µï¼šé€šè¿‡å½’çº³å‡è®¾

### 8.2 ç±»åž‹ç­‰ä»·æ€§

**å®šä¹‰ 8.1 (ç±»åž‹ç­‰ä»·æ€§)**
ç±»åž‹ $\tau_1$ å’Œ $\tau_2$ ç­‰ä»·ï¼Œè®°ä½œ $\tau_1 \equiv \tau_2$ï¼Œå¦‚æžœï¼š

1. $\tau_1 \multimap \tau_2$ å’Œ $\tau_2 \multimap \tau_1$ éƒ½æœ‰å±…æ°‘
2. å¤åˆå¾—åˆ°æ’ç­‰å‡½æ•°

**å®šç† 8.2 (ç±»åž‹ç­‰ä»·æ€§æ€§è´¨)**
ç±»åž‹ç­‰ä»·æ€§æ˜¯ç­‰ä»·å…³ç³»ã€‚

**è¯æ˜Žï¼š** é€šè¿‡ç­‰ä»·å…³ç³»å®šä¹‰ï¼š

1. è‡ªåæ€§ï¼šæ’ç­‰å‡½æ•°
2. å¯¹ç§°æ€§ï¼šé€šè¿‡é€†å‡½æ•°
3. ä¼ é€’æ€§ï¼šé€šè¿‡å‡½æ•°å¤åˆ

## 9 ç»“è®º

é«˜çº§çº¿æ€§ç±»åž‹ç†è®ºä¸ºèµ„æºç®¡ç†å’Œå†…å­˜å®‰å…¨æä¾›äº†å¼ºå¤§çš„å½¢å¼åŒ–åŸºç¡€ï¼š

1. **ç²¾ç¡®çš„èµ„æºç®¡ç†**ï¼šç¡®ä¿æ¯ä¸ªèµ„æºæ°å¥½ä½¿ç”¨ä¸€æ¬¡
2. **å†…å­˜å®‰å…¨ä¿è¯**ï¼šé˜²æ­¢æ‚¬ç©ºæŒ‡é’ˆå’Œé‡å¤é‡Šæ”¾
3. **å¹¶å‘å®‰å…¨**ï¼šé€šè¿‡çº¿æ€§æ€§é˜²æ­¢æ•°æ®ç«žäº‰
4. **ç±»åž‹å®‰å…¨**ï¼šåœ¨ç¼–è¯‘æ—¶æ•èŽ·èµ„æºç®¡ç†é”™è¯¯
5. **å½¢å¼åŒ–ä¿è¯**ï¼šæä¾›ä¸¥æ ¼çš„æ•°å­¦è¯æ˜Ž

çº¿æ€§ç±»åž‹ç†è®ºåœ¨çŽ°ä»£ç¼–ç¨‹è¯­è¨€è®¾è®¡ä¸­å‘æŒ¥ç€å…³é”®ä½œç”¨ï¼Œç‰¹åˆ«æ˜¯åœ¨ç³»ç»Ÿç¼–ç¨‹å’Œå¹¶å‘ç¼–ç¨‹é¢†åŸŸã€‚é€šè¿‡å½¢å¼åŒ–çš„ç±»åž‹ç³»ç»Ÿï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ç¼–è¯‘æ—¶ä¿è¯ç¨‹åºçš„èµ„æºå®‰å…¨æ€§å’Œå†…å­˜å®‰å…¨æ€§ã€‚

## å‚è€ƒæ–‡çŒ®

1. Girard, J. Y. (1987). Linear logic. Theoretical computer science, 50(1), 1-101.
2. Wadler, P. (1990). Linear types can change the world! Programming concepts and methods, 347-359.
3. Abramsky, S. (1993). Computational interpretations of linear logic. Theoretical Computer Science, 111(1-2), 3-57.
4. Bierman, G. M., & de Paiva, V. (2000). On an intuitionistic modal logic. Studia Logica, 65(3), 383-416.
5. MelliÃ¨s, P. A. (2009). Categorical semantics of linear logic. Panoramas et synthÃ¨ses, 27, 15-215.
