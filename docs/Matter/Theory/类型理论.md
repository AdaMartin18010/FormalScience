# ç±»å‹ç†è®º (Type Theory)

## ğŸ“‹ ç›®å½•

- [1 æ¦‚è¿°](#1-æ¦‚è¿°)
- [2 åŸºç¡€ç±»å‹ç†è®º](#2-åŸºç¡€ç±»å‹ç†è®º)
  - [2.1 ç®€å•ç±»å‹ç†è®º (Simply Typed Lambda Calculus)](#21-ç®€å•ç±»å‹ç†è®º-simply-typed-lambda-calculus)
  - [2.2 å¤šæ€ç±»å‹ç†è®º (Polymorphic Type Theory)](#22-å¤šæ€ç±»å‹ç†è®º-polymorphic-type-theory)
- [3 é«˜çº§ç±»å‹ç³»ç»Ÿ](#3-é«˜çº§ç±»å‹ç³»ç»Ÿ)
  - [3.1 ä¾èµ–ç±»å‹ç†è®º (Dependent Type Theory)](#31-ä¾èµ–ç±»å‹ç†è®º-dependent-type-theory)
  - [3.2 çº¿æ€§ç±»å‹ç†è®º (Linear Type Theory)](#32-çº¿æ€§ç±»å‹ç†è®º-linear-type-theory)
  - [3.3 ä»¿å°„ç±»å‹ç†è®º (Affine Type Theory)](#33-ä»¿å°„ç±»å‹ç†è®º-affine-type-theory)
  - [3.4 æ—¶æ€ç±»å‹ç†è®º (Temporal Type Theory)](#34-æ—¶æ€ç±»å‹ç†è®º-temporal-type-theory)
- [4 ç±»å‹ç³»ç»Ÿåº”ç”¨](#4-ç±»å‹ç³»ç»Ÿåº”ç”¨)
  - [4.1 ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»Ÿ](#41-ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»Ÿ)
    - [1.1.1 é™æ€ç±»å‹ç³»ç»Ÿ](#111-é™æ€ç±»å‹ç³»ç»Ÿ)
    - [1.1.2 åŠ¨æ€ç±»å‹ç³»ç»Ÿ](#112-åŠ¨æ€ç±»å‹ç³»ç»Ÿ)
  - [4.2 ç±»å‹å®‰å…¨ä¿è¯](#42-ç±»å‹å®‰å…¨ä¿è¯)
    - [2.2.1 ç±»å‹å®‰å…¨å®šç†](#221-ç±»å‹å®‰å…¨å®šç†)
- [5 é«˜çº§ä¸»é¢˜](#5-é«˜çº§ä¸»é¢˜)
  - [5.1 ç±»å‹æ¨å¯¼ç®—æ³•](#51-ç±»å‹æ¨å¯¼ç®—æ³•)
    - [1.1.1 Hindley-Milnerç±»å‹æ¨å¯¼](#111-hindley-milnerç±»å‹æ¨å¯¼)
  - [5.2 ç±»å‹ç³»ç»Ÿè®¾è®¡åŸåˆ™](#52-ç±»å‹ç³»ç»Ÿè®¾è®¡åŸåˆ™)
    - [2.2.1 ç±»å‹ç³»ç»Ÿè®¾è®¡æ¨¡å¼](#221-ç±»å‹ç³»ç»Ÿè®¾è®¡æ¨¡å¼)
- [6 æ€»ç»“](#6-æ€»ç»“)

---

## 1 æ¦‚è¿°

ç±»å‹ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦å’Œæ•°å­¦é€»è¾‘ä¸­çš„ä¸€ä¸ªé‡è¦åˆ†æ”¯ï¼Œå®ƒç ”ç©¶ç±»å‹ç³»ç»Ÿã€ç±»å‹æ£€æŸ¥å’Œç±»å‹æ¨å¯¼çš„æ•°å­¦åŸºç¡€ã€‚ç±»å‹ç†è®ºä¸ä»…ä¸ºç¼–ç¨‹è¯­è¨€æä¾›äº†ç†è®ºåŸºç¡€ï¼Œä¹Ÿä¸ºå½¢å¼åŒ–æ•°å­¦å’Œé€»è¾‘æ¨ç†æä¾›äº†å·¥å…·ã€‚

## 2 åŸºç¡€ç±»å‹ç†è®º

### 2.1 ç®€å•ç±»å‹ç†è®º (Simply Typed Lambda Calculus)

**å®šä¹‰**ï¼š
ç®€å•ç±»å‹ç†è®ºæ˜¯æœ€åŸºæœ¬çš„ç±»å‹ç³»ç»Ÿï¼Œä¸ºÎ»æ¼”ç®—æ·»åŠ äº†ç±»å‹æ³¨è§£ã€‚

**è¯­æ³•**ï¼š

```text
ç±»å‹ ::= åŸºæœ¬ç±»å‹ | ç±»å‹ â†’ ç±»å‹
é¡¹ ::= å˜é‡ | Î»å˜é‡:ç±»å‹.é¡¹ | é¡¹ é¡¹
```

**å½¢å¼åŒ–è¡¨è¾¾**ï¼š

```rust
enum Type {
    Base(BaseType),
    Arrow(Box<Type>, Box<Type>)
}

enum Term {
    Var(String),
    Abs(String, Type, Box<Term>),
    App(Box<Term>, Box<Term>)
}

struct TypeContext {
    bindings: HashMap<String, Type>
}

impl TypeContext {
    fn type_check(&self, term: &Term) -> Result<Type, TypeError> {
        match term {
            Term::Var(x) => {
                self.bindings.get(x)
                    .ok_or(TypeError::UnboundVariable(x.clone()))
                    .cloned()
            },
            Term::Abs(x, t, body) => {
                let mut new_ctx = self.clone();
                new_ctx.bindings.insert(x.clone(), t.clone());
                let body_type = new_ctx.type_check(body)?;
                Ok(Type::Arrow(Box::new(t.clone()), Box::new(body_type)))
            },
            Term::App(fun, arg) => {
                let fun_type = self.type_check(fun)?;
                let arg_type = self.type_check(arg)?;
                match fun_type {
                    Type::Arrow(param_type, return_type) => {
                        if *param_type == arg_type {
                            Ok(*return_type)
                        } else {
                            Err(TypeError::TypeMismatch(*param_type, arg_type))
                        }
                    },
                    _ => Err(TypeError::NotAFunction(fun_type))
                }
            }
        }
    }
}
```

### 2.2 å¤šæ€ç±»å‹ç†è®º (Polymorphic Type Theory)

**å®šä¹‰**ï¼š
å¤šæ€ç±»å‹ç†è®ºå…è®¸ç±»å‹å˜é‡å’Œç±»å‹æŠ½è±¡ï¼Œæä¾›äº†æ›´å¼ºå¤§çš„ç±»å‹è¡¨è¾¾èƒ½åŠ›ã€‚

**è¯­æ³•**ï¼š

```text
ç±»å‹ ::= ç±»å‹å˜é‡ | âˆ€ç±»å‹å˜é‡.ç±»å‹ | ç±»å‹ â†’ ç±»å‹
é¡¹ ::= å˜é‡ | Î›ç±»å‹å˜é‡.é¡¹ | é¡¹[ç±»å‹]
```

**å½¢å¼åŒ–è¡¨è¾¾**ï¼š

```rust
enum PolyType {
    Var(String),
    ForAll(String, Box<PolyType>),
    Arrow(Box<PolyType>, Box<PolyType>)
}

enum PolyTerm {
    Var(String),
    TypeAbs(String, Box<PolyTerm>),
    TypeApp(Box<PolyTerm>, PolyType)
}

impl PolyType {
    fn instantiate(&self, type_var: &str, concrete_type: &PolyType) -> PolyType {
        match self {
            PolyType::Var(x) if x == type_var => concrete_type.clone(),
            PolyType::Var(x) => PolyType::Var(x.clone()),
            PolyType::ForAll(x, body) if x == type_var => self.clone(),
            PolyType::ForAll(x, body) => {
                PolyType::ForAll(x.clone(), Box::new(body.instantiate(type_var, concrete_type)))
            },
            PolyType::Arrow(param, ret) => {
                PolyType::Arrow(
                    Box::new(param.instantiate(type_var, concrete_type)),
                    Box::new(ret.instantiate(type_var, concrete_type))
                )
            }
        }
    }
}
```

## 3 é«˜çº§ç±»å‹ç³»ç»Ÿ

### 3.1 ä¾èµ–ç±»å‹ç†è®º (Dependent Type Theory)

**å®šä¹‰**ï¼š
ä¾èµ–ç±»å‹ç†è®ºå…è®¸ç±»å‹ä¾èµ–äºå€¼ï¼Œæä¾›äº†æ›´ç²¾ç¡®çš„ç±»å‹è¡¨è¾¾èƒ½åŠ›ã€‚

**è¯­æ³•**ï¼š

```text
ç±»å‹ ::= ç±»å‹å˜é‡ | Î å˜é‡:ç±»å‹.ç±»å‹ | Î£å˜é‡:ç±»å‹.ç±»å‹
é¡¹ ::= å˜é‡ | Î»å˜é‡:ç±»å‹.é¡¹ | é¡¹ é¡¹ | (é¡¹, é¡¹) | Ï€â‚é¡¹ | Ï€â‚‚é¡¹
```

**å½¢å¼åŒ–è¡¨è¾¾**ï¼š

```rust
enum DepType {
    Var(String),
    Pi(String, Box<Term>, Box<DepType>),
    Sigma(String, Box<Term>, Box<DepType>),
    Arrow(Box<DepType>, Box<DepType>)
}

enum DepTerm {
    Var(String),
    Abs(String, Box<Term>, Box<DepTerm>),
    App(Box<DepTerm>, Box<DepTerm>),
    Pair(Box<DepTerm>, Box<DepTerm>),
    Proj1(Box<DepTerm>),
    Proj2(Box<DepTerm>)
}

struct DepTypeContext {
    term_bindings: HashMap<String, Term>,
    type_bindings: HashMap<String, DepType>
}

impl DepTypeContext {
    fn type_check(&self, term: &DepTerm) -> Result<DepType, TypeError> {
        match term {
            DepTerm::Var(x) => {
                self.type_bindings.get(x)
                    .ok_or(TypeError::UnboundVariable(x.clone()))
                    .cloned()
            },
            DepTerm::Abs(x, t, body) => {
                let mut new_ctx = self.clone();
                new_ctx.term_bindings.insert(x.clone(), *t.clone());
                let body_type = new_ctx.type_check(body)?;
                Ok(DepType::Pi(x.clone(), t.clone(), Box::new(body_type)))
            },
            DepTerm::App(fun, arg) => {
                let fun_type = self.type_check(fun)?;
                let arg_type = self.type_check(arg)?;
                match fun_type {
                    DepType::Pi(x, param_type, return_type) => {
                        if *param_type == arg_type {
                            Ok(return_type.substitute(&x, arg))
                        } else {
                            Err(TypeError::TypeMismatch(*param_type, arg_type))
                        }
                    },
                    _ => Err(TypeError::NotAFunction(fun_type))
                }
            }
        }
    }
}
```

### 3.2 çº¿æ€§ç±»å‹ç†è®º (Linear Type Theory)

**å®šä¹‰**ï¼š
çº¿æ€§ç±»å‹ç†è®ºç¡®ä¿æ¯ä¸ªå€¼åªèƒ½ä½¿ç”¨ä¸€æ¬¡ï¼Œç”¨äºèµ„æºç®¡ç†å’Œå†…å­˜å®‰å…¨ã€‚

**è¯­æ³•**ï¼š

```text
ç±»å‹ ::= çº¿æ€§ç±»å‹ | éé™åˆ¶ç±»å‹ | ç±»å‹ âŠ— ç±»å‹ | ç±»å‹ âŠ¸ ç±»å‹
é¡¹ ::= å˜é‡ | Î»å˜é‡.é¡¹ | é¡¹ é¡¹ | é¡¹ âŠ— é¡¹ | let å˜é‡âŠ—å˜é‡ = é¡¹ in é¡¹
```

**å½¢å¼åŒ–è¡¨è¾¾**ï¼š

```rust
enum LinearType {
    Linear(BaseType),
    Unrestricted(BaseType),
    Tensor(Box<LinearType>, Box<LinearType>),
    Lollipop(Box<LinearType>, Box<LinearType>)
}

enum LinearTerm {
    Var(String),
    Abs(String, Box<LinearTerm>),
    App(Box<LinearTerm>, Box<LinearTerm>),
    Tensor(Box<LinearTerm>, Box<LinearTerm>),
    LetTensor(String, String, Box<LinearTerm>, Box<LinearTerm>)
}

struct LinearContext {
    linear_vars: HashSet<String>,
    unrestricted_vars: HashMap<String, LinearType>
}

impl LinearContext {
    fn type_check(&self, term: &LinearTerm) -> Result<(LinearType, LinearContext), TypeError> {
        match term {
            LinearTerm::Var(x) => {
                if self.linear_vars.contains(x) {
                    let mut new_ctx = self.clone();
                    new_ctx.linear_vars.remove(x);
                    Ok((LinearType::Linear(BaseType::Unit), new_ctx))
                } else if let Some(t) = self.unrestricted_vars.get(x) {
                    Ok((t.clone(), self.clone()))
                } else {
                    Err(TypeError::UnboundVariable(x.clone()))
                }
            },
            LinearTerm::Abs(x, body) => {
                let mut new_ctx = self.clone();
                new_ctx.linear_vars.insert(x.clone());
                let (body_type, final_ctx) = new_ctx.type_check(body)?;
                Ok((LinearType::Lollipop(Box::new(LinearType::Linear(BaseType::Unit)), Box::new(body_type)), final_ctx))
            },
            LinearTerm::App(fun, arg) => {
                let (fun_type, ctx1) = self.type_check(fun)?;
                let (arg_type, ctx2) = ctx1.type_check(arg)?;
                match fun_type {
                    LinearType::Lollipop(param_type, return_type) => {
                        if *param_type == arg_type {
                            Ok((*return_type, ctx2))
                        } else {
                            Err(TypeError::TypeMismatch(*param_type, arg_type))
                        }
                    },
                    _ => Err(TypeError::NotAFunction(fun_type))
                }
            }
        }
    }
}
```

### 3.3 ä»¿å°„ç±»å‹ç†è®º (Affine Type Theory)

**å®šä¹‰**ï¼š
ä»¿å°„ç±»å‹ç†è®ºå…è®¸å€¼æœ€å¤šä½¿ç”¨ä¸€æ¬¡ï¼Œæ¯”çº¿æ€§ç±»å‹æ›´å®½æ¾ï¼Œä½†ä»ä¿è¯èµ„æºå®‰å…¨ã€‚

**å½¢å¼åŒ–è¡¨è¾¾**ï¼š

```rust
enum AffineType {
    Affine(BaseType),
    Unrestricted(BaseType),
    Product(Box<AffineType>, Box<AffineType>),
    Function(Box<AffineType>, Box<AffineType>)
}

struct AffineContext {
    affine_vars: HashMap<String, AffineType>,
    unrestricted_vars: HashMap<String, AffineType>
}

impl AffineContext {
    fn use_variable(&mut self, x: &str) -> Result<AffineType, TypeError> {
        if let Some(t) = self.affine_vars.remove(x) {
            Ok(t)
        } else if let Some(t) = self.unrestricted_vars.get(x) {
            Ok(t.clone())
        } else {
            Err(TypeError::UnboundVariable(x.to_string()))
        }
    }
}
```

### 3.4 æ—¶æ€ç±»å‹ç†è®º (Temporal Type Theory)

**å®šä¹‰**ï¼š
æ—¶æ€ç±»å‹ç†è®ºå°†æ—¶é—´ç»´åº¦å¼•å…¥ç±»å‹ç³»ç»Ÿï¼Œç”¨äºæè¿°åŠ¨æ€ç³»ç»Ÿçš„è¡Œä¸ºã€‚

**è¯­æ³•**ï¼š

```text
ç±»å‹ ::= åŸºæœ¬ç±»å‹ | ç±»å‹ â†’ ç±»å‹ | â–¡ç±»å‹ | â—‡ç±»å‹ | ç±»å‹ U ç±»å‹
é¡¹ ::= å˜é‡ | Î»å˜é‡:ç±»å‹.é¡¹ | é¡¹ é¡¹ | next é¡¹ | prev é¡¹ | é¡¹ until é¡¹
```

**å½¢å¼åŒ–è¡¨è¾¾**ï¼š

```rust
enum TemporalType {
    Base(BaseType),
    Arrow(Box<TemporalType>, Box<TemporalType>),
    Always(Box<TemporalType>),  // â–¡
    Eventually(Box<TemporalType>),  // â—‡
    Until(Box<TemporalType>, Box<TemporalType>)  // U
}

enum TemporalTerm {
    Var(String),
    Abs(String, TemporalType, Box<TemporalTerm>),
    App(Box<TemporalTerm>, Box<TemporalTerm>),
    Next(Box<TemporalTerm>),
    Prev(Box<TemporalTerm>),
    Until(Box<TemporalTerm>, Box<TemporalTerm>)
}

struct TemporalContext {
    current_time: u32,
    bindings: HashMap<String, TemporalType>
}

impl TemporalContext {
    fn type_check(&self, term: &TemporalTerm) -> Result<TemporalType, TypeError> {
        match term {
            TemporalTerm::Next(t) => {
                let mut next_ctx = self.clone();
                next_ctx.current_time += 1;
                let inner_type = next_ctx.type_check(t)?;
                Ok(TemporalType::Always(Box::new(inner_type)))
            },
            TemporalTerm::Prev(t) => {
                if self.current_time > 0 {
                    let mut prev_ctx = self.clone();
                    prev_ctx.current_time -= 1;
                    prev_ctx.type_check(t)
                } else {
                    Err(TypeError::InvalidTemporalOperation)
                }
            },
            TemporalTerm::Until(left, right) => {
                let left_type = self.type_check(left)?;
                let right_type = self.type_check(right)?;
                Ok(TemporalType::Until(Box::new(left_type), Box::new(right_type)))
            }
        }
    }
}
```

## 4 ç±»å‹ç³»ç»Ÿåº”ç”¨

### 4.1 ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»Ÿ

#### 1.1.1 é™æ€ç±»å‹ç³»ç»Ÿ

```rust
trait TypeSystem {
    fn type_check(&self, program: &Program) -> Result<TypeEnv, Vec<TypeError>>;
    fn type_inference(&self, program: &Program) -> Result<TypeEnv, Vec<TypeError>>;
    fn type_erasure(&self, typed_program: &TypedProgram) -> Program;
}

struct StaticTypeChecker {
    rules: Vec<TypeRule>,
    context: TypeContext
}

impl StaticTypeChecker {
    fn check_expression(&self, expr: &Expression) -> Result<Type, TypeError> {
        match expr {
            Expression::Literal(lit) => self.check_literal(lit),
            Expression::Variable(var) => self.check_variable(var),
            Expression::Application(fun, arg) => self.check_application(fun, arg),
            Expression::Abstraction(param, body) => self.check_abstraction(param, body)
        }
    }
}
```

#### 1.1.2 åŠ¨æ€ç±»å‹ç³»ç»Ÿ

```rust
struct DynamicTypeChecker {
    runtime_types: HashMap<String, RuntimeType>
}

impl DynamicTypeChecker {
    fn check_at_runtime(&self, value: &Value) -> RuntimeType {
        match value {
            Value::Integer(_) => RuntimeType::Int,
            Value::Float(_) => RuntimeType::Float,
            Value::String(_) => RuntimeType::String,
            Value::Boolean(_) => RuntimeType::Bool,
            Value::Function(_) => RuntimeType::Function,
            Value::List(elements) => {
                if elements.is_empty() {
                    RuntimeType::List(Box::new(RuntimeType::Any))
                } else {
                    let first_type = self.check_at_runtime(&elements[0]);
                    RuntimeType::List(Box::new(first_type))
                }
            }
        }
    }
}
```

### 4.2 ç±»å‹å®‰å…¨ä¿è¯

#### 2.2.1 ç±»å‹å®‰å…¨å®šç†

```rust
trait TypeSafety {
    fn progress(&self, term: &TypedTerm) -> bool;
    fn preservation(&self, term: &TypedTerm, step: &ReductionStep) -> bool;
}

impl TypeSafety for TypeSystem {
    fn progress(&self, term: &TypedTerm) -> bool {
        match term {
            TypedTerm::Value(_) => true,
            TypedTerm::Application(fun, arg) => {
                match fun.as_ref() {
                    TypedTerm::Value(Value::Function(_)) => true,
                    _ => self.progress(fun)
                }
            }
        }
    }
    
    fn preservation(&self, term: &TypedTerm, step: &ReductionStep) -> bool {
        let original_type = self.type_of(term);
        let reduced_term = self.reduce(term, step);
        let reduced_type = self.type_of(&reduced_term);
        original_type == reduced_type
    }
}
```

## 5 é«˜çº§ä¸»é¢˜

### 5.1 ç±»å‹æ¨å¯¼ç®—æ³•

#### 1.1.1 Hindley-Milnerç±»å‹æ¨å¯¼

```rust
struct HindleyMilner {
    constraints: Vec<TypeConstraint>,
    substitution: TypeSubstitution
}

impl HindleyMilner {
    fn infer(&mut self, term: &Term) -> Result<PolyType, TypeError> {
        match term {
            Term::Var(x) => Ok(PolyType::Var(x.clone())),
            Term::Abs(x, body) => {
                let alpha = self.fresh_type_variable();
                let mut new_ctx = self.context.clone();
                new_ctx.bind(x.clone(), alpha.clone());
                let body_type = new_ctx.infer(body)?;
                Ok(PolyType::Arrow(Box::new(alpha), Box::new(body_type)))
            },
            Term::App(fun, arg) => {
                let fun_type = self.infer(fun)?;
                let arg_type = self.infer(arg)?;
                let result_type = self.fresh_type_variable();
                self.unify(&fun_type, &PolyType::Arrow(Box::new(arg_type), Box::new(result_type.clone())))?;
                Ok(result_type)
            }
        }
    }
    
    fn unify(&mut self, t1: &PolyType, t2: &PolyType) -> Result<(), TypeError> {
        match (t1, t2) {
            (PolyType::Var(x), t) | (t, PolyType::Var(x)) => {
                if self.occurs_check(x, t) {
                    self.substitution.extend(x.clone(), t.clone());
                    Ok(())
                } else {
                    Err(TypeError::OccursCheckFailed)
                }
            },
            (PolyType::Arrow(p1, r1), PolyType::Arrow(p2, r2)) => {
                self.unify(p1, p2)?;
                self.unify(r1, r2)
            },
            (PolyType::ForAll(x1, body1), PolyType::ForAll(x2, body2)) => {
                let alpha = self.fresh_type_variable();
                let body1_subst = body1.instantiate(x1, &alpha);
                let body2_subst = body2.instantiate(x2, &alpha);
                self.unify(&body1_subst, &body2_subst)
            }
        }
    }
}
```

### 5.2 ç±»å‹ç³»ç»Ÿè®¾è®¡åŸåˆ™

#### 2.2.1 ç±»å‹ç³»ç»Ÿè®¾è®¡æ¨¡å¼

```rust
trait TypeSystemDesign {
    fn soundness(&self) -> bool;
    fn completeness(&self) -> bool;
    fn decidability(&self) -> bool;
    fn expressiveness(&self) -> ExpressivenessLevel;
}

enum ExpressivenessLevel {
    Basic,      // ç®€å•ç±»å‹
    Advanced,   // é«˜çº§ç±»å‹
    Dependent,  // ä¾èµ–ç±»å‹
    Linear,     // çº¿æ€§ç±»å‹
    Temporal    // æ—¶æ€ç±»å‹
}
```

## 6 æ€»ç»“

ç±»å‹ç†è®ºä¸ºç¼–ç¨‹è¯­è¨€å’Œå½¢å¼åŒ–ç³»ç»Ÿæä¾›äº†åšå®çš„ç†è®ºåŸºç¡€ï¼š

1. **åŸºç¡€ç†è®º**ï¼šç®€å•ç±»å‹ç†è®ºã€å¤šæ€ç±»å‹ç†è®º
2. **é«˜çº§ç³»ç»Ÿ**ï¼šä¾èµ–ç±»å‹ã€çº¿æ€§ç±»å‹ã€ä»¿å°„ç±»å‹ã€æ—¶æ€ç±»å‹
3. **åº”ç”¨é¢†åŸŸ**ï¼šç¼–ç¨‹è¯­è¨€è®¾è®¡ã€ç±»å‹å®‰å…¨ä¿è¯ã€å½¢å¼åŒ–éªŒè¯
4. **ç®—æ³•æ”¯æŒ**ï¼šç±»å‹æ¨å¯¼ã€ç±»å‹æ£€æŸ¥ã€ç±»å‹æ“¦é™¤

è¿™äº›ç†è®ºä¸ä»…ä¿è¯äº†ç¨‹åºçš„æ­£ç¡®æ€§ï¼Œä¹Ÿä¸ºç³»ç»Ÿè®¾è®¡æä¾›äº†å½¢å¼åŒ–çš„å·¥å…·å’Œæ–¹æ³•ã€‚
