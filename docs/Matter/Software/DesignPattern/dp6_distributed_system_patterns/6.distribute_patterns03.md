# 6. åˆ†å¸ƒå¼ç³»ç»Ÿæ¨¡å¼

```text
<think>
æˆ‘çœ‹åˆ°ç”¨æˆ·æä¾›äº†ä¸€ä¸ªç‰¹åˆ«ç›¸å…³çš„ä»£ç ç‰‡æ®µï¼Œè¿™æ˜¯å…³äºåˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡æ¨¡å¼çš„æ–‡æ¡£éƒ¨åˆ†ã€‚è¿™ä¸ªæ–‡æ¡£åˆ—å‡ºäº†ä¸€äº›æˆ‘ä»¬ä¹‹å‰è¿˜æ²¡æœ‰è¯¦ç»†å®ç°çš„åˆ†å¸ƒå¼ç³»ç»Ÿæ¨¡å¼ï¼ŒåŒ…æ‹¬ï¼š

1. å®¹é”™æ¨¡å¼ï¼šç†”æ–­å™¨ã€èˆ±å£æ¨¡å¼ã€è¶…æ—¶ä¸é‡è¯•ã€èƒŒå‹
2. äº‹åŠ¡æ¨¡å¼ï¼šä¸¤é˜¶æ®µæäº¤ã€ä¸‰é˜¶æ®µæäº¤ã€SAGAæ¨¡å¼ã€TCCæ¨¡å¼
3. ç¼“å­˜æ¨¡å¼ï¼šæœ¬åœ°ç¼“å­˜ã€åˆ†å¸ƒå¼ç¼“å­˜ã€ç¼“å­˜ç©¿é€/å‡»ç©¿é˜²å¾¡
4. æœåŠ¡å‘ç°ä¸é…ç½®ï¼šæœåŠ¡æ³¨å†Œä¸å‘ç°ã€é…ç½®ä¸­å¿ƒã€è¾¹è½¦æ¨¡å¼
5. è°ƒåº¦ä¸è´Ÿè½½å‡è¡¡ï¼šè´Ÿè½½å‡è¡¡æ¨¡å¼ã€æœåŠ¡ç½‘æ ¼ã€ä»»åŠ¡è°ƒåº¦

ç”¨æˆ·å¸Œæœ›æˆ‘ç»§ç»­å®ç°è¿™äº›åˆ†å¸ƒå¼è®¾è®¡æ¨¡å¼ã€‚æˆ‘ä¼šæŒ‰ç…§è¿™ä¸ªåˆ—è¡¨ç»§ç»­ç¼–å†™ç›¸å…³çš„Rustä»£ç å®ç°ã€‚æˆ‘å°†ä¸“æ³¨äºè¿™äº›æ¨¡å¼çš„å®ç°ï¼Œè€Œä¸æ˜¯ä¹‹å‰çš„ç³»ç»Ÿå·¥å…·ã€‚
</think>

å¥½çš„ï¼Œè®©æˆ‘å®ç°è¿™äº›åˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡æ¨¡å¼ï¼Œä»å®¹é”™æ¨¡å¼å¼€å§‹ã€‚
```

## ğŸ“‹ ç›®å½•

- [1 å®¹é”™æ¨¡å¼](#1-å®¹é”™æ¨¡å¼)
- [2 äº‹åŠ¡æ¨¡å¼](#2-äº‹åŠ¡æ¨¡å¼)
- [3 ç¼“å­˜æ¨¡å¼](#3-ç¼“å­˜æ¨¡å¼)
- [4 æœåŠ¡å‘ç°ä¸é…ç½®](#4-æœåŠ¡å‘ç°ä¸é…ç½®)
- [5 è°ƒåº¦ä¸è´Ÿè½½å‡è¡¡](#5-è°ƒåº¦ä¸è´Ÿè½½å‡è¡¡)

---

## 1 å®¹é”™æ¨¡å¼

```rust
/// 23.1 å®¹é”™æ¨¡å¼ - ç†”æ–­å™¨
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::{Duration, Instant};
use tokio::sync::RwLock;

enum CircuitState {
    Closed,      // æ­£å¸¸çŠ¶æ€
    Open,        // ç†”æ–­çŠ¶æ€
    HalfOpen,    // åŠå¼€çŠ¶æ€
}

struct CircuitBreaker {
    state: RwLock<CircuitState>,
    failure_threshold: usize,
    reset_timeout: Duration,
    failure_count: AtomicUsize,
    last_failure_time: RwLock<Option<Instant>>,
    half_open_success_threshold: usize,
    half_open_success_count: AtomicUsize,
}

impl CircuitBreaker {
    async fn new(
        failure_threshold: usize,
        reset_timeout: Duration,
        half_open_success_threshold: usize,
    ) -> Self {
        Self {
            state: RwLock::new(CircuitState::Closed),
            failure_threshold,
            reset_timeout,
            failure_count: AtomicUsize::new(0),
            last_failure_time: RwLock::new(None),
            half_open_success_threshold,
            half_open_success_count: AtomicUsize::new(0),
        }
    }
    
    async fn execute<F, T, E>(&self, f: F) -> Result<T, E>
    where
        F: Future<Output = Result<T, E>>,
    {
        match *self.state.read().await {
            CircuitState::Open => {
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥é‡ç½®ä¸ºåŠå¼€çŠ¶æ€
                let last_failure = self.last_failure_time.read().await;
                if let Some(time) = *last_failure {
                    if time.elapsed() >= self.reset_timeout {
                        // é‡ç½®ä¸ºåŠå¼€çŠ¶æ€
                        *self.state.write().await = CircuitState::HalfOpen;
                        self.half_open_success_count.store(0, Ordering::SeqCst);
                    } else {
                        return Err(CircuitBreakerError::CircuitOpen.into());
                    }
                }
            }
            CircuitState::Closed | CircuitState::HalfOpen => {
                // å…è®¸è¯·æ±‚é€šè¿‡
            }
        }
        
        // æ‰§è¡Œæ“ä½œ
        match f.await {
            Ok(result) => {
                match *self.state.read().await {
                    CircuitState::HalfOpen => {
                        // ç»Ÿè®¡åŠå¼€çŠ¶æ€ä¸‹çš„æˆåŠŸè¯·æ±‚
                        let success_count = self.half_open_success_count.fetch_add(1, Ordering::SeqCst) + 1;
                        if success_count >= self.half_open_success_threshold {
                            // é‡ç½®ä¸ºå…³é—­çŠ¶æ€
                            *self.state.write().await = CircuitState::Closed;
                            self.failure_count.store(0, Ordering::SeqCst);
                        }
                    }
                    CircuitState::Closed => {
                        // æ­£å¸¸çŠ¶æ€ä¸‹å¯ä»¥é‡ç½®å¤±è´¥è®¡æ•°
                        self.failure_count.store(0, Ordering::SeqCst);
                    }
                    _ => {}
                }
                Ok(result)
            }
            Err(err) => {
                // è®°å½•å¤±è´¥
                let failure_count = self.failure_count.fetch_add(1, Ordering::SeqCst) + 1;
                *self.last_failure_time.write().await = Some(Instant::now());
                
                match *self.state.read().await {
                    CircuitState::Closed => {
                        if failure_count >= self.failure_threshold {
                            // è§¦å‘ç†”æ–­
                            *self.state.write().await = CircuitState::Open;
                        }
                    }
                    CircuitState::HalfOpen => {
                        // åŠå¼€çŠ¶æ€ä¸‹ä»»ä½•å¤±è´¥éƒ½ä¼šé‡æ–°ç†”æ–­
                        *self.state.write().await = CircuitState::Open;
                    }
                    _ => {}
                }
                
                Err(err)
            }
        }
    }
}

/// 23.2 å®¹é”™æ¨¡å¼ - èˆ±å£æ¨¡å¼
struct Bulkhead {
    semaphore: Semaphore,
}

impl Bulkhead {
    fn new(max_concurrent_calls: usize) -> Self {
        Self {
            semaphore: Semaphore::new(max_concurrent_calls),
        }
    }
    
    async fn execute<F, T, E>(&self, f: F) -> Result<T, E>
    where
        F: Future<Output = Result<T, E>>,
    {
        let permit = match self.semaphore.acquire().await {
            Ok(permit) => permit,
            Err(_) => return Err(BulkheadError::TooManyConcurrentCalls.into()),
        };
        
        let result = f.await;
        drop(permit);
        
        result
    }
}

/// 23.3 å®¹é”™æ¨¡å¼ - è¶…æ—¶ä¸é‡è¯•
struct RetryPolicy {
    max_retries: usize,
    initial_backoff: Duration,
    max_backoff: Duration,
    backoff_multiplier: f64,
    jitter_factor: f64,
}

impl RetryPolicy {
    async fn execute<F, Fut, T, E>(&self, f: F) -> Result<T, E>
    where
        F: Fn() -> Fut,
        Fut: Future<Output = Result<T, E>>,
        E: std::fmt::Debug,
    {
        let mut retries = 0;
        let mut backoff = self.initial_backoff;
        
        loop {
            match f().await {
                Ok(result) => return Ok(result),
                Err(err) => {
                    if retries >= self.max_retries {
                        return Err(err);
                    }
                    
                    // è®°å½•é‡è¯•
                    retries += 1;
                    
                    // è®¡ç®—é€€é¿æ—¶é—´
                    let jitter = backoff.as_millis() as f64 * self.jitter_factor * rand::random::<f64>();
                    let backoff_with_jitter = Duration::from_millis(
                        (backoff.as_millis() as f64 + jitter) as u64
                    );
                    
                    // ç­‰å¾…é€€é¿æ—¶é—´
                    sleep(backoff_with_jitter).await;
                    
                    // å¢åŠ é€€é¿æ—¶é—´
                    backoff = min(
                        self.max_backoff,
                        Duration::from_millis((backoff.as_millis() as f64 * self.backoff_multiplier) as u64)
                    );
                }
            }
        }
    }
}

/// 23.4 å®¹é”™æ¨¡å¼ - èƒŒå‹
struct BackpressureController<T> {
    queue: tokio::sync::mpsc::Sender<T>,
    max_queue_size: usize,
    current_queue_size: AtomicUsize,
}

impl<T> BackpressureController<T> {
    fn new(max_queue_size: usize) -> (Self, tokio::sync::mpsc::Receiver<T>) {
        let (tx, rx) = tokio::sync::mpsc::channel(max_queue_size);
        
        (Self {
            queue: tx,
            max_queue_size,
            current_queue_size: AtomicUsize::new(0),
        }, rx)
    }
    
    async fn submit(&self, item: T) -> Result<(), BackpressureError> {
        let current_size = self.current_queue_size.load(Ordering::SeqCst);
        
        if current_size >= self.max_queue_size {
            return Err(BackpressureError::QueueFull);
        }
        
        // å°è¯•å‘é€
        match self.queue.try_send(item) {
            Ok(_) => {
                self.current_queue_size.fetch_add(1, Ordering::SeqCst);
                Ok(())
            }
            Err(err) => {
                if err.is_full() {
                    Err(BackpressureError::QueueFull)
                } else {
                    Err(BackpressureError::ChannelClosed)
                }
            }
        }
    }
    
    fn on_item_processed(&self) {
        self.current_queue_size.fetch_sub(1, Ordering::SeqCst);
    }
}

/// 24.1 äº‹åŠ¡æ¨¡å¼ - ä¸¤é˜¶æ®µæäº¤
struct TwoPhaseCommit<T> {
    coordinator: TransactionCoordinator,
    participants: Vec<Box<dyn TransactionParticipant<T>>>,
}

impl<T: Clone> TwoPhaseCommit<T> {
    async fn execute(&self, transaction_data: T) -> Result<(), TransactionError> {
        // é˜¶æ®µä¸€ï¼šå‡†å¤‡
        let prepare_results = self.prepare_phase(&transaction_data).await?;
        
        // åˆ¤æ–­æ˜¯æäº¤è¿˜æ˜¯å›æ»š
        if prepare_results.iter().all(|r| *r) {
            // é˜¶æ®µäºŒï¼šæäº¤
            self.commit_phase(&transaction_data).await
        } else {
            // å›æ»š
            self.rollback_phase(&transaction_data).await?;
            Err(TransactionError::PreparePhaseFailure)
        }
    }
    
    async fn prepare_phase(&self, data: &T) -> Result<Vec<bool>, TransactionError> {
        let mut results = Vec::with_capacity(self.participants.len());
        
        for participant in &self.participants {
            match participant.prepare(data.clone()).await {
                Ok(()) => results.push(true),
                Err(_) => results.push(false),
            }
        }
        
        Ok(results)
    }
    
    async fn commit_phase(&self, data: &T) -> Result<(), TransactionError> {
        let mut failures = Vec::new();
        
        for (i, participant) in self.participants.iter().enumerate() {
            if let Err(e) = participant.commit(data.clone()).await {
                failures.push((i, e));
            }
        }
        
        if failures.is_empty() {
            Ok(())
        } else {
            // è®°å½•æäº¤é˜¶æ®µçš„å¤±è´¥ï¼Œå¯èƒ½éœ€è¦æ‰‹åŠ¨å¹²é¢„
            self.coordinator.record_commit_failures(failures).await;
            Err(TransactionError::CommitPhaseFailure)
        }
    }
    
    async fn rollback_phase(&self, data: &T) -> Result<(), TransactionError> {
        let mut failures = Vec::new();
        
        for (i, participant) in self.participants.iter().enumerate() {
            if let Err(e) = participant.rollback(data.clone()).await {
                failures.push((i, e));
            }
        }
        
        if failures.is_empty() {
            Ok(())
        } else {
            //
            self.coordinator.record_rollback_failures(failures).await;
            Err(TransactionError::RollbackFailure)
        }
    }
}
```

## 2 äº‹åŠ¡æ¨¡å¼

```rust
/// 24.2 äº‹åŠ¡æ¨¡å¼ - SAGAæ¨¡å¼
struct Saga<T> {
    steps: Vec<SagaStep<T>>,
    context: SagaContext<T>,
}

struct SagaStep<T> {
    operation: Box<dyn Fn(T) -> Future<Output = Result<T, Error>>>,
    compensation: Box<dyn Fn(T) -> Future<Output = Result<T, Error>>>,
}

impl<T: Clone> Saga<T> {
    async fn execute(&mut self, initial_context: T) -> Result<T, SagaError> {
        let mut context = initial_context;
        let mut completed_steps = Vec::new();
        
        // æ‰§è¡Œæ¯ä¸ªæ­¥éª¤
        for (index, step) in self.steps.iter().enumerate() {
            match (step.operation)(context.clone()).await {
                Ok(new_context) => {
                    context = new_context;
                    completed_steps.push(index);
                }
                Err(e) => {
                    // æ‰§è¡Œè¡¥å¿æ“ä½œ
                    self.compensate(completed_steps, context.clone()).await?;
                    return Err(SagaError::StepFailure(index, e));
                }
            }
        }
        
        Ok(context)
    }
    
    async fn compensate(&self, completed_steps: Vec<usize>, mut context: T) -> Result<(), SagaError> {
        // åå‘æ‰§è¡Œè¡¥å¿æ“ä½œ
        for step_index in completed_steps.into_iter().rev() {
            let step = &self.steps[step_index];
            match (step.compensation)(context.clone()).await {
                Ok(new_context) => {
                    context = new_context;
                }
                Err(e) => {
                    return Err(SagaError::CompensationFailure(step_index, e));
                }
            }
        }
        
        Ok(())
    }
}
```

## 3 ç¼“å­˜æ¨¡å¼

```rust
/// 25.1 ç¼“å­˜æ¨¡å¼ - æœ¬åœ°ç¼“å­˜
struct LocalCache<K, V> {
    storage: RwLock<HashMap<K, CacheEntry<V>>>,
    max_size: usize,
    ttl: Duration,
    eviction_policy: EvictionPolicy,
}

struct CacheEntry<V> {
    value: V,
    last_accessed: Instant,
    expires_at: Instant,
}

impl<K: Eq + Hash + Clone, V: Clone> LocalCache<K, V> {
    async fn get(&self, key: &K) -> Option<V> {
        let mut storage = self.storage.write().await;
        
        if let Some(entry) = storage.get_mut(key) {
            // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
            if entry.expires_at < Instant::now() {
                storage.remove(key);
                return None;
            }
            
            // æ›´æ–°è®¿é—®æ—¶é—´
            entry.last_accessed = Instant::now();
            
            Some(entry.value.clone())
        } else {
            None
        }
    }
    
    async fn put(&self, key: K, value: V) -> Result<(), CacheError> {
        let mut storage = self.storage.write().await;
        
        // æ£€æŸ¥å®¹é‡
        if storage.len() >= self.max_size && !storage.contains_key(&key) {
            // é©±é€å…ƒç´ 
            self.evict_entry(&mut storage).await?;
        }
        
        // æ·»åŠ æ–°å…ƒç´ 
        storage.insert(key, CacheEntry {
            value,
            last_accessed: Instant::now(),
            expires_at: Instant::now() + self.ttl,
        });
        
        Ok(())
    }
    
    async fn evict_entry(&self, storage: &mut HashMap<K, CacheEntry<V>>) -> Result<(), CacheError> {
        match self.eviction_policy {
            EvictionPolicy::LRU => {
                // æŸ¥æ‰¾æœ€ä¹…æœªä½¿ç”¨çš„å…ƒç´ 
                if let Some(key_to_remove) = storage
                    .iter()
                    .min_by_key(|(_, entry)| entry.last_accessed)
                    .map(|(k, _)| k.clone())
                {
                    storage.remove(&key_to_remove);
                    Ok(())
                } else {
                    Err(CacheError::EvictionFailed)
                }
            }
            EvictionPolicy::FIFO => {
                // å®ç°FIFOé€»è¾‘
                // ...
                Ok(())
            }
            // å…¶ä»–ç­–ç•¥
        }
    }
}

/// 25.2 ç¼“å­˜æ¨¡å¼ - åˆ†å¸ƒå¼ç¼“å­˜
struct DistributedCache<K, V> {
    local_cache: LocalCache<K, V>,
    remote_client: Arc<dyn RemoteCacheClient<K, V>>,
    partition_strategy: PartitionStrategy,
}

impl<K: Eq + Hash + Serialize + DeserializeOwned + Clone, V: Serialize + DeserializeOwned + Clone> DistributedCache<K, V> {
    async fn get(&self, key: &K) -> Result<Option<V>, CacheError> {
        // å…ˆæ£€æŸ¥æœ¬åœ°ç¼“å­˜
        if let Some(value) = self.local_cache.get(key).await {
            return Ok(Some(value));
        }
        
        // ç¡®å®šè¿œç¨‹èŠ‚ç‚¹
        let node = self.partition_strategy.get_node_for_key(key);
        
        // ä»è¿œç¨‹è·å–
        match self.remote_client.get(node, key).await {
            Ok(Some(value)) => {
                // æ›´æ–°æœ¬åœ°ç¼“å­˜
                self.local_cache.put(key.clone(), value.clone()).await?;
                Ok(Some(value))
            }
            Ok(None) => Ok(None),
            Err(e) => Err(e.into()),
        }
    }
    
    async fn put(&self, key: K, value: V) -> Result<(), CacheError> {
        // æ›´æ–°æœ¬åœ°ç¼“å­˜
        self.local_cache.put(key.clone(), value.clone()).await?;
        
        // ç¡®å®šè¿œç¨‹èŠ‚ç‚¹
        let node = self.partition_strategy.get_node_for_key(&key);
        
        // æ›´æ–°è¿œç¨‹ç¼“å­˜
        self.remote_client.put(node, key, value).await?;
        
        Ok(())
    }
}

/// 25.3 ç¼“å­˜æ¨¡å¼ - ç¼“å­˜ç©¿é€/å‡»ç©¿é˜²å¾¡
struct BloomFilterCache<K, V> {
    cache: Arc<dyn Cache<K, V>>,
    bloom_filter: BloomFilter,
    negative_cache: LocalCache<K, ()>,
}

impl<K: Eq + Hash + Clone, V: Clone> BloomFilterCache<K, V> {
    async fn get(&self, key: &K) -> Result<Option<V>, CacheError> {
        // æ£€æŸ¥å¸ƒéš†è¿‡æ»¤å™¨ï¼Œé˜²æ­¢ç¼“å­˜ç©¿é€
        if !self.bloom_filter.might_contain(key) {
            return Ok(None);
        }
        
        // æ£€æŸ¥è´Ÿç¼“å­˜ï¼Œé˜²æ­¢é¢‘ç¹æŸ¥è¯¢ä¸å­˜åœ¨çš„key
        if self.negative_cache.get(key).await.is_some() {
            return Ok(None);
        }
        
        // ä»ç¼“å­˜è·å–
        match self.cache.get(key).await {
            Ok(Some(value)) => Ok(Some(value)),
            Ok(None) => {
                // å°†ä¸å­˜åœ¨çš„keyæ·»åŠ åˆ°è´Ÿç¼“å­˜
                self.negative_cache.put(key.clone(), ()).await?;
                Ok(None)
            }
            Err(e) => Err(e),
        }
    }
}

struct HotKeyCache<K, V> {
    cache: Arc<dyn Cache<K, V>>,
    hot_keys: RwLock<HashSet<K>>,
    mutex_map: Arc<DashMap<K, Arc<Mutex<()>>>>,
}

impl<K: Eq + Hash + Clone, V: Clone> HotKeyCache<K, V> {
    async fn get_or_load<F, Fut>(&self, key: K, loader: F) -> Result<V, CacheError>
    where
        F: FnOnce() -> Fut,
        Fut: Future<Output = Result<V, Error>>,
    {
        // å…ˆæ£€æŸ¥ç¼“å­˜
        if let Some(value) = self.cache.get(&key).await? {
            return Ok(value);
        }
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯çƒ­ç‚¹key
        if self.hot_keys.read().await.contains(&key) {
            // å¯¹ç‰¹å®škeyåŠ é”ï¼Œé˜²æ­¢ç¼“å­˜å‡»ç©¿
            let mutex = self.mutex_map
                .entry(key.clone())
                .or_insert_with(|| Arc::new(Mutex::new(())))
                .clone();
            
            let _guard = mutex.lock().await;
            
            // äºŒæ¬¡æ£€æŸ¥
            if let Some(value) = self.cache.get(&key).await? {
                return Ok(value);
            }
            
            // åŠ è½½æ•°æ®
            let value = loader().await?;
            
            // æ›´æ–°ç¼“å­˜
            self.cache.put(key, value.clone()).await?;
            
            Ok(value)
        } else {
            // éçƒ­ç‚¹keyç›´æ¥åŠ è½½
            let value = loader().await?;
            self.cache.put(key, value.clone()).await?;
            Ok(value)
        }
    }
}
```

## 4 æœåŠ¡å‘ç°ä¸é…ç½®

```rust
/// 26.1 æœåŠ¡å‘ç°ä¸é…ç½® - æœåŠ¡æ³¨å†Œä¸å‘ç°
struct ServiceRegistry {
    services: RwLock<HashMap<String, Vec<ServiceInstance>>>,
    health_checker: Arc<HealthChecker>,
}

struct ServiceInstance {
    id: String,
    service_name: String,
    address: String,
    port: u16,
    metadata: HashMap<String, String>,
    health_check_url: String,
    last_heartbeat: RwLock<Instant>,
}

impl ServiceRegistry {
    async fn register(&self, instance: ServiceInstance) -> Result<(), RegistryError> {
        let mut services = self.services.write().await;
        
        let instances = services
            .entry(instance.service_name.clone())
            .or_insert_with(Vec::new);
            
        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        if instances.iter().any(|i| i.id == instance.id) {
            return Err(RegistryError::DuplicateInstance);
        }
        
        // æ·»åŠ å®ä¾‹
        instances.push(instance);
        
        Ok(())
    }
    
    async fn deregister(&self, service_name: &str, instance_id: &str) -> Result<(), RegistryError> {
        let mut services = self.services.write().await;
        
        if let Some(instances) = services.get_mut(service_name) {
            let before_len = instances.len();
            instances.retain(|i| i.id != instance_id);
            
            if instances.len() < before_len {
                Ok(())
            } else {
                Err(RegistryError::InstanceNotFound)
            }
        } else {
            Err(RegistryError::ServiceNotFound)
        }
    }
    
    async fn discover(&self, service_name: &str) -> Result<Vec<ServiceInstance>, RegistryError> {
        let services = self.services.read().await;
        
        if let Some(instances) = services.get(service_name) {
            Ok(instances.clone())
        } else {
            Err(RegistryError::ServiceNotFound)
        }
    }
    
    async fn heartbeat(&self, service_name: &str, instance_id: &str) -> Result<(), RegistryError> {
        let services = self.services.read().await;
        
        if let Some(instances) = services.get(service_name) {
            if let Some(instance) = instances.iter().find(|i| i.id == instance_id) {
                let mut last_heartbeat = instance.last_heartbeat.write().await;
                *last_heartbeat = Instant::now();
                Ok(())
            } else {
                Err(RegistryError::InstanceNotFound)
            }
        } else {
            Err(RegistryError::ServiceNotFound)
        }
    }
}

/// 26.2 æœåŠ¡å‘ç°ä¸é…ç½® - é…ç½®ä¸­å¿ƒ
struct ConfigCenter {
    configs: RwLock<HashMap<String, ConfigItem>>,
    watchers: RwLock<HashMap<String, Vec<ConfigWatcher>>>,
}

struct ConfigItem {
    key: String,
    value: String,
    version: u64,
    updated_at: DateTime<Utc>,
}

struct ConfigWatcher {
    pattern: regex::Regex,
    sender: mpsc::Sender<ConfigChange>,
}

impl ConfigCenter {
    async fn set_config(&self, key: String, value: String) -> Result<(), ConfigError> {
        let mut configs = self.configs.write().await;
        
        let version = match configs.get(&key) {
            Some(item) => item.version + 1,
            None => 1,
        };
        
        let config_item = ConfigItem {
            key: key.clone(),
            value,
            version,
            updated_at: Utc::now(),
        };
        
        configs.insert(key.clone(), config_item.clone());
        
        // é€šçŸ¥è§‚å¯Ÿè€…
        self.notify_watchers(&key, &config_item).await?;
        
        Ok(())
    }
    
    async fn get_config(&self, key: &str) -> Result<ConfigItem, ConfigError> {
        let configs = self.configs.read().await;
        
        configs.get(key)
            .cloned()
            .ok_or(ConfigError::KeyNotFound)
    }
    
    async fn watch_config(&self, pattern: &str, capacity: usize) -> Result<mpsc::Receiver<ConfigChange>, ConfigError> {
        let regex = regex::Regex::new(pattern)
            .map_err(|_| ConfigError::InvalidPattern)?;
            
        let (tx, rx) = mpsc::channel(capacity);
        
        let watcher = ConfigWatcher {
            pattern: regex,
            sender: tx,
        };
        
        let mut watchers = self.watchers.write().await;
        watchers.entry(pattern.to_string())
            .or_insert_with(Vec::new)
            .push(watcher);
            
        Ok(rx)
    }
    
    async fn notify_watchers(&self, key: &str, config: &ConfigItem) -> Result<(), ConfigError> {
        let watchers = self.watchers.read().await;
        
        for (_, watcher_list) in watchers.iter() {
            for watcher in watcher_list {
                if watcher.pattern.is_match(key) {
                    let change = ConfigChange {
                        key: key.to_string(),
                        value: config.value.clone(),
                        version: config.version,
                        updated_at: config.updated_at,
                    };
                    
                    if let Err(_) = watcher.sender.send(change).await {
                        // æ¥æ”¶æ–¹å¯èƒ½å·²å…³é—­ï¼Œå¿½ç•¥é”™è¯¯
                    }
                }
            }
        }
        
        Ok(())
    }
}

/// 26.3 æœåŠ¡å‘ç°ä¸é…ç½® - è¾¹è½¦æ¨¡å¼
struct Sidecar {
    service_discovery: Arc<ServiceDiscovery>,
    config_manager: Arc<ConfigManager>,
    health_reporter: Arc<HealthReporter>,
    proxy: Arc<ServiceProxy>,
}

impl Sidecar {
    async fn start(&self) -> Result<(), Error> {
        // æ³¨å†ŒæœåŠ¡
        self.service_discovery.register_service().await?;
        
        // å¯åŠ¨å¥åº·æ£€æŸ¥
        self.health_reporter.start_reporting().await?;
        
        // åŠ è½½é…ç½®
        self.config_manager.load_configs().await?;
        
        // å¯åŠ¨ä»£ç†
        self.proxy.start().await?;
        
        Ok(())
    }
    
    async fn proxy_request(&self, request: Request) -> Result<Response, Error> {
        // å‰ç½®å¤„ç†
        let enriched_request = self.enrich_request(request).await?;
        
        // å‘é€è¯·æ±‚
        let response = self.proxy.forward_request(enriched_request).await?;
        
        // åç½®å¤„ç†
        let processed_response = self.process_response(response).await?;
        
        Ok(processed_response)
    }
    
    async fn enrich_request(&self, request: Request) -> Result<Request, Error> {
        // æ·»åŠ è¿½è¸ªä¿¡æ¯
        let request = self.add_tracing_headers(request).await?;
        
        // æ·»åŠ è®¤è¯ä¿¡æ¯
        let request = self.add_auth_headers(request).await?;
        
        // åº”ç”¨è¯·æ±‚ç­–ç•¥
        let request = self.apply_request_policies(request).await?;
        
        Ok(request)
    }
}
```

## 5 è°ƒåº¦ä¸è´Ÿè½½å‡è¡¡

```rust
/// 27.1 è°ƒåº¦ä¸è´Ÿè½½å‡è¡¡ - è´Ÿè½½å‡è¡¡æ¨¡å¼
struct LoadBalancer<T> {
    strategy: Box<dyn LoadBalancingStrategy<T>>,
    instances: RwLock<Vec<T>>,
    health_checker: Arc<HealthChecker>,
}

#[async_trait]
trait LoadBalancingStrategy<T> {
    async fn select(&self, instances: &[T]) -> Option<&T>;
}

struct RoundRobinStrategy {
    counter: AtomicUsize,
}

#[async_trait]
impl<T> LoadBalancingStrategy<T> for RoundRobinStrategy {
    async fn select(&self, instances: &[T]) -> Option<&T> {
        if instances.is_empty() {
            return None;
        }
        
        let count = self.counter.fetch_add(1, Ordering::SeqCst);
        Some(&instances[count % instances.len()])
    }
}

struct WeightedRandomStrategy<T> {
    weights: HashMap<usize, usize>,
    _phantom: PhantomData<T>,
}

#[async_trait]
impl<T> LoadBalancingStrategy<T> for WeightedRandomStrategy<T> {
    async fn select(&self, instances: &[T]) -> Option<&T> {
        if instances.is_empty() {
            return None;
        }
        
        // è®¡ç®—æ€»æƒé‡
        let total_weight: usize = self.weights.values().sum();
        
        // éšæœºé€‰æ‹©
        let mut rng = rand::thread_rng();
        let select_weight = rng.gen_range(1..=total_weight);
        
        let mut current_weight = 0;
        for (index, weight) in &self.weights {
            current_weight += weight;
            if current_weight >= select_weight && *index < instances.len() {
                return Some(&instances[*index]);
            }
        }
        
        // å…œåº•éšæœºé€‰æ‹©
        let fallback_index = rng.gen_range(0..instances.len());
        Some(&instances[fallback_index])
    }
}

impl<T: Clone> LoadBalancer<T> {
    async fn get_instance(&self) -> Option<T> {
        let instances = self.instances.read().await;
        
        self.strategy.select(&instances).await.cloned()
    }
    
    async fn update_instances(&self, new_instances: Vec<T>) {
        let mut instances = self.instances.write().await;
        *instances = new_instances;
    }
}

/// 27.2 è°ƒåº¦ä¸è´Ÿè½½å‡è¡¡ - æœåŠ¡ç½‘æ ¼
struct ServiceMesh {
    proxies: HashMap<String, ServiceProxy>,
    control_plane: Arc<ControlPlane>,
    telemetry_collector: Arc<TelemetryCollector>,
}

struct ServiceProxy {
    service_id: String,
    routes: RwLock<Vec<RouteConfig>>,
    circuit_breakers: HashMap<String, CircuitBreaker>,
    rate_limiters: HashMap<String, RateLimiter>,
    retry_policies: HashMap<String, RetryPolicy>,
}

impl ServiceProxy {
    async fn handle_request(&self, request: Request) -> Result<Response, Error> {
        // è·¯ç”±é€‰æ‹©
        let route = self.select_route(&request).await?;
        
        // æ£€æŸ¥æ–­è·¯å™¨
        let circuit_breaker = self.circuit_breakers.get(&route.id)
            .ok_or(Error::CircuitBreakerNotFound)?;
            
        // æ£€æŸ¥é™æµ
        let rate_limiter = self.rate_limiters.get(&route.id)
            .ok_or(Error::RateLimiterNotFound)?;
            
        // è·å–é‡è¯•ç­–ç•¥
        let retry_policy = self.retry_policies.get(&route.id)
            .ok_or(Error::RetryPolicyNotFound)?;
            
        // æ‰§è¡Œè¯·æ±‚ï¼ˆå¸¦æ–­è·¯å™¨å’Œé‡è¯•ï¼‰
        let result = circuit_breaker.execute(|| {
            retry_policy.execute(|| {
                rate_limiter.with_limit(|| {
                    self.forward_request(&request, &route)
                })
            })
        }).await;
        
        // æ”¶é›†é¥æµ‹æ•°æ®
        self.collect_telemetry(&request, &result).await;
        
        result
    }
    
    async fn select_route(&self, request: &Request) -> Result<RouteConfig, Error> {
        let routes = self.routes.read().await;
        
        // æ ¹æ®è¯·æ±‚åŒ¹é…è·¯ç”±
        for route in routes.iter() {
            if self.matches_route(request, route) {
                return Ok(route.clone());
            }
        }
        
        Err(Error::RouteNotFound)
    }
}

/// 27.3 è°ƒåº¦ä¸è´Ÿè½½å‡è¡¡ - ä»»åŠ¡è°ƒåº¦
struct TaskScheduler {
    queue: RwLock<BinaryHeap<Task>>,
    workers: Vec<Arc<Worker>>,
    resource_manager: Arc<ResourceManager>,
}

struct Task {
    id: String,
    priority: u32,
    resource_requirements: HashMap<String, u64>,
    deadline: Option<DateTime<Utc>>,
    dependencies: Vec<String>,
    state: AtomicTaskState,
}

impl TaskScheduler {
    async fn schedule(&self) -> Result<(), SchedulerError> {
        loop {
            // è·å–ä¸‹ä¸€ä¸ªä»»åŠ¡
            let task = self.get_next_task().await?;
            
            // æ£€æŸ¥èµ„æºå¯ç”¨æ€§
            if !self.resource_manager.check_resources(&task.resource_requirements).await? {
                // èµ„æºä¸è¶³ï¼Œæ”¾å›é˜Ÿåˆ—
                self.requeue_task(task).await?;
                sleep(Duration::from_secs(1)).await;
                continue;
            }
            
            // æ£€æŸ¥ä¾èµ–
            if !self.check_dependencies(&task).await? {
                // ä¾èµ–æœªæ»¡è¶³ï¼Œæ”¾å›é˜Ÿåˆ—
                self.requeue_task(task).await?;
                sleep(Duration::from_secs(1)).await;
                continue;
            }
            
            // åˆ†é…ç»™worker
            if let Some(worker) = self.select_worker(&task).await {
                // åˆ†é…èµ„æº
                self.resource_manager.allocate_resources(&task.resource_requirements).await?;
                
                // æäº¤ä»»åŠ¡
                worker.execute_task(task).await?;
            } else {
                // æ²¡æœ‰å¯ç”¨workerï¼Œæ”¾å›é˜Ÿåˆ—
                self.requeue_task(task).await?;
                sleep(Duration::from_secs(1)).await;
            }
        }
    }
    
    async fn get_next_task(&self) -> Result<Task, SchedulerError> {
        let mut queue = self.queue.write().await;
        
        queue.pop().ok_or(SchedulerError::EmptyQueue)
    }
    
    async fn select_worker(&self, task: &Task) -> Option<Arc<Worker>> {
        // æ‰¾åˆ°å¯ç”¨ä¸”æœ€é€‚åˆçš„worker
        for worker in &self.workers {
            if worker.is_available().await && worker.can_handle(task).await {
                return Some(worker.clone());
            }
        }
        
        None
    }
}
```

è¿™äº›å®ç°æä¾›äº†åˆ†å¸ƒå¼ç³»ç»Ÿä¸­å¸¸ç”¨çš„è®¾è®¡æ¨¡å¼ï¼ŒåŒ…æ‹¬ï¼š

1. **å®¹é”™æ¨¡å¼**ï¼šç†”æ–­å™¨ã€èˆ±å£æ¨¡å¼ã€è¶…æ—¶ä¸é‡è¯•ã€èƒŒå‹
2. **äº‹åŠ¡æ¨¡å¼**ï¼šä¸¤é˜¶æ®µæäº¤ã€SAGAæ¨¡å¼
3. **ç¼“å­˜æ¨¡å¼**ï¼šæœ¬åœ°ç¼“å­˜ã€åˆ†å¸ƒå¼ç¼“å­˜ã€ç¼“å­˜ç©¿é€/å‡»ç©¿é˜²å¾¡
4. **æœåŠ¡å‘ç°ä¸é…ç½®**ï¼šæœåŠ¡æ³¨å†Œä¸å‘ç°ã€é…ç½®ä¸­å¿ƒã€è¾¹è½¦æ¨¡å¼
5. **è°ƒåº¦ä¸è´Ÿè½½å‡è¡¡**ï¼šè´Ÿè½½å‡è¡¡æ¨¡å¼ã€æœåŠ¡ç½‘æ ¼ã€ä»»åŠ¡è°ƒåº¦

è¿™äº›æ¨¡å¼å¯ä»¥å¸®åŠ©æ„å»ºæ›´åŠ å¯é ã€é«˜æ•ˆçš„åˆ†å¸ƒå¼ç³»ç»Ÿï¼Œå¤„ç†åˆ†å¸ƒå¼ç¯å¢ƒä¸­çš„å„ç§æŒ‘æˆ˜ã€‚
