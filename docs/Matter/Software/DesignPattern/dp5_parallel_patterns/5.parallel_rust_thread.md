# å¹¶è¡Œæ¨¡å¼(Parallel Patterns)

## ğŸ“‹ ç›®å½•

- [1 åŒæ­¥å®ç°](#1-åŒæ­¥å®ç°)
  - [1.1 æ•°æ®å¹¶è¡Œæ¨¡å¼Data Parallelism](#11-æ•°æ®å¹¶è¡Œæ¨¡å¼data-parallelism)
  - [1.2 ä»»åŠ¡å¹¶è¡Œæ¨¡å¼Task Parallelism](#12-ä»»åŠ¡å¹¶è¡Œæ¨¡å¼task-parallelism)
  - [1.3 æµæ°´çº¿å¹¶è¡Œæ¨¡å¼Pipeline Parallelism](#13-æµæ°´çº¿å¹¶è¡Œæ¨¡å¼pipeline-parallelism)
  - [1.4 å·¥ä½œåˆ†å‰²æ¨¡å¼Work Decomposition](#14-å·¥ä½œåˆ†å‰²æ¨¡å¼work-decomposition)
  - [1.5 å·¥ä½œçªƒå–æ¨¡å¼Work Stealing](#15-å·¥ä½œçªƒå–æ¨¡å¼work-stealing)
  - [1.6 ä¸»ä»æ¨¡å¼Master-Worker](#16-ä¸»ä»æ¨¡å¼master-worker)
  - [1.7 åˆ†è€Œæ²»ä¹‹æ¨¡å¼Divide and Conquer](#17-åˆ†è€Œæ²»ä¹‹æ¨¡å¼divide-and-conquer)
  - [1.8 å¹¶è¡Œç®—æ³•æ¨¡å¼Parallel Algorithm](#18-å¹¶è¡Œç®—æ³•æ¨¡å¼parallel-algorithm)
  - [1.9 å¹¶è¡Œè¿­ä»£æ¨¡å¼Parallel Iteration](#19-å¹¶è¡Œè¿­ä»£æ¨¡å¼parallel-iteration)
  - [1.10 å¹¶è¡Œæœç´¢æ¨¡å¼Parallel Search](#110-å¹¶è¡Œæœç´¢æ¨¡å¼parallel-search)
  - [1.11 å¹¶è¡Œæ„å»ºæ¨¡å¼Parallel Build](#111-å¹¶è¡Œæ„å»ºæ¨¡å¼parallel-build)
  - [1.12 å¹¶è¡Œé€’å½’æ¨¡å¼Parallel Recursive](#112-å¹¶è¡Œé€’å½’æ¨¡å¼parallel-recursive)
  - [1.13 å¹¶è¡Œæ’åºæ¨¡å¼Parallel Sorting](#113-å¹¶è¡Œæ’åºæ¨¡å¼parallel-sorting)
  - [1.14 å¹¶è¡Œæ•°æ®æµæ¨¡å¼Parallel Data Streaming](#114-å¹¶è¡Œæ•°æ®æµæ¨¡å¼parallel-data-streaming)
  - [1.15 æ€»ç»“](#115-æ€»ç»“)

---

## 1 åŒæ­¥å®ç°

ä»¥ä¸‹æ˜¯ä½¿ç”¨ Rust 2024 ç‰ˆæœ¬å®ç°çš„å¹¶è¡Œæ¨¡å¼ç¤ºä¾‹ï¼Œ
åŒ…æ‹¬æ•°æ®å¹¶è¡Œæ¨¡å¼ã€ä»»åŠ¡å¹¶è¡Œæ¨¡å¼ã€æµæ°´çº¿å¹¶è¡Œæ¨¡å¼ç­‰ã€‚
æ¯ä¸ªç¤ºä¾‹éƒ½å±•ç¤ºäº†å¦‚ä½•å®ç°è¿™äº›æ¨¡å¼ï¼Œå¹¶åˆ©ç”¨ Rust çš„å¤šçº¿ç¨‹ç‰¹æ€§ã€‚

### 1.1 æ•°æ®å¹¶è¡Œæ¨¡å¼Data Parallelism

```rust
use std::thread;

fn main() {
    let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let chunk_size = data.len() / 4; // å°†æ•°æ®åˆ†æˆ4å—
    let mut handles = vec![];

    for chunk in data.chunks(chunk_size) {
        let handle = thread::spawn(move || {
            let sum: i32 = chunk.iter().sum();
            println!("Sum of chunk: {}", sum);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 1.2 ä»»åŠ¡å¹¶è¡Œæ¨¡å¼Task Parallelism

```rust
use std::thread;

fn task(id: usize) {
    println!("Task {} is running", id);
}

fn main() {
    let mut handles = vec![];

    for i in 0..10 {
        let handle = thread::spawn(move || {
            task(i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 1.3 æµæ°´çº¿å¹¶è¡Œæ¨¡å¼Pipeline Parallelism

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn stage_one(data: Vec<i32>) -> Vec<i32> {
    data.into_iter().map(|x| x + 1).collect()
}

fn stage_two(data: Vec<i32>) -> Vec<i32> {
    data.into_iter().map(|x| x * 2).collect()
}

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    let data = Arc::new(Mutex::new(data));

    let data_clone = Arc::clone(&data);
    let handle_one = thread::spawn(move || {
        let data = data_clone.lock().unwrap();
        stage_one(data.clone())
    });

    let data_clone = Arc::clone(&data);
    let handle_two = thread::spawn(move || {
        let data = data_clone.lock().unwrap();
        stage_two(data.clone())
    });

    let result_one = handle_one.join().unwrap();
    let result_two = handle_two.join().unwrap();

    println!("Stage One Result: {:?}", result_one);
    println!("Stage Two Result: {:?}", result_two);
}
```

### 1.4 å·¥ä½œåˆ†å‰²æ¨¡å¼Work Decomposition

```rust
use std::thread;

fn compute(id: usize) {
    println!("Worker {} is computing", id);
}

fn main() {
    let mut handles = vec![];

    for i in 0..10 {
        let handle = thread::spawn(move || {
            compute(i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 1.5 å·¥ä½œçªƒå–æ¨¡å¼Work Stealing

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::VecDeque;

struct Worker {
    id: usize,
    tasks: Arc<Mutex<VecDeque<Box<dyn FnOnce() + Send>>>>,
}

impl Worker {
    fn new(id: usize, tasks: Arc<Mutex<VecDeque<Box<dyn FnOnce() + Send>>>>) -> Self {
        Worker { id, tasks }
    }

    fn work(&self) {
        while let Some(task) = self.tasks.lock().unwrap().pop_front() {
            println!("Worker {} is executing a task", self.id);
            task();
        }
    }
}

fn main() {
    let tasks = Arc::new(Mutex::new(VecDeque::new()));
    let mut workers = vec![];

    for id in 0..4 {
        let tasks_clone = Arc::clone(&tasks);
        let worker = Worker::new(id, tasks_clone);
        workers.push(thread::spawn(move || worker.work()));
    }

    for i in 0..10 {
        tasks.lock().unwrap().push_back(Box::new(move || {
            println!("Task {} is executed", i);
        }));
    }

    for worker in workers {
        worker.join().unwrap();
    }
}
```

### 1.6 ä¸»ä»æ¨¡å¼Master-Worker

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn worker(id: usize) {
    println!("Worker {} is doing work", id);
}

fn main() {
    let num_workers = 4;
    let mut handles = vec![];

    for id in 0..num_workers {
        let handle = thread::spawn(move || {
            worker(id);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 1.7 åˆ†è€Œæ²»ä¹‹æ¨¡å¼Divide and Conquer

```rust
use std::thread;

fn divide_and_conquer(data: &[i32]) -> i32 {
    if data.len() == 1 {
        return data[0];
    }

    let mid = data.len() / 2;
    let left = data[..mid].to_vec();
    let right = data[mid..].to_vec();

    let left_handle = thread::spawn(move || divide_and_conquer(&left));
    let right_result = divide_and_conquer(&right);
    let left_result = left_handle.join().unwrap();

    left_result + right_result
}

fn main() {
    let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let result = divide_and_conquer(&data);
    println!("Result: {}", result);
}
```

### 1.8 å¹¶è¡Œç®—æ³•æ¨¡å¼Parallel Algorithm

```rust
use std::thread;

fn parallel_sum(data: &[i32]) -> i32 {
    let mid = data.len() / 2;
    let left = data[..mid].to_vec();
    let right = data[mid..].to_vec();

    let left_handle = thread::spawn(move || left.iter().sum::<i32>());
    let right_result = right.iter().sum::<i32>();
    let left_result = left_handle.join().unwrap();

    left_result + right_result
}

fn main() {
    let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let result = parallel_sum(&data);
    println!("Sum: {}", result);
}
```

### 1.9 å¹¶è¡Œè¿­ä»£æ¨¡å¼Parallel Iteration

```rust
use std::thread;

fn main() {
    let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let mut handles = vec![];

    for chunk in data.chunks(2) {
        let chunk = chunk.to_vec();
        let handle = thread::spawn(move || {
            let sum: i32 = chunk.iter().sum();
            println!("Sum of chunk: {}", sum);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 1.10 å¹¶è¡Œæœç´¢æ¨¡å¼Parallel Search

```rust
use std::thread;

fn search(data: &[i32], target: i32) -> bool {
    data.iter().any(|&x| x == target)
}

fn main() {
    let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let target = 5;
    let mid = data.len() / 2;

    let left_handle = thread::spawn(move || search(&data[..mid], target));
    let right_result = search(&data[mid..], target);
    let left_result = left_handle.join().unwrap();

    if left_result || right_result {
        println!("Found {}", target);
    } else {
        println!("Not found {}", target);
    }
}
```

### 1.11 å¹¶è¡Œæ„å»ºæ¨¡å¼Parallel Build

```rust
use std::sync::{Arc, Mutex};
use std::thread;

struct Node {
    value: i32,
    left: Option<Box<Node>>,
    right: Option<Box<Node>>,
}

fn build_tree(value: i32) -> Node {
    Node {
        value,
        left: None,
        right: None,
    }
}

fn main() {
    let root = Arc::new(Mutex::new(build_tree(1)));
    let mut handles = vec![];

    for i in 2..=10 {
        let root_clone = Arc::clone(&root);
        let handle = thread::spawn(move || {
            let mut root = root_clone.lock().unwrap();
            if root.left.is_none() {
                root.left = Some(Box::new(build_tree(i)));
            } else {
                root.right = Some(Box::new(build_tree(i)));
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Tree built with root value: {}", root.lock().unwrap().value);
}
```

### 1.12 å¹¶è¡Œé€’å½’æ¨¡å¼Parallel Recursive

```rust
use std::thread;

fn parallel_factorial(n: u32) -> u32 {
    if n <= 1 {
        return 1;
    }

    let mid = n / 2;
    let left_handle = thread::spawn(move || parallel_factorial(mid));
    let right_result = parallel_factorial(n - mid);

    left_handle.join().unwrap() * right_result
}

fn main() {
    let n = 10;
    let result = parallel_factorial(n);
    println!("Factorial of {}: {}", n, result);
}
```

### 1.13 å¹¶è¡Œæ’åºæ¨¡å¼Parallel Sorting

```rust
use std::thread;

fn parallel_sort(data: &mut [i32]) {
    if data.len() <= 1 {
        return;
    }

    let mid = data.len() / 2;
    let left = &mut data[..mid];
    let right = &mut data[mid..];

    let left_handle = thread::spawn(move || parallel_sort(left));
    parallel_sort(right);
    left_handle.join().unwrap();

    data.sort();
}

fn main() {
    let mut data = vec![5, 3, 8, 1, 2, 7, 4, 6];
    parallel_sort(&mut data);
    println!("Sorted data: {:?}", data);
}
```

### 1.14 å¹¶è¡Œæ•°æ®æµæ¨¡å¼Parallel Data Streaming

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn process_data(data: Vec<i32>) {
    let sum: i32 = data.iter().sum();
    println!("Processed sum: {}", sum);
}

fn main() {
    let data_streams = vec![
        vec![1, 2, 3],
        vec![4, 5, 6],
        vec![7, 8, 9],
        vec![10, 11, 12],
    ];

    let mut handles = vec![];

    for data in data_streams {
        let handle = thread::spawn(move || {
            process_data(data);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 1.15 æ€»ç»“

ä»¥ä¸Šç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•åœ¨ Rust ä¸­å®ç°å¤šç§å¹¶è¡Œæ¨¡å¼ã€‚
æ¯ç§æ¨¡å¼éƒ½æœ‰å…¶ç‰¹å®šçš„ç”¨é€”å’Œå®ç°æ–¹å¼ï¼Œé€‚ç”¨äºä¸åŒçš„åœºæ™¯ã€‚
é€šè¿‡ä½¿ç”¨ Rust çš„å¤šçº¿ç¨‹ç‰¹æ€§ï¼Œå¼€å‘è€…å¯ä»¥æ„å»ºå‡ºé«˜æ€§èƒ½ä¸”å®‰å…¨çš„åº”ç”¨ç¨‹åºã€‚
