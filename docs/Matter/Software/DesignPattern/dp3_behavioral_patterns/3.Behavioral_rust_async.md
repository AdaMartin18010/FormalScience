# è¡Œä¸ºå‹æ¨¡å¼(Behavioral Patterns)

## ğŸ“‹ ç›®å½•

- [1 å¼‚æ­¥å®ç°](#1-å¼‚æ­¥å®ç°)
  - [1.1 è´£ä»»é“¾æ¨¡å¼Chain of Responsibility Pattern](#11-è´£ä»»é“¾æ¨¡å¼chain-of-responsibility-pattern)
  - [1.2 å‘½ä»¤æ¨¡å¼Command Pattern](#12-å‘½ä»¤æ¨¡å¼command-pattern)
  - [1.3 è§£é‡Šå™¨æ¨¡å¼Interpreter Pattern](#13-è§£é‡Šå™¨æ¨¡å¼interpreter-pattern)
  - [1.4 è¿­ä»£å™¨æ¨¡å¼Iterator Pattern](#14-è¿­ä»£å™¨æ¨¡å¼iterator-pattern)
  - [1.5 ä¸­ä»‹è€…æ¨¡å¼Mediator Pattern](#15-ä¸­ä»‹è€…æ¨¡å¼mediator-pattern)
  - [1.6 å¤‡å¿˜å½•æ¨¡å¼Memento Pattern](#16-å¤‡å¿˜å½•æ¨¡å¼memento-pattern)
  - [1.7 è§‚å¯Ÿè€…æ¨¡å¼Observer Pattern](#17-è§‚å¯Ÿè€…æ¨¡å¼observer-pattern)
  - [1.8 çŠ¶æ€æ¨¡å¼State Pattern](#18-çŠ¶æ€æ¨¡å¼state-pattern)
  - [1.9 ç­–ç•¥æ¨¡å¼Strategy Pattern](#19-ç­–ç•¥æ¨¡å¼strategy-pattern)
  - [1.10 æ¨¡æ¿æ–¹æ³•æ¨¡å¼Template Method Pattern](#110-æ¨¡æ¿æ–¹æ³•æ¨¡å¼template-method-pattern)
  - [1.11 è®¿é—®è€…æ¨¡å¼Visitor Pattern](#111-è®¿é—®è€…æ¨¡å¼visitor-pattern)
  - [1.12 ç©ºå¯¹è±¡æ¨¡å¼Null Object Pattern](#112-ç©ºå¯¹è±¡æ¨¡å¼null-object-pattern)
  - [1.13 æ€»ç»“](#113-æ€»ç»“)

---

## 1 å¼‚æ­¥å®ç°

ä»¥ä¸‹æ˜¯ä½¿ç”¨ Rust 2024 ç‰ˆæœ¬çš„å¼‚æ­¥ç‰¹æ€§å®ç°çš„è¡Œä¸ºå‹è®¾è®¡æ¨¡å¼ç¤ºä¾‹ï¼Œ
åŒ…æ‹¬è´£ä»»é“¾æ¨¡å¼ã€å‘½ä»¤æ¨¡å¼ã€è§‚å¯Ÿè€…æ¨¡å¼ç­‰ã€‚
æ¯ä¸ªç¤ºä¾‹éƒ½å±•ç¤ºäº†å¦‚ä½•å®ç°è¿™äº›æ¨¡å¼ï¼Œå¹¶ä½¿ç”¨å¼‚æ­¥ç‰¹æ€§ã€‚

### 1.1 è´£ä»»é“¾æ¨¡å¼Chain of Responsibility Pattern

```rust
use std::sync::{Arc, Mutex};

// å¤„ç†è€…æ¥å£
trait Handler {
    fn set_next(&mut self, handler: Arc<dyn Handler>) -> Arc<dyn Handler>;
    fn handle(&self, request: &str) -> Option<String>;
}

// å…·ä½“å¤„ç†è€…
struct ConcreteHandlerA {
    next_handler: Option<Arc<dyn Handler>>,
}

impl Handler for ConcreteHandlerA {
    fn set_next(&mut self, handler: Arc<dyn Handler>) -> Arc<dyn Handler> {
        self.next_handler = Some(handler.clone());
        handler
    }

    fn handle(&self, request: &str) -> Option<String> {
        if request == "A" {
            Some("Handled by ConcreteHandlerA".to_string())
        } else {
            self.next_handler.as_ref()?.handle(request)
        }
    }
}

// å¦ä¸€ä¸ªå…·ä½“å¤„ç†è€…
struct ConcreteHandlerB {
    next_handler: Option<Arc<dyn Handler>>,
}

impl Handler for ConcreteHandlerB {
    fn set_next(&mut self, handler: Arc<dyn Handler>) -> Arc<dyn Handler> {
        self.next_handler = Some(handler.clone());
        handler
    }

    fn handle(&self, request: &str) -> Option<String> {
        if request == "B" {
            Some("Handled by ConcreteHandlerB".to_string())
        } else {
            self.next_handler.as_ref()?.handle(request)
        }
    }
}

#[tokio::main]
async fn main() {
    let handler_a = Arc::new(Mutex::new(ConcreteHandlerA { next_handler: None }));
    let handler_b = Arc::new(Mutex::new(ConcreteHandlerB { next_handler: None }));

    handler_a.lock().unwrap().set_next(handler_b.clone());

    let result = handler_a.lock().unwrap().handle("A");
    println!("{:?}", result); // è¾“å‡º: Some("Handled by ConcreteHandlerA")

    let result = handler_a.lock().unwrap().handle("B");
    println!("{:?}", result); // è¾“å‡º: Some("Handled by ConcreteHandlerB")

    let result = handler_a.lock().unwrap().handle("C");
    println!("{:?}", result); // è¾“å‡º: None
}
```

### 1.2 å‘½ä»¤æ¨¡å¼Command Pattern

```rust
// å‘½ä»¤æ¥å£
trait Command {
    fn execute(&self);
}

// å…·ä½“å‘½ä»¤
struct ConcreteCommand {
    receiver: Arc<dyn Receiver>,
}

impl Command for ConcreteCommand {
    fn execute(&self) {
        self.receiver.action();
    }
}

// æ¥æ”¶è€…æ¥å£
trait Receiver {
    fn action(&self);
}

// å…·ä½“æ¥æ”¶è€…
struct ConcreteReceiver;

impl Receiver for ConcreteReceiver {
    fn action(&self) {
        println!("ConcreteReceiver: Action performed.");
    }
}

// è°ƒç”¨è€…
struct Invoker {
    command: Option<Box<dyn Command>>,
}

impl Invoker {
    fn set_command(&mut self, command: Box<dyn Command>) {
        self.command = Some(command);
    }

    fn invoke(&self) {
        if let Some(command) = &self.command {
            command.execute();
        }
    }
}

#[tokio::main]
async fn main() {
    let receiver = Arc::new(ConcreteReceiver);
    let command = Box::new(ConcreteCommand { receiver });
    let mut invoker = Invoker { command: None };

    invoker.set_command(command);
    invoker.invoke(); // è¾“å‡º: ConcreteReceiver: Action performed.
}
```

### 1.3 è§£é‡Šå™¨æ¨¡å¼Interpreter Pattern

```rust
// è¡¨è¾¾å¼æ¥å£
trait Expression {
    fn interpret(&self, context: &str) -> bool;
}

// å…·ä½“è¡¨è¾¾å¼
struct TerminalExpression {
    data: String,
}

impl Expression for TerminalExpression {
    fn interpret(&self, context: &str) -> bool {
        context.contains(&self.data)
    }
}

// è§£é‡Šå™¨
struct OrExpression {
    expr1: Arc<dyn Expression>,
    expr2: Arc<dyn Expression>,
}

impl Expression for OrExpression {
    fn interpret(&self, context: &str) -> bool {
        self.expr1.interpret(context) || self.expr2.interpret(context)
    }
}

#[tokio::main]
async fn main() {
    let expr1 = Arc::new(TerminalExpression { data: "Hello".to_string() });
    let expr2 = Arc::new(TerminalExpression { data: "World".to_string() });
    let or_expr = Arc::new(OrExpression { expr1, expr2 });

    let context = "Hello, Rust!";
    println!("Context: {}", context);
    println!("Result: {}", or_expr.interpret(context)); // è¾“å‡º: Result: true
}
```

### 1.4 è¿­ä»£å™¨æ¨¡å¼Iterator Pattern

```rust
// è¿­ä»£å™¨æ¥å£
trait Iterator {
    fn next(&mut self) -> Option<i32>;
}

// èšåˆæ¥å£
trait Aggregate {
    fn create_iterator(&self) -> Box<dyn Iterator>;
}

// å…·ä½“èšåˆ
struct ConcreteAggregate {
    items: Vec<i32>,
}

impl Aggregate for ConcreteAggregate {
    fn create_iterator(&self) -> Box<dyn Iterator> {
        Box::new(ConcreteIterator {
            aggregate: self,
            index: 0,
        })
    }
}

// å…·ä½“è¿­ä»£å™¨
struct ConcreteIterator<'a> {
    aggregate: &'a ConcreteAggregate,
    index: usize,
}

impl Iterator for ConcreteIterator<'_> {
    fn next(&mut self) -> Option<i32> {
        if self.index < self.aggregate.items.len() {
            let item = self.aggregate.items[self.index];
            self.index += 1;
            Some(item)
        } else {
            None
        }
    }
}

#[tokio::main]
async fn main() {
    let aggregate = ConcreteAggregate { items: vec![1, 2, 3, 4, 5] };
    let mut iterator = aggregate.create_iterator();

    while let Some(item) = iterator.next() {
        println!("Item: {}", item);
    }
}
```

### 1.5 ä¸­ä»‹è€…æ¨¡å¼Mediator Pattern

```rust
// ä¸­ä»‹è€…æ¥å£
trait Mediator {
    fn notify(&self, colleague: &dyn Colleague, event: &str);
}

// åŒäº‹æ¥å£
trait Colleague {
    fn set_mediator(&mut self, mediator: Arc<dyn Mediator>);
    fn send(&self, event: &str);
}

// å…·ä½“åŒäº‹
struct ConcreteColleagueA {
    mediator: Option<Arc<dyn Mediator>>,
}

impl Colleague for ConcreteColleagueA {
    fn set_mediator(&mut self, mediator: Arc<dyn Mediator>) {
        self.mediator = Some(mediator);
    }

    fn send(&self, event: &str) {
        if let Some(mediator) = &self.mediator {
            mediator.notify(self, event);
        }
    }
}

// å…·ä½“ä¸­ä»‹è€…
struct ConcreteMediator {
    colleague_a: Arc<ConcreteColleagueA>,
}

impl Mediator for ConcreteMediator {
    fn notify(&self, colleague: &dyn Colleague, event: &str) {
        println!("Mediator: Notifying colleague about event: {}", event);
    }
}

#[tokio::main]
async fn main() {
    let colleague_a = Arc::new(ConcreteColleagueA { mediator: None });
    let mediator = Arc::new(ConcreteMediator { colleague_a: colleague_a.clone() });

    colleague_a.set_mediator(mediator.clone());
    colleague_a.send("Hello, Mediator!"); // è¾“å‡º: Mediator: Notifying colleague about event: Hello, Mediator!
}
```

### 1.6 å¤‡å¿˜å½•æ¨¡å¼Memento Pattern

```rust
// å¤‡å¿˜å½•
struct Memento {
    state: String,
}

impl Memento {
    fn new(state: String) -> Self {
        Memento { state }
    }

    fn get_state(&self) -> &str {
        &self.state
    }
}

// å‘èµ·äºº
struct Originator {
    state: String,
}

impl Originator {
    fn new(state: String) -> Self {
        Originator { state }
    }

    fn create_memento(&self) -> Memento {
        Memento::new(self.state.clone())
    }

    fn restore(&mut self, memento: Memento) {
        self.state = memento.get_state().to_string();
    }
}

#[tokio::main]
async fn main() {
    let mut originator = Originator::new("State1".to_string());
    let memento = originator.create_memento();

    originator.restore(memento);
    println!("Restored state: {}", originator.state); // è¾“å‡º: Restored state: State1
}
```

### 1.7 è§‚å¯Ÿè€…æ¨¡å¼Observer Pattern

```rust
use std::collections::HashSet;

// è§‚å¯Ÿè€…æ¥å£
trait Observer {
    fn update(&self, message: &str);
}

// ä¸»é¢˜æ¥å£
trait Subject {
    fn attach(&mut self, observer: Box<dyn Observer>);
    fn detach(&mut self, observer: &Box<dyn Observer>);
    fn notify(&self, message: &str);
}

// å…·ä½“ä¸»é¢˜
struct ConcreteSubject {
    observers: HashSet<Box<dyn Observer>>,
}

impl ConcreteSubject {
    fn new() -> Self {
        ConcreteSubject {
            observers: HashSet::new(),
        }
    }
}

impl Subject for ConcreteSubject {
    fn attach(&mut self, observer: Box<dyn Observer>) {
        self.observers.insert(observer);
    }

    fn detach(&mut self, observer: &Box<dyn Observer>) {
        self.observers.remove(observer);
    }

    fn notify(&self, message: &str) {
        for observer in &self.observers {
            observer.update(message);
        }
    }
}

// å…·ä½“è§‚å¯Ÿè€…
struct ConcreteObserver {
    name: String,
}

impl Observer for ConcreteObserver {
    fn update(&self, message: &str) {
        println!("{} received message: {}", self.name, message);
    }
}

#[tokio::main]
async fn main() {
    let mut subject = ConcreteSubject::new();
    let observer1 = Box::new(ConcreteObserver { name: "Observer 1".to_string() });
    let observer2 = Box::new(ConcreteObserver { name: "Observer 2".to_string() });

    subject.attach(observer1);
    subject.attach(observer2);

    subject.notify("Hello Observers!"); // è¾“å‡º: Observer 1 received message: Hello Observers!
                                         // è¾“å‡º: Observer 2 received message: Hello Observers!
}
```

### 1.8 çŠ¶æ€æ¨¡å¼State Pattern

```rust
// çŠ¶æ€æ¥å£
trait State {
    fn handle(&self);
}

// å…·ä½“çŠ¶æ€
struct ConcreteStateA;

impl State for ConcreteStateA {
    fn handle(&self) {
        println!("Handling state A");
    }
}

struct ConcreteStateB;

impl State for ConcreteStateB {
    fn handle(&self) {
        println!("Handling state B");
    }
}

// ä¸Šä¸‹æ–‡
struct Context {
    state: Box<dyn State>,
}

impl Context {
    fn set_state(&mut self, state: Box<dyn State>) {
        self.state = state;
    }

    fn request(&self) {
        self.state.handle();
    }
}

#[tokio::main]
async fn main() {
    let mut context = Context { state: Box::new(ConcreteStateA) };
    context.request(); // è¾“å‡º: Handling state A

    context.set_state(Box::new(ConcreteStateB));
    context.request(); // è¾“å‡º: Handling state B
}
```

### 1.9 ç­–ç•¥æ¨¡å¼Strategy Pattern

```rust
// ç­–ç•¥æ¥å£
trait Strategy {
    fn execute(&self);
}

// å…·ä½“ç­–ç•¥
struct ConcreteStrategyA;

impl Strategy for ConcreteStrategyA {
    fn execute(&self) {
        println!("Executing strategy A");
    }
}

struct ConcreteStrategyB;

impl Strategy for ConcreteStrategyB {
    fn execute(&self) {
        println!("Executing strategy B");
    }
}

// ä¸Šä¸‹æ–‡
struct Context {
    strategy: Box<dyn Strategy>,
}

impl Context {
    fn set_strategy(&mut self, strategy: Box<dyn Strategy>) {
        self.strategy = strategy;
    }

    fn execute_strategy(&self) {
        self.strategy.execute();
    }
}

#[tokio::main]
async fn main() {
    let mut context = Context { strategy: Box::new(ConcreteStrategyA) };
    context.execute_strategy(); // è¾“å‡º: Executing strategy A

    context.set_strategy(Box::new(ConcreteStrategyB));
    context.execute_strategy(); // è¾“å‡º: Executing strategy B
}
```

### 1.10 æ¨¡æ¿æ–¹æ³•æ¨¡å¼Template Method Pattern

```rust
// æŠ½è±¡ç±»
trait AbstractClass {
    fn template_method(&self) {
        self.step_one();
        self.step_two();
    }

    fn step_one(&self);
    fn step_two(&self);
}

// å…·ä½“ç±»
struct ConcreteClass;

impl AbstractClass for ConcreteClass {
    fn step_one(&self) {
        println!("Step One");
    }

    fn step_two(&self) {
        println!("Step Two");
    }
}

#[tokio::main]
async fn main() {
    let concrete = ConcreteClass;
    concrete.template_method(); // è¾“å‡º: Step One
                                 // è¾“å‡º: Step Two
}
```

### 1.11 è®¿é—®è€…æ¨¡å¼Visitor Pattern

```rust
// è®¿é—®è€…æ¥å£
trait Visitor {
    fn visit(&self, element: &dyn Element);
}

// å…ƒç´ æ¥å£
trait Element {
    fn accept(&self, visitor: &dyn Visitor);
}

// å…·ä½“å…ƒç´ 
struct ConcreteElementA;

impl Element for ConcreteElementA {
    fn accept(&self, visitor: &dyn Visitor) {
        visitor.visit(self);
    }
}

// å…·ä½“è®¿é—®è€…
struct ConcreteVisitor;

impl Visitor for ConcreteVisitor {
    fn visit(&self, element: &dyn Element) {
        println!("Visiting ConcreteElementA");
    }
}

#[tokio::main]
async fn main() {
    let element = ConcreteElementA;
    let visitor = ConcreteVisitor;

    element.accept(&visitor); // è¾“å‡º: Visiting ConcreteElementA
}
```

### 1.12 ç©ºå¯¹è±¡æ¨¡å¼Null Object Pattern

```rust
// æŠ½è±¡ç±»
trait AbstractObject {
    fn operation(&self);
}

// å…·ä½“å¯¹è±¡
struct RealObject;

impl AbstractObject for RealObject {
    fn operation(&self) {
        println!("RealObject: Operation performed.");
    }
}

// ç©ºå¯¹è±¡
struct NullObject;

impl AbstractObject for NullObject {
    fn operation(&self) {
        // ä¸æ‰§è¡Œä»»ä½•æ“ä½œ
    }
}

#[tokio::main]
async fn main() {
    let real_object: Box<dyn AbstractObject> = Box::new(RealObject);
    let null_object: Box<dyn AbstractObject> = Box::new(NullObject);

    real_object.operation(); // è¾“å‡º: RealObject: Operation performed.
    null_object.operation();  // ä¸è¾“å‡ºä»»ä½•å†…å®¹
}
```

### 1.13 æ€»ç»“

ä»¥ä¸Šç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•åœ¨ Rust ä¸­ä½¿ç”¨å¼‚æ­¥ç‰¹æ€§å®ç°å¤šç§è¡Œä¸ºå‹è®¾è®¡æ¨¡å¼ã€‚
æ¯ç§æ¨¡å¼éƒ½æœ‰å…¶ç‰¹å®šçš„ç”¨é€”å’Œå®ç°æ–¹å¼ï¼Œé€‚ç”¨äºä¸åŒçš„åœºæ™¯ã€‚
é€šè¿‡ä½¿ç”¨ Rust çš„å¼‚æ­¥ç‰¹æ€§ï¼Œå¼€å‘è€…å¯ä»¥æ„å»ºå‡ºé«˜æ€§èƒ½ä¸”å“åº”è¿…é€Ÿçš„åº”ç”¨ç¨‹åºã€‚
