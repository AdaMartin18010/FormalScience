# ç»“æ„å‹æ¨¡å¼(Structural Patterns)

## ğŸ“‹ ç›®å½•

- [1 åŒæ­¥å®ç°](#1-åŒæ­¥å®ç°)
  - [1.1 é€‚é…å™¨æ¨¡å¼Adapter Pattern](#11-é€‚é…å™¨æ¨¡å¼adapter-pattern)
  - [1.2 æ¡¥æ¥æ¨¡å¼Bridge Pattern](#12-æ¡¥æ¥æ¨¡å¼bridge-pattern)
  - [1.3 ç»„åˆæ¨¡å¼Composite Pattern](#13-ç»„åˆæ¨¡å¼composite-pattern)
  - [1.4 è£…é¥°å™¨æ¨¡å¼Decorator Pattern](#14-è£…é¥°å™¨æ¨¡å¼decorator-pattern)
  - [1.5 å¤–è§‚æ¨¡å¼Facade Pattern](#15-å¤–è§‚æ¨¡å¼facade-pattern)
  - [1.6 äº«å…ƒæ¨¡å¼Flyweight Pattern](#16-äº«å…ƒæ¨¡å¼flyweight-pattern)
  - [1.7 ä»£ç†æ¨¡å¼Proxy Pattern](#17-ä»£ç†æ¨¡å¼proxy-pattern)
  - [1.8 ç§æœ‰ç±»æ¨¡å¼Protected Variant Pattern](#18-ç§æœ‰ç±»æ¨¡å¼protected-variant-pattern)
  - [1.9 ä»£ç†æ¨¡å¼çš„å˜ä½“](#19-ä»£ç†æ¨¡å¼çš„å˜ä½“)
  - [1.10 ç»„åˆæ¨¡å¼çš„å˜ä½“](#110-ç»„åˆæ¨¡å¼çš„å˜ä½“)
  - [1.11 æ€»ç»“](#111-æ€»ç»“)

---

## 1 åŒæ­¥å®ç°

ä»¥ä¸‹æ˜¯ä½¿ç”¨ Rust ç¼–ç¨‹è¯­è¨€ 2024 ç‰ˆæœ¬çš„åŒæ­¥é£æ ¼å®ç°çš„ç»“æ„å‹è®¾è®¡æ¨¡å¼ç¤ºä¾‹ï¼Œ
åŒ…æ‹¬é€‚é…å™¨æ¨¡å¼ã€æ¡¥æ¥æ¨¡å¼ã€ç»„åˆæ¨¡å¼ç­‰ã€‚æ¯ä¸ªç¤ºä¾‹éƒ½å±•ç¤ºäº†å¦‚ä½•å®ç°è¿™äº›æ¨¡å¼ã€‚

### 1.1 é€‚é…å™¨æ¨¡å¼Adapter Pattern

```rust
// ç›®æ ‡æ¥å£
trait Target {
    fn request(&self) -> String;
}

// é€‚é…è€…ç±»
struct Adaptee;

impl Adaptee {
    fn specific_request(&self) -> String {
        "Adaptee's specific request".to_string()
    }
}

// é€‚é…å™¨ç±»
struct Adapter {
    adaptee: Adaptee,
}

impl Target for Adapter {
    fn request(&self) -> String {
        self.adaptee.specific_request()
    }
}

fn main() {
    let adaptee = Adaptee;
    let adapter = Adapter { adaptee };
    println!("{}", adapter.request());
}
```

### 1.2 æ¡¥æ¥æ¨¡å¼Bridge Pattern

```rust
// å®ç°æ¥å£
trait Implementor {
    fn operation_impl(&self) -> String;
}

// å…·ä½“å®ç°
struct ConcreteImplementorA;

impl Implementor for ConcreteImplementorA {
    fn operation_impl(&self) -> String {
        "ConcreteImplementorA".to_string()
    }
}

struct ConcreteImplementorB;

impl Implementor for ConcreteImplementorB {
    fn operation_impl(&self) -> String {
        "ConcreteImplementorB".to_string()
    }
}

// æŠ½è±¡ç±»
struct Abstraction {
    implementor: Box<dyn Implementor>,
}

impl Abstraction {
    fn new(implementor: Box<dyn Implementor>) -> Self {
        Abstraction { implementor }
    }

    fn operation(&self) -> String {
        self.implementor.operation_impl()
    }
}

fn main() {
    let implementor_a = Box::new(ConcreteImplementorA);
    let abstraction_a = Abstraction::new(implementor_a);
    println!("{}", abstraction_a.operation());

    let implementor_b = Box::new(ConcreteImplementorB);
    let abstraction_b = Abstraction::new(implementor_b);
    println!("{}", abstraction_b.operation());
}
```

### 1.3 ç»„åˆæ¨¡å¼Composite Pattern

```rust
// ç»„ä»¶æ¥å£
trait Component {
    fn operation(&self) -> String;
}

// å¶å­ç±»
struct Leaf {
    name: String,
}

impl Component for Leaf {
    fn operation(&self) -> String {
        format!("Leaf: {}", self.name)
    }
}

// ç»„åˆç±»
struct Composite {
    children: Vec<Box<dyn Component>>,
}

impl Component for Composite {
    fn operation(&self) -> String {
        let mut result = String::from("Composite:\n");
        for child in &self.children {
            result.push_str(&child.operation());
            result.push_str("\n");
        }
        result
    }
}

impl Composite {
    fn add(&mut self, component: Box<dyn Component>) {
        self.children.push(component);
    }
}

fn main() {
    let leaf1 = Box::new(Leaf { name: "Leaf 1".to_string() });
    let leaf2 = Box::new(Leaf { name: "Leaf 2".to_string() });

    let mut composite = Composite { children: Vec::new() };
    composite.add(leaf1);
    composite.add(leaf2);

    println!("{}", composite.operation());
}
```

### 1.4 è£…é¥°å™¨æ¨¡å¼Decorator Pattern

```rust
// åŸºç¡€æ¥å£
trait Component {
    fn operation(&self) -> String;
}

// å…·ä½“ç»„ä»¶
struct ConcreteComponent;

impl Component for ConcreteComponent {
    fn operation(&self) -> String {
        "ConcreteComponent".to_string()
    }
}

// è£…é¥°å™¨
struct Decorator {
    component: Box<dyn Component>,
}

impl Component for Decorator {
    fn operation(&self) -> String {
        format!("Decorator({})", self.component.operation())
    }
}

fn main() {
    let component = Box::new(ConcreteComponent);
    let decorated = Decorator { component };
    println!("{}", decorated.operation());
}
```

### 1.5 å¤–è§‚æ¨¡å¼Facade Pattern

```rust
// å­ç³»ç»Ÿç±»
struct SubsystemA;
impl SubsystemA {
    fn operation_a(&self) -> String {
        "Subsystem A".to_string()
    }
}

struct SubsystemB;
impl SubsystemB {
    fn operation_b(&self) -> String {
        "Subsystem B".to_string()
    }
}

// å¤–è§‚ç±»
struct Facade {
    subsystem_a: SubsystemA,
    subsystem_b: SubsystemB,
}

impl Facade {
    fn new() -> Self {
        Facade {
            subsystem_a: SubsystemA,
            subsystem_b: SubsystemB,
        }
    }

    fn operation(&self) -> String {
        format!("{} and {}", self.subsystem_a.operation_a(), self.subsystem_b.operation_b())
    }
}

fn main() {
    let facade = Facade::new();
    println!("{}", facade.operation());
}
```

### 1.6 äº«å…ƒæ¨¡å¼Flyweight Pattern

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

// äº«å…ƒæ¥å£
trait Flyweight {
    fn operation(&self, extrinsic_state: &str);
}

// å…·ä½“äº«å…ƒ
struct ConcreteFlyweight {
    intrinsic_state: String,
}

impl Flyweight for ConcreteFlyweight {
    fn operation(&self, extrinsic_state: &str) {
        println!("ConcreteFlyweight: {} - {}", self.intrinsic_state, extrinsic_state);
    }
}

// äº«å…ƒå·¥å‚
struct FlyweightFactory {
    flyweights: HashMap<String, Arc<ConcreteFlyweight>>,
}

impl FlyweightFactory {
    fn new() -> Self {
        FlyweightFactory {
            flyweights: HashMap::new(),
        }
    }

    fn get_flyweight(&mut self, key: &str) -> Arc<ConcreteFlyweight> {
        if !self.flyweights.contains_key(key) {
            self.flyweights.insert(key.to_string(), Arc::new(ConcreteFlyweight { intrinsic_state: key.to_string() }));
        }
        self.flyweights.get(key).unwrap().clone()
    }
}

fn main() {
    let mut factory = FlyweightFactory::new();
    let flyweight1 = factory.get_flyweight("A");
    let flyweight2 = factory.get_flyweight("B");
    let flyweight3 = factory.get_flyweight("A");

    flyweight1.operation("First call");
    flyweight2.operation("Second call");
    flyweight3.operation("Third call");
}
```

### 1.7 ä»£ç†æ¨¡å¼Proxy Pattern

```rust
// ä¸»é¢˜æ¥å£
trait Subject {
    fn request(&self);
}

// çœŸå®ä¸»é¢˜
struct RealSubject;

impl Subject for RealSubject {
    fn request(&self) {
        println!("RealSubject: Handling request.");
    }
}

// ä»£ç†
struct Proxy {
    real_subject: RealSubject,
}

impl Subject for Proxy {
    fn request(&self) {
        println!("Proxy: Pre-processing request.");
        self.real_subject.request();
        println!("Proxy: Post-processing request.");
    }
}

fn main() {
    let proxy = Proxy { real_subject: RealSubject };
    proxy.request();
}
```

### 1.8 ç§æœ‰ç±»æ¨¡å¼Protected Variant Pattern

```rust
// åŸºç±»
struct Base {
    value: i32,
}

impl Base {
    fn new(value: i32) -> Self {
        Base { value }
    }

    fn operation(&self) -> String {
        format!("Base value: {}", self.value)
    }
}

// æ´¾ç”Ÿç±»
struct Derived {
    base: Base,
}

impl Derived {
    fn new(value: i32) -> Self {
        Derived { base: Base::new(value) }
    }

    fn operation(&self) -> String {
        format!("Derived: {}", self.base.operation())
    }
}

fn main() {
    let derived = Derived::new(42);
    println!("{}", derived.operation());
}
```

### 1.9 ä»£ç†æ¨¡å¼çš„å˜ä½“

**è¿œç¨‹ä»£ç†ç¤ºä¾‹**:

```rust
// è¿œç¨‹ä»£ç†
struct RemoteProxy {
    address: String,
}

impl RemoteProxy {
    fn new(address: &str) -> Self {
        RemoteProxy { address: address.to_string() }
    }

    fn request(&self) {
        println!("RemoteProxy: Forwarding request to {}", self.address);
    }
}

fn main() {
    let remote_proxy = RemoteProxy::new("http://example.com");
    remote_proxy.request();
}
```

### 1.10 ç»„åˆæ¨¡å¼çš„å˜ä½“

**å®‰å…¨ç»„åˆæ¨¡å¼ç¤ºä¾‹**:

```rust
trait SafeComponent {
    fn operation(&self) -> String;
}

struct SafeLeaf {
    name: String,
}

impl SafeComponent for SafeLeaf {
    fn operation(&self) -> String {
        format!("SafeLeaf: {}", self.name)
    }
}

struct SafeComposite {
    children: Vec<Box<dyn SafeComponent>>,
}

impl SafeComponent for SafeComposite {
    fn operation(&self) -> String {
        let mut result = String::from("SafeComposite:\n");
        for child in &self.children {
            result.push_str(&child.operation());
            result.push_str("\n");
        }
        result
    }
}

impl SafeComposite {
    fn add(&mut self, component: Box<dyn SafeComponent>) {
        self.children.push(component);
    }
}

fn main() {
    let leaf1 = Box::new(SafeLeaf { name: "Leaf 1".to_string() });
    let leaf2 = Box::new(SafeLeaf { name: "Leaf 2".to_string() });

    let mut composite = SafeComposite { children: Vec::new() };
    composite.add(leaf1);
    composite.add(leaf2);

    println!("{}", composite.operation());
}
```

### 1.11 æ€»ç»“

ä»¥ä¸Šç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•åœ¨ Rust ä¸­ä½¿ç”¨åŒæ­¥é£æ ¼å®ç°å¤šç§ç»“æ„å‹è®¾è®¡æ¨¡å¼ã€‚
æ¯ç§æ¨¡å¼éƒ½æœ‰å…¶ç‰¹å®šçš„ç”¨é€”å’Œå®ç°æ–¹å¼ï¼Œé€‚ç”¨äºä¸åŒçš„åœºæ™¯ã€‚
é€šè¿‡ä½¿ç”¨ Rust çš„æ‰€æœ‰æƒã€å€Ÿç”¨å’Œç±»å‹ç³»ç»Ÿï¼Œå¼€å‘è€…å¯ä»¥æ„å»ºå‡ºé«˜æ€§èƒ½ä¸”å®‰å…¨çš„åº”ç”¨ç¨‹åºã€‚
