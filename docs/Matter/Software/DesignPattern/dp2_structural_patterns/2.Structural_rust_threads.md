# ç»“æ„å‹æ¨¡å¼(Structural Patterns)

## ğŸ“‹ ç›®å½•

- [1 å¤šçº¿ç¨‹å®ç°](#1-å¤šçº¿ç¨‹å®ç°)
  - [1.1 é€‚é…å™¨æ¨¡å¼Adapter Pattern](#11-é€‚é…å™¨æ¨¡å¼adapter-pattern)
  - [1.2 æ¡¥æ¥æ¨¡å¼Bridge Pattern](#12-æ¡¥æ¥æ¨¡å¼bridge-pattern)
  - [1.3 ç»„åˆæ¨¡å¼Composite Pattern](#13-ç»„åˆæ¨¡å¼composite-pattern)
  - [1.4 è£…é¥°å™¨æ¨¡å¼Decorator Pattern](#14-è£…é¥°å™¨æ¨¡å¼decorator-pattern)
  - [1.5 å¤–è§‚æ¨¡å¼Facade Pattern](#15-å¤–è§‚æ¨¡å¼facade-pattern)
  - [1.6 äº«å…ƒæ¨¡å¼Flyweight Pattern](#16-äº«å…ƒæ¨¡å¼flyweight-pattern)
  - [1.7 ä»£ç†æ¨¡å¼Proxy Pattern](#17-ä»£ç†æ¨¡å¼proxy-pattern)
  - [1.8 ç§æœ‰ç±»æ¨¡å¼Protected Variant Pattern](#18-ç§æœ‰ç±»æ¨¡å¼protected-variant-pattern)
  - [1.9 ä»£ç†æ¨¡å¼çš„å˜ä½“](#19-ä»£ç†æ¨¡å¼çš„å˜ä½“)
  - [1.10 ç»„åˆæ¨¡å¼çš„å˜ä½“å®‰å…¨ç»„åˆæ¨¡å¼](#110-ç»„åˆæ¨¡å¼çš„å˜ä½“å®‰å…¨ç»„åˆæ¨¡å¼)
  - [1.11 æ€»ç»“](#111-æ€»ç»“)

---

## 1 å¤šçº¿ç¨‹å®ç°

ä»¥ä¸‹æ˜¯ä½¿ç”¨ Rust 2024 ç‰ˆæœ¬çš„å¼‚æ­¥é£æ ¼ï¼ˆ`async` å’Œ `await`ï¼‰ç»“åˆå¤šçº¿ç¨‹å®ç°çš„ç»“æ„å‹è®¾è®¡æ¨¡å¼ç¤ºä¾‹ï¼ŒåŒ…æ‹¬é€‚é…å™¨æ¨¡å¼ã€æ¡¥æ¥æ¨¡å¼ã€ç»„åˆæ¨¡å¼ç­‰ã€‚

æ¯ä¸ªç¤ºä¾‹éƒ½å±•ç¤ºäº†å¦‚ä½•å®ç°è¿™äº›æ¨¡å¼ï¼Œå¹¶åˆ©ç”¨ Rust çš„å¼‚æ­¥å’Œå¤šçº¿ç¨‹ç‰¹æ€§ã€‚

### 1.1 é€‚é…å™¨æ¨¡å¼Adapter Pattern

```rust
// ç›®æ ‡æ¥å£
trait Target {
    fn request(&self);
}

// é€‚é…è€…
struct Adaptee;

impl Adaptee {
    fn specific_request(&self) {
        println!("Called specific request.");
    }
}

// é€‚é…å™¨
struct Adapter {
    adaptee: Adaptee,
}

impl Target for Adapter {
    fn request(&self) {
        self.adaptee.specific_request();
    }
}

#[tokio::main]
async fn main() {
    let adaptee = Adaptee;
    let adapter = Adapter { adaptee };

    adapter.request(); // è¾“å‡º: Called specific request.
}
```

### 1.2 æ¡¥æ¥æ¨¡å¼Bridge Pattern

```rust
trait Implementor {
    fn operation_impl(&self);
}

struct ConcreteImplementorA;

impl Implementor for ConcreteImplementorA {
    fn operation_impl(&self) {
        println!("ConcreteImplementorA operation.");
    }
}

struct ConcreteImplementorB;

impl Implementor for ConcreteImplementorB {
    fn operation_impl(&self) {
        println!("ConcreteImplementorB operation.");
    }
}

struct Abstraction {
    implementor: Box<dyn Implementor>,
}

impl Abstraction {
    fn new(implementor: Box<dyn Implementor>) -> Self {
        Abstraction { implementor }
    }

    fn operation(&self) {
        self.implementor.operation_impl();
    }
}

#[tokio::main]
async fn main() {
    let implementor_a = Box::new(ConcreteImplementorA);
    let implementor_b = Box::new(ConcreteImplementorB);

    let abstraction_a = Abstraction::new(implementor_a);
    let abstraction_b = Abstraction::new(implementor_b);

    abstraction_a.operation(); // è¾“å‡º: ConcreteImplementorA operation.
    abstraction_b.operation(); // è¾“å‡º: ConcreteImplementorB operation.
}
```

### 1.3 ç»„åˆæ¨¡å¼Composite Pattern

```rust
use std::sync::{Arc, Mutex};

trait Component {
    fn operation(&self);
}

struct Leaf {
    name: String,
}

impl Component for Leaf {
    fn operation(&self) {
        println!("Leaf: {}", self.name);
    }
}

struct Composite {
    children: Vec<Arc<dyn Component>>,
}

impl Component for Composite {
    fn operation(&self) {
        for child in &self.children {
            child.operation();
        }
    }
}

#[tokio::main]
async fn main() {
    let leaf1 = Arc::new(Leaf { name: String::from("Leaf 1") });
    let leaf2 = Arc::new(Leaf { name: String::from("Leaf 2") });

    let mut composite = Composite { children: vec![] };
    composite.children.push(leaf1);
    composite.children.push(leaf2);

    composite.operation(); // è¾“å‡º: Leaf: Leaf 1
                           // è¾“å‡º: Leaf: Leaf 2
}
```

### 1.4 è£…é¥°å™¨æ¨¡å¼Decorator Pattern

```rust
trait Component {
    fn operation(&self);
}

struct ConcreteComponent;

impl Component for ConcreteComponent {
    fn operation(&self) {
        println!("ConcreteComponent operation.");
    }
}

struct Decorator {
    component: Arc<dyn Component>,
}

impl Component for Decorator {
    fn operation(&self) {
        self.component.operation();
        self.added_behavior();
    }
}

impl Decorator {
    fn added_behavior(&self) {
        println!("Added behavior from Decorator.");
    }
}

#[tokio::main]
async fn main() {
    let component = Arc::new(ConcreteComponent);
    let decorator = Decorator { component };

    decorator.operation(); // è¾“å‡º: ConcreteComponent operation.
                           // è¾“å‡º: Added behavior from Decorator.
}
```

### 1.5 å¤–è§‚æ¨¡å¼Facade Pattern

```rust
struct SubsystemA;

impl SubsystemA {
    fn operation_a(&self) {
        println!("Subsystem A operation.");
    }
}

struct SubsystemB;

impl SubsystemB {
    fn operation_b(&self) {
        println!("Subsystem B operation.");
    }
}

struct Facade {
    subsystem_a: SubsystemA,
    subsystem_b: SubsystemB,
}

impl Facade {
    fn operation(&self) {
        self.subsystem_a.operation_a();
        self.subsystem_b.operation_b();
    }
}

#[tokio::main]
async fn main() {
    let facade = Facade {
        subsystem_a: SubsystemA,
        subsystem_b: SubsystemB,
    };

    facade.operation(); // è¾“å‡º: Subsystem A operation.
                        // è¾“å‡º: Subsystem B operation.
}
```

### 1.6 äº«å…ƒæ¨¡å¼Flyweight Pattern

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

struct Flyweight {
    intrinsic_state: String,
}

impl Flyweight {
    fn operation(&self, extrinsic_state: &str) {
        println!("Intrinsic: {}, Extrinsic: {}", self.intrinsic_state, extrinsic_state);
    }
}

struct FlyweightFactory {
    flyweights: HashMap<String, Arc<Flyweight>>,
}

impl FlyweightFactory {
    fn new() -> Self {
        FlyweightFactory {
            flyweights: HashMap::new(),
        }
    }

    fn get_flyweight(&mut self, key: &str) -> Arc<Flyweight> {
        if !self.flyweights.contains_key(key) {
            self.flyweights.insert(key.to_string(), Arc::new(Flyweight { intrinsic_state: key.to_string() }));
        }
        self.flyweights.get(key).unwrap().clone()
    }
}

#[tokio::main]
async fn main() {
    let mut factory = FlyweightFactory::new();

    let flyweight1 = factory.get_flyweight("A");
    let flyweight2 = factory.get_flyweight("B");
    let flyweight3 = factory.get_flyweight("A");

    flyweight1.operation("X");
    flyweight2.operation("Y");
    flyweight3.operation("Z"); // å…±äº«çš„ Flyweight
}
```

### 1.7 ä»£ç†æ¨¡å¼Proxy Pattern

```rust
trait Subject {
    fn request(&self);
}

struct RealSubject;

impl Subject for RealSubject {
    fn request(&self) {
        println!("RealSubject request.");
    }
}

struct Proxy {
    real_subject: Arc<RealSubject>,
}

impl Subject for Proxy {
    fn request(&self) {
        println!("Proxy request.");
        self.real_subject.request();
    }
}

#[tokio::main]
async fn main() {
    let real_subject = Arc::new(RealSubject);
    let proxy = Proxy { real_subject };

    proxy.request(); // è¾“å‡º: Proxy request.
                     // è¾“å‡º: RealSubject request.
}
```

### 1.8 ç§æœ‰ç±»æ¨¡å¼Protected Variant Pattern

```rust
trait Base {
    fn operation(&self);
}

struct ConcreteBase;

impl Base for ConcreteBase {
    fn operation(&self) {
        println!("ConcreteBase operation.");
    }
}

struct Derived {
    base: Box<dyn Base>,
}

impl Derived {
    fn new(base: Box<dyn Base>) -> Self {
        Derived { base }
    }

    fn operation(&self) {
        self.base.operation();
        println!("Derived operation.");
    }
}

#[tokio::main]
async fn main() {
    let base = Box::new(ConcreteBase);
    let derived = Derived::new(base);

    derived.operation(); // è¾“å‡º: ConcreteBase operation.
                         // è¾“å‡º: Derived operation.
}
```

### 1.9 ä»£ç†æ¨¡å¼çš„å˜ä½“

```rust
trait Image {
    fn display(&self);
}

struct RealImage {
    filename: String,
}

impl Image for RealImage {
    fn display(&self) {
        println!("Displaying {}", self.filename);
    }
}

struct ProxyImage {
    real_image: Option<RealImage>,
    filename: String,
}

impl Image for ProxyImage {
    fn display(&self) {
        if self.real_image.is_none() {
            self.real_image = Some(RealImage { filename: self.filename.clone() });
        }
        self.real_image.as_ref().unwrap().display();
    }
}

#[tokio::main]
async fn main() {
    let proxy_image = ProxyImage { real_image: None, filename: String::from("test.jpg") };
    proxy_image.display(); // è¾“å‡º: Displaying test.jpg
}
```

### 1.10 ç»„åˆæ¨¡å¼çš„å˜ä½“å®‰å…¨ç»„åˆæ¨¡å¼

```rust
use std::sync::{Arc, Mutex};

trait Component {
    fn operation(&self);
}

struct Leaf {
    name: String,
}

impl Component for Leaf {
    fn operation(&self) {
        println!("Leaf: {}", self.name);
    }
}

struct Composite {
    children: Arc<Mutex<Vec<Arc<dyn Component>>>>,
}

impl Component for Composite {
    fn operation(&self) {
        let children = self.children.lock().unwrap();
        for child in &*children {
            child.operation();
        }
    }
}

impl Composite {
    fn add(&mut self, child: Arc<dyn Component>) {
        self.children.lock().unwrap().push(child);
    }
}

#[tokio::main]
async fn main() {
    let leaf1 = Arc::new(Leaf { name: String::from("Leaf 1") });
    let leaf2 = Arc::new(Leaf { name: String::from("Leaf 2") });

    let composite = Arc::new(Mutex::new(Composite { children: Arc::new(Mutex::new(vec![])) }));
    composite.lock().unwrap().add(leaf1);
    composite.lock().unwrap().add(leaf2);

    composite.lock().unwrap().operation(); // è¾“å‡º: Leaf: Leaf 1
                                            // è¾“å‡º: Leaf: Leaf 2
}
```

### 1.11 æ€»ç»“

ä»¥ä¸Šç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•åœ¨ Rust ä¸­ä½¿ç”¨å¼‚æ­¥é£æ ¼ç»“åˆå¤šçº¿ç¨‹å®ç°å¤šç§ç»“æ„å‹è®¾è®¡æ¨¡å¼ã€‚æ¯ç§æ¨¡å¼éƒ½æœ‰å…¶ç‰¹å®šçš„ç”¨é€”å’Œå®ç°æ–¹å¼ï¼Œé€‚ç”¨äºä¸åŒçš„åœºæ™¯ã€‚é€šè¿‡ä½¿ç”¨ Rust çš„å¼‚æ­¥å’Œå¤šçº¿ç¨‹ç‰¹æ€§ï¼Œå¼€å‘è€…å¯ä»¥æ„å»ºå‡ºé«˜æ€§èƒ½ä¸”å®‰å…¨çš„åº”ç”¨ç¨‹åºã€‚
