# å¹¶å‘æ¨¡å¼(Concurrent Patterns)

## ğŸ“‹ ç›®å½•

- [1 å¼‚æ­¥å®ç°](#1-å¼‚æ­¥å®ç°)
  - [1.1 çº¿ç¨‹æ± æ¨¡å¼Thread Pool Pattern](#11-çº¿ç¨‹æ± æ¨¡å¼thread-pool-pattern)
  - [1.2 Futureæ¨¡å¼Future Pattern](#12-futureæ¨¡å¼future-pattern)
  - [1.3 Promiseæ¨¡å¼Promise Pattern](#13-promiseæ¨¡å¼promise-pattern)
  - [1.4 ååº”å™¨æ¨¡å¼Reactor Pattern](#14-ååº”å™¨æ¨¡å¼reactor-pattern)
  - [1.5 æè®®è€…æ¨¡å¼Proactor Pattern](#15-æè®®è€…æ¨¡å¼proactor-pattern)
  - [1.6 Monitor Objectæ¨¡å¼Monitor Object Pattern](#16-monitor-objectæ¨¡å¼monitor-object-pattern)
  - [1.7 é”äº’æ–¥é”æ¨¡å¼LockMutex Pattern](#17-é”äº’æ–¥é”æ¨¡å¼lockmutex-pattern)
  - [1.8 ä¿¡å·é‡æ¨¡å¼Semaphore Pattern](#18-ä¿¡å·é‡æ¨¡å¼semaphore-pattern)
  - [1.9 å±éšœæ¨¡å¼Barrier Pattern](#19-å±éšœæ¨¡å¼barrier-pattern)
  - [1.10 è¯»å†™é”æ¨¡å¼Reader-Writer Lock Pattern](#110-è¯»å†™é”æ¨¡å¼reader-writer-lock-pattern)
  - [1.11 å·¥ä½œçªƒå–æ¨¡å¼Work Stealing Pattern](#111-å·¥ä½œçªƒå–æ¨¡å¼work-stealing-pattern)
  - [1.12 Actoræ¨¡å¼Actor Pattern](#112-actoræ¨¡å¼actor-pattern)
  - [1.13 æ¡ä»¶å˜é‡æ¨¡å¼Condition Variable Pattern](#113-æ¡ä»¶å˜é‡æ¨¡å¼condition-variable-pattern)
  - [1.14 åŒé‡æ£€æŸ¥é”å®šæ¨¡å¼Double-Checked Locking Pattern](#114-åŒé‡æ£€æŸ¥é”å®šæ¨¡å¼double-checked-locking-pattern)
  - [1.15 ä¸å¯å˜æ¨¡å¼Immutable Pattern](#115-ä¸å¯å˜æ¨¡å¼immutable-pattern)
  - [1.16 æ€»ç»“](#116-æ€»ç»“)

---

## 1 å¼‚æ­¥å®ç°

ä»¥ä¸‹æ˜¯ä½¿ç”¨ Rust 2024 ç‰ˆæœ¬çš„å¼‚æ­¥ç‰¹æ€§ï¼ˆ`async`ï¼‰ç»“åˆå¤šçº¿ç¨‹å®ç°çš„å¹¶å‘æ¨¡å¼ç¤ºä¾‹ï¼Œ
åŒ…æ‹¬çº¿ç¨‹æ± æ¨¡å¼ã€Futureæ¨¡å¼ã€Promiseæ¨¡å¼ç­‰ã€‚
æ¯ä¸ªç¤ºä¾‹éƒ½å±•ç¤ºäº†å¦‚ä½•å®ç°è¿™äº›æ¨¡å¼ï¼Œå¹¶åˆ©ç”¨ Rust çš„å¼‚æ­¥å’Œå¤šçº¿ç¨‹ç‰¹æ€§ã€‚

### 1.1 çº¿ç¨‹æ± æ¨¡å¼Thread Pool Pattern

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::VecDeque;

struct ThreadPool {
    workers: Vec<Worker>,
    tasks: Arc<Mutex<VecDeque<Box<dyn FnOnce() + Send>>>>,
}

impl ThreadPool {
    fn new(size: usize) -> ThreadPool {
        let tasks = Arc::new(Mutex::new(VecDeque::new()));
        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&tasks)));
        }

        ThreadPool { workers, tasks }
    }

    fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let mut tasks = self.tasks.lock().unwrap();
        tasks.push_back(Box::new(f));
    }
}

struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

impl Worker {
    fn new(id: usize, tasks: Arc<Mutex<VecDeque<Box<dyn FnOnce() + Send>>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let task = {
                let mut tasks = tasks.lock().unwrap();
                tasks.pop_front()
            };

            if let Some(task) = task {
                task();
            } else {
                break;
            }
        });

        Worker { id, thread: Some(thread) }
    }
}

fn main() {
    let pool = ThreadPool::new(4);

    for i in 0..10 {
        pool.execute(move || {
            println!("Task {} is running", i);
        });
    }
}
```

### 1.2 Futureæ¨¡å¼Future Pattern

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use tokio::task;

struct SimpleFuture {
    value: Option<i32>,
}

impl Future for SimpleFuture {
    type Output = i32;

    fn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {
        if let Some(value) = self.value {
            Poll::Ready(value)
        } else {
            Poll::Pending
        }
    }
}

#[tokio::main]
async fn main() {
    let future = SimpleFuture { value: Some(42) };
    let result = future.await;
    println!("Future result: {}", result);
}
```

### 1.3 Promiseæ¨¡å¼Promise Pattern

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use tokio::sync::oneshot;

struct Promise<T> {
    sender: Option<oneshot::Sender<T>>,
}

impl<T> Promise<T> {
    fn new() -> (Self, oneshot::Receiver<T>) {
        let (sender, receiver) = oneshot::channel();
        (Promise { sender: Some(sender) }, receiver)
    }

    fn fulfill(&mut self, value: T) {
        if let Some(sender) = self.sender.take() {
            let _ = sender.send(value);
        }
    }
}

#[tokio::main]
async fn main() {
    let (mut promise, receiver) = Promise::new();

    thread::spawn(move || {
        thread::sleep(std::time::Duration::from_secs(2));
        promise.fulfill(42);
    });

    let result = receiver.await.unwrap();
    println!("Promise fulfilled with value: {}", result);
}
```

### 1.4 ååº”å™¨æ¨¡å¼Reactor Pattern

```rust
use tokio::net::TcpListener;
use tokio::prelude::*;

#[tokio::main]
async fn main() {
    let listener = TcpListener::bind("127.0.0.1:8080").await.unwrap();

    loop {
        let (mut socket, _) = listener.accept().await.unwrap();
        tokio::spawn(async move {
            let mut buf = [0; 1024];
            let n = socket.read(&mut buf).await.unwrap();
            socket.write_all(&buf[0..n]).await.unwrap();
        });
    }
}
```

### 1.5 æè®®è€…æ¨¡å¼Proactor Pattern

```rust
use tokio::net::TcpListener;
use tokio::prelude::*;

#[tokio::main]
async fn main() {
    let listener = TcpListener::bind("127.0.0.1:8080").await.unwrap();

    loop {
        let (mut socket, _) = listener.accept().await.unwrap();
        tokio::spawn(async move {
            let mut buf = [0; 1024];
            let n = socket.read(&mut buf).await.unwrap();
            // å¤„ç†æ•°æ®
            println!("Received: {:?}", &buf[0..n]);
            socket.write_all(&buf[0..n]).await.unwrap();
        });
    }
}
```

### 1.6 Monitor Objectæ¨¡å¼Monitor Object Pattern

```rust
use std::sync::{Arc, Mutex};
use tokio::task;

struct Monitor {
    data: Arc<Mutex<i32>>,
}

impl Monitor {
    fn new() -> Self {
        Monitor {
            data: Arc::new(Mutex::new(0)),
        }
    }

    fn increment(&self) {
        let mut data = self.data.lock().unwrap();
        *data += 1;
    }

    fn get(&self) -> i32 {
        let data = self.data.lock().unwrap();
        *data
    }
}

#[tokio::main]
async fn main() {
    let monitor = Monitor::new();
    let mut handles = vec![];

    for _ in 0..10 {
        let monitor_clone = monitor.clone();
        let handle = task::spawn(async move {
            monitor_clone.increment();
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.await.unwrap();
    }

    println!("Final count: {}", monitor.get());
}
```

### 1.7 é”äº’æ–¥é”æ¨¡å¼LockMutex Pattern

```rust
use std::sync::{Arc, Mutex};
use tokio::task;

#[tokio::main]
async fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter_clone = Arc::clone(&counter);
        let handle = task::spawn(async move {
            let mut num = counter_clone.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.await.unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

### 1.8 ä¿¡å·é‡æ¨¡å¼Semaphore Pattern

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let semaphore = Arc::new(Semaphore::new(3)); // å…è®¸3ä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®
    let mut handles = vec![];

    for i in 0..10 {
        let semaphore_clone = Arc::clone(&semaphore);
        let handle = tokio::spawn(async move {
            let _permit = semaphore_clone.acquire().await.unwrap(); // è·å–ä¿¡å·é‡
            println!("Thread {} is working", i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.await.unwrap();
    }
}
```

### 1.9 å±éšœæ¨¡å¼Barrier Pattern

```rust
use tokio::sync::Barrier;

#[tokio::main]
async fn main() {
    let barrier = Arc::new(Barrier::new(5)); // 5ä¸ªçº¿ç¨‹åˆ°è¾¾å±éšœ
    let mut handles = vec![];

    for i in 0..5 {
        let barrier_clone = Arc::clone(&barrier);
        let handle = tokio::spawn(async move {
            println!("Thread {} is waiting at the barrier", i);
            barrier_clone.wait().await; // ç­‰å¾…å…¶ä»–çº¿ç¨‹
            println!("Thread {} has crossed the barrier", i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.await.unwrap();
    }
}
```

### 1.10 è¯»å†™é”æ¨¡å¼Reader-Writer Lock Pattern

```rust
use tokio::sync::RwLock;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let data = Arc::new(RwLock::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let data_clone = Arc::clone(&data);
        let handle = tokio::spawn(async move {
            let mut num = data_clone.write().await;
            *num += 1;
            println!("Incremented to: {}", *num);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.await.unwrap();
    }

    let result = *data.read().await;
    println!("Final value: {}", result);
}
```

### 1.11 å·¥ä½œçªƒå–æ¨¡å¼Work Stealing Pattern

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::VecDeque;
use tokio::task;

struct Worker {
    id: usize,
    tasks: Arc<Mutex<VecDeque<Box<dyn FnOnce() + Send>>>>,
}

impl Worker {
    fn new(id: usize, tasks: Arc<Mutex<VecDeque<Box<dyn FnOnce() + Send>>>>) -> Self {
        Worker { id, tasks }
    }

    fn work(&self) {
        while let Some(task) = self.tasks.lock().unwrap().pop_front() {
            println!("Worker {} is executing a task", self.id);
            task();
        }
    }
}

#[tokio::main]
async fn main() {
    let tasks = Arc::new(Mutex::new(VecDeque::new()));
    let mut handles = vec![];

    for id in 0..4 {
        let tasks_clone = Arc::clone(&tasks);
        let handle = tokio::spawn(async move {
            let worker = Worker::new(id, tasks_clone);
            worker.work();
        });
        handles.push(handle);
    }

    for i in 0..10 {
        tasks.lock().unwrap().push_back(Box::new(move || {
            println!("Task {} is executed", i);
        }));
    }

    for handle in handles {
        handle.await.unwrap();
    }
}
```

### 1.12 Actoræ¨¡å¼Actor Pattern

```rust
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc;

struct Actor {
    sender: mpsc::Sender<String>,
}

impl Actor {
    fn new(sender: mpsc::Sender<String>) -> Self {
        Actor { sender }
    }

    async fn send_message(&self, message: String) {
        let _ = self.sender.send(message).await;
    }
}

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel(32);
    let actor = Actor::new(tx);

    tokio::spawn(async move {
        while let Some(message) = rx.recv().await {
            println!("Received message: {}", message);
        }
    });

    actor.send_message("Hello, Actor!".to_string()).await;
}
```

### 1.13 æ¡ä»¶å˜é‡æ¨¡å¼Condition Variable Pattern

```rust
use tokio::sync::{Notify, Mutex};
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let notify = Arc::new(Notify::new());
    let data = Arc::new(Mutex::new(0));

    let data_clone = Arc::clone(&data);
    let notify_clone = Arc::clone(&notify);
    tokio::spawn(async move {
        let mut num = data_clone.lock().await;
        *num += 1;
        notify_clone.notify_one(); // é€šçŸ¥å…¶ä»–çº¿ç¨‹
    });

    notify.notified().await; // ç­‰å¾…é€šçŸ¥
    let result = *data.lock().await;
    println!("Final value: {}", result);
}
```

### 1.14 åŒé‡æ£€æŸ¥é”å®šæ¨¡å¼Double-Checked Locking Pattern

```rust
use std::sync::{Arc, Mutex};
use tokio::task;

struct Singleton {
    value: i32,
}

impl Singleton {
    fn instance() -> Arc<Singleton> {
        static mut INSTANCE: Option<Arc<Singleton>> = None;
        static mut INITIALIZED: bool = false;

        unsafe {
            if !INITIALIZED {
                INSTANCE = Some(Arc::new(Singleton { value: 42 }));
                INITIALIZED = true;
            }
            INSTANCE.clone().unwrap()
        }
    }
}

#[tokio::main]
async fn main() {
    let handles: Vec<_> = (0..10)
        .map(|_| {
            let instance = Singleton::instance();
            tokio::spawn(async move {
                println!("Singleton value: {}", instance.value);
            })
        })
        .collect();

    for handle in handles {
        handle.await.unwrap();
    }
}
```

### 1.15 ä¸å¯å˜æ¨¡å¼Immutable Pattern

```rust
#[derive(Debug)]
struct ImmutableData {
    value: i32,
}

impl ImmutableData {
    fn new(value: i32) -> Self {
        ImmutableData { value }
    }

    fn get_value(&self) -> i32 {
        self.value
    }
}

#[tokio::main]
async fn main() {
    let data = ImmutableData::new(42);
    println!("Immutable data value: {}", data.get_value());
    // data.value = 100; // è¿™è¡Œä»£ç ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œå› ä¸º value æ˜¯ä¸å¯å˜çš„
}
```

### 1.16 æ€»ç»“

ä»¥ä¸Šç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•åœ¨ Rust ä¸­ä½¿ç”¨å¼‚æ­¥ç‰¹æ€§ç»“åˆå¤šçº¿ç¨‹å®ç°å¤šç§å¹¶å‘æ¨¡å¼ã€‚
æ¯ç§æ¨¡å¼éƒ½æœ‰å…¶ç‰¹å®šçš„ç”¨é€”å’Œå®ç°æ–¹å¼ï¼Œé€‚ç”¨äºä¸åŒçš„åœºæ™¯ã€‚
é€šè¿‡ä½¿ç”¨ Rust çš„å¼‚æ­¥å’Œå¤šçº¿ç¨‹ç‰¹æ€§ï¼Œå¼€å‘è€…å¯ä»¥æ„å»ºå‡ºé«˜æ€§èƒ½ä¸”å®‰å…¨çš„åº”ç”¨ç¨‹åºã€‚
