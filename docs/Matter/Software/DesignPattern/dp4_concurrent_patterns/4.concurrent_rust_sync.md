# å¹¶å‘æ¨¡å¼(Concurrent Patterns)

## ğŸ“‹ ç›®å½•

- [1 åŒæ­¥å®ç°](#1-åŒæ­¥å®ç°)
  - [1.1 çº¿ç¨‹æ± æ¨¡å¼Thread Pool Pattern](#11-çº¿ç¨‹æ± æ¨¡å¼thread-pool-pattern)
  - [1.2 Futureæ¨¡å¼Future Pattern](#12-futureæ¨¡å¼future-pattern)
  - [1.3 Promiseæ¨¡å¼Promise Pattern](#13-promiseæ¨¡å¼promise-pattern)
  - [1.4 ååº”å™¨æ¨¡å¼Reactor Pattern](#14-ååº”å™¨æ¨¡å¼reactor-pattern)
  - [1.5 æè®®è€…æ¨¡å¼Proactor Pattern](#15-æè®®è€…æ¨¡å¼proactor-pattern)
  - [1.6 Monitor Objectæ¨¡å¼Monitor Object Pattern](#16-monitor-objectæ¨¡å¼monitor-object-pattern)
  - [1.7 é”äº’æ–¥é”æ¨¡å¼LockMutex Pattern](#17-é”äº’æ–¥é”æ¨¡å¼lockmutex-pattern)
  - [1.8 ä¿¡å·é‡æ¨¡å¼Semaphore Pattern](#18-ä¿¡å·é‡æ¨¡å¼semaphore-pattern)
  - [1.9 å±éšœæ¨¡å¼Barrier Pattern](#19-å±éšœæ¨¡å¼barrier-pattern)
  - [1.10 è¯»å†™é”æ¨¡å¼Reader-Writer Lock Pattern](#110-è¯»å†™é”æ¨¡å¼reader-writer-lock-pattern)
  - [1.11 å·¥ä½œçªƒå–æ¨¡å¼Work Stealing Pattern](#111-å·¥ä½œçªƒå–æ¨¡å¼work-stealing-pattern)
  - [1.12 Actoræ¨¡å¼Actor Pattern](#112-actoræ¨¡å¼actor-pattern)
  - [1.13 æ¡ä»¶å˜é‡æ¨¡å¼Condition Variable Pattern](#113-æ¡ä»¶å˜é‡æ¨¡å¼condition-variable-pattern)
  - [1.14 åŒé‡æ£€æŸ¥é”å®šæ¨¡å¼Double-Checked Locking Pattern](#114-åŒé‡æ£€æŸ¥é”å®šæ¨¡å¼double-checked-locking-pattern)
  - [1.15 ä¸å¯å˜æ¨¡å¼Immutable Pattern](#115-ä¸å¯å˜æ¨¡å¼immutable-pattern)
  - [1.16 æ€»ç»“](#116-æ€»ç»“)

---

## 1 åŒæ­¥å®ç°

ä»¥ä¸‹æ˜¯ä½¿ç”¨ Rust 2024 ç‰ˆæœ¬å®ç°çš„å¹¶å‘æ¨¡å¼ç¤ºä¾‹ï¼Œ
åŒ…æ‹¬çº¿ç¨‹æ± æ¨¡å¼ã€Future æ¨¡å¼ã€Promise æ¨¡å¼ç­‰ã€‚
æ¯ä¸ªç¤ºä¾‹éƒ½å±•ç¤ºäº†å¦‚ä½•å®ç°è¿™äº›æ¨¡å¼ï¼Œå¹¶åˆ©ç”¨ Rust çš„å¹¶å‘ç‰¹æ€§ã€‚

### 1.1 çº¿ç¨‹æ± æ¨¡å¼Thread Pool Pattern

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::VecDeque;

struct ThreadPool {
    workers: Vec<Worker>,
    sender: Arc<Mutex<VecDeque<Job>>>,
}

type Job = Box<dyn FnOnce() + Send + 'static>;

impl ThreadPool {
    fn new(size: usize) -> ThreadPool {
        let sender = Arc::new(Mutex::new(VecDeque::new()));
        let mut workers = Vec::with_capacity(size);

        for _ in 0..size {
            workers.push(Worker::new(sender.clone()));
        }

        ThreadPool { workers, sender }
    }

    fn execute<F>(&self, job: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let mut sender = self.sender.lock().unwrap();
        sender.push_back(Box::new(job));
    }
}

struct Worker {
    thread: Option<thread::JoinHandle<()>>,
}

impl Worker {
    fn new(sender: Arc<Mutex<VecDeque<Job>>>) -> Worker {
        let thread = thread::spawn(move || loop {
            let job = {
                let mut sender = sender.lock().unwrap();
                sender.pop_front()
            };

            if let Some(job) = job {
                job();
            }
        });

        Worker { thread: Some(thread) }
    }
}

fn main() {
    let pool = ThreadPool::new(4);

    for i in 0..10 {
        pool.execute(move || {
            println!("Executing job {}", i);
        });
    }
}
```

### 1.2 Futureæ¨¡å¼Future Pattern

```rust
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::thread;
use std::time::Duration;

struct SimpleFuture {
    value: Option<i32>,
}

impl Future for SimpleFuture {
    type Output = i32;

    fn poll(self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<Self::Output> {
        if let Some(value) = self.value {
            Poll::Ready(value)
        } else {
            Poll::Pending
        }
    }
}

fn main() {
    let future = SimpleFuture { value: Some(42) };
    let result = futures::executor::block_on(future);
    println!("Future result: {}", result);
}
```

### 1.3 Promiseæ¨¡å¼Promise Pattern

```rust
use std::sync::{Arc, Mutex};
use std::thread;

struct Promise<T> {
    value: Arc<Mutex<Option<T>>>,
}

impl<T> Promise<T> {
    fn new() -> Self {
        Promise {
            value: Arc::new(Mutex::new(None)),
        }
    }

    fn fulfill(&self, value: T) {
        let mut guard = self.value.lock().unwrap();
        *guard = Some(value);
    }

    fn get(&self) -> Option<T> {
        let guard = self.value.lock().unwrap();
        guard.clone()
    }
}

fn main() {
    let promise = Promise::new();
    let promise_clone = promise.clone();

    thread::spawn(move || {
        thread::sleep(Duration::from_secs(2));
        promise_clone.fulfill(42);
    });

    while promise.get().is_none() {
        println!("Waiting for promise to be fulfilled...");
        thread::sleep(Duration::from_millis(500));
    }

    println!("Promise fulfilled with value: {:?}", promise.get());
}
```

### 1.4 ååº”å™¨æ¨¡å¼Reactor Pattern

```rust
use std::net::{TcpListener, TcpStream};
use std::thread;

fn handle_client(stream: TcpStream) {
    // å¤„ç†å®¢æˆ·ç«¯è¿æ¥
    println!("Client connected: {:?}", stream.peer_addr());
}

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        match stream {
            Ok(stream) => {
                thread::spawn(|| handle_client(stream));
            }
            Err(e) => {
                eprintln!("Error: {}", e);
            }
        }
    }
}
```

### 1.5 æè®®è€…æ¨¡å¼Proactor Pattern

```rust
use std::net::{TcpListener, TcpStream};
use std::thread;

fn handle_client(stream: TcpStream) {
    // å¤„ç†å®¢æˆ·ç«¯è¿æ¥
    println!("Client connected: {:?}", stream.peer_addr());
}

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        match stream {
            Ok(stream) => {
                thread::spawn(move || handle_client(stream));
            }
            Err(e) => {
                eprintln!("Error: {}", e);
            }
        }
    }
}
```

### 1.6 Monitor Objectæ¨¡å¼Monitor Object Pattern

```rust
use std::sync::{Arc, Mutex};
use std::thread;

struct Monitor {
    data: Arc<Mutex<i32>>,
}

impl Monitor {
    fn new() -> Self {
        Monitor {
            data: Arc::new(Mutex::new(0)),
        }
    }

    fn increment(&self) {
        let mut data = self.data.lock().unwrap();
        *data += 1;
    }

    fn get(&self) -> i32 {
        let data = self.data.lock().unwrap();
        *data
    }
}

fn main() {
    let monitor = Monitor::new();
    let monitor_clone = monitor.clone();

    let handles: Vec<_> = (0..10)
        .map(|_| {
            let monitor_clone = monitor_clone.clone();
            thread::spawn(move || {
                monitor_clone.increment();
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Final count: {}", monitor.get());
}
```

### 1.7 é”äº’æ–¥é”æ¨¡å¼LockMutex Pattern

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

### 1.8 ä¿¡å·é‡æ¨¡å¼Semaphore Pattern

```rust
use std::sync::{Arc, Mutex, Semaphore};
use std::thread;

fn main() {
    let semaphore = Arc::new(Semaphore::new(3)); // å…è®¸3ä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®
    let mut handles = vec![];

    for _ in 0..10 {
        let semaphore_clone = Arc::clone(&semaphore);
        let handle = thread::spawn(move || {
            let _permit = semaphore_clone.acquire(); // è·å–ä¿¡å·é‡
            println!("Thread {:?} is working", thread::current().id());
            thread::sleep(Duration::from_secs(1));
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 1.9 å±éšœæ¨¡å¼Barrier Pattern

```rust
use std::sync::{Arc, Barrier};
use std::thread;

fn main() {
    let barrier = Arc::new(Barrier::new(5)); // 5ä¸ªçº¿ç¨‹åˆ°è¾¾å±éšœ
    let mut handles = vec![];

    for i in 0..5 {
        let barrier_clone = Arc::clone(&barrier);
        let handle = thread::spawn(move || {
            println!("Thread {} is waiting at the barrier", i);
            barrier_clone.wait(); // ç­‰å¾…å…¶ä»–çº¿ç¨‹
            println!("Thread {} has crossed the barrier", i);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 1.10 è¯»å†™é”æ¨¡å¼Reader-Writer Lock Pattern

```rust
use std::sync::{Arc, RwLock};
use std::thread;

fn main() {
    let data = Arc::new(RwLock::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let data_clone = Arc::clone(&data);
        let handle = thread::spawn(move || {
            let mut num = data_clone.write().unwrap();
            *num += 1;
            println!("Incremented to: {}", *num);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    let result = *data.read().unwrap();
    println!("Final value: {}", result);
}
```

### 1.11 å·¥ä½œçªƒå–æ¨¡å¼Work Stealing Pattern

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::collections::VecDeque;

struct Worker {
    id: usize,
    tasks: Arc<Mutex<VecDeque<Box<dyn FnOnce() + Send>>>>,
}

impl Worker {
    fn new(id: usize, tasks: Arc<Mutex<VecDeque<Box<dyn FnOnce() + Send>>>>) -> Self {
        Worker { id, tasks }
    }

    fn work(&self) {
        while let Some(task) = self.tasks.lock().unwrap().pop_front() {
            println!("Worker {} is executing a task", self.id);
            task();
        }
    }
}

fn main() {
    let tasks = Arc::new(Mutex::new(VecDeque::new()));
    let mut workers = vec![];

    for id in 0..4 {
        let tasks_clone = Arc::clone(&tasks);
        let worker = Worker::new(id, tasks_clone);
        workers.push(thread::spawn(move || worker.work()));
    }

    for i in 0..10 {
        tasks.lock().unwrap().push_back(Box::new(move || {
            println!("Task {} is executed", i);
        }));
    }

    for worker in workers {
        worker.join().unwrap();
    }
}
```

### 1.12 Actoræ¨¡å¼Actor Pattern

```rust
use std::sync::{Arc, Mutex};
use std::thread;
use std::sync::mpsc::{self, Sender, Receiver};

struct Actor {
    sender: Sender<String>,
}

impl Actor {
    fn new() -> (Self, Receiver<String>) {
        let (sender, receiver) = mpsc::channel();
        (Actor { sender }, receiver)
    }

    fn send(&self, message: String) {
        self.sender.send(message).unwrap();
    }

    fn start(receiver: Receiver<String>) {
        thread::spawn(move || {
            for message in receiver {
                println!("Received message: {}", message);
            }
        });
    }
}

fn main() {
    let (actor, receiver) = Actor::new();
    Actor::start(receiver);

    actor.send("Hello, Actor!".to_string());
    actor.send("Goodbye, Actor!".to_string());

    thread::sleep(std::time::Duration::from_secs(1)); // ç­‰å¾…æ¶ˆæ¯å¤„ç†
}
```

### 1.13 æ¡ä»¶å˜é‡æ¨¡å¼Condition Variable Pattern

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::thread;

struct SharedData {
    data: i32,
    ready: bool,
}

fn main() {
    let shared_data = Arc::new((Mutex::new(SharedData { data: 0, ready: false }), Condvar::new()));
    let shared_data_clone = Arc::clone(&shared_data);

    let producer = thread::spawn(move || {
        let (lock, cvar) = &*shared_data_clone;
        let mut data = lock.lock().unwrap();
        data.data = 42;
        data.ready = true;
        cvar.notify_one(); // é€šçŸ¥æ¶ˆè´¹è€…
    });

    let consumer = thread::spawn(move || {
        let (lock, cvar) = &*shared_data;
        let mut data = lock.lock().unwrap();
        while !data.ready {
            data = cvar.wait(data).unwrap(); // ç­‰å¾…é€šçŸ¥
        }
        println!("Received data: {}", data.data);
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}
```

### 1.14 åŒé‡æ£€æŸ¥é”å®šæ¨¡å¼Double-Checked Locking Pattern

```rust
use std::sync::{Arc, Mutex};
use std::sync::atomic::{AtomicBool, Ordering};
use std::thread;

struct Singleton {
    value: i32,
}

impl Singleton {
    fn instance() -> Arc<Singleton> {
        static mut INSTANCE: Option<Arc<Singleton>> = None;
        static INITIALIZED: AtomicBool = AtomicBool::new(false);

        if !INITIALIZED.load(Ordering::SeqCst) {
            let singleton = Arc::new(Singleton { value: 42 });
            unsafe {
                INSTANCE = Some(singleton.clone());
            }
            INITIALIZED.store(true, Ordering::SeqCst);
        }

        unsafe { INSTANCE.clone().unwrap() }
    }
}

fn main() {
    let handles: Vec<_> = (0..10)
        .map(|_| {
            thread::spawn(|| {
                let instance = Singleton::instance();
                println!("Singleton value: {}", instance.value);
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }
}
```

### 1.15 ä¸å¯å˜æ¨¡å¼Immutable Pattern

```rust
#[derive(Debug)]
struct ImmutableData {
    value: i32,
}

impl ImmutableData {
    fn new(value: i32) -> Self {
        ImmutableData { value }
    }

    fn get_value(&self) -> i32 {
        self.value
    }
}

fn main() {
    let data = ImmutableData::new(42);
    println!("Immutable data value: {}", data.get_value());
    // data.value = 100; // è¿™è¡Œä»£ç ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼Œå› ä¸º value æ˜¯ä¸å¯å˜çš„
}
```

### 1.16 æ€»ç»“

ä»¥ä¸Šç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•åœ¨ Rust ä¸­å®ç°å¤šç§å¹¶å‘æ¨¡å¼ã€‚
æ¯ç§æ¨¡å¼éƒ½æœ‰å…¶ç‰¹å®šçš„ç”¨é€”å’Œå®ç°æ–¹å¼ï¼Œé€‚ç”¨äºä¸åŒçš„åœºæ™¯ã€‚
é€šè¿‡ä½¿ç”¨ Rust çš„å¹¶å‘ç‰¹æ€§ï¼Œå¼€å‘è€…å¯ä»¥æ„å»ºå‡ºé«˜æ€§èƒ½ä¸”å®‰å…¨çš„åº”ç”¨ç¨‹åºã€‚
