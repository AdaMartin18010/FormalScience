# rust å®ç°è®¾è®¡æ¨¡å¼

åœ¨ Rust ä¸­ä½¿ç”¨å¼‚æ­¥æœºåˆ¶æˆ–å¤šçº¿ç¨‹æ¥å®ç°å„ç§è®¾è®¡æ¨¡å¼
ï¼ˆå¦‚å•ä¾‹æ¨¡å¼ã€å·¥å‚æ–¹æ³•æ¨¡å¼ã€æŠ½è±¡å·¥å‚æ¨¡å¼ç­‰ï¼‰å¯ä»¥æé«˜ç¨‹åºçš„å¹¶å‘æ€§å’Œæ€§èƒ½ã€‚
ä»¥ä¸‹æ˜¯æ¯ç§æ¨¡å¼çš„å®ç°ç¤ºä¾‹ï¼Œä½¿ç”¨å¼‚æ­¥å’Œå¤šçº¿ç¨‹çš„æ–¹å¼ã€‚

## ğŸ“‹ ç›®å½•

- [1 å¼‚æ­¥å®ç°](#1-å¼‚æ­¥å®ç°)
  - [1.1 å•ä¾‹æ¨¡å¼Singleton Pattern](#11-å•ä¾‹æ¨¡å¼singleton-pattern)
  - [1.2 å·¥å‚æ–¹æ³•æ¨¡å¼Factory Method Pattern](#12-å·¥å‚æ–¹æ³•æ¨¡å¼factory-method-pattern)
  - [1.3 æŠ½è±¡å·¥å‚æ¨¡å¼Abstract Factory Pattern](#13-æŠ½è±¡å·¥å‚æ¨¡å¼abstract-factory-pattern)
  - [1.4 å»ºé€ è€…æ¨¡å¼Builder Pattern](#14-å»ºé€ è€…æ¨¡å¼builder-pattern)
  - [1.5 åŸå‹æ¨¡å¼Prototype Pattern](#15-åŸå‹æ¨¡å¼prototype-pattern)
  - [1.6 å¯¹è±¡æ± æ¨¡å¼Object Pool Pattern](#16-å¯¹è±¡æ± æ¨¡å¼object-pool-pattern)
  - [1.7 å¤šä¾‹æ¨¡å¼Multiton Pattern](#17-å¤šä¾‹æ¨¡å¼multiton-pattern)
  - [1.8 é™æ€å·¥å‚æ–¹æ³•Static Factory Method](#18-é™æ€å·¥å‚æ–¹æ³•static-factory-method)
  - [1.9 ç®€å•å·¥å‚æ¨¡å¼Simple Factory Pattern](#19-ç®€å•å·¥å‚æ¨¡å¼simple-factory-pattern)
  - [1.10 æ‡’æ±‰å¼ä¸é¥¿æ±‰å¼å•ä¾‹](#110-æ‡’æ±‰å¼ä¸é¥¿æ±‰å¼å•ä¾‹)
  - [1.11 ç™»è®°å¼å•ä¾‹Registry Singleton](#111-ç™»è®°å¼å•ä¾‹registry-singleton)
  - [1.12 æ€»ç»“](#112-æ€»ç»“)
- [2 åŒæ­¥å¤šçº¿ç¨‹å®ç°](#2-åŒæ­¥å¤šçº¿ç¨‹å®ç°)
  - [2.1 1 1 å•ä¾‹æ¨¡å¼Singleton Pattern](#21-1-1-å•ä¾‹æ¨¡å¼singleton-pattern)
  - [2.2 2 2 å·¥å‚æ–¹æ³•æ¨¡å¼Factory Method Pattern](#22-2-2-å·¥å‚æ–¹æ³•æ¨¡å¼factory-method-pattern)
  - [2.3 3 3 æŠ½è±¡å·¥å‚æ¨¡å¼Abstract Factory Pattern](#23-3-3-æŠ½è±¡å·¥å‚æ¨¡å¼abstract-factory-pattern)
  - [2.4 4 4 å»ºé€ è€…æ¨¡å¼Builder Pattern](#24-4-4-å»ºé€ è€…æ¨¡å¼builder-pattern)
  - [2.5 5 5 åŸå‹æ¨¡å¼Prototype Pattern](#25-5-5-åŸå‹æ¨¡å¼prototype-pattern)
  - [2.6 6 6 å¯¹è±¡æ± æ¨¡å¼Object Pool Pattern](#26-6-6-å¯¹è±¡æ± æ¨¡å¼object-pool-pattern)
  - [2.7 7 7 å¤šä¾‹æ¨¡å¼Multiton Pattern](#27-7-7-å¤šä¾‹æ¨¡å¼multiton-pattern)
  - [2.8 8 8 é™æ€å·¥å‚æ–¹æ³•Static Factory Method](#28-8-8-é™æ€å·¥å‚æ–¹æ³•static-factory-method)
  - [2.9 9 9 ç®€å•å·¥å‚æ¨¡å¼Simple Factory Pattern](#29-9-9-ç®€å•å·¥å‚æ¨¡å¼simple-factory-pattern)
  - [2.10 10 10 æ‡’æ±‰å¼ä¸é¥¿æ±‰å¼å•ä¾‹](#210-10-10-æ‡’æ±‰å¼ä¸é¥¿æ±‰å¼å•ä¾‹)
  - [2.11 11 11 ç™»è®°å¼å•ä¾‹Registry Singleton](#211-11-11-ç™»è®°å¼å•ä¾‹registry-singleton)
  - [2.12 æ€»ç»“](#212-æ€»ç»“)

---

## 1 å¼‚æ­¥å®ç°

### 1.1 å•ä¾‹æ¨¡å¼Singleton Pattern

**å¼‚æ­¥å®ç°**:

```rust
use std::sync::{Arc, Mutex};
use tokio::sync::OnceCell;

struct Singleton {
    value: i32,
}

impl Singleton {
    async fn instance() -> Arc<Mutex<Singleton>> {
        static INSTANCE: OnceCell<Arc<Mutex<Singleton>>> = OnceCell::const_new();

        INSTANCE.get_or_init(async {
            Arc::new(Mutex::new(Singleton { value: 42 }))
        }).await.clone()
    }
}

#[tokio::main]
async fn main() {
    let singleton = Singleton::instance().await;
    let mut instance = singleton.lock().unwrap();
    instance.value += 1;
    println!("Singleton value: {}", instance.value);
}
```

### 1.2 å·¥å‚æ–¹æ³•æ¨¡å¼Factory Method Pattern

**å¼‚æ­¥å®ç°**:

```rust
trait Product {
    fn operation(&self) -> String;
}

struct ConcreteProductA;
impl Product for ConcreteProductA {
    fn operation(&self) -> String {
        "Result of ConcreteProductA".to_string()
    }
}

struct ConcreteProductB;
impl Product for ConcreteProductB {
    fn operation(&self) -> String {
        "Result of ConcreteProductB".to_string()
    }
}

struct Creator;
impl Creator {
    async fn factory_method(product_type: &str) -> Box<dyn Product> {
        match product_type {
            "A" => Box::new(ConcreteProductA),
            "B" => Box::new(ConcreteProductB),
            _ => panic!("Unknown product type"),
        }
    }
}

#[tokio::main]
async fn main() {
    let product = Creator::factory_method("A").await;
    println!("{}", product.operation());
}
```

### 1.3 æŠ½è±¡å·¥å‚æ¨¡å¼Abstract Factory Pattern

**å¼‚æ­¥å®ç°**:

```rust
trait AbstractProductA {
    fn operation_a(&self) -> String;
}

trait AbstractProductB {
    fn operation_b(&self) -> String;
}

struct ConcreteProductA1;
impl AbstractProductA for ConcreteProductA1 {
    fn operation_a(&self) -> String {
        "Result of ConcreteProductA1".to_string()
    }
}

struct ConcreteProductB1;
impl AbstractProductB for ConcreteProductB1 {
    fn operation_b(&self) -> String {
        "Result of ConcreteProductB1".to_string()
    }
}

struct ConcreteFactory1;
impl ConcreteFactory1 {
    async fn create_product_a() -> Box<dyn AbstractProductA> {
        Box::new(ConcreteProductA1)
    }

    async fn create_product_b() -> Box<dyn AbstractProductB> {
        Box::new(ConcreteProductB1)
    }
}

#[tokio::main]
async fn main() {
    let product_a = ConcreteFactory1::create_product_a().await;
    let product_b = ConcreteFactory1::create_product_b().await;
    println!("{}", product_a.operation_a());
    println!("{}", product_b.operation_b());
}
```

### 1.4 å»ºé€ è€…æ¨¡å¼Builder Pattern

**å¼‚æ­¥å®ç°**:

```rust
struct Product {
    part_a: String,
    part_b: String,
}

struct Builder {
    product: Product,
}

impl Builder {
    fn new() -> Self {
        Builder {
            product: Product {
                part_a: String::new(),
                part_b: String::new(),
            },
        }
    }

    fn build_part_a(&mut self, part_a: &str) -> &mut Self {
        self.product.part_a = part_a.to_string();
        self
    }

    fn build_part_b(&mut self, part_b: &str) -> &mut Self {
        self.product.part_b = part_b.to_string();
        self
    }

    fn build(&self) -> Product {
        self.product.clone()
    }
}

#[tokio::main]
async fn main() {
    let product = Builder::new()
        .build_part_a("Part A")
        .build_part_b("Part B")
        .build();
    println!("Product parts: {} and {}", product.part_a, product.part_b);
}
```

### 1.5 åŸå‹æ¨¡å¼Prototype Pattern

**å¼‚æ­¥å®ç°**:

```rust
#[derive(Clone)]
struct Prototype {
    value: i32,
}

#[tokio::main]
async fn main() {
    let prototype = Prototype { value: 42 };
    let clone = prototype.clone();
    println!("Original: {}, Clone: {}", prototype.value, clone.value);
}
```

### 1.6 å¯¹è±¡æ± æ¨¡å¼Object Pool Pattern

**å¼‚æ­¥å®ç°**:

```rust
use std::collections::VecDeque;
use tokio::sync::Mutex;

struct Object {
    id: i32,
}

struct ObjectPool {
    pool: Mutex<VecDeque<Object>>,
}

impl ObjectPool {
    fn new(size: usize) -> Self {
        let mut pool = VecDeque::new();
        for i in 0..size {
            pool.push_back(Object { id: i });
        }
        ObjectPool {
            pool: Mutex::new(pool),
        }
    }

    async fn acquire(&self) -> Option<Object> {
        let mut pool = self.pool.lock().await;
        pool.pop_front()
    }

    async fn release(&self, obj: Object) {
        let mut pool = self.pool.lock().await;
        pool.push_back(obj);
    }
}

#[tokio::main]
async fn main() {
    let pool = ObjectPool::new(5);
    let obj = pool.acquire().await.unwrap();
    println!("Acquired object with id: {}", obj.id);
    pool.release(obj).await;
}
```

### 1.7 å¤šä¾‹æ¨¡å¼Multiton Pattern

**å¼‚æ­¥å®ç°**:

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::OnceCell;

struct Multiton {
    value: i32,
}

impl Multiton {
    async fn get_instance(key: &str) -> Arc<Mutex<Multiton>> {
        static INSTANCES: OnceCell<Mutex<HashMap<String, Arc<Mutex<Multiton>>>> = OnceCell::const_new();

        let instances = INSTANCES.get_or_init(async {
            Mutex::new(HashMap::new())
        }).await;

        let mut instances = instances.lock().unwrap();
        instances.entry(key.to_string()).or_insert_with(|| {
            Arc::new(Mutex::new(Multiton { value: 0 }))
        }).clone()
    }
}

#[tokio::main]
async fn main() {
    let instance1 = Multiton::get_instance("A").await;
    let instance2 = Multiton::get_instance("B").await;
    println!("Instance A: {:?}", instance1);
    println!("Instance B: {:?}", instance2);
}
```

### 1.8 é™æ€å·¥å‚æ–¹æ³•Static Factory Method

**å¼‚æ­¥å®ç°**:

```rust
struct Product {
    value: i32,
}

impl Product {
    fn new(value: i32) -> Self {
        Product { value }
    }
}

#[tokio::main]
async fn main() {
    let product = Product::new(42);
    println!("Product value: {}", product.value);
}
```

### 1.9 ç®€å•å·¥å‚æ¨¡å¼Simple Factory Pattern

**å¼‚æ­¥å®ç°**:

```rust
struct ProductA;
struct ProductB;

trait Product {
    fn operation(&self) -> String;
}

impl Product for ProductA {
    fn operation(&self) -> String {
        "Product A".to_string()
    }
}

impl Product for ProductB {
    fn operation(&self) -> String {
        "Product B".to_string()
    }
}

struct SimpleFactory;

impl SimpleFactory {
    async fn create_product(product_type: &str) -> Box<dyn Product> {
        match product_type {
            "A" => Box::new(ProductA),
            "B" => Box::new(ProductB),
            _ => panic!("Unknown product type"),
        }
    }
}

#[tokio::main]
async fn main() {
    let product = SimpleFactory::create_product("A").await;
    println!("{}", product.operation());
}
```

### 1.10 æ‡’æ±‰å¼ä¸é¥¿æ±‰å¼å•ä¾‹

**æ‡’æ±‰å¼å•ä¾‹**:

```rust
use std::sync::{Arc, Mutex};
use tokio::sync::OnceCell;

struct LazySingleton {
    value: i32,
}

impl LazySingleton {
    async fn instance() -> Arc<Mutex<LazySingleton>> {
        static INSTANCE: OnceCell<Arc<Mutex<LazySingleton>>> = OnceCell::const_new();

        INSTANCE.get_or_init(async {
            Arc::new(Mutex::new(LazySingleton { value: 42 }))
        }).await.clone()
    }
}

#[tokio::main]
async fn main() {
    let singleton = LazySingleton::instance().await;
    let mut instance = singleton.lock().unwrap();
    instance.value += 1;
    println!("LazySingleton value: {}", instance.value);
}
```

**é¥¿æ±‰å¼å•ä¾‹**:

```rust
use std::sync::{Arc, Mutex};

struct EagerSingleton {
    value: i32,
}

impl EagerSingleton {
    fn instance() -> Arc<Mutex<EagerSingleton>> {
        static SINGLETON: Arc<Mutex<EagerSingleton>> = Arc::new(Mutex::new(EagerSingleton { value: 42 }));
        SINGLETON.clone()
    }
}

#[tokio::main]
async fn main() {
    let singleton = EagerSingleton::instance();
    let mut instance = singleton.lock().unwrap();
    instance.value += 1;
    println!("EagerSingleton value: {}", instance.value);
}
```

### 1.11 ç™»è®°å¼å•ä¾‹Registry Singleton

**å¼‚æ­¥å®ç°**:

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::OnceCell;

struct RegistrySingleton {
    value: i32,
}

impl RegistrySingleton {
    async fn get_instance(key: &str) -> Arc<Mutex<RegistrySingleton>> {
        static INSTANCES: OnceCell<Mutex<HashMap<String, Arc<Mutex<RegistrySingleton>>>> = OnceCell::const_new();

        let instances = INSTANCES.get_or_init(async {
            Mutex::new(HashMap::new())
        }).await;

        let mut instances = instances.lock().unwrap();
        instances.entry(key.to_string()).or_insert_with(|| {
            Arc::new(Mutex::new(RegistrySingleton { value: 0 }))
        }).clone()
    }
}

#[tokio::main]
async fn main() {
    let instance1 = RegistrySingleton::get_instance("A").await;
    let instance2 = RegistrySingleton::get_instance("B").await;
    println!("Instance A: {:?}", instance1);
    println!("Instance B: {:?}", instance2);
}
```

### 1.12 æ€»ç»“

ä»¥ä¸Šç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•åœ¨ Rust ä¸­ä½¿ç”¨å¼‚æ­¥æœºåˆ¶å’Œå¤šçº¿ç¨‹å®ç°å¤šç§è®¾è®¡æ¨¡å¼ã€‚
æ¯ç§æ¨¡å¼éƒ½æœ‰å…¶ç‰¹å®šçš„ç”¨é€”å’Œå®ç°æ–¹å¼ï¼Œé€‚ç”¨äºä¸åŒçš„åœºæ™¯ã€‚
é€šè¿‡ä½¿ç”¨ Rust çš„æ‰€æœ‰æƒã€å€Ÿç”¨å’Œå¹¶å‘ç‰¹æ€§ï¼Œå¼€å‘è€…å¯ä»¥æ„å»ºå‡ºé«˜æ€§èƒ½ä¸”å®‰å…¨çš„åº”ç”¨ç¨‹åºã€‚

## 2 åŒæ­¥å¤šçº¿ç¨‹å®ç°

åœ¨ Rust ä¸­ä½¿ç”¨å¼‚æ­¥æœºåˆ¶æˆ–å¤šçº¿ç¨‹æ¥å®ç°å„ç§è®¾è®¡æ¨¡å¼
ï¼ˆå¦‚å•ä¾‹æ¨¡å¼ã€å·¥å‚æ–¹æ³•æ¨¡å¼ã€æŠ½è±¡å·¥å‚æ¨¡å¼ç­‰ï¼‰å¯ä»¥æé«˜ç¨‹åºçš„å¹¶å‘æ€§å’Œæ€§èƒ½ã€‚
ä»¥ä¸‹æ˜¯æ¯ç§æ¨¡å¼çš„å®ç°ç¤ºä¾‹ï¼Œä½¿ç”¨å¤šçº¿ç¨‹çš„æ–¹å¼ã€‚

### 2.1 1 å•ä¾‹æ¨¡å¼Singleton Pattern

**å¼‚æ­¥å®ç°**:

```rust
use std::sync::{Arc, Mutex};
use tokio::sync::OnceCell;

struct Singleton {
    value: i32,
}

impl Singleton {
    async fn instance() -> Arc<Mutex<Singleton>> {
        static INSTANCE: OnceCell<Arc<Mutex<Singleton>>> = OnceCell::const_new();

        INSTANCE.get_or_init(async {
            Arc::new(Mutex::new(Singleton { value: 42 }))
        }).await.clone()
    }
}

#[tokio::main]
async fn main() {
    let singleton = Singleton::instance().await;
    let mut instance = singleton.lock().unwrap();
    instance.value += 1;
    println!("Singleton value: {}", instance.value);
}
```

### 2.2 2 å·¥å‚æ–¹æ³•æ¨¡å¼Factory Method Pattern

**å¼‚æ­¥å®ç°**:

```rust
trait Product {
    fn operation(&self) -> String;
}

struct ConcreteProductA;
impl Product for ConcreteProductA {
    fn operation(&self) -> String {
        "Result of ConcreteProductA".to_string()
    }
}

struct ConcreteProductB;
impl Product for ConcreteProductB {
    fn operation(&self) -> String {
        "Result of ConcreteProductB".to_string()
    }
}

struct Creator;
impl Creator {
    async fn factory_method(product_type: &str) -> Box<dyn Product> {
        match product_type {
            "A" => Box::new(ConcreteProductA),
            "B" => Box::new(ConcreteProductB),
            _ => panic!("Unknown product type"),
        }
    }
}

#[tokio::main]
async fn main() {
    let product = Creator::factory_method("A").await;
    println!("{}", product.operation());
}
```

### 2.3 3 æŠ½è±¡å·¥å‚æ¨¡å¼Abstract Factory Pattern

**å¼‚æ­¥å®ç°**:

```rust
trait AbstractProductA {
    fn operation_a(&self) -> String;
}

trait AbstractProductB {
    fn operation_b(&self) -> String;
}

struct ConcreteProductA1;
impl AbstractProductA for ConcreteProductA1 {
    fn operation_a(&self) -> String {
        "Result of ConcreteProductA1".to_string()
    }
}

struct ConcreteProductB1;
impl AbstractProductB for ConcreteProductB1 {
    fn operation_b(&self) -> String {
        "Result of ConcreteProductB1".to_string()
    }
}

struct ConcreteFactory1;
impl ConcreteFactory1 {
    async fn create_product_a() -> Box<dyn AbstractProductA> {
        Box::new(ConcreteProductA1)
    }

    async fn create_product_b() -> Box<dyn AbstractProductB> {
        Box::new(ConcreteProductB1)
    }
}

#[tokio::main]
async fn main() {
    let product_a = ConcreteFactory1::create_product_a().await;
    let product_b = ConcreteFactory1::create_product_b().await;
    println!("{}", product_a.operation_a());
    println!("{}", product_b.operation_b());
}
```

### 2.4 4 å»ºé€ è€…æ¨¡å¼Builder Pattern

**å¼‚æ­¥å®ç°**:

```rust
struct Product {
    part_a: String,
    part_b: String,
}

struct Builder {
    product: Product,
}

impl Builder {
    fn new() -> Self {
        Builder {
            product: Product {
                part_a: String::new(),
                part_b: String::new(),
            },
        }
    }

    fn build_part_a(&mut self, part_a: &str) -> &mut Self {
        self.product.part_a = part_a.to_string();
        self
    }

    fn build_part_b(&mut self, part_b: &str) -> &mut Self {
        self.product.part_b = part_b.to_string();
        self
    }

    fn build(&self) -> Product {
        self.product.clone()
    }
}

#[tokio::main]
async fn main() {
    let product = Builder::new()
        .build_part_a("Part A")
        .build_part_b("Part B")
        .build();
    println!("Product parts: {} and {}", product.part_a, product.part_b);
}
```

### 2.5 5 åŸå‹æ¨¡å¼Prototype Pattern

**å¼‚æ­¥å®ç°**:

```rust
#[derive(Clone)]
struct Prototype {
    value: i32,
}

#[tokio::main]
async fn main() {
    let prototype = Prototype { value: 42 };
    let clone = prototype.clone();
    println!("Original: {}, Clone: {}", prototype.value, clone.value);
}
```

### 2.6 6 å¯¹è±¡æ± æ¨¡å¼Object Pool Pattern

**å¼‚æ­¥å®ç°**:

```rust
use std::collections::VecDeque;
use tokio::sync::Mutex;

struct Object {
    id: i32,
}

struct ObjectPool {
    pool: Mutex<VecDeque<Object>>,
}

impl ObjectPool {
    fn new(size: usize) -> Self {
        let mut pool = VecDeque::new();
        for i in 0..size {
            pool.push_back(Object { id: i });
        }
        ObjectPool {
            pool: Mutex::new(pool),
        }
    }

    async fn acquire(&self) -> Option<Object> {
        let mut pool = self.pool.lock().await;
        pool.pop_front()
    }

    async fn release(&self, obj: Object) {
        let mut pool = self.pool.lock().await;
        pool.push_back(obj);
    }
}

#[tokio::main]
async fn main() {
    let pool = ObjectPool::new(5);
    let obj = pool.acquire().await.unwrap();
    println!("Acquired object with id: {}", obj.id);
    pool.release(obj).await;
}
```

### 2.7 7 å¤šä¾‹æ¨¡å¼Multiton Pattern

**å¼‚æ­¥å®ç°**:

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::OnceCell;

struct Multiton {
    value: i32,
}

impl Multiton {
    async fn get_instance(key: &str) -> Arc<Mutex<Multiton>> {
        static INSTANCES: OnceCell<Mutex<HashMap<String, Arc<Mutex<Multiton>>>> = OnceCell::const_new();

        let instances = INSTANCES.get_or_init(async {
            Mutex::new(HashMap::new())
        }).await;

        let mut instances = instances.lock().unwrap();
        instances.entry(key.to_string()).or_insert_with(|| {
            Arc::new(Mutex::new(Multiton { value: 0 }))
        }).clone()
    }
}

#[tokio::main]
async fn main() {
    let instance1 = Multiton::get_instance("A").await;
    let instance2 = Multiton::get_instance("B").await;
    println!("Instance A: {:?}", instance1);
    println!("Instance B: {:?}", instance2);
}
```

### 2.8 8 é™æ€å·¥å‚æ–¹æ³•Static Factory Method

**å¼‚æ­¥å®ç°**:

```rust
struct Product {
    value: i32,
}

impl Product {
    fn new(value: i32) -> Self {
        Product { value }
    }
}

#[tokio::main]
async fn main() {
    let product = Product::new(42);
    println!("Product value: {}", product.value);
}
```

### 2.9 9 ç®€å•å·¥å‚æ¨¡å¼Simple Factory Pattern

**å¼‚æ­¥å®ç°**:

```rust
struct ProductA;
struct ProductB;

trait Product {
    fn operation(&self) -> String;
}

impl Product for ProductA {
    fn operation(&self) -> String {
        "Product A".to_string()
    }
}

impl Product for ProductB {
    fn operation(&self) -> String {
        "Product B".to_string()
    }
}

struct SimpleFactory;

impl SimpleFactory {
    async fn create_product(product_type: &str) -> Box<dyn Product> {
        match product_type {
            "A" => Box::new(ProductA),
            "B" => Box::new(ProductB),
            _ => panic!("Unknown product type"),
        }
    }
}

#[tokio::main]
async fn main() {
    let product = SimpleFactory::create_product("A").await;
    println!("{}", product.operation());
}
```

### 2.10 10 æ‡’æ±‰å¼ä¸é¥¿æ±‰å¼å•ä¾‹

**æ‡’æ±‰å¼å•ä¾‹**:

```rust
use std::sync::{Arc, Mutex};
use tokio::sync::OnceCell;

struct LazySingleton {
    value: i32,
}

impl LazySingleton {
    async fn instance() -> Arc<Mutex<LazySingleton>> {
        static INSTANCE: OnceCell<Arc<Mutex<LazySingleton>>> = OnceCell::const_new();

        INSTANCE.get_or_init(async {
            Arc::new(Mutex::new(LazySingleton { value: 42 }))
        }).await.clone()
    }
}

#[tokio::main]
async fn main() {
    let singleton = LazySingleton::instance().await;
    let mut instance = singleton.lock().unwrap();
    instance.value += 1;
    println!("LazySingleton value: {}", instance.value);
}
```

**é¥¿æ±‰å¼å•ä¾‹**:

```rust
use std::sync::{Arc, Mutex};

struct EagerSingleton {
    value: i32,
}

impl EagerSingleton {
    fn instance() -> Arc<Mutex<EagerSingleton>> {
        static SINGLETON: Arc<Mutex<EagerSingleton>> = Arc::new(Mutex::new(EagerSingleton { value: 42 }));
        SINGLETON.clone()
    }
}

#[tokio::main]
async fn main() {
    let singleton = EagerSingleton::instance();
    let mut instance = singleton.lock().unwrap();
    instance.value += 1;
    println!("EagerSingleton value: {}", instance.value);
}
```

### 2.11 11 ç™»è®°å¼å•ä¾‹Registry Singleton

**å¼‚æ­¥å®ç°**:

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::OnceCell;

struct RegistrySingleton {
    value: i32,
}

impl RegistrySingleton {
    async fn get_instance(key: &str) -> Arc<Mutex<RegistrySingleton>> {
        static INSTANCES: OnceCell<Mutex<HashMap<String, Arc<Mutex<RegistrySingleton>>>> = OnceCell::const_new();

        let instances = INSTANCES.get_or_init(async {
            Mutex::new(HashMap::new())
        }).await;

        let mut instances = instances.lock().unwrap();
        instances.entry(key.to_string()).or_insert_with(|| {
            Arc::new(Mutex::new(RegistrySingleton { value: 0 }))
        }).clone()
    }
}

#[tokio::main]
async fn main() {
    let instance1 = RegistrySingleton::get_instance("A").await;
    let instance2 = RegistrySingleton::get_instance("B").await;
    println!("Instance A: {:?}", instance1);
    println!("Instance B: {:?}", instance2);
}
```

### 2.12 æ€»ç»“

ä»¥ä¸Šç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•åœ¨ Rust ä¸­ä½¿ç”¨å¼‚æ­¥æœºåˆ¶å’Œå¤šçº¿ç¨‹å®ç°å¤šç§è®¾è®¡æ¨¡å¼ã€‚
æ¯ç§æ¨¡å¼éƒ½æœ‰å…¶ç‰¹å®šçš„ç”¨é€”å’Œå®ç°æ–¹å¼ï¼Œé€‚ç”¨äºä¸åŒçš„åœºæ™¯ã€‚
é€šè¿‡ä½¿ç”¨ Rust çš„æ‰€æœ‰æƒã€å€Ÿç”¨å’Œå¹¶å‘ç‰¹æ€§ï¼Œå¼€å‘è€…å¯ä»¥æ„å»ºå‡ºé«˜æ€§èƒ½ä¸”å®‰å…¨çš„åº”ç”¨ç¨‹åºã€‚
