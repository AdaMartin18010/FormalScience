# 12.5 ä¸Šä¸‹æ–‡å­¦ä¹ ç†è®º (Context Learning Theory)

## ğŸ“‹ ç›®å½•

- [1 æ ¸å¿ƒæ¦‚å¿µ (Core Concepts)](#1-æ ¸å¿ƒæ¦‚å¿µ-core-concepts)
- [2 ä¸Šä¸‹æ–‡ç³»ç»Ÿä¸­çš„å­¦ä¹ ä»»åŠ¡ (Learning Tasks in Context-Aware Systems)](#2-ä¸Šä¸‹æ–‡ç³»ç»Ÿä¸­çš„å­¦ä¹ ä»»åŠ¡-learning-tasks-in-context-aware-systems)
  - [2.1 ä¸Šä¸‹æ–‡æ¨æ–­åˆ†ç±» (Context InferenceClassification)](#21-ä¸Šä¸‹æ–‡æ¨æ–­åˆ†ç±»-context-inferenceclassification)
  - [2.2 é¢„æµ‹æ€§ä¸Šä¸‹æ–‡ (Predictive Context)](#22-é¢„æµ‹æ€§ä¸Šä¸‹æ–‡-predictive-context)
  - [2.3 å­¦ä¹ é€‚åº”è§„åˆ™ (Learning Adaptation Rules)](#23-å­¦ä¹ é€‚åº”è§„åˆ™-learning-adaptation-rules)
  - [2.4 ä¸Šä¸‹æ–‡å‘ç° (Context Discovery)](#24-ä¸Šä¸‹æ–‡å‘ç°-context-discovery)
- [3 å…³é”®æŒ‘æˆ˜ (Key Challenges)](#3-å…³é”®æŒ‘æˆ˜-key-challenges)
- [4 Rust ä»£ç ç¤ºä¾‹ï¼šå­¦ä¹ ç”¨æˆ·åå¥½çš„ç®€å•éŸ³ä¹æ’­æ”¾å™¨](#4-rust-ä»£ç ç¤ºä¾‹å­¦ä¹ ç”¨æˆ·åå¥½çš„ç®€å•éŸ³ä¹æ’­æ”¾å™¨)
- [5 ç»“è®º](#5-ç»“è®º)
- [6 æ‰¹åˆ¤æ€§åˆ†æ](#6-æ‰¹åˆ¤æ€§åˆ†æ)

---

## 1 æ ¸å¿ƒæ¦‚å¿µ (Core Concepts)

**ä¸Šä¸‹æ–‡å­¦ä¹  (Context Learning)** æ˜¯æŒ‡åˆ©ç”¨æœºå™¨å­¦ä¹ æŠ€æœ¯æ¥è‡ªåŠ¨è·å–ã€æ”¹è¿›å’Œåˆ©ç”¨ä¸Šä¸‹æ–‡æ¨¡å‹çš„è¿‡ç¨‹ã€‚ä¼ ç»Ÿçš„ä¸Šä¸‹æ–‡æ„ŸçŸ¥ç³»ç»Ÿä¾èµ–äºæ‰‹åŠ¨å®šä¹‰çš„æ¨¡å‹å’Œè§„åˆ™ï¼Œè¿™åœ¨å¤æ‚å’ŒåŠ¨æ€çš„ç¯å¢ƒä¸­æ˜¾å¾—è„†å¼±ä¸”éš¾ä»¥ç»´æŠ¤ã€‚ä¸Šä¸‹æ–‡å­¦ä¹ ç†è®ºæ—¨åœ¨é€šè¿‡è®©ç³»ç»Ÿä»æ•°æ®ä¸­**è‡ªä¸»å­¦ä¹ **ï¼Œæ¥å…‹æœè¿™äº›å±€é™æ€§ã€‚

å­¦ä¹ å¯ä»¥å‘ç”Ÿåœ¨ä¸Šä¸‹æ–‡æ„ŸçŸ¥ç³»ç»Ÿçš„å¤šä¸ªå±‚é¢ï¼š

- **å­¦ä¹ å¦‚ä½•æ„ŸçŸ¥**: ä»åŸå§‹ä¼ æ„Ÿå™¨æ•°æ®ä¸­å­¦ä¹ å¹¶æ¨æ–­é«˜çº§ä¸Šä¸‹æ–‡ã€‚
- **å­¦ä¹ å¦‚ä½•é¢„æµ‹**: å­¦ä¹ é¢„æµ‹ç”¨æˆ·æœªæ¥çš„çŠ¶æ€å’Œéœ€æ±‚ã€‚
- **å­¦ä¹ å¦‚ä½•é€‚åº”**: å­¦ä¹ åœ¨ç‰¹å®šä¸Šä¸‹æ–‡ä¸­åº”é‡‡å–çš„æœ€ä½³è¡ŒåŠ¨ã€‚

## 2 ä¸Šä¸‹æ–‡ç³»ç»Ÿä¸­çš„å­¦ä¹ ä»»åŠ¡ (Learning Tasks in Context-Aware Systems)

### 2.1 ä¸Šä¸‹æ–‡æ¨æ–­åˆ†ç±» (Context InferenceClassification)

è¿™æ˜¯æœ€å¸¸è§çš„å­¦ä¹ ä»»åŠ¡ã€‚ç³»ç»Ÿå­¦ä¹ ä¸€ä¸ªä»ä½çº§ä¼ æ„Ÿå™¨è¯»æ•°åˆ°é«˜çº§ä¸Šä¸‹æ–‡æ ‡ç­¾çš„æ˜ å°„å‡½æ•°ã€‚

- **ä»»åŠ¡**: å°†ä¸€ä¸ªç‰¹å¾å‘é‡ï¼ˆå¦‚æ¥è‡ªåŠ é€Ÿè®¡ã€é™€èºä»ªã€GPSçš„æ•°æ®ï¼‰åˆ†ç±»ä¸ºä¸€ä¸ªç¦»æ•£çš„æ´»åŠ¨æ ‡ç­¾ï¼ˆå¦‚"æ­¥è¡Œ"ã€"è·‘æ­¥"ã€"é™å"ã€"é©¾é©¶"ï¼‰ã€‚
- **å¸¸ç”¨æ¨¡å‹**:
  - **ç›‘ç£å­¦ä¹  (Supervised Learning)**:
    - **å†³ç­–æ ‘ (Decision Trees)**: æ˜“äºç†è§£å’Œè§£é‡Šã€‚
    - **æ”¯æŒå‘é‡æœº (Support Vector Machines - SVM)**: åœ¨é«˜ç»´ç©ºé—´ä¸­è¡¨ç°è‰¯å¥½ã€‚
    - **K-æœ€è¿‘é‚» (K-Nearest Neighbors - KNN)**: ç®€å•æœ‰æ•ˆçš„éå‚æ•°æ–¹æ³•ã€‚
    - **æ·±åº¦å­¦ä¹  (Deep Learning)**: å¦‚å·ç§¯ç¥ç»ç½‘ç»œ(CNN)å’Œå¾ªç¯ç¥ç»ç½‘ç»œ(RNN)ï¼Œèƒ½å¤Ÿè‡ªåŠ¨ä»åŸå§‹æ—¶é—´åºåˆ—æ•°æ®ä¸­æå–ç‰¹å¾ï¼Œåœ¨æ´»åŠ¨è¯†åˆ«ç­‰é¢†åŸŸå–å¾—äº†å·¨å¤§æˆåŠŸã€‚

### 2.2 é¢„æµ‹æ€§ä¸Šä¸‹æ–‡ (Predictive Context)

æ­¤ä»»åŠ¡æ—¨åœ¨æ ¹æ®å†å²ä¸Šä¸‹æ–‡æ•°æ®é¢„æµ‹æœªæ¥çš„ä¸Šä¸‹æ–‡ã€‚

- **ä»»åŠ¡**: é¢„æµ‹ç”¨æˆ·çš„ä¸‹ä¸€ä¸ªä½ç½®ï¼Œæˆ–é¢„æµ‹ä¸€ä¸ªè®¾å¤‡åœ¨æœªæ¥ä¸€å°æ—¶å†…çš„ç½‘ç»œè¿æ¥çŠ¶å†µã€‚
- **å¸¸ç”¨æ¨¡å‹**:
  - **é©¬å°”å¯å¤«æ¨¡å‹ (Markov Models)**: é¢„æµ‹åŸºäºå½“å‰çŠ¶æ€çš„ä¸‹ä¸€ä¸ªçŠ¶æ€ã€‚
  - **å¾ªç¯ç¥ç»ç½‘ç»œ (RNN) / é•¿çŸ­æœŸè®°å¿†ç½‘ç»œ (LSTM)**: ä¸“ä¸ºå¤„ç†å’Œé¢„æµ‹åºåˆ—æ•°æ®è€Œè®¾è®¡ã€‚

### 2.3 å­¦ä¹ é€‚åº”è§„åˆ™ (Learning Adaptation Rules)

è¿™æ˜¯æœ€å…·æŒ‘æˆ˜æ€§ä¹Ÿæœ€å…·æ½œåŠ›çš„å­¦ä¹ ä»»åŠ¡ã€‚ç³»ç»Ÿä¸å†ä¾èµ–äºç¨‹åºå‘˜ç¡¬ç¼–ç çš„ `IF-THEN` è§„åˆ™ï¼Œè€Œæ˜¯å­¦ä¹ æœ€ä¼˜çš„é€‚åº”ç­–ç•¥ã€‚

- **ä»»åŠ¡**: å­¦ä¹ ä¸€ä¸ªç­–ç•¥ `Ï€(ä¸Šä¸‹æ–‡) -> åŠ¨ä½œ`ï¼Œè¯¥ç­–ç•¥èƒ½åœ¨ç»™å®šä¸Šä¸‹æ–‡ä¸­é€‰æ‹©ä¸€ä¸ªèƒ½æœ€å¤§åŒ–é•¿æœŸæ”¶ç›Šï¼ˆå¦‚ç”¨æˆ·æ»¡æ„åº¦ã€ç”µæ± å¯¿å‘½ï¼‰çš„åŠ¨ä½œã€‚
- **å¸¸ç”¨æ¨¡å‹**:
  - **å¼ºåŒ–å­¦ä¹  (Reinforcement Learning - RL)**:
    - ç³»ç»Ÿï¼ˆ**Agent**ï¼‰åœ¨æŸä¸ª**ç¯å¢ƒ (Environment)** ä¸­ï¼Œè§‚å¯Ÿåˆ°**çŠ¶æ€ (State)**ï¼ˆå³ä¸Šä¸‹æ–‡ï¼‰ï¼Œæ‰§è¡Œä¸€ä¸ª**åŠ¨ä½œ (Action)**ï¼ˆå³é€‚åº”ï¼‰ï¼Œç„¶åæ”¶åˆ°ä¸€ä¸ª**å¥–åŠ± (Reward)**ï¼ˆæ­£é¢æˆ–è´Ÿé¢åé¦ˆï¼‰ã€‚
    - Agent çš„ç›®æ ‡æ˜¯å­¦ä¹ ä¸€ä¸ªç­–ç•¥ï¼Œä»¥æœ€å¤§åŒ–ç´¯ç§¯å¥–åŠ±ã€‚
    - **ç¤ºä¾‹**: ä¸€ä¸ªæ™ºèƒ½å®¶å±…ç³»ç»Ÿé€šè¿‡RLå­¦ä¹ ï¼šåœ¨ä½•ç§ä¸Šä¸‹æ–‡ï¼ˆæ—¶é—´ã€æ¸©åº¦ã€ç”¨æˆ·åœ¨å®¶çŠ¶æ€ï¼‰ä¸‹è°ƒæ•´ç©ºè°ƒæ¸©åº¦ï¼ˆåŠ¨ä½œï¼‰ï¼Œæ‰èƒ½åœ¨è·å¾—ç”¨æˆ·èˆ’é€‚åº¦ï¼ˆå¥–åŠ±ï¼‰å’ŒèŠ‚çº¦èƒ½æºï¼ˆå¥–åŠ±ï¼‰ä¹‹é—´è¾¾åˆ°æœ€ä½³å¹³è¡¡ã€‚

### 2.4 ä¸Šä¸‹æ–‡å‘ç° (Context Discovery)

ä½¿ç”¨æ— ç›‘ç£å­¦ä¹ æŠ€æœ¯æ¥è‡ªåŠ¨å‘ç°æ•°æ®ä¸­éšè—çš„ã€æœªçŸ¥çš„ä¸Šä¸‹æ–‡æ¨¡å¼ã€‚

- **ä»»åŠ¡**: è¯†åˆ«ç”¨æˆ·æ–°çš„ã€æœ‰æ„ä¹‰çš„åœ°ç‚¹ï¼ˆå¦‚"æ–°å®¶"ã€"æ–°å…¬å¸"ï¼‰ï¼Œæˆ–å‘ç°å…·æœ‰ç›¸ä¼¼è¡Œä¸ºæ¨¡å¼çš„ç”¨æˆ·ç¾¤ä½“ã€‚
- **å¸¸ç”¨æ¨¡å‹**:
  - **èšç±»ç®—æ³• (Clustering)**: å¦‚ K-Means, DBSCANï¼Œå¯ç”¨äºå°†ç›¸ä¼¼çš„ä½ç½®æ•°æ®ç‚¹èšç±»æˆæœ‰æ„ä¹‰çš„åœ°ç‚¹ã€‚

## 3 å…³é”®æŒ‘æˆ˜ (Key Challenges)

- **æ•°æ®ç¨€ç–æ€§ä¸æ ‡æ³¨æˆæœ¬**: è·å–å¤§é‡é«˜è´¨é‡ã€å¸¦æœ‰å‡†ç¡®æ ‡ç­¾çš„ä¸Šä¸‹æ–‡æ•°æ®æ˜¯éå¸¸å›°éš¾å’Œæ˜‚è´µçš„ã€‚
- **æ¦‚å¿µæ¼‚ç§» (Concept Drift)**: ç”¨æˆ·è¡Œä¸ºå’Œç¯å¢ƒæ˜¯ä¼šéšæ—¶é—´å˜åŒ–çš„ï¼Œä»Šå¤©å­¦åˆ°çš„æ¨¡å‹å¯èƒ½æ˜å¤©å°±ä¸å†é€‚ç”¨ã€‚ç³»ç»Ÿéœ€è¦å…·å¤‡æŒç»­å­¦ä¹ å’Œé€‚åº”æ¨¡å‹å˜åŒ–çš„èƒ½åŠ›ã€‚
- **å¯è§£é‡Šæ€§ (Interpretability)**: å¤æ‚çš„æ¨¡å‹ï¼ˆå¦‚æ·±åº¦å­¦ä¹ ï¼‰é€šå¸¸æ˜¯"é»‘ç®±"ï¼Œè¿™ä½¿å¾—ç†è§£å’Œä¿¡ä»»å…¶å†³ç­–å˜å¾—å›°éš¾ã€‚
- **èµ„æºé™åˆ¶**: åœ¨ç§»åŠ¨å’ŒåµŒå…¥å¼è®¾å¤‡ä¸Šè¿è¡Œå¤æ‚çš„å­¦ä¹ ç®—æ³•ä¼šå—åˆ°è®¡ç®—èƒ½åŠ›å’Œç”µæ± å¯¿å‘½çš„ä¸¥æ ¼é™åˆ¶ã€‚

## 4 Rust ä»£ç ç¤ºä¾‹ï¼šå­¦ä¹ ç”¨æˆ·åå¥½çš„ç®€å•éŸ³ä¹æ’­æ”¾å™¨

ä¸‹é¢çš„ä»£ç æ¨¡æ‹Ÿäº†ä¸€ä¸ªæç®€çš„"å­¦ä¹ "è¿‡ç¨‹ã€‚ä¸€ä¸ªæ™ºèƒ½éŸ³ä¹åŠ©æ‰‹æ ¹æ®ç”¨æˆ·åœ¨ä¸åŒä¸Šä¸‹æ–‡ï¼ˆæ—¶é—´ã€å¤©æ°”ï¼‰ä¸‹å¯¹æ­Œæ›²çš„"ç‚¹èµ"è¡Œä¸ºï¼Œæ¥å­¦ä¹ å¹¶æ¨èéŸ³ä¹ç±»å‹ã€‚

**æ³¨æ„**: è¿™æ˜¯ä¸€ä¸ªæ¦‚å¿µæ€§æ¼”ç¤ºï¼Œå¹¶éçœŸæ­£çš„æœºå™¨å­¦ä¹ æ¨¡å‹ï¼Œä½†å®ƒå±•ç¤ºäº†ä»åé¦ˆä¸­å­¦ä¹ çš„åŸºæœ¬æ€æƒ³ã€‚

```rust
use std::collections::HashMap;

// ä¸Šä¸‹æ–‡å®šä¹‰
#[derive(Debug, PartialEq, Eq, Hash, Clone)]
pub enum Context {
    Time(String),   // "Morning", "Afternoon", "Night"
    Weather(String), // "Sunny", "Rainy"
}

// åŠ¨ä½œ/é¡¹ç›® å®šä¹‰
#[derive(Debug, PartialEq, Eq, Hash, Clone)]
pub enum MusicGenre {
    Pop,
    Rock,
    Classical,
}

// ç®€å•çš„åå¥½å­¦ä¹ å™¨
// å®ƒè®°å½•åœ¨ç‰¹å®šä¸Šä¸‹æ–‡ç»„åˆä¸‹ï¼Œç”¨æˆ·å¯¹ä¸åŒéŸ³ä¹ç±»å‹çš„åå¥½åˆ†æ•°
pub struct PreferenceLearner {
    // (Vec<Context>, MusicGenre) -> Preference Score (i32)
    preferences: HashMap<(Vec<String>, MusicGenre), i32>,
}

impl PreferenceLearner {
    pub fn new() -> Self {
        PreferenceLearner {
            preferences: HashMap::new(),
        }
    }

    // æ ¹æ®ç”¨æˆ·åé¦ˆæ›´æ–°åå¥½æ¨¡å‹
    // like = true è¡¨ç¤ºåŠ åˆ†, like = false è¡¨ç¤ºå‡åˆ†
    pub fn learn(&mut self, current_context: &Vec<Context>, genre: &MusicGenre, like: bool) {
        // å°†ä¸Šä¸‹æ–‡å‘é‡è½¬æ¢ä¸ºä¸€ä¸ªå¯å“ˆå¸Œçš„é”®
        let mut context_key: Vec<String> = current_context.iter().map(|c| format!("{:?}", c)).collect();
        context_key.sort(); // ä¿è¯é¡ºåºæ— å…³æ€§

        let score = self.preferences.entry((context_key, genre.clone())).or_insert(0);
        if like {
            *score += 1;
            println!("[Learner] æ”¶åˆ°æ­£é¢åé¦ˆï¼ {:?} åœ¨ {:?} ä¸‹çš„åå¥½åˆ†æ•°å¢åŠ åˆ° {}", genre, current_context, *score);
        } else {
            *score -= 1;
             println!("[Learner] æ”¶åˆ°è´Ÿé¢åé¦ˆã€‚ {:?} åœ¨ {:?} ä¸‹çš„åå¥½åˆ†æ•°å‡å°‘åˆ° {}", genre, current_context, *score);
        }
    }

    // æ ¹æ®å½“å‰ä¸Šä¸‹æ–‡æ¨èæœ€ä½³éŸ³ä¹ç±»å‹
    pub fn recommend(&self, current_context: &Vec<Context>) -> MusicGenre {
        let mut context_key: Vec<String> = current_context.iter().map(|c| format!("{:?}", c)).collect();
        context_key.sort();

        let genres = vec![MusicGenre::Pop, MusicGenre::Rock, MusicGenre::Classical];
        let mut best_genre = MusicGenre::Pop; // é»˜è®¤æ¨è
        let mut max_score = -100;

        for genre in genres {
            let key = (context_key.clone(), genre.clone());
            let score = self.preferences.get(&key).unwrap_or(&0);
            if *score > max_score {
                max_score = *score;
                best_genre = genre;
            }
        }
        println!("[Recommender] åœ¨ {:?} ä¸‹ï¼Œæ¨è: {:?} (åˆ†æ•°: {})", current_context, best_genre, max_score);
        best_genre
    }
}

fn main() {
    let mut learner = PreferenceLearner::new();

    // --- æ¨¡æ‹Ÿå­¦ä¹ è¿‡ç¨‹ ---

    // åœºæ™¯1: é›¨å¤©çš„ä¸‹åˆï¼Œç”¨æˆ·å–œæ¬¢å¤å…¸éŸ³ä¹
    let context1 = vec![Context::Time("Afternoon".into()), Context::Weather("Rainy".into())];
    learner.learn(&context1, &MusicGenre::Classical, true);
    learner.learn(&context1, &MusicGenre::Classical, true); // å†æ¬¡å–œæ¬¢
    learner.learn(&context1, &MusicGenre::Pop, false);     // ä¸å–œæ¬¢ Pop

    // åœºæ™¯2: æ™´æœ—çš„æ—©æ™¨ï¼Œç”¨æˆ·å–œæ¬¢æµè¡ŒéŸ³ä¹
    let context2 = vec![Context::Time("Morning".into()), Context::Weather("Sunny".into())];
    learner.learn(&context2, &MusicGenre::Pop, true);

    // --- æ¨¡æ‹Ÿæ¨è ---
    
    println!("\n--- å¼€å§‹æ¨è ---");
    // åœ¨ä¸€ä¸ªå’Œåœºæ™¯1ç›¸ä¼¼çš„ä¸Šä¸‹æ–‡ä¸­è¯·æ±‚æ¨è
    let test_context1 = vec![Context::Weather("Rainy".into()), Context::Time("Afternoon".into())];
    let recommendation1 = learner.recommend(&test_context1);
    assert_eq!(recommendation1, MusicGenre::Classical);
    
    // åœ¨ä¸€ä¸ªå’Œåœºæ™¯2ç›¸ä¼¼çš„ä¸Šä¸‹æ–‡ä¸­è¯·æ±‚æ¨è
    let test_context2 = vec![Context::Time("Morning".into()), Context::Weather("Sunny".into())];
    let recommendation2 = learner.recommend(&test_context2);
    assert_eq!(recommendation2, MusicGenre::Pop);
}
```

## 5 ç»“è®º

ä¸Šä¸‹æ–‡å­¦ä¹ ç†è®ºä¸ºä¸Šä¸‹æ–‡æ„ŸçŸ¥ç³»ç»Ÿæ³¨å…¥äº†æ™ºèƒ½å’Œè‡ªä¸»æ€§ï¼Œä½¿å…¶èƒ½å¤Ÿä»è¢«åŠ¨å“åº”æ¼”å˜ä¸ºä¸»åŠ¨é¢„æµ‹å’Œä¼˜åŒ–ã€‚é€šè¿‡æ•´åˆæœºå™¨å­¦ä¹ ï¼Œç³»ç»Ÿèƒ½å¤Ÿå¤„ç†æ›´å¤æ‚ã€æ›´åŠ¨æ€çš„ç¯å¢ƒï¼Œå¹¶æä¾›æ·±åº¦ä¸ªæ€§åŒ–çš„æœåŠ¡ã€‚æœªæ¥çš„å‘å±•æ–¹å‘å°†é›†ä¸­åœ¨å¦‚ä½•åˆ©ç”¨æ›´å…ˆè¿›çš„AIæŠ€æœ¯ï¼ˆå¦‚è”é‚¦å­¦ä¹ ã€å…ƒå­¦ä¹ ï¼‰æ¥è§£å†³æ•°æ®éšç§ã€æŒç»­å­¦ä¹ å’Œèµ„æºå—é™ç­‰æ ¸å¿ƒæŒ‘æˆ˜ï¼Œä»è€Œæ„å»ºå‡ºçœŸæ­£ä¸ç”¨æˆ·å…±åŒæˆé•¿çš„ä¸Šä¸‹æ–‡æ„ŸçŸ¥ç³»ç»Ÿã€‚

## 6 æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
