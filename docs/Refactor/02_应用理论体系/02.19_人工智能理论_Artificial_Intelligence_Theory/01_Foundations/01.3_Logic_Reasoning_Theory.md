# 01.3 é€»è¾‘æ¨ç†ç†è®º (Logic Reasoning Theory)

## ğŸ“‹ ç›®å½•

- [01.3 é€»è¾‘æ¨ç†ç†è®º (Logic Reasoning Theory)](#013-é€»è¾‘æ¨ç†ç†è®º-logic-reasoning-theory)
  - [1 . åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 é€»è¾‘æ¨ç†å®šä¹‰](#11-é€»è¾‘æ¨ç†å®šä¹‰)
    - [1.2 æ¨ç†ç±»å‹åˆ†ç±»](#12-æ¨ç†ç±»å‹åˆ†ç±»)
  - [2 . å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
    - [2.1 å‘½é¢˜é€»è¾‘](#21-å‘½é¢˜é€»è¾‘)
    - [2.2 è°“è¯é€»è¾‘](#22-è°“è¯é€»è¾‘)
    - [2.3 æ¨¡æ€é€»è¾‘](#23-æ¨¡æ€é€»è¾‘)
  - [3 . å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
    - [3.1 é€»è¾‘å®Œå¤‡æ€§å®šç†](#31-é€»è¾‘å®Œå¤‡æ€§å®šç†)
    - [3.2 æ¨ç†å¯é æ€§å®šç†](#32-æ¨ç†å¯é æ€§å®šç†)
  - [4 . æ ¸å¿ƒç®—æ³•ç†è®º](#4-æ ¸å¿ƒç®—æ³•ç†è®º)
    - [4.1 å½’ç»“æ¨ç†ç†è®º](#41-å½’ç»“æ¨ç†ç†è®º)
    - [4.2 è‡ªç„¶æ¼”ç»ç†è®º](#42-è‡ªç„¶æ¼”ç»ç†è®º)
    - [4.3 è¡¨æ¨æ¼”ç†è®º](#43-è¡¨æ¨æ¼”ç†è®º)
  - [5 . Rustä»£ç å®ç°](#5-rustä»£ç å®ç°)
    - [5.1 å‘½é¢˜é€»è¾‘å®ç°](#51-å‘½é¢˜é€»è¾‘å®ç°)
    - [5.2 è°“è¯é€»è¾‘å®ç°](#52-è°“è¯é€»è¾‘å®ç°)
    - [5.3 å½’ç»“æ¨ç†å®ç°](#53-å½’ç»“æ¨ç†å®ç°)
  - [6 . ç›¸å…³ç†è®ºä¸äº¤å‰å¼•ç”¨](#6-ç›¸å…³ç†è®ºä¸äº¤å‰å¼•ç”¨)
    - [1 ä¸æ•°å­¦åŸºç¡€çš„äº¤å‰](#1-ä¸æ•°å­¦åŸºç¡€çš„äº¤å‰)
    - [6.2 ä¸è®¡ç®—æœºç§‘å­¦çš„äº¤å‰](#62-ä¸è®¡ç®—æœºç§‘å­¦çš„äº¤å‰)
    - [6.3 ä¸å“²å­¦çš„äº¤å‰](#63-ä¸å“²å­¦çš„äº¤å‰)
  - [7 . å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
    - [1 ç»å…¸æ•™æ](#1-ç»å…¸æ•™æ)
    - [7.2 é‡è¦è®ºæ–‡](#72-é‡è¦è®ºæ–‡)
    - [7.3 åœ¨çº¿èµ„æº](#73-åœ¨çº¿èµ„æº)
  - [8 æ‰¹åˆ¤æ€§åˆ†æ](#8-æ‰¹åˆ¤æ€§åˆ†æ)
    - [1 ä¸»è¦ç†è®ºè§‚ç‚¹æ¢³ç†](#1-ä¸»è¦ç†è®ºè§‚ç‚¹æ¢³ç†)
    - [8.2 ä¸»æµè§‚ç‚¹çš„ä¼˜ç¼ºç‚¹åˆ†æ](#82-ä¸»æµè§‚ç‚¹çš„ä¼˜ç¼ºç‚¹åˆ†æ)
    - [8.3 ä¸å…¶ä»–å­¦ç§‘çš„äº¤å‰ä¸èåˆ](#83-ä¸å…¶ä»–å­¦ç§‘çš„äº¤å‰ä¸èåˆ)
    - [8.4 åˆ›æ–°æ€§æ‰¹åˆ¤ä¸æœªæ¥å±•æœ›](#84-åˆ›æ–°æ€§æ‰¹åˆ¤ä¸æœªæ¥å±•æœ›)

---

## 1 . åŸºæœ¬æ¦‚å¿µ

### 1.1 é€»è¾‘æ¨ç†å®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆé€»è¾‘æ¨ç†ï¼‰
é€»è¾‘æ¨ç†æ˜¯ä½¿ç”¨å½¢å¼åŒ–è§„åˆ™ä»å·²çŸ¥å‰ææ¨å¯¼å‡ºç»“è®ºçš„è¿‡ç¨‹ï¼Œæ˜¯äººå·¥æ™ºèƒ½ä¸­ç¬¦å·æ¨ç†çš„æ ¸å¿ƒæ–¹æ³•ã€‚

### 1.2 æ¨ç†ç±»å‹åˆ†ç±»

| æ¨ç†ç±»å‹     | è‹±æ–‡åç§°         | æè¿°                         | å…¸å‹åº”ç”¨         |
|--------------|------------------|------------------------------|------------------|
| æ¼”ç»æ¨ç†     | Deductive        | ä»ä¸€èˆ¬åˆ°ç‰¹æ®Šçš„æ¨ç†           | å®šç†è¯æ˜         |
| å½’çº³æ¨ç†     | Inductive        | ä»ç‰¹æ®Šåˆ°ä¸€èˆ¬çš„æ¨ç†           | æ¨¡å¼å‘ç°         |
| æº¯å› æ¨ç†     | Abductive        | ä»ç»“æœåˆ°åŸå› çš„æ¨ç†           | è¯Šæ–­ç³»ç»Ÿ         |
| ç±»æ¯”æ¨ç†     | Analogical       | åŸºäºç›¸ä¼¼æ€§çš„æ¨ç†             | æ¡ˆä¾‹æ¨ç†         |

## 2 . å½¢å¼åŒ–å®šä¹‰

### 2.1 å‘½é¢˜é€»è¾‘

**å®šä¹‰ 2.1**ï¼ˆå‘½é¢˜ï¼‰
å‘½é¢˜æ˜¯å…·æœ‰çœŸå€¼çš„é™ˆè¿°å¥ï¼Œç”¨ç¬¦å· $p, q, r$ è¡¨ç¤ºã€‚

**å®šä¹‰ 2.2**ï¼ˆé€»è¾‘è¿æ¥è¯ï¼‰
åŸºæœ¬é€»è¾‘è¿æ¥è¯åŒ…æ‹¬ï¼š

- å¦å®šï¼š$\neg p$
- åˆå–ï¼š$p \wedge q$
- æå–ï¼š$p \vee q$
- è•´å«ï¼š$p \rightarrow q$
- ç­‰ä»·ï¼š$p \leftrightarrow q$

**å®šä¹‰ 2.3**ï¼ˆå‘½é¢˜å…¬å¼ï¼‰
å‘½é¢˜å…¬å¼é€’å½’å®šä¹‰ä¸ºï¼š

1. åŸå­å‘½é¢˜æ˜¯å…¬å¼
2. å¦‚æœ $\phi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\neg \phi$ æ˜¯å…¬å¼
3. å¦‚æœ $\phi, \psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $(\phi \wedge \psi), (\phi \vee \psi), (\phi \rightarrow \psi), (\phi \leftrightarrow \psi)$ æ˜¯å…¬å¼

### 2.2 è°“è¯é€»è¾‘

**å®šä¹‰ 2.4**ï¼ˆè°“è¯ï¼‰
è°“è¯æ˜¯æè¿°å¯¹è±¡æ€§è´¨çš„å‡½æ•° $P(x_1, x_2, ..., x_n)$ã€‚

**å®šä¹‰ 2.5**ï¼ˆé‡è¯ï¼‰

- å…¨ç§°é‡è¯ï¼š$\forall x P(x)$ è¡¨ç¤º"å¯¹æ‰€æœ‰xï¼ŒP(x)æˆç«‹"
- å­˜åœ¨é‡è¯ï¼š$\exists x P(x)$ è¡¨ç¤º"å­˜åœ¨xï¼Œä½¿å¾—P(x)æˆç«‹"

**å®šä¹‰ 2.6**ï¼ˆè°“è¯å…¬å¼ï¼‰
è°“è¯å…¬å¼é€’å½’å®šä¹‰ä¸ºï¼š

1. åŸå­å…¬å¼æ˜¯å…¬å¼
2. å¦‚æœ $\phi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\neg \phi$ æ˜¯å…¬å¼
3. å¦‚æœ $\phi, \psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $(\phi \wedge \psi), (\phi \vee \psi), (\phi \rightarrow \psi), (\phi \leftrightarrow \psi)$ æ˜¯å…¬å¼
4. å¦‚æœ $\phi$ æ˜¯å…¬å¼ï¼Œ$x$ æ˜¯å˜é‡ï¼Œåˆ™ $\forall x \phi, \exists x \phi$ æ˜¯å…¬å¼

### 2.3 æ¨¡æ€é€»è¾‘

**å®šä¹‰ 2.7**ï¼ˆæ¨¡æ€ç®—å­ï¼‰

- å¿…ç„¶ç®—å­ï¼š$\Box \phi$ è¡¨ç¤º"å¿…ç„¶åœ°ï¼Œ$\phi$æˆç«‹"
- å¯èƒ½ç®—å­ï¼š$\Diamond \phi$ è¡¨ç¤º"å¯èƒ½åœ°ï¼Œ$\phi$æˆç«‹"

**å®šä¹‰ 2.8**ï¼ˆæ¨¡æ€å…¬å¼ï¼‰
æ¨¡æ€å…¬å¼é€’å½’å®šä¹‰ä¸ºï¼š

1. å‘½é¢˜å…¬å¼æ˜¯æ¨¡æ€å…¬å¼
2. å¦‚æœ $\phi$ æ˜¯æ¨¡æ€å…¬å¼ï¼Œåˆ™ $\Box \phi, \Diamond \phi$ æ˜¯æ¨¡æ€å…¬å¼

## 3 . å®šç†ä¸è¯æ˜

### 3.1 é€»è¾‘å®Œå¤‡æ€§å®šç†

**å®šç† 3.1**ï¼ˆå‘½é¢˜é€»è¾‘å®Œå¤‡æ€§ï¼‰
å‘½é¢˜é€»è¾‘æ˜¯å®Œå¤‡çš„ï¼Œå³æ‰€æœ‰æœ‰æ•ˆå…¬å¼éƒ½æ˜¯å¯è¯æ˜çš„ã€‚

**è¯æ˜**ï¼š
é€šè¿‡çœŸå€¼è¡¨æ–¹æ³•å¯ä»¥éªŒè¯æ‰€æœ‰æœ‰æ•ˆå…¬å¼çš„å¯è¯æ˜æ€§ã€‚å¯¹äºä»»æ„æœ‰æ•ˆå…¬å¼ $\phi$ï¼Œå…¶çœŸå€¼è¡¨åœ¨æ‰€æœ‰èµ‹å€¼ä¸‹éƒ½ä¸ºçœŸï¼Œå› æ­¤å¯ä»¥é€šè¿‡å…¬ç†å’Œæ¨ç†è§„åˆ™è¯æ˜ã€‚â–¡

### 3.2 æ¨ç†å¯é æ€§å®šç†

**å®šç† 3.2**ï¼ˆæ¨ç†å¯é æ€§ï¼‰
å¦‚æœä»å‰æé›†åˆ $\Gamma$ å¯ä»¥æ¨å¯¼å‡ºç»“è®º $\phi$ï¼Œåˆ™ $\phi$ æ˜¯ $\Gamma$ çš„é€»è¾‘åæ‰¿ã€‚

**è¯æ˜**ï¼š
é€šè¿‡å½’çº³æ³•è¯æ˜æ¨ç†è§„åˆ™çš„å¯é æ€§ã€‚æ¯ä¸ªæ¨ç†è§„åˆ™éƒ½ä¿æŒçœŸå€¼ï¼Œå› æ­¤ä»çœŸå‰ææ¨å¯¼å‡ºçš„ç»“è®ºä¹Ÿä¸ºçœŸã€‚â–¡

## 4 . æ ¸å¿ƒç®—æ³•ç†è®º

### 4.1 å½’ç»“æ¨ç†ç†è®º

**å®šä¹‰ 4.1**ï¼ˆå½’ç»“æ¨ç†ï¼‰
å½’ç»“æ¨ç†æ˜¯ä¸€ç§è‡ªåŠ¨å®šç†è¯æ˜æ–¹æ³•ï¼Œé€šè¿‡æ¶ˆè§£äº’è¡¥æ–‡å­—æ¥æ¨å¯¼ç»“è®ºã€‚

**ç®—æ³• 4.1**ï¼ˆå½’ç»“ç®—æ³•ï¼‰

1. å°†å‰æå’Œç»“è®ºçš„å¦å®šè½¬æ¢ä¸ºåˆå–èŒƒå¼
2. é‡å¤åº”ç”¨å½’ç»“è§„åˆ™ï¼Œæ¶ˆè§£äº’è¡¥æ–‡å­—
3. å¦‚æœå¾—åˆ°ç©ºå­å¥ï¼Œåˆ™è¯æ˜æˆåŠŸ

**å®šç† 4.1**ï¼ˆå½’ç»“å®Œå¤‡æ€§ï¼‰
å½’ç»“æ¨ç†æ˜¯å®Œå¤‡çš„ï¼Œå³å¦‚æœå…¬å¼é›†åˆä¸å¯æ»¡è¶³ï¼Œåˆ™å½’ç»“ç®—æ³•ä¼šæ¨å¯¼å‡ºç©ºå­å¥ã€‚

### 4.2 è‡ªç„¶æ¼”ç»ç†è®º

**å®šä¹‰ 4.2**ï¼ˆè‡ªç„¶æ¼”ç»ï¼‰
è‡ªç„¶æ¼”ç»æ˜¯ä¸€ç§ç›´è§‚çš„æ¨ç†ç³»ç»Ÿï¼Œä½¿ç”¨å¼•å…¥å’Œæ¶ˆé™¤è§„åˆ™ã€‚

**è§„åˆ™ 4.1**ï¼ˆè•´å«å¼•å…¥ï¼‰
å¦‚æœä»å‡è®¾ $\phi$ å¯ä»¥æ¨å¯¼å‡º $\psi$ï¼Œåˆ™å¯ä»¥æ¨å¯¼å‡º $\phi \rightarrow \psi$ã€‚

**è§„åˆ™ 4.2**ï¼ˆè•´å«æ¶ˆé™¤ï¼‰
å¦‚æœ $\phi \rightarrow \psi$ å’Œ $\phi$ éƒ½æˆç«‹ï¼Œåˆ™å¯ä»¥æ¨å¯¼å‡º $\psi$ã€‚

### 4.3 è¡¨æ¨æ¼”ç†è®º

**å®šä¹‰ 4.3**ï¼ˆè¡¨æ¨æ¼”ï¼‰
è¡¨æ¨æ¼”æ˜¯ä¸€ç§è¯­ä¹‰æ¨ç†æ–¹æ³•ï¼Œé€šè¿‡æ„å»ºçœŸå€¼è¡¨æ¥éªŒè¯å…¬å¼çš„æœ‰æ•ˆæ€§ã€‚

**ç®—æ³• 4.2**ï¼ˆè¡¨æ¨æ¼”ç®—æ³•ï¼‰

1. æ„å»ºå…¬å¼çš„è¯­æ³•æ ‘
2. ä¸ºæ¯ä¸ªåˆ†æ”¯åˆ†é…çœŸå€¼
3. æ£€æŸ¥æ˜¯å¦å­˜åœ¨çŸ›ç›¾

## 5 . Rustä»£ç å®ç°

### 5.1 å‘½é¢˜é€»è¾‘å®ç°

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub enum Proposition {
    Atom(String),
    Not(Box<Proposition>),
    And(Box<Proposition>, Box<Proposition>),
    Or(Box<Proposition>, Box<Proposition>),
    Implies(Box<Proposition>, Box<Proposition>),
    Iff(Box<Proposition>, Box<Proposition>),
}

impl Proposition {
    pub fn atom(name: &str) -> Self {
        Proposition::Atom(name.to_string())
    }

    pub fn not(prop: Proposition) -> Self {
        Proposition::Not(Box::new(prop))
    }

    pub fn and(left: Proposition, right: Proposition) -> Self {
        Proposition::And(Box::new(left), Box::new(right))
    }

    pub fn or(left: Proposition, right: Proposition) -> Self {
        Proposition::Or(Box::new(left), Box::new(right))
    }

    pub fn implies(left: Proposition, right: Proposition) -> Self {
        Proposition::Implies(Box::new(left), Box::new(right))
    }

    pub fn iff(left: Proposition, right: Proposition) -> Self {
        Proposition::Iff(Box::new(left), Box::new(right))
    }

    // è¯­ä¹‰è¯„ä¼°
    pub fn evaluate(&self, assignment: &HashMap<String, bool>) -> bool {
        match self {
            Proposition::Atom(name) => *assignment.get(name).unwrap_or(&false),
            Proposition::Not(prop) => !prop.evaluate(assignment),
            Proposition::And(left, right) => {
                left.evaluate(assignment) && right.evaluate(assignment)
            }
            Proposition::Or(left, right) => {
                left.evaluate(assignment) || right.evaluate(assignment)
            }
            Proposition::Implies(left, right) => {
                !left.evaluate(assignment) || right.evaluate(assignment)
            }
            Proposition::Iff(left, right) => {
                left.evaluate(assignment) == right.evaluate(assignment)
            }
        }
    }

    // è·å–æ‰€æœ‰åŸå­å‘½é¢˜
    pub fn get_atoms(&self) -> Vec<String> {
        match self {
            Proposition::Atom(name) => vec![name.clone()],
            Proposition::Not(prop) => prop.get_atoms(),
            Proposition::And(left, right) => {
                let mut atoms = left.get_atoms();
                atoms.extend(right.get_atoms());
                atoms.sort();
                atoms.dedup();
                atoms
            }
            Proposition::Or(left, right) => {
                let mut atoms = left.get_atoms();
                atoms.extend(right.get_atoms());
                atoms.sort();
                atoms.dedup();
                atoms
            }
            Proposition::Implies(left, right) => {
                let mut atoms = left.get_atoms();
                atoms.extend(right.get_atoms());
                atoms.sort();
                atoms.dedup();
                atoms
            }
            Proposition::Iff(left, right) => {
                let mut atoms = left.get_atoms();
                atoms.extend(right.get_atoms());
                atoms.sort();
                atoms.dedup();
                atoms
            }
        }
    }

    // è½¬æ¢ä¸ºåˆå–èŒƒå¼
    pub fn to_cnf(&self) -> Vec<Vec<String>> {
        // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦å®Œæ•´çš„CNFè½¬æ¢ç®—æ³•
        match self {
            Proposition::Atom(name) => vec![vec![name.clone()]],
            Proposition::Not(prop) => {
                match **prop {
                    Proposition::Atom(name) => vec![vec![format!("!{}", name)]],
                    _ => vec![vec!["complex_not".to_string()]],
                }
            }
            _ => vec![vec!["complex_formula".to_string()]],
        }
    }
}

// é€»è¾‘æ¨ç†å¼•æ“
#[derive(Debug)]
pub struct LogicEngine {
    pub knowledge_base: Vec<Proposition>,
}

impl LogicEngine {
    pub fn new() -> Self {
        LogicEngine {
            knowledge_base: Vec::new(),
        }
    }

    pub fn add_knowledge(&mut self, prop: Proposition) {
        self.knowledge_base.push(prop);
    }

    // æ£€æŸ¥é€»è¾‘åæ‰¿
    pub fn entails(&self, conclusion: &Proposition) -> bool {
        // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦å®Œæ•´çš„å®šç†è¯æ˜ç®—æ³•
        let atoms = conclusion.get_atoms();
        let mut assignment = HashMap::new();
        
        // æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„çœŸå€¼èµ‹å€¼
        self.check_all_assignments(conclusion, &atoms, &mut assignment, 0)
    }

    fn check_all_assignments(
        &self,
        conclusion: &Proposition,
        atoms: &[String],
        assignment: &mut HashMap<String, bool>,
        index: usize,
    ) -> bool {
        if index >= atoms.len() {
            // æ£€æŸ¥å½“å‰èµ‹å€¼ä¸‹æ˜¯å¦æ‰€æœ‰çŸ¥è¯†éƒ½ä¸ºçœŸä¸”ç»“è®ºä¸ºå‡
            let kb_true = self.knowledge_base.iter()
                .all(|prop| prop.evaluate(assignment));
            let conclusion_false = !conclusion.evaluate(assignment);
            
            !(kb_true && conclusion_false)
        } else {
            // é€’å½’å°è¯•æ‰€æœ‰çœŸå€¼èµ‹å€¼
            assignment.insert(atoms[index].clone(), true);
            let result1 = self.check_all_assignments(conclusion, atoms, assignment, index + 1);
            
            assignment.insert(atoms[index].clone(), false);
            let result2 = self.check_all_assignments(conclusion, atoms, assignment, index + 1);
            
            result1 && result2
        }
    }

    // å½’ç»“æ¨ç†
    pub fn resolution(&self, conclusion: &Proposition) -> bool {
        let mut clauses = Vec::new();
        
        // å°†çŸ¥è¯†åº“è½¬æ¢ä¸ºå­å¥
        for prop in &self.knowledge_base {
            clauses.extend(prop.to_cnf());
        }
        
        // æ·»åŠ ç»“è®ºçš„å¦å®š
        let negated_conclusion = Proposition::not(conclusion.clone());
        clauses.extend(negated_conclusion.to_cnf());
        
        // æ‰§è¡Œå½’ç»“æ¨ç†
        self.resolve_clauses(&mut clauses)
    }

    fn resolve_clauses(&self, clauses: &mut Vec<Vec<String>>) -> bool {
        let mut new_clauses = Vec::new();
        let mut resolved = false;
        
        for i in 0..clauses.len() {
            for j in (i + 1)..clauses.len() {
                if let Some(resolvent) = self.resolve_pair(&clauses[i], &clauses[j]) {
                    if resolvent.is_empty() {
                        return true; // æ‰¾åˆ°ç©ºå­å¥ï¼Œè¯æ˜æˆåŠŸ
                    }
                    if !clauses.contains(&resolvent) && !new_clauses.contains(&resolvent) {
                        new_clauses.push(resolvent);
                        resolved = true;
                    }
                }
            }
        }
        
        if resolved {
            clauses.extend(new_clauses);
            self.resolve_clauses(clauses)
        } else {
            false // æ— æ³•å½’ç»“å‡ºç©ºå­å¥
        }
    }

    fn resolve_pair(&self, clause1: &[String], clause2: &[String]) -> Option<Vec<String>> {
        for literal1 in clause1 {
            for literal2 in clause2 {
                if self.are_complementary(literal1, literal2) {
                    let mut resolvent = Vec::new();
                    
                    // æ·»åŠ clause1ä¸­é™¤literal1å¤–çš„æ‰€æœ‰æ–‡å­—
                    for lit in clause1 {
                        if lit != literal1 {
                            resolvent.push(lit.clone());
                        }
                    }
                    
                    // æ·»åŠ clause2ä¸­é™¤literal2å¤–çš„æ‰€æœ‰æ–‡å­—
                    for lit in clause2 {
                        if lit != literal2 {
                            resolvent.push(lit.clone());
                        }
                    }
                    
                    // å»é‡
                    resolvent.sort();
                    resolvent.dedup();
                    
                    return Some(resolvent);
                }
            }
        }
        None
    }

    fn are_complementary(&self, literal1: &str, literal2: &str) -> bool {
        (literal1.starts_with('!') && literal2 == &literal1[1..]) ||
        (literal2.starts_with('!') && literal1 == &literal2[1..])
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_proposition_evaluation() {
        let mut assignment = HashMap::new();
        assignment.insert("p".to_string(), true);
        assignment.insert("q".to_string(), false);
        
        let prop = Proposition::implies(
            Proposition::atom("p"),
            Proposition::atom("q")
        );
        
        assert_eq!(prop.evaluate(&assignment), false);
    }

    #[test]
    fn test_logic_engine() {
        let mut engine = LogicEngine::new();
        
        // æ·»åŠ çŸ¥è¯†ï¼šå¦‚æœpåˆ™qï¼Œpä¸ºçœŸ
        engine.add_knowledge(Proposition::implies(
            Proposition::atom("p"),
            Proposition::atom("q")
        ));
        engine.add_knowledge(Proposition::atom("p"));
        
        // æ£€æŸ¥æ˜¯å¦èƒ½æ¨å¯¼å‡ºq
        assert!(engine.entails(&Proposition::atom("q")));
    }
}
```

### 5.2 è°“è¯é€»è¾‘å®ç°

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub enum Term {
    Variable(String),
    Constant(String),
    Function(String, Vec<Term>),
}

#[derive(Debug, Clone, PartialEq)]
pub enum PredicateFormula {
    Atom(String, Vec<Term>),
    Not(Box<PredicateFormula>),
    And(Box<PredicateFormula>, Box<PredicateFormula>),
    Or(Box<PredicateFormula>, Box<PredicateFormula>),
    Implies(Box<PredicateFormula>, Box<PredicateFormula>),
    ForAll(String, Box<PredicateFormula>),
    Exists(String, Box<PredicateFormula>),
}

impl PredicateFormula {
    pub fn atom(predicate: &str, terms: Vec<Term>) -> Self {
        PredicateFormula::Atom(predicate.to_string(), terms)
    }

    pub fn not(formula: PredicateFormula) -> Self {
        PredicateFormula::Not(Box::new(formula))
    }

    pub fn and(left: PredicateFormula, right: PredicateFormula) -> Self {
        PredicateFormula::And(Box::new(left), Box::new(right))
    }

    pub fn or(left: PredicateFormula, right: PredicateFormula) -> Self {
        PredicateFormula::Or(Box::new(left), Box::new(right))
    }

    pub fn implies(left: PredicateFormula, right: PredicateFormula) -> Self {
        PredicateFormula::Implies(Box::new(left), Box::new(right))
    }

    pub fn for_all(variable: &str, formula: PredicateFormula) -> Self {
        PredicateFormula::ForAll(variable.to_string(), Box::new(formula))
    }

    pub fn exists(variable: &str, formula: PredicateFormula) -> Self {
        PredicateFormula::Exists(variable.to_string(), Box::new(formula))
    }

    // è‡ªç”±å˜é‡
    pub fn free_variables(&self) -> Vec<String> {
        match self {
            PredicateFormula::Atom(_, terms) => {
                let mut vars = Vec::new();
                for term in terms {
                    vars.extend(term.variables());
                }
                vars
            }
            PredicateFormula::Not(formula) => formula.free_variables(),
            PredicateFormula::And(left, right) => {
                let mut vars = left.free_variables();
                vars.extend(right.free_variables());
                vars.sort();
                vars.dedup();
                vars
            }
            PredicateFormula::Or(left, right) => {
                let mut vars = left.free_variables();
                vars.extend(right.free_variables());
                vars.sort();
                vars.dedup();
                vars
            }
            PredicateFormula::Implies(left, right) => {
                let mut vars = left.free_variables();
                vars.extend(right.free_variables());
                vars.sort();
                vars.dedup();
                vars
            }
            PredicateFormula::ForAll(var, formula) => {
                let mut vars = formula.free_variables();
                vars.retain(|v| v != var);
                vars
            }
            PredicateFormula::Exists(var, formula) => {
                let mut vars = formula.free_variables();
                vars.retain(|v| v != var);
                vars
            }
        }
    }

    // å˜é‡æ›¿æ¢
    pub fn substitute(&self, variable: &str, term: &Term) -> PredicateFormula {
        match self {
            PredicateFormula::Atom(pred, terms) => {
                let new_terms = terms.iter()
                    .map(|t| t.substitute(variable, term))
                    .collect();
                PredicateFormula::Atom(pred.clone(), new_terms)
            }
            PredicateFormula::Not(formula) => {
                PredicateFormula::not(formula.substitute(variable, term))
            }
            PredicateFormula::And(left, right) => {
                PredicateFormula::and(
                    left.substitute(variable, term),
                    right.substitute(variable, term)
                )
            }
            PredicateFormula::Or(left, right) => {
                PredicateFormula::or(
                    left.substitute(variable, term),
                    right.substitute(variable, term)
                )
            }
            PredicateFormula::Implies(left, right) => {
                PredicateFormula::implies(
                    left.substitute(variable, term),
                    right.substitute(variable, term)
                )
            }
            PredicateFormula::ForAll(var, formula) => {
                if var == variable {
                    self.clone()
                } else {
                    PredicateFormula::for_all(var, formula.substitute(variable, term))
                }
            }
            PredicateFormula::Exists(var, formula) => {
                if var == variable {
                    self.clone()
                } else {
                    PredicateFormula::exists(var, formula.substitute(variable, term))
                }
            }
        }
    }
}

impl Term {
    pub fn variable(name: &str) -> Self {
        Term::Variable(name.to_string())
    }

    pub fn constant(name: &str) -> Self {
        Term::Constant(name.to_string())
    }

    pub fn function(name: &str, args: Vec<Term>) -> Self {
        Term::Function(name.to_string(), args)
    }

    pub fn variables(&self) -> Vec<String> {
        match self {
            Term::Variable(name) => vec![name.clone()],
            Term::Constant(_) => Vec::new(),
            Term::Function(_, args) => {
                let mut vars = Vec::new();
                for arg in args {
                    vars.extend(arg.variables());
                }
                vars
            }
        }
    }

    pub fn substitute(&self, variable: &str, term: &Term) -> Term {
        match self {
            Term::Variable(name) => {
                if name == variable {
                    term.clone()
                } else {
                    self.clone()
                }
            }
            Term::Constant(_) => self.clone(),
            Term::Function(name, args) => {
                let new_args = args.iter()
                    .map(|arg| arg.substitute(variable, term))
                    .collect();
                Term::Function(name.clone(), new_args)
            }
        }
    }
}

// è°“è¯é€»è¾‘æ¨ç†å¼•æ“
#[derive(Debug)]
pub struct PredicateLogicEngine {
    pub knowledge_base: Vec<PredicateFormula>,
    pub domain: Vec<String>, // è®ºåŸŸ
}

impl PredicateLogicEngine {
    pub fn new() -> Self {
        PredicateLogicEngine {
            knowledge_base: Vec::new(),
            domain: Vec::new(),
        }
    }

    pub fn add_knowledge(&mut self, formula: PredicateFormula) {
        self.knowledge_base.push(formula);
    }

    pub fn add_domain_element(&mut self, element: &str) {
        self.domain.push(element.to_string());
    }

    // æ£€æŸ¥é€»è¾‘åæ‰¿ï¼ˆç®€åŒ–å®ç°ï¼‰
    pub fn entails(&self, conclusion: &PredicateFormula) -> bool {
        // è¿™é‡Œåº”è¯¥å®ç°å®Œæ•´çš„è°“è¯é€»è¾‘æ¨ç†ç®—æ³•
        // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„ç®—æ³•
        true
    }

    // åˆä¸€ç®—æ³•
    pub fn unify(&self, term1: &Term, term2: &Term) -> Option<HashMap<String, Term>> {
        match (term1, term2) {
            (Term::Variable(var), term) | (term, Term::Variable(var)) => {
                let mut substitution = HashMap::new();
                substitution.insert(var.clone(), term.clone());
                Some(substitution)
            }
            (Term::Constant(c1), Term::Constant(c2)) => {
                if c1 == c2 {
                    Some(HashMap::new())
                } else {
                    None
                }
            }
            (Term::Function(f1, args1), Term::Function(f2, args2)) => {
                if f1 == f2 && args1.len() == args2.len() {
                    let mut substitution = HashMap::new();
                    for (arg1, arg2) in args1.iter().zip(args2.iter()) {
                        if let Some(sub) = self.unify(arg1, arg2) {
                            // åˆå¹¶æ›¿æ¢
                            for (k, v) in sub {
                                substitution.insert(k, v);
                            }
                        } else {
                            return None;
                        }
                    }
                    Some(substitution)
                } else {
                    None
                }
            }
            _ => None,
        }
    }
}

#[cfg(test)]
mod predicate_tests {
    use super::*;

    #[test]
    fn test_term_substitution() {
        let term = Term::function("f", vec![
            Term::variable("x"),
            Term::constant("a")
        ]);
        
        let substitution = term.substitute("x", &Term::constant("b"));
        
        assert_eq!(substitution, Term::function("f", vec![
            Term::constant("b"),
            Term::constant("a")
        ]));
    }

    #[test]
    fn test_formula_free_variables() {
        let formula = PredicateFormula::for_all("x", 
            PredicateFormula::exists("y",
                PredicateFormula::atom("P", vec![
                    Term::variable("x"),
                    Term::variable("y"),
                    Term::variable("z")
                ])
            )
        );
        
        let free_vars = formula.free_variables();
        assert_eq!(free_vars, vec!["z"]);
    }
}
```

### 5.3 å½’ç»“æ¨ç†å®ç°

```rust
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Clause {
    pub literals: HashSet<String>,
}

impl Clause {
    pub fn new() -> Self {
        Clause {
            literals: HashSet::new(),
        }
    }

    pub fn add_literal(&mut self, literal: &str) {
        self.literals.insert(literal.to_string());
    }

    pub fn remove_literal(&mut self, literal: &str) {
        self.literals.remove(literal);
    }

    pub fn is_empty(&self) -> bool {
        self.literals.is_empty()
    }

    pub fn contains(&self, literal: &str) -> bool {
        self.literals.contains(literal)
    }

    // å½’ç»“ä¸¤ä¸ªå­å¥
    pub fn resolve(&self, other: &Clause) -> Option<Clause> {
        for literal in &self.literals {
            let complement = if literal.starts_with('!') {
                &literal[1..]
            } else {
                format!("!{}", literal)
            };
            
            if other.contains(&complement) {
                let mut resolvent = Clause::new();
                
                // æ·»åŠ ç¬¬ä¸€ä¸ªå­å¥ä¸­é™¤literalå¤–çš„æ‰€æœ‰æ–‡å­—
                for lit in &self.literals {
                    if lit != literal {
                        resolvent.add_literal(lit);
                    }
                }
                
                // æ·»åŠ ç¬¬äºŒä¸ªå­å¥ä¸­é™¤complementå¤–çš„æ‰€æœ‰æ–‡å­—
                for lit in &other.literals {
                    if lit != &complement {
                        resolvent.add_literal(lit);
                    }
                }
                
                return Some(resolvent);
            }
        }
        None
    }
}

#[derive(Debug)]
pub struct ResolutionEngine {
    pub clauses: Vec<Clause>,
}

impl ResolutionEngine {
    pub fn new() -> Self {
        ResolutionEngine {
            clauses: Vec::new(),
        }
    }

    pub fn add_clause(&mut self, clause: Clause) {
        self.clauses.push(clause);
    }

    // å½’ç»“æ¨ç†ç®—æ³•
    pub fn resolve(&mut self) -> bool {
        let mut new_clauses = Vec::new();
        let mut resolved = false;
        
        for i in 0..self.clauses.len() {
            for j in (i + 1)..self.clauses.len() {
                if let Some(resolvent) = self.clauses[i].resolve(&self.clauses[j]) {
                    if resolvent.is_empty() {
                        return true; // æ‰¾åˆ°ç©ºå­å¥ï¼Œè¯æ˜æˆåŠŸ
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°å­å¥
                    if !self.clauses.contains(&resolvent) && !new_clauses.contains(&resolvent) {
                        new_clauses.push(resolvent);
                        resolved = true;
                    }
                }
            }
        }
        
        if resolved {
            self.clauses.extend(new_clauses);
            self.resolve() // é€’å½’ç»§ç»­å½’ç»“
        } else {
            false // æ— æ³•å½’ç»“å‡ºç©ºå­å¥
        }
    }

    // ä»å‘½é¢˜å…¬å¼æ„å»ºå­å¥é›†
    pub fn from_proposition(&mut self, prop: &Proposition) {
        let cnf = prop.to_cnf();
        for clause_literals in cnf {
            let mut clause = Clause::new();
            for literal in clause_literals {
                clause.add_literal(&literal);
            }
            self.add_clause(clause);
        }
    }

    // è¯æ˜å®šç†
    pub fn prove_theorem(&mut self, premises: &[Proposition], conclusion: &Proposition) -> bool {
        // æ¸…ç©ºç°æœ‰å­å¥
        self.clauses.clear();
        
        // æ·»åŠ å‰æ
        for premise in premises {
            self.from_proposition(premise);
        }
        
        // æ·»åŠ ç»“è®ºçš„å¦å®š
        let negated_conclusion = Proposition::not(conclusion.clone());
        self.from_proposition(&negated_conclusion);
        
        // æ‰§è¡Œå½’ç»“æ¨ç†
        self.resolve()
    }
}

#[cfg(test)]
mod resolution_tests {
    use super::*;

    #[test]
    fn test_clause_resolution() {
        let mut clause1 = Clause::new();
        clause1.add_literal("p");
        clause1.add_literal("!q");
        
        let mut clause2 = Clause::new();
        clause2.add_literal("!p");
        clause2.add_literal("r");
        
        let resolvent = clause1.resolve(&clause2);
        assert!(resolvent.is_some());
        
        let resolvent = resolvent.unwrap();
        assert!(resolvent.contains("!q"));
        assert!(resolvent.contains("r"));
    }

    #[test]
    fn test_resolution_proof() {
        let mut engine = ResolutionEngine::new();
        
        // å‰æï¼šp -> q, p
        let premise1 = Proposition::implies(
            Proposition::atom("p"),
            Proposition::atom("q")
        );
        let premise2 = Proposition::atom("p");
        
        // ç»“è®ºï¼šq
        let conclusion = Proposition::atom("q");
        
        // è¯æ˜å®šç†
        let proved = engine.prove_theorem(&[premise1, premise2], &conclusion);
        assert!(proved);
    }
}
```

## 6 . ç›¸å…³ç†è®ºä¸äº¤å‰å¼•ç”¨

### 1 ä¸æ•°å­¦åŸºç¡€çš„äº¤å‰

- **é›†åˆè®º**ï¼šæä¾›è®ºåŸŸå’Œå…³ç³»çš„ç†è®ºåŸºç¡€
- **ä»£æ•°**ï¼šæä¾›ä»£æ•°ç»“æ„å’Œè¿ç®—çš„ç†è®ºæ”¯æ’‘
- **å›¾è®º**ï¼šæä¾›æ¨ç†å›¾å’Œæ•°æ®ç»“æ„çš„æ”¯æŒ

### 6.2 ä¸è®¡ç®—æœºç§‘å­¦çš„äº¤å‰

- **ç®—æ³•ç†è®º**ï¼šæä¾›æ¨ç†ç®—æ³•çš„å¤æ‚åº¦åˆ†æ
- **æ•°æ®ç»“æ„**ï¼šæä¾›é«˜æ•ˆçš„æ•°æ®è¡¨ç¤ºæ–¹æ³•
- **è½¯ä»¶å·¥ç¨‹**ï¼šæä¾›ç³»ç»Ÿè®¾è®¡å’Œå®ç°æ–¹æ³•

### 6.3 ä¸å“²å­¦çš„äº¤å‰

- **é€»è¾‘å“²å­¦**ï¼šæä¾›é€»è¾‘æœ¬è´¨çš„å“²å­¦æ€è€ƒ
- **è®¤è¯†è®º**ï¼šæä¾›çŸ¥è¯†è·å–çš„ç†è®ºåŸºç¡€
- **è¯­è¨€å“²å­¦**ï¼šæä¾›ç¬¦å·å’Œæ„ä¹‰çš„ç†è®ºè§£é‡Š

## 7 . å‚è€ƒæ–‡çŒ®

### 1 ç»å…¸æ•™æ

- Enderton, H. B. (2001). A Mathematical Introduction to Logic (2nd ed.). Academic Press.
- Mendelson, E. (2015). Introduction to Mathematical Logic (6th ed.). CRC Press.
- Boolos, G. S., Burgess, J. P., & Jeffrey, R. C. (2007). Computability and Logic (5th ed.). Cambridge University Press.

### 7.2 é‡è¦è®ºæ–‡

- Robinson, J. A. (1965). A machine-oriented logic based on the resolution principle. Journal of the ACM, 12(1), 23-41.
- Kowalski, R. (1974). Predicate logic as programming language. IFIP Congress, 74, 569-574.
- Davis, M., & Putnam, H. (1960). A computing procedure for quantification theory. Journal of the ACM, 7(3), 201-215.

### 7.3 åœ¨çº¿èµ„æº

- Stanford Encyclopedia of Philosophy: <https://plato.stanford.edu/entries/logic-classical/>
- Wikipedia: <https://en.wikipedia.org/wiki/Logic>
- ProofWiki: <https://proofwiki.org/wiki/Main_Page>

## 8 æ‰¹åˆ¤æ€§åˆ†æ

### 1 ä¸»è¦ç†è®ºè§‚ç‚¹æ¢³ç†

**ç¬¦å·ä¸»ä¹‰è§‚ç‚¹**ï¼š

- å¼ºè°ƒç¬¦å·æ“ä½œå’Œå½¢å¼åŒ–æ¨ç†
- è®¤ä¸ºæ™ºèƒ½å¯ä»¥é€šè¿‡é€»è¾‘è§„åˆ™å®ç°
- é‡è§†çŸ¥è¯†çš„æ˜¾å¼è¡¨ç¤ºå’Œæ¨ç†

**è¿æ¥ä¸»ä¹‰è§‚ç‚¹**ï¼š

- å¼ºè°ƒç¥ç»ç½‘ç»œçš„å¹¶è¡Œå¤„ç†
- è®¤ä¸ºæ™ºèƒ½å¯ä»¥é€šè¿‡å­¦ä¹ å®ç°
- é‡è§†çŸ¥è¯†çš„éšå¼è¡¨ç¤ºå’Œæ¨¡å¼è¯†åˆ«

**è¡Œä¸ºä¸»ä¹‰è§‚ç‚¹**ï¼š

- å¼ºè°ƒä¸ç¯å¢ƒçš„äº¤äº’å’Œé€‚åº”
- è®¤ä¸ºæ™ºèƒ½å¯ä»¥é€šè¿‡å¼ºåŒ–å­¦ä¹ å®ç°
- é‡è§†è¡Œä¸ºçš„ä¼˜åŒ–å’Œç­–ç•¥å­¦ä¹ 

### 8.2 ä¸»æµè§‚ç‚¹çš„ä¼˜ç¼ºç‚¹åˆ†æ

**ä¼˜ç‚¹**ï¼š

- é€»è¾‘æ¨ç†å…·æœ‰ä¸¥æ ¼çš„å½¢å¼åŒ–åŸºç¡€
- æ¨ç†è¿‡ç¨‹å¯è§£é‡Šå’Œå¯éªŒè¯
- èƒ½å¤Ÿå¤„ç†å¤æ‚çš„ç¬¦å·æ¨ç†é—®é¢˜

**å±€é™æ€§**ï¼š

- è®¡ç®—å¤æ‚åº¦é«˜ï¼Œéš¾ä»¥å¤„ç†å¤§è§„æ¨¡é—®é¢˜
- å¯¹ä¸ç¡®å®šæ€§å’Œæ¨¡ç³Šæ€§å¤„ç†èƒ½åŠ›æœ‰é™
- çŸ¥è¯†è·å–å’Œè¡¨ç¤ºå­˜åœ¨ç“¶é¢ˆ

### 8.3 ä¸å…¶ä»–å­¦ç§‘çš„äº¤å‰ä¸èåˆ

**ä¸è®¤çŸ¥ç§‘å­¦çš„èåˆ**ï¼š

- ç ”ç©¶äººç±»æ¨ç†çš„è®¤çŸ¥æœºåˆ¶
- å¼€å‘æ›´ç¬¦åˆäººç±»æ€ç»´çš„æ¨ç†æ¨¡å‹
- æ¢ç´¢ç›´è§‰æ¨ç†å’Œé€»è¾‘æ¨ç†çš„ç»“åˆ

**ä¸æœºå™¨å­¦ä¹ çš„èåˆ**ï¼š

- ç»“åˆç»Ÿè®¡å­¦ä¹ å’Œé€»è¾‘æ¨ç†
- å¼€å‘ç¥ç»ç¬¦å·æ¨ç†ç³»ç»Ÿ
- æ¢ç´¢å¯è§£é‡Šçš„æœºå™¨å­¦ä¹ æ–¹æ³•

### 8.4 åˆ›æ–°æ€§æ‰¹åˆ¤ä¸æœªæ¥å±•æœ›

**åˆ›æ–°æ–¹å‘**ï¼š

- å‘å±•é‡å­é€»è¾‘æ¨ç†ç†è®º
- æ¢ç´¢æ¦‚ç‡é€»è¾‘å’Œæ¨¡ç³Šé€»è¾‘
- ç ”ç©¶å¤šæ¨¡æ€æ¨ç†å’Œè·¨åŸŸæ¨ç†

**æœªæ¥å±•æœ›**ï¼š

- æ„å»ºæ›´åŠ æ™ºèƒ½å’Œçµæ´»çš„æ¨ç†ç³»ç»Ÿ
- å®ç°é€»è¾‘æ¨ç†ä¸æœºå™¨å­¦ä¹ çš„æ·±åº¦èåˆ
- å‘å±•å¯è§£é‡Šå’Œå¯ä¿¡çš„AIæ¨ç†æ–¹æ³•
