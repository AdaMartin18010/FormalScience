# 18.2 ä¿¡é“å®¹é‡ç†è®º (Channel Capacity Theory)

**åˆ›å»ºæ—¶é—´**: 2025-01-17  
**æœ€åæ›´æ–°**: 2025-01-17  
**æ–‡æ¡£çŠ¶æ€**: æ´»è·ƒ  
**å…³è”æ¨¡å—**: `18_Information_Theory`

## ğŸ“ æ¦‚è¿°

ä¿¡é“å®¹é‡ç†è®ºæ˜¯ä¿¡æ¯è®ºçš„æ ¸å¿ƒï¼Œç ”ç©¶ä¿¡é“èƒ½å¤Ÿå¯é ä¼ è¾“çš„æœ€å¤§ä¿¡æ¯ç‡ã€‚æœ¬æ–‡æ¡£æ¶µç›–ç¦»æ•£æ— è®°å¿†ä¿¡é“ã€è¿ç»­ä¿¡é“ã€é¦™å†œå®šç†ã€ä¿¡é“ç¼–ç ç­‰æ ¸å¿ƒæ¦‚å¿µï¼Œä»¥åŠå®¹é‡è®¡ç®—å’Œæ€§èƒ½åˆ†æã€‚

## ğŸ”¬ ç†è®ºåŸºç¡€

### ä¿¡é“å®¹é‡å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 18.2.1** (ç¦»æ•£æ— è®°å¿†ä¿¡é“)
ç¦»æ•£æ— è®°å¿†ä¿¡é“(DMC)ç”±ä¸‰å…ƒç»„ $(\mathcal{X}, \mathcal{Y}, p(y|x))$ å®šä¹‰ï¼Œå…¶ä¸­ï¼š
- $\mathcal{X}$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\mathcal{Y}$ æ˜¯è¾“å‡ºå­—æ¯è¡¨
- $p(y|x)$ æ˜¯è½¬ç§»æ¦‚ç‡å‡½æ•°

**å®šä¹‰ 18.2.2** (ä¿¡é“å®¹é‡)
ä¿¡é“å®¹é‡å®šä¹‰ä¸ºï¼š
$C = \max_{p(x)} I(X; Y)$

å…¶ä¸­ $I(X; Y)$ æ˜¯è¾“å…¥ $X$ å’Œè¾“å‡º $Y$ ä¹‹é—´çš„äº’ä¿¡æ¯ã€‚

**å®šä¹‰ 18.2.3** (ä¿¡é“ç¼–ç )
ä¿¡é“ç¼–ç æ˜¯æ˜ å°„ $f: \mathcal{M} \rightarrow \mathcal{X}^n$ï¼Œå…¶ä¸­ $\mathcal{M}$ æ˜¯æ¶ˆæ¯é›†åˆã€‚

**å®šä¹‰ 18.2.4** (ä¿¡é“è§£ç )
ä¿¡é“è§£ç æ˜¯æ˜ å°„ $g: \mathcal{Y}^n \rightarrow \mathcal{M} \cup \{\text{error}\}$ã€‚

### é¦™å†œä¿¡é“ç¼–ç å®šç†

**å®šç† 18.2.1** (é¦™å†œä¿¡é“ç¼–ç å®šç†)
å¯¹äºç¦»æ•£æ— è®°å¿†ä¿¡é“ï¼Œå­˜åœ¨ç¼–ç æ–¹æ¡ˆä½¿å¾—ï¼š
1. é”™è¯¯æ¦‚ç‡ $P_e \rightarrow 0$ å½“ $n \rightarrow \infty$
2. ä¿¡æ¯ç‡ $R < C$

å…¶ä¸­ $C$ æ˜¯ä¿¡é“å®¹é‡ã€‚

**å®šç† 18.2.2** (ä¿¡é“å®¹é‡é€†å®šç†)
å¦‚æœä¿¡æ¯ç‡ $R > C$ï¼Œåˆ™ä»»æ„ç¼–ç æ–¹æ¡ˆçš„é”™è¯¯æ¦‚ç‡éƒ½æœ‰æ­£çš„ä¸‹ç•Œã€‚

### å¸¸è§ä¿¡é“æ¨¡å‹

**å®šä¹‰ 18.2.5** (äºŒå…ƒå¯¹ç§°ä¿¡é“)
äºŒå…ƒå¯¹ç§°ä¿¡é“(BSC)çš„è½¬ç§»æ¦‚ç‡ï¼š
$p(0|0) = p(1|1) = 1-p$
$p(0|1) = p(1|0) = p$

å…¶ä¸­ $p$ æ˜¯äº¤å‰æ¦‚ç‡ã€‚

**å®šä¹‰ 18.2.6** (äºŒå…ƒæ“¦é™¤ä¿¡é“)
äºŒå…ƒæ“¦é™¤ä¿¡é“(BEC)çš„è½¬ç§»æ¦‚ç‡ï¼š
$p(0|0) = p(1|1) = 1-\epsilon$
$p(e|0) = p(e|1) = \epsilon$

å…¶ä¸­ $\epsilon$ æ˜¯æ“¦é™¤æ¦‚ç‡ï¼Œ$e$ è¡¨ç¤ºæ“¦é™¤ç¬¦å·ã€‚

**å®šä¹‰ 18.2.7** (åŠ æ€§é«˜æ–¯ç™½å™ªå£°ä¿¡é“)
åŠ æ€§é«˜æ–¯ç™½å™ªå£°ä¿¡é“(AWGN)çš„è¾“å‡ºï¼š
$Y = X + N$

å…¶ä¸­ $N \sim \mathcal{N}(0, \sigma^2)$ æ˜¯é«˜æ–¯å™ªå£°ã€‚

## ğŸ—ï¸ ä¿¡é“å®¹é‡è®¡ç®—å®ç°

### Python ä¿¡é“å®¹é‡æ¡†æ¶

```python
import numpy as np
import pandas as pd
from scipy.optimize import minimize
from scipy.stats import norm
import matplotlib.pyplot as plt

class ChannelCapacity:
    """ä¿¡é“å®¹é‡è®¡ç®—æ¡†æ¶"""
    
    def __init__(self):
        self.epsilon = 1e-10
    
    def calculate_bsc_capacity(self, p):
        """è®¡ç®—äºŒå…ƒå¯¹ç§°ä¿¡é“å®¹é‡"""
        if p <= 0 or p >= 0.5:
            return 0
        
        # BSCå®¹é‡å…¬å¼: C = 1 - H(p)
        entropy = -p * np.log2(p) - (1-p) * np.log2(1-p)
        capacity = 1 - entropy
        return capacity
    
    def calculate_bec_capacity(self, epsilon):
        """è®¡ç®—äºŒå…ƒæ“¦é™¤ä¿¡é“å®¹é‡"""
        if epsilon <= 0 or epsilon >= 1:
            return 1
        
        # BECå®¹é‡å…¬å¼: C = 1 - Îµ
        capacity = 1 - epsilon
        return capacity
    
    def calculate_awgn_capacity(self, snr, bandwidth=1):
        """è®¡ç®—AWGNä¿¡é“å®¹é‡"""
        # AWGNå®¹é‡å…¬å¼: C = B * log2(1 + SNR)
        capacity = bandwidth * np.log2(1 + snr)
        return capacity
    
    def calculate_dmc_capacity(self, transition_matrix, max_iter=1000):
        """è®¡ç®—ç¦»æ•£æ— è®°å¿†ä¿¡é“å®¹é‡"""
        # ä½¿ç”¨Blahut-Arimotoç®—æ³•
        n_inputs, n_outputs = transition_matrix.shape
        
        # åˆå§‹åŒ–è¾“å…¥åˆ†å¸ƒ
        p_x = np.ones(n_inputs) / n_inputs
        
        for _ in range(max_iter):
            # è®¡ç®—è¾“å‡ºåˆ†å¸ƒ
            p_y = np.sum(transition_matrix * p_x[:, np.newaxis], axis=0)
            
            # è®¡ç®—åéªŒæ¦‚ç‡
            p_x_given_y = (transition_matrix * p_x[:, np.newaxis]) / (p_y + self.epsilon)
            
            # æ›´æ–°è¾“å…¥åˆ†å¸ƒ
            p_x_new = np.exp(np.sum(p_x_given_y * np.log(p_x_given_y + self.epsilon), axis=1))
            p_x_new = p_x_new / np.sum(p_x_new)
            
            # æ£€æŸ¥æ”¶æ•›
            if np.max(np.abs(p_x_new - p_x)) < 1e-6:
                break
            
            p_x = p_x_new
        
        # è®¡ç®—å®¹é‡
        capacity = 0
        for i in range(n_inputs):
            for j in range(n_outputs):
                if transition_matrix[i, j] > 0 and p_x[i] > 0:
                    capacity += p_x[i] * transition_matrix[i, j] * np.log2(
                        transition_matrix[i, j] / (p_y[j] + self.epsilon)
                    )
        
        return capacity, p_x

class ChannelCoding:
    """ä¿¡é“ç¼–ç å®ç°"""
    
    def __init__(self):
        self.codes = {}
    
    def repetition_code(self, message, n):
        """é‡å¤ç """
        return [message] * n
    
    def parity_check_code(self, message):
        """å¥‡å¶æ ¡éªŒç """
        parity = sum(message) % 2
        return message + [parity]
    
    def hamming_code_encode(self, message):
        """æ±‰æ˜ç ç¼–ç """
        # ç®€åŒ–çš„(7,4)æ±‰æ˜ç 
        if len(message) != 4:
            raise ValueError("Message must be 4 bits")
        
        # è®¡ç®—æ ¡éªŒä½
        p1 = message[0] ^ message[1] ^ message[3]
        p2 = message[0] ^ message[2] ^ message[3]
        p3 = message[1] ^ message[2] ^ message[3]
        
        return [p1, p2, message[0], p3, message[1], message[2], message[3]]
    
    def hamming_code_decode(self, received):
        """æ±‰æ˜ç è§£ç """
        if len(received) != 7:
            raise ValueError("Received message must be 7 bits")
        
        # è®¡ç®—æ ¡éªŒå­
        s1 = received[0] ^ received[2] ^ received[4] ^ received[6]
        s2 = received[1] ^ received[2] ^ received[5] ^ received[6]
        s3 = received[3] ^ received[4] ^ received[5] ^ received[6]
        
        # é”™è¯¯ä½ç½®
        error_pos = s1 + 2*s2 + 4*s3
        
        if error_pos > 0:
            # çº æ­£é”™è¯¯
            received[error_pos - 1] ^= 1
        
        # æå–åŸå§‹æ¶ˆæ¯
        return [received[2], received[4], received[5], received[6]]
    
    def simulate_channel(self, codeword, channel_type, **params):
        """æ¨¡æ‹Ÿä¿¡é“ä¼ è¾“"""
        if channel_type == 'bsc':
            p = params.get('p', 0.1)
            received = []
            for bit in codeword:
                if np.random.random() < p:
                    received.append(1 - bit)
                else:
                    received.append(bit)
            return received
        
        elif channel_type == 'bec':
            epsilon = params.get('epsilon', 0.1)
            received = []
            for bit in codeword:
                if np.random.random() < epsilon:
                    received.append('e')  # æ“¦é™¤
                else:
                    received.append(bit)
            return received
        
        elif channel_type == 'awgn':
            snr_db = params.get('snr_db', 10)
            snr_linear = 10**(snr_db/10)
            noise_power = 1 / snr_linear
            
            # BPSKè°ƒåˆ¶
            modulated = [1 if bit == 1 else -1 for bit in codeword]
            
            # æ·»åŠ å™ªå£°
            noise = np.random.normal(0, np.sqrt(noise_power), len(modulated))
            received_signal = np.array(modulated) + noise
            
            # ç¡¬åˆ¤å†³
            received = [1 if signal > 0 else 0 for signal in received_signal]
            return received
        
        else:
            raise ValueError(f"Unknown channel type: {channel_type}")

class ChannelPerformanceAnalysis:
    """ä¿¡é“æ€§èƒ½åˆ†æ"""
    
    def __init__(self):
        self.capacity_calculator = ChannelCapacity()
        self.coding = ChannelCoding()
    
    def calculate_ber(self, original, received):
        """è®¡ç®—è¯¯æ¯”ç‰¹ç‡"""
        if len(original) != len(received):
            raise ValueError("Lengths must match")
        
        errors = sum(1 for a, b in zip(original, received) if a != b)
        ber = errors / len(original)
        return ber
    
    def calculate_fer(self, original_codewords, received_codewords):
        """è®¡ç®—è¯¯å¸§ç‡"""
        if len(original_codewords) != len(received_codewords):
            raise ValueError("Lengths must match")
        
        frame_errors = sum(1 for orig, rec in zip(original_codewords, received_codewords) 
                          if orig != rec)
        fer = frame_errors / len(original_codewords)
        return fer
    
    def simulate_channel_performance(self, code_type, channel_type, 
                                   message_length=1000, **params):
        """æ¨¡æ‹Ÿä¿¡é“æ€§èƒ½"""
        # ç”Ÿæˆéšæœºæ¶ˆæ¯
        messages = np.random.randint(0, 2, (message_length, 4))
        
        # ç¼–ç 
        if code_type == 'hamming':
            codewords = [self.coding.hamming_code_encode(msg) for msg in messages]
        elif code_type == 'repetition':
            codewords = [self.coding.repetition_code(msg, 3) for msg in messages]
        else:
            raise ValueError(f"Unknown code type: {code_type}")
        
        # é€šè¿‡ä¿¡é“ä¼ è¾“
        received_codewords = []
        for codeword in codewords:
            received = self.coding.simulate_channel(codeword, channel_type, **params)
            received_codewords.append(received)
        
        # è§£ç 
        decoded_messages = []
        for received in received_codewords:
            if code_type == 'hamming':
                try:
                    decoded = self.coding.hamming_code_decode(received)
                    decoded_messages.append(decoded)
                except:
                    decoded_messages.append([0, 0, 0, 0])  # è§£ç å¤±è´¥
            elif code_type == 'repetition':
                # å¤šæ•°åˆ¤å†³
                decoded = []
                for i in range(4):
                    bits = [received[j] for j in range(i, len(received), 4)]
                    decoded.append(1 if sum(bits) > len(bits)/2 else 0)
                decoded_messages.append(decoded)
        
        # è®¡ç®—æ€§èƒ½æŒ‡æ ‡
        ber = self.calculate_ber(np.array(messages).flatten(), 
                               np.array(decoded_messages).flatten())
        fer = self.calculate_fer(messages, decoded_messages)
        
        return {
            'ber': ber,
            'fer': fer,
            'code_rate': 4 / len(codewords[0]) if code_type == 'hamming' else 1/3,
            'channel_type': channel_type,
            'code_type': code_type
        }
    
    def plot_performance_comparison(self, channel_type, snr_range=None, p_range=None):
        """ç»˜åˆ¶æ€§èƒ½æ¯”è¾ƒå›¾"""
        if channel_type == 'awgn' and snr_range is not None:
            capacities = []
            bers = []
            
            for snr_db in snr_range:
                # è®¡ç®—å®¹é‡
                capacity = self.capacity_calculator.calculate_awgn_capacity(10**(snr_db/10))
                capacities.append(capacity)
                
                # æ¨¡æ‹Ÿæ€§èƒ½
                performance = self.simulate_channel_performance(
                    'hamming', 'awgn', snr_db=snr_db
                )
                bers.append(performance['ber'])
            
            plt.figure(figsize=(10, 6))
            plt.subplot(1, 2, 1)
            plt.plot(snr_range, capacities)
            plt.xlabel('SNR (dB)')
            plt.ylabel('Capacity (bits/symbol)')
            plt.title('AWGN Channel Capacity')
            plt.grid(True)
            
            plt.subplot(1, 2, 2)
            plt.semilogy(snr_range, bers)
            plt.xlabel('SNR (dB)')
            plt.ylabel('Bit Error Rate')
            plt.title('Hamming Code Performance')
            plt.grid(True)
            plt.tight_layout()
            plt.show()
        
        elif channel_type == 'bsc' and p_range is not None:
            capacities = []
            bers = []
            
            for p in p_range:
                # è®¡ç®—å®¹é‡
                capacity = self.capacity_calculator.calculate_bsc_capacity(p)
                capacities.append(capacity)
                
                # æ¨¡æ‹Ÿæ€§èƒ½
                performance = self.simulate_channel_performance(
                    'hamming', 'bsc', p=p
                )
                bers.append(performance['ber'])
            
            plt.figure(figsize=(10, 6))
            plt.subplot(1, 2, 1)
            plt.plot(p_range, capacities)
            plt.xlabel('Crossover Probability p')
            plt.ylabel('Capacity (bits/symbol)')
            plt.title('BSC Channel Capacity')
            plt.grid(True)
            
            plt.subplot(1, 2, 2)
            plt.semilogy(p_range, bers)
            plt.xlabel('Crossover Probability p')
            plt.ylabel('Bit Error Rate')
            plt.title('Hamming Code Performance')
            plt.grid(True)
            plt.tight_layout()
            plt.show()

# ä½¿ç”¨ç¤ºä¾‹
def channel_capacity_examples():
    """ä¿¡é“å®¹é‡è®¡ç®—ç¤ºä¾‹"""
    cc = ChannelCapacity()
    
    # ç¤ºä¾‹1: BSCå®¹é‡
    p_values = np.linspace(0, 0.5, 100)
    bsc_capacities = [cc.calculate_bsc_capacity(p) for p in p_values]
    
    plt.figure(figsize=(8, 6))
    plt.plot(p_values, bsc_capacities)
    plt.xlabel('Crossover Probability p')
    plt.ylabel('Capacity (bits/symbol)')
    plt.title('Binary Symmetric Channel Capacity')
    plt.grid(True)
    plt.show()
    
    # ç¤ºä¾‹2: BECå®¹é‡
    epsilon_values = np.linspace(0, 1, 100)
    bec_capacities = [cc.calculate_bec_capacity(eps) for eps in epsilon_values]
    
    plt.figure(figsize=(8, 6))
    plt.plot(epsilon_values, bec_capacities)
    plt.xlabel('Erasure Probability Îµ')
    plt.ylabel('Capacity (bits/symbol)')
    plt.title('Binary Erasure Channel Capacity')
    plt.grid(True)
    plt.show()
    
    # ç¤ºä¾‹3: AWGNå®¹é‡
    snr_db = np.linspace(-10, 20, 100)
    snr_linear = 10**(snr_db/10)
    awgn_capacities = [cc.calculate_awgn_capacity(snr) for snr in snr_linear]
    
    plt.figure(figsize=(8, 6))
    plt.plot(snr_db, awgn_capacities)
    plt.xlabel('SNR (dB)')
    plt.ylabel('Capacity (bits/symbol)')
    plt.title('AWGN Channel Capacity')
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    channel_capacity_examples()
```

## ğŸ“Š æ€§èƒ½åˆ†æå’Œè¯„ä¼°

### ä¿¡é“ç¼–ç æ€§èƒ½åˆ†æ

```python
class ChannelCodingAnalysis:
    """ä¿¡é“ç¼–ç åˆ†æ"""
    
    def __init__(self):
        self.performance_analyzer = ChannelPerformanceAnalysis()
    
    def analyze_code_performance(self, code_types, channel_type, **params):
        """åˆ†æä¸åŒç¼–ç çš„æ€§èƒ½"""
        results = {}
        
        for code_type in code_types:
            performance = self.performance_analyzer.simulate_channel_performance(
                code_type, channel_type, **params
            )
            results[code_type] = performance
        
        return results
    
    def capacity_versus_rate_analysis(self, channel_type, **params):
        """å®¹é‡ä¸ç ç‡åˆ†æ"""
        if channel_type == 'bsc':
            p = params.get('p', 0.1)
            capacity = self.performance_analyzer.capacity_calculator.calculate_bsc_capacity(p)
        elif channel_type == 'awgn':
            snr_db = params.get('snr_db', 10)
            snr_linear = 10**(snr_db/10)
            capacity = self.performance_analyzer.capacity_calculator.calculate_awgn_capacity(snr_linear)
        else:
            raise ValueError(f"Unsupported channel type: {channel_type}")
        
        # æµ‹è¯•ä¸åŒç ç‡
        code_rates = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]
        performances = []
        
        for rate in code_rates:
            if rate <= capacity:
                # æ¨¡æ‹Ÿæ€§èƒ½ï¼ˆç®€åŒ–ï¼‰
                performance = self.performance_analyzer.simulate_channel_performance(
                    'hamming', channel_type, **params
                )
                performance['code_rate'] = rate
                performances.append(performance)
        
        return {
            'capacity': capacity,
            'performances': performances,
            'channel_type': channel_type
        }
```

## ğŸ”— ä¸æ¨¡å—å†…ä¸»é¢˜çš„å…³ç³»

- **18.1 ä¿¡æ¯ç†µç†è®º**: ç†µä¸ä¿¡é“å®¹é‡çš„å…³ç³»
- **18.3 ç¼–ç ç†è®º**: ä¿¡é“ç¼–ç å’Œçº é”™ç 
- **18.4 æ•°æ®å‹ç¼©ç†è®º**: ä¿¡æºç¼–ç ä¸ä¿¡é“ç¼–ç çš„å…³ç³»
- **18.5 é”™è¯¯çº æ­£ç†è®º**: çº é”™ç çš„è®¾è®¡å’Œåˆ†æ

## ğŸ§­ æ‰¹åˆ¤æ€§åˆ†æ

### å“²å­¦ç»´åº¦
- **ä¿¡æ¯å“²å­¦**: ä¿¡é“å®¹é‡ä½“ç°äº†"ä¿¡æ¯ä¼ è¾“æé™"çš„å“²å­¦è§‚ç‚¹
- **è®¤è¯†è®ºåŸºç¡€**: é¦™å†œå®šç†åæ˜ äº†äººç±»å¯¹é€šä¿¡æé™çš„è®¤çŸ¥
- **æœ¬ä½“è®ºåæ€**: ä¿¡é“ä½œä¸ºæŠ½è±¡å®ä½“ï¼Œå…¶å­˜åœ¨å½¢å¼ä»‹äºæ•°å­¦æ¨¡å‹å’Œç‰©ç†ç°å®ä¹‹é—´

### æ–¹æ³•è®ºç»´åº¦
- **å®¹é‡è®¡ç®—**: ä¸åŒä¿¡é“æ¨¡å‹çš„å®¹é‡è®¡ç®—æ–¹æ³•æ¯”è¾ƒ
- **ç¼–ç è®¾è®¡**: æ¥è¿‘å®¹é‡é™çš„ç¼–ç è®¾è®¡æ–¹æ³•
- **æ€§èƒ½è¯„ä¼°**: ç†è®ºå®¹é‡ä¸å®é™…æ€§èƒ½çš„å·®è·åˆ†æ

### å·¥ç¨‹ç»´åº¦
- **å®ç°å¤æ‚åº¦**: æ¥è¿‘å®¹é‡é™çš„ç¼–ç å®ç°å¤æ‚åº¦
- **å»¶è¿Ÿå½±å“**: ç¼–ç å»¶è¿Ÿå¯¹å®é™…åº”ç”¨çš„å½±å“
- **ç¡¬ä»¶çº¦æŸ**: ç¡¬ä»¶å®ç°å¯¹ç¼–ç æ€§èƒ½çš„é™åˆ¶

### ç¤¾ä¼šæŠ€æœ¯ç»´åº¦
- **é€šä¿¡å…¬å¹³**: ä¿¡é“å®¹é‡å¯¹é€šä¿¡å…¬å¹³æ€§çš„å½±å“
- **éšç§ä¿æŠ¤**: ä¿¡é“ç¼–ç å¯¹ä¿¡æ¯éšç§çš„ä¿æŠ¤
- **æŠ€æœ¯æ°‘ä¸»**: ä¿¡é“å®¹é‡ç†è®ºçš„æŠ€æœ¯æ°‘ä¸»åŒ–

## ğŸ“š å‚è§

- [18.1 ä¿¡æ¯ç†µç†è®º](./18.1_Information_Entropy_Theory.md)
- [18.3 ç¼–ç ç†è®º](./18.3_Coding_Theory.md)
- [ç»Ÿä¸€æœ¯è¯­è¡¨](../../04_Type_Theory/TERMINOLOGY_TABLE.md)

## ğŸ“– å‚è€ƒæ–‡çŒ®

1. Shannon, C. E. (1948). A mathematical theory of communication. *Bell System Technical Journal*, 27(3), 379-423.
2. Cover, T. M., & Thomas, J. A. (2006). *Elements of Information Theory*. Wiley.
3. Gallager, R. G. (1968). *Information Theory and Reliable Communication*. Wiley.
4. Proakis, J. G. (2001). *Digital Communications*. McGraw-Hill.
5. Lin, S., & Costello, D. J. (2004). *Error Control Coding*. Pearson. 