# 01. 控制论基础 (Control Theory Foundation)

## 目录

1. [概述](#1-概述)
2. [形式化定义](#2-形式化定义)
3. [核心定理与证明](#3-核心定理与证明)
4. [系统分析](#4-系统分析)
5. [控制器设计](#5-控制器设计)
6. [应用实例](#6-应用实例)
7. [与其他理论的关联](#7-与其他理论的关联)
8. [参考文献](#8-参考文献)

## 1. 概述

### 1.1 理论基础

控制论是研究动态系统行为控制和调节的科学，为工程系统、生物系统和社会系统提供了统一的理论框架。控制论基于数学建模、系统分析和反馈控制，构建了严格的形式化理论体系。

### 1.2 核心概念

- **系统**：具有输入、输出和内部状态的动态对象
- **控制**：通过输入调节系统行为的过程
- **反馈**：将输出信息返回给输入的控制机制
- **稳定性**：系统在扰动下的行为特性
- **性能**：系统响应的质量指标

### 1.3 历史发展

- **1948年**：Wiener发表《控制论》
- **1950年代**：经典控制理论发展
- **1960年代**：现代控制理论兴起
- **1970年代**：鲁棒控制理论发展
- **1980年代**：自适应控制理论成熟
- **1990年代**：非线性控制理论发展

## 2. 形式化定义

### 2.1 系统模型

**定义 2.1.1 (动态系统)**
动态系统是一个五元组 $\mathcal{S} = (X, U, Y, f, h)$，其中：

- $X \subseteq \mathbb{R}^n$ 是状态空间
- $U \subseteq \mathbb{R}^m$ 是输入空间
- $Y \subseteq \mathbb{R}^p$ 是输出空间
- $f : X \times U \times \mathbb{R} \rightarrow X$ 是状态转移函数
- $h : X \times U \times \mathbb{R} \rightarrow Y$ 是输出函数

**定义 2.1.2 (线性时不变系统)**
线性时不变(LTI)系统满足：

$$\dot{x}(t) = Ax(t) + Bu(t)$$
$$y(t) = Cx(t) + Du(t)$$

其中：
- $A \in \mathbb{R}^{n \times n}$ 是系统矩阵
- $B \in \mathbb{R}^{n \times m}$ 是输入矩阵
- $C \in \mathbb{R}^{p \times n}$ 是输出矩阵
- $D \in \mathbb{R}^{p \times m}$ 是直接传递矩阵

### 2.2 控制问题

**定义 2.1.3 (控制问题)**
控制问题是寻找控制律 $u(t) = g(x(t), t)$ 使得系统满足性能要求。

**定义 2.1.4 (状态反馈控制)**
状态反馈控制律为：

$$u(t) = -Kx(t) + r(t)$$

其中：
- $K \in \mathbb{R}^{m \times n}$ 是反馈增益矩阵
- $r(t)$ 是参考输入

### 2.3 系统特性

**定义 2.1.5 (可控性)**
系统 $(A, B)$ 是可控的，如果可控性矩阵 $W_c = [B \ AB \ A^2B \ \cdots \ A^{n-1}B]$ 满秩。

**定义 2.1.6 (可观性)**
系统 $(A, C)$ 是可观的，如果可观性矩阵 $W_o = [C^T \ A^TC^T \ (A^2)^TC^T \ \cdots \ (A^{n-1})^TC^T]^T$ 满秩。

## 3. 核心定理与证明

### 3.1 可控性判据

**定理 3.1.1 (可控性判据)**
系统 $(A, B)$ 可控当且仅当可控性矩阵 $W_c$ 满秩。

**证明：** 通过构造性证明。

**必要性：** 假设系统可控但 $W_c$ 不满秩，则存在非零向量 $v$ 使得 $v^TW_c = 0$。

1. 由可控性定义：存在控制输入 $u(t)$ 使得 $x(T) = 0$
2. 状态解：$x(T) = e^{AT}x(0) + \int_0^T e^{A(T-\tau)}Bu(\tau)d\tau = 0$
3. 由 $v^TW_c = 0$：$v^Te^{At}B = 0$ 对所有 $t \geq 0$
4. 矛盾：$v^Tx(T) = v^Te^{AT}x(0) \neq 0$

**充分性：** 假设 $W_c$ 满秩，构造控制输入。

### 3.2 稳定性定理

**定理 3.1.2 (李雅普诺夫稳定性)**
如果存在正定函数 $V(x)$ 使得 $\dot{V}(x) \leq 0$，则系统在原点稳定。

**证明：** 通过李雅普诺夫方法。

**定义 3.1.1 (李雅普诺夫函数)**
函数 $V : \mathbb{R}^n \rightarrow \mathbb{R}$ 是李雅普诺夫函数，如果：

1. $V(0) = 0$
2. $V(x) > 0$ 对所有 $x \neq 0$
3. $\dot{V}(x) \leq 0$ 对所有 $x$

**证明步骤：**

1. **正定性**：$V(x) > 0$ 保证能量函数正定
2. **递减性**：$\dot{V}(x) \leq 0$ 保证能量不增加
3. **稳定性**：系统轨迹不会远离原点

### 3.3 极点配置定理

**定理 3.1.3 (极点配置)**
如果系统 $(A, B)$ 可控，则可以通过状态反馈 $u = -Kx$ 任意配置闭环极点。

**证明：** 通过阿克曼公式。

**阿克曼公式：**
$$K = [0 \ 0 \ \cdots \ 0 \ 1]W_c^{-1}\alpha(A)$$

其中 $\alpha(s)$ 是期望的特征多项式。

## 4. 系统分析

### 4.1 时域分析

**定义 4.1.1 (时域性能指标)**
- **上升时间** $t_r$：响应从10%到90%的时间
- **峰值时间** $t_p$：达到最大超调的时间
- **超调量** $M_p$：最大超调百分比
- **调节时间** $t_s$：进入±5%误差带的时间

**定义 4.1.2 (稳态误差)**
稳态误差定义为：

$$e_{ss} = \lim_{t \rightarrow \infty} e(t) = \lim_{s \rightarrow 0} sE(s)$$

### 4.2 频域分析

**定义 4.1.3 (传递函数)**
传递函数定义为：

$$G(s) = \frac{Y(s)}{U(s)} = C(sI - A)^{-1}B + D$$

**定义 4.1.4 (频率响应)**
频率响应为：

$$G(j\omega) = C(j\omega I - A)^{-1}B + D$$

**奈奎斯特判据：**
系统稳定的充分必要条件是奈奎斯特图不包围点 $(-1, 0)$。

## 5. 控制器设计

### 5.1 PID控制器

**定义 5.1.1 (PID控制器)**
PID控制器传递函数为：

$$G_c(s) = K_p + \frac{K_i}{s} + K_ds$$

其中：
- $K_p$ 是比例增益
- $K_i$ 是积分增益
- $K_d$ 是微分增益

**设计方法：**
1. **齐格勒-尼科尔斯方法**
2. **内模控制方法**
3. **最优控制方法**

### 5.2 状态反馈设计

**定义 5.1.2 (线性二次型调节器)**
LQR问题最小化性能指标：

$$J = \int_0^{\infty} (x^TQx + u^TRu)dt$$

最优控制律为：

$$u = -R^{-1}B^TPx$$

其中 $P$ 满足代数黎卡提方程：

$$A^TP + PA - PBR^{-1}B^TP + Q = 0$$

## 6. 应用实例

### 6.1 倒立摆控制

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

# 倒立摆系统参数
M = 0.5  # 小车质量
m = 0.2  # 摆质量
b = 0.1  # 摩擦系数
I = 0.006  # 转动惯量
g = 9.8  # 重力加速度
l = 0.3  # 摆长

# 系统矩阵
A = np.array([[0, 1, 0, 0],
              [0, -b/M, -m*g/M, 0],
              [0, 0, 0, 1],
              [0, b/(M*l), (M+m)*g/(M*l), 0]])

B = np.array([[0],
              [1/M],
              [0],
              [-1/(M*l)]])

# LQR设计
Q = np.diag([1, 1, 10, 10])
R = np.array([[0.1]])

# 求解黎卡提方程
P = solve_riccati(A, B, Q, R)
K = np.linalg.inv(R) @ B.T @ P

# 闭环系统
A_cl = A - B @ K

# 仿真
def system_dynamics(x, t):
    return A_cl @ x

t = np.linspace(0, 10, 1000)
x0 = np.array([0, 0, 0.1, 0])  # 初始角度偏移
x = odeint(system_dynamics, x0, t)

# 绘制结果
plt.figure(figsize=(12, 8))
plt.subplot(2, 2, 1)
plt.plot(t, x[:, 0])
plt.title('小车位置')
plt.xlabel('时间 (s)')
plt.ylabel('位置 (m)')

plt.subplot(2, 2, 2)
plt.plot(t, x[:, 1])
plt.title('小车速度')
plt.xlabel('时间 (s)')
plt.ylabel('速度 (m/s)')

plt.subplot(2, 2, 3)
plt.plot(t, x[:, 2])
plt.title('摆角度')
plt.xlabel('时间 (s)')
plt.ylabel('角度 (rad)')

plt.subplot(2, 2, 4)
plt.plot(t, x[:, 3])
plt.title('摆角速度')
plt.xlabel('时间 (s)')
plt.ylabel('角速度 (rad/s)')

plt.tight_layout()
plt.show()
```

### 6.2 飞行器控制

```python
# 飞行器纵向动力学模型
class AircraftModel:
    def __init__(self):
        # 飞行器参数
        self.m = 1000  # 质量 (kg)
        self.Iyy = 1000  # 俯仰转动惯量
        self.S = 20  # 机翼面积
        self.c = 2  # 平均气动弦长
        self.rho = 1.225  # 空气密度
        
        # 气动导数
        self.CL_alpha = 5.0
        self.CD_0 = 0.02
        self.Cm_alpha = -0.5
        self.Cm_delta = -1.0
        
    def dynamics(self, x, u, t):
        # 状态：速度、攻角、俯仰角、俯仰角速度
        V, alpha, theta, q = x
        # 控制：升降舵偏角
        delta_e = u[0]
        
        # 空气动力
        q_dyn = 0.5 * self.rho * V**2 * self.S
        L = q_dyn * self.CL_alpha * alpha
        D = q_dyn * self.CD_0
        M = q_dyn * self.c * (self.Cm_alpha * alpha + self.Cm_delta * delta_e)
        
        # 动力学方程
        V_dot = (-D - self.m * 9.8 * np.sin(theta - alpha)) / self.m
        alpha_dot = q - (L - self.m * 9.8 * np.cos(theta - alpha)) / (self.m * V)
        theta_dot = q
        q_dot = M / self.Iyy
        
        return np.array([V_dot, alpha_dot, theta_dot, q_dot])

# 控制器设计
def design_controller(aircraft):
    # 线性化模型
    V0 = 50  # 平衡速度
    alpha0 = 0.1  # 平衡攻角
    theta0 = alpha0  # 平衡俯仰角
    q0 = 0  # 平衡角速度
    
    # 状态空间模型
    A = np.array([[0, -9.8, -9.8, 0],
                  [0, -0.5, 0, 1],
                  [0, 0, 0, 1],
                  [0, -0.1, 0, 0]])
    
    B = np.array([[0],
                  [0],
                  [0],
                  [-0.1]])
    
    # LQR设计
    Q = np.diag([1, 10, 1, 1])
    R = np.array([[1]])
    
    P = solve_riccati(A, B, Q, R)
    K = np.linalg.inv(R) @ B.T @ P
    
    return K
```

## 7. 与其他理论的关联

### 7.1 与类型理论的关联

**定理 7.1.1 (控制-类型对应)**
控制系统与类型系统存在对应关系：

```haskell
-- 系统状态对应类型
data SystemState = SystemState {
  position :: Double,
  velocity :: Double,
  angle :: Double,
  angularVelocity :: Double
}

-- 控制律对应类型转换
type ControlLaw = SystemState -> ControlInput

-- 系统动力学对应类型规则
data SystemDynamics = SystemDynamics {
  stateTransition :: SystemState -> ControlInput -> SystemState,
  outputFunction :: SystemState -> Output
}

-- 稳定性对应类型安全
checkStability :: SystemDynamics -> Bool
checkStability dynamics = 
  let lyapunov = constructLyapunovFunction dynamics
  in isPositiveDefinite lyapunov && isDecreasing lyapunov
```

### 7.2 与逻辑理论的关联

**定理 7.1.2 (控制-逻辑对应)**
控制理论与时态逻辑存在对应关系：

| 控制概念 | 时态逻辑 |
|----------|----------|
| 稳定性 | $\Box \phi$ (总是满足) |
| 可达性 | $\Diamond \phi$ (最终满足) |
| 安全性 | $\Box \neg \phi$ (永不满足) |
| 活性 | $\Diamond \Box \phi$ (最终总是满足) |

## 8. 参考文献

1. **Wiener, N.** (1948). *Cybernetics: Or Control and Communication in the Animal and the Machine*. MIT Press.

2. **Ogata, K.** (2010). *Modern Control Engineering*. Prentice Hall.

3. **Franklin, G. F., Powell, J. D., & Emami-Naeini, A.** (2015). *Feedback Control of Dynamic Systems*. Pearson.

4. **Doyle, J. C., Francis, B. A., & Tannenbaum, A. R.** (2013). *Feedback Control Theory*. Dover Publications.

5. **Khalil, H. K.** (2015). *Nonlinear Systems*. Prentice Hall.

6. **Åström, K. J., & Murray, R. M.** (2008). *Feedback Systems: An Introduction for Scientists and Engineers*. Princeton University Press.

---

**关键词**: 控制论、系统理论、稳定性、可控性、可观性、李雅普诺夫方法

**分类**: 01-形式理论基础体系 / 02-系统理论 / 01-控制论基础

**版本**: v1.0

**最后更新**: 2024-12-19
