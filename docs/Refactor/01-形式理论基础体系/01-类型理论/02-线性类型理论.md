# 02. 线性类型理论 (Linear Type Theory)

## 目录

1. [概述](#1-概述)
2. [形式化定义](#2-形式化定义)
3. [核心定理与证明](#3-核心定理与证明)
4. [语义解释](#4-语义解释)
5. [应用实例](#5-应用实例)
6. [与其他理论的关联](#6-与其他理论的关联)
7. [参考文献](#7-参考文献)

## 1. 概述

### 1.1 理论基础

线性类型理论是类型理论的重要扩展，引入了资源管理的概念。在线性类型系统中，每个值必须被使用恰好一次，这为内存安全、并发控制和资源管理提供了强大的理论基础。

### 1.2 核心思想

- **线性性**：每个值必须被使用恰好一次
- **资源管理**：显式的资源分配和释放
- **内存安全**：防止内存泄漏和重复释放
- **并发安全**：防止数据竞争

### 1.3 历史发展

- **1987年**：Girard提出线性逻辑
- **1990年代**：线性λ演算发展
- **2000年代**：线性类型系统在编程语言中的应用
- **2010年代**：Rust等语言的线性类型系统

## 2. 形式化定义

### 2.1 语法定义

**定义 2.1.1 (线性类型表达式)**
线性类型表达式 $\tau$ 由以下语法规则定义：

$$\tau ::= \text{Base} \mid \tau_1 \multimap \tau_2 \mid \tau_1 \otimes \tau_2 \mid \tau_1 \& \tau_2 \mid \tau_1 \oplus \tau_2 \mid !\tau \mid ?\tau$$

其中：

- $\text{Base}$ 是基础类型
- $\tau_1 \multimap \tau_2$ 是线性函数类型
- $\tau_1 \otimes \tau_2$ 是张量积类型
- $\tau_1 \& \tau_2$ 是加法积类型
- $\tau_1 \oplus \tau_2$ 是加法类型
- $!\tau$ 是必然模态类型
- $?\tau$ 是可能模态类型

**定义 2.1.2 (线性项表达式)**
线性项表达式 $t$ 由以下语法规则定义：

$$t ::= x \mid \lambda x : \tau.t \mid t_1 t_2 \mid t_1 \otimes t_2 \mid \text{let } x \otimes y = t_1 \text{ in } t_2 \mid \text{inl}(t) \mid \text{inr}(t) \mid \text{case}(t, x_1.t_1, x_2.t_2) \mid \text{promote}(t) \mid \text{derelict}(t)$$

### 2.2 线性上下文

**定义 2.1.3 (线性上下文)**
线性上下文 $\Gamma$ 是形如 $x_1 : \tau_1, \ldots, x_n : \tau_n$ 的有序列表，其中每个变量最多出现一次。

**定义 2.1.4 (直觉上下文)**
直觉上下文 $\Delta$ 是形如 $x_1 : \tau_1, \ldots, x_n : \tau_n$ 的有序列表，允许变量重复出现。

### 2.3 类型规则

**规则 2.1.1 (线性变量规则)**
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau}$$

**规则 2.1.2 (线性抽象规则)**
$$\frac{\Gamma, x : \tau_1 \vdash t : \tau_2}{\Gamma \vdash \lambda x : \tau_1.t : \tau_1 \multimap \tau_2}$$

**规则 2.1.3 (线性应用规则)**
$$\frac{\Gamma \vdash t_1 : \tau_1 \multimap \tau_2 \quad \Delta \vdash t_2 : \tau_1}{\Gamma, \Delta \vdash t_1 t_2 : \tau_2}$$

**规则 2.1.4 (张量积引入)**
$$\frac{\Gamma \vdash t_1 : \tau_1 \quad \Delta \vdash t_2 : \tau_2}{\Gamma, \Delta \vdash t_1 \otimes t_2 : \tau_1 \otimes \tau_2}$$

**规则 2.1.5 (张量积消除)**
$$\frac{\Gamma \vdash t_1 : \tau_1 \otimes \tau_2 \quad \Delta, x : \tau_1, y : \tau_2 \vdash t_2 : \tau}{\Gamma, \Delta \vdash \text{let } x \otimes y = t_1 \text{ in } t_2 : \tau}$$

**规则 2.1.6 (必然模态引入)**
$$\frac{\Delta \vdash t : \tau}{!\Delta \vdash \text{promote}(t) : !\tau}$$

**规则 2.1.7 (必然模态消除)**
$$\frac{\Gamma \vdash t : !\tau}{\Gamma \vdash \text{derelict}(t) : \tau}$$

## 3. 核心定理与证明

### 3.1 线性性保持定理

**定理 3.1.1 (线性性保持)**
如果 $\Gamma \vdash t : \tau$ 且 $t \rightarrow t'$，则 $\Gamma' \vdash t' : \tau$，其中 $\Gamma'$ 是 $\Gamma$ 的线性子集。

**证明：** 通过对归约规则的归纳证明。

**基础情况：** 线性β-归约
假设 $(\lambda x : \tau_1.t_1) t_2 \rightarrow t_1[t_2/x]$

1. 由线性应用规则：$\Gamma, \Delta \vdash (\lambda x : \tau_1.t_1) t_2 : \tau_2$
2. 由线性抽象规则：$\Gamma, x : \tau_1 \vdash t_1 : \tau_2$
3. 由线性替换引理：$\Gamma, \Delta \vdash t_1[t_2/x] : \tau_2$

### 3.2 资源安全定理

**定理 3.1.2 (资源安全)**
在线性类型系统中，每个资源最多被使用一次。

**证明：** 通过线性性约束和类型检查。

**定义 3.1.1 (资源使用)**
资源使用函数 $\text{use} : \text{Term} \rightarrow \text{Var} \rightarrow \mathbb{N}$ 定义为：

$$\text{use}(x, y) = \begin{cases}
1 & \text{if } x = y \\
0 & \text{otherwise}
\end{cases}$$

$$\text{use}(\lambda x.t, y) = \text{use}(t, y)$$

$$\text{use}(t_1 t_2, y) = \text{use}(t_1, y) + \text{use}(t_2, y)$$

**引理 3.1.1 (线性性约束)**
如果 $\Gamma \vdash t : \tau$，则对于所有 $x \in \text{dom}(\Gamma)$，$\text{use}(t, x) \leq 1$。

### 3.3 内存安全定理

**定理 3.1.3 (内存安全)**
线性类型系统保证内存安全，防止内存泄漏和重复释放。

**证明：** 通过资源管理和线性性约束。

```haskell
-- 内存安全证明
data Memory = Memory {
  allocated :: Set Address,
  freed :: Set Address
}

-- 线性所有权
data LinearRef a = LinearRef {
  address :: Address,
  value :: a
}

-- 线性使用保证
useOnce :: LinearRef a -> (a -> b) -> b
useOnce (LinearRef addr val) f =
  let result = f val
      -- 使用后自动释放
      _ = free addr
  in result

-- 类型系统保证：每个 LinearRef 只能使用一次
```

## 4. 语义解释

### 4.1 资源语义

**定义 4.1.1 (资源语义)**
给定类型 $\tau$，其资源语义 $[\![\tau]\!]_{\text{res}}$ 定义为：

- $[\![\text{Base}]\!]_{\text{res}} = \text{基础资源}$
- $[\![\tau_1 \multimap \tau_2]\!]_{\text{res}} = [\![\tau_1]\!]_{\text{res}} \rightarrow [\![\tau_2]\!]_{\text{res}}$
- $[\![\tau_1 \otimes \tau_2]\!]_{\text{res}} = [\![\tau_1]\!]_{\text{res}} \times [\![\tau_2]\!]_{\text{res}}$

### 4.2 对称幺半群语义

**定义 4.1.2 (对称幺半群语义)**
在对称幺半群范畴中：

- 对象对应类型
- 态射对应线性函数
- 张量积对应 $\otimes$ 类型
- 单位对象对应 $I$ 类型

## 5. 应用实例

### 5.1 Rust语言中的线性类型

```rust
// Rust 的所有权系统基于线性类型
fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // s1 的所有权移动到 s2，s1 不再可用

    // 编译错误：s1 已经被移动
    // println!("{}", s1);

    println!("{}", s2); // 正确：s2 拥有所有权
}

// 线性函数类型
fn take_ownership(s: String) -> String {
    s // 返回所有权
}

// 借用：非线性的引用
fn borrow_reference(s: &String) {
    println!("{}", s);
}
```

### 5.2 并发安全

```haskell
-- 线性类型保证并发安全
data LinearChannel a = LinearChannel {
  send :: a -> IO (),
  receive :: IO a
}

-- 创建线性通道
createChannel :: IO (LinearChannel a, LinearChannel a)
createChannel = do
  -- 实现细节
  undefined

-- 使用线性通道
useChannel :: LinearChannel a -> a -> IO ()
useChannel channel value = do
  send channel value
  -- 通道被消费，不能再次使用
```

### 5.3 资源管理

```haskell
-- 线性文件句柄
data LinearFile = LinearFile {
  handle :: FileHandle,
  path :: FilePath
}

-- 线性文件操作
readFile :: LinearFile -> IO (String, LinearFile)
readFile (LinearFile h p) = do
  content <- hGetContents h
  return (content, LinearFile h p)

closeFile :: LinearFile -> IO ()
closeFile (LinearFile h _) = hClose h

-- 类型系统保证：文件必须被关闭
withFile :: FilePath -> (LinearFile -> IO a) -> IO a
withFile path action = do
  h <- openFile path ReadMode
  let file = LinearFile h path
  result <- action file
  closeFile file
  return result
```

## 6. 与其他理论的关联

### 6.1 与系统理论的关联

**定理 6.1.1 (线性-系统对应)**
线性类型系统与资源管理系统存在对应关系：

```haskell
-- 线性类型映射到系统状态
linearToSystem :: LinearType -> SystemState
linearToSystem (Linear a) = State {
  resources = [a],
  constraints = [UseOnce a]
}

-- 线性函数映射到状态转移
linearFunctionToTransition :: LinearType -> Transition
linearFunctionToTransition (a :-> b) = Transition {
  input = linearToSystem a,
  output = linearToSystem b,
  constraint = LinearConstraint
}
```

### 6.2 与逻辑理论的关联

**定理 6.1.2 (线性逻辑对应)**
线性类型系统对应线性逻辑：

| 线性逻辑 | 线性类型 |
|----------|----------|
| $A \multimap B$ | $\tau_1 \multimap \tau_2$ |
| $A \otimes B$ | $\tau_1 \otimes \tau_2$ |
| $A \& B$ | $\tau_1 \& \tau_2$ |
| $A \oplus B$ | $\tau_1 \oplus \tau_2$ |
| $!A$ | $!\tau$ |
| $?A$ | $?\tau$ |

## 7. 参考文献

1. **Girard, J.-Y.** (1987). Linear logic. *Theoretical Computer Science*, 50(1), 1-101.

2. **Wadler, P.** (1990). Linear types can change the world! *Programming Concepts and Methods*, 561-581.

3. **Abramsky, S.** (1993). Computational interpretations of linear logic. *Theoretical Computer Science*, 111(1-2), 3-57.

4. **Benton, P. N.** (1995). A mixed linear and non-linear logic: Proofs, terms and models. *Computer Science Logic*, 121-135.

5. **Jung, A., & Tiuryn, J.** (1993). A new characterization of lambda definability. *Typed Lambda Calculi and Applications*, 245-257.

6. **Mazurak, K., & Zdancewic, S.** (2010). Abstractions for fault-tolerant computing. *Programming Languages and Systems*, 48-63.

---

**关键词**: 线性类型理论、线性逻辑、资源管理、内存安全、并发安全

**分类**: 01-形式理论基础体系 / 01-类型理论 / 02-线性类型理论

**版本**: v1.0

**最后更新**: 2024-12-19
