# 03. 仿射类型理论 (Affine Type Theory)

## 目录

1. [概述](#1-概述)
2. [形式化定义](#2-形式化定义)
3. [核心定理与证明](#3-核心定理与证明)
4. [语义解释](#4-语义解释)
5. [应用实例](#5-应用实例)
6. [与其他理论的关联](#6-与其他理论的关联)
7. [参考文献](#7-参考文献)

## 1. 概述

### 1.1 理论基础

仿射类型理论是线性类型理论的扩展，引入了"最多使用一次"的概念。在仿射类型系统中，每个值最多被使用一次，这为资源管理和内存安全提供了更灵活的理论基础。

### 1.2 核心思想

- **仿射性**：每个值最多被使用一次
- **资源管理**：灵活的资源分配和释放
- **内存安全**：防止内存泄漏
- **并发安全**：支持共享资源

### 1.3 历史发展

- **1990年代**：仿射逻辑发展
- **2000年代**：仿射λ演算
- **2010年代**：Rust语言的借用检查器
- **2020年代**：仿射类型系统在系统编程中的应用

## 2. 形式化定义

### 2.1 语法定义

**定义 2.1.1 (仿射类型表达式)**
仿射类型表达式 $\tau$ 由以下语法规则定义：

$$\tau ::= \text{Base} \mid \tau_1 \multimap \tau_2 \mid \tau_1 \otimes \tau_2 \mid \tau_1 \& \tau_2 \mid \tau_1 \oplus \tau_2 \mid !\tau \mid ?\tau$$

**定义 2.1.2 (仿射上下文)**
仿射上下文 $\Gamma$ 是形如 $x_1 : \tau_1, \ldots, x_n : \tau_n$ 的有序列表，其中每个变量最多出现一次。

### 2.2 类型规则

**规则 2.1.1 (仿射变量规则)**
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau}$$

**规则 2.1.2 (仿射抽象规则)**
$$\frac{\Gamma, x : \tau_1 \vdash t : \tau_2}{\Gamma \vdash \lambda x : \tau_1.t : \tau_1 \multimap \tau_2}$$

**规则 2.1.3 (仿射应用规则)**
$$\frac{\Gamma \vdash t_1 : \tau_1 \multimap \tau_2 \quad \Delta \vdash t_2 : \tau_1}{\Gamma, \Delta \vdash t_1 t_2 : \tau_2}$$

## 3. 核心定理与证明

### 3.1 仿射性保持定理

**定理 3.1.1 (仿射性保持)**
如果 $\Gamma \vdash t : \tau$ 且 $t \rightarrow t'$，则 $\Gamma' \vdash t' : \tau$，其中 $\Gamma'$ 是 $\Gamma$ 的仿射子集。

### 3.2 资源安全定理

**定理 3.1.2 (资源安全)**
在仿射类型系统中，每个资源最多被使用一次。

## 4. 语义解释

### 4.1 资源语义

**定义 4.1.1 (资源语义)**
给定类型 $\tau$，其资源语义 $[\![\tau]\!]_{\text{res}}$ 定义为：

- $[\![\text{Base}]\!]_{\text{res}} = \text{基础资源}$
- $[\![\tau_1 \multimap \tau_2]\!]_{\text{res}} = [\![\tau_1]\!]_{\text{res}} \rightarrow [\![\tau_2]\!]_{\text{res}}$

## 5. 应用实例

### 5.1 Rust语言中的借用检查

```rust
// Rust 的借用检查器基于仿射类型
fn main() {
    let mut s = String::from("hello");
    
    // 可变借用
    let r1 = &mut s;
    // let r2 = &mut s; // 编译错误：不能同时有两个可变借用
    
    // 使用后借用结束
    println!("{}", r1);
    
    // 现在可以再次借用
    let r3 = &mut s;
    println!("{}", r3);
}
```

### 5.2 资源管理

```haskell
-- 仿射文件句柄
data AffineFile = AffineFile {
  handle :: FileHandle,
  path :: FilePath
}

-- 仿射文件操作
readFile :: AffineFile -> IO (String, Maybe AffineFile)
readFile (AffineFile h p) = do
  content <- hGetContents h
  return (content, Nothing) -- 使用后文件句柄被消费

-- 类型系统保证：文件最多被使用一次
withFile :: FilePath -> (AffineFile -> IO a) -> IO a
withFile path action = do
  h <- openFile path ReadMode
  let file = AffineFile h path
  result <- action file
  -- 文件句柄自动关闭
  return result
```

## 6. 与其他理论的关联

### 6.1 与线性类型理论的关联

**定理 6.1.1 (仿射-线性对应)**
仿射类型系统是线性类型系统的扩展：

```haskell
-- 仿射类型包含线性类型
affineContainsLinear :: LinearType -> AffineType
affineContainsLinear linear = AffineType {
  baseType = linear,
  constraint = AtMostOnce
}

-- 线性类型是仿射类型的特例
linearIsAffine :: LinearType -> AffineType
linearIsAffine linear = AffineType {
  baseType = linear,
  constraint = ExactlyOnce
}
```

## 7. 参考文献

1. **Wadler, P.** (1990). Linear types can change the world! *Programming Concepts and Methods*, 561-581.

2. **Abramsky, S.** (1993). Computational interpretations of linear logic. *Theoretical Computer Science*, 111(1-2), 3-57.

3. **Jung, A., & Tiuryn, J.** (1993). A new characterization of lambda definability. *Typed Lambda Calculi and Applications*, 245-257.

---

**关键词**: 仿射类型理论、资源管理、内存安全、借用检查、Rust语言

**分类**: 01-形式理论基础体系 / 01-类型理论 / 03-仿射类型理论

**版本**: v1.0

**最后更新**: 2024-12-19
