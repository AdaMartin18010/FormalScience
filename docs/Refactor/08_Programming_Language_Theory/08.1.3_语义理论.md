# 08.1.3 è¯­ä¹‰ç†è®º

## ğŸ“‹ æ¦‚è¿°

è¯­ä¹‰ç†è®ºæ˜¯ç¼–ç¨‹è¯­è¨€ç†è®ºä¸­ç ”ç©¶è¯­è¨€å«ä¹‰å’Œè§£é‡Šçš„æ ¸å¿ƒç†è®ºä½“ç³»ï¼Œé€šè¿‡å»ºç«‹å½¢å¼åŒ–çš„è¯­ä¹‰æ¨¡å‹ï¼Œä¸ºç¼–ç¨‹è¯­è¨€çš„è¯­ä¹‰åˆ†æå’Œç¨‹åºéªŒè¯æä¾›ç§‘å­¦ä¾æ®ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ç¼–ç¨‹è¯­è¨€è¯­ä¹‰çš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°Rustè¯­ä¹‰åˆ†æç¤ºä¾‹
4. åˆ†æè¯­ä¹‰æ¨¡å‹ä¸è§£é‡Šæ–¹æ³•

## ğŸ“š ç›®å½•

1. åŸºæœ¬æ¦‚å¿µ
2. å½¢å¼åŒ–å®šä¹‰
3. å®šç†ä¸è¯æ˜
4. ä»£ç å®ç°
5. åº”ç”¨ç¤ºä¾‹
6. ç›¸å…³ç†è®º
7. å‚è€ƒæ–‡çŒ®

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è¯­ä¹‰å®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆè¯­ä¹‰ï¼‰
è¯­ä¹‰æ˜¯ç¼–ç¨‹è¯­è¨€ä¸­è¡¨è¾¾å¼ã€è¯­å¥å’Œç¨‹åºçš„å«ä¹‰ï¼Œæè¿°äº†ç¨‹åºåœ¨ç»™å®šè¾“å…¥ä¸‹çš„æ‰§è¡Œè¡Œä¸ºã€‚

### 1.2 è¯­ä¹‰åˆ†ç±»
- æ“ä½œè¯­ä¹‰ï¼ˆOperational Semanticsï¼‰
- æŒ‡ç§°è¯­ä¹‰ï¼ˆDenotational Semanticsï¼‰
- å…¬ç†è¯­ä¹‰ï¼ˆAxiomatic Semanticsï¼‰
- ä»£æ•°è¯­ä¹‰ï¼ˆAlgebraic Semanticsï¼‰

## 2. å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1**ï¼ˆè¯­ä¹‰åŸŸï¼‰
è¯­ä¹‰åŸŸ $D$ æ˜¯ç¨‹åºå«ä¹‰çš„æ•°å­¦ç»“æ„ï¼ŒåŒ…å«å€¼ã€å‡½æ•°å’Œå…³ç³»ã€‚

**å®šä¹‰ 2.2**ï¼ˆè¯­ä¹‰å‡½æ•°ï¼‰
è¯­ä¹‰å‡½æ•° $\mathcal{E}$ å°†è¯­æ³•ç»“æ„æ˜ å°„åˆ°è¯­ä¹‰åŸŸï¼š
$\mathcal{E}: \text{Syntax} \rightarrow D$

**å®šç† 2.1**ï¼ˆè¯­ä¹‰ä¸€è‡´æ€§ï¼‰
å½¢å¼åŒ–è¯­ä¹‰åº”è¯¥ä¸ç¨‹åºçš„å®é™…æ‰§è¡Œè¡Œä¸ºä¸€è‡´ã€‚

**è¯æ˜**ï¼š
é€šè¿‡è¯­ä¹‰ç­‰ä»·æ€§è¯æ˜ï¼Œç¡®ä¿å½¢å¼åŒ–è¯­ä¹‰æ­£ç¡®æè¿°ç¨‹åºè¡Œä¸ºã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

**å®šç† 3.1**ï¼ˆè¯­ä¹‰ç»„åˆæ€§ï¼‰
å¤æ‚è¡¨è¾¾å¼çš„è¯­ä¹‰ç”±å…¶ç»„æˆéƒ¨åˆ†çš„è¯­ä¹‰ç»„åˆè€Œæˆã€‚

**è¯æ˜**ï¼š
è¯­ä¹‰å‡½æ•°çš„ç»“æ„åŒ–å®šä¹‰ç¡®ä¿äº†ç»„åˆæ€§ã€‚$\square$

**å®šç† 3.2**ï¼ˆè¯­ä¹‰ç¡®å®šæ€§ï¼‰
ç¡®å®šæ€§è¯­è¨€çš„è¯­ä¹‰å‡½æ•°åº”è¯¥æ˜¯å•å€¼çš„ã€‚

**è¯æ˜**ï¼š
æ¯ä¸ªè¯­æ³•ç»“æ„åœ¨ç»™å®šç¯å¢ƒä¸‹éƒ½æœ‰å”¯ä¸€çš„è¯­ä¹‰è§£é‡Šã€‚$\square$

## 4. ä»£ç å®ç°

```rust
use std::collections::HashMap;
use std::fmt;

/// è¯­ä¹‰å€¼
#[derive(Debug, Clone, PartialEq)]
pub enum SemanticValue {
    Integer(i64),
    Boolean(bool),
    String(String),
    Function(Box<Function>),
    Unit,
    Error(String),
}

/// å‡½æ•°
pub struct Function {
    pub parameters: Vec<String>,
    pub body: Expression,
    pub environment: Environment,
}

/// ç¯å¢ƒ
pub struct Environment {
    pub variables: HashMap<String, SemanticValue>,
    pub parent: Option<Box<Environment>>,
}

/// è¡¨è¾¾å¼
#[derive(Debug, Clone)]
pub enum Expression {
    Literal(SemanticValue),
    Variable(String),
    BinaryOp(Box<Expression>, BinaryOperator, Box<Expression>),
    UnaryOp(UnaryOperator, Box<Expression>),
    If(Box<Expression>, Box<Expression>, Box<Expression>),
    Let(String, Box<Expression>, Box<Expression>),
    FunctionCall(String, Vec<Expression>),
    Lambda(Vec<String>, Box<Expression>),
}

/// äºŒå…ƒæ“ä½œç¬¦
#[derive(Debug, Clone, PartialEq)]
pub enum BinaryOperator {
    Add,
    Subtract,
    Multiply,
    Divide,
    Equal,
    LessThan,
    GreaterThan,
    And,
    Or,
}

/// ä¸€å…ƒæ“ä½œç¬¦
#[derive(Debug, Clone, PartialEq)]
pub enum UnaryOperator {
    Not,
    Negate,
}

/// è¯­å¥
#[derive(Debug, Clone)]
pub enum Statement {
    Expression(Expression),
    Assignment(String, Expression),
    If(Expression, Box<Statement>, Option<Box<Statement>>),
    While(Expression, Box<Statement>),
    Block(Vec<Statement>),
    Return(Option<Expression>),
}

/// æ“ä½œè¯­ä¹‰è§£é‡Šå™¨
pub struct OperationalSemantics {
    pub environment: Environment,
}

impl OperationalSemantics {
    pub fn new() -> Self {
        Self {
            environment: Environment {
                variables: HashMap::new(),
                parent: None,
            },
        }
    }
    
    /// æ±‚å€¼è¡¨è¾¾å¼
    pub fn evaluate_expression(&mut self, expr: &Expression) -> Result<SemanticValue, String> {
        match expr {
            Expression::Literal(value) => Ok(value.clone()),
            
            Expression::Variable(name) => {
                self.lookup_variable(name)
                    .ok_or_else(|| format!("Undefined variable: {}", name))
            }
            
            Expression::BinaryOp(left, op, right) => {
                let left_val = self.evaluate_expression(left)?;
                let right_val = self.evaluate_expression(right)?;
                self.apply_binary_operator(&left_val, op, &right_val)
            }
            
            Expression::UnaryOp(op, operand) => {
                let operand_val = self.evaluate_expression(operand)?;
                self.apply_unary_operator(op, &operand_val)
            }
            
            Expression::If(condition, then_expr, else_expr) => {
                let condition_val = self.evaluate_expression(condition)?;
                match condition_val {
                    SemanticValue::Boolean(true) => self.evaluate_expression(then_expr),
                    SemanticValue::Boolean(false) => {
                        if let Some(else_expr) = else_expr {
                            self.evaluate_expression(else_expr)
                        } else {
                            Ok(SemanticValue::Unit)
                        }
                    }
                    _ => Err("Condition must be boolean".to_string()),
                }
            }
            
            Expression::Let(name, value_expr, body_expr) => {
                let value = self.evaluate_expression(value_expr)?;
                self.environment.variables.insert(name.clone(), value);
                let result = self.evaluate_expression(body_expr)?;
                self.environment.variables.remove(name);
                Ok(result)
            }
            
            Expression::FunctionCall(name, args) => {
                self.call_function(name, args)
            }
            
            Expression::Lambda(params, body) => {
                Ok(SemanticValue::Function(Box::new(Function {
                    parameters: params.clone(),
                    body: *body.clone(),
                    environment: self.environment.clone(),
                })))
            }
        }
    }
    
    /// æ‰§è¡Œè¯­å¥
    pub fn execute_statement(&mut self, stmt: &Statement) -> Result<SemanticValue, String> {
        match stmt {
            Statement::Expression(expr) => self.evaluate_expression(expr),
            
            Statement::Assignment(name, expr) => {
                let value = self.evaluate_expression(expr)?;
                self.environment.variables.insert(name.clone(), value.clone());
                Ok(value)
            }
            
            Statement::If(condition, then_stmt, else_stmt) => {
                let condition_val = self.evaluate_expression(condition)?;
                match condition_val {
                    SemanticValue::Boolean(true) => self.execute_statement(then_stmt),
                    SemanticValue::Boolean(false) => {
                        if let Some(else_stmt) = else_stmt {
                            self.execute_statement(else_stmt)
                        } else {
                            Ok(SemanticValue::Unit)
                        }
                    }
                    _ => Err("Condition must be boolean".to_string()),
                }
            }
            
            Statement::While(condition, body) => {
                loop {
                    let condition_val = self.evaluate_expression(condition)?;
                    match condition_val {
                        SemanticValue::Boolean(true) => {
                            self.execute_statement(body)?;
                        }
                        SemanticValue::Boolean(false) => break,
                        _ => return Err("Condition must be boolean".to_string()),
                    }
                }
                Ok(SemanticValue::Unit)
            }
            
            Statement::Block(statements) => {
                let mut result = SemanticValue::Unit;
                for stmt in statements {
                    result = self.execute_statement(stmt)?;
                }
                Ok(result)
            }
            
            Statement::Return(expr) => {
                if let Some(expr) = expr {
                    self.evaluate_expression(expr)
                } else {
                    Ok(SemanticValue::Unit)
                }
            }
        }
    }
    
    /// åº”ç”¨äºŒå…ƒæ“ä½œç¬¦
    fn apply_binary_operator(&self, left: &SemanticValue, op: &BinaryOperator, right: &SemanticValue) -> Result<SemanticValue, String> {
        match (left, op, right) {
            (SemanticValue::Integer(a), BinaryOperator::Add, SemanticValue::Integer(b)) => {
                Ok(SemanticValue::Integer(a + b))
            }
            (SemanticValue::Integer(a), BinaryOperator::Subtract, SemanticValue::Integer(b)) => {
                Ok(SemanticValue::Integer(a - b))
            }
            (SemanticValue::Integer(a), BinaryOperator::Multiply, SemanticValue::Integer(b)) => {
                Ok(SemanticValue::Integer(a * b))
            }
            (SemanticValue::Integer(a), BinaryOperator::Divide, SemanticValue::Integer(b)) => {
                if *b == 0 {
                    Err("Division by zero".to_string())
                } else {
                    Ok(SemanticValue::Integer(a / b))
                }
            }
            (SemanticValue::Integer(a), BinaryOperator::Equal, SemanticValue::Integer(b)) => {
                Ok(SemanticValue::Boolean(a == b))
            }
            (SemanticValue::Integer(a), BinaryOperator::LessThan, SemanticValue::Integer(b)) => {
                Ok(SemanticValue::Boolean(a < b))
            }
            (SemanticValue::Integer(a), BinaryOperator::GreaterThan, SemanticValue::Integer(b)) => {
                Ok(SemanticValue::Boolean(a > b))
            }
            (SemanticValue::Boolean(a), BinaryOperator::And, SemanticValue::Boolean(b)) => {
                Ok(SemanticValue::Boolean(*a && *b))
            }
            (SemanticValue::Boolean(a), BinaryOperator::Or, SemanticValue::Boolean(b)) => {
                Ok(SemanticValue::Boolean(*a || *b))
            }
            _ => Err("Invalid binary operation".to_string()),
        }
    }
    
    /// åº”ç”¨ä¸€å…ƒæ“ä½œç¬¦
    fn apply_unary_operator(&self, op: &UnaryOperator, operand: &SemanticValue) -> Result<SemanticValue, String> {
        match (op, operand) {
            (UnaryOperator::Not, SemanticValue::Boolean(b)) => {
                Ok(SemanticValue::Boolean(!b))
            }
            (UnaryOperator::Negate, SemanticValue::Integer(i)) => {
                Ok(SemanticValue::Integer(-i))
            }
            _ => Err("Invalid unary operation".to_string()),
        }
    }
    
    /// æŸ¥æ‰¾å˜é‡
    fn lookup_variable(&self, name: &str) -> Option<SemanticValue> {
        self.environment.lookup_variable(name)
    }
    
    /// è°ƒç”¨å‡½æ•°
    fn call_function(&mut self, name: &str, args: &[Expression]) -> Result<SemanticValue, String> {
        // ç®€åŒ–çš„å‡½æ•°è°ƒç”¨å®ç°
        match name {
            "print" => {
                if args.len() == 1 {
                    let value = self.evaluate_expression(&args[0])?;
                    println!("{}", value);
                    Ok(SemanticValue::Unit)
                } else {
                    Err("print function expects exactly one argument".to_string())
                }
            }
            _ => Err(format!("Unknown function: {}", name)),
        }
    }
}

impl Environment {
    pub fn new() -> Self {
        Self {
            variables: HashMap::new(),
            parent: None,
        }
    }
    
    pub fn with_parent(parent: Environment) -> Self {
        Self {
            variables: HashMap::new(),
            parent: Some(Box::new(parent)),
        }
    }
    
    pub fn lookup_variable(&self, name: &str) -> Option<SemanticValue> {
        if let Some(value) = self.variables.get(name) {
            Some(value.clone())
        } else if let Some(ref parent) = self.parent {
            parent.lookup_variable(name)
        } else {
            None
        }
    }
    
    pub fn set_variable(&mut self, name: String, value: SemanticValue) {
        self.variables.insert(name, value);
    }
}

impl Clone for Environment {
    fn clone(&self) -> Self {
        Self {
            variables: self.variables.clone(),
            parent: self.parent.clone(),
        }
    }
}

/// æŒ‡ç§°è¯­ä¹‰è§£é‡Šå™¨
pub struct DenotationalSemantics;

impl DenotationalSemantics {
    /// è¯­ä¹‰å‡½æ•°ï¼šè¡¨è¾¾å¼åˆ°å€¼çš„æ˜ å°„
    pub fn semantic_function(&self, expr: &Expression, env: &Environment) -> SemanticValue {
        match expr {
            Expression::Literal(value) => value.clone(),
            
            Expression::Variable(name) => {
                env.lookup_variable(name).unwrap_or(SemanticValue::Error(
                    format!("Undefined variable: {}", name)
                ))
            }
            
            Expression::BinaryOp(left, op, right) => {
                let left_val = self.semantic_function(left, env);
                let right_val = self.semantic_function(right, env);
                
                match (left_val, op, right_val) {
                    (SemanticValue::Integer(a), BinaryOperator::Add, SemanticValue::Integer(b)) => {
                        SemanticValue::Integer(a + b)
                    }
                    (SemanticValue::Integer(a), BinaryOperator::Subtract, SemanticValue::Integer(b)) => {
                        SemanticValue::Integer(a - b)
                    }
                    (SemanticValue::Integer(a), BinaryOperator::Multiply, SemanticValue::Integer(b)) => {
                        SemanticValue::Integer(a * b)
                    }
                    (SemanticValue::Integer(a), BinaryOperator::Divide, SemanticValue::Integer(b)) => {
                        if b == 0 {
                            SemanticValue::Error("Division by zero".to_string())
                        } else {
                            SemanticValue::Integer(a / b)
                        }
                    }
                    _ => SemanticValue::Error("Invalid binary operation".to_string()),
                }
            }
            
            Expression::If(condition, then_expr, else_expr) => {
                let condition_val = self.semantic_function(condition, env);
                match condition_val {
                    SemanticValue::Boolean(true) => self.semantic_function(then_expr, env),
                    SemanticValue::Boolean(false) => {
                        if let Some(else_expr) = else_expr {
                            self.semantic_function(else_expr, env)
                        } else {
                            SemanticValue::Unit
                        }
                    }
                    _ => SemanticValue::Error("Condition must be boolean".to_string()),
                }
            }
            
            Expression::Let(name, value_expr, body_expr) => {
                let value = self.semantic_function(value_expr, env);
                let mut new_env = Environment::with_parent(env.clone());
                new_env.set_variable(name.clone(), value);
                self.semantic_function(body_expr, &new_env)
            }
            
            _ => SemanticValue::Error("Unsupported expression".to_string()),
        }
    }
}

/// å…¬ç†è¯­ä¹‰éªŒè¯å™¨
pub struct AxiomaticSemantics;

impl AxiomaticSemantics {
    /// å‰ç½®æ¡ä»¶
    pub struct Precondition {
        pub condition: String,
        pub variables: HashMap<String, String>,
    }
    
    /// åç½®æ¡ä»¶
    pub struct Postcondition {
        pub condition: String,
        pub variables: HashMap<String, String>,
    }
    
    /// éªŒè¯ç¨‹åºæ­£ç¡®æ€§
    pub fn verify_program(&self, precondition: &Precondition, program: &Statement, postcondition: &Postcondition) -> bool {
        // ç®€åŒ–çš„ç¨‹åºéªŒè¯
        // å®é™…å®ç°éœ€è¦æ›´å¤æ‚çš„é€»è¾‘
        
        // æ£€æŸ¥å‰ç½®æ¡ä»¶
        if !self.check_precondition(precondition) {
            return false;
        }
        
        // æ£€æŸ¥åç½®æ¡ä»¶
        if !self.check_postcondition(postcondition) {
            return false;
        }
        
        true
    }
    
    fn check_precondition(&self, precondition: &Precondition) -> bool {
        // ç®€åŒ–çš„å‰ç½®æ¡ä»¶æ£€æŸ¥
        !precondition.condition.is_empty()
    }
    
    fn check_postcondition(&self, postcondition: &Postcondition) -> bool {
        // ç®€åŒ–çš„åç½®æ¡ä»¶æ£€æŸ¥
        !postcondition.condition.is_empty()
    }
    
    /// ç”Ÿæˆæœ€å¼±å‰ç½®æ¡ä»¶
    pub fn weakest_precondition(&self, statement: &Statement, postcondition: &Postcondition) -> Precondition {
        match statement {
            Statement::Assignment(name, expr) => {
                // å¯¹äºèµ‹å€¼è¯­å¥ x := eï¼Œæœ€å¼±å‰ç½®æ¡ä»¶æ˜¯ wp(x := e, Q) = Q[x/e]
                let mut variables = postcondition.variables.clone();
                variables.insert(name.clone(), format!("({})", expr));
                
                Precondition {
                    condition: postcondition.condition.clone(),
                    variables,
                }
            }
            
            Statement::If(condition, then_stmt, else_stmt) => {
                // å¯¹äºifè¯­å¥ï¼Œæœ€å¼±å‰ç½®æ¡ä»¶æ˜¯
                // wp(if b then S1 else S2, Q) = (b âˆ§ wp(S1, Q)) âˆ¨ (Â¬b âˆ§ wp(S2, Q))
                let then_wp = self.weakest_precondition(then_stmt, postcondition);
                let else_wp = if let Some(else_stmt) = else_stmt {
                    self.weakest_precondition(else_stmt, postcondition)
                } else {
                    Precondition {
                        condition: "true".to_string(),
                        variables: HashMap::new(),
                    }
                };
                
                Precondition {
                    condition: format!("({} âˆ§ {}) âˆ¨ (Â¬{} âˆ§ {})", 
                                     condition, then_wp.condition, condition, else_wp.condition),
                    variables: HashMap::new(),
                }
            }
            
            _ => Precondition {
                condition: "true".to_string(),
                variables: HashMap::new(),
            },
        }
    }
}

/// è¯­ä¹‰åˆ†æå™¨
pub struct SemanticAnalyzer {
    pub operational_semantics: OperationalSemantics,
    pub denotational_semantics: DenotationalSemantics,
    pub axiomatic_semantics: AxiomaticSemantics,
}

impl SemanticAnalyzer {
    pub fn new() -> Self {
        Self {
            operational_semantics: OperationalSemantics::new(),
            denotational_semantics: DenotationalSemantics,
            axiomatic_semantics: AxiomaticSemantics,
        }
    }
    
    /// åˆ†æè¡¨è¾¾å¼è¯­ä¹‰
    pub fn analyze_expression(&mut self, expr: &Expression) -> SemanticAnalysis {
        let mut analysis = SemanticAnalysis {
            operational_result: None,
            denotational_result: None,
            axiomatic_result: None,
            errors: Vec::new(),
        };
        
        // æ“ä½œè¯­ä¹‰åˆ†æ
        match self.operational_semantics.evaluate_expression(expr) {
            Ok(result) => analysis.operational_result = Some(result),
            Err(error) => analysis.errors.push(format!("Operational: {}", error)),
        }
        
        // æŒ‡ç§°è¯­ä¹‰åˆ†æ
        let env = Environment::new();
        analysis.denotational_result = Some(
            self.denotational_semantics.semantic_function(expr, &env)
        );
        
        analysis
    }
    
    /// åˆ†æè¯­å¥è¯­ä¹‰
    pub fn analyze_statement(&mut self, stmt: &Statement) -> SemanticAnalysis {
        let mut analysis = SemanticAnalysis {
            operational_result: None,
            denotational_result: None,
            axiomatic_result: None,
            errors: Vec::new(),
        };
        
        // æ“ä½œè¯­ä¹‰åˆ†æ
        match self.operational_semantics.execute_statement(stmt) {
            Ok(result) => analysis.operational_result = Some(result),
            Err(error) => analysis.errors.push(format!("Operational: {}", error)),
        }
        
        analysis
    }
    
    /// éªŒè¯ç¨‹åºæ­£ç¡®æ€§
    pub fn verify_program(&self, precondition: &AxiomaticSemantics::Precondition, 
                         program: &Statement, 
                         postcondition: &AxiomaticSemantics::Postcondition) -> bool {
        self.axiomatic_semantics.verify_program(precondition, program, postcondition)
    }
}

/// è¯­ä¹‰åˆ†æç»“æœ
pub struct SemanticAnalysis {
    pub operational_result: Option<SemanticValue>,
    pub denotational_result: Option<SemanticValue>,
    pub axiomatic_result: Option<bool>,
    pub errors: Vec<String>,
}

impl fmt::Display for SemanticValue {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SemanticValue::Integer(i) => write!(f, "{}", i),
            SemanticValue::Boolean(b) => write!(f, "{}", b),
            SemanticValue::String(s) => write!(f, "\"{}\"", s),
            SemanticValue::Function(_) => write!(f, "<function>"),
            SemanticValue::Unit => write!(f, "()"),
            SemanticValue::Error(e) => write!(f, "Error: {}", e),
        }
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_operational_semantics() {
        let mut semantics = OperationalSemantics::new();
        
        // æµ‹è¯•å­—é¢é‡
        let literal = Expression::Literal(SemanticValue::Integer(42));
        let result = semantics.evaluate_expression(&literal);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), SemanticValue::Integer(42));
        
        // æµ‹è¯•äºŒå…ƒæ“ä½œ
        let binary_op = Expression::BinaryOp(
            Box::new(Expression::Literal(SemanticValue::Integer(5))),
            BinaryOperator::Add,
            Box::new(Expression::Literal(SemanticValue::Integer(3)))
        );
        let result = semantics.evaluate_expression(&binary_op);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), SemanticValue::Integer(8));
    }
    
    #[test]
    fn test_denotational_semantics() {
        let semantics = DenotationalSemantics;
        let env = Environment::new();
        
        // æµ‹è¯•å­—é¢é‡
        let literal = Expression::Literal(SemanticValue::Integer(42));
        let result = semantics.semantic_function(&literal, &env);
        assert_eq!(result, SemanticValue::Integer(42));
        
        // æµ‹è¯•äºŒå…ƒæ“ä½œ
        let binary_op = Expression::BinaryOp(
            Box::new(Expression::Literal(SemanticValue::Integer(5))),
            BinaryOperator::Multiply,
            Box::new(Expression::Literal(SemanticValue::Integer(3)))
        );
        let result = semantics.semantic_function(&binary_op, &env);
        assert_eq!(result, SemanticValue::Integer(15));
    }
    
    #[test]
    fn test_axiomatic_semantics() {
        let semantics = AxiomaticSemantics;
        
        // æµ‹è¯•èµ‹å€¼è¯­å¥çš„æœ€å¼±å‰ç½®æ¡ä»¶
        let assignment = Statement::Assignment(
            "x".to_string(),
            Expression::Literal(SemanticValue::Integer(5))
        );
        
        let postcondition = AxiomaticSemantics::Postcondition {
            condition: "x > 0".to_string(),
            variables: HashMap::new(),
        };
        
        let wp = semantics.weakest_precondition(&assignment, &postcondition);
        assert_eq!(wp.condition, "x > 0");
    }
    
    #[test]
    fn test_semantic_analyzer() {
        let mut analyzer = SemanticAnalyzer::new();
        
        // æµ‹è¯•è¡¨è¾¾å¼åˆ†æ
        let expr = Expression::BinaryOp(
            Box::new(Expression::Literal(SemanticValue::Integer(10))),
            BinaryOperator::Add,
            Box::new(Expression::Literal(SemanticValue::Integer(20)))
        );
        
        let analysis = analyzer.analyze_expression(&expr);
        assert!(analysis.operational_result.is_some());
        assert!(analysis.denotational_result.is_some());
        assert!(analysis.errors.is_empty());
        
        if let Some(SemanticValue::Integer(result)) = analysis.operational_result {
            assert_eq!(result, 30);
        }
    }
    
    #[test]
    fn test_environment() {
        let mut env = Environment::new();
        
        // è®¾ç½®å˜é‡
        env.set_variable("x".to_string(), SemanticValue::Integer(42));
        
        // æŸ¥æ‰¾å˜é‡
        let value = env.lookup_variable("x");
        assert!(value.is_some());
        assert_eq!(value.unwrap(), SemanticValue::Integer(42));
        
        // æŸ¥æ‰¾ä¸å­˜åœ¨çš„å˜é‡
        let value = env.lookup_variable("y");
        assert!(value.is_none());
    }
    
    #[test]
    fn test_if_statement() {
        let mut semantics = OperationalSemantics::new();
        
        let if_expr = Expression::If(
            Box::new(Expression::Literal(SemanticValue::Boolean(true))),
            Box::new(Expression::Literal(SemanticValue::Integer(42))),
            Some(Box::new(Expression::Literal(SemanticValue::Integer(0))))
        );
        
        let result = semantics.evaluate_expression(&if_expr);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), SemanticValue::Integer(42));
    }
    
    #[test]
    fn test_let_expression() {
        let mut semantics = OperationalSemantics::new();
        
        let let_expr = Expression::Let(
            "x".to_string(),
            Box::new(Expression::Literal(SemanticValue::Integer(5))),
            Box::new(Expression::Variable("x".to_string()))
        );
        
        let result = semantics.evaluate_expression(&let_expr);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), SemanticValue::Integer(5));
    }
}
```

## 6. ç›¸å…³ç†è®º

- å½¢å¼è¯­ä¹‰å­¦
- ç¨‹åºéªŒè¯ç†è®º
- ç±»å‹ç†è®º
- é€»è¾‘å­¦

## 7. å‚è€ƒæ–‡çŒ®

1. Winskel, G. "The Formal Semantics of Programming Languages"
2. Nielson, H. R., Nielson, F. "Semantics with Applications"
3. Tennent, R. D. "Semantics of Programming Languages"
4. Plotkin, G. D. "A Structural Approach to Operational Semantics"

---

**ç›¸å…³é“¾æ¥**ï¼š
- [08.1.1 è¯­è¨€è®¾è®¡ç†è®º](../08.1.1_è¯­è¨€è®¾è®¡ç†è®º.md)
- [08.1.2 è¯­æ³•ç†è®º](../08.1.2_è¯­æ³•ç†è®º.md)
- [08.1.4 ç±»å‹ç†è®º](../08.1.4_ç±»å‹ç†è®º.md) 