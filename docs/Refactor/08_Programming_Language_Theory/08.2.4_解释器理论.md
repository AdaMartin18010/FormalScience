# 08.2.4 è§£é‡Šå™¨ç†è®º

## ğŸ“‹ æ¦‚è¿°

è§£é‡Šå™¨ç†è®ºæ˜¯ç¼–ç¨‹è¯­è¨€ç†è®ºå’Œå®ç°é¢†åŸŸçš„é‡è¦åˆ†æ”¯ï¼Œç ”ç©¶ç¨‹åºè§£é‡Šæ‰§è¡Œçš„åŸç†ã€ç»“æ„ä¸ä¼˜åŒ–æ–¹æ³•ï¼Œä¸ºè¯­è¨€å®ç°ã€è°ƒè¯•å’ŒåŠ¨æ€åˆ†ææä¾›ç†è®ºåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹è§£é‡Šå™¨çš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°Rustè§£é‡Šå™¨ç¤ºä¾‹
4. åˆ†æä¸»æµè§£é‡Šå™¨æ¶æ„ä¸ä¼˜åŒ–

## ğŸ“š ç›®å½•

1. åŸºæœ¬æ¦‚å¿µ
2. å½¢å¼åŒ–å®šä¹‰
3. å®šç†ä¸è¯æ˜
4. ä»£ç å®ç°
5. åº”ç”¨ç¤ºä¾‹
6. ç›¸å…³ç†è®º
7. å‚è€ƒæ–‡çŒ®

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è§£é‡Šå™¨å®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆè§£é‡Šå™¨ï¼‰
è§£é‡Šå™¨æ˜¯ä¸€ç§é€æ¡è¯»å–ã€åˆ†æå¹¶æ‰§è¡Œæºç¨‹åºçš„ç³»ç»Ÿè½¯ä»¶ï¼Œä¸ç”Ÿæˆä¸­é—´ç›®æ ‡ä»£ç ã€‚

### 1.2 è§£é‡Šå™¨ç±»å‹

- ç›´æ¥è§£é‡Šå™¨ï¼ˆDirect Interpreterï¼‰
- æ ˆå¼è§£é‡Šå™¨ï¼ˆStack-based Interpreterï¼‰
- ASTè§£é‡Šå™¨ï¼ˆAST Interpreterï¼‰
- å­—èŠ‚ç è§£é‡Šå™¨ï¼ˆBytecode Interpreterï¼‰

## 2. å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1**ï¼ˆè§£é‡Šå™¨æ¨¡å‹ï¼‰
è§£é‡Šå™¨æ¨¡å‹æ˜¯ä¸€ä¸ªå››å…ƒç»„ $INT = (P, S, E, F)$ï¼Œå…¶ä¸­ï¼š

- $P$ æ˜¯ç¨‹åºè¡¨ç¤ºï¼ˆå¦‚ASTæˆ–å­—èŠ‚ç ï¼‰
- $S$ æ˜¯è¿è¡Œæ—¶çŠ¶æ€
- $E$ æ˜¯ç¯å¢ƒï¼ˆå˜é‡ç»‘å®šï¼‰
- $F$ æ˜¯è§£é‡Šå‡½æ•°

**å®šä¹‰ 2.2**ï¼ˆè§£é‡Šå‡½æ•°ï¼‰
è§£é‡Šå‡½æ•° $F$ é€’å½’åœ°å°†ç¨‹åºç»“æ„æ˜ å°„ä¸ºè¿è¡Œæ—¶è¡Œä¸ºï¼š$F: P \times E \rightarrow S$

**å®šç† 2.1**ï¼ˆè¯­ä¹‰ä¸€è‡´æ€§ï¼‰
è§£é‡Šå™¨çš„æ‰§è¡Œè¯­ä¹‰åº”ä¸è¯­è¨€çš„å½¢å¼è¯­ä¹‰ä¿æŒä¸€è‡´ã€‚

**è¯æ˜**ï¼š
é€šè¿‡ä¸æ“ä½œè¯­ä¹‰æˆ–æŒ‡ç§°è¯­ä¹‰çš„ç­‰ä»·æ€§è¯æ˜ï¼Œç¡®ä¿è§£é‡Šå™¨å®ç°æ­£ç¡®ã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

**å®šç† 3.1**ï¼ˆç»ˆæ­¢æ€§ï¼‰
è‹¥ç¨‹åºæ— æ— é™é€’å½’æˆ–æ­»å¾ªç¯ï¼Œåˆ™è§£é‡Šå™¨å¿…ç„¶ç»ˆæ­¢ã€‚

**è¯æ˜**ï¼š
æ¯æ¬¡é€’å½’æˆ–å¾ªç¯éƒ½å‡å°‘å‰©ä½™è®¡ç®—é‡ï¼Œæœ€ç»ˆè¾¾åˆ°ç»ˆæ­¢æ¡ä»¶ã€‚$\square$

**å®šç† 3.2**ï¼ˆç¯å¢ƒéš”ç¦»æ€§ï¼‰
è§£é‡Šå™¨å¯é€šè¿‡ç¯å¢ƒéš”ç¦»é˜²æ­¢å˜é‡åå†²çªå’Œå‰¯ä½œç”¨ã€‚

**è¯æ˜**ï¼š
æ¯ä¸ªä½œç”¨åŸŸæœ‰ç‹¬ç«‹ç¯å¢ƒï¼Œå˜é‡ç»‘å®šäº’ä¸å¹²æ‰°ã€‚$\square$

## 4. ä»£ç å®ç°

```rust
use std::collections::HashMap;

/// æŠ½è±¡è¯­æ³•æ ‘èŠ‚ç‚¹
#[derive(Debug, Clone)]
pub enum AST {
    Literal(i64),
    Variable(String),
    Assign(String, Box<AST>),
    BinaryOp(Box<AST>, BinOp, Box<AST>),
    Sequence(Vec<AST>),
    If(Box<AST>, Box<AST>, Option<Box<AST>>),
    While(Box<AST>, Box<AST>),
    Print(Box<AST>),
}

/// äºŒå…ƒæ“ä½œç¬¦
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum BinOp {
    Add,
    Sub,
    Mul,
    Div,
    Eq,
    Lt,
    Gt,
}

/// è¿è¡Œæ—¶ç¯å¢ƒ
pub struct Env {
    pub vars: HashMap<String, i64>,
}

/// è§£é‡Šå™¨
pub struct Interpreter {
    pub env: Env,
    pub output: Vec<String>,
}

impl Interpreter {
    pub fn new() -> Self {
        Self {
            env: Env { vars: HashMap::new() },
            output: Vec::new(),
        }
    }

    /// è§£é‡Šæ‰§è¡ŒAST
    pub fn eval(&mut self, node: &AST) -> i64 {
        match node {
            AST::Literal(n) => *n,
            AST::Variable(name) => *self.env.vars.get(name).unwrap_or(&0),
            AST::Assign(name, expr) => {
                let val = self.eval(expr);
                self.env.vars.insert(name.clone(), val);
                val
            }
            AST::BinaryOp(lhs, op, rhs) => {
                let l = self.eval(lhs);
                let r = self.eval(rhs);
                match op {
                    BinOp::Add => l + r,
                    BinOp::Sub => l - r,
                    BinOp::Mul => l * r,
                    BinOp::Div => if r != 0 { l / r } else { 0 },
                    BinOp::Eq => (l == r) as i64,
                    BinOp::Lt => (l < r) as i64,
                    BinOp::Gt => (l > r) as i64,
                }
            }
            AST::Sequence(stmts) => {
                let mut last = 0;
                for stmt in stmts {
                    last = self.eval(stmt);
                }
                last
            }
            AST::If(cond, then_branch, else_branch) => {
                if self.eval(cond) != 0 {
                    self.eval(then_branch)
                } else if let Some(else_b) = else_branch {
                    self.eval(else_b)
                } else {
                    0
                }
            }
            AST::While(cond, body) => {
                let mut last = 0;
                while self.eval(cond) != 0 {
                    last = self.eval(body);
                }
                last
            }
            AST::Print(expr) => {
                let val = self.eval(expr);
                self.output.push(format!("{}", val));
                val
            }
        }
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_arithmetic() {
        let ast = AST::BinaryOp(
            Box::new(AST::Literal(2)),
            BinOp::Add,
            Box::new(AST::Literal(3)),
        );
        let mut interp = Interpreter::new();
        let result = interp.eval(&ast);
        assert_eq!(result, 5);
    }

    #[test]
    fn test_assignment_and_variable() {
        let ast = AST::Sequence(vec![
            AST::Assign("x".to_string(), Box::new(AST::Literal(10))),
            AST::Variable("x".to_string()),
        ]);
        let mut interp = Interpreter::new();
        let result = interp.eval(&ast);
        assert_eq!(result, 10);
    }

    #[test]
    fn test_if_else() {
        let ast = AST::If(
            Box::new(AST::Literal(0)),
            Box::new(AST::Literal(1)),
            Some(Box::new(AST::Literal(2))),
        );
        let mut interp = Interpreter::new();
        let result = interp.eval(&ast);
        assert_eq!(result, 2);
    }

    #[test]
    fn test_while_loop() {
        let ast = AST::Sequence(vec![
            AST::Assign("x".to_string(), Box::new(AST::Literal(3))),
            AST::While(
                Box::new(AST::Variable("x".to_string())),
                Box::new(AST::Sequence(vec![
                    AST::Assign(
                        "x".to_string(),
                        Box::new(AST::BinaryOp(
                            Box::new(AST::Variable("x".to_string())),
                            BinOp::Sub,
                            Box::new(AST::Literal(1)),
                        )),
                    ),
                ])),
            ),
            AST::Variable("x".to_string()),
        ]);
        let mut interp = Interpreter::new();
        let result = interp.eval(&ast);
        assert_eq!(result, 0);
    }

    #[test]
    fn test_print() {
        let ast = AST::Print(Box::new(AST::Literal(42)));
        let mut interp = Interpreter::new();
        interp.eval(&ast);
        assert_eq!(interp.output, vec!["42"]);
    }
}
```

## 6. ç›¸å…³ç†è®º

- ç¼–è¯‘åŸç†
- è™šæ‹Ÿæœºç†è®º
- æ“ä½œè¯­ä¹‰å­¦
- åŠ¨æ€åˆ†æç†è®º

## 7. å‚è€ƒæ–‡çŒ®

1. Aho, A. V., et al. "Compilers: Principles, Techniques, and Tools"
2. Norvig, P., Russell, S. "Artificial Intelligence: A Modern Approach"
3. Appel, A. W. "Modern Compiler Implementation in ML"
4. Felleisen, M., Friedman, D. P. "The Little Schemer"

---

**ç›¸å…³é“¾æ¥**ï¼š

- [08.2.1 ç¼–è¯‘åŸç†ç†è®º](../08.2.1_ç¼–è¯‘åŸç†ç†è®º.md)
- [08.2.2 ä»£ç ä¼˜åŒ–ç†è®º](../08.2.2_ä»£ç ä¼˜åŒ–ç†è®º.md)
- [08.2.3 è™šæ‹Ÿæœºç†è®º](../08.2.3_è™šæ‹Ÿæœºç†è®º.md)
