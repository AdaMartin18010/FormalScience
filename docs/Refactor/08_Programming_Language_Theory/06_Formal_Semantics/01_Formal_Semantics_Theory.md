# 08.6.1 å½¢å¼è¯­ä¹‰ç†è®º

## ğŸ“‹ æ¦‚è¿°

å½¢å¼è¯­ä¹‰ç†è®ºç ”ç©¶å¦‚ä½•ç”¨æ•°å­¦æ–¹æ³•ç²¾ç¡®å®šä¹‰ç¼–ç¨‹è¯­è¨€çš„è¯­ä¹‰ã€‚å¸¸è§æ–¹æ³•åŒ…æ‹¬æ“ä½œè¯­ä¹‰ã€è¯‘ä¹‰è¯­ä¹‰ã€å…¬ç†è¯­ä¹‰ç­‰ã€‚å½¢å¼è¯­ä¹‰ä¸ºç¨‹åºéªŒè¯ã€ç¼–è¯‘å™¨æ­£ç¡®æ€§å’Œè‡ªåŠ¨æ¨ç†æä¾›ç†è®ºåŸºç¡€ã€‚

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å½¢å¼è¯­ä¹‰å®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆå½¢å¼è¯­ä¹‰ï¼‰
å½¢å¼è¯­ä¹‰æ˜¯ç”¨æ•°å­¦ç»“æ„æè¿°ç¨‹åºè¡Œä¸ºçš„ç†è®ºä½“ç³»ã€‚

### 1.2 ä¸»è¦è¯­ä¹‰æ–¹æ³•

| æ–¹æ³•         | è‹±æ–‡åç§°         | æè¿°                         | å…¸å‹åº”ç”¨         |
|--------------|------------------|------------------------------|------------------|
| æ“ä½œè¯­ä¹‰     | Operational      | ä»¥çŠ¶æ€è½¬ç§»æè¿°æ‰§è¡Œè¿‡ç¨‹       | è§£é‡Šå™¨ã€åˆ†æå™¨   |
| è¯‘ä¹‰è¯­ä¹‰     | Denotational     | ä»¥æ•°å­¦å¯¹è±¡èµ‹äºˆç¨‹åºæ„ä¹‰       | ç¼–è¯‘å™¨ã€éªŒè¯å™¨   |
| å…¬ç†è¯­ä¹‰     | Axiomatic        | ä»¥é€»è¾‘æ–­è¨€æè¿°ç¨‹åºæ€§è´¨       | ç¨‹åºéªŒè¯         |

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ“ä½œè¯­ä¹‰

**å®šä¹‰ 2.1**ï¼ˆå°æ­¥æ“ä½œè¯­ä¹‰ï¼‰
å°æ­¥æ“ä½œè¯­ä¹‰ä»¥çŠ¶æ€è½¬ç§»ç³»ç»Ÿ $(C, \rightarrow)$ å½¢å¼æè¿°ç¨‹åºæ¯ä¸€æ­¥çš„æ‰§è¡Œã€‚

### 2.2 è¯‘ä¹‰è¯­ä¹‰

**å®šä¹‰ 2.2**ï¼ˆè¯‘ä¹‰è¯­ä¹‰ï¼‰
è¯‘ä¹‰è¯­ä¹‰ä¸ºæ¯ä¸ªç¨‹åº $P$ åˆ†é…ä¸€ä¸ªæ•°å­¦å¯¹è±¡ $\llbracket P \rrbracket$ã€‚

### 2.3 å…¬ç†è¯­ä¹‰

**å®šä¹‰ 2.3**ï¼ˆHoareä¸‰å…ƒç»„ï¼‰
Hoareä¸‰å…ƒç»„ $\{P\}\ S\ \{Q\}$ è¡¨ç¤ºï¼šè‹¥å‰ç½®æ¡ä»¶ $P$ æˆç«‹ï¼Œæ‰§è¡Œ $S$ å $Q$ æˆç«‹ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 è¯­ä¹‰ä¸€è‡´æ€§å®šç†

**å®šç† 3.1**ï¼ˆè¯­ä¹‰ä¸€è‡´æ€§ï¼‰
è‹¥æ“ä½œè¯­ä¹‰ä¸è¯‘ä¹‰è¯­ä¹‰èµ‹å€¼ä¸€è‡´ï¼Œåˆ™ä¸¤è€…ç­‰ä»·ã€‚

**è¯æ˜**ï¼š
å½’çº³ç¨‹åºç»“æ„ï¼Œé€æ­¥éªŒè¯ä¸¤ç§è¯­ä¹‰å®šä¹‰ä¸‹çš„è¡Œä¸ºä¸€è‡´ã€‚â–¡

### 3.2 æ­£ç¡®æ€§å®šç†

**å®šç† 3.2**ï¼ˆHoareé€»è¾‘æ­£ç¡®æ€§ï¼‰
è‹¥ $\{P\}\ S\ \{Q\}$ å¯è¯ï¼Œåˆ™ $S$ åœ¨ $P$ æˆç«‹æ—¶æ‰§è¡Œï¼Œè‹¥ç»ˆæ­¢åˆ™ $Q$ æˆç«‹ã€‚

**è¯æ˜**ï¼š
ç”±Hoareé€»è¾‘æ¨ç†è§„åˆ™é€’å½’åº”ç”¨å¯å¾—ã€‚â–¡

## 4. Rustä»£ç å®ç°

### 4.1 å°æ­¥æ“ä½œè¯­ä¹‰æ¨¡æ‹Ÿ

```rust
#[derive(Debug, Clone)]
pub enum Stmt {
    Skip,
    Assign(String, i32),
    Seq(Box<Stmt>, Box<Stmt>),
}

#[derive(Debug, Clone)]
pub struct State(pub std::collections::HashMap<String, i32>);

impl Stmt {
    pub fn step(&self, state: &mut State) -> Option<Stmt> {
        match self {
            Stmt::Skip => None,
            Stmt::Assign(var, val) => {
                state.0.insert(var.clone(), *val);
                Some(Stmt::Skip)
            },
            Stmt::Seq(s1, s2) => {
                if let Some(s1p) = s1.step(state) {
                    Some(Stmt::Seq(Box::new(s1p), s2.clone()))
                } else {
                    Some(*s2.clone())
                }
            },
        }
    }
}
```

### 4.2 Hoareä¸‰å…ƒç»„éªŒè¯ï¼ˆä¼ªä»£ç ï¼‰

```rust
struct HoareTriple<'a> {
    pre: Box<dyn Fn(&State) -> bool + 'a>,
    stmt: Stmt,
    post: Box<dyn Fn(&State) -> bool + 'a>,
}

impl<'a> HoareTriple<'a> {
    fn is_valid(&self, init: &State) -> bool {
        if !(self.pre)(init) {
            return true;
        }
        let mut state = init.clone();
        let mut stmt = self.stmt.clone();
        while let Some(next) = stmt.step(&mut state) {
            stmt = next;
        }
        (self.post)(&state)
    }
}
```

## 5. ç›¸å…³ç†è®ºä¸äº¤å‰å¼•ç”¨

- [è¯­è¨€è¯­ä¹‰ç†è®º](../02_Language_Semantics/01_Language_Semantics_Theory.md)
- [ç±»å‹ç³»ç»Ÿç†è®º](../03_Type_Systems/01_Type_Systems_Theory.md)
- [ç¼–è¯‘åŸç†ç†è®º](../04_Compilation_Theory/01_Compilation_Theory.md)

## 6. å‚è€ƒæ–‡çŒ®

1. Winskel, G. (1993). The Formal Semantics of Programming Languages. MIT Press.
2. Hennessy, M. (1990). The Semantics of Programming Languages. Wiley.
3. Hoare, C. A. R. (1969). An Axiomatic Basis for Computer Programming. Communications of the ACM.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ21æ—¥  
**ç»´æŠ¤è€…**: AIåŠ©æ‰‹  
**ç‰ˆæœ¬**: v1.0 