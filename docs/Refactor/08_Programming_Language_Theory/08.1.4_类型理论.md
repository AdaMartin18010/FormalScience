# 08.1.4 ç±»å‹ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç±»å‹ç†è®ºæ˜¯ç¼–ç¨‹è¯­è¨€ç†è®ºä¸­ç ”ç©¶ç±»å‹ç³»ç»Ÿå’Œç±»å‹å®‰å…¨çš„æ ¸å¿ƒç†è®ºä½“ç³»ï¼Œé€šè¿‡å»ºç«‹å½¢å¼åŒ–çš„ç±»å‹æ¡†æ¶ï¼Œä¸ºç¼–ç¨‹è¯­è¨€çš„ç±»å‹æ£€æŸ¥å’Œç±»å‹æ¨å¯¼æä¾›ç§‘å­¦ä¾æ®ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°Rustç±»å‹ç³»ç»Ÿç¤ºä¾‹
4. åˆ†æç±»å‹å®‰å…¨ä¸ç±»å‹æ¨å¯¼

## ğŸ“š ç›®å½•

1. åŸºæœ¬æ¦‚å¿µ
2. å½¢å¼åŒ–å®šä¹‰
3. å®šç†ä¸è¯æ˜
4. ä»£ç å®ç°
5. åº”ç”¨ç¤ºä¾‹
6. ç›¸å…³ç†è®º
7. å‚è€ƒæ–‡çŒ®

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç±»å‹å®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆç±»å‹ï¼‰
ç±»å‹æ˜¯å€¼çš„é›†åˆï¼Œæè¿°äº†å€¼çš„å½¢å¼å’Œå¯ä»¥å¯¹å…¶æ‰§è¡Œçš„æ“ä½œã€‚

### 1.2 ç±»å‹ç³»ç»Ÿåˆ†ç±»

- é™æ€ç±»å‹ç³»ç»Ÿï¼ˆStatic Type Systemï¼‰
- åŠ¨æ€ç±»å‹ç³»ç»Ÿï¼ˆDynamic Type Systemï¼‰
- å¼ºç±»å‹ç³»ç»Ÿï¼ˆStrong Type Systemï¼‰
- å¼±ç±»å‹ç³»ç»Ÿï¼ˆWeak Type Systemï¼‰

## 2. å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1**ï¼ˆç±»å‹ç³»ç»Ÿï¼‰
ç±»å‹ç³»ç»Ÿæ˜¯ä¸€ä¸ªå››å…ƒç»„ $TS = (T, R, C, \vdash)$ï¼Œå…¶ä¸­ï¼š

- $T$ æ˜¯ç±»å‹é›†åˆ
- $R$ æ˜¯ç±»å‹è§„åˆ™é›†åˆ
- $C$ æ˜¯ç±»å‹ä¸Šä¸‹æ–‡é›†åˆ
- $\vdash$ æ˜¯ç±»å‹åˆ¤æ–­å…³ç³»

**å®šä¹‰ 2.2**ï¼ˆç±»å‹åˆ¤æ–­ï¼‰
ç±»å‹åˆ¤æ–­çš„å½¢å¼ä¸º $\Gamma \vdash e : \tau$ï¼Œè¡¨ç¤ºåœ¨ä¸Šä¸‹æ–‡ $\Gamma$ ä¸­ï¼Œè¡¨è¾¾å¼ $e$ å…·æœ‰ç±»å‹ $\tau$ã€‚

**å®šç† 2.1**ï¼ˆç±»å‹å®‰å…¨æ€§ï¼‰
ç±»å‹å®‰å…¨çš„ç¨‹åºä¸ä¼šåœ¨è¿è¡Œæ—¶äº§ç”Ÿç±»å‹é”™è¯¯ã€‚

**è¯æ˜**ï¼š
é€šè¿‡ç±»å‹æ£€æŸ¥ç¡®ä¿æ‰€æœ‰æ“ä½œéƒ½åœ¨æ­£ç¡®çš„ç±»å‹ä¸Šè¿›è¡Œã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

**å®šç† 3.1**ï¼ˆè¿›å±•æ€§ï¼‰
ç±»å‹è‰¯å¥½çš„ç¨‹åºè¦ä¹ˆæ˜¯å€¼ï¼Œè¦ä¹ˆå¯ä»¥ç»§ç»­æ±‚å€¼ã€‚

**è¯æ˜**ï¼š
ç±»å‹è§„åˆ™ç¡®ä¿ç¨‹åºä¸ä¼šå¡åœ¨æ— æ„ä¹‰çš„ä¸­é—´çŠ¶æ€ã€‚$\square$

**å®šç† 3.2**ï¼ˆä¿æŒæ€§ï¼‰
ç±»å‹è‰¯å¥½çš„ç¨‹åºåœ¨æ±‚å€¼åä»ç„¶ç±»å‹è‰¯å¥½ã€‚

**è¯æ˜**ï¼š
ç±»å‹è§„åˆ™åœ¨æ±‚å€¼è¿‡ç¨‹ä¸­å¾—åˆ°ä¿æŒã€‚$\square$

## 4. ä»£ç å®ç°

```rust
use std::collections::HashMap;
use std::fmt;

/// ç±»å‹
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    Int,
    Bool,
    String,
    Unit,
    Function(Box<Type>, Box<Type>), // å‚æ•°ç±»å‹ -> è¿”å›ç±»å‹
    Tuple(Vec<Type>),
    List(Box<Type>),
    Option(Box<Type>),
    Generic(String, Vec<Type>), // æ³›å‹ç±»å‹
    Variable(String), // ç±»å‹å˜é‡
}

/// ç±»å‹ä¸Šä¸‹æ–‡
pub struct TypeContext {
    pub variables: HashMap<String, Type>,
    pub type_variables: HashMap<String, Type>,
}

/// ç±»å‹çº¦æŸ
pub struct TypeConstraint {
    pub left: Type,
    pub right: Type,
}

/// ç±»å‹æ›¿æ¢
pub struct TypeSubstitution {
    pub mappings: HashMap<String, Type>,
}

/// ç±»å‹æ£€æŸ¥å™¨
pub struct TypeChecker {
    pub context: TypeContext,
    pub constraints: Vec<TypeConstraint>,
}

/// ç±»å‹æ¨å¯¼å™¨
pub struct TypeInferrer {
    pub checker: TypeChecker,
    pub substitution: TypeSubstitution,
}

/// è¡¨è¾¾å¼
#[derive(Debug, Clone)]
pub enum Expression {
    Literal(Literal),
    Variable(String),
    BinaryOp(Box<Expression>, BinaryOperator, Box<Expression>),
    UnaryOp(UnaryOperator, Box<Expression>),
    If(Box<Expression>, Box<Expression>, Box<Expression>),
    Let(String, Box<Expression>, Box<Expression>),
    Function(String, Box<Expression>),
    Application(Box<Expression>, Box<Expression>),
    Tuple(Vec<Expression>),
    List(Vec<Expression>),
    Match(Box<Expression>, Vec<Pattern>),
}

/// å­—é¢é‡
#[derive(Debug, Clone)]
pub enum Literal {
    Integer(i64),
    Boolean(bool),
    String(String),
    Unit,
}

/// äºŒå…ƒæ“ä½œç¬¦
#[derive(Debug, Clone, PartialEq)]
pub enum BinaryOperator {
    Add,
    Subtract,
    Multiply,
    Divide,
    Equal,
    LessThan,
    GreaterThan,
    And,
    Or,
}

/// ä¸€å…ƒæ“ä½œç¬¦
#[derive(Debug, Clone, PartialEq)]
pub enum UnaryOperator {
    Not,
    Negate,
}

/// æ¨¡å¼
#[derive(Debug, Clone)]
pub enum Pattern {
    Literal(Literal),
    Variable(String),
    Tuple(Vec<Pattern>),
    Constructor(String, Vec<Pattern>),
    Wildcard,
}

impl TypeContext {
    pub fn new() -> Self {
        Self {
            variables: HashMap::new(),
            type_variables: HashMap::new(),
        }
    }
    
    pub fn add_variable(&mut self, name: String, type_: Type) {
        self.variables.insert(name, type_);
    }
    
    pub fn get_variable(&self, name: &str) -> Option<&Type> {
        self.variables.get(name)
    }
    
    pub fn add_type_variable(&mut self, name: String, type_: Type) {
        self.type_variables.insert(name, type_);
    }
    
    pub fn get_type_variable(&self, name: &str) -> Option<&Type> {
        self.type_variables.get(name)
    }
}

impl TypeChecker {
    pub fn new() -> Self {
        Self {
            context: TypeContext::new(),
            constraints: Vec::new(),
        }
    }
    
    /// ç±»å‹æ£€æŸ¥è¡¨è¾¾å¼
    pub fn type_check(&mut self, expr: &Expression) -> Result<Type, String> {
        match expr {
            Expression::Literal(literal) => self.type_check_literal(literal),
            
            Expression::Variable(name) => {
                self.context.get_variable(name)
                    .cloned()
                    .ok_or_else(|| format!("Undefined variable: {}", name))
            }
            
            Expression::BinaryOp(left, op, right) => {
                self.type_check_binary_op(left, op, right)
            }
            
            Expression::UnaryOp(op, operand) => {
                self.type_check_unary_op(op, operand)
            }
            
            Expression::If(condition, then_expr, else_expr) => {
                self.type_check_if(condition, then_expr, else_expr)
            }
            
            Expression::Let(name, value_expr, body_expr) => {
                self.type_check_let(name, value_expr, body_expr)
            }
            
            Expression::Function(param, body) => {
                self.type_check_function(param, body)
            }
            
            Expression::Application(func, arg) => {
                self.type_check_application(func, arg)
            }
            
            Expression::Tuple(expressions) => {
                self.type_check_tuple(expressions)
            }
            
            Expression::List(expressions) => {
                self.type_check_list(expressions)
            }
            
            Expression::Match(expr, patterns) => {
                self.type_check_match(expr, patterns)
            }
        }
    }
    
    /// ç±»å‹æ£€æŸ¥å­—é¢é‡
    fn type_check_literal(&self, literal: &Literal) -> Result<Type, String> {
        match literal {
            Literal::Integer(_) => Ok(Type::Int),
            Literal::Boolean(_) => Ok(Type::Bool),
            Literal::String(_) => Ok(Type::String),
            Literal::Unit => Ok(Type::Unit),
        }
    }
    
    /// ç±»å‹æ£€æŸ¥äºŒå…ƒæ“ä½œ
    fn type_check_binary_op(&mut self, left: &Expression, op: &BinaryOperator, right: &Expression) -> Result<Type, String> {
        let left_type = self.type_check(left)?;
        let right_type = self.type_check(right)?;
        
        match op {
            BinaryOperator::Add | BinaryOperator::Subtract | BinaryOperator::Multiply | BinaryOperator::Divide => {
                if left_type == Type::Int && right_type == Type::Int {
                    Ok(Type::Int)
                } else {
                    Err(format!("Cannot apply {:?} to types {:?} and {:?}", op, left_type, right_type))
                }
            }
            
            BinaryOperator::Equal => {
                if left_type == right_type {
                    Ok(Type::Bool)
                } else {
                    Err(format!("Cannot compare types {:?} and {:?}", left_type, right_type))
                }
            }
            
            BinaryOperator::LessThan | BinaryOperator::GreaterThan => {
                if left_type == Type::Int && right_type == Type::Int {
                    Ok(Type::Bool)
                } else {
                    Err(format!("Cannot compare types {:?} and {:?}", left_type, right_type))
                }
            }
            
            BinaryOperator::And | BinaryOperator::Or => {
                if left_type == Type::Bool && right_type == Type::Bool {
                    Ok(Type::Bool)
                } else {
                    Err(format!("Cannot apply {:?} to types {:?} and {:?}", op, left_type, right_type))
                }
            }
        }
    }
    
    /// ç±»å‹æ£€æŸ¥ä¸€å…ƒæ“ä½œ
    fn type_check_unary_op(&mut self, op: &UnaryOperator, operand: &Expression) -> Result<Type, String> {
        let operand_type = self.type_check(operand)?;
        
        match op {
            UnaryOperator::Not => {
                if operand_type == Type::Bool {
                    Ok(Type::Bool)
                } else {
                    Err(format!("Cannot apply NOT to type {:?}", operand_type))
                }
            }
            
            UnaryOperator::Negate => {
                if operand_type == Type::Int {
                    Ok(Type::Int)
                } else {
                    Err(format!("Cannot negate type {:?}", operand_type))
                }
            }
        }
    }
    
    /// ç±»å‹æ£€æŸ¥ifè¡¨è¾¾å¼
    fn type_check_if(&mut self, condition: &Expression, then_expr: &Expression, else_expr: &Expression) -> Result<Type, String> {
        let condition_type = self.type_check(condition)?;
        if condition_type != Type::Bool {
            return Err("Condition must be boolean".to_string());
        }
        
        let then_type = self.type_check(then_expr)?;
        let else_type = self.type_check(else_expr)?;
        
        if then_type == else_type {
            Ok(then_type)
        } else {
            Err(format!("If branches must have same type: {:?} vs {:?}", then_type, else_type))
        }
    }
    
    /// ç±»å‹æ£€æŸ¥letè¡¨è¾¾å¼
    fn type_check_let(&mut self, name: &str, value_expr: &Expression, body_expr: &Expression) -> Result<Type, String> {
        let value_type = self.type_check(value_expr)?;
        self.context.add_variable(name.to_string(), value_type.clone());
        let body_type = self.type_check(body_expr)?;
        Ok(body_type)
    }
    
    /// ç±»å‹æ£€æŸ¥å‡½æ•°
    fn type_check_function(&mut self, param: &str, body: &Expression) -> Result<Type, String> {
        // ä¸ºå‚æ•°åˆ†é…ä¸€ä¸ªç±»å‹å˜é‡
        let param_type = Type::Variable(format!("Î±_{}", param));
        self.context.add_variable(param.to_string(), param_type.clone());
        
        let body_type = self.type_check(body)?;
        Ok(Type::Function(Box::new(param_type), Box::new(body_type)))
    }
    
    /// ç±»å‹æ£€æŸ¥å‡½æ•°åº”ç”¨
    fn type_check_application(&mut self, func: &Expression, arg: &Expression) -> Result<Type, String> {
        let func_type = self.type_check(func)?;
        let arg_type = self.type_check(arg)?;
        
        match func_type {
            Type::Function(param_type, return_type) => {
                if *param_type == arg_type {
                    Ok(*return_type)
                } else {
                    Err(format!("Function expects {:?}, got {:?}", param_type, arg_type))
                }
            }
            _ => Err("Expression is not a function".to_string()),
        }
    }
    
    /// ç±»å‹æ£€æŸ¥å…ƒç»„
    fn type_check_tuple(&mut self, expressions: &[Expression]) -> Result<Type, String> {
        let mut types = Vec::new();
        for expr in expressions {
            types.push(self.type_check(expr)?);
        }
        Ok(Type::Tuple(types))
    }
    
    /// ç±»å‹æ£€æŸ¥åˆ—è¡¨
    fn type_check_list(&mut self, expressions: &[Expression]) -> Result<Type, String> {
        if expressions.is_empty() {
            return Ok(Type::List(Box::new(Type::Variable("Î±".to_string()))));
        }
        
        let first_type = self.type_check(&expressions[0])?;
        for expr in &expressions[1..] {
            let expr_type = self.type_check(expr)?;
            if expr_type != first_type {
                return Err("List elements must have same type".to_string());
            }
        }
        
        Ok(Type::List(Box::new(first_type)))
    }
    
    /// ç±»å‹æ£€æŸ¥æ¨¡å¼åŒ¹é…
    fn type_check_match(&mut self, expr: &Expression, patterns: &[Pattern]) -> Result<Type, String> {
        let expr_type = self.type_check(expr)?;
        
        // ç®€åŒ–çš„æ¨¡å¼åŒ¹é…ç±»å‹æ£€æŸ¥
        // å®é™…å®ç°éœ€è¦æ›´å¤æ‚çš„æ¨¡å¼ç±»å‹æ£€æŸ¥
        Ok(Type::Unit)
    }
}

impl TypeInferrer {
    pub fn new() -> Self {
        Self {
            checker: TypeChecker::new(),
            substitution: TypeSubstitution::new(),
        }
    }
    
    /// ç±»å‹æ¨å¯¼
    pub fn infer_type(&mut self, expr: &Expression) -> Result<Type, String> {
        let type_var = self.fresh_type_variable();
        self.infer_expression(expr, &type_var)?;
        
        // è§£çº¦æŸ
        let final_type = self.solve_constraints(&type_var)?;
        Ok(final_type)
    }
    
    /// æ¨å¯¼è¡¨è¾¾å¼ç±»å‹
    fn infer_expression(&mut self, expr: &Expression, expected_type: &Type) -> Result<(), String> {
        match expr {
            Expression::Literal(literal) => {
                let literal_type = self.checker.type_check_literal(literal)?;
                self.unify(&literal_type, expected_type)?;
            }
            
            Expression::Variable(name) => {
                if let Some(var_type) = self.checker.context.get_variable(name) {
                    self.unify(var_type, expected_type)?;
                } else {
                    // æœªå®šä¹‰çš„å˜é‡ï¼Œåˆ†é…æ–°çš„ç±»å‹å˜é‡
                    let new_type = Type::Variable(format!("Î±_{}", name));
                    self.checker.context.add_variable(name.clone(), new_type.clone());
                    self.unify(&new_type, expected_type)?;
                }
            }
            
            Expression::BinaryOp(left, op, right) => {
                let left_type = self.fresh_type_variable();
                let right_type = self.fresh_type_variable();
                
                self.infer_expression(left, &left_type)?;
                self.infer_expression(right, &right_type)?;
                
                let result_type = self.infer_binary_op_type(op, &left_type, &right_type)?;
                self.unify(&result_type, expected_type)?;
            }
            
            Expression::Function(param, body) => {
                let param_type = self.fresh_type_variable();
                let body_type = self.fresh_type_variable();
                
                self.checker.context.add_variable(param.clone(), param_type.clone());
                self.infer_expression(body, &body_type)?;
                
                let func_type = Type::Function(Box::new(param_type), Box::new(body_type));
                self.unify(&func_type, expected_type)?;
            }
            
            Expression::Application(func, arg) => {
                let func_type = self.fresh_type_variable();
                let arg_type = self.fresh_type_variable();
                let result_type = self.fresh_type_variable();
                
                self.infer_expression(func, &func_type)?;
                self.infer_expression(arg, &arg_type)?;
                
                let expected_func_type = Type::Function(Box::new(arg_type), Box::new(result_type.clone()));
                self.unify(&func_type, &expected_func_type)?;
                self.unify(&result_type, expected_type)?;
            }
            
            _ => {
                // ç®€åŒ–å¤„ç†å…¶ä»–è¡¨è¾¾å¼
                let inferred_type = self.checker.type_check(expr)?;
                self.unify(&inferred_type, expected_type)?;
            }
        }
        
        Ok(())
    }
    
    /// æ¨å¯¼äºŒå…ƒæ“ä½œç±»å‹
    fn infer_binary_op_type(&self, op: &BinaryOperator, left_type: &Type, right_type: &Type) -> Result<Type, String> {
        match op {
            BinaryOperator::Add | BinaryOperator::Subtract | BinaryOperator::Multiply | BinaryOperator::Divide => {
                self.unify(left_type, &Type::Int)?;
                self.unify(right_type, &Type::Int)?;
                Ok(Type::Int)
            }
            
            BinaryOperator::Equal => {
                self.unify(left_type, right_type)?;
                Ok(Type::Bool)
            }
            
            BinaryOperator::LessThan | BinaryOperator::GreaterThan => {
                self.unify(left_type, &Type::Int)?;
                self.unify(right_type, &Type::Int)?;
                Ok(Type::Bool)
            }
            
            BinaryOperator::And | BinaryOperator::Or => {
                self.unify(left_type, &Type::Bool)?;
                self.unify(right_type, &Type::Bool)?;
                Ok(Type::Bool)
            }
        }
    }
    
    /// ç»Ÿä¸€ç±»å‹
    fn unify(&mut self, type1: &Type, type2: &Type) -> Result<(), String> {
        let constraint = TypeConstraint {
            left: type1.clone(),
            right: type2.clone(),
        };
        self.checker.constraints.push(constraint);
        Ok(())
    }
    
    /// è§£çº¦æŸ
    fn solve_constraints(&mut self, type_var: &Type) -> Result<Type, String> {
        // ç®€åŒ–çš„çº¦æŸæ±‚è§£
        // å®é™…å®ç°éœ€è¦æ›´å¤æ‚çš„ç»Ÿä¸€ç®—æ³•
        
        for constraint in &self.checker.constraints {
            if constraint.left == *type_var {
                return Ok(constraint.right.clone());
            }
            if constraint.right == *type_var {
                return Ok(constraint.left.clone());
            }
        }
        
        Ok(type_var.clone())
    }
    
    /// ç”Ÿæˆæ–°çš„ç±»å‹å˜é‡
    fn fresh_type_variable(&mut self) -> Type {
        static mut COUNTER: u32 = 0;
        unsafe {
            COUNTER += 1;
            Type::Variable(format!("Î±_{}", COUNTER))
        }
    }
}

impl TypeSubstitution {
    pub fn new() -> Self {
        Self {
            mappings: HashMap::new(),
        }
    }
    
    pub fn add_mapping(&mut self, var: String, type_: Type) {
        self.mappings.insert(var, type_);
    }
    
    pub fn apply(&self, type_: &Type) -> Type {
        match type_ {
            Type::Variable(name) => {
                self.mappings.get(name).cloned().unwrap_or(type_.clone())
            }
            Type::Function(param, ret) => {
                Type::Function(
                    Box::new(self.apply(param)),
                    Box::new(self.apply(ret))
                )
            }
            Type::Tuple(types) => {
                Type::Tuple(types.iter().map(|t| self.apply(t)).collect())
            }
            Type::List(element_type) => {
                Type::List(Box::new(self.apply(element_type)))
            }
            Type::Option(element_type) => {
                Type::Option(Box::new(self.apply(element_type)))
            }
            Type::Generic(name, type_args) => {
                Type::Generic(name.clone(), type_args.iter().map(|t| self.apply(t)).collect())
            }
            _ => type_.clone(),
        }
    }
}

/// ç±»å‹ç³»ç»Ÿåˆ†æå™¨
pub struct TypeSystemAnalyzer {
    pub checker: TypeChecker,
    pub inferrer: TypeInferrer,
}

impl TypeSystemAnalyzer {
    pub fn new() -> Self {
        Self {
            checker: TypeChecker::new(),
            inferrer: TypeInferrer::new(),
        }
    }
    
    /// åˆ†æè¡¨è¾¾å¼ç±»å‹
    pub fn analyze_expression(&mut self, expr: &Expression) -> TypeAnalysis {
        let mut analysis = TypeAnalysis {
            inferred_type: None,
            checked_type: None,
            constraints: Vec::new(),
            errors: Vec::new(),
        };
        
        // ç±»å‹æ¨å¯¼
        match self.inferrer.infer_type(expr) {
            Ok(type_) => analysis.inferred_type = Some(type_),
            Err(error) => analysis.errors.push(format!("Inference: {}", error)),
        }
        
        // ç±»å‹æ£€æŸ¥
        match self.checker.type_check(expr) {
            Ok(type_) => analysis.checked_type = Some(type_),
            Err(error) => analysis.errors.push(format!("Checking: {}", error)),
        }
        
        // æ”¶é›†çº¦æŸ
        analysis.constraints = self.inferrer.checker.constraints.clone();
        
        analysis
    }
    
    /// éªŒè¯ç±»å‹å®‰å…¨
    pub fn verify_type_safety(&self, expr: &Expression) -> bool {
        self.checker.type_check(expr).is_ok()
    }
    
    /// ç”Ÿæˆç±»å‹ç¯å¢ƒ
    pub fn generate_type_environment(&self) -> TypeEnvironment {
        TypeEnvironment {
            variables: self.checker.context.variables.clone(),
            type_variables: self.checker.context.type_variables.clone(),
        }
    }
}

/// ç±»å‹åˆ†æç»“æœ
pub struct TypeAnalysis {
    pub inferred_type: Option<Type>,
    pub checked_type: Option<Type>,
    pub constraints: Vec<TypeConstraint>,
    pub errors: Vec<String>,
}

/// ç±»å‹ç¯å¢ƒ
pub struct TypeEnvironment {
    pub variables: HashMap<String, Type>,
    pub type_variables: HashMap<String, Type>,
}

impl fmt::Display for Type {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Type::Int => write!(f, "Int"),
            Type::Bool => write!(f, "Bool"),
            Type::String => write!(f, "String"),
            Type::Unit => write!(f, "Unit"),
            Type::Function(param, ret) => write!(f, "({} -> {})", param, ret),
            Type::Tuple(types) => {
                write!(f, "(")?;
                for (i, type_) in types.iter().enumerate() {
                    if i > 0 { write!(f, ", ")?; }
                    write!(f, "{}", type_)?;
                }
                write!(f, ")")
            }
            Type::List(element_type) => write!(f, "[{}]", element_type),
            Type::Option(element_type) => write!(f, "Option<{}>", element_type),
            Type::Generic(name, type_args) => {
                write!(f, "{}<", name)?;
                for (i, type_arg) in type_args.iter().enumerate() {
                    if i > 0 { write!(f, ", ")?; }
                    write!(f, "{}", type_arg)?;
                }
                write!(f, ">")
            }
            Type::Variable(name) => write!(f, "{}", name),
        }
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_type_checking() {
        let mut checker = TypeChecker::new();
        
        // æµ‹è¯•å­—é¢é‡ç±»å‹æ£€æŸ¥
        let literal = Expression::Literal(Literal::Integer(42));
        let result = checker.type_check(&literal);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), Type::Int);
        
        // æµ‹è¯•äºŒå…ƒæ“ä½œç±»å‹æ£€æŸ¥
        let binary_op = Expression::BinaryOp(
            Box::new(Expression::Literal(Literal::Integer(5))),
            BinaryOperator::Add,
            Box::new(Expression::Literal(Literal::Integer(3)))
        );
        let result = checker.type_check(&binary_op);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), Type::Int);
    }
    
    #[test]
    fn test_type_inference() {
        let mut inferrer = TypeInferrer::new();
        
        // æµ‹è¯•ç±»å‹æ¨å¯¼
        let expr = Expression::BinaryOp(
            Box::new(Expression::Literal(Literal::Integer(10))),
            BinaryOperator::Add,
            Box::new(Expression::Literal(Literal::Integer(20)))
        );
        
        let result = inferrer.infer_type(&expr);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), Type::Int);
    }
    
    #[test]
    fn test_function_types() {
        let mut checker = TypeChecker::new();
        
        // æµ‹è¯•å‡½æ•°ç±»å‹
        let function = Expression::Function(
            "x".to_string(),
            Box::new(Expression::Variable("x".to_string()))
        );
        
        let result = checker.type_check(&function);
        assert!(result.is_ok());
        
        if let Type::Function(param_type, ret_type) = result.unwrap() {
            assert_eq!(*param_type, Type::Variable("Î±_x".to_string()));
            assert_eq!(*ret_type, Type::Variable("Î±_x".to_string()));
        } else {
            panic!("Expected function type");
        }
    }
    
    #[test]
    fn test_type_errors() {
        let mut checker = TypeChecker::new();
        
        // æµ‹è¯•ç±»å‹é”™è¯¯
        let invalid_op = Expression::BinaryOp(
            Box::new(Expression::Literal(Literal::Integer(5))),
            BinaryOperator::Add,
            Box::new(Expression::Literal(Literal::Boolean(true)))
        );
        
        let result = checker.type_check(&invalid_op);
        assert!(result.is_err());
    }
    
    #[test]
    fn test_type_analysis() {
        let mut analyzer = TypeSystemAnalyzer::new();
        
        let expr = Expression::If(
            Box::new(Expression::Literal(Literal::Boolean(true))),
            Box::new(Expression::Literal(Literal::Integer(42))),
            Some(Box::new(Expression::Literal(Literal::Integer(0))))
        );
        
        let analysis = analyzer.analyze_expression(&expr);
        assert!(analysis.inferred_type.is_some());
        assert!(analysis.checked_type.is_some());
        assert!(analysis.errors.is_empty());
    }
    
    #[test]
    fn test_type_safety() {
        let analyzer = TypeSystemAnalyzer::new();
        
        let safe_expr = Expression::Literal(Literal::Integer(42));
        assert!(analyzer.verify_type_safety(&safe_expr));
        
        let unsafe_expr = Expression::BinaryOp(
            Box::new(Expression::Literal(Literal::Integer(5))),
            BinaryOperator::Add,
            Box::new(Expression::Literal(Literal::Boolean(true)))
        );
        assert!(!analyzer.verify_type_safety(&unsafe_expr));
    }
    
    #[test]
    fn test_type_substitution() {
        let mut substitution = TypeSubstitution::new();
        substitution.add_mapping("Î±".to_string(), Type::Int);
        
        let type_var = Type::Variable("Î±".to_string());
        let substituted = substitution.apply(&type_var);
        assert_eq!(substituted, Type::Int);
    }
    
    #[test]
    fn test_complex_types() {
        let mut checker = TypeChecker::new();
        
        // æµ‹è¯•å…ƒç»„ç±»å‹
        let tuple = Expression::Tuple(vec![
            Expression::Literal(Literal::Integer(1)),
            Expression::Literal(Literal::Boolean(true)),
        ]);
        
        let result = checker.type_check(&tuple);
        assert!(result.is_ok());
        
        if let Type::Tuple(types) = result.unwrap() {
            assert_eq!(types.len(), 2);
            assert_eq!(types[0], Type::Int);
            assert_eq!(types[1], Type::Bool);
        } else {
            panic!("Expected tuple type");
        }
    }
}
```

## 6. ç›¸å…³ç†è®º

- ç±»å‹ç³»ç»Ÿç†è®º
- ç±»å‹æ¨å¯¼ç†è®º
- ç±»å‹å®‰å…¨ç†è®º
- å¤šæ€ç†è®º

## 7. å‚è€ƒæ–‡çŒ®

1. Pierce, B. C. "Types and Programming Languages"
2. Cardelli, L., Wegner, P. "On Understanding Types, Data Abstraction, and Polymorphism"
3. Milner, R. "A Theory of Type Polymorphism in Programming"
4. Reynolds, J. C. "Towards a Theory of Type Structure"

---

**ç›¸å…³é“¾æ¥**ï¼š

- [08.1.1 è¯­è¨€è®¾è®¡ç†è®º](../08.1.1_è¯­è¨€è®¾è®¡ç†è®º.md)
- [08.1.2 è¯­æ³•ç†è®º](../08.1.2_è¯­æ³•ç†è®º.md)
- [08.1.3 è¯­ä¹‰ç†è®º](../08.1.3_è¯­ä¹‰ç†è®º.md)
