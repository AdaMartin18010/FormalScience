# 08.1.2 è¯­æ³•ç†è®º

## ğŸ“‹ æ¦‚è¿°

è¯­æ³•ç†è®ºæ˜¯ç¼–ç¨‹è¯­è¨€ç†è®ºä¸­ç ”ç©¶è¯­è¨€è¯­æ³•ç»“æ„å’Œè§„åˆ™çš„æ ¸å¿ƒç†è®ºä½“ç³»ï¼Œé€šè¿‡å»ºç«‹å½¢å¼åŒ–çš„è¯­æ³•æ¡†æ¶ï¼Œä¸ºç¼–ç¨‹è¯­è¨€çš„è¯­æ³•åˆ†æå’Œè§£ææä¾›ç§‘å­¦ä¾æ®ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ç¼–ç¨‹è¯­è¨€è¯­æ³•çš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°Rustè¯­æ³•åˆ†æç¤ºä¾‹
4. åˆ†æè¯­æ³•è§„åˆ™ä¸è§£æç®—æ³•

## ğŸ“š ç›®å½•

1. åŸºæœ¬æ¦‚å¿µ
2. å½¢å¼åŒ–å®šä¹‰
3. å®šç†ä¸è¯æ˜
4. ä»£ç å®ç°
5. åº”ç”¨ç¤ºä¾‹
6. ç›¸å…³ç†è®º
7. å‚è€ƒæ–‡çŒ®

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è¯­æ³•å®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆè¯­æ³•ï¼‰
è¯­æ³•æ˜¯æè¿°è¯­è¨€ç»“æ„çš„å½¢å¼åŒ–è§„åˆ™é›†åˆï¼Œå®šä¹‰äº†å¦‚ä½•ä»åŸºæœ¬ç¬¦å·æ„é€ æœ‰æ•ˆçš„ç¨‹åºã€‚

### 1.2 è¯­æ³•åˆ†ç±»

- ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ï¼ˆContext-Free Grammarï¼‰
- æ­£åˆ™æ–‡æ³•ï¼ˆRegular Grammarï¼‰
- ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•ï¼ˆContext-Sensitive Grammarï¼‰
- æ— é™åˆ¶æ–‡æ³•ï¼ˆUnrestricted Grammarï¼‰

## 2. å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1**ï¼ˆä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ï¼‰
ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ $G = (N, T, P, S)$ï¼Œå…¶ä¸­ï¼š

- $N$ æ˜¯éç»ˆç»“ç¬¦é›†åˆ
- $T$ æ˜¯ç»ˆç»“ç¬¦é›†åˆ
- $P$ æ˜¯äº§ç”Ÿå¼è§„åˆ™é›†åˆ
- $S$ æ˜¯å¼€å§‹ç¬¦å·

**å®šä¹‰ 2.2**ï¼ˆäº§ç”Ÿå¼è§„åˆ™ï¼‰
äº§ç”Ÿå¼è§„åˆ™ $p \in P$ çš„å½¢å¼ä¸º $A \rightarrow \alpha$ï¼Œå…¶ä¸­ $A \in N$ï¼Œ$\alpha \in (N \cup T)^*$ã€‚

**å®šç† 2.1**ï¼ˆè¯­æ³•åˆ†ææ€§ï¼‰
ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•èƒ½å¤Ÿè¢«é«˜æ•ˆåœ°è§£æã€‚

**è¯æ˜**ï¼š
ä½¿ç”¨LL(k)æˆ–LR(k)è§£æç®—æ³•ï¼Œå¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…è§£æä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

**å®šç† 3.1**ï¼ˆè¯­æ³•æ­§ä¹‰æ€§ï¼‰
æŸäº›ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•å­˜åœ¨æ­§ä¹‰æ€§ã€‚

**è¯æ˜**ï¼š
ä¾‹å¦‚æ–‡æ³• $S \rightarrow S + S | S * S | (S) | a$ å¯¹äºè¡¨è¾¾å¼ $a + a * a$ å­˜åœ¨ä¸¤ç§ä¸åŒçš„è§£ææ ‘ã€‚$\square$

**å®šç† 3.2**ï¼ˆè¯­æ³•å±‚æ¬¡æ€§ï¼‰
ä¸åŒç±»å‹çš„æ–‡æ³•å½¢æˆä¸¥æ ¼çš„å±‚æ¬¡ç»“æ„ã€‚

**è¯æ˜**ï¼š
æ­£åˆ™æ–‡æ³• $\subset$ ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³• $\subset$ ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³• $\subset$ æ— é™åˆ¶æ–‡æ³•ã€‚$\square$

## 4. ä»£ç å®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::fmt;

/// ç¬¦å·ç±»å‹
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Symbol {
    Terminal(String),
    NonTerminal(String),
}

/// äº§ç”Ÿå¼è§„åˆ™
pub struct Production {
    pub left: String,
    pub right: Vec<Symbol>,
}

/// ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•
pub struct ContextFreeGrammar {
    pub non_terminals: HashSet<String>,
    pub terminals: HashSet<String>,
    pub productions: Vec<Production>,
    pub start_symbol: String,
}

/// è¯­æ³•åˆ†ææ ‘èŠ‚ç‚¹
pub struct ParseTreeNode {
    pub symbol: Symbol,
    pub children: Vec<ParseTreeNode>,
    pub value: Option<String>,
}

/// è¯­æ³•åˆ†æå™¨
pub struct Parser {
    pub grammar: ContextFreeGrammar,
    pub first_sets: HashMap<String, HashSet<String>>,
    pub follow_sets: HashMap<String, HashSet<String>>,
}

/// LL(1)è§£æè¡¨
pub struct LL1ParseTable {
    pub table: HashMap<(String, String), Vec<Symbol>>,
}

/// LRè§£æå™¨çŠ¶æ€
pub struct LRState {
    pub id: u32,
    pub items: Vec<LRItem>,
    pub actions: HashMap<String, LRAction>,
    pub gotos: HashMap<String, u32>,
}

/// LRé¡¹ç›®
pub struct LRItem {
    pub production: Production,
    pub dot_position: usize,
    pub lookahead: String,
}

/// LRåŠ¨ä½œ
#[derive(Debug, Clone)]
pub enum LRAction {
    Shift(u32),
    Reduce(Production),
    Accept,
    Error,
}

impl ContextFreeGrammar {
    pub fn new(start_symbol: String) -> Self {
        Self {
            non_terminals: HashSet::new(),
            terminals: HashSet::new(),
            productions: Vec::new(),
            start_symbol,
        }
    }
    
    /// æ·»åŠ éç»ˆç»“ç¬¦
    pub fn add_non_terminal(&mut self, symbol: String) {
        self.non_terminals.insert(symbol);
    }
    
    /// æ·»åŠ ç»ˆç»“ç¬¦
    pub fn add_terminal(&mut self, symbol: String) {
        self.terminals.insert(symbol);
    }
    
    /// æ·»åŠ äº§ç”Ÿå¼è§„åˆ™
    pub fn add_production(&mut self, left: String, right: Vec<Symbol>) {
        self.productions.push(Production { left, right });
    }
    
    /// æ£€æŸ¥æ–‡æ³•æ˜¯å¦åˆæ³•
    pub fn is_valid(&self) -> bool {
        // æ£€æŸ¥å¼€å§‹ç¬¦å·æ˜¯å¦åœ¨éç»ˆç»“ç¬¦ä¸­
        if !self.non_terminals.contains(&self.start_symbol) {
            return false;
        }
        
        // æ£€æŸ¥æ‰€æœ‰äº§ç”Ÿå¼è§„åˆ™
        for production in &self.productions {
            if !self.non_terminals.contains(&production.left) {
                return false;
            }
            
            for symbol in &production.right {
                match symbol {
                    Symbol::Terminal(t) => {
                        if !self.terminals.contains(t) {
                            return false;
                        }
                    }
                    Symbol::NonTerminal(nt) => {
                        if !self.non_terminals.contains(nt) {
                            return false;
                        }
                    }
                }
            }
        }
        
        true
    }
    
    /// ç”Ÿæˆç¤ºä¾‹æ–‡æ³•
    pub fn create_arithmetic_grammar() -> Self {
        let mut grammar = ContextFreeGrammar::new("E".to_string());
        
        // æ·»åŠ éç»ˆç»“ç¬¦
        grammar.add_non_terminal("E".to_string());
        grammar.add_non_terminal("T".to_string());
        grammar.add_non_terminal("F".to_string());
        
        // æ·»åŠ ç»ˆç»“ç¬¦
        grammar.add_terminal("+".to_string());
        grammar.add_terminal("*".to_string());
        grammar.add_terminal("(".to_string());
        grammar.add_terminal(")".to_string());
        grammar.add_terminal("id".to_string());
        
        // æ·»åŠ äº§ç”Ÿå¼è§„åˆ™
        grammar.add_production("E".to_string(), vec![
            Symbol::NonTerminal("T".to_string()),
            Symbol::Terminal("+".to_string()),
            Symbol::NonTerminal("E".to_string()),
        ]);
        grammar.add_production("E".to_string(), vec![
            Symbol::NonTerminal("T".to_string()),
        ]);
        
        grammar.add_production("T".to_string(), vec![
            Symbol::NonTerminal("F".to_string()),
            Symbol::Terminal("*".to_string()),
            Symbol::NonTerminal("T".to_string()),
        ]);
        grammar.add_production("T".to_string(), vec![
            Symbol::NonTerminal("F".to_string()),
        ]);
        
        grammar.add_production("F".to_string(), vec![
            Symbol::Terminal("(".to_string()),
            Symbol::NonTerminal("E".to_string()),
            Symbol::Terminal(")".to_string()),
        ]);
        grammar.add_production("F".to_string(), vec![
            Symbol::Terminal("id".to_string()),
        ]);
        
        grammar
    }
}

impl Parser {
    pub fn new(grammar: ContextFreeGrammar) -> Self {
        let mut parser = Self {
            grammar,
            first_sets: HashMap::new(),
            follow_sets: HashMap::new(),
        };
        
        parser.compute_first_sets();
        parser.compute_follow_sets();
        
        parser
    }
    
    /// è®¡ç®—FIRSTé›†åˆ
    fn compute_first_sets(&mut self) {
        // åˆå§‹åŒ–FIRSTé›†åˆ
        for terminal in &self.grammar.terminals {
            let mut first_set = HashSet::new();
            first_set.insert(terminal.clone());
            self.first_sets.insert(terminal.clone(), first_set);
        }
        
        for non_terminal in &self.grammar.non_terminals {
            self.first_sets.insert(non_terminal.clone(), HashSet::new());
        }
        
        // è¿­ä»£è®¡ç®—FIRSTé›†åˆ
        let mut changed = true;
        while changed {
            changed = false;
            
            for production in &self.grammar.productions {
                let left = &production.left;
                let first_set = self.first_sets.get_mut(left).unwrap();
                
                if let Some(symbol) = production.right.first() {
                    match symbol {
                        Symbol::Terminal(t) => {
                            if first_set.insert(t.clone()) {
                                changed = true;
                            }
                        }
                        Symbol::NonTerminal(nt) => {
                            let nt_first = self.first_sets.get(nt).unwrap();
                            for item in nt_first {
                                if first_set.insert(item.clone()) {
                                    changed = true;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    /// è®¡ç®—FOLLOWé›†åˆ
    fn compute_follow_sets(&mut self) {
        // åˆå§‹åŒ–FOLLOWé›†åˆ
        for non_terminal in &self.grammar.non_terminals {
            self.follow_sets.insert(non_terminal.clone(), HashSet::new());
        }
        
        // å¼€å§‹ç¬¦å·çš„FOLLOWé›†åˆåŒ…å«$
        let start_follow = self.follow_sets.get_mut(&self.grammar.start_symbol).unwrap();
        start_follow.insert("$".to_string());
        
        // è¿­ä»£è®¡ç®—FOLLOWé›†åˆ
        let mut changed = true;
        while changed {
            changed = false;
            
            for production in &self.grammar.productions {
                let left = &production.left;
                
                for i in 0..production.right.len() {
                    if let Symbol::NonTerminal(nt) = &production.right[i] {
                        let follow_set = self.follow_sets.get_mut(nt).unwrap();
                        
                        // æ£€æŸ¥åç»­ç¬¦å·
                        if i + 1 < production.right.len() {
                            let next_symbol = &production.right[i + 1];
                            match next_symbol {
                                Symbol::Terminal(t) => {
                                    if follow_set.insert(t.clone()) {
                                        changed = true;
                                    }
                                }
                                Symbol::NonTerminal(next_nt) => {
                                    let next_first = self.first_sets.get(next_nt).unwrap();
                                    for item in next_first {
                                        if follow_set.insert(item.clone()) {
                                            changed = true;
                                        }
                                    }
                                }
                            }
                        } else {
                            // æœ€åä¸€ä¸ªç¬¦å·ï¼Œæ·»åŠ å·¦éƒ¨çš„FOLLOWé›†åˆ
                            let left_follow = self.follow_sets.get(left).unwrap();
                            for item in left_follow {
                                if follow_set.insert(item.clone()) {
                                    changed = true;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    /// LL(1)è§£æ
    pub fn ll1_parse(&self, input: &[String]) -> Result<ParseTreeNode, String> {
        let mut stack = vec![Symbol::NonTerminal(self.grammar.start_symbol.clone())];
        let mut input_pos = 0;
        let mut tree_stack = vec![ParseTreeNode {
            symbol: Symbol::NonTerminal(self.grammar.start_symbol.clone()),
            children: Vec::new(),
            value: None,
        }];
        
        while !stack.is_empty() {
            let top = stack.last().unwrap();
            
            match top {
                Symbol::Terminal(t) => {
                    if input_pos < input.len() && &input[input_pos] == t {
                        stack.pop();
                        input_pos += 1;
                        tree_stack.pop();
                    } else {
                        return Err(format!("Expected '{}', found '{}'", t, 
                                          if input_pos < input.len() { &input[input_pos] } else { "EOF" }));
                    }
                }
                Symbol::NonTerminal(nt) => {
                    if input_pos >= input.len() {
                        return Err("Unexpected end of input".to_string());
                    }
                    
                    let current_input = &input[input_pos];
                    let production = self.find_ll1_production(nt, current_input)?;
                    
                    stack.pop();
                    let tree_node = tree_stack.pop().unwrap();
                    
                    // å°†äº§ç”Ÿå¼å³éƒ¨å‹å…¥æ ˆ
                    for symbol in production.right.iter().rev() {
                        stack.push(symbol.clone());
                        
                        let child_node = ParseTreeNode {
                            symbol: symbol.clone(),
                            children: Vec::new(),
                            value: None,
                        };
                        tree_stack.push(child_node);
                    }
                }
            }
        }
        
        if input_pos < input.len() {
            Err("Input not fully consumed".to_string())
        } else {
            Ok(tree_stack.pop().unwrap())
        }
    }
    
    /// æŸ¥æ‰¾LL(1)äº§ç”Ÿå¼
    fn find_ll1_production(&self, non_terminal: &str, input: &str) -> Result<&Production, String> {
        for production in &self.grammar.productions {
            if production.left == non_terminal {
                let first_set = self.compute_production_first(&production.right);
                if first_set.contains(input) {
                    return Ok(production);
                }
            }
        }
        
        Err(format!("No production found for '{}' with input '{}'", non_terminal, input))
    }
    
    /// è®¡ç®—äº§ç”Ÿå¼çš„FIRSTé›†åˆ
    fn compute_production_first(&self, symbols: &[Symbol]) -> HashSet<String> {
        let mut first_set = HashSet::new();
        
        for symbol in symbols {
            match symbol {
                Symbol::Terminal(t) => {
                    first_set.insert(t.clone());
                    break;
                }
                Symbol::NonTerminal(nt) => {
                    let nt_first = self.first_sets.get(nt).unwrap();
                    for item in nt_first {
                        first_set.insert(item.clone());
                    }
                    if !nt_first.contains("Îµ") {
                        break;
                    }
                }
            }
        }
        
        first_set
    }
    
    /// é€’å½’ä¸‹é™è§£æ
    pub fn recursive_descent_parse(&self, input: &[String]) -> Result<ParseTreeNode, String> {
        let mut pos = 0;
        self.parse_expression(input, &mut pos)
    }
    
    fn parse_expression(&self, input: &[String], pos: &mut usize) -> Result<ParseTreeNode, String> {
        let mut node = ParseTreeNode {
            symbol: Symbol::NonTerminal("E".to_string()),
            children: Vec::new(),
            value: None,
        };
        
        // è§£æé¡¹
        let term_node = self.parse_term(input, pos)?;
        node.children.push(term_node);
        
        // æ£€æŸ¥æ˜¯å¦æœ‰åŠ æ³•
        while *pos < input.len() && input[*pos] == "+" {
            let plus_node = ParseTreeNode {
                symbol: Symbol::Terminal("+".to_string()),
                children: Vec::new(),
                value: Some("+".to_string()),
            };
            node.children.push(plus_node);
            *pos += 1;
            
            let next_term = self.parse_term(input, pos)?;
            node.children.push(next_term);
        }
        
        Ok(node)
    }
    
    fn parse_term(&self, input: &[String], pos: &mut usize) -> Result<ParseTreeNode, String> {
        let mut node = ParseTreeNode {
            symbol: Symbol::NonTerminal("T".to_string()),
            children: Vec::new(),
            value: None,
        };
        
        // è§£æå› å­
        let factor_node = self.parse_factor(input, pos)?;
        node.children.push(factor_node);
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ä¹˜æ³•
        while *pos < input.len() && input[*pos] == "*" {
            let star_node = ParseTreeNode {
                symbol: Symbol::Terminal("*".to_string()),
                children: Vec::new(),
                value: Some("*".to_string()),
            };
            node.children.push(star_node);
            *pos += 1;
            
            let next_factor = self.parse_factor(input, pos)?;
            node.children.push(next_factor);
        }
        
        Ok(node)
    }
    
    fn parse_factor(&self, input: &[String], pos: &mut usize) -> Result<ParseTreeNode, String> {
        if *pos >= input.len() {
            return Err("Unexpected end of input".to_string());
        }
        
        match &input[*pos] {
            "(" => {
                let mut node = ParseTreeNode {
                    symbol: Symbol::NonTerminal("F".to_string()),
                    children: Vec::new(),
                    value: None,
                };
                
                let left_paren = ParseTreeNode {
                    symbol: Symbol::Terminal("(".to_string()),
                    children: Vec::new(),
                    value: Some("(".to_string()),
                };
                node.children.push(left_paren);
                *pos += 1;
                
                let expr = self.parse_expression(input, pos)?;
                node.children.push(expr);
                
                if *pos >= input.len() || input[*pos] != ")" {
                    return Err("Expected ')'".to_string());
                }
                
                let right_paren = ParseTreeNode {
                    symbol: Symbol::Terminal(")".to_string()),
                    children: Vec::new(),
                    value: Some(")".to_string()),
                };
                node.children.push(right_paren);
                *pos += 1;
                
                Ok(node)
            }
            "id" => {
                let node = ParseTreeNode {
                    symbol: Symbol::Terminal("id".to_string()),
                    children: Vec::new(),
                    value: Some("id".to_string()),
                };
                *pos += 1;
                Ok(node)
            }
            _ => Err(format!("Unexpected token: {}", input[*pos])),
        }
    }
}

impl fmt::Display for ParseTreeNode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.fmt_with_indent(f, 0)
    }
}

impl ParseTreeNode {
    fn fmt_with_indent(&self, f: &mut fmt::Formatter<'_>, indent: usize) -> fmt::Result {
        let indent_str = "  ".repeat(indent);
        writeln!(f, "{}{:?}", indent_str, self.symbol)?;
        
        for child in &self.children {
            child.fmt_with_indent(f, indent + 1)?;
        }
        
        Ok(())
    }
}

/// è¯­æ³•åˆ†æå™¨å·¥å‚
pub struct ParserFactory;

impl ParserFactory {
    /// åˆ›å»ºLL(1)è§£æå™¨
    pub fn create_ll1_parser(grammar: ContextFreeGrammar) -> Parser {
        Parser::new(grammar)
    }
    
    /// åˆ›å»ºé€’å½’ä¸‹é™è§£æå™¨
    pub fn create_recursive_descent_parser(grammar: ContextFreeGrammar) -> Parser {
        Parser::new(grammar)
    }
    
    /// åˆ›å»ºLRè§£æå™¨
    pub fn create_lr_parser(grammar: ContextFreeGrammar) -> LRParser {
        LRParser::new(grammar)
    }
}

/// LRè§£æå™¨
pub struct LRParser {
    pub grammar: ContextFreeGrammar,
    pub states: Vec<LRState>,
    pub action_table: HashMap<(u32, String), LRAction>,
    pub goto_table: HashMap<(u32, String), u32>,
}

impl LRParser {
    pub fn new(grammar: ContextFreeGrammar) -> Self {
        let mut parser = Self {
            grammar,
            states: Vec::new(),
            action_table: HashMap::new(),
            goto_table: HashMap::new(),
        };
        
        parser.build_lr_tables();
        parser
    }
    
    fn build_lr_tables(&mut self) {
        // ç®€åŒ–çš„LRè¡¨æ„å»º
        // å®é™…å®ç°éœ€è¦æ›´å¤æ‚çš„ç®—æ³•
        
        // åˆ›å»ºåˆå§‹çŠ¶æ€
        let initial_state = LRState {
            id: 0,
            items: vec![],
            actions: HashMap::new(),
            gotos: HashMap::new(),
        };
        self.states.push(initial_state);
        
        // æ„å»ºåŠ¨ä½œè¡¨å’Œè½¬ç§»è¡¨
        // è¿™é‡Œç®€åŒ–å¤„ç†
    }
    
    pub fn parse(&self, input: &[String]) -> Result<ParseTreeNode, String> {
        // ç®€åŒ–çš„LRè§£æå®ç°
        let mut stack = vec![0u32]; // çŠ¶æ€æ ˆ
        let mut symbol_stack = vec![Symbol::Terminal("$".to_string())]; // ç¬¦å·æ ˆ
        let mut input_pos = 0;
        
        loop {
            let current_state = stack.last().unwrap();
            let current_input = if input_pos < input.len() { &input[input_pos] } else { "$" };
            
            let action = self.action_table.get(&(*current_state, current_input.to_string()));
            
            match action {
                Some(LRAction::Shift(next_state)) => {
                    stack.push(*next_state);
                    symbol_stack.push(Symbol::Terminal(current_input.to_string()));
                    input_pos += 1;
                }
                Some(LRAction::Reduce(production)) => {
                    // æ‰§è¡Œå½’çº¦
                    for _ in 0..production.right.len() {
                        stack.pop();
                        symbol_stack.pop();
                    }
                    
                    let current_state = stack.last().unwrap();
                    let goto_state = self.goto_table.get(&(*current_state, production.left.clone()));
                    
                    if let Some(&next_state) = goto_state {
                        stack.push(next_state);
                        symbol_stack.push(Symbol::NonTerminal(production.left.clone()));
                    } else {
                        return Err("Goto table error".to_string());
                    }
                }
                Some(LRAction::Accept) => {
                    return Ok(ParseTreeNode {
                        symbol: Symbol::NonTerminal(self.grammar.start_symbol.clone()),
                        children: Vec::new(),
                        value: None,
                    });
                }
                Some(LRAction::Error) | None => {
                    return Err(format!("Parse error at position {}", input_pos));
                }
            }
        }
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_grammar_creation() {
        let grammar = ContextFreeGrammar::create_arithmetic_grammar();
        
        assert!(grammar.is_valid());
        assert_eq!(grammar.non_terminals.len(), 3);
        assert_eq!(grammar.terminals.len(), 5);
        assert_eq!(grammar.productions.len(), 6);
    }
    
    #[test]
    fn test_ll1_parsing() {
        let grammar = ContextFreeGrammar::create_arithmetic_grammar();
        let parser = Parser::new(grammar);
        
        let input = vec!["id".to_string(), "+".to_string(), "id".to_string()];
        let result = parser.ll1_parse(&input);
        
        assert!(result.is_ok());
        let tree = result.unwrap();
        assert_eq!(tree.symbol, Symbol::NonTerminal("E".to_string()));
    }
    
    #[test]
    fn test_recursive_descent_parsing() {
        let grammar = ContextFreeGrammar::create_arithmetic_grammar();
        let parser = Parser::new(grammar);
        
        let input = vec!["id".to_string(), "*".to_string(), "id".to_string()];
        let result = parser.recursive_descent_parse(&input);
        
        assert!(result.is_ok());
        let tree = result.unwrap();
        assert_eq!(tree.symbol, Symbol::NonTerminal("E".to_string()));
    }
    
    #[test]
    fn test_first_sets() {
        let grammar = ContextFreeGrammar::create_arithmetic_grammar();
        let parser = Parser::new(grammar);
        
        let e_first = parser.first_sets.get("E").unwrap();
        assert!(e_first.contains("id"));
        assert!(e_first.contains("("));
    }
    
    #[test]
    fn test_follow_sets() {
        let grammar = ContextFreeGrammar::create_arithmetic_grammar();
        let parser = Parser::new(grammar);
        
        let e_follow = parser.follow_sets.get("E").unwrap();
        assert!(e_follow.contains("$"));
        assert!(e_follow.contains(")"));
    }
    
    #[test]
    fn test_parse_tree_display() {
        let node = ParseTreeNode {
            symbol: Symbol::NonTerminal("E".to_string()),
            children: vec![
                ParseTreeNode {
                    symbol: Symbol::Terminal("id".to_string()),
                    children: Vec::new(),
                    value: Some("x".to_string()),
                },
            ],
            value: None,
        };
        
        let display = format!("{}", node);
        assert!(display.contains("E"));
        assert!(display.contains("id"));
    }
}
```

## 6. ç›¸å…³ç†è®º

- å½¢å¼è¯­è¨€ç†è®º
- è‡ªåŠ¨æœºç†è®º
- ç¼–è¯‘åŸç†
- è¯­è¨€è¯­ä¹‰å­¦

## 7. å‚è€ƒæ–‡çŒ®

1. Aho, A. V., et al. "Compilers: Principles, Techniques, and Tools"
2. Hopcroft, J. E., Ullman, J. D. "Introduction to Automata Theory, Languages, and Computation"
3. Grune, D., Jacobs, C. J. H. "Parsing Techniques: A Practical Guide"
4. Sipser, M. "Introduction to the Theory of Computation"

---

**ç›¸å…³é“¾æ¥**ï¼š

- [08.1.1 è¯­è¨€è®¾è®¡ç†è®º](../08.1.1_è¯­è¨€è®¾è®¡ç†è®º.md)
- [08.1.3 è¯­ä¹‰ç†è®º](../08.1.3_è¯­ä¹‰ç†è®º.md)
- [08.1.4 ç±»å‹ç†è®º](../08.1.4_ç±»å‹ç†è®º.md)
