# 08.2.3 è™šæ‹Ÿæœºç†è®º

## ğŸ“‹ æ¦‚è¿°

è™šæ‹Ÿæœºç†è®ºæ˜¯ç¼–ç¨‹è¯­è¨€ç†è®ºå’Œç³»ç»Ÿè½¯ä»¶é¢†åŸŸçš„é‡è¦åˆ†æ”¯ï¼Œç ”ç©¶è™šæ‹Ÿæœºçš„ç»“æ„ã€è¿è¡Œæœºåˆ¶ã€æŒ‡ä»¤é›†è®¾è®¡ä¸å®ç°ï¼Œä¸ºè·¨å¹³å°æ‰§è¡Œã€è¯­è¨€å®ç°å’Œç³»ç»Ÿå®‰å…¨æä¾›ç†è®ºåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹è™šæ‹Ÿæœºçš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°Rustè™šæ‹Ÿæœºç¤ºä¾‹
4. åˆ†æä¸»æµè™šæ‹Ÿæœºæ¶æ„ä¸ä¼˜åŒ–

## ğŸ“š ç›®å½•

1. åŸºæœ¬æ¦‚å¿µ
2. å½¢å¼åŒ–å®šä¹‰
3. å®šç†ä¸è¯æ˜
4. ä»£ç å®ç°
5. åº”ç”¨ç¤ºä¾‹
6. ç›¸å…³ç†è®º
7. å‚è€ƒæ–‡çŒ®

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è™šæ‹Ÿæœºå®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆè™šæ‹Ÿæœºï¼‰
è™šæ‹Ÿæœºæ˜¯ä¸€ç§è½¯ä»¶å®ç°çš„æŠ½è±¡è®¡ç®—æœºï¼Œèƒ½å¤Ÿè§£é‡Šæˆ–ç¼–è¯‘æ‰§è¡Œç‰¹å®šæŒ‡ä»¤é›†çš„ç¨‹åºã€‚

### 1.2 è™šæ‹Ÿæœºç±»å‹

- æ ˆå¼è™šæ‹Ÿæœºï¼ˆStack-based VMï¼‰
- å¯„å­˜å™¨è™šæ‹Ÿæœºï¼ˆRegister-based VMï¼‰
- è¿‡ç¨‹è™šæ‹Ÿæœºï¼ˆProcess VMï¼‰
- ç³»ç»Ÿè™šæ‹Ÿæœºï¼ˆSystem VMï¼‰

## 2. å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1**ï¼ˆè™šæ‹Ÿæœºæ¨¡å‹ï¼‰
è™šæ‹Ÿæœºæ¨¡å‹æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $VM = (S, M, I, PC, F)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯æ ˆæˆ–å¯„å­˜å™¨é›†åˆ
- $M$ æ˜¯å†…å­˜ç©ºé—´
- $I$ æ˜¯æŒ‡ä»¤é›†
- $PC$ æ˜¯ç¨‹åºè®¡æ•°å™¨
- $F$ æ˜¯æŒ‡ä»¤æ‰§è¡Œå‡½æ•°

**å®šä¹‰ 2.2**ï¼ˆæŒ‡ä»¤è¯­ä¹‰ï¼‰
æ¯æ¡æŒ‡ä»¤ $i \in I$ ç”±è½¬ç§»å‡½æ•° $F_i$ å®šä¹‰å…¶å¯¹è™šæ‹ŸæœºçŠ¶æ€çš„å˜æ¢ã€‚

**å®šç† 2.1**ï¼ˆç¡®å®šæ€§ï¼‰
ç¡®å®šæ€§è™šæ‹Ÿæœºåœ¨ç»™å®šåˆå§‹çŠ¶æ€å’ŒæŒ‡ä»¤åºåˆ—ä¸‹ï¼Œæ‰§è¡Œç»“æœå”¯ä¸€ã€‚

**è¯æ˜**ï¼š
æ¯æ¡æŒ‡ä»¤çš„è½¬ç§»å‡½æ•°æ˜¯å•å€¼çš„ï¼ŒçŠ¶æ€è½¬ç§»æ— æ­§ä¹‰ã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

**å®šç† 3.1**ï¼ˆç­‰ä»·æ€§ï¼‰
ç­‰ä»·çš„è™šæ‹Ÿæœºå®ç°å¯¹åŒä¸€ç¨‹åºäº§ç”Ÿç›¸åŒçš„è¾“å‡ºã€‚

**è¯æ˜**ï¼š
è‹¥æŒ‡ä»¤é›†å’ŒçŠ¶æ€è½¬ç§»å‡½æ•°ç­‰ä»·ï¼Œåˆ™æ‰§è¡Œè·¯å¾„å’Œç»“æœä¸€è‡´ã€‚$\square$

**å®šç† 3.2**ï¼ˆå®‰å…¨æ€§ï¼‰
è™šæ‹Ÿæœºå¯é€šè¿‡éš”ç¦»å’Œæ£€æŸ¥æœºåˆ¶æå‡ç³»ç»Ÿå®‰å…¨ã€‚

**è¯æ˜**ï¼š
è™šæ‹Ÿæœºå¯æ‹¦æˆªéæ³•æ“ä½œï¼Œé˜²æ­¢è¶Šæƒè®¿é—®å’Œæ¶æ„ä»£ç æ‰§è¡Œã€‚$\square$

## 4. ä»£ç å®ç°

```rust
use std::collections::HashMap;

/// è™šæ‹ŸæœºæŒ‡ä»¤
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Instruction {
    Push(i64),
    Pop,
    Add,
    Sub,
    Mul,
    Div,
    Load(String),
    Store(String),
    Jump(usize),
    JumpIfZero(usize),
    Halt,
}

/// è™šæ‹ŸæœºçŠ¶æ€
pub struct VM {
    pub stack: Vec<i64>,
    pub memory: HashMap<String, i64>,
    pub pc: usize,
    pub program: Vec<Instruction>,
    pub halted: bool,
}

impl VM {
    pub fn new(program: Vec<Instruction>) -> Self {
        Self {
            stack: Vec::new(),
            memory: HashMap::new(),
            pc: 0,
            program,
            halted: false,
        }
    }

    /// æ‰§è¡Œä¸€æ¡æŒ‡ä»¤
    pub fn step(&mut self) {
        if self.halted || self.pc >= self.program.len() {
            self.halted = true;
            return;
        }
        let instr = self.program[self.pc].clone();
        match instr {
            Instruction::Push(val) => {
                self.stack.push(val);
                self.pc += 1;
            }
            Instruction::Pop => {
                self.stack.pop();
                self.pc += 1;
            }
            Instruction::Add => {
                if let (Some(b), Some(a)) = (self.stack.pop(), self.stack.pop()) {
                    self.stack.push(a + b);
                }
                self.pc += 1;
            }
            Instruction::Sub => {
                if let (Some(b), Some(a)) = (self.stack.pop(), self.stack.pop()) {
                    self.stack.push(a - b);
                }
                self.pc += 1;
            }
            Instruction::Mul => {
                if let (Some(b), Some(a)) = (self.stack.pop(), self.stack.pop()) {
                    self.stack.push(a * b);
                }
                self.pc += 1;
            }
            Instruction::Div => {
                if let (Some(b), Some(a)) = (self.stack.pop(), self.stack.pop()) {
                    if b != 0 {
                        self.stack.push(a / b);
                    } else {
                        self.stack.push(0);
                    }
                }
                self.pc += 1;
            }
            Instruction::Load(name) => {
                let val = *self.memory.get(&name).unwrap_or(&0);
                self.stack.push(val);
                self.pc += 1;
            }
            Instruction::Store(name) => {
                if let Some(val) = self.stack.pop() {
                    self.memory.insert(name, val);
                }
                self.pc += 1;
            }
            Instruction::Jump(addr) => {
                self.pc = addr;
            }
            Instruction::JumpIfZero(addr) => {
                if let Some(val) = self.stack.pop() {
                    if val == 0 {
                        self.pc = addr;
                    } else {
                        self.pc += 1;
                    }
                } else {
                    self.pc += 1;
                }
            }
            Instruction::Halt => {
                self.halted = true;
            }
        }
    }

    /// è¿è¡Œç¨‹åºç›´åˆ°ç»“æŸ
    pub fn run(&mut self) {
        while !self.halted {
            self.step();
        }
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vm_arithmetic() {
        let program = vec![
            Instruction::Push(2),
            Instruction::Push(3),
            Instruction::Add,
            Instruction::Halt,
        ];
        let mut vm = VM::new(program);
        vm.run();
        assert_eq!(vm.stack, vec![5]);
    }

    #[test]
    fn test_vm_memory() {
        let program = vec![
            Instruction::Push(42),
            Instruction::Store("x".to_string()),
            Instruction::Load("x".to_string()),
            Instruction::Halt,
        ];
        let mut vm = VM::new(program);
        vm.run();
        assert_eq!(vm.stack, vec![42]);
        assert_eq!(*vm.memory.get("x").unwrap(), 42);
    }

    #[test]
    fn test_vm_jump() {
        let program = vec![
            Instruction::Push(0),
            Instruction::JumpIfZero(3),
            Instruction::Push(99),
            Instruction::Push(1),
            Instruction::Halt,
        ];
        let mut vm = VM::new(program);
        vm.run();
        assert_eq!(vm.stack, vec![1]);
    }
}
```

## 6. ç›¸å…³ç†è®º

- ç¼–è¯‘åŸç†
- è§£é‡Šå™¨ç†è®º
- æ“ä½œè¯­ä¹‰å­¦
- ç³»ç»Ÿå®‰å…¨ç†è®º

## 7. å‚è€ƒæ–‡çŒ®

1. Smith, J. E., Nair, R. "Virtual Machines: Versatile Platforms for Systems and Processes"
2. Lindholm, T., Yellin, F. "The Java Virtual Machine Specification"
3. Tanenbaum, A. S., Bos, H. "Modern Operating Systems"
4. Spector, A. Z. "Multiprocessing Architectures for Local Computer Networks"

---

**ç›¸å…³é“¾æ¥**ï¼š

- [08.2.1 ç¼–è¯‘åŸç†ç†è®º](../08.2.1_ç¼–è¯‘åŸç†ç†è®º.md)
- [08.2.2 ä»£ç ä¼˜åŒ–ç†è®º](../08.2.2_ä»£ç ä¼˜åŒ–ç†è®º.md)
- [08.2.4 è§£é‡Šå™¨ç†è®º](../08.2.4_è§£é‡Šå™¨ç†è®º.md)
