# 08.2.2 ä»£ç ä¼˜åŒ–ç†è®º

## ğŸ“‹ æ¦‚è¿°

ä»£ç ä¼˜åŒ–ç†è®ºæ˜¯ç¼–ç¨‹è¯­è¨€ç†è®ºå’Œç¼–è¯‘åŸç†ä¸­çš„é‡è¦åˆ†æ”¯ï¼Œç ”ç©¶å¦‚ä½•é€šè¿‡å½¢å¼åŒ–æ–¹æ³•å’Œç®—æ³•æå‡ç¨‹åºæ‰§è¡Œæ•ˆç‡ã€å‡å°‘èµ„æºæ¶ˆè€—ã€æ”¹å–„å¯ç»´æŠ¤æ€§ã€‚è¯¥ç†è®ºä¸ºç¼–è¯‘å™¨å’Œç¨‹åºåˆ†æå·¥å…·çš„ä¼˜åŒ–æ¨¡å—æä¾›ç§‘å­¦åŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ä»£ç ä¼˜åŒ–çš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°Rustä»£ç ä¼˜åŒ–ç¤ºä¾‹
4. åˆ†æä¸»æµä¼˜åŒ–ç­–ç•¥ä¸ç®—æ³•

## ğŸ“š ç›®å½•

1. åŸºæœ¬æ¦‚å¿µ
2. å½¢å¼åŒ–å®šä¹‰
3. å®šç†ä¸è¯æ˜
4. ä»£ç å®ç°
5. åº”ç”¨ç¤ºä¾‹
6. ç›¸å…³ç†è®º
7. å‚è€ƒæ–‡çŒ®

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ä»£ç ä¼˜åŒ–å®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆä»£ç ä¼˜åŒ–ï¼‰
ä»£ç ä¼˜åŒ–æ˜¯æŒ‡åœ¨ä¸æ”¹å˜ç¨‹åºè¯­ä¹‰çš„å‰æä¸‹ï¼Œé€šè¿‡å˜æ¢ã€é‡ç»„æˆ–ç®€åŒ–ä»£ç ç»“æ„ï¼Œæé«˜ç¨‹åºæ€§èƒ½æˆ–é™ä½èµ„æºæ¶ˆè€—çš„è¿‡ç¨‹ã€‚

### 1.2 ä¼˜åŒ–ç±»å‹
- å±€éƒ¨ä¼˜åŒ–ï¼ˆLocal Optimizationï¼‰
- å…¨å±€ä¼˜åŒ–ï¼ˆGlobal Optimizationï¼‰
- å¾ªç¯ä¼˜åŒ–ï¼ˆLoop Optimizationï¼‰
- æ•°æ®æµä¼˜åŒ–ï¼ˆData Flow Optimizationï¼‰
- æœºå™¨ç›¸å…³ä¼˜åŒ–ï¼ˆMachine-dependent Optimizationï¼‰

## 2. å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1**ï¼ˆä¼˜åŒ–å˜æ¢ï¼‰
ä¼˜åŒ–å˜æ¢ $T$ æ˜¯ä¸€ä¸ªå‡½æ•° $T: P \rightarrow P'$ï¼Œå…¶ä¸­ $P$ å’Œ $P'$ æ˜¯ç­‰ä»·çš„ç¨‹åºï¼Œä¸” $P'$ åœ¨æŸç§åº¦é‡ä¸‹ä¼˜äº $P$ã€‚

**å®šä¹‰ 2.2**ï¼ˆç­‰ä»·æ€§ï¼‰
è‹¥ $\forall x, P(x) = P'(x)$ï¼Œåˆ™ç§° $P$ ä¸ $P'$ è¯­ä¹‰ç­‰ä»·ã€‚

**å®šç† 2.1**ï¼ˆä¼˜åŒ–æ­£ç¡®æ€§ï¼‰
ä¼˜åŒ–å˜æ¢å¿…é¡»ä¿æŒç¨‹åºçš„è¯­ä¹‰ç­‰ä»·æ€§ã€‚

**è¯æ˜**ï¼š
é€šè¿‡ç­‰ä»·æ€§è¯æ˜ï¼Œç¡®ä¿ä¼˜åŒ–å‰åç¨‹åºå¯¹æ‰€æœ‰è¾“å…¥çš„è¡Œä¸ºä¸€è‡´ã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

**å®šç† 3.1**ï¼ˆæ­»ä»£ç æ¶ˆé™¤æœ‰æ•ˆæ€§ï¼‰
æ¶ˆé™¤ä¸å¯è¾¾ä»£ç ä¸ä¼šå½±å“ç¨‹åºçš„å¯è§‚æµ‹è¡Œä¸ºã€‚

**è¯æ˜**ï¼š
ä¸å¯è¾¾ä»£ç åœ¨ä»»ä½•æ‰§è¡Œè·¯å¾„ä¸Šéƒ½ä¸ä¼šè¢«æ‰§è¡Œï¼Œæ•…å…¶ç§»é™¤ä¸å½±å“ç¨‹åºè¾“å‡ºã€‚$\square$

**å®šç† 3.2**ï¼ˆå¸¸é‡ä¼ æ’­å®‰å…¨æ€§ï¼‰
å¸¸é‡ä¼ æ’­ä¸ä¼šå¼•å…¥æ–°çš„è¿è¡Œæ—¶é”™è¯¯ã€‚

**è¯æ˜**ï¼š
å¸¸é‡ä¼ æ’­ä»…ç”¨å·²çŸ¥å¸¸é‡æ›¿æ¢å˜é‡ï¼Œä¸æ”¹å˜åŸæœ‰æ§åˆ¶æµå’Œæ•°æ®æµã€‚$\square$

## 4. ä»£ç å®ç°

```rust
use std::collections::{HashMap, HashSet};

/// ä¸­é—´è¡¨ç¤ºæŒ‡ä»¤
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum IR {
    Assign(String, Expr),
    BinOp(String, String, BinOp, String),
    Jump(String),
    JumpIf(String, String),
    Label(String),
    Return(String),
    Nop,
}

/// è¡¨è¾¾å¼
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    Const(i64),
    Var(String),
    BinOp(Box<Expr>, BinOp, Box<Expr>),
}

/// äºŒå…ƒæ“ä½œç¬¦
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum BinOp {
    Add,
    Sub,
    Mul,
    Div,
    Eq,
    Lt,
    Gt,
}

/// ä¼˜åŒ–å™¨
pub struct Optimizer;

impl Optimizer {
    /// æ­»ä»£ç æ¶ˆé™¤
    pub fn dead_code_elimination(ir: &[IR]) -> Vec<IR> {
        let mut used = HashSet::new();
        for instr in ir.iter().rev() {
            match instr {
                IR::Assign(var, expr) => {
                    if used.contains(var) {
                        Self::collect_vars_expr(expr, &mut used);
                    }
                }
                IR::BinOp(dst, lhs, _, rhs) => {
                    if used.contains(dst) {
                        used.insert(lhs.clone());
                        used.insert(rhs.clone());
                    }
                }
                IR::Return(var) | IR::JumpIf(var, _) => {
                    used.insert(var.clone());
                }
                _ => {}
            }
        }
        ir.iter()
            .filter(|instr| match instr {
                IR::Assign(var, _) | IR::BinOp(var, _, _, _) => used.contains(var),
                _ => true,
            })
            .cloned()
            .collect()
    }

    /// å¸¸é‡ä¼ æ’­
    pub fn constant_propagation(ir: &[IR]) -> Vec<IR> {
        let mut env = HashMap::new();
        let mut result = Vec::new();
        for instr in ir {
            match instr {
                IR::Assign(var, Expr::Const(c)) => {
                    env.insert(var.clone(), *c);
                    result.push(instr.clone());
                }
                IR::Assign(var, Expr::Var(v)) => {
                    if let Some(&val) = env.get(v) {
                        result.push(IR::Assign(var.clone(), Expr::Const(val)));
                        env.insert(var.clone(), val);
                    } else {
                        result.push(instr.clone());
                    }
                }
                IR::BinOp(dst, lhs, op, rhs) => {
                    let l = env.get(lhs);
                    let r = env.get(rhs);
                    if let (Some(&lv), Some(&rv)) = (l, r) {
                        let val = match op {
                            BinOp::Add => lv + rv,
                            BinOp::Sub => lv - rv,
                            BinOp::Mul => lv * rv,
                            BinOp::Div => if rv != 0 { lv / rv } else { 0 },
                            BinOp::Eq => (lv == rv) as i64,
                            BinOp::Lt => (lv < rv) as i64,
                            BinOp::Gt => (lv > rv) as i64,
                        };
                        result.push(IR::Assign(dst.clone(), Expr::Const(val)));
                        env.insert(dst.clone(), val);
                    } else {
                        result.push(instr.clone());
                    }
                }
                _ => result.push(instr.clone()),
            }
        }
        result
    }

    /// å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤
    pub fn common_subexpression_elimination(ir: &[IR]) -> Vec<IR> {
        let mut expr_map = HashMap::new();
        let mut result = Vec::new();
        for instr in ir {
            match instr {
                IR::Assign(var, expr) => {
                    if let Some(existing) = expr_map.get(expr) {
                        result.push(IR::Assign(var.clone(), Expr::Var(existing.clone())));
                    } else {
                        expr_map.insert(expr.clone(), var.clone());
                        result.push(instr.clone());
                    }
                }
                _ => result.push(instr.clone()),
            }
        }
        result
    }

    fn collect_vars_expr(expr: &Expr, used: &mut HashSet<String>) {
        match expr {
            Expr::Var(v) => { used.insert(v.clone()); },
            Expr::BinOp(lhs, _, rhs) => {
                Self::collect_vars_expr(lhs, used);
                Self::collect_vars_expr(rhs, used);
            }
            _ => {}
        }
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_dead_code_elimination() {
        let ir = vec![
            IR::Assign("a".to_string(), Expr::Const(1)),
            IR::Assign("b".to_string(), Expr::Const(2)),
            IR::Return("a".to_string()),
        ];
        let optimized = Optimizer::dead_code_elimination(&ir);
        assert!(optimized.iter().any(|i| matches!(i, IR::Assign(var, _) if var == "a")));
        assert!(!optimized.iter().any(|i| matches!(i, IR::Assign(var, _) if var == "b")));
    }

    #[test]
    fn test_constant_propagation() {
        let ir = vec![
            IR::Assign("a".to_string(), Expr::Const(1)),
            IR::Assign("b".to_string(), Expr::Var("a".to_string())),
            IR::BinOp("c".to_string(), "a".to_string(), BinOp::Add, "b".to_string()),
        ];
        let optimized = Optimizer::constant_propagation(&ir);
        assert!(optimized.iter().any(|i| matches!(i, IR::Assign(var, Expr::Const(2)) if var == "c")));
    }

    #[test]
    fn test_common_subexpression_elimination() {
        let ir = vec![
            IR::Assign("a".to_string(), Expr::BinOp(Box::new(Expr::Const(1)), BinOp::Add, Box::new(Expr::Const(2)))),
            IR::Assign("b".to_string(), Expr::BinOp(Box::new(Expr::Const(1)), BinOp::Add, Box::new(Expr::Const(2)))),
        ];
        let optimized = Optimizer::common_subexpression_elimination(&ir);
        assert!(optimized.iter().any(|i| matches!(i, IR::Assign(var, Expr::Var(ref v)) if var == "b" && v == "a")));
    }
}
```

## 6. ç›¸å…³ç†è®º

- ç¼–è¯‘åŸç†
- æ•°æ®æµåˆ†æç†è®º
- ç¨‹åºå˜æ¢ç†è®º
- é™æ€åˆ†æç†è®º

## 7. å‚è€ƒæ–‡çŒ®

1. Aho, A. V., et al. "Compilers: Principles, Techniques, and Tools"
2. Muchnick, S. S. "Advanced Compiler Design and Implementation"
3. Cooper, K. D., Torczon, L. "Engineering a Compiler"
4. Allen, F. E. "Control Flow Analysis"

---

**ç›¸å…³é“¾æ¥**ï¼š
- [08.2.1 ç¼–è¯‘åŸç†ç†è®º](../08.2.1_ç¼–è¯‘åŸç†ç†è®º.md)
- [08.2.3 è™šæ‹Ÿæœºç†è®º](../08.2.3_è™šæ‹Ÿæœºç†è®º.md)
- [08.2.4 è§£é‡Šå™¨ç†è®º](../08.2.4_è§£é‡Šå™¨ç†è®º.md) 