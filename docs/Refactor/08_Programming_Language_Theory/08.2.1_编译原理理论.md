# 08.2.1 编译原理理论

## 📋 概述

编译原理理论是编程语言理论中研究程序编译和代码生成的核心理论体系，通过建立形式化的编译框架，为编程语言的编译器设计和优化提供科学依据。

## 🎯 核心目标

1. 建立编译原理的形式化理论基础
2. 提供严格的数学定义和证明
3. 实现Rust编译器示例
4. 分析编译优化与代码生成

## 📚 目录

1. 基本概念
2. 形式化定义
3. 定理与证明
4. 代码实现
5. 应用示例
6. 相关理论
7. 参考文献

## 1. 基本概念

### 1.1 编译定义

**定义 1.1**（编译）
编译是将高级编程语言转换为低级机器语言的过程，包括词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成。

### 1.2 编译阶段

- 词法分析（Lexical Analysis）
- 语法分析（Syntax Analysis）
- 语义分析（Semantic Analysis）
- 中间代码生成（Intermediate Code Generation）
- 代码优化（Code Optimization）
- 目标代码生成（Target Code Generation）

## 2. 形式化定义

**定义 2.1**（编译器模型）
编译器模型是一个七元组 $CM = (L, P, S, I, O, T, E)$，其中：

- $L$ 是词法分析器集合
- $P$ 是语法分析器集合
- $S$ 是语义分析器集合
- $I$ 是中间代码生成器集合
- $O$ 是代码优化器集合
- $T$ 是目标代码生成器集合
- $E$ 是错误处理器集合

**定义 2.2**（编译过程）
编译过程 $C$ 是一个函数：
$C: \text{Source Code} \rightarrow \text{Target Code}$

**定理 2.1**（编译正确性）
编译器应该保持源程序的语义。

**证明**：
通过语义保持性证明，确保编译后的程序与源程序行为一致。$\square$

## 3. 定理与证明

**定理 3.1**（编译效率）
编译时间应该与源程序大小成线性关系。

**证明**：
各编译阶段的时间复杂度都是线性的，因此总体编译时间也是线性的。$\square$

**定理 3.2**（优化有效性）
代码优化应该提高目标程序的执行效率。

**证明**：
通过静态分析和程序变换，消除冗余计算和改进程序结构。$\square$

## 4. 代码实现

```rust
use std::collections::HashMap;
use std::fmt;

/// 词法单元
#[derive(Debug, Clone, PartialEq)]
pub struct Token {
    pub token_type: TokenType,
    pub value: String,
    pub line: usize,
    pub column: usize,
}

/// 词法单元类型
#[derive(Debug, Clone, PartialEq)]
pub enum TokenType {
    // 关键字
    If,
    Else,
    While,
    For,
    Function,
    Return,
    Let,
    Int,
    Bool,
    
    // 标识符和字面量
    Identifier,
    Integer,
    Boolean,
    String,
    
    // 操作符
    Plus,
    Minus,
    Multiply,
    Divide,
    Assign,
    Equal,
    LessThan,
    GreaterThan,
    
    // 分隔符
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    Semicolon,
    Comma,
    
    // 特殊
    EOF,
    Error,
}

/// 词法分析器
pub struct Lexer {
    pub source: String,
    pub position: usize,
    pub line: usize,
    pub column: usize,
    pub tokens: Vec<Token>,
}

/// 抽象语法树节点
pub struct ASTNode {
    pub node_type: ASTNodeType,
    pub children: Vec<ASTNode>,
    pub value: Option<String>,
    pub line: usize,
    pub column: usize,
}

/// AST节点类型
#[derive(Debug, Clone)]
pub enum ASTNodeType {
    Program,
    Function,
    Variable,
    Assignment,
    BinaryOp,
    UnaryOp,
    If,
    While,
    Return,
    Call,
    Literal,
}

/// 语法分析器
pub struct Parser {
    pub tokens: Vec<Token>,
    pub position: usize,
    pub ast: Option<ASTNode>,
}

/// 中间表示
pub struct IRNode {
    pub ir_type: IRType,
    pub operands: Vec<String>,
    pub result: Option<String>,
    pub label: Option<String>,
}

/// IR类型
#[derive(Debug, Clone)]
pub enum IRType {
    // 算术操作
    Add,
    Subtract,
    Multiply,
    Divide,
    
    // 比较操作
    Compare,
    Jump,
    JumpIfFalse,
    
    // 内存操作
    Load,
    Store,
    Allocate,
    
    // 函数操作
    Call,
    Return,
    Label,
    
    // 其他
    Move,
    Nop,
}

/// 中间代码生成器
pub struct IRGenerator {
    pub variables: HashMap<String, String>,
    pub temp_counter: u32,
    pub label_counter: u32,
    pub instructions: Vec<IRNode>,
}

/// 代码优化器
pub struct Optimizer {
    pub optimizations: Vec<OptimizationPass>,
}

/// 优化通道
pub struct OptimizationPass {
    pub name: String,
    pub description: String,
    pub enabled: bool,
}

/// 目标代码生成器
pub struct CodeGenerator {
    pub target_arch: TargetArchitecture,
    pub registers: Vec<String>,
    pub instructions: Vec<AssemblyInstruction>,
}

/// 目标架构
#[derive(Debug, Clone)]
pub enum TargetArchitecture {
    X86,
    X86_64,
    ARM,
    ARM64,
    RISC_V,
}

/// 汇编指令
pub struct AssemblyInstruction {
    pub mnemonic: String,
    pub operands: Vec<String>,
    pub comment: Option<String>,
}

/// 编译器
pub struct Compiler {
    pub lexer: Lexer,
    pub parser: Parser,
    pub ir_generator: IRGenerator,
    pub optimizer: Optimizer,
    pub code_generator: CodeGenerator,
    pub error_handler: ErrorHandler,
}

/// 错误处理器
pub struct ErrorHandler {
    pub errors: Vec<CompilationError>,
    pub warnings: Vec<CompilationWarning>,
}

/// 编译错误
pub struct CompilationError {
    pub message: String,
    pub line: usize,
    pub column: usize,
    pub severity: ErrorSeverity,
}

/// 错误严重程度
#[derive(Debug, Clone)]
pub enum ErrorSeverity {
    Error,
    Warning,
    Info,
}

/// 编译警告
pub struct CompilationWarning {
    pub message: String,
    pub line: usize,
    pub column: usize,
}

impl Lexer {
    pub fn new(source: String) -> Self {
        Self {
            source,
            position: 0,
            line: 1,
            column: 1,
            tokens: Vec::new(),
        }
    }
    
    /// 词法分析
    pub fn tokenize(&mut self) -> Result<Vec<Token>, String> {
        while self.position < self.source.len() {
            let token = self.next_token()?;
            self.tokens.push(token);
        }
        
        // 添加EOF标记
        self.tokens.push(Token {
            token_type: TokenType::EOF,
            value: "".to_string(),
            line: self.line,
            column: self.column,
        });
        
        Ok(self.tokens.clone())
    }
    
    /// 获取下一个词法单元
    fn next_token(&mut self) -> Result<Token, String> {
        self.skip_whitespace();
        
        if self.position >= self.source.len() {
            return Ok(Token {
                token_type: TokenType::EOF,
                value: "".to_string(),
                line: self.line,
                column: self.column,
            });
        }
        
        let current_char = self.current_char();
        let line = self.line;
        let column = self.column;
        
        match current_char {
            '(' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::LeftParen,
                    value: "(".to_string(),
                    line,
                    column,
                })
            }
            
            ')' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::RightParen,
                    value: ")".to_string(),
                    line,
                    column,
                })
            }
            
            '{' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::LeftBrace,
                    value: "{".to_string(),
                    line,
                    column,
                })
            }
            
            '}' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::RightBrace,
                    value: "}".to_string(),
                    line,
                    column,
                })
            }
            
            ';' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::Semicolon,
                    value: ";".to_string(),
                    line,
                    column,
                })
            }
            
            '+' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::Plus,
                    value: "+".to_string(),
                    line,
                    column,
                })
            }
            
            '-' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::Minus,
                    value: "-".to_string(),
                    line,
                    column,
                })
            }
            
            '*' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::Multiply,
                    value: "*".to_string(),
                    line,
                    column,
                })
            }
            
            '/' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::Divide,
                    value: "/".to_string(),
                    line,
                    column,
                })
            }
            
            '=' => {
                self.advance();
                if self.current_char() == '=' {
                    self.advance();
                    Ok(Token {
                        token_type: TokenType::Equal,
                        value: "==".to_string(),
                        line,
                        column,
                    })
                } else {
                    Ok(Token {
                        token_type: TokenType::Assign,
                        value: "=".to_string(),
                        line,
                        column,
                    })
                }
            }
            
            '<' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::LessThan,
                    value: "<".to_string(),
                    line,
                    column,
                })
            }
            
            '>' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::GreaterThan,
                    value: ">".to_string(),
                    line,
                    column,
                })
            }
            
            c if c.is_alphabetic() => {
                let identifier = self.read_identifier();
                let token_type = self.get_keyword_type(&identifier);
                Ok(Token {
                    token_type,
                    value: identifier,
                    line,
                    column,
                })
            }
            
            c if c.is_digit(10) => {
                let number = self.read_number();
                Ok(Token {
                    token_type: TokenType::Integer,
                    value: number,
                    line,
                    column,
                })
            }
            
            _ => {
                let error = format!("Unexpected character: {}", current_char);
                self.advance();
                Err(error)
            }
        }
    }
    
    /// 跳过空白字符
    fn skip_whitespace(&mut self) {
        while self.position < self.source.len() {
            let c = self.current_char();
            if c.is_whitespace() {
                if c == '\n' {
                    self.line += 1;
                    self.column = 1;
                } else {
                    self.column += 1;
                }
                self.advance();
            } else {
                break;
            }
        }
    }
    
    /// 读取标识符
    fn read_identifier(&mut self) -> String {
        let mut identifier = String::new();
        while self.position < self.source.len() {
            let c = self.current_char();
            if c.is_alphanumeric() || c == '_' {
                identifier.push(c);
                self.advance();
            } else {
                break;
            }
        }
        identifier
    }
    
    /// 读取数字
    fn read_number(&mut self) -> String {
        let mut number = String::new();
        while self.position < self.source.len() {
            let c = self.current_char();
            if c.is_digit(10) {
                number.push(c);
                self.advance();
            } else {
                break;
            }
        }
        number
    }
    
    /// 获取关键字类型
    fn get_keyword_type(&self, identifier: &str) -> TokenType {
        match identifier {
            "if" => TokenType::If,
            "else" => TokenType::Else,
            "while" => TokenType::While,
            "for" => TokenType::For,
            "function" => TokenType::Function,
            "return" => TokenType::Return,
            "let" => TokenType::Let,
            "int" => TokenType::Int,
            "bool" => TokenType::Bool,
            "true" | "false" => TokenType::Boolean,
            _ => TokenType::Identifier,
        }
    }
    
    /// 获取当前字符
    fn current_char(&self) -> char {
        self.source.chars().nth(self.position).unwrap_or('\0')
    }
    
    /// 前进到下一个字符
    fn advance(&mut self) {
        self.position += 1;
        self.column += 1;
    }
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self {
        Self {
            tokens,
            position: 0,
            ast: None,
        }
    }
    
    /// 语法分析
    pub fn parse(&mut self) -> Result<ASTNode, String> {
        let program = self.parse_program()?;
        self.ast = Some(program.clone());
        Ok(program)
    }
    
    /// 解析程序
    fn parse_program(&mut self) -> Result<ASTNode, String> {
        let mut children = Vec::new();
        
        while self.position < self.tokens.len() && self.current_token().token_type != TokenType::EOF {
            let function = self.parse_function()?;
            children.push(function);
        }
        
        Ok(ASTNode {
            node_type: ASTNodeType::Program,
            children,
            value: None,
            line: 1,
            column: 1,
        })
    }
    
    /// 解析函数
    fn parse_function(&mut self) -> Result<ASTNode, String> {
        self.expect(TokenType::Function)?;
        let name = self.expect_identifier()?;
        self.expect(TokenType::LeftParen)?;
        self.expect(TokenType::RightParen)?;
        self.expect(TokenType::LeftBrace)?;
        
        let mut body = Vec::new();
        while self.current_token().token_type != TokenType::RightBrace {
            let statement = self.parse_statement()?;
            body.push(statement);
        }
        self.expect(TokenType::RightBrace)?;
        
        Ok(ASTNode {
            node_type: ASTNodeType::Function,
            children: body,
            value: Some(name),
            line: self.current_token().line,
            column: self.current_token().column,
        })
    }
    
    /// 解析语句
    fn parse_statement(&mut self) -> Result<ASTNode, String> {
        match self.current_token().token_type {
            TokenType::If => self.parse_if_statement(),
            TokenType::While => self.parse_while_statement(),
            TokenType::Return => self.parse_return_statement(),
            TokenType::Let => self.parse_assignment(),
            _ => self.parse_expression_statement(),
        }
    }
    
    /// 解析if语句
    fn parse_if_statement(&mut self) -> Result<ASTNode, String> {
        self.expect(TokenType::If)?;
        self.expect(TokenType::LeftParen)?;
        let condition = self.parse_expression()?;
        self.expect(TokenType::RightParen)?;
        
        let then_block = self.parse_block()?;
        let else_block = if self.current_token().token_type == TokenType::Else {
            self.expect(TokenType::Else)?;
            Some(self.parse_block()?)
        } else {
            None
        };
        
        let mut children = vec![condition, then_block];
        if let Some(else_block) = else_block {
            children.push(else_block);
        }
        
        Ok(ASTNode {
            node_type: ASTNodeType::If,
            children,
            value: None,
            line: self.current_token().line,
            column: self.current_token().column,
        })
    }
    
    /// 解析while语句
    fn parse_while_statement(&mut self) -> Result<ASTNode, String> {
        self.expect(TokenType::While)?;
        self.expect(TokenType::LeftParen)?;
        let condition = self.parse_expression()?;
        self.expect(TokenType::RightParen)?;
        let body = self.parse_block()?;
        
        Ok(ASTNode {
            node_type: ASTNodeType::While,
            children: vec![condition, body],
            value: None,
            line: self.current_token().line,
            column: self.current_token().column,
        })
    }
    
    /// 解析return语句
    fn parse_return_statement(&mut self) -> Result<ASTNode, String> {
        self.expect(TokenType::Return)?;
        let value = if self.current_token().token_type != TokenType::Semicolon {
            Some(self.parse_expression()?)
        } else {
            None
        };
        self.expect(TokenType::Semicolon)?;
        
        Ok(ASTNode {
            node_type: ASTNodeType::Return,
            children: value.map(|v| vec![v]).unwrap_or_default(),
            value: None,
            line: self.current_token().line,
            column: self.current_token().column,
        })
    }
    
    /// 解析赋值语句
    fn parse_assignment(&mut self) -> Result<ASTNode, String> {
        self.expect(TokenType::Let)?;
        let name = self.expect_identifier()?;
        self.expect(TokenType::Assign)?;
        let value = self.parse_expression()?;
        self.expect(TokenType::Semicolon)?;
        
        Ok(ASTNode {
            node_type: ASTNodeType::Assignment,
            children: vec![value],
            value: Some(name),
            line: self.current_token().line,
            column: self.current_token().column,
        })
    }
    
    /// 解析表达式语句
    fn parse_expression_statement(&mut self) -> Result<ASTNode, String> {
        let expr = self.parse_expression()?;
        self.expect(TokenType::Semicolon)?;
        Ok(expr)
    }
    
    /// 解析表达式
    fn parse_expression(&mut self) -> Result<ASTNode, String> {
        self.parse_binary_expression(0)
    }
    
    /// 解析二元表达式
    fn parse_binary_expression(&mut self, precedence: u32) -> Result<ASTNode, String> {
        let mut left = self.parse_unary_expression()?;
        
        while self.position < self.tokens.len() {
            let token = self.current_token();
            let op_precedence = self.get_operator_precedence(&token.token_type);
            
            if op_precedence < precedence {
                break;
            }
            
            let operator = self.parse_operator()?;
            let right = self.parse_binary_expression(op_precedence + 1)?;
            
            left = ASTNode {
                node_type: ASTNodeType::BinaryOp,
                children: vec![left, right],
                value: Some(operator),
                line: token.line,
                column: token.column,
            };
        }
        
        Ok(left)
    }
    
    /// 解析一元表达式
    fn parse_unary_expression(&mut self) -> Result<ASTNode, String> {
        let token = self.current_token();
        
        match token.token_type {
            TokenType::Minus => {
                self.advance();
                let operand = self.parse_unary_expression()?;
                Ok(ASTNode {
                    node_type: ASTNodeType::UnaryOp,
                    children: vec![operand],
                    value: Some("-".to_string()),
                    line: token.line,
                    column: token.column,
                })
            }
            _ => self.parse_primary_expression(),
        }
    }
    
    /// 解析基本表达式
    fn parse_primary_expression(&mut self) -> Result<ASTNode, String> {
        let token = self.current_token();
        
        match token.token_type {
            TokenType::Integer => {
                self.advance();
                Ok(ASTNode {
                    node_type: ASTNodeType::Literal,
                    children: Vec::new(),
                    value: Some(token.value.clone()),
                    line: token.line,
                    column: token.column,
                })
            }
            
            TokenType::Identifier => {
                let name = token.value.clone();
                self.advance();
                Ok(ASTNode {
                    node_type: ASTNodeType::Variable,
                    children: Vec::new(),
                    value: Some(name),
                    line: token.line,
                    column: token.column,
                })
            }
            
            TokenType::LeftParen => {
                self.advance();
                let expr = self.parse_expression()?;
                self.expect(TokenType::RightParen)?;
                Ok(expr)
            }
            
            _ => Err(format!("Unexpected token: {:?}", token.token_type)),
        }
    }
    
    /// 解析代码块
    fn parse_block(&mut self) -> Result<ASTNode, String> {
        self.expect(TokenType::LeftBrace)?;
        
        let mut statements = Vec::new();
        while self.current_token().token_type != TokenType::RightBrace {
            let statement = self.parse_statement()?;
            statements.push(statement);
        }
        self.expect(TokenType::RightBrace)?;
        
        Ok(ASTNode {
            node_type: ASTNodeType::Program,
            children: statements,
            value: None,
            line: self.current_token().line,
            column: self.current_token().column,
        })
    }
    
    /// 获取操作符优先级
    fn get_operator_precedence(&self, token_type: &TokenType) -> u32 {
        match token_type {
            TokenType::Plus | TokenType::Minus => 1,
            TokenType::Multiply | TokenType::Divide => 2,
            _ => 0,
        }
    }
    
    /// 解析操作符
    fn parse_operator(&mut self) -> Result<String, String> {
        let token = self.current_token();
        match token.token_type {
            TokenType::Plus | TokenType::Minus | TokenType::Multiply | TokenType::Divide => {
                let op = token.value.clone();
                self.advance();
                Ok(op)
            }
            _ => Err(format!("Expected operator, got {:?}", token.token_type)),
        }
    }
    
    /// 期望特定类型的词法单元
    fn expect(&mut self, token_type: TokenType) -> Result<(), String> {
        if self.current_token().token_type == token_type {
            self.advance();
            Ok(())
        } else {
            Err(format!("Expected {:?}, got {:?}", token_type, self.current_token().token_type))
        }
    }
    
    /// 期望标识符
    fn expect_identifier(&mut self) -> Result<String, String> {
        if let TokenType::Identifier = self.current_token().token_type {
            let name = self.current_token().value.clone();
            self.advance();
            Ok(name)
        } else {
            Err("Expected identifier".to_string())
        }
    }
    
    /// 获取当前词法单元
    fn current_token(&self) -> &Token {
        &self.tokens[self.position]
    }
    
    /// 前进到下一个词法单元
    fn advance(&mut self) {
        self.position += 1;
    }
}

impl IRGenerator {
    pub fn new() -> Self {
        Self {
            variables: HashMap::new(),
            temp_counter: 0,
            label_counter: 0,
            instructions: Vec::new(),
        }
    }
    
    /// 生成中间代码
    pub fn generate(&mut self, ast: &ASTNode) -> Result<Vec<IRNode>, String> {
        self.generate_node(ast)?;
        Ok(self.instructions.clone())
    }
    
    /// 生成节点代码
    fn generate_node(&mut self, node: &ASTNode) -> Result<String, String> {
        match node.node_type {
            ASTNodeType::Program => {
                for child in &node.children {
                    self.generate_node(child)?;
                }
                Ok("".to_string())
            }
            
            ASTNodeType::Function => {
                let label = format!("func_{}", node.value.as_ref().unwrap());
                self.instructions.push(IRNode {
                    ir_type: IRType::Label,
                    operands: Vec::new(),
                    result: None,
                    label: Some(label.clone()),
                });
                
                for child in &node.children {
                    self.generate_node(child)?;
                }
                
                self.instructions.push(IRNode {
                    ir_type: IRType::Return,
                    operands: Vec::new(),
                    result: None,
                    label: None,
                });
                
                Ok(label)
            }
            
            ASTNodeType::Assignment => {
                let value = self.generate_node(&node.children[0])?;
                let var_name = node.value.as_ref().unwrap();
                
                self.instructions.push(IRNode {
                    ir_type: IRType::Move,
                    operands: vec![value],
                    result: Some(var_name.clone()),
                    label: None,
                });
                
                Ok(var_name.clone())
            }
            
            ASTNodeType::BinaryOp => {
                let left = self.generate_node(&node.children[0])?;
                let right = self.generate_node(&node.children[1])?;
                let result = self.new_temp();
                
                let ir_type = match node.value.as_ref().unwrap().as_str() {
                    "+" => IRType::Add,
                    "-" => IRType::Subtract,
                    "*" => IRType::Multiply,
                    "/" => IRType::Divide,
                    _ => return Err("Unknown binary operator".to_string()),
                };
                
                self.instructions.push(IRNode {
                    ir_type,
                    operands: vec![left, right],
                    result: Some(result.clone()),
                    label: None,
                });
                
                Ok(result)
            }
            
            ASTNodeType::Literal => {
                let temp = self.new_temp();
                self.instructions.push(IRNode {
                    ir_type: IRType::Move,
                    operands: vec![node.value.as_ref().unwrap().clone()],
                    result: Some(temp.clone()),
                    label: None,
                });
                Ok(temp)
            }
            
            ASTNodeType::Variable => {
                Ok(node.value.as_ref().unwrap().clone())
            }
            
            ASTNodeType::If => {
                let condition = self.generate_node(&node.children[0])?;
                let then_label = self.new_label();
                let end_label = self.new_label();
                
                // 条件跳转
                self.instructions.push(IRNode {
                    ir_type: IRType::JumpIfFalse,
                    operands: vec![condition],
                    result: None,
                    label: Some(end_label.clone()),
                });
                
                // then块
                self.instructions.push(IRNode {
                    ir_type: IRType::Label,
                    operands: Vec::new(),
                    result: None,
                    label: Some(then_label.clone()),
                });
                
                self.generate_node(&node.children[1])?;
                
                // 跳转到结束
                self.instructions.push(IRNode {
                    ir_type: IRType::Jump,
                    operands: Vec::new(),
                    result: None,
                    label: Some(end_label.clone()),
                });
                
                // else块（如果存在）
                if node.children.len() > 2 {
                    let else_label = self.new_label();
                    self.instructions.push(IRNode {
                        ir_type: IRType::Label,
                        operands: Vec::new(),
                        result: None,
                        label: Some(else_label.clone()),
                    });
                    
                    self.generate_node(&node.children[2])?;
                }
                
                // 结束标签
                self.instructions.push(IRNode {
                    ir_type: IRType::Label,
                    operands: Vec::new(),
                    result: None,
                    label: Some(end_label),
                });
                
                Ok("".to_string())
            }
            
            ASTNodeType::While => {
                let start_label = self.new_label();
                let body_label = self.new_label();
                let end_label = self.new_label();
                
                // 开始标签
                self.instructions.push(IRNode {
                    ir_type: IRType::Label,
                    operands: Vec::new(),
                    result: None,
                    label: Some(start_label.clone()),
                });
                
                // 条件
                let condition = self.generate_node(&node.children[0])?;
                
                // 条件跳转
                self.instructions.push(IRNode {
                    ir_type: IRType::JumpIfFalse,
                    operands: vec![condition],
                    result: None,
                    label: Some(end_label.clone()),
                });
                
                // 循环体
                self.generate_node(&node.children[1])?;
                
                // 跳回开始
                self.instructions.push(IRNode {
                    ir_type: IRType::Jump,
                    operands: Vec::new(),
                    result: None,
                    label: Some(start_label),
                });
                
                // 结束标签
                self.instructions.push(IRNode {
                    ir_type: IRType::Label,
                    operands: Vec::new(),
                    result: None,
                    label: Some(end_label),
                });
                
                Ok("".to_string())
            }
            
            _ => Ok("".to_string()),
        }
    }
    
    /// 生成新的临时变量
    fn new_temp(&mut self) -> String {
        self.temp_counter += 1;
        format!("t{}", self.temp_counter)
    }
    
    /// 生成新的标签
    fn new_label(&mut self) -> String {
        self.label_counter += 1;
        format!("L{}", self.label_counter)
    }
}

impl Optimizer {
    pub fn new() -> Self {
        Self {
            optimizations: vec![
                OptimizationPass {
                    name: "Constant Folding".to_string(),
                    description: "Evaluate constant expressions at compile time".to_string(),
                    enabled: true,
                },
                OptimizationPass {
                    name: "Dead Code Elimination".to_string(),
                    description: "Remove unreachable code".to_string(),
                    enabled: true,
                },
                OptimizationPass {
                    name: "Common Subexpression Elimination".to_string(),
                    description: "Eliminate redundant computations".to_string(),
                    enabled: true,
                },
            ],
        }
    }
    
    /// 优化中间代码
    pub fn optimize(&self, instructions: &[IRNode]) -> Vec<IRNode> {
        let mut optimized = instructions.to_vec();
        
        for pass in &self.optimizations {
            if pass.enabled {
                optimized = self.apply_optimization_pass(&optimized, pass);
            }
        }
        
        optimized
    }
    
    /// 应用优化通道
    fn apply_optimization_pass(&self, instructions: &[IRNode], pass: &OptimizationPass) -> Vec<IRNode> {
        match pass.name.as_str() {
            "Constant Folding" => self.constant_folding(instructions),
            "Dead Code Elimination" => self.dead_code_elimination(instructions),
            "Common Subexpression Elimination" => self.cse(instructions),
            _ => instructions.to_vec(),
        }
    }
    
    /// 常量折叠
    fn constant_folding(&self, instructions: &[IRNode]) -> Vec<IRNode> {
        let mut optimized = Vec::new();
        
        for instruction in instructions {
            match instruction.ir_type {
                IRType::Add => {
                    if let (Some(left), Some(right)) = (&instruction.operands.get(0), &instruction.operands.get(1)) {
                        if let (Ok(l), Ok(r)) = (left.parse::<i64>(), right.parse::<i64>()) {
                            let result = l + r;
                            optimized.push(IRNode {
                                ir_type: IRType::Move,
                                operands: vec![result.to_string()],
                                result: instruction.result.clone(),
                                label: instruction.label.clone(),
                            });
                            continue;
                        }
                    }
                }
                _ => {}
            }
            optimized.push(instruction.clone());
        }
        
        optimized
    }
    
    /// 死代码消除
    fn dead_code_elimination(&self, instructions: &[IRNode]) -> Vec<IRNode> {
        let mut optimized = Vec::new();
        let mut reachable = true;
        
        for instruction in instructions {
            if !reachable && instruction.ir_type != IRType::Label {
                continue;
            }
            
            match instruction.ir_type {
                IRType::Jump => {
                    optimized.push(instruction.clone());
                    reachable = false;
                }
                IRType::Return => {
                    optimized.push(instruction.clone());
                    reachable = false;
                }
                IRType::Label => {
                    reachable = true;
                    optimized.push(instruction.clone());
                }
                _ => {
                    optimized.push(instruction.clone());
                }
            }
        }
        
        optimized
    }
    
    /// 公共子表达式消除
    fn cse(&self, instructions: &[IRNode]) -> Vec<IRNode> {
        let mut optimized = Vec::new();
        let mut expressions = HashMap::new();
        
        for instruction in instructions {
            let key = format!("{:?}_{:?}", instruction.ir_type, instruction.operands);
            
            if let Some(existing_result) = expressions.get(&key) {
                // 替换为已存在的表达式
                optimized.push(IRNode {
                    ir_type: IRType::Move,
                    operands: vec![existing_result.clone()],
                    result: instruction.result.clone(),
                    label: instruction.label.clone(),
                });
            } else {
                // 记录新表达式
                if let Some(ref result) = instruction.result {
                    expressions.insert(key, result.clone());
                }
                optimized.push(instruction.clone());
            }
        }
        
        optimized
    }
}

impl CodeGenerator {
    pub fn new(target_arch: TargetArchitecture) -> Self {
        Self {
            target_arch,
            registers: vec!["rax".to_string(), "rbx".to_string(), "rcx".to_string(), "rdx".to_string()],
            instructions: Vec::new(),
        }
    }
    
    /// 生成目标代码
    pub fn generate(&mut self, ir_instructions: &[IRNode]) -> Result<Vec<AssemblyInstruction>, String> {
        for instruction in ir_instructions {
            self.generate_instruction(instruction)?;
        }
        Ok(self.instructions.clone())
    }
    
    /// 生成单个指令
    fn generate_instruction(&mut self, ir: &IRNode) -> Result<(), String> {
        match ir.ir_type {
            IRType::Move => {
                if let Some(result) = &ir.result {
                    if ir.operands.len() == 1 {
                        self.instructions.push(AssemblyInstruction {
                            mnemonic: "mov".to_string(),
                            operands: vec![result.clone(), ir.operands[0].clone()],
                            comment: Some("Move value".to_string()),
                        });
                    }
                }
            }
            
            IRType::Add => {
                if let Some(result) = &ir.result {
                    if ir.operands.len() == 2 {
                        self.instructions.push(AssemblyInstruction {
                            mnemonic: "add".to_string(),
                            operands: vec![result.clone(), ir.operands[0].clone()],
                            comment: Some("Add operation".to_string()),
                        });
                    }
                }
            }
            
            IRType::Label => {
                if let Some(label) = &ir.label {
                    self.instructions.push(AssemblyInstruction {
                        mnemonic: format!("{}:", label),
                        operands: Vec::new(),
                        comment: Some("Label".to_string()),
                    });
                }
            }
            
            IRType::Jump => {
                if let Some(label) = &ir.label {
                    self.instructions.push(AssemblyInstruction {
                        mnemonic: "jmp".to_string(),
                        operands: vec![label.clone()],
                        comment: Some("Unconditional jump".to_string()),
                    });
                }
            }
            
            IRType::JumpIfFalse => {
                if let Some(label) = &ir.label {
                    if ir.operands.len() == 1 {
                        self.instructions.push(AssemblyInstruction {
                            mnemonic: "cmp".to_string(),
                            operands: vec![ir.operands[0].clone(), "0".to_string()],
                            comment: Some("Compare with zero".to_string()),
                        });
                        
                        self.instructions.push(AssemblyInstruction {
                            mnemonic: "je".to_string(),
                            operands: vec![label.clone()],
                            comment: Some("Jump if equal".to_string()),
                        });
                    }
                }
            }
            
            IRType::Return => {
                self.instructions.push(AssemblyInstruction {
                    mnemonic: "ret".to_string(),
                    operands: Vec::new(),
                    comment: Some("Return from function".to_string()),
                });
            }
            
            _ => {
                // 简化处理其他指令
                self.instructions.push(AssemblyInstruction {
                    mnemonic: format!("{:?}", ir.ir_type),
                    operands: ir.operands.clone(),
                    comment: Some("Generated instruction".to_string()),
                });
            }
        }
        
        Ok(())
    }
}

impl Compiler {
    pub fn new() -> Self {
        Self {
            lexer: Lexer::new(String::new()),
            parser: Parser::new(Vec::new()),
            ir_generator: IRGenerator::new(),
            optimizer: Optimizer::new(),
            code_generator: CodeGenerator::new(TargetArchitecture::X86_64),
            error_handler: ErrorHandler {
                errors: Vec::new(),
                warnings: Vec::new(),
            },
        }
    }
    
    /// 编译源代码
    pub fn compile(&mut self, source: &str) -> Result<Vec<AssemblyInstruction>, String> {
        // 词法分析
        self.lexer = Lexer::new(source.to_string());
        let tokens = self.lexer.tokenize()?;
        
        // 语法分析
        self.parser = Parser::new(tokens);
        let ast = self.parser.parse()?;
        
        // 中间代码生成
        let ir_instructions = self.ir_generator.generate(&ast)?;
        
        // 代码优化
        let optimized_ir = self.optimizer.optimize(&ir_instructions);
        
        // 目标代码生成
        let assembly = self.code_generator.generate(&optimized_ir)?;
        
        Ok(assembly)
    }
}

impl fmt::Display for AssemblyInstruction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.mnemonic)?;
        
        if !self.operands.is_empty() {
            write!(f, " {}", self.operands.join(", "))?;
        }
        
        if let Some(ref comment) = self.comment {
            write!(f, " ; {}", comment)?;
        }
        
        Ok(())
    }
}

## 5. 应用示例

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_lexer() {
        let source = "let x = 5 + 3;";
        let mut lexer = Lexer::new(source.to_string());
        let tokens = lexer.tokenize().unwrap();
        
        assert_eq!(tokens.len(), 7); // let, x, =, 5, +, 3, ;
        assert_eq!(tokens[0].token_type, TokenType::Let);
        assert_eq!(tokens[1].token_type, TokenType::Identifier);
        assert_eq!(tokens[2].token_type, TokenType::Assign);
    }
    
    #[test]
    fn test_parser() {
        let source = "function main() { let x = 5; return x; }";
        let mut lexer = Lexer::new(source.to_string());
        let tokens = lexer.tokenize().unwrap();
        
        let mut parser = Parser::new(tokens);
        let ast = parser.parse().unwrap();
        
        assert_eq!(ast.node_type, ASTNodeType::Program);
        assert_eq!(ast.children.len(), 1);
        assert_eq!(ast.children[0].node_type, ASTNodeType::Function);
    }
    
    #[test]
    fn test_ir_generation() {
        let source = "let x = 5 + 3;";
        let mut lexer = Lexer::new(source.to_string());
        let tokens = lexer.tokenize().unwrap();
        
        let mut parser = Parser::new(tokens);
        let ast = parser.parse().unwrap();
        
        let mut ir_generator = IRGenerator::new();
        let ir_instructions = ir_generator.generate(&ast).unwrap();
        
        assert!(!ir_instructions.is_empty());
        assert_eq!(ir_instructions[0].ir_type, IRType::Move);
    }
    
    #[test]
    fn test_optimization() {
        let instructions = vec![
            IRNode {
                ir_type: IRType::Add,
                operands: vec!["5".to_string(), "3".to_string()],
                result: Some("t1".to_string()),
                label: None,
            },
        ];
        
        let optimizer = Optimizer::new();
        let optimized = optimizer.optimize(&instructions);
        
        assert_eq!(optimized[0].ir_type, IRType::Move);
        assert_eq!(optimized[0].operands[0], "8");
    }
    
    #[test]
    fn test_code_generation() {
        let ir_instructions = vec![
            IRNode {
                ir_type: IRType::Move,
                operands: vec!["5".to_string()],
                result: Some("x".to_string()),
                label: None,
            },
        ];
        
        let mut code_generator = CodeGenerator::new(TargetArchitecture::X86_64);
        let assembly = code_generator.generate(&ir_instructions).unwrap();
        
        assert!(!assembly.is_empty());
        assert_eq!(assembly[0].mnemonic, "mov");
    }
    
    #[test]
    fn test_full_compilation() {
        let source = "function main() { let x = 5 + 3; return x; }";
        let mut compiler = Compiler::new();
        let assembly = compiler.compile(source).unwrap();
        
        assert!(!assembly.is_empty());
    }
    
    #[test]
    fn test_error_handling() {
        let source = "let x = 5 + ;"; // 语法错误
        let mut lexer = Lexer::new(source.to_string());
        let result = lexer.tokenize();
        
        assert!(result.is_err());
    }
}
```

## 6. 相关理论

- 形式语言理论
- 自动机理论
- 代码优化理论
- 计算机体系结构

## 7. 参考文献

1. Aho, A. V., et al. "Compilers: Principles, Techniques, and Tools"
2. Appel, A. W. "Modern Compiler Implementation in ML"
3. Cooper, K. D., Torczon, L. "Engineering a Compiler"
4. Muchnick, S. S. "Advanced Compiler Design and Implementation"

---

**相关链接**：

- [08.2.2 代码优化理论](../08.2.2_代码优化理论.md)
- [08.2.3 虚拟机理论](../08.2.3_虚拟机理论.md)
- [08.2.4 解释器理论](../08.2.4_解释器理论.md)
