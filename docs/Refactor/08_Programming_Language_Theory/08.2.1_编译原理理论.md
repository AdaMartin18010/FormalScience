# 08.2.1 ç¼–è¯‘åŸç†ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç¼–è¯‘åŸç†ç†è®ºæ˜¯ç¼–ç¨‹è¯­è¨€ç†è®ºä¸­ç ”ç©¶ç¨‹åºç¼–è¯‘å’Œä»£ç ç”Ÿæˆçš„æ ¸å¿ƒç†è®ºä½“ç³»ï¼Œé€šè¿‡å»ºç«‹å½¢å¼åŒ–çš„ç¼–è¯‘æ¡†æ¶ï¼Œä¸ºç¼–ç¨‹è¯­è¨€çš„ç¼–è¯‘å™¨è®¾è®¡å’Œä¼˜åŒ–æä¾›ç§‘å­¦ä¾æ®ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ç¼–è¯‘åŸç†çš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°Rustç¼–è¯‘å™¨ç¤ºä¾‹
4. åˆ†æç¼–è¯‘ä¼˜åŒ–ä¸ä»£ç ç”Ÿæˆ

## ğŸ“š ç›®å½•

1. åŸºæœ¬æ¦‚å¿µ
2. å½¢å¼åŒ–å®šä¹‰
3. å®šç†ä¸è¯æ˜
4. ä»£ç å®ç°
5. åº”ç”¨ç¤ºä¾‹
6. ç›¸å…³ç†è®º
7. å‚è€ƒæ–‡çŒ®

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç¼–è¯‘å®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆç¼–è¯‘ï¼‰
ç¼–è¯‘æ˜¯å°†é«˜çº§ç¼–ç¨‹è¯­è¨€è½¬æ¢ä¸ºä½çº§æœºå™¨è¯­è¨€çš„è¿‡ç¨‹ï¼ŒåŒ…æ‹¬è¯æ³•åˆ†æã€è¯­æ³•åˆ†æã€è¯­ä¹‰åˆ†æã€ä¸­é—´ä»£ç ç”Ÿæˆã€ä»£ç ä¼˜åŒ–å’Œç›®æ ‡ä»£ç ç”Ÿæˆã€‚

### 1.2 ç¼–è¯‘é˜¶æ®µ

- è¯æ³•åˆ†æï¼ˆLexical Analysisï¼‰
- è¯­æ³•åˆ†æï¼ˆSyntax Analysisï¼‰
- è¯­ä¹‰åˆ†æï¼ˆSemantic Analysisï¼‰
- ä¸­é—´ä»£ç ç”Ÿæˆï¼ˆIntermediate Code Generationï¼‰
- ä»£ç ä¼˜åŒ–ï¼ˆCode Optimizationï¼‰
- ç›®æ ‡ä»£ç ç”Ÿæˆï¼ˆTarget Code Generationï¼‰

## 2. å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1**ï¼ˆç¼–è¯‘å™¨æ¨¡å‹ï¼‰
ç¼–è¯‘å™¨æ¨¡å‹æ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $CM = (L, P, S, I, O, T, E)$ï¼Œå…¶ä¸­ï¼š

- $L$ æ˜¯è¯æ³•åˆ†æå™¨é›†åˆ
- $P$ æ˜¯è¯­æ³•åˆ†æå™¨é›†åˆ
- $S$ æ˜¯è¯­ä¹‰åˆ†æå™¨é›†åˆ
- $I$ æ˜¯ä¸­é—´ä»£ç ç”Ÿæˆå™¨é›†åˆ
- $O$ æ˜¯ä»£ç ä¼˜åŒ–å™¨é›†åˆ
- $T$ æ˜¯ç›®æ ‡ä»£ç ç”Ÿæˆå™¨é›†åˆ
- $E$ æ˜¯é”™è¯¯å¤„ç†å™¨é›†åˆ

**å®šä¹‰ 2.2**ï¼ˆç¼–è¯‘è¿‡ç¨‹ï¼‰
ç¼–è¯‘è¿‡ç¨‹ $C$ æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$C: \text{Source Code} \rightarrow \text{Target Code}$

**å®šç† 2.1**ï¼ˆç¼–è¯‘æ­£ç¡®æ€§ï¼‰
ç¼–è¯‘å™¨åº”è¯¥ä¿æŒæºç¨‹åºçš„è¯­ä¹‰ã€‚

**è¯æ˜**ï¼š
é€šè¿‡è¯­ä¹‰ä¿æŒæ€§è¯æ˜ï¼Œç¡®ä¿ç¼–è¯‘åçš„ç¨‹åºä¸æºç¨‹åºè¡Œä¸ºä¸€è‡´ã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

**å®šç† 3.1**ï¼ˆç¼–è¯‘æ•ˆç‡ï¼‰
ç¼–è¯‘æ—¶é—´åº”è¯¥ä¸æºç¨‹åºå¤§å°æˆçº¿æ€§å…³ç³»ã€‚

**è¯æ˜**ï¼š
å„ç¼–è¯‘é˜¶æ®µçš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯çº¿æ€§çš„ï¼Œå› æ­¤æ€»ä½“ç¼–è¯‘æ—¶é—´ä¹Ÿæ˜¯çº¿æ€§çš„ã€‚$\square$

**å®šç† 3.2**ï¼ˆä¼˜åŒ–æœ‰æ•ˆæ€§ï¼‰
ä»£ç ä¼˜åŒ–åº”è¯¥æé«˜ç›®æ ‡ç¨‹åºçš„æ‰§è¡Œæ•ˆç‡ã€‚

**è¯æ˜**ï¼š
é€šè¿‡é™æ€åˆ†æå’Œç¨‹åºå˜æ¢ï¼Œæ¶ˆé™¤å†—ä½™è®¡ç®—å’Œæ”¹è¿›ç¨‹åºç»“æ„ã€‚$\square$

## 4. ä»£ç å®ç°

```rust
use std::collections::HashMap;
use std::fmt;

/// è¯æ³•å•å…ƒ
#[derive(Debug, Clone, PartialEq)]
pub struct Token {
    pub token_type: TokenType,
    pub value: String,
    pub line: usize,
    pub column: usize,
}

/// è¯æ³•å•å…ƒç±»å‹
#[derive(Debug, Clone, PartialEq)]
pub enum TokenType {
    // å…³é”®å­—
    If,
    Else,
    While,
    For,
    Function,
    Return,
    Let,
    Int,
    Bool,
    
    // æ ‡è¯†ç¬¦å’Œå­—é¢é‡
    Identifier,
    Integer,
    Boolean,
    String,
    
    // æ“ä½œç¬¦
    Plus,
    Minus,
    Multiply,
    Divide,
    Assign,
    Equal,
    LessThan,
    GreaterThan,
    
    // åˆ†éš”ç¬¦
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    Semicolon,
    Comma,
    
    // ç‰¹æ®Š
    EOF,
    Error,
}

/// è¯æ³•åˆ†æå™¨
pub struct Lexer {
    pub source: String,
    pub position: usize,
    pub line: usize,
    pub column: usize,
    pub tokens: Vec<Token>,
}

/// æŠ½è±¡è¯­æ³•æ ‘èŠ‚ç‚¹
pub struct ASTNode {
    pub node_type: ASTNodeType,
    pub children: Vec<ASTNode>,
    pub value: Option<String>,
    pub line: usize,
    pub column: usize,
}

/// ASTèŠ‚ç‚¹ç±»å‹
#[derive(Debug, Clone)]
pub enum ASTNodeType {
    Program,
    Function,
    Variable,
    Assignment,
    BinaryOp,
    UnaryOp,
    If,
    While,
    Return,
    Call,
    Literal,
}

/// è¯­æ³•åˆ†æå™¨
pub struct Parser {
    pub tokens: Vec<Token>,
    pub position: usize,
    pub ast: Option<ASTNode>,
}

/// ä¸­é—´è¡¨ç¤º
pub struct IRNode {
    pub ir_type: IRType,
    pub operands: Vec<String>,
    pub result: Option<String>,
    pub label: Option<String>,
}

/// IRç±»å‹
#[derive(Debug, Clone)]
pub enum IRType {
    // ç®—æœ¯æ“ä½œ
    Add,
    Subtract,
    Multiply,
    Divide,
    
    // æ¯”è¾ƒæ“ä½œ
    Compare,
    Jump,
    JumpIfFalse,
    
    // å†…å­˜æ“ä½œ
    Load,
    Store,
    Allocate,
    
    // å‡½æ•°æ“ä½œ
    Call,
    Return,
    Label,
    
    // å…¶ä»–
    Move,
    Nop,
}

/// ä¸­é—´ä»£ç ç”Ÿæˆå™¨
pub struct IRGenerator {
    pub variables: HashMap<String, String>,
    pub temp_counter: u32,
    pub label_counter: u32,
    pub instructions: Vec<IRNode>,
}

/// ä»£ç ä¼˜åŒ–å™¨
pub struct Optimizer {
    pub optimizations: Vec<OptimizationPass>,
}

/// ä¼˜åŒ–é€šé“
pub struct OptimizationPass {
    pub name: String,
    pub description: String,
    pub enabled: bool,
}

/// ç›®æ ‡ä»£ç ç”Ÿæˆå™¨
pub struct CodeGenerator {
    pub target_arch: TargetArchitecture,
    pub registers: Vec<String>,
    pub instructions: Vec<AssemblyInstruction>,
}

/// ç›®æ ‡æ¶æ„
#[derive(Debug, Clone)]
pub enum TargetArchitecture {
    X86,
    X86_64,
    ARM,
    ARM64,
    RISC_V,
}

/// æ±‡ç¼–æŒ‡ä»¤
pub struct AssemblyInstruction {
    pub mnemonic: String,
    pub operands: Vec<String>,
    pub comment: Option<String>,
}

/// ç¼–è¯‘å™¨
pub struct Compiler {
    pub lexer: Lexer,
    pub parser: Parser,
    pub ir_generator: IRGenerator,
    pub optimizer: Optimizer,
    pub code_generator: CodeGenerator,
    pub error_handler: ErrorHandler,
}

/// é”™è¯¯å¤„ç†å™¨
pub struct ErrorHandler {
    pub errors: Vec<CompilationError>,
    pub warnings: Vec<CompilationWarning>,
}

/// ç¼–è¯‘é”™è¯¯
pub struct CompilationError {
    pub message: String,
    pub line: usize,
    pub column: usize,
    pub severity: ErrorSeverity,
}

/// é”™è¯¯ä¸¥é‡ç¨‹åº¦
#[derive(Debug, Clone)]
pub enum ErrorSeverity {
    Error,
    Warning,
    Info,
}

/// ç¼–è¯‘è­¦å‘Š
pub struct CompilationWarning {
    pub message: String,
    pub line: usize,
    pub column: usize,
}

impl Lexer {
    pub fn new(source: String) -> Self {
        Self {
            source,
            position: 0,
            line: 1,
            column: 1,
            tokens: Vec::new(),
        }
    }
    
    /// è¯æ³•åˆ†æ
    pub fn tokenize(&mut self) -> Result<Vec<Token>, String> {
        while self.position < self.source.len() {
            let token = self.next_token()?;
            self.tokens.push(token);
        }
        
        // æ·»åŠ EOFæ ‡è®°
        self.tokens.push(Token {
            token_type: TokenType::EOF,
            value: "".to_string(),
            line: self.line,
            column: self.column,
        });
        
        Ok(self.tokens.clone())
    }
    
    /// è·å–ä¸‹ä¸€ä¸ªè¯æ³•å•å…ƒ
    fn next_token(&mut self) -> Result<Token, String> {
        self.skip_whitespace();
        
        if self.position >= self.source.len() {
            return Ok(Token {
                token_type: TokenType::EOF,
                value: "".to_string(),
                line: self.line,
                column: self.column,
            });
        }
        
        let current_char = self.current_char();
        let line = self.line;
        let column = self.column;
        
        match current_char {
            '(' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::LeftParen,
                    value: "(".to_string(),
                    line,
                    column,
                })
            }
            
            ')' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::RightParen,
                    value: ")".to_string(),
                    line,
                    column,
                })
            }
            
            '{' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::LeftBrace,
                    value: "{".to_string(),
                    line,
                    column,
                })
            }
            
            '}' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::RightBrace,
                    value: "}".to_string(),
                    line,
                    column,
                })
            }
            
            ';' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::Semicolon,
                    value: ";".to_string(),
                    line,
                    column,
                })
            }
            
            '+' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::Plus,
                    value: "+".to_string(),
                    line,
                    column,
                })
            }
            
            '-' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::Minus,
                    value: "-".to_string(),
                    line,
                    column,
                })
            }
            
            '*' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::Multiply,
                    value: "*".to_string(),
                    line,
                    column,
                })
            }
            
            '/' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::Divide,
                    value: "/".to_string(),
                    line,
                    column,
                })
            }
            
            '=' => {
                self.advance();
                if self.current_char() == '=' {
                    self.advance();
                    Ok(Token {
                        token_type: TokenType::Equal,
                        value: "==".to_string(),
                        line,
                        column,
                    })
                } else {
                    Ok(Token {
                        token_type: TokenType::Assign,
                        value: "=".to_string(),
                        line,
                        column,
                    })
                }
            }
            
            '<' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::LessThan,
                    value: "<".to_string(),
                    line,
                    column,
                })
            }
            
            '>' => {
                self.advance();
                Ok(Token {
                    token_type: TokenType::GreaterThan,
                    value: ">".to_string(),
                    line,
                    column,
                })
            }
            
            c if c.is_alphabetic() => {
                let identifier = self.read_identifier();
                let token_type = self.get_keyword_type(&identifier);
                Ok(Token {
                    token_type,
                    value: identifier,
                    line,
                    column,
                })
            }
            
            c if c.is_digit(10) => {
                let number = self.read_number();
                Ok(Token {
                    token_type: TokenType::Integer,
                    value: number,
                    line,
                    column,
                })
            }
            
            _ => {
                let error = format!("Unexpected character: {}", current_char);
                self.advance();
                Err(error)
            }
        }
    }
    
    /// è·³è¿‡ç©ºç™½å­—ç¬¦
    fn skip_whitespace(&mut self) {
        while self.position < self.source.len() {
            let c = self.current_char();
            if c.is_whitespace() {
                if c == '\n' {
                    self.line += 1;
                    self.column = 1;
                } else {
                    self.column += 1;
                }
                self.advance();
            } else {
                break;
            }
        }
    }
    
    /// è¯»å–æ ‡è¯†ç¬¦
    fn read_identifier(&mut self) -> String {
        let mut identifier = String::new();
        while self.position < self.source.len() {
            let c = self.current_char();
            if c.is_alphanumeric() || c == '_' {
                identifier.push(c);
                self.advance();
            } else {
                break;
            }
        }
        identifier
    }
    
    /// è¯»å–æ•°å­—
    fn read_number(&mut self) -> String {
        let mut number = String::new();
        while self.position < self.source.len() {
            let c = self.current_char();
            if c.is_digit(10) {
                number.push(c);
                self.advance();
            } else {
                break;
            }
        }
        number
    }
    
    /// è·å–å…³é”®å­—ç±»å‹
    fn get_keyword_type(&self, identifier: &str) -> TokenType {
        match identifier {
            "if" => TokenType::If,
            "else" => TokenType::Else,
            "while" => TokenType::While,
            "for" => TokenType::For,
            "function" => TokenType::Function,
            "return" => TokenType::Return,
            "let" => TokenType::Let,
            "int" => TokenType::Int,
            "bool" => TokenType::Bool,
            "true" | "false" => TokenType::Boolean,
            _ => TokenType::Identifier,
        }
    }
    
    /// è·å–å½“å‰å­—ç¬¦
    fn current_char(&self) -> char {
        self.source.chars().nth(self.position).unwrap_or('\0')
    }
    
    /// å‰è¿›åˆ°ä¸‹ä¸€ä¸ªå­—ç¬¦
    fn advance(&mut self) {
        self.position += 1;
        self.column += 1;
    }
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self {
        Self {
            tokens,
            position: 0,
            ast: None,
        }
    }
    
    /// è¯­æ³•åˆ†æ
    pub fn parse(&mut self) -> Result<ASTNode, String> {
        let program = self.parse_program()?;
        self.ast = Some(program.clone());
        Ok(program)
    }
    
    /// è§£æç¨‹åº
    fn parse_program(&mut self) -> Result<ASTNode, String> {
        let mut children = Vec::new();
        
        while self.position < self.tokens.len() && self.current_token().token_type != TokenType::EOF {
            let function = self.parse_function()?;
            children.push(function);
        }
        
        Ok(ASTNode {
            node_type: ASTNodeType::Program,
            children,
            value: None,
            line: 1,
            column: 1,
        })
    }
    
    /// è§£æå‡½æ•°
    fn parse_function(&mut self) -> Result<ASTNode, String> {
        self.expect(TokenType::Function)?;
        let name = self.expect_identifier()?;
        self.expect(TokenType::LeftParen)?;
        self.expect(TokenType::RightParen)?;
        self.expect(TokenType::LeftBrace)?;
        
        let mut body = Vec::new();
        while self.current_token().token_type != TokenType::RightBrace {
            let statement = self.parse_statement()?;
            body.push(statement);
        }
        self.expect(TokenType::RightBrace)?;
        
        Ok(ASTNode {
            node_type: ASTNodeType::Function,
            children: body,
            value: Some(name),
            line: self.current_token().line,
            column: self.current_token().column,
        })
    }
    
    /// è§£æè¯­å¥
    fn parse_statement(&mut self) -> Result<ASTNode, String> {
        match self.current_token().token_type {
            TokenType::If => self.parse_if_statement(),
            TokenType::While => self.parse_while_statement(),
            TokenType::Return => self.parse_return_statement(),
            TokenType::Let => self.parse_assignment(),
            _ => self.parse_expression_statement(),
        }
    }
    
    /// è§£æifè¯­å¥
    fn parse_if_statement(&mut self) -> Result<ASTNode, String> {
        self.expect(TokenType::If)?;
        self.expect(TokenType::LeftParen)?;
        let condition = self.parse_expression()?;
        self.expect(TokenType::RightParen)?;
        
        let then_block = self.parse_block()?;
        let else_block = if self.current_token().token_type == TokenType::Else {
            self.expect(TokenType::Else)?;
            Some(self.parse_block()?)
        } else {
            None
        };
        
        let mut children = vec![condition, then_block];
        if let Some(else_block) = else_block {
            children.push(else_block);
        }
        
        Ok(ASTNode {
            node_type: ASTNodeType::If,
            children,
            value: None,
            line: self.current_token().line,
            column: self.current_token().column,
        })
    }
    
    /// è§£æwhileè¯­å¥
    fn parse_while_statement(&mut self) -> Result<ASTNode, String> {
        self.expect(TokenType::While)?;
        self.expect(TokenType::LeftParen)?;
        let condition = self.parse_expression()?;
        self.expect(TokenType::RightParen)?;
        let body = self.parse_block()?;
        
        Ok(ASTNode {
            node_type: ASTNodeType::While,
            children: vec![condition, body],
            value: None,
            line: self.current_token().line,
            column: self.current_token().column,
        })
    }
    
    /// è§£æreturnè¯­å¥
    fn parse_return_statement(&mut self) -> Result<ASTNode, String> {
        self.expect(TokenType::Return)?;
        let value = if self.current_token().token_type != TokenType::Semicolon {
            Some(self.parse_expression()?)
        } else {
            None
        };
        self.expect(TokenType::Semicolon)?;
        
        Ok(ASTNode {
            node_type: ASTNodeType::Return,
            children: value.map(|v| vec![v]).unwrap_or_default(),
            value: None,
            line: self.current_token().line,
            column: self.current_token().column,
        })
    }
    
    /// è§£æèµ‹å€¼è¯­å¥
    fn parse_assignment(&mut self) -> Result<ASTNode, String> {
        self.expect(TokenType::Let)?;
        let name = self.expect_identifier()?;
        self.expect(TokenType::Assign)?;
        let value = self.parse_expression()?;
        self.expect(TokenType::Semicolon)?;
        
        Ok(ASTNode {
            node_type: ASTNodeType::Assignment,
            children: vec![value],
            value: Some(name),
            line: self.current_token().line,
            column: self.current_token().column,
        })
    }
    
    /// è§£æè¡¨è¾¾å¼è¯­å¥
    fn parse_expression_statement(&mut self) -> Result<ASTNode, String> {
        let expr = self.parse_expression()?;
        self.expect(TokenType::Semicolon)?;
        Ok(expr)
    }
    
    /// è§£æè¡¨è¾¾å¼
    fn parse_expression(&mut self) -> Result<ASTNode, String> {
        self.parse_binary_expression(0)
    }
    
    /// è§£æäºŒå…ƒè¡¨è¾¾å¼
    fn parse_binary_expression(&mut self, precedence: u32) -> Result<ASTNode, String> {
        let mut left = self.parse_unary_expression()?;
        
        while self.position < self.tokens.len() {
            let token = self.current_token();
            let op_precedence = self.get_operator_precedence(&token.token_type);
            
            if op_precedence < precedence {
                break;
            }
            
            let operator = self.parse_operator()?;
            let right = self.parse_binary_expression(op_precedence + 1)?;
            
            left = ASTNode {
                node_type: ASTNodeType::BinaryOp,
                children: vec![left, right],
                value: Some(operator),
                line: token.line,
                column: token.column,
            };
        }
        
        Ok(left)
    }
    
    /// è§£æä¸€å…ƒè¡¨è¾¾å¼
    fn parse_unary_expression(&mut self) -> Result<ASTNode, String> {
        let token = self.current_token();
        
        match token.token_type {
            TokenType::Minus => {
                self.advance();
                let operand = self.parse_unary_expression()?;
                Ok(ASTNode {
                    node_type: ASTNodeType::UnaryOp,
                    children: vec![operand],
                    value: Some("-".to_string()),
                    line: token.line,
                    column: token.column,
                })
            }
            _ => self.parse_primary_expression(),
        }
    }
    
    /// è§£æåŸºæœ¬è¡¨è¾¾å¼
    fn parse_primary_expression(&mut self) -> Result<ASTNode, String> {
        let token = self.current_token();
        
        match token.token_type {
            TokenType::Integer => {
                self.advance();
                Ok(ASTNode {
                    node_type: ASTNodeType::Literal,
                    children: Vec::new(),
                    value: Some(token.value.clone()),
                    line: token.line,
                    column: token.column,
                })
            }
            
            TokenType::Identifier => {
                let name = token.value.clone();
                self.advance();
                Ok(ASTNode {
                    node_type: ASTNodeType::Variable,
                    children: Vec::new(),
                    value: Some(name),
                    line: token.line,
                    column: token.column,
                })
            }
            
            TokenType::LeftParen => {
                self.advance();
                let expr = self.parse_expression()?;
                self.expect(TokenType::RightParen)?;
                Ok(expr)
            }
            
            _ => Err(format!("Unexpected token: {:?}", token.token_type)),
        }
    }
    
    /// è§£æä»£ç å—
    fn parse_block(&mut self) -> Result<ASTNode, String> {
        self.expect(TokenType::LeftBrace)?;
        
        let mut statements = Vec::new();
        while self.current_token().token_type != TokenType::RightBrace {
            let statement = self.parse_statement()?;
            statements.push(statement);
        }
        self.expect(TokenType::RightBrace)?;
        
        Ok(ASTNode {
            node_type: ASTNodeType::Program,
            children: statements,
            value: None,
            line: self.current_token().line,
            column: self.current_token().column,
        })
    }
    
    /// è·å–æ“ä½œç¬¦ä¼˜å…ˆçº§
    fn get_operator_precedence(&self, token_type: &TokenType) -> u32 {
        match token_type {
            TokenType::Plus | TokenType::Minus => 1,
            TokenType::Multiply | TokenType::Divide => 2,
            _ => 0,
        }
    }
    
    /// è§£ææ“ä½œç¬¦
    fn parse_operator(&mut self) -> Result<String, String> {
        let token = self.current_token();
        match token.token_type {
            TokenType::Plus | TokenType::Minus | TokenType::Multiply | TokenType::Divide => {
                let op = token.value.clone();
                self.advance();
                Ok(op)
            }
            _ => Err(format!("Expected operator, got {:?}", token.token_type)),
        }
    }
    
    /// æœŸæœ›ç‰¹å®šç±»å‹çš„è¯æ³•å•å…ƒ
    fn expect(&mut self, token_type: TokenType) -> Result<(), String> {
        if self.current_token().token_type == token_type {
            self.advance();
            Ok(())
        } else {
            Err(format!("Expected {:?}, got {:?}", token_type, self.current_token().token_type))
        }
    }
    
    /// æœŸæœ›æ ‡è¯†ç¬¦
    fn expect_identifier(&mut self) -> Result<String, String> {
        if let TokenType::Identifier = self.current_token().token_type {
            let name = self.current_token().value.clone();
            self.advance();
            Ok(name)
        } else {
            Err("Expected identifier".to_string())
        }
    }
    
    /// è·å–å½“å‰è¯æ³•å•å…ƒ
    fn current_token(&self) -> &Token {
        &self.tokens[self.position]
    }
    
    /// å‰è¿›åˆ°ä¸‹ä¸€ä¸ªè¯æ³•å•å…ƒ
    fn advance(&mut self) {
        self.position += 1;
    }
}

impl IRGenerator {
    pub fn new() -> Self {
        Self {
            variables: HashMap::new(),
            temp_counter: 0,
            label_counter: 0,
            instructions: Vec::new(),
        }
    }
    
    /// ç”Ÿæˆä¸­é—´ä»£ç 
    pub fn generate(&mut self, ast: &ASTNode) -> Result<Vec<IRNode>, String> {
        self.generate_node(ast)?;
        Ok(self.instructions.clone())
    }
    
    /// ç”ŸæˆèŠ‚ç‚¹ä»£ç 
    fn generate_node(&mut self, node: &ASTNode) -> Result<String, String> {
        match node.node_type {
            ASTNodeType::Program => {
                for child in &node.children {
                    self.generate_node(child)?;
                }
                Ok("".to_string())
            }
            
            ASTNodeType::Function => {
                let label = format!("func_{}", node.value.as_ref().unwrap());
                self.instructions.push(IRNode {
                    ir_type: IRType::Label,
                    operands: Vec::new(),
                    result: None,
                    label: Some(label.clone()),
                });
                
                for child in &node.children {
                    self.generate_node(child)?;
                }
                
                self.instructions.push(IRNode {
                    ir_type: IRType::Return,
                    operands: Vec::new(),
                    result: None,
                    label: None,
                });
                
                Ok(label)
            }
            
            ASTNodeType::Assignment => {
                let value = self.generate_node(&node.children[0])?;
                let var_name = node.value.as_ref().unwrap();
                
                self.instructions.push(IRNode {
                    ir_type: IRType::Move,
                    operands: vec![value],
                    result: Some(var_name.clone()),
                    label: None,
                });
                
                Ok(var_name.clone())
            }
            
            ASTNodeType::BinaryOp => {
                let left = self.generate_node(&node.children[0])?;
                let right = self.generate_node(&node.children[1])?;
                let result = self.new_temp();
                
                let ir_type = match node.value.as_ref().unwrap().as_str() {
                    "+" => IRType::Add,
                    "-" => IRType::Subtract,
                    "*" => IRType::Multiply,
                    "/" => IRType::Divide,
                    _ => return Err("Unknown binary operator".to_string()),
                };
                
                self.instructions.push(IRNode {
                    ir_type,
                    operands: vec![left, right],
                    result: Some(result.clone()),
                    label: None,
                });
                
                Ok(result)
            }
            
            ASTNodeType::Literal => {
                let temp = self.new_temp();
                self.instructions.push(IRNode {
                    ir_type: IRType::Move,
                    operands: vec![node.value.as_ref().unwrap().clone()],
                    result: Some(temp.clone()),
                    label: None,
                });
                Ok(temp)
            }
            
            ASTNodeType::Variable => {
                Ok(node.value.as_ref().unwrap().clone())
            }
            
            ASTNodeType::If => {
                let condition = self.generate_node(&node.children[0])?;
                let then_label = self.new_label();
                let end_label = self.new_label();
                
                // æ¡ä»¶è·³è½¬
                self.instructions.push(IRNode {
                    ir_type: IRType::JumpIfFalse,
                    operands: vec![condition],
                    result: None,
                    label: Some(end_label.clone()),
                });
                
                // thenå—
                self.instructions.push(IRNode {
                    ir_type: IRType::Label,
                    operands: Vec::new(),
                    result: None,
                    label: Some(then_label.clone()),
                });
                
                self.generate_node(&node.children[1])?;
                
                // è·³è½¬åˆ°ç»“æŸ
                self.instructions.push(IRNode {
                    ir_type: IRType::Jump,
                    operands: Vec::new(),
                    result: None,
                    label: Some(end_label.clone()),
                });
                
                // elseå—ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if node.children.len() > 2 {
                    let else_label = self.new_label();
                    self.instructions.push(IRNode {
                        ir_type: IRType::Label,
                        operands: Vec::new(),
                        result: None,
                        label: Some(else_label.clone()),
                    });
                    
                    self.generate_node(&node.children[2])?;
                }
                
                // ç»“æŸæ ‡ç­¾
                self.instructions.push(IRNode {
                    ir_type: IRType::Label,
                    operands: Vec::new(),
                    result: None,
                    label: Some(end_label),
                });
                
                Ok("".to_string())
            }
            
            ASTNodeType::While => {
                let start_label = self.new_label();
                let body_label = self.new_label();
                let end_label = self.new_label();
                
                // å¼€å§‹æ ‡ç­¾
                self.instructions.push(IRNode {
                    ir_type: IRType::Label,
                    operands: Vec::new(),
                    result: None,
                    label: Some(start_label.clone()),
                });
                
                // æ¡ä»¶
                let condition = self.generate_node(&node.children[0])?;
                
                // æ¡ä»¶è·³è½¬
                self.instructions.push(IRNode {
                    ir_type: IRType::JumpIfFalse,
                    operands: vec![condition],
                    result: None,
                    label: Some(end_label.clone()),
                });
                
                // å¾ªç¯ä½“
                self.generate_node(&node.children[1])?;
                
                // è·³å›å¼€å§‹
                self.instructions.push(IRNode {
                    ir_type: IRType::Jump,
                    operands: Vec::new(),
                    result: None,
                    label: Some(start_label),
                });
                
                // ç»“æŸæ ‡ç­¾
                self.instructions.push(IRNode {
                    ir_type: IRType::Label,
                    operands: Vec::new(),
                    result: None,
                    label: Some(end_label),
                });
                
                Ok("".to_string())
            }
            
            _ => Ok("".to_string()),
        }
    }
    
    /// ç”Ÿæˆæ–°çš„ä¸´æ—¶å˜é‡
    fn new_temp(&mut self) -> String {
        self.temp_counter += 1;
        format!("t{}", self.temp_counter)
    }
    
    /// ç”Ÿæˆæ–°çš„æ ‡ç­¾
    fn new_label(&mut self) -> String {
        self.label_counter += 1;
        format!("L{}", self.label_counter)
    }
}

impl Optimizer {
    pub fn new() -> Self {
        Self {
            optimizations: vec![
                OptimizationPass {
                    name: "Constant Folding".to_string(),
                    description: "Evaluate constant expressions at compile time".to_string(),
                    enabled: true,
                },
                OptimizationPass {
                    name: "Dead Code Elimination".to_string(),
                    description: "Remove unreachable code".to_string(),
                    enabled: true,
                },
                OptimizationPass {
                    name: "Common Subexpression Elimination".to_string(),
                    description: "Eliminate redundant computations".to_string(),
                    enabled: true,
                },
            ],
        }
    }
    
    /// ä¼˜åŒ–ä¸­é—´ä»£ç 
    pub fn optimize(&self, instructions: &[IRNode]) -> Vec<IRNode> {
        let mut optimized = instructions.to_vec();
        
        for pass in &self.optimizations {
            if pass.enabled {
                optimized = self.apply_optimization_pass(&optimized, pass);
            }
        }
        
        optimized
    }
    
    /// åº”ç”¨ä¼˜åŒ–é€šé“
    fn apply_optimization_pass(&self, instructions: &[IRNode], pass: &OptimizationPass) -> Vec<IRNode> {
        match pass.name.as_str() {
            "Constant Folding" => self.constant_folding(instructions),
            "Dead Code Elimination" => self.dead_code_elimination(instructions),
            "Common Subexpression Elimination" => self.cse(instructions),
            _ => instructions.to_vec(),
        }
    }
    
    /// å¸¸é‡æŠ˜å 
    fn constant_folding(&self, instructions: &[IRNode]) -> Vec<IRNode> {
        let mut optimized = Vec::new();
        
        for instruction in instructions {
            match instruction.ir_type {
                IRType::Add => {
                    if let (Some(left), Some(right)) = (&instruction.operands.get(0), &instruction.operands.get(1)) {
                        if let (Ok(l), Ok(r)) = (left.parse::<i64>(), right.parse::<i64>()) {
                            let result = l + r;
                            optimized.push(IRNode {
                                ir_type: IRType::Move,
                                operands: vec![result.to_string()],
                                result: instruction.result.clone(),
                                label: instruction.label.clone(),
                            });
                            continue;
                        }
                    }
                }
                _ => {}
            }
            optimized.push(instruction.clone());
        }
        
        optimized
    }
    
    /// æ­»ä»£ç æ¶ˆé™¤
    fn dead_code_elimination(&self, instructions: &[IRNode]) -> Vec<IRNode> {
        let mut optimized = Vec::new();
        let mut reachable = true;
        
        for instruction in instructions {
            if !reachable && instruction.ir_type != IRType::Label {
                continue;
            }
            
            match instruction.ir_type {
                IRType::Jump => {
                    optimized.push(instruction.clone());
                    reachable = false;
                }
                IRType::Return => {
                    optimized.push(instruction.clone());
                    reachable = false;
                }
                IRType::Label => {
                    reachable = true;
                    optimized.push(instruction.clone());
                }
                _ => {
                    optimized.push(instruction.clone());
                }
            }
        }
        
        optimized
    }
    
    /// å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤
    fn cse(&self, instructions: &[IRNode]) -> Vec<IRNode> {
        let mut optimized = Vec::new();
        let mut expressions = HashMap::new();
        
        for instruction in instructions {
            let key = format!("{:?}_{:?}", instruction.ir_type, instruction.operands);
            
            if let Some(existing_result) = expressions.get(&key) {
                // æ›¿æ¢ä¸ºå·²å­˜åœ¨çš„è¡¨è¾¾å¼
                optimized.push(IRNode {
                    ir_type: IRType::Move,
                    operands: vec![existing_result.clone()],
                    result: instruction.result.clone(),
                    label: instruction.label.clone(),
                });
            } else {
                // è®°å½•æ–°è¡¨è¾¾å¼
                if let Some(ref result) = instruction.result {
                    expressions.insert(key, result.clone());
                }
                optimized.push(instruction.clone());
            }
        }
        
        optimized
    }
}

impl CodeGenerator {
    pub fn new(target_arch: TargetArchitecture) -> Self {
        Self {
            target_arch,
            registers: vec!["rax".to_string(), "rbx".to_string(), "rcx".to_string(), "rdx".to_string()],
            instructions: Vec::new(),
        }
    }
    
    /// ç”Ÿæˆç›®æ ‡ä»£ç 
    pub fn generate(&mut self, ir_instructions: &[IRNode]) -> Result<Vec<AssemblyInstruction>, String> {
        for instruction in ir_instructions {
            self.generate_instruction(instruction)?;
        }
        Ok(self.instructions.clone())
    }
    
    /// ç”Ÿæˆå•ä¸ªæŒ‡ä»¤
    fn generate_instruction(&mut self, ir: &IRNode) -> Result<(), String> {
        match ir.ir_type {
            IRType::Move => {
                if let Some(result) = &ir.result {
                    if ir.operands.len() == 1 {
                        self.instructions.push(AssemblyInstruction {
                            mnemonic: "mov".to_string(),
                            operands: vec![result.clone(), ir.operands[0].clone()],
                            comment: Some("Move value".to_string()),
                        });
                    }
                }
            }
            
            IRType::Add => {
                if let Some(result) = &ir.result {
                    if ir.operands.len() == 2 {
                        self.instructions.push(AssemblyInstruction {
                            mnemonic: "add".to_string(),
                            operands: vec![result.clone(), ir.operands[0].clone()],
                            comment: Some("Add operation".to_string()),
                        });
                    }
                }
            }
            
            IRType::Label => {
                if let Some(label) = &ir.label {
                    self.instructions.push(AssemblyInstruction {
                        mnemonic: format!("{}:", label),
                        operands: Vec::new(),
                        comment: Some("Label".to_string()),
                    });
                }
            }
            
            IRType::Jump => {
                if let Some(label) = &ir.label {
                    self.instructions.push(AssemblyInstruction {
                        mnemonic: "jmp".to_string(),
                        operands: vec![label.clone()],
                        comment: Some("Unconditional jump".to_string()),
                    });
                }
            }
            
            IRType::JumpIfFalse => {
                if let Some(label) = &ir.label {
                    if ir.operands.len() == 1 {
                        self.instructions.push(AssemblyInstruction {
                            mnemonic: "cmp".to_string(),
                            operands: vec![ir.operands[0].clone(), "0".to_string()],
                            comment: Some("Compare with zero".to_string()),
                        });
                        
                        self.instructions.push(AssemblyInstruction {
                            mnemonic: "je".to_string(),
                            operands: vec![label.clone()],
                            comment: Some("Jump if equal".to_string()),
                        });
                    }
                }
            }
            
            IRType::Return => {
                self.instructions.push(AssemblyInstruction {
                    mnemonic: "ret".to_string(),
                    operands: Vec::new(),
                    comment: Some("Return from function".to_string()),
                });
            }
            
            _ => {
                // ç®€åŒ–å¤„ç†å…¶ä»–æŒ‡ä»¤
                self.instructions.push(AssemblyInstruction {
                    mnemonic: format!("{:?}", ir.ir_type),
                    operands: ir.operands.clone(),
                    comment: Some("Generated instruction".to_string()),
                });
            }
        }
        
        Ok(())
    }
}

impl Compiler {
    pub fn new() -> Self {
        Self {
            lexer: Lexer::new(String::new()),
            parser: Parser::new(Vec::new()),
            ir_generator: IRGenerator::new(),
            optimizer: Optimizer::new(),
            code_generator: CodeGenerator::new(TargetArchitecture::X86_64),
            error_handler: ErrorHandler {
                errors: Vec::new(),
                warnings: Vec::new(),
            },
        }
    }
    
    /// ç¼–è¯‘æºä»£ç 
    pub fn compile(&mut self, source: &str) -> Result<Vec<AssemblyInstruction>, String> {
        // è¯æ³•åˆ†æ
        self.lexer = Lexer::new(source.to_string());
        let tokens = self.lexer.tokenize()?;
        
        // è¯­æ³•åˆ†æ
        self.parser = Parser::new(tokens);
        let ast = self.parser.parse()?;
        
        // ä¸­é—´ä»£ç ç”Ÿæˆ
        let ir_instructions = self.ir_generator.generate(&ast)?;
        
        // ä»£ç ä¼˜åŒ–
        let optimized_ir = self.optimizer.optimize(&ir_instructions);
        
        // ç›®æ ‡ä»£ç ç”Ÿæˆ
        let assembly = self.code_generator.generate(&optimized_ir)?;
        
        Ok(assembly)
    }
}

impl fmt::Display for AssemblyInstruction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.mnemonic)?;
        
        if !self.operands.is_empty() {
            write!(f, " {}", self.operands.join(", "))?;
        }
        
        if let Some(ref comment) = self.comment {
            write!(f, " ; {}", comment)?;
        }
        
        Ok(())
    }
}

## 5. åº”ç”¨ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_lexer() {
        let source = "let x = 5 + 3;";
        let mut lexer = Lexer::new(source.to_string());
        let tokens = lexer.tokenize().unwrap();
        
        assert_eq!(tokens.len(), 7); // let, x, =, 5, +, 3, ;
        assert_eq!(tokens[0].token_type, TokenType::Let);
        assert_eq!(tokens[1].token_type, TokenType::Identifier);
        assert_eq!(tokens[2].token_type, TokenType::Assign);
    }
    
    #[test]
    fn test_parser() {
        let source = "function main() { let x = 5; return x; }";
        let mut lexer = Lexer::new(source.to_string());
        let tokens = lexer.tokenize().unwrap();
        
        let mut parser = Parser::new(tokens);
        let ast = parser.parse().unwrap();
        
        assert_eq!(ast.node_type, ASTNodeType::Program);
        assert_eq!(ast.children.len(), 1);
        assert_eq!(ast.children[0].node_type, ASTNodeType::Function);
    }
    
    #[test]
    fn test_ir_generation() {
        let source = "let x = 5 + 3;";
        let mut lexer = Lexer::new(source.to_string());
        let tokens = lexer.tokenize().unwrap();
        
        let mut parser = Parser::new(tokens);
        let ast = parser.parse().unwrap();
        
        let mut ir_generator = IRGenerator::new();
        let ir_instructions = ir_generator.generate(&ast).unwrap();
        
        assert!(!ir_instructions.is_empty());
        assert_eq!(ir_instructions[0].ir_type, IRType::Move);
    }
    
    #[test]
    fn test_optimization() {
        let instructions = vec![
            IRNode {
                ir_type: IRType::Add,
                operands: vec!["5".to_string(), "3".to_string()],
                result: Some("t1".to_string()),
                label: None,
            },
        ];
        
        let optimizer = Optimizer::new();
        let optimized = optimizer.optimize(&instructions);
        
        assert_eq!(optimized[0].ir_type, IRType::Move);
        assert_eq!(optimized[0].operands[0], "8");
    }
    
    #[test]
    fn test_code_generation() {
        let ir_instructions = vec![
            IRNode {
                ir_type: IRType::Move,
                operands: vec!["5".to_string()],
                result: Some("x".to_string()),
                label: None,
            },
        ];
        
        let mut code_generator = CodeGenerator::new(TargetArchitecture::X86_64);
        let assembly = code_generator.generate(&ir_instructions).unwrap();
        
        assert!(!assembly.is_empty());
        assert_eq!(assembly[0].mnemonic, "mov");
    }
    
    #[test]
    fn test_full_compilation() {
        let source = "function main() { let x = 5 + 3; return x; }";
        let mut compiler = Compiler::new();
        let assembly = compiler.compile(source).unwrap();
        
        assert!(!assembly.is_empty());
    }
    
    #[test]
    fn test_error_handling() {
        let source = "let x = 5 + ;"; // è¯­æ³•é”™è¯¯
        let mut lexer = Lexer::new(source.to_string());
        let result = lexer.tokenize();
        
        assert!(result.is_err());
    }
}
```

## 6. ç›¸å…³ç†è®º

- å½¢å¼è¯­è¨€ç†è®º
- è‡ªåŠ¨æœºç†è®º
- ä»£ç ä¼˜åŒ–ç†è®º
- è®¡ç®—æœºä½“ç³»ç»“æ„

## 7. å‚è€ƒæ–‡çŒ®

1. Aho, A. V., et al. "Compilers: Principles, Techniques, and Tools"
2. Appel, A. W. "Modern Compiler Implementation in ML"
3. Cooper, K. D., Torczon, L. "Engineering a Compiler"
4. Muchnick, S. S. "Advanced Compiler Design and Implementation"

---

**ç›¸å…³é“¾æ¥**ï¼š

- [08.2.2 ä»£ç ä¼˜åŒ–ç†è®º](../08.2.2_ä»£ç ä¼˜åŒ–ç†è®º.md)
- [08.2.3 è™šæ‹Ÿæœºç†è®º](../08.2.3_è™šæ‹Ÿæœºç†è®º.md)
- [08.2.4 è§£é‡Šå™¨ç†è®º](../08.2.4_è§£é‡Šå™¨ç†è®º.md)
