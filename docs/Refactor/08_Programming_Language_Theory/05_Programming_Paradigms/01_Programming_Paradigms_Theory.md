# 08.5.1 ç¼–ç¨‹èŒƒå¼ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç¼–ç¨‹èŒƒå¼ç†è®ºç ”ç©¶ä¸åŒç¼–ç¨‹é£æ ¼ã€æ¨¡å‹åŠå…¶æ•°å­¦åŸºç¡€ã€‚å¸¸è§èŒƒå¼åŒ…æ‹¬å‘½ä»¤å¼ã€å‡½æ•°å¼ã€é¢å‘å¯¹è±¡ã€é€»è¾‘å¼ã€å£°æ˜å¼ç­‰ã€‚èŒƒå¼ç†è®ºæœ‰åŠ©äºç†è§£è¯­è¨€è®¾è®¡ã€ç¨‹åºç»“æ„ä¸æŠ½è±¡æœºåˆ¶ã€‚

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç¼–ç¨‹èŒƒå¼å®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆç¼–ç¨‹èŒƒå¼ï¼‰
ç¼–ç¨‹èŒƒå¼æ˜¯æŒ‡å¯¼ç¨‹åºç»“æ„å’Œç»„ç»‡æ–¹å¼çš„ç†è®ºæ¡†æ¶ã€‚

### 1.2 å¸¸è§èŒƒå¼åˆ†ç±»

| èŒƒå¼         | è‹±æ–‡åç§°         | æè¿°                         | ä»£è¡¨è¯­è¨€         |
|--------------|------------------|------------------------------|------------------|
| å‘½ä»¤å¼       | Imperative       | é€šè¿‡çŠ¶æ€æ”¹å˜æè¿°è®¡ç®—         | C, Rust          |
| å‡½æ•°å¼       | Functional       | ä»¥å‡½æ•°å’Œä¸å¯å˜æ€§ä¸ºæ ¸å¿ƒ       | Haskell, OCaml   |
| é¢å‘å¯¹è±¡     | Object-Oriented  | ä»¥å¯¹è±¡å’Œæ¶ˆæ¯ä¼ é€’ä¸ºæ ¸å¿ƒ       | Java, C++        |
| é€»è¾‘å¼       | Logic            | ä»¥é€»è¾‘æ¨ç†å’Œè§„åˆ™ä¸ºæ ¸å¿ƒ       | Prolog           |
| å£°æ˜å¼       | Declarative      | å…³æ³¨"åšä»€ä¹ˆ"è€Œé"æ€ä¹ˆåš"     | SQL, Haskell     |

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å‘½ä»¤å¼èŒƒå¼

**å®šä¹‰ 2.1**ï¼ˆå‘½ä»¤å¼è¯­ä¹‰ï¼‰
å‘½ä»¤å¼èŒƒå¼ä»¥çŠ¶æ€è½¬ç§»å‡½æ•° $S: State \rightarrow State$ å½¢å¼æè¿°ç¨‹åºæ‰§è¡Œã€‚

### 2.2 å‡½æ•°å¼èŒƒå¼

**å®šä¹‰ 2.2**ï¼ˆÎ»-æ¼”ç®—ï¼‰
Î»-æ¼”ç®—æ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„ç†è®ºåŸºç¡€ï¼Œè¡¨è¾¾å¼ $e ::= x \mid \lambda x.e \mid e_1\ e_2$ã€‚

### 2.3 é¢å‘å¯¹è±¡èŒƒå¼

**å®šä¹‰ 2.3**ï¼ˆå¯¹è±¡ï¼‰
å¯¹è±¡æ˜¯å°è£…çŠ¶æ€å’Œè¡Œä¸ºçš„æŠ½è±¡å•å…ƒï¼Œæ”¯æŒç»§æ‰¿å’Œå¤šæ€ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 èŒƒå¼ç­‰ä»·æ€§å®šç†

**å®šç† 3.1**ï¼ˆå›¾çµç­‰ä»·æ€§ï¼‰
æ‰€æœ‰å›¾çµå®Œå¤‡çš„ç¼–ç¨‹èŒƒå¼åœ¨è¡¨è¾¾èƒ½åŠ›ä¸Šç­‰ä»·ã€‚

**è¯æ˜**ï¼š
å‘½ä»¤å¼ã€å‡½æ•°å¼ã€é€»è¾‘å¼å‡å¯æ¨¡æ‹Ÿå›¾çµæœºã€‚â–¡

### 3.2 ä¸å˜é‡å®šç†

**å®šç† 3.2**ï¼ˆä¸å¯å˜æ€§ï¼‰
åœ¨çº¯å‡½æ•°å¼èŒƒå¼ä¸­ï¼Œæ‰€æœ‰æ•°æ®ç»“æ„å‡ä¸å¯å˜ã€‚

**è¯æ˜**ï¼š
Î»-æ¼”ç®—ä¸­æ— èµ‹å€¼æ“ä½œï¼Œæ‰€æœ‰å˜é‡ç»‘å®šä¸å¯æ›´æ”¹ã€‚â–¡

## 4. Rustä»£ç å®ç°

### 4.1 å‘½ä»¤å¼ä¸å‡½æ•°å¼å¯¹æ¯”

```rust
// å‘½ä»¤å¼é£æ ¼
fn imperative_sum(arr: &[i32]) -> i32 {
    let mut sum = 0;
    for x in arr {
        sum += x;
    }
    sum
}

// å‡½æ•°å¼é£æ ¼
fn functional_sum(arr: &[i32]) -> i32 {
    arr.iter().fold(0, |acc, x| acc + x)
}
```

### 4.2 é¢å‘å¯¹è±¡æ¨¡æ‹Ÿ

```rust
trait Shape {
    fn area(&self) -> f64;
}

struct Circle { r: f64 }
struct Square { s: f64 }

impl Shape for Circle {
    fn area(&self) -> f64 { std::f64::consts::PI * self.r * self.r }
}
impl Shape for Square {
    fn area(&self) -> f64 { self.s * self.s }
}
```

## 5. ç›¸å…³ç†è®ºä¸äº¤å‰å¼•ç”¨

- [è¯­è¨€è®¾è®¡ç†è®º](../01_Language_Design/01_Language_Design_Theory.md)
- [ç±»å‹ç³»ç»Ÿç†è®º](../03_Type_Systems/01_Type_Systems_Theory.md)
- [ç¼–è¯‘åŸç†ç†è®º](../04_Compilation_Theory/01_Compilation_Theory.md)

## 6. å‚è€ƒæ–‡çŒ®

1. Scott, M. L. (2015). Programming Language Pragmatics. Morgan Kaufmann.
2. Pierce, B. C. (2002). Types and Programming Languages. MIT Press.
3. Reynolds, J. C. (1998). Theories of Programming Languages. Cambridge University Press.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ21æ—¥  
**ç»´æŠ¤è€…**: AIåŠ©æ‰‹  
**ç‰ˆæœ¬**: v1.0 