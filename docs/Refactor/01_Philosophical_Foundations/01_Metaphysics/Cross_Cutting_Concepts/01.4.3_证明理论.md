# 01.4.3 è¯æ˜ç†è®º

## ğŸ“‹ æ¦‚è¿°

è¯æ˜ç†è®ºæ˜¯é€»è¾‘å“²å­¦çš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œç ”ç©¶æ•°å­¦è¯æ˜çš„å½¢å¼åŒ–ç»“æ„ã€è¯æ˜ç­–ç•¥å’Œè¯æ˜éªŒè¯ã€‚æœ¬æ–‡æ¡£å»ºç«‹è¯æ˜çš„å½¢å¼åŒ–ç†è®ºï¼Œä¸ºæ•°å­¦æ¨ç†æä¾›ä¸¥æ ¼çš„è¯æ˜æ¡†æ¶ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹è¯æ˜çš„å½¢å¼åŒ–ç†è®ºæ¡†æ¶
2. å®šä¹‰è¯æ˜ç³»ç»Ÿå’Œè¯æ˜ç­–ç•¥
3. æ„å»ºè¯æ˜éªŒè¯çš„åˆ¤å®šæ ‡å‡†
4. æä¾›è¯æ˜è¿‡ç¨‹çš„å½¢å¼åŒ–æ–¹æ³•
5. å®ç°è¯æ˜ç³»ç»Ÿçš„ç®—æ³•åŒ–

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è¯æ˜çš„æœ¬è´¨

è¯æ˜æ˜¯ä»å…¬ç†å’Œå·²çŸ¥å®šç†å‡ºå‘ï¼Œé€šè¿‡é€»è¾‘æ¨ç†è§„åˆ™ï¼Œä¸¥æ ¼æ¨å¯¼å‡ºç»“è®ºçš„è¿‡ç¨‹ã€‚

**å®šä¹‰ 1.1.1** (è¯æ˜)
è¯æ˜æ˜¯ä»å‰æé›† $\Gamma$ åˆ°ç»“è®º $\phi$ çš„æœ‰é™æ¨ç†åºåˆ—ï¼Œæ¯ä¸ªæ­¥éª¤éƒ½éµå¾ªé€»è¾‘è§„åˆ™ã€‚

### 1.2 è¯æ˜çš„ç±»å‹

**å®šä¹‰ 1.1.2** (ç›´æ¥è¯æ˜)
ç›´æ¥è¯æ˜æ˜¯ä»å‰æç›´æ¥æ¨å¯¼å‡ºç»“è®ºçš„è¯æ˜æ–¹æ³•ã€‚

**å®šä¹‰ 1.1.3** (é—´æ¥è¯æ˜)
é—´æ¥è¯æ˜æ˜¯é€šè¿‡å¦å®šç»“è®ºå¯¼å‡ºçŸ›ç›¾æ¥è¯æ˜åŸç»“è®ºçš„æ–¹æ³•ã€‚

**å®šä¹‰ 1.1.4** (æ„é€ æ€§è¯æ˜)
æ„é€ æ€§è¯æ˜æ˜¯é€šè¿‡æ„é€ å…·ä½“å¯¹è±¡æ¥è¯æ˜å­˜åœ¨æ€§çš„æ–¹æ³•ã€‚

### 1.3 è¯æ˜çš„æœ‰æ•ˆæ€§

**å®šä¹‰ 1.1.5** (æœ‰æ•ˆè¯æ˜)
è¯æ˜æ˜¯æœ‰æ•ˆçš„ï¼Œå½“ä¸”ä»…å½“æ¯ä¸ªæ¨ç†æ­¥éª¤éƒ½éµå¾ªé€»è¾‘è§„åˆ™ã€‚

**å®šä¹‰ 1.1.6** (å®Œæ•´è¯æ˜)
è¯æ˜æ˜¯å®Œæ•´çš„ï¼Œå½“ä¸”ä»…å½“æ‰€æœ‰å¿…è¦çš„æ¨ç†æ­¥éª¤éƒ½å·²æ˜ç¡®ç»™å‡ºã€‚

**å®šä¹‰ 1.1.7** (ä¸¥æ ¼è¯æ˜)
è¯æ˜æ˜¯ä¸¥æ ¼çš„ï¼Œå½“ä¸”ä»…å½“æ¯ä¸ªæ­¥éª¤éƒ½å¯ä»¥æœºæ¢°åœ°éªŒè¯ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 è¯æ˜ç³»ç»Ÿ

**å®šä¹‰ 2.1.1** (å½¢å¼åŒ–è¯æ˜ç³»ç»Ÿ)
å½¢å¼åŒ–è¯æ˜ç³»ç»Ÿ $\mathcal{P}$ åŒ…å«ï¼š

1. **è¯­è¨€**ï¼š$\mathcal{L}$
2. **å…¬ç†é›†**ï¼š$\mathcal{A} \subseteq \mathcal{L}$
3. **æ¨ç†è§„åˆ™é›†**ï¼š$\mathcal{R}$
4. **è¯æ˜åºåˆ—**ï¼šæœ‰é™åºåˆ— $\langle \phi_1, \phi_2, \ldots, \phi_n \rangle$

**å®šä¹‰ 2.1.2** (è¯æ˜åºåˆ—)
åºåˆ— $\langle \phi_1, \phi_2, \ldots, \phi_n \rangle$ æ˜¯è¯æ˜ï¼Œå½“ä¸”ä»…å½“ï¼š

1. æ¯ä¸ª $\phi_i$ è¦ä¹ˆæ˜¯å…¬ç†ï¼Œè¦ä¹ˆé€šè¿‡æ¨ç†è§„åˆ™ä»å‰é¢çš„å…¬å¼å¾—åˆ°
2. $\phi_n$ æ˜¯ç»“è®º

### 2.2 è¯æ˜ç­–ç•¥

**å®šä¹‰ 2.2.1** (å‰å‘æ¨ç†)
ä»å‰æåˆ°ç»“è®ºçš„æ¨ç†ç­–ç•¥ã€‚

**å®šä¹‰ 2.2.2** (åå‘æ¨ç†)
ä»ç»“è®ºåˆ°å‰æçš„æ¨ç†ç­–ç•¥ã€‚

**å®šä¹‰ 2.2.3** (åŒå‘æ¨ç†)
åŒæ—¶ä»å‰æåˆ°ç»“è®ºå’Œä»ç»“è®ºåˆ°å‰æçš„æ¨ç†ç­–ç•¥ã€‚

### 2.3 è¯æ˜éªŒè¯

**å®šä¹‰ 2.3.1** (è¯æ˜éªŒè¯)
è¯æ˜éªŒè¯æ˜¯æ£€æŸ¥è¯æ˜åºåˆ—æ¯ä¸ªæ­¥éª¤æ˜¯å¦æœ‰æ•ˆçš„ç®—æ³•ã€‚

**å®šä¹‰ 2.3.2** (è¯æ˜å¤æ‚åº¦)
è¯æ˜å¤æ‚åº¦æ˜¯è¯æ˜åºåˆ—çš„é•¿åº¦å’Œæ¨ç†æ­¥éª¤çš„å¤æ‚åº¦ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 è¯æ˜ç³»ç»Ÿå®šç†

**å®šç† 3.1.1** (è¯æ˜ç³»ç»Ÿçš„å¯é æ€§)
å¦‚æœ $\Gamma \vdash_{\mathcal{P}} \phi$ï¼Œåˆ™ $\Gamma \models \phi$ã€‚

**è¯æ˜**ï¼š
é€šè¿‡ç»“æ„å½’çº³æ³•è¯æ˜æ¯ä¸ªæ¨ç†è§„åˆ™éƒ½ä¿æŒé€»è¾‘æœ‰æ•ˆæ€§ã€‚

**å®šç† 3.1.2** (è¯æ˜ç³»ç»Ÿçš„å®Œå…¨æ€§)
å¦‚æœ $\Gamma \models \phi$ï¼Œåˆ™ $\Gamma \vdash_{\mathcal{P}} \phi$ã€‚

**è¯æ˜**ï¼š
ä½¿ç”¨æå¤§ä¸€è‡´é›†æ„é€ æ¨¡å‹ï¼Œè¯æ˜æ¯ä¸ªé€»è¾‘è•´å«çš„ç»“è®ºéƒ½æ˜¯å¯è¯æ˜çš„ã€‚

### 3.2 è¯æ˜ç­–ç•¥å®šç†

**å®šç† 3.2.1** (å‰å‘æ¨ç†çš„å®Œå¤‡æ€§)
å‰å‘æ¨ç†ç­–ç•¥å¯¹äºæŸäº›ç±»å‹çš„è¯æ˜æ˜¯å®Œå¤‡çš„ã€‚

**å®šç† 3.2.2** (åå‘æ¨ç†çš„æ•ˆç‡)
åå‘æ¨ç†ç­–ç•¥åœ¨æŸäº›æƒ…å†µä¸‹æ¯”å‰å‘æ¨ç†æ›´é«˜æ•ˆã€‚

### 3.3 è¯æ˜éªŒè¯å®šç†

**å®šç† 3.3.1** (è¯æ˜éªŒè¯çš„å¯åˆ¤å®šæ€§)
å¯¹äºæœ‰é™è¯æ˜ç³»ç»Ÿï¼Œè¯æ˜éªŒè¯æ˜¯å¯åˆ¤å®šçš„ã€‚

**å®šç† 3.3.2** (è¯æ˜éªŒè¯çš„å¤æ‚åº¦)
è¯æ˜éªŒè¯çš„æ—¶é—´å¤æ‚åº¦ä¸è¯æ˜é•¿åº¦æˆæ­£æ¯”ã€‚

## 4. ä»£ç å®ç°

### 4.1 è¯æ˜ç³»ç»ŸåŸºç¡€ç»“æ„

```rust
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone, PartialEq)]
pub enum ProofStep {
    Axiom(Proposition),
    Assumption(Proposition),
    ModusPonens(usize, usize), // æ­¥éª¤ç´¢å¼•
    AndIntroduction(usize, usize),
    AndElimination(usize, bool), // true for left, false for right
    OrIntroduction(usize, Proposition),
    OrElimination(usize, usize, usize),
    ImplicationIntroduction(usize, usize),
    ImplicationElimination(usize, usize),
    Contradiction(usize, usize),
}

#[derive(Debug, Clone)]
pub struct Proof {
    steps: Vec<ProofStep>,
    conclusions: Vec<Proposition>,
    assumptions: HashSet<Proposition>,
}

#[derive(Debug, Clone)]
pub struct ProofSystem {
    axioms: Vec<Proposition>,
    rules: HashMap<String, Box<dyn ProofRule>>,
}

trait ProofRule {
    fn apply(&self, premises: &[Proposition]) -> Option<Proposition>;
    fn validate(&self, premises: &[Proposition], conclusion: &Proposition) -> bool;
}
```

### 4.2 è¯æ˜éªŒè¯å™¨

```rust
pub struct ProofValidator;

impl ProofValidator {
    pub fn validate_proof(proof: &Proof, system: &ProofSystem) -> ValidationResult {
        let mut context = ProofContext::new();
        
        for (i, step) in proof.steps.iter().enumerate() {
            match Self::validate_step(step, &context, system) {
                Ok(conclusion) => {
                    context.add_step(i, conclusion);
                }
                Err(error) => {
                    return ValidationResult::Invalid {
                        step: i,
                        error: error,
                    };
                }
            }
        }
        
        ValidationResult::Valid
    }
    
    fn validate_step(
        step: &ProofStep,
        context: &ProofContext,
        system: &ProofSystem
    ) -> Result<Proposition, String> {
        match step {
            ProofStep::Axiom(prop) => {
                if system.axioms.contains(prop) {
                    Ok(prop.clone())
                } else {
                    Err("Not an axiom".to_string())
                }
            }
            ProofStep::Assumption(prop) => {
                Ok(prop.clone())
            }
            ProofStep::ModusPonens(i, j) => {
                let premise1 = context.get_step(*i)?;
                let premise2 = context.get_step(*j)?;
                
                if let Proposition::Implication(antecedent, consequent) = premise2 {
                    if premise1 == *antecedent {
                        Ok(*consequent.clone())
                    } else {
                        Err("Modus ponens: premises don't match".to_string())
                    }
                } else {
                    Err("Modus ponens: second premise is not an implication".to_string())
                }
            }
            ProofStep::AndIntroduction(i, j) => {
                let left = context.get_step(*i)?;
                let right = context.get_step(*j)?;
                Ok(Proposition::Conjunction(Box::new(left), Box::new(right)))
            }
            ProofStep::AndElimination(i, is_left) => {
                let premise = context.get_step(*i)?;
                if let Proposition::Conjunction(left, right) = premise {
                    if *is_left {
                        Ok(*left.clone())
                    } else {
                        Ok(*right.clone())
                    }
                } else {
                    Err("And elimination: premise is not a conjunction".to_string())
                }
            }
            ProofStep::OrIntroduction(i, prop) => {
                let premise = context.get_step(*i)?;
                Ok(Proposition::Disjunction(Box::new(premise), Box::new(prop.clone())))
            }
            ProofStep::OrElimination(i, j, k) => {
                let disjunction = context.get_step(*i)?;
                let case1_proof = context.get_subproof(*j)?;
                let case2_proof = context.get_subproof(*k)?;
                
                // éªŒè¯æå–æ¶ˆé™¤çš„å¤æ‚é€»è¾‘
                Self::validate_or_elimination(disjunction, case1_proof, case2_proof)
            }
            ProofStep::ImplicationIntroduction(i, j) => {
                let assumption = context.get_assumption(*i)?;
                let conclusion = context.get_step(*j)?;
                Ok(Proposition::Implication(Box::new(assumption), Box::new(conclusion)))
            }
            ProofStep::ImplicationElimination(i, j) => {
                let implication = context.get_step(*i)?;
                let antecedent = context.get_step(*j)?;
                
                if let Proposition::Implication(ant, consequent) = implication {
                    if antecedent == *ant {
                        Ok(*consequent.clone())
                    } else {
                        Err("Implication elimination: antecedent doesn't match".to_string())
                    }
                } else {
                    Err("Implication elimination: first premise is not an implication".to_string())
                }
            }
            ProofStep::Contradiction(i, j) => {
                let prop1 = context.get_step(*i)?;
                let prop2 = context.get_step(*j)?;
                
                if Self::is_contradiction(&prop1, &prop2) {
                    Ok(Proposition::Variable("âŠ¥".to_string()))
                } else {
                    Err("Contradiction: premises don't form a contradiction".to_string())
                }
            }
        }
    }
    
    fn is_contradiction(prop1: &Proposition, prop2: &Proposition) -> bool {
        if let Proposition::Negation(inner) = prop1 {
            inner.as_ref() == prop2
        } else if let Proposition::Negation(inner) = prop2 {
            inner.as_ref() == prop1
        } else {
            false
        }
    }
    
    fn validate_or_elimination(
        disjunction: &Proposition,
        case1_proof: &Proof,
        case2_proof: &Proof
    ) -> Result<Proposition, String> {
        // éªŒè¯æå–æ¶ˆé™¤çš„å¤æ‚é€»è¾‘
        // è¿™é‡Œéœ€è¦å®ç°æ›´å¤æ‚çš„éªŒè¯é€»è¾‘
        Ok(Proposition::Variable("conclusion".to_string()))
    }
}

#[derive(Debug)]
pub enum ValidationResult {
    Valid,
    Invalid { step: usize, error: String },
}

#[derive(Debug, Clone)]
pub struct ProofContext {
    steps: HashMap<usize, Proposition>,
    assumptions: HashMap<usize, Proposition>,
    subproofs: HashMap<usize, Proof>,
}

impl ProofContext {
    pub fn new() -> Self {
        Self {
            steps: HashMap::new(),
            assumptions: HashMap::new(),
            subproofs: HashMap::new(),
        }
    }
    
    pub fn add_step(&mut self, index: usize, proposition: Proposition) {
        self.steps.insert(index, proposition);
    }
    
    pub fn get_step(&self, index: usize) -> Result<Proposition, String> {
        self.steps.get(&index)
            .cloned()
            .ok_or_else(|| format!("Step {} not found", index))
    }
    
    pub fn add_assumption(&mut self, index: usize, proposition: Proposition) {
        self.assumptions.insert(index, proposition);
    }
    
    pub fn get_assumption(&self, index: usize) -> Result<Proposition, String> {
        self.assumptions.get(&index)
            .cloned()
            .ok_or_else(|| format!("Assumption {} not found", index))
    }
    
    pub fn add_subproof(&mut self, index: usize, proof: Proof) {
        self.subproofs.insert(index, proof);
    }
    
    pub fn get_subproof(&self, index: usize) -> Result<&Proof, String> {
        self.subproofs.get(&index)
            .ok_or_else(|| format!("Subproof {} not found", index))
    }
}
```

### 4.3 è¯æ˜ç­–ç•¥å®ç°

```rust
pub struct ProofStrategy;

impl ProofStrategy {
    /// å‰å‘æ¨ç†ç­–ç•¥
    pub fn forward_reasoning(
        premises: &[Proposition],
        goal: &Proposition,
        system: &ProofSystem
    ) -> Option<Proof> {
        let mut proof = Proof {
            steps: Vec::new(),
            conclusions: Vec::new(),
            assumptions: HashSet::new(),
        };
        
        // æ·»åŠ å‰æä½œä¸ºå‡è®¾
        for premise in premises {
            proof.steps.push(ProofStep::Assumption(premise.clone()));
            proof.conclusions.push(premise.clone());
        }
        
        // å°è¯•åº”ç”¨æ¨ç†è§„åˆ™
        Self::apply_rules_forward(&mut proof, goal, system)
    }
    
    /// åå‘æ¨ç†ç­–ç•¥
    pub fn backward_reasoning(
        premises: &[Proposition],
        goal: &Proposition,
        system: &ProofSystem
    ) -> Option<Proof> {
        let mut subgoals = vec![goal.clone()];
        let mut proof = Proof {
            steps: Vec::new(),
            conclusions: Vec::new(),
            assumptions: HashSet::new(),
        };
        
        // æ·»åŠ å‰æ
        for premise in premises {
            proof.steps.push(ProofStep::Assumption(premise.clone()));
            proof.conclusions.push(premise.clone());
        }
        
        // ä»ç›®æ ‡åå‘æ¨ç†
        Self::apply_rules_backward(&mut proof, &mut subgoals, system)
    }
    
    fn apply_rules_forward(
        proof: &mut Proof,
        goal: &Proposition,
        system: &ProofSystem
    ) -> Option<Proof> {
        // æ£€æŸ¥æ˜¯å¦å·²ç»è¾¾åˆ°ç›®æ ‡
        if proof.conclusions.contains(goal) {
            return Some(proof.clone());
        }
        
        // å°è¯•åº”ç”¨å„ç§æ¨ç†è§„åˆ™
        for rule in system.rules.values() {
            for i in 0..proof.conclusions.len() {
                for j in i+1..proof.conclusions.len() {
                    let premises = vec![
                        proof.conclusions[i].clone(),
                        proof.conclusions[j].clone()
                    ];
                    
                    if let Some(conclusion) = rule.apply(&premises) {
                        proof.steps.push(ProofStep::ModusPonens(i, j));
                        proof.conclusions.push(conclusion.clone());
                        
                        // é€’å½’å°è¯•
                        if let Some(result) = Self::apply_rules_forward(proof, goal, system) {
                            return Some(result);
                        }
                        
                        // å›æº¯
                        proof.steps.pop();
                        proof.conclusions.pop();
                    }
                }
            }
        }
        
        None
    }
    
    fn apply_rules_backward(
        proof: &mut Proof,
        subgoals: &mut Vec<Proposition>,
        system: &ProofSystem
    ) -> Option<Proof> {
        if subgoals.is_empty() {
            return Some(proof.clone());
        }
        
        let current_goal = subgoals.pop().unwrap();
        
        // æ£€æŸ¥ç›®æ ‡æ˜¯å¦å·²ç»è¯æ˜
        if proof.conclusions.contains(&current_goal) {
            return Self::apply_rules_backward(proof, subgoals, system);
        }
        
        // å°è¯•åˆ†è§£ç›®æ ‡
        if let Some(new_subgoals) = Self::decompose_goal(&current_goal) {
            subgoals.extend(new_subgoals);
            return Self::apply_rules_backward(proof, subgoals, system);
        }
        
        None
    }
    
    fn decompose_goal(goal: &Proposition) -> Option<Vec<Proposition>> {
        match goal {
            Proposition::Implication(antecedent, consequent) => {
                // ä¸ºäº†è¯æ˜ A -> Bï¼Œå‡è®¾ A å¹¶è¯æ˜ B
                Some(vec![antecedent.clone(), consequent.clone()])
            }
            Proposition::Conjunction(left, right) => {
                // ä¸ºäº†è¯æ˜ A & Bï¼Œåˆ†åˆ«è¯æ˜ A å’Œ B
                Some(vec![*left.clone(), *right.clone()])
            }
            Proposition::Disjunction(left, right) => {
                // ä¸ºäº†è¯æ˜ A | Bï¼Œè¯æ˜ A æˆ–è¯æ˜ B
                Some(vec![*left.clone()])
            }
            _ => None,
        }
    }
}
```

### 4.4 è¯æ˜ç”Ÿæˆå™¨

```rust
pub struct ProofGenerator;

impl ProofGenerator {
    /// ç”Ÿæˆç›´æ¥è¯æ˜
    pub fn direct_proof(
        premises: &[Proposition],
        conclusion: &Proposition
    ) -> Option<Proof> {
        ProofStrategy::forward_reasoning(premises, conclusion, &Self::default_system())
    }
    
    /// ç”Ÿæˆé—´æ¥è¯æ˜
    pub fn indirect_proof(
        premises: &[Proposition],
        conclusion: &Proposition
    ) -> Option<Proof> {
        let negated_conclusion = Proposition::Negation(Box::new(conclusion.clone()));
        let mut all_premises = premises.to_vec();
        all_premises.push(negated_conclusion);
        
        // å°è¯•æ¨å¯¼çŸ›ç›¾
        if let Some(contradiction_proof) = Self::derive_contradiction(&all_premises) {
            let mut proof = contradiction_proof;
            // æ·»åŠ åè¯æ³•æ­¥éª¤
            proof.steps.push(ProofStep::Contradiction(
                proof.conclusions.len() - 2,
                proof.conclusions.len() - 1
            ));
            proof.conclusions.push(conclusion.clone());
            return Some(proof);
        }
        
        None
    }
    
    /// ç”Ÿæˆæ„é€ æ€§è¯æ˜
    pub fn constructive_proof(
        premises: &[Proposition],
        existential_goal: &Proposition
    ) -> Option<Proof> {
        // æ„é€ æ€§è¯æ˜éœ€è¦æ‰¾åˆ°å…·ä½“çš„æ„é€ å¯¹è±¡
        if let Some(witness) = Self::find_witness(premises, existential_goal) {
            return Self::direct_proof(premises, &witness);
        }
        
        None
    }
    
    fn derive_contradiction(premises: &[Proposition]) -> Option<Proof> {
        // å°è¯•ä»å‰ææ¨å¯¼çŸ›ç›¾
        // è¿™é‡Œå®ç°çŸ›ç›¾æ¨å¯¼ç®—æ³•
        None
    }
    
    fn find_witness(premises: &[Proposition], existential_goal: &Proposition) -> Option<Proposition> {
        // å¯»æ‰¾å­˜åœ¨æ€§è¯æ˜çš„è§è¯
        // è¿™é‡Œå®ç°è§è¯å¯»æ‰¾ç®—æ³•
        None
    }
    
    fn default_system() -> ProofSystem {
        let mut system = ProofSystem {
            axioms: Vec::new(),
            rules: HashMap::new(),
        };
        
        // æ·»åŠ åŸºæœ¬å…¬ç†
        system.axioms.push(Proposition::Variable("A -> A".to_string()));
        
        // æ·»åŠ æ¨ç†è§„åˆ™
        system.rules.insert(
            "modus_ponens".to_string(),
            Box::new(ModusPonensRule),
        );
        
        system
    }
}

struct ModusPonensRule;

impl ProofRule for ModusPonensRule {
    fn apply(&self, premises: &[Proposition]) -> Option<Proposition> {
        if premises.len() == 2 {
            if let (Proposition::Implication(antecedent, consequent), premise) = 
                (&premises[0], &premises[1]) {
                if premise == antecedent.as_ref() {
                    return Some(*consequent.clone());
                }
            }
        }
        None
    }
    
    fn validate(&self, premises: &[Proposition], conclusion: &Proposition) -> bool {
        self.apply(premises).as_ref() == Some(conclusion)
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 åŸºæœ¬è¯æ˜ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_direct_proof() {
        let p = Proposition::Variable("p".to_string());
        let q = Proposition::Variable("q".to_string());
        let implication = Proposition::Implication(Box::new(p.clone()), Box::new(q.clone()));
        
        let premises = vec![p, implication];
        let conclusion = q;
        
        let proof = ProofGenerator::direct_proof(&premises, &conclusion);
        assert!(proof.is_some());
        
        if let Some(proof) = proof {
            let system = ProofGenerator::default_system();
            let result = ProofValidator::validate_proof(&proof, &system);
            assert!(matches!(result, ValidationResult::Valid));
        }
    }
    
    #[test]
    fn test_indirect_proof() {
        let p = Proposition::Variable("p".to_string());
        let not_p = Proposition::Negation(Box::new(p.clone()));
        
        let premises = vec![p];
        let conclusion = Proposition::Variable("q".to_string());
        
        let proof = ProofGenerator::indirect_proof(&premises, &conclusion);
        // é—´æ¥è¯æ˜å¯èƒ½ä¸æ€»æ˜¯æˆåŠŸ
        if let Some(proof) = proof {
            let system = ProofGenerator::default_system();
            let result = ProofValidator::validate_proof(&proof, &system);
            assert!(matches!(result, ValidationResult::Valid));
        }
    }
    
    #[test]
    fn test_proof_validation() {
        let mut proof = Proof {
            steps: Vec::new(),
            conclusions: Vec::new(),
            assumptions: HashSet::new(),
        };
        
        // æ·»åŠ å‡è®¾
        let p = Proposition::Variable("p".to_string());
        proof.steps.push(ProofStep::Assumption(p.clone()));
        proof.conclusions.push(p);
        
        let system = ProofGenerator::default_system();
        let result = ProofValidator::validate_proof(&proof, &system);
        assert!(matches!(result, ValidationResult::Valid));
    }
}
```

### 5.2 å¤æ‚è¯æ˜ç¤ºä¾‹

```rust
#[test]
fn test_complex_proof() {
    // æ„å»ºå¤æ‚è¯æ˜ï¼š(p -> q) -> ((q -> r) -> (p -> r))
    let p = Proposition::Variable("p".to_string());
    let q = Proposition::Variable("q".to_string());
    let r = Proposition::Variable("r".to_string());
    
    let p_implies_q = Proposition::Implication(Box::new(p.clone()), Box::new(q.clone()));
    let q_implies_r = Proposition::Implication(Box::new(q), Box::new(r.clone()));
    let p_implies_r = Proposition::Implication(Box::new(p), Box::new(r));
    
    let inner_implication = Proposition::Implication(Box::new(q_implies_r), Box::new(p_implies_r));
    let goal = Proposition::Implication(Box::new(p_implies_q), Box::new(inner_implication));
    
    let premises = vec![];
    let proof = ProofGenerator::direct_proof(&premises, &goal);
    
    // è¿™ä¸ªè¯æ˜æ¯”è¾ƒå¤æ‚ï¼Œå¯èƒ½éœ€è¦æ›´é«˜çº§çš„ç­–ç•¥
    if let Some(proof) = proof {
        let system = ProofGenerator::default_system();
        let result = ProofValidator::validate_proof(&proof, &system);
        assert!(matches!(result, ValidationResult::Valid));
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸æ¨ç†ç†è®ºçš„å…³ç³»

è¯æ˜ç†è®ºå»ºç«‹åœ¨æ¨ç†ç†è®ºä¹‹ä¸Šï¼Œä½¿ç”¨æ¨ç†è§„åˆ™æ„å»ºè¯æ˜ã€‚

### 6.2 ä¸æ•°å­¦åŸºç¡€çš„å…³ç³»

è¯æ˜ç†è®ºä¸ºæ•°å­¦è¯æ˜æä¾›å½¢å¼åŒ–æ¡†æ¶ã€‚

### 6.3 ä¸è®¡ç®—æœºç§‘å­¦çš„å…³ç³»

è¯æ˜ç†è®ºä¸ºç¨‹åºéªŒè¯ã€å®šç†è¯æ˜ç³»ç»Ÿæä¾›ç†è®ºåŸºç¡€ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Takeuti, G. (2013). Proof Theory. Courier Corporation.
2. Troelstra, A. S., & Schwichtenberg, H. (2000). Basic Proof Theory. Cambridge University Press.
3. Girard, J. Y., Lafont, Y., & Taylor, P. (1989). Proofs and Types. Cambridge University Press.
4. ç‹å®ªé’§. (1998). æ•°ç†é€»è¾‘å¼•è®º. åŒ—äº¬å¤§å­¦å‡ºç‰ˆç¤¾.
5. å¼ æ¸…å®‡. (2006). é€»è¾‘å“²å­¦ä¹ç« . æ±Ÿè‹äººæ°‘å‡ºç‰ˆç¤¾.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [01.4.1 é€»è¾‘åŸºç¡€](../01.4.1_é€»è¾‘åŸºç¡€.md)
- [01.4.2 æ¨ç†ç†è®º](../01.4.2_æ¨ç†ç†è®º.md)
- [01.4.4 é€»è¾‘å“²å­¦](../01.4.4_é€»è¾‘å“²å­¦.md)
- [02.2.1 å‘½é¢˜é€»è¾‘](../../02_Mathematical_Foundation/02.2.1_å‘½é¢˜é€»è¾‘.md)
- [02.2.2 è°“è¯é€»è¾‘](../../02_Mathematical_Foundation/02.2.2_è°“è¯é€»è¾‘.md)
