# 01.4.4 é€»è¾‘å“²å­¦

## ğŸ“‹ æ¦‚è¿°

é€»è¾‘å“²å­¦æ˜¯ç ”ç©¶é€»è¾‘å­¦åŸºç¡€ã€æœ¬è´¨å’Œå“²å­¦é—®é¢˜çš„å­¦ç§‘ï¼Œæ¢è®¨é€»è¾‘æ¨ç†çš„åˆç†æ€§ã€é€»è¾‘ç³»ç»Ÿçš„é€‰æ‹©æ ‡å‡†ä»¥åŠé€»è¾‘ä¸è¯­è¨€ã€æ€ç»´ã€ç°å®çš„å…³ç³»ã€‚æœ¬æ–‡æ¡£å»ºç«‹é€»è¾‘å“²å­¦çš„å½¢å¼åŒ–ç†è®ºæ¡†æ¶ï¼Œä¸ºå½¢å¼ç§‘å­¦æä¾›å“²å­¦åŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹é€»è¾‘å“²å­¦çš„å½¢å¼åŒ–åŸºç¡€**
2. **åˆ†æé€»è¾‘ç³»ç»Ÿçš„å“²å­¦é—®é¢˜**
3. **æ¢è®¨é€»è¾‘ä¸è¯­è¨€çš„å…³ç³»**
4. **ç ”ç©¶é€»è¾‘æ¨ç†çš„åˆç†æ€§**
5. **æ„å»ºé€»è¾‘å“²å­¦çš„åº”ç”¨æ¡†æ¶**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 é€»è¾‘å“²å­¦çš„å®šä¹‰

**å®šä¹‰ 1.1** (é€»è¾‘å“²å­¦)
é€»è¾‘å“²å­¦æ˜¯ç ”ç©¶é€»è¾‘å­¦åŸºç¡€ã€æœ¬è´¨å’Œå“²å­¦é—®é¢˜çš„å­¦ç§‘ï¼ŒåŒ…æ‹¬ï¼š

- é€»è¾‘æ¨ç†çš„åˆç†æ€§åˆ†æ
- é€»è¾‘ç³»ç»Ÿçš„é€‰æ‹©æ ‡å‡†
- é€»è¾‘ä¸è¯­è¨€çš„å…³ç³»
- é€»è¾‘ä¸æ€ç»´çš„å…³ç³»
- é€»è¾‘ä¸ç°å®çš„å…³ç³»

### 1.2 é€»è¾‘å“²å­¦çš„æ ¸å¿ƒé—®é¢˜

**é—®é¢˜ 1.1** (é€»è¾‘å“²å­¦æ ¸å¿ƒé—®é¢˜)
é€»è¾‘å“²å­¦ç ”ç©¶ä»¥ä¸‹æ ¸å¿ƒé—®é¢˜ï¼š

1. **é€»è¾‘æ¨ç†çš„åˆç†æ€§**ï¼šä»€ä¹ˆæ ·çš„æ¨ç†æ˜¯åˆç†çš„ï¼Ÿ
2. **é€»è¾‘ç³»ç»Ÿçš„é€‰æ‹©**ï¼šå¦‚ä½•é€‰æ‹©é€‚å½“çš„é€»è¾‘ç³»ç»Ÿï¼Ÿ
3. **é€»è¾‘ä¸è¯­è¨€**ï¼šé€»è¾‘ä¸è‡ªç„¶è¯­è¨€çš„å…³ç³»æ˜¯ä»€ä¹ˆï¼Ÿ
4. **é€»è¾‘ä¸æ€ç»´**ï¼šé€»è¾‘å¦‚ä½•åæ˜ æ€ç»´è§„å¾‹ï¼Ÿ
5. **é€»è¾‘ä¸ç°å®**ï¼šé€»è¾‘å¦‚ä½•æè¿°ç°å®ä¸–ç•Œï¼Ÿ

### 1.3 é€»è¾‘å“²å­¦çš„ä¸»è¦æµæ´¾

**å®šä¹‰ 1.2** (é€»è¾‘å“²å­¦æµæ´¾)
é€»è¾‘å“²å­¦çš„ä¸»è¦æµæ´¾åŒ…æ‹¬ï¼š

1. **å½¢å¼ä¸»ä¹‰**ï¼šé€»è¾‘æ˜¯å½¢å¼ç³»ç»Ÿï¼Œç‹¬ç«‹äºå†…å®¹
2. **ç›´è§‰ä¸»ä¹‰**ï¼šé€»è¾‘åŸºäºæ•°å­¦ç›´è§‰å’Œæ„é€ æ€§è¯æ˜
3. **é€»è¾‘å®è¯ä¸»ä¹‰**ï¼šé€»è¾‘æ˜¯ç»éªŒéªŒè¯çš„å·¥å…·
4. **å®ç”¨ä¸»ä¹‰**ï¼šé€»è¾‘çš„æœ‰æ•ˆæ€§åœ¨äºå…¶å®ç”¨ä»·å€¼

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 é€»è¾‘ç³»ç»Ÿæ¡†æ¶

**å®šä¹‰ 2.1** (é€»è¾‘ç³»ç»Ÿ)
ä¸€ä¸ªé€»è¾‘ç³»ç»Ÿæ˜¯ä¸€ä¸ªå››å…ƒç»„ $\mathcal{L} = (L, \vdash, \models, \mathcal{I})$ï¼Œå…¶ä¸­ï¼š

- $L$ æ˜¯è¯­è¨€é›†åˆ
- $\vdash$ æ˜¯è¯­æ³•æ¨å¯¼å…³ç³»
- $\models$ æ˜¯è¯­ä¹‰æ»¡è¶³å…³ç³»
- $\mathcal{I}$ æ˜¯è§£é‡Šå‡½æ•°

**å®šä¹‰ 2.2** (é€»è¾‘æ¨ç†çš„åˆç†æ€§)
é€»è¾‘æ¨ç†çš„åˆç†æ€§å®šä¹‰ä¸ºï¼š

$$\text{åˆç†æ€§}(\mathcal{L}) = \text{å¯é æ€§}(\mathcal{L}) \land \text{å®Œå¤‡æ€§}(\mathcal{L})$$

å…¶ä¸­ï¼š

- $\text{å¯é æ€§}(\mathcal{L}) = \forall \Gamma, \phi. (\Gamma \vdash \phi \Rightarrow \Gamma \models \phi)$
- $\text{å®Œå¤‡æ€§}(\mathcal{L}) = \forall \Gamma, \phi. (\Gamma \models \phi \Rightarrow \Gamma \vdash \phi)$

### 2.2 é€»è¾‘å“²å­¦çš„å½¢å¼åŒ–æ¨¡å‹

**å®šä¹‰ 2.3** (é€»è¾‘å“²å­¦æ¨¡å‹)
é€»è¾‘å“²å­¦æ¨¡å‹æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $\mathcal{P} = (W, R, V, \mathcal{T}, \mathcal{E})$ï¼Œå…¶ä¸­ï¼š

- $W$ æ˜¯å¯èƒ½ä¸–ç•Œé›†åˆ
- $R$ æ˜¯å¯è¾¾å…³ç³»
- $V$ æ˜¯èµ‹å€¼å‡½æ•°
- $\mathcal{T}$ æ˜¯çœŸç†ç†è®º
- $\mathcal{E}$ æ˜¯è®¤è¯†è®ºå‡½æ•°

**å®šä¹‰ 2.4** (é€»è¾‘çœŸç†)
åœ¨é€»è¾‘å“²å­¦æ¨¡å‹ $\mathcal{P}$ ä¸­ï¼Œé€»è¾‘çœŸç†å®šä¹‰ä¸ºï¼š

$$\mathcal{P} \models \phi \text{ å½“ä¸”ä»…å½“ } \forall w \in W. \mathcal{P}, w \models \phi$$

### 2.3 é€»è¾‘ä¸è¯­è¨€çš„å…³ç³»

**å®šä¹‰ 2.5** (é€»è¾‘-è¯­è¨€æ˜ å°„)
é€»è¾‘ä¸è¯­è¨€çš„æ˜ å°„å…³ç³»å®šä¹‰ä¸ºï¼š

$$\mathcal{M}: \mathcal{L} \times \mathcal{N} \rightarrow \mathcal{I}$$

å…¶ä¸­ï¼š

- $\mathcal{L}$ æ˜¯é€»è¾‘ç³»ç»Ÿ
- $\mathcal{N}$ æ˜¯è‡ªç„¶è¯­è¨€
- $\mathcal{I}$ æ˜¯è§£é‡Šç©ºé—´

**å®šç† 2.1** (é€»è¾‘-è¯­è¨€å¯¹åº”æ€§)
å¯¹äºä»»ä½•é€»è¾‘ç³»ç»Ÿ $\mathcal{L}$ å’Œè‡ªç„¶è¯­è¨€ $\mathcal{N}$ï¼Œå­˜åœ¨æ˜ å°„ $\mathcal{M}$ ä½¿å¾—ï¼š

$$\forall \phi \in \mathcal{L}. \exists \psi \in \mathcal{N}. \mathcal{M}(\phi) = \psi$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 é€»è¾‘æ¨ç†çš„åˆç†æ€§å®šç†

**å®šç† 3.1** (é€»è¾‘æ¨ç†åˆç†æ€§)
å¦‚æœé€»è¾‘ç³»ç»Ÿ $\mathcal{L}$ æ˜¯å¯é ä¸”å®Œå¤‡çš„ï¼Œåˆ™å…¶æ¨ç†æ˜¯åˆç†çš„ã€‚

**è¯æ˜**ï¼š

1. å‡è®¾ $\mathcal{L}$ æ˜¯å¯é ä¸”å®Œå¤‡çš„
2. æ ¹æ®å®šä¹‰ 2.2ï¼Œ$\text{åˆç†æ€§}(\mathcal{L}) = \text{å¯é æ€§}(\mathcal{L}) \land \text{å®Œå¤‡æ€§}(\mathcal{L})$
3. ç”±äº $\mathcal{L}$ æ˜¯å¯é ä¸”å®Œå¤‡çš„ï¼Œæ‰€ä»¥ $\text{åˆç†æ€§}(\mathcal{L}) = \text{True}$
4. å› æ­¤ï¼Œ$\mathcal{L}$ çš„æ¨ç†æ˜¯åˆç†çš„ã€‚$\square$

### 3.2 é€»è¾‘ç³»ç»Ÿé€‰æ‹©å®šç†

**å®šç† 3.2** (é€»è¾‘ç³»ç»Ÿé€‰æ‹©)
å¯¹äºä»»ä½•é—®é¢˜åŸŸ $D$ï¼Œå­˜åœ¨æœ€ä¼˜é€»è¾‘ç³»ç»Ÿ $\mathcal{L}^*$ ä½¿å¾—ï¼š

$$\mathcal{L}^* = \arg\max_{\mathcal{L}} \text{é€‚ç”¨æ€§}(\mathcal{L}, D)$$

å…¶ä¸­é€‚ç”¨æ€§å®šä¹‰ä¸ºï¼š

$$\text{é€‚ç”¨æ€§}(\mathcal{L}, D) = \alpha \cdot \text{è¡¨è¾¾èƒ½åŠ›}(\mathcal{L}) + \beta \cdot \text{è®¡ç®—æ•ˆç‡}(\mathcal{L}) + \gamma \cdot \text{ç›´è§‚æ€§}(\mathcal{L})$$

**è¯æ˜**ï¼š

1. ç”±äºé€»è¾‘ç³»ç»Ÿé›†åˆæ˜¯æœ‰é™çš„ï¼Œé€‚ç”¨æ€§å‡½æ•°æ˜¯è¿ç»­çš„
2. æ ¹æ®æå€¼å®šç†ï¼Œå­˜åœ¨æœ€å¤§å€¼
3. å› æ­¤å­˜åœ¨æœ€ä¼˜é€»è¾‘ç³»ç»Ÿ $\mathcal{L}^*$ã€‚$\square$

### 3.3 é€»è¾‘ä¸æ€ç»´å¯¹åº”å®šç†

**å®šç† 3.3** (é€»è¾‘-æ€ç»´å¯¹åº”)
é€»è¾‘æ¨ç†ä¸æ€ç»´è¿‡ç¨‹å­˜åœ¨ç»“æ„å¯¹åº”å…³ç³»ï¼š

$$\forall \text{æ€ç»´è¿‡ç¨‹ } T. \exists \text{é€»è¾‘æ¨ç† } R. \text{ç»“æ„å¯¹åº”}(T, R)$$

**è¯æ˜**ï¼š

1. æ€ç»´è¿‡ç¨‹å¯ä»¥å½¢å¼åŒ–ä¸ºçŠ¶æ€è½¬æ¢åºåˆ—
2. é€»è¾‘æ¨ç†ä¹Ÿå¯ä»¥å½¢å¼åŒ–ä¸ºçŠ¶æ€è½¬æ¢åºåˆ—
3. å­˜åœ¨åŒæ„æ˜ å°„ä½¿å¾—ä¸¤è€…å¯¹åº”
4. å› æ­¤å­˜åœ¨ç»“æ„å¯¹åº”å…³ç³»ã€‚$\square$

## 4. ä»£ç å®ç°

### 4.1 é€»è¾‘å“²å­¦æ¨¡å‹å®ç°

```rust
use std::collections::HashMap;
use std::fmt;

/// é€»è¾‘å“²å­¦æ¨¡å‹
#[derive(Debug, Clone)]
pub struct LogicPhilosophyModel {
    /// å¯èƒ½ä¸–ç•Œé›†åˆ
    worlds: Vec<String>,
    /// å¯è¾¾å…³ç³»
    accessibility: HashMap<(String, String), bool>,
    /// èµ‹å€¼å‡½æ•°
    valuation: HashMap<(String, String), bool>,
    /// çœŸç†ç†è®º
    truth_theory: TruthTheory,
    /// è®¤è¯†è®ºå‡½æ•°
    epistemology: EpistemologyFunction,
}

/// çœŸç†ç†è®º
#[derive(Debug, Clone)]
pub enum TruthTheory {
    Correspondence,    // ç¬¦åˆè®º
    Coherence,         // èè´¯è®º
    Pragmatic,         // å®ç”¨è®º
    Deflationary,      // ç´§ç¼©è®º
}

/// è®¤è¯†è®ºå‡½æ•°
#[derive(Debug, Clone)]
pub struct EpistemologyFunction {
    /// çŸ¥è¯†å‡½æ•°
    knowledge: HashMap<String, Vec<String>>,
    /// ä¿¡å¿µå‡½æ•°
    belief: HashMap<String, Vec<String>>,
    /// ç¡®è¯å‡½æ•°
    justification: HashMap<String, Vec<String>>,
}

impl LogicPhilosophyModel {
    /// åˆ›å»ºæ–°çš„é€»è¾‘å“²å­¦æ¨¡å‹
    pub fn new() -> Self {
        Self {
            worlds: Vec::new(),
            accessibility: HashMap::new(),
            valuation: HashMap::new(),
            truth_theory: TruthTheory::Correspondence,
            epistemology: EpistemologyFunction::new(),
        }
    }

    /// æ·»åŠ å¯èƒ½ä¸–ç•Œ
    pub fn add_world(&mut self, world: String) {
        self.worlds.push(world);
    }

    /// è®¾ç½®å¯è¾¾å…³ç³»
    pub fn set_accessibility(&mut self, from: String, to: String, accessible: bool) {
        self.accessibility.insert((from, to), accessible);
    }

    /// è®¾ç½®èµ‹å€¼
    pub fn set_valuation(&mut self, world: String, proposition: String, value: bool) {
        self.valuation.insert((world, proposition), value);
    }

    /// æ£€æŸ¥é€»è¾‘çœŸç†
    pub fn is_logical_truth(&self, proposition: &str) -> bool {
        self.worlds.iter().all(|world| {
            self.valuation.get(&(world.clone(), proposition.to_string()))
                .unwrap_or(&false)
        })
    }

    /// æ£€æŸ¥é€»è¾‘æœ‰æ•ˆæ€§
    pub fn is_logically_valid(&self, premises: &[String], conclusion: &str) -> bool {
        // æ£€æŸ¥æ‰€æœ‰ä½¿å‰æä¸ºçœŸçš„ä¸–ç•Œæ˜¯å¦ä¹Ÿä½¿ç»“è®ºä¸ºçœŸ
        self.worlds.iter().all(|world| {
            let premises_true = premises.iter().all(|premise| {
                self.valuation.get(&(world.clone(), premise.clone()))
                    .unwrap_or(&false)
            });
            
            if premises_true {
                self.valuation.get(&(world.clone(), conclusion.to_string()))
                    .unwrap_or(&false)
            } else {
                true
            }
        })
    }
}

impl EpistemologyFunction {
    pub fn new() -> Self {
        Self {
            knowledge: HashMap::new(),
            belief: HashMap::new(),
            justification: HashMap::new(),
        }
    }

    /// æ·»åŠ çŸ¥è¯†
    pub fn add_knowledge(&mut self, agent: String, proposition: String) {
        self.knowledge.entry(agent).or_insert_with(Vec::new).push(proposition);
    }

    /// æ·»åŠ ä¿¡å¿µ
    pub fn add_belief(&mut self, agent: String, proposition: String) {
        self.belief.entry(agent).or_insert_with(Vec::new).push(proposition);
    }

    /// æ·»åŠ ç¡®è¯
    pub fn add_justification(&mut self, agent: String, evidence: String) {
        self.justification.entry(agent).or_insert_with(Vec::new).push(evidence);
    }
}

/// é€»è¾‘ç³»ç»Ÿé€‰æ‹©å™¨
pub struct LogicSystemSelector {
    /// å¯ç”¨é€»è¾‘ç³»ç»Ÿ
    systems: Vec<LogicSystem>,
}

#[derive(Debug, Clone)]
pub struct LogicSystem {
    name: String,
    expressiveness: f64,
    efficiency: f64,
    intuitiveness: f64,
}

impl LogicSystemSelector {
    pub fn new() -> Self {
        Self {
            systems: Vec::new(),
        }
    }

    /// æ·»åŠ é€»è¾‘ç³»ç»Ÿ
    pub fn add_system(&mut self, system: LogicSystem) {
        self.systems.push(system);
    }

    /// é€‰æ‹©æœ€ä¼˜é€»è¾‘ç³»ç»Ÿ
    pub fn select_optimal(&self, domain: &str, alpha: f64, beta: f64, gamma: f64) -> Option<&LogicSystem> {
        self.systems.iter().max_by(|a, b| {
            let score_a = alpha * a.expressiveness + beta * a.efficiency + gamma * a.intuitiveness;
            let score_b = alpha * b.expressiveness + beta * b.efficiency + gamma * b.intuitiveness;
            score_a.partial_cmp(&score_b).unwrap_or(std::cmp::Ordering::Equal)
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_logic_philosophy_model() {
        let mut model = LogicPhilosophyModel::new();
        
        // æ·»åŠ å¯èƒ½ä¸–ç•Œ
        model.add_world("w1".to_string());
        model.add_world("w2".to_string());
        
        // è®¾ç½®èµ‹å€¼
        model.set_valuation("w1".to_string(), "p".to_string(), true);
        model.set_valuation("w2".to_string(), "p".to_string(), true);
        
        // æ£€æŸ¥é€»è¾‘çœŸç†
        assert!(model.is_logical_truth("p"));
    }

    #[test]
    fn test_logic_system_selection() {
        let mut selector = LogicSystemSelector::new();
        
        // æ·»åŠ é€»è¾‘ç³»ç»Ÿ
        selector.add_system(LogicSystem {
            name: "Classical Logic".to_string(),
            expressiveness: 0.8,
            efficiency: 0.9,
            intuitiveness: 0.7,
        });
        
        selector.add_system(LogicSystem {
            name: "Intuitionistic Logic".to_string(),
            expressiveness: 0.6,
            efficiency: 0.7,
            intuitiveness: 0.8,
        });
        
        // é€‰æ‹©æœ€ä¼˜ç³»ç»Ÿ
        let optimal = selector.select_optimal("mathematics", 0.4, 0.3, 0.3);
        assert!(optimal.is_some());
        assert_eq!(optimal.unwrap().name, "Classical Logic");
    }
}
```

### 4.2 Haskellå®ç°

```haskell
-- é€»è¾‘å“²å­¦æ¨¡å‹
data TruthTheory = Correspondence | Coherence | Pragmatic | Deflationary
  deriving (Show, Eq)

-- å¯èƒ½ä¸–ç•Œ
type World = String
type Proposition = String
type Agent = String

-- é€»è¾‘å“²å­¦æ¨¡å‹
data LogicPhilosophyModel = LogicPhilosophyModel
  { worlds :: [World]
  , accessibility :: [(World, World)]
  , valuation :: [(World, Proposition, Bool)]
  , truthTheory :: TruthTheory
  , knowledge :: [(Agent, Proposition)]
  , belief :: [(Agent, Proposition)]
  , justification :: [(Agent, Proposition)]
  } deriving (Show)

-- åˆ›å»ºç©ºæ¨¡å‹
emptyModel :: LogicPhilosophyModel
emptyModel = LogicPhilosophyModel
  { worlds = []
  , accessibility = []
  , valuation = []
  , truthTheory = Correspondence
  , knowledge = []
  , belief = []
  , justification = []
  }

-- æ·»åŠ å¯èƒ½ä¸–ç•Œ
addWorld :: World -> LogicPhilosophyModel -> LogicPhilosophyModel
addWorld w model = model { worlds = w : worlds model }

-- è®¾ç½®å¯è¾¾å…³ç³»
setAccessibility :: World -> World -> LogicPhilosophyModel -> LogicPhilosophyModel
setAccessibility from to model = 
  model { accessibility = (from, to) : accessibility model }

-- è®¾ç½®èµ‹å€¼
setValuation :: World -> Proposition -> Bool -> LogicPhilosophyModel -> LogicPhilosophyModel
setValuation w p v model = 
  model { valuation = (w, p, v) : valuation model }

-- æ£€æŸ¥é€»è¾‘çœŸç†
isLogicalTruth :: Proposition -> LogicPhilosophyModel -> Bool
isLogicalTruth p model = 
  all (\w -> getValuation w p model) (worlds model)
  where
    getValuation w p model = 
      case lookup (w, p) [(w', p', v) | (w', p', v) <- valuation model, w' == w, p' == p] of
        Just v -> v
        Nothing -> False

-- æ£€æŸ¥é€»è¾‘æœ‰æ•ˆæ€§
isLogicallyValid :: [Proposition] -> Proposition -> LogicPhilosophyModel -> Bool
isLogicallyValid premises conclusion model =
  all (\w -> 
    if all (\p -> getValuation w p model) premises
    then getValuation w conclusion model
    else True
  ) (worlds model)
  where
    getValuation w p model = 
      case lookup (w, p) [(w', p', v) | (w', p', v) <- valuation model, w' == w, p' == p] of
        Just v -> v
        Nothing -> False

-- é€»è¾‘ç³»ç»Ÿ
data LogicSystem = LogicSystem
  { systemName :: String
  , expressiveness :: Double
  , efficiency :: Double
  , intuitiveness :: Double
  } deriving (Show)

-- è®¡ç®—é€‚ç”¨æ€§åˆ†æ•°
applicability :: LogicSystem -> Double -> Double -> Double -> Double
applicability system alpha beta gamma =
  alpha * expressiveness system + 
  beta * efficiency system + 
  gamma * intuitiveness system

-- é€‰æ‹©æœ€ä¼˜é€»è¾‘ç³»ç»Ÿ
selectOptimal :: [LogicSystem] -> Double -> Double -> Double -> Maybe LogicSystem
selectOptimal systems alpha beta gamma =
  case systems of
    [] -> Nothing
    _ -> Just $ maximumBy (\a b -> 
           compare (applicability a alpha beta gamma) 
                   (applicability b alpha beta gamma)) systems

-- ç¤ºä¾‹ä½¿ç”¨
example :: IO ()
example = do
  -- åˆ›å»ºæ¨¡å‹
  let model = addWorld "w1" $ addWorld "w2" emptyModel
      model' = setValuation "w1" "p" True $ 
               setValuation "w2" "p" True model
  
  -- æ£€æŸ¥é€»è¾‘çœŸç†
  putStrLn $ "p is logical truth: " ++ show (isLogicalTruth "p" model')
  
  -- é€»è¾‘ç³»ç»Ÿé€‰æ‹©
  let systems = 
        [ LogicSystem "Classical Logic" 0.8 0.9 0.7
        , LogicSystem "Intuitionistic Logic" 0.6 0.7 0.8
        ]
  
  case selectOptimal systems 0.4 0.3 0.3 of
    Just optimal -> putStrLn $ "Optimal system: " ++ systemName optimal
    Nothing -> putStrLn "No systems available"
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 é€»è¾‘ç³»ç»Ÿé€‰æ‹©åº”ç”¨

```rust
fn main() {
    // åˆ›å»ºé€»è¾‘ç³»ç»Ÿé€‰æ‹©å™¨
    let mut selector = LogicSystemSelector::new();
    
    // æ·»åŠ å„ç§é€»è¾‘ç³»ç»Ÿ
    selector.add_system(LogicSystem {
        name: "Classical Logic".to_string(),
        expressiveness: 0.8,
        efficiency: 0.9,
        intuitiveness: 0.7,
    });
    
    selector.add_system(LogicSystem {
        name: "Intuitionistic Logic".to_string(),
        expressiveness: 0.6,
        efficiency: 0.7,
        intuitiveness: 0.8,
    });
    
    selector.add_system(LogicSystem {
        name: "Modal Logic".to_string(),
        expressiveness: 0.9,
        efficiency: 0.6,
        intuitiveness: 0.6,
    });
    
    // ä¸ºä¸åŒé¢†åŸŸé€‰æ‹©æœ€ä¼˜é€»è¾‘ç³»ç»Ÿ
    let domains = vec![
        ("mathematics", (0.4, 0.3, 0.3)),
        ("computer_science", (0.3, 0.5, 0.2)),
        ("philosophy", (0.2, 0.2, 0.6)),
    ];
    
    for (domain, (alpha, beta, gamma)) in domains {
        if let Some(optimal) = selector.select_optimal(domain, alpha, beta, gamma) {
            println!("Domain: {}, Optimal System: {}", domain, optimal.name);
        }
    }
}
```

### 5.2 é€»è¾‘å“²å­¦æ¨¡å‹åº”ç”¨

```rust
fn main() {
    // åˆ›å»ºé€»è¾‘å“²å­¦æ¨¡å‹
    let mut model = LogicPhilosophyModel::new();
    
    // æ·»åŠ å¯èƒ½ä¸–ç•Œ
    model.add_world("ç°å®ä¸–ç•Œ".to_string());
    model.add_world("å¯èƒ½ä¸–ç•Œ1".to_string());
    model.add_world("å¯èƒ½ä¸–ç•Œ2".to_string());
    
    // è®¾ç½®å¯è¾¾å…³ç³»
    model.set_accessibility("ç°å®ä¸–ç•Œ".to_string(), "å¯èƒ½ä¸–ç•Œ1".to_string(), true);
    model.set_accessibility("ç°å®ä¸–ç•Œ".to_string(), "å¯èƒ½ä¸–ç•Œ2".to_string(), true);
    
    // è®¾ç½®èµ‹å€¼
    model.set_valuation("ç°å®ä¸–ç•Œ".to_string(), "å­˜åœ¨ä¸Šå¸".to_string(), false);
    model.set_valuation("å¯èƒ½ä¸–ç•Œ1".to_string(), "å­˜åœ¨ä¸Šå¸".to_string(), true);
    model.set_valuation("å¯èƒ½ä¸–ç•Œ2".to_string(), "å­˜åœ¨ä¸Šå¸".to_string(), false);
    
    // æ£€æŸ¥é€»è¾‘çœŸç†
    println!("'å­˜åœ¨ä¸Šå¸'æ˜¯é€»è¾‘çœŸç†: {}", model.is_logical_truth("å­˜åœ¨ä¸Šå¸"));
    
    // æ£€æŸ¥é€»è¾‘æœ‰æ•ˆæ€§
    let premises = vec!["æ‰€æœ‰äººç±»éƒ½æ˜¯ç†æ€§çš„".to_string(), "è‹æ ¼æ‹‰åº•æ˜¯äººç±»".to_string()];
    let conclusion = "è‹æ ¼æ‹‰åº•æ˜¯ç†æ€§çš„";
    
    println!("æ¨ç†æœ‰æ•ˆ: {}", model.is_logically_valid(&premises, conclusion));
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸è®¤è¯†è®ºçš„å…³ç³»

é€»è¾‘å“²å­¦ä¸è®¤è¯†è®ºå¯†åˆ‡ç›¸å…³ï¼Œç‰¹åˆ«æ˜¯åœ¨çŸ¥è¯†ã€ä¿¡å¿µå’Œç¡®è¯çš„æ¦‚å¿µä¸Šã€‚å‚è§ï¼š

- [01.2.1 çŸ¥è¯†ç†è®º](../01.2.1_Knowledge_Theory.md)
- [01.2.2 ä¿¡å¿µç†è®º](../01.2.2_Belief_Theory.md)
- [01.2.3 ç¡®è¯ç†è®º](../01.2.3_Justification_Theory.md)

### 6.2 ä¸é€»è¾‘å­¦çš„å…³ç³»

é€»è¾‘å“²å­¦ä¸ºé€»è¾‘å­¦æä¾›å“²å­¦åŸºç¡€ï¼Œå‚è§ï¼š

- [02.2.1 å‘½é¢˜é€»è¾‘](../../02_Mathematical_Foundation/02.2.1_Propositional_Logic.md)
- [02.2.2 è°“è¯é€»è¾‘](../../02_Mathematical_Foundation/02.2.2_Predicate_Logic.md)
- [02.2.3 æ¨¡æ€é€»è¾‘](../../02_Mathematical_Foundation/02.2.3_Modal_Logic.md)

### 6.3 ä¸è¯­è¨€å“²å­¦çš„å…³ç³»

é€»è¾‘å“²å­¦ä¸è¯­è¨€å“²å­¦åœ¨æ„ä¹‰å’ŒæŒ‡ç§°é—®é¢˜ä¸Šç›¸äº’å½±å“ï¼Œå‚è§ï¼š

- [01.4.1 é€»è¾‘åŸºç¡€](../01.4.1_Logic_Foundation.md)
- [01.4.2 æ¨ç†ç†è®º](../01.4.2_Reasoning_Theory.md)

## 7. å‚è€ƒæ–‡çŒ®

1. Quine, W. V. O. (1951). "Two Dogmas of Empiricism". *The Philosophical Review*.
2. Tarski, A. (1936). "The Concept of Truth in Formalized Languages". *Logic, Semantics, Metamathematics*.
3. Kripke, S. (1972). *Naming and Necessity*. Harvard University Press.
4. Putnam, H. (1975). "The Meaning of 'Meaning'". *Mind, Language and Reality*.
5. Davidson, D. (1967). "Truth and Meaning". *Synthese*.
6. Dummett, M. (1973). *Frege: Philosophy of Language*. Harvard University Press.
7. Carnap, R. (1937). *The Logical Syntax of Language*. Routledge.
8. Russell, B. (1905). "On Denoting". *Mind*.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [01.4.1 é€»è¾‘åŸºç¡€](../01.4.1_Logic_Foundation.md)
- [01.4.2 æ¨ç†ç†è®º](../01.4.2_Reasoning_Theory.md)
- [01.4.3 è¯æ˜ç†è®º](../01.4.3_Proof_Theory.md)
- [02.2.1 å‘½é¢˜é€»è¾‘](../../02_Mathematical_Foundation/02.2.1_Propositional_Logic.md)
- [02.2.2 è°“è¯é€»è¾‘](../../02_Mathematical_Foundation/02.2.2_Predicate_Logic.md)
