# 02.1 形式语言基础 (Formal Language Foundation)

## 目录

```markdown
02.1 形式语言基础
├── 1. 基础概念
│   ├── 1.1 字母表与字符串
│   ├── 1.2 语言定义
│   ├── 1.3 语言运算
│   └── 1.4 语言层次
├── 2. 正则语言
│   ├── 2.1 正则表达式
│   ├── 2.2 有限自动机
│   ├── 2.3 正则语言性质
│   └── 2.4 泵引理
├── 3. 上下文无关语言
│   ├── 3.1 上下文无关文法
│   ├── 3.2 下推自动机
│   ├── 3.3 语法分析
│   └── 3.4 歧义性
├── 4. 上下文相关语言
│   ├── 4.1 上下文相关文法
│   ├── 4.2 线性有界自动机
│   ├── 4.3 语言性质
│   └── 4.4 应用领域
├── 5. 递归可枚举语言
│   ├── 5.1 图灵机
│   ├── 5.2 递归可枚举性
│   ├── 5.3 可判定性
│   └── 5.4 停机问题
├── 6. 自动机理论
│   ├── 6.1 有限自动机
│   ├── 6.2 下推自动机
│   ├── 6.3 图灵机
│   └── 6.4 自动机等价性
├── 7. 计算理论
│   ├── 7.1 可计算性
│   ├── 7.2 复杂性理论
│   ├── 7.3 算法分析
│   └── 7.4 实际应用
└── 8. 交叉引用
    ├── 8.1 相关理论
    ├── 8.2 应用领域
    ├── 8.3 扩展方向
    └── 8.4 参考文献
```

## 1. 基础概念

### 1.1 字母表与字符串

**定义 1.1.1 (字母表)**
字母表 $\Sigma$ 是一个有限的符号集合。

**定义 1.1.2 (字符串)**
字符串是字母表中符号的有限序列。

**定义 1.1.3 (字符串长度)**
字符串 $w$ 的长度 $|w|$ 是其包含的符号个数。

**定义 1.1.4 (空字符串)**
空字符串 $\varepsilon$ 是长度为 0 的字符串。

**定义 1.1.5 (字符串连接)**
字符串 $w_1$ 和 $w_2$ 的连接 $w_1 \cdot w_2$ 是将 $w_2$ 附加到 $w_1$ 后得到的字符串。

**定理 1.1.1 (字符串连接性质)**
1. 结合性：$(w_1 \cdot w_2) \cdot w_3 = w_1 \cdot (w_2 \cdot w_3)$
2. 单位元：$\varepsilon \cdot w = w \cdot \varepsilon = w$

### 1.2 语言定义

**定义 1.2.1 (语言)**
语言 $L$ 是字母表 $\Sigma$ 上字符串的集合：$L \subseteq \Sigma^*$

**定义 1.2.2 (克林闭包)**
$\Sigma^* = \bigcup_{i=0}^{\infty} \Sigma^i$，其中 $\Sigma^i$ 表示长度为 $i$ 的字符串集合。

**定义 1.2.3 (正闭包)**
$\Sigma^+ = \bigcup_{i=1}^{\infty} \Sigma^i$

### 1.3 语言运算

**定义 1.3.1 (语言并)**
$L_1 \cup L_2 = \{w \mid w \in L_1 \text{ 或 } w \in L_2\}$

**定义 1.3.2 (语言交)**
$L_1 \cap L_2 = \{w \mid w \in L_1 \text{ 且 } w \in L_2\}$

**定义 1.3.3 (语言补)**
$\overline{L} = \Sigma^* \setminus L$

**定义 1.3.4 (语言连接)**
$L_1 \cdot L_2 = \{w_1 \cdot w_2 \mid w_1 \in L_1, w_2 \in L_2\}$

**定义 1.3.5 (语言幂)**
$L^0 = \{\varepsilon\}$
$L^{i+1} = L \cdot L^i$

**定义 1.3.6 (语言克林闭包)**
$L^* = \bigcup_{i=0}^{\infty} L^i$

**定义 1.3.7 (语言正闭包)**
$L^+ = \bigcup_{i=1}^{\infty} L^i$

### 1.4 语言层次

**定义 1.4.1 (乔姆斯基层次)**
1. **类型 0 (递归可枚举语言)** - 图灵机可识别
2. **类型 1 (上下文相关语言)** - 线性有界自动机可识别
3. **类型 2 (上下文无关语言)** - 下推自动机可识别
4. **类型 3 (正则语言)** - 有限自动机可识别

## 2. 正则语言

### 2.1 正则表达式

**定义 2.1.1 (正则表达式)**
正则表达式的语法：
$$\begin{align}
R ::= & \emptyset \mid \varepsilon \mid a \mid \\
& R_1 \cup R_2 \mid R_1 \cdot R_2 \mid R^*
\end{align}$$

其中 $a \in \Sigma$。

**定义 2.1.2 (正则表达式语义)**
$$\begin{align}
L(\emptyset) &= \emptyset \\
L(\varepsilon) &= \{\varepsilon\} \\
L(a) &= \{a\} \\
L(R_1 \cup R_2) &= L(R_1) \cup L(R_2) \\
L(R_1 \cdot R_2) &= L(R_1) \cdot L(R_2) \\
L(R^*) &= L(R)^*
\end{align}$$

### 2.2 有限自动机

**定义 2.2.1 (确定性有限自动机)**
DFA $M = (Q, \Sigma, \delta, q_0, F)$ 其中：
- $Q$ 是有限状态集
- $\Sigma$ 是输入字母表
- $\delta : Q \times \Sigma \rightarrow Q$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $F \subseteq Q$ 是接受状态集

**定义 2.2.2 (非确定性有限自动机)**
NFA $M = (Q, \Sigma, \delta, q_0, F)$ 其中：
- $\delta : Q \times \Sigma \rightarrow 2^Q$ 是转移函数

**定义 2.2.3 (ε-NFA)**
ε-NFA $M = (Q, \Sigma, \delta, q_0, F)$ 其中：
- $\delta : Q \times (\Sigma \cup \{\varepsilon\}) \rightarrow 2^Q$ 是转移函数

### 2.3 正则语言性质

**定理 2.3.1 (正则语言封闭性)**
正则语言在以下运算下封闭：
1. 并运算
2. 交运算
3. 补运算
4. 连接运算
5. 克林闭包

**定理 2.3.2 (正则表达式与有限自动机等价性)**
对于任意正则表达式 $R$，存在有限自动机 $M$ 使得 $L(R) = L(M)$，反之亦然。

### 2.4 泵引理

**定理 2.4.1 (正则语言泵引理)**
设 $L$ 是正则语言，则存在常数 $n$ 使得对于任意 $w \in L$ 且 $|w| \geq n$，存在分解 $w = xyz$ 满足：
1. $|xy| \leq n$
2. $|y| > 0$
3. 对于任意 $i \geq 0$，$xy^iz \in L$

**证明：** 设 $M$ 是接受 $L$ 的 DFA，状态数为 $n$。对于长度至少为 $n$ 的字符串，根据鸽巢原理，存在状态重复，从而可以泵引。

## 3. 上下文无关语言

### 3.1 上下文无关文法

**定义 3.1.1 (上下文无关文法)**
CFG $G = (V, \Sigma, P, S)$ 其中：
- $V$ 是非终结符集合
- $\Sigma$ 是终结符集合
- $P$ 是产生式集合
- $S \in V$ 是开始符号

**定义 3.1.2 (产生式)**
产生式形如 $A \rightarrow \alpha$，其中 $A \in V$，$\alpha \in (V \cup \Sigma)^*$。

**定义 3.1.3 (推导)**
$\alpha \Rightarrow \beta$ 表示从 $\alpha$ 一步推导到 $\beta$。
$\alpha \Rightarrow^* \beta$ 表示从 $\alpha$ 零步或多步推导到 $\beta$。

### 3.2 下推自动机

**定义 3.2.1 (下推自动机)**
PDA $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$ 其中：
- $Q$ 是有限状态集
- $\Sigma$ 是输入字母表
- $\Gamma$ 是栈字母表
- $\delta : Q \times (\Sigma \cup \{\varepsilon\}) \times \Gamma \rightarrow 2^{Q \times \Gamma^*}$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $Z_0 \in \Gamma$ 是初始栈符号
- $F \subseteq Q$ 是接受状态集

### 3.3 语法分析

**定义 3.3.1 (语法分析)**
语法分析是确定输入字符串是否属于给定语言的过程。

**算法 3.3.1 (CYK算法)**
```haskell
-- CYK算法实现
cyk :: Grammar -> String -> Bool
cyk grammar input = 
  let n = length input
      table = array ((0,0), (n-1,n-1)) 
              [((i,j), derive grammar (take (j-i+1) (drop i input))) 
               | i <- [0..n-1], j <- [i..n-1]]
  in S `elem` table!(0,n-1)

derive :: Grammar -> String -> [Symbol]
derive grammar [] = []
derive grammar [c] = [c | c `elem` terminals grammar]
derive grammar str = 
  concat [derive grammar (take i str) `intersect` 
          derive grammar (drop i str) | i <- [1..length str-1]]
```

### 3.4 歧义性

**定义 3.4.1 (歧义文法)**
如果存在字符串 $w$ 有多个不同的最左推导，则文法 $G$ 是歧义的。

**定理 3.4.1 (歧义性不可判定)**
给定上下文无关文法 $G$，判断 $G$ 是否歧义是不可判定的。

## 4. 上下文相关语言

### 4.1 上下文相关文法

**定义 4.1.1 (上下文相关文法)**
CSG $G = (V, \Sigma, P, S)$ 其中产生式形如：
$\alpha A \beta \rightarrow \alpha \gamma \beta$
其中 $A \in V$，$\alpha, \beta \in (V \cup \Sigma)^*$，$\gamma \in (V \cup \Sigma)^+$。

### 4.2 线性有界自动机

**定义 4.2.1 (线性有界自动机)**
LBA $M = (Q, \Sigma, \Gamma, \delta, q_0, \#, F)$ 其中：
- 读写头不能超出输入边界
- $\#$ 是边界符号

### 4.3 语言性质

**定理 4.3.1 (上下文相关语言封闭性)**
上下文相关语言在以下运算下封闭：
1. 并运算
2. 交运算
3. 连接运算
4. 克林闭包

### 4.4 应用领域

- 自然语言处理
- 编译器设计
- 形式化验证

## 5. 递归可枚举语言

### 5.1 图灵机

**定义 5.1.1 (图灵机)**
TM $M = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$ 其中：
- $Q$ 是有限状态集
- $\Sigma$ 是输入字母表
- $\Gamma$ 是磁带字母表
- $\delta : Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $B \in \Gamma$ 是空白符号
- $F \subseteq Q$ 是接受状态集

### 5.2 递归可枚举性

**定义 5.2.1 (递归可枚举语言)**
语言 $L$ 是递归可枚举的，如果存在图灵机 $M$ 使得 $L = L(M)$。

**定义 5.2.2 (递归语言)**
语言 $L$ 是递归的，如果存在图灵机 $M$ 使得 $M$ 总是停机且 $L = L(M)$。

### 5.3 可判定性

**定理 5.3.1 (可判定性)**
语言 $L$ 是可判定的，当且仅当 $L$ 和 $\overline{L}$ 都是递归可枚举的。

### 5.4 停机问题

**定理 5.4.1 (停机问题不可判定)**
停机问题 $H = \{\langle M, w \rangle \mid M \text{ 在输入 } w \text{ 上停机}\}$ 是不可判定的。

**证明：** 假设 $H$ 可判定，构造图灵机 $D$ 使得 $D$ 在输入 $\langle D \rangle$ 上的行为矛盾。

## 6. 自动机理论

### 6.1 有限自动机

```rust
// Rust 有限自动机实现
use std::collections::HashMap;

#[derive(Debug, Clone)]
struct DFA {
    states: Vec<String>,
    alphabet: Vec<char>,
    transitions: HashMap<(String, char), String>,
    initial_state: String,
    accepting_states: Vec<String>,
}

impl DFA {
    fn new() -> Self {
        DFA {
            states: Vec::new(),
            alphabet: Vec::new(),
            transitions: HashMap::new(),
            initial_state: String::new(),
            accepting_states: Vec::new(),
        }
    }
    
    fn add_transition(&mut self, from: String, symbol: char, to: String) {
        self.transitions.insert((from, symbol), to);
    }
    
    fn accepts(&self, input: &str) -> bool {
        let mut current_state = self.initial_state.clone();
        
        for symbol in input.chars() {
            if let Some(next_state) = self.transitions.get(&(current_state.clone(), symbol)) {
                current_state = next_state.clone();
            } else {
                return false;
            }
        }
        
        self.accepting_states.contains(&current_state)
    }
}
```

### 6.2 下推自动机

```rust
// Rust 下推自动机实现
use std::collections::HashMap;

#[derive(Debug, Clone)]
struct PDA {
    states: Vec<String>,
    input_alphabet: Vec<char>,
    stack_alphabet: Vec<char>,
    transitions: HashMap<(String, char, char), Vec<(String, String)>>,
    initial_state: String,
    initial_stack_symbol: char,
    accepting_states: Vec<String>,
}

impl PDA {
    fn new() -> Self {
        PDA {
            states: Vec::new(),
            input_alphabet: Vec::new(),
            stack_alphabet: Vec::new(),
            transitions: HashMap::new(),
            initial_state: String::new(),
            initial_stack_symbol: 'Z',
            accepting_states: Vec::new(),
        }
    }
    
    fn add_transition(&mut self, from: String, input: char, stack_top: char, 
                     to: String, stack_push: String) {
        let key = (from, input, stack_top);
        let value = (to, stack_push);
        
        self.transitions.entry(key)
            .or_insert_with(Vec::new)
            .push(value);
    }
}
```

### 6.3 图灵机

```rust
// Rust 图灵机实现
use std::collections::HashMap;

#[derive(Debug, Clone)]
enum Direction {
    Left,
    Right,
}

#[derive(Debug, Clone)]
struct TuringMachine {
    states: Vec<String>,
    input_alphabet: Vec<char>,
    tape_alphabet: Vec<char>,
    transitions: HashMap<(String, char), (String, char, Direction)>,
    initial_state: String,
    blank_symbol: char,
    accepting_states: Vec<String>,
}

impl TuringMachine {
    fn new() -> Self {
        TuringMachine {
            states: Vec::new(),
            input_alphabet: Vec::new(),
            tape_alphabet: Vec::new(),
            transitions: HashMap::new(),
            initial_state: String::new(),
            blank_symbol: 'B',
            accepting_states: Vec::new(),
        }
    }
    
    fn add_transition(&mut self, from: String, read: char, 
                     to: String, write: char, direction: Direction) {
        self.transitions.insert((from, read), (to, write, direction));
    }
    
    fn run(&self, input: &str) -> bool {
        let mut tape: Vec<char> = input.chars().collect();
        let mut head = 0;
        let mut current_state = self.initial_state.clone();
        
        loop {
            let current_symbol = if head < tape.len() { tape[head] } else { self.blank_symbol };
            
            if let Some((next_state, write_symbol, direction)) = 
                self.transitions.get(&(current_state.clone(), current_symbol)) {
                
                // 写入符号
                if head < tape.len() {
                    tape[head] = *write_symbol;
                } else {
                    tape.push(*write_symbol);
                }
                
                // 移动读写头
                match direction {
                    Direction::Left => {
                        if head > 0 { head -= 1; }
                    }
                    Direction::Right => {
                        head += 1;
                        if head >= tape.len() {
                            tape.push(self.blank_symbol);
                        }
                    }
                }
                
                current_state = next_state.clone();
            } else {
                break;
            }
        }
        
        self.accepting_states.contains(&current_state)
    }
}
```

### 6.4 自动机等价性

**定理 6.4.1 (DFA与NFA等价性)**
对于任意NFA $N$，存在DFA $D$ 使得 $L(N) = L(D)$。

**定理 6.4.2 (NFA与ε-NFA等价性)**
对于任意ε-NFA $N$，存在NFA $N'$ 使得 $L(N) = L(N')$。

## 7. 计算理论

### 7.1 可计算性

**定义 7.1.1 (可计算函数)**
函数 $f$ 是可计算的，如果存在图灵机 $M$ 计算 $f$。

**定义 7.1.2 (可判定问题)**
问题 $P$ 是可判定的，如果存在图灵机 $M$ 总是停机且正确回答 $P$。

### 7.2 复杂性理论

**定义 7.2.1 (时间复杂度)**
图灵机 $M$ 的时间复杂度是 $T(n) = \max\{t_M(w) \mid |w| = n\}$。

**定义 7.2.2 (空间复杂度)**
图灵机 $M$ 的空间复杂度是 $S(n) = \max\{s_M(w) \mid |w| = n\}$。

### 7.3 算法分析

```haskell
-- 算法复杂度分析
data Complexity = O1 | OLogN | ON | ONLogN | ON2 | O2N

analyzeComplexity :: Algorithm -> Input -> Complexity
analyzeComplexity algorithm input = 
  case algorithm of
    LinearSearch -> ON
    BinarySearch -> OLogN
    QuickSort -> ONLogN
    BubbleSort -> ON2
    Fibonacci -> O2N
```

### 7.4 实际应用

- 编译器设计
- 自然语言处理
- 密码学
- 人工智能

## 8. 交叉引用

### 8.1 相关理论

- [02.2 正则语言](02.2_Regular_Languages.md) - 正则语言详细理论
- [02.3 上下文无关语言](02.3_Context_Free_Languages.md) - 上下文无关语言
- [02.4 上下文相关语言](02.4_Context_Sensitive_Languages.md) - 上下文相关语言
- [01.1 类型理论基础](../01_Foundational_Theory/01.1_Type_Theory_Foundation.md) - 类型理论应用

### 8.2 应用领域

- [07.1 软件工程基础](../07_Software_Engineering/07.1_Software_Engineering_Foundation.md) - 软件工程应用
- [08.1 编程语言基础](../08_Programming_Language_Theory/08.1_Programming_Language_Foundation.md) - 编程语言设计

### 8.3 扩展方向

- [02.5 递归可枚举语言](02.5_Recursively_Enumerable_Languages.md) - 递归可枚举语言
- [02.6 自动机理论](02.6_Automata_Theory.md) - 自动机理论

### 8.4 参考文献

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to automata theory, languages, and computation. Pearson Education.
2. Sipser, M. (2012). Introduction to the theory of computation. Cengage Learning.
3. Chomsky, N. (1956). Three models for the description of language. IRE Transactions on information theory, 2(3), 113-124.
4. Kleene, S. C. (1956). Representation of events in nerve nets and finite automata. Automata studies, 34, 3-41.
5. Rabin, M. O., & Scott, D. (1959). Finite automata and their decision problems. IBM journal of research and development, 3(2), 114-125.
6. Myhill, J. (1957). Finite automata and the representation of events. WADD TR-57-624, 112-137.
7. Nerode, A. (1958). Linear automaton transformations. Proceedings of the American Mathematical Society, 9(4), 541-544. 