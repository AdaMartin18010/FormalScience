# 02.1 形式语言基础

## 目录

```markdown
02.1 形式语言基础
├── 1. 引言
│   ├── 1.1 形式语言概述
│   ├── 1.2 历史发展
│   ├── 1.3 基本概念
│   └── 1.4 应用领域
├── 2. 数学基础
│   ├── 2.1 集合论基础
│   ├── 2.2 字符串理论
│   ├── 2.3 语言定义
│   └── 2.4 操作定义
├── 3. 语言层次结构
│   ├── 3.1 Chomsky层次
│   ├── 3.2 正则语言
│   ├── 3.3 上下文无关语言
│   └── 3.4 上下文相关语言
├── 4. 自动机理论
│   ├── 4.1 有限自动机
│   ├── 4.2 下推自动机
│   ├── 4.3 图灵机
│   └── 4.4 计算模型
├── 5. 实现示例
│   ├── 5.1 Rust实现
│   ├── 5.2 Haskell实现
│   └── 5.3 形式化验证
├── 6. 应用与扩展
│   ├── 6.1 编译器设计
│   ├── 6.2 自然语言处理
│   ├── 6.3 模式匹配
│   └── 6.4 协议验证
└── 7. 参考文献
```

## 1. 引言

### 1.1 形式语言概述

形式语言理论是计算机科学和数学的重要分支，研究语言的数学性质和计算模型。它为编译器设计、自然语言处理和计算理论提供了理论基础。

**定义 1.1.1** (形式语言)
形式语言是字母表上字符串的集合，通常通过语法规则或自动机来定义。

### 1.2 历史发展

形式语言理论的发展历程：

1. **Chomsky层次** (1956)
2. **有限自动机** (1950s)
3. **上下文无关文法** (1960s)
4. **计算复杂性理论** (1970s)

### 1.3 基本概念

**定义 1.3.1** (字母表)
字母表是有限符号的集合，记为 $\Sigma$

**定义 1.3.2** (字符串)
字符串是字母表上符号的有限序列，空字符串记为 $\varepsilon$

**定义 1.3.3** (语言)
语言是字母表上字符串的集合，即 $L \subseteq \Sigma^*$

### 1.4 应用领域

- 编译器设计
- 自然语言处理
- 模式匹配
- 协议验证
- 生物信息学

## 2. 数学基础

### 2.1 集合论基础

**定义 2.1.1** (字符串集合)
给定字母表 $\Sigma$，定义：

- $\Sigma^0 = \{\varepsilon\}$ (空字符串集合)
- $\Sigma^n = \{w_1w_2\cdots w_n \mid w_i \in \Sigma\}$ (长度为n的字符串集合)
- $\Sigma^+ = \bigcup_{n=1}^{\infty} \Sigma^n$ (非空字符串集合)
- $\Sigma^* = \Sigma^0 \cup \Sigma^+$ (所有字符串集合)

**定理 2.1.1** (字符串集合性质)
$\Sigma^*$ 在字符串连接操作下构成幺半群，单位元为 $\varepsilon$

### 2.2 字符串理论

**定义 2.2.1** (字符串操作)
给定字符串 $w = w_1w_2\cdots w_n$：

- **长度**: $|w| = n$
- **反转**: $w^R = w_nw_{n-1}\cdots w_1$
- **前缀**: $u$ 是 $w$ 的前缀，如果存在 $v$ 使得 $w = uv$
- **后缀**: $v$ 是 $w$ 的后缀，如果存在 $u$ 使得 $w = uv$
- **子串**: $u$ 是 $w$ 的子串，如果存在 $v_1, v_2$ 使得 $w = v_1uv_2$

**定义 2.2.2** (字符串连接)
字符串连接操作 $\cdot$ 定义为：
$$u \cdot v = u_1u_2\cdots u_mv_1v_2\cdots v_n$$

### 2.3 语言定义

**定义 2.3.1** (语言操作)
给定语言 $L_1, L_2 \subseteq \Sigma^*$：

- **并集**: $L_1 \cup L_2 = \{w \mid w \in L_1 \text{ 或 } w \in L_2\}$
- **交集**: $L_1 \cap L_2 = \{w \mid w \in L_1 \text{ 且 } w \in L_2\}$
- **连接**: $L_1 \cdot L_2 = \{uv \mid u \in L_1, v \in L_2\}$
- **Kleene星**: $L^* = \bigcup_{n=0}^{\infty} L^n$
- **补集**: $\overline{L} = \Sigma^* \setminus L$

### 2.4 操作定义

**定义 2.4.1** (语言操作性质)
语言操作满足以下性质：

1. **结合律**: $(L_1 \cdot L_2) \cdot L_3 = L_1 \cdot (L_2 \cdot L_3)$
2. **分配律**: $L_1 \cdot (L_2 \cup L_3) = (L_1 \cdot L_2) \cup (L_1 \cdot L_3)$
3. **幂等律**: $L \cup L = L$

## 3. 语言层次结构

### 3.1 Chomsky层次

**定义 3.1.1** (Chomsky层次)
Chomsky层次定义了语言的四个层次：

1. **类型0**: 递归可枚举语言
2. **类型1**: 上下文相关语言
3. **类型2**: 上下文无关语言
4. **类型3**: 正则语言

**定理 3.1.1** (层次包含关系)
正则语言 $\subset$ 上下文无关语言 $\subset$ 上下文相关语言 $\subset$ 递归可枚举语言

### 3.2 正则语言

**定义 3.2.1** (正则语言)
正则语言是可以通过正则表达式定义的语言。

**正则表达式语法**:
$$\begin{align}
R &::= \emptyset \mid \varepsilon \mid a \mid R_1 \cup R_2 \mid R_1 \cdot R_2 \mid R^* \\
\end{align}$$

**示例**:
- $a^*$: 所有由 $a$ 组成的字符串
- $(a \cup b)^*$: 所有由 $a$ 和 $b$ 组成的字符串
- $a^*b^*$: 所有先有 $a$ 后有 $b$ 的字符串

### 3.3 上下文无关语言

**定义 3.3.1** (上下文无关文法)
上下文无关文法是一个四元组 $G = (V, \Sigma, P, S)$，其中：

- $V$ 是非终结符集合
- $\Sigma$ 是终结符集合
- $P$ 是产生式规则集合
- $S$ 是开始符号

**产生式规则形式**:
$$A \rightarrow \alpha$$
其中 $A \in V$，$\alpha \in (V \cup \Sigma)^*$

**示例**:
```
S → aSb | ε
```
这个文法生成语言 $\{a^nb^n \mid n \geq 0\}$

### 3.4 上下文相关语言

**定义 3.4.1** (上下文相关文法)
上下文相关文法的产生式规则形式为：
$$\alpha A \beta \rightarrow \alpha \gamma \beta$$
其中 $A \in V$，$\alpha, \beta, \gamma \in (V \cup \Sigma)^*$，且 $\gamma \neq \varepsilon$

## 4. 自动机理论

### 4.1 有限自动机

**定义 4.1.1** (确定性有限自动机)
确定性有限自动机是一个五元组 $M = (Q, \Sigma, \delta, q_0, F)$，其中：

- $Q$ 是状态集合
- $\Sigma$ 是输入字母表
- $\delta: Q \times \Sigma \rightarrow Q$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $F \subseteq Q$ 是接受状态集合

**定义 4.1.2** (扩展转移函数)
扩展转移函数 $\delta^*: Q \times \Sigma^* \rightarrow Q$ 定义为：
$$\begin{align}
\delta^*(q, \varepsilon) &= q \\
\delta^*(q, wa) &= \delta(\delta^*(q, w), a)
\end{align}$$

**定义 4.1.3** (语言接受)
自动机 $M$ 接受的语言为：
$$L(M) = \{w \in \Sigma^* \mid \delta^*(q_0, w) \in F\}$$

### 4.2 下推自动机

**定义 4.2.1** (下推自动机)
下推自动机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$，其中：

- $Q$ 是状态集合
- $\Sigma$ 是输入字母表
- $\Gamma$ 是栈字母表
- $\delta: Q \times (\Sigma \cup \{\varepsilon\}) \times \Gamma \rightarrow 2^{Q \times \Gamma^*}$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $Z_0 \in \Gamma$ 是初始栈符号
- $F \subseteq Q$ 是接受状态集合

### 4.3 图灵机

**定义 4.3.1** (图灵机)
图灵机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$，其中：

- $Q$ 是状态集合
- $\Sigma$ 是输入字母表
- $\Gamma$ 是磁带字母表
- $\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}$ 是转移函数
- $q_0 \in Q$ 是初始状态
- $B \in \Gamma$ 是空白符号
- $F \subseteq Q$ 是接受状态集合

### 4.4 计算模型

**定理 4.4.1** (Church-Turing论题)
任何可计算的函数都可以由图灵机计算。

## 5. 实现示例

### 5.1 Rust实现

```rust
use std::collections::{HashMap, HashSet};

// 字符串类型
type String = Vec<char>;

// 语言类型
type Language = HashSet<String>;

// 有限自动机
#[derive(Debug, Clone)]
struct DFA {
    states: HashSet<String>,
    alphabet: HashSet<char>,
    transitions: HashMap<(String, char), String>,
    initial_state: String,
    accepting_states: HashSet<String>,
}

impl DFA {
    fn new(initial: String) -> Self {
        DFA {
            states: HashSet::new(),
            alphabet: HashSet::new(),
            transitions: HashMap::new(),
            initial_state: initial.clone(),
            accepting_states: HashSet::new(),
        }
    }
    
    fn add_state(&mut self, state: String) {
        self.states.insert(state);
    }
    
    fn add_transition(&mut self, from: String, symbol: char, to: String) {
        self.transitions.insert((from, symbol), to);
        self.alphabet.insert(symbol);
    }
    
    fn set_accepting(&mut self, state: String) {
        self.accepting_states.insert(state);
    }
    
    fn accepts(&self, input: &str) -> bool {
        let mut current_state = self.initial_state.clone();
        
        for c in input.chars() {
            if let Some(next_state) = self.transitions.get(&(current_state.clone(), c)) {
                current_state = next_state.clone();
            } else {
                return false;
            }
        }
        
        self.accepting_states.contains(&current_state)
    }
}

// 正则表达式
#[derive(Debug, Clone)]
enum Regex {
    Empty,
    Epsilon,
    Char(char),
    Union(Box<Regex>, Box<Regex>),
    Concat(Box<Regex>, Box<Regex>),
    Star(Box<Regex>),
}

impl Regex {
    fn empty() -> Self {
        Regex::Empty
    }
    
    fn epsilon() -> Self {
        Regex::Epsilon
    }
    
    fn char(c: char) -> Self {
        Regex::Char(c)
    }
    
    fn union(r1: Regex, r2: Regex) -> Self {
        Regex::Union(Box::new(r1), Box::new(r2))
    }
    
    fn concat(r1: Regex, r2: Regex) -> Self {
        Regex::Concat(Box::new(r1), Box::new(r2))
    }
    
    fn star(r: Regex) -> Self {
        Regex::Star(Box::new(r))
    }
    
    fn matches(&self, input: &str) -> bool {
        self.matches_helper(input, 0).contains(&input.len())
    }
    
    fn matches_helper(&self, input: &str, start: usize) -> HashSet<usize> {
        match self {
            Regex::Empty => HashSet::new(),
            Regex::Epsilon => {
                let mut result = HashSet::new();
                result.insert(start);
                result
            }
            Regex::Char(c) => {
                let mut result = HashSet::new();
                if start < input.len() && input.chars().nth(start) == Some(*c) {
                    result.insert(start + 1);
                }
                result
            }
            Regex::Union(r1, r2) => {
                let mut result = HashSet::new();
                result.extend(r1.matches_helper(input, start));
                result.extend(r2.matches_helper(input, start));
                result
            }
            Regex::Concat(r1, r2) => {
                let mut result = HashSet::new();
                for pos in r1.matches_helper(input, start) {
                    result.extend(r2.matches_helper(input, pos));
                }
                result
            }
            Regex::Star(r) => {
                let mut result = HashSet::new();
                result.insert(start);
                
                let mut current = r.matches_helper(input, start);
                while !current.is_empty() {
                    let mut next = HashSet::new();
                    for pos in current {
                        if pos > start {
                            result.insert(pos);
                            next.extend(r.matches_helper(input, pos));
                        }
                    }
                    current = next;
                }
                result
            }
        }
    }
}

// 上下文无关文法
#[derive(Debug, Clone)]
struct CFG {
    variables: HashSet<String>,
    terminals: HashSet<char>,
    productions: HashMap<String, Vec<String>>,
    start_symbol: String,
}

impl CFG {
    fn new(start: String) -> Self {
        CFG {
            variables: HashSet::new(),
            terminals: HashSet::new(),
            productions: HashMap::new(),
            start_symbol: start.clone(),
        }
    }
    
    fn add_production(&mut self, variable: String, rhs: String) {
        self.productions.entry(variable.clone()).or_insert_with(Vec::new).push(rhs);
        self.variables.insert(variable);
    }
    
    fn derive(&self, input: &str) -> bool {
        self.derive_helper(&self.start_symbol, input)
    }
    
    fn derive_helper(&self, current: &str, target: &str) -> bool {
        if current == target {
            return true;
        }
        
        // 找到最左边的非终结符
        for (i, c) in current.chars().enumerate() {
            if self.variables.contains(&c.to_string()) {
                // 尝试所有可能的产生式
                if let Some(productions) = self.productions.get(&c.to_string()) {
                    for production in productions {
                        let new_current = format!("{}{}{}", 
                            &current[..i], production, &current[i+1..]);
                        if self.derive_helper(&new_current, target) {
                            return true;
                        }
                    }
                }
                break;
            }
        }
        
        false
    }
}

// 示例：构建识别a^nb^n的DFA
fn build_anbn_dfa() -> DFA {
    let mut dfa = DFA::new("q0".to_string());
    
    dfa.add_state("q0".to_string());
    dfa.add_state("q1".to_string());
    dfa.add_state("q2".to_string());
    dfa.add_state("q3".to_string());
    
    dfa.add_transition("q0".to_string(), 'a', "q1".to_string());
    dfa.add_transition("q1".to_string(), 'a', "q1".to_string());
    dfa.add_transition("q1".to_string(), 'b', "q2".to_string());
    dfa.add_transition("q2".to_string(), 'b', "q2".to_string());
    
    dfa.set_accepting("q0".to_string());
    dfa.set_accepting("q2".to_string());
    
    dfa
}

// 示例：构建a^nb^n的上下文无关文法
fn build_anbn_cfg() -> CFG {
    let mut cfg = CFG::new("S".to_string());
    
    cfg.add_production("S".to_string(), "aSb".to_string());
    cfg.add_production("S".to_string(), "".to_string());
    
    cfg
}

fn main() {
    // 测试DFA
    let dfa = build_anbn_dfa();
    println!("DFA accepts 'aabb': {}", dfa.accepts("aabb"));
    println!("DFA accepts 'ab': {}", dfa.accepts("ab"));
    println!("DFA accepts 'aaabbb': {}", dfa.accepts("aaabbb"));
    
    // 测试正则表达式
    let regex = Regex::concat(
        Regex::star(Regex::char('a')),
        Regex::star(Regex::char('b'))
    );
    println!("Regex matches 'aabb': {}", regex.matches("aabb"));
    println!("Regex matches 'ab': {}", regex.matches("ab"));
    
    // 测试CFG
    let cfg = build_anbn_cfg();
    println!("CFG derives 'aabb': {}", cfg.derive("aabb"));
    println!("CFG derives 'ab': {}", cfg.derive("ab"));
}
```

### 5.2 Haskell实现

```haskell
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Map (Map)
import qualified Data.Map as Map

-- 字符串类型
type String = [Char]

-- 语言类型
type Language = Set String

-- 有限自动机
data DFA = DFA {
    states :: Set String,
    alphabet :: Set Char,
    transitions :: Map (String, Char) String,
    initialState :: String,
    acceptingStates :: Set String
}

-- 构建DFA
buildDFA :: String -> Set String -> Map (String, Char) String -> Set String -> DFA
buildDFA initial states trans accepting = DFA {
    states = states,
    alphabet = Set.fromList [c | (_, c) <- Map.keys trans],
    transitions = trans,
    initialState = initial,
    acceptingStates = accepting
}

-- DFA接受检查
accepts :: DFA -> String -> Bool
accepts dfa input = 
    let finalState = foldl step (initialState dfa) input
    in Set.member finalState (acceptingStates dfa)
  where
    step current c = 
        case Map.lookup (current, c) (transitions dfa) of
            Just next -> next
            Nothing -> current -- 死状态

-- 正则表达式
data Regex = Empty | Epsilon | Char Char | Union Regex Regex | Concat Regex Regex | Star Regex

-- 正则表达式匹配
matches :: Regex -> String -> Bool
matches regex input = 
    let positions = matchesHelper regex input 0
    in Set.member (length input) positions

matchesHelper :: Regex -> String -> Int -> Set Int
matchesHelper Empty _ _ = Set.empty
matchesHelper Epsilon _ start = Set.singleton start
matchesHelper (Char c) input start = 
    if start < length input && input !! start == c 
    then Set.singleton (start + 1)
    else Set.empty
matchesHelper (Union r1 r2) input start = 
    Set.union (matchesHelper r1 input start) (matchesHelper r2 input start)
matchesHelper (Concat r1 r2) input start = 
    let pos1 = matchesHelper r1 input start
        pos2 = Set.unions [matchesHelper r2 input pos | pos <- Set.toList pos1]
    in pos2
matchesHelper (Star r) input start = 
    let initial = Set.singleton start
        iterate pos = 
            let next = Set.unions [matchesHelper r input p | p <- Set.toList pos, p > start]
            in if Set.null next then pos else iterate (Set.union pos next)
    in iterate initial

-- 上下文无关文法
data CFG = CFG {
    variables :: Set String,
    terminals :: Set Char,
    productions :: Map String [String],
    startSymbol :: String
}

-- 构建CFG
buildCFG :: String -> Map String [String] -> CFG
buildCFG start prods = CFG {
    variables = Set.fromList (Map.keys prods),
    terminals = Set.fromList [c | rhs <- concat (Map.elems prods), c <- rhs, isLower c],
    productions = prods,
    startSymbol = start
}

-- CFG推导
derive :: CFG -> String -> Bool
derive cfg input = deriveHelper cfg (startSymbol cfg) input

deriveHelper :: CFG -> String -> String -> Bool
deriveHelper cfg current target = 
    if current == target then True
    else 
        let derivations = [replace current i prod | 
                          (i, c) <- zip [0..] current,
                          isVariable c,
                          prod <- getProductions cfg [c]]
        in any (\new -> deriveHelper cfg new target) derivations
  where
    isVariable c = Set.member [c] (variables cfg)
    getProductions cfg var = 
        case Map.lookup var (productions cfg) of
            Just prods -> prods
            Nothing -> []
    replace str i new = take i str ++ new ++ drop (i + 1) str

-- 示例：构建a^nb^n的DFA
buildAnBnDFA :: DFA
buildAnBnDFA = buildDFA "q0" states transitions accepting
  where
    states = Set.fromList ["q0", "q1", "q2", "q3"]
    transitions = Map.fromList [
        (("q0", 'a'), "q1"),
        (("q1", 'a'), "q1"),
        (("q1", 'b'), "q2"),
        (("q2", 'b'), "q2")
    ]
    accepting = Set.fromList ["q0", "q2"]

-- 示例：构建a^nb^n的CFG
buildAnBnCFG :: CFG
buildAnBnCFG = buildCFG "S" productions
  where
    productions = Map.fromList [
        ("S", ["aSb", ""])
    ]

-- 示例：构建正则表达式
buildAnBnRegex :: Regex
buildAnBnRegex = Concat (Star (Char 'a')) (Star (Char 'b'))

-- 测试函数
testExamples :: IO ()
testExamples = do
    let dfa = buildAnBnDFA
    let cfg = buildAnBnCFG
    let regex = buildAnBnRegex
    
    putStrLn "Testing DFA:"
    putStrLn $ "aabb: " ++ show (accepts dfa "aabb")
    putStrLn $ "ab: " ++ show (accepts dfa "ab")
    putStrLn $ "aaabbb: " ++ show (accepts dfa "aaabbb")
    
    putStrLn "\nTesting Regex:"
    putStrLn $ "aabb: " ++ show (matches regex "aabb")
    putStrLn $ "ab: " ++ show (matches regex "ab")
    
    putStrLn "\nTesting CFG:"
    putStrLn $ "aabb: " ++ show (derive cfg "aabb")
    putStrLn $ "ab: " ++ show (derive cfg "ab")
```

### 5.3 形式化验证

```haskell
-- 形式化验证：DFA正确性
verifyDFA :: DFA -> String -> Bool
verifyDFA dfa input = 
    let finalState = foldl step (initialState dfa) input
        validTransitions = all (\c -> Set.member c (alphabet dfa)) input
        validState = Set.member finalState (states dfa)
    in validTransitions && validState
  where
    step current c = 
        case Map.lookup (current, c) (transitions dfa) of
            Just next -> next
            Nothing -> current

-- 验证正则表达式性质
verifyRegexProperties :: Regex -> Bool
verifyRegexProperties regex = 
    -- 空语言性质
    not (matches regex "") || regex == Epsilon ||
    -- 星号性质
    case regex of
        Star r -> matches (Star r) "" -- 星号总是匹配空字符串
        _ -> True

-- 验证CFG性质
verifyCFGProperties :: CFG -> Bool
verifyCFGProperties cfg = 
    -- 开始符号在变量集合中
    Set.member (startSymbol cfg) (variables cfg) &&
    -- 所有产生式右部只包含变量和终结符
    all (\rhs -> all (\c -> Set.member [c] (variables cfg) || 
                           Set.member c (terminals cfg)) rhs) 
        (concat (Map.elems (productions cfg)))
```

## 6. 应用与扩展

### 6.1 编译器设计

形式语言理论在编译器设计中的应用：

**词法分析器**:
```rust
// 使用正则表达式进行词法分析
enum Token {
    Number(i32),
    Identifier(String),
    Operator(String),
    Keyword(String),
}

fn lex(input: &str) -> Vec<Token> {
    let mut tokens = Vec::new();
    let mut current = String::new();
    
    for c in input.chars() {
        match c {
            '0'..='9' => current.push(c),
            'a'..='z' | 'A'..='Z' => current.push(c),
            _ => {
                if !current.is_empty() {
                    tokens.push(parse_token(&current));
                    current.clear();
                }
            }
        }
    }
    
    tokens
}
```

### 6.2 自然语言处理

形式语言理论在自然语言处理中的应用：

**语法分析**:
```rust
// 上下文无关文法用于自然语言语法分析
struct GrammarRule {
    lhs: String,
    rhs: Vec<String>,
}

fn parse_sentence(grammar: &[GrammarRule], sentence: &str) -> Option<ParseTree> {
    // 使用CYK算法进行语法分析
    // 实现省略...
    None
}
```

### 6.3 模式匹配

形式语言理论在模式匹配中的应用：

**字符串匹配算法**:
```rust
// KMP算法实现
fn kmp_search(pattern: &str, text: &str) -> Vec<usize> {
    let pattern_chars: Vec<char> = pattern.chars().collect();
    let text_chars: Vec<char> = text.chars().collect();
    let lps = compute_lps(&pattern_chars);
    
    let mut result = Vec::new();
    let mut i = 0; // text索引
    let mut j = 0; // pattern索引
    
    while i < text_chars.len() {
        if pattern_chars[j] == text_chars[i] {
            i += 1;
            j += 1;
        }
        
        if j == pattern_chars.len() {
            result.push(i - j);
            j = lps[j - 1];
        } else if i < text_chars.len() && pattern_chars[j] != text_chars[i] {
            if j != 0 {
                j = lps[j - 1];
            } else {
                i += 1;
            }
        }
    }
    
    result
}

fn compute_lps(pattern: &[char]) -> Vec<usize> {
    let mut lps = vec![0; pattern.len()];
    let mut len = 0;
    let mut i = 1;
    
    while i < pattern.len() {
        if pattern[i] == pattern[len] {
            len += 1;
            lps[i] = len;
            i += 1;
        } else {
            if len != 0 {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i += 1;
            }
        }
    }
    
    lps
}
```

### 6.4 协议验证

形式语言理论在协议验证中的应用：

**协议状态机**:
```rust
// 使用有限状态机验证协议
#[derive(Debug, Clone, PartialEq)]
enum ProtocolState {
    Idle,
    Connecting,
    Connected,
    Disconnecting,
}

#[derive(Debug)]
enum ProtocolEvent {
    Connect,
    Disconnect,
    Data,
    Timeout,
}

struct ProtocolFSM {
    current_state: ProtocolState,
    transitions: HashMap<(ProtocolState, ProtocolEvent), ProtocolState>,
}

impl ProtocolFSM {
    fn new() -> Self {
        let mut transitions = HashMap::new();
        transitions.insert((ProtocolState::Idle, ProtocolEvent::Connect), ProtocolState::Connecting);
        transitions.insert((ProtocolState::Connecting, ProtocolEvent::Connect), ProtocolState::Connected);
        transitions.insert((ProtocolState::Connected, ProtocolEvent::Disconnect), ProtocolState::Disconnecting);
        transitions.insert((ProtocolState::Disconnecting, ProtocolEvent::Disconnect), ProtocolState::Idle);
        
        ProtocolFSM {
            current_state: ProtocolState::Idle,
            transitions,
        }
    }
    
    fn transition(&mut self, event: ProtocolEvent) -> bool {
        if let Some(next_state) = self.transitions.get(&(self.current_state.clone(), event)) {
            self.current_state = next_state.clone();
            true
        } else {
            false
        }
    }
}
```

## 7. 参考文献

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation*. Pearson.
2. Sipser, M. (2012). *Introduction to the Theory of Computation*. Cengage Learning.
3. Chomsky, N. (1956). *Three Models for the Description of Language*. IRE Transactions on Information Theory.
4. Kleene, S. C. (1956). *Representation of Events in Nerve Nets and Finite Automata*. Automata Studies.
5. Thompson, K. (1968). *Programming Techniques: Regular Expression Search Algorithm*. Communications of the ACM.

---

**相关文档**:
- [02.2 正则语言](02.2_Regular_Languages.md)
- [02.3 上下文无关语言](02.3_Context_Free_Languages.md)
- [02.4 上下文相关语言](02.4_Context_Sensitive_Languages.md)
- [02.6 自动机理论](02.6_Automata_Theory.md)
