# 02.1 形式语言基础

## 目录

```markdown
02.1 形式语言基础
├── 1. 引言
│   ├── 1.1 形式语言概述
│   ├── 1.2 历史发展
│   ├── 1.3 应用领域
│   └── 1.4 本文结构
├── 2. 基础概念
│   ├── 2.1 字母表与字符串
│   ├── 2.2 语言定义
│   ├── 2.3 语言运算
│   └── 2.4 语言层次
├── 3. 正则语言
│   ├── 3.1 正则表达式
│   ├── 3.2 有限自动机
│   ├── 3.3 正则文法
│   └── 3.4 泵引理
├── 4. 上下文无关语言
│   ├── 4.1 上下文无关文法
│   ├── 4.2 下推自动机
│   ├── 4.3 语法分析
│   └── 4.4 乔姆斯基范式
├── 5. 上下文相关语言
│   ├── 5.1 上下文相关文法
│   ├── 5.2 线性有界自动机
│   ├── 5.3 语法分析
│   └── 5.4 应用实例
├── 6. 递归可枚举语言
│   ├── 6.1 图灵机
│   ├── 6.2 递归可枚举文法
│   ├── 6.3 可计算性
│   └── 6.4 停机问题
├── 7. 形式化证明
│   ├── 7.1 语言等价性定理
│   ├── 7.2 泵引理证明
│   ├── 7.3 不可判定性定理
│   └── 7.4 完备性定理
├── 8. 代码实现
│   ├── 8.1 Haskell 实现
│   ├── 8.2 Rust 实现
│   └── 8.3 示例程序
├── 9. 应用与扩展
│   ├── 9.1 编译器设计
│   ├── 9.2 自然语言处理
│   ├── 9.3 模式匹配
│   └── 9.4 未来方向
└── 10. 参考文献
```

## 1. 引言

### 1.1 形式语言概述

形式语言理论是计算机科学的基础理论之一，研究语言的数学性质和计算模型。它为编译器设计、自然语言处理和模式匹配提供了理论基础。

**定义 1.1.1** (形式语言)
形式语言是字母表上字符串的集合，通常通过文法、自动机或表达式来定义。

**定义 1.1.2** (字母表)
字母表 $\Sigma$ 是一个有限的符号集合。

**定义 1.1.3** (字符串)
字符串是字母表中符号的有限序列。

### 1.2 历史发展

形式语言理论的发展历程：

1. **乔姆斯基层次** (Chomsky, 1956)
2. **正则表达式** (Kleene, 1956)
3. **有限自动机** (Rabin & Scott, 1959)
4. **下推自动机** (Schützenberger, 1963)
5. **图灵机** (Turing, 1936)

### 1.3 应用领域

形式语言理论在以下领域有重要应用：

- **编译器设计**: 词法分析和语法分析
- **自然语言处理**: 语言模型和语法分析
- **模式匹配**: 字符串匹配和搜索
- **数据库查询**: 查询语言和模式匹配

### 1.4 本文结构

本文按照乔姆斯基层次介绍形式语言理论，从简单到复杂，每个概念都包含形式化定义和代码实现。

## 2. 基础概念

### 2.1 字母表与字符串

**定义 2.1.1** (字母表)
字母表 $\Sigma$ 是一个有限的符号集合。

**定义 2.1.2** (字符串)
字符串是字母表中符号的有限序列，空字符串记作 $\varepsilon$。

**定义 2.1.3** (字符串长度)
字符串 $w$ 的长度 $|w|$ 是其中符号的个数。

**定义 2.1.4** (字符串连接)
字符串 $w$ 和 $v$ 的连接记作 $w \cdot v$ 或 $wv$。

### 2.2 语言定义

**定义 2.2.1** (语言)
语言是字母表 $\Sigma$ 上字符串的集合，即 $L \subseteq \Sigma^*$。

**定义 2.2.2** (克林闭包)
$\Sigma^*$ 表示字母表 $\Sigma$ 上所有字符串的集合。

**定义 2.2.3** (正闭包)
$\Sigma^+$ 表示字母表 $\Sigma$ 上所有非空字符串的集合。

### 2.3 语言运算

**定义 2.3.1** (语言并)
$L_1 \cup L_2 = \{w \mid w \in L_1 \text{ 或 } w \in L_2\}$

**定义 2.3.2** (语言交)
$L_1 \cap L_2 = \{w \mid w \in L_1 \text{ 且 } w \in L_2\}$

**定义 2.3.3** (语言连接)
$L_1 \cdot L_2 = \{w_1 w_2 \mid w_1 \in L_1, w_2 \in L_2\}$

**定义 2.3.4** (语言闭包)
$L^* = \bigcup_{i=0}^{\infty} L^i$，其中 $L^0 = \{\varepsilon\}$，$L^{i+1} = L \cdot L^i$

### 2.4 语言层次

**定义 2.4.1** (乔姆斯基层次)
乔姆斯基层次将形式语言分为四个层次：

1. **正则语言** (Type 3): 由正则文法生成
2. **上下文无关语言** (Type 2): 由上下文无关文法生成
3. **上下文相关语言** (Type 1): 由上下文相关文法生成
4. **递归可枚举语言** (Type 0): 由无限制文法生成

## 3. 正则语言

### 3.1 正则表达式

**定义 3.1.1** (正则表达式)
正则表达式是描述正则语言的表达式，定义如下：

- $\emptyset$: 空语言
- $\varepsilon$: 空字符串语言
- $a$: 单个符号语言 $\{a\}$
- $r_1 + r_2$: 并运算
- $r_1 \cdot r_2$: 连接运算
- $r^*$: 克林闭包

**示例 3.1.1** (正则表达式示例)
```haskell
-- 正则表达式数据类型
data Regex = 
    Empty
  | Epsilon
  | Symbol Char
  | Union Regex Regex
  | Concat Regex Regex
  | Star Regex

-- 示例：匹配所有以a开头以b结尾的字符串
example1 = Concat (Symbol 'a') (Concat (Star (Symbol 'c')) (Symbol 'b'))

-- 示例：匹配所有包含偶数个a的字符串
example2 = Star (Concat (Star (Symbol 'b')) (Concat (Symbol 'a') (Concat (Star (Symbol 'b')) (Symbol 'a'))))
```

### 3.2 有限自动机

**定义 3.2.1** (有限自动机)
有限自动机是一个五元组 $M = (Q, \Sigma, \delta, q_0, F)$，其中：

- $Q$: 状态集合
- $\Sigma$: 输入字母表
- $\delta$: 转移函数 $Q \times \Sigma \to Q$
- $q_0$: 初始状态
- $F$: 接受状态集合

**定义 3.2.2** (确定性有限自动机)
确定性有限自动机 (DFA) 的转移函数是确定的。

**定义 3.2.3** (非确定性有限自动机)
非确定性有限自动机 (NFA) 的转移函数可以是非确定的。

**示例 3.2.1** (DFA 实现)
```haskell
-- 有限自动机实现
data DFA = DFA {
  states :: Set Int,
  alphabet :: Set Char,
  transition :: Int -> Char -> Int,
  initialState :: Int,
  acceptStates :: Set Int
}

-- DFA 执行
runDFA :: DFA -> String -> Bool
runDFA dfa input = finalState `Set.member` acceptStates dfa
  where
    finalState = foldl (transition dfa) (initialState dfa) input
```

### 3.3 正则文法

**定义 3.3.1** (正则文法)
正则文法是一个四元组 $G = (V, \Sigma, P, S)$，其中：

- $V$: 非终结符集合
- $\Sigma$: 终结符集合
- $P$: 产生式集合
- $S$: 开始符号

**规则 3.3.1** (右线性文法)
右线性文法的产生式形式为 $A \to aB$ 或 $A \to a$。

**规则 3.3.2** (左线性文法)
左线性文法的产生式形式为 $A \to Ba$ 或 $A \to a$。

### 3.4 泵引理

**定理 3.4.1** (正则语言泵引理)
设 $L$ 是正则语言，则存在常数 $n$，使得对于任意 $w \in L$ 且 $|w| \geq n$，存在分解 $w = xyz$，满足：

1. $|xy| \leq n$
2. $|y| > 0$
3. 对于所有 $i \geq 0$，$xy^i z \in L$

**证明**:
设 $M$ 是接受 $L$ 的 DFA，状态数为 $n$。对于长度至少为 $n$ 的字符串 $w$，根据鸽巢原理，在读取 $w$ 的过程中，某个状态会被访问至少两次。设 $y$ 是导致状态重复的子串，则 $xy^i z$ 对于所有 $i \geq 0$ 都被接受。

## 4. 上下文无关语言

### 4.1 上下文无关文法

**定义 4.1.1** (上下文无关文法)
上下文无关文法是一个四元组 $G = (V, \Sigma, P, S)$，其中产生式形式为 $A \to \alpha$，其中 $A \in V$，$\alpha \in (V \cup \Sigma)^*$。

**示例 4.1.1** (算术表达式文法)
```haskell
-- 算术表达式文法
data CFG = CFG {
  nonterminals :: Set String,
  terminals :: Set Char,
  productions :: [(String, String)],
  startSymbol :: String
}

-- 示例：简单算术表达式文法
arithmeticGrammar = CFG {
  nonterminals = Set.fromList ["E", "T", "F"],
  terminals = Set.fromList ['0'..'9', '+', '*', '(', ')'],
  productions = [
    ("E", "E+T"),
    ("E", "T"),
    ("T", "T*F"),
    ("T", "F"),
    ("F", "(E)"),
    ("F", "0"), ("F", "1"), ("F", "2"), ("F", "3"), ("F", "4"),
    ("F", "5"), ("F", "6"), ("F", "7"), ("F", "8"), ("F", "9")
  ],
  startSymbol = "E"
}
```

### 4.2 下推自动机

**定义 4.2.1** (下推自动机)
下推自动机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$，其中：

- $Q$: 状态集合
- $\Sigma$: 输入字母表
- $\Gamma$: 栈字母表
- $\delta$: 转移函数
- $q_0$: 初始状态
- $Z_0$: 初始栈符号
- $F$: 接受状态集合

**示例 4.2.1** (PDA 实现)
```haskell
-- 下推自动机实现
data PDA = PDA {
  states :: Set Int,
  inputAlphabet :: Set Char,
  stackAlphabet :: Set Char,
  transition :: Int -> Char -> Char -> [(Int, String)],
  initialState :: Int,
  initialStack :: Char,
  acceptStates :: Set Int
}

-- PDA 配置
data PDAConfig = PDAConfig {
  state :: Int,
  input :: String,
  stack :: String
}

-- PDA 执行
runPDA :: PDA -> String -> Bool
runPDA pda input = any (\config -> state config `Set.member` acceptStates pda) 
                    (reachableConfigs pda (PDAConfig (initialState pda) input [initialStack pda]))
```

### 4.3 语法分析

**定义 4.3.1** (语法分析)
语法分析是确定输入字符串是否由给定文法生成的过程。

**算法 4.3.1** (CYK 算法)
CYK 算法用于判断字符串是否属于上下文无关语言。

```haskell
-- CYK 算法实现
cyk :: CFG -> String -> Bool
cyk cfg input = startSymbol cfg `elem` table !! 0 !! (length input - 1)
  where
    n = length input
    table = [[generateCell i j | j <- [0..n-1]] | i <- [0..n-1]]
    
    generateCell i j
      | i == 0 = [a | a <- Set.toList (nonterminals cfg), 
                     any (\(lhs, rhs) -> lhs == a && rhs == [input !! j]) (productions cfg)]
      | otherwise = [a | a <- Set.toList (nonterminals cfg),
                        any (\(lhs, rhs) -> lhs == a && 
                             any (\(k, b, c) -> b `elem` table !! k !! j && 
                                               c `elem` table !! (i-k-1) !! (j+k+1))
                                  [(k, take 1 rhs, drop 1 rhs) | k <- [0..i-1]])
                             (productions cfg)]
```

### 4.4 乔姆斯基范式

**定义 4.4.1** (乔姆斯基范式)
上下文无关文法 $G$ 是乔姆斯基范式，如果所有产生式都是以下形式之一：

1. $A \to BC$，其中 $B, C \in V$
2. $A \to a$，其中 $a \in \Sigma$
3. $S \to \varepsilon$（仅当 $S$ 是开始符号时）

**定理 4.4.1** (乔姆斯基范式定理)
任何上下文无关文法都可以转换为等价的乔姆斯基范式。

## 5. 上下文相关语言

### 5.1 上下文相关文法

**定义 5.1.1** (上下文相关文法)
上下文相关文法的产生式形式为 $\alpha A \beta \to \alpha \gamma \beta$，其中 $A \in V$，$\alpha, \beta, \gamma \in (V \cup \Sigma)^*$，且 $\gamma \neq \varepsilon$。

**示例 5.1.1** (上下文相关文法示例)
```haskell
-- 上下文相关文法：{a^n b^n c^n | n > 0}
csgExample = CSG {
  nonterminals = Set.fromList ["S", "A", "B", "C"],
  terminals = Set.fromList ['a', 'b', 'c'],
  productions = [
    ("S", "aAbc"),
    ("A", "aAbC"),
    ("A", "ab"),
    ("bB", "Bb"),
    ("aB", "ab"),
    ("C", "c")
  ],
  startSymbol = "S"
}
```

### 5.2 线性有界自动机

**定义 5.2.1** (线性有界自动机)
线性有界自动机是一种图灵机，其读写头只能在输入字符串的范围内移动。

**定义 5.2.2** (LBA 配置)
LBA 的配置包括当前状态、读写头位置和磁带内容。

### 5.3 语法分析

**算法 5.3.1** (上下文相关语言语法分析)
上下文相关语言的语法分析比上下文无关语言更复杂，通常需要回溯或约束满足技术。

### 5.4 应用实例

**示例 5.4.1** (自然语言语法)
自然语言的某些语法现象需要上下文相关文法来描述，如一致性和依赖关系。

## 6. 递归可枚举语言

### 6.1 图灵机

**定义 6.1.1** (图灵机)
图灵机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$，其中：

- $Q$: 状态集合
- $\Sigma$: 输入字母表
- $\Gamma$: 磁带字母表
- $\delta$: 转移函数
- $q_0$: 初始状态
- $B$: 空白符号
- $F$: 接受状态集合

**示例 6.1.1** (图灵机实现)
```haskell
-- 图灵机实现
data TuringMachine = TuringMachine {
  states :: Set Int,
  inputAlphabet :: Set Char,
  tapeAlphabet :: Set Char,
  transition :: Int -> Char -> (Int, Char, Direction),
  initialState :: Int,
  blankSymbol :: Char,
  acceptStates :: Set Int
}

data Direction = Left | Right | Stay

-- 图灵机配置
data TMConfig = TMConfig {
  state :: Int,
  tape :: String,
  head :: Int
}

-- 图灵机执行
runTM :: TuringMachine -> String -> Bool
runTM tm input = any (\config -> state config `Set.member` acceptStates tm)
                   (reachableConfigs tm (TMConfig (initialState tm) input 0))
```

### 6.2 递归可枚举文法

**定义 6.2.1** (递归可枚举文法)
递归可枚举文法（无限制文法）的产生式形式为 $\alpha \to \beta$，其中 $\alpha, \beta \in (V \cup \Sigma)^*$，且 $\alpha$ 包含至少一个非终结符。

### 6.3 可计算性

**定义 6.3.1** (可计算性)
一个函数是可计算的，如果存在图灵机计算该函数。

**定义 6.3.2** (递归可枚举)
一个语言是递归可枚举的，如果存在图灵机接受该语言。

**定义 6.3.3** (递归)
一个语言是递归的，如果存在图灵机判定该语言。

### 6.4 停机问题

**定理 6.4.1** (停机问题不可判定)
停机问题是不可判定的，即不存在算法判定任意图灵机在任意输入上是否停机。

**证明**:
假设存在停机问题的判定算法 $H$，构造图灵机 $D$ 使得 $D$ 在输入 $w$ 上的行为与 $H(w, w)$ 相反。考虑 $D$ 在输入 $\langle D \rangle$ 上的行为，导出矛盾。

## 7. 形式化证明

### 7.1 语言等价性定理

**定理 7.1.1** (正则表达式与 DFA 等价)
对于任意正则表达式 $r$，存在 DFA $M$ 使得 $L(r) = L(M)$，反之亦然。

**证明**:
通过构造性证明，将正则表达式转换为 NFA，再将 NFA 转换为 DFA。

### 7.2 泵引理证明

**定理 7.2.1** (上下文无关语言泵引理)
设 $L$ 是上下文无关语言，则存在常数 $n$，使得对于任意 $w \in L$ 且 $|w| \geq n$，存在分解 $w = uvxyz$，满足：

1. $|vxy| \leq n$
2. $|vy| > 0$
3. 对于所有 $i \geq 0$，$uv^i xy^i z \in L$

### 7.3 不可判定性定理

**定理 7.3.1** (波斯特对应问题不可判定)
波斯特对应问题是不可判定的。

**定理 7.3.2** (上下文无关语言交集不可判定)
两个上下文无关语言的交集是否为空是不可判定的。

### 7.4 完备性定理

**定理 7.4.1** (图灵机完备性)
图灵机是计算完备的，即任何可计算函数都可以由图灵机计算。

## 8. 代码实现

### 8.1 Haskell 实现

```haskell
-- 完整的形式语言实现
module FormalLanguages where

import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.Maybe

-- 正则表达式
data Regex = 
    Empty
  | Epsilon
  | Symbol Char
  | Union Regex Regex
  | Concat Regex Regex
  | Star Regex
  deriving (Show, Eq)

-- 正则表达式匹配
matchRegex :: Regex -> String -> Bool
matchRegex Empty _ = False
matchRegex Epsilon "" = True
matchRegex Epsilon _ = False
matchRegex (Symbol c) [x] = c == x
matchRegex (Symbol _) _ = False
matchRegex (Union r1 r2) s = matchRegex r1 s || matchRegex r2 s
matchRegex (Concat r1 r2) s = any (\i -> matchRegex r1 (take i s) && matchRegex r2 (drop i s)) [0..length s]
matchRegex (Star r) "" = True
matchRegex (Star r) s = any (\i -> matchRegex r (take i s) && matchRegex (Star r) (drop i s)) [1..length s]

-- 有限自动机
data DFA = DFA {
  states :: Set Int,
  alphabet :: Set Char,
  transition :: Int -> Char -> Int,
  initialState :: Int,
  acceptStates :: Set Int
}

-- DFA 执行
runDFA :: DFA -> String -> Bool
runDFA dfa input = finalState `Set.member` acceptStates dfa
  where
    finalState = foldl (transition dfa) (initialState dfa) input

-- 上下文无关文法
data CFG = CFG {
  nonterminals :: Set String,
  terminals :: Set Char,
  productions :: [(String, String)],
  startSymbol :: String
}

-- CYK 算法
cyk :: CFG -> String -> Bool
cyk cfg input = startSymbol cfg `elem` table !! 0 !! (length input - 1)
  where
    n = length input
    table = [[generateCell i j | j <- [0..n-1]] | i <- [0..n-1]]
    
    generateCell i j
      | i == 0 = [a | a <- Set.toList (nonterminals cfg), 
                     any (\(lhs, rhs) -> lhs == a && rhs == [input !! j]) (productions cfg)]
      | otherwise = [a | a <- Set.toList (nonterminals cfg),
                        any (\(lhs, rhs) -> lhs == a && 
                             any (\(k, b, c) -> b `elem` table !! k !! j && 
                                               c `elem` table !! (i-k-1) !! (j+k+1))
                                  [(k, take 1 rhs, drop 1 rhs) | k <- [0..i-1]])
                             (productions cfg)]

-- 示例：算术表达式文法
arithmeticGrammar :: CFG
arithmeticGrammar = CFG {
  nonterminals = Set.fromList ["E", "T", "F"],
  terminals = Set.fromList ['0'..'9', '+', '*', '(', ')'],
  productions = [
    ("E", "E+T"),
    ("E", "T"),
    ("T", "T*F"),
    ("T", "F"),
    ("F", "(E)"),
    ("F", "0"), ("F", "1"), ("F", "2"), ("F", "3"), ("F", "4"),
    ("F", "5"), ("F", "6"), ("F", "7"), ("F", "8"), ("F", "9")
  ],
  startSymbol = "E"
}

-- 示例：正则表达式
exampleRegex :: Regex
exampleRegex = Concat (Symbol 'a') (Concat (Star (Symbol 'b')) (Symbol 'c'))

-- 测试函数
testFormalLanguages :: IO ()
testFormalLanguages = do
  putStrLn "Testing Regular Expressions:"
  print $ matchRegex exampleRegex "abbbc"
  print $ matchRegex exampleRegex "ac"
  print $ matchRegex exampleRegex "abbc"
  
  putStrLn "\nTesting Context-Free Grammar:"
  print $ cyk arithmeticGrammar "1+2*3"
  print $ cyk arithmeticGrammar "(1+2)*3"
  print $ cyk arithmeticGrammar "1+2+3"
```

### 8.2 Rust 实现

```rust
// 形式语言实现
use std::collections::{HashMap, HashSet};

// 正则表达式
#[derive(Debug, Clone, PartialEq)]
enum Regex {
    Empty,
    Epsilon,
    Symbol(char),
    Union(Box<Regex>, Box<Regex>),
    Concat(Box<Regex>, Box<Regex>),
    Star(Box<Regex>),
}

impl Regex {
    fn matches(&self, input: &str) -> bool {
        match self {
            Regex::Empty => false,
            Regex::Epsilon => input.is_empty(),
            Regex::Symbol(c) => input.len() == 1 && input.chars().next() == Some(*c),
            Regex::Union(r1, r2) => r1.matches(input) || r2.matches(input),
            Regex::Concat(r1, r2) => {
                for i in 0..=input.len() {
                    if r1.matches(&input[..i]) && r2.matches(&input[i..]) {
                        return true;
                    }
                }
                false
            }
            Regex::Star(r) => {
                if input.is_empty() {
                    return true;
                }
                for i in 1..=input.len() {
                    if r.matches(&input[..i]) && self.matches(&input[i..]) {
                        return true;
                    }
                }
                false
            }
        }
    }
}

// 有限自动机
#[derive(Debug)]
struct DFA {
    states: HashSet<i32>,
    alphabet: HashSet<char>,
    transition: HashMap<(i32, char), i32>,
    initial_state: i32,
    accept_states: HashSet<i32>,
}

impl DFA {
    fn new(initial_state: i32, accept_states: HashSet<i32>) -> Self {
        DFA {
            states: HashSet::new(),
            alphabet: HashSet::new(),
            transition: HashMap::new(),
            initial_state,
            accept_states,
        }
    }

    fn add_transition(&mut self, from: i32, symbol: char, to: i32) {
        self.states.insert(from);
        self.states.insert(to);
        self.alphabet.insert(symbol);
        self.transition.insert((from, symbol), to);
    }

    fn run(&self, input: &str) -> bool {
        let mut current_state = self.initial_state.clone();
        for c in input.chars() {
            if let Some(&next_state) = self.transition.get(&(current_state.clone(), c)) {
                current_state = next_state;
            } else {
                return false;
            }
        }
        self.accept_states.contains(&current_state)
    }
}

// 上下文无关文法
#[derive(Debug)]
struct CFG {
    nonterminals: HashSet<String>,
    terminals: HashSet<char>,
    productions: Vec<(String, String)>,
    start_symbol: String,
}

impl CFG {
    fn new(start_symbol: String) -> Self {
        CFG {
            nonterminals: HashSet::new(),
            terminals: HashSet::new(),
            productions: Vec::new(),
            start_symbol,
        }
    }

    fn add_production(&mut self, lhs: String, rhs: String) {
        self.nonterminals.insert(lhs.clone());
        for c in rhs.chars() {
            if c.is_ascii_lowercase() || c.is_ascii_digit() || c == '+' || c == '*' || c == '(' || c == ')' {
                self.terminals.insert(c);
            } else {
                self.nonterminals.insert(c.to_string());
            }
        }
        self.productions.push((lhs, rhs));
    }

    fn cyk(&self, input: &str) -> bool {
        let n = input.len();
        if n == 0 {
            return self.productions.iter().any(|(lhs, rhs)| {
                lhs == &self.start_symbol && rhs.is_empty()
            });
        }

        let mut table = vec![vec![HashSet::<String>::new(); n]; n];

        // 初始化第一行
        for j in 0..n {
            for (lhs, rhs) in &self.productions {
                if rhs.len() == 1 && rhs.chars().next() == Some(input.chars().nth(j).unwrap()) {
                    table[0][j].insert(lhs.clone());
                }
            }
        }

        // 填充其余行
        for i in 1..n {
            for j in 0..n-i {
                for k in 0..i {
                    for (lhs, rhs) in &self.productions {
                        if rhs.len() == 2 {
                            let b = rhs.chars().nth(0).unwrap().to_string();
                            let c = rhs.chars().nth(1).unwrap().to_string();
                            if table[k][j].contains(&b) && table[i-k-1][j+k+1].contains(&c) {
                                table[i][j].insert(lhs.clone());
                            }
                        }
                    }
                }
            }
        }

        table[n-1][0].contains(&self.start_symbol)
    }
}

// 示例函数
fn create_arithmetic_grammar() -> CFG {
    let mut cfg = CFG::new("E".to_string());
    cfg.add_production("E".to_string(), "E+T".to_string());
    cfg.add_production("E".to_string(), "T".to_string());
    cfg.add_production("T", "T*F".to_string());
    cfg.add_production("T", "F".to_string());
    cfg.add_production("F", "(E)".to_string());
    for c in '0'..='9' {
        cfg.add_production("F", c.to_string());
    }
    cfg
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_regex() {
        let regex = Regex::Concat(
            Box::new(Regex::Symbol('a')),
            Box::new(Regex::Concat(
                Box::new(Regex::Star(Box::new(Regex::Symbol('b')))),
                Box::new(Regex::Symbol('c'))
            ))
        );
        assert!(regex.matches("ac"));
        assert!(regex.matches("abc"));
        assert!(regex.matches("abbbc"));
        assert!(!regex.matches("abb"));
    }

    #[test]
    fn test_dfa() {
        let mut dfa = DFA::new(0, [1].iter().cloned().collect());
        dfa.add_transition(0, 'a', 1);
        dfa.add_transition(1, 'b', 1);
        dfa.add_transition(1, 'c', 2);
        dfa.accept_states.insert(2);
        
        assert!(dfa.run("ac"));
        assert!(dfa.run("abc"));
        assert!(dfa.run("abbbc"));
        assert!(!dfa.run("abb"));
    }

    #[test]
    fn test_cfg() {
        let cfg = create_arithmetic_grammar();
        assert!(cfg.cyk("1"));
        assert!(cfg.cyk("1+2"));
        assert!(cfg.cyk("1*2"));
        assert!(cfg.cyk("(1+2)*3"));
    }
}
```

### 8.3 示例程序

```haskell
-- 高级形式语言示例
module AdvancedFormalLanguageExamples where

-- 词法分析器
data Token = 
    Number Int
  | Plus | Minus | Times | Divide
  | LParen | RParen
  | Identifier String
  deriving (Show, Eq)

-- 词法分析
lexer :: String -> [Token]
lexer [] = []
lexer (c:cs)
  | isSpace c = lexer cs
  | isDigit c = let (num, rest) = span isDigit (c:cs)
                in Number (read num) : lexer rest
  | c == '+' = Plus : lexer cs
  | c == '-' = Minus : lexer cs
  | c == '*' = Times : lexer cs
  | c == '/' = Divide : lexer cs
  | c == '(' = LParen : lexer cs
  | c == ')' = RParen : lexer cs
  | isAlpha c = let (id, rest) = span isAlphaNum (c:cs)
                in Identifier id : lexer rest
  | otherwise = lexer cs

-- 语法分析器
data AST = 
    Num Int
  | BinOp AST String AST
  | Var String
  deriving (Show)

-- 递归下降语法分析
parseExpression :: [Token] -> (AST, [Token])
parseExpression tokens = parseTerm tokens

parseTerm :: [Token] -> (AST, [Token])
parseTerm tokens = 
  let (left, tokens1) = parseFactor tokens
  in parseTerm' left tokens1
  where
    parseTerm' left (Plus:tokens) = 
      let (right, tokens1) = parseFactor tokens
          (rest, tokens2) = parseTerm' (BinOp left "+" right) tokens1
      in (rest, tokens2)
    parseTerm' left (Minus:tokens) = 
      let (right, tokens1) = parseFactor tokens
          (rest, tokens2) = parseTerm' (BinOp left "-" right) tokens1
      in (rest, tokens2)
    parseTerm' left tokens = (left, tokens)

parseFactor :: [Token] -> (AST, [Token])
parseFactor tokens = 
  let (left, tokens1) = parsePrimary tokens
  in parseFactor' left tokens1
  where
    parseFactor' left (Times:tokens) = 
      let (right, tokens1) = parsePrimary tokens
          (rest, tokens2) = parseFactor' (BinOp left "*" right) tokens1
      in (rest, tokens2)
    parseFactor' left (Divide:tokens) = 
      let (right, tokens1) = parsePrimary tokens
          (rest, tokens2) = parseFactor' (BinOp left "/" right) tokens1
      in (rest, tokens2)
    parseFactor' left tokens = (left, tokens)

parsePrimary :: [Token] -> (AST, [Token])
parsePrimary (Number n:tokens) = (Num n, tokens)
parsePrimary (Identifier name:tokens) = (Var name, tokens)
parsePrimary (LParen:tokens) = 
  let (expr, tokens1) = parseExpression tokens
  in case tokens1 of
       RParen:tokens2 -> (expr, tokens2)
       _ -> error "Expected closing parenthesis"
parsePrimary _ = error "Unexpected token"

-- 示例：完整的表达式解析
parseString :: String -> AST
parseString input = 
  let tokens = lexer input
      (ast, []) = parseExpression tokens
  in ast

-- 示例使用
example1 = parseString "1+2*3"
example2 = parseString "(1+2)*3"
example3 = parseString "x+y*z"
```

## 9. 应用与扩展

### 9.1 编译器设计

形式语言理论在编译器设计中的应用：

1. **词法分析**: 使用正则表达式和有限自动机
2. **语法分析**: 使用上下文无关文法和语法分析算法
3. **语义分析**: 使用属性文法
4. **代码生成**: 使用语法指导的翻译

### 9.2 自然语言处理

形式语言理论在自然语言处理中的应用：

1. **句法分析**: 使用上下文无关文法分析句子结构
2. **语言模型**: 使用概率上下文无关文法
3. **机器翻译**: 使用同步上下文无关文法
4. **语音识别**: 使用有限状态转换器

### 9.3 模式匹配

形式语言理论在模式匹配中的应用：

1. **字符串匹配**: 使用正则表达式
2. **文本搜索**: 使用有限自动机
3. **数据验证**: 使用形式文法
4. **生物信息学**: 使用序列模式匹配

### 9.4 未来方向

形式语言理论的未来发展方向：

1. **概率形式语言**: 结合概率论和形式语言理论
2. **量子形式语言**: 支持量子计算的形式语言
3. **分布式形式语言**: 支持分布式系统的形式语言
4. **机器学习形式语言**: 支持机器学习的形式语言

## 10. 参考文献

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation*. Pearson.
2. Sipser, M. (2012). *Introduction to the Theory of Computation*. Cengage Learning.
3. Chomsky, N. (1956). *Three Models for the Description of Language*. IRE Transactions on Information Theory, 2(3), 113-124.
4. Kleene, S. C. (1956). *Representation of Events in Nerve Nets and Finite Automata*. Automata Studies, 3-42.
5. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). *Compilers: Principles, Techniques, and Tools*. Pearson.

---

**相关文档**:
- [02.2 正则语言](02.2_Regular_Languages.md)
- [02.3 上下文无关语言](02.3_Context_Free_Languages.md)
- [02.4 上下文相关语言](02.4_Context_Sensitive_Languages.md)
- [01.1 类型理论基础](../01_Foundational_Theory/01.1_Type_Theory_Foundation.md)
- [06.1 集合论](../06_Mathematical_Foundation/06.1_Set_Theory.md)
