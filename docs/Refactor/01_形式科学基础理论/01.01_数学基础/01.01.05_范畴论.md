# 01.01.05 èŒƒç•´è®º (Category Theory)

## ç›®å½•

1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [å‰ç½®çŸ¥è¯†](#å‰ç½®çŸ¥è¯†)
3. [ç›¸å…³ç†è®º](#ç›¸å…³ç†è®º)
4. [åº”ç”¨é¢†åŸŸ](#åº”ç”¨é¢†åŸŸ)
5. [å“²å­¦åŸºç¡€](#å“²å­¦åŸºç¡€)
6. [åŸºæœ¬æ¦‚å¿µ](#åŸºæœ¬æ¦‚å¿µ)
7. [å‡½å­](#å‡½å­)
8. [è‡ªç„¶å˜æ¢](#è‡ªç„¶å˜æ¢)
9. [æé™ä¸ä½™æé™](#æé™ä¸ä½™æé™)
10. [ä¼´éšå‡½å­](#ä¼´éšå‡½å­)
11. [å¹ºåŠèŒƒç•´](#å¹ºåŠèŒƒç•´)
12. [å½¢å¼åŒ–è¯æ˜](#å½¢å¼åŒ–è¯æ˜)
13. [ä»£ç å®ç°](#ä»£ç å®ç°)
14. [å“²å­¦æ‰¹åˆ¤](#å“²å­¦æ‰¹åˆ¤)
15. [æ€»ç»“](#æ€»ç»“)

## æ¦‚è¿°

èŒƒç•´è®ºæ˜¯ç ”ç©¶æ•°å­¦ç»“æ„ä¹‹é—´å…³ç³»çš„æŠ½è±¡ç†è®ºï¼Œä¸ºç°ä»£æ•°å­¦æä¾›äº†ç»Ÿä¸€çš„è¯­è¨€å’Œæ¡†æ¶ã€‚æœ¬æ–‡æ¡£æ¶µç›–èŒƒç•´ã€å‡½å­ã€è‡ªç„¶å˜æ¢ã€æé™ç­‰æ ¸å¿ƒæ¦‚å¿µï¼ŒåŒ…å«ä¸¥æ ¼çš„å½¢å¼åŒ–å®šä¹‰å’Œå®é™…åº”ç”¨ã€‚

### æ ¸å¿ƒç‰¹å¾
- **å½¢å¼åŒ–ç¨‹åº¦**: é«˜åº¦å½¢å¼åŒ–ï¼ŒåŸºäºå…¬ç†åŒ–å®šä¹‰
- **ç†è®ºæ·±åº¦**: é«˜çº§ï¼Œä¸ºç°ä»£æ•°å­¦æä¾›ç»Ÿä¸€æ¡†æ¶
- **åº”ç”¨å¹¿åº¦**: å¹¿æ³›åº”ç”¨äºä»£æ•°ã€æ‹“æ‰‘ã€é€»è¾‘ã€è®¡ç®—æœºç§‘å­¦
- **å“²å­¦æ„ä¹‰**: æ¶‰åŠæ•°å­¦ç»“æ„çš„æœ¬è´¨å’Œå…³ç³»

## å‰ç½®çŸ¥è¯†

- [é›†åˆè®ºåŸºç¡€](./01.01.01_é›†åˆè®ºåŸºç¡€.md) - é›†åˆè®ºåŸºæœ¬æ¦‚å¿µ
- [ä»£æ•°ç»“æ„](./01.01.03_ä»£æ•°ç»“æ„.md) - ç¾¤ã€ç¯ã€åŸŸç­‰ä»£æ•°ç»“æ„

## ç›¸å…³ç†è®º

- [ç±»å‹ç†è®ºä½“ç³»](./01.03_ç±»å‹ç†è®ºä½“ç³»/01.03.01_åŸºç¡€ç±»å‹ç†è®º.md) - èŒƒç•´è®ºåœ¨ç±»å‹ç†è®ºä¸­çš„åº”ç”¨
- [ä»£æ•°æ‹“æ‰‘](../01.02_è®¡ç®—ç†è®º/01.02.01_è‡ªåŠ¨æœºç†è®º.md) - èŒƒç•´è®ºåœ¨æ‹“æ‰‘å­¦ä¸­çš„åº”ç”¨

## åº”ç”¨é¢†åŸŸ

- [å‡½æ•°å¼ç¼–ç¨‹](../04_ç¼–ç¨‹è¯­è¨€ç†è®º/04.02.01_å‡½æ•°å¼ç¼–ç¨‹ç†è®º.md) - èŒƒç•´è®ºåœ¨ç¼–ç¨‹è¯­è¨€ä¸­çš„åº”ç”¨
- [æ•°æ®åº“ç†è®º](../08_åº”ç”¨é¢†åŸŸç†è®º/08.03_æ•°æ®åº“ç†è®º/08.03.01_å…³ç³»æ•°æ®åº“ç†è®º.md) - èŒƒç•´è®ºåœ¨æ•°æ®åº“ä¸­çš„åº”ç”¨

## å“²å­¦åŸºç¡€

- [ç»“æ„ä¸»ä¹‰](../06_å“²å­¦åŸºç¡€/06.05.01_å­˜åœ¨è®º.md) - èŒƒç•´è®ºçš„å“²å­¦åŸºç¡€
- [æ•°å­¦æœ¬ä½“è®º](../06_å“²å­¦åŸºç¡€/06.01.01_æ•°å­¦æœ¬ä½“è®º.md) - èŒƒç•´è®ºä¸æ•°å­¦æœ¬ä½“è®ºçš„å…³ç³»

## åŸºæœ¬æ¦‚å¿µ

### 1.1 èŒƒç•´çš„å®šä¹‰

**å®šä¹‰ 1.1.1 (èŒƒç•´)**
èŒƒç•´ $\mathcal{C}$ åŒ…å«ï¼š
1. **å¯¹è±¡ç±»**: $\text{Ob}(\mathcal{C})$
2. **æ€å°„é›†**: å¯¹ä»»æ„ $A, B \in \text{Ob}(\mathcal{C})$ï¼Œæ€å°„é›† $\text{Hom}_{\mathcal{C}}(A, B)$
3. **å¤åˆè¿ç®—**: $\circ: \text{Hom}_{\mathcal{C}}(B, C) \times \text{Hom}_{\mathcal{C}}(A, B) \rightarrow \text{Hom}_{\mathcal{C}}(A, C)$
4. **å•ä½æ€å°„**: å¯¹æ¯ä¸ªå¯¹è±¡ $A$ï¼Œå•ä½æ€å°„ $1_A \in \text{Hom}_{\mathcal{C}}(A, A)$

æ»¡è¶³ä»¥ä¸‹å…¬ç†ï¼š
- **ç»“åˆå¾‹**: $(h \circ g) \circ f = h \circ (g \circ f)$
- **å•ä½å¾‹**: $1_B \circ f = f = f \circ 1_A$

**å®šä¹‰ 1.1.2 (åŒæ„)**
æ€å°„ $f: A \rightarrow B$ æ˜¯åŒæ„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨æ€å°„ $g: B \rightarrow A$ ä½¿å¾— $g \circ f = 1_A$ ä¸” $f \circ g = 1_B$ã€‚

**å®šä¹‰ 1.1.3 (å•æ€å°„ä¸æ»¡æ€å°„)**
- **å•æ€å°„**: æ€å°„ $f: A \rightarrow B$ æ˜¯å•æ€å°„ï¼Œå½“ä¸”ä»…å½“å¯¹ä»»æ„æ€å°„ $g, h: C \rightarrow A$ï¼Œ$f \circ g = f \circ h$ è•´å« $g = h$
- **æ»¡æ€å°„**: æ€å°„ $f: A \rightarrow B$ æ˜¯æ»¡æ€å°„ï¼Œå½“ä¸”ä»…å½“å¯¹ä»»æ„æ€å°„ $g, h: B \rightarrow C$ï¼Œ$g \circ f = h \circ f$ è•´å« $g = h$

### 1.2 å¸¸è§èŒƒç•´

**å®šä¹‰ 1.1.4 (SetèŒƒç•´)**
Setæ˜¯é›†åˆå’Œå‡½æ•°æ„æˆçš„èŒƒç•´ã€‚

**å®šä¹‰ 1.1.5 (GrpèŒƒç•´)**
Grpæ˜¯ç¾¤å’Œç¾¤åŒæ€æ„æˆçš„èŒƒç•´ã€‚

**å®šä¹‰ 1.1.6 (TopèŒƒç•´)**
Topæ˜¯æ‹“æ‰‘ç©ºé—´å’Œè¿ç»­æ˜ å°„æ„æˆçš„èŒƒç•´ã€‚

**å®šä¹‰ 1.1.7 (Vect_KèŒƒç•´)**
Vect_Kæ˜¯K-å‘é‡ç©ºé—´å’Œçº¿æ€§æ˜ å°„æ„æˆçš„èŒƒç•´ã€‚

## å‡½å­

### 2.1 åå˜å‡½å­

**å®šä¹‰ 2.1.1 (åå˜å‡½å­)**
ä»èŒƒç•´ $\mathcal{C}$ åˆ°èŒƒç•´ $\mathcal{D}$ çš„åå˜å‡½å­ $F: \mathcal{C} \rightarrow \mathcal{D}$ åŒ…å«ï¼š
1. **å¯¹è±¡æ˜ å°„**: $F: \text{Ob}(\mathcal{C}) \rightarrow \text{Ob}(\mathcal{D})$
2. **æ€å°„æ˜ å°„**: $F: \text{Hom}_{\mathcal{C}}(A, B) \rightarrow \text{Hom}_{\mathcal{D}}(F(A), F(B))$

æ»¡è¶³ï¼š
- $F(1_A) = 1_{F(A)}$
- $F(g \circ f) = F(g) \circ F(f)$

**å®šä¹‰ 2.1.2 (åå˜å‡½å­)**
åå˜å‡½å­ $F: \mathcal{C} \rightarrow \mathcal{D}$ æ»¡è¶³ï¼š
- $F(1_A) = 1_{F(A)}$
- $F(g \circ f) = F(f) \circ F(g)$

### 2.2 å¸¸è§å‡½å­

**å®šä¹‰ 2.1.3 (é—å¿˜å‡½å­)**
é—å¿˜å‡½å­ $U: \text{Grp} \rightarrow \text{Set}$ å°†ç¾¤æ˜ å°„åˆ°å…¶åº•å±‚é›†åˆï¼Œç¾¤åŒæ€æ˜ å°„åˆ°å‡½æ•°ã€‚

**å®šä¹‰ 2.1.4 (è‡ªç”±å‡½å­)**
è‡ªç”±å‡½å­ $F: \text{Set} \rightarrow \text{Grp}$ å°†é›†åˆæ˜ å°„åˆ°å…¶ç”Ÿæˆçš„è‡ªç”±ç¾¤ã€‚

**å®šä¹‰ 2.1.5 (å¹‚é›†å‡½å­)**
å¹‚é›†å‡½å­ $P: \text{Set} \rightarrow \text{Set}$ å°†é›†åˆæ˜ å°„åˆ°å…¶å¹‚é›†ã€‚

## è‡ªç„¶å˜æ¢

### 3.1 è‡ªç„¶å˜æ¢çš„å®šä¹‰

**å®šä¹‰ 3.1.1 (è‡ªç„¶å˜æ¢)**
è®¾ $F, G: \mathcal{C} \rightarrow \mathcal{D}$ æ˜¯å‡½å­ï¼Œè‡ªç„¶å˜æ¢ $\alpha: F \Rightarrow G$ æ˜¯æ€å°„æ— $\{\alpha_A: F(A) \rightarrow G(A)\}_{A \in \text{Ob}(\mathcal{C})}$ï¼Œæ»¡è¶³ï¼š
$$\forall f: A \rightarrow B, G(f) \circ \alpha_A = \alpha_B \circ F(f)$$

**å®šä¹‰ 3.1.2 (è‡ªç„¶åŒæ„)**
å¦‚æœè‡ªç„¶å˜æ¢ $\alpha$ çš„æ¯ä¸ªåˆ†é‡éƒ½æ˜¯åŒæ„ï¼Œåˆ™ç§° $\alpha$ æ˜¯è‡ªç„¶åŒæ„ã€‚

**å®šç† 3.1.1 (è‡ªç„¶å˜æ¢çš„å¤åˆ)**
è®¾ $\alpha: F \Rightarrow G$ å’Œ $\beta: G \Rightarrow H$ æ˜¯è‡ªç„¶å˜æ¢ï¼Œåˆ™ $(\beta \circ \alpha)_A = \beta_A \circ \alpha_A$ ä¹Ÿæ˜¯è‡ªç„¶å˜æ¢ã€‚

## æé™ä¸ä½™æé™

### 4.1 é”¥ä¸ä½™é”¥

**å®šä¹‰ 4.1.1 (é”¥)**
è®¾ $F: \mathcal{J} \rightarrow \mathcal{C}$ æ˜¯å‡½å­ï¼Œ$F$ çš„é”¥æ˜¯å¯¹è±¡ $C$ å’Œæ€å°„æ— $\{\pi_j: C \rightarrow F(j)\}_{j \in \text{Ob}(\mathcal{J})}$ï¼Œæ»¡è¶³ï¼š
$$\forall f: i \rightarrow j, F(f) \circ \pi_i = \pi_j$$

**å®šä¹‰ 4.1.2 (ä½™é”¥)**
$F$ çš„ä½™é”¥æ˜¯å¯¹è±¡ $C$ å’Œæ€å°„æ— $\{\iota_j: F(j) \rightarrow C\}_{j \in \text{Ob}(\mathcal{J})}$ï¼Œæ»¡è¶³ï¼š
$$\forall f: i \rightarrow j, \iota_j \circ F(f) = \iota_i$$

### 4.2 æé™

**å®šä¹‰ 4.1.3 (æé™)**
å‡½å­ $F: \mathcal{J} \rightarrow \mathcal{C}$ çš„æé™æ˜¯æ³›é”¥ $(L, \{\pi_j\})$ï¼Œå³å¯¹ä»»æ„é”¥ $(C, \{\pi_j'\})$ï¼Œå­˜åœ¨å”¯ä¸€æ€å°„ $u: C \rightarrow L$ ä½¿å¾— $\pi_j \circ u = \pi_j'$ã€‚

**å®šä¹‰ 4.1.4 (ä½™æé™)**
å‡½å­ $F: \mathcal{J} \rightarrow \mathcal{C}$ çš„ä½™æé™æ˜¯æ³›ä½™é”¥ $(L, \{\iota_j\})$ï¼Œå³å¯¹ä»»æ„ä½™é”¥ $(C, \{\iota_j'\})$ï¼Œå­˜åœ¨å”¯ä¸€æ€å°„ $u: L \rightarrow C$ ä½¿å¾— $u \circ \iota_j = \iota_j'$ã€‚

### 4.3 ç‰¹æ®Šæé™

**å®šä¹‰ 4.1.5 (ç§¯ä¸ä½™ç§¯)**
- **ç§¯**: ç¦»æ•£èŒƒç•´ä¸Šçš„æé™
- **ä½™ç§¯**: ç¦»æ•£èŒƒç•´ä¸Šçš„ä½™æé™

**å®šä¹‰ 4.1.6 (ç­‰åŒ–å­ä¸ä½™ç­‰åŒ–å­)**
- **ç­‰åŒ–å­**: å¹³è¡Œæ€å°„å¯¹çš„æé™
- **ä½™ç­‰åŒ–å­**: å¹³è¡Œæ€å°„å¯¹çš„ä½™æé™

**å®šä¹‰ 4.1.7 (æ‹‰å›ä¸æ¨å‡º)**
- **æ‹‰å›**: è§’å½¢å›¾çš„æé™
- **æ¨å‡º**: è§’å½¢å›¾çš„ä½™æé™

## ä¼´éšå‡½å­

### 5.1 ä¼´éšçš„å®šä¹‰

**å®šä¹‰ 5.1.1 (ä¼´éšå‡½å­)**
å‡½å­ $F: \mathcal{C} \rightarrow \mathcal{D}$ å’Œ $G: \mathcal{D} \rightarrow \mathcal{C}$ æ„æˆä¼´éšå¯¹ï¼Œè®°ä½œ $F \dashv G$ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨è‡ªç„¶åŒæ„ï¼š
$$\text{Hom}_{\mathcal{D}}(F(A), B) \cong \text{Hom}_{\mathcal{C}}(A, G(B))$$

**å®šç† 5.1.1 (ä¼´éšçš„ç­‰ä»·æ¡ä»¶)**
$F \dashv G$ å½“ä¸”ä»…å½“å­˜åœ¨è‡ªç„¶å˜æ¢ï¼š
- **å•ä½**: $\eta: 1_{\mathcal{C}} \Rightarrow G \circ F$
- **ä½™å•ä½**: $\varepsilon: F \circ G \Rightarrow 1_{\mathcal{D}}$

æ»¡è¶³ä¸‰è§’æ’ç­‰å¼ï¼š
- $(G \varepsilon) \circ (\eta G) = 1_G$
- $(\varepsilon F) \circ (F \eta) = 1_F$

### 5.2 å¸¸è§ä¼´éš

**å®šç† 5.1.2 (è‡ªç”±-é—å¿˜ä¼´éš)**
è‡ªç”±å‡½å­ $F: \text{Set} \rightarrow \text{Grp}$ å’Œé—å¿˜å‡½å­ $U: \text{Grp} \rightarrow \text{Set}$ æ„æˆä¼´éšå¯¹ $F \dashv U$ã€‚

## å¹ºåŠèŒƒç•´

### 6.1 å¹ºåŠèŒƒç•´çš„å®šä¹‰

**å®šä¹‰ 6.1.1 (å¹ºåŠèŒƒç•´)**
å¹ºåŠèŒƒç•´æ˜¯äº”å…ƒç»„ $(\mathcal{C}, \otimes, I, \alpha, \lambda, \rho)$ï¼Œå…¶ä¸­ï¼š
- $\mathcal{C}$ æ˜¯èŒƒç•´
- $\otimes: \mathcal{C} \times \mathcal{C} \rightarrow \mathcal{C}$ æ˜¯åŒå‡½å­
- $I$ æ˜¯å•ä½å¯¹è±¡
- $\alpha, \lambda, \rho$ æ˜¯è‡ªç„¶åŒæ„ï¼ˆç»“åˆå¾‹ã€å·¦å•ä½å¾‹ã€å³å•ä½å¾‹ï¼‰

**å®šä¹‰ 6.1.2 (å¯¹ç§°å¹ºåŠèŒƒç•´)**
å¦‚æœå¹ºåŠèŒƒç•´è¿˜æ»¡è¶³å¯¹ç§°æ€§ï¼Œåˆ™ç§°å…¶ä¸ºå¯¹ç§°å¹ºåŠèŒƒç•´ã€‚

### 6.2 å¸¸è§å¹ºåŠèŒƒç•´

**å®šä¹‰ 6.1.3 (Setçš„å¹ºåŠç»“æ„)**
Setä¸Šçš„ç¬›å¡å°”ç§¯ $\times$ å’Œå•ç‚¹é›† $\{*\}$ æ„æˆå¹ºåŠç»“æ„ã€‚

**å®šä¹‰ 6.1.4 (Vectçš„å¹ºåŠç»“æ„)**
Vectä¸Šçš„å¼ é‡ç§¯ $\otimes$ å’ŒåŸºåŸŸ $K$ æ„æˆå¹ºåŠç»“æ„ã€‚

## å½¢å¼åŒ–è¯æ˜

### 7.1 åœ¨Coqä¸­çš„å½¢å¼åŒ–

```coq
(* èŒƒç•´è®ºåœ¨Coqä¸­çš„å½¢å¼åŒ– *)
Require Import Coq.Classes.Morphisms.
Require Import Coq.Classes.RelationClasses.

(* èŒƒç•´çš„å®šä¹‰ *)
Class Category (obj : Type) (hom : obj -> obj -> Type) := {
  compose : forall {A B C : obj}, hom B C -> hom A B -> hom A C;
  identity : forall A : obj, hom A A;
  compose_assoc : forall {A B C D : obj} (f : hom C D) (g : hom B C) (h : hom A B),
    compose f (compose g h) = compose (compose f g) h;
  compose_id_left : forall {A B : obj} (f : hom A B),
    compose (identity B) f = f;
  compose_id_right : forall {A B : obj} (f : hom A B),
    compose f (identity A) = f
}.

(* å‡½å­çš„å®šä¹‰ *)
Class Functor {C D : Type} {homC : C -> C -> Type} {homD : D -> D -> Type}
  {catC : Category C homC} {catD : Category D homD}
  (F : C -> D) := {
  fmap : forall {A B : C}, homC A B -> homD (F A) (F B);
  fmap_id : forall A : C, fmap (identity A) = identity (F A);
  fmap_comp : forall {A B C : C} (f : homC B C) (g : homC A B),
    fmap (compose f g) = compose (fmap f) (fmap g)
}.

(* è‡ªç„¶å˜æ¢çš„å®šä¹‰ *)
Class NaturalTransformation {C D : Type} {homC : C -> C -> Type} {homD : D -> D -> Type}
  {catC : Category C homC} {catD : Category D homD}
  {F G : C -> D} {funF : Functor F} {funG : Functor G}
  (alpha : forall A : C, homD (F A) (G A)) := {
  naturality : forall {A B : C} (f : homC A B),
    compose (fmap f) (alpha A) = compose (alpha B) (fmap f)
}.

(* æé™çš„å®šä¹‰ *)
Class Limit {J C : Type} {homJ : J -> J -> Type} {homC : C -> C -> Type}
  {catJ : Category J homJ} {catC : Category C homC}
  (F : J -> C) (L : C) (pi : forall j : J, homC L (F j)) := {
  limit_universal : forall (X : C) (f : forall j : J, homC X (F j)),
    (forall {i j : J} (g : homJ i j), compose (fmap g) (f i) = f j) ->
    exists! u : homC X L, forall j : J, compose (pi j) u = f j
}.
```

### 7.2 åœ¨Leanä¸­çš„å½¢å¼åŒ–

```lean
-- èŒƒç•´è®ºåœ¨Leanä¸­çš„å½¢å¼åŒ–
import category_theory.category
import category_theory.functor
import category_theory.natural_transformation

-- èŒƒç•´çš„åŸºæœ¬å®šä¹‰
class category (obj : Type*) (hom : obj â†’ obj â†’ Type*) :=
(comp : Î  {A B C : obj}, hom B C â†’ hom A B â†’ hom A C)
(id : Î  A : obj, hom A A)
(assoc : Î  {A B C D : obj} (f : hom C D) (g : hom B C) (h : hom A B),
  comp f (comp g h) = comp (comp f g) h)
(id_comp : Î  {A B : obj} (f : hom A B), comp (id B) f = f)
(comp_id : Î  {A B : obj} (f : hom A B), comp f (id A) = f)

-- å‡½å­çš„å®šä¹‰
class functor {C D : Type*} [category C] [category D] (F : C â†’ D) :=
(map : Î  {A B : C}, hom A B â†’ hom (F A) (F B))
(map_id : Î  A : C, map (ğŸ™ A) = ğŸ™ (F A))
(map_comp : Î  {A B C : C} (f : hom B C) (g : hom A B),
  map (f â‰« g) = map f â‰« map g)

-- è‡ªç„¶å˜æ¢çš„å®šä¹‰
class natural_transformation {C D : Type*} [category C] [category D]
  {F G : C â†’ D} [functor F] [functor G] (Î± : Î  A : C, hom (F A) (G A)) :=
(naturality : Î  {A B : C} (f : hom A B), map f â‰« Î± A = Î± B â‰« map f)

-- æé™çš„å®šä¹‰
class limit {J C : Type*} [category J] [category C] (F : J â†’ C) (L : C)
  (Ï€ : Î  j : J, hom L (F j)) :=
(universal : Î  (X : C) (f : Î  j : J, hom X (F j)),
  (âˆ€ {i j : J} (g : hom i j), map g â‰« f i = f j) â†’
  âˆƒ! u : hom X L, âˆ€ j : J, Ï€ j â‰« u = f j)

-- ä¼´éšå‡½å­çš„å®šä¹‰
class adjunction {C D : Type*} [category C] [category D]
  (F : C â†’ D) (G : D â†’ C) [functor F] [functor G] :=
(unit : natural_transformation (ğŸ­ C) (G â‹™ F))
(counit : natural_transformation (F â‹™ G) (ğŸ­ D))
(triangle_left : âˆ€ A : C, counit.app (F A) â‰« map (unit.app A) = ğŸ™ (F A))
(triangle_right : âˆ€ B : D, map (counit.app B) â‰« unit.app (G B) = ğŸ™ (G B))
```

## ä»£ç å®ç°

### 8.1 Rustå®ç°

```rust
// èŒƒç•´è®ºåœ¨Rustä¸­çš„å®ç°
use std::collections::HashMap;
use std::fmt;

// èŒƒç•´
pub struct Category<Obj, Hom> {
    objects: Vec<Obj>,
    hom_sets: HashMap<(Obj, Obj), Vec<Hom>>,
    compose: Box<dyn Fn(&Hom, &Hom) -> Option<Hom>>,
    identity: Box<dyn Fn(&Obj) -> Hom>,
}

impl<Obj: Clone + Eq + fmt::Debug, Hom: Clone + fmt::Debug> Category<Obj, Hom> {
    pub fn new<F, G>(objects: Vec<Obj>, compose: F, identity: G) -> Self 
    where 
        F: Fn(&Hom, &Hom) -> Option<Hom> + 'static,
        G: Fn(&Obj) -> Hom + 'static 
    {
        Category {
            objects,
            hom_sets: HashMap::new(),
            compose: Box::new(compose),
            identity: Box::new(identity),
        }
    }
    
    pub fn add_morphism(&mut self, source: Obj, target: Obj, morphism: Hom) {
        let key = (source, target);
        self.hom_sets.entry(key).or_insert_with(Vec::new).push(morphism);
    }
    
    pub fn compose(&self, f: &Hom, g: &Hom) -> Option<Hom> {
        (self.compose)(f, g)
    }
    
    pub fn identity(&self, obj: &Obj) -> Hom {
        (self.identity)(obj)
    }
}

// å‡½å­
pub struct Functor<C, D, F> {
    object_map: Box<dyn Fn(&C) -> D>,
    morphism_map: Box<dyn Fn(&C) -> D>,
}

impl<C, D, F> Functor<C, D, F> {
    pub fn new<G, H>(obj_map: G, morph_map: H) -> Self 
    where 
        G: Fn(&C) -> D + 'static,
        H: Fn(&C) -> D + 'static 
    {
        Functor {
            object_map: Box::new(obj_map),
            morphism_map: Box::new(morph_map),
        }
    }
    
    pub fn map_object(&self, obj: &C) -> D {
        (self.object_map)(obj)
    }
    
    pub fn map_morphism(&self, morph: &C) -> D {
        (self.morphism_map)(morph)
    }
}

// SetèŒƒç•´
pub struct SetCategory;

impl SetCategory {
    pub fn new() -> Category<String, Box<dyn Fn(&String) -> String>> {
        let objects = vec!["A".to_string(), "B".to_string(), "C".to_string()];
        
        Category::new(
            objects,
            |f, g| {
                // å‡½æ•°å¤åˆ
                Some(Box::new(move |x| f(&g(x))))
            },
            |obj| {
                // æ’ç­‰å‡½æ•°
                let obj = obj.clone();
                Box::new(move |x| x.clone())
            }
        )
    }
}

// é—å¿˜å‡½å­
pub struct ForgetfulFunctor;

impl ForgetfulFunctor {
    pub fn new() -> Functor<String, String, Box<dyn Fn(&String) -> String>> {
        Functor::new(
            |obj| obj.clone(),  // å¯¹è±¡æ˜ å°„
            |morph| morph.clone()  // æ€å°„æ˜ å°„
        )
    }
}

// è‡ªç„¶å˜æ¢
pub struct NaturalTransformation<C, D> {
    components: HashMap<C, D>,
}

impl<C: Clone + Eq, D: Clone> NaturalTransformation<C, D> {
    pub fn new() -> Self {
        NaturalTransformation {
            components: HashMap::new(),
        }
    }
    
    pub fn add_component(&mut self, obj: C, morphism: D) {
        self.components.insert(obj, morphism);
    }
    
    pub fn get_component(&self, obj: &C) -> Option<&D> {
        self.components.get(obj)
    }
}

// æé™
pub struct Limit<Obj, Hom> {
    limit_object: Obj,
    projections: HashMap<Obj, Hom>,
}

impl<Obj: Clone + Eq, Hom: Clone> Limit<Obj, Hom> {
    pub fn new(limit_obj: Obj) -> Self {
        Limit {
            limit_object: limit_obj,
            projections: HashMap::new(),
        }
    }
    
    pub fn add_projection(&mut self, target: Obj, projection: Hom) {
        self.projections.insert(target, projection);
    }
}

// æµ‹è¯•
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_category() {
        let mut category = SetCategory::new();
        
        // æ·»åŠ æ€å°„
        let f = Box::new(|x: &String| format!("f({})", x));
        let g = Box::new(|x: &String| format!("g({})", x));
        
        category.add_morphism("A".to_string(), "B".to_string(), f);
        category.add_morphism("B".to_string(), "C".to_string(), g);
        
        // æµ‹è¯•æ’ç­‰æ€å°„
        let id = category.identity(&"A".to_string());
        assert_eq!(id(&"test".to_string()), "test".to_string());
    }

    #[test]
    fn test_functor() {
        let functor = ForgetfulFunctor::new();
        
        let result = functor.map_object(&"A".to_string());
        assert_eq!(result, "A".to_string());
    }

    #[test]
    fn test_natural_transformation() {
        let mut nat_trans = NaturalTransformation::new();
        
        nat_trans.add_component("A".to_string(), "f_A".to_string());
        nat_trans.add_component("B".to_string(), "f_B".to_string());
        
        assert_eq!(nat_trans.get_component(&"A".to_string()), Some(&"f_A".to_string()));
    }
}
```

### 8.2 Haskellå®ç°

```haskell
-- èŒƒç•´è®ºåœ¨Haskellä¸­çš„å®ç°
module CategoryTheory where

import Data.Map (Map)
import qualified Data.Map as Map
import Control.Monad

-- èŒƒç•´ç±»å‹ç±»
class Category obj hom where
    id :: obj -> hom
    compose :: hom -> hom -> Maybe hom
    source :: hom -> obj
    target :: hom -> obj

-- å‡½å­ç±»å‹ç±»
class (Category c homC, Category d homD) => Functor f c d homC homD where
    fmap :: homC -> homD
    fmapObj :: c -> d

-- è‡ªç„¶å˜æ¢
data NaturalTransformation f g c d homC homD = NaturalTransformation {
    components :: Map c (homD (f c) (g c))
}

-- SetèŒƒç•´å®ä¾‹
data SetObj = SetObj String
    deriving (Eq, Ord, Show)

data SetHom = SetHom {
    setSource :: SetObj,
    setTarget :: SetObj,
    setFunction :: String -> String
}

instance Category SetObj SetHom where
    id obj = SetHom obj obj id
    compose f g = 
        if setTarget g == setSource f
        then Just $ SetHom (setSource g) (setTarget f) 
                           (setFunction f . setFunction g)
        else Nothing
    source = setSource
    target = setTarget

-- é—å¿˜å‡½å­
data ForgetfulFunctor = ForgetfulFunctor

instance Functor ForgetfulFunctor SetObj SetObj SetHom SetHom where
    fmap = id
    fmapObj = id

-- è‡ªç”±å‡½å­
data FreeFunctor = FreeFunctor

instance Functor FreeFunctor SetObj SetObj SetHom SetHom where
    fmap = id
    fmapObj = id

-- ä¼´éšå‡½å­
class (Functor f c d homC homD, Functor g d c homD homC) => 
      Adjunction f g c d homC homD where
    unit :: c -> homC c (g (f c))
    counit :: d -> homD (f (g d)) d

-- æé™
data Limit diagram limit = Limit {
    limitObject :: limit,
    projections :: Map String (String -> String)
}

-- ç§¯
data Product a b = Product {
    productA :: a,
    productB :: b
}

-- ä½™ç§¯
data Coproduct a b = Left a | Right b

-- ç­‰åŒ–å­
data Equalizer f g = Equalizer {
    equalizerObject :: String,
    equalizerMorphism :: String -> String
}

-- å¹ºåŠèŒƒç•´
class Category obj hom => MonoidalCategory obj hom where
    tensor :: obj -> obj -> obj
    unit :: obj
    associator :: obj -> obj -> obj -> hom (tensor (tensor a b) c) (tensor a (tensor b c))
    leftUnitor :: obj -> hom (tensor unit a) a
    rightUnitor :: obj -> hom (tensor a unit) a

-- Setçš„å¹ºåŠç»“æ„
instance MonoidalCategory SetObj SetHom where
    tensor (SetObj a) (SetObj b) = SetObj (a ++ "Ã—" ++ b)
    unit = SetObj "1"
    associator a b c = SetHom (tensor (tensor a b) c) (tensor a (tensor b c)) id
    leftUnitor a = SetHom (tensor unit a) a id
    rightUnitor a = SetHom (tensor a unit) a id

-- è‡ªç„¶å˜æ¢çš„ç»„åˆ
composeNaturalTransformation :: NaturalTransformation f g c d homC homD ->
                               NaturalTransformation g h c d homC homD ->
                               NaturalTransformation f h c d homC homD
composeNaturalTransformation alpha beta = 
    NaturalTransformation $ Map.union (components alpha) (components beta)

-- æµ‹è¯•å‡½æ•°
testCategoryTheory :: IO ()
testCategoryTheory = do
    putStrLn "èŒƒç•´è®ºæµ‹è¯•:"
    
    -- æµ‹è¯•SetèŒƒç•´
    let objA = SetObj "A"
        objB = SetObj "B"
        homF = SetHom objA objB (\x -> "f(" ++ x ++ ")")
        homG = SetHom objB objA (\x -> "g(" ++ x ++ ")")
    
    putStrLn $ "å¯¹è±¡A: " ++ show objA
    putStrLn $ "å¯¹è±¡B: " ++ show objB
    putStrLn $ "æ€å°„f: " ++ show homF
    putStrLn $ "æ€å°„g: " ++ show homG
    
    -- æµ‹è¯•å¤åˆ
    case compose homF homG of
        Just composed -> putStrLn $ "å¤åˆç»“æœ: " ++ show composed
        Nothing -> putStrLn "æ— æ³•å¤åˆ"
    
    -- æµ‹è¯•æ’ç­‰æ€å°„
    let idA = id objA
    putStrLn $ "æ’ç­‰æ€å°„: " ++ show idA
    
    -- æµ‹è¯•å¹ºåŠç»“æ„
    let tensorAB = tensor objA objB
    putStrLn $ "å¼ é‡ç§¯: " ++ show tensorAB
    
    putStrLn "æµ‹è¯•å®Œæˆ"

-- å…·ä½“åº”ç”¨ï¼šå‡½æ•°å¼ç¼–ç¨‹ä¸­çš„èŒƒç•´
-- Maybeå‡½å­
data Maybe a = Nothing | Just a
    deriving (Show, Eq)

instance Functor Maybe where
    fmap f Nothing = Nothing
    fmap f (Just x) = Just (f x)

-- Listå‡½å­
instance Functor [] where
    fmap = map

-- Readerå‡½å­
newtype Reader r a = Reader { runReader :: r -> a }

instance Functor (Reader r) where
    fmap f (Reader g) = Reader (f . g)

-- Writerå‡½å­
newtype Writer w a = Writer { runWriter :: (a, w) }

instance Functor (Writer w) where
    fmap f (Writer (a, w)) = Writer (f a, w)

-- Stateå‡½å­
newtype State s a = State { runState :: s -> (a, s) }

instance Functor (State s) where
    fmap f (State g) = State (\s -> let (a, s') = g s in (f a, s'))
```

## å“²å­¦æ‰¹åˆ¤

### 9.1 èŒƒç•´è®ºçš„æœ¬ä½“è®ºé—®é¢˜

èŒƒç•´è®ºé¢ä¸´å‡ ä¸ªé‡è¦çš„å“²å­¦é—®é¢˜ï¼š

1. **æŠ½è±¡ç»“æ„çš„å®åœ¨æ€§**: èŒƒç•´æ˜¯å®¢è§‚å­˜åœ¨çš„æ•°å­¦å¯¹è±¡ï¼Œè¿˜æ˜¯äººç±»æ€ç»´çš„æ„é€ ï¼Ÿ
2. **å…³ç³»çš„ä¼˜å…ˆæ€§**: èŒƒç•´è®ºå¼ºè°ƒå…³ç³»è€Œéå¯¹è±¡ï¼Œè¿™æ˜¯å¦åæ˜ äº†ä¸–ç•Œçš„æœ¬è´¨ï¼Ÿ
3. **ç»Ÿä¸€æ€§çš„æ„ä¹‰**: èŒƒç•´è®ºèƒ½å¦çœŸæ­£ç»Ÿä¸€æ‰€æœ‰æ•°å­¦åˆ†æ”¯ï¼Ÿ

### 9.2 ç»“æ„ä¸»ä¹‰ä¸æŸæ‹‰å›¾ä¸»ä¹‰

**ç»“æ„ä¸»ä¹‰è§‚ç‚¹**: èŒƒç•´è®ºæ­ç¤ºäº†æ•°å­¦ç»“æ„çš„æ·±å±‚å…³ç³»ã€‚
**æŸæ‹‰å›¾ä¸»ä¹‰è§‚ç‚¹**: èŒƒç•´è®ºå‘ç°äº†å®¢è§‚å­˜åœ¨çš„æŠ½è±¡ç»“æ„ã€‚

### 9.3 åº”ç”¨ä¸çº¯ç²¹

èŒƒç•´è®ºæ—¢æœ‰çº¯ç²¹çš„ç†è®ºä»·å€¼ï¼Œä¹Ÿæœ‰å¹¿æ³›çš„åº”ç”¨ä»·å€¼ï¼Œè¿™ç§åŒé‡æ€§è´¨å¼•å‘äº†å…³äºæ•°å­¦æœ¬è´¨çš„è®¨è®ºã€‚

## æ€»ç»“

èŒƒç•´è®ºä¸ºç°ä»£æ•°å­¦æä¾›äº†å¼ºå¤§çš„æŠ½è±¡å·¥å…·ï¼Œå…¶ä¸¥æ ¼çš„å½¢å¼åŒ–å®šä¹‰å’Œä¸°å¯Œçš„ç†è®ºç»“æ„ä½¿å…¶æˆä¸ºæ•°å­¦ç ”ç©¶çš„æ ¸å¿ƒé¢†åŸŸã€‚

### ä¸»è¦æˆå°±
1. **æŠ½è±¡æ€§**: æä¾›äº†é«˜åº¦æŠ½è±¡çš„æ•°å­¦æ¡†æ¶
2. **ç»Ÿä¸€æ€§**: ç»Ÿä¸€äº†ä¸åŒæ•°å­¦åˆ†æ”¯çš„å…±åŒç‰¹å¾
3. **åº”ç”¨æ€§**: å¹¿æ³›åº”ç”¨äºä»£æ•°ã€æ‹“æ‰‘ã€é€»è¾‘ã€è®¡ç®—æœºç§‘å­¦
4. **ç†è®ºæ·±åº¦**: å»ºç«‹äº†æ·±åˆ»çš„ç†è®ºä½“ç³»

### æœªæ¥å‘å±•æ–¹å‘
1. **é«˜é˜¶èŒƒç•´**: ç ”ç©¶n-èŒƒç•´å’Œæ— ç©·èŒƒç•´
2. **åŒä¼¦ç±»å‹è®º**: ç ”ç©¶èŒƒç•´è®ºä¸ç±»å‹è®ºçš„ç»“åˆ
3. **é‡å­èŒƒç•´**: ç ”ç©¶é‡å­ç¾¤å’Œé‡å­ä»£æ•°
4. **è®¡ç®—èŒƒç•´**: ç ”ç©¶èŒƒç•´è®ºçš„è®¡ç®—æ–¹æ³•

---

**å‚è€ƒæ–‡çŒ®**
1. Mac Lane, S. (2013). Categories for the Working Mathematician. Springer.
2. Awodey, S. (2010). Category Theory. Oxford University Press.
3. Leinster, T. (2014). Basic Category Theory. Cambridge University Press.
4. Riehl, E. (2017). Category Theory in Context. Dover Publications. 