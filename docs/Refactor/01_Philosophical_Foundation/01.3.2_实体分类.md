# 01.3.2 å®ä½“åˆ†ç±»ç†è®º

## ğŸ“‹ æ¦‚è¿°

å®ä½“åˆ†ç±»ç†è®ºæ˜¯æœ¬ä½“è®ºçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œç ”ç©¶å¦‚ä½•å¯¹å­˜åœ¨ç‰©è¿›è¡Œç³»ç»Ÿæ€§çš„åˆ†ç±»å’Œå½’ç±»ã€‚æœ¬ç†è®ºå»ºç«‹åœ¨å¯¹å®ä½“æœ¬è´¨ç‰¹å¾åˆ†æçš„åŸºç¡€ä¸Šï¼Œæä¾›äº†ä¸€å¥—å®Œæ•´çš„åˆ†ç±»æ¡†æ¶å’Œå½¢å¼åŒ–æ–¹æ³•ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹å®ä½“åˆ†ç±»çš„å½¢å¼åŒ–æ¡†æ¶**
2. **æä¾›åˆ†ç±»æ ‡å‡†çš„é€»è¾‘åŸºç¡€**
3. **æ„å»ºåˆ†ç±»ç³»ç»Ÿçš„å±‚æ¬¡ç»“æ„**
4. **ç¡®ä¿åˆ†ç±»çš„ä¸€è‡´æ€§å’Œå®Œå¤‡æ€§**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [åˆ†ç±»æ ‡å‡†](#3-åˆ†ç±»æ ‡å‡†)
4. [åˆ†ç±»ç³»ç»Ÿ](#4-åˆ†ç±»ç³»ç»Ÿ)
5. [å½¢å¼åŒ–è¯æ˜](#5-å½¢å¼åŒ–è¯æ˜)
6. [ä»£ç å®ç°](#6-ä»£ç å®ç°)
7. [åº”ç”¨ç¤ºä¾‹](#7-åº”ç”¨ç¤ºä¾‹)
8. [ç›¸å…³ç†è®º](#8-ç›¸å…³ç†è®º)
9. [å‚è€ƒæ–‡çŒ®](#9-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å®ä½“åˆ†ç±»çš„å®šä¹‰

**å®šä¹‰ 1.1** (å®ä½“åˆ†ç±»)
å®ä½“åˆ†ç±»æ˜¯æŒ‡æ ¹æ®å®ä½“çš„æœ¬è´¨ç‰¹å¾å’Œå±æ€§ï¼Œå°†å®ä½“åˆ’åˆ†ä¸ºä¸åŒç±»åˆ«çš„è¿‡ç¨‹ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
è®¾ $E$ ä¸ºå®ä½“é›†åˆï¼Œ$C$ ä¸ºç±»åˆ«é›†åˆï¼Œ$f: E \rightarrow C$ ä¸ºåˆ†ç±»å‡½æ•°ï¼Œåˆ™å®ä½“åˆ†ç±»å¯ä»¥è¡¨ç¤ºä¸ºï¼š
$$\text{Classification} = \langle E, C, f \rangle$$

### 1.2 åˆ†ç±»æ ‡å‡†

**å®šä¹‰ 1.2** (åˆ†ç±»æ ‡å‡†)
åˆ†ç±»æ ‡å‡†æ˜¯ç”¨äºåŒºåˆ†ä¸åŒå®ä½“çš„ç‰¹å¾é›†åˆï¼Œé€šå¸¸åŒ…æ‹¬ï¼š
- æœ¬è´¨å±æ€§ (Essential Properties)
- å¶ç„¶å±æ€§ (Accidental Properties)
- å…³ç³»å±æ€§ (Relational Properties)

### 1.3 åˆ†ç±»å±‚æ¬¡

**å®šä¹‰ 1.3** (åˆ†ç±»å±‚æ¬¡)
åˆ†ç±»å±‚æ¬¡æ˜¯æŒ‡åˆ†ç±»ç³»ç»Ÿä¸­ä¸åŒçº§åˆ«ä¹‹é—´çš„åŒ…å«å…³ç³»ï¼Œå½¢æˆæ ‘çŠ¶ç»“æ„ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 åˆ†ç±»ç³»ç»Ÿ

**å®šä¹‰ 2.1** (åˆ†ç±»ç³»ç»Ÿ)
åˆ†ç±»ç³»ç»Ÿæ˜¯ä¸€ä¸ªå››å…ƒç»„ $\mathcal{C} = \langle E, C, \preceq, f \rangle$ï¼Œå…¶ä¸­ï¼š
- $E$ æ˜¯å®ä½“é›†åˆ
- $C$ æ˜¯ç±»åˆ«é›†åˆ
- $\preceq$ æ˜¯ç±»åˆ«é—´çš„ååºå…³ç³»ï¼ˆåŒ…å«å…³ç³»ï¼‰
- $f: E \rightarrow C$ æ˜¯åˆ†ç±»å‡½æ•°

### 2.2 åˆ†ç±»å‡½æ•°

**å®šä¹‰ 2.2** (åˆ†ç±»å‡½æ•°)
åˆ†ç±»å‡½æ•° $f: E \rightarrow C$ æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š
1. **å®Œå¤‡æ€§**ï¼š$\forall e \in E, \exists c \in C: f(e) = c$
2. **ä¸€è‡´æ€§**ï¼š$\forall e_1, e_2 \in E: \text{similar}(e_1, e_2) \Rightarrow f(e_1) = f(e_2)$

### 2.3 ç›¸ä¼¼æ€§å…³ç³»

**å®šä¹‰ 2.3** (ç›¸ä¼¼æ€§å…³ç³»)
å®ä½“é—´çš„ç›¸ä¼¼æ€§å…³ç³» $\text{similar}: E \times E \rightarrow \mathbb{B}$ å®šä¹‰ä¸ºï¼š
$$\text{similar}(e_1, e_2) \iff \forall p \in P: p(e_1) = p(e_2)$$
å…¶ä¸­ $P$ æ˜¯ç›¸å…³å±æ€§é›†åˆã€‚

## 3. åˆ†ç±»æ ‡å‡†

### 3.1 æœ¬è´¨å±æ€§åˆ†ç±»

**å®šä¹‰ 3.1** (æœ¬è´¨å±æ€§)
æœ¬è´¨å±æ€§æ˜¯å®ä½“å¿…ç„¶å…·æœ‰çš„å±æ€§ï¼Œç”¨ $P_e$ è¡¨ç¤ºï¼š
$$P_e(e) = \{p \in P \mid \square p(e)\}$$

**åˆ†ç±»æ ‡å‡† 3.1**ï¼š
æ ¹æ®æœ¬è´¨å±æ€§è¿›è¡Œåˆ†ç±»ï¼š
$$C_e = \{c \mid \forall e \in f^{-1}(c): P_e(e) = P_e(c)\}$$

### 3.2 å¶ç„¶å±æ€§åˆ†ç±»

**å®šä¹‰ 3.2** (å¶ç„¶å±æ€§)
å¶ç„¶å±æ€§æ˜¯å®ä½“å¯èƒ½å…·æœ‰çš„å±æ€§ï¼Œç”¨ $P_a$ è¡¨ç¤ºï¼š
$$P_a(e) = \{p \in P \mid \diamond p(e)\}$$

### 3.3 å…³ç³»å±æ€§åˆ†ç±»

**å®šä¹‰ 3.3** (å…³ç³»å±æ€§)
å…³ç³»å±æ€§æè¿°å®ä½“é—´çš„å…³ç³»ï¼Œç”¨ $P_r$ è¡¨ç¤ºï¼š
$$P_r(e_1, e_2) = \{r \in R \mid r(e_1, e_2)\}$$

## 4. åˆ†ç±»ç³»ç»Ÿ

### 4.1 å±‚æ¬¡åˆ†ç±»

**å®šä¹‰ 4.1** (å±‚æ¬¡åˆ†ç±»)
å±‚æ¬¡åˆ†ç±»ç³»ç»Ÿ $\mathcal{H}$ æ˜¯ä¸€ä¸ªæ ‘çŠ¶ç»“æ„ï¼š
$$\mathcal{H} = \langle C, \preceq, \text{root} \rangle$$

å…¶ä¸­ï¼š
- $\text{root} \in C$ æ˜¯æ ¹èŠ‚ç‚¹
- $\preceq$ æ˜¯çˆ¶å­å…³ç³»
- $\forall c \in C: \text{root} \preceq c$

### 4.2 å¤šç»´åº¦åˆ†ç±»

**å®šä¹‰ 4.2** (å¤šç»´åº¦åˆ†ç±»)
å¤šç»´åº¦åˆ†ç±»ç³»ç»Ÿ $\mathcal{M}$ å®šä¹‰ä¸ºï¼š
$$\mathcal{M} = \langle D, \{f_d\}_{d \in D} \rangle$$

å…¶ä¸­ï¼š
- $D$ æ˜¯ç»´åº¦é›†åˆ
- $f_d: E \rightarrow C_d$ æ˜¯ç¬¬ $d$ ç»´çš„åˆ†ç±»å‡½æ•°

## 5. å½¢å¼åŒ–è¯æ˜

### 5.1 åˆ†ç±»å®Œå¤‡æ€§å®šç†

**å®šç† 5.1** (åˆ†ç±»å®Œå¤‡æ€§)
å¯¹äºä»»æ„å®ä½“é›†åˆ $E$ï¼Œå­˜åœ¨å®Œå¤‡çš„åˆ†ç±»ç³»ç»Ÿ $\mathcal{C}$ã€‚

**è¯æ˜**ï¼š
1. æ„é€ åˆ†ç±»å‡½æ•° $f(e) = \{e'\in E \mid \text{similar}(e, e')\}$
2. è¯æ˜ $f$ æ»¡è¶³å®Œå¤‡æ€§å’Œä¸€è‡´æ€§
3. æ„é€ ç±»åˆ«é›†åˆ $C = \text{range}(f)$
4. å®šä¹‰ååºå…³ç³» $\preceq$ ä¸ºåŒ…å«å…³ç³»

### 5.2 åˆ†ç±»å”¯ä¸€æ€§å®šç†

**å®šç† 5.2** (åˆ†ç±»å”¯ä¸€æ€§)
åœ¨ç»™å®šåˆ†ç±»æ ‡å‡†ä¸‹ï¼Œåˆ†ç±»ç»“æœåœ¨ç­‰ä»·æ„ä¹‰ä¸‹å”¯ä¸€ã€‚

**è¯æ˜**ï¼š
å‡è®¾å­˜åœ¨ä¸¤ä¸ªä¸åŒçš„åˆ†ç±»å‡½æ•° $f_1, f_2$ï¼Œåˆ™ï¼š
$$\forall e \in E: f_1(e) = f_2(e) \iff \text{similar}(e_1, e_2)$$

### 5.3 å±‚æ¬¡åˆ†ç±»å®šç†

**å®šç† 5.3** (å±‚æ¬¡åˆ†ç±»)
ä»»æ„åˆ†ç±»ç³»ç»Ÿéƒ½å¯ä»¥æ‰©å±•ä¸ºå±‚æ¬¡åˆ†ç±»ç³»ç»Ÿã€‚

**è¯æ˜**ï¼š
1. æ·»åŠ æ ¹èŠ‚ç‚¹ $\text{root} = E$
2. å®šä¹‰çˆ¶å­å…³ç³»ï¼š$c_1 \preceq c_2 \iff c_1 \subseteq c_2$
3. éªŒè¯æ ‘çŠ¶ç»“æ„æ€§è´¨

## 6. ä»£ç å®ç°

### 6.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::hash::Hash;

/// å®ä½“åˆ†ç±»ç³»ç»Ÿ
#[derive(Debug, Clone)]
pub struct ClassificationSystem<E, C> {
    entities: HashSet<E>,
    categories: HashSet<C>,
    classification: HashMap<E, C>,
    hierarchy: HashMap<C, Vec<C>>,
}

impl<E, C> ClassificationSystem<E, C>
where
    E: Hash + Eq + Clone,
    C: Hash + Eq + Clone,
{
    /// åˆ›å»ºæ–°çš„åˆ†ç±»ç³»ç»Ÿ
    pub fn new() -> Self {
        Self {
            entities: HashSet::new(),
            categories: HashSet::new(),
            classification: HashMap::new(),
            hierarchy: HashMap::new(),
        }
    }

    /// æ·»åŠ å®ä½“
    pub fn add_entity(&mut self, entity: E, category: C) {
        self.entities.insert(entity.clone());
        self.categories.insert(category.clone());
        self.classification.insert(entity, category);
    }

    /// è·å–å®ä½“çš„ç±»åˆ«
    pub fn get_category(&self, entity: &E) -> Option<&C> {
        self.classification.get(entity)
    }

    /// è·å–ç±»åˆ«ä¸­çš„æ‰€æœ‰å®ä½“
    pub fn get_entities_in_category(&self, category: &C) -> Vec<&E> {
        self.classification
            .iter()
            .filter(|(_, c)| *c == category)
            .map(|(e, _)| e)
            .collect()
    }

    /// æ·»åŠ å±‚æ¬¡å…³ç³»
    pub fn add_hierarchy(&mut self, parent: C, child: C) {
        self.hierarchy
            .entry(parent)
            .or_insert_with(Vec::new)
            .push(child);
    }

    /// éªŒè¯åˆ†ç±»ä¸€è‡´æ€§
    pub fn is_consistent(&self) -> bool {
        // æ£€æŸ¥æ¯ä¸ªç±»åˆ«ä¸­çš„å®ä½“æ˜¯å¦å…·æœ‰ç›¸ä¼¼å±æ€§
        for category in &self.categories {
            let entities = self.get_entities_in_category(category);
            if entities.len() > 1 {
                // è¿™é‡Œåº”è¯¥å®ç°å…·ä½“çš„ç›¸ä¼¼æ€§æ£€æŸ¥é€»è¾‘
                // ç®€åŒ–ç‰ˆæœ¬ï¼šæ£€æŸ¥æ‰€æœ‰å®ä½“æ˜¯å¦åœ¨åŒä¸€ç±»åˆ«
                for i in 0..entities.len() {
                    for j in i + 1..entities.len() {
                        if !self.are_similar(entities[i], entities[j]) {
                            return false;
                        }
                    }
                }
            }
        }
        true
    }

    /// æ£€æŸ¥ä¸¤ä¸ªå®ä½“æ˜¯å¦ç›¸ä¼¼ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
    fn are_similar(&self, e1: &E, e2: &E) -> bool {
        // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥å®ç°å…·ä½“çš„ç›¸ä¼¼æ€§æ£€æŸ¥
        // è¿™é‡Œä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬ï¼šæ£€æŸ¥æ˜¯å¦åœ¨åŒä¸€ç±»åˆ«
        self.classification.get(e1) == self.classification.get(e2)
    }
}

/// å¤šç»´åº¦åˆ†ç±»ç³»ç»Ÿ
#[derive(Debug, Clone)]
pub struct MultiDimensionalClassification<E, C> {
    dimensions: HashMap<String, ClassificationSystem<E, C>>,
}

impl<E, C> MultiDimensionalClassification<E, C>
where
    E: Hash + Eq + Clone,
    C: Hash + Eq + Clone,
{
    pub fn new() -> Self {
        Self {
            dimensions: HashMap::new(),
        }
    }

    /// æ·»åŠ ç»´åº¦
    pub fn add_dimension(&mut self, name: String) {
        self.dimensions.insert(name, ClassificationSystem::new());
    }

    /// åœ¨æŒ‡å®šç»´åº¦ä¸­åˆ†ç±»å®ä½“
    pub fn classify_in_dimension(&mut self, dimension: &str, entity: E, category: C) {
        if let Some(system) = self.dimensions.get_mut(dimension) {
            system.add_entity(entity, category);
        }
    }

    /// è·å–å®ä½“åœ¨æ‰€æœ‰ç»´åº¦ä¸­çš„åˆ†ç±»
    pub fn get_all_classifications(&self, entity: &E) -> HashMap<String, Option<&C>> {
        let mut result = HashMap::new();
        for (dimension, system) in &self.dimensions {
            result.insert(dimension.clone(), system.get_category(entity));
        }
        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_classification() {
        let mut system = ClassificationSystem::new();
        
        // æ·»åŠ å®ä½“å’Œåˆ†ç±»
        system.add_entity("apple", "fruit");
        system.add_entity("banana", "fruit");
        system.add_entity("carrot", "vegetable");
        
        // éªŒè¯åˆ†ç±»
        assert_eq!(system.get_category(&"apple"), Some(&"fruit"));
        assert_eq!(system.get_category(&"carrot"), Some(&"vegetable"));
        
        // éªŒè¯ç±»åˆ«ä¸­çš„å®ä½“
        let fruits = system.get_entities_in_category(&"fruit");
        assert_eq!(fruits.len(), 2);
        assert!(fruits.contains(&&"apple"));
        assert!(fruits.contains(&&"banana"));
    }

    #[test]
    fn test_multi_dimensional_classification() {
        let mut system = MultiDimensionalClassification::new();
        
        // æ·»åŠ ç»´åº¦
        system.add_dimension("type".to_string());
        system.add_dimension("color".to_string());
        
        // åˆ†ç±»å®ä½“
        system.classify_in_dimension("type", "apple", "fruit");
        system.classify_in_dimension("color", "apple", "red");
        
        // éªŒè¯å¤šç»´åº¦åˆ†ç±»
        let classifications = system.get_all_classifications(&"apple");
        assert_eq!(classifications.get("type"), Some(&Some(&"fruit")));
        assert_eq!(classifications.get("color"), Some(&Some(&"red")));
    }
}
```

### 6.2 Haskell å®ç°

```haskell
module EntityClassification where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Maybe (fromMaybe)

-- å®ä½“åˆ†ç±»ç³»ç»Ÿ
data ClassificationSystem e c = ClassificationSystem
    { entities :: Set e
    , categories :: Set c
    , classification :: Map e c
    , hierarchy :: Map c [c]
    } deriving (Show, Eq)

-- åˆ›å»ºç©ºåˆ†ç±»ç³»ç»Ÿ
emptyClassificationSystem :: ClassificationSystem e c
emptyClassificationSystem = ClassificationSystem
    { entities = Set.empty
    , categories = Set.empty
    , classification = Map.empty
    , hierarchy = Map.empty
    }

-- æ·»åŠ å®ä½“åˆ†ç±»
addEntity :: (Ord e, Ord c) => e -> c -> ClassificationSystem e c -> ClassificationSystem e c
addEntity entity category system = system
    { entities = Set.insert entity (entities system)
    , categories = Set.insert category (categories system)
    , classification = Map.insert entity category (classification system)
    }

-- è·å–å®ä½“ç±»åˆ«
getCategory :: (Ord e, Ord c) => e -> ClassificationSystem e c -> Maybe c
getCategory entity system = Map.lookup entity (classification system)

-- è·å–ç±»åˆ«ä¸­çš„æ‰€æœ‰å®ä½“
getEntitiesInCategory :: (Ord e, Ord c) => c -> ClassificationSystem e c -> [e]
getEntitiesInCategory category system = 
    [entity | (entity, cat) <- Map.toList (classification system), cat == category]

-- æ·»åŠ å±‚æ¬¡å…³ç³»
addHierarchy :: (Ord c) => c -> c -> ClassificationSystem e c -> ClassificationSystem e c
addHierarchy parent child system = system
    { hierarchy = Map.insertWith (++) parent [child] (hierarchy system)
    }

-- å¤šç»´åº¦åˆ†ç±»ç³»ç»Ÿ
data MultiDimensionalClassification e c = MultiDimensionalClassification
    { dimensions :: Map String (ClassificationSystem e c)
    } deriving (Show, Eq)

-- åˆ›å»ºç©ºå¤šç»´åº¦åˆ†ç±»ç³»ç»Ÿ
emptyMultiDimensionalClassification :: MultiDimensionalClassification e c
emptyMultiDimensionalClassification = MultiDimensionalClassification Map.empty

-- æ·»åŠ ç»´åº¦
addDimension :: String -> MultiDimensionalClassification e c -> MultiDimensionalClassification e c
addDimension name system = system
    { dimensions = Map.insert name emptyClassificationSystem (dimensions system)
    }

-- åœ¨æŒ‡å®šç»´åº¦ä¸­åˆ†ç±»å®ä½“
classifyInDimension :: (Ord e, Ord c) => String -> e -> c -> MultiDimensionalClassification e c -> MultiDimensionalClassification e c
classifyInDimension dimension entity category system = system
    { dimensions = Map.adjust (addEntity entity category) dimension (dimensions system)
    }

-- è·å–å®ä½“åœ¨æ‰€æœ‰ç»´åº¦ä¸­çš„åˆ†ç±»
getAllClassifications :: (Ord e, Ord c) => e -> MultiDimensionalClassification e c -> Map String (Maybe c)
getAllClassifications entity system = 
    Map.map (getCategory entity) (dimensions system)

-- éªŒè¯åˆ†ç±»ä¸€è‡´æ€§
isConsistent :: (Ord e, Ord c) => ClassificationSystem e c -> Bool
isConsistent system = 
    all (\category -> 
        let entities = getEntitiesInCategory category system
        in all (\e1 -> all (\e2 -> areSimilar e1 e2 system) entities) entities
    ) (Set.toList (categories system))
  where
    areSimilar e1 e2 sys = getCategory e1 sys == getCategory e2 sys

-- ç¤ºä¾‹ä½¿ç”¨
example :: IO ()
example = do
    let system = emptyClassificationSystem
        system' = addEntity "apple" "fruit" system
        system'' = addEntity "banana" "fruit" system'
        system''' = addEntity "carrot" "vegetable" system''
    
    putStrLn "Basic Classification Example:"
    putStrLn $ "Apple category: " ++ show (getCategory "apple" system''')
    putStrLn $ "Fruits: " ++ show (getEntitiesInCategory "fruit" system''')
    putStrLn $ "Is consistent: " ++ show (isConsistent system''')
    
    let multiSystem = emptyMultiDimensionalClassification
        multiSystem' = addDimension "type" multiSystem
        multiSystem'' = addDimension "color" multiSystem'
        multiSystem''' = classifyInDimension "type" "apple" "fruit" multiSystem''
        multiSystem'''' = classifyInDimension "color" "apple" "red" multiSystem'''
    
    putStrLn "\nMulti-dimensional Classification Example:"
    putStrLn $ "Apple classifications: " ++ show (getAllClassifications "apple" multiSystem'''')

main :: IO ()
main = example
```

## 7. åº”ç”¨ç¤ºä¾‹

### 7.1 ç”Ÿç‰©å­¦åˆ†ç±»

**ç¤ºä¾‹ 7.1** (ç”Ÿç‰©åˆ†ç±»ç³»ç»Ÿ)
```rust
// ç”Ÿç‰©åˆ†ç±»ç³»ç»Ÿ
let mut bio_system = ClassificationSystem::new();

// æ·»åŠ ç”Ÿç‰©å®ä½“
bio_system.add_entity("Homo sapiens", "Mammalia");
bio_system.add_entity("Canis lupus", "Mammalia");
bio_system.add_entity("Falco peregrinus", "Aves");

// éªŒè¯åˆ†ç±»
assert_eq!(bio_system.get_category(&"Homo sapiens"), Some(&"Mammalia"));
```

### 7.2 è½¯ä»¶ç³»ç»Ÿåˆ†ç±»

**ç¤ºä¾‹ 7.2** (è½¯ä»¶åˆ†ç±»ç³»ç»Ÿ)
```rust
// å¤šç»´åº¦è½¯ä»¶åˆ†ç±»
let mut software_system = MultiDimensionalClassification::new();
software_system.add_dimension("paradigm".to_string());
software_system.add_dimension("language".to_string());

// åˆ†ç±»è½¯ä»¶
software_system.classify_in_dimension("paradigm", "Rust", "systems");
software_system.classify_in_dimension("language", "Rust", "compiled");
```

## 8. ç›¸å…³ç†è®º

### 8.1 ä¸æœ¬ä½“è®ºçš„å…³ç³»

å®ä½“åˆ†ç±»ç†è®ºæ˜¯æœ¬ä½“è®ºçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œä¸ºå®ä½“ç ”ç©¶æä¾›äº†ç³»ç»ŸåŒ–çš„æ–¹æ³•ã€‚

### 8.2 ä¸é›†åˆè®ºçš„å…³ç³»

åˆ†ç±»ç³»ç»Ÿå¯ä»¥å½¢å¼åŒ–ä¸ºé›†åˆè®ºä¸­çš„ç­‰ä»·å…³ç³»ï¼Œåˆ©ç”¨é›†åˆè®ºçš„å·¥å…·è¿›è¡Œåˆ†æã€‚

### 8.3 ä¸é€»è¾‘å­¦çš„å…³ç³»

åˆ†ç±»æ¨ç†éœ€è¦é€»è¾‘å­¦çš„åŸºç¡€ï¼Œç‰¹åˆ«æ˜¯è°“è¯é€»è¾‘å’Œæ¨¡æ€é€»è¾‘ã€‚

## 9. å‚è€ƒæ–‡çŒ®

1. Aristotle. *Categories*. 350 BCE.
2. Quine, W. V. O. *Word and Object*. MIT Press, 1960.
3. Lewis, D. *On the Plurality of Worlds*. Blackwell, 1986.
4. Lowe, E. J. *The Four-Category Ontology*. Oxford University Press, 2006.
5. Smith, B. *Ontology: Philosophical and Computational*. 2003.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [01.3.1 æœ¬ä½“è®ºæ¡†æ¶](../01.3.1_æœ¬ä½“è®ºæ¡†æ¶.md)
- [01.3.3 å­˜åœ¨æ¨¡æ€](../01.3.3_å­˜åœ¨æ¨¡æ€.md)
- [01.3.4 æœ¬ä½“è®ºå…³ç³»](../01.3.4_æœ¬ä½“è®ºå…³ç³».md)
- [02.1.1 æœ´ç´ é›†åˆè®º](../../02_Mathematical_Foundation/02.1.1_æœ´ç´ é›†åˆè®º.md)
- [02.2.1 å‘½é¢˜é€»è¾‘](../../02_Mathematical_Foundation/02.2.1_å‘½é¢˜é€»è¾‘.md) 