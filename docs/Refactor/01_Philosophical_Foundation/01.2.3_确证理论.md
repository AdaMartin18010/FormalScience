# 01.2.3 ç¡®è¯ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç¡®è¯ç†è®ºæ˜¯è®¤è¯†è®ºçš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶ä¿¡å¿µçš„åˆç†æ€§æ ‡å‡†å’Œç¡®è¯æ¡ä»¶ã€‚ç¡®è¯æ˜¯çŸ¥è¯†æ„æˆçš„å…³é”®è¦ç´ ï¼Œæ¢è®¨å¦‚ä½•åŒºåˆ†åˆç†çš„ä¿¡å¿µä¸ä¸åˆç†çš„ä¿¡å¿µï¼Œä»¥åŠç¡®è¯çš„æ€§è´¨ã€æ¥æºå’Œç»“æ„ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **ç¡®è¯æœ¬è´¨åˆ†æ**: æ¢è®¨ç¡®è¯çš„æœ¬è´¨å’Œæ€§è´¨
2. **ç¡®è¯æ¥æºç ”ç©¶**: åˆ†æç¡®è¯çš„ä¸åŒæ¥æºå’ŒåŸºç¡€
3. **ç¡®è¯ç»“æ„ç†è®º**: ç ”ç©¶ç¡®è¯çš„ç»“æ„å’Œç»„ç»‡æ–¹å¼
4. **ç¡®è¯æ ‡å‡†å»ºç«‹**: å»ºç«‹ç¡®è¯è¯„ä»·çš„è§„èŒƒæ ‡å‡†

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç¡®è¯çš„å®šä¹‰

**ç¡®è¯**æ˜¯ä½¿ä¿¡å¿µåˆç†åŒ–çš„è¿‡ç¨‹æˆ–çŠ¶æ€ï¼Œä¸ºä¿¡å¿µæä¾›å……åˆ†çš„ç†ç”±æ”¯æŒã€‚

**å½¢å¼åŒ–å®šä¹‰**:
è®¾ $A$ ä¸ºä¸»ä½“ï¼Œ$p$ ä¸ºå‘½é¢˜ï¼Œ$J$ ä¸ºç¡®è¯å…³ç³»ï¼Œåˆ™ï¼š
$$J(A, p) \iff A \text{ å¯¹ } p \text{ æœ‰å……åˆ†çš„ç¡®è¯}$$

### 1.2 ç¡®è¯çš„åŸºæœ¬æ€§è´¨

1. **è§„èŒƒæ€§**: ç¡®è¯å…·æœ‰è§„èŒƒæ€§ç‰¹å¾
2. **å¯ä¼ é€’æ€§**: ç¡®è¯å¯ä»¥åœ¨ä¿¡å¿µé—´ä¼ é€’
3. **å¯å åŠ æ€§**: å¤šä¸ªç¡®è¯å¯ä»¥å åŠ 
4. **å¯æ’¤é”€æ€§**: ç¡®è¯å¯èƒ½è¢«æ–°è¯æ®æ¨ç¿»

### 1.3 ç¡®è¯ç±»å‹

#### 1.3.1 æ ¹æ®æ¥æºåˆ†ç±»

- **ç»éªŒç¡®è¯**: åŸºäºæ„ŸçŸ¥ç»éªŒçš„ç¡®è¯
- **ç†æ€§ç¡®è¯**: åŸºäºç†æ€§æ¨ç†çš„ç¡®è¯
- **æƒå¨ç¡®è¯**: åŸºäºæƒå¨æ¥æºçš„ç¡®è¯
- **ç›´è§‰ç¡®è¯**: åŸºäºç›´è§‰çš„ç¡®è¯

#### 1.3.2 æ ¹æ®ç»“æ„åˆ†ç±»

- **åŸºç¡€ç¡®è¯**: ä¸ä¾èµ–å…¶ä»–ä¿¡å¿µçš„ç¡®è¯
- **æ¨è®ºç¡®è¯**: ä¾èµ–å…¶ä»–ä¿¡å¿µçš„ç¡®è¯
- **èè´¯ç¡®è¯**: åŸºäºä¿¡å¿µç³»ç»Ÿèè´¯çš„ç¡®è¯

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ç¡®è¯é€»è¾‘åŸºç¡€

**ç¡®è¯é€»è¾‘è¯­è¨€** $\mathcal{L}_{Just}$:

$$\mathcal{L}_{Just} = \mathcal{L}_0 \cup \{Just_i \mid i \in Ag\} \cup \{t: \phi \mid t \in Term, \phi \in \mathcal{L}_{Just}\}$$

å…¶ä¸­ $Term$ æ˜¯ç¡®è¯é¡¹é›†åˆã€‚

### 2.2 ç¡®è¯æ¨¡å‹

**ç¡®è¯æ¨¡å‹** $M = \langle W, R, E, V \rangle$:

- $W$: å¯èƒ½ä¸–ç•Œé›†åˆ
- $R: Ag \rightarrow 2^{W \times W}$: å¯è¾¾å…³ç³»
- $E: W \times Term \rightarrow 2^{\mathcal{L}_{Just}}$: è¯æ®å‡½æ•°
- $V: Prop \rightarrow 2^W$: èµ‹å€¼å‡½æ•°

### 2.3 ç¡®è¯è¯­ä¹‰

å¯¹äºä»»æ„ $w \in W$ å’Œå…¬å¼ $\phi$:

$$M, w \models t: \phi \iff \phi \in E(w, t) \text{ ä¸” } \forall v \in W: (w, v) \in R \Rightarrow M, v \models \phi$$

### 2.4 ç¡®è¯å…¬ç†ç³»ç»Ÿ

**LPå…¬ç†ç³»ç»Ÿ**:

1. **A1**: $t: \phi \rightarrow \phi$ (äº‹å®æ€§)
2. **A2**: $t: (\phi \rightarrow \psi) \rightarrow (s: \phi \rightarrow (t \cdot s): \psi)$ (åº”ç”¨)
3. **A3**: $t: \phi \rightarrow !t: (t: \phi)$ (æ­£å†…çœ)
4. **A4**: $t: \phi \vee s: \phi \rightarrow (t + s): \phi$ (å’Œ)

## 3. å®šç†ä¸è¯æ˜

### 3.1 ç¡®è¯ä¼ é€’å®šç†

**å®šç†**: å¦‚æœä¸»ä½“ $A$ å¯¹ $p \rightarrow q$ æœ‰ç¡®è¯ï¼Œä¸”å¯¹ $p$ æœ‰ç¡®è¯ï¼Œé‚£ä¹ˆ $A$ å¯¹ $q$ æœ‰ç¡®è¯ã€‚

**è¯æ˜**:
1. å‡è®¾ $Just(A, p \rightarrow q)$ ä¸” $Just(A, p)$
2. æ ¹æ®ç¡®è¯é€»è¾‘å…¬ç† A2: $t: (\phi \rightarrow \psi) \rightarrow (s: \phi \rightarrow (t \cdot s): \psi)$
3. åº”ç”¨åˆ†ç¦»è§„åˆ™å¾—åˆ° $Just(A, q)$

### 3.2 ç¡®è¯å åŠ å®šç†

**å®šç†**: å¦‚æœä¸»ä½“ $A$ å¯¹ $p$ æœ‰ç¡®è¯ $t$ï¼Œå¯¹ $p$ æœ‰ç¡®è¯ $s$ï¼Œé‚£ä¹ˆ $A$ å¯¹ $p$ æœ‰ç¡®è¯ $t + s$ã€‚

**è¯æ˜**:
1. å‡è®¾ $t: p$ ä¸” $s: p$
2. æ ¹æ®ç¡®è¯é€»è¾‘å…¬ç† A4: $t: \phi \vee s: \phi \rightarrow (t + s): \phi$
3. ç›´æ¥å¾—åˆ° $(t + s): p$

### 3.3 ç¡®è¯åæ€å®šç†

**å®šç†**: å¦‚æœä¸»ä½“ $A$ å¯¹ $p$ æœ‰ç¡®è¯ $t$ï¼Œé‚£ä¹ˆ $A$ å¯¹è‡ªå·±å¯¹ $p$ æœ‰ç¡®è¯ $t$ æœ‰ç¡®è¯ã€‚

**è¯æ˜**:
1. å‡è®¾ $t: p$
2. æ ¹æ®ç¡®è¯é€»è¾‘å…¬ç† A3: $t: \phi \rightarrow !t: (t: \phi)$
3. ç›´æ¥å¾—åˆ° $!t: (t: p)$

## 4. ä»£ç å®ç°

### 4.1 ç¡®è¯é€»è¾‘å®ç° (Rust)

```rust
use std::collections::HashMap;

/// ç¡®è¯é€»è¾‘ç³»ç»Ÿ
pub struct JustificationSystem {
    agents: Vec<String>,
    justifications: HashMap<String, HashMap<Proposition, Vec<JustificationTerm>>>,
    evidence_base: HashMap<JustificationTerm, Evidence>,
    world_states: Vec<WorldState>,
}

/// ç¡®è¯é¡¹
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum JustificationTerm {
    Constant(String),
    Variable(String),
    Application(Box<JustificationTerm>, Box<JustificationTerm>),
    Sum(Box<JustificationTerm>, Box<JustificationTerm>),
    Factorial(Box<JustificationTerm>),
}

/// è¯æ®
#[derive(Debug, Clone)]
pub struct Evidence {
    term: JustificationTerm,
    propositions: Vec<Proposition>,
    strength: f64,
    source: EvidenceSource,
}

/// è¯æ®æ¥æº
#[derive(Debug, Clone)]
pub enum EvidenceSource {
    Perception,
    Reasoning,
    Authority,
    Intuition,
    Testimony,
}

/// å‘½é¢˜
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Proposition {
    Atomic(String),
    Not(Box<Proposition>),
    And(Box<Proposition>, Box<Proposition>),
    Or(Box<Proposition>, Box<Proposition>),
    Implies(Box<Proposition>, Box<Proposition>),
    Justified(String, JustificationTerm, Box<Proposition>),
}

impl JustificationSystem {
    /// åˆ›å»ºæ–°çš„ç¡®è¯ç³»ç»Ÿ
    pub fn new() -> Self {
        Self {
            agents: Vec::new(),
            justifications: HashMap::new(),
            evidence_base: HashMap::new(),
            world_states: Vec::new(),
        }
    }

    /// æ·»åŠ ä¸»ä½“
    pub fn add_agent(&mut self, agent: String) {
        if !self.agents.contains(&agent) {
            self.agents.push(agent.clone());
            self.justifications.insert(agent, HashMap::new());
        }
    }

    /// æ·»åŠ ç¡®è¯
    pub fn add_justification(&mut self, agent: &str, proposition: Proposition, term: JustificationTerm) {
        if let Some(agent_justifications) = self.justifications.get_mut(agent) {
            agent_justifications
                .entry(proposition)
                .or_insert_with(Vec::new)
                .push(term);
        }
    }

    /// æ·»åŠ è¯æ®
    pub fn add_evidence(&mut self, term: JustificationTerm, evidence: Evidence) {
        self.evidence_base.insert(term, evidence);
    }

    /// æ£€æŸ¥ç¡®è¯æœ‰æ•ˆæ€§
    pub fn check_justification_validity(&self, agent: &str, proposition: &Proposition, term: &JustificationTerm) -> bool {
        // æ£€æŸ¥è¯æ®åŸºç¡€ä¸­æ˜¯å¦å­˜åœ¨è¯¥ç¡®è¯é¡¹
        if let Some(evidence) = self.evidence_base.get(term) {
            // æ£€æŸ¥å‘½é¢˜æ˜¯å¦åœ¨è¯æ®æ”¯æŒçš„å‘½é¢˜åˆ—è¡¨ä¸­
            return evidence.propositions.contains(proposition);
        }
        false
    }

    /// ç¡®è¯æ¨ç†
    pub fn justify_inference(&mut self, agent: &str) -> Vec<Proposition> {
        let mut justified = Vec::new();
        
        if let Some(agent_justifications) = self.justifications.get(agent) {
            for (proposition, terms) in agent_justifications {
                for term in terms {
                    if self.check_justification_validity(agent, proposition, term) {
                        justified.push(proposition.clone());
                    }
                }
            }
        }
        
        justified
    }

    /// ç¡®è¯ä¼ é€’
    pub fn justify_transitivity(&mut self, agent: &str) -> Vec<Proposition> {
        let mut new_justifications = Vec::new();
        
        if let Some(agent_justifications) = self.justifications.get(agent) {
            for (proposition, terms) in agent_justifications {
                match proposition {
                    Proposition::Implies(p, q) => {
                        // å¦‚æœå¯¹ pâ†’q æœ‰ç¡®è¯ï¼Œä¸”å¯¹ p æœ‰ç¡®è¯ï¼Œåˆ™å¯¹ q æœ‰ç¡®è¯
                        if let Some(p_terms) = agent_justifications.get(p) {
                            for p_term in p_terms {
                                for impl_term in terms {
                                    let new_term = JustificationTerm::Application(
                                        Box::new(impl_term.clone()),
                                        Box::new(p_term.clone())
                                    );
                                    new_justifications.push((q.clone(), new_term));
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        
        new_justifications
    }

    /// ç¡®è¯å åŠ 
    pub fn justify_superposition(&mut self, agent: &str) -> Vec<Proposition> {
        let mut superposed = Vec::new();
        
        if let Some(agent_justifications) = self.justifications.get(agent) {
            for (proposition, terms) in agent_justifications {
                if terms.len() > 1 {
                    // åˆ›å»ºå åŠ ç¡®è¯é¡¹
                    let mut superposed_term = terms[0].clone();
                    for term in &terms[1..] {
                        superposed_term = JustificationTerm::Sum(
                            Box::new(superposed_term),
                            Box::new(term.clone())
                        );
                    }
                    superposed.push((proposition.clone(), superposed_term));
                }
            }
        }
        
        superposed
    }

    /// ç¡®è¯åæ€
    pub fn justify_reflection(&mut self, agent: &str) -> Vec<Proposition> {
        let mut reflected = Vec::new();
        
        if let Some(agent_justifications) = self.justifications.get(agent) {
            for (proposition, terms) in agent_justifications {
                for term in terms {
                    let reflected_term = JustificationTerm::Factorial(Box::new(term.clone()));
                    let reflected_prop = Proposition::Justified(
                        agent.to_string(),
                        reflected_term,
                        Box::new(proposition.clone())
                    );
                    reflected.push(reflected_prop);
                }
            }
        }
        
        reflected
    }

    /// è®¡ç®—ç¡®è¯å¼ºåº¦
    pub fn calculate_justification_strength(&self, agent: &str, proposition: &Proposition) -> f64 {
        if let Some(agent_justifications) = self.justifications.get(agent) {
            if let Some(terms) = agent_justifications.get(proposition) {
                let mut total_strength = 0.0;
                for term in terms {
                    if let Some(evidence) = self.evidence_base.get(term) {
                        total_strength += evidence.strength;
                    }
                }
                return total_strength.min(1.0);
            }
        }
        0.0
    }
}

/// ç¡®è¯æ¦‚ç‡æ¨¡å‹
pub struct JustificationProbabilityModel {
    agent_justifications: HashMap<String, HashMap<Proposition, f64>>,
    evidence_weights: HashMap<EvidenceSource, f64>,
}

impl JustificationProbabilityModel {
    /// åˆ›å»ºæ–°çš„ç¡®è¯æ¦‚ç‡æ¨¡å‹
    pub fn new() -> Self {
        let mut evidence_weights = HashMap::new();
        evidence_weights.insert(EvidenceSource::Perception, 0.8);
        evidence_weights.insert(EvidenceSource::Reasoning, 0.9);
        evidence_weights.insert(EvidenceSource::Authority, 0.7);
        evidence_weights.insert(EvidenceSource::Intuition, 0.6);
        evidence_weights.insert(EvidenceSource::Testimony, 0.7);
        
        Self {
            agent_justifications: HashMap::new(),
            evidence_weights,
        }
    }

    /// è®¾ç½®ç¡®è¯æ¦‚ç‡
    pub fn set_justification_probability(&mut self, agent: &str, proposition: Proposition, probability: f64) {
        self.agent_justifications
            .entry(agent.to_string())
            .or_insert_with(HashMap::new)
            .insert(proposition, probability.max(0.0).min(1.0));
    }

    /// è·å–ç¡®è¯æ¦‚ç‡
    pub fn get_justification_probability(&self, agent: &str, proposition: &Proposition) -> f64 {
        self.agent_justifications
            .get(agent)
            .and_then(|justifications| justifications.get(proposition))
            .copied()
            .unwrap_or(0.0)
    }

    /// ç¡®è¯æ›´æ–°
    pub fn update_justification(&mut self, agent: &str, new_evidence: &Evidence) {
        if let Some(justifications) = self.agent_justifications.get_mut(agent) {
            let evidence_weight = self.evidence_weights.get(&new_evidence.source).unwrap_or(&0.5);
            
            for proposition in &new_evidence.propositions {
                let current_prob = justifications.get(proposition).unwrap_or(&0.0);
                let new_prob = current_prob + (new_evidence.strength * evidence_weight) * (1.0 - current_prob);
                justifications.insert(proposition.clone(), new_prob.min(1.0));
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_justification_validity() {
        let mut system = JustificationSystem::new();
        system.add_agent("Alice".to_string());
        
        let p = Proposition::Atomic("p".to_string());
        let term = JustificationTerm::Constant("evidence_1".to_string());
        let evidence = Evidence {
            term: term.clone(),
            propositions: vec![p.clone()],
            strength: 0.8,
            source: EvidenceSource::Perception,
        };
        
        system.add_evidence(term.clone(), evidence);
        system.add_justification("Alice", p.clone(), term);
        
        assert!(system.check_justification_validity("Alice", &p, &term));
    }

    #[test]
    fn test_justification_transitivity() {
        let mut system = JustificationSystem::new();
        system.add_agent("Bob".to_string());
        
        let p = Proposition::Atomic("p".to_string());
        let q = Proposition::Atomic("q".to_string());
        let p_implies_q = Proposition::Implies(Box::new(p.clone()), Box::new(q.clone()));
        
        let term1 = JustificationTerm::Constant("evidence_1".to_string());
        let term2 = JustificationTerm::Constant("evidence_2".to_string());
        
        system.add_justification("Bob", p_implies_q, term1);
        system.add_justification("Bob", p, term2);
        
        let new_justifications = system.justify_transitivity("Bob");
        assert!(!new_justifications.is_empty());
    }

    #[test]
    fn test_justification_probability() {
        let mut model = JustificationProbabilityModel::new();
        let p = Proposition::Atomic("p".to_string());
        
        model.set_justification_probability("Alice", p.clone(), 0.8);
        assert_eq!(model.get_justification_probability("Alice", &p), 0.8);
        
        let new_evidence = Evidence {
            term: JustificationTerm::Constant("new_evidence".to_string()),
            propositions: vec![p.clone()],
            strength: 0.9,
            source: EvidenceSource::Reasoning,
        };
        
        model.update_justification("Alice", &new_evidence);
        let updated_prob = model.get_justification_probability("Alice", &p);
        assert!(updated_prob > 0.8); // æ¦‚ç‡åº”è¯¥å¢åŠ 
    }
}
```

### 4.2 ç¡®è¯ç½‘ç»œå®ç° (Haskell)

```haskell
module JustificationTheory where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set

-- ç¡®è¯ç½‘ç»œæ•°æ®ç±»å‹
data JustificationNetwork = JustificationNetwork
    { agents :: Set String
    , justifications :: Map String (Map Proposition [JustificationTerm])
    , evidenceBase :: Map JustificationTerm Evidence
    , evidenceWeights :: Map EvidenceSource Double
    }

-- ç¡®è¯é¡¹
data JustificationTerm
    = Constant String
    | Variable String
    | Application JustificationTerm JustificationTerm
    | Sum JustificationTerm JustificationTerm
    | Factorial JustificationTerm
    deriving (Eq, Ord, Show)

-- è¯æ®
data Evidence = Evidence
    { evidenceTerm :: JustificationTerm
    , evidencePropositions :: [Proposition]
    , evidenceStrength :: Double
    , evidenceSource :: EvidenceSource
    }
    deriving (Eq, Ord, Show)

-- è¯æ®æ¥æº
data EvidenceSource
    = Perception
    | Reasoning
    | Authority
    | Intuition
    | Testimony
    deriving (Eq, Ord, Show)

-- å‘½é¢˜
data Proposition
    = Atomic String
    | Not Proposition
    | And Proposition Proposition
    | Or Proposition Proposition
    | Implies Proposition Proposition
    | Justified String JustificationTerm Proposition
    deriving (Eq, Ord, Show)

-- åˆ›å»ºç©ºç¡®è¯ç½‘ç»œ
emptyJustificationNetwork :: JustificationNetwork
emptyJustificationNetwork = JustificationNetwork
    { agents = Set.empty
    , justifications = Map.empty
    , evidenceBase = Map.empty
    , evidenceWeights = Map.fromList
        [ (Perception, 0.8)
        , (Reasoning, 0.9)
        , (Authority, 0.7)
        , (Intuition, 0.6)
        , (Testimony, 0.7)
        ]
    }

-- æ·»åŠ ä¸»ä½“
addAgent :: String -> JustificationNetwork -> JustificationNetwork
addAgent agent network = network
    { agents = Set.insert agent (agents network)
    , justifications = Map.insert agent Map.empty (justifications network)
    }

-- æ·»åŠ ç¡®è¯
addJustification :: String -> Proposition -> JustificationTerm -> JustificationNetwork -> JustificationNetwork
addJustification agent prop term network = network
    { justifications = Map.insertWith (Map.unionWith (++)) agent 
        (Map.singleton prop [term]) (justifications network)
    }

-- æ·»åŠ è¯æ®
addEvidence :: JustificationTerm -> Evidence -> JustificationNetwork -> JustificationNetwork
addEvidence term evidence network = network
    { evidenceBase = Map.insert term evidence (evidenceBase network)
    }

-- æ£€æŸ¥ç¡®è¯æœ‰æ•ˆæ€§
checkJustificationValidity :: String -> Proposition -> JustificationTerm -> JustificationNetwork -> Bool
checkJustificationValidity agent prop term network = case Map.lookup term (evidenceBase network) of
    Just evidence -> prop `elem` evidencePropositions evidence
    Nothing -> False

-- ç¡®è¯æ¨ç†
inferJustifications :: String -> JustificationNetwork -> [Proposition]
inferJustifications agent network = case Map.lookup agent (justifications network) of
    Just agentJustifications -> concatMap inferFromProposition (Map.toList agentJustifications)
    Nothing -> []
  where
    inferFromProposition (prop, terms) = 
        [prop | term <- terms, checkJustificationValidity agent prop term network]

-- ç¡®è¯ä¼ é€’
justifyTransitivity :: String -> JustificationNetwork -> [(Proposition, JustificationTerm)]
justifyTransitivity agent network = case Map.lookup agent (justifications network) of
    Just agentJustifications -> concatMap applyTransitivity (Map.toList agentJustifications)
    Nothing -> []
  where
    applyTransitivity (prop, terms) = case prop of
        Implies p q -> 
            case Map.lookup p agentJustifications of
                Just pTerms -> [(q, Application t1 t2) | t1 <- terms, t2 <- pTerms]
                Nothing -> []
        _ -> []

-- ç¡®è¯å åŠ 
justifySuperposition :: String -> JustificationNetwork -> [(Proposition, JustificationTerm)]
justifySuperposition agent network = case Map.lookup agent (justifications network) of
    Just agentJustifications -> concatMap applySuperposition (Map.toList agentJustifications)
    Nothing -> []
  where
    applySuperposition (prop, terms) = 
        if length terms > 1 
        then [(prop, foldr1 Sum terms)]
        else []

-- ç¡®è¯åæ€
justifyReflection :: String -> JustificationNetwork -> [Proposition]
justifyReflection agent network = case Map.lookup agent (justifications network) of
    Just agentJustifications -> concatMap applyReflection (Map.toList agentJustifications)
    Nothing -> []
  where
    applyReflection (prop, terms) = 
        [Justified agent (Factorial term) prop | term <- terms]

-- è®¡ç®—ç¡®è¯å¼ºåº¦
calculateJustificationStrength :: String -> Proposition -> JustificationNetwork -> Double
calculateJustificationStrength agent prop network = case Map.lookup agent (justifications network) of
    Just agentJustifications -> case Map.lookup prop agentJustifications of
        Just terms -> sum [getEvidenceStrength term network | term <- terms]
        Nothing -> 0.0
    Nothing -> 0.0
  where
    getEvidenceStrength term network = case Map.lookup term (evidenceBase network) of
        Just evidence -> evidenceStrength evidence
        Nothing -> 0.0

-- ç¡®è¯ç½‘ç»œåˆ†æ
analyzeJustificationNetwork :: JustificationNetwork -> JustificationNetworkAnalysis
analyzeJustificationNetwork network = JustificationNetworkAnalysis
    { totalAgents = Set.size (agents network)
    , totalJustifications = sum $ map Map.size (Map.elems (justifications network))
    , averageJustificationStrength = calculateAverageStrength network
    , evidenceDistribution = calculateEvidenceDistribution network
    }

data JustificationNetworkAnalysis = JustificationNetworkAnalysis
    { totalAgents :: Int
    , totalJustifications :: Int
    , averageJustificationStrength :: Double
    , evidenceDistribution :: Map EvidenceSource Int
    }

calculateAverageStrength :: JustificationNetwork -> Double
calculateAverageStrength network = 
    let strengths = [calculateJustificationStrength agent prop network 
                    | agent <- Set.toList (agents network)
                    , (prop, _) <- Map.toList (justifications network Map.! agent)]
    in if null strengths then 0.0 else sum strengths / fromIntegral (length strengths)

calculateEvidenceDistribution :: JustificationNetwork -> Map EvidenceSource Int
calculateEvidenceDistribution network = 
    Map.fromListWith (+) [(evidenceSource evidence, 1) 
                          | evidence <- Map.elems (evidenceBase network)]
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç§‘å­¦ç¡®è¯ç³»ç»Ÿ

```rust
// ç§‘å­¦ç¡®è¯ç³»ç»Ÿç¤ºä¾‹
fn scientific_justification_system() {
    let mut system = JustificationSystem::new();
    
    // æ·»åŠ ç§‘å­¦å®¶ä¸»ä½“
    system.add_agent("Einstein".to_string());
    
    // æ·»åŠ ç§‘å­¦è¯æ®
    let relativity_evidence = Evidence {
        term: JustificationTerm::Constant("experimental_evidence".to_string()),
        propositions: vec![Proposition::Atomic("relativity_theory".to_string())],
        strength: 0.95,
        source: EvidenceSource::Perception,
    };
    
    system.add_evidence(JustificationTerm::Constant("experimental_evidence".to_string()), relativity_evidence);
    
    // æ·»åŠ ç¡®è¯
    system.add_justification("Einstein", 
        Proposition::Atomic("relativity_theory".to_string()),
        JustificationTerm::Constant("experimental_evidence".to_string())
    );
    
    // ç¡®è¯æ¨ç†
    let justified = system.justify_inference("Einstein");
    println!("Einstein's justified beliefs: {:?}", justified);
    
    // è®¡ç®—ç¡®è¯å¼ºåº¦
    let strength = system.calculate_justification_strength("Einstein", 
        &Proposition::Atomic("relativity_theory".to_string()));
    println!("Justification strength: {}", strength);
}
```

### 5.2 å¤šä¸»ä½“ç¡®è¯ç½‘ç»œ

```haskell
-- å¤šä¸»ä½“ç¡®è¯ç½‘ç»œç¤ºä¾‹
multiAgentJustificationExample :: IO ()
multiAgentJustificationExample = do
    let network = emptyJustificationNetwork
        network' = addAgent "Alice" network
        network'' = addAgent "Bob" network'
        
        -- Aliceçš„ç¡®è¯
        network''' = addJustification "Alice" (Atomic "p") (Constant "evidence_1") network''
        network'''' = addEvidence (Constant "evidence_1") 
            (Evidence (Constant "evidence_1") [Atomic "p"] 0.9 Perception) network'''
        
        -- Bobçš„ç¡®è¯
        network''''' = addJustification "Bob" (Atomic "q") (Constant "evidence_2") network''''
        network'''''' = addEvidence (Constant "evidence_2") 
            (Evidence (Constant "evidence_2") [Atomic "q"] 0.8 Reasoning) network'''''
        
        -- ç¡®è¯æ¨ç†
        aliceJustified = inferJustifications "Alice" network''''''
        bobJustified = inferJustifications "Bob" network''''''
        
        analysis = analyzeJustificationNetwork network''''''
    
    putStrLn "Multi-Agent Justification Network Analysis:"
    putStrLn $ "Total agents: " ++ show (totalAgents analysis)
    putStrLn $ "Total justifications: " ++ show (totalJustifications analysis)
    putStrLn $ "Average justification strength: " ++ show (averageJustificationStrength analysis)
    putStrLn $ "Evidence distribution: " ++ show (evidenceDistribution analysis)
    putStrLn $ "Alice's justified beliefs: " ++ show aliceJustified
    putStrLn $ "Bob's justified beliefs: " ++ show bobJustified
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸ä¿¡å¿µç†è®ºçš„å…³ç³»

ç¡®è¯æ˜¯ä¿¡å¿µåˆç†åŒ–çš„å¿…è¦æ¡ä»¶ï¼š
- **ç¡®è¯ä¿¡å¿µ**: æœ‰å……åˆ†ç†ç”±æ”¯æŒçš„ä¿¡å¿µ
- **éç¡®è¯ä¿¡å¿µ**: ç¼ºä¹å……åˆ†ç†ç”±çš„ä¿¡å¿µ
- **ç¡®è¯ç¨‹åº¦**: ä¿¡å¿µç¡®è¯çš„å¼ºåº¦å·®å¼‚

### 6.2 ä¸çŸ¥è¯†ç†è®ºçš„å…³ç³»

ç¡®è¯æ˜¯çŸ¥è¯†æ„æˆçš„æ ¸å¿ƒè¦ç´ ï¼š
- **ç¡®è¯æ¡ä»¶**: çŸ¥è¯†éœ€è¦ç¡®è¯
- **ç¡®è¯ç±»å‹**: ä¸åŒç±»å‹çš„çŸ¥è¯†éœ€è¦ä¸åŒç±»å‹çš„ç¡®è¯
- **ç¡®è¯æ ‡å‡†**: ç¡®è¯çš„å……åˆ†æ€§æ ‡å‡†

### 6.3 ä¸çœŸç†ç†è®ºçš„å…³ç³»

ç¡®è¯ä¸çœŸç†çš„å…³ç³»ï¼š
- **ç¡®è¯ä¸çœŸç†**: ç¡®è¯ä¸ä¿è¯çœŸç†
- **ç¡®è¯ä¸å¯é æ€§**: ç¡®è¯éœ€è¦å¯é çš„æ¥æº
- **ç¡®è¯ä¸èè´¯**: ç¡®è¯éœ€è¦ä¸æ•´ä½“ä¿¡å¿µç³»ç»Ÿèè´¯

## 7. å‚è€ƒæ–‡çŒ®

1. **Alston, W. P.** (1989). *Epistemic Justification: Essays in the Theory of Knowledge*. Cornell University Press.
2. **BonJour, L.** (1985). *The Structure of Empirical Knowledge*. Harvard University Press.
3. **Chisholm, R. M.** (1989). *Theory of Knowledge*. Prentice-Hall.
4. **Goldman, A. I.** (1986). *Epistemology and Cognition*. Harvard University Press.
5. **Plantinga, A.** (1993). *Warrant: The Current Debate*. Oxford University Press.
6. **Pollock, J. L.** (1986). *Contemporary Theories of Knowledge*. Rowman & Littlefield.
7. **Sosa, E.** (1991). *Knowledge in Perspective: Selected Essays in Epistemology*. Cambridge University Press.

---

**ç›¸å…³æ–‡æ¡£**:
- [01.2.1 çŸ¥è¯†ç†è®º](../01.2.1_çŸ¥è¯†ç†è®º.md)
- [01.2.2 ä¿¡å¿µç†è®º](../01.2.2_ä¿¡å¿µç†è®º.md)
- [01.2.4 çœŸç†ç†è®º](../01.2.4_çœŸç†ç†è®º.md)
- [01.4.1 é€»è¾‘åŸºç¡€](../01.4.1_é€»è¾‘åŸºç¡€.md) 