# 01.1.3 æ¨¡æ€ç†è®º (Modal Theory)

## ğŸ“‹ æ¦‚è¿°

æ¨¡æ€ç†è®ºæ˜¯å½¢è€Œä¸Šå­¦çš„é‡è¦åˆ†æ”¯ï¼Œç ”ç©¶å¯èƒ½æ€§ã€å¿…ç„¶æ€§ã€å¶ç„¶æ€§ç­‰æ¨¡æ€æ¦‚å¿µã€‚å®ƒæ¶‰åŠå¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦ã€æ¨¡æ€é€»è¾‘å’Œå½¢è€Œä¸Šå­¦æ¨¡æ€ç­‰æ ¸å¿ƒå†…å®¹ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹æ¨¡æ€æ¦‚å¿µçš„å½¢å¼åŒ–ç†è®ºæ¡†æ¶
2. å‘å±•å¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦
3. æ„å»ºæ¨¡æ€é€»è¾‘ç³»ç»Ÿ
4. åˆ†æå½¢è€Œä¸Šå­¦æ¨¡æ€é—®é¢˜

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦](#3-å¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦)
4. [æ¨¡æ€é€»è¾‘ç³»ç»Ÿ](#4-æ¨¡æ€é€»è¾‘ç³»ç»Ÿ)
5. [å½¢è€Œä¸Šå­¦æ¨¡æ€](#5-å½¢è€Œä¸Šå­¦æ¨¡æ€)
6. [ä»£ç å®ç°](#6-ä»£ç å®ç°)
7. [åº”ç”¨ç¤ºä¾‹](#7-åº”ç”¨ç¤ºä¾‹)
8. [ç›¸å…³ç†è®º](#8-ç›¸å…³ç†è®º)
9. [å‚è€ƒæ–‡çŒ®](#9-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ¨¡æ€æ¦‚å¿µ

**å®šä¹‰ 1.1 (æ¨¡æ€æ¦‚å¿µ)**
æ¨¡æ€æ¦‚å¿µæ˜¯è¡¨è¾¾äº‹ç‰©å­˜åœ¨æ–¹å¼æˆ–çŠ¶æ€çš„æ¦‚å¿µï¼Œä¸»è¦åŒ…æ‹¬ï¼š

- **å¿…ç„¶æ€§** (Necessity): $\Box p$ - "pæ˜¯å¿…ç„¶çš„"
- **å¯èƒ½æ€§** (Possibility): $\Diamond p$ - "pæ˜¯å¯èƒ½çš„"
- **å¶ç„¶æ€§** (Contingency): $\Diamond p \land \Diamond \neg p$ - "pæ˜¯å¶ç„¶çš„"
- **ä¸å¯èƒ½æ€§** (Impossibility): $\neg \Diamond p$ - "pæ˜¯ä¸å¯èƒ½çš„"

### 1.2 æ¨¡æ€ç±»å‹

**å®šä¹‰ 1.2 (æ¨¡æ€ç±»å‹åˆ†ç±»)**
æ¨¡æ€å¯ä»¥åˆ†ä¸ºä»¥ä¸‹ç±»å‹ï¼š

1. **é€»è¾‘æ¨¡æ€**: åŸºäºé€»è¾‘å¿…ç„¶æ€§
2. **å½¢è€Œä¸Šå­¦æ¨¡æ€**: åŸºäºå½¢è€Œä¸Šå­¦å¿…ç„¶æ€§
3. **ç‰©ç†æ¨¡æ€**: åŸºäºç‰©ç†è§„å¾‹
4. **è®¤è¯†æ¨¡æ€**: åŸºäºçŸ¥è¯†çŠ¶æ€
5. **é“ä¹‰æ¨¡æ€**: åŸºäºé“å¾·ä¹‰åŠ¡

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ¨¡æ€è¯­è¨€

**å®šä¹‰ 2.1 (æ¨¡æ€è¯­è¨€ $\mathcal{L}_\Box$)**
æ¨¡æ€è¯­è¨€ç”±ä»¥ä¸‹éƒ¨åˆ†ç»„æˆï¼š

- **å‘½é¢˜å˜å…ƒ**: $p, q, r, \ldots \in \Phi$
- **é€»è¾‘è¿æ¥è¯**: $\neg, \land, \lor, \rightarrow, \leftrightarrow$
- **æ¨¡æ€ç®—å­**: $\Box$ (å¿…ç„¶), $\Diamond$ (å¯èƒ½)
- **æ‹¬å·**: $(, )$

**å®šä¹‰ 2.2 (æ¨¡æ€å…¬å¼)**
æ¨¡æ€å…¬å¼çš„é€’å½’å®šä¹‰ï¼š

1. å¦‚æœ $p \in \Phi$ï¼Œåˆ™ $p$ æ˜¯å…¬å¼
2. å¦‚æœ $\phi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\neg \phi$ å’Œ $\Box \phi$ æ˜¯å…¬å¼
3. å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $(\phi \land \psi)$ æ˜¯å…¬å¼
4. å¦‚æœ $\phi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\Diamond \phi \equiv \neg \Box \neg \phi$

### 2.2 æ¨¡æ€æ¡†æ¶

**å®šä¹‰ 2.3 (æ¨¡æ€æ¡†æ¶)**
æ¨¡æ€æ¡†æ¶æ˜¯äºŒå…ƒç»„ $\mathcal{F} = (W, R)$ï¼Œå…¶ä¸­ï¼š

- $W$ æ˜¯éç©ºé›†åˆï¼Œç§°ä¸ºå¯èƒ½ä¸–ç•Œé›†åˆ
- $R \subseteq W \times W$ æ˜¯å¯è¾¾å…³ç³»

**å®šä¹‰ 2.4 (æ¨¡æ€æ¨¡å‹)**
æ¨¡æ€æ¨¡å‹æ˜¯ä¸‰å…ƒç»„ $\mathcal{M} = (W, R, V)$ï¼Œå…¶ä¸­ï¼š

- $(W, R)$ æ˜¯æ¨¡æ€æ¡†æ¶
- $V: \Phi \rightarrow 2^W$ æ˜¯èµ‹å€¼å‡½æ•°

## 3. å¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦

### 3.1 çœŸå€¼æ¡ä»¶

**å®šä¹‰ 3.1 (æ¨¡æ€çœŸå€¼æ¡ä»¶)**
åœ¨æ¨¡å‹ $\mathcal{M} = (W, R, V)$ ä¸­ï¼Œå…¬å¼ $\phi$ åœ¨ä¸–ç•Œ $w \in W$ ä¸­ä¸ºçœŸï¼Œè®°ä½œ $\mathcal{M}, w \models \phi$ï¼š

1. $\mathcal{M}, w \models p$ å½“ä¸”ä»…å½“ $w \in V(p)$
2. $\mathcal{M}, w \models \neg \phi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \not\models \phi$
3. $\mathcal{M}, w \models \phi \land \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \phi$ ä¸” $\mathcal{M}, w \models \psi$
4. $\mathcal{M}, w \models \Box \phi$ å½“ä¸”ä»…å½“å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œæœ‰ $\mathcal{M}, v \models \phi$

### 3.2 æœ‰æ•ˆæ€§

**å®šä¹‰ 3.2 (æ¡†æ¶æœ‰æ•ˆæ€§)**
å…¬å¼ $\phi$ åœ¨æ¡†æ¶ $\mathcal{F}$ ä¸Šæœ‰æ•ˆï¼Œè®°ä½œ $\mathcal{F} \models \phi$ï¼Œå½“ä¸”ä»…å½“å¯¹äº $\mathcal{F}$ ä¸Šçš„æ‰€æœ‰æ¨¡å‹ $\mathcal{M}$ å’Œæ‰€æœ‰ä¸–ç•Œ $w$ï¼Œéƒ½æœ‰ $\mathcal{M}, w \models \phi$ã€‚

**å®šä¹‰ 3.3 (ç±»æœ‰æ•ˆæ€§)**
å…¬å¼ $\phi$ åœ¨æ¡†æ¶ç±» $\mathcal{C}$ ä¸Šæœ‰æ•ˆï¼Œè®°ä½œ $\mathcal{C} \models \phi$ï¼Œå½“ä¸”ä»…å½“å¯¹äº $\mathcal{C}$ ä¸­çš„æ‰€æœ‰æ¡†æ¶ $\mathcal{F}$ï¼Œéƒ½æœ‰ $\mathcal{F} \models \phi$ã€‚

## 4. æ¨¡æ€é€»è¾‘ç³»ç»Ÿ

### 4.1 åŸºæœ¬æ¨¡æ€é€»è¾‘ K

**å®šä¹‰ 4.1 (ç³»ç»Ÿ K)**
ç³»ç»Ÿ K çš„å…¬ç†å’Œæ¨ç†è§„åˆ™ï¼š

**å…¬ç†ï¼š**
- (PL) æ‰€æœ‰å‘½é¢˜é€»è¾‘é‡è¨€å¼
- (K) $\Box(p \rightarrow q) \rightarrow (\Box p \rightarrow \Box q)$

**æ¨ç†è§„åˆ™ï¼š**
- (MP) ä» $\phi$ å’Œ $\phi \rightarrow \psi$ æ¨å‡º $\psi$
- (Nec) ä» $\phi$ æ¨å‡º $\Box \phi$

**å®šç† 4.1 (Kçš„å¯é æ€§)**
å¦‚æœ $\vdash_K \phi$ï¼Œåˆ™ $\phi$ åœ¨æ‰€æœ‰æ¡†æ¶ä¸Šæœ‰æ•ˆã€‚

**è¯æ˜ï¼š**
1. å…¬ç† (PL) åœ¨æ‰€æœ‰æ¡†æ¶ä¸Šæœ‰æ•ˆ
2. å…¬ç† (K) åœ¨æ‰€æœ‰æ¡†æ¶ä¸Šæœ‰æ•ˆ
3. æ¨ç†è§„åˆ™ä¿æŒæœ‰æ•ˆæ€§
4. å› æ­¤æ‰€æœ‰å¯è¯å…¬å¼éƒ½æœ‰æ•ˆ

### 4.2 å¸¸è§æ¨¡æ€é€»è¾‘

**å®šä¹‰ 4.2 (ç³»ç»Ÿ T)**
ç³»ç»Ÿ T = K + $\Box p \rightarrow p$

**å®šä¹‰ 4.3 (ç³»ç»Ÿ S4)**
ç³»ç»Ÿ S4 = T + $\Box p \rightarrow \Box \Box p$

**å®šä¹‰ 4.4 (ç³»ç»Ÿ S5)**
ç³»ç»Ÿ S5 = S4 + $\Diamond p \rightarrow \Box \Diamond p$

**å®šç† 4.2 (å¯¹åº”å®šç†)**
- T å¯¹åº”è‡ªåæ¡†æ¶
- S4 å¯¹åº”è‡ªåä¼ é€’æ¡†æ¶
- S5 å¯¹åº”ç­‰ä»·å…³ç³»æ¡†æ¶

## 5. å½¢è€Œä¸Šå­¦æ¨¡æ€

### 5.1 å½¢è€Œä¸Šå­¦å¿…ç„¶æ€§

**å®šä¹‰ 5.1 (å½¢è€Œä¸Šå­¦å¿…ç„¶æ€§)**
å‘½é¢˜ $p$ æ˜¯å½¢è€Œä¸Šå­¦å¿…ç„¶çš„ï¼Œå½“ä¸”ä»…å½“ $p$ åœ¨æ‰€æœ‰å½¢è€Œä¸Šå­¦å¯èƒ½çš„ä¸–ç•Œä¸­ä¸ºçœŸã€‚

**å®šä¹‰ 5.2 (å½¢è€Œä¸Šå­¦å¯èƒ½æ€§)**
å‘½é¢˜ $p$ æ˜¯å½¢è€Œä¸Šå­¦å¯èƒ½çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨å½¢è€Œä¸Šå­¦å¯èƒ½çš„ä¸–ç•Œï¼Œåœ¨å…¶ä¸­ $p$ ä¸ºçœŸã€‚

### 5.2 æœ¬è´¨ä¸»ä¹‰

**å®šä¹‰ 5.3 (æœ¬è´¨å±æ€§)**
å±æ€§ $F$ æ˜¯å¯¹è±¡ $x$ çš„æœ¬è´¨å±æ€§ï¼Œå½“ä¸”ä»…å½“åœ¨æ‰€æœ‰ $x$ å­˜åœ¨çš„å¯èƒ½ä¸–ç•Œä¸­ï¼Œ$x$ éƒ½å…·æœ‰ $F$ã€‚

**å®šä¹‰ 5.4 (å¶ç„¶å±æ€§)**
å±æ€§ $F$ æ˜¯å¯¹è±¡ $x$ çš„å¶ç„¶å±æ€§ï¼Œå½“ä¸”ä»…å½“ $F$ ä¸æ˜¯ $x$ çš„æœ¬è´¨å±æ€§ã€‚

## 6. ä»£ç å®ç°

### 6.1 æ¨¡æ€é€»è¾‘æ¡†æ¶

```rust
use std::collections::{HashMap, HashSet};

/// å¯èƒ½ä¸–ç•Œ
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct World {
    pub id: String,
    pub propositions: HashSet<String>,
}

/// å¯è¾¾å…³ç³»
#[derive(Debug, Clone)]
pub struct AccessibilityRelation {
    pub relations: HashMap<String, HashSet<String>>,
}

/// æ¨¡æ€æ¡†æ¶
#[derive(Debug, Clone)]
pub struct ModalFrame {
    pub worlds: HashSet<World>,
    pub accessibility: AccessibilityRelation,
}

/// æ¨¡æ€æ¨¡å‹
#[derive(Debug, Clone)]
pub struct ModalModel {
    pub frame: ModalFrame,
    pub valuation: HashMap<String, HashSet<String>>, // å‘½é¢˜ -> ä¸–ç•Œé›†åˆ
}

/// æ¨¡æ€å…¬å¼
#[derive(Debug, Clone, PartialEq)]
pub enum ModalFormula {
    Proposition(String),
    Negation(Box<ModalFormula>),
    Conjunction(Box<ModalFormula>, Box<ModalFormula>),
    Disjunction(Box<ModalFormula>, Box<ModalFormula>),
    Implication(Box<ModalFormula>, Box<ModalFormula>),
    Necessity(Box<ModalFormula>),
    Possibility(Box<ModalFormula>),
}

impl ModalModel {
    /// æ£€æŸ¥å…¬å¼åœ¨ä¸–ç•Œä¸­æ˜¯å¦ä¸ºçœŸ
    pub fn satisfies(&self, world: &World, formula: &ModalFormula) -> bool {
        match formula {
            ModalFormula::Proposition(p) => {
                world.propositions.contains(p)
            }
            ModalFormula::Negation(phi) => {
                !self.satisfies(world, phi)
            }
            ModalFormula::Conjunction(phi, psi) => {
                self.satisfies(world, phi) && self.satisfies(world, psi)
            }
            ModalFormula::Disjunction(phi, psi) => {
                self.satisfies(world, phi) || self.satisfies(world, psi)
            }
            ModalFormula::Implication(phi, psi) => {
                !self.satisfies(world, phi) || self.satisfies(world, psi)
            }
            ModalFormula::Necessity(phi) => {
                // æ£€æŸ¥æ‰€æœ‰å¯è¾¾ä¸–ç•Œ
                if let Some(accessible) = self.frame.accessibility.relations.get(&world.id) {
                    accessible.iter().all(|w_id| {
                        if let Some(w) = self.find_world(w_id) {
                            self.satisfies(w, phi)
                        } else {
                            false
                        }
                    })
                } else {
                    true // å¦‚æœæ²¡æœ‰å¯è¾¾ä¸–ç•Œï¼Œå¿…ç„¶æ€§ä¸ºçœŸ
                }
            }
            ModalFormula::Possibility(phi) => {
                // æ£€æŸ¥æ˜¯å¦å­˜åœ¨å¯è¾¾ä¸–ç•Œ
                if let Some(accessible) = self.frame.accessibility.relations.get(&world.id) {
                    accessible.iter().any(|w_id| {
                        if let Some(w) = self.find_world(w_id) {
                            self.satisfies(w, phi)
                        } else {
                            false
                        }
                    })
                } else {
                    false // å¦‚æœæ²¡æœ‰å¯è¾¾ä¸–ç•Œï¼Œå¯èƒ½æ€§ä¸ºå‡
                }
            }
        }
    }

    fn find_world(&self, id: &str) -> Option<&World> {
        self.frame.worlds.iter().find(|w| w.id == id)
    }
}
```

### 6.2 æ¨¡æ€é€»è¾‘æ¨ç†ç³»ç»Ÿ

```rust
/// æ¨¡æ€é€»è¾‘æ¨ç†ç³»ç»Ÿ
#[derive(Debug, Clone)]
pub struct ModalLogicSystem {
    pub axioms: Vec<ModalFormula>,
    pub theorems: Vec<ModalFormula>,
}

impl ModalLogicSystem {
    /// ç³»ç»Ÿ K çš„å…¬ç†
    pub fn system_k() -> Self {
        let k_axiom = ModalFormula::Implication(
            Box::new(ModalFormula::Necessity(Box::new(
                ModalFormula::Implication(
                    Box::new(ModalFormula::Proposition("p".to_string())),
                    Box::new(ModalFormula::Proposition("q".to_string())),
                )
            ))),
            Box::new(ModalFormula::Implication(
                Box::new(ModalFormula::Necessity(Box::new(
                    ModalFormula::Proposition("p".to_string())
                ))),
                Box::new(ModalFormula::Necessity(Box::new(
                    ModalFormula::Proposition("q".to_string())
                ))),
            ))
        );

        Self {
            axioms: vec![k_axiom],
            theorems: Vec::new(),
        }
    }

    /// æ·»åŠ å®šç†
    pub fn add_theorem(&mut self, theorem: ModalFormula) {
        self.theorems.push(theorem);
    }

    /// æ£€æŸ¥å…¬å¼æ˜¯å¦ä¸ºå®šç†
    pub fn is_theorem(&self, formula: &ModalFormula) -> bool {
        self.theorems.contains(formula)
    }
}
```

### 6.3 å¯èƒ½ä¸–ç•Œæ„é€ å™¨

```rust
/// å¯èƒ½ä¸–ç•Œæ„é€ å™¨
pub struct WorldBuilder {
    worlds: Vec<World>,
    relations: HashMap<String, HashSet<String>>,
}

impl WorldBuilder {
    pub fn new() -> Self {
        Self {
            worlds: Vec::new(),
            relations: HashMap::new(),
        }
    }

    /// æ·»åŠ ä¸–ç•Œ
    pub fn add_world(&mut self, id: String, propositions: Vec<String>) -> &mut Self {
        let world = World {
            id: id.clone(),
            propositions: propositions.into_iter().collect(),
        };
        self.worlds.push(world);
        self
    }

    /// æ·»åŠ å¯è¾¾å…³ç³»
    pub fn add_relation(&mut self, from: String, to: String) -> &mut Self {
        self.relations.entry(from).or_insert_with(HashSet::new).insert(to);
        self
    }

    /// æ„å»ºæ¨¡æ€æ¡†æ¶
    pub fn build_frame(self) -> ModalFrame {
        ModalFrame {
            worlds: self.worlds.into_iter().collect(),
            accessibility: AccessibilityRelation {
                relations: self.relations,
            },
        }
    }
}
```

## 7. åº”ç”¨ç¤ºä¾‹

### 7.1 å½¢è€Œä¸Šå­¦æ¨¡æ€åˆ†æ

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_metaphysical_necessity() {
        // æ„é€ å½¢è€Œä¸Šå­¦æ¨¡æ€æ¨¡å‹
        let mut builder = WorldBuilder::new();
        
        // æ·»åŠ å¯èƒ½ä¸–ç•Œ
        builder
            .add_world("w1".to_string(), vec!["å­˜åœ¨".to_string(), "æœ‰æ„è¯†".to_string()])
            .add_world("w2".to_string(), vec!["å­˜åœ¨".to_string()])
            .add_world("w3".to_string(), vec!["å­˜åœ¨".to_string(), "æœ‰æ„è¯†".to_string(), "ç†æ€§".to_string()]);
        
        // æ·»åŠ å¯è¾¾å…³ç³»ï¼ˆå½¢è€Œä¸Šå­¦å¯èƒ½æ€§ï¼‰
        builder
            .add_relation("w1".to_string(), "w2".to_string())
            .add_relation("w1".to_string(), "w3".to_string())
            .add_relation("w2".to_string(), "w1".to_string())
            .add_relation("w3".to_string(), "w1".to_string());

        let frame = builder.build_frame();
        let mut model = ModalModel {
            frame,
            valuation: HashMap::new(),
        };

        // æµ‹è¯•å½¢è€Œä¸Šå­¦å¿…ç„¶æ€§
        let existence = ModalFormula::Proposition("å­˜åœ¨".to_string());
        let consciousness = ModalFormula::Proposition("æœ‰æ„è¯†".to_string());
        
        let world1 = model.find_world("w1").unwrap();
        
        // "å­˜åœ¨"åœ¨æ‰€æœ‰å½¢è€Œä¸Šå­¦å¯èƒ½ä¸–ç•Œä¸­ä¸ºçœŸ
        assert!(model.satisfies(world1, &ModalFormula::Necessity(Box::new(existence.clone()))));
        
        // "æœ‰æ„è¯†"ä¸æ˜¯å½¢è€Œä¸Šå­¦å¿…ç„¶çš„
        assert!(!model.satisfies(world1, &ModalFormula::Necessity(Box::new(consciousness.clone()))));
        
        // "æœ‰æ„è¯†"æ˜¯å½¢è€Œä¸Šå­¦å¯èƒ½çš„
        assert!(model.satisfies(world1, &ModalFormula::Possibility(Box::new(consciousness))));
    }

    #[test]
    fn test_essential_properties() {
        // æµ‹è¯•æœ¬è´¨å±æ€§
        let mut builder = WorldBuilder::new();
        
        // æ„é€ è‹æ ¼æ‹‰åº•å­˜åœ¨çš„ä¸–ç•Œ
        builder
            .add_world("w1".to_string(), vec!["è‹æ ¼æ‹‰åº•å­˜åœ¨".to_string(), "è‹æ ¼æ‹‰åº•æ˜¯äºº".to_string()])
            .add_world("w2".to_string(), vec!["è‹æ ¼æ‹‰åº•å­˜åœ¨".to_string(), "è‹æ ¼æ‹‰åº•æ˜¯äºº".to_string()])
            .add_world("w3".to_string(), vec!["è‹æ ¼æ‹‰åº•å­˜åœ¨".to_string(), "è‹æ ¼æ‹‰åº•æ˜¯äºº".to_string(), "è‹æ ¼æ‹‰åº•æ˜¯å“²å­¦å®¶".to_string()]);

        let frame = builder.build_frame();
        let model = ModalModel {
            frame,
            valuation: HashMap::new(),
        };

        let world1 = model.find_world("w1").unwrap();
        let human = ModalFormula::Proposition("è‹æ ¼æ‹‰åº•æ˜¯äºº".to_string());
        let philosopher = ModalFormula::Proposition("è‹æ ¼æ‹‰åº•æ˜¯å“²å­¦å®¶".to_string());

        // "æ˜¯äºº"æ˜¯è‹æ ¼æ‹‰åº•çš„æœ¬è´¨å±æ€§
        assert!(model.satisfies(world1, &ModalFormula::Necessity(Box::new(human))));
        
        // "æ˜¯å“²å­¦å®¶"ä¸æ˜¯è‹æ ¼æ‹‰åº•çš„æœ¬è´¨å±æ€§
        assert!(!model.satisfies(world1, &ModalFormula::Necessity(Box::new(philosopher))));
    }
}
```

## 8. ç›¸å…³ç†è®º

### 8.1 ä¸è®¤è¯†è®ºçš„å…³ç³»

æ¨¡æ€ç†è®ºä¸è®¤è¯†è®ºå¯†åˆ‡ç›¸å…³ï¼Œç‰¹åˆ«æ˜¯ï¼š

- **è®¤è¯†æ¨¡æ€**: ç ”ç©¶çŸ¥è¯†çŠ¶æ€å’Œä¿¡å¿µçŠ¶æ€
- **å¯æƒ³è±¡æ€§è®ºè¯**: é€šè¿‡å¯æƒ³è±¡æ€§è®ºè¯å½¢è€Œä¸Šå­¦å¯èƒ½æ€§
- **å…ˆéªŒçŸ¥è¯†**: æ¨¡æ€çŸ¥è¯†æ˜¯å¦å¯ä»¥æ˜¯å…ˆéªŒçš„

### 8.2 ä¸é€»è¾‘å­¦çš„å…³ç³»

- **æ¨¡æ€é€»è¾‘**: å½¢å¼åŒ–æ¨¡æ€æ¨ç†
- **å¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦**: ä¸ºæ¨¡æ€é€»è¾‘æä¾›è¯­ä¹‰
- **å¯¹åº”ç†è®º**: æ¨¡æ€å…¬ç†ä¸æ¡†æ¶æ€§è´¨çš„å…³ç³»

### 8.3 ä¸å½¢è€Œä¸Šå­¦çš„å…¶ä»–åˆ†æ”¯

- **æœ¬è´¨ä¸»ä¹‰**: æœ¬è´¨å±æ€§ä¸å¶ç„¶å±æ€§çš„åŒºåˆ†
- **åŒä¸€æ€§**: è·¨ä¸–ç•ŒåŒä¸€æ€§é—®é¢˜
- **å­˜åœ¨**: å­˜åœ¨ä¸å¿…ç„¶å­˜åœ¨çš„å…³ç³»

## 9. å‚è€ƒæ–‡çŒ®

1. Kripke, S. (1980). *Naming and Necessity*. Harvard University Press.
2. Lewis, D. (1986). *On the Plurality of Worlds*. Blackwell.
3. Plantinga, A. (1974). *The Nature of Necessity*. Oxford University Press.
4. Stalnaker, R. (2003). *Ways a World Might Be*. Oxford University Press.
5. Williamson, T. (2013). *Modal Logic as Metaphysics*. Oxford University Press.

---

**ç›¸å…³æ–‡æ¡£**: 
- [01.1.1 å­˜åœ¨ç†è®º](../01.1.1_å­˜åœ¨ç†è®º.md)
- [01.1.2 å®ä½“ç†è®º](../01.1.2_å®ä½“ç†è®º.md)
- [01.4.1 é€»è¾‘åŸºç¡€](../01.4.1_é€»è¾‘åŸºç¡€.md)
- [02.2.3 æ¨¡æ€é€»è¾‘](../../02_Mathematical_Foundation/02.2.3_æ¨¡æ€é€»è¾‘.md) 