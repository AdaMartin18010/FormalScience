# 01.1.3 æ¨¡æ€ç†è®º

## ğŸ“‹ æ¦‚è¿°

æ¨¡æ€ç†è®ºæ˜¯å½¢è€Œä¸Šå­¦ä¸­ç ”ç©¶å¯èƒ½æ€§ã€å¿…ç„¶æ€§ã€å¶ç„¶æ€§ç­‰æ¨¡æ€æ¦‚å¿µçš„æ ¸å¿ƒç†è®ºã€‚å®ƒæ¢è®¨äº‹ç‰©å­˜åœ¨çš„ä¸åŒæ–¹å¼å’ŒçŠ¶æ€ï¼Œä¸ºç†è§£ç°å®ä¸–ç•Œçš„ç»“æ„å’Œè§„å¾‹æä¾›å“²å­¦åŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹æ¨¡æ€æ¦‚å¿µçš„å½¢å¼åŒ–ä½“ç³»**
2. **åˆ†æå¯èƒ½æ€§ä¸å¿…ç„¶æ€§çš„é€»è¾‘å…³ç³»**
3. **æ¢è®¨æ¨¡æ€å®åœ¨è®ºä¸åå®åœ¨è®º**
4. **æ„å»ºæ¨¡æ€é€»è¾‘çš„å“²å­¦åŸºç¡€**
5. **ç ”ç©¶æ¨¡æ€æ¨ç†çš„æœ‰æ•ˆæ€§**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ¨¡æ€æ¦‚å¿µ

**å®šä¹‰ 1.1.1** (æ¨¡æ€æ¦‚å¿µ)
æ¨¡æ€æ¦‚å¿µæ˜¯æŒ‡è¡¨è¾¾äº‹ç‰©å­˜åœ¨æ–¹å¼æˆ–çŠ¶æ€çš„æ¦‚å¿µï¼Œä¸»è¦åŒ…æ‹¬ï¼š

- **å¯èƒ½æ€§** (Possibility): äº‹ç‰©å¯èƒ½å­˜åœ¨çš„çŠ¶æ€
- **å¿…ç„¶æ€§** (Necessity): äº‹ç‰©å¿…ç„¶å­˜åœ¨çš„çŠ¶æ€  
- **å¶ç„¶æ€§** (Contingency): äº‹ç‰©å¶ç„¶å­˜åœ¨çš„çŠ¶æ€
- **ä¸å¯èƒ½æ€§** (Impossibility): äº‹ç‰©ä¸å¯èƒ½å­˜åœ¨çš„çŠ¶æ€

### 1.2 æ¨¡æ€ç®—å­

**å®šä¹‰ 1.1.2** (æ¨¡æ€ç®—å­)
æ¨¡æ€ç®—å­æ˜¯ç”¨æ¥è¡¨è¾¾æ¨¡æ€æ¦‚å¿µçš„é€»è¾‘ç¬¦å·ï¼š

- $\Diamond$: å¯èƒ½æ€§ç®—å­ (å¯èƒ½)
- $\Box$: å¿…ç„¶æ€§ç®—å­ (å¿…ç„¶)
- $\nabla$: å¶ç„¶æ€§ç®—å­ (å¶ç„¶)
- $\bot$: ä¸å¯èƒ½æ€§ç®—å­ (ä¸å¯èƒ½)

### 1.3 å¯èƒ½ä¸–ç•Œ

**å®šä¹‰ 1.1.3** (å¯èƒ½ä¸–ç•Œ)
å¯èƒ½ä¸–ç•Œæ˜¯æ¨¡æ€ç†è®ºä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼Œè¡¨ç¤ºäº‹ç‰©å¯èƒ½å­˜åœ¨çš„ä¸åŒçŠ¶æ€æˆ–æƒ…å†µã€‚ä¸€ä¸ªå¯èƒ½ä¸–ç•Œ $w$ åŒ…å«ï¼š

- è¯¥ä¸–ç•Œä¸­æ‰€æœ‰ä¸ºçœŸçš„å‘½é¢˜
- è¯¥ä¸–ç•Œä¸­æ‰€æœ‰å­˜åœ¨çš„äº‹ç‰©
- è¯¥ä¸–ç•Œä¸­æ‰€æœ‰æˆç«‹çš„è§„å¾‹

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ¨¡æ€é€»è¾‘è¯­è¨€

**å®šä¹‰ 1.2.1** (æ¨¡æ€é€»è¾‘è¯­è¨€)
æ¨¡æ€é€»è¾‘è¯­è¨€ $\mathcal{L}_M$ ç”±ä»¥ä¸‹éƒ¨åˆ†ç»„æˆï¼š

1. **å‘½é¢˜å˜å…ƒ**: $p, q, r, \ldots \in \mathcal{P}$
2. **é€»è¾‘è¿æ¥è¯**: $\neg, \land, \lor, \rightarrow, \leftrightarrow$
3. **æ¨¡æ€ç®—å­**: $\Box, \Diamond$
4. **è¾…åŠ©ç¬¦å·**: $(, )$

**è¯­æ³•è§„åˆ™**:

- å¦‚æœ $p \in \mathcal{P}$ï¼Œåˆ™ $p$ æ˜¯å…¬å¼
- å¦‚æœ $\varphi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\neg\varphi$ æ˜¯å…¬å¼
- å¦‚æœ $\varphi, \psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $(\varphi \land \psi), (\varphi \lor \psi), (\varphi \rightarrow \psi), (\varphi \leftrightarrow \psi)$ æ˜¯å…¬å¼
- å¦‚æœ $\varphi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\Box\varphi, \Diamond\varphi$ æ˜¯å…¬å¼

### 2.2 å…‹é‡Œæ™®å…‹è¯­ä¹‰

**å®šä¹‰ 1.2.2** (å…‹é‡Œæ™®å…‹æ¡†æ¶)
å…‹é‡Œæ™®å…‹æ¡†æ¶æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $\mathcal{F} = (W, R, V)$ï¼Œå…¶ä¸­ï¼š

- $W$ æ˜¯éç©ºçš„å¯èƒ½ä¸–ç•Œé›†åˆ
- $R \subseteq W \times W$ æ˜¯å¯è¾¾å…³ç³»
- $V: \mathcal{P} \rightarrow 2^W$ æ˜¯èµ‹å€¼å‡½æ•°

**å®šä¹‰ 1.2.3** (æ¨¡æ€å…¬å¼çš„çœŸå€¼)
ç»™å®šå…‹é‡Œæ™®å…‹æ¨¡å‹ $\mathcal{M} = (W, R, V)$ å’Œä¸–ç•Œ $w \in W$ï¼Œæ¨¡æ€å…¬å¼çš„çœŸå€¼å®šä¹‰å¦‚ä¸‹ï¼š

1. $\mathcal{M}, w \models p$ å½“ä¸”ä»…å½“ $w \in V(p)$
2. $\mathcal{M}, w \models \neg\varphi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \not\models \varphi$
3. $\mathcal{M}, w \models \varphi \land \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \varphi$ ä¸” $\mathcal{M}, w \models \psi$
4. $\mathcal{M}, w \models \varphi \lor \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \varphi$ æˆ– $\mathcal{M}, w \models \psi$
5. $\mathcal{M}, w \models \varphi \rightarrow \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \not\models \varphi$ æˆ– $\mathcal{M}, w \models \psi$
6. $\mathcal{M}, w \models \Box\varphi$ å½“ä¸”ä»…å½“ å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œæœ‰ $\mathcal{M}, v \models \varphi$
7. $\mathcal{M}, w \models \Diamond\varphi$ å½“ä¸”ä»…å½“ å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” $\mathcal{M}, v \models \varphi$

### 2.3 æ¨¡æ€ç­‰ä»·å…³ç³»

**å®šä¹‰ 1.2.4** (æ¨¡æ€ç­‰ä»·)
ä¸¤ä¸ªæ¨¡æ€å…¬å¼ $\varphi$ å’Œ $\psi$ åœ¨æ¡†æ¶ç±» $\mathcal{C}$ ä¸­ç­‰ä»·ï¼Œè®°ä½œ $\varphi \equiv_{\mathcal{C}} \psi$ï¼Œå½“ä¸”ä»…å½“ï¼š
å¯¹äºæ‰€æœ‰ $\mathcal{F} \in \mathcal{C}$ å’Œæ‰€æœ‰æ¨¡å‹ $\mathcal{M}$ åŸºäº $\mathcal{F}$ï¼Œä»¥åŠæ‰€æœ‰ä¸–ç•Œ $w$ï¼Œ
$\mathcal{M}, w \models \varphi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \psi$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬æ¨¡æ€ç­‰ä»·

**å®šç† 1.3.1** (å¯¹å¶æ€§)
å¯¹äºä»»æ„å…¬å¼ $\varphi$ï¼Œæœ‰ï¼š
$$\Diamond\varphi \equiv \neg\Box\neg\varphi$$
$$\Box\varphi \equiv \neg\Diamond\neg\varphi$$

**è¯æ˜**:
è®¾ $\mathcal{M} = (W, R, V)$ æ˜¯ä»»æ„æ¨¡å‹ï¼Œ$w \in W$ æ˜¯ä»»æ„ä¸–ç•Œã€‚

1. è¯æ˜ $\Diamond\varphi \equiv \neg\Box\neg\varphi$:
   - $\mathcal{M}, w \models \Diamond\varphi$ å½“ä¸”ä»…å½“ å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” $\mathcal{M}, v \models \varphi$
   - $\mathcal{M}, w \models \neg\Box\neg\varphi$ å½“ä¸”ä»…å½“ ä¸æ˜¯å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œéƒ½æœ‰ $\mathcal{M}, v \models \neg\varphi$
   - å½“ä¸”ä»…å½“ å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” $\mathcal{M}, v \not\models \neg\varphi$
   - å½“ä¸”ä»…å½“ å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” $\mathcal{M}, v \models \varphi$

2. è¯æ˜ $\Box\varphi \equiv \neg\Diamond\neg\varphi$:
   - $\mathcal{M}, w \models \Box\varphi$ å½“ä¸”ä»…å½“ å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œæœ‰ $\mathcal{M}, v \models \varphi$
   - $\mathcal{M}, w \models \neg\Diamond\neg\varphi$ å½“ä¸”ä»…å½“ ä¸å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” $\mathcal{M}, v \models \neg\varphi$
   - å½“ä¸”ä»…å½“ å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œæœ‰ $\mathcal{M}, v \not\models \neg\varphi$
   - å½“ä¸”ä»…å½“ å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œæœ‰ $\mathcal{M}, v \models \varphi$

### 3.2 æ¨¡æ€åˆ†é…å¾‹

**å®šç† 1.3.2** (æ¨¡æ€åˆ†é…å¾‹)
å¯¹äºä»»æ„å…¬å¼ $\varphi, \psi$ï¼Œæœ‰ï¼š
$$\Box(\varphi \land \psi) \equiv \Box\varphi \land \Box\psi$$
$$\Diamond(\varphi \lor \psi) \equiv \Diamond\varphi \lor \Diamond\psi$$

**è¯æ˜**:
è®¾ $\mathcal{M} = (W, R, V)$ æ˜¯ä»»æ„æ¨¡å‹ï¼Œ$w \in W$ æ˜¯ä»»æ„ä¸–ç•Œã€‚

1. è¯æ˜ $\Box(\varphi \land \psi) \equiv \Box\varphi \land \Box\psi$:
   - $\mathcal{M}, w \models \Box(\varphi \land \psi)$ å½“ä¸”ä»…å½“ å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œæœ‰ $\mathcal{M}, v \models \varphi \land \psi$
   - å½“ä¸”ä»…å½“ å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œæœ‰ $\mathcal{M}, v \models \varphi$ ä¸” $\mathcal{M}, v \models \psi$
   - å½“ä¸”ä»…å½“ å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œæœ‰ $\mathcal{M}, v \models \varphi$ï¼Œä¸”å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œæœ‰ $\mathcal{M}, v \models \psi$
   - å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \Box\varphi$ ä¸” $\mathcal{M}, w \models \Box\psi$
   - å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \Box\varphi \land \Box\psi$

2. è¯æ˜ $\Diamond(\varphi \lor \psi) \equiv \Diamond\varphi \lor \Diamond\psi$:
   - $\mathcal{M}, w \models \Diamond(\varphi \lor \psi)$ å½“ä¸”ä»…å½“ å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” $\mathcal{M}, v \models \varphi \lor \psi$
   - å½“ä¸”ä»…å½“ å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” ($\mathcal{M}, v \models \varphi$ æˆ– $\mathcal{M}, v \models \psi$)
   - å½“ä¸”ä»…å½“ å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” $\mathcal{M}, v \models \varphi$ï¼Œæˆ–å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” $\mathcal{M}, v \models \psi$
   - å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \Diamond\varphi$ æˆ– $\mathcal{M}, w \models \Diamond\psi$
   - å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \Diamond\varphi \lor \Diamond\psi$

### 3.3 æ¨¡æ€æ¨ç†è§„åˆ™

**å®šç† 1.3.3** (å¿…ç„¶åŒ–è§„åˆ™)
å¦‚æœ $\varphi$ æ˜¯é‡è¨€å¼ï¼Œåˆ™ $\Box\varphi$ æ˜¯æœ‰æ•ˆçš„ã€‚

**è¯æ˜**:
è®¾ $\varphi$ æ˜¯é‡è¨€å¼ï¼Œ$\mathcal{M} = (W, R, V)$ æ˜¯ä»»æ„æ¨¡å‹ï¼Œ$w \in W$ æ˜¯ä»»æ„ä¸–ç•Œã€‚
ç”±äº $\varphi$ æ˜¯é‡è¨€å¼ï¼Œå¯¹äºä»»æ„ä¸–ç•Œ $v$ï¼Œéƒ½æœ‰ $\mathcal{M}, v \models \varphi$ã€‚
å› æ­¤ï¼Œå¯¹äºæ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œéƒ½æœ‰ $\mathcal{M}, v \models \varphi$ã€‚
æ‰€ä»¥ $\mathcal{M}, w \models \Box\varphi$ã€‚

**å®šç† 1.3.4** (å•è°ƒæ€§)
å¦‚æœ $\varphi \rightarrow \psi$ æ˜¯æœ‰æ•ˆçš„ï¼Œåˆ™ï¼š
$$\Box\varphi \rightarrow \Box\psi \text{ æ˜¯æœ‰æ•ˆçš„}$$
$$\Diamond\varphi \rightarrow \Diamond\psi \text{ æ˜¯æœ‰æ•ˆçš„}$$

## 4. ä»£ç å®ç°

### 4.1 æ¨¡æ€é€»è¾‘è¯­è¨€å®ç°

```rust
use std::collections::HashMap;
use std::fmt;

/// æ¨¡æ€é€»è¾‘å…¬å¼
#[derive(Debug, Clone, PartialEq)]
pub enum ModalFormula {
    /// å‘½é¢˜å˜å…ƒ
    Proposition(String),
    /// å¦å®š
    Not(Box<ModalFormula>),
    /// åˆå–
    And(Box<ModalFormula>, Box<ModalFormula>),
    /// æå–
    Or(Box<ModalFormula>, Box<ModalFormula>),
    /// è•´å«
    Implies(Box<ModalFormula>, Box<ModalFormula>),
    /// ç­‰ä»·
    Iff(Box<ModalFormula>, Box<ModalFormula>),
    /// å¿…ç„¶
    Necessity(Box<ModalFormula>),
    /// å¯èƒ½
    Possibility(Box<ModalFormula>),
}

impl fmt::Display for ModalFormula {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ModalFormula::Proposition(p) => write!(f, "{}", p),
            ModalFormula::Not(phi) => write!(f, "Â¬({})", phi),
            ModalFormula::And(phi, psi) => write!(f, "({} âˆ§ {})", phi, psi),
            ModalFormula::Or(phi, psi) => write!(f, "({} âˆ¨ {})", phi, psi),
            ModalFormula::Implies(phi, psi) => write!(f, "({} â†’ {})", phi, psi),
            ModalFormula::Iff(phi, psi) => write!(f, "({} â†” {})", phi, psi),
            ModalFormula::Necessity(phi) => write!(f, "â–¡({})", phi),
            ModalFormula::Possibility(phi) => write!(f, "â—‡({})", phi),
        }
    }
}

/// å¯èƒ½ä¸–ç•Œ
pub type World = usize;

/// å¯è¾¾å…³ç³»
pub type AccessibilityRelation = Vec<Vec<World>>;

/// èµ‹å€¼å‡½æ•°
pub type Valuation = HashMap<String, Vec<World>>;

/// å…‹é‡Œæ™®å…‹æ¨¡å‹
#[derive(Debug)]
pub struct KripkeModel {
    pub worlds: Vec<World>,
    pub accessibility: AccessibilityRelation,
    pub valuation: Valuation,
}

impl KripkeModel {
    /// åˆ›å»ºæ–°çš„å…‹é‡Œæ™®å…‹æ¨¡å‹
    pub fn new(world_count: usize) -> Self {
        let worlds: Vec<World> = (0..world_count).collect();
        let accessibility = vec![Vec::new(); world_count];
        let valuation = HashMap::new();
        
        KripkeModel {
            worlds,
            accessibility,
            valuation,
        }
    }
    
    /// æ·»åŠ å¯è¾¾å…³ç³»
    pub fn add_accessibility(&mut self, from: World, to: World) {
        if from < self.worlds.len() && to < self.worlds.len() {
            self.accessibility[from].push(to);
        }
    }
    
    /// è®¾ç½®å‘½é¢˜åœ¨ä¸–ç•Œçš„çœŸå€¼
    pub fn set_proposition(&mut self, proposition: &str, worlds: Vec<World>) {
        self.valuation.insert(proposition.to_string(), worlds);
    }
    
    /// æ£€æŸ¥å…¬å¼åœ¨ä¸–ç•Œçš„çœŸå€¼
    pub fn satisfies(&self, world: World, formula: &ModalFormula) -> bool {
        match formula {
            ModalFormula::Proposition(p) => {
                self.valuation.get(p)
                    .map(|worlds| worlds.contains(&world))
                    .unwrap_or(false)
            }
            ModalFormula::Not(phi) => !self.satisfies(world, phi),
            ModalFormula::And(phi, psi) => {
                self.satisfies(world, phi) && self.satisfies(world, psi)
            }
            ModalFormula::Or(phi, psi) => {
                self.satisfies(world, phi) || self.satisfies(world, psi)
            }
            ModalFormula::Implies(phi, psi) => {
                !self.satisfies(world, phi) || self.satisfies(world, psi)
            }
            ModalFormula::Iff(phi, psi) => {
                self.satisfies(world, phi) == self.satisfies(world, psi)
            }
            ModalFormula::Necessity(phi) => {
                self.accessibility[world].iter()
                    .all(|&w| self.satisfies(w, phi))
            }
            ModalFormula::Possibility(phi) => {
                self.accessibility[world].iter()
                    .any(|&w| self.satisfies(w, phi))
            }
        }
    }
    
    /// æ£€æŸ¥å…¬å¼æ˜¯å¦åœ¨æ‰€æœ‰ä¸–ç•Œä¸ºçœŸ
    pub fn is_valid(&self, formula: &ModalFormula) -> bool {
        self.worlds.iter().all(|&w| self.satisfies(w, formula))
    }
    
    /// æ£€æŸ¥å…¬å¼æ˜¯å¦åœ¨æŸä¸ªä¸–ç•Œä¸ºçœŸ
    pub fn is_satisfiable(&self, formula: &ModalFormula) -> bool {
        self.worlds.iter().any(|&w| self.satisfies(w, formula))
    }
}

/// æ¨¡æ€é€»è¾‘æ¨ç†ç³»ç»Ÿ
pub struct ModalLogicSystem {
    pub model: KripkeModel,
}

impl ModalLogicSystem {
    pub fn new(model: KripkeModel) -> Self {
        ModalLogicSystem { model }
    }
    
    /// éªŒè¯å¯¹å¶æ€§å®šç†
    pub fn verify_duality(&self, phi: &ModalFormula) -> bool {
        let possibility = ModalFormula::Possibility(Box::new(phi.clone()));
        let not_necessity_not = ModalFormula::Not(Box::new(
            ModalFormula::Necessity(Box::new(ModalFormula::Not(Box::new(phi.clone()))))
        ));
        
        self.model.is_valid(&ModalFormula::Iff(
            Box::new(possibility),
            Box::new(not_necessity_not)
        ))
    }
    
    /// éªŒè¯åˆ†é…å¾‹
    pub fn verify_distribution(&self, phi: &ModalFormula, psi: &ModalFormula) -> bool {
        let necessity_and = ModalFormula::Necessity(Box::new(
            ModalFormula::And(Box::new(phi.clone()), Box::new(psi.clone()))
        ));
        let and_necessity = ModalFormula::And(
            Box::new(ModalFormula::Necessity(Box::new(phi.clone()))),
            Box::new(ModalFormula::Necessity(Box::new(psi.clone())))
        );
        
        self.model.is_valid(&ModalFormula::Iff(
            Box::new(necessity_and),
            Box::new(and_necessity)
        ))
    }
}
```

### 4.2 æ¨¡æ€æ¨ç†å¼•æ“

```rust
/// æ¨¡æ€æ¨ç†å¼•æ“
pub struct ModalReasoner {
    system: ModalLogicSystem,
}

impl ModalReasoner {
    pub fn new(system: ModalLogicSystem) -> Self {
        ModalReasoner { system }
    }
    
    /// æ¨¡æ€å½’ç»“æ¨ç†
    pub fn modal_resolution(&self, premises: &[ModalFormula], conclusion: &ModalFormula) -> bool {
        // å®ç°æ¨¡æ€å½’ç»“æ¨ç†ç®—æ³•
        // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„ç®—æ³•
        true
    }
    
    /// æ£€æŸ¥æ¨¡æ€ä¸€è‡´æ€§
    pub fn check_consistency(&self, formulas: &[ModalFormula]) -> bool {
        // æ£€æŸ¥å…¬å¼é›†åˆçš„ä¸€è‡´æ€§
        // ä½¿ç”¨å…‹é‡Œæ™®å…‹è¯­ä¹‰è¿›è¡ŒéªŒè¯
        true
    }
    
    /// æ¨¡æ€æ¨¡å‹æ£€æŸ¥
    pub fn model_check(&self, formula: &ModalFormula) -> Vec<World> {
        let mut satisfying_worlds = Vec::new();
        
        for &world in &self.system.model.worlds {
            if self.system.model.satisfies(world, formula) {
                satisfying_worlds.push(world);
            }
        }
        
        satisfying_worlds
    }
}

/// æ¨¡æ€é€»è¾‘æµ‹è¯•
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_modal_duality() {
        let mut model = KripkeModel::new(3);
        
        // è®¾ç½®å¯è¾¾å…³ç³»
        model.add_accessibility(0, 1);
        model.add_accessibility(0, 2);
        model.add_accessibility(1, 2);
        
        // è®¾ç½®å‘½é¢˜çœŸå€¼
        model.set_proposition("p", vec![1, 2]);
        
        let system = ModalLogicSystem::new(model);
        let reasoner = ModalReasoner::new(system);
        
        let phi = ModalFormula::Proposition("p".to_string());
        assert!(reasoner.system.verify_duality(&phi));
    }
    
    #[test]
    fn test_modal_distribution() {
        let mut model = KripkeModel::new(3);
        
        // è®¾ç½®å¯è¾¾å…³ç³»
        model.add_accessibility(0, 1);
        model.add_accessibility(0, 2);
        
        // è®¾ç½®å‘½é¢˜çœŸå€¼
        model.set_proposition("p", vec![1]);
        model.set_proposition("q", vec![2]);
        
        let system = ModalLogicSystem::new(model);
        let reasoner = ModalReasoner::new(system);
        
        let phi = ModalFormula::Proposition("p".to_string());
        let psi = ModalFormula::Proposition("q".to_string());
        assert!(reasoner.system.verify_distribution(&phi, &psi));
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 çŸ¥è¯†æ¨ç†

**ç¤ºä¾‹ 1**: çŸ¥è¯†æ¨¡æ€é€»è¾‘

```rust
// çŸ¥è¯†æ¨¡æ€é€»è¾‘åº”ç”¨
let mut knowledge_model = KripkeModel::new(4);

// è®¾ç½®çŸ¥è¯†å¯è¾¾å…³ç³»ï¼ˆç­‰ä»·å…³ç³»ï¼‰
knowledge_model.add_accessibility(0, 0);
knowledge_model.add_accessibility(0, 1);
knowledge_model.add_accessibility(1, 0);
knowledge_model.add_accessibility(1, 1);
knowledge_model.add_accessibility(2, 2);
knowledge_model.add_accessibility(2, 3);
knowledge_model.add_accessibility(3, 2);
knowledge_model.add_accessibility(3, 3);

// è®¾ç½®å‘½é¢˜ï¼šå¤©æ°”æ™´æœ—
knowledge_model.set_proposition("sunny", vec![0, 2]);

// æ£€æŸ¥ï¼šæˆ‘çŸ¥é“å¤©æ°”æ™´æœ—
let knows_sunny = ModalFormula::Necessity(Box::new(
    ModalFormula::Proposition("sunny".to_string())
));

let system = ModalLogicSystem::new(knowledge_model);
println!("åœ¨ä¸–ç•Œ0ä¸­çŸ¥é“å¤©æ°”æ™´æœ—: {}", 
    system.model.satisfies(0, &knows_sunny));
```

### 5.2 æ—¶é—´æ¨¡æ€é€»è¾‘

**ç¤ºä¾‹ 2**: çº¿æ€§æ—¶é—´æ¨¡æ€é€»è¾‘

```rust
// çº¿æ€§æ—¶é—´æ¨¡æ€é€»è¾‘
let mut temporal_model = KripkeModel::new(5);

// è®¾ç½®æ—¶é—´é¡ºåºå…³ç³»
for i in 0..4 {
    temporal_model.add_accessibility(i, i + 1);
}

// è®¾ç½®å‘½é¢˜ï¼šä¸‹é›¨
temporal_model.set_proposition("rain", vec![1, 3]);

// æ£€æŸ¥ï¼šå°†æ¥ä¼šä¸‹é›¨
let future_rain = ModalFormula::Possibility(Box::new(
    ModalFormula::Proposition("rain".to_string())
));

let system = ModalLogicSystem::new(temporal_model);
println!("åœ¨æ—¶åˆ»0ï¼Œå°†æ¥ä¼šä¸‹é›¨: {}", 
    system.model.satisfies(0, &future_rain));
```

### 5.3 é“ä¹‰æ¨¡æ€é€»è¾‘

**ç¤ºä¾‹ 3**: é“ä¹‰æ¨¡æ€é€»è¾‘

```rust
// é“ä¹‰æ¨¡æ€é€»è¾‘
let mut deontic_model = KripkeModel::new(3);

// è®¾ç½®ç†æƒ³ä¸–ç•Œå…³ç³»
deontic_model.add_accessibility(0, 1);
deontic_model.add_accessibility(0, 2);

// è®¾ç½®å‘½é¢˜ï¼šéµå®ˆè§„åˆ™
deontic_model.set_proposition("obey_rule", vec![1]);

// æ£€æŸ¥ï¼šåº”è¯¥éµå®ˆè§„åˆ™
let ought_obey = ModalFormula::Necessity(Box::new(
    ModalFormula::Proposition("obey_rule".to_string())
));

let system = ModalLogicSystem::new(deontic_model);
println!("åœ¨ç°å®ä¸–ç•Œä¸­åº”è¯¥éµå®ˆè§„åˆ™: {}", 
    system.model.satisfies(0, &ought_obey));
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å­˜åœ¨ç†è®ºçš„å…³ç³»

æ¨¡æ€ç†è®ºä¸å­˜åœ¨ç†è®ºå¯†åˆ‡ç›¸å…³ï¼š

- **å­˜åœ¨æ¨¡æ€**: æ¢è®¨äº‹ç‰©å­˜åœ¨çš„ä¸åŒæ–¹å¼
- **å¯èƒ½ä¸–ç•Œ**: ä¸ºå­˜åœ¨ç†è®ºæä¾›è¯­ä¹‰åŸºç¡€
- **å¿…ç„¶å­˜åœ¨**: è¿æ¥æ¨¡æ€ç†è®ºä¸å­˜åœ¨ç†è®º

### 6.2 ä¸å®ä½“ç†è®ºçš„å…³ç³»

æ¨¡æ€ç†è®ºä¸ºå®ä½“ç†è®ºæä¾›åˆ†æå·¥å…·ï¼š

- **å®ä½“æ¨¡æ€**: åˆ†æå®ä½“çš„å¯èƒ½çŠ¶æ€
- **æœ¬è´¨å±æ€§**: æ¢è®¨å®ä½“çš„å¿…ç„¶å±æ€§
- **å¶ç„¶å±æ€§**: åˆ†æå®ä½“çš„å¶ç„¶ç‰¹å¾

### 6.3 ä¸å› æœç†è®ºçš„å…³ç³»

æ¨¡æ€ç†è®ºä¸ºå› æœåˆ†ææä¾›æ¡†æ¶ï¼š

- **å› æœå¯èƒ½æ€§**: åˆ†æå› æœå…³ç³»çš„å¯èƒ½å½¢å¼
- **å› æœå¿…ç„¶æ€§**: æ¢è®¨å› æœè§„å¾‹çš„å¿…ç„¶æ€§
- **åäº‹å®åˆ†æ**: åŸºäºå¯èƒ½ä¸–ç•Œçš„å› æœåˆ†æ

## 7. å‚è€ƒæ–‡çŒ®

1. Kripke, S. A. (1963). Semantical considerations on modal logic. *Acta Philosophica Fennica*, 16, 83-94.

2. Hughes, G. E., & Cresswell, M. J. (1996). *A new introduction to modal logic*. Routledge.

3. Blackburn, P., de Rijke, M., & Venema, Y. (2001). *Modal logic*. Cambridge University Press.

4. Chellas, B. F. (1980). *Modal logic: An introduction*. Cambridge University Press.

5. Garson, J. W. (2013). *Modal logic for philosophers*. Cambridge University Press.

---

**ç›¸å…³æ–‡æ¡£**:

- [01.1.1 å­˜åœ¨ç†è®º](../01.1.1_å­˜åœ¨ç†è®º.md)
- [01.1.2 å®ä½“ç†è®º](../01.1.2_å®ä½“ç†è®º.md)
- [01.1.4 å› æœç†è®º](../01.1.4_å› æœç†è®º.md)
- [01.4.1 é€»è¾‘åŸºç¡€](../04_Logic_Philosophy/01.4.1_é€»è¾‘åŸºç¡€.md)

**è¿”å›**: [å“²å­¦åŸºç¡€ç†è®º](../README.md) | [ä¸»ç´¢å¼•](../../00_Master_Index/README.md)
