# 01.4.2 æ¨ç†ç†è®º

## ğŸ“‹ æ¦‚è¿°

æ¨ç†ç†è®ºæ˜¯é€»è¾‘å“²å­¦çš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œç ”ç©¶ä»å·²çŸ¥å‰æå¾—å‡ºç»“è®ºçš„æ€ç»´è¿‡ç¨‹ã€‚æœ¬æ–‡æ¡£å»ºç«‹æ¨ç†çš„å½¢å¼åŒ–ç†è®ºï¼ŒåŒ…æ‹¬æ¼”ç»æ¨ç†ã€å½’çº³æ¨ç†ã€ç±»æ¯”æ¨ç†ç­‰å¤šç§æ¨ç†å½¢å¼ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹æ¨ç†çš„å½¢å¼åŒ–ç†è®ºæ¡†æ¶
2. å®šä¹‰å„ç§æ¨ç†ç±»å‹å’Œè§„åˆ™
3. æ„å»ºæ¨ç†æœ‰æ•ˆæ€§çš„åˆ¤å®šæ ‡å‡†
4. æä¾›æ¨ç†è¿‡ç¨‹çš„å½¢å¼åŒ–è¯æ˜
5. å®ç°æ¨ç†ç³»ç»Ÿçš„ç®—æ³•åŒ–

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ¨ç†çš„æœ¬è´¨

æ¨ç†æ˜¯ä»å·²çŸ¥å‘½é¢˜å‡ºå‘ï¼Œé€šè¿‡é€»è¾‘è§„åˆ™æ¨å¯¼å‡ºæ–°å‘½é¢˜çš„æ€ç»´è¿‡ç¨‹ã€‚

**å®šä¹‰ 1.1.1** (æ¨ç†)
æ¨ç†æ˜¯ä»å‰æé›† $\Gamma$ åˆ°ç»“è®º $\phi$ çš„é€»è¾‘æ¨å¯¼è¿‡ç¨‹ï¼Œè®°ä½œ $\Gamma \vdash \phi$ã€‚

### 1.2 æ¨ç†çš„ç±»å‹

**å®šä¹‰ 1.1.2** (æ¼”ç»æ¨ç†)
æ¼”ç»æ¨ç†æ˜¯ä»ä¸€èˆ¬åˆ°ç‰¹æ®Šçš„æ¨ç†ï¼Œå¦‚æœå‰æä¸ºçœŸï¼Œåˆ™ç»“è®ºå¿…ç„¶ä¸ºçœŸã€‚

**å®šä¹‰ 1.1.3** (å½’çº³æ¨ç†)
å½’çº³æ¨ç†æ˜¯ä»ç‰¹æ®Šåˆ°ä¸€èˆ¬çš„æ¨ç†ï¼Œå‰æä¸ºçœŸæ—¶ï¼Œç»“è®ºå¯èƒ½ä¸ºçœŸã€‚

**å®šä¹‰ 1.1.4** (ç±»æ¯”æ¨ç†)
ç±»æ¯”æ¨ç†æ˜¯åŸºäºç›¸ä¼¼æ€§çš„æ¨ç†ï¼Œé€šè¿‡å·²çŸ¥äº‹ç‰©çš„æ€§è´¨æ¨æ–­æœªçŸ¥äº‹ç‰©çš„æ€§è´¨ã€‚

### 1.3 æ¨ç†çš„æœ‰æ•ˆæ€§

**å®šä¹‰ 1.1.5** (æœ‰æ•ˆæ¨ç†)
æ¨ç† $\Gamma \vdash \phi$ æ˜¯æœ‰æ•ˆçš„ï¼Œå½“ä¸”ä»…å½“ $\Gamma \models \phi$ã€‚

**å®šä¹‰ 1.1.6** (å¯é æ¨ç†)
æ¨ç†ç³»ç»Ÿæ˜¯å¯é çš„ï¼Œå½“ä¸”ä»…å½“æ‰€æœ‰å¯æ¨å¯¼çš„ç»“è®ºéƒ½æ˜¯é€»è¾‘è•´å«çš„ã€‚

**å®šä¹‰ 1.1.7** (å®Œå…¨æ¨ç†)
æ¨ç†ç³»ç»Ÿæ˜¯å®Œå…¨çš„ï¼Œå½“ä¸”ä»…å½“æ‰€æœ‰é€»è¾‘è•´å«çš„ç»“è®ºéƒ½æ˜¯å¯æ¨å¯¼çš„ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ¼”ç»æ¨ç†ç³»ç»Ÿ

**å®šä¹‰ 2.1.1** (è‡ªç„¶æ¼”ç»ç³»ç»Ÿ)
è‡ªç„¶æ¼”ç»ç³»ç»ŸåŒ…å«ä»¥ä¸‹æ¨ç†è§„åˆ™ï¼š

1. **å‡è®¾è§„åˆ™**ï¼š$\phi \vdash \phi$
2. **å¼•å…¥è§„åˆ™**ï¼š
   - $\land$-å¼•å…¥ï¼š$\frac{\Gamma \vdash \phi \quad \Delta \vdash \psi}{\Gamma, \Delta \vdash \phi \land \psi}$
   - $\lor$-å¼•å…¥ï¼š$\frac{\Gamma \vdash \phi}{\Gamma \vdash \phi \lor \psi}$
   - $\rightarrow$-å¼•å…¥ï¼š$\frac{\Gamma, \phi \vdash \psi}{\Gamma \vdash \phi \rightarrow \psi}$
3. **æ¶ˆé™¤è§„åˆ™**ï¼š
   - $\land$-æ¶ˆé™¤ï¼š$\frac{\Gamma \vdash \phi \land \psi}{\Gamma \vdash \phi}$
   - $\lor$-æ¶ˆé™¤ï¼š$\frac{\Gamma \vdash \phi \lor \psi \quad \Delta, \phi \vdash \chi \quad \Theta, \psi \vdash \chi}{\Gamma, \Delta, \Theta \vdash \chi}$
   - $\rightarrow$-æ¶ˆé™¤ï¼š$\frac{\Gamma \vdash \phi \rightarrow \psi \quad \Delta \vdash \phi}{\Gamma, \Delta \vdash \psi}$

### 2.2 å½’çº³æ¨ç†ç³»ç»Ÿ

**å®šä¹‰ 2.2.1** (å½’çº³æ¨ç†è§„åˆ™)
å½’çº³æ¨ç†åŸºäºä»¥ä¸‹æ¨¡å¼ï¼š

$$\frac{P(a_1) \land P(a_2) \land \cdots \land P(a_n)}{\forall x P(x)}$$

å…¶ä¸­ $a_1, a_2, \ldots, a_n$ æ˜¯æ ·æœ¬ï¼Œ$P$ æ˜¯å±æ€§ã€‚

**å®šä¹‰ 2.2.2** (å½’çº³å¼ºåº¦)
å½’çº³æ¨ç†çš„å¼ºåº¦å®šä¹‰ä¸ºï¼š

$$\text{Strength}(\Gamma, \phi) = \frac{|\{v : \overline{v}(\psi) = \top \text{ for all } \psi \in \Gamma \text{ and } \overline{v}(\phi) = \top\}|}{|\{v : \overline{v}(\psi) = \top \text{ for all } \psi \in \Gamma\}|}$$

### 2.3 ç±»æ¯”æ¨ç†ç³»ç»Ÿ

**å®šä¹‰ 2.3.1** (ç±»æ¯”å…³ç³»)
ç±»æ¯”å…³ç³»æ˜¯å››å…ƒç»„ $(S, T, f, g)$ï¼Œå…¶ä¸­ï¼š
- $S$ æ˜¯æºåŸŸ
- $T$ æ˜¯ç›®æ ‡åŸŸ
- $f$ æ˜¯æºåŸŸåˆ°ç›®æ ‡åŸŸçš„æ˜ å°„
- $g$ æ˜¯å±æ€§æ˜ å°„

**å®šä¹‰ 2.3.2** (ç±»æ¯”æ¨ç†è§„åˆ™)
å¦‚æœ $(S, T, f, g)$ æ˜¯ç±»æ¯”å…³ç³»ï¼Œä¸” $P(s)$ åœ¨æºåŸŸæˆç«‹ï¼Œåˆ™ $g(P)(f(s))$ åœ¨ç›®æ ‡åŸŸå¯èƒ½æˆç«‹ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 æ¼”ç»æ¨ç†å®šç†

**å®šç† 3.1.1** (æ¼”ç»æ¨ç†çš„å¯é æ€§)
å¦‚æœ $\Gamma \vdash \phi$ï¼Œåˆ™ $\Gamma \models \phi$ã€‚

**è¯æ˜**ï¼š
é€šè¿‡ç»“æ„å½’çº³æ³•è¯æ˜æ¯ä¸ªæ¨ç†è§„åˆ™éƒ½ä¿æŒé€»è¾‘æœ‰æ•ˆæ€§ã€‚

**å®šç† 3.1.2** (æ¼”ç»æ¨ç†çš„å®Œå…¨æ€§)
å¦‚æœ $\Gamma \models \phi$ï¼Œåˆ™ $\Gamma \vdash \phi$ã€‚

**è¯æ˜**ï¼š
ä½¿ç”¨æå¤§ä¸€è‡´é›†æ„é€ æ¨¡å‹ï¼Œè¯æ˜æ¯ä¸ªé€»è¾‘è•´å«çš„ç»“è®ºéƒ½æ˜¯å¯æ¨å¯¼çš„ã€‚

### 3.2 å½’çº³æ¨ç†å®šç†

**å®šç† 3.2.1** (å½’çº³æ¨ç†çš„æˆ–ç„¶æ€§)
å½’çº³æ¨ç†çš„ç»“è®ºä¸æ˜¯å¿…ç„¶çš„ï¼Œè€Œæ˜¯æˆ–ç„¶çš„ã€‚

**è¯æ˜**ï¼š
æ„é€ åä¾‹ï¼Œè¯´æ˜å³ä½¿æ‰€æœ‰å‰æä¸ºçœŸï¼Œç»“è®ºä¹Ÿå¯èƒ½ä¸ºå‡ã€‚

**å®šç† 3.2.2** (å½’çº³æ¨ç†çš„æ”¶æ•›æ€§)
åœ¨é€‚å½“æ¡ä»¶ä¸‹ï¼Œå½’çº³æ¨ç†çš„å¼ºåº¦éšç€æ ·æœ¬å¢åŠ è€Œæ”¶æ•›ã€‚

**è¯æ˜**ï¼š
ä½¿ç”¨å¤§æ•°å®šå¾‹è¯æ˜å½’çº³æ¨ç†çš„ç»Ÿè®¡æ”¶æ•›æ€§ã€‚

### 3.3 ç±»æ¯”æ¨ç†å®šç†

**å®šç† 3.3.1** (ç±»æ¯”æ¨ç†çš„ç›¸ä¼¼æ€§åŸç†)
ç±»æ¯”æ¨ç†çš„æœ‰æ•ˆæ€§å–å†³äºæºåŸŸå’Œç›®æ ‡åŸŸçš„ç›¸ä¼¼ç¨‹åº¦ã€‚

**å®šç† 3.3.2** (ç±»æ¯”æ¨ç†çš„ä¼ é€’æ€§)
å¦‚æœ $A$ ä¸ $B$ ç›¸ä¼¼ï¼Œ$B$ ä¸ $C$ ç›¸ä¼¼ï¼Œåˆ™ $A$ ä¸ $C$ ä¹Ÿå¯èƒ½ç›¸ä¼¼ã€‚

## 4. ä»£ç å®ç°

### 4.1 æ¨ç†ç³»ç»ŸåŸºç¡€ç»“æ„

```rust
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone, PartialEq)]
pub enum InferenceRule {
    Assumption,
    AndIntroduction,
    AndElimination,
    OrIntroduction,
    OrElimination,
    ImplicationIntroduction,
    ImplicationElimination,
    Induction,
    Analogy,
}

#[derive(Debug, Clone)]
pub struct Inference {
    premises: Vec<Proposition>,
    conclusion: Proposition,
    rule: InferenceRule,
    justification: String,
}

#[derive(Debug, Clone)]
pub struct InferenceSystem {
    rules: HashMap<InferenceRule, Box<dyn InferenceRuleHandler>>,
    proofs: Vec<Inference>,
}

trait InferenceRuleHandler {
    fn apply(&self, premises: &[Proposition]) -> Option<Proposition>;
    fn is_valid(&self, premises: &[Proposition], conclusion: &Proposition) -> bool;
}
```

### 4.2 æ¼”ç»æ¨ç†å®ç°

```rust
pub struct DeductiveInference;

impl InferenceRuleHandler for DeductiveInference {
    fn apply(&self, premises: &[Proposition]) -> Option<Proposition> {
        if premises.len() == 2 {
            // å‡è¨€æ¨ç†
            if let (Proposition::Implication(antecedent, consequent), premise) = 
                (&premises[0], &premises[1]) {
                if premise == antecedent.as_ref() {
                    return Some(*consequent.clone());
                }
            }
        }
        None
    }
    
    fn is_valid(&self, premises: &[Proposition], conclusion: &Proposition) -> bool {
        // æ£€æŸ¥é€»è¾‘è•´å«
        let variables = Self::extract_variables(premises, conclusion);
        LogicValidator::implies(premises, conclusion, &variables)
    }
}

impl DeductiveInference {
    pub fn modus_ponens(premise1: &Proposition, premise2: &Proposition) -> Option<Proposition> {
        if let Proposition::Implication(antecedent, consequent) = premise2 {
            if premise1 == antecedent.as_ref() {
                return Some(*consequent.clone());
            }
        }
        None
    }
    
    pub fn modus_tollens(premise1: &Proposition, premise2: &Proposition) -> Option<Proposition> {
        if let (Proposition::Negation(consequent), Proposition::Implication(antecedent, _)) = 
            (premise1, premise2) {
            return Some(Proposition::Negation(Box::new(*antecedent.clone())));
        }
        None
    }
    
    fn extract_variables(premises: &[Proposition], conclusion: &Proposition) -> Vec<String> {
        let mut variables = HashSet::new();
        for premise in premises {
            Self::collect_variables(premise, &mut variables);
        }
        Self::collect_variables(conclusion, &mut variables);
        variables.into_iter().collect()
    }
    
    fn collect_variables(prop: &Proposition, variables: &mut HashSet<String>) {
        match prop {
            Proposition::Variable(name) => { variables.insert(name.clone()); }
            Proposition::Negation(inner) => Self::collect_variables(inner, variables),
            Proposition::Conjunction(left, right) => {
                Self::collect_variables(left, variables);
                Self::collect_variables(right, variables);
            }
            Proposition::Disjunction(left, right) => {
                Self::collect_variables(left, variables);
                Self::collect_variables(right, variables);
            }
            Proposition::Implication(antecedent, consequent) => {
                Self::collect_variables(antecedent, variables);
                Self::collect_variables(consequent, variables);
            }
            Proposition::Equivalence(left, right) => {
                Self::collect_variables(left, variables);
                Self::collect_variables(right, variables);
            }
        }
    }
}
```

### 4.3 å½’çº³æ¨ç†å®ç°

```rust
pub struct InductiveInference;

impl InferenceRuleHandler for InductiveInference {
    fn apply(&self, premises: &[Proposition]) -> Option<Proposition> {
        // ä»å…·ä½“å®ä¾‹å½’çº³å‡ºä¸€èˆ¬è§„å¾‹
        if let Some(pattern) = Self::find_pattern(premises) {
            return Some(pattern);
        }
        None
    }
    
    fn is_valid(&self, premises: &[Proposition], conclusion: &Proposition) -> bool {
        // å½’çº³æ¨ç†ä¸æ˜¯é€»è¾‘æœ‰æ•ˆçš„ï¼Œä½†å¯ä»¥è®¡ç®—å¼ºåº¦
        let strength = Self::calculate_strength(premises, conclusion);
        strength > 0.5 // å¼ºåº¦é˜ˆå€¼
    }
}

impl InductiveInference {
    pub fn calculate_strength(premises: &[Proposition], conclusion: &Proposition) -> f64 {
        let variables = DeductiveInference::extract_variables(premises, conclusion);
        let total_assignments = 1 << variables.len();
        let mut valid_assignments = 0;
        
        for i in 0..total_assignments {
            let mut assignment = TruthAssignment::new();
            for (j, var) in variables.iter().enumerate() {
                assignment.set(var, (i >> j) & 1 == 1);
            }
            
            let all_premises_true = premises.iter()
                .all(|premise| premise.evaluate(&assignment));
            
            if all_premises_true && conclusion.evaluate(&assignment) {
                valid_assignments += 1;
            }
        }
        
        valid_assignments as f64 / total_assignments as f64
    }
    
    fn find_pattern(premises: &[Proposition]) -> Option<Proposition> {
        // ç®€åŒ–çš„æ¨¡å¼è¯†åˆ«
        if premises.is_empty() {
            return None;
        }
        
        // å¯»æ‰¾å…±åŒå±æ€§
        let mut common_properties = Vec::new();
        for premise in premises {
            if let Some(prop) = Self::extract_property(premise) {
                common_properties.push(prop);
            }
        }
        
        if !common_properties.is_empty() {
            // æ„é€ ä¸€èˆ¬åŒ–ç»“è®º
            return Some(Proposition::Variable(format!("âˆ€x P(x)")));
        }
        
        None
    }
    
    fn extract_property(premise: &Proposition) -> Option<String> {
        // ç®€åŒ–çš„å±æ€§æå–
        match premise {
            Proposition::Variable(name) => Some(name.clone()),
            _ => None,
        }
    }
}
```

### 4.4 ç±»æ¯”æ¨ç†å®ç°

```rust
#[derive(Debug, Clone)]
pub struct AnalogyMapping {
    source_domain: HashMap<String, String>,
    target_domain: HashMap<String, String>,
    property_mapping: HashMap<String, String>,
}

pub struct AnalogyInference;

impl InferenceRuleHandler for AnalogyInference {
    fn apply(&self, premises: &[Proposition]) -> Option<Proposition> {
        // åŸºäºç±»æ¯”æ˜ å°„æ¨å¯¼ç»“è®º
        if let Some(mapping) = Self::extract_mapping(premises) {
            return Self::apply_mapping(&mapping, premises);
        }
        None
    }
    
    fn is_valid(&self, premises: &[Proposition], conclusion: &Proposition) -> bool {
        // ç±»æ¯”æ¨ç†çš„æœ‰æ•ˆæ€§åŸºäºç›¸ä¼¼æ€§
        let similarity = Self::calculate_similarity(premises, conclusion);
        similarity > 0.7 // ç›¸ä¼¼æ€§é˜ˆå€¼
    }
}

impl AnalogyInference {
    pub fn calculate_similarity(premises: &[Proposition], conclusion: &Proposition) -> f64 {
        // è®¡ç®—æºåŸŸå’Œç›®æ ‡åŸŸçš„ç›¸ä¼¼æ€§
        let source_features = Self::extract_features(premises);
        let target_features = Self::extract_features(&[conclusion.clone()]);
        
        let intersection = source_features.intersection(&target_features).count();
        let union = source_features.union(&target_features).count();
        
        intersection as f64 / union as f64
    }
    
    fn extract_features(propositions: &[Proposition]) -> HashSet<String> {
        let mut features = HashSet::new();
        for prop in propositions {
            Self::collect_features(prop, &mut features);
        }
        features
    }
    
    fn collect_features(prop: &Proposition, features: &mut HashSet<String>) {
        match prop {
            Proposition::Variable(name) => { features.insert(name.clone()); }
            Proposition::Negation(inner) => Self::collect_features(inner, features),
            Proposition::Conjunction(left, right) => {
                Self::collect_features(left, features);
                Self::collect_features(right, features);
            }
            Proposition::Disjunction(left, right) => {
                Self::collect_features(left, features);
                Self::collect_features(right, features);
            }
            Proposition::Implication(antecedent, consequent) => {
                Self::collect_features(antecedent, features);
                Self::collect_features(consequent, features);
            }
            Proposition::Equivalence(left, right) => {
                Self::collect_features(left, features);
                Self::collect_features(right, features);
            }
        }
    }
    
    fn extract_mapping(premises: &[Proposition]) -> Option<AnalogyMapping> {
        // ç®€åŒ–çš„æ˜ å°„æå–
        let mut mapping = AnalogyMapping {
            source_domain: HashMap::new(),
            target_domain: HashMap::new(),
            property_mapping: HashMap::new(),
        };
        
        // è¿™é‡Œåº”è¯¥å®ç°æ›´å¤æ‚çš„æ˜ å°„æå–ç®—æ³•
        Some(mapping)
    }
    
    fn apply_mapping(mapping: &AnalogyMapping, premises: &[Proposition]) -> Option<Proposition> {
        // åº”ç”¨ç±»æ¯”æ˜ å°„æ¨å¯¼ç»“è®º
        // è¿™é‡Œåº”è¯¥å®ç°æ˜ å°„åº”ç”¨ç®—æ³•
        None
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 æ¼”ç»æ¨ç†ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_deductive_inference() {
        let p = Proposition::Variable("p".to_string());
        let q = Proposition::Variable("q".to_string());
        let implication = Proposition::Implication(Box::new(p.clone()), Box::new(q.clone()));
        
        let premises = vec![p, implication];
        let conclusion = q;
        
        assert!(DeductiveInference::is_valid(&premises, &conclusion));
        
        let result = DeductiveInference::modus_ponens(&premises[0], &premises[1]);
        assert_eq!(result, Some(conclusion));
    }
    
    #[test]
    fn test_inductive_inference() {
        let p1 = Proposition::Variable("P(a1)".to_string());
        let p2 = Proposition::Variable("P(a2)".to_string());
        let p3 = Proposition::Variable("P(a3)".to_string());
        
        let premises = vec![p1, p2, p3];
        let conclusion = Proposition::Variable("âˆ€x P(x)".to_string());
        
        let strength = InductiveInference::calculate_strength(&premises, &conclusion);
        assert!(strength > 0.0);
    }
    
    #[test]
    fn test_analogy_inference() {
        let source = Proposition::Variable("åœ°çƒæœ‰ç”Ÿå‘½".to_string());
        let target = Proposition::Variable("ç«æ˜Ÿæœ‰ç”Ÿå‘½".to_string());
        
        let premises = vec![source];
        let conclusion = target;
        
        let similarity = AnalogyInference::calculate_similarity(&premises, &conclusion);
        assert!(similarity > 0.0);
    }
}
```

### 5.2 å¤æ‚æ¨ç†ç¤ºä¾‹

```rust
#[test]
fn test_complex_inference() {
    // æ„å»ºå¤æ‚æ¨ç†é“¾
    let p = Proposition::Variable("p".to_string());
    let q = Proposition::Variable("q".to_string());
    let r = Proposition::Variable("r".to_string());
    
    let step1 = Proposition::Implication(Box::new(p.clone()), Box::new(q.clone()));
    let step2 = Proposition::Implication(Box::new(q), Box::new(r.clone()));
    
    // æ¼”ç»æ¨ç†ï¼šä¸‰æ®µè®º
    let premises = vec![p, step1, step2];
    let conclusion = r;
    
    assert!(DeductiveInference::is_valid(&premises, &conclusion));
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸é€»è¾‘åŸºç¡€çš„å…³ç³»

æ¨ç†ç†è®ºå»ºç«‹åœ¨é€»è¾‘åŸºç¡€ä¹‹ä¸Šï¼Œä½¿ç”¨é€»è¾‘è§„åˆ™è¿›è¡Œæ¨ç†ã€‚

### 6.2 ä¸è¯æ˜ç†è®ºçš„å…³ç³»

æ¨ç†ç†è®ºä¸ºè¯æ˜ç†è®ºæä¾›æ¨ç†è§„åˆ™å’Œæ–¹æ³•ã€‚

### 6.3 ä¸äººå·¥æ™ºèƒ½çš„å…³ç³»

æ¨ç†ç†è®ºä¸ºäººå·¥æ™ºèƒ½çš„æ¨ç†ç³»ç»Ÿæä¾›ç†è®ºåŸºç¡€ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Copi, I. M., Cohen, C., & McMahon, K. (2016). Introduction to Logic. Routledge.
2. Hurley, P. J. (2018). A Concise Introduction to Logic. Cengage Learning.
3. Salmon, W. C. (2006). Logic. Prentice Hall.
4. é‡‘å²³éœ–. (2005). é€»è¾‘. å•†åŠ¡å°ä¹¦é¦†.
5. å‘¨ç¤¼å…¨. (1994). é€»è¾‘. äººæ°‘å‡ºç‰ˆç¤¾.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [01.4.1 é€»è¾‘åŸºç¡€](../01.4.1_é€»è¾‘åŸºç¡€.md)
- [01.4.3 è¯æ˜ç†è®º](../01.4.3_è¯æ˜ç†è®º.md)
- [01.4.4 é€»è¾‘å“²å­¦](../01.4.4_é€»è¾‘å“²å­¦.md)
- [02.2.1 å‘½é¢˜é€»è¾‘](../../02_Mathematical_Foundation/02.2.1_å‘½é¢˜é€»è¾‘.md)
- [02.2.2 è°“è¯é€»è¾‘](../../02_Mathematical_Foundation/02.2.2_è°“è¯é€»è¾‘.md) 