# 01.4.1 é€»è¾‘åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

é€»è¾‘åŸºç¡€æ˜¯å“²å­¦è®¤è¯†è®ºçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œç ”ç©¶æ¨ç†çš„æœ‰æ•ˆæ€§ã€è®ºè¯çš„ç»“æ„å’Œæ€ç»´çš„å½¢å¼è§„å¾‹ã€‚æœ¬æ–‡æ¡£å»ºç«‹é€»è¾‘çš„å½¢å¼åŒ–åŸºç¡€ï¼Œä¸ºåç»­çš„é€»è¾‘ç†è®ºæä¾›ä¸¥æ ¼çš„æ•°å­¦æ¡†æ¶ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹é€»è¾‘çš„å½¢å¼åŒ–åŸºç¡€
2. å®šä¹‰é€»è¾‘æ¨ç†çš„åŸºæœ¬æ¦‚å¿µ
3. æ„å»ºé€»è¾‘ç³»ç»Ÿçš„å…¬ç†åŒ–æ¡†æ¶
4. æä¾›é€»è¾‘æ¨ç†çš„å½¢å¼åŒ–è¯æ˜
5. å®ç°é€»è¾‘æ¨ç†çš„ç®—æ³•åŒ–

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 é€»è¾‘çš„æœ¬è´¨

é€»è¾‘æ˜¯ç ”ç©¶æ¨ç†æœ‰æ•ˆæ€§çš„ç§‘å­¦ï¼Œå…³æ³¨ä»å‰æå¾—å‡ºç»“è®ºçš„åˆç†æ€§ã€‚

**å®šä¹‰ 1.1.1** (é€»è¾‘æ¨ç†)
é€»è¾‘æ¨ç†æ˜¯ä»å·²çŸ¥å‘½é¢˜å‡ºå‘ï¼Œé€šè¿‡é€»è¾‘è§„åˆ™æ¨å¯¼å‡ºæ–°å‘½é¢˜çš„è¿‡ç¨‹ã€‚

### 1.2 å‘½é¢˜ä¸çœŸå€¼

**å®šä¹‰ 1.1.2** (å‘½é¢˜)
å‘½é¢˜æ˜¯å…·æœ‰ç¡®å®šçœŸå€¼çš„é™ˆè¿°å¥ï¼Œç”¨ç¬¦å· $p, q, r$ ç­‰è¡¨ç¤ºã€‚

**å®šä¹‰ 1.1.3** (çœŸå€¼)
çœŸå€¼æ˜¯å‘½é¢˜çš„å±æ€§ï¼Œå–å€¼ä¸ºçœŸ($\top$)æˆ–å‡($\bot$)ã€‚

### 1.3 é€»è¾‘è¿æ¥è¯

**å®šä¹‰ 1.1.4** (é€»è¾‘è¿æ¥è¯)
é€»è¾‘è¿æ¥è¯æ˜¯è¿æ¥å‘½é¢˜å½¢æˆå¤åˆå‘½é¢˜çš„é€»è¾‘è¿ç®—ç¬¦ï¼š

- å¦å®šï¼š$\neg p$ (ép)
- åˆå–ï¼š$p \land q$ (pä¸”q)
- æå–ï¼š$p \lor q$ (pæˆ–q)
- è•´å«ï¼š$p \rightarrow q$ (å¦‚æœpåˆ™q)
- ç­‰ä»·ï¼š$p \leftrightarrow q$ (på½“ä¸”ä»…å½“q)

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å‘½é¢˜é€»è¾‘è¯­è¨€

**å®šä¹‰ 2.1.1** (å‘½é¢˜é€»è¾‘è¯­è¨€)
å‘½é¢˜é€»è¾‘è¯­è¨€ $\mathcal{L}$ ç”±ä»¥ä¸‹éƒ¨åˆ†ç»„æˆï¼š

1. **å‘½é¢˜å˜å…ƒé›†**ï¼š$\mathcal{P} = \{p_1, p_2, p_3, \ldots\}$
2. **é€»è¾‘è¿æ¥è¯**ï¼š$\{\neg, \land, \lor, \rightarrow, \leftrightarrow\}$
3. **è¾…åŠ©ç¬¦å·**ï¼š$\{(, )\}$

**å®šä¹‰ 2.1.2** (åˆå¼å…¬å¼)
åˆå¼å…¬å¼(WFF)é€’å½’å®šä¹‰å¦‚ä¸‹ï¼š

1. æ¯ä¸ªå‘½é¢˜å˜å…ƒ $p \in \mathcal{P}$ æ˜¯åˆå¼å…¬å¼
2. å¦‚æœ $\phi$ æ˜¯åˆå¼å…¬å¼ï¼Œåˆ™ $\neg \phi$ æ˜¯åˆå¼å…¬å¼
3. å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯åˆå¼å…¬å¼ï¼Œåˆ™ $(\phi \land \psi)$ã€$(\phi \lor \psi)$ã€$(\phi \rightarrow \psi)$ã€$(\phi \leftrightarrow \psi)$ æ˜¯åˆå¼å…¬å¼
4. åªæœ‰é€šè¿‡ä¸Šè¿°è§„åˆ™æ„é€ çš„è¡¨è¾¾å¼æ‰æ˜¯åˆå¼å…¬å¼

### 2.2 çœŸå€¼èµ‹å€¼

**å®šä¹‰ 2.2.1** (çœŸå€¼èµ‹å€¼)
çœŸå€¼èµ‹å€¼æ˜¯ä»å‘½é¢˜å˜å…ƒé›†åˆ°çœŸå€¼é›†çš„å‡½æ•°ï¼š
$$v: \mathcal{P} \rightarrow \{\top, \bot\}$$

**å®šä¹‰ 2.2.2** (çœŸå€¼å‡½æ•°)
çœŸå€¼å‡½æ•° $\overline{v}$ é€’å½’å®šä¹‰å¦‚ä¸‹ï¼š

1. $\overline{v}(p) = v(p)$ å¯¹æ‰€æœ‰ $p \in \mathcal{P}$
2. $\overline{v}(\neg \phi) = \top$ å½“ä¸”ä»…å½“ $\overline{v}(\phi) = \bot$
3. $\overline{v}(\phi \land \psi) = \top$ å½“ä¸”ä»…å½“ $\overline{v}(\phi) = \top$ ä¸” $\overline{v}(\psi) = \top$
4. $\overline{v}(\phi \lor \psi) = \top$ å½“ä¸”ä»…å½“ $\overline{v}(\phi) = \top$ æˆ– $\overline{v}(\psi) = \top$
5. $\overline{v}(\phi \rightarrow \psi) = \top$ å½“ä¸”ä»…å½“ $\overline{v}(\phi) = \bot$ æˆ– $\overline{v}(\psi) = \top$
6. $\overline{v}(\phi \leftrightarrow \psi) = \top$ å½“ä¸”ä»…å½“ $\overline{v}(\phi) = \overline{v}(\psi)$

### 2.3 é€»è¾‘æœ‰æ•ˆæ€§

**å®šä¹‰ 2.3.1** (é‡è¨€å¼)
å…¬å¼ $\phi$ æ˜¯é‡è¨€å¼ï¼Œå½“ä¸”ä»…å½“å¯¹æ‰€æœ‰çœŸå€¼èµ‹å€¼ $v$ï¼Œéƒ½æœ‰ $\overline{v}(\phi) = \top$ã€‚

**å®šä¹‰ 2.3.2** (çŸ›ç›¾å¼)
å…¬å¼ $\phi$ æ˜¯çŸ›ç›¾å¼ï¼Œå½“ä¸”ä»…å½“å¯¹æ‰€æœ‰çœŸå€¼èµ‹å€¼ $v$ï¼Œéƒ½æœ‰ $\overline{v}(\phi) = \bot$ã€‚

**å®šä¹‰ 2.3.3** (å¯æ»¡è¶³å¼)
å…¬å¼ $\phi$ æ˜¯å¯æ»¡è¶³å¼ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨çœŸå€¼èµ‹å€¼ $v$ï¼Œä½¿å¾— $\overline{v}(\phi) = \top$ã€‚

**å®šä¹‰ 2.3.4** (é€»è¾‘è•´å«)
å…¬å¼é›† $\Gamma$ é€»è¾‘è•´å«å…¬å¼ $\phi$ï¼Œè®°ä½œ $\Gamma \models \phi$ï¼Œå½“ä¸”ä»…å½“å¯¹æ‰€æœ‰çœŸå€¼èµ‹å€¼ $v$ï¼Œå¦‚æœ $\overline{v}(\psi) = \top$ å¯¹æ‰€æœ‰ $\psi \in \Gamma$ï¼Œåˆ™ $\overline{v}(\phi) = \top$ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬é€»è¾‘å®šç†

**å®šç† 3.1.1** (åŒé‡å¦å®šå¾‹)
$$\models \neg \neg \phi \leftrightarrow \phi$$

**è¯æ˜**ï¼š
è®¾ $v$ ä¸ºä»»æ„çœŸå€¼èµ‹å€¼ã€‚

- å¦‚æœ $\overline{v}(\phi) = \top$ï¼Œåˆ™ $\overline{v}(\neg \phi) = \bot$ï¼Œ$\overline{v}(\neg \neg \phi) = \top$
- å¦‚æœ $\overline{v}(\phi) = \bot$ï¼Œåˆ™ $\overline{v}(\neg \phi) = \top$ï¼Œ$\overline{v}(\neg \neg \phi) = \bot$
å› æ­¤ $\overline{v}(\neg \neg \phi) = \overline{v}(\phi)$ï¼Œå³ $\overline{v}(\neg \neg \phi \leftrightarrow \phi) = \top$ã€‚

**å®šç† 3.1.2** (å¾·æ‘©æ ¹å¾‹)
$$\models \neg(\phi \land \psi) \leftrightarrow (\neg \phi \lor \neg \psi)$$
$$\models \neg(\phi \lor \psi) \leftrightarrow (\neg \phi \land \neg \psi)$$

**å®šç† 3.1.3** (åˆ†é…å¾‹)
$$\models \phi \land (\psi \lor \chi) \leftrightarrow (\phi \land \psi) \lor (\phi \land \chi)$$
$$\models \phi \lor (\psi \land \chi) \leftrightarrow (\phi \lor \psi) \land (\phi \lor \chi)$$

### 3.2 æ¨ç†è§„åˆ™

**å®šç† 3.2.1** (å‡è¨€æ¨ç†)
$$\{\phi, \phi \rightarrow \psi\} \models \psi$$

**è¯æ˜**ï¼š
è®¾ $v$ ä¸ºä»»æ„çœŸå€¼èµ‹å€¼ï¼Œä½¿å¾— $\overline{v}(\phi) = \top$ ä¸” $\overline{v}(\phi \rightarrow \psi) = \top$ã€‚
ç”±è•´å«å®šä¹‰ï¼Œ$\overline{v}(\phi \rightarrow \psi) = \top$ æ„å‘³ç€ $\overline{v}(\phi) = \bot$ æˆ– $\overline{v}(\psi) = \top$ã€‚
ç”±äº $\overline{v}(\phi) = \top$ï¼Œæ‰€ä»¥ $\overline{v}(\psi) = \top$ã€‚

**å®šç† 3.2.2** (åè¯æ³•)
å¦‚æœ $\Gamma \cup \{\neg \phi\} \models \bot$ï¼Œåˆ™ $\Gamma \models \phi$ã€‚

**å®šç† 3.2.3** (å½’è°¬æ³•)
å¦‚æœ $\Gamma \cup \{\phi\} \models \bot$ï¼Œåˆ™ $\Gamma \models \neg \phi$ã€‚

### 3.3 é€»è¾‘ç­‰ä»·æ€§

**å®šä¹‰ 3.3.1** (é€»è¾‘ç­‰ä»·)
å…¬å¼ $\phi$ å’Œ $\psi$ é€»è¾‘ç­‰ä»·ï¼Œè®°ä½œ $\phi \equiv \psi$ï¼Œå½“ä¸”ä»…å½“ $\models \phi \leftrightarrow \psi$ã€‚

**å®šç† 3.3.1** (ç­‰ä»·å…³ç³»çš„æ€§è´¨)
é€»è¾‘ç­‰ä»·å…³ç³»å…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼š

1. è‡ªåæ€§ï¼š$\phi \equiv \phi$
2. å¯¹ç§°æ€§ï¼šå¦‚æœ $\phi \equiv \psi$ï¼Œåˆ™ $\psi \equiv \phi$
3. ä¼ é€’æ€§ï¼šå¦‚æœ $\phi \equiv \psi$ ä¸” $\psi \equiv \chi$ï¼Œåˆ™ $\phi \equiv \chi$

## 4. ä»£ç å®ç°

### 4.1 å‘½é¢˜é€»è¾‘æ•°æ®ç»“æ„

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub enum Proposition {
    Variable(String),
    Negation(Box<Proposition>),
    Conjunction(Box<Proposition>, Box<Proposition>),
    Disjunction(Box<Proposition>, Box<Proposition>),
    Implication(Box<Proposition>, Box<Proposition>),
    Equivalence(Box<Proposition>, Box<Proposition>),
}

#[derive(Debug, Clone)]
pub struct TruthAssignment {
    values: HashMap<String, bool>,
}

impl TruthAssignment {
    pub fn new() -> Self {
        Self {
            values: HashMap::new(),
        }
    }
    
    pub fn set(&mut self, variable: &str, value: bool) {
        self.values.insert(variable.to_string(), value);
    }
    
    pub fn get(&self, variable: &str) -> bool {
        self.values.get(variable).copied().unwrap_or(false)
    }
}
```

### 4.2 çœŸå€¼è®¡ç®—

```rust
impl Proposition {
    pub fn evaluate(&self, assignment: &TruthAssignment) -> bool {
        match self {
            Proposition::Variable(name) => assignment.get(name),
            Proposition::Negation(prop) => !prop.evaluate(assignment),
            Proposition::Conjunction(left, right) => {
                left.evaluate(assignment) && right.evaluate(assignment)
            }
            Proposition::Disjunction(left, right) => {
                left.evaluate(assignment) || right.evaluate(assignment)
            }
            Proposition::Implication(antecedent, consequent) => {
                !antecedent.evaluate(assignment) || consequent.evaluate(assignment)
            }
            Proposition::Equivalence(left, right) => {
                left.evaluate(assignment) == right.evaluate(assignment)
            }
        }
    }
}
```

### 4.3 é€»è¾‘éªŒè¯

```rust
pub struct LogicValidator;

impl LogicValidator {
    /// æ£€æŸ¥å…¬å¼æ˜¯å¦ä¸ºé‡è¨€å¼
    pub fn is_tautology(prop: &Proposition, variables: &[String]) -> bool {
        Self::check_all_assignments(prop, variables, |assignment| {
            prop.evaluate(assignment)
        })
    }
    
    /// æ£€æŸ¥å…¬å¼æ˜¯å¦ä¸ºçŸ›ç›¾å¼
    pub fn is_contradiction(prop: &Proposition, variables: &[String]) -> bool {
        Self::check_all_assignments(prop, variables, |assignment| {
            !prop.evaluate(assignment)
        })
    }
    
    /// æ£€æŸ¥é€»è¾‘è•´å«
    pub fn implies(premises: &[Proposition], conclusion: &Proposition, variables: &[String]) -> bool {
        Self::check_all_assignments(conclusion, variables, |assignment| {
            // å¦‚æœæ‰€æœ‰å‰æä¸ºçœŸï¼Œåˆ™ç»“è®ºå¿…é¡»ä¸ºçœŸ
            let all_premises_true = premises.iter()
                .all(|premise| premise.evaluate(assignment));
            
            if all_premises_true {
                conclusion.evaluate(assignment)
            } else {
                true // å‰æä¸éƒ½ä¸ºçœŸæ—¶ï¼Œè•´å«è‡ªåŠ¨æˆç«‹
            }
        })
    }
    
    fn check_all_assignments<F>(
        prop: &Proposition,
        variables: &[String],
        condition: F
    ) -> bool 
    where
        F: Fn(&TruthAssignment) -> bool,
    {
        let n = variables.len();
        for i in 0..(1 << n) {
            let mut assignment = TruthAssignment::new();
            for (j, var) in variables.iter().enumerate() {
                assignment.set(var, (i >> j) & 1 == 1);
            }
            if !condition(&assignment) {
                return false;
            }
        }
        true
    }
}
```

### 4.4 é€»è¾‘æ¨ç†å¼•æ“

```rust
pub struct LogicEngine;

impl LogicEngine {
    /// å‡è¨€æ¨ç†
    pub fn modus_ponens(premise1: &Proposition, premise2: &Proposition) -> Option<Proposition> {
        if let Proposition::Implication(antecedent, consequent) = premise2 {
            if premise1 == antecedent.as_ref() {
                return Some(*consequent.clone());
            }
        }
        None
    }
    
    /// åè¯æ³•
    pub fn proof_by_contradiction(
        premises: &[Proposition],
        conclusion: &Proposition,
        variables: &[String]
    ) -> bool {
        let negated_conclusion = Proposition::Negation(Box::new(conclusion.clone()));
        let mut all_premises = premises.to_vec();
        all_premises.push(negated_conclusion);
        
        // æ£€æŸ¥æ˜¯å¦å¯¼è‡´çŸ›ç›¾
        LogicValidator::check_all_assignments(
            &Proposition::Conjunction(
                Box::new(all_premises[0].clone()),
                Box::new(all_premises[1].clone())
            ),
            variables,
            |_| false
        )
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 åŸºæœ¬é€»è¾‘æ¨ç†

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_modus_ponens() {
        let p = Proposition::Variable("p".to_string());
        let q = Proposition::Variable("q".to_string());
        let implication = Proposition::Implication(Box::new(p.clone()), Box::new(q.clone()));
        
        let result = LogicEngine::modus_ponens(&p, &implication);
        assert_eq!(result, Some(q));
    }
    
    #[test]
    fn test_tautology() {
        let p = Proposition::Variable("p".to_string());
        let not_p = Proposition::Negation(Box::new(p.clone()));
        let tautology = Proposition::Disjunction(Box::new(p), Box::new(not_p));
        
        let variables = vec!["p".to_string()];
        assert!(LogicValidator::is_tautology(&tautology, &variables));
    }
    
    #[test]
    fn test_contradiction() {
        let p = Proposition::Variable("p".to_string());
        let not_p = Proposition::Negation(Box::new(p.clone()));
        let contradiction = Proposition::Conjunction(Box::new(p), Box::new(not_p));
        
        let variables = vec!["p".to_string()];
        assert!(LogicValidator::is_contradiction(&contradiction, &variables));
    }
}
```

### 5.2 å¤æ‚é€»è¾‘æ¨ç†

```rust
#[test]
fn test_complex_reasoning() {
    // æ„å»ºå¤æ‚å‘½é¢˜ï¼š(p -> q) -> ((q -> r) -> (p -> r))
    let p = Proposition::Variable("p".to_string());
    let q = Proposition::Variable("q".to_string());
    let r = Proposition::Variable("r".to_string());
    
    let p_implies_q = Proposition::Implication(Box::new(p.clone()), Box::new(q.clone()));
    let q_implies_r = Proposition::Implication(Box::new(q), Box::new(r.clone()));
    let p_implies_r = Proposition::Implication(Box::new(p), Box::new(r));
    
    let inner_implication = Proposition::Implication(Box::new(q_implies_r), Box::new(p_implies_r));
    let complex_prop = Proposition::Implication(Box::new(p_implies_q), Box::new(inner_implication));
    
    let variables = vec!["p".to_string(), "q".to_string(), "r".to_string()];
    assert!(LogicValidator::is_tautology(&complex_prop, &variables));
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸è®¤è¯†è®ºçš„å…³ç³»

é€»è¾‘åŸºç¡€ä¸ºè®¤è¯†è®ºæä¾›äº†æ¨ç†å·¥å…·ï¼Œç¡®ä¿çŸ¥è¯†è·å–çš„åˆç†æ€§ã€‚

### 6.2 ä¸æ•°å­¦åŸºç¡€çš„å…³ç³»

é€»è¾‘æ˜¯æ•°å­¦çš„åŸºç¡€ï¼Œä¸ºæ•°å­¦è¯æ˜æä¾›å½¢å¼åŒ–æ¡†æ¶ã€‚

### 6.3 ä¸è®¡ç®—æœºç§‘å­¦çš„å…³ç³»

é€»è¾‘ä¸ºç¨‹åºéªŒè¯ã€äººå·¥æ™ºèƒ½æ¨ç†æä¾›ç†è®ºåŸºç¡€ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Enderton, H. B. (2001). A Mathematical Introduction to Logic. Academic Press.
2. Mendelson, E. (2015). Introduction to Mathematical Logic. CRC Press.
3. Boolos, G. S., Burgess, J. P., & Jeffrey, R. C. (2007). Computability and Logic. Cambridge University Press.
4. ç‹å®ªé’§. (1998). æ•°ç†é€»è¾‘å¼•è®º. åŒ—äº¬å¤§å­¦å‡ºç‰ˆç¤¾.
5. å¼ æ¸…å®‡. (2006). é€»è¾‘å“²å­¦ä¹ç« . æ±Ÿè‹äººæ°‘å‡ºç‰ˆç¤¾.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [01.4.2 æ¨ç†ç†è®º](../01.4.2_æ¨ç†ç†è®º.md)
- [01.4.3 è¯æ˜ç†è®º](../01.4.3_è¯æ˜ç†è®º.md)
- [01.4.4 é€»è¾‘å“²å­¦](../01.4.4_é€»è¾‘å“²å­¦.md)
- [02.2.1 å‘½é¢˜é€»è¾‘](../../02_Mathematical_Foundation/02.2.1_å‘½é¢˜é€»è¾‘.md)
- [02.2.2 è°“è¯é€»è¾‘](../../02_Mathematical_Foundation/02.2.2_è°“è¯é€»è¾‘.md)
