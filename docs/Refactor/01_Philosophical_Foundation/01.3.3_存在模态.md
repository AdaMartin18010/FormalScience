# 01.3.3 å­˜åœ¨æ¨¡æ€ç†è®º

## ğŸ“‹ æ¦‚è¿°

å­˜åœ¨æ¨¡æ€ç†è®ºç ”ç©¶å®ä½“å­˜åœ¨çš„ä¸åŒæ–¹å¼å’Œå¯èƒ½æ€§ã€‚æœ¬ç†è®ºæ¢è®¨å®ä½“çš„å¿…ç„¶å­˜åœ¨ã€å¯èƒ½å­˜åœ¨ã€å¶ç„¶å­˜åœ¨ç­‰æ¨¡æ€æ¦‚å¿µï¼Œä¸ºç†è§£å®ä½“çš„å­˜åœ¨çŠ¶æ€æä¾›å½¢å¼åŒ–æ¡†æ¶ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹å­˜åœ¨æ¨¡æ€çš„å½¢å¼åŒ–ç†è®º**
2. **åˆ†æä¸åŒå­˜åœ¨æ¨¡æ€çš„é€»è¾‘å…³ç³»**
3. **æ„å»ºæ¨¡æ€å­˜åœ¨è®ºçš„æ¡†æ¶**
4. **æä¾›æ¨¡æ€æ¨ç†çš„å½¢å¼åŒ–æ–¹æ³•**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [æ¨¡æ€ç®—å­](#3-æ¨¡æ€ç®—å­)
4. [æ¨¡æ€ç³»ç»Ÿ](#4-æ¨¡æ€ç³»ç»Ÿ)
5. [å½¢å¼åŒ–è¯æ˜](#5-å½¢å¼åŒ–è¯æ˜)
6. [ä»£ç å®ç°](#6-ä»£ç å®ç°)
7. [åº”ç”¨ç¤ºä¾‹](#7-åº”ç”¨ç¤ºä¾‹)
8. [ç›¸å…³ç†è®º](#8-ç›¸å…³ç†è®º)
9. [å‚è€ƒæ–‡çŒ®](#9-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å­˜åœ¨æ¨¡æ€çš„å®šä¹‰

**å®šä¹‰ 1.1** (å­˜åœ¨æ¨¡æ€)
å­˜åœ¨æ¨¡æ€æ˜¯æŒ‡å®ä½“å­˜åœ¨çš„ä¸åŒæ–¹å¼æˆ–çŠ¶æ€ï¼ŒåŒ…æ‹¬å¿…ç„¶å­˜åœ¨ã€å¯èƒ½å­˜åœ¨ã€å¶ç„¶å­˜åœ¨ç­‰ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
è®¾ $E$ ä¸ºå®ä½“é›†åˆï¼Œ$W$ ä¸ºå¯èƒ½ä¸–ç•Œé›†åˆï¼Œåˆ™å­˜åœ¨æ¨¡æ€å¯ä»¥è¡¨ç¤ºä¸ºï¼š
$$\text{ExistenceModal} = \langle E, W, \text{exists} \rangle$$
å…¶ä¸­ $\text{exists}: E \times W \rightarrow \mathbb{B}$ æ˜¯å­˜åœ¨å‡½æ•°ã€‚

### 1.2 æ¨¡æ€ç±»å‹

**å®šä¹‰ 1.2** (æ¨¡æ€ç±»å‹)
å­˜åœ¨æ¨¡æ€åŒ…æ‹¬ä»¥ä¸‹åŸºæœ¬ç±»å‹ï¼š

- **å¿…ç„¶å­˜åœ¨** (Necessary Existence)ï¼šåœ¨æ‰€æœ‰å¯èƒ½ä¸–ç•Œä¸­éƒ½å­˜åœ¨
- **å¯èƒ½å­˜åœ¨** (Possible Existence)ï¼šåœ¨è‡³å°‘ä¸€ä¸ªå¯èƒ½ä¸–ç•Œä¸­å­˜åœ¨
- **å¶ç„¶å­˜åœ¨** (Contingent Existence)ï¼šåœ¨æŸäº›å¯èƒ½ä¸–ç•Œä¸­å­˜åœ¨ï¼Œåœ¨æŸäº›ä¸­ä¸å­˜åœ¨
- **ä¸å¯èƒ½å­˜åœ¨** (Impossible Existence)ï¼šåœ¨æ‰€æœ‰å¯èƒ½ä¸–ç•Œä¸­éƒ½ä¸å­˜åœ¨

### 1.3 å¯èƒ½ä¸–ç•Œ

**å®šä¹‰ 1.3** (å¯èƒ½ä¸–ç•Œ)
å¯èƒ½ä¸–ç•Œæ˜¯é€»è¾‘ä¸Šä¸€è‡´çš„ä¸–ç•ŒçŠ¶æ€ï¼Œç”¨ $w \in W$ è¡¨ç¤ºã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ¨¡æ€å­˜åœ¨è®º

**å®šä¹‰ 2.1** (æ¨¡æ€å­˜åœ¨è®º)
æ¨¡æ€å­˜åœ¨è®ºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $\mathcal{M} = \langle E, W, R, \text{exists}, V \rangle$ï¼Œå…¶ä¸­ï¼š

- $E$ æ˜¯å®ä½“é›†åˆ
- $W$ æ˜¯å¯èƒ½ä¸–ç•Œé›†åˆ
- $R \subseteq W \times W$ æ˜¯å¯åŠå…³ç³»
- $\text{exists}: E \times W \rightarrow \mathbb{B}$ æ˜¯å­˜åœ¨å‡½æ•°
- $V: \text{Prop} \times W \rightarrow \mathbb{B}$ æ˜¯èµ‹å€¼å‡½æ•°

### 2.2 å­˜åœ¨å‡½æ•°

**å®šä¹‰ 2.2** (å­˜åœ¨å‡½æ•°)
å­˜åœ¨å‡½æ•° $\text{exists}: E \times W \rightarrow \mathbb{B}$ æ»¡è¶³ï¼š

$$\text{exists}(e, w) = \begin{cases}
\text{true} & \text{if } e \text{ exists in } w \\
\text{false} & \text{if } e \text{ does not exist in } w
\end{cases}$$

### 2.3 å¯åŠå…³ç³»

**å®šä¹‰ 2.3** (å¯åŠå…³ç³»)
å¯åŠå…³ç³» $R \subseteq W \times W$ è¡¨ç¤ºå¯èƒ½ä¸–ç•Œä¹‹é—´çš„å¯è¾¾æ€§ï¼š
$$w_1 R w_2 \iff w_2 \text{ is accessible from } w_1$$

## 3. æ¨¡æ€ç®—å­

### 3.1 å¿…ç„¶ç®—å­

**å®šä¹‰ 3.1** (å¿…ç„¶ç®—å­)
å¿…ç„¶ç®—å­ $\square$ å®šä¹‰ä¸ºï¼š
$$\square \phi \iff \forall w' \in W: wRw' \Rightarrow \phi(w')$$

**å­˜åœ¨å¿…ç„¶æ€§**ï¼š
$$\square \text{exists}(e) \iff \forall w \in W: \text{exists}(e, w)$$

### 3.2 å¯èƒ½ç®—å­

**å®šä¹‰ 3.2** (å¯èƒ½ç®—å­)
å¯èƒ½ç®—å­ $\diamond$ å®šä¹‰ä¸ºï¼š
$$\diamond \phi \iff \exists w' \in W: wRw' \land \phi(w')$$

**å­˜åœ¨å¯èƒ½æ€§**ï¼š
$$\diamond \text{exists}(e) \iff \exists w \in W: \text{exists}(e, w)$$

### 3.3 å¶ç„¶ç®—å­

**å®šä¹‰ 3.3** (å¶ç„¶ç®—å­)
å¶ç„¶ç®—å­ $\nabla$ å®šä¹‰ä¸ºï¼š
$$\nabla \phi \iff \diamond \phi \land \diamond \neg \phi$$

**å¶ç„¶å­˜åœ¨**ï¼š
$$\nabla \text{exists}(e) \iff \diamond \text{exists}(e) \land \diamond \neg \text{exists}(e)$$

## 4. æ¨¡æ€ç³»ç»Ÿ

### 4.1 åŸºæœ¬æ¨¡æ€ç³»ç»Ÿ

**å®šä¹‰ 4.1** (åŸºæœ¬æ¨¡æ€ç³»ç»Ÿ)
åŸºæœ¬æ¨¡æ€ç³»ç»Ÿ $\mathcal{S}$ åŒ…å«ä»¥ä¸‹å…¬ç†ï¼š
1. **Kå…¬ç†**ï¼š$\square(\phi \rightarrow \psi) \rightarrow (\square\phi \rightarrow \square\psi)$
2. **Tå…¬ç†**ï¼š$\square\phi \rightarrow \phi$
3. **4å…¬ç†**ï¼š$\square\phi \rightarrow \square\square\phi$
4. **5å…¬ç†**ï¼š$\diamond\phi \rightarrow \square\diamond\phi$

### 4.2 å­˜åœ¨æ¨¡æ€ç³»ç»Ÿ

**å®šä¹‰ 4.2** (å­˜åœ¨æ¨¡æ€ç³»ç»Ÿ)
å­˜åœ¨æ¨¡æ€ç³»ç»Ÿ $\mathcal{E}$ åœ¨åŸºæœ¬æ¨¡æ€ç³»ç»ŸåŸºç¡€ä¸Šæ·»åŠ ï¼š
1. **å­˜åœ¨å¿…ç„¶æ€§å…¬ç†**ï¼š$\square\text{exists}(e) \rightarrow \text{exists}(e)$
2. **å­˜åœ¨å¯èƒ½æ€§å…¬ç†**ï¼š$\text{exists}(e) \rightarrow \diamond\text{exists}(e)$
3. **å­˜åœ¨å¶ç„¶æ€§å…¬ç†**ï¼š$\nabla\text{exists}(e) \rightarrow (\diamond\text{exists}(e) \land \diamond\neg\text{exists}(e))$

### 4.3 æ¨¡æ€é€»è¾‘è§„åˆ™

**å®šä¹‰ 4.3** (æ¨¡æ€æ¨ç†è§„åˆ™)
1. **å¿…ç„¶åŒ–è§„åˆ™**ï¼šå¦‚æœ $\vdash \phi$ï¼Œåˆ™ $\vdash \square\phi$
2. **å­˜åœ¨åŒ–è§„åˆ™**ï¼šå¦‚æœ $\vdash \text{exists}(e)$ï¼Œåˆ™ $\vdash \diamond\text{exists}(e)$
3. **å¶ç„¶åŒ–è§„åˆ™**ï¼šå¦‚æœ $\vdash \nabla\text{exists}(e)$ï¼Œåˆ™ $\vdash \diamond\text{exists}(e) \land \diamond\neg\text{exists}(e)$

## 5. å½¢å¼åŒ–è¯æ˜

### 5.1 å­˜åœ¨å¿…ç„¶æ€§å®šç†

**å®šç† 5.1** (å­˜åœ¨å¿…ç„¶æ€§)
å¦‚æœå®ä½“ $e$ å¿…ç„¶å­˜åœ¨ï¼Œåˆ™å®ƒåœ¨æ‰€æœ‰å¯èƒ½ä¸–ç•Œä¸­éƒ½å­˜åœ¨ã€‚

**è¯æ˜**ï¼š
1. å‡è®¾ $\square\text{exists}(e)$
2. æ ¹æ®å¿…ç„¶ç®—å­å®šä¹‰ï¼š$\forall w \in W: \text{exists}(e, w)$
3. å› æ­¤ $e$ åœ¨æ‰€æœ‰å¯èƒ½ä¸–ç•Œä¸­éƒ½å­˜åœ¨

### 5.2 å­˜åœ¨å¯èƒ½æ€§å®šç†

**å®šç† 5.2** (å­˜åœ¨å¯èƒ½æ€§)
å¦‚æœå®ä½“ $e$ å¯èƒ½å­˜åœ¨ï¼Œåˆ™å®ƒåœ¨è‡³å°‘ä¸€ä¸ªå¯èƒ½ä¸–ç•Œä¸­å­˜åœ¨ã€‚

**è¯æ˜**ï¼š
1. å‡è®¾ $\diamond\text{exists}(e)$
2. æ ¹æ®å¯èƒ½ç®—å­å®šä¹‰ï¼š$\exists w \in W: \text{exists}(e, w)$
3. å› æ­¤ $e$ åœ¨è‡³å°‘ä¸€ä¸ªå¯èƒ½ä¸–ç•Œä¸­å­˜åœ¨

### 5.3 å­˜åœ¨å¶ç„¶æ€§å®šç†

**å®šç† 5.3** (å­˜åœ¨å¶ç„¶æ€§)
å¦‚æœå®ä½“ $e$ å¶ç„¶å­˜åœ¨ï¼Œåˆ™å®ƒåœ¨æŸäº›å¯èƒ½ä¸–ç•Œä¸­å­˜åœ¨ï¼Œåœ¨æŸäº›ä¸­ä¸å­˜åœ¨ã€‚

**è¯æ˜**ï¼š
1. å‡è®¾ $\nabla\text{exists}(e)$
2. æ ¹æ®å¶ç„¶ç®—å­å®šä¹‰ï¼š$\diamond\text{exists}(e) \land \diamond\neg\text{exists}(e)$
3. å› æ­¤ $\exists w_1 \in W: \text{exists}(e, w_1)$ ä¸” $\exists w_2 \in W: \neg\text{exists}(e, w_2)$

### 5.4 æ¨¡æ€å­˜åœ¨è®ºå®Œå¤‡æ€§å®šç†

**å®šç† 5.4** (æ¨¡æ€å­˜åœ¨è®ºå®Œå¤‡æ€§)
æ¨¡æ€å­˜åœ¨è®ºç³»ç»Ÿ $\mathcal{E}$ æ˜¯å®Œå¤‡çš„ã€‚

**è¯æ˜**ï¼š
1. æ„é€ å…¸èŒƒæ¨¡å‹ $\mathcal{M}^*$
2. è¯æ˜ $\mathcal{M}^*$ æ»¡è¶³æ‰€æœ‰å…¬ç†
3. è¯æ˜ $\mathcal{M}^*$ æ˜¯ $\mathcal{E}$ çš„æ¨¡å‹
4. æ ¹æ®å®Œå¤‡æ€§å®šç†ï¼Œ$\mathcal{E}$ æ˜¯å®Œå¤‡çš„

## 6. ä»£ç å®ç°

### 6.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::hash::Hash;

/// å¯èƒ½ä¸–ç•Œ
# [derive(Debug, Clone, Hash, Eq, PartialEq)]
pub struct PossibleWorld {
    id: String,
    properties: HashMap<String, bool>,
}

impl PossibleWorld {
    pub fn new(id: String) -> Self {
        Self {
            id,
            properties: HashMap::new(),
        }
    }

    pub fn add_property(&mut self, property: String, value: bool) {
        self.properties.insert(property, value);
    }

    pub fn get_property(&self, property: &str) -> Option<bool> {
        self.properties.get(property).copied()
    }
}

/// å®ä½“
# [derive(Debug, Clone, Hash, Eq, PartialEq)]
pub struct Entity {
    id: String,
    name: String,
}

impl Entity {
    pub fn new(id: String, name: String) -> Self {
        Self { id, name }
    }
}

/// æ¨¡æ€å­˜åœ¨è®ºç³»ç»Ÿ
# [derive(Debug, Clone)]
pub struct ModalExistenceTheory {
    entities: HashSet<Entity>,
    worlds: HashSet<PossibleWorld>,
    accessibility: HashMap<PossibleWorld, HashSet<PossibleWorld>>,
    existence: HashMap<(Entity, PossibleWorld), bool>,
}

impl ModalExistenceTheory {
    pub fn new() -> Self {
        Self {
            entities: HashSet::new(),
            worlds: HashSet::new(),
            accessibility: HashMap::new(),
            existence: HashMap::new(),
        }
    }

    /// æ·»åŠ å®ä½“
    pub fn add_entity(&mut self, entity: Entity) {
        self.entities.insert(entity);
    }

    /// æ·»åŠ å¯èƒ½ä¸–ç•Œ
    pub fn add_world(&mut self, world: PossibleWorld) {
        self.worlds.insert(world.clone());
        self.accessibility.insert(world, HashSet::new());
    }

    /// è®¾ç½®å¯åŠå…³ç³»
    pub fn set_accessible(&mut self, from: &PossibleWorld, to: &PossibleWorld) {
        if let Some(accessible) = self.accessibility.get_mut(from) {
            accessible.insert(to.clone());
        }
    }

    /// è®¾ç½®å®ä½“åœ¨ä¸–ç•Œä¸­çš„å­˜åœ¨çŠ¶æ€
    pub fn set_existence(&mut self, entity: &Entity, world: &PossibleWorld, exists: bool) {
        self.existence.insert((entity.clone(), world.clone()), exists);
    }

    /// æ£€æŸ¥å®ä½“åœ¨ä¸–ç•Œä¸­æ˜¯å¦å­˜åœ¨
    pub fn exists_in_world(&self, entity: &Entity, world: &PossibleWorld) -> bool {
        *self.existence.get(&(entity.clone(), world.clone())).unwrap_or(&false)
    }

    /// å¿…ç„¶å­˜åœ¨
    pub fn necessarily_exists(&self, entity: &Entity) -> bool {
        self.worlds.iter().all(|world| self.exists_in_world(entity, world))
    }

    /// å¯èƒ½å­˜åœ¨
    pub fn possibly_exists(&self, entity: &Entity) -> bool {
        self.worlds.iter().any(|world| self.exists_in_world(entity, world))
    }

    /// å¶ç„¶å­˜åœ¨
    pub fn contingently_exists(&self, entity: &Entity) -> bool {
        let exists_somewhere = self.possibly_exists(entity);
        let not_exists_somewhere = self.worlds.iter().any(|world| !self.exists_in_world(entity, world));
        exists_somewhere && not_exists_somewhere
    }

    /// ä¸å¯èƒ½å­˜åœ¨
    pub fn impossibly_exists(&self, entity: &Entity) -> bool {
        !self.possibly_exists(entity)
    }

    /// æ¨¡æ€ç®—å­ï¼šå¿…ç„¶
    pub fn necessarily(&self, world: &PossibleWorld, predicate: impl Fn(&PossibleWorld) -> bool) -> bool {
        if let Some(accessible) = self.accessibility.get(world) {
            accessible.iter().all(|w| predicate(w))
        } else {
            false
        }
    }

    /// æ¨¡æ€ç®—å­ï¼šå¯èƒ½
    pub fn possibly(&self, world: &PossibleWorld, predicate: impl Fn(&PossibleWorld) -> bool) -> bool {
        if let Some(accessible) = self.accessibility.get(world) {
            accessible.iter().any(|w| predicate(w))
        } else {
            false
        }
    }

    /// éªŒè¯æ¨¡æ€å…¬ç†
    pub fn verify_axioms(&self) -> HashMap<String, bool> {
        let mut results = HashMap::new();

        // éªŒè¯Tå…¬ç†ï¼šâ–¡Ï† â†’ Ï†
        let mut t_axiom_holds = true;
        for world in &self.worlds {
            for entity in &self.entities {
                let necessarily_exists = self.necessarily(world, |w| self.exists_in_world(entity, w));
                let exists_here = self.exists_in_world(entity, world);
                if necessarily_exists && !exists_here {
                    t_axiom_holds = false;
                    break;
                }
            }
        }
        results.insert("T_axiom".to_string(), t_axiom_holds);

        // éªŒè¯4å…¬ç†ï¼šâ–¡Ï† â†’ â–¡â–¡Ï†
        let mut axiom_4_holds = true;
        for world in &self.worlds {
            for entity in &self.entities {
                let necessarily_exists = self.necessarily(world, |w| self.exists_in_world(entity, w));
                let necessarily_necessarily_exists = self.necessarily(world, |w1| {
                    self.necessarily(w1, |w2| self.exists_in_world(entity, w2))
                });
                if necessarily_exists && !necessarily_necessarily_exists {
                    axiom_4_holds = false;
                    break;
                }
            }
        }
        results.insert("4_axiom".to_string(), axiom_4_holds);

        results
    }
}

/// æ¨¡æ€é€»è¾‘æ¨ç†å™¨
# [derive(Debug, Clone)]
pub struct ModalReasoner {
    theory: ModalExistenceTheory,
}

impl ModalReasoner {
    pub fn new(theory: ModalExistenceTheory) -> Self {
        Self { theory }
    }

    /// æ¨ç†å®ä½“å­˜åœ¨æ¨¡æ€
    pub fn infer_existence_modality(&self, entity: &Entity) -> String {
        if self.theory.necessarily_exists(entity) {
            "Necessarily exists".to_string()
        } else if self.theory.impossibly_exists(entity) {
            "Impossibly exists".to_string()
        } else if self.theory.contingently_exists(entity) {
            "Contingently exists".to_string()
        } else {
            "Possibly exists".to_string()
        }
    }

    /// æ¨¡æ€æ¨ç†ï¼šä»å¿…ç„¶æ¨å‡ºå¯èƒ½
    pub fn necessary_implies_possible(&self, entity: &Entity) -> bool {
        if self.theory.necessarily_exists(entity) {
            self.theory.possibly_exists(entity)
        } else {
            true
        }
    }

    /// æ¨¡æ€æ¨ç†ï¼šä»å¯èƒ½æ¨å‡ºå¶ç„¶
    pub fn possible_implies_contingent(&self, entity: &Entity) -> bool {
        if self.theory.possibly_exists(entity) && !self.theory.necessarily_exists(entity) {
            self.theory.contingently_exists(entity)
        } else {
            true
        }
    }
}

# [cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_modal_existence() {
        let mut theory = ModalExistenceTheory::new();

        // åˆ›å»ºå®ä½“
        let god = Entity::new("god".to_string(), "God".to_string());
        let unicorn = Entity::new("unicorn".to_string(), "Unicorn".to_string());
        let human = Entity::new("human".to_string(), "Human".to_string());

        theory.add_entity(god.clone());
        theory.add_entity(unicorn.clone());
        theory.add_entity(human.clone());

        // åˆ›å»ºå¯èƒ½ä¸–ç•Œ
        let world1 = PossibleWorld::new("w1".to_string());
        let world2 = PossibleWorld::new("w2".to_string());
        let world3 = PossibleWorld::new("w3".to_string());

        theory.add_world(world1.clone());
        theory.add_world(world2.clone());
        theory.add_world(world3.clone());

        // è®¾ç½®å¯åŠå…³ç³»ï¼ˆæ‰€æœ‰ä¸–ç•Œç›¸äº’å¯è¾¾ï¼‰
        theory.set_accessible(&world1, &world2);
        theory.set_accessible(&world1, &world3);
        theory.set_accessible(&world2, &world1);
        theory.set_accessible(&world2, &world3);
        theory.set_accessible(&world3, &world1);
        theory.set_accessible(&world3, &world2);

        // è®¾ç½®å­˜åœ¨çŠ¶æ€
        // ä¸Šå¸åœ¨æ‰€æœ‰ä¸–ç•Œéƒ½å­˜åœ¨ï¼ˆå¿…ç„¶å­˜åœ¨ï¼‰
        theory.set_existence(&god, &world1, true);
        theory.set_existence(&god, &world2, true);
        theory.set_existence(&god, &world3, true);

        // ç‹¬è§’å…½åœ¨éƒ¨åˆ†ä¸–ç•Œå­˜åœ¨ï¼ˆå¶ç„¶å­˜åœ¨ï¼‰
        theory.set_existence(&unicorn, &world1, true);
        theory.set_existence(&unicorn, &world2, false);
        theory.set_existence(&unicorn, &world3, true);

        // äººç±»åœ¨éƒ¨åˆ†ä¸–ç•Œå­˜åœ¨ï¼ˆå¶ç„¶å­˜åœ¨ï¼‰
        theory.set_existence(&human, &world1, true);
        theory.set_existence(&human, &world2, true);
        theory.set_existence(&human, &world3, false);

        // éªŒè¯æ¨¡æ€
        assert!(theory.necessarily_exists(&god));
        assert!(theory.contingently_exists(&unicorn));
        assert!(theory.contingently_exists(&human));
        assert!(!theory.impossibly_exists(&god));

        // æµ‹è¯•æ¨ç†å™¨
        let reasoner = ModalReasoner::new(theory);
        assert_eq!(reasoner.infer_existence_modality(&god), "Necessarily exists");
        assert_eq!(reasoner.infer_existence_modality(&unicorn), "Contingently exists");
        assert!(reasoner.necessary_implies_possible(&god));
    }
}
```

### 6.2 Haskell å®ç°

```haskell
module ModalExistenceTheory where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Maybe (fromMaybe)

-- å¯èƒ½ä¸–ç•Œ
data PossibleWorld = PossibleWorld
    { worldId :: String
    , properties :: Map String Bool
    } deriving (Show, Eq, Ord)

-- å®ä½“
data Entity = Entity
    { entityId :: String
    , entityName :: String
    } deriving (Show, Eq, Ord)

-- æ¨¡æ€å­˜åœ¨è®ºç³»ç»Ÿ
data ModalExistenceTheory = ModalExistenceTheory
    { entities :: Set Entity
    , worlds :: Set PossibleWorld
    , accessibility :: Map PossibleWorld (Set PossibleWorld)
    , existence :: Map (Entity, PossibleWorld) Bool
    } deriving (Show, Eq)

-- åˆ›å»ºç©ºæ¨¡æ€å­˜åœ¨è®ºç³»ç»Ÿ
emptyModalExistenceTheory :: ModalExistenceTheory
emptyModalExistenceTheory = ModalExistenceTheory
    { entities = Set.empty
    , worlds = Set.empty
    , accessibility = Map.empty
    , existence = Map.empty
    }

-- æ·»åŠ å®ä½“
addEntity :: Entity -> ModalExistenceTheory -> ModalExistenceTheory
addEntity entity theory = theory
    { entities = Set.insert entity (entities theory)
    }

-- æ·»åŠ å¯èƒ½ä¸–ç•Œ
addWorld :: PossibleWorld -> ModalExistenceTheory -> ModalExistenceTheory
addWorld world theory = theory
    { worlds = Set.insert world (worlds theory)
    , accessibility = Map.insert world Set.empty (accessibility theory)
    }

-- è®¾ç½®å¯åŠå…³ç³»
setAccessible :: PossibleWorld -> PossibleWorld -> ModalExistenceTheory -> ModalExistenceTheory
setAccessible from to theory = theory
    { accessibility = Map.insertWith Set.union from (Set.singleton to) (accessibility theory)
    }

-- è®¾ç½®å®ä½“åœ¨ä¸–ç•Œä¸­çš„å­˜åœ¨çŠ¶æ€
setExistence :: Entity -> PossibleWorld -> Bool -> ModalExistenceTheory -> ModalExistenceTheory
setExistence entity world exists theory = theory
    { existence = Map.insert (entity, world) exists (existence theory)
    }

-- æ£€æŸ¥å®ä½“åœ¨ä¸–ç•Œä¸­æ˜¯å¦å­˜åœ¨
existsInWorld :: Entity -> PossibleWorld -> ModalExistenceTheory -> Bool
existsInWorld entity world theory =
    fromMaybe False (Map.lookup (entity, world) (existence theory))

-- å¿…ç„¶å­˜åœ¨
necessarilyExists :: Entity -> ModalExistenceTheory -> Bool
necessarilyExists entity theory =
    all (\world -> existsInWorld entity world theory) (Set.toList (worlds theory))

-- å¯èƒ½å­˜åœ¨
possiblyExists :: Entity -> ModalExistenceTheory -> Bool
possiblyExists entity theory =
    any (\world -> existsInWorld entity world theory) (Set.toList (worlds theory))

-- å¶ç„¶å­˜åœ¨
contingentlyExists :: Entity -> ModalExistenceTheory -> Bool
contingentlyExists entity theory =
    let exists_somewhere = possiblyExists entity theory
        not_exists_somewhere = any (\world -> not (existsInWorld entity world theory)) (Set.toList (worlds theory))
    in exists_somewhere && not_exists_somewhere

-- ä¸å¯èƒ½å­˜åœ¨
impossiblyExists :: Entity -> ModalExistenceTheory -> Bool
impossiblyExists entity theory = not (possiblyExists entity theory)

-- æ¨¡æ€ç®—å­ï¼šå¿…ç„¶
necessarily :: PossibleWorld -> (PossibleWorld -> Bool) -> ModalExistenceTheory -> Bool
necessarily world predicate theory =
    case Map.lookup world (accessibility theory) of
        Just accessible -> all predicate (Set.toList accessible)
        Nothing -> False

-- æ¨¡æ€ç®—å­ï¼šå¯èƒ½
possibly :: PossibleWorld -> (PossibleWorld -> Bool) -> ModalExistenceTheory -> Bool
possibly world predicate theory =
    case Map.lookup world (accessibility theory) of
        Just accessible -> any predicate (Set.toList accessible)
        Nothing -> False

-- æ¨¡æ€æ¨ç†å™¨
data ModalReasoner = ModalReasoner
    { theory :: ModalExistenceTheory
    } deriving (Show, Eq)

-- æ¨ç†å®ä½“å­˜åœ¨æ¨¡æ€
inferExistenceModality :: Entity -> ModalReasoner -> String
inferExistenceModality entity reasoner
    | necessarilyExists entity (theory reasoner) = "Necessarily exists"
    | impossiblyExists entity (theory reasoner) = "Impossibly exists"
    | contingentlyExists entity (theory reasoner) = "Contingently exists"
    | otherwise = "Possibly exists"

-- æ¨¡æ€æ¨ç†ï¼šä»å¿…ç„¶æ¨å‡ºå¯èƒ½
necessaryImpliesPossible :: Entity -> ModalReasoner -> Bool
necessaryImpliesPossible entity reasoner
    | necessarilyExists entity (theory reasoner) = possiblyExists entity (theory reasoner)
    | otherwise = True

-- æ¨¡æ€æ¨ç†ï¼šä»å¯èƒ½æ¨å‡ºå¶ç„¶
possibleImpliesContingent :: Entity -> ModalReasoner -> Bool
possibleImpliesContingent entity reasoner
    | possiblyExists entity (theory reasoner) && not (necessarilyExists entity (theory reasoner)) =
        contingentlyExists entity (theory reasoner)
    | otherwise = True

-- ç¤ºä¾‹ä½¿ç”¨
example :: IO ()
example = do
    let theory = emptyModalExistenceTheory

        -- åˆ›å»ºå®ä½“
        god = Entity "god" "God"
        unicorn = Entity "unicorn" "Unicorn"
        human = Entity "human" "Human"

        -- åˆ›å»ºå¯èƒ½ä¸–ç•Œ
        world1 = PossibleWorld "w1" Map.empty
        world2 = PossibleWorld "w2" Map.empty
        world3 = PossibleWorld "w3" Map.empty

        -- æ„å»ºç†è®º
        theory' = addEntity god theory
        theory'' = addEntity unicorn theory'
        theory''' = addEntity human theory''
        theory'''' = addWorld world1 theory'''
        theory''''' = addWorld world2 theory''''
        theory'''''' = addWorld world3 theory'''''

        -- è®¾ç½®å¯åŠå…³ç³»
        theory''''''' = setAccessible world1 world2 theory'''''
        theory'''''''' = setAccessible world1 world3 theory'''''''
        theory''''''''' = setAccessible world2 world1 theory'''''''
        theory'''''''''' = setAccessible world2 world3 theory'''''''''
        theory''''''''''' = setAccessible world3 world1 theory'''''''''
        theory'''''''''''' = setAccessible world3 world2 theory'''''''''

        -- è®¾ç½®å­˜åœ¨çŠ¶æ€
        theory''''''''''''' = setExistence god world1 True theory'''''''''''
        theory'''''''''''''' = setExistence god world2 True theory'''''''''''
        theory''''''''''''''' = setExistence god world3 True theory'''''''''''
        theory'''''''''''''''' = setExistence unicorn world1 True theory'''''''''''
        theory''''''''''''''''' = setExistence unicorn world2 False theory'''''''''''
        theory'''''''''''''''''' = setExistence unicorn world3 True theory'''''''''''
        theory''''''''''''''''''' = setExistence human world1 True theory'''''''''''
        theory'''''''''''''''''''' = setExistence human world2 True theory'''''''''''
        theory''''''''''''''''''''' = setExistence human world3 False theory'''''''''''

        -- åˆ›å»ºæ¨ç†å™¨
        reasoner = ModalReasoner theory'''''''''''''

    putStrLn "Modal Existence Theory Example:"
    putStrLn $ "God: " ++ inferExistenceModality god reasoner
    putStrLn $ "Unicorn: " ++ inferExistenceModality unicorn reasoner
    putStrLn $ "Human: " ++ inferExistenceModality human reasoner
    putStrLn $ "Necessary implies possible for God: " ++ show (necessaryImpliesPossible god reasoner)

main :: IO ()
main = example
```

## 7. åº”ç”¨ç¤ºä¾‹

### 7.1 ç¥å­¦å­˜åœ¨è®º

**ç¤ºä¾‹ 7.1** (ä¸Šå¸å­˜åœ¨æ¨¡æ€)
```rust
// ä¸Šå¸å­˜åœ¨æ¨¡æ€åˆ†æ
let mut theology = ModalExistenceTheory::new();

// åˆ›å»ºä¸Šå¸å®ä½“
let god = Entity::new("god".to_string(), "God".to_string());
theology.add_entity(god.clone());

// åˆ›å»ºå¯èƒ½ä¸–ç•Œ
let actual_world = PossibleWorld::new("actual".to_string());
let possible_world1 = PossibleWorld::new("possible1".to_string());
let possible_world2 = PossibleWorld::new("possible2".to_string());

theology.add_world(actual_world.clone());
theology.add_world(possible_world1.clone());
theology.add_world(possible_world2.clone());

// è®¾ç½®ä¸Šå¸åœ¨æ‰€æœ‰ä¸–ç•Œéƒ½å­˜åœ¨ï¼ˆå¿…ç„¶å­˜åœ¨ï¼‰
theology.set_existence(&god, &actual_world, true);
theology.set_existence(&god, &possible_world1, true);
theology.set_existence(&god, &possible_world2, true);

// éªŒè¯ä¸Šå¸å¿…ç„¶å­˜åœ¨
assert!(theology.necessarily_exists(&god));
```

### 7.2 æ•°å­¦å¯¹è±¡å­˜åœ¨æ¨¡æ€

**ç¤ºä¾‹ 7.2** (æ•°å­¦å¯¹è±¡å­˜åœ¨æ¨¡æ€)
```rust
// æ•°å­¦å¯¹è±¡å­˜åœ¨æ¨¡æ€åˆ†æ
let mut mathematics = ModalExistenceTheory::new();

// åˆ›å»ºæ•°å­¦å¯¹è±¡
let natural_numbers = Entity::new("natural_numbers".to_string(), "Natural Numbers".to_string());
let square_root_2 = Entity::new("sqrt_2".to_string(), "Square Root of 2".to_string());

mathematics.add_entity(natural_numbers.clone());
mathematics.add_entity(square_root_2.clone());

// åœ¨æ•°å­¦ä¸–ç•Œä¸­ï¼Œè¿™äº›å¯¹è±¡å¿…ç„¶å­˜åœ¨
let mathematical_world = PossibleWorld::new("mathematical".to_string());
mathematics.add_world(mathematical_world.clone());

mathematics.set_existence(&natural_numbers, &mathematical_world, true);
mathematics.set_existence(&square_root_2, &mathematical_world, true);

// éªŒè¯æ•°å­¦å¯¹è±¡å¿…ç„¶å­˜åœ¨
assert!(mathematics.necessarily_exists(&natural_numbers));
assert!(mathematics.necessarily_exists(&square_root_2));
```

## 8. ç›¸å…³ç†è®º

### 8.1 ä¸æ¨¡æ€é€»è¾‘çš„å…³ç³»

å­˜åœ¨æ¨¡æ€ç†è®ºæ˜¯æ¨¡æ€é€»è¾‘åœ¨å­˜åœ¨è®ºä¸­çš„åº”ç”¨ï¼Œåˆ©ç”¨æ¨¡æ€ç®—å­åˆ†æå®ä½“çš„å­˜åœ¨çŠ¶æ€ã€‚

### 8.2 ä¸å¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦çš„å…³ç³»

å¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦ä¸ºå­˜åœ¨æ¨¡æ€ç†è®ºæä¾›äº†å½¢å¼åŒ–åŸºç¡€ï¼Œé€šè¿‡å¯èƒ½ä¸–ç•Œæ¥è§£é‡Šæ¨¡æ€æ¦‚å¿µã€‚

### 8.3 ä¸æœ¬ä½“è®ºçš„å…³ç³»

å­˜åœ¨æ¨¡æ€ç†è®ºæ˜¯æœ¬ä½“è®ºçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œç ”ç©¶å®ä½“çš„å­˜åœ¨æ–¹å¼å’Œå¯èƒ½æ€§ã€‚

## 9. å‚è€ƒæ–‡çŒ®

1. Kripke, S. *Naming and Necessity*. Harvard University Press, 1980.
2. Plantinga, A. *The Nature of Necessity*. Oxford University Press, 1974.
3. Lewis, D. *On the Plurality of Worlds*. Blackwell, 1986.
4. Stalnaker, R. *Inquiry*. MIT Press, 1984.
5. Williamson, T. *Modal Logic as Metaphysics*. Oxford University Press, 2013.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [01.3.1 æœ¬ä½“è®ºæ¡†æ¶](../01.3.1_æœ¬ä½“è®ºæ¡†æ¶.md)
- [01.3.2 å®ä½“åˆ†ç±»](../01.3.2_å®ä½“åˆ†ç±».md)
- [01.3.4 æœ¬ä½“è®ºå…³ç³»](../01.3.4_æœ¬ä½“è®ºå…³ç³».md)
- [02.2.3 æ¨¡æ€é€»è¾‘](../../02_Mathematical_Foundation/02.2.3_æ¨¡æ€é€»è¾‘.md)
- [04.1.1 ç®€å•ç±»å‹ç†è®º](../../04_Type_Theory/04.1.1_ç®€å•ç±»å‹ç†è®º.md)
