# 01.1.4 å› æœç†è®º (Causal Theory)

## ğŸ“‹ æ¦‚è¿°

å› æœç†è®ºæ˜¯å½¢è€Œä¸Šå­¦å’Œç§‘å­¦å“²å­¦çš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶å› æœå…³ç³»ã€å› æœè§£é‡Šå’Œå› æœæ¨ç†ã€‚å®ƒæ¶‰åŠå› æœå…³ç³»çš„æœ¬è´¨ã€å› æœå¾‹ã€åäº‹å®åˆ†æå’Œå› æœæ¨¡å‹ç­‰æ ¸å¿ƒå†…å®¹ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹å› æœå…³ç³»çš„å½¢å¼åŒ–ç†è®ºæ¡†æ¶
2. å‘å±•å› æœæ¨ç†çš„é€»è¾‘ç³»ç»Ÿ
3. æ„å»ºå› æœæ¨¡å‹å’Œå› æœç½‘ç»œ
4. åˆ†æå› æœè§£é‡Šå’Œå› æœå¾‹

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å› æœå…³ç³»çš„ç†è®º](#3-å› æœå…³ç³»çš„ç†è®º)
4. [åäº‹å®åˆ†æ](#4-åäº‹å®åˆ†æ)
5. [å› æœæ¨ç†](#5-å› æœæ¨ç†)
6. [ä»£ç å®ç°](#6-ä»£ç å®ç°)
7. [åº”ç”¨ç¤ºä¾‹](#7-åº”ç”¨ç¤ºä¾‹)
8. [ç›¸å…³ç†è®º](#8-ç›¸å…³ç†è®º)
9. [å‚è€ƒæ–‡çŒ®](#9-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å› æœå…³ç³»

**å®šä¹‰ 1.1 (å› æœå…³ç³»)**
äº‹ä»¶ $C$ æ˜¯äº‹ä»¶ $E$ çš„åŸå› ï¼Œå½“ä¸”ä»…å½“ï¼š

1. $C$ åœ¨æ—¶é—´ä¸Šå…ˆäº $E$
2. $C$ ä¸ $E$ ä¹‹é—´å­˜åœ¨è§„å¾‹æ€§å…³è”
3. å¦‚æœæ²¡æœ‰ $C$ï¼Œåˆ™ $E$ ä¸ä¼šå‘ç”Ÿï¼ˆåäº‹å®æ¡ä»¶ï¼‰

**å®šä¹‰ 1.2 (å› æœé“¾)**
å› æœé“¾æ˜¯äº‹ä»¶åºåˆ— $E_1, E_2, \ldots, E_n$ï¼Œå…¶ä¸­æ¯ä¸ª $E_i$ éƒ½æ˜¯ $E_{i+1}$ çš„åŸå› ã€‚

### 1.2 å› æœå…³ç³»çš„ç±»å‹

**å®šä¹‰ 1.3 (å› æœç±»å‹åˆ†ç±»)**
å› æœå…³ç³»å¯ä»¥åˆ†ä¸ºä»¥ä¸‹ç±»å‹ï¼š

1. **å……åˆ†åŸå› **: $C$ å•ç‹¬è¶³ä»¥äº§ç”Ÿ $E$
2. **å¿…è¦åŸå› **: $C$ æ˜¯ $E$ å‘ç”Ÿçš„å¿…è¦æ¡ä»¶
3. **è´¡çŒ®åŸå› **: $C$ å¯¹ $E$ çš„å‘ç”Ÿæœ‰è´¡çŒ®ä½†ä¸å……åˆ†
4. **è¿œç¨‹åŸå› **: $C$ é€šè¿‡ä¸­ä»‹å› ç´ å½±å“ $E$
5. **ç›´æ¥åŸå› **: $C$ ç›´æ¥å¯¼è‡´ $E$ï¼Œæ— ä¸­ä»‹

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å› æœè¯­è¨€

**å®šä¹‰ 2.1 (å› æœè¯­è¨€ $\mathcal{L}_C$)**
å› æœè¯­è¨€ç”±ä»¥ä¸‹éƒ¨åˆ†ç»„æˆï¼š

- **äº‹ä»¶å˜å…ƒ**: $e_1, e_2, \ldots \in \mathcal{E}$
- **å› æœå…³ç³»**: $\rightarrow$ (ç›´æ¥å› æœ), $\Rightarrow$ (å› æœè•´å«)
- **æ—¶é—´å…³ç³»**: $<$ (æ—¶é—´å…ˆå)
- **åäº‹å®æ¡ä»¶**: $\Box \rightarrow$ (åäº‹å®è•´å«)
- **é€»è¾‘è¿æ¥è¯**: $\neg, \land, \lor, \rightarrow$

**å®šä¹‰ 2.2 (å› æœå…¬å¼)**
å› æœå…¬å¼çš„é€’å½’å®šä¹‰ï¼š

1. å¦‚æœ $e \in \mathcal{E}$ï¼Œåˆ™ $e$ æ˜¯å…¬å¼
2. å¦‚æœ $\phi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\neg \phi$ æ˜¯å…¬å¼
3. å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $(\phi \land \psi)$ æ˜¯å…¬å¼
4. å¦‚æœ $e_1, e_2 \in \mathcal{E}$ï¼Œåˆ™ $e_1 \rightarrow e_2$ æ˜¯å› æœå…¬å¼

### 2.2 å› æœæ¨¡å‹

**å®šä¹‰ 2.3 (å› æœæ¨¡å‹)**
å› æœæ¨¡å‹æ˜¯å››å…ƒç»„ $\mathcal{C} = (V, E, \mathcal{F}, P)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯å˜é‡é›†åˆ
- $E \subseteq V \times V$ æ˜¯å› æœè¾¹é›†åˆ
- $\mathcal{F}$ æ˜¯ç»“æ„æ–¹ç¨‹é›†åˆ
- $P$ æ˜¯æ¦‚ç‡åˆ†å¸ƒ

**å®šä¹‰ 2.4 (ç»“æ„æ–¹ç¨‹)**
ç»“æ„æ–¹ç¨‹çš„å½¢å¼ä¸ºï¼š
$$X_i = f_i(PA_i, U_i)$$
å…¶ä¸­ $PA_i$ æ˜¯ $X_i$ çš„çˆ¶èŠ‚ç‚¹é›†åˆï¼Œ$U_i$ æ˜¯å¤–ç”Ÿå˜é‡ã€‚

## 3. å› æœå…³ç³»çš„ç†è®º

### 3.1 ä¼‘è°Ÿçš„å› æœç†è®º

**å®šä¹‰ 3.1 (ä¼‘è°Ÿå› æœè§‚)**
ä¼‘è°Ÿè®¤ä¸ºå› æœå…³ç³»åŒ…å«ä¸‰ä¸ªè¦ç´ ï¼š

1. **æ—¶é—´ä¼˜å…ˆæ€§**: åŸå› å…ˆäºç»“æœ
2. **ç©ºé—´é‚»è¿‘æ€§**: åŸå› å’Œç»“æœåœ¨ç©ºé—´ä¸Šé‚»è¿‘
3. **å¿…ç„¶è”ç³»**: åŸå› å’Œç»“æœä¹‹é—´å­˜åœ¨å¿…ç„¶è”ç³»

**å®šç† 3.1 (ä¼‘è°Ÿé—®é¢˜)**
æˆ‘ä»¬æ— æ³•é€šè¿‡ç»éªŒè¯æ˜å› æœå¿…ç„¶æ€§ï¼Œåªèƒ½è§‚å¯Ÿåˆ°è§„å¾‹æ€§å…³è”ã€‚

### 3.2 åˆ˜æ˜“æ–¯çš„åäº‹å®ç†è®º

**å®šä¹‰ 3.2 (åäº‹å®å› æœ)**
äº‹ä»¶ $C$ æ˜¯äº‹ä»¶ $E$ çš„åŸå› ï¼Œå½“ä¸”ä»…å½“ï¼š

1. $C$ å’Œ $E$ éƒ½æ˜¯å®é™…å‘ç”Ÿçš„
2. å­˜åœ¨æœ€æ¥è¿‘ $C$ ä¸å‘ç”Ÿçš„å¯èƒ½ä¸–ç•Œï¼Œå…¶ä¸­ $E$ ä¹Ÿä¸å‘ç”Ÿ
3. å­˜åœ¨æœ€æ¥è¿‘ $C$ ä¸å‘ç”Ÿçš„å¯èƒ½ä¸–ç•Œï¼Œå…¶ä¸­ $E$ ä»ç„¶å‘ç”Ÿ

**å®šä¹‰ 3.3 (ç›¸ä¼¼æ€§åº¦é‡)**
å¯èƒ½ä¸–ç•Œä¹‹é—´çš„ç›¸ä¼¼æ€§åŸºäºï¼š

1. äº‹å®çš„åŒ¹é…ç¨‹åº¦
2. è‡ªç„¶å¾‹çš„è¿åç¨‹åº¦
3. å¥‡è¿¹çš„æ•°é‡

### 3.3 å¹²é¢„ä¸»ä¹‰å› æœç†è®º

**å®šä¹‰ 3.4 (å¹²é¢„)**
å¯¹å˜é‡ $X$ çš„å¹²é¢„æ˜¯å°† $X$ è®¾ç½®ä¸ºç‰¹å®šå€¼ï¼ŒåŒæ—¶åˆ‡æ–­ $X$ çš„æ‰€æœ‰å› æœè¾“å…¥ã€‚

**å®šä¹‰ 3.5 (å› æœæ•ˆåº”)**
$X$ å¯¹ $Y$ çš„å› æœæ•ˆåº”æ˜¯ï¼š
$$P(Y = y \mid do(X = x)) - P(Y = y \mid do(X = x'))$$

**å®šç† 3.2 (å› æœæ•ˆåº”è®¡ç®—)**
åœ¨å› æœå›¾ä¸­ï¼Œå› æœæ•ˆåº”å¯ä»¥é€šè¿‡åé—¨å‡†åˆ™è®¡ç®—ã€‚

## 4. åäº‹å®åˆ†æ

### 4.1 åäº‹å®æ¡ä»¶

**å®šä¹‰ 4.1 (åäº‹å®æ¡ä»¶)**
åäº‹å®æ¡ä»¶çš„å½¢å¼ä¸ºï¼šå¦‚æœ $A$ ä¸ºçœŸï¼Œé‚£ä¹ˆ $B$ ä¸ºçœŸï¼Œè®°ä½œ $A \Box \rightarrow B$ã€‚

**å®šä¹‰ 4.2 (åäº‹å®çœŸå€¼)**
$A \Box \rightarrow B$ åœ¨ä¸–ç•Œ $w$ ä¸­ä¸ºçœŸï¼Œå½“ä¸”ä»…å½“åœ¨æ‰€æœ‰æœ€æ¥è¿‘ $w$ çš„ $A$ ä¸ºçœŸçš„ä¸–ç•Œä¸­ï¼Œ$B$ éƒ½ä¸ºçœŸã€‚

### 4.2 åäº‹å®æ¨ç†

**å®šç† 4.1 (åäº‹å®æ¨ç†è§„åˆ™)**
1. **ç­‰ä»·æ€§**: å¦‚æœ $A \leftrightarrow A'$ï¼Œåˆ™ $(A \Box \rightarrow B) \leftrightarrow (A' \Box \rightarrow B)$
2. **ä¼ é€’æ€§**: å¦‚æœ $A \Box \rightarrow B$ ä¸” $B \Box \rightarrow C$ï¼Œåˆ™ $A \Box \rightarrow C$
3. **å•è°ƒæ€§**: å¦‚æœ $A \Box \rightarrow B$ ä¸” $A \land C$ ä¸€è‡´ï¼Œåˆ™ $A \land C \Box \rightarrow B$

## 5. å› æœæ¨ç†

### 5.1 å› æœæ¨ç†è§„åˆ™

**å®šä¹‰ 5.1 (å› æœæ¨ç†)**
å› æœæ¨ç†æ˜¯ä»å› æœçŸ¥è¯†æ¨å¯¼å› æœç»“è®ºçš„è¿‡ç¨‹ã€‚

**å®šç† 5.1 (å› æœæ¨ç†è§„åˆ™)**
1. **å› æœä¼ é€’**: å¦‚æœ $A \rightarrow B$ ä¸” $B \rightarrow C$ï¼Œåˆ™ $A \rightarrow C$
2. **å› æœåˆ†ç¦»**: å¦‚æœ $A \rightarrow B \lor C$ ä¸” $\neg(A \rightarrow C)$ï¼Œåˆ™ $A \rightarrow B$
3. **å› æœåˆå–**: å¦‚æœ $A \rightarrow B$ ä¸” $A \rightarrow C$ï¼Œåˆ™ $A \rightarrow B \land C$

### 5.2 å› æœå‘ç°

**å®šä¹‰ 5.2 (å› æœå‘ç°)**
å› æœå‘ç°æ˜¯ä»è§‚å¯Ÿæ•°æ®æ¨æ–­å› æœç»“æ„çš„è¿‡ç¨‹ã€‚

**ç®—æ³• 5.1 (PCç®—æ³•)**
1. æ„å»ºå®Œå…¨æ— å‘å›¾
2. åŸºäºæ¡ä»¶ç‹¬ç«‹æ€§æµ‹è¯•åˆ é™¤è¾¹
3. åŸºäºV-ç»“æ„ç¡®å®šæ–¹å‘
4. åº”ç”¨Meekè§„åˆ™ä¼ æ’­æ–¹å‘

## 6. ä»£ç å®ç°

### 6.1 å› æœå›¾æ¨¡å‹

```rust
use std::collections::{HashMap, HashSet};

/// å› æœå˜é‡
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CausalVariable {
    pub name: String,
    pub domain: Vec<String>,
}

/// å› æœè¾¹
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CausalEdge {
    pub from: String,
    pub to: String,
    pub weight: f64,
}

/// å› æœå›¾
#[derive(Debug, Clone)]
pub struct CausalGraph {
    pub variables: Vec<CausalVariable>,
    pub edges: Vec<CausalEdge>,
    pub adjacency: HashMap<String, HashSet<String>>,
}

/// ç»“æ„æ–¹ç¨‹
#[derive(Debug, Clone)]
pub struct StructuralEquation {
    pub variable: String,
    pub parents: Vec<String>,
    pub function: Box<dyn Fn(&HashMap<String, f64>) -> f64>,
}

/// å› æœæ¨¡å‹
#[derive(Debug, Clone)]
pub struct CausalModel {
    pub graph: CausalGraph,
    pub equations: Vec<StructuralEquation>,
    pub exogenous: HashMap<String, f64>,
}

impl CausalGraph {
    /// æ·»åŠ å˜é‡
    pub fn add_variable(&mut self, variable: CausalVariable) {
        self.variables.push(variable);
    }

    /// æ·»åŠ å› æœè¾¹
    pub fn add_edge(&mut self, edge: CausalEdge) {
        self.edges.push(edge.clone());
        self.adjacency
            .entry(edge.from.clone())
            .or_insert_with(HashSet::new)
            .insert(edge.to);
    }

    /// è·å–çˆ¶èŠ‚ç‚¹
    pub fn get_parents(&self, variable: &str) -> HashSet<String> {
        let mut parents = HashSet::new();
        for edge in &self.edges {
            if edge.to == variable {
                parents.insert(edge.from.clone());
            }
        }
        parents
    }

    /// è·å–å­èŠ‚ç‚¹
    pub fn get_children(&self, variable: &str) -> HashSet<String> {
        self.adjacency.get(variable).cloned().unwrap_or_default()
    }

    /// æ£€æŸ¥æ˜¯å¦å­˜åœ¨è·¯å¾„
    pub fn has_path(&self, from: &str, to: &str) -> bool {
        let mut visited = HashSet::new();
        self.dfs(from, to, &mut visited)
    }

    fn dfs(&self, current: &str, target: &str, visited: &mut HashSet<String>) -> bool {
        if current == target {
            return true;
        }
        if visited.contains(current) {
            return false;
        }
        visited.insert(current.to_string());
        
        if let Some(children) = self.adjacency.get(current) {
            for child in children {
                if self.dfs(child, target, visited) {
                    return true;
                }
            }
        }
        false
    }
}

impl CausalModel {
    /// æ‰§è¡Œå¹²é¢„
    pub fn do_intervention(&mut self, variable: &str, value: f64) {
        // åˆ‡æ–­æ‰€æœ‰æŒ‡å‘è¯¥å˜é‡çš„è¾¹
        self.graph.edges.retain(|edge| edge.to != variable);
        
        // æ›´æ–°é‚»æ¥çŸ©é˜µ
        for (_, children) in &mut self.graph.adjacency {
            children.remove(variable);
        }
        
        // è®¾ç½®å¤–ç”Ÿå˜é‡å€¼
        self.exogenous.insert(variable.to_string(), value);
    }

    /// è®¡ç®—å› æœæ•ˆåº”
    pub fn causal_effect(&self, cause: &str, effect: &str) -> f64 {
        // ä½¿ç”¨åé—¨å‡†åˆ™è®¡ç®—å› æœæ•ˆåº”
        let backdoor_set = self.find_backdoor_set(cause, effect);
        self.compute_effect_given_backdoor(cause, effect, &backdoor_set)
    }

    /// å¯»æ‰¾åé—¨é›†åˆ
    fn find_backdoor_set(&self, cause: &str, effect: &str) -> HashSet<String> {
        let mut backdoor = HashSet::new();
        
        // æ‰¾åˆ°æ‰€æœ‰ä»causeåˆ°effectçš„åé—¨è·¯å¾„
        for variable in &self.graph.variables {
            let var_name = &variable.name;
            if var_name != cause && var_name != effect {
                // æ£€æŸ¥æ˜¯å¦æ˜¯åé—¨å˜é‡
                if self.is_backdoor_variable(var_name, cause, effect) {
                    backdoor.insert(var_name.clone());
                }
            }
        }
        
        backdoor
    }

    /// æ£€æŸ¥æ˜¯å¦æ˜¯åé—¨å˜é‡
    fn is_backdoor_variable(&self, variable: &str, cause: &str, effect: &str) -> bool {
        // å˜é‡æŒ‡å‘cause
        let points_to_cause = self.graph.has_path(variable, cause);
        
        // å˜é‡ä¸æ˜¯causeçš„åä»£
        let not_descendant = !self.graph.has_path(cause, variable);
        
        points_to_cause && not_descendant
    }

    /// ç»™å®šåé—¨é›†åˆè®¡ç®—æ•ˆåº”
    fn compute_effect_given_backdoor(&self, cause: &str, effect: &str, backdoor: &HashSet<String>) -> f64 {
        // ç®€åŒ–çš„å› æœæ•ˆåº”è®¡ç®—
        // å®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„æ¦‚ç‡è®¡ç®—
        0.5 // å ä½ç¬¦
    }
}
```

### 6.2 åäº‹å®æ¨ç†

```rust
/// åäº‹å®ä¸–ç•Œ
#[derive(Debug, Clone)]
pub struct CounterfactualWorld {
    pub facts: HashMap<String, bool>,
    pub interventions: HashMap<String, bool>,
    pub similarity_score: f64,
}

/// åäº‹å®æ¨ç†å™¨
#[derive(Debug, Clone)]
pub struct CounterfactualReasoner {
    pub actual_world: CounterfactualWorld,
    pub possible_worlds: Vec<CounterfactualWorld>,
}

impl CounterfactualReasoner {
    /// è¯„ä¼°åäº‹å®æ¡ä»¶
    pub fn evaluate_counterfactual(&self, antecedent: &str, consequent: &str) -> bool {
        // æ‰¾åˆ°æœ€ç›¸ä¼¼çš„æ»¡è¶³å‰ä»¶çš„å¯èƒ½ä¸–ç•Œ
        let closest_worlds = self.find_closest_worlds(antecedent);
        
        // æ£€æŸ¥æ‰€æœ‰æœ€ç›¸ä¼¼ä¸–ç•Œä¸­åä»¶æ˜¯å¦éƒ½ä¸ºçœŸ
        closest_worlds.iter().all(|world| {
            world.facts.get(consequent).unwrap_or(&false)
        })
    }

    /// æ‰¾åˆ°æœ€ç›¸ä¼¼çš„å¯èƒ½ä¸–ç•Œ
    fn find_closest_worlds(&self, antecedent: &str) -> Vec<&CounterfactualWorld> {
        let mut satisfying_worlds: Vec<&CounterfactualWorld> = self.possible_worlds
            .iter()
            .filter(|world| {
                world.facts.get(antecedent).unwrap_or(&false)
            })
            .collect();
        
        // æŒ‰ç›¸ä¼¼æ€§æ’åº
        satisfying_worlds.sort_by(|a, b| {
            b.similarity_score.partial_cmp(&a.similarity_score).unwrap()
        });
        
        // è¿”å›æœ€ç›¸ä¼¼çš„ä¸–ç•Œ
        if let Some(max_similarity) = satisfying_worlds.first().map(|w| w.similarity_score) {
            satisfying_worlds.retain(|w| w.similarity_score == max_similarity);
        }
        
        satisfying_worlds
    }

    /// è®¡ç®—ä¸–ç•Œç›¸ä¼¼æ€§
    pub fn compute_similarity(&self, world: &CounterfactualWorld) -> f64 {
        let mut similarity = 0.0;
        
        // äº‹å®åŒ¹é…åº¦
        for (fact, value) in &self.actual_world.facts {
            if world.facts.get(fact) == Some(value) {
                similarity += 1.0;
            }
        }
        
        // è‡ªç„¶å¾‹è¿åæƒ©ç½š
        for intervention in &world.interventions {
            if intervention.1 {
                similarity -= 0.5; // å¹²é¢„æƒ©ç½š
            }
        }
        
        similarity
    }
}
```

### 6.3 å› æœå‘ç°ç®—æ³•

```rust
/// æ¡ä»¶ç‹¬ç«‹æ€§æµ‹è¯•
#[derive(Debug, Clone)]
pub struct IndependenceTest {
    pub data: Vec<HashMap<String, f64>>,
}

impl IndependenceTest {
    /// æµ‹è¯•æ¡ä»¶ç‹¬ç«‹æ€§
    pub fn test_independence(&self, x: &str, y: &str, condition: &[String]) -> (f64, f64) {
        // ç®€åŒ–çš„ç‹¬ç«‹æ€§æµ‹è¯•
        // å®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„ç»Ÿè®¡æµ‹è¯•
        
        let p_value = 0.05; // å ä½ç¬¦
        let statistic = 3.84; // å ä½ç¬¦
        
        (p_value, statistic)
    }
}

/// PCç®—æ³•å®ç°
#[derive(Debug, Clone)]
pub struct PCAlgorithm {
    pub independence_test: IndependenceTest,
    pub significance_level: f64,
}

impl PCAlgorithm {
    /// æ‰§è¡ŒPCç®—æ³•
    pub fn run(&self, variables: &[String]) -> CausalGraph {
        let mut graph = CausalGraph {
            variables: variables.iter().map(|v| CausalVariable {
                name: v.clone(),
                domain: vec![],
            }).collect(),
            edges: Vec::new(),
            adjacency: HashMap::new(),
        };
        
        // æ­¥éª¤1: æ„å»ºå®Œå…¨æ— å‘å›¾
        self.build_complete_graph(&mut graph);
        
        // æ­¥éª¤2: åŸºäºç‹¬ç«‹æ€§æµ‹è¯•åˆ é™¤è¾¹
        self.remove_edges_by_independence(&mut graph);
        
        // æ­¥éª¤3: ç¡®å®šæ–¹å‘
        self.orient_edges(&mut graph);
        
        graph
    }

    /// æ„å»ºå®Œå…¨æ— å‘å›¾
    fn build_complete_graph(&self, graph: &mut CausalGraph) {
        for i in 0..graph.variables.len() {
            for j in (i + 1)..graph.variables.len() {
                let edge = CausalEdge {
                    from: graph.variables[i].name.clone(),
                    to: graph.variables[j].name.clone(),
                    weight: 1.0,
                };
                graph.add_edge(edge);
            }
        }
    }

    /// åŸºäºç‹¬ç«‹æ€§æµ‹è¯•åˆ é™¤è¾¹
    fn remove_edges_by_independence(&self, graph: &mut CausalGraph) {
        let mut edges_to_remove = Vec::new();
        
        for edge in &graph.edges {
            let (p_value, _) = self.independence_test.test_independence(
                &edge.from,
                &edge.to,
                &[]
            );
            
            if p_value > self.significance_level {
                edges_to_remove.push((edge.from.clone(), edge.to.clone()));
            }
        }
        
        // åˆ é™¤è¾¹
        for (from, to) in edges_to_remove {
            graph.edges.retain(|e| !(e.from == from && e.to == to));
        }
    }

    /// ç¡®å®šè¾¹æ–¹å‘
    fn orient_edges(&self, graph: &mut CausalGraph) {
        // ç®€åŒ–çš„æ–¹å‘ç¡®å®š
        // å®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„V-ç»“æ„æ£€æµ‹
    }
}
```

## 7. åº”ç”¨ç¤ºä¾‹

### 7.1 å› æœæ•ˆåº”åˆ†æ

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_causal_effect() {
        // æ„é€ å› æœæ¨¡å‹ï¼šå¸çƒŸ -> è‚ºç™Œ <- åŸºå› 
        let mut model = CausalModel {
            graph: CausalGraph {
                variables: vec![
                    CausalVariable { name: "å¸çƒŸ".to_string(), domain: vec![] },
                    CausalVariable { name: "è‚ºç™Œ".to_string(), domain: vec![] },
                    CausalVariable { name: "åŸºå› ".to_string(), domain: vec![] },
                ],
                edges: Vec::new(),
                adjacency: HashMap::new(),
            },
            equations: Vec::new(),
            exogenous: HashMap::new(),
        };

        // æ·»åŠ å› æœè¾¹
        model.graph.add_edge(CausalEdge {
            from: "åŸºå› ".to_string(),
            to: "è‚ºç™Œ".to_string(),
            weight: 0.3,
        });
        model.graph.add_edge(CausalEdge {
            from: "å¸çƒŸ".to_string(),
            to: "è‚ºç™Œ".to_string(),
            weight: 0.7,
        });

        // è®¡ç®—å¸çƒŸå¯¹è‚ºç™Œçš„å› æœæ•ˆåº”
        let effect = model.causal_effect("å¸çƒŸ", "è‚ºç™Œ");
        assert!(effect > 0.0);
    }

    #[test]
    fn test_counterfactual_reasoning() {
        let actual_world = CounterfactualWorld {
            facts: vec![
                ("ä¸‹é›¨".to_string(), true),
                ("åœ°é¢æ¹¿".to_string(), true),
                ("å¸¦ä¼".to_string(), false),
            ].into_iter().collect(),
            interventions: HashMap::new(),
            similarity_score: 1.0,
        };

        let possible_world = CounterfactualWorld {
            facts: vec![
                ("ä¸‹é›¨".to_string(), false),
                ("åœ°é¢æ¹¿".to_string(), false),
                ("å¸¦ä¼".to_string(), false),
            ].into_iter().collect(),
            interventions: HashMap::new(),
            similarity_score: 0.8,
        };

        let reasoner = CounterfactualReasoner {
            actual_world,
            possible_worlds: vec![possible_world],
        };

        // æµ‹è¯•åäº‹å®æ¨ç†ï¼šå¦‚æœä¸ä¸‹é›¨ï¼Œåœ°é¢å°±ä¸ä¼šæ¹¿
        let result = reasoner.evaluate_counterfactual("ä¸‹é›¨", "åœ°é¢æ¹¿");
        assert!(result);
    }

    #[test]
    fn test_causal_discovery() {
        let data = vec![
            vec![("X".to_string(), 1.0), ("Y".to_string(), 2.0)].into_iter().collect(),
            vec![("X".to_string(), 2.0), ("Y".to_string(), 4.0)].into_iter().collect(),
        ];

        let independence_test = IndependenceTest { data };
        let pc_algorithm = PCAlgorithm {
            independence_test,
            significance_level: 0.05,
        };

        let variables = vec!["X".to_string(), "Y".to_string()];
        let causal_graph = pc_algorithm.run(&variables);

        // éªŒè¯å‘ç°çš„å› æœç»“æ„
        assert!(!causal_graph.edges.is_empty());
    }
}
```

## 8. ç›¸å…³ç†è®º

### 8.1 ä¸ç§‘å­¦å“²å­¦çš„å…³ç³»

å› æœç†è®ºä¸ç§‘å­¦å“²å­¦å¯†åˆ‡ç›¸å…³ï¼Œç‰¹åˆ«æ˜¯ï¼š

- **ç§‘å­¦è§£é‡Š**: å› æœè§£é‡Šåœ¨ç§‘å­¦ä¸­çš„ä½œç”¨
- **è§„å¾‹æ€§**: å› æœå¾‹ä¸è‡ªç„¶å¾‹çš„å…³ç³»
- **è¿˜åŸè®º**: å› æœå…³ç³»çš„å±‚æ¬¡ç»“æ„

### 8.2 ä¸æ¦‚ç‡è®ºçš„å…³ç³»

- **å› æœæ¦‚ç‡**: å› æœå…³ç³»çš„æ¦‚ç‡è¡¨ç¤º
- **è´å¶æ–¯ç½‘ç»œ**: å› æœå…³ç³»çš„å›¾å½¢è¡¨ç¤º
- **å› æœæ¨æ–­**: ä»æ•°æ®æ¨æ–­å› æœå…³ç³»

### 8.3 ä¸äººå·¥æ™ºèƒ½çš„å…³ç³»

- **å› æœæœºå™¨å­¦ä¹ **: åŸºäºå› æœå…³ç³»çš„æœºå™¨å­¦ä¹ 
- **åäº‹å®æ¨ç†**: åœ¨AIç³»ç»Ÿä¸­çš„åäº‹å®åˆ†æ
- **å› æœå¼ºåŒ–å­¦ä¹ **: åŸºäºå› æœå…³ç³»çš„å¼ºåŒ–å­¦ä¹ 

## 9. å‚è€ƒæ–‡çŒ®

1. Hume, D. (1739). *A Treatise of Human Nature*. Oxford University Press.
2. Lewis, D. (1973). *Counterfactuals*. Harvard University Press.
3. Pearl, J. (2009). *Causality: Models, Reasoning, and Inference*. Cambridge University Press.
4. Woodward, J. (2003). *Making Things Happen: A Theory of Causal Explanation*. Oxford University Press.
5. Spirtes, P., Glymour, C., & Scheines, R. (2000). *Causation, Prediction, and Search*. MIT Press.

---

**ç›¸å…³æ–‡æ¡£**: 
- [01.1.1 å­˜åœ¨ç†è®º](../01.1.1_å­˜åœ¨ç†è®º.md)
- [01.1.2 å®ä½“ç†è®º](../01.1.2_å®ä½“ç†è®º.md)
- [01.1.3 æ¨¡æ€ç†è®º](../01.1.3_æ¨¡æ€ç†è®º.md)
- [02.2.2 è°“è¯é€»è¾‘](../../02_Mathematical_Foundation/02.2.2_è°“è¯é€»è¾‘.md)
- [10.1.1 çº¿æ€§æ—¶æ€é€»è¾‘](../../10_Temporal_Logic_Theory/10.1.1_çº¿æ€§æ—¶æ€é€»è¾‘.md) 