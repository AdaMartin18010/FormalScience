# 01.1.3 æ¨¡æ€ç†è®º

## ğŸ“‹ æ¦‚è¿°

æ¨¡æ€ç†è®ºæ˜¯å½¢è€Œä¸Šå­¦ä¸­ç ”ç©¶å¯èƒ½æ€§ã€å¿…ç„¶æ€§ã€å¶ç„¶æ€§ç­‰æ¨¡æ€æ¦‚å¿µçš„æ ¸å¿ƒç†è®ºã€‚å®ƒæ¢è®¨äº‹ç‰©åœ¨ä¸åŒå¯èƒ½ä¸–ç•Œä¸­çš„å­˜åœ¨æ–¹å¼å’Œæ€§è´¨ï¼Œä¸ºç†è§£ç°å®ä¸–ç•Œçš„æœ¬è´¨æä¾›å½¢å¼åŒ–æ¡†æ¶ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å½¢å¼åŒ–æ¨¡æ€æ¦‚å¿µ**: å»ºç«‹å¯èƒ½æ€§ã€å¿…ç„¶æ€§çš„ç²¾ç¡®æ•°å­¦å®šä¹‰
2. **å¯èƒ½ä¸–ç•Œè¯­ä¹‰**: æ„å»ºå¯èƒ½ä¸–ç•Œç†è®ºçš„å½¢å¼åŒ–æ¨¡å‹
3. **æ¨¡æ€é€»è¾‘ç³»ç»Ÿ**: å‘å±•å®Œæ•´çš„æ¨¡æ€é€»è¾‘æ¨ç†ç³»ç»Ÿ
4. **åº”ç”¨æ‰©å±•**: å°†æ¨¡æ€ç†è®ºåº”ç”¨äºè®¤çŸ¥ã€é“ä¹‰ã€æ—¶æ€ç­‰é¢†åŸŸ

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ¨¡æ€æ¦‚å¿µ

**å®šä¹‰ 1.1.1** (æ¨¡æ€æ¦‚å¿µ)
æ¨¡æ€æ¦‚å¿µæ˜¯è¡¨è¾¾äº‹ç‰©å­˜åœ¨æ–¹å¼æˆ–æ€§è´¨çš„æ¦‚å¿µï¼Œä¸»è¦åŒ…æ‹¬ï¼š
- **å¯èƒ½æ€§** (â—‡): äº‹ç‰©å¯èƒ½å…·æœ‰çš„æ€§è´¨æˆ–çŠ¶æ€
- **å¿…ç„¶æ€§** (â–¡): äº‹ç‰©å¿…ç„¶å…·æœ‰çš„æ€§è´¨æˆ–çŠ¶æ€
- **å¶ç„¶æ€§**: äº‹ç‰©æ—¢éå¿…ç„¶ä¹Ÿéä¸å¯èƒ½çš„æ€§è´¨

### 1.2 å¯èƒ½ä¸–ç•Œ

**å®šä¹‰ 1.1.2** (å¯èƒ½ä¸–ç•Œ)
å¯èƒ½ä¸–ç•Œæ˜¯æ¨¡æ€ç†è®ºä¸­çš„åŸºæœ¬æ¦‚å¿µï¼Œè¡¨ç¤ºä¸€ç§å¯èƒ½çš„çŠ¶æ€æˆ–æƒ…å†µï¼š
- **ç°å®ä¸–ç•Œ**: æˆ‘ä»¬å®é™…ç”Ÿæ´»çš„ä¸–ç•Œ
- **å¯èƒ½ä¸–ç•Œ**: ä¸ç°å®ä¸–ç•Œç›¸å®¹çš„å…¶ä»–ä¸–ç•Œ
- **å¯è¾¾å…³ç³»**: ä¸–ç•Œä¹‹é—´çš„å¯è®¿é—®æ€§å…³ç³»

### 1.3 æ¨¡æ€å‘½é¢˜

**å®šä¹‰ 1.1.3** (æ¨¡æ€å‘½é¢˜)
æ¨¡æ€å‘½é¢˜æ˜¯åŒ…å«æ¨¡æ€ç®—å­çš„å‘½é¢˜ï¼š
- **å¿…ç„¶å‘½é¢˜**: â–¡Ï† è¡¨ç¤º"Ï†å¿…ç„¶ä¸ºçœŸ"
- **å¯èƒ½å‘½é¢˜**: â—‡Ï† è¡¨ç¤º"Ï†å¯èƒ½ä¸ºçœŸ"
- **å¶ç„¶å‘½é¢˜**: Ï† âˆ§ Â¬â–¡Ï† âˆ§ Â¬â–¡Â¬Ï†

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ¨¡æ€é€»è¾‘è¯­è¨€

**å®šä¹‰ 2.1.1** (æ¨¡æ€é€»è¾‘è¯­è¨€)
æ¨¡æ€é€»è¾‘è¯­è¨€ $\mathcal{L}_M$ ç”±ä»¥ä¸‹éƒ¨åˆ†ç»„æˆï¼š

1. **å‘½é¢˜å˜å…ƒ**: $P = \{p_1, p_2, p_3, \ldots\}$
2. **é€»è¾‘è¿æ¥è¯**: $\neg, \land, \lor, \rightarrow, \leftrightarrow$
3. **æ¨¡æ€ç®—å­**: $\Box$ (å¿…ç„¶), $\Diamond$ (å¯èƒ½)
4. **æ‹¬å·**: $(, )$

**è¯­æ³•è§„åˆ™**:
- å¦‚æœ $p \in P$ï¼Œåˆ™ $p$ æ˜¯å…¬å¼
- å¦‚æœ $\varphi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\neg\varphi$ å’Œ $\Box\varphi$ æ˜¯å…¬å¼
- å¦‚æœ $\varphi$ å’Œ $\psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $(\varphi \land \psi)$ æ˜¯å…¬å¼
- $\Diamond\varphi$ å®šä¹‰ä¸º $\neg\Box\neg\varphi$

### 2.2 å…‹é‡Œæ™®å…‹æ¨¡å‹

**å®šä¹‰ 2.1.2** (å…‹é‡Œæ™®å…‹æ¨¡å‹)
å…‹é‡Œæ™®å…‹æ¨¡å‹æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $\mathcal{M} = (W, R, V)$ï¼Œå…¶ä¸­ï¼š

- $W$ æ˜¯éç©ºçš„å¯èƒ½ä¸–ç•Œé›†åˆ
- $R \subseteq W \times W$ æ˜¯å¯è¾¾å…³ç³»
- $V: P \rightarrow 2^W$ æ˜¯èµ‹å€¼å‡½æ•°

**å®šä¹‰ 2.1.3** (æ»¡è¶³å…³ç³»)
åœ¨æ¨¡å‹ $\mathcal{M} = (W, R, V)$ ä¸­ï¼Œä¸–ç•Œ $w \in W$ æ»¡è¶³å…¬å¼ $\varphi$ï¼Œè®°ä½œ $\mathcal{M}, w \models \varphi$ï¼š

1. $\mathcal{M}, w \models p$ å½“ä¸”ä»…å½“ $w \in V(p)$
2. $\mathcal{M}, w \models \neg\varphi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \not\models \varphi$
3. $\mathcal{M}, w \models \varphi \land \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \varphi$ ä¸” $\mathcal{M}, w \models \psi$
4. $\mathcal{M}, w \models \Box\varphi$ å½“ä¸”ä»…å½“å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œæœ‰ $\mathcal{M}, v \models \varphi$

### 2.3 æ¨¡æ€ç³»ç»Ÿ

**å®šä¹‰ 2.1.4** (åŸºæœ¬æ¨¡æ€ç³»ç»Ÿ)
åŸºæœ¬æ¨¡æ€ç³»ç»Ÿ K çš„å…¬ç†å’Œæ¨ç†è§„åˆ™ï¼š

**å…¬ç†**:
- (K) $\Box(\varphi \rightarrow \psi) \rightarrow (\Box\varphi \rightarrow \Box\psi)$
- (Dual) $\Diamond\varphi \leftrightarrow \neg\Box\neg\varphi$

**æ¨ç†è§„åˆ™**:
- (MP) ä» $\varphi$ å’Œ $\varphi \rightarrow \psi$ æ¨å‡º $\psi$
- (Nec) ä» $\varphi$ æ¨å‡º $\Box\varphi$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬å®šç†

**å®šç† 3.1.1** (æ¨¡æ€å¯¹å¶æ€§)
å¯¹äºä»»æ„å…¬å¼ $\varphi$ï¼Œæœ‰ï¼š
$$\Diamond\varphi \leftrightarrow \neg\Box\neg\varphi$$

**è¯æ˜**:
æ ¹æ®å®šä¹‰ï¼Œ$\Diamond\varphi$ å®šä¹‰ä¸º $\neg\Box\neg\varphi$ï¼Œå› æ­¤ï¼š
$$\Diamond\varphi \leftrightarrow \neg\Box\neg\varphi$$

**å®šç† 3.1.2** (å¿…ç„¶æ€§åˆ†é…å¾‹)
å¯¹äºä»»æ„å…¬å¼ $\varphi$ å’Œ $\psi$ï¼Œæœ‰ï¼š
$$\Box(\varphi \land \psi) \leftrightarrow (\Box\varphi \land \Box\psi)$$

**è¯æ˜**:
1. å‡è®¾ $\mathcal{M}, w \models \Box(\varphi \land \psi)$
2. å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œæœ‰ $\mathcal{M}, v \models \varphi \land \psi$
3. å› æ­¤å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œæœ‰ $\mathcal{M}, v \models \varphi$ ä¸” $\mathcal{M}, v \models \psi$
4. æ‰€ä»¥ $\mathcal{M}, w \models \Box\varphi$ ä¸” $\mathcal{M}, w \models \Box\psi$
5. å› æ­¤ $\mathcal{M}, w \models \Box\varphi \land \Box\psi$

### 3.2 æ¡†æ¶æ€§è´¨

**å®šç† 3.1.3** (è‡ªåæ€§å¯¹åº”)
å¦‚æœæ¡†æ¶ $(W, R)$ æ˜¯è‡ªåçš„ï¼ˆå³å¯¹æ‰€æœ‰ $w \in W$ï¼Œæœ‰ $wRw$ï¼‰ï¼Œåˆ™ï¼š
$$\Box\varphi \rightarrow \varphi$$

**è¯æ˜**:
1. å‡è®¾ $\mathcal{M}, w \models \Box\varphi$
2. ç”±äº $R$ æ˜¯è‡ªåçš„ï¼Œ$wRw$ æˆç«‹
3. å› æ­¤ $\mathcal{M}, w \models \varphi$
4. æ‰€ä»¥ $\Box\varphi \rightarrow \varphi$ åœ¨è‡ªåæ¡†æ¶ä¸­æœ‰æ•ˆ

**å®šç† 3.1.4** (ä¼ é€’æ€§å¯¹åº”)
å¦‚æœæ¡†æ¶ $(W, R)$ æ˜¯ä¼ é€’çš„ï¼Œåˆ™ï¼š
$$\Box\varphi \rightarrow \Box\Box\varphi$$

**è¯æ˜**:
1. å‡è®¾ $\mathcal{M}, w \models \Box\varphi$
2. å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œæœ‰ $\mathcal{M}, v \models \varphi$
3. å¯¹æ‰€æœ‰ $u$ ä½¿å¾— $vRu$ï¼Œç”±äºä¼ é€’æ€§ï¼Œæœ‰ $wRu$
4. å› æ­¤ $\mathcal{M}, u \models \varphi$
5. æ‰€ä»¥å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $wRv$ï¼Œæœ‰ $\mathcal{M}, v \models \Box\varphi$
6. å› æ­¤ $\mathcal{M}, w \models \Box\Box\varphi$

## 4. ä»£ç å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet};

/// æ¨¡æ€é€»è¾‘å…¬å¼
#[derive(Debug, Clone, PartialEq)]
pub enum ModalFormula {
    Atom(String),
    Not(Box<ModalFormula>),
    And(Box<ModalFormula>, Box<ModalFormula>),
    Or(Box<ModalFormula>, Box<ModalFormula>),
    Implies(Box<ModalFormula>, Box<ModalFormula>),
    Necessarily(Box<ModalFormula>),
    Possibly(Box<ModalFormula>),
}

impl ModalFormula {
    /// åˆ›å»ºåŸå­å‘½é¢˜
    pub fn atom(name: &str) -> Self {
        ModalFormula::Atom(name.to_string())
    }
    
    /// åˆ›å»ºå¦å®š
    pub fn not(phi: ModalFormula) -> Self {
        ModalFormula::Not(Box::new(phi))
    }
    
    /// åˆ›å»ºåˆå–
    pub fn and(phi: ModalFormula, psi: ModalFormula) -> Self {
        ModalFormula::And(Box::new(phi), Box::new(psi))
    }
    
    /// åˆ›å»ºå¿…ç„¶
    pub fn necessarily(phi: ModalFormula) -> Self {
        ModalFormula::Necessarily(Box::new(phi))
    }
    
    /// åˆ›å»ºå¯èƒ½
    pub fn possibly(phi: ModalFormula) -> Self {
        ModalFormula::Not(Box::new(
            ModalFormula::Necessarily(Box::new(ModalFormula::not(phi)))
        ))
    }
}

/// å…‹é‡Œæ™®å…‹æ¨¡å‹
#[derive(Debug)]
pub struct KripkeModel {
    worlds: Vec<String>,
    relation: HashMap<String, HashSet<String>>,
    valuation: HashMap<String, HashSet<String>>,
}

impl KripkeModel {
    /// åˆ›å»ºæ–°çš„å…‹é‡Œæ™®å…‹æ¨¡å‹
    pub fn new() -> Self {
        KripkeModel {
            worlds: Vec::new(),
            relation: HashMap::new(),
            valuation: HashMap::new(),
        }
    }
    
    /// æ·»åŠ ä¸–ç•Œ
    pub fn add_world(&mut self, world: &str) {
        if !self.worlds.contains(&world.to_string()) {
            self.worlds.push(world.to_string());
            self.relation.insert(world.to_string(), HashSet::new());
        }
    }
    
    /// æ·»åŠ å¯è¾¾å…³ç³»
    pub fn add_relation(&mut self, from: &str, to: &str) {
        self.add_world(from);
        self.add_world(to);
        self.relation.get_mut(from).unwrap().insert(to.to_string());
    }
    
    /// è®¾ç½®åŸå­å‘½é¢˜çš„çœŸå€¼
    pub fn set_valuation(&mut self, atom: &str, world: &str, value: bool) {
        self.add_world(world);
        if value {
            self.valuation.entry(atom.to_string())
                .or_insert_with(HashSet::new)
                .insert(world.to_string());
        }
    }
    
    /// æ£€æŸ¥å…¬å¼åœ¨ä¸–ç•Œä¸­æ˜¯å¦ä¸ºçœŸ
    pub fn satisfies(&self, world: &str, formula: &ModalFormula) -> bool {
        match formula {
            ModalFormula::Atom(name) => {
                self.valuation.get(name)
                    .map_or(false, |worlds| worlds.contains(world))
            }
            ModalFormula::Not(phi) => {
                !self.satisfies(world, phi)
            }
            ModalFormula::And(phi, psi) => {
                self.satisfies(world, phi) && self.satisfies(world, psi)
            }
            ModalFormula::Or(phi, psi) => {
                self.satisfies(world, phi) || self.satisfies(world, psi)
            }
            ModalFormula::Implies(phi, psi) => {
                !self.satisfies(world, phi) || self.satisfies(world, psi)
            }
            ModalFormula::Necessarily(phi) => {
                self.relation.get(world)
                    .map_or(true, |successors| {
                        successors.iter().all(|w| self.satisfies(w, phi))
                    })
            }
            ModalFormula::Possibly(phi) => {
                self.relation.get(world)
                    .map_or(false, |successors| {
                        successors.iter().any(|w| self.satisfies(w, phi))
                    })
            }
        }
    }
    
    /// æ£€æŸ¥å…¬å¼æ˜¯å¦åœ¨æ‰€æœ‰ä¸–ç•Œä¸­ä¸ºçœŸ
    pub fn is_valid(&self, formula: &ModalFormula) -> bool {
        self.worlds.iter().all(|w| self.satisfies(w, formula))
    }
}

/// æ¨¡æ€é€»è¾‘æ¨ç†ç³»ç»Ÿ
pub struct ModalLogicSystem {
    model: KripkeModel,
}

impl ModalLogicSystem {
    /// åˆ›å»ºæ–°çš„æ¨¡æ€é€»è¾‘ç³»ç»Ÿ
    pub fn new() -> Self {
        ModalLogicSystem {
            model: KripkeModel::new(),
        }
    }
    
    /// æ·»åŠ å…¬ç† K
    pub fn add_axiom_k(&mut self) {
        // â–¡(Ï† â†’ Ïˆ) â†’ (â–¡Ï† â†’ â–¡Ïˆ)
        let phi = ModalFormula::atom("p");
        let psi = ModalFormula::atom("q");
        let axiom_k = ModalFormula::Implies(
            Box::new(ModalFormula::Necessarily(Box::new(
                ModalFormula::Implies(Box::new(phi.clone()), Box::new(psi.clone()))
            ))),
            Box::new(ModalFormula::Implies(
                Box::new(ModalFormula::Necessarily(Box::new(phi))),
                Box::new(ModalFormula::Necessarily(Box::new(psi)))
            ))
        );
        
        // éªŒè¯å…¬ç† K çš„æœ‰æ•ˆæ€§
        assert!(self.model.is_valid(&axiom_k), "Axiom K should be valid");
    }
    
    /// éªŒè¯å¿…ç„¶æ€§åˆ†é…å¾‹
    pub fn verify_necessity_distribution(&mut self) {
        let phi = ModalFormula::atom("p");
        let psi = ModalFormula::atom("q");
        
        let left = ModalFormula::Necessarily(Box::new(
            ModalFormula::And(Box::new(phi.clone()), Box::new(psi.clone()))
        ));
        
        let right = ModalFormula::And(
            Box::new(ModalFormula::Necessarily(Box::new(phi))),
            Box::new(ModalFormula::Necessarily(Box::new(psi)))
        );
        
        let distribution_law = ModalFormula::Implies(Box::new(left), Box::new(right));
        
        assert!(self.model.is_valid(&distribution_law), 
                "Necessity distribution law should be valid");
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_modal_logic_basics() {
        let mut system = ModalLogicSystem::new();
        
        // æ·»åŠ ä¸€äº›ä¸–ç•Œå’Œå…³ç³»
        system.model.add_world("w1");
        system.model.add_world("w2");
        system.model.add_relation("w1", "w2");
        
        // è®¾ç½®åŸå­å‘½é¢˜çš„çœŸå€¼
        system.model.set_valuation("p", "w1", true);
        system.model.set_valuation("p", "w2", true);
        
        // æµ‹è¯•å¿…ç„¶æ€§
        let phi = ModalFormula::atom("p");
        let necessarily_phi = ModalFormula::necessarily(phi);
        
        assert!(system.model.satisfies("w1", &necessarily_phi));
    }
    
    #[test]
    fn test_possibility_definition() {
        let phi = ModalFormula::atom("p");
        let possibly_phi = ModalFormula::possibly(phi.clone());
        let not_necessarily_not_phi = ModalFormula::not(
            ModalFormula::necessarily(ModalFormula::not(phi))
        );
        
        assert_eq!(possibly_phi, not_necessarily_not_phi);
    }
}
```

### 4.2 Haskell å®ç°

```haskell
-- æ¨¡æ€é€»è¾‘å…¬å¼
data ModalFormula = Atom String
                  | Not ModalFormula
                  | And ModalFormula ModalFormula
                  | Or ModalFormula ModalFormula
                  | Implies ModalFormula ModalFormula
                  | Necessarily ModalFormula
                  | Possibly ModalFormula
                  deriving (Eq, Show)

-- å…‹é‡Œæ™®å…‹æ¨¡å‹
data KripkeModel = KripkeModel {
    worlds :: [String],
    relation :: [(String, String)],
    valuation :: [(String, [String])]
} deriving Show

-- åˆ›å»ºç©ºæ¨¡å‹
emptyModel :: KripkeModel
emptyModel = KripkeModel [] [] []

-- æ·»åŠ ä¸–ç•Œ
addWorld :: String -> KripkeModel -> KripkeModel
addWorld w model = model { worlds = w : worlds model }

-- æ·»åŠ å¯è¾¾å…³ç³»
addRelation :: String -> String -> KripkeModel -> KripkeModel
addRelation from to model = model { 
    relation = (from, to) : relation model 
}

-- è®¾ç½®åŸå­å‘½é¢˜çš„çœŸå€¼
setValuation :: String -> String -> Bool -> KripkeModel -> KripkeModel
setValuation atom world True model = model {
    valuation = (atom, world : getValuation atom model) : 
                filter (\(a, _) -> a /= atom) (valuation model)
}
setValuation atom world False model = model {
    valuation = filter (\(a, ws) -> a /= atom || world `notElem` ws) (valuation model)
}

-- è·å–åŸå­å‘½é¢˜åœ¨ä¸–ç•Œä¸­çš„çœŸå€¼
getValuation :: String -> KripkeModel -> [String]
getValuation atom model = case lookup atom (valuation model) of
    Just worlds -> worlds
    Nothing -> []

-- æ£€æŸ¥å…¬å¼åœ¨ä¸–ç•Œä¸­æ˜¯å¦ä¸ºçœŸ
satisfies :: KripkeModel -> String -> ModalFormula -> Bool
satisfies model world formula = case formula of
    Atom name -> world `elem` getValuation name model
    Not phi -> not (satisfies model world phi)
    And phi psi -> satisfies model world phi && satisfies model world psi
    Or phi psi -> satisfies model world phi || satisfies model world psi
    Implies phi psi -> not (satisfies model world phi) || satisfies model world psi
    Necessarily phi -> all (\w -> satisfies model w phi) (getSuccessors model world)
    Possibly phi -> any (\w -> satisfies model w phi) (getSuccessors model world)

-- è·å–ä¸–ç•Œçš„åç»§
getSuccessors :: KripkeModel -> String -> [String]
getSuccessors model world = [w | (from, w) <- relation model, from == world]

-- æ£€æŸ¥å…¬å¼æ˜¯å¦åœ¨æ‰€æœ‰ä¸–ç•Œä¸­ä¸ºçœŸ
isValid :: KripkeModel -> ModalFormula -> Bool
isValid model formula = all (\w -> satisfies model w formula) (worlds model)

-- æ¨¡æ€é€»è¾‘æ¨ç†ç³»ç»Ÿ
data ModalLogicSystem = ModalLogicSystem {
    model :: KripkeModel
}

-- åˆ›å»ºæ–°çš„æ¨¡æ€é€»è¾‘ç³»ç»Ÿ
newSystem :: ModalLogicSystem
newSystem = ModalLogicSystem emptyModel

-- éªŒè¯å…¬ç† K
verifyAxiomK :: ModalLogicSystem -> Bool
verifyAxiomK system = 
    let phi = Atom "p"
        psi = Atom "q"
        axiomK = Implies 
                    (Necessarily (Implies phi psi))
                    (Implies (Necessarily phi) (Necessarily psi))
    in isValid (model system) axiomK

-- éªŒè¯å¿…ç„¶æ€§åˆ†é…å¾‹
verifyNecessityDistribution :: ModalLogicSystem -> Bool
verifyNecessityDistribution system =
    let phi = Atom "p"
        psi = Atom "q"
        left = Necessarily (And phi psi)
        right = And (Necessarily phi) (Necessarily psi)
        distributionLaw = Implies left right
    in isValid (model system) distributionLaw

-- æµ‹è¯•å‡½æ•°
testModalLogic :: IO ()
testModalLogic = do
    let model = addWorld "w1" $ addWorld "w2" emptyModel
    let model' = addRelation "w1" "w2" model
    let model'' = setValuation "p" "w1" True $ 
                  setValuation "p" "w2" True model'
    
    let system = ModalLogicSystem model''
    let phi = Atom "p"
    let necessarilyPhi = Necessarily phi
    
    putStrLn $ "Necessarily p at w1: " ++ show (satisfies model'' "w1" necessarilyPhi)
    putStrLn $ "Axiom K is valid: " ++ show (verifyAxiomK system)
    putStrLn $ "Necessity distribution is valid: " ++ show (verifyNecessityDistribution system)
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 è®¤çŸ¥æ¨¡æ€é€»è¾‘

è®¤çŸ¥æ¨¡æ€é€»è¾‘å°†æ¨¡æ€ç†è®ºåº”ç”¨äºçŸ¥è¯†è®ºï¼š

```rust
/// è®¤çŸ¥æ¨¡æ€é€»è¾‘
pub struct EpistemicLogic {
    agents: Vec<String>,
    knowledge_relation: HashMap<String, HashMap<String, HashSet<String>>>,
}

impl EpistemicLogic {
    /// åˆ›å»ºè®¤çŸ¥æ¨¡æ€é€»è¾‘ç³»ç»Ÿ
    pub fn new(agents: Vec<String>) -> Self {
        let mut knowledge_relation = HashMap::new();
        for agent in &agents {
            knowledge_relation.insert(agent.clone(), HashMap::new());
        }
        
        EpistemicLogic {
            agents,
            knowledge_relation,
        }
    }
    
    /// æ·»åŠ ä»£ç†çš„çŸ¥è¯†å…³ç³»
    pub fn add_knowledge_relation(&mut self, agent: &str, world1: &str, world2: &str) {
        self.knowledge_relation.get_mut(agent)
            .unwrap()
            .entry(world1.to_string())
            .or_insert_with(HashSet::new)
            .insert(world2.to_string());
    }
    
    /// æ£€æŸ¥ä»£ç†æ˜¯å¦çŸ¥é“å…¬å¼
    pub fn knows(&self, agent: &str, world: &str, formula: &ModalFormula) -> bool {
        // ä»£ç†çŸ¥é“Ï†å½“ä¸”ä»…å½“åœ¨æ‰€æœ‰ä¸å½“å‰ä¸–ç•Œä¸å¯åŒºåˆ†çš„ä¸–ç•Œä¸­Ï†éƒ½ä¸ºçœŸ
        self.knowledge_relation.get(agent)
            .and_then(|relations| relations.get(world))
            .map_or(false, |indistinguishable_worlds| {
                indistinguishable_worlds.iter().all(|w| {
                    // è¿™é‡Œéœ€è¦å®ç°å…¬å¼åœ¨ä¸–ç•Œä¸­çš„çœŸå€¼æ£€æŸ¥
                    true // ç®€åŒ–å®ç°
                })
            })
    }
}
```

### 5.2 é“ä¹‰æ¨¡æ€é€»è¾‘

é“ä¹‰æ¨¡æ€é€»è¾‘ç ”ç©¶ä¹‰åŠ¡ã€å…è®¸ã€ç¦æ­¢ç­‰æ¦‚å¿µï¼š

```rust
/// é“ä¹‰æ¨¡æ€é€»è¾‘
pub struct DeonticLogic {
    ideal_worlds: HashSet<String>,
    accessibility_relation: HashMap<String, HashSet<String>>,
}

impl DeonticLogic {
    /// åˆ›å»ºé“ä¹‰æ¨¡æ€é€»è¾‘ç³»ç»Ÿ
    pub fn new() -> Self {
        DeonticLogic {
            ideal_worlds: HashSet::new(),
            accessibility_relation: HashMap::new(),
        }
    }
    
    /// æ·»åŠ ç†æƒ³ä¸–ç•Œ
    pub fn add_ideal_world(&mut self, world: &str) {
        self.ideal_worlds.insert(world.to_string());
    }
    
    /// æ·»åŠ å¯è¾¾å…³ç³»ï¼ˆä»ç°å®ä¸–ç•Œåˆ°ç†æƒ³ä¸–ç•Œï¼‰
    pub fn add_accessibility(&mut self, from: &str, to: &str) {
        self.accessibility_relation.entry(from.to_string())
            .or_insert_with(HashSet::new)
            .insert(to.to_string());
    }
    
    /// æ£€æŸ¥ä¹‰åŠ¡ï¼ˆOÏ†ï¼šåœ¨æ‰€æœ‰ç†æƒ³ä¸–ç•Œä¸­Ï†ä¸ºçœŸï¼‰
    pub fn is_obligatory(&self, world: &str, formula: &ModalFormula) -> bool {
        self.accessibility_relation.get(world)
            .map_or(false, |ideal_worlds| {
                ideal_worlds.iter().all(|w| {
                    // æ£€æŸ¥åœ¨ç†æƒ³ä¸–ç•Œä¸­å…¬å¼æ˜¯å¦ä¸ºçœŸ
                    true // ç®€åŒ–å®ç°
                })
            })
    }
    
    /// æ£€æŸ¥å…è®¸ï¼ˆPÏ†ï¼šåœ¨æŸä¸ªç†æƒ³ä¸–ç•Œä¸­Ï†ä¸ºçœŸï¼‰
    pub fn is_permitted(&self, world: &str, formula: &ModalFormula) -> bool {
        self.accessibility_relation.get(world)
            .map_or(false, |ideal_worlds| {
                ideal_worlds.iter().any(|w| {
                    // æ£€æŸ¥åœ¨æŸä¸ªç†æƒ³ä¸–ç•Œä¸­å…¬å¼æ˜¯å¦ä¸ºçœŸ
                    true // ç®€åŒ–å®ç°
                })
            })
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å­˜åœ¨ç†è®ºçš„å…³ç³»

æ¨¡æ€ç†è®ºä¸å­˜åœ¨ç†è®ºå¯†åˆ‡ç›¸å…³ï¼š
- **å­˜åœ¨æ¨¡æ€**: ç ”ç©¶äº‹ç‰©åœ¨ä¸åŒå¯èƒ½ä¸–ç•Œä¸­çš„å­˜åœ¨æ–¹å¼
- **æœ¬è´¨å±æ€§**: åŒºåˆ†å¿…ç„¶å±æ€§å’Œå¶ç„¶å±æ€§
- **è·¨ä¸–ç•ŒåŒä¸€æ€§**: ç ”ç©¶åŒä¸€äº‹ç‰©åœ¨ä¸åŒä¸–ç•Œä¸­çš„è¯†åˆ«é—®é¢˜

### 6.2 ä¸å®ä½“ç†è®ºçš„å…³ç³»

æ¨¡æ€ç†è®ºä¸ºå®ä½“ç†è®ºæä¾›å½¢å¼åŒ–å·¥å…·ï¼š
- **å®ä½“æ¨¡æ€**: ç ”ç©¶å®ä½“çš„å¯èƒ½æ€§å’Œå¿…ç„¶æ€§
- **æ¨¡æ€å®åœ¨è®º**: å…³äºå¯èƒ½ä¸–ç•Œæœ¬ä½“è®ºåœ°ä½çš„å“²å­¦ç«‹åœº
- **åäº‹å®æ¨ç†**: åŸºäºæ¨¡æ€æ¦‚å¿µçš„åäº‹å®æ¡ä»¶å¥åˆ†æ

### 6.3 ä¸é€»è¾‘å“²å­¦çš„å…³ç³»

æ¨¡æ€ç†è®ºæ˜¯é€»è¾‘å“²å­¦çš„æ ¸å¿ƒå†…å®¹ï¼š
- **æ¨¡æ€é€»è¾‘**: å½¢å¼åŒ–æ¨¡æ€æ¨ç†çš„é€»è¾‘ç³»ç»Ÿ
- **å¯èƒ½ä¸–ç•Œè¯­ä¹‰**: ä¸ºæ¨¡æ€é€»è¾‘æä¾›è¯­ä¹‰è§£é‡Š
- **æ¨¡æ€è®¤è¯†è®º**: ç ”ç©¶æ¨¡æ€çŸ¥è¯†çš„æ¥æºå’Œæ€§è´¨

## 7. å‚è€ƒæ–‡çŒ®

1. Kripke, S. A. (1963). Semantical considerations on modal logic. *Acta Philosophica Fennica*, 16, 83-94.

2. Hughes, G. E., & Cresswell, M. J. (1996). *A new introduction to modal logic*. Routledge.

3. Blackburn, P., de Rijke, M., & Venema, Y. (2001). *Modal logic*. Cambridge University Press.

4. Garson, J. W. (2013). *Modal logic for philosophers*. Cambridge University Press.

5. Chagrov, A., & Zakharyaschev, M. (1997). *Modal logic*. Oxford University Press.

---

**ç›¸å…³æ–‡æ¡£**:
- [01.1.1 å­˜åœ¨ç†è®º](../01.1.1_Existence_Theory.md)
- [01.1.2 å®ä½“ç†è®º](../01.1.2_Entity_Theory.md)
- [01.1.4 å› æœç†è®º](../01.1.4_Causation_Theory.md)
- [01.4.1 é€»è¾‘åŸºç¡€](../../01.4_Logic_Foundation/01.4.1_Logical_Foundation.md) 