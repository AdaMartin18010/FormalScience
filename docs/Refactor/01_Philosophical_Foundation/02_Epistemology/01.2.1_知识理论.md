# 01.2.1 çŸ¥è¯†ç†è®º

## ğŸ“‹ æ¦‚è¿°

çŸ¥è¯†ç†è®ºæ˜¯è®¤è¯†è®ºä¸­ç ”ç©¶çŸ¥è¯†æœ¬è´¨ã€æ¥æºã€ç»“æ„å’Œç¡®è¯çš„æ ¸å¿ƒç†è®ºã€‚å®ƒæ¢è®¨ä»€ä¹ˆæ˜¯çŸ¥è¯†ã€å¦‚ä½•è·å¾—çŸ¥è¯†ã€çŸ¥è¯†çš„å¯é æ€§ç­‰é—®é¢˜ï¼Œä¸ºç†è§£äººç±»è®¤çŸ¥æ´»åŠ¨æä¾›å“²å­¦åŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹çŸ¥è¯†æ¦‚å¿µçš„å½¢å¼åŒ–ä½“ç³»**
2. **åˆ†æçŸ¥è¯†çš„æœ¬è´¨ç‰¹å¾å’Œæ¡ä»¶**
3. **æ¢è®¨çŸ¥è¯†çš„æ¥æºå’Œè·å¾—æ–¹å¼**
4. **æ„å»ºçŸ¥è¯†ç¡®è¯çš„ç†è®ºæ¡†æ¶**
5. **ç ”ç©¶çŸ¥è¯†æ¨ç†çš„æœ‰æ•ˆæ€§**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 çŸ¥è¯†æ¦‚å¿µ

**å®šä¹‰ 1.1.1** (çŸ¥è¯†)
çŸ¥è¯†æ˜¯æŒ‡è¢«ç¡®è¯çš„çœŸä¿¡å¿µï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š

- **çœŸç†æ€§**: çŸ¥è¯†å¿…é¡»æ˜¯çœŸå®çš„
- **ä¿¡å¿µæ€§**: çŸ¥è¯†å¿…é¡»æ˜¯è¢«ç›¸ä¿¡çš„
- **ç¡®è¯æ€§**: çŸ¥è¯†å¿…é¡»æœ‰å……åˆ†çš„ç†ç”±æ”¯æŒ
- **å¯é æ€§**: çŸ¥è¯†å¿…é¡»é€šè¿‡å¯é çš„æ–¹æ³•è·å¾—

### 1.2 çŸ¥è¯†ç±»å‹

**å®šä¹‰ 1.1.2** (çŸ¥è¯†ç±»å‹åˆ†ç±»)
çŸ¥è¯†å¯ä»¥åˆ†ä¸ºä»¥ä¸‹ç±»å‹ï¼š

1. **å‘½é¢˜çŸ¥è¯†**: å…³äºäº‹å®çš„çŸ¥è¯† (çŸ¥é“p)
2. **èƒ½åŠ›çŸ¥è¯†**: å…³äºå¦‚ä½•åšçš„çŸ¥è¯† (çŸ¥é“å¦‚ä½•)
3. **äº²çŸ¥çŸ¥è¯†**: å…³äºç›´æ¥ç»éªŒçš„çŸ¥è¯† (çŸ¥é“ä»€ä¹ˆ)
4. **å…ˆéªŒçŸ¥è¯†**: ä¸ä¾èµ–ç»éªŒçš„çŸ¥è¯†
5. **åéªŒçŸ¥è¯†**: ä¾èµ–ç»éªŒçš„çŸ¥è¯†

### 1.3 çŸ¥è¯†æ¡ä»¶

**å®šä¹‰ 1.1.3** (ä¼ ç»ŸçŸ¥è¯†æ¡ä»¶)
æ ¹æ®æŸæ‹‰å›¾ä¼ ç»Ÿï¼ŒçŸ¥è¯†éœ€è¦æ»¡è¶³ä¸‰ä¸ªæ¡ä»¶ï¼š

- **çœŸç†æ€§æ¡ä»¶**: SçŸ¥é“pï¼Œä»…å½“pä¸ºçœŸ
- **ä¿¡å¿µæ¡ä»¶**: SçŸ¥é“pï¼Œä»…å½“Sç›¸ä¿¡p
- **ç¡®è¯æ¡ä»¶**: SçŸ¥é“pï¼Œä»…å½“Sæœ‰å……åˆ†çš„ç†ç”±ç›¸ä¿¡p

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 çŸ¥è¯†é€»è¾‘è¯­è¨€

**å®šä¹‰ 1.2.1** (çŸ¥è¯†é€»è¾‘è¯­è¨€)
çŸ¥è¯†é€»è¾‘è¯­è¨€ $\mathcal{L}_K$ ç”±ä»¥ä¸‹éƒ¨åˆ†ç»„æˆï¼š

1. **ä¸»ä½“å˜å…ƒ**: $a_1, a_2, a_3, \ldots \in \mathcal{A}$
2. **å‘½é¢˜å˜å…ƒ**: $p, q, r, \ldots \in \mathcal{P}$
3. **çŸ¥è¯†ç®—å­**: $K_a$ (ä¸»ä½“açŸ¥é“)
4. **ä¿¡å¿µç®—å­**: $B_a$ (ä¸»ä½“aç›¸ä¿¡)
5. **ç¡®è¯ç®—å­**: $J_a$ (ä¸»ä½“aç¡®è¯)
6. **é€»è¾‘è¿æ¥è¯**: $\neg, \land, \lor, \rightarrow, \leftrightarrow$

**è¯­æ³•è§„åˆ™**:

- å¦‚æœ $p \in \mathcal{P}$ï¼Œåˆ™ $p$ æ˜¯å…¬å¼
- å¦‚æœ $\varphi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\neg\varphi$ æ˜¯å…¬å¼
- å¦‚æœ $\varphi, \psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $(\varphi \land \psi), (\varphi \lor \psi), (\varphi \rightarrow \psi), (\varphi \leftrightarrow \psi)$ æ˜¯å…¬å¼
- å¦‚æœ $\varphi$ æ˜¯å…¬å¼ä¸” $a \in \mathcal{A}$ï¼Œåˆ™ $K_a\varphi, B_a\varphi, J_a\varphi$ æ˜¯å…¬å¼

### 2.2 çŸ¥è¯†è¯­ä¹‰

**å®šä¹‰ 1.2.2** (çŸ¥è¯†æ¨¡å‹)
çŸ¥è¯†æ¨¡å‹æ˜¯ä¸€ä¸ªå››å…ƒç»„ $\mathcal{K} = (W, \sim_a, V, \mathcal{E})$ï¼Œå…¶ä¸­ï¼š

- $W$ æ˜¯éç©ºçš„ä¸–ç•Œé›†åˆ
- $\sim_a \subseteq W \times W$ æ˜¯ä¸»ä½“açš„ä¸å¯åŒºåˆ†å…³ç³»
- $V: \mathcal{P} \rightarrow 2^W$ æ˜¯å‘½é¢˜èµ‹å€¼å‡½æ•°
- $\mathcal{E}: \mathcal{A} \times W \rightarrow 2^{\mathcal{P}}$ æ˜¯è¯æ®å‡½æ•°

**å®šä¹‰ 1.2.3** (çŸ¥è¯†å…¬å¼çš„çœŸå€¼)
ç»™å®šçŸ¥è¯†æ¨¡å‹ $\mathcal{K} = (W, \sim_a, V, \mathcal{E})$ å’Œä¸–ç•Œ $w \in W$ï¼ŒçŸ¥è¯†å…¬å¼çš„çœŸå€¼å®šä¹‰å¦‚ä¸‹ï¼š

1. $\mathcal{K}, w \models p$ å½“ä¸”ä»…å½“ $w \in V(p)$
2. $\mathcal{K}, w \models \neg\varphi$ å½“ä¸”ä»…å½“ $\mathcal{K}, w \not\models \varphi$
3. $\mathcal{K}, w \models \varphi \land \psi$ å½“ä¸”ä»…å½“ $\mathcal{K}, w \models \varphi$ ä¸” $\mathcal{K}, w \models \psi$
4. $\mathcal{K}, w \models \varphi \lor \psi$ å½“ä¸”ä»…å½“ $\mathcal{K}, w \models \varphi$ æˆ– $\mathcal{K}, w \models \psi$
5. $\mathcal{K}, w \models \varphi \rightarrow \psi$ å½“ä¸”ä»…å½“ $\mathcal{K}, w \not\models \varphi$ æˆ– $\mathcal{K}, w \models \psi$
6. $\mathcal{K}, w \models K_a\varphi$ å½“ä¸”ä»…å½“ å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{K}, v \models \varphi$
7. $\mathcal{K}, w \models B_a\varphi$ å½“ä¸”ä»…å½“ ä¸»ä½“aåœ¨ä¸–ç•Œwä¸­ç›¸ä¿¡$\varphi$
8. $\mathcal{K}, w \models J_a\varphi$ å½“ä¸”ä»…å½“ ä¸»ä½“aåœ¨ä¸–ç•Œwä¸­æœ‰è¯æ®æ”¯æŒ$\varphi$

### 2.3 çŸ¥è¯†å®šä¹‰

**å®šä¹‰ 1.2.4** (çŸ¥è¯†çš„å½¢å¼åŒ–å®šä¹‰)
åœ¨çŸ¥è¯†æ¨¡å‹ $\mathcal{K}$ ä¸­ï¼Œä¸»ä½“açŸ¥é“å‘½é¢˜pï¼Œè®°ä½œ $K_a p$ï¼Œå½“ä¸”ä»…å½“ï¼š
$$K_a p \equiv p \land B_a p \land J_a p$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 çŸ¥è¯†å…¬ç†

**å®šç† 1.3.1** (çŸ¥è¯†å…¬ç†)
çŸ¥è¯†ç®—å­æ»¡è¶³ä»¥ä¸‹å…¬ç†ï¼š

1. **çœŸç†æ€§**: $K_a p \rightarrow p$
2. **æ­£å†…çœ**: $K_a p \rightarrow K_a K_a p$
3. **è´Ÿå†…çœ**: $\neg K_a p \rightarrow K_a \neg K_a p$
4. **åˆ†é…å¾‹**: $K_a(p \rightarrow q) \rightarrow (K_a p \rightarrow K_a q)$

**è¯æ˜**:
è®¾ $\mathcal{K} = (W, \sim_a, V, \mathcal{E})$ æ˜¯çŸ¥è¯†æ¨¡å‹ï¼Œ$w \in W$ æ˜¯ä»»æ„ä¸–ç•Œã€‚

1. è¯æ˜çœŸç†æ€§ $K_a p \rightarrow p$:
   - $\mathcal{K}, w \models K_a p$ å½“ä¸”ä»…å½“ å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{K}, v \models p$
   - ç”±äº $\sim_a$ æ˜¯è‡ªåçš„ï¼Œ$w \sim_a w$ï¼Œæ‰€ä»¥ $\mathcal{K}, w \models p$
   - å› æ­¤ $\mathcal{K}, w \models K_a p \rightarrow p$

2. è¯æ˜æ­£å†…çœ $K_a p \rightarrow K_a K_a p$:
   - $\mathcal{K}, w \models K_a p$ æ„å‘³ç€å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{K}, v \models p$
   - ç”±äº $\sim_a$ æ˜¯ä¼ é€’çš„ï¼Œå¯¹æ‰€æœ‰ $u$ ä½¿å¾— $v \sim_a u$ï¼Œæœ‰ $\mathcal{K}, u \models p$
   - å› æ­¤ $\mathcal{K}, v \models K_a p$ å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ æˆç«‹
   - æ‰€ä»¥ $\mathcal{K}, w \models K_a K_a p$

3. è¯æ˜è´Ÿå†…çœ $\neg K_a p \rightarrow K_a \neg K_a p$:
   - $\mathcal{K}, w \models \neg K_a p$ æ„å‘³ç€å­˜åœ¨ $v$ ä½¿å¾— $w \sim_a v$ ä¸” $\mathcal{K}, v \not\models p$
   - ç”±äº $\sim_a$ æ˜¯å¯¹ç§°çš„ï¼Œå¯¹æ‰€æœ‰ $u$ ä½¿å¾— $w \sim_a u$ï¼Œå­˜åœ¨ $v$ ä½¿å¾— $u \sim_a v$ ä¸” $\mathcal{K}, v \not\models p$
   - å› æ­¤ $\mathcal{K}, u \models \neg K_a p$ å¯¹æ‰€æœ‰ $u$ ä½¿å¾— $w \sim_a u$ æˆç«‹
   - æ‰€ä»¥ $\mathcal{K}, w \models K_a \neg K_a p$

4. è¯æ˜åˆ†é…å¾‹ $K_a(p \rightarrow q) \rightarrow (K_a p \rightarrow K_a q)$:
   - $\mathcal{K}, w \models K_a(p \rightarrow q)$ æ„å‘³ç€å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{K}, v \models p \rightarrow q$
   - $\mathcal{K}, w \models K_a p$ æ„å‘³ç€å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{K}, v \models p$
   - å› æ­¤å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{K}, v \models q$
   - æ‰€ä»¥ $\mathcal{K}, w \models K_a q$

### 3.2 ç›–æ¢¯å°”é—®é¢˜

**å®šç† 1.3.2** (ç›–æ¢¯å°”åä¾‹)
ä¼ ç»Ÿçš„çŸ¥è¯†å®šä¹‰ï¼ˆçœŸä¿¡å¿µ+ç¡®è¯ï¼‰ä¸è¶³ä»¥å®šä¹‰çŸ¥è¯†ã€‚

**è¯æ˜**:
æ„é€ ç›–æ¢¯å°”åä¾‹ï¼š

è®¾ä¸»ä½“Sç›¸ä¿¡"ç¼æ–¯æœ‰ä¸€è¾†ç¦ç‰¹è½¦"ï¼Œå¹¶ä¸”ï¼š

1. Sæœ‰å……åˆ†çš„è¯æ®æ”¯æŒè¿™ä¸ªä¿¡å¿µ
2. è¿™ä¸ªä¿¡å¿µæ˜¯çœŸå®çš„
3. ä½†Sçš„è¯æ®å®é™…ä¸ŠæŒ‡å‘çš„æ˜¯å²å¯†æ–¯ï¼Œè€Œä¸æ˜¯ç¼æ–¯

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼š

- Sç›¸ä¿¡pï¼ˆçœŸç†æ€§æ¡ä»¶æ»¡è¶³ï¼‰
- pä¸ºçœŸï¼ˆä¿¡å¿µæ¡ä»¶æ»¡è¶³ï¼‰
- Sæœ‰ç¡®è¯ï¼ˆç¡®è¯æ¡ä»¶æ»¡è¶³ï¼‰
- ä½†Så¹¶ä¸çŸ¥é“pï¼ˆç›´è§‰ä¸Šä¸æ„æˆçŸ¥è¯†ï¼‰

å› æ­¤ï¼Œä¼ ç»Ÿçš„çŸ¥è¯†å®šä¹‰å­˜åœ¨åä¾‹ã€‚

### 3.3 çŸ¥è¯†å°é—­æ€§

**å®šç† 1.3.3** (çŸ¥è¯†å°é—­æ€§)
å¦‚æœä¸»ä½“çŸ¥é“pï¼Œå¹¶ä¸”çŸ¥é“pè•´å«qï¼Œé‚£ä¹ˆä¸»ä½“çŸ¥é“qã€‚

**å½¢å¼åŒ–**: $K_a p \land K_a(p \rightarrow q) \rightarrow K_a q$

**è¯æ˜**:
è®¾ $\mathcal{K} = (W, \sim_a, V, \mathcal{E})$ æ˜¯çŸ¥è¯†æ¨¡å‹ï¼Œ$w \in W$ æ˜¯ä»»æ„ä¸–ç•Œã€‚

å‡è®¾ $\mathcal{K}, w \models K_a p \land K_a(p \rightarrow q)$ã€‚

1. $\mathcal{K}, w \models K_a p$ æ„å‘³ç€å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{K}, v \models p$
2. $\mathcal{K}, w \models K_a(p \rightarrow q)$ æ„å‘³ç€å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{K}, v \models p \rightarrow q$
3. å› æ­¤å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{K}, v \models p$ ä¸” $\mathcal{K}, v \models p \rightarrow q$
4. æ ¹æ®è•´å«çš„è¯­ä¹‰ï¼Œå¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{K}, v \models q$
5. æ‰€ä»¥ $\mathcal{K}, w \models K_a q$

### 3.4 çŸ¥è¯†çš„ä¸ç¡®å®šæ€§

**å®šç† 1.3.4** (çŸ¥è¯†çš„ä¸ç¡®å®šæ€§)
çŸ¥è¯†å…·æœ‰ä¸ç¡®å®šæ€§ç‰¹å¾ï¼šä¸»ä½“å¯èƒ½ä¸çŸ¥é“è‡ªå·±çš„çŸ¥è¯†çŠ¶æ€ã€‚

**å½¢å¼åŒ–**: $\neg K_a p \land \neg K_a \neg p$ å¯èƒ½ä¸ºçœŸ

**è¯æ˜**:
æ„é€ ä¸€ä¸ªæ¨¡å‹ï¼Œå…¶ä¸­ä¸»ä½“aä¸çŸ¥é“pçš„çœŸå€¼ï¼š

è®¾ $\mathcal{K} = (W, \sim_a, V, \mathcal{E})$ï¼Œå…¶ä¸­ï¼š

- $W = \{w_1, w_2\}$
- $\sim_a = \{(w_1, w_1), (w_1, w_2), (w_2, w_1), (w_2, w_2)\}$
- $V(p) = \{w_1\}$

åœ¨è¿™ä¸ªæ¨¡å‹ä¸­ï¼š

- $\mathcal{K}, w_1 \models p$ ä½† $\mathcal{K}, w_2 \not\models p$
- ç”±äº $w_1 \sim_a w_2$ï¼Œä¸»ä½“aæ— æ³•åŒºåˆ†è¿™ä¸¤ä¸ªä¸–ç•Œ
- å› æ­¤ $\mathcal{K}, w_1 \models \neg K_a p \land \neg K_a \neg p$

## 4. ä»£ç å®ç°

### 4.1 çŸ¥è¯†é€»è¾‘è¯­è¨€å®ç°

```rust
use std::collections::HashMap;
use std::fmt;

/// ä¸»ä½“æ ‡è¯†ç¬¦
pub type AgentId = String;

/// ä¸–ç•Œæ ‡è¯†ç¬¦
pub type WorldId = usize;

/// çŸ¥è¯†é€»è¾‘å…¬å¼
#[derive(Debug, Clone, PartialEq)]
pub enum KnowledgeFormula {
    /// å‘½é¢˜å˜å…ƒ
    Proposition(String),
    /// å¦å®š
    Not(Box<KnowledgeFormula>),
    /// åˆå–
    And(Box<KnowledgeFormula>, Box<KnowledgeFormula>),
    /// æå–
    Or(Box<KnowledgeFormula>, Box<KnowledgeFormula>),
    /// è•´å«
    Implies(Box<KnowledgeFormula>, Box<KnowledgeFormula>),
    /// ç­‰ä»·
    Iff(Box<KnowledgeFormula>, Box<KnowledgeFormula>),
    /// çŸ¥è¯†ç®—å­
    Knows(AgentId, Box<KnowledgeFormula>),
    /// ä¿¡å¿µç®—å­
    Believes(AgentId, Box<KnowledgeFormula>),
    /// ç¡®è¯ç®—å­
    Justified(AgentId, Box<KnowledgeFormula>),
}

impl fmt::Display for KnowledgeFormula {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            KnowledgeFormula::Proposition(p) => write!(f, "{}", p),
            KnowledgeFormula::Not(phi) => write!(f, "Â¬({})", phi),
            KnowledgeFormula::And(phi, psi) => write!(f, "({} âˆ§ {})", phi, psi),
            KnowledgeFormula::Or(phi, psi) => write!(f, "({} âˆ¨ {})", phi, psi),
            KnowledgeFormula::Implies(phi, psi) => write!(f, "({} â†’ {})", phi, psi),
            KnowledgeFormula::Iff(phi, psi) => write!(f, "({} â†” {})", phi, psi),
            KnowledgeFormula::Knows(agent, phi) => write!(f, "K_{}({})", agent, phi),
            KnowledgeFormula::Believes(agent, phi) => write!(f, "B_{}({})", agent, phi),
            KnowledgeFormula::Justified(agent, phi) => write!(f, "J_{}({})", agent, phi),
        }
    }
}

/// ä¸å¯åŒºåˆ†å…³ç³»
pub type IndistinguishabilityRelation = HashMap<AgentId, Vec<Vec<WorldId>>>;

/// è¯æ®å‡½æ•°
pub type EvidenceFunction = HashMap<(AgentId, WorldId), Vec<String>>;

/// çŸ¥è¯†æ¨¡å‹
#[derive(Debug)]
pub struct KnowledgeModel {
    pub worlds: Vec<WorldId>,
    pub indistinguishability: IndistinguishabilityRelation,
    pub proposition_valuation: HashMap<String, Vec<WorldId>>,
    pub evidence: EvidenceFunction,
    pub belief_function: HashMap<(AgentId, WorldId), Vec<String>>,
}

impl KnowledgeModel {
    /// åˆ›å»ºæ–°çš„çŸ¥è¯†æ¨¡å‹
    pub fn new(world_count: usize) -> Self {
        let worlds: Vec<WorldId> = (0..world_count).collect();
        let indistinguishability = HashMap::new();
        let proposition_valuation = HashMap::new();
        let evidence = HashMap::new();
        let belief_function = HashMap::new();
        
        KnowledgeModel {
            worlds,
            indistinguishability,
            proposition_valuation,
            evidence,
            belief_function,
        }
    }
    
    /// è®¾ç½®ä¸å¯åŒºåˆ†å…³ç³»
    pub fn set_indistinguishability(&mut self, agent: &str, relations: Vec<Vec<WorldId>>) {
        self.indistinguishability.insert(agent.to_string(), relations);
    }
    
    /// è®¾ç½®å‘½é¢˜åœ¨ä¸–ç•Œä¸­çš„çœŸå€¼
    pub fn set_proposition(&mut self, proposition: &str, worlds: Vec<WorldId>) {
        self.proposition_valuation.insert(proposition.to_string(), worlds);
    }
    
    /// è®¾ç½®ä¸»ä½“çš„è¯æ®
    pub fn set_evidence(&mut self, agent: &str, world: WorldId, evidence: Vec<String>) {
        self.evidence.insert((agent.to_string(), world), evidence);
    }
    
    /// è®¾ç½®ä¸»ä½“çš„ä¿¡å¿µ
    pub fn set_belief(&mut self, agent: &str, world: WorldId, beliefs: Vec<String>) {
        self.belief_function.insert((agent.to_string(), world), beliefs);
    }
    
    /// æ£€æŸ¥å…¬å¼åœ¨ä¸–ç•Œçš„çœŸå€¼
    pub fn satisfies(&self, world: WorldId, formula: &KnowledgeFormula) -> bool {
        match formula {
            KnowledgeFormula::Proposition(p) => {
                self.proposition_valuation.get(p)
                    .map(|worlds| worlds.contains(&world))
                    .unwrap_or(false)
            }
            KnowledgeFormula::Not(phi) => !self.satisfies(world, phi),
            KnowledgeFormula::And(phi, psi) => {
                self.satisfies(world, phi) && self.satisfies(world, psi)
            }
            KnowledgeFormula::Or(phi, psi) => {
                self.satisfies(world, phi) || self.satisfies(world, psi)
            }
            KnowledgeFormula::Implies(phi, psi) => {
                !self.satisfies(world, phi) || self.satisfies(world, psi)
            }
            KnowledgeFormula::Iff(phi, psi) => {
                self.satisfies(world, phi) == self.satisfies(world, psi)
            }
            KnowledgeFormula::Knows(agent, phi) => {
                self.evaluate_knowledge(world, agent, phi)
            }
            KnowledgeFormula::Believes(agent, phi) => {
                self.evaluate_belief(world, agent, phi)
            }
            KnowledgeFormula::Justified(agent, phi) => {
                self.evaluate_justification(world, agent, phi)
            }
        }
    }
    
    /// è¯„ä¼°çŸ¥è¯†
    fn evaluate_knowledge(&self, world: WorldId, agent: &str, phi: &KnowledgeFormula) -> bool {
        // çŸ¥è¯†è¦æ±‚ï¼šçœŸç†æ€§ + ä¿¡å¿µ + ç¡®è¯
        let truth = self.satisfies(world, phi);
        let belief = self.evaluate_belief(world, agent, phi);
        let justification = self.evaluate_justification(world, agent, phi);
        
        truth && belief && justification
    }
    
    /// è¯„ä¼°ä¿¡å¿µ
    fn evaluate_belief(&self, world: WorldId, agent: &str, phi: &KnowledgeFormula) -> bool {
        // æ£€æŸ¥ä¸»ä½“æ˜¯å¦ç›¸ä¿¡è¯¥å‘½é¢˜
        if let Some(beliefs) = self.belief_function.get(&(agent.to_string(), world)) {
            // ç®€åŒ–å¤„ç†ï¼šæ£€æŸ¥ä¿¡å¿µåˆ—è¡¨ä¸­æ˜¯å¦åŒ…å«è¯¥å‘½é¢˜
            if let KnowledgeFormula::Proposition(p) = phi {
                beliefs.contains(p)
            } else {
                // å¯¹äºå¤æ‚å…¬å¼ï¼Œéœ€è¦æ›´å¤æ‚çš„ä¿¡å¿µè¯„ä¼°
                true // ç®€åŒ–å¤„ç†
            }
        } else {
            false
        }
    }
    
    /// è¯„ä¼°ç¡®è¯
    fn evaluate_justification(&self, world: WorldId, agent: &str, phi: &KnowledgeFormula) -> bool {
        // æ£€æŸ¥ä¸»ä½“æ˜¯å¦æœ‰è¯æ®æ”¯æŒè¯¥å‘½é¢˜
        if let Some(evidence) = self.evidence.get(&(agent.to_string(), world)) {
            // ç®€åŒ–å¤„ç†ï¼šæ£€æŸ¥è¯æ®æ˜¯å¦æ”¯æŒè¯¥å‘½é¢˜
            !evidence.is_empty() // æœ‰è¯æ®å°±è®¤ä¸ºæœ‰ç¡®è¯
        } else {
            false
        }
    }
    
    /// æ£€æŸ¥å…¬å¼æ˜¯å¦åœ¨æ‰€æœ‰ä¸–ç•Œä¸ºçœŸ
    pub fn is_valid(&self, formula: &KnowledgeFormula) -> bool {
        self.worlds.iter().all(|&w| self.satisfies(w, formula))
    }
    
    /// æ£€æŸ¥å…¬å¼æ˜¯å¦åœ¨æŸä¸ªä¸–ç•Œä¸ºçœŸ
    pub fn is_satisfiable(&self, formula: &KnowledgeFormula) -> bool {
        self.worlds.iter().any(|&w| self.satisfies(w, formula))
    }
}

/// çŸ¥è¯†æ¨ç†ç³»ç»Ÿ
pub struct KnowledgeReasoningSystem {
    pub model: KnowledgeModel,
}

impl KnowledgeReasoningSystem {
    pub fn new(model: KnowledgeModel) -> Self {
        KnowledgeReasoningSystem { model }
    }
    
    /// éªŒè¯çŸ¥è¯†å…¬ç†
    pub fn verify_knowledge_axioms(&self, agent: &str, phi: &KnowledgeFormula) -> bool {
        // éªŒè¯çœŸç†æ€§å…¬ç†
        let truth_axiom = KnowledgeFormula::Implies(
            Box::new(KnowledgeFormula::Knows(agent.to_string(), Box::new(phi.clone()))),
            Box::new(phi.clone())
        );
        
        self.model.is_valid(&truth_axiom)
    }
    
    /// éªŒè¯æ­£å†…çœå…¬ç†
    pub fn verify_positive_introspection(&self, agent: &str, phi: &KnowledgeFormula) -> bool {
        let positive_introspection = KnowledgeFormula::Implies(
            Box::new(KnowledgeFormula::Knows(agent.to_string(), Box::new(phi.clone()))),
            Box::new(KnowledgeFormula::Knows(
                agent.to_string(),
                Box::new(KnowledgeFormula::Knows(agent.to_string(), Box::new(phi.clone())))
            ))
        );
        
        self.model.is_valid(&positive_introspection)
    }
    
    /// éªŒè¯åˆ†é…å¾‹
    pub fn verify_distribution(&self, agent: &str, phi: &KnowledgeFormula, psi: &KnowledgeFormula) -> bool {
        let distribution = KnowledgeFormula::Implies(
            Box::new(KnowledgeFormula::Knows(
                agent.to_string(),
                Box::new(KnowledgeFormula::Implies(Box::new(phi.clone()), Box::new(psi.clone())))
            )),
            Box::new(KnowledgeFormula::Implies(
                Box::new(KnowledgeFormula::Knows(agent.to_string(), Box::new(phi.clone()))),
                Box::new(KnowledgeFormula::Knows(agent.to_string(), Box::new(psi.clone())))
            ))
        );
        
        self.model.is_valid(&distribution)
    }
}

/// çŸ¥è¯†åˆ†æå™¨
pub struct KnowledgeAnalyzer {
    system: KnowledgeReasoningSystem,
}

impl KnowledgeAnalyzer {
    pub fn new(system: KnowledgeReasoningSystem) -> Self {
        KnowledgeAnalyzer { system }
    }
    
    /// åˆ†æçŸ¥è¯†çŠ¶æ€
    pub fn analyze_knowledge_state(&self, agent: &str, world: WorldId) -> Vec<String> {
        let mut knowledge_state = Vec::new();
        
        for &w in &self.system.model.worlds {
            if w == world {
                // æ£€æŸ¥ä¸»ä½“åœ¨è¯¥ä¸–ç•ŒçŸ¥é“å“ªäº›å‘½é¢˜
                for (proposition, _) in &self.system.model.proposition_valuation {
                    let phi = KnowledgeFormula::Proposition(proposition.clone());
                    if self.system.model.satisfies(world, &KnowledgeFormula::Knows(
                        agent.to_string(), Box::new(phi)
                    )) {
                        knowledge_state.push(format!("çŸ¥é“ {}", proposition));
                    }
                }
            }
        }
        
        knowledge_state
    }
    
    /// æ£€æµ‹ç›–æ¢¯å°”é—®é¢˜
    pub fn detect_gettier_problem(&self, agent: &str, phi: &KnowledgeFormula) -> bool {
        // æ£€æŸ¥æ˜¯å¦å­˜åœ¨ç›–æ¢¯å°”æƒ…å†µï¼šçœŸä¿¡å¿µ+ç¡®è¯ä½†ä¸æ„æˆçŸ¥è¯†
        for &world in &self.system.model.worlds {
            let truth = self.system.model.satisfies(world, phi);
            let belief = self.system.model.evaluate_belief(world, agent, phi);
            let justification = self.system.model.evaluate_justification(world, agent, phi);
            let knowledge = self.system.model.satisfies(world, &KnowledgeFormula::Knows(
                agent.to_string(), Box::new(phi.clone())
            ));
            
            // ç›–æ¢¯å°”æƒ…å†µï¼šçœŸä¿¡å¿µ+ç¡®è¯ä½†ä¸æ„æˆçŸ¥è¯†
            if truth && belief && justification && !knowledge {
                return true;
            }
        }
        
        false
    }
    
    /// çŸ¥è¯†ä¸ç¡®å®šæ€§åˆ†æ
    pub fn analyze_uncertainty(&self, agent: &str, phi: &KnowledgeFormula) -> bool {
        // æ£€æŸ¥ä¸»ä½“æ˜¯å¦å¯¹æŸä¸ªå‘½é¢˜ä¸ç¡®å®š
        for &world in &self.system.model.worlds {
            let knows_phi = self.system.model.satisfies(world, &KnowledgeFormula::Knows(
                agent.to_string(), Box::new(phi.clone())
            ));
            let knows_not_phi = self.system.model.satisfies(world, &KnowledgeFormula::Knows(
                agent.to_string(), Box::new(KnowledgeFormula::Not(Box::new(phi.clone())))
            ));
            
            if !knows_phi && !knows_not_phi {
                return true; // å­˜åœ¨ä¸ç¡®å®šæ€§
            }
        }
        
        false
    }
}

/// çŸ¥è¯†é€»è¾‘æµ‹è¯•
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_knowledge_axioms() {
        let mut model = KnowledgeModel::new(3);
        
        // è®¾ç½®ä¸å¯åŒºåˆ†å…³ç³»ï¼ˆç­‰ä»·å…³ç³»ï¼‰
        model.set_indistinguishability("Alice", vec![
            vec![0, 1], // ä¸–ç•Œ0å’Œ1ä¸å¯åŒºåˆ†
            vec![0, 1],
            vec![2],    // ä¸–ç•Œ2å•ç‹¬
        ]);
        
        // è®¾ç½®å‘½é¢˜çœŸå€¼
        model.set_proposition("p", vec![0, 1]);
        
        // è®¾ç½®ä¿¡å¿µå’Œç¡®è¯
        model.set_belief("Alice", 0, vec!["p".to_string()]);
        model.set_evidence("Alice", 0, vec!["evidence_p".to_string()]);
        
        let system = KnowledgeReasoningSystem::new(model);
        let analyzer = KnowledgeAnalyzer::new(system);
        
        let phi = KnowledgeFormula::Proposition("p".to_string());
        assert!(analyzer.system.verify_knowledge_axioms("Alice", &phi));
    }
    
    #[test]
    fn test_gettier_problem() {
        let mut model = KnowledgeModel::new(2);
        
        // è®¾ç½®ç›–æ¢¯å°”æƒ…å†µ
        model.set_proposition("p", vec![0]); // påœ¨ä¸–ç•Œ0ä¸ºçœŸ
        model.set_belief("Bob", 0, vec!["p".to_string()]); // Bobç›¸ä¿¡p
        model.set_evidence("Bob", 0, vec!["misleading_evidence".to_string()]); // è¯¯å¯¼æ€§è¯æ®
        
        let system = KnowledgeReasoningSystem::new(model);
        let analyzer = KnowledgeAnalyzer::new(system);
        
        let phi = KnowledgeFormula::Proposition("p".to_string());
        assert!(analyzer.detect_gettier_problem("Bob", &phi));
    }
    
    #[test]
    fn test_knowledge_uncertainty() {
        let mut model = KnowledgeModel::new(2);
        
        // è®¾ç½®ä¸ç¡®å®šæ€§æƒ…å†µ
        model.set_proposition("q", vec![0]); // qåªåœ¨ä¸–ç•Œ0ä¸ºçœŸ
        model.set_indistinguishability("Charlie", vec![
            vec![0, 1], // Charlieæ— æ³•åŒºåˆ†ä¸–ç•Œ0å’Œ1
            vec![0, 1],
        ]);
        
        let system = KnowledgeReasoningSystem::new(model);
        let analyzer = KnowledgeAnalyzer::new(system);
        
        let phi = KnowledgeFormula::Proposition("q".to_string());
        assert!(analyzer.analyze_uncertainty("Charlie", &phi));
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 è®¤çŸ¥çŠ¶æ€åˆ†æ

**ç¤ºä¾‹ 1**: è®¤çŸ¥çŠ¶æ€åˆ†æ

```rust
// è®¤çŸ¥çŠ¶æ€åˆ†æ
let mut cognitive_model = KnowledgeModel::new(4);

// è®¾ç½®è®¤çŸ¥ä¸å¯åŒºåˆ†å…³ç³»
cognitive_model.set_indistinguishability("Agent", vec![
    vec![0, 1], // ä¸–ç•Œ0å’Œ1ä¸å¯åŒºåˆ†
    vec![0, 1],
    vec![2, 3], // ä¸–ç•Œ2å’Œ3ä¸å¯åŒºåˆ†
    vec![2, 3],
]);

// è®¾ç½®å‘½é¢˜ï¼šå¤©æ°”æ™´æœ—
cognitive_model.set_proposition("sunny", vec![0, 2]);

// è®¾ç½®ä¿¡å¿µå’Œç¡®è¯
cognitive_model.set_belief("Agent", 0, vec!["sunny".to_string()]);
cognitive_model.set_evidence("Agent", 0, vec!["visual_evidence".to_string()]);

let system = KnowledgeReasoningSystem::new(cognitive_model);
let analyzer = KnowledgeAnalyzer::new(system);

// åˆ†æAgentçš„çŸ¥è¯†çŠ¶æ€
let knowledge_state = analyzer.analyze_knowledge_state("Agent", 0);
println!("Agentçš„çŸ¥è¯†çŠ¶æ€: {:?}", knowledge_state);
```

### 5.2 ç§‘å­¦çŸ¥è¯†åˆ†æ

**ç¤ºä¾‹ 2**: ç§‘å­¦çŸ¥è¯†åˆ†æ

```rust
// ç§‘å­¦çŸ¥è¯†åˆ†æ
let mut scientific_model = KnowledgeModel::new(3);

// è®¾ç½®ç§‘å­¦å‘½é¢˜
scientific_model.set_proposition("gravity_exists", vec![0, 1, 2]);
scientific_model.set_proposition("quantum_entanglement", vec![0, 1]);

// è®¾ç½®ç§‘å­¦å®¶çš„ä¿¡å¿µå’Œç¡®è¯
scientific_model.set_belief("Scientist", 0, vec![
    "gravity_exists".to_string(),
    "quantum_entanglement".to_string(),
]);
scientific_model.set_evidence("Scientist", 0, vec![
    "experimental_data".to_string(),
    "mathematical_proof".to_string(),
]);

let system = KnowledgeReasoningSystem::new(scientific_model);
let analyzer = KnowledgeAnalyzer::new(system);

// æ£€æŸ¥ç§‘å­¦çŸ¥è¯†
let gravity = KnowledgeFormula::Proposition("gravity_exists".to_string());
let quantum = KnowledgeFormula::Proposition("quantum_entanglement".to_string());

println!("ç§‘å­¦å®¶çŸ¥é“é‡åŠ›å­˜åœ¨: {}", 
    system.model.satisfies(0, &KnowledgeFormula::Knows("Scientist".to_string(), Box::new(gravity))));
println!("ç§‘å­¦å®¶çŸ¥é“é‡å­çº ç¼ : {}", 
    system.model.satisfies(0, &KnowledgeFormula::Knows("Scientist".to_string(), Box::new(quantum))));
```

### 5.3 ç¤¾ä¼šçŸ¥è¯†åˆ†æ

**ç¤ºä¾‹ 3**: ç¤¾ä¼šçŸ¥è¯†åˆ†æ

```rust
// ç¤¾ä¼šçŸ¥è¯†åˆ†æ
let mut social_model = KnowledgeModel::new(5);

// è®¾ç½®ç¤¾ä¼šå‘½é¢˜
social_model.set_proposition("policy_effective", vec![0, 1, 2]);
social_model.set_proposition("public_support", vec![0, 1]);

// è®¾ç½®ä¸åŒä¸»ä½“çš„ä¿¡å¿µ
social_model.set_belief("Politician", 0, vec!["policy_effective".to_string()]);
social_model.set_belief("Expert", 0, vec!["policy_effective".to_string(), "public_support".to_string()]);
social_model.set_belief("Public", 0, vec!["public_support".to_string()]);

// è®¾ç½®è¯æ®
social_model.set_evidence("Politician", 0, vec!["opinion_poll".to_string()]);
social_model.set_evidence("Expert", 0, vec!["research_data".to_string()]);
social_model.set_evidence("Public", 0, vec!["personal_experience".to_string()]);

let system = KnowledgeReasoningSystem::new(social_model);
let analyzer = KnowledgeAnalyzer::new(system);

// åˆ†æä¸åŒä¸»ä½“çš„çŸ¥è¯†å·®å¼‚
let policy = KnowledgeFormula::Proposition("policy_effective".to_string());

for agent in &["Politician", "Expert", "Public"] {
    let knows_policy = system.model.satisfies(0, &KnowledgeFormula::Knows(
        agent.to_string(), Box::new(policy.clone())
    ));
    println!("{}çŸ¥é“æ”¿ç­–æœ‰æ•ˆ: {}", agent, knows_policy);
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸ä¿¡å¿µç†è®ºçš„å…³ç³»

çŸ¥è¯†ç†è®ºä¸ä¿¡å¿µç†è®ºå¯†åˆ‡ç›¸å…³ï¼š

- **çŸ¥è¯†vsä¿¡å¿µ**: çŸ¥è¯†æ˜¯ç¡®è¯çš„çœŸä¿¡å¿µ
- **ä¿¡å¿µæ¡ä»¶**: çŸ¥è¯†å¿…é¡»åŒ…å«ä¿¡å¿µæˆåˆ†
- **ä¿¡å¿µç¡®è¯**: ä¿¡å¿µçš„ç¡®è¯æ˜¯çŸ¥è¯†çš„å¿…è¦æ¡ä»¶

### 6.2 ä¸ç¡®è¯ç†è®ºçš„å…³ç³»

çŸ¥è¯†ç†è®ºä¾èµ–ç¡®è¯ç†è®ºï¼š

- **ç¡®è¯æ¡ä»¶**: çŸ¥è¯†éœ€è¦ç¡®è¯æ”¯æŒ
- **ç¡®è¯ç±»å‹**: ä¸åŒç±»å‹çš„çŸ¥è¯†éœ€è¦ä¸åŒçš„ç¡®è¯
- **ç¡®è¯ç¨‹åº¦**: ç¡®è¯çš„å……åˆ†æ€§æ ‡å‡†

### 6.3 ä¸çœŸç†ç†è®ºçš„å…³ç³»

çŸ¥è¯†ç†è®ºä»¥çœŸç†ç†è®ºä¸ºåŸºç¡€ï¼š

- **çœŸç†æ€§æ¡ä»¶**: çŸ¥è¯†å¿…é¡»æ˜¯çœŸå®çš„
- **çœŸç†æ ‡å‡†**: å¦‚ä½•åˆ¤æ–­çŸ¥è¯†çš„çœŸç†æ€§
- **çœŸç†ç±»å‹**: ä¸åŒç±»å‹çš„çœŸç†å¯¹åº”ä¸åŒç±»å‹çš„çŸ¥è¯†

## 7. å‚è€ƒæ–‡çŒ®

1. Gettier, E. L. (1963). Is justified true belief knowledge? *Analysis*, 23(6), 121-123.

2. Goldman, A. I. (1967). A causal theory of knowing. *The Journal of Philosophy*, 64(12), 357-372.

3. Nozick, R. (1981). *Philosophical explanations*. Harvard University Press.

4. Williamson, T. (2000). *Knowledge and its limits*. Oxford University Press.

5. Zagzebski, L. (1996). *Virtues of the mind: An inquiry into the nature of virtue and the ethical foundations of knowledge*. Cambridge University Press.

---

**ç›¸å…³æ–‡æ¡£**:

- [01.1.1 å­˜åœ¨ç†è®º](../01_Metaphysics/01.1.1_å­˜åœ¨ç†è®º.md)
- [01.1.2 å®ä½“ç†è®º](../01_Metaphysics/01.1.2_å®ä½“ç†è®º.md)
- [01.2.2 ä¿¡å¿µç†è®º](01.2.2_ä¿¡å¿µç†è®º.md)
- [01.2.3 ç¡®è¯ç†è®º](01.2.3_ç¡®è¯ç†è®º.md)

**è¿”å›**: [å“²å­¦åŸºç¡€ç†è®º](../README.md) | [ä¸»ç´¢å¼•](../../00_Master_Index/README.md)
