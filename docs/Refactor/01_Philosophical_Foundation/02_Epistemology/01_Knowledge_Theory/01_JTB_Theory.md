# 01.02.01 JTBçŸ¥è¯†ç†è®º (JTB Knowledge Theory)

## ğŸ“‹ æ¦‚è¿°

JTBçŸ¥è¯†ç†è®ºæ˜¯è®¤è¯†è®ºçš„æ ¸å¿ƒç†è®ºï¼Œç ”ç©¶çŸ¥è¯†çš„æœ¬è´¨ã€ç»“æ„å’Œæ¡ä»¶ã€‚JTBç†è®ºè®¤ä¸ºçŸ¥è¯†æ˜¯ç¡®è¯çš„çœŸä¿¡å¿µï¼ˆJustified True Beliefï¼‰ï¼Œä¸ºç°ä»£è®¤è¯†è®ºæä¾›äº†åŸºç¡€æ¡†æ¶ã€‚

**æ„å»ºæ—¶é—´**: 2024å¹´12æœˆ20æ—¥  
**ç‰ˆæœ¬**: v2.0  
**çŠ¶æ€**: å·²å®Œæˆ

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [JTBç†è®ºæ¡†æ¶](#2-jtbç†è®ºæ¡†æ¶)
3. [ç¡®è¯ç†è®º](#3-ç¡®è¯ç†è®º)
4. [çœŸç†ç†è®º](#4-çœŸç†ç†è®º)
5. [ä¿¡å¿µç†è®º](#5-ä¿¡å¿µç†è®º)
6. [è‘›æ¢¯å°”é—®é¢˜](#6-è‘›æ¢¯å°”é—®é¢˜)
7. [çŸ¥è¯†æ¨¡æ€](#7-çŸ¥è¯†æ¨¡æ€)
8. [åº”ç”¨å®ä¾‹](#8-åº”ç”¨å®ä¾‹)
9. [ä»£ç å®ç°](#9-ä»£ç å®ç°)
10. [å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 çŸ¥è¯†çš„å®šä¹‰

**å®šä¹‰ 1.1.1** (çŸ¥è¯†)
çŸ¥è¯†æ˜¯ç¡®è¯çš„çœŸä¿¡å¿µã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$K(p) \equiv B(p) \land J(p) \land p$$

å…¶ä¸­ï¼š

- $K(p)$ è¡¨ç¤º"çŸ¥é“p"
- $B(p)$ è¡¨ç¤º"ç›¸ä¿¡p"
- $J(p)$ è¡¨ç¤º"pæ˜¯ç¡®è¯çš„"
- $p$ è¡¨ç¤º"pæ˜¯çœŸçš„"

### 1.2 çŸ¥è¯†çš„åŸºæœ¬æ€§è´¨

**æ€§è´¨ 1.2.1** (çŸ¥è¯†çœŸç†æ€§)
å¦‚æœSçŸ¥é“pï¼Œåˆ™pä¸ºçœŸã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$K_S(p) \rightarrow p$$

**æ€§è´¨ 1.2.2** (çŸ¥è¯†ä¿¡å¿µæ€§)
å¦‚æœSçŸ¥é“pï¼Œåˆ™Sç›¸ä¿¡pã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$K_S(p) \rightarrow B_S(p)$$

**æ€§è´¨ 1.2.3** (çŸ¥è¯†ç¡®è¯æ€§)
å¦‚æœSçŸ¥é“pï¼Œåˆ™Så¯¹pçš„ç¡®è¯æ˜¯å……åˆ†çš„ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$K_S(p) \rightarrow J_S(p)$$

## 2. JTBç†è®ºæ¡†æ¶

### 2.1 JTBæ¡ä»¶

**æ¡ä»¶ 2.1.1** (çœŸç†æ€§æ¡ä»¶)
SçŸ¥é“pï¼Œä»…å½“pä¸ºçœŸã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$K_S(p) \rightarrow p$$

**æ¡ä»¶ 2.1.2** (ä¿¡å¿µæ¡ä»¶)
SçŸ¥é“pï¼Œä»…å½“Sç›¸ä¿¡pã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$K_S(p) \rightarrow B_S(p)$$

**æ¡ä»¶ 2.1.3** (ç¡®è¯æ¡ä»¶)
SçŸ¥é“pï¼Œä»…å½“Så¯¹pçš„ç¡®è¯æ˜¯å……åˆ†çš„ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$K_S(p) \rightarrow J_S(p)$$

### 2.2 JTBå……åˆ†æ€§

**å®šç† 2.2.1** (JTBå……åˆ†æ€§)
å¦‚æœSç›¸ä¿¡pï¼Œpä¸ºçœŸï¼Œä¸”Så¯¹pçš„ç¡®è¯æ˜¯å……åˆ†çš„ï¼Œåˆ™SçŸ¥é“pã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$B_S(p) \land p \land J_S(p) \rightarrow K_S(p)$$

**è¯æ˜**:

1. å‡è®¾ $B_S(p) \land p \land J_S(p)$
2. ç”±JTBå®šä¹‰ï¼Œ$K_S(p) \equiv B_S(p) \land J_S(p) \land p$
3. å› æ­¤ï¼Œ$K_S(p)$ æˆç«‹
4. æ‰€ä»¥ $B_S(p) \land p \land J_S(p) \rightarrow K_S(p)$

### 2.3 JTBå¿…è¦æ€§

**å®šç† 2.3.1** (JTBå¿…è¦æ€§)
å¦‚æœSçŸ¥é“pï¼Œåˆ™Sç›¸ä¿¡pï¼Œpä¸ºçœŸï¼Œä¸”Så¯¹pçš„ç¡®è¯æ˜¯å……åˆ†çš„ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$K_S(p) \rightarrow B_S(p) \land p \land J_S(p)$$

**è¯æ˜**:

1. å‡è®¾ $K_S(p)$
2. ç”±JTBå®šä¹‰ï¼Œ$K_S(p) \equiv B_S(p) \land J_S(p) \land p$
3. å› æ­¤ï¼Œ$B_S(p) \land J_S(p) \land p$ æˆç«‹
4. æ‰€ä»¥ $K_S(p) \rightarrow B_S(p) \land p \land J_S(p)$

## 3. ç¡®è¯ç†è®º

### 3.1 ç¡®è¯çš„å®šä¹‰

**å®šä¹‰ 3.1.1** (ç¡®è¯)
ç¡®è¯æ˜¯ä½¿ä¿¡å¿µåˆç†åŒ–çš„è¿‡ç¨‹æˆ–çŠ¶æ€ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$J_S(p) \equiv \exists e \text{Evidence}(e) \land \text{Supports}(e,p) \land \text{Reliable}(e)$$

### 3.2 ç¡®è¯çš„ç±»å‹

**å®šä¹‰ 3.2.1** (åŸºç¡€ç¡®è¯)
åŸºç¡€ç¡®è¯æ˜¯ä¸ä¾èµ–äºå…¶ä»–ä¿¡å¿µçš„ç¡®è¯ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{BasicJustification}(p) \equiv J(p) \land \neg \exists q (J(q) \land \text{DependsOn}(p,q))$$

**å®šä¹‰ 3.2.2** (æ¨è®ºç¡®è¯)
æ¨è®ºç¡®è¯æ˜¯ä¾èµ–äºå…¶ä»–ä¿¡å¿µçš„ç¡®è¯ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{InferentialJustification}(p) \equiv J(p) \land \exists q (J(q) \land \text{DependsOn}(p,q))$$

### 3.3 ç¡®è¯ç†è®º

**ç†è®º 3.3.1** (åŸºç¡€ä¸»ä¹‰)
æ‰€æœ‰ç¡®è¯æœ€ç»ˆéƒ½åŸºäºåŸºç¡€ä¿¡å¿µã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$\forall p (J(p) \rightarrow \text{BasicJustification}(p) \lor \exists q (\text{InferentialJustification}(p,q) \land J(q)))$$

**ç†è®º 3.3.2** (èè´¯ä¸»ä¹‰)
ç¡®è¯æ˜¯ä¿¡å¿µç³»ç»Ÿå†…éƒ¨èè´¯æ€§çš„å‡½æ•°ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$J_S(p) \equiv \text{Coherent}(B_S \cup \{p\})$$

## 4. çœŸç†ç†è®º

### 4.1 çœŸç†çš„å®šä¹‰

**å®šä¹‰ 4.1.1** (ç¬¦åˆè®ºçœŸç†)
å‘½é¢˜pä¸ºçœŸï¼Œå½“ä¸”ä»…å½“pä¸äº‹å®ç›¸ç¬¦ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$T(p) \equiv \exists f \text{Fact}(f) \land \text{Corresponds}(p,f)$$

**å®šä¹‰ 4.1.2** (èè´¯è®ºçœŸç†)
å‘½é¢˜pä¸ºçœŸï¼Œå½“ä¸”ä»…å½“pä¸ä¿¡å¿µç³»ç»Ÿèè´¯ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$T(p) \equiv \text{Coherent}(B \cup \{p\})$$

### 4.2 çœŸç†çš„æ€§è´¨

**æ€§è´¨ 4.2.1** (çœŸç†æ’ä¸­å¾‹)
å¯¹äºä»»æ„å‘½é¢˜pï¼Œpä¸ºçœŸæˆ–pä¸ºå‡ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$T(p) \lor T(\neg p)$$

**æ€§è´¨ 4.2.2** (çœŸç†ä¸€è‡´æ€§)
å‘½é¢˜pä¸èƒ½åŒæ—¶ä¸ºçœŸå’Œå‡ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$\neg (T(p) \land T(\neg p))$$

### 4.3 çœŸç†ç†è®º

**ç†è®º 4.3.1** (å†—ä½™è®º)
"pä¸ºçœŸ"ç­‰ä»·äº"p"ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$T(p) \leftrightarrow p$$

**ç†è®º 4.3.2** (å®ç”¨è®º)
çœŸç†æ˜¯ä¿¡å¿µçš„æœ‰ç”¨æ€§ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$T(p) \equiv \text{Useful}(B(p))$$

## 5. ä¿¡å¿µç†è®º

### 5.1 ä¿¡å¿µçš„å®šä¹‰

**å®šä¹‰ 5.1.1** (ä¿¡å¿µ)
ä¿¡å¿µæ˜¯è®¤çŸ¥ä¸»ä½“å¯¹å‘½é¢˜çš„æ€åº¦ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$B_S(p) \equiv \text{Attitude}(S,p,\text{Belief})$$

### 5.2 ä¿¡å¿µçš„æ€§è´¨

**æ€§è´¨ 5.2.1** (ä¿¡å¿µä¸€è‡´æ€§)
å¦‚æœSç›¸ä¿¡pä¸”pè•´å«qï¼Œåˆ™Sç›¸ä¿¡qã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$B_S(p) \land (p \rightarrow q) \rightarrow B_S(q)$$

**æ€§è´¨ 5.2.2** (ä¿¡å¿µå°é—­æ€§)
å¦‚æœSç›¸ä¿¡pä¸”Sç›¸ä¿¡qï¼Œåˆ™Sç›¸ä¿¡pâˆ§qã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$B_S(p) \land B_S(q) \rightarrow B_S(p \land q)$$

### 5.3 ä¿¡å¿µç†è®º

**ç†è®º 5.3.1** (ä¿¡å¿µåº¦ç†è®º)
ä¿¡å¿µæœ‰ç¨‹åº¦ä¹‹åˆ†ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$B_S(p) \equiv \text{Degree}(S,p) > \text{Threshold}$$

**ç†è®º 5.3.2** (ä¿¡å¿µä¿®æ­£ç†è®º)
ä¿¡å¿µå¯ä»¥é€šè¿‡æ–°è¯æ®è¿›è¡Œä¿®æ­£ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$B_S'(p) = \text{Revise}(B_S(p), E)$$

## 6. è‘›æ¢¯å°”é—®é¢˜

### 6.1 è‘›æ¢¯å°”åä¾‹

**åä¾‹ 6.1.1** (å²å¯†æ–¯å’Œç¼æ–¯æ¡ˆä¾‹)
å²å¯†æ–¯æœ‰å……åˆ†çš„è¯æ®ç›¸ä¿¡ç¼æ–¯å°†å¾—åˆ°å·¥ä½œï¼Œä¸”ç¼æ–¯å£è¢‹é‡Œæœ‰10ä¸ªç¡¬å¸ã€‚å²å¯†æ–¯å› æ­¤ç›¸ä¿¡"å¾—åˆ°å·¥ä½œçš„äººå£è¢‹é‡Œæœ‰10ä¸ªç¡¬å¸"ã€‚å®é™…ä¸Šï¼Œå²å¯†æ–¯å¾—åˆ°äº†å·¥ä½œï¼Œä¸”å²å¯†æ–¯å£è¢‹é‡Œæ°å¥½æœ‰10ä¸ªç¡¬å¸ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$B_S(p) \land J_S(p) \land p \land \neg K_S(p)$$

å…¶ä¸­p = "å¾—åˆ°å·¥ä½œçš„äººå£è¢‹é‡Œæœ‰10ä¸ªç¡¬å¸"

### 6.2 è‘›æ¢¯å°”é—®é¢˜çš„æ„ä¹‰

**é—®é¢˜ 6.2.1** (JTBå……åˆ†æ€§é—®é¢˜)
JTBæ¡ä»¶å¯¹äºçŸ¥è¯†æ˜¯å¦å……åˆ†ï¼Ÿ

**åˆ†æ**:
è‘›æ¢¯å°”åä¾‹è¡¨æ˜ï¼Œå³ä½¿æ»¡è¶³JTBæ¡ä»¶ï¼Œä¹Ÿå¯èƒ½ä¸æ„æˆçŸ¥è¯†ã€‚è¿™è¦æ±‚æˆ‘ä»¬å¯»æ‰¾ç¬¬å››ä¸ªæ¡ä»¶ã€‚

### 6.3 è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆ 6.3.1** (æ— å‡å‰ææ¡ä»¶)
çŸ¥è¯†è¦æ±‚ç¡®è¯ä¸ä¾èµ–äºå‡å‰æã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$K_S(p) \equiv B_S(p) \land J_S(p) \land p \land \text{NoFalsePremises}(J_S(p))$$

**æ–¹æ¡ˆ 6.3.2** (å› æœæ¡ä»¶)
çŸ¥è¯†è¦æ±‚ä¿¡å¿µä¸äº‹å®ä¹‹é—´æœ‰é€‚å½“çš„å› æœè”ç³»ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$K_S(p) \equiv B_S(p) \land J_S(p) \land p \land \text{CausalConnection}(B_S(p), p)$$

## 7. çŸ¥è¯†æ¨¡æ€

### 7.1 çŸ¥è¯†æ¨¡æ€ç®—å­

**å®šä¹‰ 7.1.1** (çŸ¥è¯†ç®—å­)
K_S(p)è¡¨ç¤ºä¸»ä½“SçŸ¥é“pã€‚

**å®šä¹‰ 7.1.2** (ä¿¡å¿µç®—å­)
B_S(p)è¡¨ç¤ºä¸»ä½“Sç›¸ä¿¡pã€‚

**å®šä¹‰ 7.1.3** (å¯èƒ½çŸ¥é“ç®—å­)
â—‡K_S(p)è¡¨ç¤ºä¸»ä½“Så¯èƒ½çŸ¥é“pã€‚

### 7.2 çŸ¥è¯†æ¨¡æ€å…¬ç†

**å…¬ç† 7.2.1** (çŸ¥è¯†çœŸç†æ€§)
$$K_S(p) \rightarrow p$$

**å…¬ç† 7.2.2** (çŸ¥è¯†åˆ†é…æ€§)
$$K_S(p \rightarrow q) \rightarrow (K_S(p) \rightarrow K_S(q))$$

**å…¬ç† 7.2.3** (çŸ¥è¯†æ­£å†…çœ)
$$K_S(p) \rightarrow K_S(K_S(p))$$

**å…¬ç† 7.2.4** (çŸ¥è¯†è´Ÿå†…çœ)
$$\neg K_S(p) \rightarrow K_S(\neg K_S(p))$$

### 7.3 çŸ¥è¯†æ¨¡æ€å®šç†

**å®šç† 7.3.1** (çŸ¥è¯†ä¼ é€’å®šç†)
å¦‚æœSçŸ¥é“pï¼Œä¸”pè•´å«qï¼Œä¸”SçŸ¥é“pè•´å«qï¼Œåˆ™SçŸ¥é“qã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$K_S(p) \land (p \rightarrow q) \land K_S(p \rightarrow q) \rightarrow K_S(q)$$

**è¯æ˜**:

1. å‡è®¾ $K_S(p) \land (p \rightarrow q) \land K_S(p \rightarrow q)$
2. ç”±çŸ¥è¯†åˆ†é…æ€§ï¼Œ$K_S(p \rightarrow q) \rightarrow (K_S(p) \rightarrow K_S(q))$
3. å› æ­¤ï¼Œ$K_S(q)$ æˆç«‹
4. æ‰€ä»¥ $K_S(p) \land (p \rightarrow q) \land K_S(p \rightarrow q) \rightarrow K_S(q)$

## 8. åº”ç”¨å®ä¾‹

### 8.1 ç§‘å­¦çŸ¥è¯†

**å®ä¾‹ 8.1.1** (ç§‘å­¦çŸ¥è¯†ç¡®è¯)
ç§‘å­¦çŸ¥è¯†é€šè¿‡å®éªŒè¯æ®ç¡®è¯ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$K_S(p) \equiv B_S(p) \land \text{ExperimentalEvidence}(p) \land p$$

### 8.2 æ•°å­¦çŸ¥è¯†

**å®ä¾‹ 8.1.2** (æ•°å­¦çŸ¥è¯†ç¡®è¯)
æ•°å­¦çŸ¥è¯†é€šè¿‡è¯æ˜ç¡®è¯ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$K_S(p) \equiv B_S(p) \land \text{MathematicalProof}(p) \land p$$

### 8.3 æ—¥å¸¸çŸ¥è¯†

**å®ä¾‹ 8.1.3** (æ„ŸçŸ¥çŸ¥è¯†ç¡®è¯)
æ„ŸçŸ¥çŸ¥è¯†é€šè¿‡æ„Ÿå®˜ç»éªŒç¡®è¯ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
$$K_S(p) \equiv B_S(p) \land \text{PerceptualExperience}(p) \land p$$

## 9. ä»£ç å®ç°

### 9.1 Rustå®ç°

```rust
use std::fmt;

// çŸ¥è¯†ç±»å‹å®šä¹‰
#[derive(Debug, Clone, PartialEq)]
pub struct Knowledge<P> {
    belief: Belief<P>,
    justification: Justification<P>,
    truth: bool,
}

// ä¿¡å¿µç±»å‹å®šä¹‰
#[derive(Debug, Clone)]
pub struct Belief<P> {
    proposition: P,
    confidence: f64,
    subject: String,
}

// ç¡®è¯ç±»å‹å®šä¹‰
#[derive(Debug, Clone)]
pub struct Justification<P> {
    evidence: Vec<Evidence>,
    reasoning: Reasoning<P>,
    reliability: f64,
}

// è¯æ®ç±»å‹å®šä¹‰
#[derive(Debug, Clone)]
pub struct Evidence {
    source: String,
    content: String,
    strength: f64,
}

// æ¨ç†ç±»å‹å®šä¹‰
#[derive(Debug, Clone)]
pub struct Reasoning<P> {
    premises: Vec<P>,
    conclusion: P,
    method: ReasoningMethod,
}

#[derive(Debug, Clone)]
pub enum ReasoningMethod {
    Deduction,
    Induction,
    Abduction,
}

impl<P> Knowledge<P> 
where 
    P: Clone + PartialEq,
{
    /// æ„é€ çŸ¥è¯†
    pub fn new(belief: Belief<P>, justification: Justification<P>, truth: bool) -> Self {
        Self { belief, justification, truth }
    }
    
    /// æ£€æŸ¥æ˜¯å¦æ»¡è¶³JTBæ¡ä»¶
    pub fn satisfies_jtb(&self) -> bool {
        self.belief.confidence > 0.5 && 
        self.justification.reliability > 0.7 && 
        self.truth
    }
    
    /// è·å–çŸ¥è¯†ä¸»ä½“
    pub fn subject(&self) -> &str {
        &self.belief.subject
    }
    
    /// è·å–ä¿¡å¿µå†…å®¹
    pub fn proposition(&self) -> &P {
        &self.belief.proposition
    }
    
    /// çŸ¥è¯†ä¼ é€’å®šç†
    pub fn knowledge_transmission(&self, other: &Knowledge<P>, implication: &dyn Fn(&P, &P) -> bool) -> Option<Knowledge<P>> {
        if self.truth && 
           implication(self.proposition(), other.proposition()) && 
           self.satisfies_jtb() {
            Some(other.clone())
        } else {
            None
        }
    }
}

// è‘›æ¢¯å°”é—®é¢˜å®ç°
pub struct GettierProblem<P> {
    cases: Vec<GettierCase<P>>,
}

#[derive(Debug, Clone)]
pub struct GettierCase<P> {
    belief: Belief<P>,
    justification: Justification<P>,
    truth: bool,
    is_knowledge: bool,
}

impl<P> GettierProblem<P> 
where 
    P: Clone + PartialEq,
{
    pub fn new() -> Self {
        Self { cases: Vec::new() }
    }
    
    /// æ·»åŠ è‘›æ¢¯å°”æ¡ˆä¾‹
    pub fn add_case(&mut self, case: GettierCase<P>) {
        self.cases.push(case);
    }
    
    /// æ£€æŸ¥JTBå……åˆ†æ€§
    pub fn check_jtb_sufficiency(&self) -> bool {
        self.cases.iter().all(|case| {
            let jtb_satisfied = case.belief.confidence > 0.5 && 
                               case.justification.reliability > 0.7 && 
                               case.truth;
            jtb_satisfied == case.is_knowledge
        })
    }
    
    /// ç”Ÿæˆè‘›æ¢¯å°”åä¾‹
    pub fn generate_counterexample(&self) -> Option<&GettierCase<P>> {
        self.cases.iter().find(|case| {
            let jtb_satisfied = case.belief.confidence > 0.5 && 
                               case.justification.reliability > 0.7 && 
                               case.truth;
            jtb_satisfied && !case.is_knowledge
        })
    }
}

// çŸ¥è¯†æ¨¡æ€å®ç°
pub struct EpistemicModal<P> {
    knowledge_base: Vec<Knowledge<P>>,
    belief_base: Vec<Belief<P>>,
}

impl<P> EpistemicModal<P> 
where 
    P: Clone + PartialEq,
{
    pub fn new() -> Self {
        Self {
            knowledge_base: Vec::new(),
            belief_base: Vec::new(),
        }
    }
    
    /// æ·»åŠ çŸ¥è¯†
    pub fn add_knowledge(&mut self, knowledge: Knowledge<P>) {
        if knowledge.satisfies_jtb() {
            self.knowledge_base.push(knowledge);
        }
    }
    
    /// æ·»åŠ ä¿¡å¿µ
    pub fn add_belief(&mut self, belief: Belief<P>) {
        self.belief_base.push(belief);
    }
    
    /// æ£€æŸ¥çŸ¥è¯†çœŸç†æ€§
    pub fn check_truth_axiom(&self, subject: &str, proposition: &P) -> bool {
        if let Some(knowledge) = self.get_knowledge(subject, proposition) {
            knowledge.truth
        } else {
            false
        }
    }
    
    /// æ£€æŸ¥çŸ¥è¯†åˆ†é…æ€§
    pub fn check_distribution_axiom(&self, subject: &str, p: &P, q: &P, implication: &dyn Fn(&P, &P) -> bool) -> bool {
        let knows_implication = self.has_knowledge(subject, &(p.clone(), q.clone()));
        let knows_p = self.has_knowledge(subject, p);
        let knows_q = self.has_knowledge(subject, q);
        
        !knows_implication || !knows_p || knows_q
    }
    
    /// è·å–çŸ¥è¯†
    pub fn get_knowledge(&self, subject: &str, proposition: &P) -> Option<&Knowledge<P>> {
        self.knowledge_base.iter().find(|k| 
            k.subject() == subject && k.proposition() == proposition
        )
    }
    
    /// æ£€æŸ¥æ˜¯å¦æœ‰çŸ¥è¯†
    pub fn has_knowledge(&self, subject: &str, proposition: &P) -> bool {
        self.get_knowledge(subject, proposition).is_some()
    }
}

// æµ‹è¯•ç”¨ä¾‹
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_jtb_conditions() {
        let belief = Belief {
            proposition: "2+2=4".to_string(),
            confidence: 0.9,
            subject: "Alice".to_string(),
        };
        
        let justification = Justification {
            evidence: vec![Evidence {
                source: "mathematical proof".to_string(),
                content: "Peano axioms".to_string(),
                strength: 0.95,
            }],
            reasoning: Reasoning {
                premises: vec!["Peano axioms".to_string()],
                conclusion: "2+2=4".to_string(),
                method: ReasoningMethod::Deduction,
            },
            reliability: 0.95,
        };
        
        let knowledge = Knowledge::new(belief, justification, true);
        
        assert!(knowledge.satisfies_jtb());
        assert_eq!(knowledge.subject(), "Alice");
        assert_eq!(knowledge.proposition(), "2+2=4");
    }
    
    #[test]
    fn test_gettier_problem() {
        let mut gettier = GettierProblem::new();
        
        // æ·»åŠ è‘›æ¢¯å°”åä¾‹
        let case = GettierCase {
            belief: Belief {
                proposition: "Jones will get the job".to_string(),
                confidence: 0.8,
                subject: "Smith".to_string(),
            },
            justification: Justification {
                evidence: vec![Evidence {
                    source: "reliable testimony".to_string(),
                    content: "Jones has 10 coins".to_string(),
                    strength: 0.8,
                }],
                reasoning: Reasoning {
                    premises: vec!["Jones will get the job".to_string()],
                    conclusion: "The person who gets the job has 10 coins".to_string(),
                    method: ReasoningMethod::Deduction,
                },
                reliability: 0.8,
            },
            truth: true,
            is_knowledge: false, // è‘›æ¢¯å°”è®¤ä¸ºè¿™ä¸æ˜¯çŸ¥è¯†
        };
        
        gettier.add_case(case);
        
        // JTBæ¡ä»¶æ»¡è¶³ä½†ä¸æ˜¯çŸ¥è¯†
        assert!(!gettier.check_jtb_sufficiency());
        assert!(gettier.generate_counterexample().is_some());
    }
    
    #[test]
    fn test_epistemic_modal() {
        let mut modal = EpistemicModal::new();
        
        let knowledge = Knowledge::new(
            Belief {
                proposition: "p".to_string(),
                confidence: 0.9,
                subject: "S".to_string(),
            },
            Justification {
                evidence: vec![],
                reasoning: Reasoning {
                    premises: vec![],
                    conclusion: "p".to_string(),
                    method: ReasoningMethod::Deduction,
                },
                reliability: 0.9,
            },
            true,
        );
        
        modal.add_knowledge(knowledge);
        
        // æ£€æŸ¥çŸ¥è¯†çœŸç†æ€§å…¬ç†
        assert!(modal.check_truth_axiom("S", &"p".to_string()));
    }
}
```

### 9.2 Haskellå®ç°

```haskell
-- çŸ¥è¯†ç±»å‹å®šä¹‰
data Knowledge p = Knowledge
    { belief :: Belief p
    , justification :: Justification p
    , truth :: Bool
    }

-- ä¿¡å¿µç±»å‹å®šä¹‰
data Belief p = Belief
    { proposition :: p
    , confidence :: Double
    , subject :: String
    }

-- ç¡®è¯ç±»å‹å®šä¹‰
data Justification p = Justification
    { evidence :: [Evidence]
    , reasoning :: Reasoning p
    , reliability :: Double
    }

-- è¯æ®ç±»å‹å®šä¹‰
data Evidence = Evidence
    { source :: String
    , content :: String
    , strength :: Double
    }

-- æ¨ç†ç±»å‹å®šä¹‰
data Reasoning p = Reasoning
    { premises :: [p]
    , conclusion :: p
    , method :: ReasoningMethod
    }

data ReasoningMethod = Deduction | Induction | Abduction

-- JTBæ¡ä»¶æ£€æŸ¥
satisfiesJTB :: Knowledge p -> Bool
satisfiesJTB (Knowledge belief justification truth) =
    confidence belief > 0.5 && 
    reliability justification > 0.7 && 
    truth

-- çŸ¥è¯†ä¼ é€’å®šç†
knowledgeTransmission :: Knowledge p -> Knowledge p -> (p -> p -> Bool) -> Maybe (Knowledge p)
knowledgeTransmission k1 k2 implication =
    if truth k1 && 
       implication (proposition $ belief k1) (proposition $ belief k2) && 
       satisfiesJTB k1
    then Just k2
    else Nothing

-- è‘›æ¢¯å°”é—®é¢˜
data GettierCase p = GettierCase
    { belief :: Belief p
    , justification :: Justification p
    , truth :: Bool
    , isKnowledge :: Bool
    }

data GettierProblem p = GettierProblem
    { cases :: [GettierCase p]
    }

-- æ£€æŸ¥JTBå……åˆ†æ€§
checkJTBSufficiency :: GettierProblem p -> Bool
checkJTBSufficiency (GettierProblem cases) =
    all checkCase cases
  where
    checkCase case =
        let jtbSatisfied = confidence (belief case) > 0.5 && 
                           reliability (justification case) > 0.7 && 
                           truth case
        in jtbSatisfied == isKnowledge case

-- ç”Ÿæˆè‘›æ¢¯å°”åä¾‹
generateCounterexample :: GettierProblem p -> Maybe (GettierCase p)
generateCounterexample (GettierProblem cases) =
    find isCounterexample cases
  where
    isCounterexample case =
        let jtbSatisfied = confidence (belief case) > 0.5 && 
                           reliability (justification case) > 0.7 && 
                           truth case
        in jtbSatisfied && not (isKnowledge case)

-- çŸ¥è¯†æ¨¡æ€
data EpistemicModal p = EpistemicModal
    { knowledgeBase :: [Knowledge p]
    , beliefBase :: [Belief p]
    }

-- æ·»åŠ çŸ¥è¯†
addKnowledge :: EpistemicModal p -> Knowledge p -> EpistemicModal p
addKnowledge modal knowledge =
    if satisfiesJTB knowledge
    then modal { knowledgeBase = knowledge : knowledgeBase modal }
    else modal

-- æ£€æŸ¥çŸ¥è¯†çœŸç†æ€§å…¬ç†
checkTruthAxiom :: Eq p => EpistemicModal p -> String -> p -> Bool
checkTruthAxiom modal subject proposition =
    case findKnowledge modal subject proposition of
        Just knowledge -> truth knowledge
        Nothing -> False

-- æŸ¥æ‰¾çŸ¥è¯†
findKnowledge :: Eq p => EpistemicModal p -> String -> p -> Maybe (Knowledge p)
findKnowledge modal subject proposition =
    find (\k -> subject (belief k) == subject && 
                proposition (belief k) == proposition) 
         (knowledgeBase modal)

-- å®ä¾‹ï¼šæ•°å­¦çŸ¥è¯†
mathematicalKnowledge :: Knowledge String
mathematicalKnowledge = Knowledge
    { belief = Belief
        { proposition = "2+2=4"
        , confidence = 0.9
        , subject = "Alice"
        }
    , justification = Justification
        { evidence = [Evidence
            { source = "mathematical proof"
            , content = "Peano axioms"
            , strength = 0.95
            }]
        , reasoning = Reasoning
            { premises = ["Peano axioms"]
            , conclusion = "2+2=4"
            , method = Deduction
            }
        , reliability = 0.95
        }
    , truth = True
    }

-- æµ‹è¯•å‡½æ•°
testJTB :: IO ()
testJTB = do
    putStrLn $ "JTB satisfied: " ++ show (satisfiesJTB mathematicalKnowledge)
    
    let gettierCase = GettierCase
            { belief = Belief
                { proposition = "Jones will get the job"
                , confidence = 0.8
                , subject = "Smith"
                }
            , justification = Justification
                { evidence = [Evidence
                    { source = "reliable testimony"
                    , content = "Jones has 10 coins"
                    , strength = 0.8
                    }]
                , reasoning = Reasoning
                    { premises = ["Jones will get the job"]
                    , conclusion = "The person who gets the job has 10 coins"
                    , method = Deduction
                    }
                , reliability = 0.8
                }
            , truth = True
            , isKnowledge = False
            }
    
    let gettierProblem = GettierProblem [gettierCase]
    putStrLn $ "JTB sufficiency: " ++ show (checkJTBSufficiency gettierProblem)
    putStrLn $ "Counterexample exists: " ++ show (isJust $ generateCounterexample gettierProblem)
```

## 10. å‚è€ƒæ–‡çŒ®

1. **Plato** (380 BCE). *Theaetetus*. 151e-210a.
2. **Gettier, E.** (1963). "Is Justified True Belief Knowledge?". *Analysis* 23 (6): 121-123.
3. **Chisholm, R.** (1977). *Theory of Knowledge*. Prentice-Hall.
4. **Goldman, A.** (1967). "A Causal Theory of Knowing". *Journal of Philosophy* 64 (12): 357-372.
5. **Nozick, R.** (1981). *Philosophical Explanations*. Harvard University Press.
6. **Dretske, F.** (1981). *Knowledge and the Flow of Information*. MIT Press.
7. **Hintikka, J.** (1962). *Knowledge and Belief*. Cornell University Press.

---

**æ„å»ºè€…**: AI Assistant  
**æœ€åæ›´æ–°**: 2024å¹´12æœˆ20æ—¥  
**ç‰ˆæœ¬**: v2.0
