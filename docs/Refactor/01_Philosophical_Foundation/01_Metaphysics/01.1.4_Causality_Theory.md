# 01.1.4 å› æœç†è®º

## ğŸ“‹ æ¦‚è¿°

**æ–‡æ¡£**: 01.1.4 å› æœç†è®º  
**ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2024-12-21  
**ç»´æŠ¤çŠ¶æ€**: æŒç»­æ„å»ºä¸­  

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

å»ºç«‹ä¸¥æ ¼çš„å½¢å¼åŒ–å› æœç†è®ºä½“ç³»ï¼Œä¸ºå½¢å¼ç§‘å­¦æä¾›å› æœæ€§åŸºç¡€ã€‚

## ğŸ“š ç›®å½•

1. [å› æœæ¦‚å¿µ](#1-å› æœæ¦‚å¿µ)
2. [å› æœå…³ç³»](#2-å› æœå…³ç³»)
3. [å› æœæ¨ç†](#3-å› æœæ¨ç†)
4. [å› æœæ¨¡å‹](#4-å› æœæ¨¡å‹)
5. [å½¢å¼åŒ–å®šä¹‰](#5-å½¢å¼åŒ–å®šä¹‰)
6. [å®šç†ä¸è¯æ˜](#6-å®šç†ä¸è¯æ˜)
7. [ä»£ç å®ç°](#7-ä»£ç å®ç°)
8. [åº”ç”¨ç¤ºä¾‹](#8-åº”ç”¨ç¤ºä¾‹)
9. [ç›¸å…³ç†è®º](#9-ç›¸å…³ç†è®º)
10. [å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)

## 1. å› æœæ¦‚å¿µ

### 1.1 åŸºæœ¬å®šä¹‰

**å®šä¹‰ 1.1.1** (å› æœå…³ç³»)
å› æœå…³ç³»æ˜¯ä¸€ä¸ªä¸‰å…ƒå…³ç³» $C(a, b, t)$ï¼Œè¡¨ç¤ºäº‹ä»¶ $a$ åœ¨æ—¶é—´ $t$ å¯¼è‡´äº‹ä»¶ $b$ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$C(a, b, t) \equiv \text{Event}(a) \land \text{Event}(b) \land \text{Time}(t) \land \text{Causes}(a, b, t)$$

**å®šä¹‰ 1.1.2** (å› æœé“¾)
å› æœé“¾æ˜¯ä¸€ä¸ªäº‹ä»¶åºåˆ—ï¼Œå…¶ä¸­æ¯ä¸ªäº‹ä»¶éƒ½æ˜¯å‰ä¸€ä¸ªäº‹ä»¶çš„ç»“æœã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{CausalChain}(e_1, e_2, \ldots, e_n) \equiv \bigwedge_{i=1}^{n-1} C(e_i, e_{i+1}, t_i)$$

### 1.2 å› æœç±»å‹

**å®šä¹‰ 1.1.3** (ç›´æ¥å› æœ)
äº‹ä»¶ $a$ ç›´æ¥å¯¼è‡´äº‹ä»¶ $b$ å½“ä¸”ä»…å½“æ²¡æœ‰ä¸­é—´äº‹ä»¶ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{DirectCause}(a, b, t) \equiv C(a, b, t) \land \neg \exists c \exists t' (C(a, c, t') \land C(c, b, t))$$

**å®šä¹‰ 1.1.4** (é—´æ¥å› æœ)
äº‹ä»¶ $a$ é—´æ¥å¯¼è‡´äº‹ä»¶ $b$ å½“ä¸”ä»…å½“å­˜åœ¨å› æœé“¾è¿æ¥å®ƒä»¬ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{IndirectCause}(a, b) \equiv \exists e_1, \ldots, e_n \text{CausalChain}(a, e_1, \ldots, e_n, b)$$

## 2. å› æœå…³ç³»

### 2.1 å› æœæ€§è´¨

**å…¬ç† 2.1.1** (å› æœä¼ é€’æ€§)
å¦‚æœ $C(a, b, t_1)$ ä¸” $C(b, c, t_2)$ï¼Œé‚£ä¹ˆ $C(a, c, t_3)$ å…¶ä¸­ $t_3 > t_2 > t_1$ã€‚

**å½¢å¼åŒ–å…¬ç†**:
$$\forall a, b, c, t_1, t_2, t_3 (C(a, b, t_1) \land C(b, c, t_2) \land t_2 > t_1 \rightarrow C(a, c, t_3))$$

**å…¬ç† 2.1.2** (å› æœéå¯¹ç§°æ€§)
å¦‚æœ $C(a, b, t)$ï¼Œé‚£ä¹ˆ $\neg C(b, a, t)$ã€‚

**å½¢å¼åŒ–å…¬ç†**:
$$\forall a, b, t (C(a, b, t) \rightarrow \neg C(b, a, t))$$

### 2.2 å› æœæ¡ä»¶

**å®šä¹‰ 2.2.1** (å……åˆ†æ¡ä»¶)
äº‹ä»¶ $a$ æ˜¯äº‹ä»¶ $b$ çš„å……åˆ†æ¡ä»¶å½“ä¸”ä»…å½“ $a$ çš„å‘ç”Ÿå¿…ç„¶å¯¼è‡´ $b$ çš„å‘ç”Ÿã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{Sufficient}(a, b) \equiv \forall t (O(a, t) \rightarrow O(b, t'))$$

**å®šä¹‰ 2.2.2** (å¿…è¦æ¡ä»¶)
äº‹ä»¶ $a$ æ˜¯äº‹ä»¶ $b$ çš„å¿…è¦æ¡ä»¶å½“ä¸”ä»…å½“ $b$ çš„å‘ç”Ÿå¿…ç„¶è¦æ±‚ $a$ çš„å‘ç”Ÿã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{Necessary}(a, b) \equiv \forall t (O(b, t) \rightarrow O(a, t'))$$

## 3. å› æœæ¨ç†

### 3.1 å› æœæ¨ç†è§„åˆ™

**è§„åˆ™ 3.1.1** (å› æœæ¼”ç»)
å¦‚æœ $C(a, b, t)$ ä¸” $O(a, t)$ï¼Œé‚£ä¹ˆ $O(b, t')$ å…¶ä¸­ $t' > t$ã€‚

**å½¢å¼åŒ–è§„åˆ™**:
$$\frac{C(a, b, t) \quad O(a, t)}{O(b, t')} \text{ (å› æœæ¼”ç»)}$$

**è§„åˆ™ 3.1.2** (å› æœå½’çº³)
å¦‚æœè§‚å¯Ÿåˆ° $O(a, t) \rightarrow O(b, t')$ çš„æ¨¡å¼ï¼Œé‚£ä¹ˆå¯èƒ½ $C(a, b, t)$ã€‚

**å½¢å¼åŒ–è§„åˆ™**:
$$\frac{O(a, t) \rightarrow O(b, t') \text{ (è§‚å¯Ÿæ¨¡å¼)}}{C(a, b, t) \text{ (å¯èƒ½)}} \text{ (å› æœå½’çº³)}$$

### 3.2 å› æœæ¨ç†æ–¹æ³•

**æ–¹æ³• 3.2.1** (åäº‹å®æ¨ç†)
é€šè¿‡è€ƒè™‘"å¦‚æœ $a$ æ²¡æœ‰å‘ç”Ÿä¼šæ€æ ·"æ¥æ¨æ–­å› æœå…³ç³»ã€‚

**å½¢å¼åŒ–æ–¹æ³•**:
$$\text{Counterfactual}(a, b) \equiv \neg O(a, t) \rightarrow \neg O(b, t')$$

**æ–¹æ³• 3.2.2** (å¹²é¢„æ¨ç†)
é€šè¿‡ä¸»åŠ¨å¹²é¢„æ¥éªŒè¯å› æœå…³ç³»ã€‚

**å½¢å¼åŒ–æ–¹æ³•**:
$$\text{Intervention}(a, b) \equiv \text{Do}(a) \rightarrow O(b)$$

## 4. å› æœæ¨¡å‹

### 4.1 å› æœå›¾æ¨¡å‹

**å®šä¹‰ 4.1.1** (å› æœå›¾)
å› æœå›¾æ˜¯ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ $G = (V, E)$ï¼Œå…¶ä¸­èŠ‚ç‚¹è¡¨ç¤ºå˜é‡ï¼Œè¾¹è¡¨ç¤ºå› æœå…³ç³»ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$G = (V, E) \text{ where } E \subseteq V \times V \land \text{DAG}(G)$$

**å®šä¹‰ 4.1.2** (å› æœè·¯å¾„)
å› æœè·¯å¾„æ˜¯ä»èŠ‚ç‚¹ $X$ åˆ°èŠ‚ç‚¹ $Y$ çš„æœ‰å‘è·¯å¾„ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{CausalPath}(X, Y) \equiv \exists p \text{Path}(X, Y, p) \land \text{Directed}(p)$$

### 4.2 ç»“æ„å› æœæ¨¡å‹

**å®šä¹‰ 4.2.1** (ç»“æ„æ–¹ç¨‹)
ç»“æ„æ–¹ç¨‹è¡¨ç¤ºå˜é‡ä¹‹é—´çš„å‡½æ•°å…³ç³»ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$X_i = f_i(\text{Pa}(X_i), U_i)$$

å…¶ä¸­ $\text{Pa}(X_i)$ æ˜¯ $X_i$ çš„çˆ¶èŠ‚ç‚¹ï¼Œ$U_i$ æ˜¯è¯¯å·®é¡¹ã€‚

**å®šä¹‰ 4.2.2** (å› æœæ•ˆåº”)
å˜é‡ $X$ å¯¹å˜é‡ $Y$ çš„å› æœæ•ˆåº”æ˜¯ $Y$ å¯¹ $X$ çš„åå¯¼æ•°ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{CausalEffect}(X, Y) = \frac{\partial Y}{\partial X}$$

## 5. å½¢å¼åŒ–å®šä¹‰

### 5.1 å› æœç†è®ºçš„å½¢å¼åŒ–ç³»ç»Ÿ

**å®šä¹‰ 5.1.1** (å› æœç†è®ºè¯­è¨€)
å› æœç†è®ºçš„è¯­è¨€ $\mathcal{L}_C$ åŒ…å«ï¼š

- äº‹ä»¶å˜é‡ï¼š$e, f, g, \ldots$
- æ—¶é—´å˜é‡ï¼š$t, t', t'', \ldots$
- å› æœè°“è¯ï¼š$C, \text{DirectCause}, \text{IndirectCause}$
- æ—¶é—´è°“è¯ï¼š$<, >, =$
- é€»è¾‘è¿æ¥è¯ï¼š$\neg, \land, \lor, \rightarrow, \leftrightarrow$
- é‡è¯ï¼š$\forall, \exists$

**å®šä¹‰ 5.1.2** (å› æœç†è®ºæ¨¡å‹)
å› æœç†è®ºæ¨¡å‹ $\mathcal{M} = \langle E, T, C, < \rangle$ åŒ…å«ï¼š

- $E$ï¼šäº‹ä»¶é›†åˆ
- $T$ï¼šæ—¶é—´é›†åˆ
- $C$ï¼šå› æœå…³ç³»é›†åˆ
- $<$ï¼šæ—¶é—´é¡ºåºå…³ç³»

### 5.2 å› æœç†è®ºå…¬ç†ç³»ç»Ÿ

**å…¬ç† 5.2.1** (å› æœç†è®ºå…¬ç†)

1. $\forall e, f, t (C(e, f, t) \rightarrow \text{Event}(e) \land \text{Event}(f) \land \text{Time}(t))$
2. $\forall e, f, t (C(e, f, t) \rightarrow \neg C(f, e, t))$ (éå¯¹ç§°æ€§)
3. $\forall e, f, g, t_1, t_2, t_3 (C(e, f, t_1) \land C(f, g, t_2) \land t_2 > t_1 \rightarrow C(e, g, t_3))$ (ä¼ é€’æ€§)
4. $\forall e, f, t (C(e, f, t) \rightarrow \exists t' (t' > t \land \text{Effect}(f, t')))$ (æ—¶é—´æ€§)

## 6. å®šç†ä¸è¯æ˜

### 6.1 åŸºæœ¬å®šç†

**å®šç† 6.1.1** (å› æœå”¯ä¸€æ€§)
å¦‚æœ $C(a, b, t_1)$ ä¸” $C(a, b, t_2)$ï¼Œé‚£ä¹ˆ $t_1 = t_2$ã€‚

**è¯æ˜**:
å‡è®¾ $C(a, b, t_1)$ ä¸” $C(a, b, t_2)$ã€‚
æ ¹æ®å› æœå…³ç³»çš„å®šä¹‰ï¼Œæ¯ä¸ªå› æœå…³ç³»éƒ½æœ‰å”¯ä¸€çš„æ—¶é—´ç‚¹ã€‚
å› æ­¤ï¼Œ$t_1 = t_2$ã€‚

**å®šç† 6.1.2** (å› æœä¼ é€’æ€§)
å¦‚æœ $C(a, b, t_1)$ ä¸” $C(b, c, t_2)$ï¼Œé‚£ä¹ˆå­˜åœ¨ $t_3$ ä½¿å¾— $C(a, c, t_3)$ã€‚

**è¯æ˜**:
å‡è®¾ $C(a, b, t_1)$ ä¸” $C(b, c, t_2)$ã€‚
æ ¹æ®å› æœä¼ é€’æ€§å…¬ç†ï¼Œå­˜åœ¨ $t_3 > t_2 > t_1$ ä½¿å¾— $C(a, c, t_3)$ã€‚

### 6.2 é«˜çº§å®šç†

**å®šç† 6.1.3** (å› æœé—­åˆæ€§)
å¦‚æœ $C(a, b, t)$ ä¸” $C(b, c, t')$ï¼Œé‚£ä¹ˆå­˜åœ¨å› æœé“¾ä» $a$ åˆ° $c$ã€‚

**è¯æ˜**:
å‡è®¾ $C(a, b, t)$ ä¸” $C(b, c, t')$ã€‚
æ ¹æ®å› æœé“¾å®šä¹‰ï¼Œ$\text{CausalChain}(a, b, c)$ã€‚
å› æ­¤ï¼Œå­˜åœ¨å› æœé“¾ä» $a$ åˆ° $c$ã€‚

## 7. ä»£ç å®ç°

### 7.1 Rustå®ç°

```rust
/// å› æœç†è®ºçš„æ ¸å¿ƒæ¦‚å¿µ
pub mod causality_theory {
    use std::collections::{HashMap, HashSet};
    use std::time::{SystemTime, UNIX_EPOCH};
    
    /// äº‹ä»¶ç±»å‹
    #[derive(Debug, Clone, PartialEq, Eq, Hash)]
    pub struct Event {
        pub id: String,
        pub description: String,
        pub timestamp: u64,
    }
    
    /// å› æœå…³ç³»
    #[derive(Debug, Clone)]
    pub struct Causality {
        pub cause: Event,
        pub effect: Event,
        pub timestamp: u64,
    }
    
    /// å› æœå›¾
    #[derive(Debug)]
    pub struct CausalGraph {
        nodes: HashSet<String>,
        edges: HashMap<String, Vec<String>>,
    }
    
    impl CausalGraph {
        pub fn new() -> Self {
            Self {
                nodes: HashSet::new(),
                edges: HashMap::new(),
            }
        }
        
        /// æ·»åŠ å› æœå…³ç³»
        pub fn add_causality(&mut self, causality: Causality) {
            self.nodes.insert(causality.cause.id.clone());
            self.nodes.insert(causality.effect.id.clone());
            
            self.edges
                .entry(causality.cause.id.clone())
                .or_insert_with(Vec::new)
                .push(causality.effect.id.clone());
        }
        
        /// æ£€æŸ¥æ˜¯å¦å­˜åœ¨å› æœè·¯å¾„
        pub fn has_causal_path(&self, from: &str, to: &str) -> bool {
            let mut visited = HashSet::new();
            self.dfs(from, to, &mut visited)
        }
        
        fn dfs(&self, current: &str, target: &str, visited: &mut HashSet<String>) -> bool {
            if current == target {
                return true;
            }
            
            if visited.contains(current) {
                return false;
            }
            
            visited.insert(current.to_string());
            
            if let Some(neighbors) = self.edges.get(current) {
                for neighbor in neighbors {
                    if self.dfs(neighbor, target, visited) {
                        return true;
                    }
                }
            }
            
            false
        }
        
        /// è·å–å› æœé“¾
        pub fn get_causal_chain(&self, from: &str, to: &str) -> Option<Vec<String>> {
            let mut path = Vec::new();
            let mut visited = HashSet::new();
            
            if self.dfs_path(from, to, &mut path, &mut visited) {
                Some(path)
            } else {
                None
            }
        }
        
        fn dfs_path(
            &self,
            current: &str,
            target: &str,
            path: &mut Vec<String>,
            visited: &mut HashSet<String>,
        ) -> bool {
            path.push(current.to_string());
            
            if current == target {
                return true;
            }
            
            if visited.contains(current) {
                path.pop();
                return false;
            }
            
            visited.insert(current.to_string());
            
            if let Some(neighbors) = self.edges.get(current) {
                for neighbor in neighbors {
                    if self.dfs_path(neighbor, target, path, visited) {
                        return true;
                    }
                }
            }
            
            path.pop();
            false
        }
    }
    
    /// å› æœæ¨ç†å¼•æ“
    #[derive(Debug)]
    pub struct CausalReasoner {
        graph: CausalGraph,
        events: HashMap<String, Event>,
    }
    
    impl CausalReasoner {
        pub fn new() -> Self {
            Self {
                graph: CausalGraph::new(),
                events: HashMap::new(),
            }
        }
        
        /// æ·»åŠ äº‹ä»¶
        pub fn add_event(&mut self, event: Event) {
            self.events.insert(event.id.clone(), event);
        }
        
        /// æ·»åŠ å› æœå…³ç³»
        pub fn add_causality(&mut self, causality: Causality) {
            self.graph.add_causality(causality.clone());
        }
        
        /// å› æœæ¼”ç»æ¨ç†
        pub fn causal_deduction(&self, event_id: &str) -> Vec<String> {
            let mut effects = Vec::new();
            
            if let Some(neighbors) = self.graph.edges.get(event_id) {
                for effect_id in neighbors {
                    effects.push(effect_id.clone());
                    // é€’å½’æ¨ç†
                    effects.extend(self.causal_deduction(effect_id));
                }
            }
            
            effects
        }
        
        /// åäº‹å®æ¨ç†
        pub fn counterfactual_reasoning(&self, event_id: &str) -> Vec<String> {
            let mut counterfactuals = Vec::new();
            
            // æ‰¾åˆ°æ‰€æœ‰ä¾èµ–äºè¯¥äº‹ä»¶çš„äº‹ä»¶
            for (node, neighbors) in &self.graph.edges {
                if neighbors.contains(&event_id.to_string()) {
                    counterfactuals.push(format!("å¦‚æœ {} æ²¡æœ‰å‘ç”Ÿï¼Œé‚£ä¹ˆ {} ä¹Ÿä¸ä¼šå‘ç”Ÿ", event_id, node));
                }
            }
            
            counterfactuals
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
pub fn causality_example() {
    use causality_theory::*;
    
    let mut reasoner = CausalReasoner::new();
    
    // åˆ›å»ºäº‹ä»¶
    let event_a = Event {
        id: "A".to_string(),
        description: "å¼€å…³æ‰“å¼€".to_string(),
        timestamp: SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs(),
    };
    
    let event_b = Event {
        id: "B".to_string(),
        description: "ç¯æ³¡äº®èµ·".to_string(),
        timestamp: event_a.timestamp + 1,
    };
    
    let event_c = Event {
        id: "C".to_string(),
        description: "æˆ¿é—´å˜äº®".to_string(),
        timestamp: event_b.timestamp + 1,
    };
    
    // æ·»åŠ äº‹ä»¶
    reasoner.add_event(event_a.clone());
    reasoner.add_event(event_b.clone());
    reasoner.add_event(event_c.clone());
    
    // æ·»åŠ å› æœå…³ç³»
    let causality_ab = Causality {
        cause: event_a.clone(),
        effect: event_b.clone(),
        timestamp: event_a.timestamp,
    };
    
    let causality_bc = Causality {
        cause: event_b.clone(),
        effect: event_c.clone(),
        timestamp: event_b.timestamp,
    };
    
    reasoner.add_causality(causality_ab);
    reasoner.add_causality(causality_bc);
    
    // å› æœæ¨ç†
    let effects = reasoner.causal_deduction("A");
    println!("äº‹ä»¶Açš„ç›´æ¥å’Œé—´æ¥æ•ˆæœ: {:?}", effects);
    
    // åäº‹å®æ¨ç†
    let counterfactuals = reasoner.counterfactual_reasoning("A");
    println!("åäº‹å®æ¨ç†ç»“æœ: {:?}", counterfactuals);
    
    // è·å–å› æœé“¾
    if let Some(chain) = reasoner.graph.get_causal_chain("A", "C") {
        println!("ä»Aåˆ°Cçš„å› æœé“¾: {:?}", chain);
    }
}
```

### 7.2 Haskellå®ç°

```haskell
-- å› æœç†è®ºçš„æ ¸å¿ƒæ¦‚å¿µ
module CausalityTheory where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Maybe (fromMaybe)

-- äº‹ä»¶ç±»å‹
data Event = Event
  { eventId :: String
  , description :: String
  , timestamp :: Integer
  } deriving (Show, Eq, Ord)

-- å› æœå…³ç³»
data Causality = Causality
  { cause :: Event
  , effect :: Event
  , causalityTimestamp :: Integer
  } deriving (Show, Eq)

-- å› æœå›¾
data CausalGraph = CausalGraph
  { nodes :: Set String
  , edges :: Map String [String]
  } deriving (Show)

-- åˆ›å»ºç©ºå› æœå›¾
emptyCausalGraph :: CausalGraph
emptyCausalGraph = CausalGraph Set.empty Map.empty

-- æ·»åŠ å› æœå…³ç³»
addCausality :: CausalGraph -> Causality -> CausalGraph
addCausality graph causality = 
  let newNodes = Set.insert (eventId $ cause causality) 
                $ Set.insert (eventId $ effect causality) 
                $ nodes graph
      newEdges = Map.insertWith (++) (eventId $ cause causality) 
                [eventId $ effect causality] 
                $ edges graph
  in CausalGraph newNodes newEdges

-- æ£€æŸ¥æ˜¯å¦å­˜åœ¨å› æœè·¯å¾„
hasCausalPath :: CausalGraph -> String -> String -> Bool
hasCausalPath graph from to = 
  let visited = Set.empty
  in dfs graph from to visited

-- æ·±åº¦ä¼˜å…ˆæœç´¢
dfs :: CausalGraph -> String -> String -> Set String -> Bool
dfs graph current target visited
  | current == target = True
  | Set.member current visited = False
  | otherwise = 
      let newVisited = Set.insert current visited
          neighbors = fromMaybe [] $ Map.lookup current (edges graph)
      in any (\neighbor -> dfs graph neighbor target newVisited) neighbors

-- è·å–å› æœé“¾
getCausalChain :: CausalGraph -> String -> String -> Maybe [String]
getCausalChain graph from to = 
  let path = []
      visited = Set.empty
  in dfsPath graph from to path visited

-- æ·±åº¦ä¼˜å…ˆæœç´¢è·¯å¾„
dfsPath :: CausalGraph -> String -> String -> [String] -> Set String -> Maybe [String]
dfsPath graph current target path visited
  | current == target = Just (path ++ [current])
  | Set.member current visited = Nothing
  | otherwise = 
      let newVisited = Set.insert current visited
          newPath = path ++ [current]
          neighbors = fromMaybe [] $ Map.lookup current (edges graph)
      in foldr (\neighbor acc -> 
                 case acc of
                   Just _ -> acc
                   Nothing -> dfsPath graph neighbor target newPath newVisited) 
               Nothing neighbors

-- å› æœæ¨ç†å¼•æ“
data CausalReasoner = CausalReasoner
  { graph :: CausalGraph
  , events :: Map String Event
  } deriving (Show)

-- åˆ›å»ºæ¨ç†å¼•æ“
emptyReasoner :: CausalReasoner
emptyReasoner = CausalReasoner emptyCausalGraph Map.empty

-- æ·»åŠ äº‹ä»¶
addEvent :: CausalReasoner -> Event -> CausalReasoner
addEvent reasoner event = 
  reasoner { events = Map.insert (eventId event) event (events reasoner) }

-- æ·»åŠ å› æœå…³ç³»
addCausalityToReasoner :: CausalReasoner -> Causality -> CausalReasoner
addCausalityToReasoner reasoner causality = 
  reasoner { graph = addCausality (graph reasoner) causality }

-- å› æœæ¼”ç»æ¨ç†
causalDeduction :: CausalReasoner -> String -> [String]
causalDeduction reasoner eventId = 
  let neighbors = fromMaybe [] $ Map.lookup eventId (edges $ graph reasoner)
  in neighbors ++ concatMap (causalDeduction reasoner) neighbors

-- åäº‹å®æ¨ç†
counterfactualReasoning :: CausalReasoner -> String -> [String]
counterfactualReasoning reasoner eventId = 
  let allEdges = Map.toList (edges $ graph reasoner)
      dependentEvents = [node | (node, neighbors) <- allEdges, eventId `elem` neighbors]
  in map (\node -> "å¦‚æœ " ++ eventId ++ " æ²¡æœ‰å‘ç”Ÿï¼Œé‚£ä¹ˆ " ++ node ++ " ä¹Ÿä¸ä¼šå‘ç”Ÿ") dependentEvents

-- ä½¿ç”¨ç¤ºä¾‹
example :: IO ()
example = do
  let eventA = Event "A" "å¼€å…³æ‰“å¼€" 1000
      eventB = Event "B" "ç¯æ³¡äº®èµ·" 1001
      eventC = Event "C" "æˆ¿é—´å˜äº®" 1002
      
      causalityAB = Causality eventA eventB 1000
      causalityBC = Causality eventB eventC 1001
      
      reasoner = addEvent (addEvent (addEvent emptyReasoner eventA) eventB) eventC
      reasonerWithCausality = addCausalityToReasoner (addCausalityToReasoner reasoner causalityAB) causalityBC
      
      effects = causalDeduction reasonerWithCausality "A"
      counterfactuals = counterfactualReasoning reasonerWithCausality "A"
      chain = getCausalChain (graph reasonerWithCausality) "A" "C"
  
  putStrLn $ "äº‹ä»¶Açš„ç›´æ¥å’Œé—´æ¥æ•ˆæœ: " ++ show effects
  putStrLn $ "åäº‹å®æ¨ç†ç»“æœ: " ++ show counterfactuals
  putStrLn $ "ä»Aåˆ°Cçš„å› æœé“¾: " ++ show chain
```

## 8. åº”ç”¨ç¤ºä¾‹

### 8.1 ç§‘å­¦æ¨ç†åº”ç”¨

**ç¤ºä¾‹ 8.1.1** (åŒ»å­¦è¯Šæ–­)
åœ¨åŒ»å­¦è¯Šæ–­ä¸­ï¼Œç—‡çŠ¶å’Œç–¾ç—…ä¹‹é—´å­˜åœ¨å› æœå…³ç³»ã€‚

```rust
// åŒ»å­¦è¯Šæ–­çš„å› æœæ¨ç†
let fever = Event {
    id: "fever".to_string(),
    description: "å‘çƒ§".to_string(),
    timestamp: 1000,
};

let infection = Event {
    id: "infection".to_string(),
    description: "æ„ŸæŸ“".to_string(),
    timestamp: 999,
};

let causality = Causality {
    cause: infection,
    effect: fever,
    timestamp: 999,
};
```

**ç¤ºä¾‹ 8.1.2** (ç»æµåˆ†æ)
åœ¨ç»æµåˆ†æä¸­ï¼Œæ”¿ç­–å˜åŒ–å’Œç»æµæŒ‡æ ‡ä¹‹é—´å­˜åœ¨å› æœå…³ç³»ã€‚

### 8.2 äººå·¥æ™ºèƒ½åº”ç”¨

**ç¤ºä¾‹ 8.2.1** (å¼ºåŒ–å­¦ä¹ )
åœ¨å¼ºåŒ–å­¦ä¹ ä¸­ï¼ŒåŠ¨ä½œå’Œå¥–åŠ±ä¹‹é—´å­˜åœ¨å› æœå…³ç³»ã€‚

**ç¤ºä¾‹ 8.2.2** (è‡ªç„¶è¯­è¨€å¤„ç†)
åœ¨è‡ªç„¶è¯­è¨€å¤„ç†ä¸­ï¼Œè¯è¯­å’Œè¯­ä¹‰ä¹‹é—´å­˜åœ¨å› æœå…³ç³»ã€‚

## 9. ç›¸å…³ç†è®º

### 9.1 ç›¸å…³ç†è®ºé“¾æ¥

- [01.1.1 å­˜åœ¨ç†è®º](../01.1.1_Existence_Theory.md)
- [01.1.2 å®ä½“ç†è®º](../01.1.2_Entity_Theory.md)
- [01.1.3 æ¨¡æ€ç†è®º](../01.1.3_Modal_Theory.md)
- [02.2.1 å‘½é¢˜é€»è¾‘](../../02_Mathematical_Foundation/02_Logic/02.2.1_Propositional_Logic.md)
- [02.2.2 è°“è¯é€»è¾‘](../../02_Mathematical_Foundation/02_Logic/02.2.2_Predicate_Logic.md)
- [02.2.3 æ¨¡æ€é€»è¾‘](../../02_Mathematical_Foundation/02_Logic/02.2.3_Modal_Logic.md)

### 9.2 ç†è®ºå…³ç³»

å› æœç†è®ºä¸ä»¥ä¸‹ç†è®ºå¯†åˆ‡ç›¸å…³ï¼š

- **å­˜åœ¨ç†è®º**: å› æœå…³ç³»æ˜¯å­˜åœ¨çš„ä¸€ç§å½¢å¼
- **æ¨¡æ€ç†è®º**: å› æœæ¨¡æ€æ˜¯æ¨¡æ€çš„ä¸€ç§
- **é€»è¾‘ç†è®º**: å› æœæ¨ç†æ˜¯é€»è¾‘æ¨ç†çš„ä¸€ç§
- **æ—¶é—´ç†è®º**: å› æœå…³ç³»å…·æœ‰æ—¶é—´æ€§

## 10. å‚è€ƒæ–‡çŒ®

1. Pearl, J. (2009). *Causality: Models, Reasoning, and Inference*. Cambridge University Press.
2. Spirtes, P., Glymour, C., & Scheines, R. (2000). *Causation, Prediction, and Search*. MIT Press.
3. Woodward, J. (2003). *Making Things Happen: A Theory of Causal Explanation*. Oxford University Press.
4. Lewis, D. (1973). *Causation*. Journal of Philosophy, 70(17), 556-567.
5. Hume, D. (1739). *A Treatise of Human Nature*. Oxford University Press.

---

**æ–‡æ¡£çŠ¶æ€**: æŒç»­æ„å»ºä¸­  
**æœ€åæ›´æ–°**: 2024-12-21  
**ä¸‹ä¸€æ­¥è®¡åˆ’**: å®Œå–„å®šç†è¯æ˜ï¼Œå¢åŠ æ›´å¤šåº”ç”¨ç¤ºä¾‹
