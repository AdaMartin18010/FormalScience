# 01.1.3 æ¨¡æ€ç†è®º

## ğŸ“‹ æ¦‚è¿°

**æ–‡æ¡£**: 01.1.3 æ¨¡æ€ç†è®º  
**ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2024-12-21  
**ç»´æŠ¤çŠ¶æ€**: æŒç»­æ„å»ºä¸­  

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

å»ºç«‹ä¸¥æ ¼çš„å½¢å¼åŒ–æ¨¡æ€ç†è®ºä½“ç³»ï¼Œä¸ºå½¢å¼ç§‘å­¦æä¾›æ¨¡æ€é€»è¾‘åŸºç¡€ã€‚

## ğŸ“š ç›®å½•

1. [æ¨¡æ€æ¦‚å¿µ](#1-æ¨¡æ€æ¦‚å¿µ)
2. [å¯èƒ½ä¸–ç•Œè¯­ä¹‰](#2-å¯èƒ½ä¸–ç•Œè¯­ä¹‰)
3. [æ¨¡æ€é€»è¾‘ç³»ç»Ÿ](#3-æ¨¡æ€é€»è¾‘ç³»ç»Ÿ)
4. [æ¨¡æ€æ¨ç†](#4-æ¨¡æ€æ¨ç†)
5. [å½¢å¼åŒ–å®šä¹‰](#5-å½¢å¼åŒ–å®šä¹‰)
6. [å®šç†ä¸è¯æ˜](#6-å®šç†ä¸è¯æ˜)
7. [ä»£ç å®ç°](#7-ä»£ç å®ç°)
8. [åº”ç”¨ç¤ºä¾‹](#8-åº”ç”¨ç¤ºä¾‹)
9. [ç›¸å…³ç†è®º](#9-ç›¸å…³ç†è®º)
10. [å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)

## 1. æ¨¡æ€æ¦‚å¿µ

### 1.1 åŸºæœ¬å®šä¹‰

**å®šä¹‰ 1.3.1** (æ¨¡æ€)
æ¨¡æ€æ˜¯è¡¨ç¤ºå¯èƒ½æ€§ã€å¿…ç„¶æ€§ç­‰æ¦‚å¿µçš„é€»è¾‘ç®—å­ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{Modal}(\phi) \equiv \Box \phi \lor \Diamond \phi$$

**å®šä¹‰ 1.3.2** (å¿…ç„¶æ€§)
å‘½é¢˜ $\phi$ æ˜¯å¿…ç„¶çš„å½“ä¸”ä»…å½“ $\phi$ åœ¨æ‰€æœ‰å¯èƒ½ä¸–ç•Œä¸­éƒ½ä¸ºçœŸã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\Box \phi \equiv \forall w \in W \ \phi_w$$

**å®šä¹‰ 1.3.3** (å¯èƒ½æ€§)
å‘½é¢˜ $\phi$ æ˜¯å¯èƒ½çš„å½“ä¸”ä»…å½“ $\phi$ åœ¨è‡³å°‘ä¸€ä¸ªå¯èƒ½ä¸–ç•Œä¸­ä¸ºçœŸã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\Diamond \phi \equiv \exists w \in W \ \phi_w$$

### 1.2 æ¨¡æ€ç±»å‹

**å®šä¹‰ 1.3.4** (é€»è¾‘æ¨¡æ€)
é€»è¾‘æ¨¡æ€æ¶‰åŠé€»è¾‘å¿…ç„¶æ€§å’Œé€»è¾‘å¯èƒ½æ€§ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{LogicalModal}(\phi) \equiv \Box_L \phi \lor \Diamond_L \phi$$

**å®šä¹‰ 1.3.5** (ç‰©ç†æ¨¡æ€)
ç‰©ç†æ¨¡æ€æ¶‰åŠç‰©ç†å¿…ç„¶æ€§å’Œç‰©ç†å¯èƒ½æ€§ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{PhysicalModal}(\phi) \equiv \Box_P \phi \lor \Diamond_P \phi$$

**å®šä¹‰ 1.3.6** (è®¤è¯†æ¨¡æ€)
è®¤è¯†æ¨¡æ€æ¶‰åŠè®¤è¯†å¿…ç„¶æ€§å’Œè®¤è¯†å¯èƒ½æ€§ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{EpistemicModal}(\phi) \equiv \Box_E \phi \lor \Diamond_E \phi$$

## 2. å¯èƒ½ä¸–ç•Œè¯­ä¹‰

### 2.1 å¯èƒ½ä¸–ç•Œ

**å®šä¹‰ 2.1.1** (å¯èƒ½ä¸–ç•Œ)
å¯èƒ½ä¸–ç•Œæ˜¯é€»è¾‘ä¸Šä¸€è‡´çš„ä¸–ç•ŒçŠ¶æ€ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$World(w) \equiv \text{Consistent}(w)$$

**å®šä¹‰ 2.1.2** (å¯è¾¾å…³ç³»)
ä¸–ç•Œ $w_1$ å¯è¾¾ä¸–ç•Œ $w_2$ å½“ä¸”ä»…å½“ä» $w_1$ çš„è§’åº¦çœ‹ $w_2$ æ˜¯å¯èƒ½çš„ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$R(w_1, w_2) \equiv \text{Accessible}(w_1, w_2)$$

### 2.2 æ¨¡æ€è¯­ä¹‰

**å®šä¹‰ 2.1.3** (å¿…ç„¶æ€§è¯­ä¹‰)
$\Box \phi$ åœ¨ä¸–ç•Œ $w$ ä¸­ä¸ºçœŸå½“ä¸”ä»…å½“ $\phi$ åœ¨æ‰€æœ‰ä» $w$ å¯è¾¾çš„ä¸–ç•Œä¸­ä¸ºçœŸã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$w \models \Box \phi \equiv \forall w' (R(w, w') \rightarrow w' \models \phi)$$

**å®šä¹‰ 2.1.4** (å¯èƒ½æ€§è¯­ä¹‰)
$\Diamond \phi$ åœ¨ä¸–ç•Œ $w$ ä¸­ä¸ºçœŸå½“ä¸”ä»…å½“ $\phi$ åœ¨è‡³å°‘ä¸€ä¸ªä» $w$ å¯è¾¾çš„ä¸–ç•Œä¸­ä¸ºçœŸã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$w \models \Diamond \phi \equiv \exists w' (R(w, w') \land w' \models \phi)$$

## 3. æ¨¡æ€é€»è¾‘ç³»ç»Ÿ

### 3.1 åŸºæœ¬æ¨¡æ€é€»è¾‘

**å®šä¹‰ 3.1.1** (Kç³»ç»Ÿ)
Kç³»ç»Ÿæ˜¯æœ€åŸºæœ¬çš„æ¨¡æ€é€»è¾‘ç³»ç»Ÿï¼ŒåŒ…å«ä»¥ä¸‹å…¬ç†ï¼š
1. æ‰€æœ‰å‘½é¢˜é€»è¾‘é‡è¨€å¼
2. $\Box(\phi \rightarrow \psi) \rightarrow (\Box \phi \rightarrow \Box \psi)$ (Kå…¬ç†)
3. å¿…ç„¶åŒ–è§„åˆ™ï¼šå¦‚æœ $\vdash \phi$ï¼Œé‚£ä¹ˆ $\vdash \Box \phi$

**å®šä¹‰ 3.1.2** (Tç³»ç»Ÿ)
Tç³»ç»Ÿåœ¨Kç³»ç»ŸåŸºç¡€ä¸Šæ·»åŠ ï¼š
$\Box \phi \rightarrow \phi$ (Tå…¬ç†)

**å®šä¹‰ 3.1.3** (S4ç³»ç»Ÿ)
S4ç³»ç»Ÿåœ¨Tç³»ç»ŸåŸºç¡€ä¸Šæ·»åŠ ï¼š
$\Box \phi \rightarrow \Box \Box \phi$ (4å…¬ç†)

**å®šä¹‰ 3.1.4** (S5ç³»ç»Ÿ)
S5ç³»ç»Ÿåœ¨S4ç³»ç»ŸåŸºç¡€ä¸Šæ·»åŠ ï¼š
$\Diamond \phi \rightarrow \Box \Diamond \phi$ (5å…¬ç†)

### 3.2 é«˜çº§æ¨¡æ€é€»è¾‘

**å®šä¹‰ 3.1.5** (å¤šæ¨¡æ€é€»è¾‘)
å¤šæ¨¡æ€é€»è¾‘åŒ…å«å¤šä¸ªæ¨¡æ€ç®—å­ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\text{MultiModal}(\phi) \equiv \Box_1 \phi \lor \Box_2 \phi \lor \ldots \lor \Box_n \phi$$

**å®šä¹‰ 3.1.6** (åŠ¨æ€æ¨¡æ€é€»è¾‘)
åŠ¨æ€æ¨¡æ€é€»è¾‘åŒ…å«åŠ¨æ€æ¨¡æ€ç®—å­ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$[\alpha] \phi \equiv \text{After}(\alpha, \phi)$$

## 4. æ¨¡æ€æ¨ç†

### 4.1 åŸºæœ¬æ¨ç†è§„åˆ™

**è§„åˆ™ 4.1.1** (å¿…ç„¶åŒ–)
å¦‚æœ $\phi$ æ˜¯å®šç†ï¼Œé‚£ä¹ˆ $\Box \phi$ ä¹Ÿæ˜¯å®šç†ã€‚

**å½¢å¼åŒ–è§„åˆ™**:
$$\frac{\vdash \phi}{\vdash \Box \phi} \text{ (å¿…ç„¶åŒ–)}$$

**è§„åˆ™ 4.1.2** (æ¨¡æ€åˆ†ç¦»)
ä» $\Box(\phi \rightarrow \psi)$ å’Œ $\Box \phi$ å¯ä»¥æ¨å‡º $\Box \psi$ã€‚

**å½¢å¼åŒ–è§„åˆ™**:
$$\frac{\Box(\phi \rightarrow \psi) \quad \Box \phi}{\Box \psi} \text{ (æ¨¡æ€åˆ†ç¦»)}$$

### 4.2 é«˜çº§æ¨ç†è§„åˆ™

**è§„åˆ™ 4.1.3** (å¯èƒ½ä¸–ç•Œæ¨ç†)
å¦‚æœ $\Diamond \phi$ ä¸ºçœŸï¼Œé‚£ä¹ˆå­˜åœ¨ä¸€ä¸ªå¯èƒ½ä¸–ç•Œä½¿å¾— $\phi$ ä¸ºçœŸã€‚

**å½¢å¼åŒ–è§„åˆ™**:
$$\frac{\Diamond \phi}{\exists w \ \phi_w} \text{ (å¯èƒ½ä¸–ç•Œæ¨ç†)}$$

**è§„åˆ™ 4.1.4** (æ¨¡æ€å½’çº¦)
$\Diamond \phi$ ç­‰ä»·äº $\neg \Box \neg \phi$ã€‚

**å½¢å¼åŒ–è§„åˆ™**:
$$\Diamond \phi \leftrightarrow \neg \Box \neg \phi$$

## 5. å½¢å¼åŒ–å®šä¹‰

### 5.1 æ¨¡æ€ç†è®ºçš„å½¢å¼åŒ–ç³»ç»Ÿ

**å®šä¹‰ 5.1.1** (æ¨¡æ€ç†è®ºè¯­è¨€)
æ¨¡æ€ç†è®ºçš„è¯­è¨€ $\mathcal{L}_M$ åŒ…å«ï¼š
- å‘½é¢˜å˜é‡ï¼š$p, q, r, \ldots$
- æ¨¡æ€ç®—å­ï¼š$\Box, \Diamond$
- é€»è¾‘è¿æ¥è¯ï¼š$\neg, \land, \lor, \rightarrow, \leftrightarrow$
- é‡è¯ï¼š$\forall, \exists$

**å®šä¹‰ 5.1.2** (æ¨¡æ€ç†è®ºæ¨¡å‹)
æ¨¡æ€ç†è®ºæ¨¡å‹ $\mathcal{M} = \langle W, R, V \rangle$ åŒ…å«ï¼š
- $W$ï¼šå¯èƒ½ä¸–ç•Œé›†åˆ
- $R$ï¼šå¯è¾¾å…³ç³»
- $V$ï¼šèµ‹å€¼å‡½æ•°

### 5.2 æ¨¡æ€ç†è®ºå…¬ç†ç³»ç»Ÿ

**å…¬ç† 5.1.1** (æ¨¡æ€ç†è®ºå…¬ç†)
1. $\Box(\phi \rightarrow \psi) \rightarrow (\Box \phi \rightarrow \Box \psi)$ (Kå…¬ç†)
2. $\Box \phi \rightarrow \phi$ (Tå…¬ç†)
3. $\Box \phi \rightarrow \Box \Box \phi$ (4å…¬ç†)
4. $\Diamond \phi \rightarrow \Box \Diamond \phi$ (5å…¬ç†)
5. $\Diamond \phi \leftrightarrow \neg \Box \neg \phi$ (å¯¹å¶å…¬ç†)

## 6. å®šç†ä¸è¯æ˜

### 6.1 åŸºæœ¬å®šç†

**å®šç† 6.1.1** (æ¨¡æ€å¯¹å¶æ€§)
$\Box \phi \leftrightarrow \neg \Diamond \neg \phi$

**è¯æ˜**:
æ ¹æ®å¯èƒ½ä¸–ç•Œè¯­ä¹‰ï¼š
$\Box \phi$ ä¸ºçœŸå½“ä¸”ä»…å½“ $\forall w' (R(w, w') \rightarrow w' \models \phi)$
$\neg \Diamond \neg \phi$ ä¸ºçœŸå½“ä¸”ä»…å½“ $\neg \exists w' (R(w, w') \land w' \models \neg \phi)$
æ ¹æ®é€»è¾‘ç­‰ä»·æ€§ï¼Œä¸¤è€…ç­‰ä»·ã€‚

**å®šç† 6.1.2** (æ¨¡æ€åˆ†é…å¾‹)
$\Box(\phi \land \psi) \leftrightarrow \Box \phi \land \Box \psi$

**è¯æ˜**:
æ ¹æ®å¯èƒ½ä¸–ç•Œè¯­ä¹‰ï¼š
$\Box(\phi \land \psi)$ ä¸ºçœŸå½“ä¸”ä»…å½“ $\forall w' (R(w, w') \rightarrow w' \models \phi \land \psi)$
$\Box \phi \land \Box \psi$ ä¸ºçœŸå½“ä¸”ä»…å½“ $\forall w' (R(w, w') \rightarrow w' \models \phi) \land \forall w' (R(w, w') \rightarrow w' \models \psi)$
æ ¹æ®é€»è¾‘ç­‰ä»·æ€§ï¼Œä¸¤è€…ç­‰ä»·ã€‚

### 6.2 é«˜çº§å®šç†

**å®šç† 6.1.3** (æ¨¡æ€ä¼ é€’æ€§)
$\Box \phi \rightarrow \Box \Box \phi$

**è¯æ˜**:
å‡è®¾ $\Box \phi$ åœ¨ä¸–ç•Œ $w$ ä¸­ä¸ºçœŸã€‚
æ ¹æ®å¿…ç„¶æ€§è¯­ä¹‰ï¼Œ$\forall w' (R(w, w') \rightarrow w' \models \phi)$ã€‚
å¯¹äºä»»æ„ä¸–ç•Œ $w''$ï¼Œå¦‚æœ $R(w, w'')$ï¼Œé‚£ä¹ˆ $w'' \models \phi$ã€‚
å› æ­¤ï¼Œ$\forall w''' (R(w'', w''') \rightarrow w''' \models \phi)$ã€‚
æ‰€ä»¥ï¼Œ$\Box \Box \phi$ åœ¨ä¸–ç•Œ $w$ ä¸­ä¸ºçœŸã€‚

**å®šç† 6.1.4** (æ¨¡æ€æ¬§å‡ é‡Œå¾—æ€§)
$\Diamond \phi \rightarrow \Box \Diamond \phi$

**è¯æ˜**:
å‡è®¾ $\Diamond \phi$ åœ¨ä¸–ç•Œ $w$ ä¸­ä¸ºçœŸã€‚
æ ¹æ®å¯èƒ½æ€§è¯­ä¹‰ï¼Œ$\exists w' (R(w, w') \land w' \models \phi)$ã€‚
å¯¹äºä»»æ„ä¸–ç•Œ $w''$ï¼Œå¦‚æœ $R(w, w'')$ï¼Œé‚£ä¹ˆç”±äºå¯è¾¾å…³ç³»çš„æ¬§å‡ é‡Œå¾—æ€§ï¼Œ$R(w'', w')$ã€‚
å› æ­¤ï¼Œ$\exists w' (R(w'', w') \land w' \models \phi)$ã€‚
æ‰€ä»¥ï¼Œ$\Box \Diamond \phi$ åœ¨ä¸–ç•Œ $w$ ä¸­ä¸ºçœŸã€‚

## 7. ä»£ç å®ç°

### 7.1 Rustå®ç°

```rust
/// æ¨¡æ€ç†è®ºçš„æ ¸å¿ƒæ¦‚å¿µ
pub mod modal_theory {
    use std::collections::HashMap;
    use std::collections::HashSet;
    
    /// æ¨¡æ€ç®—å­
    #[derive(Debug, Clone, PartialEq)]
    pub enum ModalOperator {
        Necessity,  // â–¡
        Possibility, // â—‡
    }
    
    /// æ¨¡æ€å…¬å¼
    #[derive(Debug, Clone)]
    pub enum ModalFormula {
        Atom(String),
        Not(Box<ModalFormula>),
        And(Box<ModalFormula>, Box<ModalFormula>),
        Or(Box<ModalFormula>, Box<ModalFormula>),
        Implies(Box<ModalFormula>, Box<ModalFormula>),
        Modal(ModalOperator, Box<ModalFormula>),
    }
    
    /// å¯èƒ½ä¸–ç•Œ
    #[derive(Debug, Clone, PartialEq, Eq, Hash)]
    pub struct PossibleWorld {
        id: String,
        propositions: HashSet<String>,
    }
    
    impl PossibleWorld {
        pub fn new(id: String) -> Self {
            PossibleWorld {
                id,
                propositions: HashSet::new(),
            }
        }
        
        pub fn add_proposition(&mut self, prop: String) {
            self.propositions.insert(prop);
        }
        
        pub fn satisfies(&self, prop: &str) -> bool {
            self.propositions.contains(prop)
        }
    }
    
    /// å¯è¾¾å…³ç³»
    #[derive(Debug, Clone)]
    pub struct AccessibilityRelation {
        relations: HashMap<String, HashSet<String>>,
    }
    
    impl AccessibilityRelation {
        pub fn new() -> Self {
            AccessibilityRelation {
                relations: HashMap::new(),
            }
        }
        
        pub fn add_relation(&mut self, from: String, to: String) {
            self.relations.entry(from).or_insert_with(HashSet::new).insert(to);
        }
        
        pub fn is_accessible(&self, from: &str, to: &str) -> bool {
            self.relations.get(from).map_or(false, |targets| targets.contains(to))
        }
        
        pub fn get_accessible_worlds(&self, from: &str) -> HashSet<String> {
            self.relations.get(from).cloned().unwrap_or_default()
        }
    }
    
    /// æ¨¡æ€æ¨¡å‹
    #[derive(Debug, Clone)]
    pub struct ModalModel {
        worlds: HashMap<String, PossibleWorld>,
        accessibility: AccessibilityRelation,
    }
    
    impl ModalModel {
        pub fn new() -> Self {
            ModalModel {
                worlds: HashMap::new(),
                accessibility: AccessibilityRelation::new(),
            }
        }
        
        pub fn add_world(&mut self, world: PossibleWorld) {
            self.worlds.insert(world.id.clone(), world);
        }
        
        pub fn add_accessibility(&mut self, from: String, to: String) {
            self.accessibility.add_relation(from, to);
        }
        
        /// è¯„ä¼°æ¨¡æ€å…¬å¼
        pub fn evaluate(&self, formula: &ModalFormula, world_id: &str) -> bool {
            match formula {
                ModalFormula::Atom(prop) => {
                    self.worlds.get(world_id).map_or(false, |w| w.satisfies(prop))
                }
                ModalFormula::Not(f) => !self.evaluate(f, world_id),
                ModalFormula::And(f1, f2) => {
                    self.evaluate(f1, world_id) && self.evaluate(f2, world_id)
                }
                ModalFormula::Or(f1, f2) => {
                    self.evaluate(f1, world_id) || self.evaluate(f2, world_id)
                }
                ModalFormula::Implies(f1, f2) => {
                    !self.evaluate(f1, world_id) || self.evaluate(f2, world_id)
                }
                ModalFormula::Modal(operator, f) => {
                    match operator {
                        ModalOperator::Necessity => {
                            let accessible = self.accessibility.get_accessible_worlds(world_id);
                            accessible.iter().all(|w| self.evaluate(f, w))
                        }
                        ModalOperator::Possibility => {
                            let accessible = self.accessibility.get_accessible_worlds(world_id);
                            accessible.iter().any(|w| self.evaluate(f, w))
                        }
                    }
                }
            }
        }
        
        /// æ£€æŸ¥å…¬å¼åœ¨æ‰€æœ‰ä¸–ç•Œä¸­æ˜¯å¦ä¸ºçœŸ
        pub fn is_valid(&self, formula: &ModalFormula) -> bool {
            self.worlds.keys().all(|world_id| self.evaluate(formula, world_id))
        }
        
        /// æ£€æŸ¥å…¬å¼æ˜¯å¦å¯æ»¡è¶³
        pub fn is_satisfiable(&self, formula: &ModalFormula) -> bool {
            self.worlds.keys().any(|world_id| self.evaluate(formula, world_id))
        }
    }
    
    /// æ¨¡æ€é€»è¾‘ç³»ç»Ÿ
    pub struct ModalLogicSystem {
        model: ModalModel,
    }
    
    impl ModalLogicSystem {
        pub fn new(model: ModalModel) -> Self {
            ModalLogicSystem { model }
        }
        
        /// Kå…¬ç†ï¼šâ–¡(Ï†â†’Ïˆ) â†’ (â–¡Ï†â†’â–¡Ïˆ)
        pub fn k_axiom(&self, phi: &ModalFormula, psi: &ModalFormula) -> bool {
            let antecedent = ModalFormula::Modal(
                ModalOperator::Necessity,
                Box::new(ModalFormula::Implies(Box::new(phi.clone()), Box::new(psi.clone()))),
            );
            let consequent = ModalFormula::Implies(
                Box::new(ModalFormula::Modal(ModalOperator::Necessity, Box::new(phi.clone()))),
                Box::new(ModalFormula::Modal(ModalOperator::Necessity, Box::new(psi.clone()))),
            );
            let k_formula = ModalFormula::Implies(Box::new(antecedent), Box::new(consequent));
            self.model.is_valid(&k_formula)
        }
        
        /// Tå…¬ç†ï¼šâ–¡Ï† â†’ Ï†
        pub fn t_axiom(&self, phi: &ModalFormula) -> bool {
            let t_formula = ModalFormula::Implies(
                Box::new(ModalFormula::Modal(ModalOperator::Necessity, Box::new(phi.clone()))),
                Box::new(phi.clone()),
            );
            self.model.is_valid(&t_formula)
        }
        
        /// 4å…¬ç†ï¼šâ–¡Ï† â†’ â–¡â–¡Ï†
        pub fn four_axiom(&self, phi: &ModalFormula) -> bool {
            let four_formula = ModalFormula::Implies(
                Box::new(ModalFormula::Modal(ModalOperator::Necessity, Box::new(phi.clone()))),
                Box::new(ModalFormula::Modal(
                    ModalOperator::Necessity,
                    Box::new(ModalFormula::Modal(ModalOperator::Necessity, Box::new(phi.clone()))),
                )),
            );
            self.model.is_valid(&four_formula)
        }
        
        /// 5å…¬ç†ï¼šâ—‡Ï† â†’ â–¡â—‡Ï†
        pub fn five_axiom(&self, phi: &ModalFormula) -> bool {
            let five_formula = ModalFormula::Implies(
                Box::new(ModalFormula::Modal(ModalOperator::Possibility, Box::new(phi.clone()))),
                Box::new(ModalFormula::Modal(
                    ModalOperator::Necessity,
                    Box::new(ModalFormula::Modal(ModalOperator::Possibility, Box::new(phi.clone()))),
                )),
            );
            self.model.is_valid(&five_formula)
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_modal_model() {
        let mut model = modal_theory::ModalModel::new();
        
        // åˆ›å»ºå¯èƒ½ä¸–ç•Œ
        let mut world1 = modal_theory::PossibleWorld::new("w1".to_string());
        world1.add_proposition("p".to_string());
        
        let mut world2 = modal_theory::PossibleWorld::new("w2".to_string());
        world2.add_proposition("q".to_string());
        
        model.add_world(world1);
        model.add_world(world2);
        
        // æ·»åŠ å¯è¾¾å…³ç³»
        model.add_accessibility("w1".to_string(), "w2".to_string());
        
        // æµ‹è¯•å…¬å¼
        let p = modal_theory::ModalFormula::Atom("p".to_string());
        let q = modal_theory::ModalFormula::Atom("q".to_string());
        
        assert!(model.evaluate(&p, "w1"));
        assert!(!model.evaluate(&p, "w2"));
        assert!(model.evaluate(&q, "w2"));
    }
    
    #[test]
    fn test_modal_operators() {
        let mut model = modal_theory::ModalModel::new();
        
        // åˆ›å»ºå¯èƒ½ä¸–ç•Œ
        let mut world1 = modal_theory::PossibleWorld::new("w1".to_string());
        let mut world2 = modal_theory::PossibleWorld::new("w2".to_string());
        world2.add_proposition("p".to_string());
        
        model.add_world(world1);
        model.add_world(world2);
        model.add_accessibility("w1".to_string(), "w2".to_string());
        
        let p = modal_theory::ModalFormula::Atom("p".to_string());
        let necessity_p = modal_theory::ModalFormula::Modal(
            modal_theory::ModalOperator::Necessity,
            Box::new(p.clone()),
        );
        let possibility_p = modal_theory::ModalFormula::Modal(
            modal_theory::ModalOperator::Possibility,
            Box::new(p.clone()),
        );
        
        // åœ¨w1ä¸­ï¼Œpä¸æ˜¯å¿…ç„¶çš„ï¼Œä½†æ˜¯å¯èƒ½çš„
        assert!(!model.evaluate(&necessity_p, "w1"));
        assert!(model.evaluate(&possibility_p, "w1"));
    }
}
```

### 7.2 Haskellå®ç°

```haskell
-- æ¨¡æ€ç†è®ºçš„æ ¸å¿ƒæ¦‚å¿µ
module ModalTheory where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set

-- æ¨¡æ€ç®—å­
data ModalOperator = Necessity | Possibility deriving (Show, Eq)

-- æ¨¡æ€å…¬å¼
data ModalFormula = Atom String
                  | Not ModalFormula
                  | And ModalFormula ModalFormula
                  | Or ModalFormula ModalFormula
                  | Implies ModalFormula ModalFormula
                  | Modal ModalOperator ModalFormula
                  deriving (Show, Eq)

-- å¯èƒ½ä¸–ç•Œ
data PossibleWorld = PossibleWorld
    { worldId :: String
    , propositions :: Set String
    } deriving (Show, Eq)

-- åˆ›å»ºå¯èƒ½ä¸–ç•Œ
newWorld :: String -> PossibleWorld
newWorld id = PossibleWorld id Set.empty

-- æ·»åŠ å‘½é¢˜
addProposition :: String -> PossibleWorld -> PossibleWorld
addProposition prop world = world { propositions = Set.insert prop (propositions world) }

-- æ£€æŸ¥å‘½é¢˜æ˜¯å¦æ»¡è¶³
satisfies :: String -> PossibleWorld -> Bool
satisfies prop world = Set.member prop (propositions world)

-- å¯è¾¾å…³ç³»
type AccessibilityRelation = Map String (Set String)

-- åˆ›å»ºå¯è¾¾å…³ç³»
newAccessibility :: AccessibilityRelation
newAccessibility = Map.empty

-- æ·»åŠ å¯è¾¾å…³ç³»
addRelation :: String -> String -> AccessibilityRelation -> AccessibilityRelation
addRelation from to relation = Map.insertWith Set.union from (Set.singleton to) relation

-- æ£€æŸ¥æ˜¯å¦å¯è¾¾
isAccessible :: String -> String -> AccessibilityRelation -> Bool
isAccessible from to relation = case Map.lookup from relation of
    Just targets -> Set.member to targets
    Nothing -> False

-- è·å–å¯è¾¾ä¸–ç•Œ
getAccessibleWorlds :: String -> AccessibilityRelation -> Set String
getAccessibleWorlds from relation = Map.findWithDefault Set.empty from relation

-- æ¨¡æ€æ¨¡å‹
data ModalModel = ModalModel
    { worlds :: Map String PossibleWorld
    , accessibility :: AccessibilityRelation
    } deriving (Show)

-- åˆ›å»ºæ¨¡æ€æ¨¡å‹
newModalModel :: ModalModel
newModalModel = ModalModel Map.empty newAccessibility

-- æ·»åŠ ä¸–ç•Œ
addWorld :: PossibleWorld -> ModalModel -> ModalModel
addWorld world model = model { worlds = Map.insert (worldId world) world (worlds model) }

-- æ·»åŠ å¯è¾¾å…³ç³»
addAccessibility :: String -> String -> ModalModel -> ModalModel
addAccessibility from to model = model 
    { accessibility = addRelation from to (accessibility model) }

-- è¯„ä¼°æ¨¡æ€å…¬å¼
evaluate :: ModalFormula -> String -> ModalModel -> Bool
evaluate formula worldId model = case formula of
    Atom prop -> case Map.lookup worldId (worlds model) of
        Just world -> satisfies prop world
        Nothing -> False
    Not f -> not $ evaluate f worldId model
    And f1 f2 -> evaluate f1 worldId model && evaluate f2 worldId model
    Or f1 f2 -> evaluate f1 worldId model || evaluate f2 worldId model
    Implies f1 f2 -> not (evaluate f1 worldId model) || evaluate f2 worldId model
    Modal operator f -> case operator of
        Necessity -> let accessible = getAccessibleWorlds worldId (accessibility model)
                     in all (\w -> evaluate f w model) accessible
        Possibility -> let accessible = getAccessibleWorlds worldId (accessibility model)
                       in any (\w -> evaluate f w model) accessible

-- æ£€æŸ¥å…¬å¼åœ¨æ‰€æœ‰ä¸–ç•Œä¸­æ˜¯å¦ä¸ºçœŸ
isValid :: ModalFormula -> ModalModel -> Bool
isValid formula model = all (\worldId -> evaluate formula worldId model) (Map.keys (worlds model))

-- æ£€æŸ¥å…¬å¼æ˜¯å¦å¯æ»¡è¶³
isSatisfiable :: ModalFormula -> ModalModel -> Bool
isSatisfiable formula model = any (\worldId -> evaluate formula worldId model) (Map.keys (worlds model))

-- æ¨¡æ€é€»è¾‘ç³»ç»Ÿ
data ModalLogicSystem = ModalLogicSystem ModalModel

-- Kå…¬ç†ï¼šâ–¡(Ï†â†’Ïˆ) â†’ (â–¡Ï†â†’â–¡Ïˆ)
kAxiom :: ModalFormula -> ModalFormula -> ModalLogicSystem -> Bool
kAxiom phi psi (ModalLogicSystem model) = isValid kFormula model
  where
    antecedent = Modal Necessity (Implies phi psi)
    consequent = Implies (Modal Necessity phi) (Modal Necessity psi)
    kFormula = Implies antecedent consequent

-- Tå…¬ç†ï¼šâ–¡Ï† â†’ Ï†
tAxiom :: ModalFormula -> ModalLogicSystem -> Bool
tAxiom phi (ModalLogicSystem model) = isValid tFormula model
  where
    tFormula = Implies (Modal Necessity phi) phi

-- 4å…¬ç†ï¼šâ–¡Ï† â†’ â–¡â–¡Ï†
fourAxiom :: ModalFormula -> ModalLogicSystem -> Bool
fourAxiom phi (ModalLogicSystem model) = isValid fourFormula model
  where
    fourFormula = Implies (Modal Necessity phi) (Modal Necessity (Modal Necessity phi))

-- 5å…¬ç†ï¼šâ—‡Ï† â†’ â–¡â—‡Ï†
fiveAxiom :: ModalFormula -> ModalLogicSystem -> Bool
fiveAxiom phi (ModalLogicSystem model) = isValid fiveFormula model
  where
    fiveFormula = Implies (Modal Possibility phi) (Modal Necessity (Modal Possibility phi))

-- ä½¿ç”¨ç¤ºä¾‹
main :: IO ()
main = do
    -- åˆ›å»ºæ¨¡æ€æ¨¡å‹
    let world1 = addProposition "p" (newWorld "w1")
    let world2 = addProposition "q" (newWorld "w2")
    
    let model = addAccessibility "w1" "w2" 
                $ addWorld world2 
                $ addWorld world1 
                $ newModalModel
    
    -- æµ‹è¯•å…¬å¼
    let p = Atom "p"
    let q = Atom "q"
    let necessityP = Modal Necessity p
    let possibilityP = Modal Possibility p
    
    putStrLn $ "påœ¨w1ä¸­ä¸ºçœŸ: " ++ show (evaluate p "w1" model)
    putStrLn $ "påœ¨w2ä¸­ä¸ºçœŸ: " ++ show (evaluate p "w2" model)
    putStrLn $ "â–¡påœ¨w1ä¸­ä¸ºçœŸ: " ++ show (evaluate necessityP "w1" model)
    putStrLn $ "â—‡påœ¨w1ä¸­ä¸ºçœŸ: " ++ show (evaluate possibilityP "w1" model)
    
    -- æµ‹è¯•å…¬ç†
    let system = ModalLogicSystem model
    putStrLn $ "Kå…¬ç†æˆç«‹: " ++ show (kAxiom p q system)
    putStrLn $ "Tå…¬ç†æˆç«‹: " ++ show (tAxiom p system)
```

## 8. åº”ç”¨ç¤ºä¾‹

### 8.1 å“²å­¦ä¸­çš„åº”ç”¨

**ç¤ºä¾‹ 8.1.1** (ä¸Šå¸å­˜åœ¨æ€§)
è®¨è®ºä¸Šå¸å­˜åœ¨çš„æ¨¡æ€è¯æ˜ã€‚

**æ¨¡æ€è®ºè¯**:
1. ä¸Šå¸å­˜åœ¨æ˜¯å¯èƒ½çš„ï¼š$\Diamond \text{GodExists}$
2. å¦‚æœä¸Šå¸å­˜åœ¨ï¼Œé‚£ä¹ˆä¸Šå¸å¿…ç„¶å­˜åœ¨ï¼š$\text{GodExists} \rightarrow \Box \text{GodExists}$
3. å› æ­¤ï¼Œä¸Šå¸å­˜åœ¨ï¼š$\text{GodExists}$

### 8.2 è®¡ç®—æœºç§‘å­¦ä¸­çš„åº”ç”¨

**ç¤ºä¾‹ 8.1.2** (ç¨‹åºéªŒè¯)
ä½¿ç”¨æ¨¡æ€é€»è¾‘éªŒè¯ç¨‹åºæ€§è´¨ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
- å®‰å…¨æ€§ï¼š$\Box \text{Safe}$
- æ´»æ€§ï¼š$\Diamond \text{Terminate}$
- å…¬å¹³æ€§ï¼š$\Box \Diamond \text{Fair}$

### 8.3 äººå·¥æ™ºèƒ½ä¸­çš„åº”ç”¨

**ç¤ºä¾‹ 8.1.3** (çŸ¥è¯†è¡¨ç¤º)
ä½¿ç”¨æ¨¡æ€é€»è¾‘è¡¨ç¤ºæ™ºèƒ½ä½“çš„çŸ¥è¯†ã€‚

**å½¢å¼åŒ–è¡¨ç¤º**:
- çŸ¥é“ï¼š$K_i \phi$ (æ™ºèƒ½ä½“içŸ¥é“Ï†)
- ç›¸ä¿¡ï¼š$B_i \phi$ (æ™ºèƒ½ä½“iç›¸ä¿¡Ï†)
- å¯èƒ½ï¼š$M_i \phi$ (æ™ºèƒ½ä½“iè®¤ä¸ºÏ†å¯èƒ½)

## 9. ç›¸å…³ç†è®º

### 9.1 å½¢è€Œä¸Šå­¦

- [å­˜åœ¨ç†è®º](./01.1.1_Existence_Theory.md)
- [å®ä½“ç†è®º](./01.1.2_Entity_Theory.md)
- [å› æœç†è®º](./01.1.4_Causality_Theory.md)

### 9.2 é€»è¾‘å­¦

- [é€»è¾‘åŸºç¡€](../04_Logic_Philosophy/01.4.1_Logical_Foundation.md)
- [æ¨ç†ç†è®º](../04_Logic_Philosophy/01.4.2_Reasoning_Theory.md)
- [è¯æ˜ç†è®º](../04_Logic_Philosophy/01.4.3_Proof_Theory.md)

### 9.3 æ•°å­¦

- [æ¨¡æ€é€»è¾‘](../02_Logic/02.2.3_Modal_Logic.md)
- [é›†åˆè®ºåŸºç¡€](../02_Mathematical_Foundation/01_Set_Theory/README.md)
- [å‡½æ•°è®ºåŸºç¡€](../02_Mathematical_Foundation/04_Function_Theory/README.md)

## 10. å‚è€ƒæ–‡çŒ®

1. Kripke, S. (1963). "Semantical Considerations on Modal Logic". *Acta Philosophica Fennica*.
2. Hughes, G. E., & Cresswell, M. J. (1996). *A New Introduction to Modal Logic*. Routledge.
3. Blackburn, P., de Rijke, M., & Venema, Y. (2001). *Modal Logic*. Cambridge University Press.
4. Chellas, B. F. (1980). *Modal Logic: An Introduction*. Cambridge University Press.
5. Fitting, M., & Mendelsohn, R. L. (1998). *First-Order Modal Logic*. Kluwer.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ21æ—¥  
**ç»´æŠ¤è€…**: AIåŠ©æ‰‹  
**ç‰ˆæœ¬**: v1.0 