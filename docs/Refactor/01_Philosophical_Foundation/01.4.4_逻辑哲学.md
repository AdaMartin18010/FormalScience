# 01.4.4 é€»è¾‘å“²å­¦

## ğŸ“‹ æ¦‚è¿°

é€»è¾‘å“²å­¦æ˜¯ç ”ç©¶é€»è¾‘çš„æœ¬è´¨ã€åŸºç¡€ã€æ–¹æ³•å’Œåº”ç”¨çš„å“²å­¦åˆ†æ”¯ã€‚å®ƒæ¢è®¨é€»è¾‘ç³»ç»Ÿçš„å“²å­¦åŸºç¡€ï¼ŒåŒ…æ‹¬é€»è¾‘çœŸç†çš„æœ¬è´¨ã€é€»è¾‘æ¨ç†çš„æœ‰æ•ˆæ€§ã€é€»è¾‘ç³»ç»Ÿçš„é€‰æ‹©æ ‡å‡†ç­‰æ ¸å¿ƒé—®é¢˜ã€‚é€»è¾‘å“²å­¦ä¸ºå½¢å¼ç§‘å­¦æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€å’Œæ–¹æ³•è®ºæŒ‡å¯¼ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹é€»è¾‘çš„å“²å­¦åŸºç¡€**ï¼šæ¢è®¨é€»è¾‘çš„æœ¬è´¨å’ŒåŸºç¡€
2. **åˆ†æé€»è¾‘çœŸç†**ï¼šç ”ç©¶é€»è¾‘çœŸç†çš„æ€§è´¨å’Œæ¥æº
3. **ç ”ç©¶é€»è¾‘æ¨ç†**ï¼šåˆ†æé€»è¾‘æ¨ç†çš„æœ‰æ•ˆæ€§å’Œåˆç†æ€§
4. **æ¢è®¨é€»è¾‘å¤šå…ƒä¸»ä¹‰**ï¼šç ”ç©¶ä¸åŒé€»è¾‘ç³»ç»Ÿçš„å“²å­¦æ„ä¹‰
5. **è¿æ¥é€»è¾‘ä¸è®¤çŸ¥**ï¼šæ¢è®¨é€»è¾‘åœ¨è®¤çŸ¥ä¸­çš„ä½œç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 é€»è¾‘çš„æœ¬è´¨

**å®šä¹‰ 1.1.1 (é€»è¾‘ç³»ç»Ÿ)**
é€»è¾‘ç³»ç»Ÿæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $\mathcal{L} = (L, \vdash, \models)$ï¼Œå…¶ä¸­ï¼š

- $L$ æ˜¯è¯­è¨€é›†åˆ
- $\vdash$ æ˜¯è¯­æ³•æ¨å¯¼å…³ç³»
- $\models$ æ˜¯è¯­ä¹‰è•´å«å…³ç³»

**å®šä¹‰ 1.1.2 (é€»è¾‘çœŸç†)**
é€»è¾‘çœŸç†æ˜¯åœ¨æ‰€æœ‰å¯èƒ½ä¸–ç•Œä¸­éƒ½ä¸ºçœŸçš„å‘½é¢˜ã€‚

**å®šä¹‰ 1.1.3 (é€»è¾‘æœ‰æ•ˆæ€§)**
ä¸€ä¸ªæ¨ç†æ˜¯é€»è¾‘æœ‰æ•ˆçš„ï¼Œå½“ä¸”ä»…å½“å‰æä¸ºçœŸæ—¶ç»“è®ºå¿…ç„¶ä¸ºçœŸã€‚

### 1.2 é€»è¾‘å“²å­¦çš„æ ¸å¿ƒé—®é¢˜

1. **é€»è¾‘çœŸç†çš„æœ¬è´¨**ï¼šé€»è¾‘çœŸç†æ˜¯å‘ç°çš„è¿˜æ˜¯å‘æ˜çš„ï¼Ÿ
2. **é€»è¾‘æ¨ç†çš„åŸºç¡€**ï¼šé€»è¾‘æ¨ç†çš„æœ‰æ•ˆæ€§åŸºäºä»€ä¹ˆï¼Ÿ
3. **é€»è¾‘ç³»ç»Ÿçš„é€‰æ‹©**ï¼šå¦‚ä½•é€‰æ‹©é€‚å½“çš„é€»è¾‘ç³»ç»Ÿï¼Ÿ
4. **é€»è¾‘ä¸å®åœ¨çš„å…³ç³»**ï¼šé€»è¾‘æ˜¯å¦åæ˜ å®åœ¨çš„ç»“æ„ï¼Ÿ

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 é€»è¾‘ç³»ç»Ÿå…¬ç†åŒ–

**å…¬ç† 2.1.1 (é€»è¾‘ç³»ç»Ÿå…¬ç†)**
é€»è¾‘ç³»ç»Ÿæ»¡è¶³ä»¥ä¸‹å…¬ç†ï¼š

1. **ä¸€è‡´æ€§**ï¼š$\Gamma \vdash \phi$ ä¸” $\Gamma \vdash \neg\phi$ ä¸èƒ½åŒæ—¶æˆç«‹
2. **å®Œå¤‡æ€§**ï¼šå¦‚æœ $\Gamma \models \phi$ï¼Œåˆ™ $\Gamma \vdash \phi$
3. **å¯é æ€§**ï¼šå¦‚æœ $\Gamma \vdash \phi$ï¼Œåˆ™ $\Gamma \models \phi$

**å®šä¹‰ 2.1.1 (é€»è¾‘æ¡†æ¶)**
é€»è¾‘æ¡†æ¶æ˜¯ä¸€ä¸ªå››å…ƒç»„ $\mathcal{F} = (W, R, V, \models)$ï¼Œå…¶ä¸­ï¼š

- $W$ æ˜¯å¯èƒ½ä¸–ç•Œé›†åˆ
- $R$ æ˜¯å¯è¾¾å…³ç³»
- $V$ æ˜¯èµ‹å€¼å‡½æ•°
- $\models$ æ˜¯æ»¡è¶³å…³ç³»

### 2.2 é€»è¾‘çœŸç†çš„å½¢å¼åŒ–

**å®šä¹‰ 2.2.1 (é€»è¾‘çœŸç†)**
$\phi$ æ˜¯é€»è¾‘çœŸç†ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall \mathcal{M} \forall w \in W_{\mathcal{M}} : \mathcal{M}, w \models \phi$$

**å®šä¹‰ 2.2.2 (é€»è¾‘æœ‰æ•ˆæ€§)**
$\Gamma \models \phi$ å½“ä¸”ä»…å½“ï¼š
$$\forall \mathcal{M} \forall w \in W_{\mathcal{M}} : (\mathcal{M}, w \models \Gamma \Rightarrow \mathcal{M}, w \models \phi)$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 é€»è¾‘çœŸç†çš„å¿…ç„¶æ€§

**å®šç† 3.1.1 (é€»è¾‘çœŸç†å¿…ç„¶æ€§)**
å¦‚æœ $\phi$ æ˜¯é€»è¾‘çœŸç†ï¼Œåˆ™ $\phi$ åœ¨æ‰€æœ‰å¯èƒ½ä¸–ç•Œä¸­éƒ½ä¸ºçœŸã€‚

**è¯æ˜ï¼š**

1. å‡è®¾ $\phi$ æ˜¯é€»è¾‘çœŸç†
2. æ ¹æ®å®šä¹‰ï¼Œ$\forall \mathcal{M} \forall w \in W_{\mathcal{M}} : \mathcal{M}, w \models \phi$
3. å› æ­¤ï¼Œ$\phi$ åœ¨æ‰€æœ‰å¯èƒ½ä¸–ç•Œä¸­éƒ½ä¸ºçœŸ
4. ç»“è®ºï¼šé€»è¾‘çœŸç†å…·æœ‰å¿…ç„¶æ€§

### 3.2 é€»è¾‘æ¨ç†çš„æœ‰æ•ˆæ€§

**å®šç† 3.2.1 (é€»è¾‘æ¨ç†æœ‰æ•ˆæ€§)**
å¦‚æœ $\Gamma \vdash \phi$ ä¸”æ¨ç†è§„åˆ™æ˜¯å¯é çš„ï¼Œåˆ™ $\Gamma \models \phi$ã€‚

**è¯æ˜ï¼š**

1. å‡è®¾ $\Gamma \vdash \phi$
2. æ ¹æ®å¯é æ€§å…¬ç†ï¼Œ$\Gamma \vdash \phi \Rightarrow \Gamma \models \phi$
3. å› æ­¤ï¼Œ$\Gamma \models \phi$
4. ç»“è®ºï¼šé€»è¾‘æ¨ç†æ˜¯æœ‰æ•ˆçš„

### 3.3 é€»è¾‘ç³»ç»Ÿçš„å®Œå¤‡æ€§

**å®šç† 3.3.1 (å“¥å¾·å°”å®Œå¤‡æ€§å®šç†)**
ä¸€é˜¶é€»è¾‘æ˜¯å®Œå¤‡çš„ï¼Œå³ï¼š
$$\Gamma \models \phi \Rightarrow \Gamma \vdash \phi$$

**è¯æ˜ï¼š**
é€šè¿‡æ¨¡å‹æ„é€ å’Œä¸€è‡´æ€§è¯æ˜ï¼š

1. å¦‚æœ $\Gamma \not\vdash \phi$ï¼Œåˆ™ $\Gamma \cup \{\neg\phi\}$ æ˜¯ä¸€è‡´çš„
2. æ ¹æ®ç´§è‡´æ€§å®šç†ï¼Œå­˜åœ¨æ¨¡å‹ $\mathcal{M}$ ä½¿å¾— $\mathcal{M} \models \Gamma \cup \{\neg\phi\}$
3. å› æ­¤ï¼Œ$\mathcal{M} \models \Gamma$ ä½† $\mathcal{M} \not\models \phi$
4. æ‰€ä»¥ï¼Œ$\Gamma \not\models \phi$
5. ç»“è®ºï¼šå®Œå¤‡æ€§æˆç«‹

## 4. ä»£ç å®ç°

### 4.1 é€»è¾‘ç³»ç»Ÿå®ç°

```rust
// é€»è¾‘ç³»ç»Ÿå®ç°
#[derive(Debug, Clone)]
pub struct LogicSystem {
    language: Language,
    syntax_rules: Vec<SyntaxRule>,
    semantic_rules: Vec<SemanticRule>,
}

impl LogicSystem {
    pub fn new() -> Self {
        LogicSystem {
            language: Language::new(),
            syntax_rules: Vec::new(),
            semantic_rules: Vec::new(),
        }
    }
    
    // è¯­æ³•æ¨å¯¼
    pub fn derive(&self, premises: &[Formula], conclusion: &Formula) -> bool {
        let mut context = Context::from_formulas(premises);
        self.apply_syntax_rules(&mut context, conclusion)
    }
    
    // è¯­ä¹‰éªŒè¯
    pub fn validate(&self, premises: &[Formula], conclusion: &Formula) -> bool {
        let mut model = Model::new();
        self.apply_semantic_rules(&mut model, premises, conclusion)
    }
    
    // ä¸€è‡´æ€§æ£€æŸ¥
    pub fn is_consistent(&self, formulas: &[Formula]) -> bool {
        !self.derive(formulas, &Formula::Contradiction)
    }
    
    // å®Œå¤‡æ€§æ£€æŸ¥
    pub fn is_complete(&self) -> bool {
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰è¯­ä¹‰æœ‰æ•ˆçš„æ¨ç†éƒ½èƒ½è¢«è¯­æ³•æ¨å¯¼
        self.check_completeness()
    }
}

// é€»è¾‘çœŸç†æ£€æŸ¥
pub fn is_logical_truth(formula: &Formula) -> bool {
    let mut logic_system = LogicSystem::new();
    logic_system.initialize_standard_logic();
    
    // æ£€æŸ¥åœ¨æ‰€æœ‰æ¨¡å‹ä¸­æ˜¯å¦ä¸ºçœŸ
    logic_system.validate(&[], formula)
}

// é€»è¾‘æœ‰æ•ˆæ€§æ£€æŸ¥
pub fn is_logically_valid(premises: &[Formula], conclusion: &Formula) -> bool {
    let mut logic_system = LogicSystem::new();
    logic_system.initialize_standard_logic();
    
    logic_system.validate(premises, conclusion)
}
```

### 4.2 é€»è¾‘æ¡†æ¶å®ç°

```rust
// é€»è¾‘æ¡†æ¶å®ç°
#[derive(Debug, Clone)]
pub struct LogicalFramework {
    worlds: Vec<World>,
    accessibility_relation: AccessibilityRelation,
    valuation: Valuation,
}

impl LogicalFramework {
    pub fn new() -> Self {
        LogicalFramework {
            worlds: Vec::new(),
            accessibility_relation: AccessibilityRelation::new(),
            valuation: Valuation::new(),
        }
    }
    
    // æ·»åŠ å¯èƒ½ä¸–ç•Œ
    pub fn add_world(&mut self, world: World) {
        self.worlds.push(world);
    }
    
    // è®¾ç½®å¯è¾¾å…³ç³»
    pub fn set_accessibility(&mut self, from: WorldId, to: WorldId) {
        self.accessibility_relation.add(from, to);
    }
    
    // è®¾ç½®èµ‹å€¼
    pub fn set_valuation(&mut self, world: WorldId, proposition: &str, value: bool) {
        self.valuation.set(world, proposition, value);
    }
    
    // æ£€æŸ¥å…¬å¼åœ¨ä¸–ç•Œçš„çœŸå€¼
    pub fn satisfies(&self, world: WorldId, formula: &Formula) -> bool {
        match formula {
            Formula::Proposition(p) => self.valuation.get(world, p),
            Formula::Negation(f) => !self.satisfies(world, f),
            Formula::Conjunction(f1, f2) => {
                self.satisfies(world, f1) && self.satisfies(world, f2)
            },
            Formula::Disjunction(f1, f2) => {
                self.satisfies(world, f1) || self.satisfies(world, f2)
            },
            Formula::Implication(f1, f2) => {
                !self.satisfies(world, f1) || self.satisfies(world, f2)
            },
            Formula::Necessity(f) => {
                self.worlds.iter()
                    .filter(|w| self.accessibility_relation.accessible(world, w.id))
                    .all(|w| self.satisfies(w.id, f))
            },
            Formula::Possibility(f) => {
                self.worlds.iter()
                    .filter(|w| self.accessibility_relation.accessible(world, w.id))
                    .any(|w| self.satisfies(w.id, f))
            },
        }
    }
    
    // æ£€æŸ¥é€»è¾‘çœŸç†
    pub fn is_logical_truth(&self, formula: &Formula) -> bool {
        self.worlds.iter().all(|w| self.satisfies(w.id, formula))
    }
}
```

### 4.3 é€»è¾‘å¤šå…ƒä¸»ä¹‰å®ç°

```rust
// é€»è¾‘å¤šå…ƒä¸»ä¹‰å®ç°
#[derive(Debug, Clone)]
pub enum LogicType {
    Classical,
    Intuitionistic,
    Modal,
    Linear,
    Quantum,
}

#[derive(Debug, Clone)]
pub struct LogicPluralism {
    logics: HashMap<LogicType, LogicSystem>,
    current_logic: LogicType,
}

impl LogicPluralism {
    pub fn new() -> Self {
        let mut logics = HashMap::new();
        logics.insert(LogicType::Classical, LogicSystem::classical());
        logics.insert(LogicType::Intuitionistic, LogicSystem::intuitionistic());
        logics.insert(LogicType::Modal, LogicSystem::modal());
        logics.insert(LogicType::Linear, LogicSystem::linear());
        logics.insert(LogicType::Quantum, LogicSystem::quantum());
        
        LogicPluralism {
            logics,
            current_logic: LogicType::Classical,
        }
    }
    
    // åˆ‡æ¢é€»è¾‘ç³»ç»Ÿ
    pub fn switch_logic(&mut self, logic_type: LogicType) {
        self.current_logic = logic_type;
    }
    
    // åœ¨å½“å‰é€»è¾‘ç³»ç»Ÿä¸­æ¨å¯¼
    pub fn derive(&self, premises: &[Formula], conclusion: &Formula) -> bool {
        if let Some(logic) = self.logics.get(&self.current_logic) {
            logic.derive(premises, conclusion)
        } else {
            false
        }
    }
    
    // æ¯”è¾ƒä¸åŒé€»è¾‘ç³»ç»Ÿçš„ç»“æœ
    pub fn compare_logics(&self, premises: &[Formula], conclusion: &Formula) -> HashMap<LogicType, bool> {
        let mut results = HashMap::new();
        
        for (logic_type, logic) in &self.logics {
            let result = logic.derive(premises, conclusion);
            results.insert(logic_type.clone(), result);
        }
        
        results
    }
    
    // é€‰æ‹©æœ€é€‚åˆçš„é€»è¾‘ç³»ç»Ÿ
    pub fn select_best_logic(&self, context: &LogicContext) -> LogicType {
        // æ ¹æ®ä¸Šä¸‹æ–‡é€‰æ‹©æœ€é€‚åˆçš„é€»è¾‘ç³»ç»Ÿ
        match context {
            LogicContext::Mathematical => LogicType::Classical,
            LogicContext::Constructive => LogicType::Intuitionistic,
            LogicContext::Temporal => LogicType::Modal,
            LogicContext::Resource => LogicType::Linear,
            LogicContext::Quantum => LogicType::Quantum,
        }
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 é€»è¾‘çœŸç†éªŒè¯

```rust
// éªŒè¯é€»è¾‘çœŸç†
fn verify_logical_truths() {
    let mut framework = LogicalFramework::new();
    
    // æ·»åŠ å¯èƒ½ä¸–ç•Œ
    framework.add_world(World::new(1));
    framework.add_world(World::new(2));
    framework.add_world(World::new(3));
    
    // è®¾ç½®èµ‹å€¼
    framework.set_valuation(1, "p", true);
    framework.set_valuation(2, "p", false);
    framework.set_valuation(3, "p", true);
    
    // éªŒè¯æ’ä¸­å¾‹
    let excluded_middle = Formula::Disjunction(
        Box::new(Formula::Proposition("p".to_string())),
        Box::new(Formula::Negation(Box::new(Formula::Proposition("p".to_string())))
    );
    
    assert!(framework.is_logical_truth(&excluded_middle));
    
    // éªŒè¯çŸ›ç›¾å¾‹
    let contradiction = Formula::Negation(Box::new(Formula::Conjunction(
        Box::new(Formula::Proposition("p".to_string())),
        Box::new(Formula::Negation(Box::new(Formula::Proposition("p".to_string())))
    )));
    
    assert!(framework.is_logical_truth(&contradiction));
}
```

### 5.2 é€»è¾‘æ¨ç†éªŒè¯

```rust
// éªŒè¯é€»è¾‘æ¨ç†
fn verify_logical_reasoning() {
    let mut logic_system = LogicSystem::new();
    logic_system.initialize_standard_logic();
    
    // éªŒè¯å‡è¨€æ¨ç†
    let premise1 = Formula::Implication(
        Box::new(Formula::Proposition("p".to_string())),
        Box::new(Formula::Proposition("q".to_string()))
    );
    let premise2 = Formula::Proposition("p".to_string());
    let conclusion = Formula::Proposition("q".to_string());
    
    let premises = vec![premise1, premise2];
    
    assert!(logic_system.derive(&premises, &conclusion));
    assert!(logic_system.validate(&premises, &conclusion));
}
```

### 5.3 é€»è¾‘å¤šå…ƒä¸»ä¹‰åº”ç”¨

```rust
// é€»è¾‘å¤šå…ƒä¸»ä¹‰åº”ç”¨
fn apply_logic_pluralism() {
    let mut pluralism = LogicPluralism::new();
    
    let premise = Formula::Proposition("p".to_string());
    let conclusion = Formula::Proposition("p".to_string());
    
    // åœ¨ç»å…¸é€»è¾‘ä¸­
    pluralism.switch_logic(LogicType::Classical);
    assert!(pluralism.derive(&[premise.clone()], &conclusion));
    
    // åœ¨ç›´è§‰ä¸»ä¹‰é€»è¾‘ä¸­
    pluralism.switch_logic(LogicType::Intuitionistic);
    assert!(pluralism.derive(&[premise.clone()], &conclusion));
    
    // æ¯”è¾ƒä¸åŒé€»è¾‘ç³»ç»Ÿ
    let results = pluralism.compare_logics(&[premise], &conclusion);
    println!("Logic comparison results: {:?}", results);
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸è®¤è¯†è®ºçš„å…³ç³»

é€»è¾‘å“²å­¦ä¸è®¤è¯†è®ºå¯†åˆ‡ç›¸å…³ï¼Œæ¢è®¨é€»è¾‘çŸ¥è¯†çš„åŸºç¡€å’Œæ¥æºï¼š

1. **é€»è¾‘çŸ¥è¯†çš„åŸºç¡€**ï¼šé€»è¾‘çŸ¥è¯†æ˜¯å¦åŸºäºç»éªŒæˆ–ç†æ€§ï¼Ÿ
2. **é€»è¾‘ç›´è§‰**ï¼šé€»è¾‘ç›´è§‰åœ¨é€»è¾‘çŸ¥è¯†ä¸­çš„ä½œç”¨
3. **é€»è¾‘å­¦ä¹ **ï¼šå¦‚ä½•è·å¾—é€»è¾‘çŸ¥è¯†ï¼Ÿ

### 6.2 ä¸å½¢è€Œä¸Šå­¦çš„è”ç³»

é€»è¾‘å“²å­¦ä¸å½¢è€Œä¸Šå­¦çš„å…³ç³»ï¼š

1. **é€»è¾‘å®åœ¨è®º**ï¼šé€»è¾‘çœŸç†æ˜¯å¦å®¢è§‚å­˜åœ¨ï¼Ÿ
2. **é€»è¾‘ç»“æ„**ï¼šé€»è¾‘æ˜¯å¦åæ˜ å®åœ¨çš„ç»“æ„ï¼Ÿ
3. **å¯èƒ½ä¸–ç•Œ**ï¼šå¯èƒ½ä¸–ç•Œçš„æœ¬ä½“è®ºåœ°ä½

### 6.3 ä¸è¯­è¨€å“²å­¦çš„å…³ç³»

é€»è¾‘å“²å­¦ä¸è¯­è¨€å“²å­¦çš„è”ç³»ï¼š

1. **é€»è¾‘å½¢å¼**ï¼šé€»è¾‘å½¢å¼ä¸è¯­è¨€å½¢å¼çš„å…³ç³»
2. **æ„ä¹‰ç†è®º**ï¼šé€»è¾‘åœ¨æ„ä¹‰ç†è®ºä¸­çš„ä½œç”¨
3. **è¯­è¨€æ¸¸æˆ**ï¼šé€»è¾‘ä½œä¸ºè¯­è¨€æ¸¸æˆçš„è§’è‰²

## 7. å‚è€ƒæ–‡çŒ®

1. Quine, W. V. O. (1951). Two dogmas of empiricism. The Philosophical Review, 60(1), 20-43.
2. Kripke, S. A. (1980). Naming and necessity. Harvard University Press.
3. Putnam, H. (1975). The meaning of 'meaning'. Minnesota Studies in the Philosophy of Science, 7, 131-193.
4. Beall, J. C., & Restall, G. (2006). Logical pluralism. Oxford University Press.
5. Priest, G. (2006). In contradiction: A study of the transconsistent. Oxford University Press.
6. Field, H. (2009). What is the normative role of logic? Aristotelian Society Supplementary Volume, 83(1), 251-268.
7. MacFarlane, J. (2004). In what sense (if any) is logic normative for thought? Unpublished manuscript.
8. Russell, B. (1919). Introduction to mathematical philosophy. George Allen & Unwin.
9. Frege, G. (1879). Begriffsschrift: Eine der arithmetischen nachgebildete Formelsprache des reinen Denkens. Halle.
10. Tarski, A. (1936). The concept of logical consequence. In Logic, semantics, metamathematics (pp. 409-420).

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [01.4.1 é€»è¾‘åŸºç¡€](../01_Philosophical_Foundation/01.4.1_é€»è¾‘åŸºç¡€.md)
- [01.4.2 æ¨ç†ç†è®º](../01_Philosophical_Foundation/01.4.2_æ¨ç†ç†è®º.md)
- [01.4.3 è¯æ˜ç†è®º](../01_Philosophical_Foundation/01.4.3_è¯æ˜ç†è®º.md)
- [02.2.1 å‘½é¢˜é€»è¾‘](../02_Mathematical_Foundation/02.2.1_å‘½é¢˜é€»è¾‘.md)
- [02.2.2 è°“è¯é€»è¾‘](../02_Mathematical_Foundation/02.2.2_è°“è¯é€»è¾‘.md)
