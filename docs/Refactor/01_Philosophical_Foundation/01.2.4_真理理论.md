# 01.2.4 çœŸç†ç†è®º

## ğŸ“‹ æ¦‚è¿°

çœŸç†ç†è®ºæ˜¯å“²å­¦çš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶çœŸç†çš„æœ¬è´¨ã€æ ‡å‡†å’Œæ€§è´¨ã€‚çœŸç†ä½œä¸ºè®¤è¯†è®ºå’Œä»·å€¼è®ºçš„åŸºç¡€æ¦‚å¿µï¼Œæ„æˆäº†äººç±»çŸ¥è¯†ä½“ç³»å’Œä»·å€¼åˆ¤æ–­çš„ç»ˆææ ‡å‡†ã€‚ä¸åŒçš„çœŸç†ç†è®ºæä¾›äº†ä¸åŒçš„çœŸç†è§‚ï¼Œå½±å“ç€æˆ‘ä»¬å¯¹çŸ¥è¯†ã€ä¿¡å¿µå’Œä»·å€¼çš„ç†è§£ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **çœŸç†æœ¬è´¨åˆ†æ**: æ¢è®¨çœŸç†çš„æœ¬è´¨å’Œæ€§è´¨
2. **çœŸç†æ ‡å‡†ç ”ç©¶**: åˆ†æçœŸç†çš„ä¸åŒæ ‡å‡†å’Œå®šä¹‰
3. **çœŸç†ç†è®ºæ¯”è¾ƒ**: æ¯”è¾ƒä¸åŒçœŸç†ç†è®ºçš„ä¼˜ç¼ºç‚¹
4. **çœŸç†åº”ç”¨æ¢è®¨**: ç ”ç©¶çœŸç†åœ¨å®è·µä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 çœŸç†çš„å®šä¹‰

**çœŸç†**æ˜¯å‘½é¢˜ä¸äº‹å®æˆ–ç°å®ä¹‹é—´çš„ç¬¦åˆå…³ç³»ï¼Œæ˜¯è®¤è¯†æ­£ç¡®æ€§çš„æ ‡å‡†ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
è®¾ $p$ ä¸ºå‘½é¢˜ï¼Œ$T$ ä¸ºçœŸç†è°“è¯ï¼Œåˆ™ï¼š
$$T(p) \iff p \text{ ä¸ºçœŸ}$$

### 1.2 çœŸç†çš„åŸºæœ¬æ€§è´¨

1. **å®¢è§‚æ€§**: çœŸç†ç‹¬ç«‹äºä¸»è§‚è®¤è¯†
2. **æ™®éæ€§**: çœŸç†å¯¹æ‰€æœ‰ä¸»ä½“éƒ½æœ‰æ•ˆ
3. **æ°¸æ’æ€§**: çœŸç†ä¸éšæ—¶é—´å˜åŒ–
4. **ä¸€è‡´æ€§**: çœŸç†ä¹‹é—´ä¸çŸ›ç›¾

### 1.3 çœŸç†ç†è®ºç±»å‹

#### 1.3.1 ç¬¦åˆè®º (Correspondence Theory)

çœŸç†æ˜¯å‘½é¢˜ä¸äº‹å®çš„ç¬¦åˆå…³ç³»ï¼š
$$T(p) \iff p \text{ ä¸äº‹å®ç¬¦åˆ}$$

#### 1.3.2 èè´¯è®º (Coherence Theory)

çœŸç†æ˜¯ä¿¡å¿µç³»ç»Ÿçš„èè´¯æ€§ï¼š
$$T(p) \iff p \text{ ä¸ä¿¡å¿µç³»ç»Ÿèè´¯}$$

#### 1.3.3 å®ç”¨è®º (Pragmatic Theory)

çœŸç†æ˜¯å®ç”¨çš„æœ‰æ•ˆæ€§ï¼š
$$T(p) \iff p \text{ åœ¨å®è·µä¸­æœ‰æ•ˆ}$$

#### 1.3.4 å†—ä½™è®º (Redundancy Theory)

çœŸç†è°“è¯æ˜¯é€»è¾‘å†—ä½™çš„ï¼š
$$T(p) \iff p$$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 çœŸç†é€»è¾‘åŸºç¡€

**çœŸç†é€»è¾‘è¯­è¨€** $\mathcal{L}_{Truth}$:

$$\mathcal{L}_{Truth} = \mathcal{L}_0 \cup \{T\} \cup \{Tr(\phi) \mid \phi \in \mathcal{L}_{Truth}\}$$

å…¶ä¸­ $T$ æ˜¯çœŸç†è°“è¯ï¼Œ$Tr(\phi)$ è¡¨ç¤º $\phi$ ä¸ºçœŸã€‚

### 2.2 çœŸç†æ¨¡å‹

**çœŸç†æ¨¡å‹** $M = \langle W, R, V, T \rangle$:

- $W$: å¯èƒ½ä¸–ç•Œé›†åˆ
- $R: W \times W$: å¯è¾¾å…³ç³»
- $V: Prop \rightarrow 2^W$: èµ‹å€¼å‡½æ•°
- $T: W \rightarrow 2^{\mathcal{L}_{Truth}}$: çœŸç†å‡½æ•°

### 2.3 çœŸç†è¯­ä¹‰

å¯¹äºä»»æ„ $w \in W$ å’Œå…¬å¼ $\phi$:

$$M, w \models Tr(\phi) \iff \phi \in T(w)$$

### 2.4 çœŸç†å…¬ç†ç³»ç»Ÿ

**Tarskiå…¬ç†ç³»ç»Ÿ**:

1. **T1**: $Tr(\phi) \rightarrow \phi$ (äº‹å®æ€§)
2. **T2**: $\phi \rightarrow Tr(\phi)$ (å®Œå…¨æ€§)
3. **T3**: $Tr(\neg \phi) \leftrightarrow \neg Tr(\phi)$ (å¦å®š)
4. **T4**: $Tr(\phi \land \psi) \leftrightarrow Tr(\phi) \land Tr(\psi)$ (åˆå–)
5. **T5**: $Tr(\phi \lor \psi) \leftrightarrow Tr(\phi) \lor Tr(\psi)$ (æå–)

## 3. å®šç†ä¸è¯æ˜

### 3.1 çœŸç†ä¸€è‡´æ€§å®šç†

**å®šç†**: å¦‚æœ $p$ ä¸ºçœŸï¼Œé‚£ä¹ˆ $\neg p$ ä¸ä¸ºçœŸã€‚

**è¯æ˜**:
1. å‡è®¾ $T(p)$ ä¸” $T(\neg p)$
2. æ ¹æ®çœŸç†å…¬ç† T3: $T(\neg p) \leftrightarrow \neg T(p)$
3. ä» $T(\neg p)$ å¾—åˆ° $\neg T(p)$
4. è¿™ä¸å‡è®¾ $T(p)$ çŸ›ç›¾
5. å› æ­¤ï¼Œå¦‚æœ $T(p)$ï¼Œåˆ™ $\neg T(\neg p)$

### 3.2 çœŸç†ä¼ é€’å®šç†

**å®šç†**: å¦‚æœ $p \rightarrow q$ ä¸ºçœŸä¸” $p$ ä¸ºçœŸï¼Œé‚£ä¹ˆ $q$ ä¸ºçœŸã€‚

**è¯æ˜**:
1. å‡è®¾ $T(p \rightarrow q)$ ä¸” $T(p)$
2. æ ¹æ®çœŸç†å…¬ç† T4: $T(\phi \land \psi) \leftrightarrow T(\phi) \land T(\psi)$
3. åº”ç”¨åˆ†ç¦»è§„åˆ™å¾—åˆ° $T(q)$

### 3.3 çœŸç†åæ€å®šç†

**å®šç†**: å¦‚æœ $p$ ä¸ºçœŸï¼Œé‚£ä¹ˆ "$p$ ä¸ºçœŸ" ä¸ºçœŸã€‚

**è¯æ˜**:
1. å‡è®¾ $T(p)$
2. æ ¹æ®çœŸç†å…¬ç† T2: $\phi \rightarrow T(\phi)$
3. ç›´æ¥å¾—åˆ° $T(T(p))$

### 3.4 çœŸç†æ‚–è®ºåˆ†æ

**è¯´è°è€…æ‚–è®º**: "è¿™å¥è¯æ˜¯å‡çš„"

å½¢å¼åŒ–è¡¨ç¤ºï¼š$L \leftrightarrow \neg T(L)$

**åˆ†æ**:
1. å‡è®¾ $T(L)$
2. æ ¹æ®å®šä¹‰ï¼Œ$L \leftrightarrow \neg T(L)$
3. ä» $T(L)$ å¾—åˆ° $\neg T(L)$
4. çŸ›ç›¾

**è§£å†³æ–¹æ¡ˆ**:
- **å±‚æ¬¡ç†è®º**: å°†çœŸç†åˆ†ä¸ºä¸åŒå±‚æ¬¡
- **ä¿®æ­£ç†è®º**: å…è®¸éƒ¨åˆ†çœŸç†
- **éç»å…¸é€»è¾‘**: ä½¿ç”¨ä¸‰å€¼é€»è¾‘æˆ–å¤šå€¼é€»è¾‘

## 4. ä»£ç å®ç°

### 4.1 çœŸç†é€»è¾‘å®ç° (Rust)

```rust
use std::collections::HashMap;

/// çœŸç†é€»è¾‘ç³»ç»Ÿ
pub struct TruthSystem {
    propositions: HashMap<String, Proposition>,
    truth_values: HashMap<String, TruthValue>,
    truth_theories: Vec<TruthTheory>,
    world_states: Vec<WorldState>,
}

/// çœŸç†å€¼
#[derive(Debug, Clone, PartialEq)]
pub enum TruthValue {
    True,
    False,
    Unknown,
    Paradoxical,
}

/// çœŸç†ç†è®º
#[derive(Debug, Clone)]
pub enum TruthTheory {
    Correspondence, // ç¬¦åˆè®º
    Coherence,      // èè´¯è®º
    Pragmatic,      // å®ç”¨è®º
    Redundancy,     // å†—ä½™è®º
}

/// å‘½é¢˜
#[derive(Debug, Clone, PartialEq)]
pub enum Proposition {
    Atomic(String),
    Not(Box<Proposition>),
    And(Box<Proposition>, Box<Proposition>),
    Or(Box<Proposition>, Box<Proposition>),
    Implies(Box<Proposition>, Box<Proposition>),
    Truth(Box<Proposition>), // çœŸç†è°“è¯
}

/// ä¸–ç•ŒçŠ¶æ€
#[derive(Debug, Clone)]
pub struct WorldState {
    id: String,
    facts: HashMap<String, bool>,
    truth_assignments: HashMap<String, TruthValue>,
}

impl TruthSystem {
    /// åˆ›å»ºæ–°çš„çœŸç†ç³»ç»Ÿ
    pub fn new() -> Self {
        Self {
            propositions: HashMap::new(),
            truth_values: HashMap::new(),
            truth_theories: vec![TruthTheory::Correspondence],
            world_states: Vec::new(),
        }
    }

    /// æ·»åŠ å‘½é¢˜
    pub fn add_proposition(&mut self, name: String, proposition: Proposition) {
        self.propositions.insert(name.clone(), proposition);
    }

    /// è®¾ç½®çœŸç†å€¼
    pub fn set_truth_value(&mut self, proposition: &str, value: TruthValue) {
        self.truth_values.insert(proposition.to_string(), value);
    }

    /// è·å–çœŸç†å€¼
    pub fn get_truth_value(&self, proposition: &str) -> TruthValue {
        self.truth_values.get(proposition).cloned().unwrap_or(TruthValue::Unknown)
    }

    /// ç¬¦åˆè®ºçœŸç†åˆ¤æ–­
    pub fn correspondence_truth(&self, proposition: &Proposition) -> TruthValue {
        match proposition {
            Proposition::Atomic(name) => {
                self.truth_values.get(name).cloned().unwrap_or(TruthValue::Unknown)
            }
            Proposition::Not(p) => {
                match self.correspondence_truth(p) {
                    TruthValue::True => TruthValue::False,
                    TruthValue::False => TruthValue::True,
                    TruthValue::Unknown => TruthValue::Unknown,
                    TruthValue::Paradoxical => TruthValue::Paradoxical,
                }
            }
            Proposition::And(p, q) => {
                let p_val = self.correspondence_truth(p);
                let q_val = self.correspondence_truth(q);
                match (p_val, q_val) {
                    (TruthValue::True, TruthValue::True) => TruthValue::True,
                    (TruthValue::False, _) | (_, TruthValue::False) => TruthValue::False,
                    _ => TruthValue::Unknown,
                }
            }
            Proposition::Or(p, q) => {
                let p_val = self.correspondence_truth(p);
                let q_val = self.correspondence_truth(q);
                match (p_val, q_val) {
                    (TruthValue::True, _) | (_, TruthValue::True) => TruthValue::True,
                    (TruthValue::False, TruthValue::False) => TruthValue::False,
                    _ => TruthValue::Unknown,
                }
            }
            Proposition::Implies(p, q) => {
                let p_val = self.correspondence_truth(p);
                let q_val = self.correspondence_truth(q);
                match (p_val, q_val) {
                    (TruthValue::False, _) | (_, TruthValue::True) => TruthValue::True,
                    (TruthValue::True, TruthValue::False) => TruthValue::False,
                    _ => TruthValue::Unknown,
                }
            }
            Proposition::Truth(p) => {
                let p_val = self.correspondence_truth(p);
                match p_val {
                    TruthValue::True => TruthValue::True,
                    TruthValue::False => TruthValue::False,
                    TruthValue::Unknown => TruthValue::Unknown,
                    TruthValue::Paradoxical => TruthValue::Paradoxical,
                }
            }
        }
    }

    /// èè´¯è®ºçœŸç†åˆ¤æ–­
    pub fn coherence_truth(&self, proposition: &Proposition) -> TruthValue {
        // ç®€åŒ–çš„èè´¯è®ºå®ç°
        // æ£€æŸ¥å‘½é¢˜æ˜¯å¦ä¸ç°æœ‰ä¿¡å¿µç³»ç»Ÿèè´¯
        let mut coherence_score = 0.0;
        let mut total_relations = 0;
        
        for (name, value) in &self.truth_values {
            if let Some(prop) = self.propositions.get(name) {
                if self.check_coherence(proposition, prop) {
                    coherence_score += match value {
                        TruthValue::True => 1.0,
                        TruthValue::False => -1.0,
                        _ => 0.0,
                    };
                    total_relations += 1;
                }
            }
        }
        
        if total_relations == 0 {
            TruthValue::Unknown
        } else if coherence_score > 0.0 {
            TruthValue::True
        } else if coherence_score < 0.0 {
            TruthValue::False
        } else {
            TruthValue::Unknown
        }
    }

    /// æ£€æŸ¥èè´¯æ€§
    fn check_coherence(&self, p1: &Proposition, p2: &Proposition) -> bool {
        // ç®€åŒ–çš„èè´¯æ€§æ£€æŸ¥
        match (p1, p2) {
            (Proposition::Atomic(name1), Proposition::Atomic(name2)) => {
                name1 == name2 || self.are_related(name1, name2)
            }
            _ => false,
        }
    }

    /// æ£€æŸ¥å‘½é¢˜æ˜¯å¦ç›¸å…³
    fn are_related(&self, name1: &str, name2: &str) -> bool {
        // ç®€åŒ–çš„ç›¸å…³æ€§æ£€æŸ¥
        name1.contains(name2) || name2.contains(name1)
    }

    /// å®ç”¨è®ºçœŸç†åˆ¤æ–­
    pub fn pragmatic_truth(&self, proposition: &Proposition) -> TruthValue {
        // ç®€åŒ–çš„å®ç”¨è®ºå®ç°
        // åŸºäºå‘½é¢˜çš„å®ç”¨ä»·å€¼åˆ¤æ–­çœŸç†
        match proposition {
            Proposition::Atomic(name) => {
                if self.is_useful(name) {
                    TruthValue::True
                } else {
                    TruthValue::False
                }
            }
            _ => TruthValue::Unknown,
        }
    }

    /// æ£€æŸ¥å®ç”¨æ€§
    fn is_useful(&self, name: &str) -> bool {
        // ç®€åŒ–çš„å®ç”¨æ€§æ£€æŸ¥
        name.contains("useful") || name.contains("effective") || name.contains("successful")
    }

    /// å†—ä½™è®ºçœŸç†åˆ¤æ–­
    pub fn redundancy_truth(&self, proposition: &Proposition) -> TruthValue {
        match proposition {
            Proposition::Truth(p) => self.correspondence_truth(p),
            _ => self.correspondence_truth(proposition),
        }
    }

    /// æ£€æµ‹çœŸç†æ‚–è®º
    pub fn detect_paradox(&self, proposition: &Proposition) -> bool {
        match proposition {
            Proposition::Truth(p) => {
                // æ£€æŸ¥æ˜¯å¦å½¢æˆè‡ªæŒ‡
                self.contains_self_reference(proposition)
            }
            _ => false,
        }
    }

    /// æ£€æŸ¥è‡ªæŒ‡
    fn contains_self_reference(&self, proposition: &Proposition) -> bool {
        // ç®€åŒ–çš„è‡ªæŒ‡æ£€æµ‹
        match proposition {
            Proposition::Truth(p) => {
                if let Proposition::Truth(_) = **p {
                    true
                } else {
                    self.contains_self_reference(p)
                }
            }
            _ => false,
        }
    }

    /// çœŸç†ç†è®ºæ¯”è¾ƒ
    pub fn compare_theories(&self, proposition: &Proposition) -> HashMap<TruthTheory, TruthValue> {
        let mut results = HashMap::new();
        
        results.insert(TruthTheory::Correspondence, self.correspondence_truth(proposition));
        results.insert(TruthTheory::Coherence, self.coherence_truth(proposition));
        results.insert(TruthTheory::Pragmatic, self.pragmatic_truth(proposition));
        results.insert(TruthTheory::Redundancy, self.redundancy_truth(proposition));
        
        results
    }
}

/// çœŸç†æ¦‚ç‡æ¨¡å‹
pub struct TruthProbabilityModel {
    truth_probabilities: HashMap<String, f64>,
    theory_weights: HashMap<TruthTheory, f64>,
}

impl TruthProbabilityModel {
    /// åˆ›å»ºæ–°çš„çœŸç†æ¦‚ç‡æ¨¡å‹
    pub fn new() -> Self {
        let mut theory_weights = HashMap::new();
        theory_weights.insert(TruthTheory::Correspondence, 0.4);
        theory_weights.insert(TruthTheory::Coherence, 0.3);
        theory_weights.insert(TruthTheory::Pragmatic, 0.2);
        theory_weights.insert(TruthTheory::Redundancy, 0.1);
        
        Self {
            truth_probabilities: HashMap::new(),
            theory_weights,
        }
    }

    /// è®¾ç½®çœŸç†æ¦‚ç‡
    pub fn set_truth_probability(&mut self, proposition: &str, probability: f64) {
        self.truth_probabilities.insert(proposition.to_string(), probability.max(0.0).min(1.0));
    }

    /// è·å–çœŸç†æ¦‚ç‡
    pub fn get_truth_probability(&self, proposition: &str) -> f64 {
        self.truth_probabilities.get(proposition).copied().unwrap_or(0.5)
    }

    /// è®¡ç®—ç»¼åˆçœŸç†æ¦‚ç‡
    pub fn calculate_comprehensive_probability(&self, proposition: &str, system: &TruthSystem) -> f64 {
        let mut total_probability = 0.0;
        let mut total_weight = 0.0;
        
        for (theory, weight) in &self.theory_weights {
            let truth_value = match theory {
                TruthTheory::Correspondence => system.correspondence_truth(&Proposition::Atomic(proposition.to_string())),
                TruthTheory::Coherence => system.coherence_truth(&Proposition::Atomic(proposition.to_string())),
                TruthTheory::Pragmatic => system.pragmatic_truth(&Proposition::Atomic(proposition.to_string())),
                TruthTheory::Redundancy => system.redundancy_truth(&Proposition::Atomic(proposition.to_string())),
            };
            
            let probability = match truth_value {
                TruthValue::True => 1.0,
                TruthValue::False => 0.0,
                TruthValue::Unknown => 0.5,
                TruthValue::Paradoxical => 0.5,
            };
            
            total_probability += probability * weight;
            total_weight += weight;
        }
        
        if total_weight > 0.0 {
            total_probability / total_weight
        } else {
            0.5
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_correspondence_truth() {
        let mut system = TruthSystem::new();
        
        let p = Proposition::Atomic("p".to_string());
        system.add_proposition("p".to_string(), p.clone());
        system.set_truth_value("p", TruthValue::True);
        
        assert_eq!(system.correspondence_truth(&p), TruthValue::True);
        
        let not_p = Proposition::Not(Box::new(p));
        assert_eq!(system.correspondence_truth(&not_p), TruthValue::False);
    }

    #[test]
    fn test_truth_consistency() {
        let mut system = TruthSystem::new();
        
        let p = Proposition::Atomic("p".to_string());
        system.add_proposition("p".to_string(), p.clone());
        system.set_truth_value("p", TruthValue::True);
        system.set_truth_value("not_p", TruthValue::False);
        
        let not_p = Proposition::Not(Box::new(p));
        assert_eq!(system.correspondence_truth(&not_p), TruthValue::False);
    }

    #[test]
    fn test_paradox_detection() {
        let mut system = TruthSystem::new();
        
        // åˆ›å»ºè¯´è°è€…æ‚–è®º
        let liar = Proposition::Truth(Box::new(Proposition::Not(Box::new(
            Proposition::Truth(Box::new(Proposition::Atomic("liar".to_string())))
        ))));
        
        assert!(system.detect_paradox(&liar));
    }

    #[test]
    fn test_theory_comparison() {
        let mut system = TruthSystem::new();
        let p = Proposition::Atomic("useful_proposition".to_string());
        
        let results = system.compare_theories(&p);
        assert!(results.contains_key(&TruthTheory::Correspondence));
        assert!(results.contains_key(&TruthTheory::Coherence));
        assert!(results.contains_key(&TruthTheory::Pragmatic));
        assert!(results.contains_key(&TruthTheory::Redundancy));
    }
}
```

### 4.2 çœŸç†ç½‘ç»œå®ç° (Haskell)

```haskell
module TruthTheory where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set

-- çœŸç†ç½‘ç»œæ•°æ®ç±»å‹
data TruthNetwork = TruthNetwork
    { propositions :: Map String Proposition
    , truthValues :: Map String TruthValue
    , truthTheories :: [TruthTheory]
    , worldStates :: [WorldState]
    }

-- çœŸç†å€¼
data TruthValue
    = True
    | False
    | Unknown
    | Paradoxical
    deriving (Eq, Ord, Show)

-- çœŸç†ç†è®º
data TruthTheory
    = Correspondence
    | Coherence
    | Pragmatic
    | Redundancy
    deriving (Eq, Ord, Show)

-- å‘½é¢˜
data Proposition
    = Atomic String
    | Not Proposition
    | And Proposition Proposition
    | Or Proposition Proposition
    | Implies Proposition Proposition
    | Truth Proposition
    deriving (Eq, Ord, Show)

-- ä¸–ç•ŒçŠ¶æ€
data WorldState = WorldState
    { worldId :: String
    , worldFacts :: Map String Bool
    , worldTruthAssignments :: Map String TruthValue
    }
    deriving (Eq, Ord, Show)

-- åˆ›å»ºç©ºçœŸç†ç½‘ç»œ
emptyTruthNetwork :: TruthNetwork
emptyTruthNetwork = TruthNetwork
    { propositions = Map.empty
    , truthValues = Map.empty
    , truthTheories = [Correspondence, Coherence, Pragmatic, Redundancy]
    , worldStates = []
    }

-- æ·»åŠ å‘½é¢˜
addProposition :: String -> Proposition -> TruthNetwork -> TruthNetwork
addProposition name prop network = network
    { propositions = Map.insert name prop (propositions network)
    }

-- è®¾ç½®çœŸç†å€¼
setTruthValue :: String -> TruthValue -> TruthNetwork -> TruthNetwork
setTruthValue name value network = network
    { truthValues = Map.insert name value (truthValues network)
    }

-- è·å–çœŸç†å€¼
getTruthValue :: String -> TruthNetwork -> TruthValue
getTruthValue name network = Map.findWithDefault Unknown name (truthValues network)

-- ç¬¦åˆè®ºçœŸç†åˆ¤æ–­
correspondenceTruth :: Proposition -> TruthNetwork -> TruthValue
correspondenceTruth prop network = case prop of
    Atomic name -> getTruthValue name network
    Not p -> case correspondenceTruth p network of
        True -> False
        False -> True
        Unknown -> Unknown
        Paradoxical -> Paradoxical
    And p q -> case (correspondenceTruth p network, correspondenceTruth q network) of
        (True, True) -> True
        (False, _) -> False
        (_, False) -> False
        _ -> Unknown
    Or p q -> case (correspondenceTruth p network, correspondenceTruth q network) of
        (True, _) -> True
        (_, True) -> True
        (False, False) -> False
        _ -> Unknown
    Implies p q -> case (correspondenceTruth p network, correspondenceTruth q network) of
        (False, _) -> True
        (_, True) -> True
        (True, False) -> False
        _ -> Unknown
    Truth p -> correspondenceTruth p network

-- èè´¯è®ºçœŸç†åˆ¤æ–­
coherenceTruth :: Proposition -> TruthNetwork -> TruthValue
coherenceTruth prop network = 
    let coherenceScore = calculateCoherenceScore prop network
    in if coherenceScore > 0.0 then True
       else if coherenceScore < 0.0 then False
       else Unknown

-- è®¡ç®—èè´¯æ€§åˆ†æ•°
calculateCoherenceScore :: Proposition -> TruthNetwork -> Double
calculateCoherenceScore prop network = 
    let relations = [(name, value) | (name, value) <- Map.toList (truthValues network)
                                   , checkCoherence prop (propositions network Map.! name)]
        scores = [case value of
                    True -> 1.0
                    False -> -1.0
                    _ -> 0.0 | (_, value) <- relations]
    in if null scores then 0.0 else sum scores / fromIntegral (length scores)

-- æ£€æŸ¥èè´¯æ€§
checkCoherence :: Proposition -> Proposition -> Bool
checkCoherence p1 p2 = case (p1, p2) of
    (Atomic name1, Atomic name2) -> name1 == name2 || areRelated name1 name2
    _ -> False

-- æ£€æŸ¥ç›¸å…³æ€§
areRelated :: String -> String -> Bool
areRelated name1 name2 = name1 `isInfixOf` name2 || name2 `isInfixOf` name1

-- å®ç”¨è®ºçœŸç†åˆ¤æ–­
pragmaticTruth :: Proposition -> TruthNetwork -> TruthValue
pragmaticTruth prop network = case prop of
    Atomic name -> if isUseful name then True else False
    _ -> Unknown

-- æ£€æŸ¥å®ç”¨æ€§
isUseful :: String -> Bool
isUseful name = "useful" `isInfixOf` name || "effective" `isInfixOf` name || "successful" `isInfixOf` name

-- å†—ä½™è®ºçœŸç†åˆ¤æ–­
redundancyTruth :: Proposition -> TruthNetwork -> TruthValue
redundancyTruth prop network = case prop of
    Truth p -> correspondenceTruth p network
    _ -> correspondenceTruth prop network

-- æ£€æµ‹çœŸç†æ‚–è®º
detectParadox :: Proposition -> Bool
detectParadox prop = containsSelfReference prop

-- æ£€æŸ¥è‡ªæŒ‡
containsSelfReference :: Proposition -> Bool
containsSelfReference prop = case prop of
    Truth p -> case p of
        Truth _ -> True
        _ -> containsSelfReference p
    _ -> False

-- çœŸç†ç†è®ºæ¯”è¾ƒ
compareTheories :: Proposition -> TruthNetwork -> Map TruthTheory TruthValue
compareTheories prop network = Map.fromList
    [ (Correspondence, correspondenceTruth prop network)
    , (Coherence, coherenceTruth prop network)
    , (Pragmatic, pragmaticTruth prop network)
    , (Redundancy, redundancyTruth prop network)
    ]

-- çœŸç†ç½‘ç»œåˆ†æ
analyzeTruthNetwork :: TruthNetwork -> TruthNetworkAnalysis
analyzeTruthNetwork network = TruthNetworkAnalysis
    { totalPropositions = Map.size (propositions network)
    , truePropositions = length [() | (_, value) <- Map.toList (truthValues network), value == True]
    , falsePropositions = length [() | (_, value) <- Map.toList (truthValues network), value == False]
    , unknownPropositions = length [() | (_, value) <- Map.toList (truthValues network), value == Unknown]
    , paradoxicalPropositions = length [() | (_, value) <- Map.toList (truthValues network), value == Paradoxical]
    }

data TruthNetworkAnalysis = TruthNetworkAnalysis
    { totalPropositions :: Int
    , truePropositions :: Int
    , falsePropositions :: Int
    , unknownPropositions :: Int
    , paradoxicalPropositions :: Int
    }
    deriving (Eq, Ord, Show)
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç§‘å­¦çœŸç†ç³»ç»Ÿ

```rust
// ç§‘å­¦çœŸç†ç³»ç»Ÿç¤ºä¾‹
fn scientific_truth_system() {
    let mut system = TruthSystem::new();
    
    // æ·»åŠ ç§‘å­¦å‘½é¢˜
    let relativity = Proposition::Atomic("relativity_theory".to_string());
    let quantum = Proposition::Atomic("quantum_mechanics".to_string());
    
    system.add_proposition("relativity_theory".to_string(), relativity.clone());
    system.add_proposition("quantum_mechanics".to_string(), quantum.clone());
    
    // è®¾ç½®çœŸç†å€¼
    system.set_truth_value("relativity_theory", TruthValue::True);
    system.set_truth_value("quantum_mechanics", TruthValue::True);
    
    // æ¯”è¾ƒä¸åŒçœŸç†ç†è®º
    let results = system.compare_theories(&relativity);
    println!("Relativity theory truth values: {:?}", results);
    
    // æ£€æµ‹æ‚–è®º
    let liar = Proposition::Truth(Box::new(Proposition::Not(Box::new(
        Proposition::Truth(Box::new(Proposition::Atomic("liar".to_string())))
    ))));
    
    println!("Liar paradox detected: {}", system.detect_paradox(&liar));
}
```

### 5.2 å¤šç†è®ºçœŸç†ç½‘ç»œ

```haskell
-- å¤šç†è®ºçœŸç†ç½‘ç»œç¤ºä¾‹
multiTheoryTruthExample :: IO ()
multiTheoryTruthExample = do
    let network = emptyTruthNetwork
        network' = addProposition "p" (Atomic "p") network
        network'' = addProposition "q" (Atomic "q") network'
        network''' = setTruthValue "p" True network''
        network'''' = setTruthValue "q" False network'''
        
        p = Atomic "p"
        q = Atomic "q"
        p_and_q = And p q
        
        -- æ¯”è¾ƒä¸åŒç†è®º
        correspondenceResult = correspondenceTruth p_and_q network''''
        coherenceResult = coherenceTruth p_and_q network''''
        pragmaticResult = pragmaticTruth p_and_q network''''
        redundancyResult = redundancyTruth p_and_q network''''
        
        analysis = analyzeTruthNetwork network''''
    
    putStrLn "Multi-Theory Truth Network Analysis:"
    putStrLn $ "Total propositions: " ++ show (totalPropositions analysis)
    putStrLn $ "True propositions: " ++ show (truePropositions analysis)
    putStrLn $ "False propositions: " ++ show (falsePropositions analysis)
    putStrLn $ "Unknown propositions: " ++ show (unknownPropositions analysis)
    putStrLn $ "Paradoxical propositions: " ++ show (paradoxicalPropositions analysis)
    putStrLn $ "Correspondence result: " ++ show correspondenceResult
    putStrLn $ "Coherence result: " ++ show coherenceResult
    putStrLn $ "Pragmatic result: " ++ show pragmaticResult
    putStrLn $ "Redundancy result: " ++ show redundancyResult
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸ä¿¡å¿µç†è®ºçš„å…³ç³»

çœŸç†æ˜¯ä¿¡å¿µçš„ç›®æ ‡å’Œæ ‡å‡†ï¼š
- **çœŸä¿¡å¿µ**: ä¸äº‹å®ç¬¦åˆçš„ä¿¡å¿µ
- **å‡ä¿¡å¿µ**: ä¸äº‹å®ä¸ç¬¦åˆçš„ä¿¡å¿µ
- **çœŸç†è¿½æ±‚**: ä¿¡å¿µç³»ç»Ÿçš„ç›®æ ‡

### 6.2 ä¸ç¡®è¯ç†è®ºçš„å…³ç³»

çœŸç†ä¸ç¡®è¯çš„å…³ç³»ï¼š
- **ç¡®è¯ä¸çœŸç†**: ç¡®è¯ä¸ä¿è¯çœŸç†
- **çœŸç†ä¸ç¡®è¯**: çœŸç†éœ€è¦ç¡®è¯
- **çœŸç†æ ‡å‡†**: ç¡®è¯çš„æ ‡å‡†é—®é¢˜

### 6.3 ä¸çŸ¥è¯†ç†è®ºçš„å…³ç³»

çœŸç†æ˜¯çŸ¥è¯†çš„å¿…è¦æ¡ä»¶ï¼š
- **çŸ¥è¯†å®šä¹‰**: ç¡®è¯çš„çœŸä¿¡å¿µ
- **çœŸç†æ¡ä»¶**: çŸ¥è¯†å¿…é¡»ä¸ºçœŸ
- **çœŸç†æ ‡å‡†**: çŸ¥è¯†çš„çœŸç†æ€§æ ‡å‡†

## 7. å‚è€ƒæ–‡çŒ®

1. **Armstrong, D. M.** (2004). *Truth and Truthmakers*. Cambridge University Press.
2. **Davidson, D.** (1984). *Inquiries into Truth and Interpretation*. Oxford University Press.
3. **Dummett, M.** (1978). *Truth and Other Enigmas*. Harvard University Press.
4. **James, W.** (1907). *Pragmatism: A New Name for Some Old Ways of Thinking*. Longmans, Green.
5. **Quine, W. V. O.** (1990). *Pursuit of Truth*. Harvard University Press.
6. **Ramsey, F. P.** (1927). "Facts and Propositions". *Proceedings of the Aristotelian Society*.
7. **Tarski, A.** (1944). "The Semantic Conception of Truth". *Philosophy and Phenomenological Research*.

---

**ç›¸å…³æ–‡æ¡£**:
- [01.2.1 çŸ¥è¯†ç†è®º](../01.2.1_çŸ¥è¯†ç†è®º.md)
- [01.2.2 ä¿¡å¿µç†è®º](../01.2.2_ä¿¡å¿µç†è®º.md)
- [01.2.3 ç¡®è¯ç†è®º](../01.2.3_ç¡®è¯ç†è®º.md)
- [01.4.1 é€»è¾‘åŸºç¡€](../01.4.1_é€»è¾‘åŸºç¡€.md) 