# 01-分布式系统基础 (Distributed Systems Foundation)

## 目录

1. [分布式系统模型](#1-分布式系统模型)
2. [一致性理论](#2-一致性理论)
3. [容错理论](#3-容错理论)
4. [分布式算法](#4-分布式算法)
5. [共识理论](#5-共识理论)
6. [分布式事务](#6-分布式事务)
7. [形式化证明](#7-形式化证明)
8. [应用与实现](#8-应用与实现)

## 1. 分布式系统模型

### 1.1 系统模型

**定义 1.1.1 (分布式系统)**
分布式系统是一个三元组 $\mathcal{S} = (N, C, M)$，其中：

- $N = \{p_1, p_2, \ldots, p_n\}$ 是进程集合
- $C \subseteq N \times N$ 是通信关系
- $M$ 是消息传递机制

**定义 1.1.2 (异步模型)**
异步分布式系统中：

- 消息传递延迟无界
- 进程执行速度无界
- 时钟不同步

**定义 1.1.3 (同步模型)**
同步分布式系统中：

- 消息传递延迟有界
- 进程执行速度有界
- 时钟同步

### 1.2 故障模型

**定义 1.1.4 (故障类型)**
故障类型包括：

- **崩溃故障**：进程停止响应
- **拜占庭故障**：进程任意行为
- **遗漏故障**：消息丢失或延迟

**定义 1.1.5 (故障假设)**
系统最多有 $f$ 个故障进程，其中 $f < n/2$ 对于拜占庭故障。

**定理 1.1.1 (故障下界)**
拜占庭容错需要至少 $3f+1$ 个进程。

## 2. 一致性理论

### 2.1 一致性定义

**定义 2.1.1 (强一致性)**
强一致性要求所有操作按全局顺序执行。

**定义 2.1.2 (最终一致性)**
最终一致性要求系统最终达到一致状态。

**定义 2.1.3 (因果一致性)**
因果一致性要求因果相关的操作按顺序执行。

**定理 2.1.1 (CAP定理)**
分布式系统最多同时满足一致性、可用性、分区容错性中的两个。

### 2.2 一致性模型

**定义 2.1.4 (线性一致性)**
线性一致性要求操作看起来按全局顺序执行。

**定义 2.1.5 (顺序一致性)**
顺序一致性要求每个进程的操作按程序顺序执行。

**定理 2.1.2 (一致性层次)**
线性一致性 $\Rightarrow$ 顺序一致性 $\Rightarrow$ 因果一致性 $\Rightarrow$ 最终一致性。

## 3. 容错理论

### 3.1 复制理论

**定义 3.1.1 (状态机复制)**
状态机复制要求所有副本按相同顺序执行相同操作。

**定义 3.1.2 (主从复制)**
主从复制中主节点处理写操作，从节点复制数据。

**定义 3.1.3 (多主复制)**
多主复制允许多个节点处理写操作。

**定理 3.1.1 (复制一致性)**
状态机复制保证强一致性。

### 3.2 故障恢复

**定义 3.1.4 (检查点)**
检查点是系统状态的快照。

**定义 3.1.5 (日志恢复)**
日志恢复通过重放操作恢复状态。

**定理 3.1.2 (恢复正确性)**
基于日志的恢复保证状态一致性。

## 4. 分布式算法

### 4.1 领导者选举

**定义 4.1.1 (领导者选举)**
领导者选举算法选择一个进程作为领导者。

**算法 4.1.1 (Bully算法)**

```haskell
-- Bully算法
bullyElection :: [Process] -> Process
bullyElection processes = 
  let candidates = filter isCandidate processes
      highestId = maximum (map processId candidates)
      leader = find (\p -> processId p == highestId) candidates
  in fromJust leader

-- 候选者检查
isCandidate :: Process -> Bool
isCandidate process = 
  process.state == Candidate && process.isAlive
```

**定理 4.1.1 (选举正确性)**
Bully算法在有限时间内选出唯一领导者。

### 4.2 互斥算法

**定义 4.1.2 (分布式互斥)**
分布式互斥确保临界区互斥访问。

**算法 4.1.2 (Lamport算法)**

```haskell
-- Lamport互斥算法
lamportMutex :: Process -> Resource -> Bool
lamportMutex process resource = 
  let request = Request { process = process
                        , timestamp = getTimestamp process
                        , resource = resource }
      responses = broadcastRequest request
      canEnter = all (\r -> r.timestamp > request.timestamp || 
                           (r.timestamp == request.timestamp && 
                            r.processId > process.processId)) responses
  in canEnter
```

**定理 4.1.2 (互斥正确性)**
Lamport算法保证互斥和公平性。

## 5. 共识理论

### 5.1 共识问题

**定义 5.1.1 (共识问题)**
共识问题要求所有进程就一个值达成一致。

**定义 5.1.2 (共识性质)**
共识算法必须满足：

- **一致性**：所有进程决定相同值
- **有效性**：决定的值必须是某个进程提议的
- **终止性**：所有进程最终决定

**定理 5.1.1 (FLP不可能性)**
在异步系统中，即使只有一个崩溃故障，也无法解决共识问题。

### 5.2 Paxos算法

**定义 5.1.3 (Paxos)**
Paxos是一个共识算法，包含提议者、接受者、学习者。

**算法 5.1.1 (Paxos算法)**

```haskell
-- Paxos算法
paxosConsensus :: [Process] -> Value -> Value
paxosConsensus processes proposedValue = 
  let proposers = filter isProposer processes
      acceptors = filter isAcceptor processes
      learners = filter isLearner processes
      
      -- 阶段1：准备
      prepareResponses = map (\p -> prepare p) proposers
      
      -- 阶段2：接受
      acceptResponses = map (\p -> accept p proposedValue) proposers
      
      -- 阶段3：学习
      decidedValue = learn acceptResponses learners
  in decidedValue

-- 准备阶段
prepare :: Proposer -> PrepareResponse
prepare proposer = 
  let proposalNumber = generateProposalNumber proposer
      responses = broadcastPrepare proposalNumber
      majority = hasMajority responses
  in if majority 
     then PrepareResponse { accepted = True, highestAccepted = findHighestAccepted responses }
     else PrepareResponse { accepted = False, highestAccepted = Nothing }
```

**定理 5.1.2 (Paxos正确性)**
Paxos算法在异步系统中保证共识。

## 6. 分布式事务

### 6.1 两阶段提交

**定义 6.1.1 (2PC)**
两阶段提交包含准备阶段和提交阶段。

**算法 6.1.1 (2PC算法)**

```haskell
-- 两阶段提交
twoPhaseCommit :: Transaction -> Bool
twoPhaseCommit transaction = 
  let participants = transaction.participants
      
      -- 阶段1：准备
      prepareResponses = map (\p -> prepare p transaction) participants
      allPrepared = all (\r -> r.status == Prepared) prepareResponses
      
      -- 阶段2：提交或中止
      if allPrepared
      then do
        commitResponses = map (\p -> commit p transaction) participants
        allCommitted = all (\r -> r.status == Committed) commitResponses
        return allCommitted
      else do
        abortResponses = map (\p -> abort p transaction) participants
        return True
```

**定理 6.1.1 (2PC正确性)**
2PC保证事务的原子性。

### 6.2 三阶段提交

**定义 6.1.2 (3PC)**
三阶段提交增加预提交阶段，提高性能。

**定理 6.1.2 (3PC优势)**
3PC在无故障时比2PC更快。

## 7. 形式化证明

### 7.1 安全性证明

**定理 7.1.1 (互斥安全性)**
分布式互斥算法保证安全性：

```haskell
-- 互斥安全性检查
mutualExclusionSafety :: MutexAlgorithm -> Bool
mutualExclusionSafety algorithm = 
  let executions = generateExecutions algorithm
      safetyViolations = filter (\e -> hasConcurrentAccess e) executions
  in null safetyViolations

-- 并发访问检查
hasConcurrentAccess :: Execution -> Bool
hasConcurrentAccess execution = 
  let criticalSections = extractCriticalSections execution
      overlapping = findOverlapping criticalSections
  in not (null overlapping)
```

### 7.2 活性证明

**定理 7.1.2 (共识活性)**
共识算法保证活性：

```haskell
-- 共识活性检查
consensusLiveness :: ConsensusAlgorithm -> Bool
consensusLiveness algorithm = 
  let executions = generateExecutions algorithm
      allDecided = all (\e -> allDecisionsMade e) executions
  in allDecided

-- 决策检查
allDecisionsMade :: Execution -> Bool
allDecisionsMade execution = 
  let processes = execution.processes
      decisions = map (\p -> getDecision p) processes
  in all isJust decisions
```

## 8. 应用与实现

### 8.1 分布式数据库

**应用 8.1.1 (一致性哈希)**
使用一致性哈希进行数据分布：

```haskell
-- 一致性哈希
consistentHashing :: Key -> [Node] -> Node
consistentHashing key nodes = 
  let hashRing = constructHashRing nodes
      keyHash = hash key
      targetNode = findNode hashRing keyHash
  in targetNode

-- 哈希环构造
constructHashRing :: [Node] -> HashRing
constructHashRing nodes = 
  let nodeHashes = map (\n -> (hash n.id, n)) nodes
      sortedHashes = sortBy (\a b -> compare (fst a) (fst b)) nodeHashes
  in HashRing { nodes = sortedHashes }
```

### 8.2 分布式存储

**应用 8.2.1 (复制策略)**
实现数据复制策略：

```haskell
-- 复制策略
replicationStrategy :: Data -> [Node] -> ReplicationPlan
replicationStrategy data nodes = 
  let primary = selectPrimary nodes
      replicas = selectReplicas nodes (replicationFactor data)
      plan = ReplicationPlan { primary = primary
                             , replicas = replicas
                             , strategy = data.strategy }
  in plan

-- 主节点选择
selectPrimary :: [Node] -> Node
selectPrimary nodes = 
  let candidates = filter isHealthy nodes
      primary = maximumBy (\a b -> compare (a.load) (b.load)) candidates
  in primary
```

## 总结

分布式系统基础提供了：

1. **系统模型**：异步和同步系统模型
2. **一致性理论**：强一致性到最终一致性
3. **容错理论**：复制和故障恢复
4. **分布式算法**：选举、互斥、共识
5. **事务处理**：2PC、3PC等协议
6. **形式化证明**：安全性和活性证明
7. **实际应用**：数据库、存储等应用

该理论为分布式系统设计提供了完整的理论基础。
