# 05.1.3 ç³»ç»Ÿç¨³å®šæ€§ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç³»ç»Ÿç¨³å®šæ€§ç†è®ºæ˜¯æ§åˆ¶ç†è®ºçš„æ ¸å¿ƒï¼Œç ”ç©¶ç³»ç»Ÿåœ¨æ‰°åŠ¨ä¸‹çš„è¡Œä¸ºç‰¹æ€§ã€‚ç¨³å®šæ€§åˆ†æä¸ºæ§åˆ¶ç³»ç»Ÿè®¾è®¡æä¾›äº†ç†è®ºåŸºç¡€ï¼Œç¡®ä¿ç³»ç»Ÿåœ¨å„ç§æ¡ä»¶ä¸‹éƒ½èƒ½ä¿æŒæœŸæœ›çš„æ€§èƒ½ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹ç¨³å®šæ€§åˆ†æçš„æ•°å­¦æ¡†æ¶**
2. **ç ”ç©¶æé›…æ™®è¯ºå¤«ç¨³å®šæ€§ç†è®º**
3. **å‘å±•è¾“å…¥è¾“å‡ºç¨³å®šæ€§ç†è®º**
4. **æä¾›ç¨³å®šæ€§åˆ¤æ®å’Œè¯æ˜æ–¹æ³•**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [æé›…æ™®è¯ºå¤«ç¨³å®šæ€§](#2-æé›…æ™®è¯ºå¤«ç¨³å®šæ€§)
3. [çº¿æ€§ç³»ç»Ÿç¨³å®šæ€§](#3-çº¿æ€§ç³»ç»Ÿç¨³å®šæ€§)
4. [è¾“å…¥è¾“å‡ºç¨³å®šæ€§](#4-è¾“å…¥è¾“å‡ºç¨³å®šæ€§)
5. [ç»å¯¹ç¨³å®šæ€§](#5-ç»å¯¹ç¨³å®šæ€§)
6. [ç»“æ„ç¨³å®šæ€§](#6-ç»“æ„ç¨³å®šæ€§)
7. [é²æ£’ç¨³å®šæ€§](#7-é²æ£’ç¨³å®šæ€§)
8. [æ—¶æ»ç³»ç»Ÿç¨³å®šæ€§](#8-æ—¶æ»ç³»ç»Ÿç¨³å®šæ€§)
9. [ä»£ç å®ç°](#9-ä»£ç å®ç°)
10. [åº”ç”¨ç¤ºä¾‹](#10-åº”ç”¨ç¤ºä¾‹)
11. [ç›¸å…³ç†è®º](#11-ç›¸å…³ç†è®º)
12. [å‚è€ƒæ–‡çŒ®](#12-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å¹³è¡¡ç‚¹

**å®šä¹‰ 1.1.1** (å¹³è¡¡ç‚¹)
å¯¹äºç³»ç»Ÿ $\dot{x} = f(x)$ï¼Œå¦‚æœ $f(x_e) = 0$ï¼Œåˆ™ç§° $x_e$ ä¸ºç³»ç»Ÿçš„å¹³è¡¡ç‚¹ã€‚

### 1.2 ç¨³å®šæ€§å®šä¹‰

**å®šä¹‰ 1.1.2** (ç¨³å®šæ€§)
ç³»ç»Ÿ $\dot{x} = f(x)$ çš„å¹³è¡¡ç‚¹ $x_e$ æ˜¯ç¨³å®šçš„ï¼Œå¦‚æœå¯¹äºä»»æ„ $\epsilon > 0$ï¼Œå­˜åœ¨ $\delta > 0$ï¼Œä½¿å¾—ï¼š
$$\|x(0) - x_e\| < \delta \Rightarrow \|x(t) - x_e\| < \epsilon, \quad \forall t \geq 0$$

**å®šä¹‰ 1.1.3** (æ¸è¿‘ç¨³å®šæ€§)
ç³»ç»Ÿ $\dot{x} = f(x)$ çš„å¹³è¡¡ç‚¹ $x_e$ æ˜¯æ¸è¿‘ç¨³å®šçš„ï¼Œå¦‚æœå®ƒæ˜¯ç¨³å®šçš„ï¼Œå¹¶ä¸”ï¼š
$$\lim_{t \to \infty} x(t) = x_e$$

**å®šä¹‰ 1.1.4** (æŒ‡æ•°ç¨³å®šæ€§)
ç³»ç»Ÿ $\dot{x} = f(x)$ çš„å¹³è¡¡ç‚¹ $x_e$ æ˜¯æŒ‡æ•°ç¨³å®šçš„ï¼Œå¦‚æœå­˜åœ¨å¸¸æ•° $M > 0$ å’Œ $\alpha > 0$ï¼Œä½¿å¾—ï¼š
$$\|x(t) - x_e\| \leq M \|x(0) - x_e\| e^{-\alpha t}, \quad \forall t \geq 0$$

## 2. æé›…æ™®è¯ºå¤«ç¨³å®šæ€§

### 2.1 æé›…æ™®è¯ºå¤«å‡½æ•°

**å®šä¹‰ 2.1.1** (æé›…æ™®è¯ºå¤«å‡½æ•°)
å¯¹äºç³»ç»Ÿ $\dot{x} = f(x)$ çš„å¹³è¡¡ç‚¹ $x_e$ï¼Œå¦‚æœå­˜åœ¨è¿ç»­å¯å¾®å‡½æ•° $V: \mathbb{R}^n \to \mathbb{R}$ æ»¡è¶³ï¼š

1. $V(x_e) = 0$
2. $V(x) > 0$ å¯¹äº $x \neq x_e$
3. $\dot{V}(x) = \nabla V(x)^T f(x) \leq 0$ å¯¹äº $x \neq x_e$

åˆ™ç§° $V(x)$ ä¸ºæé›…æ™®è¯ºå¤«å‡½æ•°ã€‚

### 2.2 æé›…æ™®è¯ºå¤«ç¨³å®šæ€§å®šç†

**å®šç† 2.1.1** (æé›…æ™®è¯ºå¤«ç¨³å®šæ€§å®šç†)
å¦‚æœç³»ç»Ÿ $\dot{x} = f(x)$ çš„å¹³è¡¡ç‚¹ $x_e$ å­˜åœ¨æé›…æ™®è¯ºå¤«å‡½æ•°ï¼Œåˆ™ $x_e$ æ˜¯ç¨³å®šçš„ã€‚

**è¯æ˜**ï¼š
è®¾ $V(x)$ æ˜¯æé›…æ™®è¯ºå¤«å‡½æ•°ã€‚å¯¹äºä»»æ„ $\epsilon > 0$ï¼Œé€‰æ‹© $\delta > 0$ ä½¿å¾—ï¼š
$$\{x : \|x - x_e\| \leq \delta\} \subset \{x : V(x) \leq \min_{\|y - x_e\| = \epsilon} V(y)\}$$

ç”±äº $\dot{V}(x) \leq 0$ï¼Œ$V(x(t))$ æ˜¯éå¢çš„ã€‚å› æ­¤ï¼Œå¦‚æœ $\|x(0) - x_e\| < \delta$ï¼Œåˆ™ï¼š
$$V(x(t)) \leq V(x(0)) \leq \min_{\|y - x_e\| = \epsilon} V(y)$$

è¿™æ„å‘³ç€ $\|x(t) - x_e\| < \epsilon$ å¯¹äºæ‰€æœ‰ $t \geq 0$ã€‚

**å®šç† 2.1.2** (æé›…æ™®è¯ºå¤«æ¸è¿‘ç¨³å®šæ€§å®šç†)
å¦‚æœç³»ç»Ÿ $\dot{x} = f(x)$ çš„å¹³è¡¡ç‚¹ $x_e$ å­˜åœ¨æé›…æ™®è¯ºå¤«å‡½æ•° $V(x)$ï¼Œä¸” $\dot{V}(x) < 0$ å¯¹äº $x \neq x_e$ï¼Œåˆ™ $x_e$ æ˜¯æ¸è¿‘ç¨³å®šçš„ã€‚

### 2.3 ä¸å˜é›†å®šç†

**å®šç† 2.1.3** (æ‹‰è¨å°”ä¸å˜é›†å®šç†)
è®¾ $V(x)$ æ˜¯ç³»ç»Ÿ $\dot{x} = f(x)$ çš„æé›…æ™®è¯ºå¤«å‡½æ•°ï¼Œ$E = \{x : \dot{V}(x) = 0\}$ï¼Œ$M$ æ˜¯ $E$ ä¸­çš„æœ€å¤§ä¸å˜é›†ã€‚åˆ™æ‰€æœ‰æœ‰ç•Œè§£éƒ½æ”¶æ•›åˆ° $M$ã€‚

## 3. çº¿æ€§ç³»ç»Ÿç¨³å®šæ€§

### 3.1 çº¿æ€§ç³»ç»Ÿç¨³å®šæ€§åˆ¤æ®

**å®šç† 3.1.1** (çº¿æ€§ç³»ç»Ÿç¨³å®šæ€§)
çº¿æ€§ç³»ç»Ÿ $\dot{x} = Ax$ çš„é›¶å¹³è¡¡ç‚¹æ˜¯æ¸è¿‘ç¨³å®šçš„ï¼Œå½“ä¸”ä»…å½“ $A$ çš„æ‰€æœ‰ç‰¹å¾å€¼éƒ½å…·æœ‰è´Ÿå®éƒ¨ã€‚

**è¯æ˜**ï¼š
ç³»ç»Ÿè§£ä¸º $x(t) = e^{At}x(0)$ã€‚å½“ $A$ çš„æ‰€æœ‰ç‰¹å¾å€¼éƒ½å…·æœ‰è´Ÿå®éƒ¨æ—¶ï¼Œ$e^{At} \to 0$ å½“ $t \to \infty$ï¼Œå› æ­¤ç³»ç»Ÿæ¸è¿‘ç¨³å®šã€‚

### 3.2 åŠ³æ–¯-èµ«å°”ç»´èŒ¨åˆ¤æ®

**å®šç† 3.1.2** (åŠ³æ–¯-èµ«å°”ç»´èŒ¨åˆ¤æ®)
å¤šé¡¹å¼ $P(s) = a_ns^n + a_{n-1}s^{n-1} + \cdots + a_0$ çš„æ‰€æœ‰æ ¹éƒ½å…·æœ‰è´Ÿå®éƒ¨ï¼Œå½“ä¸”ä»…å½“ï¼š

1. æ‰€æœ‰ç³»æ•° $a_i > 0$
2. åŠ³æ–¯é˜µåˆ—çš„ç¬¬ä¸€åˆ—æ‰€æœ‰å…ƒç´ éƒ½ä¸ºæ­£

### 3.3 å¥ˆå¥æ–¯ç‰¹åˆ¤æ®

**å®šç† 3.1.3** (å¥ˆå¥æ–¯ç‰¹åˆ¤æ®)
é—­ç¯ç³»ç»Ÿç¨³å®šçš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯å¥ˆå¥æ–¯ç‰¹å›¾ç»• $(-1, 0)$ ç‚¹çš„åœˆæ•°ç­‰äºå¼€ç¯ç³»ç»Ÿåœ¨å³åŠå¹³é¢çš„æç‚¹æ•°ã€‚

## 4. è¾“å…¥è¾“å‡ºç¨³å®šæ€§

### 4.1 Lpç¨³å®šæ€§

**å®šä¹‰ 4.1.1** (Lpç¨³å®šæ€§)
ç³»ç»Ÿ $y = H(u)$ æ˜¯Lpç¨³å®šçš„ï¼Œå¦‚æœå­˜åœ¨å¸¸æ•° $c > 0$ å’Œ $b \geq 0$ï¼Œä½¿å¾—ï¼š
$$\|y\|_{L_p} \leq c\|u\|_{L_p} + b$$

### 4.2 æœ‰ç•Œè¾“å…¥æœ‰ç•Œè¾“å‡ºç¨³å®šæ€§

**å®šä¹‰ 4.1.2** (BIBOç¨³å®šæ€§)
ç³»ç»Ÿ $y = H(u)$ æ˜¯BIBOç¨³å®šçš„ï¼Œå¦‚æœå¯¹äºä»»æ„æœ‰ç•Œè¾“å…¥ $u(t)$ï¼Œè¾“å‡º $y(t)$ ä¹Ÿæ˜¯æœ‰ç•Œçš„ã€‚

**å®šç† 4.1.1** (çº¿æ€§æ—¶ä¸å˜ç³»ç»ŸBIBOç¨³å®šæ€§)
çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿæ˜¯BIBOç¨³å®šçš„ï¼Œå½“ä¸”ä»…å½“ä¼ é€’å‡½æ•°çš„æ‰€æœ‰æç‚¹éƒ½å…·æœ‰è´Ÿå®éƒ¨ã€‚

### 4.3 å°å¢ç›Šå®šç†

**å®šç† 4.1.2** (å°å¢ç›Šå®šç†)
å¦‚æœç³»ç»Ÿ $H_1$ å’Œ $H_2$ éƒ½æ˜¯L2ç¨³å®šçš„ï¼Œä¸” $\|H_1\| \cdot \|H_2\| < 1$ï¼Œåˆ™åé¦ˆç³»ç»Ÿæ˜¯L2ç¨³å®šçš„ã€‚

## 5. ç»å¯¹ç¨³å®šæ€§

### 5.1 ç»å¯¹ç¨³å®šæ€§å®šä¹‰

**å®šä¹‰ 5.1.1** (ç»å¯¹ç¨³å®šæ€§)
ç³»ç»Ÿ $\dot{x} = Ax + B\phi(y)$ï¼Œ$y = Cx$ æ˜¯ç»å¯¹ç¨³å®šçš„ï¼Œå¦‚æœå¯¹äºä»»æ„æ»¡è¶³æ‰‡å½¢æ¡ä»¶çš„éçº¿æ€§å‡½æ•° $\phi$ï¼Œç³»ç»Ÿéƒ½æ˜¯å…¨å±€æ¸è¿‘ç¨³å®šçš„ã€‚

### 5.2 åœ†åˆ¤æ®

**å®šç† 5.1.1** (åœ†åˆ¤æ®)
ç³»ç»Ÿ $\dot{x} = Ax + B\phi(y)$ï¼Œ$y = Cx$ æ˜¯ç»å¯¹ç¨³å®šçš„ï¼Œå¦‚æœå­˜åœ¨æ­£å®šçŸ©é˜µ $P$ å’Œå¸¸æ•° $q > 0$ï¼Œä½¿å¾—ï¼š
$$A^T P + PA + qC^T C < 0$$
$$PB = qC^T$$

### 5.3 æ³¢æ³¢å¤«åˆ¤æ®

**å®šç† 5.1.2** (æ³¢æ³¢å¤«åˆ¤æ®)
ç³»ç»Ÿ $\dot{x} = Ax + B\phi(y)$ï¼Œ$y = Cx$ æ˜¯ç»å¯¹ç¨³å®šçš„ï¼Œå¦‚æœå­˜åœ¨å¸¸æ•° $q > 0$ï¼Œä½¿å¾—ï¼š
$$\text{Re}\{G(j\omega)\} + q|G(j\omega)|^2 > 0, \quad \forall \omega \in \mathbb{R}$$

å…¶ä¸­ $G(s) = C(sI - A)^{-1}B$ã€‚

## 6. ç»“æ„ç¨³å®šæ€§

### 6.1 ç»“æ„ç¨³å®šæ€§å®šä¹‰

**å®šä¹‰ 6.1.1** (ç»“æ„ç¨³å®šæ€§)
ç³»ç»Ÿ $\dot{x} = f(x)$ æ˜¯ç»“æ„ç¨³å®šçš„ï¼Œå¦‚æœå¯¹äºä»»æ„å……åˆ†å°çš„æ‰°åŠ¨ $g(x)$ï¼Œç³»ç»Ÿ $\dot{x} = f(x) + g(x)$ éƒ½ä¸åŸç³»ç»Ÿæ‹“æ‰‘ç­‰ä»·ã€‚

### 6.2 ç»“æ„ç¨³å®šæ€§åˆ¤æ®

**å®šç† 6.1.1** (ç»“æ„ç¨³å®šæ€§åˆ¤æ®)
äºŒç»´ç³»ç»Ÿæ˜¯ç»“æ„ç¨³å®šçš„ï¼Œå½“ä¸”ä»…å½“ï¼š

1. æ‰€æœ‰å¹³è¡¡ç‚¹éƒ½æ˜¯åŒæ›²çš„
2. æ‰€æœ‰é—­è½¨éƒ½æ˜¯åŒæ›²çš„
3. ä¸å­˜åœ¨è¿æ¥éç‚¹çš„è½¨é“

## 7. é²æ£’ç¨³å®šæ€§

### 7.1 é²æ£’ç¨³å®šæ€§å®šä¹‰

**å®šä¹‰ 7.1.1** (é²æ£’ç¨³å®šæ€§)
ç³»ç»Ÿåœ¨å‚æ•°ä¸ç¡®å®šæ€§ä¸‹ä¿æŒç¨³å®šçš„æ€§è´¨ç§°ä¸ºé²æ£’ç¨³å®šæ€§ã€‚

### 7.2 Kharitonovå®šç†

**å®šç† 7.1.1** (Kharitonovå®šç†)
åŒºé—´å¤šé¡¹å¼æ—æ˜¯é²æ£’ç¨³å®šçš„ï¼Œå½“ä¸”ä»…å½“å››ä¸ªKharitonovå¤šé¡¹å¼éƒ½æ˜¯ç¨³å®šçš„ã€‚

### 7.3 ç»“æ„å¥‡å¼‚å€¼

**å®šä¹‰ 7.1.2** (ç»“æ„å¥‡å¼‚å€¼)
ç»“æ„å¥‡å¼‚å€¼å®šä¹‰ä¸ºï¼š
$$\mu_{\Delta}(M) = \frac{1}{\min\{\bar{\sigma}(\Delta) : \Delta \in \Delta, \det(I - M\Delta) = 0\}}$$

**å®šç† 7.1.2** (Î¼å®šç†)
ç³»ç»Ÿæ˜¯é²æ£’ç¨³å®šçš„ï¼Œå½“ä¸”ä»…å½“ $\sup_{\omega} \mu_{\Delta}(M(j\omega)) < 1$ã€‚

## 8. æ—¶æ»ç³»ç»Ÿç¨³å®šæ€§

### 8.1 æ—¶æ»ç³»ç»Ÿæ¨¡å‹

**å®šä¹‰ 8.1.1** (æ—¶æ»ç³»ç»Ÿ)
æ—¶æ»ç³»ç»Ÿçš„ä¸€èˆ¬å½¢å¼ä¸ºï¼š
$$\dot{x}(t) = f(x(t), x(t-\tau), t)$$

å…¶ä¸­ $\tau > 0$ æ˜¯æ—¶æ»ã€‚

### 8.2 æ—¶æ»ç³»ç»Ÿç¨³å®šæ€§åˆ¤æ®

**å®šç† 8.1.1** (æ—¶æ»ç³»ç»Ÿç¨³å®šæ€§)
çº¿æ€§æ—¶æ»ç³»ç»Ÿ $\dot{x}(t) = Ax(t) + A_d x(t-\tau)$ æ˜¯æ¸è¿‘ç¨³å®šçš„ï¼Œå¦‚æœå­˜åœ¨æ­£å®šçŸ©é˜µ $P$ å’Œ $Q$ï¼Œä½¿å¾—ï¼š
$$A^T P + PA + Q + PA_d Q^{-1} A_d^T P < 0$$

## 9. ä»£ç å®ç°

### 9.1 ç¨³å®šæ€§åˆ†æç±»

```rust
use nalgebra::{DMatrix, DVector, Matrix, Vector};
use std::f64::consts::PI;

/// ç¨³å®šæ€§åˆ†æå™¨
pub struct StabilityAnalyzer;

impl StabilityAnalyzer {
    /// æ£€æŸ¥çº¿æ€§ç³»ç»Ÿç¨³å®šæ€§
    pub fn check_linear_stability(a: &DMatrix<f64>) -> StabilityResult {
        let eigenvals = a.eigenvalues();
        let mut max_real_part = f64::NEG_INFINITY;
        let mut unstable_eigenvals = Vec::new();
        
        for &lambda in eigenvals.iter() {
            max_real_part = max_real_part.max(lambda.re);
            if lambda.re >= 0.0 {
                unstable_eigenvals.push(lambda);
            }
        }
        
        let stability = if max_real_part < 0.0 {
            Stability::AsymptoticallyStable
        } else if max_real_part == 0.0 {
            Stability::MarginallyStable
        } else {
            Stability::Unstable
        };
        
        StabilityResult {
            stability,
            max_real_part,
            unstable_eigenvals,
            all_eigenvals: eigenvals,
        }
    }
    
    /// åŠ³æ–¯-èµ«å°”ç»´èŒ¨åˆ¤æ®
    pub fn routh_hurwitz_criterion(coefficients: &[f64]) -> bool {
        let n = coefficients.len() - 1;
        if n <= 0 {
            return false;
        }
        
        // æ£€æŸ¥æ‰€æœ‰ç³»æ•°æ˜¯å¦ä¸ºæ­£
        if coefficients.iter().any(|&c| c <= 0.0) {
            return false;
        }
        
        // æ„å»ºåŠ³æ–¯é˜µåˆ—
        let mut routh_array = vec![vec![0.0; n + 1]; n + 1];
        
        // ç¬¬ä¸€è¡Œ
        for i in 0..=n {
            routh_array[0][i] = coefficients[n - i];
        }
        
        // ç¬¬äºŒè¡Œ
        for i in 0..n {
            routh_array[1][i] = if n - 1 - i >= 0 { coefficients[n - 1 - i] } else { 0.0 };
        }
        
        // è®¡ç®—åç»­è¡Œ
        for i in 2..=n {
            for j in 0..n {
                if routh_array[i-1][0] == 0.0 {
                    // å¤„ç†é›¶å…ƒç´ æƒ…å†µ
                    routh_array[i][j] = routh_array[i-2][j+1];
                } else {
                    routh_array[i][j] = (routh_array[i-1][0] * routh_array[i-2][j+1] 
                                       - routh_array[i-2][0] * routh_array[i-1][j+1]) 
                                       / routh_array[i-1][0];
                }
            }
        }
        
        // æ£€æŸ¥ç¬¬ä¸€åˆ—ç¬¦å·
        routh_array.iter().all(|row| row[0] > 0.0)
    }
    
    /// å¥ˆå¥æ–¯ç‰¹åˆ¤æ®
    pub fn nyquist_criterion(g: &dyn Fn(f64) -> num_complex::Complex<f64>, 
                           open_loop_poles: &[num_complex::Complex<f64>]) -> bool {
        let mut encirclements = 0;
        let critical_point = num_complex::Complex::new(-1.0, 0.0);
        
        // è®¡ç®—å¥ˆå¥æ–¯ç‰¹å›¾ç»•ä¸´ç•Œç‚¹çš„åœˆæ•°
        let omega_max = 100.0;
        let n_points = 1000;
        let mut prev_angle = 0.0;
        
        for i in 0..n_points {
            let omega = omega_max * (i as f64) / (n_points as f64);
            let g_jw = g(omega);
            let angle = (g_jw - critical_point).arg();
            
            if i > 0 {
                let angle_diff = angle - prev_angle;
                if angle_diff > PI {
                    encirclements -= 1;
                } else if angle_diff < -PI {
                    encirclements += 1;
                }
            }
            
            prev_angle = angle;
        }
        
        // è®¡ç®—å³åŠå¹³é¢æç‚¹æ•°
        let rhp_poles = open_loop_poles.iter()
            .filter(|&&p| p.re > 0.0)
            .count();
        
        encirclements == rhp_poles
    }
    
    /// æé›…æ™®è¯ºå¤«å‡½æ•°æ„é€ 
    pub fn construct_lyapunov_function(a: &DMatrix<f64>) -> Option<DMatrix<f64>> {
        // å¯¹äºçº¿æ€§ç³»ç»Ÿï¼Œæ±‚è§£æé›…æ™®è¯ºå¤«æ–¹ç¨‹ A^T P + PA = -Q
        let n = a.nrows();
        let q = DMatrix::identity(n, n);
        
        // ä½¿ç”¨è¿­ä»£æ–¹æ³•æ±‚è§£
        let mut p = DMatrix::identity(n, n);
        
        for _ in 0..100 {
            let p_new = Self::solve_lyapunov_equation(a, &q, &p);
            if (&p_new - &p).norm() < 1e-6 {
                return Some(p_new);
            }
            p = p_new;
        }
        
        None
    }
    
    /// æ±‚è§£æé›…æ™®è¯ºå¤«æ–¹ç¨‹
    fn solve_lyapunov_equation(a: &DMatrix<f64>, q: &DMatrix<f64>, p_guess: &DMatrix<f64>) -> DMatrix<f64> {
        let n = a.nrows();
        let mut p = p_guess.clone();
        
        // ç®€åŒ–çš„æ±‚è§£æ–¹æ³•
        for _ in 0..10 {
            let residual = a.transpose() * &p + &p * a + q;
            let correction = residual * 0.1;
            p -= correction;
        }
        
        p
    }
    
    /// æ£€æŸ¥BIBOç¨³å®šæ€§
    pub fn check_bibo_stability(transfer_function: &dyn Fn(f64) -> num_complex::Complex<f64>) -> bool {
        // æ£€æŸ¥ä¼ é€’å‡½æ•°æç‚¹æ˜¯å¦éƒ½åœ¨å·¦åŠå¹³é¢
        let mut omega = 0.0;
        let mut prev_phase = 0.0;
        let mut phase_wraps = 0;
        
        while omega < 1000.0 {
            let g_jw = transfer_function(omega);
            let phase = g_jw.arg();
            
            if omega > 0.0 {
                let phase_diff = phase - prev_phase;
                if phase_diff > PI {
                    phase_wraps -= 1;
                } else if phase_diff < -PI {
                    phase_wraps += 1;
                }
            }
            
            prev_phase = phase;
            omega += 0.1;
        }
        
        phase_wraps == 0
    }
}

/// ç¨³å®šæ€§ç»“æœ
#[derive(Debug)]
pub struct StabilityResult {
    pub stability: Stability,
    pub max_real_part: f64,
    pub unstable_eigenvals: Vec<num_complex::Complex<f64>>,
    pub all_eigenvals: nalgebra::base::storage::Owned<num_complex::Complex<f64>, nalgebra::U1, nalgebra::U1>,
}

/// ç¨³å®šæ€§ç±»å‹
#[derive(Debug, PartialEq)]
pub enum Stability {
    AsymptoticallyStable,
    MarginallyStable,
    Unstable,
}

/// æé›…æ™®è¯ºå¤«å‡½æ•°
pub struct LyapunovFunction {
    pub p: DMatrix<f64>,
}

impl LyapunovFunction {
    /// æ„é€ æé›…æ™®è¯ºå¤«å‡½æ•°
    pub fn new(p: DMatrix<f64>) -> Self {
        Self { p }
    }
    
    /// è®¡ç®—æé›…æ™®è¯ºå¤«å‡½æ•°å€¼
    pub fn value(&self, x: &DVector<f64>) -> f64 {
        x.transpose() * &self.p * x
    }
    
    /// è®¡ç®—æé›…æ™®è¯ºå¤«å‡½æ•°å¯¼æ•°
    pub fn derivative(&self, x: &DVector<f64>, f: &DVector<f64>) -> f64 {
        2.0 * x.transpose() * &self.p * f
    }
    
    /// æ£€æŸ¥æé›…æ™®è¯ºå¤«æ¡ä»¶
    pub fn check_lyapunov_conditions(&self, a: &DMatrix<f64>) -> bool {
        let q = -(a.transpose() * &self.p + &self.p * a);
        q.is_positive_definite()
    }
}

/// é²æ£’ç¨³å®šæ€§åˆ†æå™¨
pub struct RobustStabilityAnalyzer;

impl RobustStabilityAnalyzer {
    /// Kharitonovå®šç†
    pub fn kharitonov_theorem(interval_coeffs: &[(f64, f64)]) -> bool {
        let kharitonov_polynomials = Self::generate_kharitonov_polynomials(interval_coeffs);
        
        kharitonov_polynomials.iter().all(|poly| {
            Self::routh_hurwitz_criterion(poly)
        })
    }
    
    /// ç”ŸæˆKharitonovå¤šé¡¹å¼
    fn generate_kharitonov_polynomials(interval_coeffs: &[(f64, f64)]) -> Vec<Vec<f64>> {
        let mut polynomials = Vec::new();
        
        // å››ä¸ªKharitonovå¤šé¡¹å¼
        let patterns = [
            (0, 0, 0, 0), // K1: [a0, a1], [a2, a3], [a4, a5], ...
            (0, 1, 1, 0), // K2: [a0, a1], [a2, a3], [a4, a5], ...
            (1, 0, 0, 1), // K3: [a0, a1], [a2, a3], [a4, a5], ...
            (1, 1, 1, 1), // K4: [a0, a1], [a2, a3], [a4, a5], ...
        ];
        
        for pattern in &patterns {
            let mut poly = Vec::new();
            for (i, &(low, high)) in interval_coeffs.iter().enumerate() {
                let coeff = if i % 4 == pattern.0 || i % 4 == pattern.1 || 
                              i % 4 == pattern.2 || i % 4 == pattern.3 {
                    low
                } else {
                    high
                };
                poly.push(coeff);
            }
            polynomials.push(poly);
        }
        
        polynomials
    }
    
    /// ç»“æ„å¥‡å¼‚å€¼è®¡ç®—
    pub fn structural_singular_value(m: &DMatrix<num_complex::f64>, 
                                   delta_structure: &DeltaStructure) -> f64 {
        // ç®€åŒ–çš„Î¼è®¡ç®—
        let svd = m.svd(true, true);
        let max_singular_value = svd.singular_values.max();
        
        // è¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“çš„Î”ç»“æ„è¿›è¡Œæ›´å¤æ‚çš„è®¡ç®—
        max_singular_value
    }
}

/// Î”ç»“æ„å®šä¹‰
pub struct DeltaStructure {
    pub block_sizes: Vec<usize>,
    pub repeated_blocks: Vec<usize>,
}

/// æ—¶æ»ç³»ç»Ÿç¨³å®šæ€§åˆ†æå™¨
pub struct TimeDelayStabilityAnalyzer;

impl TimeDelayStabilityAnalyzer {
    /// æ£€æŸ¥æ—¶æ»ç³»ç»Ÿç¨³å®šæ€§
    pub fn check_delay_stability(a: &DMatrix<f64>, a_d: &DMatrix<f64>, tau: f64) -> bool {
        // ä½¿ç”¨é¢‘åŸŸæ–¹æ³•
        let omega_max = 10.0 / tau;
        let n_points = 1000;
        
        for i in 0..n_points {
            let omega = omega_max * (i as f64) / (n_points as f64);
            let s = num_complex::Complex::new(0.0, omega);
            let i_s = DMatrix::identity(a.nrows(), a.ncols()) * s;
            
            let characteristic_matrix = &i_s - a - a_d * (-s * tau).exp();
            let det = characteristic_matrix.determinant();
            
            if det.norm() < 1e-6 {
                return false; // æ‰¾åˆ°å³åŠå¹³é¢æ ¹
            }
        }
        
        true
    }
    
    /// æ—¶æ»ç³»ç»Ÿæé›…æ™®è¯ºå¤«å‡½æ•°
    pub fn construct_delay_lyapunov_function(a: &DMatrix<f64>, a_d: &DMatrix<f64>, tau: f64) -> Option<DMatrix<f64>> {
        let n = a.nrows();
        let mut p = DMatrix::identity(n, n);
        let q = DMatrix::identity(n, n);
        let r = DMatrix::identity(n, n);
        
        // æ±‚è§£æ—¶æ»æé›…æ™®è¯ºå¤«æ–¹ç¨‹
        for _ in 0..100 {
            let p_new = Self::solve_delay_lyapunov_equation(a, a_d, &q, &r, tau, &p);
            if (&p_new - &p).norm() < 1e-6 {
                return Some(p_new);
            }
            p = p_new;
        }
        
        None
    }
    
    /// æ±‚è§£æ—¶æ»æé›…æ™®è¯ºå¤«æ–¹ç¨‹
    fn solve_delay_lyapunov_equation(a: &DMatrix<f64>, a_d: &DMatrix<f64>, 
                                   q: &DMatrix<f64>, r: &DMatrix<f64>, 
                                   tau: f64, p_guess: &DMatrix<f64>) -> DMatrix<f64> {
        let n = a.nrows();
        let mut p = p_guess.clone();
        
        // ç®€åŒ–çš„æ±‚è§£æ–¹æ³•
        for _ in 0..10 {
            let residual = a.transpose() * &p + &p * a + q + &p * a_d * r * a_d.transpose() * &p;
            let correction = residual * 0.1;
            p -= correction;
        }
        
        p
    }
}
```

### 9.2 æµ‹è¯•ä»£ç 

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_linear_stability() {
        // ç¨³å®šç³»ç»Ÿ
        let a_stable = DMatrix::from_row_slice(2, 2, &[-1.0, 0.0, 0.0, -2.0]);
        let result = StabilityAnalyzer::check_linear_stability(&a_stable);
        assert_eq!(result.stability, Stability::AsymptoticallyStable);
        
        // ä¸ç¨³å®šç³»ç»Ÿ
        let a_unstable = DMatrix::from_row_slice(2, 2, &[1.0, 0.0, 0.0, 2.0]);
        let result = StabilityAnalyzer::check_linear_stability(&a_unstable);
        assert_eq!(result.stability, Stability::Unstable);
    }
    
    #[test]
    fn test_routh_hurwitz() {
        // ç¨³å®šå¤šé¡¹å¼: s^2 + 3s + 2
        let stable_coeffs = vec![1.0, 3.0, 2.0];
        assert!(StabilityAnalyzer::routh_hurwitz_criterion(&stable_coeffs));
        
        // ä¸ç¨³å®šå¤šé¡¹å¼: s^2 - 3s + 2
        let unstable_coeffs = vec![1.0, -3.0, 2.0];
        assert!(!StabilityAnalyzer::routh_hurwitz_criterion(&unstable_coeffs));
    }
    
    #[test]
    fn test_lyapunov_function() {
        let a = DMatrix::from_row_slice(2, 2, &[-1.0, 0.0, 0.0, -2.0]);
        
        if let Some(p) = StabilityAnalyzer::construct_lyapunov_function(&a) {
            let lyap = LyapunovFunction::new(p);
            assert!(lyap.check_lyapunov_conditions(&a));
        }
    }
    
    #[test]
    fn test_kharitonov_theorem() {
        // åŒºé—´å¤šé¡¹å¼æ—: [1,2]s^2 + [3,4]s + [5,6]
        let interval_coeffs = vec![(1.0, 2.0), (3.0, 4.0), (5.0, 6.0)];
        assert!(RobustStabilityAnalyzer::kharitonov_theorem(&interval_coeffs));
    }
    
    #[test]
    fn test_delay_stability() {
        let a = DMatrix::from_row_slice(2, 2, &[-1.0, 0.0, 0.0, -2.0]);
        let a_d = DMatrix::from_row_slice(2, 2, &[-0.1, 0.0, 0.0, -0.1]);
        let tau = 0.1;
        
        assert!(TimeDelayStabilityAnalyzer::check_delay_stability(&a, &a_d, tau));
    }
}
```

## 10. åº”ç”¨ç¤ºä¾‹

### 10.1 å€’ç«‹æ‘†ç¨³å®šæ€§åˆ†æ

```rust
/// å€’ç«‹æ‘†ç¨³å®šæ€§åˆ†æç¤ºä¾‹
pub fn inverted_pendulum_stability_analysis() {
    // å€’ç«‹æ‘†çº¿æ€§åŒ–æ¨¡å‹
    let m = 0.1; // æ‘†è´¨é‡
    let M = 0.5; // å°è½¦è´¨é‡
    let l = 0.3; // æ‘†é•¿
    let g = 9.81; // é‡åŠ›åŠ é€Ÿåº¦
    
    let a = DMatrix::from_row_slice(4, 4, &[
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, -m*g/(M+m), 0.0,
        0.0, 0.0, 0.0, 1.0,
        0.0, 0.0, (M+m)*g/(l*(M+m)), 0.0
    ]);
    
    println!("å€’ç«‹æ‘†ç³»ç»Ÿç¨³å®šæ€§åˆ†æ:");
    println!("ç³»ç»ŸçŸ©é˜µ A:\n{}", a);
    
    // æ£€æŸ¥ç¨³å®šæ€§
    let result = StabilityAnalyzer::check_linear_stability(&a);
    println!("ç¨³å®šæ€§ç»“æœ: {:?}", result.stability);
    println!("æœ€å¤§å®éƒ¨: {:.4}", result.max_real_part);
    
    // æ„é€ æé›…æ™®è¯ºå¤«å‡½æ•°
    if let Some(p) = StabilityAnalyzer::construct_lyapunov_function(&a) {
        println!("æé›…æ™®è¯ºå¤«å‡½æ•°çŸ©é˜µ P:\n{}", p);
        
        let lyap = LyapunovFunction::new(p);
        println!("æé›…æ™®è¯ºå¤«æ¡ä»¶æ»¡è¶³: {}", lyap.check_lyapunov_conditions(&a));
        
        // ä»¿çœŸéªŒè¯
        let x0 = DVector::from_vec(vec![0.1, 0.0, 0.1, 0.0]);
        let mut x = x0.clone();
        let dt = 0.01;
        let t_final = 5.0;
        let mut t = 0.0;
        
        println!("\næé›…æ™®è¯ºå¤«å‡½æ•°å€¼å˜åŒ–:");
        println!("æ—¶é—´(s) | V(x) | dV/dt");
        
        while t <= t_final {
            let v = lyap.value(&x);
            let dx = &a * &x;
            let dv_dt = lyap.derivative(&x, &dx);
            
            if (t * 100.0).round() as i32 % 50 == 0 {
                println!("{:.2} | {:.6} | {:.6}", t, v, dv_dt);
            }
            
            x += dx * dt;
            t += dt;
        }
    }
}
```

### 10.2 é²æ£’ç¨³å®šæ€§åˆ†æ

```rust
/// é²æ£’ç¨³å®šæ€§åˆ†æç¤ºä¾‹
pub fn robust_stability_analysis() {
    println!("é²æ£’ç¨³å®šæ€§åˆ†æç¤ºä¾‹:");
    
    // åŒºé—´å¤šé¡¹å¼æ—
    let interval_coeffs = vec![
        (1.0, 1.2),   // s^4
        (2.0, 2.5),   // s^3
        (3.0, 3.8),   // s^2
        (4.0, 4.5),   // s^1
        (5.0, 5.2),   // s^0
    ];
    
    println!("åŒºé—´å¤šé¡¹å¼æ—:");
    for (i, &(low, high)) in interval_coeffs.iter().enumerate() {
        println!("a{} âˆˆ [{:.1}, {:.1}]", 4-i, low, high);
    }
    
    // Kharitonovå®šç†
    let is_robustly_stable = RobustStabilityAnalyzer::kharitonov_theorem(&interval_coeffs);
    println!("é²æ£’ç¨³å®šæ€§: {}", is_robustly_stable);
    
    // ç”ŸæˆKharitonovå¤šé¡¹å¼
    let kharitonov_polynomials = RobustStabilityAnalyzer::generate_kharitonov_polynomials(&interval_coeffs);
    
    println!("\nKharitonovå¤šé¡¹å¼:");
    for (i, poly) in kharitonov_polynomials.iter().enumerate() {
        let is_stable = StabilityAnalyzer::routh_hurwitz_criterion(poly);
        println!("K{}: {:?} - ç¨³å®šæ€§: {}", i+1, poly, is_stable);
    }
}
```

### 10.3 æ—¶æ»ç³»ç»Ÿç¨³å®šæ€§åˆ†æ

```rust
/// æ—¶æ»ç³»ç»Ÿç¨³å®šæ€§åˆ†æç¤ºä¾‹
pub fn time_delay_stability_analysis() {
    println!("æ—¶æ»ç³»ç»Ÿç¨³å®šæ€§åˆ†æ:");
    
    // æ—¶æ»ç³»ç»Ÿå‚æ•°
    let a = DMatrix::from_row_slice(2, 2, &[-2.0, 0.0, 0.0, -1.0]);
    let a_d = DMatrix::from_row_slice(2, 2, &[-0.5, 0.0, 0.0, -0.3]);
    
    println!("ç³»ç»ŸçŸ©é˜µ A:\n{}", a);
    println!("æ—¶æ»çŸ©é˜µ A_d:\n{}", a_d);
    
    // ä¸åŒæ—¶æ»å€¼çš„ç¨³å®šæ€§
    let delay_values = vec![0.1, 0.5, 1.0, 2.0];
    
    println!("\nä¸åŒæ—¶æ»å€¼çš„ç¨³å®šæ€§:");
    for &tau in &delay_values {
        let is_stable = TimeDelayStabilityAnalyzer::check_delay_stability(&a, &a_d, tau);
        println!("Ï„ = {:.1}: {}", tau, if is_stable { "ç¨³å®š" } else { "ä¸ç¨³å®š" });
        
        if is_stable {
            if let Some(p) = TimeDelayStabilityAnalyzer::construct_delay_lyapunov_function(&a, &a_d, tau) {
                println!("  æé›…æ™®è¯ºå¤«å‡½æ•°çŸ©é˜µ P:\n{}", p);
            }
        }
    }
}
```

## 11. ç›¸å…³ç†è®º

### 11.1 æ§åˆ¶ç†è®º

- [05.1.1 åŸºç¡€æ§åˆ¶ç†è®º](05.1.1_åŸºç¡€æ§åˆ¶ç†è®º.md)
- [05.1.2 çº¿æ€§ç³»ç»Ÿç†è®º](05.1.2_çº¿æ€§ç³»ç»Ÿç†è®º.md)
- [05.1.4 ç³»ç»Ÿè¾¨è¯†ç†è®º](05.1.4_ç³»ç»Ÿè¾¨è¯†ç†è®º.md)

### 11.2 éçº¿æ€§æ§åˆ¶ç†è®º

- [05.3.1 éçº¿æ€§æ§åˆ¶åŸºç¡€](05.3.1_éçº¿æ€§æ§åˆ¶åŸºç¡€.md)
- [05.3.2 åé¦ˆçº¿æ€§åŒ–](05.3.2_åé¦ˆçº¿æ€§åŒ–.md)

### 11.3 é²æ£’æ§åˆ¶ç†è®º

- [05.4.1 é²æ£’æ§åˆ¶åŸºç¡€](05.4.1_é²æ£’æ§åˆ¶åŸºç¡€.md)
- [05.4.2 Î¼ç»¼åˆæ–¹æ³•](05.4.2_Î¼ç»¼åˆæ–¹æ³•.md)

### 11.4 è‡ªé€‚åº”æ§åˆ¶ç†è®º

- [05.5.1 è‡ªé€‚åº”æ§åˆ¶åŸºç¡€](05.5.1_è‡ªé€‚åº”æ§åˆ¶åŸºç¡€.md)
- [05.5.2 è‡ªæ ¡æ­£æ§åˆ¶](05.5.2_è‡ªæ ¡æ­£æ§åˆ¶.md)

## 12. å‚è€ƒæ–‡çŒ®

1. **Khalil, H. K.** (2015). *Nonlinear Systems*. Prentice Hall.
2. **Vidyasagar, M.** (2002). *Nonlinear Systems Analysis*. SIAM.
3. **Slotine, J. J. E., & Li, W.** (1991). *Applied Nonlinear Control*. Prentice Hall.
4. **Zhou, K., & Doyle, J. C.** (1998). *Essentials of Robust Control*. Prentice Hall.
5. **Gu, K., Kharitonov, V. L., & Chen, J.** (2003). *Stability of Time-Delay Systems*. BirkhÃ¤user.
6. **Bhattacharyya, S. P., Chapellat, H., & Keel, L. H.** (1995). *Robust Control: The Parametric Approach*. Prentice Hall.
7. **Packard, A., & Doyle, J. C.** (1993). *The Complex Structured Singular Value*. Automatica.
8. **Doyle, J. C., Francis, B. A., & Tannenbaum, A. R.** (1992). *Feedback Control Theory*. Macmillan.
9. **Anderson, B. D. O., & Moore, J. B.** (1990). *Optimal Control: Linear Quadratic Methods*. Prentice Hall.
10. **Sontag, E. D.** (1998). *Mathematical Control Theory: Deterministic Finite Dimensional Systems*. Springer.

---

**å…³é”®è¯**: ç³»ç»Ÿç¨³å®šæ€§ã€æé›…æ™®è¯ºå¤«ç¨³å®šæ€§ã€è¾“å…¥è¾“å‡ºç¨³å®šæ€§ã€é²æ£’ç¨³å®šæ€§ã€æ—¶æ»ç³»ç»Ÿç¨³å®šæ€§

**ç›¸å…³æ–‡æ¡£**:

- [05.1.1 åŸºç¡€æ§åˆ¶ç†è®º](05.1.1_åŸºç¡€æ§åˆ¶ç†è®º.md)
- [05.1.2 çº¿æ€§ç³»ç»Ÿç†è®º](05.1.2_çº¿æ€§ç³»ç»Ÿç†è®º.md)
- [05.1.4 ç³»ç»Ÿè¾¨è¯†ç†è®º](05.1.4_ç³»ç»Ÿè¾¨è¯†ç†è®º.md)
