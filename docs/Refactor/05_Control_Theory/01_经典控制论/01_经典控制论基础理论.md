# ç»å…¸æ§åˆ¶è®ºåŸºç¡€ç†è®º (Classical Control Theory Foundation)

## ğŸ¯ **æ¦‚è¿°**

ç»å…¸æ§åˆ¶è®ºæ˜¯æ§åˆ¶ç†è®ºçš„åŸºç¡€ï¼Œä¸»è¦ç ”ç©¶çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿçš„åˆ†æå’Œè®¾è®¡ã€‚æœ¬æ–‡æ¡£æ„å»ºäº†å®Œæ•´çš„ç»å…¸æ§åˆ¶è®ºç†è®ºä½“ç³»ï¼ŒåŒ…æ‹¬ç³»ç»Ÿå»ºæ¨¡ã€ç¨³å®šæ€§åˆ†æã€æ§åˆ¶å™¨è®¾è®¡ç­‰æ ¸å¿ƒå†…å®¹ã€‚

## ğŸ“š **ç›®å½•**

### 1. æ§åˆ¶ç³»ç»ŸåŸºç¡€æ¶æ„
- **1.1** ç³»ç»Ÿåˆ†ç±»ä¸å±‚æ¬¡ç»“æ„
- **1.2** çŠ¶æ€ç©ºé—´è¡¨ç¤º
- **1.3** ä¼ é€’å‡½æ•°è¡¨ç¤º
- **1.4** ç³»ç»Ÿçº¿æ€§åŒ–

### 2. ç¨³å®šæ€§ç†è®º
- **2.1** æé›…æ™®è¯ºå¤«ç¨³å®šæ€§
- **2.2** è¾“å…¥è¾“å‡ºç¨³å®šæ€§
- **2.3** é¢‘åŸŸç¨³å®šæ€§
- **2.4** é²æ£’ç¨³å®šæ€§

### 3. æ§åˆ¶å™¨è®¾è®¡
- **3.1** PIDæ§åˆ¶å™¨
- **3.2** çŠ¶æ€åé¦ˆæ§åˆ¶
- **3.3** è¾“å‡ºåé¦ˆæ§åˆ¶
- **3.4** æœ€ä¼˜æ§åˆ¶

### 4. ç³»ç»Ÿæ€§èƒ½åˆ†æ
- **4.1** æ—¶åŸŸæ€§èƒ½æŒ‡æ ‡
- **4.2** é¢‘åŸŸæ€§èƒ½æŒ‡æ ‡
- **4.3** é²æ£’æ€§èƒ½åˆ†æ
- **4.4** çµæ•åº¦åˆ†æ

### 5. ç³»ç»Ÿè¾¨è¯†ä¸å»ºæ¨¡
- **5.1** å‚æ•°è¾¨è¯†
- **5.2** ç»“æ„è¾¨è¯†
- **5.3** æ¨¡å‹éªŒè¯
- **5.4** æ¨¡å‹ç®€åŒ–

## 1. æ§åˆ¶ç³»ç»ŸåŸºç¡€æ¶æ„

### 1.1 ç³»ç»Ÿåˆ†ç±»ä¸å±‚æ¬¡ç»“æ„

**å®šä¹‰ 1.1 (ç³»ç»Ÿåˆ†ç±»)**
æ§åˆ¶ç³»ç»ŸæŒ‰ç‰¹æ€§åˆ†ç±»ï¼š

1. **çº¿æ€§ç³»ç»Ÿ**ï¼šæ»¡è¶³å åŠ åŸç†
2. **éçº¿æ€§ç³»ç»Ÿ**ï¼šä¸æ»¡è¶³å åŠ åŸç†
3. **æ—¶å˜ç³»ç»Ÿ**ï¼šå‚æ•°éšæ—¶é—´å˜åŒ–
4. **æ—¶ä¸å˜ç³»ç»Ÿ**ï¼šå‚æ•°ä¸éšæ—¶é—´å˜åŒ–
5. **è¿ç»­æ—¶é—´ç³»ç»Ÿ**ï¼šçŠ¶æ€è¿ç»­å˜åŒ–
6. **ç¦»æ•£æ—¶é—´ç³»ç»Ÿ**ï¼šçŠ¶æ€ç¦»æ•£å˜åŒ–

**å®šä¹‰ 1.2 (ç³»ç»Ÿå±‚æ¬¡)**
æ§åˆ¶ç³»ç»ŸæŒ‰å¤æ‚åº¦åˆ†å±‚ï¼š

- **å•è¾“å…¥å•è¾“å‡º(SISO)**ï¼š$\mathbb{R} \rightarrow \mathbb{R}$
- **å¤šè¾“å…¥å¤šè¾“å‡º(MIMO)**ï¼š$\mathbb{R}^m \rightarrow \mathbb{R}^p$
- **åˆ†å¸ƒå¼ç³»ç»Ÿ**ï¼šå¤šä¸ªå­ç³»ç»ŸååŒ
- **ç½‘ç»œåŒ–ç³»ç»Ÿ**ï¼šé€šè¿‡ç½‘ç»œè¿æ¥

**å®šç† 1.1 (ç³»ç»Ÿåˆ†è§£)**
ä»»ä½•å¤æ‚ç³»ç»Ÿéƒ½å¯ä»¥åˆ†è§£ä¸ºåŸºæœ¬å­ç³»ç»Ÿçš„ç»„åˆã€‚

**è¯æ˜ï¼š** é€šè¿‡ç»“æ„åˆ†è§£ï¼š

1. å°†ç³»ç»Ÿåˆ†è§£ä¸ºå¯æ§å’Œä¸å¯æ§éƒ¨åˆ†
2. å°†å¯æ§éƒ¨åˆ†åˆ†è§£ä¸ºå¯è§‚å’Œä¸å¯è§‚éƒ¨åˆ†
3. æ¯ä¸ªéƒ¨åˆ†éƒ½å¯ä»¥ç‹¬ç«‹åˆ†æå’Œè®¾è®¡

**å½¢å¼åŒ–å®ç°ï¼š**

```haskell
data SystemType = 
  Linear | Nonlinear
  | TimeVarying | TimeInvariant
  | Continuous | Discrete
  deriving (Show, Eq)

data SystemComplexity = 
  SISO | MIMO | Distributed | Networked
  deriving (Show, Eq)

data ControlSystem = ControlSystem {
  systemType :: SystemType,
  complexity :: SystemComplexity,
  stateDimension :: Int,
  inputDimension :: Int,
  outputDimension :: Int
} deriving (Show)

-- ç³»ç»Ÿåˆ†è§£
decomposeSystem :: ControlSystem -> [ControlSystem]
decomposeSystem sys = 
  let -- å¯æ§æ€§åˆ†è§£
      (controllable, uncontrollable) = decomposeControllability sys
      -- å¯è§‚æ€§åˆ†è§£
      (observable, unobservable) = decomposeObservability controllable
  in [observable, unobservable, uncontrollable]
```

### 1.2 çŠ¶æ€ç©ºé—´è¡¨ç¤º

**å®šä¹‰ 1.3 (å¹¿ä¹‰çŠ¶æ€ç©ºé—´)**
å¹¿ä¹‰çŠ¶æ€ç©ºé—´è¡¨ç¤ºï¼š
$$\dot{x}(t) = f(x(t), u(t), t)$$
$$y(t) = h(x(t), u(t), t)$$

å…¶ä¸­ $x(t) \in \mathbb{R}^n$, $u(t) \in \mathbb{R}^m$, $y(t) \in \mathbb{R}^p$ã€‚

**å®šä¹‰ 1.4 (çº¿æ€§åŒ–)**
éçº¿æ€§ç³»ç»Ÿåœ¨å¹³è¡¡ç‚¹ $(x_e, u_e)$ é™„è¿‘çš„çº¿æ€§åŒ–ï¼š
$$\delta \dot{x}(t) = A \delta x(t) + B \delta u(t)$$
$$\delta y(t) = C \delta x(t) + D \delta u(t)$$

å…¶ä¸­ï¼š
$$A = \frac{\partial f}{\partial x}\bigg|_{(x_e, u_e)}, \quad B = \frac{\partial f}{\partial u}\bigg|_{(x_e, u_e)}$$
$$C = \frac{\partial h}{\partial x}\bigg|_{(x_e, u_e)}, \quad D = \frac{\partial h}{\partial u}\bigg|_{(x_e, u_e)}$$

**å½¢å¼åŒ–å®ç°ï¼š**

```haskell
data NonlinearSystem = NonlinearSystem {
  stateDimension :: Int,
  inputDimension :: Int,
  outputDimension :: Int,
  stateFunction :: Vector Double -> Vector Double -> Double -> Vector Double,
  outputFunction :: Vector Double -> Vector Double -> Double -> Vector Double
}

data LinearSystem = LinearSystem {
  a :: Matrix Double,
  b :: Matrix Double,
  c :: Matrix Double,
  d :: Matrix Double
} deriving (Show)

-- ç³»ç»Ÿçº¿æ€§åŒ–
linearizeSystem :: NonlinearSystem -> Vector Double -> Vector Double -> LinearSystem
linearizeSystem sys xEquilibrium uEquilibrium = 
  let -- è®¡ç®—é›…å¯æ¯”çŸ©é˜µ
      aMatrix = computeJacobian (stateFunction sys) xEquilibrium uEquilibrium 0.0
      bMatrix = computeJacobian (stateFunction sys) xEquilibrium uEquilibrium 0.0
      cMatrix = computeJacobian (outputFunction sys) xEquilibrium uEquilibrium 0.0
      dMatrix = computeJacobian (outputFunction sys) xEquilibrium uEquilibrium 0.0
  in LinearSystem {
    a = aMatrix,
    b = bMatrix,
    c = cMatrix,
    d = dMatrix
  }

computeJacobian :: (Vector Double -> Vector Double -> Double -> Vector Double) 
                -> Vector Double -> Vector Double -> Double -> Matrix Double
computeJacobian f x u t = 
  let n = length x
      epsilon = 1e-8
      jacobian = matrix n n (\(i, j) -> 
        let xPlus = x + (unitVector n j * epsilon)
            xMinus = x - (unitVector n j * epsilon)
            derivative = (f xPlus u t - f xMinus u t) / (2 * epsilon)
        in derivative `atIndex` i)
  in jacobian
```

### 1.3 ä¼ é€’å‡½æ•°è¡¨ç¤º

**å®šä¹‰ 1.5 (ä¼ é€’å‡½æ•°)**
çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿçš„ä¼ é€’å‡½æ•°ï¼š
$$G(s) = C(sI - A)^{-1}B + D$$

**å®šä¹‰ 1.6 (æç‚¹ä¸é›¶ç‚¹)**
ä¼ é€’å‡½æ•°çš„æç‚¹æ˜¯ $|sI - A| = 0$ çš„è§£ï¼Œé›¶ç‚¹æ˜¯ $|sI - A - BD^{-1}C| = 0$ çš„è§£ã€‚

**å½¢å¼åŒ–å®ç°ï¼š**

```haskell
data TransferFunction = TransferFunction {
  numerator :: [Double],    -- åˆ†å­å¤šé¡¹å¼ç³»æ•°
  denominator :: [Double]   -- åˆ†æ¯å¤šé¡¹å¼ç³»æ•°
} deriving (Show)

-- çŠ¶æ€ç©ºé—´åˆ°ä¼ é€’å‡½æ•°è½¬æ¢
stateSpaceToTransferFunction :: LinearSystem -> TransferFunction
stateSpaceToTransferFunction sys = 
  let -- è®¡ç®—ç‰¹å¾å¤šé¡¹å¼
      charPoly = characteristicPolynomial (a sys)
      -- è®¡ç®—ä¼ é€’å‡½æ•°åˆ†å­
      numPoly = computeNumerator sys
  in TransferFunction {
    numerator = numPoly,
    denominator = charPoly
  }

characteristicPolynomial :: Matrix Double -> [Double]
characteristicPolynomial a = 
  let n = rows a
      -- è®¡ç®—ç‰¹å¾å€¼
      eigenvalues = eigenValues a
      -- æ„é€ ç‰¹å¾å¤šé¡¹å¼
      poly = foldl (\acc lambda -> 
        multiplyPolynomials acc [1, -lambda]) [1] eigenvalues
  in poly

-- æç‚¹è®¡ç®—
computePoles :: TransferFunction -> [Complex Double]
computePoles tf = 
  let -- æ±‚è§£åˆ†æ¯å¤šé¡¹å¼çš„æ ¹
      poles = roots (denominator tf)
  in poles

-- é›¶ç‚¹è®¡ç®—
computeZeros :: TransferFunction -> [Complex Double]
computeZeros tf = 
  let -- æ±‚è§£åˆ†å­å¤šé¡¹å¼çš„æ ¹
      zeros = roots (numerator tf)
  in zeros
```

## 2. ç¨³å®šæ€§ç†è®º

### 2.1 æé›…æ™®è¯ºå¤«ç¨³å®šæ€§

**å®šä¹‰ 2.1 (æé›…æ™®è¯ºå¤«å‡½æ•°)**
å‡½æ•° $V : \mathbb{R}^n \rightarrow \mathbb{R}$ æ˜¯ç³»ç»Ÿ $\dot{x} = f(x)$ çš„æé›…æ™®è¯ºå¤«å‡½æ•°ï¼Œå¦‚æœï¼š

1. $V(0) = 0$
2. $V(x) > 0$ å¯¹äº $x \neq 0$
3. $\dot{V}(x) = \nabla V(x)^T f(x) \leq 0$ å¯¹äº $x \neq 0$

**å®šä¹‰ 2.2 (å…¨å±€æ¸è¿‘ç¨³å®šæ€§)**
å¹³è¡¡ç‚¹ $x_e = 0$ æ˜¯å…¨å±€æ¸è¿‘ç¨³å®šçš„ï¼Œå¦‚æœï¼š

1. å®ƒæ˜¯æé›…æ™®è¯ºå¤«ç¨³å®šçš„
2. $\lim_{t \rightarrow \infty} x(t) = 0$ å¯¹äºæ‰€æœ‰åˆå§‹æ¡ä»¶

**å®šç† 2.1 (å…¨å±€æ¸è¿‘ç¨³å®šæ€§åˆ¤æ®)**
å¦‚æœå­˜åœ¨å¾„å‘æ— ç•Œçš„æé›…æ™®è¯ºå¤«å‡½æ•° $V(x)$ ä½¿å¾— $\dot{V}(x) < 0$ å¯¹äº $x \neq 0$ï¼Œåˆ™å¹³è¡¡ç‚¹æ˜¯å…¨å±€æ¸è¿‘ç¨³å®šçš„ã€‚

**è¯æ˜ï¼š** é€šè¿‡æé›…æ™®è¯ºå¤«ç›´æ¥æ³•ï¼š

1. å¾„å‘æ— ç•Œæ€§ç¡®ä¿æ‰€æœ‰è½¨è¿¹æœ‰ç•Œ
2. $\dot{V}(x) < 0$ ç¡®ä¿ $V(x)$ ä¸¥æ ¼é€’å‡
3. ç»“åˆæé›…æ™®è¯ºå¤«ç¨³å®šæ€§å¾—åˆ°å…¨å±€æ¸è¿‘ç¨³å®šæ€§

**å½¢å¼åŒ–å®ç°ï¼š**

```haskell
data LyapunovFunction = LyapunovFunction {
  function :: Vector Double -> Double,
  gradient :: Vector Double -> Vector Double
}

-- æé›…æ™®è¯ºå¤«å‡½æ•°æ„é€ 
constructLyapunovFunction :: Matrix Double -> LyapunovFunction
constructLyapunovFunction aMatrix = 
  let -- æ±‚è§£æé›…æ™®è¯ºå¤«æ–¹ç¨‹ A^T P + P A = -Q
      qMatrix = identity (rows aMatrix)
      pMatrix = solveLyapunovEquation aMatrix qMatrix
      
      -- æ„é€ äºŒæ¬¡å‹æé›…æ™®è¯ºå¤«å‡½æ•°
      lyapunovFunc x = x `dot` (pMatrix `multiply` x)
      lyapunovGrad x = 2 * (pMatrix `multiply` x)
  in LyapunovFunction {
    function = lyapunovFunc,
    gradient = lyapunovGrad
  }

solveLyapunovEquation :: Matrix Double -> Matrix Double -> Matrix Double
solveLyapunovEquation a q = 
  let n = rows a
      -- å°†æé›…æ™®è¯ºå¤«æ–¹ç¨‹è½¬æ¢ä¸ºçº¿æ€§ç³»ç»Ÿ
      vecP = solve (kroneckerProduct (transpose a) (identity n) + 
                   kroneckerProduct (identity n) a) (vectorize q)
  in reshape n n vecP

-- ç¨³å®šæ€§æ£€æŸ¥
checkStability :: LyapunovFunction -> (Vector Double -> Vector Double) -> Bool
checkStability lyap f = 
  let -- æ£€æŸ¥æé›…æ™®è¯ºå¤«å‡½æ•°æ¡ä»¶
      positiveDefinite = checkPositiveDefinite (function lyap)
      negativeSemiDefinite = checkNegativeSemiDefinite lyap f
  in positiveDefinite && negativeSemiDefinite

checkPositiveDefinite :: (Vector Double -> Double) -> Bool
checkPositiveDefinite v = 
  let -- åœ¨å¤šä¸ªç‚¹ä¸Šæ£€æŸ¥æ­£å®šæ€§
      testPoints = generateTestPoints
      allPositive = all (\x -> v x > 0) testPoints
  in allPositive
```

### 2.2 é¢‘åŸŸç¨³å®šæ€§

**å®šä¹‰ 2.3 (å¥ˆå¥æ–¯ç‰¹ç¨³å®šæ€§åˆ¤æ®)**
é—­ç¯ç³»ç»Ÿç¨³å®šçš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯å¥ˆå¥æ–¯ç‰¹å›¾ä¸åŒ…å›´ç‚¹ $(-1, 0)$ã€‚

**å®šä¹‰ 2.4 (å¢ç›Šè£•åº¦ä¸ç›¸ä½è£•åº¦)**
- **å¢ç›Šè£•åº¦**ï¼š$GM = \frac{1}{|G(j\omega_{180})|}$
- **ç›¸ä½è£•åº¦**ï¼š$PM = 180Â° + \angle G(j\omega_c)$

å…¶ä¸­ $\omega_{180}$ æ˜¯ç›¸ä½ç©¿è¶Šé¢‘ç‡ï¼Œ$\omega_c$ æ˜¯å¢ç›Šç©¿è¶Šé¢‘ç‡ã€‚

**å½¢å¼åŒ–å®ç°ï¼š**

```haskell
data NyquistPlot = NyquistPlot {
  frequencies :: [Double],
  realParts :: [Double],
  imaginaryParts :: [Double]
} deriving (Show)

-- å¥ˆå¥æ–¯ç‰¹å›¾è®¡ç®—
computeNyquistPlot :: TransferFunction -> NyquistPlot
computeNyquistPlot tf = 
  let -- ç”Ÿæˆé¢‘ç‡ç‚¹
      frequencies = generateFrequencies
      -- è®¡ç®—é¢‘ç‡å“åº”
      responses = map (\w -> evaluateTransferFunction tf (0 :+ w)) frequencies
      -- æå–å®éƒ¨å’Œè™šéƒ¨
      realParts = map realPart responses
      imaginaryParts = map imagPart responses
  in NyquistPlot {
    frequencies = frequencies,
    realParts = realParts,
    imaginaryParts = imaginaryParts
  }

-- ç¨³å®šæ€§æ£€æŸ¥
checkNyquistStability :: NyquistPlot -> Bool
checkNyquistStability plot = 
  let -- è®¡ç®—åŒ…å›´æ•°
      encirclements = countEncirclements plot (-1, 0)
  in encirclements == 0

countEncirclements :: NyquistPlot -> (Double, Double) -> Int
countEncirclements plot point = 
  let -- ä½¿ç”¨è§’åº¦å˜åŒ–è®¡ç®—åŒ…å›´æ•°
      angles = computeAngleChanges plot point
      totalChange = sum angles
  in round (totalChange / (2 * pi))

-- å¢ç›Šè£•åº¦å’Œç›¸ä½è£•åº¦è®¡ç®—
computeMargins :: TransferFunction -> (Double, Double)
computeMargins tf = 
  let -- è®¡ç®—å¢ç›Šè£•åº¦
      gainMargin = computeGainMargin tf
      -- è®¡ç®—ç›¸ä½è£•åº¦
      phaseMargin = computePhaseMargin tf
  in (gainMargin, phaseMargin)

computeGainMargin :: TransferFunction -> Double
computeGainMargin tf = 
  let -- æ‰¾åˆ°ç›¸ä½ç©¿è¶Šé¢‘ç‡
      omega180 = findPhaseCrossover tf
      -- è®¡ç®—åœ¨è¯¥é¢‘ç‡çš„å¢ç›Š
      gain = magnitude (evaluateTransferFunction tf (0 :+ omega180))
  in 1 / gain

computePhaseMargin :: TransferFunction -> Double
computePhaseMargin tf = 
  let -- æ‰¾åˆ°å¢ç›Šç©¿è¶Šé¢‘ç‡
      omegaC = findGainCrossover tf
      -- è®¡ç®—åœ¨è¯¥é¢‘ç‡çš„ç›¸ä½
      phase = phase (evaluateTransferFunction tf (0 :+ omegaC))
  in 180 + phase
```

## 3. æ§åˆ¶å™¨è®¾è®¡

### 3.1 PIDæ§åˆ¶å™¨

**å®šä¹‰ 3.1 (PIDæ§åˆ¶å™¨)**
PIDæ§åˆ¶å™¨çš„ä¼ é€’å‡½æ•°ï¼š
$$G_c(s) = K_p + \frac{K_i}{s} + K_d s$$

**å®šä¹‰ 3.2 (PIDå‚æ•°æ•´å®š)**
PIDå‚æ•°æ•´å®šæ–¹æ³•åŒ…æ‹¬Ziegler-Nicholsæ–¹æ³•ã€Cohen-Coonæ–¹æ³•ç­‰ã€‚

**å½¢å¼åŒ–å®ç°ï¼š**

```rust
// Rustå®ç°PIDæ§åˆ¶å™¨
#[derive(Debug, Clone)]
pub struct PIDController {
    kp: f64,  // æ¯”ä¾‹å¢ç›Š
    ki: f64,  // ç§¯åˆ†å¢ç›Š
    kd: f64,  // å¾®åˆ†å¢ç›Š
    setpoint: f64,  // è®¾å®šå€¼
    integral: f64,  // ç§¯åˆ†é¡¹
    previous_error: f64,  // å‰ä¸€æ¬¡è¯¯å·®
    output_min: f64,  // è¾“å‡ºä¸‹é™
    output_max: f64,  // è¾“å‡ºä¸Šé™
}

impl PIDController {
    pub fn new(kp: f64, ki: f64, kd: f64) -> Self {
        PIDController {
            kp,
            ki,
            kd,
            setpoint: 0.0,
            integral: 0.0,
            previous_error: 0.0,
            output_min: f64::NEG_INFINITY,
            output_max: f64::INFINITY,
        }
    }
    
    pub fn set_setpoint(&mut self, setpoint: f64) {
        self.setpoint = setpoint;
    }
    
    pub fn set_output_limits(&mut self, min: f64, max: f64) {
        self.output_min = min;
        self.output_max = max;
    }
    
    pub fn compute(&mut self, measurement: f64, dt: f64) -> f64 {
        // è®¡ç®—è¯¯å·®
        let error = self.setpoint - measurement;
        
        // æ¯”ä¾‹é¡¹
        let proportional = self.kp * error;
        
        // ç§¯åˆ†é¡¹
        self.integral += error * dt;
        let integral = self.ki * self.integral;
        
        // å¾®åˆ†é¡¹
        let derivative = self.kd * (error - self.previous_error) / dt;
        self.previous_error = error;
        
        // è®¡ç®—è¾“å‡º
        let output = proportional + integral + derivative;
        
        // é™åˆ¶è¾“å‡ºèŒƒå›´
        output.clamp(self.output_min, self.output_max)
    }
    
    pub fn reset(&mut self) {
        self.integral = 0.0;
        self.previous_error = 0.0;
    }
}

// Ziegler-Nicholsæ•´å®šæ–¹æ³•
pub fn ziegler_nichols_tuning(ku: f64, tu: f64) -> (f64, f64, f64) {
    let kp = 0.6 * ku;
    let ki = 1.2 * ku / tu;
    let kd = 0.075 * ku * tu;
    
    (kp, ki, kd)
}

// Cohen-Coonæ•´å®šæ–¹æ³•
pub fn cohen_coon_tuning(k: f64, tau: f64, theta: f64) -> (f64, f64, f64) {
    let ratio = theta / tau;
    
    let kp = (1.35 + 0.25 * ratio) / k;
    let ki = (0.54 + 0.33 * ratio) / (k * tau);
    let kd = (0.5 * theta) / k;
    
    (kp, ki, kd)
}
```

### 3.2 çŠ¶æ€åé¦ˆæ§åˆ¶

**å®šä¹‰ 3.3 (çŠ¶æ€åé¦ˆ)**
çŠ¶æ€åé¦ˆæ§åˆ¶å¾‹ï¼š$u(t) = -Kx(t) + r(t)$

**å®šä¹‰ 3.4 (æç‚¹é…ç½®)**
é€šè¿‡é€‰æ‹©åé¦ˆå¢ç›ŠçŸ©é˜µ $K$ æ¥é…ç½®é—­ç¯ç³»ç»Ÿçš„æç‚¹ã€‚

**å½¢å¼åŒ–å®ç°ï¼š**

```haskell
data StateFeedback = StateFeedback {
  gainMatrix :: Matrix Double,
  referenceInput :: Vector Double
} deriving (Show)

-- æç‚¹é…ç½®
polePlacement :: LinearSystem -> [Complex Double] -> Matrix Double
polePlacement sys desiredPoles = 
  let -- æ£€æŸ¥å¯æ§æ€§
      controllable = checkControllability sys
      if not controllable
        then error "System is not controllable"
        else
          -- è®¡ç®—åé¦ˆå¢ç›ŠçŸ©é˜µ
          let a = aMatrix sys
              b = bMatrix sys
              k = computeFeedbackGain a b desiredPoles
          in k

computeFeedbackGain :: Matrix Double -> Matrix Double -> [Complex Double] -> Matrix Double
computeFeedbackGain a b poles = 
  let -- ä½¿ç”¨Ackermannå…¬å¼
      n = rows a
      desiredCharPoly = characteristicPolynomialFromPoles poles
      k = ackermannFormula a b desiredCharPoly
  in k

ackermannFormula :: Matrix Double -> Matrix Double -> [Double] -> Matrix Double
ackermannFormula a b charPoly = 
  let n = rows a
      -- è®¡ç®—å¯æ§æ€§çŸ©é˜µ
      controllabilityMatrix = computeControllabilityMatrix a b
      -- è®¡ç®—ç‰¹å¾å¤šé¡¹å¼ç³»æ•°
      coefficients = reverse charPoly
      -- åº”ç”¨Ackermannå…¬å¼
      k = [0, 0, ..., 1] `multiply` (inverse controllabilityMatrix) `multiply` 
          (foldl (\acc coeff -> acc + coeff `scale` (a `power` (length coefficients - 1 - i))) 
                 (zeroMatrix n n) (zip coefficients [0..]))
  in k
```

## 4. ç³»ç»Ÿæ€§èƒ½åˆ†æ

### 4.1 æ—¶åŸŸæ€§èƒ½æŒ‡æ ‡

**å®šä¹‰ 4.1 (æ—¶åŸŸæ€§èƒ½æŒ‡æ ‡)**
- **ä¸Šå‡æ—¶é—´**ï¼š$t_r$ - å“åº”ä»10%åˆ°90%çš„æ—¶é—´
- **å³°å€¼æ—¶é—´**ï¼š$t_p$ - è¾¾åˆ°æœ€å¤§è¶…è°ƒçš„æ—¶é—´
- **è¶…è°ƒé‡**ï¼š$M_p$ - æœ€å¤§è¶…è°ƒç™¾åˆ†æ¯”
- **è°ƒèŠ‚æ—¶é—´**ï¼š$t_s$ - å“åº”è¿›å…¥Â±5%è¯¯å·®å¸¦çš„æ—¶é—´

**å½¢å¼åŒ–å®ç°ï¼š**

```haskell
data TimeDomainSpecs = TimeDomainSpecs {
  riseTime :: Double,
  peakTime :: Double,
  overshoot :: Double,
  settlingTime :: Double
} deriving (Show)

-- æ—¶åŸŸæ€§èƒ½åˆ†æ
analyzeTimeDomain :: TransferFunction -> TimeDomainSpecs
analyzeTimeDomain tf = 
  let -- è®¡ç®—é˜¶è·ƒå“åº”
      stepResponse = computeStepResponse tf
      -- è®¡ç®—æ€§èƒ½æŒ‡æ ‡
      riseTime = computeRiseTime stepResponse
      peakTime = computePeakTime stepResponse
      overshoot = computeOvershoot stepResponse
      settlingTime = computeSettlingTime stepResponse
  in TimeDomainSpecs {
    riseTime = riseTime,
    peakTime = peakTime,
    overshoot = overshoot,
    settlingTime = settlingTime
  }

computeStepResponse :: TransferFunction -> [Double]
computeStepResponse tf = 
  let -- ä½¿ç”¨æ‹‰æ™®æ‹‰æ–¯é€†å˜æ¢è®¡ç®—é˜¶è·ƒå“åº”
      timePoints = [0, 0.01 .. 10]  -- æ—¶é—´ç‚¹
      response = map (\t -> inverseLaplace tf t) timePoints
  in response

computeRiseTime :: [Double] -> Double
computeRiseTime response = 
  let -- æ‰¾åˆ°10%å’Œ90%å“åº”æ—¶é—´
      t10 = findTimeAtLevel response 0.1
      t90 = findTimeAtLevel response 0.9
  in t90 - t10

computeOvershoot :: [Double] -> Double
computeOvershoot response = 
  let -- æ‰¾åˆ°æœ€å¤§å€¼
      maxValue = maximum response
      -- è®¡ç®—è¶…è°ƒé‡
      overshoot = (maxValue - 1.0) * 100
  in overshoot
```

### 4.2 é¢‘åŸŸæ€§èƒ½æŒ‡æ ‡

**å®šä¹‰ 4.2 (é¢‘åŸŸæ€§èƒ½æŒ‡æ ‡)**
- **å¸¦å®½**ï¼š$\omega_b$ - å¢ç›Šä¸‹é™åˆ°-3dBçš„é¢‘ç‡
- **è°æŒ¯å³°å€¼**ï¼š$M_r$ - é¢‘ç‡å“åº”çš„æœ€å¤§å¹…å€¼
- **è°æŒ¯é¢‘ç‡**ï¼š$\omega_r$ - è°æŒ¯å³°å€¼å¯¹åº”çš„é¢‘ç‡

**å½¢å¼åŒ–å®ç°ï¼š**

```haskell
data FrequencyDomainSpecs = FrequencyDomainSpecs {
  bandwidth :: Double,
  resonantPeak :: Double,
  resonantFrequency :: Double
} deriving (Show)

-- é¢‘åŸŸæ€§èƒ½åˆ†æ
analyzeFrequencyDomain :: TransferFunction -> FrequencyDomainSpecs
analyzeFrequencyDomain tf = 
  let -- è®¡ç®—é¢‘ç‡å“åº”
      freqResponse = computeFrequencyResponse tf
      -- è®¡ç®—æ€§èƒ½æŒ‡æ ‡
      bandwidth = computeBandwidth freqResponse
      resonantPeak = computeResonantPeak freqResponse
      resonantFreq = computeResonantFrequency freqResponse
  in FrequencyDomainSpecs {
    bandwidth = bandwidth,
    resonantPeak = resonantPeak,
    resonantFrequency = resonantFreq
  }

computeFrequencyResponse :: TransferFunction -> [(Double, Complex Double)]
computeFrequencyResponse tf = 
  let -- ç”Ÿæˆé¢‘ç‡ç‚¹
      frequencies = [0.01, 0.02 .. 100]
      -- è®¡ç®—é¢‘ç‡å“åº”
      responses = map (\w -> (w, evaluateTransferFunction tf (0 :+ w))) frequencies
  in responses

computeBandwidth :: [(Double, Complex Double)] -> Double
computeBandwidth freqResponse = 
  let -- æ‰¾åˆ°-3dBé¢‘ç‡
      minus3dB = 1 / sqrt 2
      bandwidth = findFrequencyAtMagnitude freqResponse minus3dB
  in bandwidth
```

## 5. ç³»ç»Ÿè¾¨è¯†ä¸å»ºæ¨¡

### 5.1 å‚æ•°è¾¨è¯†

**å®šä¹‰ 5.1 (æœ€å°äºŒä¹˜è¾¨è¯†)**
æœ€å°äºŒä¹˜è¾¨è¯†é€šè¿‡æœ€å°åŒ–è¯¯å·®å¹³æ–¹å’Œæ¥ä¼°è®¡ç³»ç»Ÿå‚æ•°ã€‚

**å®šä¹‰ 5.2 (é€’å½’æœ€å°äºŒä¹˜)**
é€’å½’æœ€å°äºŒä¹˜ç®—æ³•ç”¨äºåœ¨çº¿å‚æ•°è¾¨è¯†ã€‚

**å½¢å¼åŒ–å®ç°ï¼š**

```haskell
data SystemIdentification = SystemIdentification {
  inputData :: [Double],
  outputData :: [Double],
  modelOrder :: Int
} deriving (Show)

-- æœ€å°äºŒä¹˜è¾¨è¯†
leastSquaresIdentification :: SystemIdentification -> [Double]
leastSquaresIdentification ident = 
  let -- æ„é€ å›å½’çŸ©é˜µ
      regressionMatrix = constructRegressionMatrix ident
      -- æ±‚è§£æœ€å°äºŒä¹˜é—®é¢˜
      parameters = solveLeastSquares regressionMatrix (outputData ident)
  in parameters

constructRegressionMatrix :: SystemIdentification -> Matrix Double
constructRegressionMatrix ident = 
  let n = modelOrder ident
      input = inputData ident
      output = outputData ident
      m = length input - n
      
      -- æ„é€ å›å½’çŸ©é˜µ
      matrix = matrix m (2*n) (\(i, j) -> 
        if j < n
          then input !! (i + n - j - 1)  -- è¾“å…¥å»¶è¿Ÿ
          else output !! (i + n - (j - n) - 1))  -- è¾“å‡ºå»¶è¿Ÿ
  in matrix

solveLeastSquares :: Matrix Double -> [Double] -> [Double]
solveLeastSquares a b = 
  let -- æ±‚è§£æœ€å°äºŒä¹˜é—®é¢˜ A^T A x = A^T b
      ata = transpose a `multiply` a
      atb = transpose a `multiply` (vector b)
      x = solve ata atb
  in toList x
```

## ğŸ“Š **ç†è®ºå…³ç³»å›¾**

```mermaid
graph TD
    A[ç»å…¸æ§åˆ¶è®º] --> B[ç³»ç»Ÿå»ºæ¨¡]
    A --> C[ç¨³å®šæ€§åˆ†æ]
    A --> D[æ§åˆ¶å™¨è®¾è®¡]
    A --> E[æ€§èƒ½åˆ†æ]
    A --> F[ç³»ç»Ÿè¾¨è¯†]
    
    B --> B1[çŠ¶æ€ç©ºé—´è¡¨ç¤º]
    B --> B2[ä¼ é€’å‡½æ•°è¡¨ç¤º]
    B --> B3[ç³»ç»Ÿçº¿æ€§åŒ–]
    
    C --> C1[æé›…æ™®è¯ºå¤«ç¨³å®šæ€§]
    C --> C2[é¢‘åŸŸç¨³å®šæ€§]
    C --> C3[é²æ£’ç¨³å®šæ€§]
    
    D --> D1[PIDæ§åˆ¶å™¨]
    D --> D2[çŠ¶æ€åé¦ˆ]
    D --> D3[æœ€ä¼˜æ§åˆ¶]
    
    E --> E1[æ—¶åŸŸæ€§èƒ½]
    E --> E2[é¢‘åŸŸæ€§èƒ½]
    E --> E3[é²æ£’æ€§èƒ½]
    
    F --> F1[å‚æ•°è¾¨è¯†]
    F --> F2[ç»“æ„è¾¨è¯†]
    F --> F3[æ¨¡å‹éªŒè¯]
```

## ğŸ”— **ç›¸å…³ç†è®ºé“¾æ¥**

- [ç°ä»£æ§åˆ¶è®º](../02_ç°ä»£æ§åˆ¶è®º/01_ç°ä»£æ§åˆ¶è®ºåŸºç¡€ç†è®º.md)
- [é²æ£’æ§åˆ¶è®º](../03_é²æ£’æ§åˆ¶è®º/01_é²æ£’æ§åˆ¶è®ºåŸºç¡€ç†è®º.md)
- [è‡ªé€‚åº”æ§åˆ¶è®º](../04_è‡ªé€‚åº”æ§åˆ¶è®º/01_è‡ªé€‚åº”æ§åˆ¶è®ºåŸºç¡€ç†è®º.md)
- [æ™ºèƒ½æ§åˆ¶è®º](../05_æ™ºèƒ½æ§åˆ¶è®º/01_æ™ºèƒ½æ§åˆ¶è®ºåŸºç¡€ç†è®º.md)
- [å½¢å¼è¯­è¨€ç†è®º](../../03_Formal_Language_Theory/01_å½¢å¼è¯­æ³•ç†è®º/01_å½¢å¼è¯­æ³•åŸºç¡€ç†è®º.md)
- [ç±»å‹ç†è®º](../../04_Type_Theory/01_ç®€å•ç±»å‹ç†è®º/01_ç®€å•ç±»å‹åŸºç¡€ç†è®º.md)

## ğŸ“š **å‚è€ƒæ–‡çŒ®**

1. Ogata, K. (2010). Modern control engineering. Pearson.
2. Franklin, G. F., Powell, J. D., & Emami-Naeini, A. (2015). Feedback control of dynamic systems. Pearson.
3. Ã…strÃ¶m, K. J., & Murray, R. M. (2021). Feedback systems: an introduction for scientists and engineers. Princeton University Press.
4. Kailath, T. (1980). Linear systems. Prentice-Hall.
5. Chen, C. T. (1999). Linear system theory and design. Oxford University Press.

---

**æœ€åæ›´æ–°æ—¶é—´**: 2024-12-20  
**ç‰ˆæœ¬**: v1.0.0  
**ç»´æŠ¤è€…**: å½¢å¼ç§‘å­¦ä½“ç³»æ„å»ºå›¢é˜Ÿ 