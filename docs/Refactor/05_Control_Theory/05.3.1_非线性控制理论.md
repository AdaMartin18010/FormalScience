# 05.3.1 éçº¿æ€§æ§åˆ¶ç†è®º

## ğŸ“‹ æ¦‚è¿°

éçº¿æ€§æ§åˆ¶ç†è®ºæ˜¯ç°ä»£æ§åˆ¶ç†è®ºçš„é‡è¦åˆ†æ”¯ï¼Œç ”ç©¶éçº¿æ€§åŠ¨æ€ç³»ç»Ÿçš„æ§åˆ¶é—®é¢˜ã€‚éçº¿æ€§æ§åˆ¶ç†è®ºä¸ºå¤æ‚éçº¿æ€§ç³»ç»Ÿçš„åˆ†æå’Œè®¾è®¡æä¾›äº†å¼ºæœ‰åŠ›çš„æ•°å­¦å·¥å…·ï¼Œå¹¿æ³›åº”ç”¨äºæœºå™¨äººã€èˆªç©ºèˆªå¤©ã€ç”Ÿç‰©ç³»ç»Ÿã€ç»æµç³»ç»Ÿç­‰é¢†åŸŸã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **éçº¿æ€§ç³»ç»Ÿå»ºæ¨¡**ï¼šå»ºç«‹éçº¿æ€§ç³»ç»Ÿçš„æ•°å­¦æ¨¡å‹
2. **ç¨³å®šæ€§åˆ†æ**ï¼šåˆ†æéçº¿æ€§ç³»ç»Ÿçš„ç¨³å®šæ€§
3. **æ§åˆ¶å™¨è®¾è®¡**ï¼šè®¾è®¡éçº¿æ€§æ§åˆ¶å™¨
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šä¼˜åŒ–éçº¿æ€§ç³»ç»Ÿçš„æ€§èƒ½

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [æé›…æ™®è¯ºå¤«ç¨³å®šæ€§ç†è®º](#2-æé›…æ™®è¯ºå¤«ç¨³å®šæ€§ç†è®º)
3. [åé¦ˆçº¿æ€§åŒ–](#3-åé¦ˆçº¿æ€§åŒ–)
4. [æ»‘æ¨¡æ§åˆ¶](#4-æ»‘æ¨¡æ§åˆ¶)
5. [åæ­¥æ³•](#5-åæ­¥æ³•)
6. [è‡ªé€‚åº”æ§åˆ¶](#6-è‡ªé€‚åº”æ§åˆ¶)
7. [ä»£ç å®ç°](#7-ä»£ç å®ç°)
8. [åº”ç”¨ç¤ºä¾‹](#8-åº”ç”¨ç¤ºä¾‹)
9. [ç›¸å…³ç†è®º](#9-ç›¸å…³ç†è®º)
10. [å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 éçº¿æ€§ç³»ç»Ÿ

**å®šä¹‰ 1.1.1** (éçº¿æ€§ç³»ç»Ÿ)
éçº¿æ€§ç³»ç»Ÿæ˜¯å…·æœ‰éçº¿æ€§åŠ¨æ€ç‰¹æ€§çš„ç³»ç»Ÿï¼Œå…¶çŠ¶æ€æ–¹ç¨‹å¯ä»¥è¡¨ç¤ºä¸ºï¼š

$$\dot{x}(t) = f(x(t), u(t), t)$$

å…¶ä¸­ $f$ æ˜¯éçº¿æ€§å‡½æ•°ã€‚

**ä¾‹ 1.1.1** (å€’ç«‹æ‘†ç³»ç»Ÿ)
å€’ç«‹æ‘†ç³»ç»Ÿçš„éçº¿æ€§æ–¹ç¨‹ä¸ºï¼š

$$\begin{align}
\dot{x}_1 &= x_2 \\
\dot{x}_2 &= \frac{g\sin(x_1) - \frac{mLx_2^2\sin(x_1)\cos(x_1)}{m_c + m}}{L\left(\frac{4}{3} - \frac{m\cos^2(x_1)}{m_c + m}\right)} + \frac{\cos(x_1)}{L\left(\frac{4}{3} - \frac{m\cos^2(x_1)}{m_c + m}\right)}u
\end{align}$$

å…¶ä¸­ $x_1$ æ˜¯æ‘†æ†è§’åº¦ï¼Œ$x_2$ æ˜¯è§’é€Ÿåº¦ï¼Œ$u$ æ˜¯æ§åˆ¶è¾“å…¥ã€‚

### 1.2 å¹³è¡¡ç‚¹

**å®šä¹‰ 1.2.1** (å¹³è¡¡ç‚¹)
å¯¹äºè‡ªæ²»ç³»ç»Ÿ $\dot{x} = f(x)$ï¼Œå¦‚æœ $f(x_e) = 0$ï¼Œåˆ™ç§° $x_e$ ä¸ºç³»ç»Ÿçš„å¹³è¡¡ç‚¹ã€‚

**ä¾‹ 1.2.1** (å€’ç«‹æ‘†å¹³è¡¡ç‚¹)
å€’ç«‹æ‘†ç³»ç»Ÿæœ‰ä¸¤ä¸ªå¹³è¡¡ç‚¹ï¼š
1. ä¸‹å‚ä½ç½®ï¼š$x_e = [0, 0]^T$
2. å€’ç«‹ä½ç½®ï¼š$x_e = [\pi, 0]^T$

### 1.3 å±€éƒ¨ä¸å…¨å±€æ€§è´¨

**å®šä¹‰ 1.3.1** (å±€éƒ¨ä¸å…¨å±€)
- **å±€éƒ¨æ€§è´¨**ï¼šåœ¨å¹³è¡¡ç‚¹é™„è¿‘çš„å°é‚»åŸŸå†…æˆç«‹çš„æ€§è´¨
- **å…¨å±€æ€§è´¨**ï¼šåœ¨æ•´ä¸ªçŠ¶æ€ç©ºé—´å†…æˆç«‹çš„æ€§è´¨

## 2. æé›…æ™®è¯ºå¤«ç¨³å®šæ€§ç†è®º

### 2.1 æé›…æ™®è¯ºå¤«ç¨³å®šæ€§å®šä¹‰

**å®šä¹‰ 2.1.1** (æé›…æ™®è¯ºå¤«ç¨³å®šæ€§)
å¯¹äºç³»ç»Ÿ $\dot{x} = f(x)$ï¼Œå¹³è¡¡ç‚¹ $x_e = 0$ æ˜¯æé›…æ™®è¯ºå¤«ç¨³å®šçš„ï¼Œå¦‚æœå¯¹äºä»»æ„ $\epsilon > 0$ï¼Œå­˜åœ¨ $\delta > 0$ï¼Œä½¿å¾—ï¼š

$$\|x(0)\| < \delta \Rightarrow \|x(t)\| < \epsilon, \quad \forall t \geq 0$$

**å®šä¹‰ 2.1.2** (æ¸è¿‘ç¨³å®šæ€§)
å¹³è¡¡ç‚¹ $x_e = 0$ æ˜¯æ¸è¿‘ç¨³å®šçš„ï¼Œå¦‚æœå®ƒæ˜¯æé›…æ™®è¯ºå¤«ç¨³å®šçš„ï¼Œå¹¶ä¸”ï¼š

$$\lim_{t \to \infty} x(t) = 0$$

**å®šä¹‰ 2.1.3** (æŒ‡æ•°ç¨³å®šæ€§)
å¹³è¡¡ç‚¹ $x_e = 0$ æ˜¯æŒ‡æ•°ç¨³å®šçš„ï¼Œå¦‚æœå­˜åœ¨å¸¸æ•° $c > 0$ å’Œ $\lambda > 0$ï¼Œä½¿å¾—ï¼š

$$\|x(t)\| \leq c\|x(0)\|e^{-\lambda t}, \quad \forall t \geq 0$$

### 2.2 æé›…æ™®è¯ºå¤«ç›´æ¥æ³•

**å®šç† 2.2.1** (æé›…æ™®è¯ºå¤«ç¨³å®šæ€§å®šç†)
å¯¹äºç³»ç»Ÿ $\dot{x} = f(x)$ï¼Œå¦‚æœå­˜åœ¨è¿ç»­å¯å¾®å‡½æ•° $V(x)$ï¼Œæ»¡è¶³ï¼š

1. $V(0) = 0$
2. $V(x) > 0$ å¯¹äºæ‰€æœ‰ $x \neq 0$
3. $\dot{V}(x) \leq 0$ å¯¹äºæ‰€æœ‰ $x$

åˆ™å¹³è¡¡ç‚¹ $x_e = 0$ æ˜¯æé›…æ™®è¯ºå¤«ç¨³å®šçš„ã€‚

**å®šç† 2.2.2** (æ¸è¿‘ç¨³å®šæ€§å®šç†)
å¦‚æœè¿›ä¸€æ­¥æ»¡è¶³ï¼š

4. $\dot{V}(x) < 0$ å¯¹äºæ‰€æœ‰ $x \neq 0$

åˆ™å¹³è¡¡ç‚¹ $x_e = 0$ æ˜¯æ¸è¿‘ç¨³å®šçš„ã€‚

**è¯æ˜**ï¼š
è®¾ $V(x)$ æ˜¯æé›…æ™®è¯ºå¤«å‡½æ•°ï¼Œåˆ™ï¼š

$$\dot{V}(x) = \frac{\partial V}{\partial x}f(x) \leq 0$$

è¿™æ„å‘³ç€ $V(x(t))$ æ˜¯éå¢å‡½æ•°ã€‚ç”±äº $V(x) > 0$ï¼Œ$x(t)$ å°†ä¿æŒåœ¨æŸä¸ªæœ‰ç•ŒåŒºåŸŸå†…ï¼Œå› æ­¤ç³»ç»Ÿæ˜¯æé›…æ™®è¯ºå¤«ç¨³å®šçš„ã€‚

å¦‚æœ $\dot{V}(x) < 0$ï¼Œåˆ™ $V(x(t))$ ä¸¥æ ¼é€’å‡ï¼Œæœ€ç»ˆæ”¶æ•›åˆ° $V(0) = 0$ï¼Œå› æ­¤ $x(t) \to 0$ã€‚

### 2.3 æé›…æ™®è¯ºå¤«å‡½æ•°æ„é€ 

**æ–¹æ³• 2.3.1** (èƒ½é‡å‡½æ•°æ³•)
å¯¹äºç‰©ç†ç³»ç»Ÿï¼Œå¯ä»¥ä½¿ç”¨ç³»ç»Ÿçš„æ€»èƒ½é‡ä½œä¸ºæé›…æ™®è¯ºå¤«å‡½æ•°ã€‚

**ä¾‹ 2.3.1** (å€’ç«‹æ‘†èƒ½é‡å‡½æ•°)
å€’ç«‹æ‘†çš„æ€»èƒ½é‡ä¸ºï¼š

$$E = \frac{1}{2}mL^2\dot{\theta}^2 + mgL(1 - \cos\theta)$$

å®šä¹‰æé›…æ™®è¯ºå¤«å‡½æ•°ï¼š

$$V(x) = \frac{1}{2}mL^2x_2^2 + mgL(1 - \cos x_1)$$

**æ–¹æ³• 2.3.2** (äºŒæ¬¡å‹å‡½æ•°æ³•)
å¯¹äºçº¿æ€§åŒ–ç³»ç»Ÿï¼Œå¯ä»¥ä½¿ç”¨äºŒæ¬¡å‹å‡½æ•°ï¼š

$$V(x) = x^TPx$$

å…¶ä¸­ $P$ æ˜¯æ­£å®šçŸ©é˜µã€‚

## 3. åé¦ˆçº¿æ€§åŒ–

### 3.1 è¾“å…¥-çŠ¶æ€çº¿æ€§åŒ–

**å®šä¹‰ 3.1.1** (ç›¸å¯¹åº¦)
å¯¹äºç³»ç»Ÿ $\dot{x} = f(x) + g(x)u$ï¼Œå¦‚æœå­˜åœ¨æ•´æ•° $r$ï¼Œä½¿å¾—ï¼š

$$L_g L_f^{r-1} h(x) \neq 0$$

åˆ™ç§°ç³»ç»Ÿçš„ç›¸å¯¹åº¦ä¸º $r$ï¼Œå…¶ä¸­ $h(x)$ æ˜¯è¾“å‡ºå‡½æ•°ã€‚

**å®šç† 3.1.1** (è¾“å…¥-çŠ¶æ€çº¿æ€§åŒ–)
å¦‚æœç³»ç»Ÿ $\dot{x} = f(x) + g(x)u$ åœ¨ $x_0$ é™„è¿‘å…·æœ‰ç›¸å¯¹åº¦ $n$ï¼Œåˆ™å­˜åœ¨åæ ‡å˜æ¢ï¼š

$$z = \Phi(x) = \begin{bmatrix} h(x) \\ L_f h(x) \\ \vdots \\ L_f^{n-1} h(x) \end{bmatrix}$$

ä½¿å¾—ç³»ç»Ÿåœ¨æ–°åæ ‡ä¸‹å˜ä¸ºï¼š

$$\begin{align}
\dot{z}_1 &= z_2 \\
\dot{z}_2 &= z_3 \\
&\vdots \\
\dot{z}_n &= L_f^n h(x) + L_g L_f^{n-1} h(x) u
\end{align}$$

**è¯æ˜**ï¼š
é€šè¿‡æå¯¼æ•°è®¡ç®—ï¼š

$$\dot{z}_1 = \frac{\partial h}{\partial x}\dot{x} = L_f h(x) + L_g h(x) u = z_2$$

å› ä¸º $L_g h(x) = 0$ï¼ˆç›¸å¯¹åº¦å®šä¹‰ï¼‰ã€‚

ç±»ä¼¼åœ°ï¼š

$$\dot{z}_2 = L_f^2 h(x) + L_g L_f h(x) u = z_3$$

æœ€ç»ˆï¼š

$$\dot{z}_n = L_f^n h(x) + L_g L_f^{n-1} h(x) u$$

### 3.2 è¾“å…¥-è¾“å‡ºçº¿æ€§åŒ–

**å®šä¹‰ 3.2.1** (è¾“å…¥-è¾“å‡ºçº¿æ€§åŒ–)
å¯¹äºç³»ç»Ÿ $\dot{x} = f(x) + g(x)u$ï¼Œ$y = h(x)$ï¼Œå¦‚æœç›¸å¯¹åº¦ä¸º $r < n$ï¼Œåˆ™å¯ä»¥é€šè¿‡åé¦ˆï¼š

$$u = \frac{v - L_f^r h(x)}{L_g L_f^{r-1} h(x)}$$

ä½¿å¾—è¾“å…¥-è¾“å‡ºå…³ç³»å˜ä¸ºï¼š

$$y^{(r)} = v$$

**ä¾‹ 3.2.1** (å€’ç«‹æ‘†è¾“å…¥-è¾“å‡ºçº¿æ€§åŒ–)
å¯¹äºå€’ç«‹æ‘†ç³»ç»Ÿï¼Œé€‰æ‹©è¾“å‡º $y = x_1$ï¼ˆè§’åº¦ï¼‰ï¼Œåˆ™ï¼š

$$L_f h(x) = x_2$$
$$L_f^2 h(x) = \frac{g\sin(x_1) - \frac{mLx_2^2\sin(x_1)\cos(x_1)}{m_c + m}}{L\left(\frac{4}{3} - \frac{m\cos^2(x_1)}{m_c + m}\right)}$$
$$L_g L_f h(x) = \frac{\cos(x_1)}{L\left(\frac{4}{3} - \frac{m\cos^2(x_1)}{m_c + m}\right)}$$

å› æ­¤ç›¸å¯¹åº¦ä¸º2ï¼Œåé¦ˆæ§åˆ¶å¾‹ä¸ºï¼š

$$u = \frac{v - L_f^2 h(x)}{L_g L_f h(x)}$$

### 3.3 é›¶åŠ¨æ€

**å®šä¹‰ 3.3.1** (é›¶åŠ¨æ€)
å¯¹äºè¾“å…¥-è¾“å‡ºçº¿æ€§åŒ–ç³»ç»Ÿï¼Œé›¶åŠ¨æ€æ˜¯ç³»ç»Ÿåœ¨è¾“å‡ºæ’ä¸ºé›¶æ—¶çš„å†…éƒ¨åŠ¨æ€ã€‚

**å®šç† 3.3.1** (é›¶åŠ¨æ€ç¨³å®šæ€§)
å¦‚æœé›¶åŠ¨æ€æ˜¯æ¸è¿‘ç¨³å®šçš„ï¼Œåˆ™æ•´ä¸ªç³»ç»Ÿå¯ä»¥é€šè¿‡é€‚å½“çš„åé¦ˆå®ç°æ¸è¿‘ç¨³å®šã€‚

## 4. æ»‘æ¨¡æ§åˆ¶

### 4.1 æ»‘æ¨¡é¢è®¾è®¡

**å®šä¹‰ 4.1.1** (æ»‘æ¨¡é¢)
å¯¹äºç³»ç»Ÿ $\dot{x} = f(x) + g(x)u$ï¼Œæ»‘æ¨¡é¢å®šä¹‰ä¸ºï¼š

$$s(x) = c_1 x_1 + c_2 x_2 + \cdots + c_{n-1} x_{n-1} + x_n = 0$$

å…¶ä¸­ $c_i$ æ˜¯è®¾è®¡å‚æ•°ã€‚

**ä¾‹ 4.1.1** (äºŒé˜¶ç³»ç»Ÿæ»‘æ¨¡é¢)
å¯¹äºäºŒé˜¶ç³»ç»Ÿï¼š

$$\begin{align}
\dot{x}_1 &= x_2 \\
\dot{x}_2 &= f(x) + g(x)u
\end{align}$$

æ»‘æ¨¡é¢ä¸ºï¼š

$$s(x) = c x_1 + x_2 = 0$$

### 4.2 æ»‘æ¨¡æ§åˆ¶å¾‹

**å®šç† 4.2.1** (æ»‘æ¨¡æ§åˆ¶å¾‹)
æ»‘æ¨¡æ§åˆ¶å¾‹ä¸ºï¼š

$$u = u_{eq} + u_{sw}$$

å…¶ä¸­ï¼š
- ç­‰æ•ˆæ§åˆ¶ï¼š$u_{eq} = -\frac{L_f s(x)}{L_g s(x)}$
- åˆ‡æ¢æ§åˆ¶ï¼š$u_{sw} = -\eta \text{sign}(s(x))$

**è¯æ˜**ï¼š
è€ƒè™‘æ»‘æ¨¡é¢çš„å¯¼æ•°ï¼š

$$\dot{s} = L_f s(x) + L_g s(x) u$$

åœ¨æ»‘æ¨¡é¢ä¸Šï¼Œ$\dot{s} = 0$ï¼Œå› æ­¤ï¼š

$$u_{eq} = -\frac{L_f s(x)}{L_g s(x)}$$

ä¸ºäº†ç¡®ä¿æ»‘æ¨¡é¢çš„å¯è¾¾æ€§ï¼Œéœ€è¦ï¼š

$$s \dot{s} < 0$$

è¿™è¦æ±‚ï¼š

$$u = u_{eq} - \eta \text{sign}(s)$$

### 4.3 æ»‘æ¨¡å¯è¾¾æ€§

**å®šç† 4.3.1** (æ»‘æ¨¡å¯è¾¾æ€§)
å¦‚æœæ§åˆ¶å¾‹æ»¡è¶³ï¼š

$$s \dot{s} < -\eta |s|$$

åˆ™ç³»ç»ŸçŠ¶æ€å°†åœ¨æœ‰é™æ—¶é—´å†…åˆ°è¾¾æ»‘æ¨¡é¢ã€‚

**è¯æ˜**ï¼š
è€ƒè™‘æé›…æ™®è¯ºå¤«å‡½æ•° $V = \frac{1}{2}s^2$ï¼Œåˆ™ï¼š

$$\dot{V} = s \dot{s} < -\eta |s| = -\eta \sqrt{2V}$$

å› æ­¤ï¼š

$$\frac{dV}{dt} < -\eta \sqrt{2V}$$

ç§¯åˆ†å¾—åˆ°ï¼š

$$\sqrt{V(t)} < \sqrt{V(0)} - \frac{\eta}{\sqrt{2}}t$$

å› æ­¤ $V(t) = 0$ åœ¨æœ‰é™æ—¶é—´å†…è¾¾åˆ°ã€‚

## 5. åæ­¥æ³•

### 5.1 åæ­¥æ³•åŸç†

**å®šä¹‰ 5.1.1** (åæ­¥æ³•)
åæ­¥æ³•æ˜¯ä¸€ç§é€’å½’è®¾è®¡æ–¹æ³•ï¼Œé€šè¿‡é€æ­¥è®¾è®¡è™šæ‹Ÿæ§åˆ¶å¾‹æ¥ç¨³å®šç³»ç»Ÿã€‚

**ä¾‹ 5.1.1** (ä¸‰é˜¶ç³»ç»Ÿåæ­¥æ³•)
è€ƒè™‘ç³»ç»Ÿï¼š

$$\begin{align}
\dot{x}_1 &= x_2 \\
\dot{x}_2 &= x_3 \\
\dot{x}_3 &= f(x) + g(x)u
\end{align}$$

**æ­¥éª¤1**ï¼šè®¾è®¡ $x_2$ çš„è™šæ‹Ÿæ§åˆ¶å¾‹
è®¾ $x_2^d = -k_1 x_1$ï¼Œå®šä¹‰è¯¯å·® $z_1 = x_1$ï¼Œ$z_2 = x_2 - x_2^d$ã€‚

**æ­¥éª¤2**ï¼šè®¾è®¡ $x_3$ çš„è™šæ‹Ÿæ§åˆ¶å¾‹
è®¾ $x_3^d = -k_2 z_2 - \dot{x}_2^d$ï¼Œå®šä¹‰è¯¯å·® $z_3 = x_3 - x_3^d$ã€‚

**æ­¥éª¤3**ï¼šè®¾è®¡å®é™…æ§åˆ¶å¾‹
$$u = \frac{1}{g(x)}(-k_3 z_3 - f(x) - \dot{x}_3^d)$$

### 5.2 åæ­¥æ³•ç¨³å®šæ€§

**å®šç† 5.2.1** (åæ­¥æ³•ç¨³å®šæ€§)
å¦‚æœæ‰€æœ‰å¢ç›Š $k_i > 0$ï¼Œåˆ™åæ­¥æ³•è®¾è®¡çš„ç³»ç»Ÿæ˜¯æ¸è¿‘ç¨³å®šçš„ã€‚

**è¯æ˜**ï¼š
è€ƒè™‘æé›…æ™®è¯ºå¤«å‡½æ•°ï¼š

$$V = \frac{1}{2}\sum_{i=1}^{n} z_i^2$$

å…¶å¯¼æ•°ä¸ºï¼š

$$\dot{V} = \sum_{i=1}^{n} z_i \dot{z}_i$$

é€šè¿‡é€‚å½“é€‰æ‹©è™šæ‹Ÿæ§åˆ¶å¾‹ï¼Œå¯ä»¥ä½¿å¾—ï¼š

$$\dot{V} = -\sum_{i=1}^{n} k_i z_i^2 < 0$$

å› æ­¤ç³»ç»Ÿæ˜¯æ¸è¿‘ç¨³å®šçš„ã€‚

## 6. è‡ªé€‚åº”æ§åˆ¶

### 6.1 å‚æ•°è‡ªé€‚åº”æ§åˆ¶

**å®šä¹‰ 6.1.1** (å‚æ•°è‡ªé€‚åº”æ§åˆ¶)
å¯¹äºç³»ç»Ÿ $\dot{x} = f(x, \theta) + g(x)u$ï¼Œå…¶ä¸­ $\theta$ æ˜¯æœªçŸ¥å‚æ•°ï¼Œè‡ªé€‚åº”æ§åˆ¶å¾‹ä¸ºï¼š

$$u = u_0(x, \hat{\theta}) + u_a(x, \hat{\theta})$$

å…¶ä¸­ $\hat{\theta}$ æ˜¯å‚æ•°ä¼°è®¡ã€‚

**å®šç† 6.1.1** (å‚æ•°è‡ªé€‚åº”å¾‹)
å‚æ•°è‡ªé€‚åº”å¾‹ä¸ºï¼š

$$\dot{\hat{\theta}} = -\Gamma \frac{\partial f}{\partial \theta}^T P e$$

å…¶ä¸­ $e = x - x_d$ æ˜¯è·Ÿè¸ªè¯¯å·®ï¼Œ$P$ æ˜¯æ­£å®šçŸ©é˜µã€‚

### 6.2 ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶

**å®šä¹‰ 6.2.1** (ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶)
ä½¿ç”¨ç¥ç»ç½‘ç»œé€¼è¿‘æœªçŸ¥å‡½æ•°ï¼š

$$f(x) = W^T \phi(x) + \epsilon(x)$$

å…¶ä¸­ $W$ æ˜¯æƒé‡çŸ©é˜µï¼Œ$\phi(x)$ æ˜¯åŸºå‡½æ•°ï¼Œ$\epsilon(x)$ æ˜¯é€¼è¿‘è¯¯å·®ã€‚

**å®šç† 6.2.1** (ç¥ç»ç½‘ç»œè‡ªé€‚åº”å¾‹)
ç¥ç»ç½‘ç»œæƒé‡è‡ªé€‚åº”å¾‹ä¸ºï¼š

$$\dot{W} = -\Gamma \phi(x) e^T P$$

## 7. ä»£ç å®ç°

### 7.1 éçº¿æ€§ç³»ç»Ÿæ¡†æ¶

```rust
use nalgebra::{DMatrix, DVector};
use std::f64::consts::PI;

/// éçº¿æ€§ç³»ç»Ÿ
pub trait NonlinearSystem {
    fn dynamics(&self, x: &DVector<f64>, u: &DVector<f64>, t: f64) -> DVector<f64>;
    fn jacobian_x(&self, x: &DVector<f64>, u: &DVector<f64>, t: f64) -> DMatrix<f64>;
    fn jacobian_u(&self, x: &DVector<f64>, u: &DVector<f64>, t: f64) -> DMatrix<f64>;
}

/// å€’ç«‹æ‘†ç³»ç»Ÿ
pub struct InvertedPendulum {
    pub m: f64,  // æ‘†æ†è´¨é‡
    pub M: f64,  // å°è½¦è´¨é‡
    pub l: f64,  // æ‘†æ†é•¿åº¦
    pub g: f64,  // é‡åŠ›åŠ é€Ÿåº¦
    pub b: f64,  // æ‘©æ“¦ç³»æ•°
}

impl InvertedPendulum {
    pub fn new() -> Self {
        Self {
            m: 0.2,
            M: 0.5,
            l: 0.3,
            g: 9.8,
            b: 0.1,
        }
    }
}

impl NonlinearSystem for InvertedPendulum {
    fn dynamics(&self, x: &DVector<f64>, u: &DVector<f64>, _t: f64) -> DVector<f64> {
        let theta = x[0];  // è§’åº¦
        let omega = x[1];  // è§’é€Ÿåº¦

        let p = self.m * self.l * self.l;
        let q = self.M + self.m;

        let denominator = p * q - self.m * self.m * self.l * self.l * (theta.cos()).powi(2);

        let dtheta = omega;
        let domega = (self.m * self.g * self.l * theta.sin() -
                     self.b * omega -
                     self.m * self.l * omega.powi(2) * theta.sin() * theta.cos()) / denominator +
                    (self.l * theta.cos()) / denominator * u[0];

        DVector::from_column_slice(&[dtheta, domega])
    }

    fn jacobian_x(&self, x: &DVector<f64>, u: &DVector<f64>, _t: f64) -> DMatrix<f64> {
        let theta = x[0];
        let omega = x[1];

        let p = self.m * self.l * self.l;
        let q = self.M + self.m;
        let denominator = p * q - self.m * self.m * self.l * self.l * (theta.cos()).powi(2);

        let d_denominator_dtheta = 2.0 * self.m * self.m * self.l * self.l * theta.cos() * theta.sin();

        let domega_dtheta = (self.m * self.g * self.l * theta.cos() -
                            self.m * self.l * omega.powi(2) * (theta.cos().powi(2) - theta.sin().powi(2))) / denominator -
                           (self.m * self.g * self.l * theta.sin() -
                            self.b * omega -
                            self.m * self.l * omega.powi(2) * theta.sin() * theta.cos()) * d_denominator_dtheta / denominator.powi(2) +
                           (-self.l * theta.sin()) / denominator * u[0] +
                           (self.l * theta.cos()) * d_denominator_dtheta / denominator.powi(2) * u[0];

        let domega_domega = (-self.b - 2.0 * self.m * self.l * omega * theta.sin() * theta.cos()) / denominator;

        DMatrix::from_row_slice(2, 2, &[
            0.0, 1.0,
            domega_dtheta, domega_domega
        ])
    }

    fn jacobian_u(&self, x: &DVector<f64>, _u: &DVector<f64>, _t: f64) -> DMatrix<f64> {
        let theta = x[0];

        let p = self.m * self.l * self.l;
        let q = self.M + self.m;
        let denominator = p * q - self.m * self.m * self.l * self.l * (theta.cos()).powi(2);

        DMatrix::from_column_slice(2, 1, &[
            0.0,
            (self.l * theta.cos()) / denominator
        ])
    }
}

/// æé›…æ™®è¯ºå¤«ç¨³å®šæ€§åˆ†æå™¨
pub struct LyapunovAnalyzer;

impl LyapunovAnalyzer {
    /// æ£€æŸ¥æé›…æ™®è¯ºå¤«ç¨³å®šæ€§
    pub fn check_stability<F>(system: &dyn NonlinearSystem, lyapunov_fn: F, x0: &DVector<f64>) -> bool
    where F: Fn(&DVector<f64>) -> f64 {
        let dt = 0.01;
        let t_final = 10.0;
        let steps = (t_final / dt) as usize;

        let mut x = x0.clone();
        let mut v_old = lyapunov_fn(&x);

        for _ in 0..steps {
            let u = DVector::zeros(1); // é›¶è¾“å…¥
            let dx = system.dynamics(&x, &u, 0.0) * dt;
            x = &x + &dx;

            let v_new = lyapunov_fn(&x);

            // æ£€æŸ¥æé›…æ™®è¯ºå¤«å‡½æ•°æ˜¯å¦é€’å‡
            if v_new > v_old {
                return false;
            }

            v_old = v_new;
        }

        true
    }

    /// æ„é€ äºŒæ¬¡å‹æé›…æ™®è¯ºå¤«å‡½æ•°
    pub fn quadratic_lyapunov(x: &DVector<f64>, P: &DMatrix<f64>) -> f64 {
        x.transpose() * P * x
    }
}
```

### 7.2 åé¦ˆçº¿æ€§åŒ–æ§åˆ¶å™¨

```rust
/// åé¦ˆçº¿æ€§åŒ–æ§åˆ¶å™¨
pub struct FeedbackLinearizationController {
    pub k: DVector<f64>,
}

impl FeedbackLinearizationController {
    pub fn new(k: DVector<f64>) -> Self {
        Self { k }
    }

    /// è®¡ç®—åé¦ˆçº¿æ€§åŒ–æ§åˆ¶å¾‹
    pub fn compute_control(&self, system: &dyn NonlinearSystem, x: &DVector<f64>, v: &DVector<f64>) -> DVector<f64> {
        let n = x.len();

        // è®¡ç®—æå¯¼æ•°
        let mut lie_derivatives = vec![0.0; n];
        lie_derivatives[0] = x[0]; // h(x) = x_1

        for i in 1..n {
            lie_derivatives[i] = self.compute_lie_derivative(system, x, i);
        }

        // è®¡ç®—åé¦ˆçº¿æ€§åŒ–æ§åˆ¶å¾‹
        let alpha = self.compute_alpha(system, x, n);
        let beta = self.compute_beta(system, x, n);

        (v[0] - alpha) / beta
    }

    /// è®¡ç®—æå¯¼æ•°
    fn compute_lie_derivative(&self, system: &dyn NonlinearSystem, x: &DVector<f64>, order: usize) -> f64 {
        if order == 0 {
            return x[0];
        }

        let mut result = 0.0;
        let u = DVector::zeros(1);
        let jacobian = system.jacobian_x(x, &u, 0.0);

        for i in 0..x.len() {
            result += jacobian[(order - 1, i)] * x[i];
        }

        result
    }

    /// è®¡ç®—alphaé¡¹
    fn compute_alpha(&self, system: &dyn NonlinearSystem, x: &DVector<f64>, order: usize) -> f64 {
        self.compute_lie_derivative(system, x, order)
    }

    /// è®¡ç®—betaé¡¹
    fn compute_beta(&self, system: &dyn NonlinearSystem, x: &DVector<f64>, order: usize) -> f64 {
        let u = DVector::zeros(1);
        let jacobian_u = system.jacobian_u(x, &u, 0.0);

        if order > 0 {
            jacobian_u[(order - 1, 0)]
        } else {
            0.0
        }
    }
}
```

### 7.3 æ»‘æ¨¡æ§åˆ¶å™¨

```rust
/// æ»‘æ¨¡æ§åˆ¶å™¨
pub struct SlidingModeController {
    pub c: DVector<f64>,
    pub eta: f64,
}

impl SlidingModeController {
    pub fn new(c: DVector<f64>, eta: f64) -> Self {
        Self { c, eta }
    }

    /// è®¡ç®—æ»‘æ¨¡é¢
    pub fn sliding_surface(&self, x: &DVector<f64>) -> f64 {
        let mut s = 0.0;
        for i in 0..self.c.len() {
            s += self.c[i] * x[i];
        }
        s + x[x.len() - 1]
    }

    /// è®¡ç®—æ»‘æ¨¡æ§åˆ¶å¾‹
    pub fn compute_control(&self, system: &dyn NonlinearSystem, x: &DVector<f64>) -> DVector<f64> {
        let s = self.sliding_surface(x);

        // è®¡ç®—ç­‰æ•ˆæ§åˆ¶
        let u_eq = self.compute_equivalent_control(system, x);

        // è®¡ç®—åˆ‡æ¢æ§åˆ¶
        let u_sw = -self.eta * s.signum();

        DVector::from_column_slice(&[u_eq + u_sw])
    }

    /// è®¡ç®—ç­‰æ•ˆæ§åˆ¶
    fn compute_equivalent_control(&self, system: &dyn NonlinearSystem, x: &DVector<f64>) -> f64 {
        let n = x.len();
        let u = DVector::zeros(1);

        // è®¡ç®—æ»‘æ¨¡é¢çš„æå¯¼æ•°
        let mut lie_derivative = 0.0;
        let jacobian = system.jacobian_x(x, &u, 0.0);

        for i in 0..n-1 {
            lie_derivative += self.c[i] * x[i+1];
        }

        lie_derivative += self.c[n-1] * system.dynamics[x, &u, 0.0](n-1);

        // è®¡ç®—æ§åˆ¶å¢ç›Š
        let control_gain = self.c[n-1] * system.jacobian_u[x, &u, 0.0]((n-1, 0));

        -lie_derivative / control_gain
    }
}
```

### 7.4 åæ­¥æ³•æ§åˆ¶å™¨

```rust
/// åæ­¥æ³•æ§åˆ¶å™¨
pub struct BacksteppingController {
    pub k: DVector<f64>,
}

impl BacksteppingController {
    pub fn new(k: DVector<f64>) -> Self {
        Self { k }
    }

    /// è®¡ç®—åæ­¥æ³•æ§åˆ¶å¾‹
    pub fn compute_control(&self, system: &dyn NonlinearSystem, x: &DVector<f64>) -> DVector<f64> {
        let n = x.len();
        let mut z = vec![0.0; n];
        let mut virtual_controls = vec![0.0; n-1];

        // æ­¥éª¤1ï¼šè®¡ç®—è¯¯å·®å˜é‡
        z[0] = x[0];
        virtual_controls[0] = -self.k[0] * z[0];
        z[1] = x[1] - virtual_controls[0];

        for i in 1..n-1 {
            virtual_controls[i] = -self.k[i] * z[i] - self.derivative_virtual_control(&virtual_controls, i-1);
            z[i+1] = x[i+1] - virtual_controls[i];
        }

        // æ­¥éª¤nï¼šè®¡ç®—å®é™…æ§åˆ¶å¾‹
        let u = (-self.k[n-1] * z[n-1] -
                self.derivative_virtual_control(&virtual_controls, n-2) -
                system.dynamics(x, &DVector::zeros(1), 0.0)[n-1]) /
               system.jacobian_u(x, &DVector::zeros(1), 0.0)[(n-1, 0)];

        DVector::from_column_slice(&[u])
    }

    /// è®¡ç®—è™šæ‹Ÿæ§åˆ¶çš„å¯¼æ•°
    fn derivative_virtual_control(&self, virtual_controls: &[f64], index: usize) -> f64 {
        if index == 0 {
            -self.k[0] * virtual_controls[0]
        } else {
            -self.k[index] * self.derivative_virtual_control(virtual_controls, index-1)
        }
    }
}
```

## 8. åº”ç”¨ç¤ºä¾‹

### 8.1 å€’ç«‹æ‘†éçº¿æ€§æ§åˆ¶

```rust
/// å€’ç«‹æ‘†éçº¿æ€§æ§åˆ¶ç¤ºä¾‹
pub fn inverted_pendulum_nonlinear_control() {
    let system = InvertedPendulum::new();

    // åˆå§‹çŠ¶æ€ï¼šæ‘†æ†åç¦»å‚ç›´ä½ç½®0.5å¼§åº¦
    let x0 = DVector::from_column_slice(&[0.5, 0.0]);

    // è®¾è®¡æ»‘æ¨¡æ§åˆ¶å™¨
    let c = DVector::from_column_slice(&[2.0]);
    let eta = 1.0;
    let sliding_controller = SlidingModeController::new(c, eta);

    // ä»¿çœŸ
    let dt = 0.01;
    let t_final = 10.0;
    let steps = (t_final / dt) as usize;

    let mut x = x0.clone();
    let mut t = 0.0;

    println!("å€’ç«‹æ‘†æ»‘æ¨¡æ§åˆ¶ä»¿çœŸç»“æœï¼š");

    for step in 0..steps {
        let u = sliding_controller.compute_control(&system, &x);
        let dx = system.dynamics(&x, &u, t) * dt;
        x = &x + &dx;
        t += dt;

        if step % 100 == 0 {
            let s = sliding_controller.sliding_surface(&x);
            println!("t={:.1}s: è§’åº¦={:.3}rad, è§’é€Ÿåº¦={:.3}rad/s, æ»‘æ¨¡é¢={:.3}, æ§åˆ¶={:.3}N",
                t, x[0], x[1], s, u[0]);
        }
    }

    println!("æœ€ç»ˆçŠ¶æ€: è§’åº¦={:.3}rad, è§’é€Ÿåº¦={:.3}rad/s", x[0], x[1]);
}
```

### 8.2 åé¦ˆçº¿æ€§åŒ–ç¤ºä¾‹

```rust
/// åé¦ˆçº¿æ€§åŒ–ç¤ºä¾‹
pub fn feedback_linearization_example() {
    let system = InvertedPendulum::new();

    // è®¾è®¡åé¦ˆçº¿æ€§åŒ–æ§åˆ¶å™¨
    let k = DVector::from_column_slice(&[4.0, 4.0]);
    let controller = FeedbackLinearizationController::new(k);

    // æœŸæœ›è½¨è¿¹ï¼šæ­£å¼¦æ³¢
    let x0 = DVector::from_column_slice(&[0.0, 0.0]);
    let dt = 0.01;
    let t_final = 10.0;
    let steps = (t_final / dt) as usize;

    let mut x = x0.clone();
    let mut t = 0.0;

    println!("åé¦ˆçº¿æ€§åŒ–æ§åˆ¶ä»¿çœŸç»“æœï¼š");

    for step in 0..steps {
        // æœŸæœ›è¾“å‡ºï¼šæ­£å¼¦æ³¢
        let y_d = 0.5 * (t).sin();
        let dy_d = 0.5 * (t).cos();
        let ddy_d = -0.5 * (t).sin();

        let v = DVector::from_column_slice(&[ddy_d - k[0] * (x[0] - y_d) - k[1] * (x[1] - dy_d)]);

        let u = controller.compute_control(&system, &x, &v);
        let dx = system.dynamics(&x, &u, t) * dt;
        x = &x + &dx;
        t += dt;

        if step % 100 == 0 {
            println!("t={:.1}s: å®é™…è§’åº¦={:.3}rad, æœŸæœ›è§’åº¦={:.3}rad, æ§åˆ¶={:.3}N",
                t, x[0], y_d, u[0]);
        }
    }
}
```

### 8.3 åæ­¥æ³•ç¤ºä¾‹

```rust
/// åæ­¥æ³•ç¤ºä¾‹
pub fn backstepping_example() {
    let system = InvertedPendulum::new();

    // è®¾è®¡åæ­¥æ³•æ§åˆ¶å™¨
    let k = DVector::from_column_slice(&[2.0, 2.0]);
    let controller = BacksteppingController::new(k);

    // åˆå§‹çŠ¶æ€
    let x0 = DVector::from_column_slice(&[0.3, 0.0]);

    // ä»¿çœŸ
    let dt = 0.01;
    let t_final = 10.0;
    let steps = (t_final / dt) as usize;

    let mut x = x0.clone();
    let mut t = 0.0;

    println!("åæ­¥æ³•æ§åˆ¶ä»¿çœŸç»“æœï¼š");

    for step in 0..steps {
        let u = controller.compute_control(&system, &x);
        let dx = system.dynamics(&x, &u, t) * dt;
        x = &x + &dx;
        t += dt;

        if step % 100 == 0 {
            println!("t={:.1}s: è§’åº¦={:.3}rad, è§’é€Ÿåº¦={:.3}rad/s, æ§åˆ¶={:.3}N",
                t, x[0], x[1], u[0]);
        }
    }

    println!("æœ€ç»ˆçŠ¶æ€: è§’åº¦={:.3}rad, è§’é€Ÿåº¦={:.3}rad/s", x[0], x[1]);
}
```

## 9. ç›¸å…³ç†è®º

### 9.1 ä¸çº¿æ€§æ§åˆ¶ç†è®ºçš„å…³ç³»

éçº¿æ€§æ§åˆ¶ç†è®ºæ˜¯çº¿æ€§æ§åˆ¶ç†è®ºçš„æ¨å¹¿ï¼š

1. **å±€éƒ¨çº¿æ€§åŒ–**ï¼šåœ¨å¹³è¡¡ç‚¹é™„è¿‘å¯ä»¥çº¿æ€§åŒ–
2. **å…¨å±€æ€§è´¨**ï¼šéçº¿æ€§æ§åˆ¶ç†è®ºå¤„ç†å…¨å±€æ€§è´¨
3. **è®¾è®¡æ–¹æ³•**ï¼šæä¾›äº†ä¸“é—¨çš„éçº¿æ€§è®¾è®¡æ–¹æ³•

### 9.2 ä¸ç°ä»£æ§åˆ¶ç†è®ºçš„å…³ç³»

éçº¿æ€§æ§åˆ¶ç†è®ºåˆ©ç”¨ç°ä»£æ§åˆ¶ç†è®ºçš„æ¦‚å¿µï¼š

1. **çŠ¶æ€ç©ºé—´æ–¹æ³•**ï¼šä½¿ç”¨çŠ¶æ€ç©ºé—´æè¿°ç³»ç»Ÿ
2. **æé›…æ™®è¯ºå¤«ç†è®º**ï¼šåŸºäºæé›…æ™®è¯ºå¤«ç¨³å®šæ€§ç†è®º
3. **æœ€ä¼˜æ§åˆ¶**ï¼šç»“åˆæœ€ä¼˜æ§åˆ¶ç†è®º

### 9.3 ä¸é²æ£’æ§åˆ¶çš„å…³ç³»

éçº¿æ€§æ§åˆ¶ç†è®ºä¸é²æ£’æ§åˆ¶ç†è®ºäº’è¡¥ï¼š

1. **ä¸ç¡®å®šæ€§å¤„ç†**ï¼šå¤„ç†éçº¿æ€§ç³»ç»Ÿä¸­çš„ä¸ç¡®å®šæ€§
2. **è‡ªé€‚åº”æ§åˆ¶**ï¼šç»“åˆè‡ªé€‚åº”æ§åˆ¶å¤„ç†æœªçŸ¥å‚æ•°
3. **æ»‘æ¨¡æ§åˆ¶**ï¼šæä¾›é²æ£’æ€§ä¿è¯

## 10. å‚è€ƒæ–‡çŒ®

1. Khalil, H. K. (2015). Nonlinear Systems. Pearson.
2. Slotine, J. J. E., & Li, W. (1991). Applied Nonlinear Control. Prentice Hall.
3. Isidori, A. (1995). Nonlinear Control Systems. Springer.
4. Vidyasagar, M. (2002). Nonlinear Systems Analysis. SIAM.
5. Krstic, M., Kanellakopoulos, I., & Kokotovic, P. V. (1995). Nonlinear and Adaptive Control Design. John Wiley & Sons.
6. Sastry, S. (1999). Nonlinear Systems: Analysis, Stability, and Control. Springer.
7. Sepulchre, R., Jankovic, M., & Kokotovic, P. V. (1997). Constructive Nonlinear Control. Springer.
8. Utkin, V. I. (1992). Sliding Modes in Control and Optimization. Springer.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [05.2.1 ç°ä»£æ§åˆ¶ç†è®º](05.2.1_ç°ä»£æ§åˆ¶ç†è®º.md)
- [05.2.2 æœ€ä¼˜æ§åˆ¶ç†è®º](05.2.2_æœ€ä¼˜æ§åˆ¶ç†è®º.md)
- [05.2.3 é²æ£’æ§åˆ¶ç†è®º](05.2.3_é²æ£’æ§åˆ¶ç†è®º.md)
- [05.3.2 è‡ªé€‚åº”æ§åˆ¶ç†è®º](05.3.2_è‡ªé€‚åº”æ§åˆ¶ç†è®º.md)
