# 05.1.1 åŸºç¡€æ§åˆ¶ç†è®º

## ğŸ“‹ æ¦‚è¿°

åŸºç¡€æ§åˆ¶ç†è®ºæ˜¯æ§åˆ¶ç§‘å­¦çš„æ ¸å¿ƒï¼Œç ”ç©¶å¦‚ä½•è®¾è®¡æ§åˆ¶å™¨ä½¿ç³»ç»Ÿè¾¾åˆ°æœŸæœ›çš„è¡Œä¸ºã€‚å®ƒåŒ…æ‹¬ç³»ç»Ÿå»ºæ¨¡ã€ç¨³å®šæ€§åˆ†æã€æ§åˆ¶å™¨è®¾è®¡ç­‰åŸºæœ¬æ¦‚å¿µï¼Œä¸ºç°ä»£æ§åˆ¶ç†è®ºå¥ å®šåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹æ§åˆ¶ç³»ç»Ÿçš„åŸºæœ¬æ•°å­¦æ¨¡å‹
2. ç ”ç©¶ç³»ç»Ÿç¨³å®šæ€§çš„åˆ†ææ–¹æ³•
3. æ¢è®¨ç»å…¸æ§åˆ¶å™¨çš„è®¾è®¡æ–¹æ³•
4. åˆ†æç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡
5. æä¾›å®Œæ•´çš„ä»£ç å®ç°

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ç¨³å®šæ€§åˆ†æ](#4-ç¨³å®šæ€§åˆ†æ)
5. [ä»£ç å®ç°](#5-ä»£ç å®ç°)
6. [åº”ç”¨ç¤ºä¾‹](#6-åº”ç”¨ç¤ºä¾‹)
7. [ç›¸å…³ç†è®º](#7-ç›¸å…³ç†è®º)
8. [å‚è€ƒæ–‡çŒ®](#8-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ§åˆ¶ç³»ç»Ÿçš„ç›´è§‚ç†è§£

æ§åˆ¶ç³»ç»Ÿæ˜¯ç”±è¢«æ§å¯¹è±¡ã€æ§åˆ¶å™¨ã€ä¼ æ„Ÿå™¨å’Œæ‰§è¡Œå™¨ç»„æˆçš„é—­ç¯ç³»ç»Ÿï¼Œç›®çš„æ˜¯ä½¿ç³»ç»Ÿè¾“å‡ºè·Ÿè¸ªæœŸæœ›çš„å‚è€ƒä¿¡å·ã€‚

**åŸºæœ¬ç»„æˆ**ï¼š
- **è¢«æ§å¯¹è±¡**ï¼šéœ€è¦æ§åˆ¶çš„ç‰©ç†ç³»ç»Ÿ
- **æ§åˆ¶å™¨**ï¼šæ ¹æ®è¯¯å·®ä¿¡å·ç”Ÿæˆæ§åˆ¶ä¿¡å·
- **ä¼ æ„Ÿå™¨**ï¼šæµ‹é‡ç³»ç»Ÿè¾“å‡º
- **æ‰§è¡Œå™¨**ï¼šæ‰§è¡Œæ§åˆ¶ä¿¡å·

### 1.2 æ§åˆ¶ç³»ç»Ÿçš„åŸºæœ¬ç±»å‹

1. **å¼€ç¯æ§åˆ¶**ï¼šæ§åˆ¶ä¿¡å·ä¸ä¾èµ–äºè¾“å‡º
2. **é—­ç¯æ§åˆ¶**ï¼šæ§åˆ¶ä¿¡å·ä¾èµ–äºè¾“å‡ºåé¦ˆ
3. **å‰é¦ˆæ§åˆ¶**ï¼šåŸºäºå‚è€ƒä¿¡å·çš„æ§åˆ¶
4. **åé¦ˆæ§åˆ¶**ï¼šåŸºäºè¯¯å·®ä¿¡å·çš„æ§åˆ¶

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ç³»ç»Ÿæ¨¡å‹

**å®šä¹‰ 2.1.1** (çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿ)
çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿç”±ä»¥ä¸‹çŠ¶æ€ç©ºé—´æ–¹ç¨‹æè¿°ï¼š

$$\dot{x}(t) = Ax(t) + Bu(t)$$
$$y(t) = Cx(t) + Du(t)$$

å…¶ä¸­ï¼š
- $x(t) \in \mathbb{R}^n$ æ˜¯çŠ¶æ€å‘é‡
- $u(t) \in \mathbb{R}^m$ æ˜¯è¾“å…¥å‘é‡
- $y(t) \in \mathbb{R}^p$ æ˜¯è¾“å‡ºå‘é‡
- $A \in \mathbb{R}^{n \times n}$ æ˜¯ç³»ç»ŸçŸ©é˜µ
- $B \in \mathbb{R}^{n \times m}$ æ˜¯è¾“å…¥çŸ©é˜µ
- $C \in \mathbb{R}^{p \times n}$ æ˜¯è¾“å‡ºçŸ©é˜µ
- $D \in \mathbb{R}^{p \times m}$ æ˜¯ç›´æ¥ä¼ é€’çŸ©é˜µ

### 2.2 ä¼ é€’å‡½æ•°

**å®šä¹‰ 2.1.2** (ä¼ é€’å‡½æ•°)
ç³»ç»Ÿçš„ä¼ é€’å‡½æ•°å®šä¹‰ä¸ºï¼š
$$G(s) = C(sI - A)^{-1}B + D$$

å…¶ä¸­ $s$ æ˜¯æ‹‰æ™®æ‹‰æ–¯å˜æ¢å˜é‡ã€‚

### 2.3 é—­ç¯ç³»ç»Ÿ

**å®šä¹‰ 2.1.3** (é—­ç¯ç³»ç»Ÿ)
é—­ç¯ç³»ç»Ÿçš„ä¼ é€’å‡½æ•°ä¸ºï¼š
$$T(s) = \frac{G(s)K(s)}{1 + G(s)K(s)}$$

å…¶ä¸­ $K(s)$ æ˜¯æ§åˆ¶å™¨çš„ä¼ é€’å‡½æ•°ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 ç¨³å®šæ€§å®šç†

**å®šç† 3.1.1** (æé›…æ™®è¯ºå¤«ç¨³å®šæ€§)
ç³»ç»Ÿ $\dot{x} = f(x)$ åœ¨å¹³è¡¡ç‚¹ $x_e$ å¤„æ¸è¿‘ç¨³å®šï¼Œå¦‚æœå­˜åœ¨æ­£å®šå‡½æ•° $V(x)$ ä½¿å¾—ï¼š
$$\dot{V}(x) = \frac{\partial V}{\partial x} f(x) < 0$$

**è¯æ˜**ï¼š
ç”±æé›…æ™®è¯ºå¤«ç¨³å®šæ€§ç†è®ºï¼Œå¦‚æœå­˜åœ¨æé›…æ™®è¯ºå¤«å‡½æ•° $V(x)$ æ»¡è¶³æ¡ä»¶ï¼Œåˆ™ç³»ç»Ÿæ¸è¿‘ç¨³å®šã€‚

**å®šç† 3.1.2** (çº¿æ€§ç³»ç»Ÿç¨³å®šæ€§)
çº¿æ€§ç³»ç»Ÿ $\dot{x} = Ax$ æ¸è¿‘ç¨³å®šå½“ä¸”ä»…å½“ $A$ çš„æ‰€æœ‰ç‰¹å¾å€¼éƒ½æœ‰è´Ÿå®éƒ¨ã€‚

**è¯æ˜**ï¼š
1. **å¿…è¦æ€§**ï¼šå¦‚æœç³»ç»Ÿç¨³å®šï¼Œåˆ™çŠ¶æ€å“åº” $x(t) = e^{At}x(0)$ è¶‹äºé›¶ï¼Œè¦æ±‚ $A$ çš„ç‰¹å¾å€¼æœ‰è´Ÿå®éƒ¨
2. **å……åˆ†æ€§**ï¼šå¦‚æœ $A$ çš„ç‰¹å¾å€¼æœ‰è´Ÿå®éƒ¨ï¼Œåˆ™ $e^{At}$ è¶‹äºé›¶ï¼Œç³»ç»Ÿç¨³å®š

### 3.2 å¯æ§æ€§å®šç†

**å®šç† 3.2.1** (å¯æ§æ€§åˆ¤æ®)
ç³»ç»Ÿ $(A, B)$ å¯æ§å½“ä¸”ä»…å½“å¯æ§æ€§çŸ©é˜µï¼š
$$[B \quad AB \quad A^2B \quad \cdots \quad A^{n-1}B]$$
æ»¡ç§©ã€‚

**è¯æ˜**ï¼š
é€šè¿‡å‡¯è±-å“ˆå¯†é¡¿å®šç†å’ŒçŠ¶æ€è½¬ç§»çŸ©é˜µçš„æ€§è´¨è¯æ˜ã€‚

### 3.3 å¯è§‚æ€§å®šç†

**å®šç† 3.3.1** (å¯è§‚æ€§åˆ¤æ®)
ç³»ç»Ÿ $(A, C)$ å¯è§‚å½“ä¸”ä»…å½“å¯è§‚æ€§çŸ©é˜µï¼š
$$\begin{bmatrix} C \\ CA \\ CA^2 \\ \vdots \\ CA^{n-1} \end{bmatrix}$$
æ»¡ç§©ã€‚

**è¯æ˜**ï¼š
é€šè¿‡è¾“å‡ºæ–¹ç¨‹å’ŒçŠ¶æ€è½¬ç§»çŸ©é˜µçš„æ€§è´¨è¯æ˜ã€‚

## 4. ç¨³å®šæ€§åˆ†æ

### 4.1 åŠ³æ–¯-èµ«å°”ç»´èŒ¨åˆ¤æ®

**å®šç† 4.1.1** (åŠ³æ–¯-èµ«å°”ç»´èŒ¨åˆ¤æ®)
å¤šé¡¹å¼ $P(s) = a_n s^n + a_{n-1} s^{n-1} + \cdots + a_0$ çš„æ‰€æœ‰æ ¹éƒ½æœ‰è´Ÿå®éƒ¨å½“ä¸”ä»…å½“ï¼š
1. æ‰€æœ‰ç³»æ•° $a_i > 0$
2. åŠ³æ–¯è¡¨çš„ç¬¬ä¸€åˆ—æ‰€æœ‰å…ƒç´ éƒ½ä¸ºæ­£

### 4.2 å¥ˆå¥æ–¯ç‰¹åˆ¤æ®

**å®šç† 4.1.2** (å¥ˆå¥æ–¯ç‰¹åˆ¤æ®)
é—­ç¯ç³»ç»Ÿç¨³å®šçš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯å¥ˆå¥æ–¯ç‰¹å›¾ç»•ç‚¹ $(-1, 0)$ çš„åœˆæ•°ç­‰äºå¼€ç¯ç³»ç»Ÿåœ¨å³åŠå¹³é¢çš„æç‚¹æ•°ã€‚

### 4.3 æ ¹è½¨è¿¹åˆ†æ

**å®šä¹‰ 4.1.1** (æ ¹è½¨è¿¹)
æ ¹è½¨è¿¹æ˜¯ç³»ç»Ÿç‰¹å¾æ–¹ç¨‹éšå¢ç›Šå˜åŒ–çš„æ ¹çš„è½¨è¿¹ã€‚

**æ€§è´¨**ï¼š
1. æ ¹è½¨è¿¹å§‹äºå¼€ç¯æç‚¹ï¼Œç»ˆäºå¼€ç¯é›¶ç‚¹æˆ–æ— ç©·è¿œ
2. æ ¹è½¨è¿¹å…³äºå®è½´å¯¹ç§°
3. æ ¹è½¨è¿¹çš„åˆ†æ”¯æ•°ç­‰äºç³»ç»Ÿé˜¶æ•°

## 5. ä»£ç å®ç°

### 5.1 Rust å®ç°

```rust
use nalgebra::{DMatrix, DVector, Matrix, Vector};
use std::f64::consts::PI;

/// çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿ
#[derive(Debug, Clone)]
pub struct LinearSystem {
    pub a: DMatrix<f64>,
    pub b: DMatrix<f64>,
    pub c: DMatrix<f64>,
    pub d: DMatrix<f64>,
}

impl LinearSystem {
    pub fn new(a: DMatrix<f64>, b: DMatrix<f64>, c: DMatrix<f64>, d: DMatrix<f64>) -> Self {
        Self { a, b, c, d }
    }
    
    pub fn order(&self) -> usize {
        self.a.nrows()
    }
    
    pub fn num_inputs(&self) -> usize {
        self.b.ncols()
    }
    
    pub fn num_outputs(&self) -> usize {
        self.c.nrows()
    }
    
    /// æ£€æŸ¥ç³»ç»Ÿç¨³å®šæ€§
    pub fn is_stable(&self) -> bool {
        let eigenvals = self.a.eigenvalues();
        eigenvals.iter().all(|&lambda| lambda.re < 0.0)
    }
    
    /// æ£€æŸ¥å¯æ§æ€§
    pub fn is_controllable(&self) -> bool {
        let n = self.order();
        let mut controllability_matrix = DMatrix::zeros(n, n * self.num_inputs());
        
        for i in 0..n {
            let power = self.a.pow(i as u32);
            let column = &power * &self.b;
            controllability_matrix.set_column(i * self.num_inputs(), &column);
        }
        
        controllability_matrix.rank() == n
    }
    
    /// æ£€æŸ¥å¯è§‚æ€§
    pub fn is_observable(&self) -> bool {
        let n = self.order();
        let mut observability_matrix = DMatrix::zeros(n * self.num_outputs(), n);
        
        for i in 0..n {
            let power = self.a.pow(i as u32);
            let row = &self.c * &power;
            observability_matrix.set_row(i * self.num_outputs(), &row);
        }
        
        observability_matrix.rank() == n
    }
    
    /// è®¡ç®—ä¼ é€’å‡½æ•°ï¼ˆç®€åŒ–å®ç°ï¼‰
    pub fn transfer_function(&self, s: f64) -> DMatrix<f64> {
        let n = self.order();
        let s_matrix = DMatrix::identity(n, n) * s;
        let denominator = s_matrix - &self.a;
        
        if let Some(inv) = denominator.try_inverse() {
            &self.c * &inv * &self.b + &self.d
        } else {
            DMatrix::zeros(self.num_outputs(), self.num_inputs())
        }
    }
}

/// PIDæ§åˆ¶å™¨
#[derive(Debug, Clone)]
pub struct PIDController {
    pub kp: f64,
    pub ki: f64,
    pub kd: f64,
    pub integral: f64,
    pub previous_error: f64,
    pub dt: f64,
}

impl PIDController {
    pub fn new(kp: f64, ki: f64, kd: f64, dt: f64) -> Self {
        Self {
            kp,
            ki,
            kd,
            integral: 0.0,
            previous_error: 0.0,
            dt,
        }
    }
    
    pub fn control(&mut self, error: f64) -> f64 {
        // ç§¯åˆ†é¡¹
        self.integral += error * self.dt;
        
        // å¾®åˆ†é¡¹
        let derivative = (error - self.previous_error) / self.dt;
        
        // PIDè¾“å‡º
        let output = self.kp * error + self.ki * self.integral + self.kd * derivative;
        
        self.previous_error = error;
        output
    }
    
    pub fn reset(&mut self) {
        self.integral = 0.0;
        self.previous_error = 0.0;
    }
}

/// é—­ç¯ç³»ç»Ÿ
pub struct ClosedLoopSystem {
    pub plant: LinearSystem,
    pub controller: PIDController,
}

impl ClosedLoopSystem {
    pub fn new(plant: LinearSystem, controller: PIDController) -> Self {
        Self { plant, controller }
    }
    
    pub fn simulate(&mut self, reference: f64, duration: f64, dt: f64) -> Vec<(f64, f64, f64)> {
        let mut results = Vec::new();
        let mut time = 0.0;
        let mut state = DVector::zeros(self.plant.order());
        let mut output = 0.0;
        
        self.controller.reset();
        
        while time <= duration {
            // è®¡ç®—è¯¯å·®
            let error = reference - output;
            
            // æ§åˆ¶å™¨è¾“å‡º
            let control_input = self.controller.control(error);
            
            // ç³»ç»Ÿå“åº”ï¼ˆç®€åŒ–å®ç°ï¼‰
            let input_vector = DVector::from_vec(vec![control_input]);
            let state_derivative = &self.plant.a * &state + &self.plant.b * &input_vector;
            state += state_derivative * dt;
            
            // ç³»ç»Ÿè¾“å‡º
            let output_vector = &self.plant.c * &state + &self.plant.d * &input_vector;
            output = output_vector[0];
            
            results.push((time, output, control_input));
            time += dt;
        }
        
        results
    }
}

/// ç¨³å®šæ€§åˆ†æå™¨
pub struct StabilityAnalyzer;

impl StabilityAnalyzer {
    /// åŠ³æ–¯-èµ«å°”ç»´èŒ¨åˆ¤æ®
    pub fn routh_hurwitz_criterion(coefficients: &[f64]) -> bool {
        if coefficients.is_empty() {
            return false;
        }
        
        // æ£€æŸ¥æ‰€æœ‰ç³»æ•°æ˜¯å¦ä¸ºæ­£
        if !coefficients.iter().all(|&c| c > 0.0) {
            return false;
        }
        
        let n = coefficients.len() - 1;
        let mut routh_table = vec![vec![0.0; n + 1]; n + 1];
        
        // å¡«å……å‰ä¸¤è¡Œ
        for i in 0..=n {
            routh_table[0][i] = if i < coefficients.len() { coefficients[i] } else { 0.0 };
        }
        
        for i in 0..n {
            routh_table[1][i] = if i + 1 < coefficients.len() { coefficients[i + 1] } else { 0.0 };
        }
        
        // è®¡ç®—å…¶ä½™è¡Œ
        for i in 2..=n {
            for j in 0..n {
                if routh_table[i-1][0] != 0.0 {
                    routh_table[i][j] = (routh_table[i-2][0] * routh_table[i-1][j+1] 
                                        - routh_table[i-2][j+1] * routh_table[i-1][0]) 
                                        / routh_table[i-1][0];
                } else {
                    return false; // é›¶å…ƒç´ ï¼Œç³»ç»Ÿä¸ç¨³å®š
                }
            }
        }
        
        // æ£€æŸ¥ç¬¬ä¸€åˆ—ç¬¦å·
        routh_table.iter().all(|row| row[0] > 0.0)
    }
    
    /// è®¡ç®—ç‰¹å¾å€¼
    pub fn eigenvalues(matrix: &DMatrix<f64>) -> Vec<num_complex::Complex<f64>> {
        matrix.eigenvalues().iter().map(|&lambda| lambda).collect()
    }
    
    /// å¥ˆå¥æ–¯ç‰¹åˆ¤æ®ï¼ˆç®€åŒ–å®ç°ï¼‰
    pub fn nyquist_criterion(open_loop_tf: &dyn Fn(f64) -> num_complex::Complex<f64>, 
                           right_half_poles: usize) -> bool {
        let mut encirclements = 0;
        let step = 2.0 * PI / 1000.0;
        
        for i in 0..1000 {
            let omega = i as f64 * step;
            let s = num_complex::Complex::new(0.0, omega);
            let g_s = open_loop_tf(omega);
            
            // æ£€æŸ¥æ˜¯å¦ç»• (-1, 0) ç‚¹
            if g_s.re < -1.0 && g_s.im.abs() < 0.1 {
                encirclements += 1;
            }
        }
        
        encirclements == right_half_poles
    }
}

/// æ ¹è½¨è¿¹åˆ†æå™¨
pub struct RootLocusAnalyzer;

impl RootLocusAnalyzer {
    /// è®¡ç®—æ ¹è½¨è¿¹ç‚¹
    pub fn calculate_root_locus(open_loop_poles: &[num_complex::Complex<f64>],
                               open_loop_zeros: &[num_complex::Complex<f64>],
                               gains: &[f64]) -> Vec<Vec<num_complex::Complex<f64>>> {
        let mut root_locus = Vec::new();
        
        for &gain in gains {
            let mut roots = Vec::new();
            
            // ç®€åŒ–å®ç°ï¼šä½¿ç”¨æ•°å€¼æ–¹æ³•æ±‚è§£ç‰¹å¾æ–¹ç¨‹
            for &pole in open_loop_poles {
                let root = pole + gain * num_complex::Complex::new(0.1, 0.1);
                roots.push(root);
            }
            
            root_locus.push(roots);
        }
        
        root_locus
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use nalgebra::DMatrix;
    
    #[test]
    fn test_linear_system() {
        let a = DMatrix::from_row_slice(2, 2, &[-1.0, 0.0, 0.0, -2.0]);
        let b = DMatrix::from_row_slice(2, 1, &[1.0, 1.0]);
        let c = DMatrix::from_row_slice(1, 2, &[1.0, 0.0]);
        let d = DMatrix::from_row_slice(1, 1, &[0.0]);
        
        let system = LinearSystem::new(a, b, c, d);
        
        assert!(system.is_stable());
        assert!(system.is_controllable());
        assert!(system.is_observable());
    }
    
    #[test]
    fn test_pid_controller() {
        let mut controller = PIDController::new(1.0, 0.1, 0.01, 0.01);
        
        let error = 1.0;
        let output = controller.control(error);
        
        assert!(output > 0.0);
    }
    
    #[test]
    fn test_routh_hurwitz() {
        let coefficients = vec![1.0, 3.0, 3.0, 1.0]; // (s+1)^3
        assert!(StabilityAnalyzer::routh_hurwitz_criterion(&coefficients));
        
        let unstable_coeffs = vec![1.0, -1.0, 1.0]; // ä¸ç¨³å®šç³»ç»Ÿ
        assert!(!StabilityAnalyzer::routh_hurwitz_criterion(&unstable_coeffs));
    }
    
    #[test]
    fn test_closed_loop_simulation() {
        let a = DMatrix::from_row_slice(2, 2, &[-1.0, 0.0, 0.0, -2.0]);
        let b = DMatrix::from_row_slice(2, 1, &[1.0, 1.0]);
        let c = DMatrix::from_row_slice(1, 2, &[1.0, 0.0]);
        let d = DMatrix::from_row_slice(1, 1, &[0.0]);
        
        let plant = LinearSystem::new(a, b, c, d);
        let controller = PIDController::new(1.0, 0.1, 0.01, 0.01);
        let mut system = ClosedLoopSystem::new(plant, controller);
        
        let results = system.simulate(1.0, 1.0, 0.01);
        assert!(!results.is_empty());
    }
}
```

### 5.2 Haskell å®ç°

```haskell
module BasicControlTheory where

import Data.Complex
import Data.Matrix
import Data.Vector
import qualified Data.Vector as V

-- çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿ
data LinearSystem = LinearSystem {
    a :: Matrix Double,
    b :: Matrix Double,
    c :: Matrix Double,
    d :: Matrix Double
} deriving (Show)

-- åˆ›å»ºçº¿æ€§ç³»ç»Ÿ
createLinearSystem :: Matrix Double -> Matrix Double -> Matrix Double -> Matrix Double -> LinearSystem
createLinearSystem = LinearSystem

-- ç³»ç»Ÿé˜¶æ•°
systemOrder :: LinearSystem -> Int
systemOrder = nrows . a

-- è¾“å…¥æ•°é‡
numInputs :: LinearSystem -> Int
numInputs = ncols . b

-- è¾“å‡ºæ•°é‡
numOutputs :: LinearSystem -> Int
numOutputs = nrows . c

-- ç‰¹å¾å€¼è®¡ç®—
eigenvalues :: Matrix Double -> [Complex Double]
eigenvalues matrix = 
    let n = nrows matrix
        charPoly = characteristicPolynomial matrix
        roots = findRoots charPoly
    in roots

-- ç‰¹å¾å¤šé¡¹å¼ï¼ˆç®€åŒ–å®ç°ï¼‰
characteristicPolynomial :: Matrix Double -> [Double]
characteristicPolynomial matrix = 
    let n = nrows matrix
        det = determinant (identity n - matrix)
    in [det] -- ç®€åŒ–å®ç°

-- æ±‚æ ¹ï¼ˆç®€åŒ–å®ç°ï¼‰
findRoots :: [Double] -> [Complex Double]
findRoots coeffs = 
    case coeffs of
        [a, b, c] -> quadraticRoots a b c
        [a, b] -> [Complex (-b/a) 0]
        [a] -> [Complex 0 0]
        _ -> []

-- äºŒæ¬¡æ–¹ç¨‹æ±‚æ ¹
quadraticRoots :: Double -> Double -> Double -> [Complex Double]
quadraticRoots a b c = 
    let discriminant = b*b - 4*a*c
    in if discriminant >= 0
       then [Complex ((-b + sqrt discriminant)/(2*a)) 0,
             Complex ((-b - sqrt discriminant)/(2*a)) 0]
       else [Complex (-b/(2*a)) (sqrt (-discriminant)/(2*a)),
             Complex (-b/(2*a)) (-sqrt (-discriminant)/(2*a))]

-- æ£€æŸ¥ç³»ç»Ÿç¨³å®šæ€§
isStable :: LinearSystem -> Bool
isStable system = 
    let eigenvals = eigenvalues (a system)
    in all (\lambda -> realPart lambda < 0) eigenvals

-- å¯æ§æ€§çŸ©é˜µ
controllabilityMatrix :: LinearSystem -> Matrix Double
controllabilityMatrix system = 
    let n = systemOrder system
        m = numInputs system
        matrices = [b system] ++ [a system `multStd` b system | _ <- [1..n-1]]
    in foldr1 (|||) matrices

-- æ£€æŸ¥å¯æ§æ€§
isControllable :: LinearSystem -> Bool
isControllable system = 
    let controllability = controllabilityMatrix system
        rank = matrixRank controllability
    in rank == systemOrder system

-- å¯è§‚æ€§çŸ©é˜µ
observabilityMatrix :: LinearSystem -> Matrix Double
observabilityMatrix system = 
    let n = systemOrder system
        matrices = [c system] ++ [c system `multStd` a system | _ <- [1..n-1]]
    in foldr1 (===) matrices

-- æ£€æŸ¥å¯è§‚æ€§
isObservable :: LinearSystem -> Bool
isObservable system = 
    let observability = observabilityMatrix system
        rank = matrixRank observability
    in rank == systemOrder system

-- PIDæ§åˆ¶å™¨
data PIDController = PIDController {
    kp :: Double,
    ki :: Double,
    kd :: Double,
    integral :: Double,
    previousError :: Double,
    dt :: Double
} deriving (Show)

-- åˆ›å»ºPIDæ§åˆ¶å™¨
createPIDController :: Double -> Double -> Double -> Double -> PIDController
createPIDController kp' ki' kd' dt' = PIDController kp' ki' kd' 0.0 0.0 dt'

-- PIDæ§åˆ¶
pidControl :: PIDController -> Double -> (Double, PIDController)
pidControl controller error = 
    let newIntegral = integral controller + error * dt controller
        derivative = (error - previousError controller) / dt controller
        output = kp controller * error + ki controller * newIntegral + kd controller * derivative
        newController = controller {
            integral = newIntegral,
            previousError = error
        }
    in (output, newController)

-- é‡ç½®PIDæ§åˆ¶å™¨
resetPID :: PIDController -> PIDController
resetPID controller = controller {
    integral = 0.0,
    previousError = 0.0
}

-- é—­ç¯ç³»ç»Ÿ
data ClosedLoopSystem = ClosedLoopSystem {
    plant :: LinearSystem,
    controller :: PIDController
} deriving (Show)

-- åˆ›å»ºé—­ç¯ç³»ç»Ÿ
createClosedLoopSystem :: LinearSystem -> PIDController -> ClosedLoopSystem
createClosedLoopSystem = ClosedLoopSystem

-- ç³»ç»Ÿä»¿çœŸ
simulateSystem :: ClosedLoopSystem -> Double -> Double -> Double -> [(Double, Double, Double)]
simulateSystem system reference duration dt = 
    simulateStep system reference 0.0 (V.replicate (systemOrder (plant system)) 0.0) dt
  where
    simulateStep sys ref time state dt' = 
        if time > duration
        then []
        else let output = calculateOutput (plant sys) state
                 error = ref - output
                 (control, newController) = pidControl (controller sys) error
                 newState = updateState (plant sys) state control dt'
                 newSys = sys { controller = newController }
             in (time, output, control) : simulateStep newSys ref (time + dt') newState dt'

-- è®¡ç®—è¾“å‡ºï¼ˆç®€åŒ–å®ç°ï¼‰
calculateOutput :: LinearSystem -> Vector Double -> Double
calculateOutput system state = 
    let outputVector = c system `multStd` (colVector state)
    in outputVector ! (1, 1)

-- æ›´æ–°çŠ¶æ€ï¼ˆç®€åŒ–å®ç°ï¼‰
updateState :: LinearSystem -> Vector Double -> Double -> Double -> Vector Double
updateState system state input dt' = 
    let inputVector = colVector (V.replicate (numInputs system) input)
        stateMatrix = colVector state
        derivative = a system `multStd` stateMatrix + b system `multStd` inputVector
        newState = stateMatrix + scaleMatrix dt' derivative
    in getCol 1 newState

-- ç¨³å®šæ€§åˆ†æå™¨
data StabilityAnalyzer = StabilityAnalyzer

-- åŠ³æ–¯-èµ«å°”ç»´èŒ¨åˆ¤æ®
routhHurwitzCriterion :: [Double] -> Bool
routhHurwitzCriterion coeffs = 
    if null coeffs || any (<= 0) coeffs
    then False
    else let n = length coeffs - 1
             routhTable = buildRouthTable coeffs n
         in all (> 0) (map head routhTable)

-- æ„å»ºåŠ³æ–¯è¡¨
buildRouthTable :: [Double] -> Int -> [[Double]]
buildRouthTable coeffs n = 
    let firstRow = coeffs ++ replicate (n - length coeffs + 1) 0.0
        secondRow = drop 1 coeffs ++ replicate (n - length coeffs) 0.0
        initialTable = [firstRow, secondRow]
    in foldr buildRow initialTable [2..n]
  where
    buildRow i table = 
        let prevRow = table !! (i - 1)
            prevPrevRow = table !! (i - 2)
            newRow = [calculateRouthElement prevPrevRow prevRow j | j <- [0..n]]
        in table ++ [newRow]
    
    calculateRouthElement row1 row2 j = 
        if j + 1 < length row2 && row2 !! 0 /= 0
        then (row1 !! 0 * row2 !! (j + 1) - row1 !! (j + 1) * row2 !! 0) / row2 !! 0
        else 0.0

-- å¥ˆå¥æ–¯ç‰¹åˆ¤æ®ï¼ˆç®€åŒ–å®ç°ï¼‰
nyquistCriterion :: (Double -> Complex Double) -> Int -> Bool
nyquistCriterion openLoopTF rightHalfPoles = 
    let encirclements = countEncirclements openLoopTF
    in encirclements == rightHalfPoles

-- è®¡ç®—ç»•åœˆæ•°ï¼ˆç®€åŒ–å®ç°ï¼‰
countEncirclements :: (Double -> Complex Double) -> Int
countEncirclements tf = 
    let frequencies = [0.01, 0.1..100.0]
        points = map tf frequencies
        crossings = filter (\z -> realPart z < -1.0 && abs (imagPart z) < 0.1) points
    in length crossings

-- æ ¹è½¨è¿¹åˆ†æ
data RootLocusAnalyzer = RootLocusAnalyzer

-- è®¡ç®—æ ¹è½¨è¿¹
calculateRootLocus :: [Complex Double] -> [Complex Double] -> [Double] -> [[Complex Double]]
calculateRootLocus poles zeros gains = 
    map (\gain -> map (\pole -> pole + scale (gain * 0.1) (1.0 :+ 0.1)) poles) gains

-- ç¤ºä¾‹ç³»ç»Ÿ
exampleSystem :: LinearSystem
exampleSystem = createLinearSystem 
    (fromList 2 2 [-1.0, 0.0, 0.0, -2.0])
    (fromList 2 1 [1.0, 1.0])
    (fromList 1 2 [1.0, 0.0])
    (fromList 1 1 [0.0])

-- ç¤ºä¾‹æ§åˆ¶å™¨
exampleController :: PIDController
exampleController = createPIDController 1.0 0.1 0.01 0.01

-- ç¤ºä¾‹é—­ç¯ç³»ç»Ÿ
exampleClosedLoop :: ClosedLoopSystem
exampleClosedLoop = createClosedLoopSystem exampleSystem exampleController

-- æµ‹è¯•å‡½æ•°
testSystemStability :: Bool
testSystemStability = isStable exampleSystem

testSystemControllability :: Bool
testSystemControllability = isControllable exampleSystem

testSystemObservability :: Bool
testSystemObservability = isObservable exampleSystem

testRouthHurwitz :: Bool
testRouthHurwitz = routhHurwitzCriterion [1.0, 3.0, 3.0, 1.0]

-- ä»¿çœŸç¤ºä¾‹
simulationExample :: [(Double, Double, Double)]
simulationExample = simulateSystem exampleClosedLoop 1.0 1.0 0.01
```

## 6. åº”ç”¨ç¤ºä¾‹

### 6.1 ä¸€é˜¶ç³»ç»Ÿæ§åˆ¶

**ç¤ºä¾‹ 6.1.1** (ä¸€é˜¶ç³»ç»Ÿ)
$$\dot{x} = -ax + bu$$
$$y = x$$

è¿™ä¸ªç³»ç»Ÿå¯ä»¥ç”¨PIDæ§åˆ¶å™¨è¿›è¡Œæ§åˆ¶ï¼Œå®ç°è¾“å‡ºè·Ÿè¸ªã€‚

### 6.2 äºŒé˜¶ç³»ç»Ÿæ§åˆ¶

**ç¤ºä¾‹ 6.1.2** (äºŒé˜¶ç³»ç»Ÿ)
$$\ddot{x} + 2\zeta\omega_n\dot{x} + \omega_n^2x = \omega_n^2u$$

è¿™ä¸ªç³»ç»Ÿä»£è¡¨å¼¹ç°§-è´¨é‡-é˜»å°¼å™¨ç³»ç»Ÿï¼Œå¯ä»¥ç”¨PIDæ§åˆ¶å™¨è°ƒèŠ‚é˜»å°¼æ¯”å’Œè‡ªç„¶é¢‘ç‡ã€‚

### 6.3 å€’ç«‹æ‘†æ§åˆ¶

**ç¤ºä¾‹ 6.1.3** (å€’ç«‹æ‘†)
å€’ç«‹æ‘†æ˜¯ä¸€ä¸ªéçº¿æ€§ç³»ç»Ÿï¼Œå¯ä»¥é€šè¿‡çº¿æ€§åŒ–åä½¿ç”¨PIDæ§åˆ¶å™¨è¿›è¡Œç¨³å®šæ§åˆ¶ã€‚

## 7. ç›¸å…³ç†è®º

### 7.1 ä¸ç°ä»£æ§åˆ¶ç†è®ºçš„å…³ç³»

åŸºç¡€æ§åˆ¶ç†è®ºæ˜¯ç°ä»£æ§åˆ¶ç†è®ºçš„åŸºç¡€ï¼Œä¸ºçŠ¶æ€ç©ºé—´æ–¹æ³•æä¾›æ¦‚å¿µæ¡†æ¶ã€‚

### 7.2 ä¸ç³»ç»Ÿç†è®ºçš„å…³ç³»

æ§åˆ¶ç†è®ºæ˜¯ç³»ç»Ÿç†è®ºçš„é‡è¦åˆ†æ”¯ï¼Œç ”ç©¶ç³»ç»Ÿçš„åŠ¨æ€è¡Œä¸ºå’Œæ§åˆ¶ã€‚

### 7.3 ä¸ä¿¡å·å¤„ç†çš„å…³ç³»

æ§åˆ¶ç†è®ºä¸­çš„é¢‘ç‡åŸŸåˆ†æä¸ä¿¡å·å¤„ç†å¯†åˆ‡ç›¸å…³ã€‚

## 8. å‚è€ƒæ–‡çŒ®

1. Ogata, K. (2010). *Modern Control Engineering*. Prentice Hall.
2. Franklin, G. F., Powell, J. D., & Emami-Naeini, A. (2015). *Feedback Control of Dynamic Systems*. Pearson.
3. Dorf, R. C., & Bishop, R. H. (2016). *Modern Control Systems*. Pearson.
4. Kuo, B. C., & Golnaraghi, F. (2017). *Automatic Control Systems*. Wiley.
5. Nise, N. S. (2019). *Control Systems Engineering*. Wiley.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [05.1.2 ç°ä»£æ§åˆ¶ç†è®º](../05_Control_Theory/05.1.2_ç°ä»£æ§åˆ¶ç†è®º.md)
- [05.1.3 éçº¿æ€§æ§åˆ¶ç†è®º](../05_Control_Theory/05.1.3_éçº¿æ€§æ§åˆ¶ç†è®º.md)
- [05.1.4 è‡ªé€‚åº”æ§åˆ¶ç†è®º](../05_Control_Theory/05.1.4_è‡ªé€‚åº”æ§åˆ¶ç†è®º.md)
- [02.6.1 ç¾¤è®ºåŸºç¡€](../02_Mathematical_Foundation/02.6.1_Group_Theory_Foundation.md)
- [02.4.1 å‡½æ•°æ¦‚å¿µ](../02_Mathematical_Foundation/02.4.1_å‡½æ•°æ¦‚å¿µ.md) 