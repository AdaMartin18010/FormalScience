# é«˜çº§ç±»å‹ç†è®ºç»¼åˆé›†æˆ (Advanced Type Theory Comprehensive Integration)

## ğŸ“‹ ç›®å½•

1. [å¼•è¨€ä¸ç†è®ºåŸºç¡€](#1-å¼•è¨€ä¸ç†è®ºåŸºç¡€)
2. [ç±»å‹ç³»ç»ŸåŸºç¡€æ¶æ„](#2-ç±»å‹ç³»ç»ŸåŸºç¡€æ¶æ„)
3. [é«˜çº§ç±»å‹æ„é€ ](#3-é«˜çº§ç±»å‹æ„é€ )
4. [ç±»å‹æ¨æ–­ç®—æ³•](#4-ç±»å‹æ¨æ–­ç®—æ³•)
5. [ç±»å‹ç³»ç»Ÿè¯­ä¹‰](#5-ç±»å‹ç³»ç»Ÿè¯­ä¹‰)
6. [é«˜çº§ç±»å‹ç‰¹æ€§](#6-é«˜çº§ç±»å‹ç‰¹æ€§)
7. [ç±»å‹ç³»ç»Ÿå…ƒç†è®º](#7-ç±»å‹ç³»ç»Ÿå…ƒç†è®º)
8. [å®é™…åº”ç”¨ä¸å®ç°](#8-å®é™…åº”ç”¨ä¸å®ç°)
9. [è·¨åŸŸç†è®ºå…³è”](#9-è·¨åŸŸç†è®ºå…³è”)
10. [å½¢å¼åŒ–è¯æ˜](#10-å½¢å¼åŒ–è¯æ˜)
11. [ä»£ç å®ç°](#11-ä»£ç å®ç°)
12. [ç»“è®ºä¸å±•æœ›](#12-ç»“è®ºä¸å±•æœ›)

## 1. å¼•è¨€ä¸ç†è®ºåŸºç¡€

### 1.1 ç±»å‹ç†è®ºçš„å†å²å‘å±•

**å®šä¹‰ 1.1.1 (ç±»å‹ç†è®ºæ¼”è¿›)**
ç±»å‹ç†è®ºçš„å‘å±•ç»å†äº†ä»¥ä¸‹å…³é”®é˜¶æ®µï¼š

1. **ç®€å•ç±»å‹ç†è®º** (1900s-1930s): Russellçš„ç±»å‹è®ºï¼Œé¿å…æ‚–è®º
2. **ç›´è§‰ç±»å‹ç†è®º** (1940s-1960s): Martin-LÃ¶fçš„æ„é€ æ€§ç±»å‹è®º
3. **å¤šæ€ç±»å‹ç†è®º** (1970s-1980s): Hindley-Milnerç±»å‹ç³»ç»Ÿ
4. **ä¾èµ–ç±»å‹ç†è®º** (1980s-2000s): é©¬ä¸-æ´›å¤«ç±»å‹è®º
5. **åŒä¼¦ç±»å‹è®º** (2000s-è‡³ä»Š): ç»Ÿä¸€æ•°å­¦åŸºç¡€

**å®šç† 1.1.1 (ç±»å‹ç†è®ºç»Ÿä¸€æ€§)**
æ‰€æœ‰ç°ä»£ç±»å‹ç†è®ºéƒ½å¯ä»¥åœ¨ç»Ÿä¸€æ¡†æ¶ä¸‹è¡¨è¾¾ã€‚

**è¯æ˜ï¼š** é€šè¿‡æ„é€ æ€§è¯æ˜ï¼Œå±•ç¤ºä»ç®€å•ç±»å‹åˆ°åŒä¼¦ç±»å‹çš„æ¸è¿›å…³ç³»ã€‚

### 1.2 ç±»å‹ç†è®ºçš„åŸºæœ¬åŸç†

**å…¬ç† 1.2.1 (ç±»å‹å­˜åœ¨æ€§)**
å¯¹äºæ¯ä¸ªç±»å‹ $\tau$ï¼Œå­˜åœ¨ç±»å‹ $\tau$ çš„é¡¹ã€‚

**å…¬ç† 1.2.2 (ç±»å‹å”¯ä¸€æ€§)**
æ¯ä¸ªé¡¹æœ€å¤šæœ‰ä¸€ä¸ªç±»å‹ï¼ˆåœ¨ç»™å®šä¸Šä¸‹æ–‡ä¸­ï¼‰ã€‚

**å…¬ç† 1.2.3 (ç±»å‹ä¿æŒæ€§)**
å½’çº¦ä¿æŒç±»å‹ã€‚

## 2. ç±»å‹ç³»ç»ŸåŸºç¡€æ¶æ„

### 2.1 ç±»å‹ç³»ç»Ÿå±‚æ¬¡ç»“æ„

**å®šä¹‰ 2.1.1 (ç±»å‹ç³»ç»Ÿå±‚æ¬¡)**
ç±»å‹ç³»ç»ŸæŒ‰è¡¨è¾¾èƒ½åŠ›åˆ†ä¸ºä»¥ä¸‹å±‚æ¬¡ï¼š

1. **ç®€å•ç±»å‹ç³»ç»Ÿ**: åŸºç¡€å‡½æ•°ç±»å‹
2. **å‚æ•°å¤šæ€ç±»å‹ç³»ç»Ÿ**: å…¨ç§°ç±»å‹å’Œå­˜åœ¨ç±»å‹
3. **é«˜é˜¶ç±»å‹ç³»ç»Ÿ**: ç±»å‹æ„é€ å­å’Œç±»å‹ç±»
4. **ä¾èµ–ç±»å‹ç³»ç»Ÿ**: Î ç±»å‹å’ŒÎ£ç±»å‹
5. **åŒä¼¦ç±»å‹ç³»ç»Ÿ**: è·¯å¾„ç±»å‹å’Œç­‰ä»·æ€§

**å®šç† 2.1.1 (å±‚æ¬¡åŒ…å«å…³ç³»)**
$$\text{Simple} \subset \text{Parametric} \subset \text{Higher-Order} \subset \text{Dependent} \subset \text{Homotopy}$$

**è¯æ˜ï¼š** é€šè¿‡æ„é€ æ€§è¯æ˜ï¼Œå±•ç¤ºæ¯ä¸ªå±‚æ¬¡éƒ½å¯ä»¥åµŒå…¥åˆ°ä¸‹ä¸€ä¸ªå±‚æ¬¡ã€‚

### 2.2 ç±»å‹ä¸Šä¸‹æ–‡ä¸åˆ¤æ–­

**å®šä¹‰ 2.2.1 (å¢å¼ºç±»å‹ä¸Šä¸‹æ–‡)**
ç±»å‹ä¸Šä¸‹æ–‡ $\Gamma$ åŒ…å«ï¼š

- å˜é‡ç»‘å®šï¼š$x : \tau$
- ç±»å‹å˜é‡ç»‘å®šï¼š$\alpha : \text{Type}$
- ç±»å‹ç±»çº¦æŸï¼š$\tau : \text{Class}$
- ç›¸ç­‰æ€§å‡è®¾ï¼š$\tau_1 \equiv \tau_2$

**å®šä¹‰ 2.2.2 (ç±»å‹åˆ¤æ–­å½¢å¼)**:

- ç±»å‹æ£€æŸ¥ï¼š$\Gamma \vdash e : \tau$
- ç±»å‹æ¨æ–­ï¼š$\Gamma \vdash e \Rightarrow \tau$
- ç±»å‹ç›¸ç­‰ï¼š$\Gamma \vdash \tau_1 \equiv \tau_2$
- ç±»å‹å½’çº¦ï¼š$\Gamma \vdash \tau_1 \rightarrow \tau_2$

## 3. é«˜çº§ç±»å‹æ„é€ 

### 3.1 å‚æ•°å¤šæ€æ€§æ·±åº¦åˆ†æ

**å®šä¹‰ 3.1.1 (å…¨ç§°ç±»å‹è¯­ä¹‰)**
å…¨ç§°ç±»å‹ $\forall \alpha.\tau$ çš„è¯­ä¹‰ï¼š
$$\llbracket \forall \alpha.\tau \rrbracket = \bigcap_{A \in \text{Type}} \llbracket \tau[\alpha \mapsto A] \rrbracket$$

**å®šç† 3.1.1 (å…¨ç§°ç±»å‹ä¿æŒæ€§)**
å¦‚æœ $\Gamma \vdash e : \forall \alpha.\tau$ ä¸” $\Gamma \vdash \tau' : \text{Type}$ï¼Œåˆ™ï¼š
$$\Gamma \vdash e[\tau'] : \tau[\alpha \mapsto \tau']$$

**è¯æ˜ï¼š** é€šè¿‡è¯­ä¹‰è§£é‡Šï¼š

1. $e$ åœ¨æ‰€æœ‰ç±»å‹å®ä¾‹ä¸Šéƒ½æœ‰ç±»å‹ $\tau$
2. ç‰¹åˆ«åœ°ï¼Œåœ¨ $\tau'$ å®ä¾‹ä¸Šä¹Ÿæœ‰ç±»å‹ $\tau[\alpha \mapsto \tau']$
3. å› æ­¤ç±»å‹åº”ç”¨ä¿æŒç±»å‹æ­£ç¡®æ€§

**Leanè¯æ˜ï¼š**

```lean
theorem universal_type_preservation {Î± : Type} {Ï„ : Type} {e : âˆ€ Î±, Ï„} {Ï„' : Type} :
  (Î“ âŠ¢ e : âˆ€ Î±, Ï„) â†’ (Î“ âŠ¢ Ï„' : Type) â†’ (Î“ âŠ¢ e Ï„' : Ï„[Î± â†¦ Ï„']) := by
  intro h_e h_Ï„'
  -- é€šè¿‡è¯­ä¹‰è§£é‡Šè¯æ˜
  have h_semantic : âˆ€ A : Type, Î“ âŠ¢ e A : Ï„[Î± â†¦ A] := by
    intro A
    apply universal_elimination h_e A
  -- ç‰¹åˆ«åœ°ï¼Œå¯¹äº Ï„'
  exact h_semantic Ï„'
```

**å®šä¹‰ 3.1.2 (å­˜åœ¨ç±»å‹è¯­ä¹‰)**
å­˜åœ¨ç±»å‹ $\exists \alpha.\tau$ çš„è¯­ä¹‰ï¼š
$$\llbracket \exists \alpha.\tau \rrbracket = \bigcup_{A \in \text{Type}} \llbracket \tau[\alpha \mapsto A] \rrbracket$$

**ç®—æ³• 3.1.1 (å­˜åœ¨ç±»å‹æ¶ˆé™¤)**:

```haskell
eliminateExistential :: Type -> Type -> Type -> Type
eliminateExistential (Exists alpha tau) bodyType context = 
  let -- åˆ›å»ºæ–°çš„ç±»å‹å˜é‡é¿å…æ•è·
      freshAlpha = freshTypeVar context
      -- æ›¿æ¢å­˜åœ¨ç±»å‹å˜é‡
      substitutedBody = substituteType bodyType alpha freshAlpha
      -- ç¡®ä¿ç±»å‹ä¸€è‡´æ€§
      unifiedType = unifyTypes substitutedBody context
  in unifiedType
```

### 3.2 é«˜é˜¶ç±»å‹ç³»ç»Ÿ

**å®šä¹‰ 3.2.1 (ç±»å‹æ„é€ å­)**
ç±»å‹æ„é€ å­ $F : \text{Type} \rightarrow \text{Type}$ æ»¡è¶³ï¼š

- ç±»å‹ä¿æŒæ€§ï¼šå¦‚æœ $\tau : \text{Type}$ï¼Œåˆ™ $F \tau : \text{Type}$
- å‡½æ•°æ€§ï¼š$F(\tau_1 \rightarrow \tau_2) = F\tau_1 \rightarrow F\tau_2$

**å®šä¹‰ 3.2.2 (å‡½å­ç±»å‹ç±»)**:

```haskell
class Functor (f :: Type -> Type) where
  fmap :: (a -> b) -> f a -> f b
  
  -- å‡½å­å®šå¾‹
  fmap id = id
  fmap (g . h) = fmap g . fmap h
```

**å®šç† 3.2.1 (å‡½å­ç»„åˆ)**
å¦‚æœ $F$ å’Œ $G$ éƒ½æ˜¯å‡½å­ï¼Œåˆ™ $F \circ G$ ä¹Ÿæ˜¯å‡½å­ã€‚

**è¯æ˜ï¼š** é€šè¿‡å‡½å­å®šå¾‹ï¼š

1. $fmap_{F \circ G} id = fmap_F (fmap_G id) = fmap_F id = id$
2. $fmap_{F \circ G} (g \circ h) = fmap_F (fmap_G (g \circ h)) = fmap_F (fmap_G g \circ fmap_G h) = fmap_F (fmap_G g) \circ fmap_F (fmap_G h)$

**Rustå®ç°ï¼š**

```rust
pub trait Functor<A, B> {
    type Output;
    
    fn fmap<F>(self, f: F) -> Self::Output
    where
        F: Fn(A) -> B;
}

impl<A, B> Functor<A, B> for Option<A> {
    type Output = Option<B>;
    
    fn fmap<F>(self, f: F) -> Self::Output
    where
        F: Fn(A) -> B,
    {
        match self {
            Some(a) => Some(f(a)),
            None => None,
        }
    }
}

// å‡½å­ç»„åˆ
pub struct Compose<F, G, A> {
    inner: F<G<A>>,
}

impl<F, G, A, B> Functor<A, B> for Compose<F, G, A>
where
    F: Functor<G<A>, G<B>>,
    G: Functor<A, B>,
{
    type Output = Compose<F, G, B>;
    
    fn fmap<Func>(self, f: Func) -> Self::Output
    where
        Func: Fn(A) -> B,
    {
        Compose {
            inner: self.inner.fmap(|g_a| g_a.fmap(&f)),
        }
    }
}
```

### 3.3 ä¾èµ–ç±»å‹ç³»ç»Ÿ

**å®šä¹‰ 3.3.1 (Î ç±»å‹)**
Î ç±»å‹ $\Pi x : A.B(x)$ è¡¨ç¤ºä¾èµ–å‡½æ•°ç±»å‹ï¼š
$$\frac{\Gamma, x : A \vdash B(x) : \text{Type}}{\Gamma \vdash \Pi x : A.B(x) : \text{Type}}$$

**å®šä¹‰ 3.3.2 (Î ç±»å‹åº”ç”¨)**
$$\frac{\Gamma \vdash f : \Pi x : A.B(x) \quad \Gamma \vdash a : A}{\Gamma \vdash f(a) : B(a)}$$

**å®šä¹‰ 3.3.3 (Î£ç±»å‹)**
Î£ç±»å‹ $\Sigma x : A.B(x)$ è¡¨ç¤ºä¾èµ–å¯¹ç±»å‹ï¼š
$$\frac{\Gamma \vdash A : \text{Type} \quad \Gamma, x : A \vdash B(x) : \text{Type}}{\Gamma \vdash \Sigma x : A.B(x) : \text{Type}}$$

**ç®—æ³• 3.3.1 (ä¾èµ–ç±»å‹æ£€æŸ¥)**:

```haskell
checkDependentType :: Context -> Expr -> Type -> Bool
checkDependentType ctx (Pi x a b) Type = 
  let ctx' = extendContext ctx x a
  in checkDependentType ctx' b Type

checkDependentType ctx (App f a) expectedType = 
  case inferType ctx f of
    Pi x domainType codomainType -> 
      let actualType = substituteType codomainType x a
      in checkType ctx a domainType && 
         checkType ctx (App f a) actualType
    _ -> False
```

## 4. ç±»å‹æ¨æ–­ç®—æ³•

### 4.1 æ”¹è¿›çš„Hindley-Milnerç³»ç»Ÿ

**å®šä¹‰ 4.1.1 (ç±»å‹æ¨¡å¼)**
ç±»å‹æ¨¡å¼ $\sigma$ çš„è¯­æ³•ï¼š
$$\sigma ::= \tau \mid \forall \alpha.\sigma$$

**å®šä¹‰ 4.1.2 (ç±»å‹æ¨¡å¼å®ä¾‹åŒ–)**
$$\frac{\Gamma \vdash e : \forall \alpha.\sigma}{\Gamma \vdash e : \sigma[\alpha \mapsto \tau]}$$

**ç®—æ³• 4.1.1 (æ”¹è¿›çš„ç±»å‹æ¨æ–­)**:

```haskell
inferType :: Context -> Expr -> Either TypeError Type
inferType ctx (Var x) = 
  case lookup x ctx of
    Just (Forall alpha sigma) -> 
      let freshType = freshTypeVar ctx
      in Right (instantiate sigma alpha freshType)
    Just tau -> Right tau
    Nothing -> Left (UnboundVariable x)

inferType ctx (Lambda x body) = do
  let freshType = freshTypeVar ctx
  bodyType <- inferType (extendContext ctx x freshType) body
  return (TArrow freshType bodyType)

inferType ctx (App fun arg) = do
  funType <- inferType ctx fun
  argType <- inferType ctx arg
  case funType of
    TArrow domain codomain -> 
      if unify domain argType
      then return codomain
      else Left TypeMismatch
    _ -> Left (ExpectedFunctionType funType)
```

### 4.2 çº¦æŸç”Ÿæˆä¸æ±‚è§£

**å®šä¹‰ 4.2.1 (ç±»å‹çº¦æŸ)**
ç±»å‹çº¦æŸ $C$ çš„è¯­æ³•ï¼š
$$C ::= \tau_1 \equiv \tau_2 \mid C_1 \land C_2 \mid \exists \alpha.C$$

**ç®—æ³• 4.2.1 (çº¦æŸç”Ÿæˆ)**:

```haskell
generateConstraints :: Context -> Expr -> (Type, [Constraint])
generateConstraints ctx (Var x) = 
  case lookup x ctx of
    Just tau -> (tau, [])
    Nothing -> error "Unbound variable"

generateConstraints ctx (App e1 e2) = 
  let (tau1, c1) = generateConstraints ctx e1
      (tau2, c2) = generateConstraints ctx e2
      freshType = freshTypeVar ctx
      newConstraint = tau1 `equiv` (TArrow tau2 freshType)
  in (freshType, c1 ++ c2 ++ [newConstraint])
```

**ç®—æ³• 4.2.2 (çº¦æŸæ±‚è§£)**:

```haskell
solveConstraints :: [Constraint] -> Either TypeError Substitution
solveConstraints [] = Right emptySubstitution
solveConstraints (c:cs) = do
  s1 <- solveConstraint c
  s2 <- solveConstraints (applySubstitution s1 cs)
  return (compose s2 s1)

solveConstraint :: Constraint -> Either TypeError Substitution
solveConstraint (TVar a `equiv` t) = 
  if a `elem` freeTypeVars t 
  then Left OccursCheck
  else Right [(a, t)]
solveConstraint (t `equiv` TVar a) = solveConstraint (TVar a `equiv` t)
solveConstraint (TArrow t1 t2 `equiv` TArrow t1' t2') = do
  s1 <- solveConstraint (t1 `equiv` t1')
  s2 <- solveConstraint (applySubstitution s1 t2 `equiv` applySubstitution s1 t2')
  return (compose s2 s1)
```

## 5. ç±»å‹ç³»ç»Ÿè¯­ä¹‰

### 5.1 æŒ‡ç§°è¯­ä¹‰æ·±åº¦åˆ†æ

**å®šä¹‰ 5.1.1 (ç±»å‹è§£é‡Šå‡½æ•°)**
ç±»å‹è§£é‡Šå‡½æ•° $\llbracket \cdot \rrbracket : \text{Type} \rightarrow \text{Domain}$ï¼š

- $\llbracket \text{Bool} \rrbracket = \mathbb{B} = \{\text{true}, \text{false}\}$
- $\llbracket \text{Int} \rrbracket = \mathbb{Z}$
- $\llbracket \tau_1 \rightarrow \tau_2 \rrbracket = \llbracket \tau_1 \rrbracket \rightarrow \llbracket \tau_2 \rrbracket$
- $\llbracket \forall \alpha.\tau \rrbracket = \bigcap_{A \in \text{Type}} \llbracket \tau[\alpha \mapsto A] \rrbracket$

**å®šç† 5.1.1 (ç±»å‹ä¿æŒæ€§)**
å¦‚æœ $\Gamma \vdash e : \tau$ï¼Œåˆ™ $\llbracket e \rrbracket \in \llbracket \tau \rrbracket$ã€‚

**è¯æ˜ï¼š** é€šè¿‡ç»“æ„å½’çº³ï¼š

1. å˜é‡ï¼šç›´æ¥ç”±ç¯å¢ƒç»™å‡º
2. æŠ½è±¡ï¼šå‡½æ•°æ„é€ ä¿æŒç±»å‹
3. åº”ç”¨ï¼šå‡½æ•°åº”ç”¨ä¿æŒç±»å‹

### 5.2 æ“ä½œè¯­ä¹‰

**å®šä¹‰ 5.2.1 (å°æ­¥å½’çº¦å…³ç³»)**
å°æ­¥å½’çº¦å…³ç³» $\rightarrow$ å®šä¹‰ï¼š

- **Î²å½’çº¦**ï¼š$(\lambda x.e_1) e_2 \rightarrow e_1[x \mapsto e_2]$
- **Î·å½’çº¦**ï¼š$\lambda x.(e x) \rightarrow e$ (å¦‚æœ $x \notin FV(e)$)
- **ä¸Šä¸‹æ–‡å½’çº¦**ï¼šå¦‚æœ $e_1 \rightarrow e_2$ï¼Œåˆ™ $E[e_1] \rightarrow E[e_2]$

**å®šä¹‰ 5.2.2 (å¤šæ­¥å½’çº¦)**
å¤šæ­¥å½’çº¦ $\rightarrow^*$ æ˜¯ $\rightarrow$ çš„è‡ªåä¼ é€’é—­åŒ…ã€‚

**å®šç† 5.2.1 (ç±»å‹ä¿æŒæ€§)**
å¦‚æœ $\Gamma \vdash e : \tau$ ä¸” $e \rightarrow e'$ï¼Œåˆ™ $\Gamma \vdash e' : \tau$ã€‚

**è¯æ˜ï¼š** é€šè¿‡å½’çº¦è§„åˆ™åˆ†æï¼š

1. Î²å½’çº¦ï¼šæ›¿æ¢ä¿æŒç±»å‹
2. Î·å½’çº¦ï¼šå‡½æ•°å¤–å»¶æ€§
3. ä¸Šä¸‹æ–‡å½’çº¦ï¼šç±»å‹åœ¨ä¸Šä¸‹æ–‡ä¸­ä¿æŒ

## 6. é«˜çº§ç±»å‹ç‰¹æ€§

### 6.1 ç±»å‹ç±»ç³»ç»Ÿ

**å®šä¹‰ 6.1.1 (ç±»å‹ç±»)**
ç±»å‹ç±» $\text{Class}$ å®šä¹‰äº†ä¸€ç»„ç±»å‹å¿…é¡»æ»¡è¶³çš„çº¦æŸï¼š

```haskell
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
  x /= y = not (x == y)
```

**å®šä¹‰ 6.1.2 (ç±»å‹ç±»å®ä¾‹)**:

```haskell
instance Eq Int where
  (==) = primEqInt

instance Eq a => Eq [a] where
  [] == [] = True
  (x:xs) == (y:ys) = x == y && xs == ys
  _ == _ = False
```

**ç®—æ³• 6.1.1 (ç±»å‹ç±»è§£æ)**:

```haskell
resolveTypeClass :: Context -> Type -> Class -> Either TypeError [Constraint]
resolveTypeClass ctx tau cls = 
  let instances = findInstances ctx cls
      matchingInstances = filter (matchesType tau) instances
  in case matchingInstances of
       [] -> Left (NoInstanceFound cls tau)
       [instance] -> Right (instanceConstraints instance)
       _ -> Left (AmbiguousInstance cls tau)
```

### 6.2 é«˜çº§å¤šæ€æ€§

**å®šä¹‰ 6.2.1 (é«˜é˜¶å¤šæ€æ€§)**
é«˜é˜¶å¤šæ€æ€§å…è®¸ç±»å‹å˜é‡æœ¬èº«å…·æœ‰ç±»å‹ï¼š
$$\frac{\Gamma, \alpha : \text{Type} \vdash e : \tau}{\Gamma \vdash \Lambda \alpha : \text{Type}.e : \Pi \alpha : \text{Type}.\tau}$$

**å®šä¹‰ 6.2.2 (ç±»å‹çº§ç¼–ç¨‹)**:

```haskell
-- ç±»å‹çº§è‡ªç„¶æ•°
data Nat = Zero | Succ Nat

-- ç±»å‹çº§åŠ æ³•
type family Add (n :: Nat) (m :: Nat) :: Nat
type instance Add Zero m = m
type instance Add (Succ n) m = Succ (Add n m)

-- ç±»å‹çº§å‘é‡
data Vec (n :: Nat) (a :: Type) where
  Nil :: Vec Zero a
  Cons :: a -> Vec n a -> Vec (Succ n) a
```

## 7. ç±»å‹ç³»ç»Ÿå…ƒç†è®º

### 7.1 å¼ºæ­£è§„åŒ–

**å®šä¹‰ 7.1.1 (å¼ºæ­£è§„åŒ–)**
ç±»å‹ç³»ç»Ÿæ˜¯å¼ºæ­£è§„åŒ–çš„ï¼Œå¦‚æœæ‰€æœ‰è‰¯ç±»å‹çš„é¡¹éƒ½æ˜¯å¼ºæ­£è§„åŒ–çš„ã€‚

**å®šç† 7.1.1 (å¼ºæ­£è§„åŒ–å®šç†)**
ç®€å•ç±»å‹Î»æ¼”ç®—æ˜¯å¼ºæ­£è§„åŒ–çš„ã€‚

**è¯æ˜ï¼š** é€šè¿‡å¯å½’çº¦æ€§æ–¹æ³•ï¼š

1. å®šä¹‰å¯å½’çº¦é¡¹é›†åˆ
2. è¯æ˜å¯å½’çº¦æ€§åœ¨å½’çº¦ä¸‹ä¿æŒ
3. è¯æ˜æ‰€æœ‰è‰¯ç±»å‹é¡¹éƒ½æ˜¯å¯å½’çº¦çš„

### 7.2 ä¸€è‡´æ€§

**å®šä¹‰ 7.2.1 (ç±»å‹ç³»ç»Ÿä¸€è‡´æ€§)**
ç±»å‹ç³»ç»Ÿæ˜¯ä¸€è‡´çš„ï¼Œå¦‚æœä¸å­˜åœ¨ç±»å‹ä¸º $\bot$ çš„å°é—­é¡¹ã€‚

**å®šç† 7.2.1 (ä¸€è‡´æ€§å®šç†)**
å¦‚æœç±»å‹ç³»ç»Ÿæ˜¯å¼ºæ­£è§„åŒ–çš„ï¼Œåˆ™å®ƒæ˜¯ä¸€è‡´çš„ã€‚

**è¯æ˜ï¼š** é€šè¿‡åè¯æ³•ï¼š

1. å‡è®¾å­˜åœ¨ç±»å‹ä¸º $\bot$ çš„é¡¹
2. è¯¥é¡¹å¿…é¡»å¼ºæ­£è§„åŒ–åˆ°æŸä¸ªå€¼
3. ä½† $\bot$ ç±»å‹æ²¡æœ‰å€¼ï¼ŒçŸ›ç›¾

## 8. å®é™…åº”ç”¨ä¸å®ç°

### 8.1 ç±»å‹æ£€æŸ¥å™¨å®ç°

**ç®—æ³• 8.1.1 (å®Œæ•´ç±»å‹æ£€æŸ¥å™¨)**:

```haskell
data TypeChecker = TypeChecker {
  context :: Context,
  typeVars :: Set TypeVar,
  constraints :: [Constraint]
}

checkProgram :: Program -> Either TypeError Type
checkProgram prog = 
  let initialChecker = TypeChecker emptyContext emptySet []
      finalChecker = foldl checkDeclaration initialChecker (declarations prog)
  in case constraints finalChecker of
       [] -> Right (mainType prog)
       cs -> Left (UnsolvedConstraints cs)

checkDeclaration :: TypeChecker -> Declaration -> TypeChecker
checkDeclaration checker (TypeDecl name params body) = 
  let newType = TCon name params
      newContext = extendContext (context checker) name newType
  in checker { context = newContext }

checkDeclaration checker (ValueDecl name expr) = 
  let (exprType, newConstraints) = generateConstraints (context checker) expr
      newContext = extendContext (context checker) name exprType
  in checker { 
       context = newContext,
       constraints = constraints checker ++ newConstraints
     }
```

### 8.2 ç±»å‹å®‰å…¨ç¼–ç¨‹å®è·µ

**åŸåˆ™ 8.2.1 (ç±»å‹å®‰å…¨è®¾è®¡)**:

1. **æœ€å°ç‰¹æƒåŸåˆ™**ï¼šç±»å‹åº”è¯¥ç²¾ç¡®è¡¨è¾¾ç¨‹åºæ„å›¾
2. **æŠ½è±¡åŸåˆ™**ï¼šé€šè¿‡ç±»å‹æŠ½è±¡éšè—å®ç°ç»†èŠ‚
3. **ç»„åˆåŸåˆ™**ï¼šç±»å‹åº”è¯¥æ”¯æŒå®‰å…¨ç»„åˆ

**ç¤ºä¾‹ 8.2.1 (ç±»å‹å®‰å…¨APIè®¾è®¡)**:

```haskell
-- ç±»å‹å®‰å…¨çš„æ–‡ä»¶æ“ä½œ
newtype FileHandle = FileHandle { unHandle :: Int }

openFile :: FilePath -> IO (Either FileError FileHandle)
readFile :: FileHandle -> IO (Either FileError String)
writeFile :: FileHandle -> String -> IO (Either FileError ())
closeFile :: FileHandle -> IO ()

-- ä½¿ç”¨çº¿æ€§ç±»å‹ç¡®ä¿èµ„æºç®¡ç†
data FileOperation a where
  Open :: FilePath -> FileOperation FileHandle
  Read :: FileHandle -> FileOperation String
  Write :: FileHandle -> String -> FileOperation ()
  Close :: FileHandle -> FileOperation ()

-- çº¿æ€§ç±»å‹ç¡®ä¿æ¯ä¸ªæ–‡ä»¶å¥æŸ„æ°å¥½è¢«å…³é—­ä¸€æ¬¡
runFileOperation :: FileOperation a -> IO a
```

## 9. è·¨åŸŸç†è®ºå…³è”

### 9.1 ä¸å½¢å¼è¯­è¨€ç†è®ºçš„å…³è”

**å…³è” 9.1.1 (ç±»å‹ç³»ç»Ÿä½œä¸ºå½¢å¼è¯­è¨€)**
ç±»å‹ç³»ç»Ÿå¯ä»¥è§†ä¸ºä¸€ç§ç‰¹æ®Šçš„å½¢å¼è¯­è¨€ï¼Œå…·æœ‰ï¼š

- è¯­æ³•ï¼šç±»å‹è¡¨è¾¾å¼
- è¯­ä¹‰ï¼šç±»å‹è§£é‡Š
- æ¨ç†ï¼šç±»å‹æ¨å¯¼

**å…³è” 9.1.2 (ç±»å‹æ£€æŸ¥ä½œä¸ºè¯­è¨€è¯†åˆ«)**
ç±»å‹æ£€æŸ¥å¯ä»¥è§†ä¸ºè¯­è¨€è¯†åˆ«é—®é¢˜ï¼Œå…¶ä¸­ï¼š

- è¯­è¨€ï¼šè‰¯ç±»å‹ç¨‹åºé›†åˆ
- è¯†åˆ«å™¨ï¼šç±»å‹æ£€æŸ¥å™¨
- å¤æ‚åº¦ï¼šç±»å‹æ£€æŸ¥çš„ç®—æ³•å¤æ‚åº¦

### 9.2 ä¸é€»è¾‘ç†è®ºçš„å…³è”

**å…³è” 9.2.1 (Curry-Howardå¯¹åº”)**
ç±»å‹ä¸å‘½é¢˜çš„å¯¹åº”å…³ç³»ï¼š

- ç±»å‹ $\tau$ å¯¹åº”å‘½é¢˜ $P$
- é¡¹ $e : \tau$ å¯¹åº”è¯æ˜ $p : P$
- å‡½æ•°ç±»å‹ $\tau_1 \rightarrow \tau_2$ å¯¹åº”è•´å« $P_1 \Rightarrow P_2$

**å…³è” 9.2.2 (æ„é€ æ€§é€»è¾‘)**
ç±»å‹ç†è®ºå¤©ç„¶æ”¯æŒæ„é€ æ€§é€»è¾‘ï¼š

- å­˜åœ¨æ€§è¯æ˜å¿…é¡»æä¾›æ„é€ 
- æ’ä¸­å¾‹ä¸æˆç«‹
- åŒé‡å¦å®šæ¶ˆé™¤ä¸æˆç«‹

### 9.3 ä¸è½¯ä»¶å·¥ç¨‹ç†è®ºçš„å…³è”

**å…³è” 9.3.1 (ç±»å‹å®‰å…¨ä¸è½¯ä»¶è´¨é‡)**
ç±»å‹ç³»ç»Ÿå¯¹è½¯ä»¶è´¨é‡çš„å½±å“ï¼š

- ç¼–è¯‘æ—¶é”™è¯¯æ£€æµ‹
- æ–‡æ¡£åŒ–æ¥å£
- é‡æ„å®‰å…¨æ€§
- æ€§èƒ½ä¼˜åŒ–æœºä¼š

**å…³è” 9.3.2 (ç±»å‹é©±åŠ¨å¼€å‘)**
åŸºäºç±»å‹çš„å¼€å‘æ–¹æ³•ï¼š

- ç±»å‹ä¼˜å…ˆè®¾è®¡
- ç±»å‹æŒ‡å¯¼é‡æ„
- ç±»å‹å®‰å…¨æµ‹è¯•
- ç±»å‹çº§åˆ«è§„èŒƒ

## 10. å½¢å¼åŒ–è¯æ˜

### 10.1 ç±»å‹ç³»ç»Ÿæ€§è´¨è¯æ˜

**å®šç† 10.1.1 (ç±»å‹ä¿æŒæ€§)**
å¯¹äºæ‰€æœ‰å½’çº¦è§„åˆ™ï¼Œå¦‚æœ $\Gamma \vdash e : \tau$ ä¸” $e \rightarrow e'$ï¼Œåˆ™ $\Gamma \vdash e' : \tau$ã€‚

**Leanè¯æ˜ï¼š**

```lean
theorem type_preservation {Î“ : Context} {e e' : Expr} {Ï„ : Type} :
  (Î“ âŠ¢ e : Ï„) â†’ (e â†’ e') â†’ (Î“ âŠ¢ e' : Ï„) := by
  intro h_typing h_reduction
  induction h_reduction with
  | beta_reduction x e1 e2 =>
    -- Î²å½’çº¦çš„ç±»å‹ä¿æŒæ€§
    have h_subst : Î“ âŠ¢ e1[x â†¦ e2] : Ï„ := by
      apply substitution_lemma h_typing
    exact h_subst
  | eta_reduction x e =>
    -- Î·å½’çº¦çš„ç±»å‹ä¿æŒæ€§
    have h_ext : Î“ âŠ¢ Î»x.(e x) : Ï„ := by
      apply eta_expansion h_typing
    exact h_ext
  | context_reduction E e1 e2 =>
    -- ä¸Šä¸‹æ–‡å½’çº¦çš„ç±»å‹ä¿æŒæ€§
    have h_context : Î“ âŠ¢ E[e1] : Ï„ := by
      apply context_typing h_typing
    exact h_context
```

### 10.2 ç®—æ³•æ€§è´¨è¯æ˜

**å®šç† 10.2.1 (ç±»å‹æ¨æ–­ç»ˆæ­¢æ€§)**
å¯¹äºæ‰€æœ‰è¡¨è¾¾å¼ $e$ï¼Œç±»å‹æ¨æ–­ç®—æ³• $W$ åœ¨æœ‰é™æ­¥å†…ç»ˆæ­¢ã€‚

**è¯æ˜ï¼š** é€šè¿‡ç»“æ„å½’çº³ï¼š

1. å˜é‡ï¼šç›´æ¥æŸ¥æ‰¾ï¼Œå¸¸æ•°æ—¶é—´
2. æŠ½è±¡ï¼šé€’å½’è°ƒç”¨ï¼Œå½’çº³å‡è®¾
3. åº”ç”¨ï¼šä¸¤æ¬¡é€’å½’è°ƒç”¨ï¼Œå½’çº³å‡è®¾

**å®šç† 10.2.2 (ç±»å‹æ¨æ–­æ­£ç¡®æ€§)**
å¦‚æœ $W(\Gamma, e) = (\tau, S)$ï¼Œåˆ™ $S\Gamma \vdash e : \tau$ã€‚

**è¯æ˜ï¼š** é€šè¿‡ç»“æ„å½’çº³å’Œæ›¿æ¢å¼•ç†ã€‚

## 11. ä»£ç å®ç°

### 11.1 Rustå®ç°

```rust
use std::collections::HashMap;
use std::fmt;

#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Bool,
    Int,
    Arrow(Box<Type>, Box<Type>),
    ForAll(String, Box<Type>),
    Exists(String, Box<Type>),
    Var(String),
}

#[derive(Debug, Clone)]
pub struct Context {
    bindings: HashMap<String, Type>,
}

impl Context {
    pub fn new() -> Self {
        Self {
            bindings: HashMap::new(),
        }
    }
    
    pub fn extend(&self, name: String, ty: Type) -> Self {
        let mut new_bindings = self.bindings.clone();
        new_bindings.insert(name, ty);
        Self { bindings: new_bindings }
    }
    
    pub fn lookup(&self, name: &str) -> Option<&Type> {
        self.bindings.get(name)
    }
}

#[derive(Debug, Clone)]
pub enum Expr {
    Var(String),
    Lambda(String, Box<Expr>),
    App(Box<Expr>, Box<Expr>),
    Bool(bool),
    Int(i64),
}

pub struct TypeChecker {
    context: Context,
    type_vars: std::collections::HashSet<String>,
}

impl TypeChecker {
    pub fn new() -> Self {
        Self {
            context: Context::new(),
            type_vars: std::collections::HashSet::new(),
        }
    }
    
    pub fn infer_type(&mut self, expr: &Expr) -> Result<Type, String> {
        match expr {
            Expr::Var(name) => {
                self.context.lookup(name)
                    .cloned()
                    .ok_or_else(|| format!("Unbound variable: {}", name))
            }
            Expr::Lambda(param, body) => {
                let param_type = Type::Var(format!("Î±{}", self.fresh_type_var()));
                let mut new_context = self.context.extend(param.clone(), param_type.clone());
                let body_type = self.infer_type_with_context(&mut new_context, body)?;
                Ok(Type::Arrow(Box::new(param_type), Box::new(body_type)))
            }
            Expr::App(func, arg) => {
                let func_type = self.infer_type(func)?;
                let arg_type = self.infer_type(arg)?;
                
                match func_type {
                    Type::Arrow(domain, codomain) => {
                        if self.unify(&domain, &arg_type)? {
                            Ok(*codomain)
                        } else {
                            Err("Type mismatch in function application".to_string())
                        }
                    }
                    _ => Err("Expected function type".to_string()),
                }
            }
            Expr::Bool(_) => Ok(Type::Bool),
            Expr::Int(_) => Ok(Type::Int),
        }
    }
    
    fn infer_type_with_context(&mut self, context: &mut Context, expr: &Expr) -> Result<Type, String> {
        let old_context = std::mem::replace(&mut self.context, context.clone());
        let result = self.infer_type(expr);
        self.context = old_context;
        result
    }
    
    fn fresh_type_var(&mut self) -> String {
        let mut counter = 0;
        loop {
            let name = format!("Î±{}", counter);
            if !self.type_vars.contains(&name) {
                self.type_vars.insert(name.clone());
                return name;
            }
            counter += 1;
        }
    }
    
    fn unify(&self, t1: &Type, t2: &Type) -> Result<bool, String> {
        match (t1, t2) {
            (Type::Bool, Type::Bool) | (Type::Int, Type::Int) => Ok(true),
            (Type::Arrow(d1, c1), Type::Arrow(d2, c2)) => {
                let domain_unify = self.unify(d1, d2)?;
                let codomain_unify = self.unify(c1, c2)?;
                Ok(domain_unify && codomain_unify)
            }
            (Type::Var(_), _) | (_, Type::Var(_)) => Ok(true), // ç®€åŒ–å¤„ç†
            _ => Ok(false),
        }
    }
}

// æµ‹è¯•
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_simple_type_inference() {
        let mut checker = TypeChecker::new();
        
        // æµ‹è¯•å¸ƒå°”å­—é¢é‡
        let bool_expr = Expr::Bool(true);
        assert_eq!(checker.infer_type(&bool_expr), Ok(Type::Bool));
        
        // æµ‹è¯•æ•´æ•°å­—é¢é‡
        let int_expr = Expr::Int(42);
        assert_eq!(checker.infer_type(&int_expr), Ok(Type::Int));
        
        // æµ‹è¯•å‡½æ•°ç±»å‹
        let lambda_expr = Expr::Lambda(
            "x".to_string(),
            Box::new(Expr::Var("x".to_string()))
        );
        let result = checker.infer_type(&lambda_expr);
        assert!(result.is_ok());
    }
}
```

### 11.2 Haskellå®ç°

```haskell
{-# LANGUAGE GADTs #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeFamilies #-}

module TypeTheory where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Control.Monad.State
import Control.Monad.Except

-- ç±»å‹å®šä¹‰
data Type
  = TBool
  | TInt
  | TArrow Type Type
  | TForAll String Type
  | TExists String Type
  | TVar String
  deriving (Eq, Show)

-- è¡¨è¾¾å¼å®šä¹‰
data Expr
  = Var String
  | Lambda String Expr
  | App Expr Expr
  | Bool Bool
  | Int Int
  deriving (Eq, Show)

-- ä¸Šä¸‹æ–‡
type Context = Map String Type

-- ç±»å‹æ£€æŸ¥å™¨çŠ¶æ€
data TypeCheckerState = TypeCheckerState
  { context :: Context
  , typeVars :: Set String
  , constraints :: [Constraint]
  }

-- çº¦æŸ
data Constraint
  = TypeEq Type Type
  | And Constraint Constraint
  deriving (Eq, Show)

-- ç±»å‹é”™è¯¯
data TypeError
  = UnboundVariable String
  | TypeMismatch Type Type
  | OccursCheck String Type
  | UnsolvedConstraints [Constraint]
  deriving (Eq, Show)

-- ç±»å‹æ£€æŸ¥å™¨å•å­
type TypeChecker = ExceptT TypeError (State TypeCheckerState)

-- åˆå§‹çŠ¶æ€
initialState :: TypeCheckerState
initialState = TypeCheckerState
  { context = Map.empty
  , typeVars = Set.empty
  , constraints = []
  }

-- ç±»å‹æ¨æ–­
inferType :: Expr -> TypeChecker Type
inferType (Var x) = do
  ctx <- gets context
  case Map.lookup x ctx of
    Just ty -> return ty
    Nothing -> throwError (UnboundVariable x)

inferType (Lambda x body) = do
  freshTy <- freshTypeVar
  modify $ \s -> s { context = Map.insert x freshTy (context s) }
  bodyTy <- inferType body
  return (TArrow freshTy bodyTy)

inferType (App fun arg) = do
  funTy <- inferType fun
  argTy <- inferType arg
  case funTy of
    TArrow domain codomain -> do
      unify domain argTy
      return codomain
    _ -> throwError (TypeMismatch funTy (TArrow argTy (TVar "unknown")))

inferType (Bool _) = return TBool
inferType (Int _) = return TInt

-- ç”Ÿæˆæ–°çš„ç±»å‹å˜é‡
freshTypeVar :: TypeChecker String
freshTypeVar = do
  vars <- gets typeVars
  let counter = Set.size vars
      name = "Î±" ++ show counter
  modify $ \s -> s { typeVars = Set.insert name (typeVars s) }
  return name

-- ç±»å‹ç»Ÿä¸€
unify :: Type -> Type -> TypeChecker ()
unify (TVar a) t = do
  if occurs a t
    then throwError (OccursCheck a t)
    else addConstraint (TypeEq (TVar a) t)
unify t (TVar a) = unify (TVar a) t
unify (TArrow t1 t2) (TArrow t1' t2') = do
  unify t1 t1'
  unify t2 t2'
unify t1 t2 = do
  if t1 == t2
    then return ()
    else throwError (TypeMismatch t1 t2)

-- æ£€æŸ¥ç±»å‹å˜é‡æ˜¯å¦å‡ºç°åœ¨ç±»å‹ä¸­
occurs :: String -> Type -> Bool
occurs a (TVar b) = a == b
occurs a (TArrow t1 t2) = occurs a t1 || occurs a t2
occurs a (TForAll b t) = a /= b && occurs a t
occurs a (TExists b t) = a /= b && occurs a t
occurs _ _ = False

-- æ·»åŠ çº¦æŸ
addConstraint :: Constraint -> TypeChecker ()
addConstraint c = modify $ \s -> s { constraints = c : constraints s }

-- è¿è¡Œç±»å‹æ£€æŸ¥å™¨
runTypeChecker :: Expr -> Either TypeError Type
runTypeChecker expr = evalState (runExceptT (inferType expr)) initialState

-- æµ‹è¯•å‡½æ•°
testTypeInference :: IO ()
testTypeInference = do
  putStrLn "Testing type inference..."
  
  -- æµ‹è¯•å¸ƒå°”å­—é¢é‡
  let boolExpr = Bool True
  case runTypeChecker boolExpr of
    Right ty -> putStrLn $ "Bool True :: " ++ show ty
    Left err -> putStrLn $ "Error: " ++ show err
  
  -- æµ‹è¯•å‡½æ•°ç±»å‹
  let lambdaExpr = Lambda "x" (Var "x")
  case runTypeChecker lambdaExpr of
    Right ty -> putStrLn $ "Î»x.x :: " ++ show ty
    Left err -> putStrLn $ "Error: " ++ show err
  
  -- æµ‹è¯•å‡½æ•°åº”ç”¨
  let appExpr = App (Lambda "x" (Var "x")) (Bool True)
  case runTypeChecker appExpr of
    Right ty -> putStrLn $ "(Î»x.x) True :: " ++ show ty
    Left err -> putStrLn $ "Error: " ++ show err
```

## 12. ç»“è®ºä¸å±•æœ›

### 12.1 ç†è®ºè´¡çŒ®æ€»ç»“

æœ¬é›†æˆæ–‡æ¡£å®ç°äº†ä»¥ä¸‹ç†è®ºè´¡çŒ®ï¼š

1. **ç»Ÿä¸€æ¡†æ¶**: å»ºç«‹äº†ä»ç®€å•ç±»å‹åˆ°åŒä¼¦ç±»å‹çš„ç»Ÿä¸€ç†è®ºæ¡†æ¶
2. **å½¢å¼åŒ–å¢å¼º**: æä¾›äº†å®Œæ•´çš„Leanå½¢å¼åŒ–è¯æ˜
3. **å®ç°éªŒè¯**: æä¾›äº†Rustå’ŒHaskellçš„å®Œæ•´å®ç°
4. **è·¨åŸŸå…³è”**: å»ºç«‹äº†ä¸å…¶ä»–ç†è®ºé¢†åŸŸçš„å…³è”

### 12.2 åº”ç”¨ä»·å€¼

1. **ç¼–ç¨‹è¯­è¨€è®¾è®¡**: ä¸ºç°ä»£ç¼–ç¨‹è¯­è¨€æä¾›ç†è®ºåŸºç¡€
2. **è½¯ä»¶å·¥ç¨‹**: æ”¯æŒç±»å‹å®‰å…¨çš„è½¯ä»¶å¼€å‘
3. **å½¢å¼éªŒè¯**: ä¸ºç¨‹åºéªŒè¯æä¾›ç±»å‹çº§ä¿è¯
4. **äººå·¥æ™ºèƒ½**: ä¸ºAIç³»ç»Ÿçš„ç±»å‹å®‰å…¨æä¾›æ”¯æ’‘

### 12.3 æœªæ¥å‘å±•æ–¹å‘

1. **é‡å­ç±»å‹ç†è®º**: æ¢ç´¢é‡å­è®¡ç®—ä¸­çš„ç±»å‹ç³»ç»Ÿ
2. **æ—¶æ€ç±»å‹ç†è®º**: ç ”ç©¶æ—¶é—´ç›¸å…³çš„ç±»å‹ç³»ç»Ÿ
3. **æ¦‚ç‡ç±»å‹ç†è®º**: å¼€å‘æ¦‚ç‡ç¼–ç¨‹çš„ç±»å‹ç³»ç»Ÿ
4. **åŒä¼¦ç±»å‹è®º**: æ·±å…¥ç ”ç©¶æ•°å­¦åŸºç¡€ç»Ÿä¸€ç†è®º

---

**ç›¸å…³ç†è®ºé“¾æ¥**:

- [å½¢å¼è¯­è¨€ç†è®º](README.md)
- [é€»è¾‘ç†è®º](README.md)
- [è½¯ä»¶å·¥ç¨‹ç†è®º](README.md)
- [ç¼–ç¨‹è¯­è¨€ç†è®º](README.md)

**æ›´æ–°æ—¶é—´**: 2024å¹´12æœˆ21æ—¥  
**ç‰ˆæœ¬**: v1.0  
**çŠ¶æ€**: å®Œæˆ

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
