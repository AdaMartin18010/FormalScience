# 04.5.5 åŒä¼¦ä¸å˜é‡

## ğŸ“‹ æ¦‚è¿°

åŒä¼¦ä¸å˜é‡æ˜¯åŒä¼¦ç†è®ºä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼Œç”¨äºåŒºåˆ†ä¸åŒæ‹“æ‰‘ç©ºé—´ã€‚æœ¬æ–‡æ¡£å»ºç«‹ä¸¥æ ¼çš„åŒä¼¦ä¸å˜é‡ç†è®ºæ¡†æ¶ï¼ŒåŒ…å«åŒä¼¦ä¸å˜é‡ã€åŸºæœ¬ç¾¤ã€åŒä¼¦ç¾¤ã€åŒä¼¦ç­‰ä»·ç±»ç­‰å†…å®¹ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹åŒä¼¦ä¸å˜é‡çš„åŸºæœ¬æ¦‚å¿µå’Œå½¢å¼åŒ–å®šä¹‰
2. åˆ†æåŒä¼¦ä¸å˜é‡ä¸æ‹“æ‰‘ç©ºé—´çš„å…³ç³»
3. ç ”ç©¶åŒä¼¦ä¸å˜é‡çš„è®¡ç®—æ–¹æ³•
4. æä¾›åŒä¼¦ä¸å˜é‡çš„å®é™…åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 åŒä¼¦ä¸å˜é‡åŸºç¡€

**å®šä¹‰ 1.1.1** (åŒä¼¦ä¸å˜é‡)
åŒä¼¦ä¸å˜é‡æ˜¯åœ¨åŒä¼¦ç­‰ä»·ä¸‹ä¿æŒä¸å˜çš„æ•°å­¦å¯¹è±¡ï¼š
$$Inv(X) = \{f : Top \rightarrow Set \mid X \simeq Y \Rightarrow f(X) \cong f(Y)\}$$

**å®šä¹‰ 1.1.2** (åŸºæœ¬ç¾¤)
åŸºæœ¬ç¾¤æ˜¯æ‹“æ‰‘ç©ºé—´çš„åŸºæœ¬åŒä¼¦ä¸å˜é‡ï¼š
$$\pi_1(X, x_0) = \{[f] \mid f : S^1 \rightarrow X, f(1) = x_0\}$$

**å®šä¹‰ 1.1.3** (åŒä¼¦ç¾¤)
åŒä¼¦ç¾¤æ˜¯åŸºæœ¬ç¾¤çš„é«˜ç»´æ¨å¹¿ï¼š
$$\pi_n(X, x_0) = \{[f] \mid f : S^n \rightarrow X, f(base) = x_0\}$$

### 1.2 åŒä¼¦ä¸å˜é‡ç‰¹å¾

**å®šä¹‰ 1.2.1** (ä¸å˜é‡æ€§è´¨)
åŒä¼¦ä¸å˜é‡æ»¡è¶³ï¼š

- åŒä¼¦ä¸å˜æ€§ï¼š$X \simeq Y \Rightarrow Inv(X) \cong Inv(Y)$
- å‡½å­æ€§ï¼š$f : X \rightarrow Y \Rightarrow Inv(f) : Inv(X) \rightarrow Inv(Y)$
- è‡ªç„¶æ€§ï¼šåŒä¼¦ç­‰ä»·è¯±å¯¼åŒæ„

**å®šä¹‰ 1.2.2** (ä¸å˜é‡ç±»å‹)
åŒä¼¦ä¸å˜é‡ç±»å‹åŒ…æ‹¬ï¼š

- ä»£æ•°ä¸å˜é‡ï¼šåŸºæœ¬ç¾¤ã€åŒä¼¦ç¾¤ã€åŒè°ƒç¾¤
- å‡ ä½•ä¸å˜é‡ï¼šæ¬§æ‹‰ç¤ºæ€§æ•°ã€é™ˆç±»
- æ‹“æ‰‘ä¸å˜é‡ï¼šè¿é€šæ€§ã€ç´§æ€§

**å®šä¹‰ 1.2.3** (ä¸å˜é‡è®¡ç®—)
åŒä¼¦ä¸å˜é‡è®¡ç®—æ–¹æ³•ï¼š

- ä»£æ•°æ–¹æ³•ï¼šç¾¤è®ºã€åŒè°ƒè®º
- å‡ ä½•æ–¹æ³•ï¼šå¾®åˆ†å‡ ä½•ã€ä»£æ•°å‡ ä½•
- ç»„åˆæ–¹æ³•ï¼šèƒè…”åˆ†è§£ã€CWå¤å½¢

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 åŸºæœ¬ç¾¤ç³»ç»Ÿ

**å®šä¹‰ 2.1.1** (åŸºæœ¬ç¾¤è¯­æ³•)
åŸºæœ¬ç¾¤è¯­æ³•ï¼š

```text
FundamentalGroup ::= Pi1[Space, Point]
                   | Loop[Space, Point]
                   | HomotopyClass[Loop]
                   | GroupOperation[Loop, Loop]
```

**å®šä¹‰ 2.1.2** (åŸºæœ¬ç¾¤è§„åˆ™)
åŸºæœ¬ç¾¤æ¨å¯¼è§„åˆ™ï¼š
$$\frac{\Gamma \vdash X : Space \quad \Gamma \vdash x_0 : X}{\Gamma \vdash \pi_1(X, x_0) : Group} \text{ (Fundamental Group Formation)}$$
$$\frac{\Gamma \vdash f : S^1 \rightarrow X \quad \Gamma \vdash f(1) = x_0}{\Gamma \vdash [f] : \pi_1(X, x_0)} \text{ (Loop Class Formation)}$$

**å®šä¹‰ 2.1.3** (åŸºæœ¬ç¾¤è¯­ä¹‰)
åŸºæœ¬ç¾¤è¯­ä¹‰ï¼š
$$\llbracket \pi_1(X, x_0) \rrbracket = \{[f] \mid f : [0,1] \rightarrow X, f(0) = f(1) = x_0\}$$

### 2.2 åŒä¼¦ç¾¤ç³»ç»Ÿ

**å®šä¹‰ 2.2.1** (åŒä¼¦ç¾¤è¯­æ³•)
åŒä¼¦ç¾¤è¯­æ³•ï¼š

```text
HomotopyGroup ::= PiN[Space, Point, Nat]
                | SphereMap[Space, Point, Nat]
                | HomotopyClass[SphereMap]
                | GroupOperation[SphereMap, SphereMap]
```

**å®šä¹‰ 2.2.2** (åŒä¼¦ç¾¤è§„åˆ™)
åŒä¼¦ç¾¤æ¨å¯¼è§„åˆ™ï¼š
$$\frac{\Gamma \vdash X : Space \quad \Gamma \vdash x_0 : X \quad \Gamma \vdash n : Nat}{\Gamma \vdash \pi_n(X, x_0) : Group} \text{ (Homotopy Group Formation)}$$
$$\frac{\Gamma \vdash f : S^n \rightarrow X \quad \Gamma \vdash f(base) = x_0}{\Gamma \vdash [f] : \pi_n(X, x_0)} \text{ (Sphere Map Class Formation)}$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŒä¼¦ä¸å˜é‡åŸºæœ¬å®šç†

**å®šç† 3.1.1** (åŒä¼¦ä¸å˜é‡å®šç†)
åŒä¼¦ä¸å˜é‡åœ¨åŒä¼¦ç­‰ä»·ä¸‹ä¿æŒä¸å˜ï¼š
$$X \simeq Y \Rightarrow Inv(X) \cong Inv(Y)$$

**è¯æ˜**ï¼š
é€šè¿‡å‡½å­æ€§è¯æ˜ï¼š

1. ç»™å®šåŒä¼¦ç­‰ä»· $f : X \simeq Y$
2. æ„é€ åŒæ„ $Inv(f) : Inv(X) \cong Inv(Y)$
3. éªŒè¯åŒæ„æ€§è´¨

**å®šç† 3.1.2** (åŸºæœ¬ç¾¤åŒä¼¦ä¸å˜æ€§å®šç†)
åŸºæœ¬ç¾¤æ˜¯åŒä¼¦ä¸å˜é‡ï¼š
$$X \simeq Y \Rightarrow \pi_1(X, x_0) \cong \pi_1(Y, f(x_0))$$

**è¯æ˜**ï¼š
é€šè¿‡åŒä¼¦ç­‰ä»·ï¼š

1. ç»™å®šåŒä¼¦ç­‰ä»· $f : X \simeq Y$
2. æ„é€ ç¾¤åŒæ„ $\pi_1(f) : \pi_1(X, x_0) \cong \pi_1(Y, f(x_0))$
3. éªŒè¯ç¾¤åŒæ„æ€§è´¨

### 3.2 åŒä¼¦ç¾¤å®šç†

**å®šç† 3.2.1** (åŒä¼¦ç¾¤åŒä¼¦ä¸å˜æ€§å®šç†)
åŒä¼¦ç¾¤æ˜¯åŒä¼¦ä¸å˜é‡ï¼š
$$X \simeq Y \Rightarrow \pi_n(X, x_0) \cong \pi_n(Y, f(x_0))$$

**è¯æ˜**ï¼š
é€šè¿‡åŒä¼¦ç­‰ä»·ï¼š

1. ç»™å®šåŒä¼¦ç­‰ä»· $f : X \simeq Y$
2. æ„é€ ç¾¤åŒæ„ $\pi_n(f) : \pi_n(X, x_0) \cong \pi_n(Y, f(x_0))$
3. éªŒè¯ç¾¤åŒæ„æ€§è´¨

**å®šç† 3.2.2** (åŒä¼¦ç¾¤é˜¿è´å°”æ€§å®šç†)
é«˜é˜¶åŒä¼¦ç¾¤æ˜¯é˜¿è´å°”ç¾¤ï¼š
$$n \geq 2 \Rightarrow \pi_n(X, x_0) \text{ is abelian}$$

**è¯æ˜**ï¼š
é€šè¿‡Eckmann-Hiltonè®ºè¯ï¼š

1. æ„é€ ä¸¤ä¸ªç¾¤è¿ç®—
2. è¯æ˜è¿ç®—äº¤æ¢æ€§
3. éªŒè¯é˜¿è´å°”æ€§è´¨

## 4. ä»£ç å®ç°

### 4.1 åŒä¼¦ä¸å˜é‡åŸºç¡€å®ç°

```rust
use std::collections::HashMap;

/// åŒä¼¦ä¸å˜é‡
#[derive(Debug, Clone)]
enum HomotopyInvariant {
    FundamentalGroup(Space, Point),
    HomotopyGroup(Space, Point, usize),
    HomologyGroup(Space, usize),
    CohomologyGroup(Space, usize),
    EulerCharacteristic(Space),
}

/// ç©ºé—´
#[derive(Debug, Clone)]
enum Space {
    Point,
    Circle,
    Sphere(usize),
    Torus,
    ProjectiveSpace(usize),
    CWComplex(Vec<Cell>),
}

/// ç‚¹
#[derive(Debug, Clone)]
struct Point {
    coordinates: Vec<f64>,
    space: Space,
}

/// èƒè…”
#[derive(Debug, Clone)]
struct Cell {
    dimension: usize,
    boundary: Vec<Cell>,
    attaching_map: Option<AttachingMap>,
}

/// é™„ç€æ˜ å°„
#[derive(Debug, Clone)]
struct AttachingMap {
    domain: Space,
    codomain: Space,
    function: Term,
}

/// åŒä¼¦ä¸å˜é‡ç³»ç»Ÿ
#[derive(Debug)]
struct HomotopyInvariantSystem {
    spaces: HashMap<String, Space>,
    invariants: HashMap<String, HomotopyInvariant>,
    groups: HashMap<String, Group>,
}

/// ç¾¤
#[derive(Debug, Clone)]
struct Group {
    elements: Vec<GroupElement>,
    operation: GroupOperation,
    identity: GroupElement,
}

/// ç¾¤å…ƒç´ 
#[derive(Debug, Clone)]
enum GroupElement {
    Identity,
    Generator(String),
    Product(Box<GroupElement>, Box<GroupElement>),
    Inverse(Box<GroupElement>),
}

/// ç¾¤è¿ç®—
#[derive(Debug, Clone)]
enum GroupOperation {
    Multiplication,
    Addition,
    Concatenation,
}

impl HomotopyInvariantSystem {
    /// åˆ›å»ºåŒä¼¦ä¸å˜é‡ç³»ç»Ÿ
    fn new() -> Self {
        HomotopyInvariantSystem {
            spaces: HashMap::new(),
            invariants: HashMap::new(),
            groups: HashMap::new(),
        }
    }
    
    /// è®¡ç®—åŸºæœ¬ç¾¤
    fn compute_fundamental_group(&self, space: &Space, base_point: &Point) -> Result<Group, String> {
        match space {
            Space::Point => {
                // å•ç‚¹ç©ºé—´çš„åŸºæœ¬ç¾¤æ˜¯å¹³å‡¡ç¾¤
                Ok(Group {
                    elements: vec![GroupElement::Identity],
                    operation: GroupOperation::Multiplication,
                    identity: GroupElement::Identity,
                })
            },
            Space::Circle => {
                // åœ†çš„åŸºæœ¬ç¾¤æ˜¯æ•´æ•°ç¾¤
                let generator = GroupElement::Generator("loop".to_string());
                let elements = vec![
                    GroupElement::Identity,
                    generator.clone(),
                    GroupElement::Inverse(Box::new(generator.clone())),
                ];
                
                Ok(Group {
                    elements,
                    operation: GroupOperation::Concatenation,
                    identity: GroupElement::Identity,
                })
            },
            Space::Sphere(dimension) => {
                if *dimension == 1 {
                    // 1ç»´çƒé¢ï¼ˆåœ†ï¼‰çš„åŸºæœ¬ç¾¤æ˜¯æ•´æ•°ç¾¤
                    self.compute_fundamental_group(&Space::Circle, base_point)
                } else {
                    // é«˜é˜¶çƒé¢çš„åŸºæœ¬ç¾¤æ˜¯å¹³å‡¡ç¾¤
                    Ok(Group {
                        elements: vec![GroupElement::Identity],
                        operation: GroupOperation::Multiplication,
                        identity: GroupElement::Identity,
                    })
                }
            },
            Space::Torus => {
                // ç¯é¢çš„åŸºæœ¬ç¾¤æ˜¯è‡ªç”±é˜¿è´å°”ç¾¤ Z Ã— Z
                let generator1 = GroupElement::Generator("meridian".to_string());
                let generator2 = GroupElement::Generator("longitude".to_string());
                let elements = vec![
                    GroupElement::Identity,
                    generator1.clone(),
                    generator2.clone(),
                    GroupElement::Product(Box::new(generator1), Box::new(generator2)),
                ];
                
                Ok(Group {
                    elements,
                    operation: GroupOperation::Concatenation,
                    identity: GroupElement::Identity,
                })
            },
            _ => Err("æ— æ³•è®¡ç®—åŸºæœ¬ç¾¤".to_string())
        }
    }
    
    /// è®¡ç®—åŒä¼¦ç¾¤
    fn compute_homotopy_group(&self, space: &Space, base_point: &Point, dimension: usize) -> Result<Group, String> {
        match space {
            Space::Sphere(n) => {
                if dimension == *n {
                    // nç»´çƒé¢çš„nç»´åŒä¼¦ç¾¤æ˜¯æ•´æ•°ç¾¤
                    let generator = GroupElement::Generator("identity".to_string());
                    let elements = vec![
                        GroupElement::Identity,
                        generator.clone(),
                        GroupElement::Inverse(Box::new(generator.clone())),
                    ];
                    
                    Ok(Group {
                        elements,
                        operation: GroupOperation::Addition,
                        identity: GroupElement::Identity,
                    })
                } else if dimension < *n {
                    // nç»´çƒé¢çš„ä½ç»´åŒä¼¦ç¾¤æ˜¯å¹³å‡¡ç¾¤
                    Ok(Group {
                        elements: vec![GroupElement::Identity],
                        operation: GroupOperation::Multiplication,
                        identity: GroupElement::Identity,
                    })
                } else {
                    // é«˜é˜¶åŒä¼¦ç¾¤éœ€è¦ç‰¹æ®Šè®¡ç®—
                    Err("é«˜é˜¶åŒä¼¦ç¾¤è®¡ç®—å¤æ‚".to_string())
                }
            },
            _ => {
                // å…¶ä»–ç©ºé—´éœ€è¦ç‰¹æ®Šå¤„ç†
                Err("æ— æ³•è®¡ç®—åŒä¼¦ç¾¤".to_string())
            }
        }
    }
    
    /// è®¡ç®—æ¬§æ‹‰ç¤ºæ€§æ•°
    fn compute_euler_characteristic(&self, space: &Space) -> Result<i32, String> {
        match space {
            Space::Point => Ok(1),
            Space::Circle => Ok(0),
            Space::Sphere(dimension) => {
                if *dimension % 2 == 0 {
                    Ok(2)
                } else {
                    Ok(0)
                }
            },
            Space::Torus => Ok(0),
            Space::ProjectiveSpace(dimension) => {
                if *dimension % 2 == 0 {
                    Ok(1)
                } else {
                    Ok(0)
                }
            },
            Space::CWComplex(cells) => {
                // è®¡ç®—CWå¤å½¢çš„æ¬§æ‹‰ç¤ºæ€§æ•°
                let mut chi = 0;
                for cell in cells {
                    if cell.dimension % 2 == 0 {
                        chi += 1;
                    } else {
                        chi -= 1;
                    }
                }
                Ok(chi)
            },
        }
    }
    
    /// æ£€æŸ¥åŒä¼¦ç­‰ä»·
    fn check_homotopy_equivalence(&self, space1: &Space, space2: &Space) -> Result<bool, String> {
        // è®¡ç®—åŒä¼¦ä¸å˜é‡
        let base_point = Point {
            coordinates: vec![0.0],
            space: space1.clone(),
        };
        
        let group1 = self.compute_fundamental_group(space1, &base_point)?;
        let group2 = self.compute_fundamental_group(space2, &base_point)?;
        
        let chi1 = self.compute_euler_characteristic(space1)?;
        let chi2 = self.compute_euler_characteristic(space2)?;
        
        // æ£€æŸ¥ä¸å˜é‡æ˜¯å¦ç›¸ç­‰
        Ok(self.groups_isomorphic(&group1, &group2) && chi1 == chi2)
    }
    
    /// æ£€æŸ¥ç¾¤åŒæ„
    fn groups_isomorphic(&self, group1: &Group, group2: &Group) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥å…ƒç´ æ•°é‡
        group1.elements.len() == group2.elements.len()
    }
}
```

### 4.2 åŒä¼¦ç¾¤è®¡ç®—ç³»ç»Ÿ

```rust
/// åŒä¼¦ç¾¤è®¡ç®—ç³»ç»Ÿ
#[derive(Debug)]
struct HomotopyGroupCalculator {
    invariant_system: HomotopyInvariantSystem,
    calculations: HashMap<String, Group>,
    theorems: HashMap<String, Theorem>,
}

/// å®šç†
#[derive(Debug, Clone)]
struct Theorem {
    name: String,
    hypothesis: Vec<Proposition>,
    conclusion: Proposition,
    proof: Option<Proof>,
}

/// å‘½é¢˜
#[derive(Debug, Clone)]
enum Proposition {
    True,
    False,
    GroupIsomorphic(Group, Group),
    SpaceHomotopyEquivalent(Space, Space),
    HomotopyGroupTrivial(Space, usize),
}

/// è¯æ˜
#[derive(Debug, Clone)]
struct Proof {
    steps: Vec<ProofStep>,
    conclusion: Proposition,
}

/// è¯æ˜æ­¥éª¤
#[derive(Debug, Clone)]
struct ProofStep {
    step_type: ProofStepType,
    premises: Vec<Proposition>,
    conclusion: Proposition,
}

#[derive(Debug, Clone)]
enum ProofStepType {
    Axiom,
    Theorem,
    Calculation,
    Deduction,
}

impl HomotopyGroupCalculator {
    /// åˆ›å»ºåŒä¼¦ç¾¤è®¡ç®—ç³»ç»Ÿ
    fn new() -> Self {
        HomotopyGroupCalculator {
            invariant_system: HomotopyInvariantSystem::new(),
            calculations: HashMap::new(),
            theorems: HashMap::new(),
        }
    }
    
    /// è®¡ç®—åŒä¼¦ç¾¤
    fn calculate_homotopy_group(&mut self, space: &Space, dimension: usize) -> Result<Group, String> {
        let base_point = Point {
            coordinates: vec![0.0],
            space: space.clone(),
        };
        
        let group = self.invariant_system.compute_homotopy_group(space, &base_point, dimension)?;
        
        // å­˜å‚¨è®¡ç®—ç»“æœ
        let key = format!("{:?}_{}", space, dimension);
        self.calculations.insert(key, group.clone());
        
        Ok(group)
    }
    
    /// åº”ç”¨å®šç†
    fn apply_theorem(&self, theorem_name: &str, space: &Space) -> Result<Proposition, String> {
        if let Some(theorem) = self.theorems.get(theorem_name) {
            // æ£€æŸ¥å®šç†å‡è®¾
            for hypothesis in &theorem.hypothesis {
                if !self.verify_hypothesis(hypothesis, space)? {
                    return Err("å®šç†å‡è®¾ä¸æ»¡è¶³".to_string());
                }
            }
            
            // è¿”å›å®šç†ç»“è®º
            Ok(theorem.conclusion.clone())
        } else {
            Err("å®šç†æœªæ‰¾åˆ°".to_string())
        }
    }
    
    /// éªŒè¯å‡è®¾
    fn verify_hypothesis(&self, hypothesis: &Proposition, space: &Space) -> Result<bool, String> {
        match hypothesis {
            Proposition::True => Ok(true),
            Proposition::False => Ok(false),
            Proposition::SpaceHomotopyEquivalent(space1, space2) => {
                self.invariant_system.check_homotopy_equivalence(space1, space2)
            },
            Proposition::HomotopyGroupTrivial(space, dimension) => {
                let base_point = Point {
                    coordinates: vec![0.0],
                    space: space.clone(),
                };
                let group = self.invariant_system.compute_homotopy_group(space, &base_point, *dimension)?;
                Ok(group.elements.len() == 1)
            },
            _ => Ok(true) // ç®€åŒ–å®ç°
        }
    }
    
    /// è®¡ç®—åŒä¼¦ä¸å˜é‡
    fn compute_invariants(&self, space: &Space) -> Result<Vec<HomotopyInvariant>, String> {
        let mut invariants = Vec::new();
        
        let base_point = Point {
            coordinates: vec![0.0],
            space: space.clone(),
        };
        
        // è®¡ç®—åŸºæœ¬ç¾¤
        let fundamental_group = self.invariant_system.compute_fundamental_group(space, &base_point)?;
        invariants.push(HomotopyInvariant::FundamentalGroup(space.clone(), base_point.clone()));
        
        // è®¡ç®—ä½ç»´åŒä¼¦ç¾¤
        for dimension in 2..=3 {
            if let Ok(group) = self.invariant_system.compute_homotopy_group(space, &base_point, dimension) {
                invariants.push(HomotopyInvariant::HomotopyGroup(space.clone(), base_point.clone(), dimension));
            }
        }
        
        // è®¡ç®—æ¬§æ‹‰ç¤ºæ€§æ•°
        let euler_characteristic = self.invariant_system.compute_euler_characteristic(space)?;
        invariants.push(HomotopyInvariant::EulerCharacteristic(space.clone()));
        
        Ok(invariants)
    }
    
    /// æ¯”è¾ƒåŒä¼¦ä¸å˜é‡
    fn compare_invariants(&self, space1: &Space, space2: &Space) -> Result<bool, String> {
        let invariants1 = self.compute_invariants(space1)?;
        let invariants2 = self.compute_invariants(space2)?;
        
        if invariants1.len() != invariants2.len() {
            return Ok(false);
        }
        
        // æ¯”è¾ƒæ¯ä¸ªä¸å˜é‡
        for (inv1, inv2) in invariants1.iter().zip(invariants2.iter()) {
            if !self.invariants_equal(inv1, inv2)? {
                return Ok(false);
            }
        }
        
        Ok(true)
    }
    
    /// æ£€æŸ¥ä¸å˜é‡ç›¸ç­‰æ€§
    fn invariants_equal(&self, inv1: &HomotopyInvariant, inv2: &HomotopyInvariant) -> Result<bool, String> {
        match (inv1, inv2) {
            (HomotopyInvariant::FundamentalGroup(space1, point1), HomotopyInvariant::FundamentalGroup(space2, point2)) => {
                let group1 = self.invariant_system.compute_fundamental_group(space1, point1)?;
                let group2 = self.invariant_system.compute_fundamental_group(space2, point2)?;
                Ok(self.invariant_system.groups_isomorphic(&group1, &group2))
            },
            (HomotopyInvariant::EulerCharacteristic(space1), HomotopyInvariant::EulerCharacteristic(space2)) => {
                let chi1 = self.invariant_system.compute_euler_characteristic(space1)?;
                let chi2 = self.invariant_system.compute_euler_characteristic(space2)?;
                Ok(chi1 == chi2)
            },
            _ => Ok(false)
        }
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 åŒä¼¦ä¸å˜é‡ä½¿ç”¨

```rust
// åŒä¼¦ä¸å˜é‡ä½¿ç”¨ç¤ºä¾‹
fn homotopy_invariant_example() {
    let mut invariant_system = HomotopyInvariantSystem::new();
    
    // æ„é€ åŸºæœ¬ç©ºé—´
    let point = Space::Point;
    let circle = Space::Circle;
    let sphere_2 = Space::Sphere(2);
    let torus = Space::Torus;
    
    let base_point = Point {
        coordinates: vec![0.0],
        space: point.clone(),
    };
    
    // è®¡ç®—åŸºæœ¬ç¾¤
    let point_group = invariant_system.compute_fundamental_group(&point, &base_point);
    println!("å•ç‚¹ç©ºé—´åŸºæœ¬ç¾¤: {:?}", point_group);
    
    let circle_group = invariant_system.compute_fundamental_group(&circle, &base_point);
    println!("åœ†åŸºæœ¬ç¾¤: {:?}", circle_group);
    
    let torus_group = invariant_system.compute_fundamental_group(&torus, &base_point);
    println!("ç¯é¢åŸºæœ¬ç¾¤: {:?}", torus_group);
    
    // è®¡ç®—åŒä¼¦ç¾¤
    let sphere_group = invariant_system.compute_homotopy_group(&sphere_2, &base_point, 2);
    println!("2ç»´çƒé¢2ç»´åŒä¼¦ç¾¤: {:?}", sphere_group);
    
    // è®¡ç®—æ¬§æ‹‰ç¤ºæ€§æ•°
    let point_chi = invariant_system.compute_euler_characteristic(&point);
    println!("å•ç‚¹ç©ºé—´æ¬§æ‹‰ç¤ºæ€§æ•°: {:?}", point_chi);
    
    let circle_chi = invariant_system.compute_euler_characteristic(&circle);
    println!("åœ†æ¬§æ‹‰ç¤ºæ€§æ•°: {:?}", circle_chi);
    
    let sphere_chi = invariant_system.compute_euler_characteristic(&sphere_2);
    println!("2ç»´çƒé¢æ¬§æ‹‰ç¤ºæ€§æ•°: {:?}", sphere_chi);
    
    let torus_chi = invariant_system.compute_euler_characteristic(&torus);
    println!("ç¯é¢æ¬§æ‹‰ç¤ºæ€§æ•°: {:?}", torus_chi);
    
    // æ£€æŸ¥åŒä¼¦ç­‰ä»·
    let point_circle_equiv = invariant_system.check_homotopy_equivalence(&point, &circle);
    println!("å•ç‚¹ç©ºé—´ä¸åœ†åŒä¼¦ç­‰ä»·: {:?}", point_circle_equiv);
    
    let circle_sphere_equiv = invariant_system.check_homotopy_equivalence(&circle, &sphere_2);
    println!("åœ†ä¸2ç»´çƒé¢åŒä¼¦ç­‰ä»·: {:?}", circle_sphere_equiv);
}

// åŒä¼¦ç¾¤è®¡ç®—ç¤ºä¾‹
fn homotopy_group_calculation_example() {
    let mut calculator = HomotopyGroupCalculator::new();
    
    // æ„é€ ç©ºé—´
    let circle = Space::Circle;
    let sphere_2 = Space::Sphere(2);
    let sphere_3 = Space::Sphere(3);
    
    // è®¡ç®—åŒä¼¦ç¾¤
    let circle_group = calculator.calculate_homotopy_group(&circle, 1);
    println!("åœ†1ç»´åŒä¼¦ç¾¤: {:?}", circle_group);
    
    let sphere_2_group = calculator.calculate_homotopy_group(&sphere_2, 2);
    println!("2ç»´çƒé¢2ç»´åŒä¼¦ç¾¤: {:?}", sphere_2_group);
    
    let sphere_3_group = calculator.calculate_homotopy_group(&sphere_3, 3);
    println!("3ç»´çƒé¢3ç»´åŒä¼¦ç¾¤: {:?}", sphere_3_group);
    
    // è®¡ç®—åŒä¼¦ä¸å˜é‡
    let circle_invariants = calculator.compute_invariants(&circle);
    println!("åœ†åŒä¼¦ä¸å˜é‡: {:?}", circle_invariants);
    
    let sphere_invariants = calculator.compute_invariants(&sphere_2);
    println!("2ç»´çƒé¢åŒä¼¦ä¸å˜é‡: {:?}", sphere_invariants);
    
    // æ¯”è¾ƒåŒä¼¦ä¸å˜é‡
    let comparison = calculator.compare_invariants(&circle, &sphere_2);
    println!("åœ†ä¸2ç»´çƒé¢ä¸å˜é‡æ¯”è¾ƒ: {:?}", comparison);
}

// ç»¼åˆåº”ç”¨ç¤ºä¾‹
fn comprehensive_invariant_example() {
    println!("=== åŒä¼¦ä¸å˜é‡ç³»ç»Ÿ ===");
    homotopy_invariant_example();
    
    println!("\n=== åŒä¼¦ç¾¤è®¡ç®—ç³»ç»Ÿ ===");
    homotopy_group_calculation_example();
    
    // åŒä¼¦ä¸å˜é‡æ—åº”ç”¨
    println!("\n=== åŒä¼¦ä¸å˜é‡æ—åº”ç”¨ ===");
    
    let mut calculator = HomotopyGroupCalculator::new();
    
    // æ„é€ åŒä¼¦ä¸å˜é‡æ—
    let invariant_family = vec![
        "FundamentalGroup".to_string(),
        "HomotopyGroup".to_string(),
        "EulerCharacteristic".to_string(),
        "HomologyGroup".to_string(),
    ];
    
    println!("åŒä¼¦ä¸å˜é‡æ—: {:?}", invariant_family);
    
    // æ„é€ ç©ºé—´æ—
    let space_family = vec![
        Space::Point,
        Space::Circle,
        Space::Sphere(2),
        Space::Torus,
        Space::ProjectiveSpace(2),
    ];
    
    println!("ç©ºé—´æ—: {:?}", space_family);
    
    // è®¡ç®—æ‰€æœ‰ç©ºé—´çš„ä¸å˜é‡
    for space in &space_family {
        let invariants = calculator.compute_invariants(space);
        println!("{:?} çš„ä¸å˜é‡: {:?}", space, invariants);
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸åŒä¼¦ç±»å‹è®ºçš„å…³ç³»

åŒä¼¦ä¸å˜é‡ä¸åŒä¼¦ç±»å‹è®ºçš„å…³ç³»ï¼š

1. **æ ¸å¿ƒæ¦‚å¿µ**ï¼šåŒä¼¦ä¸å˜é‡æ˜¯åŒä¼¦ç±»å‹è®ºçš„æ ¸å¿ƒæ¦‚å¿µ
2. **ç±»å‹è§£é‡Š**ï¼šåŒä¼¦ä¸å˜é‡å¯ä»¥è§£é‡Šä¸ºç±»å‹
3. **åŒä¼¦ç­‰ä»·**ï¼šåŒä¼¦ä¸å˜é‡ä¸åŒä¼¦ç­‰ä»·ç›¸å…³
4. **ç±»å‹å®‰å…¨**ï¼šåŒä¼¦ä¸å˜é‡ä¿è¯ç±»å‹å®‰å…¨

### 6.2 ä¸æ‹“æ‰‘å­¦çš„å…³ç³»

åŒä¼¦ä¸å˜é‡ä¸æ‹“æ‰‘å­¦çš„å…³ç³»ï¼š

1. **æ‹“æ‰‘ç©ºé—´**ï¼šåŒä¼¦ä¸å˜é‡ç”¨äºåŒºåˆ†æ‹“æ‰‘ç©ºé—´
2. **åŒä¼¦ç­‰ä»·**ï¼šåŒä¼¦ä¸å˜é‡åœ¨åŒä¼¦ç­‰ä»·ä¸‹ä¸å˜
3. **ä»£æ•°æ‹“æ‰‘**ï¼šåŒä¼¦ä¸å˜é‡æ˜¯ä»£æ•°æ‹“æ‰‘çš„æ ¸å¿ƒ
4. **å‡ ä½•ä¸å˜é‡**ï¼šåŒä¼¦ä¸å˜é‡æ˜¯å‡ ä½•ä¸å˜é‡

### 6.3 ä¸ä»£æ•°å‡ ä½•çš„å…³ç³»

åŒä¼¦ä¸å˜é‡ä¸ä»£æ•°å‡ ä½•çš„å…³ç³»ï¼š

1. **ä»£æ•°ç°‡**ï¼šåŒä¼¦ä¸å˜é‡ç”¨äºç ”ç©¶ä»£æ•°ç°‡
2. **é™ˆç±»**ï¼šåŒä¼¦ä¸å˜é‡ä¸é™ˆç±»ç›¸å…³
3. **ä¸ŠåŒè°ƒ**ï¼šåŒä¼¦ä¸å˜é‡ä¸ä¸ŠåŒè°ƒç›¸å…³
4. **å‡ ä½•ä¸å˜é‡**ï¼šåŒä¼¦ä¸å˜é‡æ˜¯å‡ ä½•ä¸å˜é‡

## 7. å‚è€ƒæ–‡çŒ®

1. Hatcher, A. (2002). Algebraic topology. Cambridge University Press.
2. May, J. P. (1999). A concise course in algebraic topology. University of Chicago Press.
3. Spanier, E. H. (1966). Algebraic topology. McGraw-Hill.
4. Whitehead, G. W. (1978). Elements of homotopy theory. Springer.
5. Steenrod, N. E. (1951). The topology of fibre bundles. Princeton University Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [04.5.4 é«˜é˜¶å½’çº³ç±»å‹](../04.5.4_é«˜é˜¶å½’çº³ç±»å‹.md)
- [04.5.6 åŒä¼¦ç¾¤](../04.5.6_åŒä¼¦ç¾¤.md)
- [04.6.1 ç±»å‹å®‰å…¨](../04.6.1_ç±»å‹å®‰å…¨.md)
- [04.5.1 åŒä¼¦ç†è®º](../04.5.1_åŒä¼¦ç†è®º.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
