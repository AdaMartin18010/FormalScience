# 04.1.4 ä¾èµ–ç±»å‹

## ğŸ“‹ æ¦‚è¿°

ä¾èµ–ç±»å‹æ˜¯ç±»å‹ç†è®ºçš„é«˜çº§æ¦‚å¿µï¼Œå…è®¸ç±»å‹ä¾èµ–äºå€¼ã€‚æœ¬æ–‡æ¡£å»ºç«‹ä¸¥æ ¼çš„ä¾èµ–ç±»å‹ç†è®ºæ¡†æ¶ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ä¸¥æ ¼çš„ä¾èµ–ç±»å‹æ¦‚å¿µå’Œå½¢å¼åŒ–å®šä¹‰
2. è¯æ˜ä¾èµ–ç±»å‹çš„åŸºæœ¬å®šç†
3. æä¾›å®Œæ•´çš„ä»£ç å®ç°
4. å±•ç¤ºä¾èµ–ç±»å‹åœ¨å½¢å¼ç§‘å­¦ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ä¾èµ–ç±»å‹çš„åŸºæœ¬æ€æƒ³

**å®šä¹‰ 1.1.1** (ä¾èµ–ç±»å‹)
ä¾èµ–ç±»å‹å…è®¸ç±»å‹ä¾èµ–äºå€¼ï¼Œå³ç±»å‹å¯ä»¥åŒ…å«å€¼è¡¨è¾¾å¼ã€‚

**å®šä¹‰ 1.1.2** (ä¾èµ–å‡½æ•°ç±»å‹)
ä¾èµ–å‡½æ•°ç±»å‹ $\Pi x:A. B(x)$ è¡¨ç¤ºå¯¹äºæ‰€æœ‰ $x:A$ï¼Œå‡½æ•°è¿”å›ç±»å‹ $B(x)$ã€‚

**å®šä¹‰ 1.1.3** (ä¾èµ–å¯¹ç±»å‹)
ä¾èµ–å¯¹ç±»å‹ $\Sigma x:A. B(x)$ è¡¨ç¤ºå­˜åœ¨ $x:A$ å’Œå€¼ $b:B(x)$ çš„å¯¹ã€‚

### 1.2 é©¬ä¸-æ´›å¤«ç±»å‹è®º

**å®šä¹‰ 1.2.1** (é©¬ä¸-æ´›å¤«ç±»å‹è®º)
é©¬ä¸-æ´›å¤«ç±»å‹è®ºæ˜¯ä¾èµ–ç±»å‹ç†è®ºçš„åŸºç¡€ï¼ŒåŒ…å«ï¼š

- ç±»å‹å½¢æˆè§„åˆ™
- é¡¹å½¢æˆè§„åˆ™
- è®¡ç®—è§„åˆ™
- ç±»å‹ç­‰ä»·è§„åˆ™

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ä¾èµ–ç±»å‹è¯­æ³•

**å®šä¹‰ 2.1.1** (ä¾èµ–ç±»å‹è¯­æ³•)
ä¾èµ–ç±»å‹çš„è¯­æ³•å®šä¹‰ä¸ºï¼š
$$A, B ::= \text{Type} \mid x \mid A \to B \mid \Pi x:A. B \mid \Sigma x:A. B \mid \text{Id}_A(x, y)$$

### 2.2 ç±»å‹å½¢æˆè§„åˆ™

**å®šä¹‰ 2.2.1** (ç±»å‹å½¢æˆè§„åˆ™)

1. **å®‡å®™è§„åˆ™**ï¼š$\vdash \text{Type} : \text{Type}$
2. **ä¾èµ–å‡½æ•°ç±»å‹**ï¼š$\frac{\Gamma \vdash A : \text{Type} \quad \Gamma, x:A \vdash B : \text{Type}}{\Gamma \vdash \Pi x:A. B : \text{Type}}$
3. **ä¾èµ–å¯¹ç±»å‹**ï¼š$\frac{\Gamma \vdash A : \text{Type} \quad \Gamma, x:A \vdash B : \text{Type}}{\Gamma \vdash \Sigma x:A. B : \text{Type}}$

## 3. å®šç†ä¸è¯æ˜

### 3.1 ç±»å‹å®‰å…¨å®šç†

**å®šç† 3.1.1** (ç±»å‹ä¿æŒ)
å¦‚æœ $\Gamma \vdash t : A$ ä¸” $t \to t'$ï¼Œåˆ™ $\Gamma \vdash t' : A$ã€‚

**å®šç† 3.1.2** (å¼ºæ­£è§„åŒ–)
ä¾èµ–ç±»å‹ç†è®ºä¸­çš„æ¯ä¸ªè‰¯ç±»å‹é¡¹éƒ½æ˜¯å¼ºæ­£è§„åŒ–çš„ã€‚

## 4. ä»£ç å®ç°

### 4.1 Rust å®ç°

```rust
/// ä¾èµ–ç±»å‹å®ç°
pub struct DependentType;

impl DependentType {
    /// ä¾èµ–å‡½æ•°ç±»å‹
    pub fn dependent_function<A, B, F>(f: F) -> DependentFunction<A, B, F> 
    where
        F: Fn(A) -> B,
    {
        DependentFunction { f }
    }
    
    /// ä¾èµ–å¯¹ç±»å‹
    pub fn dependent_pair<A, B>(a: A, b: B) -> DependentPair<A, B> {
        DependentPair { first: a, second: b }
    }
}

/// ä¾èµ–å‡½æ•°ç±»å‹
pub struct DependentFunction<A, B, F> {
    f: F,
}

impl<A, B, F> DependentFunction<A, B, F>
where
    F: Fn(A) -> B,
{
    pub fn apply(&self, x: A) -> B {
        (self.f)(x)
    }
}

/// ä¾èµ–å¯¹ç±»å‹
pub struct DependentPair<A, B> {
    pub first: A,
    pub second: B,
}

/// å‘é‡ç±»å‹ï¼ˆä¾èµ–ç±»å‹çš„ç»å…¸ä¾‹å­ï¼‰
pub struct Vector<T> {
    data: Vec<T>,
    length: usize,
}

impl<T> Vector<T> {
    pub fn new() -> Self {
        Self {
            data: Vec::new(),
            length: 0,
        }
    }
    
    pub fn cons(mut self, x: T) -> Vector<T> {
        self.data.push(x);
        self.length += 1;
        self
    }
    
    pub fn head(&self) -> Option<&T> {
        self.data.first()
    }
    
    pub fn tail(&self) -> Option<Vector<T>> {
        if self.length > 0 {
            Some(Vector {
                data: self.data[1..].to_vec(),
                length: self.length - 1,
            })
        } else {
            None
        }
    }
    
    pub fn length(&self) -> usize {
        self.length
    }
    
    /// ç±»å‹å®‰å…¨çš„ç´¢å¼•è®¿é—®
    pub fn index(&self, i: usize) -> Option<&T> {
        if i < self.length {
            self.data.get(i)
        } else {
            None
        }
    }
}

/// æœ‰é™é›†åˆç±»å‹
pub struct FiniteSet<T> {
    elements: Vec<T>,
    size: usize,
}

impl<T: Clone + PartialEq> FiniteSet<T> {
    pub fn new() -> Self {
        Self {
            elements: Vec::new(),
            size: 0,
        }
    }
    
    pub fn insert(&mut self, x: T) {
        if !self.elements.contains(&x) {
            self.elements.push(x);
            self.size += 1;
        }
    }
    
    pub fn size(&self) -> usize {
        self.size
    }
    
    pub fn contains(&self, x: &T) -> bool {
        self.elements.contains(x)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_dependent_function() {
        let f = DependentType::dependent_function(|x: i32| x * 2);
        assert_eq!(f.apply(5), 10);
    }
    
    #[test]
    fn test_dependent_pair() {
        let pair = DependentType::dependent_pair(5, "hello");
        assert_eq!(pair.first, 5);
        assert_eq!(pair.second, "hello");
    }
    
    #[test]
    fn test_vector() {
        let v = Vector::new().cons(1).cons(2).cons(3);
        assert_eq!(v.length(), 3);
        assert_eq!(v.index(1), Some(&2));
    }
}
```

### 4.2 Haskell å®ç°

```haskell
-- ä¾èµ–ç±»å‹
module DependentTypes where

-- ä¾èµ–å‡½æ•°ç±»å‹
newtype DependentFunction a b = DependentFunction (a -> b)

apply :: DependentFunction a b -> a -> b
apply (DependentFunction f) = f

-- ä¾èµ–å¯¹ç±»å‹
data DependentPair a b = DependentPair a b

-- å‘é‡ç±»å‹
data Vector a = Empty | Cons a (Vector a)

length :: Vector a -> Int
length Empty = 0
length (Cons _ xs) = 1 + length xs

head :: Vector a -> Maybe a
head Empty = Nothing
head (Cons x _) = Just x

tail :: Vector a -> Maybe (Vector a)
tail Empty = Nothing
tail (Cons _ xs) = Just xs

index :: Vector a -> Int -> Maybe a
index Empty _ = Nothing
index (Cons x xs) 0 = Just x
index (Cons _ xs) n = index xs (n - 1)

-- æœ‰é™é›†åˆç±»å‹
data FiniteSet a = FiniteSet [a]

empty :: FiniteSet a
empty = FiniteSet []

insert :: Eq a => a -> FiniteSet a -> FiniteSet a
insert x (FiniteSet xs) = FiniteSet (x : xs)

size :: FiniteSet a -> Int
size (FiniteSet xs) = length xs

contains :: Eq a => a -> FiniteSet a -> Bool
contains x (FiniteSet xs) = x `elem` xs

-- æµ‹è¯•å‡½æ•°
testDependentTypes :: IO ()
testDependentTypes = do
    putStrLn "ä¾èµ–ç±»å‹æµ‹è¯•:"
    
    -- æµ‹è¯•ä¾èµ–å‡½æ•°
    let f = DependentFunction (\x -> x * 2)
    print $ apply f 5
    
    -- æµ‹è¯•ä¾èµ–å¯¹
    let pair = DependentPair 5 "hello"
    print pair
    
    -- æµ‹è¯•å‘é‡
    let v = Cons 1 (Cons 2 (Cons 3 Empty))
    print $ length v
    print $ index v 1
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å½¢å¼åŒ–éªŒè¯ä¸­çš„åº”ç”¨

```rust
/// å½¢å¼åŒ–éªŒè¯ä¸­çš„ä¾èµ–ç±»å‹
pub struct FormalVerification;

impl FormalVerification {
    /// é•¿åº¦ä¿æŒçš„å‘é‡
    pub fn length_preserving_vector<T>() -> LengthPreservingVector<T> {
        LengthPreservingVector::new()
    }
    
    /// æ’åºä¿æŒçš„å‘é‡
    pub fn sorted_vector<T: Ord>() -> SortedVector<T> {
        SortedVector::new()
    }
}

/// é•¿åº¦ä¿æŒçš„å‘é‡
pub struct LengthPreservingVector<T> {
    data: Vec<T>,
    invariant: LengthInvariant,
}

struct LengthInvariant {
    expected_length: usize,
}

impl<T> LengthPreservingVector<T> {
    pub fn new() -> Self {
        Self {
            data: Vec::new(),
            invariant: LengthInvariant { expected_length: 0 },
        }
    }
    
    pub fn push(&mut self, x: T) {
        self.data.push(x);
        self.invariant.expected_length += 1;
        self.verify_invariant();
    }
    
    fn verify_invariant(&self) {
        assert_eq!(self.data.len(), self.invariant.expected_length);
    }
}

/// æ’åºä¿æŒçš„å‘é‡
pub struct SortedVector<T: Ord> {
    data: Vec<T>,
}

impl<T: Ord> SortedVector<T> {
    pub fn new() -> Self {
        Self { data: Vec::new() }
    }
    
    pub fn insert(&mut self, x: T) {
        // ä¿æŒæ’åºçš„æ’å…¥
        let pos = self.data.binary_search(&x).unwrap_or_else(|e| e);
        self.data.insert(pos, x);
    }
    
    pub fn is_sorted(&self) -> bool {
        self.data.windows(2).all(|w| w[0] <= w[1])
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸ç®€å•ç±»å‹Î»æ¼”ç®—çš„å…³ç³»

ä¾èµ–ç±»å‹æ˜¯ç®€å•ç±»å‹Î»æ¼”ç®—çš„æ‰©å±•ï¼Œæ·»åŠ äº†ç±»å‹ä¾èµ–å€¼çš„èƒ½åŠ›ã€‚

### 6.2 ä¸åŒä¼¦ç±»å‹è®ºçš„å…³ç³»

**å®šç† 6.2.1** (ä¾èµ–ç±»å‹ä¸åŒä¼¦ç±»å‹è®º)
åŒä¼¦ç±»å‹è®ºæ˜¯ä¾èµ–ç±»å‹ç†è®ºçš„è¿›ä¸€æ­¥æ‰©å±•ï¼Œæ·»åŠ äº†è·¯å¾„ç±»å‹å’Œå•å€¼å…¬ç†ã€‚

### 6.3 ä¸è¯æ˜ç†è®ºçš„å…³ç³»

ä¾èµ–ç±»å‹ç†è®ºä¸ºè¯æ˜ç†è®ºæä¾›åŸºç¡€ï¼Œå®ç°äº†"ç¨‹åºå³è¯æ˜"çš„æ€æƒ³ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. **Martin-LÃ¶f, P.** (1984). *Intuitionistic Type Theory*. Bibliopolis.
2. **Coquand, T., & Huet, G.** (1988). *The Calculus of Constructions*. Information and Computation.
3. **Barendregt, H.** (1992). *Lambda Calculi with Types*. Handbook of Logic in Computer Science.
4. **Pierce, B. C.** (2002). *Types and Programming Languages*. MIT Press.
5. **Univalent Foundations Program.** (2013). *Homotopy Type Theory: Univalent Foundations of Mathematics*. Institute for Advanced Study.

---

**ç›¸å…³æ–‡æ¡£**:

- [04.1.1 ç®€å•ç±»å‹Î»æ¼”ç®—](../04.1.1_ç®€å•ç±»å‹Î»æ¼”ç®—.md)
- [04.1.2 Hindley-Milnerç±»å‹ç³»ç»Ÿ](../04.1.2_Hindley_Milnerç±»å‹ç³»ç»Ÿ.md)
- [04.1.3 ç³»ç»ŸF](../04.1.3_ç³»ç»ŸF.md)
- [04.4.1 ä¾èµ–ç±»å‹åŸºç¡€](../04.4.1_ä¾èµ–ç±»å‹åŸºç¡€.md)
- [04.4.2 é©¬ä¸-æ´›å¤«ç±»å‹è®º](../04.4.2_é©¬ä¸-æ´›å¤«ç±»å‹è®º.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
