# 04.2 依赖类型论（Dependent Type Theory, DTT）

**创建时间**: 2025-01-17  
**最后更新**: 2025-01-17  
**文档状态**: 活跃  
**关联模块**: `04_Type_Theory`

## 📝 概述

依赖类型论允许类型依赖于项（值），以此在类型层级表达精细的程序与数学性质。通过在类型层编码约束（如"向量长度为 n""矩阵维度为 m×n""排序结果保持元素多重集不变"），DTT 将"证明即程序"的构造主义观点推进到可执行层面，成为现代交互式定理证明与可验证编程的核心基础。

## 📜 历史与背景

- Church 的 λ演算与类型化λ演算奠定语法与语义基础
- Curry–Howard 对应揭示"命题即类型，证明即程序"
- Martin‑Löf 构造主义类型论提出依赖函数（Π）与依赖对（Σ）
- Coquand 等发展 Calculus of Constructions 与其扩展（Coq 核心）
- 近年来与同伦类型论（HoTT）和范畴语义（CwF、拟范畴）深度融合

## 🔣 形式系统与判断

标准判断（随具体系统略有差异）：

- `Γ ⊢ A : 𝒰ᵢ`  类型形成（A 是第 i 层宇宙的类型）
- `Γ ⊢ a : A`    项形成（a 的类型为 A）
- `Γ ⊢ A ≡ B`    类型相等（或 `A = B`）
- `Γ ⊢ a ≡ b : A` 项相等（或 `a = b : A`）

核心构造与形成规则（示例）：

- Π‑类型（依赖函数）  `Π (x : A). B(x)`  表示依赖于 x 的返回类型
- Σ‑类型（依赖对）    `Σ (x : A). B(x)`  表示 `(a : A, b : B(a))`
- Id‑类型（恒等/相等）  `Id_A(a, b)` 或 `a =_A b`
- W‑类型（广义归纳）   构造一般归纳数据类型
- 自然数、列表、树等归纳类型 由归纳原理与消去子刻画
- 宇宙层级 `𝒰₀ : 𝒰₁ : 𝒰₂ : …`（可累积/非累积）避免 Girard 悖论

示例（规则示意）：

- Π‑形成：`Γ ⊢ A : 𝒰ᵢ, Γ, x:A ⊢ B(x) : 𝒰ⱼ  ⇒  Γ ⊢ Πx:A. B(x) : 𝒰_max(i,j)`
- λ‑引入：`Γ, x:A ⊢ t : B(x)  ⇒  Γ ⊢ (λx. t) : Πx:A. B(x)`
- 应用消去：`Γ ⊢ f : Πx:A. B(x), Γ ⊢ a : A  ⇒  Γ ⊢ f a : B(a)`
- β/η 规律：确保函数与依赖对的规范计算行为

## 🧠 元理论性质（典型目标）

- 进展（Progress）与保型（Preservation）：执行不陷入、类型随执行保持
- 强规范化/弱规范化：项归约至规范形（视系统与扩展而定）
- 一致性：不可推出空类型 inhabit（与外延性、公理扩展相关）
- 可判定性：类型检查与相等判定的可计算性（依赖于相等定义与内核设计）
- 规范性（Canonicity）：如 `Nat` 上闭项能化归到标准构造子

说明：不同风格（内涵/外延、带公理的 HoTT、Cubical 等）在上述性质上各有取舍。

## 🧩 语义模型与解释

- 集合论/集合代数语义：以集合与函数解释类型与项（受未定理/选择公理影响）
- PER/Setoid 语义：以同值关系刻画可计算等价，服务于可计算性与抽象性
- 范畴语义：CwF（有家族的范畴）、族范畴、依赖笛卡儿闭范畴等
- 同伦语义：以空间/路径解释相等与高维结构（与 HoTT 接轨）
- 立方体/拟范畴模型：支撑 Univalence 与高归纳类型的可计算语义

## 🛠️ 实现与工具链

- Coq：Calculus of Inductive Constructions（CIC），支持依赖/归纳类型与程序提取
- Agda：依赖类型语言，交互式构造证明，模式匹配友好
- Lean：依赖类型定理证明器，Mathlib 生态发达，支持自动化与元编程
- Idris/F★：更偏可执行与工程化的依赖类型语言，用于安全编程与验证

典型实践：

- 规范化编译器/解释器证明（类型保型、语义保留）
- 协议/密码学性质验证（安全性、终止性、信息流）
- 算法正确性与复杂度不变量在类型层编码

## 🧪 示例片段

```agda
-- 以向量长度为类型参数的安全操作（示意）
record Vec (A : Set) (n : Nat) : Set where
  constructor _::_
  field head : A
        tail : Vec A n

safeHead : ∀ {A n} → Vec A (suc n) → A
safeHead v = Vec.head v
```

```lean
-- 依赖返回类型示意：长度保形映射
def mapVec {α β : Type} {n : Nat}
  (f : α → β) : Vector α n → Vector β n :=
λ v => Vector.map f v
```

## 🔗 与模块内主题的关系

- 与 `04.1 简单类型理论`：DTT 泛化 STLC 的函数/积/和类型，增加依赖性与宇宙
- 与 `04.3 线性类型理论`：可融合资源约束形成依赖‑线性体系（DILL 等）
- 与 `04.4 同伦类型论 (HoTT)`：在等同性与高维结构上进一步公理化（Univalence/HITs）
- 与 `04.5 Curry–Howard`：将"命题即类型"拓展到依赖命题、证明/程序统一

## 🧭 方法学与批判性哲学

- 构造主义与本体论：数学对象的存在须由构造给出，抵制不可构造存在论
- 认识论：知识即可检验的构造，证明即程序的可执行性强化了"可知即可为"
- 语义多元：集合、范畴、同伦等多重解释彼此制衡，防止单一语义独断
- 工程与伦理：形式化验证降低系统性风险，但成本与门槛构成新的不平等
- 元反思：当证明成为程序，谁应为证明‑程序缺陷负责？如何治理工具偏见？

## 🧭 Wiki 对齐的条目结构（对外读者）

- 概述｜历史｜语法与语义｜规则与计算｜元性质｜模型｜实现｜应用｜批判｜参见｜参考

## 📚 参见（See also）

- [04.1 简单类型理论](../04.1_Simple_Type_Theory/04.1_Simple_Type_Theory.md)
- [04.3 线性类型理论](../04.3_Linear_Type_Theory/05.3_Linear_Type_Theory.md)
- [04.4 同伦类型理论](../04.4_Homotopy_Type_Theory/05.4_Homotopy_Type_Theory.md)
- [04.5 Curry-Howard 对应](../04.5_Curry_Howard_Correspondence/05.5_Curry_Howard_Correspondence.md)
- [统一术语表](../TERMINOLOGY_TABLE.md)

## 📖 参考文献（精选）

1. Martin-Löf, P. (1975). An intuitionistic theory of types. *Preprint*, University of Stockholm.
2. Coquand, T., & Huet, G. (1988). The calculus of constructions. *Information and Computation*, 76(2-3), 95-120.
3. The Univalent Foundations Program. (2013). *Homotopy Type Theory: Univalent Foundations of Mathematics*. Institute for Advanced Study.
4. Benton, N., Bierman, G., de Paiva, V., & Hyland, M. (1993). A term calculus for intuitionistic linear logic. *TLCA*, 75-90.
5. Harper, R. (2016). *Practical Foundations for Programming Languages*. Cambridge University Press.

## 🔧 Coq 最小证明片段

```coq
(* Π-类型：依赖函数 *)
Definition id_family (A : Type) : A -> A := fun x => x.

(* Σ-类型：依赖对 *)
Inductive sigT {A : Type} (P : A -> Type) : Type :=
  existT : forall x : A, P x -> sigT P.

(* Id-类型：同一性类型 *)
Inductive eq {A : Type} (x : A) : A -> Prop :=
  eq_refl : eq x x.

(* 示例：向量长度保持 *)
Fixpoint map_vec {A B : Type} (f : A -> B) {n : nat} 
  (v : Vector.t A n) : Vector.t B n :=
  match v with
  | Vector.nil => Vector.nil
  | Vector.cons h t => Vector.cons (f h) (map_vec f t)
  end.
```
