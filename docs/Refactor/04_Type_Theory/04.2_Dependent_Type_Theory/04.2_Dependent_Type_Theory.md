# 04.2 依赖类型论（Dependent Type Theory, DTT）

**创建时间**: 2025-01-17  
**最后更新**: 2025-01-17  
**文档状态**: 活跃  
**关联模块**: `04_Type_Theory`

## 📝 概述

依赖类型论允许类型依赖于项（值），以此在类型层级表达精细的程序与数学性质。通过在类型层编码约束（如“向量长度为 n”“矩阵维度为 m×n”“排序结果保持元素多重集不变”），DTT 将“证明即程序”的构造主义观点推进到可执行层面，成为现代交互式定理证明与可验证编程的核心基础。

## 📜 历史与背景

- Church 的 λ演算与类型化λ演算奠定语法与语义基础
- Curry–Howard 对应揭示“命题即类型，证明即程序”
- Martin‑Löf 构造主义类型论提出依赖函数（Π）与依赖对（Σ）
- Coquand 等发展 Calculus of Constructions 与其扩展（Coq 核心）
- 近年来与同伦类型论（HoTT）和范畴语义（CwF、拟范畴）深度融合

## 🔣 形式系统与判断

标准判断（随具体系统略有差异）：

- `Γ ⊢ A : 𝒰ᵢ`  类型形成（A 是第 i 层宇宙的类型）
- `Γ ⊢ a : A`    项形成（a 的类型为 A）
- `Γ ⊢ A ≡ B`    类型相等（或 `A = B`）
- `Γ ⊢ a ≡ b : A` 项相等（或 `a = b : A`）

核心构造与形成规则（示例）：

- Π‑类型（依赖函数）  `Π (x : A). B(x)`  表示依赖于 x 的返回类型
- Σ‑类型（依赖对）    `Σ (x : A). B(x)`  表示 `(a : A, b : B(a))`
- Id‑类型（恒等/相等）  `Id_A(a, b)` 或 `a =_A b`
- W‑类型（广义归纳）   构造一般归纳数据类型
- 自然数、列表、树等归纳类型 由归纳原理与消去子刻画
- 宇宙层级 `𝒰₀ : 𝒰₁ : 𝒰₂ : …`（可累积/非累积）避免 Girard 悖论

示例（规则示意）：

- Π‑形成：`Γ ⊢ A : 𝒰ᵢ, Γ, x:A ⊢ B(x) : 𝒰ⱼ  ⇒  Γ ⊢ Πx:A. B(x) : 𝒰_max(i,j)`
- λ‑引入：`Γ, x:A ⊢ t : B(x)  ⇒  Γ ⊢ (λx. t) : Πx:A. B(x)`
- 应用消去：`Γ ⊢ f : Πx:A. B(x), Γ ⊢ a : A  ⇒  Γ ⊢ f a : B(a)`
- β/η 规律：确保函数与依赖对的规范计算行为

## 🧠 元理论性质（典型目标）

- 进展（Progress）与保型（Preservation）：执行不陷入、类型随执行保持
- 强规范化/弱规范化：项归约至规范形（视系统与扩展而定）
- 一致性：不可推出空类型 inhabit（与外延性、公理扩展相关）
- 可判定性：类型检查与相等判定的可计算性（依赖于相等定义与内核设计）
- 规范性（Canonicity）：如 `Nat` 上闭项能化归到标准构造子

说明：不同风格（内涵/外延、带公理的 HoTT、Cubical 等）在上述性质上各有取舍。

## 🧩 语义模型与解释

- 集合论/集合代数语义：以集合与函数解释类型与项（受未定理/选择公理影响）
- PER/Setoid 语义：以同值关系刻画可计算等价，服务于可计算性与抽象性
- 范畴语义：CwF（有家族的范畴）、族范畴、依赖笛卡儿闭范畴等
- 同伦语义：以空间/路径解释相等与高维结构（与 HoTT 接轨）
- 立方体/拟范畴模型：支撑 Univalence 与高归纳类型的可计算语义

## 🛠️ 实现与工具链

- Coq：Calculus of Inductive Constructions（CIC），支持依赖/归纳类型与程序提取
- Agda：依赖类型语言，交互式构造证明，模式匹配友好
- Lean：依赖类型定理证明器，Mathlib 生态发达，支持自动化与元编程
- Idris/F★：更偏可执行与工程化的依赖类型语言，用于安全编程与验证

典型实践：

- 规范化编译器/解释器证明（类型保型、语义保留）
- 协议/密码学性质验证（安全性、终止性、信息流）
- 算法正确性与复杂度不变量在类型层编码

## 🧪 示例片段

```agda
-- 以向量长度为类型参数的安全操作（示意）
record Vec (A : Set) (n : Nat) : Set where
  constructor _::_
  field head : A
        tail : Vec A n

safeHead : ∀ {A n} → Vec A (suc n) → A
safeHead v = Vec.head v
```

```lean
-- 依赖返回类型示意：长度保形映射
def mapVec {α β : Type} {n : Nat}
  (f : α → β) : Vector α n → Vector β n :=
λ v => Vector.map f v
```

## 🔗 与模块内主题的关系

- 与 `04.1 简单类型理论`：DTT 泛化 STLC 的函数/积/和类型，增加依赖性与宇宙
- 与 `04.3 线性类型理论`：可融合资源约束形成依赖‑线性体系（DILL 等）
- 与 `04.4 同伦类型论 (HoTT)`：在等同性与高维结构上进一步公理化（Univalence/HITs）
- 与 `04.5 Curry–Howard`：将“命题即类型”拓展到依赖命题、证明/程序统一

## 🧭 方法学与批判性哲学

- 构造主义与本体论：数学对象的存在须由构造给出，抵制不可构造存在论
- 认识论：知识即可检验的构造，证明即程序的可执行性强化了“可知即可为”
- 语义多元：集合、范畴、同伦等多重解释彼此制衡，防止单一语义独断
- 工程与伦理：形式化验证降低系统性风险，但成本与门槛构成新的不平等
- 元反思：当证明成为程序，谁应为证明‑程序缺陷负责？如何治理工具偏见？

## 🧭 Wiki 对齐的条目结构（对外读者）

- 概述｜历史｜语法与语义｜规则与计算｜元性质｜模型｜实现｜应用｜批判｜参见｜参考

## 📚 参见（See also）

- [04.1 简单类型理论](../04.1_Simple_Type_Theory/04.1_Simple_Type_Theory.md)
- [04.3 线性类型理论](../04.3_Linear_Type_Theory/05.3_Linear_Type_Theory.md)
- [04.4 同伦类型理论](../04.4_Homotopy_Type_Theory/05.4_Homotopy_Type_Theory.md)
- [04.5 Curry-Howard 对应](../04.5_Curry_Howard_Correspondence/05.5_Curry_Howard_Correspondence.md)
- [统一术语表](../TERMINOLOGY_TABLE.md)

## 📖 参考文献（精选）

1. Per Martin‑Löf. “An Intuitionistic Theory of Types.” 1975.  
2. Thierry Coquand, Gérard Huet. “The Calculus of Constructions.” 1988.  
3. The Univalent Foundations Program. “HoTT Book.” 2013.  
4. N. Benton et al. “A Linear/Non‑linear Lambda Calculus.” 1993.  
5. R. Harper. “Practical Foundations for Programming Languages.”  
