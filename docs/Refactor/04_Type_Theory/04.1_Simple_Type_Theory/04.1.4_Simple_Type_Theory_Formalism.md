# 04.1.1 ç®€å•ç±»å‹ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç®€å•ç±»å‹ç†è®ºæ˜¯ç±»å‹ç†è®ºçš„åŸºç¡€ï¼Œå®ƒå¼•å…¥äº†ç±»å‹çš„æ¦‚å¿µæ¥é˜²æ­¢ç¨‹åºé”™è¯¯å¹¶æé«˜ä»£ç çš„å¯é æ€§ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦æ„å»ºç®€å•ç±»å‹ç†è®ºçš„ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬ç±»å‹ç³»ç»Ÿã€ç±»å‹æ¨å¯¼å’Œç±»å‹å®‰å…¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹ç®€å•ç±»å‹ç†è®ºçš„å½¢å¼åŒ–åŸºç¡€**
2. **åˆ†æç±»å‹ç³»ç»Ÿçš„ç»“æ„**
3. **æ¢è®¨ç±»å‹æ¨å¯¼ç®—æ³•**
4. **ç ”ç©¶ç±»å‹å®‰å…¨æ€§è´¨**
5. **æ„å»ºç±»å‹ç†è®ºçš„åº”ç”¨æ¡†æ¶**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç®€å•ç±»å‹ç†è®ºçš„å®šä¹‰

ç®€å•ç±»å‹ç†è®ºï¼ˆSimply Typed Lambda Calculusï¼‰æ˜¯Î»æ¼”ç®—çš„ç±»å‹åŒ–ç‰ˆæœ¬ï¼Œå®ƒï¼š

- **å¼•å…¥ç±»å‹**ï¼šä¸ºæ¯ä¸ªé¡¹åˆ†é…ç±»å‹
- **ç±»å‹æ£€æŸ¥**ï¼šç¡®ä¿ç±»å‹ä¸€è‡´æ€§
- **ç±»å‹å®‰å…¨**ï¼šé˜²æ­¢ç±»å‹é”™è¯¯
- **ç±»å‹æ¨å¯¼**ï¼šè‡ªåŠ¨æ¨æ–­ç±»å‹

### 1.2 åŸºæœ¬ç±»å‹

1. **åŸºæœ¬ç±»å‹**ï¼šå¦‚ `Int`ã€`Bool`ã€`String`
2. **å‡½æ•°ç±»å‹**ï¼šå¦‚ `A â†’ B`
3. **ç§¯ç±»å‹**ï¼šå¦‚ `A Ã— B`
4. **å’Œç±»å‹**ï¼šå¦‚ `A + B`

### 1.3 ç±»å‹ç³»ç»Ÿçš„ä½œç”¨

- **é”™è¯¯æ£€æµ‹**ï¼šåœ¨ç¼–è¯‘æ—¶å‘ç°ç±»å‹é”™è¯¯
- **æ–‡æ¡£åŒ–**ï¼šç±»å‹ä½œä¸ºç¨‹åºæ–‡æ¡£
- **ä¼˜åŒ–**ï¼šç±»å‹ä¿¡æ¯ç”¨äºä»£ç ä¼˜åŒ–
- **æŠ½è±¡**ï¼šç±»å‹æä¾›æŠ½è±¡å±‚æ¬¡

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ç±»å‹è¯­æ³•

**å®šä¹‰ 2.1.1** (ç±»å‹è¯­æ³•)
ç±»å‹é›†åˆ $\mathcal{T}$ ç”±ä»¥ä¸‹è§„åˆ™å®šä¹‰ï¼š

$$\tau ::= \alpha \mid \text{Int} \mid \text{Bool} \mid \tau_1 \to \tau_2 \mid \tau_1 \times \tau_2 \mid \tau_1 + \tau_2$$

å…¶ä¸­ $\alpha$ æ˜¯ç±»å‹å˜é‡ã€‚

### 2.2 é¡¹è¯­æ³•

**å®šä¹‰ 2.2.1** (é¡¹è¯­æ³•)
é¡¹é›†åˆ $\Lambda$ ç”±ä»¥ä¸‹è§„åˆ™å®šä¹‰ï¼š

$$M ::= x \mid \lambda x:\tau.M \mid M_1 M_2 \mid \langle M_1, M_2 \rangle \mid \pi_1 M \mid \pi_2 M \mid \text{in}_1 M \mid \text{in}_2 M \mid \text{case } M \text{ of } \text{in}_1 x \Rightarrow M_1 \mid \text{in}_2 y \Rightarrow M_2$$

### 2.3 ç±»å‹ç¯å¢ƒ

**å®šä¹‰ 2.3.1** (ç±»å‹ç¯å¢ƒ)
ç±»å‹ç¯å¢ƒ $\Gamma$ æ˜¯å˜é‡åˆ°ç±»å‹çš„æ˜ å°„ï¼š

$$\Gamma ::= \emptyset \mid \Gamma, x:\tau$$

### 2.4 ç±»å‹æ¨å¯¼è§„åˆ™

**å®šä¹‰ 2.4.1** (ç±»å‹æ¨å¯¼)
ç±»å‹æ¨å¯¼å…³ç³» $\Gamma \vdash M : \tau$ ç”±ä»¥ä¸‹è§„åˆ™å®šä¹‰ï¼š

1. **å˜é‡è§„åˆ™**ï¼š
   $$\frac{x:\tau \in \Gamma}{\Gamma \vdash x : \tau}$$

2. **æŠ½è±¡è§„åˆ™**ï¼š
   $$\frac{\Gamma, x:\tau_1 \vdash M : \tau_2}{\Gamma \vdash \lambda x:\tau_1.M : \tau_1 \to \tau_2}$$

3. **åº”ç”¨è§„åˆ™**ï¼š
   $$\frac{\Gamma \vdash M_1 : \tau_1 \to \tau_2 \quad \Gamma \vdash M_2 : \tau_1}{\Gamma \vdash M_1 M_2 : \tau_2}$$

4. **ç§¯ç±»å‹è§„åˆ™**ï¼š
   $$\frac{\Gamma \vdash M_1 : \tau_1 \quad \Gamma \vdash M_2 : \tau_2}{\Gamma \vdash \langle M_1, M_2 \rangle : \tau_1 \times \tau_2}$$

5. **æŠ•å½±è§„åˆ™**ï¼š
   $$\frac{\Gamma \vdash M : \tau_1 \times \tau_2}{\Gamma \vdash \pi_1 M : \tau_1} \quad \frac{\Gamma \vdash M : \tau_1 \times \tau_2}{\Gamma \vdash \pi_2 M : \tau_2}$$

### 2.5 ç±»å‹å®‰å…¨

**å®šä¹‰ 2.5.1** (ç±»å‹å®‰å…¨)
ç±»å‹ç³»ç»Ÿæ˜¯ç±»å‹å®‰å…¨çš„ï¼Œå½“ä¸”ä»…å½“ï¼š

1. **è¿›å±•æ€§**ï¼šè‰¯ç±»å‹çš„é¡¹è¦ä¹ˆæ˜¯å€¼ï¼Œè¦ä¹ˆå¯ä»¥ç»§ç»­æ±‚å€¼
2. **ä¿æŒæ€§**ï¼šæ±‚å€¼ä¿æŒç±»å‹

## 3. å®šç†ä¸è¯æ˜

### 3.1 ç±»å‹ä¿æŒæ€§

**å®šç† 3.1.1** (ç±»å‹ä¿æŒæ€§)
å¦‚æœ $\Gamma \vdash M : \tau$ ä¸” $M \to M'$ï¼Œåˆ™ $\Gamma \vdash M' : \tau$ã€‚

**è¯æ˜**ï¼š

1. å¯¹æ±‚å€¼è§„åˆ™è¿›è¡Œå½’çº³
2. å¯¹æ¯ç§æ±‚å€¼è§„åˆ™è¯æ˜ç±»å‹ä¿æŒ
3. ä½¿ç”¨ç±»å‹æ¨å¯¼è§„åˆ™

### 3.2 è¿›å±•æ€§

**å®šç† 3.2.1** (è¿›å±•æ€§)
å¦‚æœ $\emptyset \vdash M : \tau$ï¼Œåˆ™ $M$ è¦ä¹ˆæ˜¯å€¼ï¼Œè¦ä¹ˆå­˜åœ¨ $M'$ ä½¿å¾— $M \to M'$ã€‚

**è¯æ˜**ï¼š

1. å¯¹é¡¹çš„ç»“æ„è¿›è¡Œå½’çº³
2. å¯¹æ¯ç§æƒ…å†µè¯æ˜è¿›å±•æ€§
3. ä½¿ç”¨ç±»å‹æ¨å¯¼è§„åˆ™

### 3.3 ç±»å‹å”¯ä¸€æ€§

**å®šç† 3.3.1** (ç±»å‹å”¯ä¸€æ€§)
å¦‚æœ $\Gamma \vdash M : \tau_1$ ä¸” $\Gamma \vdash M : \tau_2$ï¼Œåˆ™ $\tau_1 = \tau_2$ã€‚

**è¯æ˜**ï¼š

1. å¯¹é¡¹çš„ç»“æ„è¿›è¡Œå½’çº³
2. å¯¹æ¯ç§æƒ…å†µè¯æ˜ç±»å‹å”¯ä¸€æ€§
3. ä½¿ç”¨ç±»å‹æ¨å¯¼è§„åˆ™çš„ä¸€è‡´æ€§

### 3.4 ä¸»ä½“å½’çº¦

**å®šç† 3.4.1** (ä¸»ä½“å½’çº¦)
å¦‚æœ $\Gamma \vdash M : \tau$ï¼Œåˆ™ $M$ å¼ºæ­£è§„åŒ–ã€‚

**è¯æ˜**ï¼š

1. æ„é€ ç±»å‹å¤§å°çš„åº¦é‡
2. è¯æ˜æ¯æ¬¡å½’çº¦å‡å°åº¦é‡
3. ä½¿ç”¨è‰¯åŸºå½’çº³

## 4. ä»£ç å®ç°

### 4.1 ç®€å•ç±»å‹ç†è®ºå®ç°

```rust
use std::collections::HashMap;

/// ç±»å‹
#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Int,
    Bool,
    String,
    Function(Box<Type>, Box<Type>),
    Product(Box<Type>, Box<Type>),
    Sum(Box<Type>, Box<Type>),
    Variable(String),
}

/// é¡¹
#[derive(Debug, Clone)]
pub enum Term {
    Variable(String),
    Lambda(String, Type, Box<Term>),
    Application(Box<Term>, Box<Term>),
    Pair(Box<Term>, Box<Term>),
    Projection1(Box<Term>),
    Projection2(Box<Term>),
    Injection1(Box<Term>, Type),
    Injection2(Box<Term>, Type),
    Case(Box<Term>, String, Box<Term>, String, Box<Term>),
    Integer(i64),
    Boolean(bool),
    String(String),
}

/// ç±»å‹ç¯å¢ƒ
#[derive(Debug, Clone)]
pub struct TypeEnvironment {
    bindings: HashMap<String, Type>,
}

/// ç±»å‹æ¨å¯¼ç»“æœ
#[derive(Debug, Clone)]
pub struct TypeInferenceResult {
    term: Term,
    inferred_type: Type,
    substitutions: HashMap<String, Type>,
}

/// ç±»å‹é”™è¯¯
#[derive(Debug, Clone)]
pub enum TypeError {
    UnboundVariable(String),
    TypeMismatch(Type, Type),
    InvalidApplication(Type, Type),
    InvalidProjection(Type),
    InvalidInjection(Type),
    InvalidCase(Type),
}

impl TypeEnvironment {
    /// åˆ›å»ºæ–°çš„ç±»å‹ç¯å¢ƒ
    pub fn new() -> Self {
        Self {
            bindings: HashMap::new(),
        }
    }
    
    /// æ·»åŠ ç»‘å®š
    pub fn add_binding(&mut self, name: String, ty: Type) {
        self.bindings.insert(name, ty);
    }
    
    /// æŸ¥æ‰¾ç±»å‹
    pub fn lookup(&self, name: &str) -> Option<&Type> {
        self.bindings.get(name)
    }
    
    /// æ‰©å±•ç¯å¢ƒ
    pub fn extend(&self, name: String, ty: Type) -> Self {
        let mut new_env = self.clone();
        new_env.add_binding(name, ty);
        new_env
    }
}

impl Term {
    /// ç±»å‹æ¨å¯¼
    pub fn type_inference(&self, env: &TypeEnvironment) -> Result<Type, TypeError> {
        match self {
            Term::Variable(name) => {
                env.lookup(name)
                    .cloned()
                    .ok_or_else(|| TypeError::UnboundVariable(name.clone()))
            }
            
            Term::Lambda(param, param_type, body) => {
                let new_env = env.extend(param.clone(), param_type.clone());
                let body_type = body.type_inference(&new_env)?;
                Ok(Type::Function(Box::new(param_type.clone()), Box::new(body_type)))
            }
            
            Term::Application(func, arg) => {
                let func_type = func.type_inference(env)?;
                let arg_type = arg.type_inference(env)?;
                
                match func_type {
                    Type::Function(input_type, output_type) => {
                        if *input_type == arg_type {
                            Ok(*output_type)
                        } else {
                            Err(TypeError::TypeMismatch(*input_type, arg_type))
                        }
                    }
                    _ => Err(TypeError::InvalidApplication(func_type, arg_type)),
                }
            }
            
            Term::Pair(left, right) => {
                let left_type = left.type_inference(env)?;
                let right_type = right.type_inference(env)?;
                Ok(Type::Product(Box::new(left_type), Box::new(right_type)))
            }
            
            Term::Projection1(pair) => {
                let pair_type = pair.type_inference(env)?;
                match pair_type {
                    Type::Product(left_type, _) => Ok(*left_type),
                    _ => Err(TypeError::InvalidProjection(pair_type)),
                }
            }
            
            Term::Projection2(pair) => {
                let pair_type = pair.type_inference(env)?;
                match pair_type {
                    Type::Product(_, right_type) => Ok(*right_type),
                    _ => Err(TypeError::InvalidProjection(pair_type)),
                }
            }
            
            Term::Injection1(term, _) => {
                let term_type = term.type_inference(env)?;
                Ok(Type::Sum(Box::new(term_type), Box::new(Type::Variable("_".to_string()))))
            }
            
            Term::Injection2(term, _) => {
                let term_type = term.type_inference(env)?;
                Ok(Type::Sum(Box::new(Type::Variable("_".to_string())), Box::new(term_type)))
            }
            
            Term::Case(term, left_var, left_body, right_var, right_body) => {
                let term_type = term.type_inference(env)?;
                
                match term_type {
                    Type::Sum(left_type, right_type) => {
                        let left_env = env.extend(left_var.clone(), *left_type);
                        let right_env = env.extend(right_var.clone(), *right_type);
                        
                        let left_result = left_body.type_inference(&left_env)?;
                        let right_result = right_body.type_inference(&right_env)?;
                        
                        if left_result == right_result {
                            Ok(left_result)
                        } else {
                            Err(TypeError::TypeMismatch(left_result, right_result))
                        }
                    }
                    _ => Err(TypeError::InvalidCase(term_type)),
                }
            }
            
            Term::Integer(_) => Ok(Type::Int),
            Term::Boolean(_) => Ok(Type::Bool),
            Term::String(_) => Ok(Type::String),
        }
    }
    
    /// æ±‚å€¼
    pub fn evaluate(&self) -> Result<Term, String> {
        match self {
            Term::Application(func, arg) => {
                let func_value = func.evaluate()?;
                let arg_value = arg.evaluate()?;
                
                match func_value {
                    Term::Lambda(param, _, body) => {
                        let substituted = self.substitute(&body, &param, &arg_value);
                        substituted.evaluate()
                    }
                    _ => Err("ä¸æ˜¯å‡½æ•°".to_string()),
                }
            }
            
            Term::Projection1(pair) => {
                let pair_value = pair.evaluate()?;
                match pair_value {
                    Term::Pair(left, _) => Ok(*left),
                    _ => Err("ä¸æ˜¯ç§¯ç±»å‹".to_string()),
                }
            }
            
            Term::Projection2(pair) => {
                let pair_value = pair.evaluate()?;
                match pair_value {
                    Term::Pair(_, right) => Ok(*right),
                    _ => Err("ä¸æ˜¯ç§¯ç±»å‹".to_string()),
                }
            }
            
            Term::Case(term, left_var, left_body, right_var, right_body) => {
                let term_value = term.evaluate()?;
                match term_value {
                    Term::Injection1(value, _) => {
                        let substituted = self.substitute(&left_body, left_var, &value);
                        substituted.evaluate()
                    }
                    Term::Injection2(value, _) => {
                        let substituted = self.substitute(&right_body, right_var, &value);
                        substituted.evaluate()
                    }
                    _ => Err("ä¸æ˜¯å’Œç±»å‹".to_string()),
                }
            }
            
            _ => Ok(self.clone()),
        }
    }
    
    /// æ›¿æ¢
    fn substitute(&self, term: &Term, var: &str, value: &Term) -> Term {
        match term {
            Term::Variable(name) if name == var => value.clone(),
            Term::Variable(_) => term.clone(),
            Term::Lambda(param, param_type, body) => {
                if param == var {
                    Term::Lambda(param.clone(), param_type.clone(), body.clone())
                } else {
                    Term::Lambda(param.clone(), param_type.clone(), 
                                Box::new(self.substitute(body, var, value)))
                }
            }
            Term::Application(func, arg) => {
                Term::Application(
                    Box::new(self.substitute(func, var, value)),
                    Box::new(self.substitute(arg, var, value))
                )
            }
            Term::Pair(left, right) => {
                Term::Pair(
                    Box::new(self.substitute(left, var, value)),
                    Box::new(self.substitute(right, var, value))
                )
            }
            Term::Projection1(pair) => {
                Term::Projection1(Box::new(self.substitute(pair, var, value)))
            }
            Term::Projection2(pair) => {
                Term::Projection2(Box::new(self.substitute(pair, var, value)))
            }
            Term::Injection1(term, ty) => {
                Term::Injection1(Box::new(self.substitute(term, var, value)), ty.clone())
            }
            Term::Injection2(term, ty) => {
                Term::Injection2(Box::new(self.substitute(term, var, value)), ty.clone())
            }
            Term::Case(term, left_var, left_body, right_var, right_body) => {
                Term::Case(
                    Box::new(self.substitute(term, var, value)),
                    left_var.clone(),
                    Box::new(self.substitute(left_body, var, value)),
                    right_var.clone(),
                    Box::new(self.substitute(right_body, var, value))
                )
            }
            _ => term.clone(),
        }
    }
}

/// ç±»å‹æ£€æŸ¥å™¨
pub struct TypeChecker;

impl TypeChecker {
    /// æ£€æŸ¥ç±»å‹å®‰å…¨
    pub fn check_type_safety(&self, term: &Term) -> Result<bool, TypeError> {
        let env = TypeEnvironment::new();
        term.type_inference(&env)?;
        Ok(true)
    }
    
    /// ç±»å‹æ¨å¯¼
    pub fn infer_type(&self, term: &Term) -> Result<Type, TypeError> {
        let env = TypeEnvironment::new();
        term.type_inference(&env)
    }
    
    /// æ£€æŸ¥ç±»å‹ç­‰ä»·
    pub fn type_equivalent(&self, type1: &Type, type2: &Type) -> bool {
        self.unify_types(type1, type2).is_ok()
    }
    
    /// ç±»å‹åˆä¸€
    pub fn unify_types(&self, type1: &Type, type2: &Type) -> Result<HashMap<String, Type>, String> {
        let mut substitutions = HashMap::new();
        self.unify_types_helper(type1, type2, &mut substitutions)?;
        Ok(substitutions)
    }
    
    /// ç±»å‹åˆä¸€è¾…åŠ©å‡½æ•°
    fn unify_types_helper(
        &self,
        type1: &Type,
        type2: &Type,
        substitutions: &mut HashMap<String, Type>,
    ) -> Result<(), String> {
        match (type1, type2) {
            (Type::Variable(var), ty) | (ty, Type::Variable(var)) => {
                if let Some(subst_ty) = substitutions.get(var) {
                    self.unify_types_helper(subst_ty, ty, substitutions)
                } else {
                    substitutions.insert(var.clone(), ty.clone());
                    Ok(())
                }
            }
            
            (Type::Int, Type::Int) | (Type::Bool, Type::Bool) | (Type::String, Type::String) => {
                Ok(())
            }
            
            (Type::Function(arg1, ret1), Type::Function(arg2, ret2)) => {
                self.unify_types_helper(arg1, arg2, substitutions)?;
                self.unify_types_helper(ret1, ret2, substitutions)
            }
            
            (Type::Product(left1, right1), Type::Product(left2, right2)) => {
                self.unify_types_helper(left1, left2, substitutions)?;
                self.unify_types_helper(right1, right2, substitutions)
            }
            
            (Type::Sum(left1, right1), Type::Sum(left2, right2)) => {
                self.unify_types_helper(left1, left2, substitutions)?;
                self.unify_types_helper(right1, right2, substitutions)
            }
            
            _ => Err("ç±»å‹ä¸åŒ¹é…".to_string()),
        }
    }
}

/// ç±»å‹ç†è®ºåˆ†æå™¨
pub struct TypeTheoryAnalyzer;

impl TypeTheoryAnalyzer {
    /// åˆ†æç±»å‹ç³»ç»Ÿ
    pub fn analyze(&self, term: &Term) -> TypeAnalysis {
        let type_checker = TypeChecker;
        let type_safety = type_checker.check_type_safety(term);
        let type_inference = type_checker.infer_type(term);
        
        TypeAnalysis {
            type_safe: type_safety.is_ok(),
            inferred_type: type_inference.ok(),
            complexity: self.estimate_complexity(term),
            normalization: self.check_normalization(term),
        }
    }
    
    /// ä¼°è®¡å¤æ‚åº¦
    fn estimate_complexity(&self, term: &Term) -> TypeComplexity {
        match term {
            Term::Variable(_) | Term::Integer(_) | Term::Boolean(_) | Term::String(_) => {
                TypeComplexity::Simple
            }
            Term::Lambda(_, _, body) | Term::Application(_, _) => {
                TypeComplexity::Moderate
            }
            Term::Case(_, _, _, _, _) => TypeComplexity::Complex,
            _ => TypeComplexity::Moderate,
        }
    }
    
    /// æ£€æŸ¥æ­£è§„åŒ–
    fn check_normalization(&self, term: &Term) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥æ˜¯å¦æœ‰æ˜æ˜¾çš„æ— é™å½’çº¦
        !self.has_infinite_reduction(term)
    }
    
    /// æ£€æŸ¥æ˜¯å¦æœ‰æ— é™å½’çº¦
    fn has_infinite_reduction(&self, term: &Term) -> bool {
        match term {
            Term::Application(func, arg) => {
                matches!(**func, Term::Application(_, _))
            }
            _ => false,
        }
    }
}

/// ç±»å‹åˆ†æç»“æœ
#[derive(Debug, Clone)]
pub struct TypeAnalysis {
    type_safe: bool,
    inferred_type: Option<Type>,
    complexity: TypeComplexity,
    normalization: bool,
}

/// ç±»å‹å¤æ‚åº¦
#[derive(Debug, Clone)]
pub enum TypeComplexity {
    Simple,
    Moderate,
    Complex,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_type_inference() {
        let term = Term::Lambda(
            "x".to_string(),
            Type::Int,
            Box::new(Term::Variable("x".to_string())),
        );
        
        let env = TypeEnvironment::new();
        let result = term.type_inference(&env);
        
        assert!(result.is_ok());
        if let Ok(ty) = result {
            assert_eq!(ty, Type::Function(Box::new(Type::Int), Box::new(Type::Int)));
        }
    }

    #[test]
    fn test_type_safety() {
        let term = Term::Application(
            Box::new(Term::Lambda(
                "x".to_string(),
                Type::Int,
                Box::new(Term::Variable("x".to_string())),
            )),
            Box::new(Term::Integer(42)),
        );
        
        let type_checker = TypeChecker;
        let result = type_checker.check_type_safety(&term);
        
        assert!(result.is_ok());
    }

    #[test]
    fn test_type_error() {
        let term = Term::Application(
            Box::new(Term::Integer(42)),
            Box::new(Term::Integer(10)),
        );
        
        let env = TypeEnvironment::new();
        let result = term.type_inference(&env);
        
        assert!(result.is_err());
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 åŸºæœ¬ç±»å‹æ¨å¯¼

```rust
fn main() {
    let type_checker = TypeChecker;
    
    // åˆ›å»ºç®€å•çš„Î»é¡¹
    let identity = Term::Lambda(
        "x".to_string(),
        Type::Int,
        Box::new(Term::Variable("x".to_string())),
    );
    
    let application = Term::Application(
        Box::new(identity.clone()),
        Box::new(Term::Integer(42)),
    );
    
    println!("ç±»å‹æ¨å¯¼ç¤ºä¾‹:");
    println!("æ’ç­‰å‡½æ•°ç±»å‹: {:?}", type_checker.infer_type(&identity));
    println!("åº”ç”¨ç±»å‹: {:?}", type_checker.infer_type(&application));
    println!("ç±»å‹å®‰å…¨: {:?}", type_checker.check_type_safety(&application));
}
```

### 5.2 å¤æ‚ç±»å‹åˆ†æ

```rust
fn analyze_complex_types() {
    let analyzer = TypeTheoryAnalyzer;
    
    // åˆ›å»ºå¤æ‚çš„ç±»å‹é¡¹
    let complex_term = Term::Case(
        Box::new(Term::Injection1(
            Box::new(Term::Integer(42)),
            Type::Int,
        )),
        "x".to_string(),
        Box::new(Term::Variable("x".to_string())),
        "y".to_string(),
        Box::new(Term::Variable("y".to_string())),
    );
    
    let analysis = analyzer.analyze(&complex_term);
    
    println!("å¤æ‚ç±»å‹åˆ†æ:");
    println!("ç±»å‹å®‰å…¨: {}", analysis.type_safe);
    println!("æ¨æ–­ç±»å‹: {:?}", analysis.inferred_type);
    println!("å¤æ‚åº¦: {:?}", analysis.complexity);
    println!("æ­£è§„åŒ–: {}", analysis.normalization);
}
```

### 5.3 ç±»å‹ç­‰ä»·æ£€æŸ¥

```rust
fn check_type_equivalence() {
    let type_checker = TypeChecker;
    
    let type1 = Type::Function(Box::new(Type::Int), Box::new(Type::Bool));
    let type2 = Type::Function(Box::new(Type::Int), Box::new(Type::Bool));
    let type3 = Type::Function(Box::new(Type::Bool), Box::new(Type::Int));
    
    println!("ç±»å‹ç­‰ä»·æ£€æŸ¥:");
    println!("type1 == type2: {}", type_checker.type_equivalent(&type1, &type2));
    println!("type1 == type3: {}", type_checker.type_equivalent(&type1, &type3));
    
    let unification = type_checker.unify_types(&type1, &type2);
    println!("ç±»å‹åˆä¸€: {:?}", unification);
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸Î»æ¼”ç®—çš„å…³ç³»

- **æ— ç±»å‹Î»æ¼”ç®—**ï¼šç®€å•ç±»å‹ç†è®ºçš„åŸºç¡€
- **ç±»å‹åŒ–Î»æ¼”ç®—**ï¼šç®€å•ç±»å‹ç†è®ºçš„å½¢å¼åŒ–
- **å½’çº¦ç†è®º**ï¼šç±»å‹ä¿æŒçš„å½’çº¦

### 6.2 ä¸é€»è¾‘çš„å…³ç³»

- **ç›´è§‰é€»è¾‘**ï¼šç±»å‹ä¸é€»è¾‘çš„å¯¹åº”å…³ç³»
- **è¯æ˜è®º**ï¼šç±»å‹ä½œä¸ºè¯æ˜
- **æ¨¡å‹è®º**ï¼šç±»å‹ä½œä¸ºè¯­ä¹‰

### 6.3 ä¸ç¼–ç¨‹è¯­è¨€çš„å…³ç³»

- **å‡½æ•°å¼ç¼–ç¨‹**ï¼šåŸºäºç±»å‹ç†è®º
- **ç±»å‹ç³»ç»Ÿ**ï¼šç¼–ç¨‹è¯­è¨€çš„ç±»å‹ç³»ç»Ÿ
- **ç¼–è¯‘å™¨**ï¼šç±»å‹æ£€æŸ¥çš„å®ç°

### 6.4 ä¸èŒƒç•´è®ºçš„å…³ç³»

- **ç¬›å¡å°”é—­èŒƒç•´**ï¼šç±»å‹ç†è®ºçš„è¯­ä¹‰
- **å‡½å­**ï¼šç±»å‹æ„é€ å­
- **è‡ªç„¶å˜æ¢**ï¼šç±»å‹å‡½æ•°

## 7. å‚è€ƒæ–‡çŒ®

1. **Barendregt, H. P.** (1992). *Lambda Calculi with Types*. Oxford University Press.
2. **Pierce, B. C.** (2002). *Types and Programming Languages*. MIT Press.
3. **Girard, J.-Y., Lafont, Y., Taylor, P.** (1989). *Proofs and Types*. Cambridge University Press.
4. **Thompson, S.** (1991). *Type Theory and Functional Programming*. Addison-Wesley.
5. **Cardelli, L., Wegner, P.** (1985). "On Understanding Types, Data Abstraction, and Polymorphism". *Computing Surveys*.
6. **Reynolds, J. C.** (1983). "Types, Abstraction and Parametric Polymorphism". *Information Processing*.
7. **Mitchell, J. C.** (1996). *Foundations for Programming Languages*. MIT Press.
8. **Winskel, G.** (1993). *The Formal Semantics of Programming Languages*. MIT Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [04.1.2 çº¿æ€§ç±»å‹ç†è®º](../04_Type_Theory/04.1.2_çº¿æ€§ç±»å‹ç†è®º.md)
- [04.1.3 ä»¿å°„ç±»å‹ç†è®º](../04_Type_Theory/04.1.3_ä»¿å°„ç±»å‹ç†è®º.md)
- [04.1.4 ä¾èµ–ç±»å‹ç†è®º](../04_Type_Theory/04.1.4_ä¾èµ–ç±»å‹ç†è®º.md)
- [04.2.1 åŒä¼¦ç±»å‹ç†è®º](../04_Type_Theory/04.2.1_åŒä¼¦ç±»å‹ç†è®º.md)
- [04.2.2 é‡å­ç±»å‹ç†è®º](../04_Type_Theory/04.2.2_é‡å­ç±»å‹ç†è®º.md)
- [04.2.3 æ—¶æ€ç±»å‹ç†è®º](../04_Type_Theory/04.2.3_æ—¶æ€ç±»å‹ç†è®º.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
