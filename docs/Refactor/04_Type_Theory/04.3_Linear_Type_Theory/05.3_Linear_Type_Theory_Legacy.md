# çº¿æ€§ç±»å‹ç†è®º (Linear Type Theory)

## ğŸ“‹ **ç›®å½•**

### 1. [çº¿æ€§é€»è¾‘åŸºç¡€](#1-çº¿æ€§é€»è¾‘åŸºç¡€)

### 2. [çº¿æ€§Î»æ¼”ç®—](#2-çº¿æ€§Î»æ¼”ç®—)

### 3. [èµ„æºç®¡ç†](#3-èµ„æºç®¡ç†)

### 4. [å¹¶å‘æ§åˆ¶](#4-å¹¶å‘æ§åˆ¶)

### 5. [é‡å­çº¿æ€§ç±»å‹ç³»ç»Ÿ](#5-é‡å­çº¿æ€§ç±»å‹ç³»ç»Ÿ)

### 6. [çº¿æ€§ç±»å‹ç³»ç»Ÿçš„ä¼˜åŒ–](#6-çº¿æ€§ç±»å‹ç³»ç»Ÿçš„ä¼˜åŒ–)

### 7. [å‰æ²¿ç ”ç©¶æ–¹å‘](#7-å‰æ²¿ç ”ç©¶æ–¹å‘)

---

## ğŸ¯ **æ¦‚è¿°**

çº¿æ€§ç±»å‹ç†è®ºæ˜¯ç±»å‹ç†è®ºçš„é‡è¦åˆ†æ”¯ï¼Œå®ƒåŸºäºçº¿æ€§é€»è¾‘ï¼Œå¼ºè°ƒèµ„æºçš„ä¸€æ¬¡æ€§ä½¿ç”¨ã€‚çº¿æ€§ç±»å‹ç³»ç»Ÿç¡®ä¿èµ„æºä¸ä¼šæ³„æ¼æˆ–é‡å¤é‡Šæ”¾ï¼Œä¸ºå†…å­˜å®‰å…¨ã€å¹¶å‘æ§åˆ¶å’Œé‡å­è®¡ç®—æä¾›äº†ç†è®ºåŸºç¡€ã€‚

### æ ¸å¿ƒç‰¹å¾

1. **èµ„æºå®‰å…¨**ï¼šç¡®ä¿èµ„æºçš„ä¸€æ¬¡æ€§ä½¿ç”¨
2. **å†…å­˜å®‰å…¨**ï¼šé˜²æ­¢å†…å­˜æ³„æ¼å’Œé‡å¤é‡Šæ”¾
3. **å¹¶å‘å®‰å…¨**ï¼šæ”¯æŒå®‰å…¨çš„å¹¶å‘ç¼–ç¨‹
4. **é‡å­è®¡ç®—**ï¼šä¸ºé‡å­è®¡ç®—æä¾›ç±»å‹å®‰å…¨

---

## 1. çº¿æ€§é€»è¾‘åŸºç¡€

### 1.1 çº¿æ€§é€»è¾‘çš„å®Œæ•´å…¬ç†åŒ–

**å®šä¹‰ 1.1 (çº¿æ€§é€»è¾‘è¿æ¥è¯)**
çº¿æ€§é€»è¾‘çš„å®Œæ•´è¿æ¥è¯é›†åˆï¼š

- **ä¹˜æ³•è¿æ¥è¯**ï¼š$\otimes$ (å¼ é‡ç§¯), $\&$ (ä¸), $!$ (æŒ‡æ•°)
- **åŠ æ³•è¿æ¥è¯**ï¼š$\oplus$ (åŠ ), $\oplus$ (æˆ–), $?$ (å¼±æŒ‡æ•°)
- **çº¿æ€§è•´å«**ï¼š$\multimap$ (çº¿æ€§è•´å«)
- **çº¿æ€§å¦å®š**ï¼š$(\cdot)^\bot$ (çº¿æ€§å¦å®š)

**å®šä¹‰ 1.2 (çº¿æ€§é€»è¾‘è§„åˆ™)**
çº¿æ€§é€»è¾‘çš„æ¨ç†è§„åˆ™ï¼š

**ä¹˜æ³•è§„åˆ™ï¼š**
$$\frac{\Gamma \vdash A \quad \Delta \vdash B}{\Gamma, \Delta \vdash A \otimes B} \text{ (âŠ—R)}$$
$$\frac{\Gamma, A, B \vdash C}{\Gamma, A \otimes B \vdash C} \text{ (âŠ—L)}$$

**åŠ æ³•è§„åˆ™ï¼š**
$$\frac{\Gamma \vdash A}{\Gamma \vdash A \oplus B} \text{ (âŠ•R1)}$$
$$\frac{\Gamma \vdash B}{\Gamma \vdash A \oplus B} \text{ (âŠ•R2)}$$
$$\frac{\Gamma, A \vdash C \quad \Gamma, B \vdash C}{\Gamma, A \oplus B \vdash C} \text{ (âŠ•L)}$$

**æŒ‡æ•°è§„åˆ™ï¼š**
$$\frac{!\Gamma \vdash A}{!\Gamma \vdash !A} \text{ (!R)}$$
$$\frac{\Gamma, A \vdash B}{\Gamma, !A \vdash B} \text{ (!L)}$$

**å®šç† 1.1 (çº¿æ€§é€»è¾‘ä¸€è‡´æ€§)**
çº¿æ€§é€»è¾‘æ˜¯ä¸€è‡´çš„ï¼Œå³ä¸èƒ½åŒæ—¶è¯æ˜ $A$ å’Œ $A^\bot$ã€‚

**è¯æ˜ï¼š** é€šè¿‡åˆ‡å‰²æ¶ˆé™¤ï¼š

1. çº¿æ€§é€»è¾‘æ»¡è¶³åˆ‡å‰²æ¶ˆé™¤
2. åˆ‡å‰²æ¶ˆé™¤ç¡®ä¿ä¸€è‡´æ€§
3. é€šè¿‡ç»“æ„å½’çº³è¯æ˜

### 1.2 çº¿æ€§é€»è¾‘çš„è¯­ä¹‰

**å®šä¹‰ 1.3 (çº¿æ€§é€»è¾‘è¯­ä¹‰)**
çº¿æ€§é€»è¾‘çš„æŒ‡ç§°è¯­ä¹‰ï¼š

- **å¼ é‡ç§¯**ï¼š$\llbracket A \otimes B \rrbracket = \llbracket A \rrbracket \otimes \llbracket B \rrbracket$
- **çº¿æ€§è•´å«**ï¼š$\llbracket A \multimap B \rrbracket = \llbracket A \rrbracket \multimap \llbracket B \rrbracket$
- **æŒ‡æ•°**ï¼š$\llbracket !A \rrbracket = !\llbracket A \rrbracket$

**å®šä¹‰ 1.4 (çº¿æ€§é€»è¾‘æ¨¡å‹)**
çº¿æ€§é€»è¾‘æ¨¡å‹æ˜¯æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„ç»“æ„ï¼š

1. **å¹ºåŠç¾¤ç»“æ„**ï¼š$(M, \otimes, I)$ æ˜¯å¹ºåŠç¾¤
2. **é—­ç»“æ„**ï¼šå­˜åœ¨å†…éƒ¨åŒæ€å¯¹è±¡ $\multimap$
3. **æŒ‡æ•°ç»“æ„**ï¼šå­˜åœ¨å…±å¹ºå­ $\delta : A \rightarrow !A$ å’Œ $\varepsilon : !A \rightarrow A$

---

## 2. çº¿æ€§Î»æ¼”ç®—

### 2.1 çº¿æ€§Î»æ¼”ç®—è¯­æ³•

**å®šä¹‰ 2.1 (çº¿æ€§Î»æ¼”ç®—)**
çº¿æ€§Î»æ¼”ç®—çš„è¯­æ³•ï¼š

$$M ::= x \mid \lambda x.M \mid M N \mid M \otimes N \mid \text{let } x \otimes y = M \text{ in } N$$

**å®šä¹‰ 2.2 (çº¿æ€§ç±»å‹è§„åˆ™)**
çº¿æ€§ç±»å‹è§„åˆ™ï¼š

$$\frac{\Gamma, x : A \vdash M : B}{\Gamma \vdash \lambda x.M : A \multimap B} \text{ (Î»æŠ½è±¡)}$$

$$\frac{\Gamma \vdash M : A \multimap B \quad \Delta \vdash N : A}{\Gamma, \Delta \vdash M N : B} \text{ (Î»åº”ç”¨)}$$

$$\frac{\Gamma \vdash M : A \quad \Delta \vdash N : B}{\Gamma, \Delta \vdash M \otimes N : A \otimes B} \text{ (å¼ é‡ç§¯)}$$

### 2.2 çº¿æ€§ç±»å‹æ£€æŸ¥ç®—æ³•

```rust
// çº¿æ€§ç±»å‹ç³»ç»Ÿçš„Rustå®ç°
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    LinearArrow(Box<Type>, Box<Type>),
    Tensor(Box<Type>, Box<Type>),
    Unit,
    Bool,
    Int,
}

#[derive(Debug, Clone)]
pub enum Term {
    Var(String),
    Lambda(String, Box<Term>),
    App(Box<Term>, Box<Term>),
    Tensor(Box<Term>, Box<Term>),
    LetTensor(String, String, Box<Term>, Box<Term>),
}

#[derive(Debug)]
pub struct Context {
    bindings: HashMap<String, Type>,
    multiplicity: HashMap<String, i32>,
}

impl Context {
    pub fn new() -> Self {
        Context {
            bindings: HashMap::new(),
            multiplicity: HashMap::new(),
        }
    }

    pub fn extend(&self, var: &str, ty: Type) -> Self {
        let mut new_bindings = self.bindings.clone();
        let mut new_multiplicity = self.multiplicity.clone();
        new_bindings.insert(var.to_string(), ty);
        new_multiplicity.insert(var.to_string(), 1);
        Context {
            bindings: new_bindings,
            multiplicity: new_multiplicity,
        }
    }

    pub fn lookup(&self, var: &str) -> Option<&Type> {
        self.bindings.get(var)
    }

    pub fn get_multiplicity(&self, var: &str) -> i32 {
        *self.multiplicity.get(var).unwrap_or(&0)
    }
}

pub struct LinearTypeChecker;

impl LinearTypeChecker {
    pub fn check_type(&self, ctx: &Context, term: &Term, expected_type: &Type) -> bool {
        match term {
            Term::Var(x) => {
                if let Some(var_type) = ctx.lookup(x) {
                    var_type == expected_type && ctx.get_multiplicity(x) == 1
                } else {
                    false
                }
            }
            Term::Lambda(x, body) => {
                if let Type::LinearArrow(domain, codomain) = expected_type {
                    let new_ctx = ctx.extend(x, *domain.clone());
                    self.check_type(&new_ctx, body, codomain)
                } else {
                    false
                }
            }
            Term::App(fun, arg) => {
                let fun_type = self.infer_type(ctx, fun);
                if let Type::LinearArrow(domain, codomain) = fun_type {
                    self.check_type(ctx, arg, domain) && codomain.as_ref() == expected_type
                } else {
                    false
                }
            }
            Term::Tensor(left, right) => {
                if let Type::Tensor(left_type, right_type) = expected_type {
                    self.check_type(ctx, left, left_type) && self.check_type(ctx, right, right_type)
                } else {
                    false
                }
            }
            _ => false,
        }
    }

    pub fn infer_type(&self, ctx: &Context, term: &Term) -> Type {
        match term {
            Term::Var(x) => ctx.lookup(x).unwrap().clone(),
            Term::Lambda(x, body) => {
                let domain_type = Type::Int; // ç®€åŒ–å¤„ç†
                let new_ctx = ctx.extend(x, domain_type.clone());
                let codomain_type = self.infer_type(&new_ctx, body);
                Type::LinearArrow(Box::new(domain_type), Box::new(codomain_type))
            }
            Term::App(fun, arg) => {
                let fun_type = self.infer_type(ctx, fun);
                if let Type::LinearArrow(domain, codomain) = fun_type {
                    codomain.as_ref().clone()
                } else {
                    panic!("Expected function type")
                }
            }
            _ => Type::Unit,
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let checker = LinearTypeChecker;
    let ctx = Context::new();
    
    // æ£€æŸ¥çº¿æ€§å‡½æ•°: Î»x.x
    let identity = Term::Lambda("x".to_string(), Box::new(Term::Var("x".to_string())));
    let expected_type = Type::LinearArrow(Box::new(Type::Int), Box::new(Type::Int));
    
    println!("Identity function type check: {}", 
             checker.check_type(&ctx, &identity, &expected_type));
}
```

---

## 3. èµ„æºç®¡ç†

### 3.1 èµ„æºç±»å‹å®šä¹‰

**å®šä¹‰ 3.1 (èµ„æºç±»å‹)**
èµ„æºç±»å‹è¡¨ç¤ºå¿…é¡»ç²¾ç¡®ç®¡ç†çš„èµ„æºã€‚

**å®šä¹‰ 3.2 (èµ„æºå®‰å…¨)**
èµ„æºå®‰å…¨ç¡®ä¿èµ„æºä¸ä¼šæ³„æ¼æˆ–é‡å¤é‡Šæ”¾ã€‚

### 3.2 èµ„æºç®¡ç†å™¨å®ç°

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::thread;

#[derive(Debug, Clone)]
pub struct Resource {
    pub id: u64,
    pub resource_type: String,
    pub state: ResourceState,
}

#[derive(Debug, Clone)]
pub enum ResourceState {
    Initial,
    Allocated,
    InUse,
    Released,
}

#[derive(Debug)]
pub struct ResourceManager {
    resources: Arc<Mutex<HashMap<u64, Resource>>>,
    ownership: Arc<Mutex<HashMap<u64, thread::ThreadId>>>,
    linearity: Arc<Mutex<HashMap<u64, Linearity>>>,
}

#[derive(Debug, Clone)]
pub enum Linearity {
    Linear,
    Affine,
    Relevant,
    Unrestricted,
}

impl ResourceManager {
    pub fn new() -> Self {
        ResourceManager {
            resources: Arc::new(Mutex::new(HashMap::new())),
            ownership: Arc::new(Mutex::new(HashMap::new())),
            linearity: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    pub fn allocate_resource(&self, resource_type: &str) -> Result<u64, String> {
        let resource_id = self.generate_resource_id();
        let resource = Resource {
            id: resource_id,
            resource_type: resource_type.to_string(),
            state: ResourceState::Initial,
        };

        {
            let mut resources = self.resources.lock().unwrap();
            let mut ownership = self.ownership.lock().unwrap();
            let mut linearity = self.linearity.lock().unwrap();

            resources.insert(resource_id, resource);
            ownership.insert(resource_id, thread::current().id());
            linearity.insert(resource_id, Linearity::Linear);
        }

        Ok(resource_id)
    }

    pub fn release_resource(&self, resource_id: u64) -> Result<(), String> {
        let current_thread = thread::current().id();
        
        {
            let mut resources = self.resources.lock().unwrap();
            let mut ownership = self.ownership.lock().unwrap();
            let mut linearity = self.linearity.lock().unwrap();

            if let Some(owner) = ownership.get(&resource_id) {
                if *owner == current_thread {
                    resources.remove(&resource_id);
                    ownership.remove(&resource_id);
                    linearity.remove(&resource_id);
                    Ok(())
                } else {
                    Err("Cannot release resource: wrong owner".to_string())
                }
            } else {
                Err("Resource not found".to_string())
            }
        }
    }

    fn generate_resource_id(&self) -> u64 {
        use std::time::{SystemTime, UNIX_EPOCH};
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let manager = ResourceManager::new();
    
    // åˆ†é…èµ„æº
    let resource_id = manager.allocate_resource("file_handle").unwrap();
    println!("Allocated resource: {}", resource_id);
    
    // é‡Šæ”¾èµ„æº
    match manager.release_resource(resource_id) {
        Ok(()) => println!("Resource released successfully"),
        Err(e) => println!("Error releasing resource: {}", e),
    }
}
```

---

## 4. å¹¶å‘æ§åˆ¶

### 4.1 çº¿æ€§é€šé“

**å®šä¹‰ 4.1 (çº¿æ€§é€šé“)**
çº¿æ€§é€šé“ç¡®ä¿æ¶ˆæ¯ä¼ é€’çš„å®‰å…¨æ€§ã€‚

```rust
use std::collections::VecDeque;
use std::sync::{Arc, Mutex, Condvar};
use std::thread;

#[derive(Debug)]
pub struct LinearChannel<T> {
    id: u64,
    messages: Arc<Mutex<VecDeque<T>>>,
    senders: Arc<Mutex<Vec<thread::ThreadId>>>,
    receivers: Arc<Mutex<Vec<thread::ThreadId>>>,
    send_cv: Arc<Condvar>,
    recv_cv: Arc<Condvar>,
}

impl<T> LinearChannel<T> {
    pub fn new() -> Self {
        LinearChannel {
            id: Self::generate_id(),
            messages: Arc::new(Mutex::new(VecDeque::new())),
            senders: Arc::new(Mutex::new(Vec::new())),
            receivers: Arc::new(Mutex::new(Vec::new())),
            send_cv: Arc::new(Condvar::new()),
            recv_cv: Arc::new(Condvar::new()),
        }
    }

    pub fn register_sender(&self) {
        let mut senders = self.senders.lock().unwrap();
        senders.push(thread::current().id());
    }

    pub fn register_receiver(&self) {
        let mut receivers = self.receivers.lock().unwrap();
        receivers.push(thread::current().id());
    }

    pub fn send(&self, message: T) -> Result<(), String> {
        let current_thread = thread::current().id();
        {
            let senders = self.senders.lock().unwrap();
            if !senders.contains(&current_thread) {
                return Err("Not registered as sender".to_string());
            }
        }

        {
            let mut messages = self.messages.lock().unwrap();
            messages.push_back(message);
        }
        
        self.recv_cv.notify_one();
        Ok(())
    }

    pub fn receive(&self) -> Result<T, String> {
        let current_thread = thread::current().id();
        {
            let receivers = self.receivers.lock().unwrap();
            if !receivers.contains(&current_thread) {
                return Err("Not registered as receiver".to_string());
            }
        }

        let mut messages = self.messages.lock().unwrap();
        while messages.is_empty() {
            messages = self.recv_cv.wait(messages).unwrap();
        }
        
        messages.pop_front().ok_or("No message available".to_string())
    }

    fn generate_id() -> u64 {
        use std::time::{SystemTime, UNIX_EPOCH};
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let channel: LinearChannel<String> = LinearChannel::new();
    
    // æ³¨å†Œå‘é€è€…å’Œæ¥æ”¶è€…
    channel.register_sender();
    channel.register_receiver();
    
    // å‘é€æ¶ˆæ¯
    channel.send("Hello, Linear Channel!".to_string()).unwrap();
    
    // æ¥æ”¶æ¶ˆæ¯
    let message = channel.receive().unwrap();
    println!("Received: {}", message);
}
```

### 4.2 çº¿æ€§äº’æ–¥é”

**å®šä¹‰ 4.2 (çº¿æ€§äº’æ–¥é”)**
çº¿æ€§äº’æ–¥é”ç¡®ä¿é”çš„æ­£ç¡®ä½¿ç”¨ã€‚

```rust
use std::sync::{Arc, Mutex, Condvar};
use std::thread;

#[derive(Debug)]
pub struct LinearMutex {
    id: u64,
    owner: Arc<Mutex<Option<thread::ThreadId>>>,
    wait_queue: Arc<Mutex<Vec<thread::ThreadId>>>,
    cv: Arc<Condvar>,
}

impl LinearMutex {
    pub fn new() -> Self {
        LinearMutex {
            id: Self::generate_id(),
            owner: Arc::new(Mutex::new(None)),
            wait_queue: Arc::new(Mutex::new(Vec::new())),
            cv: Arc::new(Condvar::new()),
        }
    }

    pub fn acquire(&self) -> Result<(), String> {
        let current_thread = thread::current().id();
        
        let mut owner = self.owner.lock().unwrap();
        match *owner {
            None => {
                *owner = Some(current_thread);
                Ok(())
            }
            Some(thread_id) if thread_id == current_thread => {
                // é‡å…¥é”
                Ok(())
            }
            Some(_) => {
                // ç­‰å¾…é”
                let mut wait_queue = self.wait_queue.lock().unwrap();
                wait_queue.push(current_thread);
                drop(wait_queue);
                
                while *owner != Some(current_thread) {
                    owner = self.cv.wait(owner).unwrap();
                }
                Ok(())
            }
        }
    }

    pub fn release(&self) -> Result<(), String> {
        let current_thread = thread::current().id();
        
        let mut owner = self.owner.lock().unwrap();
        if *owner == Some(current_thread) {
            *owner = None;
            
            // å”¤é†’ç­‰å¾…çš„çº¿ç¨‹
            let mut wait_queue = self.wait_queue.lock().unwrap();
            if let Some(next_thread) = wait_queue.pop() {
                *owner = Some(next_thread);
            }
            
            self.cv.notify_all();
            Ok(())
        } else {
            Err("Cannot release mutex: not owner".to_string())
        }
    }

    fn generate_id() -> u64 {
        use std::time::{SystemTime, UNIX_EPOCH};
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let mutex = Arc::new(LinearMutex::new());
    let mutex_clone = Arc::clone(&mutex);
    
    let handle = thread::spawn(move || {
        mutex_clone.acquire().unwrap();
        println!("Thread acquired lock");
        thread::sleep(std::time::Duration::from_millis(100));
        mutex_clone.release().unwrap();
        println!("Thread released lock");
    });
    
    mutex.acquire().unwrap();
    println!("Main thread acquired lock");
    mutex.release().unwrap();
    println!("Main thread released lock");
    
    handle.join().unwrap();
}
```

---

## 5. é‡å­çº¿æ€§ç±»å‹ç³»ç»Ÿ

### 5.1 é‡å­çº¿æ€§é€»è¾‘

**å®šä¹‰ 5.1 (é‡å­çº¿æ€§é€»è¾‘)**
é‡å­çº¿æ€§é€»è¾‘æ‰©å±•äº†ç»å…¸çº¿æ€§é€»è¾‘ä»¥æ”¯æŒé‡å­è®¡ç®—ã€‚

**å®šä¹‰ 5.2 (é‡å­è¿æ¥è¯)**
é‡å­çº¿æ€§é€»è¾‘çš„æ–°è¿æ¥è¯ï¼š

- **é‡å­å¼ é‡ç§¯**ï¼š$\otimes_q$ (é‡å­å¼ é‡ç§¯)
- **é‡å­æµ‹é‡**ï¼š$\text{measure}$ (é‡å­æµ‹é‡)
- **é‡å­å åŠ **ï¼š$\oplus_q$ (é‡å­å åŠ )

### 5.2 é‡å­èµ„æºç®¡ç†

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

#[derive(Debug, Clone)]
pub enum QuantumState {
    Zero,
    One,
    Superposition(f64, f64), // |ÏˆâŸ© = Î±|0âŸ© + Î²|1âŸ©
}

#[derive(Debug)]
pub struct Qubit {
    pub id: u64,
    pub state: QuantumState,
    pub entangled: Option<u64>,
}

#[derive(Debug)]
pub struct QuantumResourceManager {
    qubits: Arc<Mutex<HashMap<u64, Qubit>>>,
    gates: Arc<Mutex<HashMap<String, QuantumGate>>>,
    measurements: Arc<Mutex<HashMap<u64, Measurement>>>,
    entanglement: Arc<Mutex<HashMap<u64, Vec<u64>>>>,
}

#[derive(Debug, Clone)]
pub struct QuantumGate {
    pub name: String,
    pub matrix: Vec<Vec<f64>>,
}

#[derive(Debug)]
pub struct Measurement {
    pub id: u64,
    pub qubit_id: u64,
    pub result: bool,
}

impl QuantumResourceManager {
    pub fn new() -> Self {
        QuantumResourceManager {
            qubits: Arc::new(Mutex::new(HashMap::new())),
            gates: Arc::new(Mutex::new(HashMap::new())),
            measurements: Arc::new(Mutex::new(HashMap::new())),
            entanglement: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    pub fn allocate_qubit(&self) -> Result<u64, String> {
        let qubit_id = self.generate_qubit_id();
        let qubit = Qubit {
            id: qubit_id,
            state: QuantumState::Zero,
            entangled: None,
        };

        {
            let mut qubits = self.qubits.lock().unwrap();
            qubits.insert(qubit_id, qubit);
        }

        Ok(qubit_id)
    }

    pub fn apply_gate(&self, gate_name: &str, qubit_ids: &[u64]) -> Result<(), String> {
        let gate = {
            let gates = self.gates.lock().unwrap();
            gates.get(gate_name).cloned()
        };

        if let Some(gate) = gate {
            let mut qubits = self.qubits.lock().unwrap();
            for &qubit_id in qubit_ids {
                if let Some(qubit) = qubits.get_mut(&qubit_id) {
                    qubit.state = self.apply_gate_to_state(&gate, &qubit.state);
                }
            }
            Ok(())
        } else {
            Err(format!("Gate {} not found", gate_name))
        }
    }

    pub fn measure_qubit(&self, qubit_id: u64) -> Result<bool, String> {
        let mut qubits = self.qubits.lock().unwrap();
        let mut measurements = self.measurements.lock().unwrap();

        if let Some(qubit) = qubits.get_mut(&qubit_id) {
            let result = match qubit.state {
                QuantumState::Zero => false,
                QuantumState::One => true,
                QuantumState::Superposition(alpha, beta) => {
                    // ç®€åŒ–çš„æµ‹é‡ï¼šæ ¹æ®æ¦‚ç‡åˆ†å¸ƒ
                    let prob_zero = alpha * alpha;
                    let prob_one = beta * beta;
                    if prob_zero > prob_one {
                        qubit.state = QuantumState::Zero;
                        false
                    } else {
                        qubit.state = QuantumState::One;
                        true
                    }
                }
            };

            let measurement = Measurement {
                id: self.generate_measurement_id(),
                qubit_id,
                result,
            };
            measurements.insert(measurement.id, measurement);

            Ok(result)
        } else {
            Err("Qubit not found".to_string())
        }
    }

    fn apply_gate_to_state(&self, gate: &QuantumGate, state: &QuantumState) -> QuantumState {
        // ç®€åŒ–çš„é—¨åº”ç”¨
        match state {
            QuantumState::Zero => QuantumState::One,
            QuantumState::One => QuantumState::Zero,
            QuantumState::Superposition(alpha, beta) => {
                QuantumState::Superposition(*beta, *alpha)
            }
        }
    }

    fn generate_qubit_id(&self) -> u64 {
        use std::time::{SystemTime, UNIX_EPOCH};
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64
    }

    fn generate_measurement_id(&self) -> u64 {
        use std::time::{SystemTime, UNIX_EPOCH};
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let manager = QuantumResourceManager::new();
    
    // åˆ†é…é‡å­æ¯”ç‰¹
    let qubit_id = manager.allocate_qubit().unwrap();
    println!("Allocated qubit: {}", qubit_id);
    
    // åº”ç”¨Hadamardé—¨
    manager.apply_gate("H", &[qubit_id]).unwrap();
    
    // æµ‹é‡é‡å­æ¯”ç‰¹
    let result = manager.measure_qubit(qubit_id).unwrap();
    println!("Measurement result: {}", result);
}
```

---

## 6. çº¿æ€§ç±»å‹ç³»ç»Ÿçš„ä¼˜åŒ–

### 6.1 çº¿æ€§æ€§æ¨æ–­

**å®šä¹‰ 6.1 (çº¿æ€§æ€§æ¨æ–­)**
çº¿æ€§æ€§æ¨æ–­è‡ªåŠ¨æ¨æ–­å˜é‡çš„çº¿æ€§æ€§ã€‚

**å®šä¹‰ 6.2 (çº¿æ€§æ€§çº¦æŸ)**
çº¿æ€§æ€§çº¦æŸæè¿°å˜é‡çš„ä½¿ç”¨æ¨¡å¼ã€‚

### 6.2 çº¿æ€§æ€§æ¨æ–­ç®—æ³•

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub enum Linearity {
    Linear,
    Affine,
    Relevant,
    Unrestricted,
}

#[derive(Debug)]
pub struct LinearityInference {
    constraints: Vec<LinearityConstraint>,
    solution: HashMap<String, Linearity>,
}

#[derive(Debug)]
pub struct LinearityConstraint {
    variables: Vec<String>,
    relation: LinearityRelation,
}

#[derive(Debug)]
pub enum LinearityRelation {
    Equal,
    LessEqual,
    GreaterEqual,
}

impl LinearityInference {
    pub fn new() -> Self {
        LinearityInference {
            constraints: Vec::new(),
            solution: HashMap::new(),
        }
    }

    pub fn infer_linearity(&mut self, program: &Program) -> HashMap<String, Linearity> {
        // æ”¶é›†çº¿æ€§æ€§çº¦æŸ
        self.collect_constraints(program);
        
        // æ±‚è§£çº¦æŸ
        self.solve_constraints();
        
        self.solution.clone()
    }

    fn collect_constraints(&mut self, program: &Program) {
        // åˆ†æå˜é‡ä½¿ç”¨
        let usage_map = self.analyze_variable_usage(program);
        
        // ç”Ÿæˆçº¦æŸ
        for (var, usage) in usage_map {
            match usage {
                Usage::Unused => {
                    self.solution.insert(var, Linearity::Affine);
                }
                Usage::UsedOnce => {
                    self.solution.insert(var, Linearity::Linear);
                }
                Usage::UsedMultiple => {
                    self.solution.insert(var, Linearity::Unrestricted);
                }
            }
        }
    }

    fn analyze_variable_usage(&self, program: &Program) -> HashMap<String, Usage> {
        let mut usage_map = HashMap::new();
        
        // éå†ç¨‹åºåˆ†æå˜é‡ä½¿ç”¨
        for expr in &program.expressions {
            self.analyze_expression(&mut usage_map, expr);
        }
        
        usage_map
    }

    fn analyze_expression(&self, usage_map: &mut HashMap<String, Usage>, expr: &Expression) {
        match expr {
            Expression::Var(name) => {
                let usage = usage_map.entry(name.clone()).or_insert(Usage::Unused);
                *usage = match *usage {
                    Usage::Unused => Usage::UsedOnce,
                    Usage::UsedOnce => Usage::UsedMultiple,
                    Usage::UsedMultiple => Usage::UsedMultiple,
                };
            }
            Expression::Lambda(param, body) => {
                // å‚æ•°æ ‡è®°ä¸ºçº¿æ€§
                usage_map.insert(param.clone(), Usage::UsedOnce);
                self.analyze_expression(usage_map, body);
            }
            Expression::App(fun, arg) => {
                self.analyze_expression(usage_map, fun);
                self.analyze_expression(usage_map, arg);
            }
            _ => {}
        }
    }

    fn solve_constraints(&mut self) {
        // è¿­ä»£æ±‚è§£çº¦æŸ
        let mut changed = true;
        while changed {
            changed = false;
            for constraint in &self.constraints {
                if self.apply_constraint(constraint) {
                    changed = true;
                }
            }
        }
    }

    fn apply_constraint(&mut self, constraint: &LinearityConstraint) -> bool {
        match constraint.relation {
            LinearityRelation::Equal => {
                let linearity = self.solution.get(&constraint.variables[0]).unwrap().clone();
                for var in &constraint.variables[1..] {
                    if self.solution.get(var) != Some(&linearity) {
                        self.solution.insert(var.clone(), linearity.clone());
                        return true;
                    }
                }
            }
            _ => {}
        }
        false
    }
}

#[derive(Debug)]
pub enum Usage {
    Unused,
    UsedOnce,
    UsedMultiple,
}

#[derive(Debug)]
pub struct Program {
    expressions: Vec<Expression>,
}

#[derive(Debug)]
pub enum Expression {
    Var(String),
    Lambda(String, Box<Expression>),
    App(Box<Expression>, Box<Expression>),
    // å…¶ä»–è¡¨è¾¾å¼ç±»å‹
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let mut inference = LinearityInference::new();
    
    // åˆ›å»ºç¤ºä¾‹ç¨‹åº
    let program = Program {
        expressions: vec![
            Expression::Lambda("x".to_string(), Box::new(Expression::Var("x".to_string()))),
        ],
    };
    
    // æ¨æ–­çº¿æ€§æ€§
    let linearity_map = inference.infer_linearity(&program);
    println!("Linearity inference result: {:?}", linearity_map);
}
```

---

## 7. å‰æ²¿ç ”ç©¶æ–¹å‘

### 7.1 é«˜é˜¶çº¿æ€§ç±»å‹ç³»ç»Ÿ

**å®šä¹‰ 7.1 (é«˜é˜¶çº¿æ€§ç±»å‹)**
é«˜é˜¶çº¿æ€§ç±»å‹æ”¯æŒç±»å‹çº§åˆ«çš„çº¿æ€§æ€§ã€‚

**å®šä¹‰ 7.2 (çº¿æ€§ç±»å‹æ—)**
çº¿æ€§ç±»å‹æ—å®šä¹‰ç±»å‹çº§åˆ«çš„çº¿æ€§æ€§å…³ç³»ã€‚

### 7.2 çº¿æ€§ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–éªŒè¯

**å®šä¹‰ 7.3 (çº¿æ€§ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–)**
çº¿æ€§ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–åœ¨è¯æ˜åŠ©æ‰‹ä¸­å®ç°ã€‚

**å®šä¹‰ 7.4 (çº¿æ€§æ€§è¯æ˜)**
çº¿æ€§æ€§è¯æ˜ç¡®ä¿ç¨‹åºçš„çº¿æ€§æ€§æ€§è´¨ã€‚

---

## ğŸ”„ **ä¸å…¶ä»–ç†è®ºçš„å…³è”**

### å‘ä¸Šå…³è”

- **å½¢å¼è¯­è¨€ç†è®º**ï¼š[03_Formal_Language_Theory](../03_Formal_Language_Theory/README.md)
- **æ•°å­¦åŸºç¡€ç†è®º**ï¼š[02_Mathematical_Foundation](../02_Mathematical_Foundations/01_Mathematical_Foundation_Index.md)

### å‘ä¸‹å…³è”

- **æ§åˆ¶è®ºç†è®º**ï¼š[05_Control_Theory](../03_Control_Theory/01_Control_Theory_Index.md)
- **å¹¶å‘ç†è®º**ï¼š[11_Concurrency_Theory](../11_Concurrency_Theory/01_Concurrency_Theory_Index.md)

---

## ğŸ“– **å­¦ä¹ è·¯å¾„å»ºè®®**

### åŸºç¡€è·¯å¾„

1. çº¿æ€§é€»è¾‘åŸºç¡€ â†’ çº¿æ€§Î»æ¼”ç®— â†’ èµ„æºç®¡ç†
2. å¹¶å‘æ§åˆ¶ â†’ é‡å­çº¿æ€§ç±»å‹ç³»ç»Ÿ â†’ ç³»ç»Ÿä¼˜åŒ–
3. å‰æ²¿ç ”ç©¶æ–¹å‘ â†’ å½¢å¼åŒ–éªŒè¯ â†’ ç†è®ºç»¼åˆ

### ä¸“ä¸šè·¯å¾„

- **ç³»ç»Ÿç¼–ç¨‹æ–¹å‘**ï¼šèµ„æºç®¡ç† â†’ å¹¶å‘æ§åˆ¶ â†’ ç³»ç»Ÿä¼˜åŒ–
- **é‡å­è®¡ç®—æ–¹å‘**ï¼šé‡å­çº¿æ€§ç±»å‹ â†’ é‡å­èµ„æºç®¡ç† â†’ é‡å­ç¨‹åºéªŒè¯
- **å½¢å¼éªŒè¯æ–¹å‘**ï¼šçº¿æ€§æ€§è¯æ˜ â†’ å½¢å¼åŒ–éªŒè¯ â†’ å®šç†è¯æ˜

---

## ğŸ”„ **æŒç»­æ›´æ–°**

**æœ€åæ›´æ–°æ—¶é—´**ï¼š2024-12-20
**ç‰ˆæœ¬**ï¼šv1.0.0
**ç»´æŠ¤è€…**ï¼šçº¿æ€§ç±»å‹ç†è®ºé‡æ„å›¢é˜Ÿ

---

## ğŸ“‹ **å¾…å®Œæˆä»»åŠ¡**

- [ ] å®Œå–„é‡å­çº¿æ€§ç±»å‹ç³»ç»Ÿçš„å®ç°
- [ ] å»ºç«‹çº¿æ€§æ€§è¯æ˜çš„è‡ªåŠ¨åŒ–å·¥å…·
- [ ] æ„å»ºçº¿æ€§ç±»å‹ç³»ç»Ÿä¸å¹¶å‘ç†è®ºçš„æ¡¥æ¢
- [ ] å¼€å‘çº¿æ€§ç±»å‹ç³»ç»Ÿçš„å®é™…åº”ç”¨æ¡ˆä¾‹

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
