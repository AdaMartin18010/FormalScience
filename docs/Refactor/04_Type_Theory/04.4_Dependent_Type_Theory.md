# 04.4 依赖类型理论 (Dependent Type Theory)

## 📋 概述

依赖类型允许类型依赖于项，表达“带规格的程序”与“证明即程序”的强对应，是交互式定理证明与可验证编程的核心基础。

## 基本构件

- 依赖函数类型：`Πx:A. B x`（对应 ∀）
- 依赖对/Σ类型：`Σx:A. B x`（对应 ∃）
- 身份/等同性类型：`Id_A(a,b)` 或 `a =_A b`
- 归纳/递归类型与消解器：`Nat/Vec/Eq` 等

## 判断与规则（轮廓）

- 上下文与类型良构：`Γ ⊢ A : Type`，`Γ ⊢ t : A`
- 转换规则：β/η，传递替换与提升
- 归纳原理：通过消解器与模式匹配给出计算行为

## 关键性质

- 类型检查与相等判定：规范化/可判定性取决于核心设计
- Curry–Howard：`定理 ↔ 类型`，`证明 ↔ 项`，可提取可执行程序

## 示例（占位）

```coq
(* 依赖对与向量示意 *)
```

```lean
-- 等同性传递与重写示意
```

## 参考文献

1. Martin‑Löf, Intuitionistic Type Theory.
2. The Coq/Agda/Lean reference manuals.

## 批判性分析

- 多元理论视角：
  - 规格即类型：将程序性质内化为类型层级，统一“写代码—写证明”的开发活动。
  - 语义多样：集合/范畴/同伦多视角语义增强表达力，但也引入相等判定与可实现性的张力。
- 局限性分析：
  - 工程成本：强表达力带来类型推断难题、错误信息复杂与学习曲线陡峭；可信内核与库治理成为门槛。
  - 可判定边界：加入外延、公理或高等同性后，类型检查/相等判定可能失去判定性或性能恶化。
- 争议与分歧：
  - 内外延选择、证明无关性、计算内容与提取边界；“先可判定核心再扩展” vs “一次到位”的路线之争。
- 应用前景：
  - 安全关键软件、编译器与协议栈验证、数学形式化；在教育与研究复现中价值显著。
- 改进建议：
  - 分层核心：以小型可判定核心（Calculus of Constructions 等）承载扩展；标准化证据产物与CI 校验流程。
  - 工具体验：改进错误诊断、交互提示与库生态，降低采用门槛。
