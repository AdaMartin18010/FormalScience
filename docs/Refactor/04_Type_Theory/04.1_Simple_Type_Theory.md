# ç®€å•ç±»å‹ç†è®º (Simple Type Theory)

## ğŸ“‹ ç« èŠ‚ä¿¡æ¯

**ç¼–å·**: 04.1  
**ä¸Šçº§ç« èŠ‚**: [ç±»å‹ç†è®º](01_Type_Theory_Index.md)  
**åˆ›å»ºæ—¶é—´**: 2024-12-21  
**æœ€åæ›´æ–°**: 2024-12-21  
**å†…å®¹å®Œæ•´åº¦**: 80%  

## ğŸ¯ ç« èŠ‚æ¦‚è¿°

ç®€å•ç±»å‹ç†è®ºæ˜¯ç±»å‹ç†è®ºçš„åŸºç¡€ï¼Œå®ƒåœ¨æ— ç±»å‹Î»æ¼”ç®—çš„åŸºç¡€ä¸Šå¼•å…¥ç±»å‹ç³»ç»Ÿï¼Œç ”ç©¶å¦‚ä½•ä½¿ç”¨ç±»å‹æ¥æè¿°ç¨‹åºçš„è¡Œä¸ºå’Œå±æ€§ã€‚æœ¬ç« å°†ä»‹ç»Î»æ¼”ç®—çš„åŸºç¡€çŸ¥è¯†ï¼Œç®€å•ç±»å‹Î»æ¼”ç®—ï¼ˆSimply Typed Lambda Calculus, STLCï¼‰çš„å½¢å¼åŒ–å®šä¹‰ï¼Œç±»å‹æ¨å¯¼ç³»ç»Ÿä»¥åŠç±»å‹å®‰å…¨æ€§çš„è¯æ˜ã€‚

ç®€å•ç±»å‹ç†è®ºè™½ç„¶è¡¨è¾¾èƒ½åŠ›æœ‰é™ï¼Œä½†ä¸ºä¾èµ–ç±»å‹ã€å¤šæ€ç±»å‹å’Œå­ç±»å‹ç³»ç»Ÿç­‰æ›´å¤æ‚çš„ç±»å‹ç†è®ºå¥ å®šäº†åŸºç¡€ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»Ÿè®¾è®¡çš„ç†è®ºèµ·ç‚¹ã€‚

## ğŸ“š æ ¸å¿ƒå†…å®¹

### 1. Î»æ¼”ç®—åŸºç¡€

Î»æ¼”ç®—æ˜¯ä¸€ç§å½¢å¼åŒ–çš„è®¡ç®—æ¨¡å‹ï¼Œç”±Alonzo Churchäº20ä¸–çºª30å¹´ä»£æå‡ºï¼Œæ˜¯å‡½æ•°å¼ç¼–ç¨‹çš„ç†è®ºåŸºç¡€ã€‚Î»æ¼”ç®—å…·æœ‰å›¾çµå®Œå¤‡æ€§ï¼Œå¯ä»¥è¡¨ç¤ºä»»ä½•å¯è®¡ç®—å‡½æ•°ã€‚

#### 1.1 è¯­æ³•

æ— ç±»å‹Î»æ¼”ç®—çš„è¯­æ³•å®šä¹‰å¦‚ä¸‹ï¼š

$$
\begin{align}
t ::= & x & \text{(å˜é‡)} \\
    | & \lambda x.t & \text{(æŠ½è±¡)} \\
    | & t_1 \; t_2 & \text{(åº”ç”¨)}
\end{align}
$$

å…¶ä¸­ï¼š

- $x$ æ˜¯å˜é‡
- $\lambda x.t$ è¡¨ç¤ºå‡½æ•°æŠ½è±¡ï¼Œ$x$ æ˜¯å‚æ•°ï¼Œ$t$ æ˜¯å‡½æ•°ä½“
- $t_1 \; t_2$ è¡¨ç¤ºå‡½æ•°åº”ç”¨ï¼Œå³å°†å‡½æ•° $t_1$ åº”ç”¨äºå‚æ•° $t_2$

#### 1.2 å½’çº¦è§„åˆ™

Î»æ¼”ç®—çš„è®¡ç®—é€šè¿‡Î²-å½’çº¦ï¼ˆbeta-reductionï¼‰è¿›è¡Œï¼š

$$
(\lambda x.t_1) \; t_2 \to [x \mapsto t_2]t_1
$$

è¿™è¡¨ç¤ºå°†å‡½æ•° $\lambda x.t_1$ åº”ç”¨åˆ°å‚æ•° $t_2$ ä¸Šï¼Œç»“æœæ˜¯å°†å‡½æ•°ä½“ $t_1$ ä¸­çš„æ‰€æœ‰è‡ªç”±å‡ºç°çš„å˜é‡ $x$ æ›¿æ¢ä¸º $t_2$ã€‚

#### 1.3 æ— ç±»å‹Î»æ¼”ç®—çš„å±€é™æ€§

æ— ç±»å‹Î»æ¼”ç®—è™½ç„¶å¼ºå¤§ï¼Œä½†ä¹Ÿå­˜åœ¨é—®é¢˜ï¼š

- ä¸èƒ½ç›´æ¥æ£€æµ‹ç±»å‹é”™è¯¯
- å¯èƒ½å¯¼è‡´ä¸ç»ˆæ­¢çš„è®¡ç®—
- å®¹æ˜“äº§ç”Ÿæ‚–è®ºï¼ˆå¦‚Russellæ‚–è®ºï¼‰

**è¯¦ç»†å†…å®¹è¯·å‚é˜…**: [Î»æ¼”ç®—åŸºç¡€](04.1.1_Lambda_Calculus.md)

### 2. ç®€å•ç±»å‹Î»æ¼”ç®—

ç®€å•ç±»å‹Î»æ¼”ç®—ï¼ˆSTLCï¼‰é€šè¿‡ä¸ºÎ»æ¼”ç®—æ·»åŠ ç±»å‹ç³»ç»Ÿï¼Œè§£å†³äº†æ— ç±»å‹Î»æ¼”ç®—çš„ä¸€äº›é—®é¢˜ã€‚

#### 2.1 ç±»å‹è¯­æ³•

ç®€å•ç±»å‹ç³»ç»ŸåŒ…å«åŸºæœ¬ç±»å‹å’Œå‡½æ•°ç±»å‹ï¼š

$$
\begin{align}
\tau ::= & \; b & \text{(åŸºæœ¬ç±»å‹)} \\
    | & \; \tau_1 \to \tau_2 & \text{(å‡½æ•°ç±»å‹)}
\end{align}
$$

å…¶ä¸­:

- $b$ æ˜¯åŸºæœ¬ç±»å‹ï¼Œå¦‚ Boolã€Nat ç­‰
- $\tau_1 \to \tau_2$ è¡¨ç¤ºä»ç±»å‹ $\tau_1$ åˆ°ç±»å‹ $\tau_2$ çš„å‡½æ•°ç±»å‹

#### 2.2 ç±»å‹è§„åˆ™

ç®€å•ç±»å‹Î»æ¼”ç®—çš„ç±»å‹è§„åˆ™é€šè¿‡ç±»å‹åˆ¤æ–­ï¼ˆtyping judgmentsï¼‰æ¥å®šä¹‰ï¼Œå½¢å¼ä¸º $\Gamma \vdash t : \tau$ï¼Œè¡¨ç¤ºåœ¨ä¸Šä¸‹æ–‡ $\Gamma$ ä¸­ï¼Œé¡¹ $t$ å…·æœ‰ç±»å‹ $\tau$ã€‚

ä¸»è¦çš„ç±»å‹è§„åˆ™åŒ…æ‹¬ï¼š

**å˜é‡è§„åˆ™**:
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau} \textsf{(T-Var)}$$

**æŠ½è±¡è§„åˆ™**:
$$\frac{\Gamma, x : \tau_1 \vdash t : \tau_2}{\Gamma \vdash \lambda x : \tau_1. t : \tau_1 \to \tau_2} \textsf{(T-Abs)}$$

**åº”ç”¨è§„åˆ™**:
$$\frac{\Gamma \vdash t_1 : \tau_1 \to \tau_2 \quad \Gamma \vdash t_2 : \tau_1}{\Gamma \vdash t_1 \; t_2 : \tau_2} \textsf{(T-App)}$$

#### 2.3 ç®€å•ç±»å‹Î»æ¼”ç®—çš„æ€§è´¨

STLCå…·æœ‰ä»¥ä¸‹é‡è¦æ€§è´¨ï¼š

- **ç±»å‹ä¿æŒï¼ˆSubject Reductionï¼‰**: å¦‚æœ $\Gamma \vdash t : \tau$ ä¸” $t \to t'$ï¼Œåˆ™ $\Gamma \vdash t' : \tau$
- **å¼ºè§„èŒƒåŒ–ï¼ˆStrong Normalizationï¼‰**: æ‰€æœ‰è‰¯ç±»å‹çš„é¡¹éƒ½ä¼šåœ¨æœ‰é™æ­¥éª¤å†…å½’çº¦åˆ°èŒƒå¼
- **è¿›åº¦ï¼ˆProgressï¼‰**: è‰¯ç±»å‹çš„å°é—­é¡¹è¦ä¹ˆæ˜¯å€¼ï¼Œè¦ä¹ˆå¯ä»¥è¿›ä¸€æ­¥å½’çº¦

**è¯¦ç»†å†…å®¹è¯·å‚é˜…**: [ç®€å•ç±»å‹Î»æ¼”ç®—](04.1.2_Simply_Typed_Lambda_Calculus.md)

### 3. ç±»å‹æ¨å¯¼

ç±»å‹æ¨å¯¼æ˜¯è‡ªåŠ¨ç¡®å®šç¨‹åºè¡¨è¾¾å¼ç±»å‹çš„è¿‡ç¨‹ï¼Œæ— éœ€æ˜¾å¼ç±»å‹æ³¨è§£ã€‚Hindley-Milnerç³»ç»Ÿæ˜¯æœ€è‘—åçš„ç±»å‹æ¨å¯¼ç®—æ³•ä¹‹ä¸€ã€‚

#### 3.1 Hindley-Milnerç³»ç»Ÿ

Hindley-Milnerç³»ç»Ÿä¸ºÎ»æ¼”ç®—æ·»åŠ äº†å¤šæ€ç±»å‹ï¼ŒåŒæ—¶ä¿æŒäº†ç±»å‹æ¨å¯¼çš„å¯åˆ¤å®šæ€§ã€‚

#### 3.2 ç±»å‹å˜é‡å’Œç±»å‹çº¦æŸ

ç±»å‹æ¨å¯¼é€šè¿‡å¼•å…¥ç±»å‹å˜é‡å’Œæ”¶é›†ç±»å‹çº¦æŸæ¥å·¥ä½œï¼š

$$
\begin{align}
\sigma ::= & \; \tau & \text{(å•æ€ç±»å‹)} \\
    | & \; \forall \alpha. \sigma & \text{(å¤šæ€ç±»å‹)}
\end{align}
$$

#### 3.3 ç»Ÿä¸€ç®—æ³•

ç±»å‹æ¨å¯¼çš„æ ¸å¿ƒæ˜¯ç»Ÿä¸€ç®—æ³•ï¼ˆUnification Algorithmï¼‰ï¼Œç”¨äºè§£å†³ç±»å‹çº¦æŸæ–¹ç¨‹ã€‚

**è¯¦ç»†å†…å®¹è¯·å‚é˜…**: [Hindley-Milnerç³»ç»Ÿ](04.1.3_Hindley_Milner_System.md)

### 4. ç³»ç»ŸF

ç³»ç»ŸFï¼ˆSystem Fï¼‰åˆç§°ä¸ºå¤šæ€Î»æ¼”ç®—ï¼Œç”±Jean-Yves Girardå’ŒJohn Reynoldsåˆ†åˆ«ç‹¬ç«‹å‘ç°ï¼Œå®ƒæ‰©å±•äº†ç®€å•ç±»å‹Î»æ¼”ç®—ï¼Œå¢åŠ äº†å¤šæ€ç±»å‹ã€‚

#### 4.1 ç±»å‹æŠ½è±¡å’Œç±»å‹åº”ç”¨

ç³»ç»ŸFå¼•å…¥äº†ç±»å‹æŠ½è±¡å’Œç±»å‹åº”ç”¨ï¼š

$$
\begin{align}
t ::= & \; ... & \text{(STLCé¡¹)} \\
    | & \; \Lambda \alpha. t & \text{(ç±»å‹æŠ½è±¡)} \\
    | & \; t[\tau] & \text{(ç±»å‹åº”ç”¨)}
\end{align}
$$

#### 4.2 å‚æ•°å¤šæ€

ç³»ç»ŸFæ”¯æŒå‚æ•°å¤šæ€ï¼Œå…è®¸å‡½æ•°å¯¹ä¸åŒç±»å‹çš„å€¼è¿›è¡Œç»Ÿä¸€å¤„ç†ã€‚

#### 4.3 ç³»ç»ŸFçš„æ€§è´¨

ç³»ç»ŸFå…·æœ‰å¼ºå¤§çš„è¡¨è¾¾èƒ½åŠ›ï¼Œä½†ç±»å‹æ¨å¯¼çš„å®Œå…¨æ€§ä¸å†ä¿è¯ã€‚

**è¯¦ç»†å†…å®¹è¯·å‚é˜…**: [ç³»ç»ŸF](04.1.4_System_F.md)

## ğŸ’» ä»£ç å®ç°

### Rustå®ç°ç®€å•ç±»å‹ç³»ç»Ÿ

```rust
enum Type {
    Base(String),
    Function(Box<Type>, Box<Type>),
}

enum Term {
    Var(String),
    Abs(String, Type, Box<Term>),
    App(Box<Term>, Box<Term>),
}

struct TypeChecker {
    context: HashMap<String, Type>,
}

impl TypeChecker {
    fn new() -> Self {
        Self { context: HashMap::new() }
    }
    
    fn type_check(&self, term: &Term) -> Result<Type, String> {
        match term {
            Term::Var(x) => {
                if let Some(ty) = self.context.get(x) {
                    Ok(ty.clone())
                } else {
                    Err(format!("Unbound variable: {}", x))
                }
            },
            Term::Abs(x, ty, t) => {
                let mut new_context = self.context.clone();
                new_context.insert(x.clone(), ty.clone());
                
                let checker = TypeChecker { context: new_context };
                let t_type = checker.type_check(t)?;
                
                Ok(Type::Function(Box::new(ty.clone()), Box::new(t_type)))
            },
            Term::App(t1, t2) => {
                let t1_type = self.type_check(t1)?;
                let t2_type = self.type_check(t2)?;
                
                if let Type::Function(arg_type, ret_type) = t1_type {
                    if *arg_type == t2_type {
                        Ok(*ret_type)
                    } else {
                        Err("Type mismatch in application".to_string())
                    }
                } else {
                    Err("Expected function in application".to_string())
                }
            }
        }
    }
}
```

### Haskellå®ç°å¤šæ€ç±»å‹æ¨å¯¼

```haskell
data Type = TVar String
          | TBase String
          | TFun Type Type
          deriving (Eq, Show)

data Term = Var String
          | Abs String Term
          | App Term Term
          deriving (Eq, Show)

type Subst = [(String, Type)]

apply :: Subst -> Type -> Type
apply s (TVar n) = case lookup n s of
                      Just t  -> t
                      Nothing -> TVar n
apply s (TFun t1 t2) = TFun (apply s t1) (apply s t2)
apply _ t@(TBase _) = t

infer :: [(String, Type)] -> Term -> (Type, Subst)
infer env (Var x) = 
  case lookup x env of
    Just t  -> (t, [])
    Nothing -> error $ "Unbound variable: " ++ x
infer env (Abs x e) = 
  let tv = TVar "a"  -- Fresh type variable
      (t, s) = infer ((x, tv):env) e
  in (TFun (apply s tv) t, s)
infer env (App e1 e2) = 
  let (t1, s1) = infer env e1
      (t2, s2) = infer (map (\(x,t) -> (x, apply s1 t)) env) e2
      tv = TVar "b"  -- Fresh type variable
      s3 = unify (apply s2 t1) (TFun t2 tv)
  in (apply s3 tv, compose s3 (compose s2 s1))
```

## ğŸ“ ç»ƒä¹ ä¸æ€è€ƒ

1. å®ç°ä¸€ä¸ªç®€å•çš„ç±»å‹æ£€æŸ¥å™¨ï¼Œèƒ½å¤Ÿå¤„ç†åŸºæœ¬çš„Î»è¡¨è¾¾å¼ã€‚
2. è¯æ˜STLCçš„è¿›åº¦å®šç†ï¼ˆProgress Theoremï¼‰ã€‚
3. æ‰©å±•STLCï¼Œæ·»åŠ å¸ƒå°”ç±»å‹å’Œæ¡ä»¶è¡¨è¾¾å¼ã€‚
4. æ¯”è¾ƒHindley-Milnerç³»ç»Ÿå’Œç³»ç»ŸFçš„è¡¨è¾¾èƒ½åŠ›ã€‚
5. æ¢è®¨ç±»å‹ç†è®ºåœ¨ç¼–ç¨‹è¯­è¨€è®¾è®¡ä¸­çš„åº”ç”¨ã€‚

## ğŸ“š æ‰©å±•é˜…è¯»

1. Pierce, B. C. (2002). *Types and Programming Languages*. MIT Press.
2. Harper, R. (2016). *Practical Foundations for Programming Languages*. Cambridge University Press.
3. Hindley, J. R. (1969). *The Principal Type-Scheme of an Object in Combinatory Logic*. Transactions of the American Mathematical Society.
4. Milner, R. (1978). *A Theory of Type Polymorphism in Programming*. Journal of Computer and System Sciences.
5. Reynolds, J. C. (1974). *Towards a Theory of Type Structure*. Programming Symposium.

## ğŸ”„ ä¸å…¶ä»–ç« èŠ‚çš„è”ç³»

- [Î»æ¼”ç®—åŸºç¡€](04.1.1_Lambda_Calculus.md)ï¼šè¯¦ç»†ä»‹ç»Î»æ¼”ç®—çš„è¯­æ³•ã€è¯­ä¹‰å’ŒåŸºæœ¬æ€§è´¨ã€‚
- [ç®€å•ç±»å‹Î»æ¼”ç®—](04.1.2_Simply_Typed_Lambda_Calculus.md)ï¼šæ·±å…¥ç ”ç©¶ç®€å•ç±»å‹ç³»ç»Ÿçš„å½¢å¼åŒ–å®šä¹‰å’Œæ€§è´¨ã€‚
- [Hindley-Milnerç³»ç»Ÿ](04.1.3_Hindley_Milner_System.md)ï¼šæ¢è®¨ç±»å‹æ¨å¯¼ç®—æ³•å’Œå¤šæ€ç±»å‹ã€‚
- [ç³»ç»ŸF](04.1.4_System_F.md)ï¼šç ”ç©¶å‚æ•°å¤šæ€å’Œæ›´å¼ºå¤§çš„ç±»å‹ç³»ç»Ÿã€‚
- [çº¿æ€§ç±»å‹ç†è®º](04.2_Linear_Type_Theory.md)ï¼šå»ºç«‹åœ¨ç®€å•ç±»å‹ç†è®ºåŸºç¡€ä¸Šçš„èµ„æºæ•æ„Ÿç±»å‹ç³»ç»Ÿã€‚
- [ä¾èµ–ç±»å‹ç†è®º](04.4_Dependent_Type_Theory.md)ï¼šå°†ç±»å‹ä¸å€¼å…³è”èµ·æ¥çš„é«˜çº§ç±»å‹ç³»ç»Ÿã€‚
- [ç¼–ç¨‹è¯­è¨€è®¾è®¡](04.8.1_Programming_Language_Design.md)ï¼šç±»å‹ç†è®ºåœ¨ç¼–ç¨‹è¯­è¨€è®¾è®¡ä¸­çš„åº”ç”¨ã€‚

---

**ç‰ˆæœ¬**: v1.0  
**ç»´æŠ¤è€…**: ç±»å‹ç†è®ºé‡æ„å›¢é˜Ÿ
