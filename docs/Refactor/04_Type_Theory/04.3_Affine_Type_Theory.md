# 04.3 仿射类型理论 (Affine Type Theory)

## 📋 概述

仿射类型放宽线性“必须使用一次”为“至多使用一次”，允许丢弃但禁止复制，兼顾资源安全与工程可用性，常作为线性类型的实用化折中。

## 语法直觉与差异

- 线性 `A ⊸ B` 与仿射 `A ⟿ B`（记号示意）：仿射允许弱化（丢弃）
- 允许弱化（W），禁止收缩（C）；可选以指数/标签表达可复制区域

## 规则（轮廓）

- 变量使用约束：未用到的绑定在仿射系统中合法
- 与所有权/借用：仿射可直观对齐“可丢弃所有权”，借用规则需另行约束

## 性质与应用

- 防止重复释放与双重别名导致的竞态；同时不强制“必须使用”，降低心智负担
- 适合错误恢复路径、可提前中止的计算与资源清理模式

## 代码片段

```rust
// 仿射直觉：值可被丢弃，但不会隐式复制（Copy 需显式派生）
struct Token;

fn maybe_use(t: Token) {
    // 允许提前返回导致未使用 t（仿射允许丢弃）
    let _ = core::mem::drop(t);
}
```

```haskell
-- 概念示意：仿射风格 API（通过类型类/约束禁止复制）
class Affine a where
  discard :: a -> ()

useOrDiscard :: Affine a => Bool -> a -> ()
useOrDiscard cond x = if cond then discard x else ()
```

## 参考文献

1. Tov & Pucella, Practical Affine Types.
2. Wadler, Linear/Affine Types in Practice.

## 批判性分析

- 多元理论视角：
  - 从线性到仿射：以弱化替代严格守恒，贴近异常/提前返回等工程控制流，保持大部分资源安全收益。
  - 与效应系统：仿射约束与效果标注/区域/生命周期联合使用，形成可组合资源语义。
- 局限性分析：
  - 剩余风险：允许丢弃可能掩盖资源泄漏，需要配合析构/RAII/自动清理策略；与GC/RC的协同设计重要。
  - 推断与可读性：静态诊断与类型推断复杂度上升；需要良好错误信息与IDE 支持。
- 争议与分歧：
  - 何时选择仿射而非线性：性能/安全/可用性的权衡因域而异；是否引入统一指数区或专用标注存在分歧。
- 应用前景：
  - 系统编程与服务端开发中的资源通道、错误处理路径、超时/取消语义；与会话类型结合以降摩擦。
- 改进建议：
  - 提供“线性↔仿射”迁移指南与对照案例；构建常用抽象（仿射Option/Result、仿射迭代器）与基准评测。
