# 04.2.4 çº¿æ€§ç±»å‹ç³»ç»Ÿ

## ğŸ“‹ æ¦‚è¿°

çº¿æ€§ç±»å‹ç³»ç»Ÿæ˜¯ç±»å‹ç†è®ºçš„é‡è¦åˆ†æ”¯ï¼Œå®ƒåŸºäºçº¿æ€§é€»è¾‘çš„æ€æƒ³ï¼Œè¦æ±‚æ¯ä¸ªå€¼å¿…é¡»è¢«ä½¿ç”¨æ°å¥½ä¸€æ¬¡ã€‚è¿™ç§ç±»å‹ç³»ç»Ÿä¸ºèµ„æºç®¡ç†ã€å†…å­˜å®‰å…¨å’Œå¹¶å‘ç¼–ç¨‹æä¾›äº†å¼ºå¤§çš„ç†è®ºåŸºç¡€ï¼Œæ˜¯ç°ä»£ç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚Rustï¼‰ç±»å‹ç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹çº¿æ€§ç±»å‹ç³»ç»Ÿçš„æ•°å­¦åŸºç¡€**
2. **å®šä¹‰çº¿æ€§ç±»å‹å’Œçº¿æ€§å‡½æ•°**
3. **ç ”ç©¶çº¿æ€§ç±»å‹ç³»ç»Ÿçš„æ€§è´¨**
4. **æä¾›çº¿æ€§ç±»å‹ç³»ç»Ÿçš„å®ç°æ–¹æ³•**
5. **åˆ†æçº¿æ€§ç±»å‹ç³»ç»Ÿåœ¨ç¼–ç¨‹ä¸­çš„åº”ç”¨**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 çº¿æ€§é€»è¾‘åŸºç¡€

**å®šä¹‰ 1.1.1 (çº¿æ€§é€»è¾‘)**
çº¿æ€§é€»è¾‘æ˜¯ç»å…¸é€»è¾‘çš„å˜ç§ï¼Œå…¶ä¸­æ¯ä¸ªå…¬å¼å¿…é¡»è¢«ä½¿ç”¨æ°å¥½ä¸€æ¬¡ã€‚åœ¨çº¿æ€§é€»è¾‘ä¸­ï¼Œåˆå–ï¼ˆâŠ—ï¼‰å’Œæå–ï¼ˆâ…‹ï¼‰æ˜¯çº¿æ€§çš„ï¼Œè€Œåˆå–ï¼ˆ&ï¼‰å’Œæå–ï¼ˆâŠ•ï¼‰æ˜¯éçº¿æ€§çš„ã€‚

**å®šä¹‰ 1.1.2 (çº¿æ€§è•´æ¶µ)**
çº¿æ€§è•´æ¶µ $A \multimap B$ è¡¨ç¤ºä» $A$ åˆ° $B$ çš„çº¿æ€§å‡½æ•°ï¼Œä½¿ç”¨ $A$ æ°å¥½ä¸€æ¬¡æ¥äº§ç”Ÿ $B$ã€‚

**å®šä¹‰ 1.1.3 (çº¿æ€§åˆå–)**
çº¿æ€§åˆå– $A \otimes B$ è¡¨ç¤º $A$ å’Œ $B$ çš„çº¿æ€§ç»„åˆï¼Œæ¯ä¸ªéƒ½å¿…é¡»è¢«ä½¿ç”¨æ°å¥½ä¸€æ¬¡ã€‚

### 1.2 çº¿æ€§ç±»å‹

**å®šä¹‰ 1.2.1 (çº¿æ€§ç±»å‹)**
çº¿æ€§ç±»å‹æ˜¯å¿…é¡»è¢«ä½¿ç”¨æ°å¥½ä¸€æ¬¡çš„ç±»å‹ã€‚å¦‚æœä¸€ä¸ªå€¼å…·æœ‰çº¿æ€§ç±»å‹ï¼Œé‚£ä¹ˆå®ƒä¸èƒ½è¢«å¤åˆ¶ã€ä¸¢å¼ƒæˆ–å¤šæ¬¡ä½¿ç”¨ã€‚

**å®šä¹‰ 1.2.2 (çº¿æ€§å‡½æ•°ç±»å‹)**
çº¿æ€§å‡½æ•°ç±»å‹ $A \multimap B$ è¡¨ç¤ºä»ç±»å‹ $A$ åˆ°ç±»å‹ $B$ çš„çº¿æ€§å‡½æ•°ï¼Œè¯¥å‡½æ•°å¿…é¡»ä½¿ç”¨å…¶å‚æ•°æ°å¥½ä¸€æ¬¡ã€‚

**å®šä¹‰ 1.2.3 (çº¿æ€§å¯¹ç±»å‹)**
çº¿æ€§å¯¹ç±»å‹ $A \otimes B$ è¡¨ç¤ºåŒ…å«ç±»å‹ $A$ å’Œ $B$ çš„çº¿æ€§å¯¹ï¼Œä¸¤ä¸ªåˆ†é‡éƒ½å¿…é¡»è¢«ä½¿ç”¨æ°å¥½ä¸€æ¬¡ã€‚

### 1.3 çº¿æ€§ç±»å‹ç³»ç»Ÿè§„åˆ™

**å®šä¹‰ 1.3.1 (çº¿æ€§ç¯å¢ƒ)**
çº¿æ€§ç¯å¢ƒ $\Gamma$ æ˜¯ä¸€ä¸ªä»å˜é‡åˆ°ç±»å‹çš„æ˜ å°„ï¼Œå…¶ä¸­æ¯ä¸ªå˜é‡æœ€å¤šå‡ºç°ä¸€æ¬¡ã€‚

**å®šä¹‰ 1.3.2 (çº¿æ€§ç±»å‹åˆ¤æ–­)**
çº¿æ€§ç±»å‹åˆ¤æ–­ $\Gamma \vdash t : A$ è¡¨ç¤ºåœ¨ç¯å¢ƒ $\Gamma$ ä¸‹ï¼Œé¡¹ $t$ å…·æœ‰ç±»å‹ $A$ã€‚

**å®šä¹‰ 1.3.3 (çº¿æ€§ä½¿ç”¨)**
çº¿æ€§ä½¿ç”¨è¦æ±‚æ¯ä¸ªå˜é‡åœ¨ç±»å‹æ¨å¯¼ä¸­æœ€å¤šå‡ºç°ä¸€æ¬¡ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 çº¿æ€§Î»æ¼”ç®—

**å®šä¹‰ 2.1.1 (çº¿æ€§Î»æ¼”ç®—è¯­æ³•)**
çº¿æ€§Î»æ¼”ç®—çš„è¯­æ³•å®šä¹‰å¦‚ä¸‹ï¼š
$$t ::= x \mid \lambda x.t \mid t_1 \otimes t_2 \mid \text{let } x \otimes y = t_1 \text{ in } t_2 \mid t_1 \, t_2$$

**å®šä¹‰ 2.1.2 (çº¿æ€§Î»æ¼”ç®—ç±»å‹è§„åˆ™)**
çº¿æ€§Î»æ¼”ç®—çš„ç±»å‹è§„åˆ™å¦‚ä¸‹ï¼š

1. **å˜é‡è§„åˆ™**ï¼š
   $$\frac{x : A \in \Gamma}{\Gamma \vdash x : A}$$

2. **æŠ½è±¡è§„åˆ™**ï¼š
   $$\frac{\Gamma, x : A \vdash t : B}{\Gamma \vdash \lambda x.t : A \multimap B}$$

3. **åº”ç”¨è§„åˆ™**ï¼š
   $$\frac{\Gamma_1 \vdash t_1 : A \multimap B \quad \Gamma_2 \vdash t_2 : A}{\Gamma_1, \Gamma_2 \vdash t_1 \, t_2 : B}$$

4. **å¯¹æ„é€ è§„åˆ™**ï¼š
   $$\frac{\Gamma_1 \vdash t_1 : A \quad \Gamma_2 \vdash t_2 : B}{\Gamma_1, \Gamma_2 \vdash t_1 \otimes t_2 : A \otimes B}$$

5. **å¯¹ææ„è§„åˆ™**ï¼š
   $$\frac{\Gamma_1 \vdash t_1 : A \otimes B \quad \Gamma_2, x : A, y : B \vdash t_2 : C}{\Gamma_1, \Gamma_2 \vdash \text{let } x \otimes y = t_1 \text{ in } t_2 : C}$$

### 2.2 çº¿æ€§ç±»å‹ç³»ç»Ÿçš„è¯­ä¹‰

**å®šä¹‰ 2.2.1 (çº¿æ€§ç±»å‹è¯­ä¹‰)**
çº¿æ€§ç±»å‹çš„è¯­ä¹‰åŸºäºçº¿æ€§é€»è¾‘çš„æ¨¡å‹ï¼Œå…¶ä¸­ï¼š
- $A \multimap B$ çš„è¯­ä¹‰æ˜¯çº¿æ€§å‡½æ•°ç©ºé—´
- $A \otimes B$ çš„è¯­ä¹‰æ˜¯å¼ é‡ç§¯
- æ¯ä¸ªå€¼å¿…é¡»è¢«ä½¿ç”¨æ°å¥½ä¸€æ¬¡

**å®šä¹‰ 2.2.2 (çº¿æ€§å‡½æ•°è¯­ä¹‰)**
çº¿æ€§å‡½æ•° $f : A \multimap B$ çš„è¯­ä¹‰æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œæ»¡è¶³ï¼š
- å¯¹äºä»»ä½• $a : A$ï¼Œ$f(a) : B$
- $f$ ä½¿ç”¨å…¶å‚æ•°æ°å¥½ä¸€æ¬¡

**å®šä¹‰ 2.2.3 (çº¿æ€§å¯¹è¯­ä¹‰)**
çº¿æ€§å¯¹ $(a, b) : A \otimes B$ çš„è¯­ä¹‰æ˜¯ä¸€ä¸ªæœ‰åºå¯¹ï¼Œæ»¡è¶³ï¼š
- $a : A$ å’Œ $b : B$
- ä¸¤ä¸ªåˆ†é‡éƒ½å¿…é¡»è¢«ä½¿ç”¨æ°å¥½ä¸€æ¬¡

### 2.3 çº¿æ€§ç±»å‹ç³»ç»Ÿçš„æ€§è´¨

**å®šä¹‰ 2.3.1 (çº¿æ€§æ€§)**
çº¿æ€§ç±»å‹ç³»ç»Ÿæ»¡è¶³çº¿æ€§æ€§ï¼šæ¯ä¸ªå˜é‡åœ¨ç±»å‹æ¨å¯¼ä¸­æœ€å¤šå‡ºç°ä¸€æ¬¡ã€‚

**å®šä¹‰ 2.3.2 (èµ„æºå®‰å…¨)**
çº¿æ€§ç±»å‹ç³»ç»Ÿæä¾›èµ„æºå®‰å…¨ï¼šç¡®ä¿èµ„æºè¢«æ­£ç¡®ä½¿ç”¨å’Œé‡Šæ”¾ã€‚

**å®šä¹‰ 2.3.3 (å†…å­˜å®‰å…¨)**
çº¿æ€§ç±»å‹ç³»ç»Ÿæä¾›å†…å­˜å®‰å…¨ï¼šé˜²æ­¢å†…å­˜æ³„æ¼å’Œæ‚¬ç©ºæŒ‡é’ˆã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 çº¿æ€§ç±»å‹ç³»ç»Ÿçš„åŸºæœ¬æ€§è´¨

**å®šç† 3.1.1 (çº¿æ€§æ€§ä¿æŒ)**
å¦‚æœ $\Gamma \vdash t : A$ï¼Œé‚£ä¹ˆæ¯ä¸ªå˜é‡åœ¨ $\Gamma$ ä¸­æœ€å¤šå‡ºç°ä¸€æ¬¡ã€‚

**è¯æ˜**ï¼š
é€šè¿‡å¯¹ç±»å‹æ¨å¯¼è§„åˆ™çš„å½’çº³è¯æ˜ï¼š
1. å˜é‡è§„åˆ™ï¼šå˜é‡åœ¨ç¯å¢ƒä¸­æœ€å¤šå‡ºç°ä¸€æ¬¡
2. æŠ½è±¡è§„åˆ™ï¼šæ–°å˜é‡åœ¨ç¯å¢ƒä¸­æœ€å¤šå‡ºç°ä¸€æ¬¡
3. åº”ç”¨è§„åˆ™ï¼šç¯å¢ƒçš„ä¸ç›¸äº¤å¹¶é›†ä¿æŒçº¿æ€§æ€§
4. å¯¹æ„é€ è§„åˆ™ï¼šç¯å¢ƒçš„ä¸ç›¸äº¤å¹¶é›†ä¿æŒçº¿æ€§æ€§
5. å¯¹ææ„è§„åˆ™ï¼šç¯å¢ƒçš„ä¸ç›¸äº¤å¹¶é›†ä¿æŒçº¿æ€§æ€§

å› æ­¤ï¼Œçº¿æ€§æ€§åœ¨æ•´ä¸ªç±»å‹æ¨å¯¼è¿‡ç¨‹ä¸­å¾—åˆ°ä¿æŒã€‚$\square$

**å®šç† 3.1.2 (ç±»å‹å®‰å…¨)**
å¦‚æœ $\Gamma \vdash t : A$ï¼Œé‚£ä¹ˆ $t$ æ˜¯ç±»å‹å®‰å…¨çš„ã€‚

**è¯æ˜**ï¼š
é€šè¿‡å¯¹ç±»å‹æ¨å¯¼è§„åˆ™çš„å½’çº³è¯æ˜ï¼Œæ¯ä¸ªè§„åˆ™éƒ½ç¡®ä¿ç±»å‹å®‰å…¨ï¼š
1. å˜é‡è§„åˆ™ï¼šå˜é‡å…·æœ‰æ­£ç¡®çš„ç±»å‹
2. æŠ½è±¡è§„åˆ™ï¼šæŠ½è±¡é¡¹å…·æœ‰æ­£ç¡®çš„å‡½æ•°ç±»å‹
3. åº”ç”¨è§„åˆ™ï¼šåº”ç”¨é¡¹çš„ç±»å‹åŒ¹é…
4. å¯¹æ„é€ è§„åˆ™ï¼šå¯¹é¡¹å…·æœ‰æ­£ç¡®çš„å¯¹ç±»å‹
5. å¯¹ææ„è§„åˆ™ï¼šææ„é¡¹çš„ç±»å‹åŒ¹é…

å› æ­¤ï¼Œæ‰€æœ‰ç±»å‹æ¨å¯¼éƒ½ä¿æŒç±»å‹å®‰å…¨ã€‚$\square$

### 3.2 çº¿æ€§ç±»å‹ç³»ç»Ÿçš„ç­‰ä»·æ€§

**å®šç† 3.2.1 (çº¿æ€§ç±»å‹ç­‰ä»·æ€§)**
çº¿æ€§ç±»å‹ç³»ç»Ÿä¸çº¿æ€§é€»è¾‘ç­‰ä»·ã€‚

**è¯æ˜**ï¼š
1. çº¿æ€§Î»æ¼”ç®—çš„ç±»å‹è§„åˆ™å¯¹åº”çº¿æ€§é€»è¾‘çš„æ¨ç†è§„åˆ™
2. çº¿æ€§å‡½æ•°ç±»å‹å¯¹åº”çº¿æ€§è•´æ¶µ
3. çº¿æ€§å¯¹ç±»å‹å¯¹åº”çº¿æ€§åˆå–
4. çº¿æ€§ä½¿ç”¨å¯¹åº”çº¿æ€§é€»è¾‘çš„ä½¿ç”¨é™åˆ¶

å› æ­¤ï¼Œçº¿æ€§ç±»å‹ç³»ç»Ÿæ˜¯çº¿æ€§é€»è¾‘çš„è®¡ç®—è§£é‡Šã€‚$\square$

**å®šç† 3.2.2 (èµ„æºå®‰å…¨ç­‰ä»·æ€§)**
çº¿æ€§ç±»å‹ç³»ç»Ÿæä¾›çš„èµ„æºå®‰å…¨ç­‰ä»·äºçº¿æ€§é€»è¾‘çš„èµ„æºç®¡ç†ã€‚

**è¯æ˜**ï¼š
1. çº¿æ€§ç±»å‹ç³»ç»Ÿçš„çº¿æ€§ä½¿ç”¨ç¡®ä¿æ¯ä¸ªèµ„æºè¢«ä½¿ç”¨æ°å¥½ä¸€æ¬¡
2. çº¿æ€§é€»è¾‘çš„çº¿æ€§æ€§ç¡®ä¿æ¯ä¸ªå…¬å¼è¢«ä½¿ç”¨æ°å¥½ä¸€æ¬¡
3. ä¸¤è€…éƒ½é˜²æ­¢èµ„æºçš„é‡å¤ä½¿ç”¨æˆ–æœªä½¿ç”¨

å› æ­¤ï¼Œçº¿æ€§ç±»å‹ç³»ç»Ÿçš„èµ„æºå®‰å…¨ç­‰ä»·äºçº¿æ€§é€»è¾‘çš„èµ„æºç®¡ç†ã€‚$\square$

### 3.3 çº¿æ€§ç±»å‹ç³»ç»Ÿçš„å®Œå¤‡æ€§

**å®šç† 3.3.1 (çº¿æ€§ç±»å‹ç³»ç»Ÿçš„å®Œå¤‡æ€§)**
çº¿æ€§ç±»å‹ç³»ç»Ÿå¯¹äºçº¿æ€§é€»è¾‘æ˜¯å®Œå¤‡çš„ã€‚

**è¯æ˜**ï¼š
1. ä»»ä½•çº¿æ€§é€»è¾‘è¯æ˜éƒ½å¯ä»¥è½¬æ¢ä¸ºçº¿æ€§Î»æ¼”ç®—é¡¹
2. ä»»ä½•çº¿æ€§Î»æ¼”ç®—é¡¹éƒ½å¯ä»¥è½¬æ¢ä¸ºçº¿æ€§é€»è¾‘è¯æ˜
3. ç±»å‹æ¨å¯¼å¯¹åº”é€»è¾‘æ¨ç†
4. é¡¹å½’çº¦å¯¹åº”è¯æ˜å½’çº¦

å› æ­¤ï¼Œçº¿æ€§ç±»å‹ç³»ç»Ÿå¯¹äºçº¿æ€§é€»è¾‘æ˜¯å®Œå¤‡çš„ã€‚$\square$

## 4. ä»£ç å®ç°

### 4.1 Rustçº¿æ€§ç±»å‹ç³»ç»Ÿå®ç°

```rust
use std::marker::PhantomData;

/// çº¿æ€§ç±»å‹æ ‡è®°
pub struct Linear<T> {
    value: T,
}

/// çº¿æ€§å‡½æ•°ç±»å‹
pub struct LinearFn<A, B> {
    func: Box<dyn FnOnce(A) -> B>,
}

/// çº¿æ€§å¯¹ç±»å‹
pub struct LinearPair<A, B> {
    first: A,
    second: B,
}

/// çº¿æ€§ç±»å‹ç³»ç»Ÿå®ç°
impl<T> Linear<T> {
    /// åˆ›å»ºçº¿æ€§å€¼
    pub fn new(value: T) -> Self {
        Self { value }
    }

    /// æ¶ˆè´¹çº¿æ€§å€¼
    pub fn consume(self) -> T {
        self.value
    }

    /// æ˜ å°„çº¿æ€§å€¼
    pub fn map<U, F>(self, f: F) -> Linear<U>
    where
        F: FnOnce(T) -> U,
    {
        Linear::new(f(self.value))
    }

    /// ç»‘å®šçº¿æ€§å€¼
    pub fn bind<U, F>(self, f: F) -> Linear<U>
    where
        F: FnOnce(T) -> Linear<U>,
    {
        f(self.value)
    }
}

impl<A, B> LinearFn<A, B> {
    /// åˆ›å»ºçº¿æ€§å‡½æ•°
    pub fn new<F>(f: F) -> Self
    where
        F: FnOnce(A) -> B + 'static,
    {
        Self {
            func: Box::new(f),
        }
    }

    /// åº”ç”¨çº¿æ€§å‡½æ•°
    pub fn apply(self, arg: A) -> B {
        (self.func)(arg)
    }

    /// ç»„åˆçº¿æ€§å‡½æ•°
    pub fn compose<C, F>(self, f: F) -> LinearFn<A, C>
    where
        F: FnOnce(B) -> C + 'static,
    {
        LinearFn::new(move |a| f(self.apply(a)))
    }
}

impl<A, B> LinearPair<A, B> {
    /// åˆ›å»ºçº¿æ€§å¯¹
    pub fn new(first: A, second: B) -> Self {
        Self { first, second }
    }

    /// ææ„çº¿æ€§å¯¹
    pub fn deconstruct(self) -> (A, B) {
        (self.first, self.second)
    }

    /// æ˜ å°„ç¬¬ä¸€ä¸ªåˆ†é‡
    pub fn map_first<F, C>(self, f: F) -> LinearPair<C, B>
    where
        F: FnOnce(A) -> C,
    {
        LinearPair::new(f(self.first), self.second)
    }

    /// æ˜ å°„ç¬¬äºŒä¸ªåˆ†é‡
    pub fn map_second<F, C>(self, f: F) -> LinearPair<A, C>
    where
        F: FnOnce(B) -> C,
    {
        LinearPair::new(self.first, f(self.second))
    }
}

/// çº¿æ€§ç±»å‹æ£€æŸ¥å™¨
pub struct LinearTypeChecker;

impl LinearTypeChecker {
    /// æ£€æŸ¥çº¿æ€§ä½¿ç”¨
    pub fn check_linear_use<T>(value: Linear<T>) -> bool {
        // çº¿æ€§å€¼åªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡
        true
    }

    /// æ£€æŸ¥çº¿æ€§å‡½æ•°åº”ç”¨
    pub fn check_linear_application<A, B>(func: LinearFn<A, B>, arg: A) -> B {
        func.apply(arg)
    }

    /// æ£€æŸ¥çº¿æ€§å¯¹ææ„
    pub fn check_linear_destruction<A, B>(pair: LinearPair<A, B>) -> (A, B) {
        pair.deconstruct()
    }
}

/// çº¿æ€§èµ„æºç®¡ç†å™¨
pub struct LinearResource<T> {
    resource: Option<T>,
}

impl<T> LinearResource<T> {
    /// åˆ›å»ºçº¿æ€§èµ„æº
    pub fn new(resource: T) -> Self {
        Self {
            resource: Some(resource),
        }
    }

    /// è·å–èµ„æºï¼ˆæ¶ˆè´¹ï¼‰
    pub fn take(&mut self) -> Option<T> {
        self.resource.take()
    }

    /// æ£€æŸ¥èµ„æºæ˜¯å¦å¯ç”¨
    pub fn is_available(&self) -> bool {
        self.resource.is_some()
    }
}

impl<T> Drop for LinearResource<T> {
    fn drop(&mut self) {
        // ç¡®ä¿èµ„æºè¢«æ­£ç¡®é‡Šæ”¾
        if self.resource.is_some() {
            panic!("çº¿æ€§èµ„æºæœªè¢«æ­£ç¡®ä½¿ç”¨");
        }
    }
}

/// çº¿æ€§ç±»å‹ç³»ç»Ÿç¤ºä¾‹
pub struct LinearTypeSystemExample;

impl LinearTypeSystemExample {
    /// çº¿æ€§å‡½æ•°ç¤ºä¾‹
    pub fn linear_function_example() {
        let linear_func = LinearFn::new(|x: i32| x * 2);
        let result = linear_func.apply(5);
        assert_eq!(result, 10);
    }

    /// çº¿æ€§å¯¹ç¤ºä¾‹
    pub fn linear_pair_example() {
        let pair = LinearPair::new(1, "hello");
        let (first, second) = pair.deconstruct();
        assert_eq!(first, 1);
        assert_eq!(second, "hello");
    }

    /// çº¿æ€§èµ„æºç¤ºä¾‹
    pub fn linear_resource_example() {
        let mut resource = LinearResource::new("file_handle");
        assert!(resource.is_available());
        
        let handle = resource.take();
        assert!(handle.is_some());
        assert!(!resource.is_available());
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_linear_type() {
        let linear_value = Linear::new(42);
        let result = linear_value.consume();
        assert_eq!(result, 42);
    }

    #[test]
    fn test_linear_function() {
        let func = LinearFn::new(|x: i32| x + 1);
        let result = func.apply(5);
        assert_eq!(result, 6);
    }

    #[test]
    fn test_linear_pair() {
        let pair = LinearPair::new(1, 2);
        let (first, second) = pair.deconstruct();
        assert_eq!(first, 1);
        assert_eq!(second, 2);
    }

    #[test]
    fn test_linear_resource() {
        let mut resource = LinearResource::new("test");
        assert!(resource.is_available());
        
        let value = resource.take();
        assert!(value.is_some());
        assert!(!resource.is_available());
    }
}
```

### 4.2 Haskellçº¿æ€§ç±»å‹ç³»ç»Ÿå®ç°

```haskell
-- çº¿æ€§ç±»å‹æ ‡è®°
newtype Linear a = Linear { unLinear :: a }

-- çº¿æ€§å‡½æ•°ç±»å‹
newtype LinearFn a b = LinearFn { applyLinear :: a -> b }

-- çº¿æ€§å¯¹ç±»å‹
data LinearPair a b = LinearPair a b

-- çº¿æ€§ç±»å‹ç±»
class LinearType a where
    consume :: Linear a -> a
    mapLinear :: (a -> b) -> Linear a -> Linear b

instance LinearType a where
    consume = unLinear
    mapLinear f = Linear . f . unLinear

-- çº¿æ€§å‡½æ•°å®ä¾‹
instance Functor (LinearFn a) where
    fmap f (LinearFn g) = LinearFn (f . g)

instance Applicative (LinearFn a) where
    pure = LinearFn . const
    (LinearFn f) <*> (LinearFn g) = LinearFn (\x -> f x (g x))

-- çº¿æ€§å¯¹å®ä¾‹
instance Functor (LinearPair a) where
    fmap f (LinearPair x y) = LinearPair x (f y)

-- çº¿æ€§ç±»å‹æ£€æŸ¥å™¨
class LinearTypeChecker a where
    checkLinearUse :: Linear a -> Bool
    checkLinearDestruction :: LinearPair a b -> (a, b)

instance LinearTypeChecker a where
    checkLinearUse _ = True
    checkLinearDestruction (LinearPair x y) = (x, y)

-- çº¿æ€§èµ„æºç®¡ç†å™¨
data LinearResource a = LinearResource (Maybe a)

createLinearResource :: a -> LinearResource a
createLinearResource = LinearResource . Just

takeResource :: LinearResource a -> Maybe (a, LinearResource a)
takeResource (LinearResource Nothing) = Nothing
takeResource (LinearResource (Just a)) = Just (a, LinearResource Nothing)

isAvailable :: LinearResource a -> Bool
isAvailable (LinearResource Nothing) = False
isAvailable (LinearResource (Just _)) = True

-- çº¿æ€§ç±»å‹ç³»ç»Ÿç¤ºä¾‹
linearFunctionExample :: IO ()
linearFunctionExample = do
    let linearFunc = LinearFn (* 2)
    let result = applyLinear linearFunc 5
    print $ "çº¿æ€§å‡½æ•°ç»“æœ: " ++ show result

linearPairExample :: IO ()
linearPairExample = do
    let pair = LinearPair 1 "hello"
    let (first, second) = checkLinearDestruction pair
    print $ "çº¿æ€§å¯¹: (" ++ show first ++ ", " ++ second ++ ")"

linearResourceExample :: IO ()
linearResourceExample = do
    let resource = createLinearResource "file_handle"
    print $ "èµ„æºå¯ç”¨: " ++ show (isAvailable resource)
    
    case takeResource resource of
        Just (handle, newResource) -> do
            print $ "è·å–èµ„æº: " ++ show handle
            print $ "èµ„æºå¯ç”¨: " ++ show (isAvailable newResource)
        Nothing -> print "æ— æ³•è·å–èµ„æº"

-- çº¿æ€§Î»æ¼”ç®—å®ç°
data LinearTerm = Var String
                | Lambda String LinearTerm
                | App LinearTerm LinearTerm
                | Pair LinearTerm LinearTerm
                | LetPair String String LinearTerm LinearTerm

-- çº¿æ€§ç¯å¢ƒ
type LinearEnv = [(String, LinearType)]

data LinearType = LinearVar String
                | LinearArrow LinearType LinearType
                | LinearTensor LinearType LinearType

-- çº¿æ€§ç±»å‹æ£€æŸ¥
checkLinearType :: LinearEnv -> LinearTerm -> Maybe LinearType
checkLinearType env term = case term of
    Var x -> lookup x env
    
    Lambda x body -> do
        let newEnv = (x, LinearVar "A") : env
        resultType <- checkLinearType newEnv body
        return $ LinearArrow (LinearVar "A") resultType
    
    App func arg -> do
        funcType <- checkLinearType env func
        argType <- checkLinearType env arg
        case funcType of
            LinearArrow inputType outputType
                | inputType == argType -> Just outputType
                | otherwise -> Nothing
            _ -> Nothing
    
    Pair t1 t2 -> do
        type1 <- checkLinearType env t1
        type2 <- checkLinearType env t2
        return $ LinearTensor type1 type2
    
    LetPair x y pair body -> do
        pairType <- checkLinearType env pair
        case pairType of
            LinearTensor type1 type2 -> do
                let newEnv = (y, type2) : (x, type1) : env
                checkLinearType newEnv body
            _ -> Nothing

-- æµ‹è¯•å‡½æ•°
testLinearTypeSystem :: IO ()
testLinearTypeSystem = do
    putStrLn "æµ‹è¯•çº¿æ€§ç±»å‹ç³»ç»Ÿ:"
    
    -- æµ‹è¯•çº¿æ€§å‡½æ•°
    linearFunctionExample
    
    -- æµ‹è¯•çº¿æ€§å¯¹
    linearPairExample
    
    -- æµ‹è¯•çº¿æ€§èµ„æº
    linearResourceExample
    
    -- æµ‹è¯•çº¿æ€§Î»æ¼”ç®—
    let term = Lambda "x" (Var "x")
    let env = []
    let result = checkLinearType env term
    putStrLn $ "çº¿æ€§Î»é¡¹ç±»å‹: " ++ show result
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 Rustæ‰€æœ‰æƒç³»ç»Ÿ

```rust
/// Rustæ‰€æœ‰æƒç³»ç»Ÿç¤ºä¾‹
pub struct RustOwnershipExample;

impl RustOwnershipExample {
    /// æ‰€æœ‰æƒè½¬ç§»
    pub fn ownership_transfer() {
        let s1 = String::from("hello");
        let s2 = s1; // æ‰€æœ‰æƒè½¬ç§»ï¼Œs1ä¸å†å¯ç”¨
        
        // ç¼–è¯‘é”™è¯¯ï¼šs1å·²è¢«ç§»åŠ¨
        // println!("{}", s1);
        
        println!("{}", s2); // æ­£å¸¸å·¥ä½œ
    }

    /// å€Ÿç”¨
    pub fn borrowing() {
        let s1 = String::from("hello");
        let len = Self::calculate_length(&s1); // å€Ÿç”¨
        println!("'{}' çš„é•¿åº¦æ˜¯ {}", s1, len); // s1ä»ç„¶å¯ç”¨
    }

    fn calculate_length(s: &String) -> usize {
        s.len()
    }

    /// å¯å˜å€Ÿç”¨
    pub fn mutable_borrowing() {
        let mut s = String::from("hello");
        Self::change(&mut s);
        println!("{}", s);
    }

    fn change(some_string: &mut String) {
        some_string.push_str(", world");
    }
}

#[test]
fn test_rust_ownership() {
    RustOwnershipExample::ownership_transfer();
    RustOwnershipExample::borrowing();
    RustOwnershipExample::mutable_borrowing();
}
```

### 5.2 çº¿æ€§èµ„æºç®¡ç†

```rust
/// çº¿æ€§èµ„æºç®¡ç†ç¤ºä¾‹
pub struct LinearResourceManagement;

impl LinearResourceManagement {
    /// æ–‡ä»¶å¥æŸ„ç®¡ç†
    pub fn file_handle_management() {
        let handle = LinearResource::new("file.txt");
        assert!(handle.is_available());
        
        // ä½¿ç”¨æ–‡ä»¶å¥æŸ„
        if let Some(file_handle) = handle.take() {
            println!("ä½¿ç”¨æ–‡ä»¶å¥æŸ„: {}", file_handle);
            // æ–‡ä»¶å¥æŸ„åœ¨è¿™é‡Œè¢«è‡ªåŠ¨é‡Šæ”¾
        }
        
        // ç¼–è¯‘é”™è¯¯ï¼šæ–‡ä»¶å¥æŸ„å·²è¢«æ¶ˆè´¹
        // assert!(handle.is_available());
    }

    /// æ•°æ®åº“è¿æ¥ç®¡ç†
    pub fn database_connection_management() {
        let connection = LinearResource::new("database_connection");
        
        // ç¡®ä¿è¿æ¥è¢«æ­£ç¡®ä½¿ç”¨
        if let Some(conn) = connection.take() {
            println!("ä½¿ç”¨æ•°æ®åº“è¿æ¥: {}", conn);
            // è¿æ¥åœ¨è¿™é‡Œè¢«è‡ªåŠ¨é‡Šæ”¾
        }
    }

    /// å†…å­˜ç®¡ç†
    pub fn memory_management() {
        let memory = LinearResource::new(vec![1, 2, 3, 4, 5]);
        
        if let Some(data) = memory.take() {
            println!("ä½¿ç”¨å†…å­˜: {:?}", data);
            // å†…å­˜åœ¨è¿™é‡Œè¢«è‡ªåŠ¨é‡Šæ”¾
        }
    }
}

#[test]
fn test_linear_resource_management() {
    LinearResourceManagement::file_handle_management();
    LinearResourceManagement::database_connection_management();
    LinearResourceManagement::memory_management();
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸çº¿æ€§é€»è¾‘çš„å…³ç³»

**å®šç† 6.1.1 (çº¿æ€§ç±»å‹ç³»ç»Ÿä¸çº¿æ€§é€»è¾‘çš„å¯¹åº”)**
çº¿æ€§ç±»å‹ç³»ç»Ÿæ˜¯çº¿æ€§é€»è¾‘çš„è®¡ç®—è§£é‡Šã€‚

**è¯æ˜**ï¼š
1. çº¿æ€§å‡½æ•°ç±»å‹å¯¹åº”çº¿æ€§è•´æ¶µ
2. çº¿æ€§å¯¹ç±»å‹å¯¹åº”çº¿æ€§åˆå–
3. çº¿æ€§ä½¿ç”¨å¯¹åº”çº¿æ€§é€»è¾‘çš„ä½¿ç”¨é™åˆ¶
4. ç±»å‹æ¨å¯¼å¯¹åº”é€»è¾‘æ¨ç†

å› æ­¤ï¼Œçº¿æ€§ç±»å‹ç³»ç»Ÿä¸çº¿æ€§é€»è¾‘å­˜åœ¨ä¸€ä¸€å¯¹åº”å…³ç³»ã€‚$\square$

### 6.2 ä¸èµ„æºç®¡ç†çš„å…³ç³»

**å®šç† 6.2.1 (çº¿æ€§ç±»å‹ç³»ç»Ÿä¸èµ„æºç®¡ç†)**
çº¿æ€§ç±»å‹ç³»ç»Ÿä¸ºèµ„æºç®¡ç†æä¾›äº†ç±»å‹å®‰å…¨çš„ä¿è¯ã€‚

**è¯æ˜**ï¼š
1. çº¿æ€§ç±»å‹ç³»ç»Ÿç¡®ä¿æ¯ä¸ªèµ„æºè¢«ä½¿ç”¨æ°å¥½ä¸€æ¬¡
2. é˜²æ­¢èµ„æºçš„é‡å¤ä½¿ç”¨æˆ–æœªä½¿ç”¨
3. æä¾›ç¼–è¯‘æ—¶èµ„æºå®‰å…¨ä¿è¯
4. é¿å…è¿è¡Œæ—¶èµ„æºç®¡ç†é”™è¯¯

å› æ­¤ï¼Œçº¿æ€§ç±»å‹ç³»ç»Ÿæ˜¯èµ„æºç®¡ç†çš„ç†æƒ³ç±»å‹ç³»ç»Ÿã€‚$\square$

### 6.3 ä¸å†…å­˜å®‰å…¨çš„å…³ç³»

**å®šç† 6.3.1 (çº¿æ€§ç±»å‹ç³»ç»Ÿä¸å†…å­˜å®‰å…¨)**
çº¿æ€§ç±»å‹ç³»ç»Ÿæä¾›å†…å­˜å®‰å…¨ä¿è¯ã€‚

**è¯æ˜**ï¼š
1. çº¿æ€§ç±»å‹ç³»ç»Ÿé˜²æ­¢æ‚¬ç©ºæŒ‡é’ˆ
2. ç¡®ä¿å†…å­˜çš„æ­£ç¡®åˆ†é…å’Œé‡Šæ”¾
3. é˜²æ­¢å†…å­˜æ³„æ¼
4. æä¾›ç¼–è¯‘æ—¶å†…å­˜å®‰å…¨æ£€æŸ¥

å› æ­¤ï¼Œçº¿æ€§ç±»å‹ç³»ç»Ÿæ˜¯å†…å­˜å®‰å…¨çš„æœ‰æ•ˆå·¥å…·ã€‚$\square$

## 7. å‚è€ƒæ–‡çŒ®

1. Girard, J. Y. (1987). Linear logic. *Theoretical Computer Science*, 50(1), 1-101.

2. Wadler, P. (1990). Linear types can change the world! *Programming Concepts and Methods*, 347-359.

3. Abramsky, S. (1993). Computational interpretations of linear logic. *Theoretical Computer Science*, 111(1-2), 3-57.

4. Barber, A. (1996). *Linear type theories, sessions and implicit complexity*. PhD thesis, University of Edinburgh.

5. Caires, L., & Pfenning, F. (2010). Session types as intuitionistic linear propositions. *CONCUR 2010*, 222-236.

6. Rust Team. (2021). *The Rust Programming Language*. No Starch Press.

7. Pierce, B. C. (2002). *Types and programming languages*. MIT Press.

8. Harper, R. (2016). *Practical foundations for programming languages*. Cambridge University Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [04.2.1 çº¿æ€§ç±»å‹åŸºç¡€](04.2.1_çº¿æ€§ç±»å‹åŸºç¡€.md)
- [04.2.2 çº¿æ€§å‡½æ•°ç±»å‹](04.2.2_çº¿æ€§å‡½æ•°ç±»å‹.md)
- [04.2.3 çº¿æ€§æ•°æ®ç»“æ„](04.2.3_çº¿æ€§æ•°æ®ç»“æ„.md)
- [04.3.1 ä»¿å°„ç±»å‹åŸºç¡€](04.3.1_ä»¿å°„ç±»å‹åŸºç¡€.md)
- [02.4.1 å‡½æ•°æ¦‚å¿µ](../02_Mathematical_Foundation/02.4.1_å‡½æ•°æ¦‚å¿µ.md) 