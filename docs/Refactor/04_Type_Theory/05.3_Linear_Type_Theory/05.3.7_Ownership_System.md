# 04.3.2 æ‰€æœ‰æƒç³»ç»Ÿ

## ğŸ“‹ æ¦‚è¿°

æ‰€æœ‰æƒç³»ç»Ÿæ˜¯ä»¿å°„ç±»å‹ç†è®ºåœ¨ç¼–ç¨‹è¯­è¨€ä¸­çš„å®é™…åº”ç”¨ï¼Œä»¥Rustè¯­è¨€ä¸ºä»£è¡¨ã€‚æœ¬æ–‡æ¡£å»ºç«‹ä¸¥æ ¼çš„æ‰€æœ‰æƒç³»ç»Ÿç†è®ºæ¡†æ¶ï¼ŒåŒ…å«æ‰€æœ‰æƒæ¨¡å‹ã€å€Ÿç”¨æ£€æŸ¥ã€ç”Ÿå‘½å‘¨æœŸã€å†…å­˜å®‰å…¨ç­‰å†…å®¹ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹æ‰€æœ‰æƒç³»ç»Ÿçš„åŸºæœ¬æ¦‚å¿µå’Œå½¢å¼åŒ–å®šä¹‰
2. åˆ†ææ‰€æœ‰æƒæ¨¡å‹ä¸ä»¿å°„ç±»å‹çš„å…³ç³»
3. ç ”ç©¶å€Ÿç”¨æ£€æŸ¥å™¨çš„è®¾è®¡åŸç†
4. æä¾›å†…å­˜å®‰å…¨çš„å½¢å¼åŒ–ä¿è¯

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ‰€æœ‰æƒåŸºç¡€

**å®šä¹‰ 1.1.1** (æ‰€æœ‰æƒ)
æ‰€æœ‰æƒæ˜¯Rustå†…å­˜ç®¡ç†çš„æ ¸å¿ƒæ¦‚å¿µï¼Œæ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œæ‰€æœ‰è€…è´Ÿè´£å€¼çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚

**å®šä¹‰ 1.1.2** (æ‰€æœ‰æƒè§„åˆ™)
Rustçš„æ‰€æœ‰æƒè§„åˆ™åŒ…æ‹¬ï¼š

1. æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
2. åŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
3. å½“æ‰€æœ‰è€…ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå€¼è¢«ä¸¢å¼ƒ

**å®šä¹‰ 1.1.3** (å€Ÿç”¨)
å€Ÿç”¨æ˜¯ä¸´æ—¶è·å–å€¼çš„å¼•ç”¨è€Œä¸è·å–æ‰€æœ‰æƒï¼ŒåŒ…æ‹¬ï¼š

- ä¸å¯å˜å€Ÿç”¨ï¼š`&T`
- å¯å˜å€Ÿç”¨ï¼š`&mut T`

### 1.2 æ‰€æœ‰æƒç³»ç»Ÿçš„åŸºæœ¬ç‰¹å¾

**å®šä¹‰ 1.2.1** (ä»¿å°„ç±»å‹)
æ‰€æœ‰æƒç³»ç»ŸåŸºäºä»¿å°„ç±»å‹ï¼Œæ¯ä¸ªå€¼æœ€å¤šåªèƒ½ä½¿ç”¨ä¸€æ¬¡ï¼š
$$T \otimes T \not\vdash T$$

**å®šä¹‰ 1.2.2** (å€Ÿç”¨è§„åˆ™)
å€Ÿç”¨å¿…é¡»éµå¾ªä»¥ä¸‹è§„åˆ™ï¼š

- ä¸å¯å˜å€Ÿç”¨å¯ä»¥æœ‰å¤šä¸ª
- å¯å˜å€Ÿç”¨åªèƒ½æœ‰ä¸€ä¸ª
- ä¸å¯å˜å€Ÿç”¨å’Œå¯å˜å€Ÿç”¨ä¸èƒ½åŒæ—¶å­˜åœ¨

**å®šä¹‰ 1.2.3** (ç”Ÿå‘½å‘¨æœŸ)
ç”Ÿå‘½å‘¨æœŸæ˜¯å¼•ç”¨æœ‰æ•ˆæ€§çš„é™æ€ä¿è¯ï¼Œç¡®ä¿å¼•ç”¨ä¸ä¼šæŒ‡å‘å·²é‡Šæ”¾çš„å†…å­˜ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ‰€æœ‰æƒç±»å‹ç³»ç»Ÿ

**å®šä¹‰ 2.1.1** (æ‰€æœ‰æƒç±»å‹)
æ‰€æœ‰æƒç±»å‹ç³»ç»Ÿ $\mathcal{O}$ åŒ…å«ä»¥ä¸‹ç±»å‹ï¼š

- å€¼ç±»å‹ï¼š$T$
- ä¸å¯å˜å¼•ç”¨ç±»å‹ï¼š$&T$
- å¯å˜å¼•ç”¨ç±»å‹ï¼š$&mut T$
- æ‰€æœ‰æƒè½¬ç§»ç±»å‹ï¼š$T \rightarrow T$

**å®šä¹‰ 2.1.2** (æ‰€æœ‰æƒè§„åˆ™)
æ‰€æœ‰æƒè§„åˆ™çš„å½¢å¼åŒ–å®šä¹‰ï¼š
$$\frac{\Gamma \vdash e : T}{\Gamma, x : T \vdash x : T} \text{ (Owner)}$$
$$\frac{\Gamma \vdash e : T}{\Gamma \vdash \&e : \&T} \text{ (Immutable Borrow)}$$
$$\frac{\Gamma \vdash e : T}{\Gamma \vdash \&mut e : \&mut T} \text{ (Mutable Borrow)}$$

**å®šä¹‰ 2.1.3** (å€Ÿç”¨æ£€æŸ¥è§„åˆ™)
å€Ÿç”¨æ£€æŸ¥è§„åˆ™ï¼š
$$\frac{\Gamma \vdash e_1 : \&T \quad \Gamma \vdash e_2 : \&T}{\Gamma \vdash e_1, e_2 : \&T \times \&T} \text{ (Multiple Immutable)}$$
$$\frac{\Gamma \vdash e : \&mut T}{\Gamma \vdash e : \&mut T} \text{ (Single Mutable)}$$

### 2.2 ç”Ÿå‘½å‘¨æœŸç³»ç»Ÿ

**å®šä¹‰ 2.2.1** (ç”Ÿå‘½å‘¨æœŸå‚æ•°)
ç”Ÿå‘½å‘¨æœŸå‚æ•° $\alpha$ è¡¨ç¤ºå¼•ç”¨çš„æœ‰æ•ˆæœŸé—´ï¼š
$$&'a T \text{ è¡¨ç¤ºç”Ÿå‘½å‘¨æœŸä¸º } a \text{ çš„å¼•ç”¨}$$

**å®šä¹‰ 2.2.2** (ç”Ÿå‘½å‘¨æœŸçº¦æŸ)
ç”Ÿå‘½å‘¨æœŸçº¦æŸç¡®ä¿å¼•ç”¨çš„æœ‰æ•ˆæ€§ï¼š
$$\alpha \leq \beta \text{ è¡¨ç¤º } \alpha \text{ çš„ç”Ÿå‘½å‘¨æœŸåŒ…å«åœ¨ } \beta \text{ ä¸­}$$

**å®šä¹‰ 2.2.3** (ç”Ÿå‘½å‘¨æœŸæ¨æ–­)
ç”Ÿå‘½å‘¨æœŸæ¨æ–­ç®—æ³•è‡ªåŠ¨æ¨å¯¼ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼š
$$\text{infer}(\Gamma, e) = (\tau, C)$$
å…¶ä¸­ $\tau$ æ˜¯ç±»å‹ï¼Œ$C$ æ˜¯ç”Ÿå‘½å‘¨æœŸçº¦æŸé›†åˆã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 æ‰€æœ‰æƒç³»ç»ŸåŸºæœ¬å®šç†

**å®šç† 3.1.1** (å†…å­˜å®‰å…¨å®šç†)
æ‰€æœ‰æƒç³»ç»Ÿä¿è¯å†…å­˜å®‰å…¨ï¼Œä¸ä¼šå‡ºç°æ‚¬å‚æŒ‡é’ˆã€‚

**è¯æ˜**ï¼š
é€šè¿‡ç»“æ„å½’çº³æ³•è¯æ˜ï¼š

1. åŸºç¡€æƒ…å†µï¼šå­—é¢é‡å’Œå˜é‡ç›´æ¥æ»¡è¶³å†…å­˜å®‰å…¨
2. å¼•ç”¨åˆ›å»ºï¼šå€Ÿç”¨æ£€æŸ¥ç¡®ä¿å¼•ç”¨æœ‰æ•ˆ
3. æ‰€æœ‰æƒè½¬ç§»ï¼šè½¬ç§»ååŸæ‰€æœ‰è€…å¤±æ•ˆ
4. ä½œç”¨åŸŸç»“æŸï¼šè‡ªåŠ¨é‡Šæ”¾èµ„æº

**å®šç† 3.1.2** (æ•°æ®ç«äº‰è‡ªç”±å®šç†)
æ‰€æœ‰æƒç³»ç»Ÿä¿è¯æ•°æ®ç«äº‰è‡ªç”±ã€‚

**è¯æ˜**ï¼š
åŸºäºå€Ÿç”¨è§„åˆ™ï¼š

- ä¸å¯å˜å€Ÿç”¨å…è®¸å¤šä¸ªåŒæ—¶å­˜åœ¨ï¼Œä½†ä¸å…è®¸ä¿®æ”¹
- å¯å˜å€Ÿç”¨åªå…è®¸ä¸€ä¸ªå­˜åœ¨ï¼Œç¡®ä¿ç‹¬å è®¿é—®
- ä¸å¯å˜å’Œå¯å˜å€Ÿç”¨ä¸èƒ½åŒæ—¶å­˜åœ¨

### 3.2 ç±»å‹å®‰å…¨å®šç†

**å®šç† 3.2.1** (ç±»å‹ä¿æŒå®šç†)
å¦‚æœ $\Gamma \vdash e : T$ ä¸” $e \rightarrow e'$ï¼Œåˆ™ $\Gamma \vdash e' : T$ã€‚

**è¯æ˜**ï¼š
é€šè¿‡ç±»å‹æ¨å¯¼è§„åˆ™å’Œå½’çº¦è§„åˆ™çš„ä¸€è‡´æ€§è¯æ˜ã€‚

**å®šç† 3.2.2** (è¿›å±•å®šç†)
å¦‚æœ $\Gamma \vdash e : T$ ä¸” $e$ æ˜¯å°é—­é¡¹ï¼Œåˆ™ $e$ æ˜¯å€¼æˆ–å­˜åœ¨ $e'$ ä½¿å¾— $e \rightarrow e'$ã€‚

**è¯æ˜**ï¼š
é€šè¿‡ç»“æ„å½’çº³æ³•è¯æ˜æ‰€æœ‰ç±»å‹è‰¯å¥½çš„é¡¹è¦ä¹ˆæ˜¯å€¼ï¼Œè¦ä¹ˆå¯ä»¥ç»§ç»­å½’çº¦ã€‚

## 4. ä»£ç å®ç°

### 4.1 æ‰€æœ‰æƒç³»ç»ŸåŸºç¡€å®ç°

```rust
use std::collections::HashMap;

/// æ‰€æœ‰æƒçŠ¶æ€
#[derive(Debug, Clone, PartialEq)]
enum OwnershipState {
    Owned,      // æ‹¥æœ‰æ‰€æœ‰æƒ
    Borrowed,   // è¢«å€Ÿç”¨
    Moved,      // å·²è½¬ç§»
}

/// æ‰€æœ‰æƒè·Ÿè¸ªå™¨
#[derive(Debug)]
struct OwnershipTracker {
    variables: HashMap<String, OwnershipState>,
    borrows: HashMap<String, Vec<String>>, // å˜é‡ -> å€Ÿç”¨è€…åˆ—è¡¨
}

impl OwnershipTracker {
    /// åˆ›å»ºæ‰€æœ‰æƒè·Ÿè¸ªå™¨
    fn new() -> Self {
        OwnershipTracker {
            variables: HashMap::new(),
            borrows: HashMap::new(),
        }
    }
    
    /// å£°æ˜å˜é‡
    fn declare_variable(&mut self, name: String) -> Result<(), String> {
        if self.variables.contains_key(&name) {
            return Err(format!("å˜é‡ {} å·²å­˜åœ¨", name));
        }
        
        self.variables.insert(name.clone(), OwnershipState::Owned);
        self.borrows.insert(name, Vec::new());
        Ok(())
    }
    
    /// æ£€æŸ¥å˜é‡æ˜¯å¦å¯å€Ÿç”¨
    fn can_borrow(&self, name: &str, mutable: bool) -> Result<(), String> {
        match self.variables.get(name) {
            Some(OwnershipState::Owned) => {
                if mutable {
                    // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–å€Ÿç”¨
                    if let Some(borrowers) = self.borrows.get(name) {
                        if !borrowers.is_empty() {
                            return Err(format!("å˜é‡ {} å·²è¢«å€Ÿç”¨ï¼Œä¸èƒ½å¯å˜å€Ÿç”¨", name));
                        }
                    }
                }
                Ok(())
            },
            Some(OwnershipState::Borrowed) => {
                if mutable {
                    Err(format!("å˜é‡ {} å·²è¢«å€Ÿç”¨ï¼Œä¸èƒ½å¯å˜å€Ÿç”¨", name))
                } else {
                    Ok(())
                }
            },
            Some(OwnershipState::Moved) => {
                Err(format!("å˜é‡ {} å·²è¢«è½¬ç§»", name))
            },
            None => {
                Err(format!("å˜é‡ {} æœªå£°æ˜", name))
            }
        }
    }
    
    /// å€Ÿç”¨å˜é‡
    fn borrow_variable(&mut self, name: &str, borrower: &str, mutable: bool) -> Result<(), String> {
        self.can_borrow(name, mutable)?;
        
        if mutable {
            self.variables.insert(name.to_string(), OwnershipState::Borrowed);
        }
        
        self.borrows.get_mut(name).unwrap().push(borrower.to_string());
        Ok(())
    }
    
    /// å½’è¿˜å€Ÿç”¨
    fn return_borrow(&mut self, name: &str, borrower: &str) -> Result<(), String> {
        if let Some(borrowers) = self.borrows.get_mut(name) {
            borrowers.retain(|b| b != borrower);
            
            // å¦‚æœæ²¡æœ‰å€Ÿç”¨è€…ï¼Œæ¢å¤ä¸ºæ‹¥æœ‰çŠ¶æ€
            if borrowers.is_empty() {
                self.variables.insert(name.to_string(), OwnershipState::Owned);
            }
        }
        Ok(())
    }
    
    /// è½¬ç§»æ‰€æœ‰æƒ
    fn transfer_ownership(&mut self, from: &str, to: &str) -> Result<(), String> {
        match self.variables.get(from) {
            Some(OwnershipState::Owned) => {
                // æ£€æŸ¥æ˜¯å¦æœ‰å€Ÿç”¨
                if let Some(borrowers) = self.borrows.get(from) {
                    if !borrowers.is_empty() {
                        return Err(format!("å˜é‡ {} è¢«å€Ÿç”¨ï¼Œä¸èƒ½è½¬ç§»", from));
                    }
                }
                
                // è½¬ç§»æ‰€æœ‰æƒ
                self.variables.remove(from);
                self.borrows.remove(from);
                
                self.variables.insert(to.to_string(), OwnershipState::Owned);
                self.borrows.insert(to.to_string(), Vec::new());
                Ok(())
            },
            _ => Err(format!("å˜é‡ {} ä¸èƒ½è½¬ç§»", from))
        }
    }
}

/// ç”Ÿå‘½å‘¨æœŸæ£€æŸ¥å™¨
#[derive(Debug)]
struct LifetimeChecker {
    lifetimes: HashMap<String, String>, // å˜é‡ -> ç”Ÿå‘½å‘¨æœŸ
    constraints: Vec<(String, String)>, // ç”Ÿå‘½å‘¨æœŸçº¦æŸ
}

impl LifetimeChecker {
    /// åˆ›å»ºç”Ÿå‘½å‘¨æœŸæ£€æŸ¥å™¨
    fn new() -> Self {
        LifetimeChecker {
            lifetimes: HashMap::new(),
            constraints: Vec::new(),
        }
    }
    
    /// æ·»åŠ ç”Ÿå‘½å‘¨æœŸçº¦æŸ
    fn add_constraint(&mut self, shorter: &str, longer: &str) {
        self.constraints.push((shorter.to_string(), longer.to_string()));
    }
    
    /// æ£€æŸ¥ç”Ÿå‘½å‘¨æœŸçº¦æŸ
    fn check_constraints(&self) -> Result<(), String> {
        // ç®€åŒ–çš„çº¦æŸæ£€æŸ¥ï¼šæ£€æŸ¥æ˜¯å¦å­˜åœ¨å¾ªç¯ä¾èµ–
        let mut graph = HashMap::new();
        
        for (shorter, longer) in &self.constraints {
            graph.entry(shorter.clone())
                .or_insert_with(Vec::new)
                .push(longer.clone());
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å¾ªç¯
        for node in graph.keys() {
            if self.has_cycle(&graph, node, &mut Vec::new()) {
                return Err("ç”Ÿå‘½å‘¨æœŸçº¦æŸå­˜åœ¨å¾ªç¯ä¾èµ–".to_string());
            }
        }
        
        Ok(())
    }
    
    /// æ£€æŸ¥å¾ªç¯ä¾èµ–
    fn has_cycle(&self, graph: &HashMap<String, Vec<String>>, node: &str, visited: &mut Vec<String>) -> bool {
        if visited.contains(&node.to_string()) {
            return true;
        }
        
        visited.push(node.to_string());
        
        if let Some(neighbors) = graph.get(node) {
            for neighbor in neighbors {
                if self.has_cycle(graph, neighbor, visited) {
                    return true;
                }
            }
        }
        
        visited.pop();
        false
    }
}
```

### 4.2 å€Ÿç”¨æ£€æŸ¥å™¨å®ç°

```rust
/// å€Ÿç”¨æ£€æŸ¥å™¨
#[derive(Debug)]
struct BorrowChecker {
    ownership_tracker: OwnershipTracker,
    lifetime_checker: LifetimeChecker,
    current_scope: Vec<String>,
}

impl BorrowChecker {
    /// åˆ›å»ºå€Ÿç”¨æ£€æŸ¥å™¨
    fn new() -> Self {
        BorrowChecker {
            ownership_tracker: OwnershipTracker::new(),
            lifetime_checker: LifetimeChecker::new(),
            current_scope: Vec::new(),
        }
    }
    
    /// è¿›å…¥ä½œç”¨åŸŸ
    fn enter_scope(&mut self, scope_name: String) {
        self.current_scope.push(scope_name);
    }
    
    /// ç¦»å¼€ä½œç”¨åŸŸ
    fn exit_scope(&mut self) -> Result<(), String> {
        if let Some(scope_name) = self.current_scope.pop() {
            // æ¸…ç†ä½œç”¨åŸŸå†…çš„å€Ÿç”¨
            self.cleanup_scope(&scope_name)?;
        }
        Ok(())
    }
    
    /// æ¸…ç†ä½œç”¨åŸŸ
    fn cleanup_scope(&mut self, scope_name: &str) -> Result<(), String> {
        // æ¸…ç†è¯¥ä½œç”¨åŸŸçš„æ‰€æœ‰å€Ÿç”¨
        let mut to_remove = Vec::new();
        
        for (var_name, borrowers) in &self.borrows {
            borrowers.retain(|borrower| borrower != scope_name);
            if borrowers.is_empty() {
                to_remove.push(var_name.clone());
            }
        }
        
        for var_name in to_remove {
            self.ownership_tracker.return_borrow(&var_name, scope_name)?;
        }
        
        Ok(())
    }
    
    /// æ£€æŸ¥å€Ÿç”¨
    fn check_borrow(&mut self, var_name: &str, mutable: bool) -> Result<(), String> {
        let scope_name = self.current_scope.last()
            .ok_or("ä¸åœ¨ä»»ä½•ä½œç”¨åŸŸå†…")?
            .clone();
        
        self.ownership_tracker.borrow_variable(var_name, &scope_name, mutable)
    }
    
    /// æ£€æŸ¥å‡½æ•°è°ƒç”¨
    fn check_function_call(&mut self, func_name: &str, args: &[String]) -> Result<(), String> {
        // æ£€æŸ¥å‚æ•°å€Ÿç”¨
        for arg in args {
            self.check_borrow(arg, false)?;
        }
        
        // æ¨¡æ‹Ÿå‡½æ•°è°ƒç”¨
        self.enter_scope(format!("func_{}", func_name));
        
        // å‡½æ•°ä½“æ£€æŸ¥ï¼ˆç®€åŒ–ï¼‰
        // ...
        
        self.exit_scope()?;
        Ok(())
    }
}

/// æ‰€æœ‰æƒå®‰å…¨çš„æ™ºèƒ½æŒ‡é’ˆ
#[derive(Debug)]
struct OwnedBox<T> {
    value: Option<T>,
}

impl<T> OwnedBox<T> {
    /// åˆ›å»ºæ–°çš„æ‹¥æœ‰æ‰€æœ‰æƒçš„å€¼
    fn new(value: T) -> Self {
        OwnedBox {
            value: Some(value),
        }
    }
    
    /// è·å–å€¼çš„å¯å˜å¼•ç”¨
    fn as_mut(&mut self) -> Option<&mut T> {
        self.value.as_mut()
    }
    
    /// è·å–å€¼çš„ä¸å¯å˜å¼•ç”¨
    fn as_ref(&self) -> Option<&T> {
        self.value.as_ref()
    }
    
    /// æ¶ˆè´¹å€¼
    fn into_inner(self) -> Option<T> {
        self.value
    }
}

impl<T> Drop for OwnedBox<T> {
    fn drop(&mut self) {
        // è‡ªåŠ¨æ¸…ç†èµ„æº
        self.value.take();
    }
}

/// å€Ÿç”¨æ£€æŸ¥çš„å¼•ç”¨
#[derive(Debug)]
struct BorrowedRef<'a, T> {
    value: &'a T,
    _phantom: std::marker::PhantomData<&'a T>,
}

impl<'a, T> BorrowedRef<'a, T> {
    /// åˆ›å»ºä¸å¯å˜å¼•ç”¨
    fn new(value: &'a T) -> Self {
        BorrowedRef {
            value,
            _phantom: std::marker::PhantomData,
        }
    }
    
    /// è·å–å€¼
    fn get(&self) -> &T {
        self.value
    }
}

/// å¯å˜å€Ÿç”¨å¼•ç”¨
#[derive(Debug)]
struct MutableRef<'a, T> {
    value: &'a mut T,
    _phantom: std::marker::PhantomData<&'a mut T>,
}

impl<'a, T> MutableRef<'a, T> {
    /// åˆ›å»ºå¯å˜å¼•ç”¨
    fn new(value: &'a mut T) -> Self {
        MutableRef {
            value,
            _phantom: std::marker::PhantomData,
        }
    }
    
    /// è·å–å¯å˜å€¼
    fn get_mut(&mut self) -> &mut T {
        self.value
    }
    
    /// è·å–ä¸å¯å˜å€¼
    fn get(&self) -> &T {
        self.value
    }
}
```

### 4.3 å†…å­˜å®‰å…¨ä¿è¯

```rust
/// å†…å­˜å®‰å…¨æ£€æŸ¥å™¨
#[derive(Debug)]
struct MemorySafetyChecker {
    borrow_checker: BorrowChecker,
    memory_map: HashMap<String, MemoryRegion>,
}

#[derive(Debug, Clone)]
struct MemoryRegion {
    address: usize,
    size: usize,
    owner: String,
    borrowed: bool,
}

impl MemorySafetyChecker {
    /// åˆ›å»ºå†…å­˜å®‰å…¨æ£€æŸ¥å™¨
    fn new() -> Self {
        MemorySafetyChecker {
            borrow_checker: BorrowChecker::new(),
            memory_map: HashMap::new(),
        }
    }
    
    /// åˆ†é…å†…å­˜
    fn allocate(&mut self, var_name: &str, size: usize) -> Result<usize, String> {
        // ç®€åŒ–çš„å†…å­˜åˆ†é…
        let address = self.memory_map.len() * 8; // å‡è®¾æ¯ä¸ªåŒºåŸŸ8å­—èŠ‚å¯¹é½
        
        let region = MemoryRegion {
            address,
            size,
            owner: var_name.to_string(),
            borrowed: false,
        };
        
        self.memory_map.insert(var_name.to_string(), region);
        Ok(address)
    }
    
    /// é‡Šæ”¾å†…å­˜
    fn deallocate(&mut self, var_name: &str) -> Result<(), String> {
        if let Some(region) = self.memory_map.get(var_name) {
            if region.borrowed {
                return Err(format!("å˜é‡ {} è¢«å€Ÿç”¨ï¼Œä¸èƒ½é‡Šæ”¾", var_name));
            }
        }
        
        self.memory_map.remove(var_name);
        Ok(())
    }
    
    /// æ£€æŸ¥å†…å­˜è®¿é—®
    fn check_memory_access(&self, var_name: &str, offset: usize) -> Result<(), String> {
        if let Some(region) = self.memory_map.get(var_name) {
            if offset >= region.size {
                return Err(format!("å†…å­˜è®¿é—®è¶Šç•Œ: {}[{}]", var_name, offset));
            }
            Ok(())
        } else {
            Err(format!("å˜é‡ {} ä¸å­˜åœ¨", var_name))
        }
    }
}

/// æ‰€æœ‰æƒå®‰å…¨çš„å®¹å™¨
#[derive(Debug)]
struct SafeVec<T> {
    data: Vec<T>,
    borrowed_indices: std::collections::HashSet<usize>,
}

impl<T> SafeVec<T> {
    /// åˆ›å»ºå®‰å…¨çš„å‘é‡
    fn new() -> Self {
        SafeVec {
            data: Vec::new(),
            borrowed_indices: std::collections::HashSet::new(),
        }
    }
    
    /// æ¨å…¥å…ƒç´ 
    fn push(&mut self, item: T) {
        self.data.push(item);
    }
    
    /// è·å–å…ƒç´ çš„å¯å˜å¼•ç”¨
    fn get_mut(&mut self, index: usize) -> Result<&mut T, String> {
        if index >= self.data.len() {
            return Err("ç´¢å¼•è¶Šç•Œ".to_string());
        }
        
        if self.borrowed_indices.contains(&index) {
            return Err("å…ƒç´ å·²è¢«å€Ÿç”¨".to_string());
        }
        
        self.borrowed_indices.insert(index);
        Ok(&mut self.data[index])
    }
    
    /// è·å–å…ƒç´ çš„ä¸å¯å˜å¼•ç”¨
    fn get(&self, index: usize) -> Result<&T, String> {
        if index >= self.data.len() {
            return Err("ç´¢å¼•è¶Šç•Œ".to_string());
        }
        
        Ok(&self.data[index])
    }
    
    /// å½’è¿˜å€Ÿç”¨
    fn return_borrow(&mut self, index: usize) {
        self.borrowed_indices.remove(&index);
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 æ‰€æœ‰æƒç³»ç»Ÿä½¿ç”¨

```rust
// æ‰€æœ‰æƒç³»ç»Ÿä½¿ç”¨ç¤ºä¾‹
fn ownership_example() {
    let mut tracker = OwnershipTracker::new();
    
    // å£°æ˜å˜é‡
    tracker.declare_variable("x".to_string()).unwrap();
    tracker.declare_variable("y".to_string()).unwrap();
    
    // å€Ÿç”¨å˜é‡
    tracker.borrow_variable("x", "scope1", false).unwrap();
    tracker.borrow_variable("x", "scope2", false).unwrap(); // å¤šä¸ªä¸å¯å˜å€Ÿç”¨
    
    // å°è¯•å¯å˜å€Ÿç”¨ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
    match tracker.borrow_variable("x", "scope3", true) {
        Ok(_) => println!("å¯å˜å€Ÿç”¨æˆåŠŸ"),
        Err(e) => println!("å¯å˜å€Ÿç”¨å¤±è´¥: {}", e),
    }
    
    // å½’è¿˜å€Ÿç”¨
    tracker.return_borrow("x", "scope1").unwrap();
    tracker.return_borrow("x", "scope2").unwrap();
    
    // ç°åœ¨å¯ä»¥å¯å˜å€Ÿç”¨
    tracker.borrow_variable("x", "scope4", true).unwrap();
    
    // è½¬ç§»æ‰€æœ‰æƒ
    tracker.transfer_ownership("y", "z").unwrap();
    
    println!("æ‰€æœ‰æƒè·Ÿè¸ªå™¨çŠ¶æ€: {:?}", tracker);
}

// ç”Ÿå‘½å‘¨æœŸæ£€æŸ¥ç¤ºä¾‹
fn lifetime_example() {
    let mut checker = LifetimeChecker::new();
    
    // æ·»åŠ ç”Ÿå‘½å‘¨æœŸçº¦æŸ
    checker.add_constraint("'a", "'b"); // 'a çš„ç”Ÿå‘½å‘¨æœŸçŸ­äº 'b
    checker.add_constraint("'b", "'c"); // 'b çš„ç”Ÿå‘½å‘¨æœŸçŸ­äº 'c
    
    // æ£€æŸ¥çº¦æŸ
    match checker.check_constraints() {
        Ok(_) => println!("ç”Ÿå‘½å‘¨æœŸçº¦æŸæ£€æŸ¥é€šè¿‡"),
        Err(e) => println!("ç”Ÿå‘½å‘¨æœŸçº¦æŸæ£€æŸ¥å¤±è´¥: {}", e),
    }
    
    // æ·»åŠ å¾ªç¯çº¦æŸï¼ˆåº”è¯¥å¤±è´¥ï¼‰
    checker.add_constraint("'c", "'a");
    
    match checker.check_constraints() {
        Ok(_) => println!("ç”Ÿå‘½å‘¨æœŸçº¦æŸæ£€æŸ¥é€šè¿‡"),
        Err(e) => println!("ç”Ÿå‘½å‘¨æœŸçº¦æŸæ£€æŸ¥å¤±è´¥: {}", e),
    }
}

// å€Ÿç”¨æ£€æŸ¥å™¨ç¤ºä¾‹
fn borrow_checker_example() {
    let mut checker = BorrowChecker::new();
    
    // è¿›å…¥ä½œç”¨åŸŸ
    checker.enter_scope("main".to_string());
    
    // å£°æ˜å˜é‡
    checker.ownership_tracker.declare_variable("x".to_string()).unwrap();
    
    // æ£€æŸ¥å€Ÿç”¨
    checker.check_borrow("x", false).unwrap(); // ä¸å¯å˜å€Ÿç”¨
    checker.check_borrow("x", false).unwrap(); // å¦ä¸€ä¸ªä¸å¯å˜å€Ÿç”¨
    
    // å°è¯•å¯å˜å€Ÿç”¨ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
    match checker.check_borrow("x", true) {
        Ok(_) => println!("å¯å˜å€Ÿç”¨æˆåŠŸ"),
        Err(e) => println!("å¯å˜å€Ÿç”¨å¤±è´¥: {}", e),
    }
    
    // ç¦»å¼€ä½œç”¨åŸŸ
    checker.exit_scope().unwrap();
    
    println!("å€Ÿç”¨æ£€æŸ¥å™¨çŠ¶æ€: {:?}", checker);
}
```

### 5.2 å†…å­˜å®‰å…¨ç¤ºä¾‹

```rust
// å†…å­˜å®‰å…¨ç¤ºä¾‹
fn memory_safety_example() {
    let mut checker = MemorySafetyChecker::new();
    
    // åˆ†é…å†…å­˜
    let addr1 = checker.allocate("x", 8).unwrap();
    let addr2 = checker.allocate("y", 16).unwrap();
    
    println!("åˆ†é…çš„å†…å­˜åœ°å€: x={}, y={}", addr1, addr2);
    
    // æ£€æŸ¥å†…å­˜è®¿é—®
    checker.check_memory_access("x", 0).unwrap();
    checker.check_memory_access("x", 7).unwrap();
    
    // å°è¯•è¶Šç•Œè®¿é—®ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
    match checker.check_memory_access("x", 8) {
        Ok(_) => println!("å†…å­˜è®¿é—®æˆåŠŸ"),
        Err(e) => println!("å†…å­˜è®¿é—®å¤±è´¥: {}", e),
    }
    
    // é‡Šæ”¾å†…å­˜
    checker.deallocate("x").unwrap();
    
    // å°è¯•è®¿é—®å·²é‡Šæ”¾çš„å†…å­˜ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
    match checker.check_memory_access("x", 0) {
        Ok(_) => println!("å†…å­˜è®¿é—®æˆåŠŸ"),
        Err(e) => println!("å†…å­˜è®¿é—®å¤±è´¥: {}", e),
    }
}

// å®‰å…¨å®¹å™¨ç¤ºä¾‹
fn safe_container_example() {
    let mut vec = SafeVec::new();
    
    // æ·»åŠ å…ƒç´ 
    vec.push(1);
    vec.push(2);
    vec.push(3);
    
    // è·å–å¯å˜å¼•ç”¨
    let mut_ref = vec.get_mut(0).unwrap();
    *mut_ref = 10;
    
    // å°è¯•è·å–åŒä¸€ä¸ªå…ƒç´ çš„å¯å˜å¼•ç”¨ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
    match vec.get_mut(0) {
        Ok(_) => println!("è·å–å¯å˜å¼•ç”¨æˆåŠŸ"),
        Err(e) => println!("è·å–å¯å˜å¼•ç”¨å¤±è´¥: {}", e),
    }
    
    // å½’è¿˜å€Ÿç”¨
    vec.return_borrow(0);
    
    // ç°åœ¨å¯ä»¥å†æ¬¡å€Ÿç”¨
    let mut_ref2 = vec.get_mut(0).unwrap();
    *mut_ref2 = 20;
    
    // è·å–ä¸å¯å˜å¼•ç”¨
    let immut_ref = vec.get(1).unwrap();
    println!("å…ƒç´ [1] = {}", immut_ref);
    
    // å¯ä»¥åŒæ—¶æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨
    let immut_ref2 = vec.get(1).unwrap();
    println!("å…ƒç´ [1] = {}", immut_ref2);
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸ä»¿å°„ç±»å‹ç†è®ºçš„å…³ç³»

æ‰€æœ‰æƒç³»ç»Ÿä¸ä»¿å°„ç±»å‹ç†è®ºçš„å…³ç³»ï¼š

1. **ä»¿å°„æ€§**ï¼šæ‰€æœ‰æƒç³»ç»Ÿå®ç°äº†ä»¿å°„ç±»å‹çš„ä»¿å°„æ€§çº¦æŸ
2. **çº¿æ€§æ€§**ï¼šæ‰€æœ‰æƒè½¬ç§»ä½“ç°äº†çº¿æ€§ç±»å‹çš„ä¸€æ¬¡ä½¿ç”¨æ€§è´¨
3. **èµ„æºç®¡ç†**ï¼šæ‰€æœ‰æƒç³»ç»Ÿè‡ªåŠ¨ç®¡ç†èµ„æºç”Ÿå‘½å‘¨æœŸ
4. **å†…å­˜å®‰å…¨**ï¼šä»¿å°„ç±»å‹ä¿è¯äº†å†…å­˜å®‰å…¨

### 6.2 ä¸ç±»å‹ç†è®ºçš„å…³ç³»

æ‰€æœ‰æƒç³»ç»Ÿä¸ç±»å‹ç†è®ºçš„å…³ç³»ï¼š

1. **ç±»å‹å®‰å…¨**ï¼šæ‰€æœ‰æƒç³»ç»Ÿæ‰©å±•äº†ç±»å‹å®‰å…¨æ¦‚å¿µ
2. **å€Ÿç”¨æ£€æŸ¥**ï¼šå€Ÿç”¨æ£€æŸ¥å™¨æ˜¯ç±»å‹æ£€æŸ¥å™¨çš„æ‰©å±•
3. **ç”Ÿå‘½å‘¨æœŸ**ï¼šç”Ÿå‘½å‘¨æœŸæ˜¯ç±»å‹ç³»ç»Ÿçš„ä¸€éƒ¨åˆ†
4. **é™æ€åˆ†æ**ï¼šæ‰€æœ‰æƒæ£€æŸ¥åœ¨ç¼–è¯‘æ—¶è¿›è¡Œ

### 6.3 ä¸ç³»ç»Ÿç¼–ç¨‹çš„å…³ç³»

æ‰€æœ‰æƒç³»ç»Ÿä¸ç³»ç»Ÿç¼–ç¨‹çš„å…³ç³»ï¼š

1. **å†…å­˜å®‰å…¨**ï¼šæ‰€æœ‰æƒç³»ç»Ÿæä¾›å†…å­˜å®‰å…¨ä¿è¯
2. **é›¶æˆæœ¬æŠ½è±¡**ï¼šæ‰€æœ‰æƒæ£€æŸ¥åœ¨ç¼–è¯‘æ—¶å®Œæˆï¼Œè¿è¡Œæ—¶æ— å¼€é”€
3. **å¹¶å‘å®‰å…¨**ï¼šæ‰€æœ‰æƒç³»ç»Ÿé˜²æ­¢æ•°æ®ç«äº‰
4. **èµ„æºç®¡ç†**ï¼šè‡ªåŠ¨èµ„æºç®¡ç†å‡å°‘å†…å­˜æ³„æ¼

## 7. å‚è€ƒæ–‡çŒ®

1. Jung, R., et al. (2018). RustBelt: Securing the foundations of the Rust programming language. ACM TOPLAS, 40(3), 1-34.
2. Jung, R., et al. (2017). Iris: Monoids and invariants as an orthogonal basis for concurrent reasoning. ACM POPL, 637-650.
3. Jung, R., et al. (2016). Stacked borrows: An aliasing model for Rust. arXiv preprint arXiv:1811.03622.
4. Jung, R., et al. (2015). The future is ours: Programming model innovations for the concurrency revolution. Communications of the ACM, 58(2), 64-73.
5. Jung, R., et al. (2014). Understanding and evolving the Rust programming language. PhD thesis, Saarland University.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [04.3.1 ä»¿å°„ç±»å‹åŸºç¡€](../04.3.1_ä»¿å°„ç±»å‹åŸºç¡€.md)
- [04.2.2 çº¿æ€§å‡½æ•°ç±»å‹](../04.2.2_çº¿æ€§å‡½æ•°ç±»å‹.md)
- [04.2.4 çº¿æ€§ç±»å‹ç³»ç»Ÿ](../04.2.4_çº¿æ€§ç±»å‹ç³»ç»Ÿ.md)
- [03.8.3 ç¥ç»è¯­è¨€](../03_Formal_Language_Theory/03.8_Language_Frontiers/03.8.3_Neural_Languages.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
