# 04.1.2 简单类型λ演算 (STLC)

## 📋 概述

STLC 在无类型λ演算之上引入函数类型与类型检查，保证良构项的类型安全（进展与保型），为现代语言核心奠基。

## 语法与类型

- 类型：`T ::= ι | T -> T`
- 项：`e ::= x | λx:T.e | e e`
- 环境：`Γ ::= · | Γ, x:T`

## 规则

- Var / Abs / App 同 `04.1_Simple_Type_Theory.md`
- 替换引理、弱化/置换引理为后续性质证明提供技术基础

## 性质（要点）

- 进展（Progress）与保型（Preservation）
- 强规范化（无递归与效应时）

## 代码片段

```haskell
-- 极简 STLC 类型检查（伪码）
data Ty = base | Fun Ty Ty

type Ctx = [(String, Ty)]

typeOf :: Ctx -> Expr -> Maybe Ty
typeOf g (Var x)      = lookup x g
typeOf g (Abs x t e)  = do t' <- typeOf ((x,t):g) e
                           pure (Fun t t')
typeOf g (App e1 e2)  = do Fun t u <- typeOf g e1
                           t'      <- typeOf g e2
                           if t==t' then pure u else Nothing
```

```haskell
-- 小步语义（→β）
step (App (Abs x _ e) v) | isValue v = subst x v e
```

```rust
// 保型检查接口（示意）
fn check_progress_and_preservation(program: &Expr) -> bool { true }
```

## 参考文献

1. Pierce, TAPL.
2. Harper, PFPL.

## 批判性分析

- 多元理论视角：
  - 类型安全的范式教材：以进展/保型为核心公理化演绎，直观刻画“不会走到坏状态”。
  - 语义对接：CCC 为函数类型提供自然语义，连接范畴语义与编译器语义学。
- 局限性分析：
  - 无多态与抽象重用不足；无依赖与证明携带不足；强规范化排斥通用递归—需通过不动点与效应扩展。
- 争议与分歧：
  - 注解密度与类型推断的权衡；教学中STLC与HM/System F的先后关系与过渡方式。
- 应用前景：
  - 作为核心语言/IR 的安全壳；教学与验证最小模型；跨语言类型语义对照基准。
- 改进建议：
  - 增补可运行最小检查器，提供Progress/Preservation的机器检查草图；给出到HM/System F的演进“食谱”。
