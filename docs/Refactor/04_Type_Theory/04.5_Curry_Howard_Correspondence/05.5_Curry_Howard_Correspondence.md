# 04.5 Curryâ€“Howard å¯¹åº”ï¼ˆCurryâ€“Howard Correspondenceï¼‰

**åˆ›å»ºæ—¶é—´**: 2025-01-17  
**æœ€åæ›´æ–°**: 2025-01-17  
**æ–‡æ¡£çŠ¶æ€**: æ´»è·ƒ  
**å…³è”æ¨¡å—**: `04_Type_Theory`

## ğŸ“ æ¦‚è¿°

Curryâ€“Howard å¯¹åº”ï¼ˆåˆç§°"å‘½é¢˜â€‘å³â€‘ç±»å‹ï¼Œè¯æ˜â€‘å³â€‘ç¨‹åº"ï¼‰åˆ»ç”»äº†é€»è¾‘ä¸è®¡ç®—ä¹‹é—´çš„ç»“æ„æ€§åŒæ„ï¼š

- é€»è¾‘å‘½é¢˜ â†” ç±»å‹
- è¯æ˜ â†” ç¨‹åº/é¡¹
- è¯æ˜çš„è§„èŒƒåŒ– â†” ç¨‹åºæ±‚å€¼/å½’çº¦

è¯¥å¯¹åº”ä¸ºç±»å‹é©±åŠ¨å¼€å‘ã€äº¤äº’å¼å®šç†è¯æ˜ä¸å¯éªŒè¯ç¼–ç¨‹æä¾›äº†ç»Ÿä¸€çš„ç†è®ºæ¡†æ¶ã€‚

## ğŸ“œ å†å²ä¸å‘å±•

- Curry ä¸ Feysã€Howard ç­‰äººçš„å·¥ä½œæ­ç¤ºç›´è§‰ä¸»ä¹‰é€»è¾‘ä¸Î»æ¼”ç®—çš„æ·±åº¦è”ç³»
- Gentzen å‰Šåˆ‡æ¶ˆé™¤ä¸å½’çº¦å¯¹åº”ï¼Œè¿æ¥è¯æ˜è®ºä¸è®¡ç®—
- ç°ä»£æ‰©å±•åŒ…æ‹¬ä¾èµ–ã€çº¿æ€§ã€åŒä¼¦ç­‰å¤šç§"ç±»å‹â€‘é€»è¾‘"åŒæ„

## ğŸ”£ åŸºæœ¬æ˜ å°„ï¼ˆç¤ºæ„ï¼‰

- åˆå– `A âˆ§ B` â†” ç§¯ç±»å‹ `A Ã— B`
- æå– `A âˆ¨ B` â†” å’Œç±»å‹ `A + B`
- è•´å« `A â†’ B` â†” å‡½æ•°ç±»å‹ `A â†’ B`
- çœŸ `âŠ¤` â†” å•å…ƒç±»å‹ `Unit`
- å‡ `âŠ¥` â†” ç©ºç±»å‹ `Void`
- å…¨ç§° `âˆ€x:A. P(x)` â†” ä¾èµ–å‡½æ•° `Î x:A. P(x)`
- å­˜åœ¨ `âˆƒx:A. P(x)` â†” ä¾èµ–å¯¹ `Î£x:A. P(x)`
- ç­‰å¼ `a =_A b` â†” èº«ä»½/è·¯å¾„ç±»å‹ `Id_A(a,b)`

å¯¹åº”çš„"è®¡ç®—"ä¾§ä¸"è¯æ˜å˜æ¢"ä¾§åœ¨ Î²/Î· å½’çº¦ä¸å‰Šåˆ‡æ¶ˆé™¤ä¸‹åŒæ„ã€‚

## ğŸ§  å˜ä½“ä¸æ‰©å±•

- ä¾èµ–ç±»å‹ç‰ˆ Curryâ€“Howardï¼šå‘½é¢˜å³ä¾èµ–ç±»å‹ï¼Œè¯æ˜å³ä¾èµ–é¡¹
- çº¿æ€§/ä»¿å°„ç‰ˆæœ¬ï¼šç»“æ„è§„åˆ™å—é™ï¼Œå¯¹åº”èµ„æºæ•æ„Ÿé€»è¾‘ï¼ˆLLï¼‰ä¸ç±»å‹ï¼ˆ`âŠ—, âŠ¸, !`ï¼‰
- åŒä¼¦ç‰ˆæœ¬ï¼šç­‰ä»·å³ç›¸ç­‰ï¼ˆUnivalenceï¼‰ï¼Œè¯æ˜å³é«˜ç»´è·¯å¾„
- ç»å…¸é€»è¾‘æ‰©å±•ï¼šç» CPS/åŒé‡å¦å®šç¿»è¯‘æˆ–æ§åˆ¶ç®—å­ï¼ˆ`call/cc`ï¼‰è·å¾—

## ğŸ§ª ç¤ºä¾‹ä¸å®è·µ

- åœ¨ Coq/Agda/Lean ä¸­ï¼Œ"å®šç†"å³å¸¦ç±»å‹çš„å¸¸é‡ï¼Œ"è¯æ˜"å³å…¶é¡¹ï¼›æå–ï¼ˆExtractionï¼‰å°†è¯æ˜â€‘ç¨‹åºå¯¼å‡ºä¸º Haskell/OCaml ç­‰
- ç¼–ç¨‹å³è¯æ˜ï¼šç±»å‹è§„èŒƒå³è§„æ ¼ï¼Œç±»å‹æ£€æŸ¥å³éªŒè¯ï¼ˆå—ç›¸ç­‰åˆ¤å®šä¸å†…æ ¸å¯ä¿¡åŸºå¤§å°å½±å“ï¼‰

## ğŸ§© å±€é™ä¸æ‰¹åˆ¤

- ç»å…¸æ€§ï¼šç›´è§‰ä¸»ä¹‰åŸºç¡€é™åˆ¶è‹¥ä¸é‡‡ç”¨ç¿»è¯‘/æ§åˆ¶ç®—å­ï¼Œåˆ™ä¸ä¸»æµç»å…¸æ•°å­¦æœ‰ç¼éš™
- å¯åˆ¤å®šæ€§ï¼šå¼ºè¡¨è¾¾åŠ›ï¼ˆå¦‚é«˜ç­‰åŒæ€§ã€å…¬ç†ï¼‰å¯èƒ½å‰Šå¼±åˆ¤å®šæ€§ä¸è§„èŒƒæ€§
- è¯­ä¹‰ä¾èµ–ï¼šä¸åŒè¯­ä¹‰ï¼ˆé›†åˆã€èŒƒç•´ã€åŒä¼¦ï¼‰ä¸‹"ç›¸ç­‰/ç­‰ä»·"è§£é‡Šå·®å¼‚å½±å“å·¥ç¨‹å®è·µ
- ç¤¾ä¼šæŠ€æœ¯ï¼šé—¨æ§›ä¸å­¦ä¹ æ›²çº¿å¸¦æ¥çŸ¥è¯†ä¸å¹³ç­‰ï¼›å¯ä¿¡å†…æ ¸æ²»ç†ä¸è´£ä»»åˆ’åˆ†éœ€æ˜ç¡®

## ğŸ”— ä¸æ¨¡å—å†…ä¸»é¢˜çš„å…³ç³»

- `04.2 ä¾èµ–ç±»å‹è®º`ï¼šå°† Curryâ€“Howard æå‡è‡³ä¾èµ–å±‚çº§ï¼Œ`Î /Î£/Id` å¯¹åº” `âˆ€/âˆƒ/=`
- `04.3 çº¿æ€§ç±»å‹ç†è®º`ï¼šä¸èµ„æºé€»è¾‘å¯¹æ¥ï¼Œç¨‹åº=è¯æ˜å…·èµ„æºä¿çœŸè¯­ä¹‰
- `04.4 åŒä¼¦ç±»å‹è®º`ï¼šè¯æ˜å³é«˜ç»´è·¯å¾„ï¼›ä¸€è‡´æ€§ä½¿é€»è¾‘ç­‰ä»·ä¸Šå‡ä¸ºç›¸ç­‰
- `04.1 ç®€å•ç±»å‹ç†è®º`ï¼šæœ€å°æ ¸å¯¹åº”ç›´è§‰å‘½é¢˜é€»è¾‘çš„è•´å«ç‰‡æ®µ

## ğŸ§­ Wiki å¯¹é½çš„æ¡ç›®ç»“æ„

- æ¦‚è¿°ï½œå†å²ï½œæ˜ å°„ï½œæ‰©å±•ï½œå®è·µï½œæ‰¹åˆ¤ï½œå‚è§ï½œå‚è€ƒ

## ğŸ“š å‚è§ï¼ˆSee alsoï¼‰

- [04.1 ç®€å•ç±»å‹ç†è®º](../04.1_Simple_Type_Theory/04.1_Simple_Type_Theory.md)
- [04.2 ä¾èµ–ç±»å‹ç†è®º](../04.2_Dependent_Type_Theory/04.2_Dependent_Type_Theory.md)
- [04.3 çº¿æ€§ç±»å‹ç†è®º](../04.3_Linear_Type_Theory/05.3_Linear_Type_Theory.md)
- [04.4 åŒä¼¦ç±»å‹ç†è®º](../04.4_Homotopy_Type_Theory/05.4_Homotopy_Type_Theory.md)
- [ç»Ÿä¸€æœ¯è¯­è¡¨](../TERMINOLOGY_TABLE.md)

## ğŸ“– å‚è€ƒæ–‡çŒ®ï¼ˆç²¾é€‰ï¼‰

1. Howard, W. A. (1980). The formulae-as-types notion of construction. *To H. B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism*, 479-490.
2. Barendregt, H. P. (1992). Lambda calculi with types. *Handbook of Logic in Computer Science*, 2, 117-309.
3. Harper, R. (2016). *Practical Foundations for Programming Languages*. Cambridge University Press.
4. Girard, J.-Y. (1987). Linear logic. *Theoretical Computer Science*, 50(1), 1-101.
5. The Univalent Foundations Program. (2013). *Homotopy Type Theory: Univalent Foundations of Mathematics*. Institute for Advanced Study.

## ğŸ”§ Coq æœ€å°è¯æ˜ç‰‡æ®µ

```coq
(* Curry-Howard å¯¹åº”çš„ç»å…¸ç¤ºä¾‹ *)

(* å‘½é¢˜ï¼šA -> A (æ’ç­‰å‡½æ•°) *)
Definition id_prop (A : Type) : A -> A := fun x => x.

(* å‘½é¢˜ï¼šA -> B -> A (K ç»„åˆå­) *)
Definition k_prop (A B : Type) : A -> B -> A := fun x y => x.

(* å‘½é¢˜ï¼š(A -> B -> C) -> (A -> B) -> A -> C (S ç»„åˆå­) *)
Definition s_prop (A B C : Type) : 
  (A -> B -> C) -> (A -> B) -> A -> C :=
  fun f g x => f x (g x).

(* å‘½é¢˜ï¼šA /\ B -> A (åˆå–æ¶ˆé™¤) *)
Definition and_elim_left (A B : Type) : A * B -> A :=
  fun p => fst p.

(* å‘½é¢˜ï¼šA -> A \/ B (æå–å¼•å…¥) *)
Definition or_intro_left (A B : Type) : A -> A + B :=
  fun a => inl a.
```
