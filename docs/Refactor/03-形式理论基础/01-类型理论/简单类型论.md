# 简单类型论 (Simple Type Theory)

## 目录

1. [概述](#概述)
2. [基本概念](#基本概念)
3. [类型构造](#类型构造)
4. [项与归约](#项与归约)
5. [类型检查](#类型检查)
6. [语义解释](#语义解释)
7. [元理论性质](#元理论性质)
8. [应用与扩展](#应用与扩展)
9. [参考文献](#参考文献)

## 概述

简单类型论是类型理论的基础，它提供了类型安全的形式化框架。简单类型论由Alonzo Church在1940年提出，是现代编程语言类型系统的基础。

### 核心思想

简单类型论基于以下原则：

- 每个项都有类型
- 类型决定项的合法操作
- 类型检查在编译时进行
- 类型安全保证运行时安全

## 基本概念

### 定义 1.1 (类型)

类型是项的集合，表示项的可能值。基本类型包括：

- $\text{Bool}$：布尔类型
- $\text{Nat}$：自然数类型
- $\text{Unit}$：单位类型

### 定义 1.2 (函数类型)

如果 $A$ 和 $B$ 是类型，则 $A \rightarrow B$ 是从 $A$ 到 $B$ 的函数类型。

### 定义 1.3 (项)

项是类型的实例，包括：

- 变量：$x, y, z, \ldots$
- 常量：$\text{true}, \text{false}, 0, 1, \ldots$
- 函数应用：$f \, a$
- 函数抽象：$\lambda x : A. t$

### 定义 1.4 (类型判断)

类型判断的形式为 $\Gamma \vdash t : A$，表示在上下文 $\Gamma$ 中，项 $t$ 具有类型 $A$。

### 定义 1.5 (上下文)

上下文是类型假设的有限序列：
$$\Gamma = x_1 : A_1, x_2 : A_2, \ldots, x_n : A_n$$

## 类型构造

### 定义 1.6 (类型语法)

类型 $A, B$ 的语法定义为：
$$A, B ::= \text{Bool} \mid \text{Nat} \mid \text{Unit} \mid A \rightarrow B$$

### 定义 1.7 (项语法)

项 $t, s$ 的语法定义为：
$$t, s ::= x \mid c \mid t \, s \mid \lambda x : A. t$$

其中：

- $x$ 是变量
- $c$ 是常量
- $t \, s$ 是函数应用
- $\lambda x : A. t$ 是函数抽象

### 定义 1.8 (自由变量)

项 $t$ 的自由变量集合 $\text{FV}(t)$ 递归定义为：

1. $\text{FV}(x) = \{x\}$
2. $\text{FV}(c) = \emptyset$
3. $\text{FV}(t \, s) = \text{FV}(t) \cup \text{FV}(s)$
4. $\text{FV}(\lambda x : A. t) = \text{FV}(t) \setminus \{x\}$

### 定义 1.9 (替换)

项 $t[x := s]$ 表示将项 $t$ 中自由变量 $x$ 替换为项 $s$：

1. $x[x := s] = s$
2. $y[x := s] = y$ （如果 $y \neq x$）
3. $c[x := s] = c$
4. $[t_1 \, t_2](x := s) = (t_1[x := s]) \, (t_2[x := s])$
5. $[\lambda y : A. t](x := s) = \lambda y : A. (t[x := s])$ （如果 $y \neq x$ 且 $y \notin \text{FV}(s)$）

## 项与归约

### 定义 1.10 (β归约)

β归约规则：
$$(\lambda x : A. t) \, s \rightarrow_\beta t[x := s]$$

### 定义 1.11 (η归约)

η归约规则：
$$\lambda x : A. (t \, x) \rightarrow_\eta t$$ （如果 $x \notin \text{FV}(t)$）

### 定义 1.12 (归约关系)

归约关系 $\rightarrow$ 是 $\rightarrow_\beta \cup \rightarrow_\eta$ 的闭包。

### 定义 1.13 (等价关系)

等价关系 $\equiv$ 是 $\rightarrow$ 的对称传递闭包。

### 定理 1.1 (Church-Rosser定理)

简单类型论的归约关系满足Church-Rosser性质：
如果 $t \rightarrow^* t_1$ 且 $t \rightarrow^* t_2$，则存在 $t_3$ 使得 $t_1 \rightarrow^* t_3$ 且 $t_2 \rightarrow^* t_3$。

**证明**:
通过并行归约和标准化定理证明。

## 类型检查

### 定义 1.14 (类型规则)

简单类型论的类型规则：

#### 变量规则

$$\frac{x : A \in \Gamma}{\Gamma \vdash x : A}$$

#### 常量规则

$$\frac{}{\Gamma \vdash \text{true} : \text{Bool}} \quad \frac{}{\Gamma \vdash \text{false} : \text{Bool}}$$
$$\frac{}{\Gamma \vdash 0 : \text{Nat}} \quad \frac{\Gamma \vdash n : \text{Nat}}{\Gamma \vdash \text{succ}(n) : \text{Nat}}$$

#### 函数应用规则

$$\frac{\Gamma \vdash t : A \rightarrow B \quad \Gamma \vdash s : A}{\Gamma \vdash t \, s : B}$$

#### 函数抽象规则

$$\frac{\Gamma, x : A \vdash t : B}{\Gamma \vdash \lambda x : A. t : A \rightarrow B}$$

### 定义 1.15 (类型推导)

类型推导是应用类型规则得到的证明树。

### 定义 1.16 (类型检查算法)

类型检查算法 $\text{TypeCheck}(\Gamma, t)$ 返回项 $t$ 在上下文 $\Gamma$ 中的类型：

```haskell
typeCheck :: Context -> Term -> Maybe Type
typeCheck gamma (Var x) = lookup x gamma
typeCheck gamma (Const c) = typeOfConst c
typeCheck gamma (App t s) = do
  tType <- typeCheck gamma t
  sType <- typeCheck gamma s
  case tType of
    Arrow a b | a == sType -> Just b
    _ -> Nothing
typeCheck gamma (Lambda x a t) = do
  b <- typeCheck (extend gamma x a) t
  return (Arrow a b)
```

### 定理 1.2 (类型检查正确性)

如果 $\text{TypeCheck}(\Gamma, t) = \text{Just} A$，则 $\Gamma \vdash t : A$。

**证明**:
通过对项的结构归纳证明。

## 语义解释

### 定义 1.17 (类型语义)

类型的语义解释：

- $[\![\text{Bool}]\!] = \{\text{true}, \text{false}\}$
- $[\![\text{Nat}]\!] = \mathbb{N}$
- $[\![\text{Unit}]\!] = \{\text{unit}\}$
- $[\![A \rightarrow B]\!] = [\![A]\!] \rightarrow [\![B]\!]$

### 定义 1.18 (项语义)

项 $t$ 在环境 $\rho$ 中的语义 $[\![t]\!]_\rho$：

1. $[\![x]\!]_\rho = \rho(x)$
2. $[\![c]\!]_\rho = [\![c]\!]$
3. $[\![t \, s]\!]_\rho = [\![t]\!]_\rho([\![s]\!]_\rho)$
4. $[\![\lambda x : A. t]\!]_\rho = \lambda v \in [\![A]\!]. [\![t]\!]_{\rho[x := v]}$

### 定理 1.3 (语义一致性)

如果 $\Gamma \vdash t : A$，则对于所有满足 $\Gamma$ 的环境 $\rho$，$[\![t]\!]_\rho \in [\![A]\!]$。

**证明**:
通过对类型推导的结构归纳证明。

## 元理论性质

### 定理 1.4 (类型保持性)

如果 $\Gamma \vdash t : A$ 且 $t \rightarrow t'$，则 $\Gamma \vdash t' : A$。

**证明**:
通过对归约规则的分析证明。

### 定理 1.5 (进展性)

如果 $\emptyset \vdash t : A$ 且 $t$ 是封闭项，则要么 $t$ 是值，要么存在 $t'$ 使得 $t \rightarrow t'$。

**证明**:
通过对项的结构归纳证明。

### 定理 1.6 (强正规化)

简单类型论中的每个项都强正规化，即不存在无限归约序列。

**证明**:
通过可归约性谓词和逻辑关系证明。

### 定义 1.19 (可归约性谓词)

可归约性谓词 $\text{Red}_A(t)$ 递归定义为：

1. $\text{Red}_{\text{Bool}}(t)$ 如果 $t$ 是布尔值
2. $\text{Red}_{\text{Nat}}(t)$ 如果 $t$ 是自然数
3. $\text{Red}_{A \rightarrow B}(t)$ 如果对于所有 $s$ 满足 $\text{Red}_A(s)$，都有 $\text{Red}_B(t \, s)$

### 定理 1.7 (可归约性保持性)

如果 $\text{Red}_A(t)$ 且 $t \rightarrow t'$，则 $\text{Red}_A(t')$。

**证明**:
通过对归约规则的分析证明。

## 应用与扩展

### 应用 1.1 (编程语言)

简单类型论在编程语言中的应用：

- 静态类型检查
- 类型安全保证
- 编译器优化

### 应用 1.2 (逻辑系统)

简单类型论作为逻辑系统：

- 直觉主义逻辑
- 证明论
- 构造性数学

### 扩展 1.1 (多态类型)

扩展简单类型论以支持多态：

- 系统F
- 参数多态
- 类型抽象

### 扩展 1.2 (依赖类型)

扩展简单类型论以支持依赖类型：

- 依赖函数类型
- 依赖对类型
- 类型族

### 扩展 1.3 (高阶类型)

扩展简单类型论以支持高阶类型：

- 类型构造子
- 类型类
- 高阶抽象

## 实现示例

### 示例 1.1 (简单类型检查器)

```haskell
-- 类型定义
data Type = Bool | Nat | Unit | Arrow Type Type
  deriving (Eq, Show)

-- 项定义
data Term = Var String
          | Const String
          | App Term Term
          | Lambda String Type Term
  deriving (Show)

-- 上下文定义
type Context = [(String, Type)]

-- 类型检查
typeCheck :: Context -> Term -> Maybe Type
typeCheck gamma (Var x) = lookup x gamma
typeCheck gamma (Const "true") = Just Bool
typeCheck gamma (Const "false") = Just Bool
typeCheck gamma (Const "0") = Just Nat
typeCheck gamma (App t s) = do
  tType <- typeCheck gamma t
  sType <- typeCheck gamma s
  case tType of
    Arrow a b | a == sType -> Just b
    _ -> Nothing
typeCheck gamma (Lambda x a t) = do
  b <- typeCheck ((x, a) : gamma) t
  return (Arrow a b)
typeCheck _ _ = Nothing

-- 归约
reduce :: Term -> Maybe Term
reduce (App (Lambda x _ t) s) = Just (substitute x s t)
reduce (App t s) = do
  t' <- reduce t
  return (App t' s)
reduce _ = Nothing

-- 替换
substitute :: String -> Term -> Term -> Term
substitute x s (Var y) | x == y = s
substitute x s (Var y) = Var y
substitute x s (Const c) = Const c
substitute x s (App t1 t2) = App (substitute x s t1) (substitute x s t2)
substitute x s (Lambda y a t) | x /= y = Lambda y a (substitute x s t)
substitute x s (Lambda y a t) = Lambda y a t
```

### 示例 1.2 (类型推导示例)

```haskell
-- 恒等函数
id :: Term
id = Lambda "x" Bool (Var "x")

-- 类型检查
-- typeCheck [] id = Just (Arrow Bool Bool)

-- 应用恒等函数
app :: Term
app = App id (Const "true")

-- 类型检查
-- typeCheck [] app = Just Bool

-- 归约
-- reduce app = Just (Const "true")
```

## 参考文献

1. Church, A. (1940). A formulation of the simple theory of types. *The Journal of Symbolic Logic*, 5(2), 56-68.
2. Hindley, J. R., & Seldin, J. P. (2008). *Lambda-calculus and combinators: An introduction*. Cambridge University Press.
3. Pierce, B. C. (2002). *Types and programming languages*. MIT Press.
4. Tait, W. W. (1967). Intensional interpretations of functionals of finite type I. *The Journal of Symbolic Logic*, 32(2), 198-212.
5. Girard, J. Y., Lafont, Y., & Taylor, P. (1989). *Proofs and types*. Cambridge University Press.

---

**作者**: FormalScience项目组  
**创建日期**: 2024年12月19日  
**最后更新**: 2024年12月19日  
**版本**: 1.0  
**状态**: 初稿完成
