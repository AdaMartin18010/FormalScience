# 02.11.2 æ’åˆ—ç»„åˆ

## ğŸ“‹ æ¦‚è¿°

æ’åˆ—ç»„åˆæ˜¯ç»„åˆæ•°å­¦çš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶æœ‰é™é›†åˆä¸­å…ƒç´ çš„æœ‰åºå’Œæ— åºé€‰æ‹©é—®é¢˜ã€‚å®ƒåœ¨æ¦‚ç‡è®ºã€ç»Ÿè®¡å­¦ã€å¯†ç å­¦ã€ç®—æ³•è®¾è®¡ç­‰é¢†åŸŸæœ‰å¹¿æ³›åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹æ’åˆ—ç»„åˆçš„åŸºç¡€ç†è®ºä½“ç³»**
2. **ç ”ç©¶æ’åˆ—å’Œç»„åˆçš„è®¡ç®—æ–¹æ³•**
3. **å‘å±•æ’åˆ—ç»„åˆçš„ç®—æ³•å®ç°**
4. **æ¢ç´¢æ’åˆ—ç»„åˆåœ¨å®é™…é—®é¢˜ä¸­çš„åº”ç”¨**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ’åˆ—å®šä¹‰

ä» $n$ ä¸ªä¸åŒå…ƒç´ ä¸­å–å‡º $r$ ä¸ªå…ƒç´ ï¼ŒæŒ‰ç…§ä¸€å®šé¡ºåºæ’åˆ—ï¼Œç§°ä¸º**æ’åˆ—**ï¼Œè®°ä½œ $P(n, r)$ æˆ– $A(n, r)$ã€‚

### 1.2 ç»„åˆå®šä¹‰

ä» $n$ ä¸ªä¸åŒå…ƒç´ ä¸­å–å‡º $r$ ä¸ªå…ƒç´ ï¼Œä¸è€ƒè™‘é¡ºåºï¼Œç§°ä¸º**ç»„åˆ**ï¼Œè®°ä½œ $C(n, r)$ æˆ– $\binom{n}{r}$ã€‚

### 1.3 æ’åˆ—æ•°å…¬å¼

$$P(n, r) = \frac{n!}{(n-r)!} = n \times (n-1) \times \cdots \times (n-r+1)$$

### 1.4 ç»„åˆæ•°å…¬å¼

$$C(n, r) = \binom{n}{r} = \frac{n!}{r!(n-r)!} = \frac{P(n, r)}{r!}$$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ’åˆ—çš„å½¢å¼åŒ–å®šä¹‰

å¯¹äºé›†åˆ $S$ å’Œæ­£æ•´æ•° $r \leq |S|$ï¼Œå®šä¹‰ $r$ æ’åˆ—ä¸ºï¼š

$$\text{Perm}(S, r) = \{(a_1, a_2, \ldots, a_r) \mid a_i \in S, a_i \neq a_j \text{ for } i \neq j\}$$

æ’åˆ—æ•°ä¸ºï¼š

$$P(|S|, r) = |\text{Perm}(S, r)|$$

### 2.2 ç»„åˆçš„å½¢å¼åŒ–å®šä¹‰

å¯¹äºé›†åˆ $S$ å’Œæ­£æ•´æ•° $r \leq |S|$ï¼Œå®šä¹‰ $r$ ç»„åˆä¸ºï¼š

$$\text{Comb}(S, r) = \{A \subseteq S \mid |A| = r\}$$

ç»„åˆæ•°ä¸ºï¼š

$$C(|S|, r) = |\text{Comb}(S, r)|$$

### 2.3 å¤šé‡æ’åˆ—å®šä¹‰

å¯¹äºå¤šé‡é›† $M = \{a_1^{n_1}, a_2^{n_2}, \ldots, a_k^{n_k}\}$ï¼Œå¤šé‡æ’åˆ—æ•°ä¸ºï¼š

$$\frac{n!}{n_1! n_2! \cdots n_k!}$$

å…¶ä¸­ $n = n_1 + n_2 + \cdots + n_k$ã€‚

### 2.4 å¤šé‡ç»„åˆå®šä¹‰

ä» $n$ ç§ä¸åŒå…ƒç´ ä¸­ï¼Œæ¯ç§å…ƒç´ å¯ä»¥é‡å¤é€‰æ‹©ï¼Œå– $r$ ä¸ªå…ƒç´ çš„ç»„åˆæ•°ä¸ºï¼š

$$\binom{n + r - 1}{r}$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 æ’åˆ—æ•°çš„é€’æ¨å…³ç³»

**å®šç† 3.1.1**ï¼šæ’åˆ—æ•°æ»¡è¶³é€’æ¨å…³ç³»ï¼š

$$P(n, r) = n \times P(n-1, r-1)$$

**è¯æ˜**ï¼š
è€ƒè™‘ç¬¬ä¸€ä¸ªä½ç½®çš„é€‰æ‹©ï¼Œæœ‰ $n$ ç§é€‰æ‹©ã€‚å¯¹äºæ¯ç§é€‰æ‹©ï¼Œå‰©ä¸‹çš„ $r-1$ ä¸ªä½ç½®éœ€è¦ä» $n-1$ ä¸ªå…ƒç´ ä¸­é€‰æ‹©ï¼Œå³ $P(n-1, r-1)$ã€‚

å› æ­¤æ€»æ•°ä¸ºï¼š$n \times P(n-1, r-1)$ã€‚

### 3.2 ç»„åˆæ•°çš„é€’æ¨å…³ç³»

**å®šç† 3.2.1**ï¼šç»„åˆæ•°æ»¡è¶³é€’æ¨å…³ç³»ï¼š

$$\binom{n}{r} = \binom{n-1}{r} + \binom{n-1}{r-1}$$

**è¯æ˜**ï¼š
è€ƒè™‘å…ƒç´  $a_n$ æ˜¯å¦è¢«é€‰ä¸­ï¼š

1. å¦‚æœ $a_n$ ä¸è¢«é€‰ä¸­ï¼Œåˆ™éœ€è¦ä» $n-1$ ä¸ªå…ƒç´ ä¸­é€‰æ‹© $r$ ä¸ªï¼Œå³ $\binom{n-1}{r}$
2. å¦‚æœ $a_n$ è¢«é€‰ä¸­ï¼Œåˆ™éœ€è¦ä» $n-1$ ä¸ªå…ƒç´ ä¸­é€‰æ‹© $r-1$ ä¸ªï¼Œå³ $\binom{n-1}{r-1}$

å› æ­¤æ€»æ•°ä¸ºï¼š$\binom{n-1}{r} + \binom{n-1}{r-1}$ã€‚

### 3.3 äºŒé¡¹å¼å®šç†

**å®šç† 3.3.1** (äºŒé¡¹å¼å®šç†)ï¼šå¯¹äºä»»æ„å®æ•° $a, b$ å’Œéè´Ÿæ•´æ•° $n$ï¼Œæœ‰ï¼š

$$(a + b)^n = \sum_{k=0}^n \binom{n}{k} a^{n-k} b^k$$

**è¯æ˜**ï¼š
ä½¿ç”¨æ•°å­¦å½’çº³æ³•ï¼š
- åŸºç¡€æƒ…å†µï¼š$n = 0$ æ—¶ï¼Œ$(a + b)^0 = 1 = \binom{0}{0} a^0 b^0$
- å½’çº³å‡è®¾ï¼šå‡è®¾å¯¹äº $n = k$ æˆç«‹
- å½’çº³æ­¥éª¤ï¼šå¯¹äº $n = k + 1$ï¼Œ
  $$(a + b)^{k+1} = (a + b)(a + b)^k = (a + b)\sum_{i=0}^k \binom{k}{i} a^{k-i} b^i$$
  å±•å¼€åä½¿ç”¨ç»„åˆæ•°çš„é€’æ¨å…³ç³»å³å¯å¾—åˆ°ç»“æœã€‚

### 3.4 èŒƒå¾·è’™å¾·æ’ç­‰å¼

**å®šç† 3.4.1** (èŒƒå¾·è’™å¾·æ’ç­‰å¼)ï¼šå¯¹äºéè´Ÿæ•´æ•° $m, n, r$ï¼Œæœ‰ï¼š

$$\sum_{k=0}^r \binom{m}{k} \binom{n}{r-k} = \binom{m+n}{r}$$

**è¯æ˜**ï¼š
è€ƒè™‘ä» $m$ ä¸ªçº¢çƒå’Œ $n$ ä¸ªè“çƒä¸­é€‰æ‹© $r$ ä¸ªçƒçš„æ–¹æ³•æ•°ã€‚

å·¦è¾¹ï¼šæšä¸¾é€‰æ‹© $k$ ä¸ªçº¢çƒå’Œ $r-k$ ä¸ªè“çƒçš„æ–¹æ³•æ•°
å³è¾¹ï¼šç›´æ¥ä» $m+n$ ä¸ªçƒä¸­é€‰æ‹© $r$ ä¸ªçš„æ–¹æ³•æ•°

ä¸¤è€…ç›¸ç­‰ï¼Œå› æ­¤æ’ç­‰å¼æˆç«‹ã€‚

### 3.5 å¤šé‡ç»„åˆçš„ç”Ÿæˆ

**å®šç† 3.5.1**ï¼šå¤šé‡ç»„åˆçš„ç”Ÿæˆå¯ä»¥é€šè¿‡"æ˜Ÿå’Œæ¡"æ–¹æ³•å®ç°ã€‚

**è¯æ˜**ï¼š
å°† $r$ ä¸ªç›¸åŒçš„çƒæ”¾å…¥ $n$ ä¸ªä¸åŒçš„ç›’å­ä¸­ï¼Œç­‰ä»·äºåœ¨ $r$ ä¸ªæ˜Ÿå’Œ $n-1$ ä¸ªæ¡ä¹‹é—´é€‰æ‹© $r$ ä¸ªä½ç½®æ”¾ç½®æ˜Ÿã€‚

å› æ­¤æ–¹æ³•æ•°ä¸ºï¼š$\binom{r + n - 1}{r} = \binom{n + r - 1}{r}$ã€‚

## 4. ä»£ç å®ç°

### 4.1 Rustå®ç°

```rust
use std::collections::HashSet;

/// æ’åˆ—ç»„åˆç†è®ºå®ç°
pub struct PermutationCombination;

impl PermutationCombination {
    /// è®¡ç®—æ’åˆ—æ•° P(n, r)
    pub fn permutation_count(n: usize, r: usize) -> usize {
        if r > n {
            return 0;
        }
        
        let mut result = 1;
        for i in 0..r {
            result *= n - i;
        }
        result
    }
    
    /// è®¡ç®—ç»„åˆæ•° C(n, r)
    pub fn combination_count(n: usize, r: usize) -> usize {
        if r > n {
            return 0;
        }
        
        if r > n / 2 {
            return Self::combination_count(n, n - r);
        }
        
        let mut result = 1;
        for i in 0..r {
            result = result * (n - i) / (i + 1);
        }
        result
    }
    
    /// è®¡ç®—å¤šé‡æ’åˆ—æ•°
    pub fn multiset_permutation_count(counts: &[usize]) -> usize {
        let total: usize = counts.iter().sum();
        let mut result = Self::factorial(total);
        
        for &count in counts {
            if count > 1 {
                result /= Self::factorial(count);
            }
        }
        
        result
    }
    
    /// è®¡ç®—å¤šé‡ç»„åˆæ•°
    pub fn multiset_combination_count(n: usize, r: usize) -> usize {
        Self::combination_count(n + r - 1, r)
    }
    
    /// è®¡ç®—é˜¶ä¹˜
    pub fn factorial(n: usize) -> usize {
        if n <= 1 {
            1
        } else {
            n * Self::factorial(n - 1)
        }
    }
    
    /// ç”Ÿæˆæ‰€æœ‰æ’åˆ—
    pub fn generate_permutations<T: Clone + Eq + std::hash::Hash>(items: &[T], r: usize) -> Vec<Vec<T>> {
        if r == 0 {
            return vec![vec![]];
        }
        
        if r > items.len() {
            return vec![];
        }
        
        let mut result = Vec::new();
        Self::generate_permutations_helper(items, r, &mut vec![], &mut vec![false; items.len()], &mut result);
        result
    }
    
    /// ç”Ÿæˆæ’åˆ—çš„è¾…åŠ©å‡½æ•°
    fn generate_permutations_helper<T: Clone + Eq + std::hash::Hash>(
        items: &[T],
        r: usize,
        current: &mut Vec<T>,
        used: &mut [bool],
        result: &mut Vec<Vec<T>>
    ) {
        if current.len() == r {
            result.push(current.clone());
            return;
        }
        
        for i in 0..items.len() {
            if !used[i] {
                used[i] = true;
                current.push(items[i].clone());
                Self::generate_permutations_helper(items, r, current, used, result);
                current.pop();
                used[i] = false;
            }
        }
    }
    
    /// ç”Ÿæˆæ‰€æœ‰ç»„åˆ
    pub fn generate_combinations<T: Clone + Eq + std::hash::Hash>(items: &[T], r: usize) -> Vec<Vec<T>> {
        if r == 0 {
            return vec![vec![]];
        }
        
        if r > items.len() {
            return vec![];
        }
        
        let mut result = Vec::new();
        Self::generate_combinations_helper(items, r, 0, &mut vec![], &mut result);
        result
    }
    
    /// ç”Ÿæˆç»„åˆçš„è¾…åŠ©å‡½æ•°
    fn generate_combinations_helper<T: Clone + Eq + std::hash::Hash>(
        items: &[T],
        r: usize,
        start: usize,
        current: &mut Vec<T>,
        result: &mut Vec<Vec<T>>
    ) {
        if current.len() == r {
            result.push(current.clone());
            return;
        }
        
        for i in start..items.len() {
            current.push(items[i].clone());
            Self::generate_combinations_helper(items, r, i + 1, current, result);
            current.pop();
        }
    }
    
    /// ç”Ÿæˆå¤šé‡ç»„åˆ
    pub fn generate_multiset_combinations<T: Clone + Eq + std::hash::Hash>(items: &[T], r: usize) -> Vec<Vec<T>> {
        if r == 0 {
            return vec![vec![]];
        }
        
        let mut result = Vec::new();
        Self::generate_multiset_combinations_helper(items, r, 0, &mut vec![], &mut result);
        result
    }
    
    /// ç”Ÿæˆå¤šé‡ç»„åˆçš„è¾…åŠ©å‡½æ•°
    fn generate_multiset_combinations_helper<T: Clone + Eq + std::hash::Hash>(
        items: &[T],
        r: usize,
        start: usize,
        current: &mut Vec<T>,
        result: &mut Vec<Vec<T>>
    ) {
        if current.len() == r {
            result.push(current.clone());
            return;
        }
        
        for i in start..items.len() {
            current.push(items[i].clone());
            Self::generate_multiset_combinations_helper(items, r, i, current, result);
            current.pop();
        }
    }
    
    /// è®¡ç®—äºŒé¡¹å¼ç³»æ•°
    pub fn binomial_coefficient(n: usize, k: usize) -> usize {
        Self::combination_count(n, k)
    }
    
    /// è®¡ç®—å¤šé¡¹å¼ç³»æ•°
    pub fn multinomial_coefficient(n: usize, counts: &[usize]) -> usize {
        let sum: usize = counts.iter().sum();
        if sum != n {
            return 0;
        }
        
        let mut result = Self::factorial(n);
        for &count in counts {
            if count > 1 {
                result /= Self::factorial(count);
            }
        }
        
        result
    }
    
    /// è®¡ç®—æ–¯ç‰¹æ—æ•°ç¬¬äºŒç±» S(n, k)
    pub fn stirling_number_second_kind(n: usize, k: usize) -> usize {
        if k == 0 || k > n {
            return 0;
        }
        if k == 1 || k == n {
            return 1;
        }
        
        k * Self::stirling_number_second_kind(n - 1, k) + 
        Self::stirling_number_second_kind(n - 1, k - 1)
    }
    
    /// è®¡ç®—è´å°”æ•° B(n)
    pub fn bell_number(n: usize) -> usize {
        if n == 0 {
            return 1;
        }
        
        (0..n).map(|k| Self::combination_count(n - 1, k) * Self::bell_number(k)).sum()
    }
    
    /// è®¡ç®—å¡ç‰¹å…°æ•° C(n)
    pub fn catalan_number(n: usize) -> usize {
        if n <= 1 {
            return 1;
        }
        
        let mut result = 0;
        for i in 0..n {
            result += Self::catalan_number(i) * Self::catalan_number(n - 1 - i);
        }
        result
    }
    
    /// è®¡ç®—æ¬§æ‹‰æ•° E(n, k)
    pub fn euler_number(n: usize, k: usize) -> usize {
        if k == 0 {
            return 1;
        }
        if k >= n {
            return 0;
        }
        
        (k + 1) * Self::euler_number(n - 1, k) + 
        (n - k) * Self::euler_number(n - 1, k - 1)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_permutation_count() {
        assert_eq!(PermutationCombination::permutation_count(5, 3), 60);
        assert_eq!(PermutationCombination::permutation_count(4, 4), 24);
        assert_eq!(PermutationCombination::permutation_count(3, 5), 0);
    }
    
    #[test]
    fn test_combination_count() {
        assert_eq!(PermutationCombination::combination_count(5, 3), 10);
        assert_eq!(PermutationCombination::combination_count(4, 2), 6);
        assert_eq!(PermutationCombination::combination_count(3, 5), 0);
    }
    
    #[test]
    fn test_multiset_permutation_count() {
        let counts = vec![2, 1, 3]; // 2ä¸ªAï¼Œ1ä¸ªBï¼Œ3ä¸ªC
        let result = PermutationCombination::multiset_permutation_count(&counts);
        assert_eq!(result, 60); // 6! / (2! * 1! * 3!) = 720 / 12 = 60
    }
    
    #[test]
    fn test_multiset_combination_count() {
        assert_eq!(PermutationCombination::multiset_combination_count(3, 2), 6);
        assert_eq!(PermutationCombination::multiset_combination_count(2, 3), 4);
    }
    
    #[test]
    fn test_generate_permutations() {
        let items = vec!['a', 'b', 'c'];
        let permutations = PermutationCombination::generate_permutations(&items, 2);
        assert_eq!(permutations.len(), 6);
        
        let expected = vec![
            vec!['a', 'b'], vec!['a', 'c'], vec!['b', 'a'],
            vec!['b', 'c'], vec!['c', 'a'], vec!['c', 'b']
        ];
        
        for perm in expected {
            assert!(permutations.contains(&perm));
        }
    }
    
    #[test]
    fn test_generate_combinations() {
        let items = vec!['a', 'b', 'c'];
        let combinations = PermutationCombination::generate_combinations(&items, 2);
        assert_eq!(combinations.len(), 3);
        
        let expected = vec![
            vec!['a', 'b'], vec!['a', 'c'], vec!['b', 'c']
        ];
        
        for comb in expected {
            assert!(combinations.contains(&comb));
        }
    }
    
    #[test]
    fn test_binomial_coefficient() {
        assert_eq!(PermutationCombination::binomial_coefficient(5, 3), 10);
        assert_eq!(PermutationCombination::binomial_coefficient(4, 2), 6);
    }
    
    #[test]
    fn test_multinomial_coefficient() {
        let counts = vec![2, 1, 3];
        let result = PermutationCombination::multinomial_coefficient(6, &counts);
        assert_eq!(result, 60);
    }
    
    #[test]
    fn test_stirling_number() {
        assert_eq!(PermutationCombination::stirling_number_second_kind(4, 2), 7);
        assert_eq!(PermutationCombination::stirling_number_second_kind(5, 3), 25);
    }
    
    #[test]
    fn test_bell_number() {
        assert_eq!(PermutationCombination::bell_number(0), 1);
        assert_eq!(PermutationCombination::bell_number(1), 1);
        assert_eq!(PermutationCombination::bell_number(2), 2);
        assert_eq!(PermutationCombination::bell_number(3), 5);
        assert_eq!(PermutationCombination::bell_number(4), 15);
    }
    
    #[test]
    fn test_catalan_number() {
        assert_eq!(PermutationCombination::catalan_number(0), 1);
        assert_eq!(PermutationCombination::catalan_number(1), 1);
        assert_eq!(PermutationCombination::catalan_number(2), 2);
        assert_eq!(PermutationCombination::catalan_number(3), 5);
        assert_eq!(PermutationCombination::catalan_number(4), 14);
    }
    
    #[test]
    fn test_euler_number() {
        assert_eq!(PermutationCombination::euler_number(4, 1), 11);
        assert_eq!(PermutationCombination::euler_number(4, 2), 11);
        assert_eq!(PermutationCombination::euler_number(5, 2), 66);
    }
}
```

### 4.2 Haskellå®ç°

```haskell
module PermutationCombination where

import Data.List (subsequences, permutations, nub)

-- æ’åˆ—ç»„åˆç†è®ºå®ç°
class PermutationCombination a where
    permutationCount :: Int -> Int -> Int
    combinationCount :: Int -> Int -> Int
    multisetPermutationCount :: [Int] -> Int
    multisetCombinationCount :: Int -> Int -> Int
    factorial :: Int -> Int
    generatePermutations :: [a] -> Int -> [[a]]
    generateCombinations :: [a] -> Int -> [[a]]
    generateMultisetCombinations :: [a] -> Int -> [[a]]
    binomialCoefficient :: Int -> Int -> Int
    multinomialCoefficient :: Int -> [Int] -> Int
    stirlingNumberSecondKind :: Int -> Int -> Int
    bellNumber :: Int -> Int
    catalanNumber :: Int -> Int
    eulerNumber :: Int -> Int -> Int

instance PermutationCombination Int where
    -- è®¡ç®—æ’åˆ—æ•°
    permutationCount n r
        | r > n = 0
        | otherwise = product [n - i | i <- [0..r-1]]
    
    -- è®¡ç®—ç»„åˆæ•°
    combinationCount n r
        | r > n = 0
        | r > n `div` 2 = combinationCount n (n - r)
        | otherwise = product [n - i | i <- [0..r-1]] `div` product [1..r]
    
    -- è®¡ç®—å¤šé‡æ’åˆ—æ•°
    multisetPermutationCount counts = 
        factorial total `div` product (map factorial counts)
        where total = sum counts
    
    -- è®¡ç®—å¤šé‡ç»„åˆæ•°
    multisetCombinationCount n r = combinationCount (n + r - 1) r
    
    -- è®¡ç®—é˜¶ä¹˜
    factorial n
        | n <= 1 = 1
        | otherwise = n * factorial (n - 1)
    
    -- ç”Ÿæˆæ‰€æœ‰æ’åˆ—
    generatePermutations items r
        | r == 0 = [[]]
        | r > length items = []
        | otherwise = [take r perm | perm <- permutations items]
    
    -- ç”Ÿæˆæ‰€æœ‰ç»„åˆ
    generateCombinations items r
        | r == 0 = [[]]
        | r > length items = []
        | otherwise = [comb | comb <- subsequences items, length comb == r]
    
    -- ç”Ÿæˆå¤šé‡ç»„åˆ
    generateMultisetCombinations items r
        | r == 0 = [[]]
        | otherwise = generateMultisetCombinationsHelper items r 0
        where
            generateMultisetCombinationsHelper _ 0 _ = [[]]
            generateMultisetCombinationsHelper items r start = 
                concat [map (item:) (generateMultisetCombinationsHelper items (r-1) i) 
                       | (i, item) <- zip [start..] (drop start items)]
    
    -- è®¡ç®—äºŒé¡¹å¼ç³»æ•°
    binomialCoefficient n k = combinationCount n k
    
    -- è®¡ç®—å¤šé¡¹å¼ç³»æ•°
    multinomialCoefficient n counts
        | sum counts /= n = 0
        | otherwise = factorial n `div` product (map factorial counts)
    
    -- æ–¯ç‰¹æ—æ•°ç¬¬äºŒç±»
    stirlingNumberSecondKind n k
        | k == 0 || k > n = 0
        | k == 1 || k == n = 1
        | otherwise = k * stirlingNumberSecondKind (n - 1) k + 
                     stirlingNumberSecondKind (n - 1) (k - 1)
    
    -- è´å°”æ•°
    bellNumber n
        | n == 0 = 1
        | otherwise = sum [combinationCount (n - 1) k * bellNumber k | k <- [0..n-1]]
    
    -- å¡ç‰¹å…°æ•°
    catalanNumber n
        | n <= 1 = 1
        | otherwise = sum [catalanNumber i * catalanNumber (n - 1 - i) | i <- [0..n-1]]
    
    -- æ¬§æ‹‰æ•°
    eulerNumber n k
        | k == 0 = 1
        | k >= n = 0
        | otherwise = (k + 1) * eulerNumber (n - 1) k + 
                     (n - k) * eulerNumber (n - 1) (k - 1)

-- æµ‹è¯•å‡½æ•°
testPermutationCombination :: IO ()
testPermutationCombination = do
    putStrLn "Testing Permutation and Combination..."
    
    -- æµ‹è¯•æ’åˆ—æ•°
    putStrLn $ "P(5,3): " ++ show (permutationCount 5 3)
    putStrLn $ "P(4,4): " ++ show (permutationCount 4 4)
    putStrLn $ "P(3,5): " ++ show (permutationCount 3 5)
    
    -- æµ‹è¯•ç»„åˆæ•°
    putStrLn $ "C(5,3): " ++ show (combinationCount 5 3)
    putStrLn $ "C(4,2): " ++ show (combinationCount 4 2)
    putStrLn $ "C(3,5): " ++ show (combinationCount 3 5)
    
    -- æµ‹è¯•å¤šé‡æ’åˆ—æ•°
    putStrLn $ "Multiset permutation [2,1,3]: " ++ show (multisetPermutationCount [2,1,3])
    
    -- æµ‹è¯•å¤šé‡ç»„åˆæ•°
    putStrLn $ "Multiset combination (3,2): " ++ show (multisetCombinationCount 3 2)
    putStrLn $ "Multiset combination (2,3): " ++ show (multisetCombinationCount 2 3)
    
    -- æµ‹è¯•ç”Ÿæˆæ’åˆ—
    let items = "abc"
    let perms = generatePermutations items 2
    putStrLn $ "Permutations of 'abc' with length 2: " ++ show perms
    putStrLn $ "Number of permutations: " ++ show (length perms)
    
    -- æµ‹è¯•ç”Ÿæˆç»„åˆ
    let combs = generateCombinations items 2
    putStrLn $ "Combinations of 'abc' with length 2: " ++ show combs
    putStrLn $ "Number of combinations: " ++ show (length combs)
    
    -- æµ‹è¯•äºŒé¡¹å¼ç³»æ•°
    putStrLn $ "Binomial coefficient (5,3): " ++ show (binomialCoefficient 5 3)
    putStrLn $ "Binomial coefficient (4,2): " ++ show (binomialCoefficient 4 2)
    
    -- æµ‹è¯•å¤šé¡¹å¼ç³»æ•°
    putStrLn $ "Multinomial coefficient (6,[2,1,3]): " ++ show (multinomialCoefficient 6 [2,1,3])
    
    -- æµ‹è¯•æ–¯ç‰¹æ—æ•°
    putStrLn $ "Stirling number S(4,2): " ++ show (stirlingNumberSecondKind 4 2)
    putStrLn $ "Stirling number S(5,3): " ++ show (stirlingNumberSecondKind 5 3)
    
    -- æµ‹è¯•è´å°”æ•°
    putStrLn $ "Bell number B(0): " ++ show (bellNumber 0)
    putStrLn $ "Bell number B(1): " ++ show (bellNumber 1)
    putStrLn $ "Bell number B(2): " ++ show (bellNumber 2)
    putStrLn $ "Bell number B(3): " ++ show (bellNumber 3)
    putStrLn $ "Bell number B(4): " ++ show (bellNumber 4)
    
    -- æµ‹è¯•å¡ç‰¹å…°æ•°
    putStrLn $ "Catalan number C(0): " ++ show (catalanNumber 0)
    putStrLn $ "Catalan number C(1): " ++ show (catalanNumber 1)
    putStrLn $ "Catalan number C(2): " ++ show (catalanNumber 2)
    putStrLn $ "Catalan number C(3): " ++ show (catalanNumber 3)
    putStrLn $ "Catalan number C(4): " ++ show (catalanNumber 4)
    
    -- æµ‹è¯•æ¬§æ‹‰æ•°
    putStrLn $ "Euler number E(4,1): " ++ show (eulerNumber 4 1)
    putStrLn $ "Euler number E(4,2): " ++ show (eulerNumber 4 2)
    putStrLn $ "Euler number E(5,2): " ++ show (eulerNumber 5 2)
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å¯†ç å­¦åº”ç”¨

æ’åˆ—ç»„åˆåœ¨å¯†ç å­¦ä¸­çš„åº”ç”¨ï¼š

```rust
use rand::Rng;

pub struct CryptographicPermutations;

impl CryptographicPermutations {
    /// ç”Ÿæˆéšæœºæ’åˆ—
    pub fn generate_random_permutation(n: usize) -> Vec<usize> {
        let mut rng = rand::thread_rng();
        let mut permutation: Vec<usize> = (0..n).collect();
        
        // Fisher-Yates æ´—ç‰Œç®—æ³•
        for i in (1..n).rev() {
            let j = rng.gen_range(0..=i);
            permutation.swap(i, j);
        }
        
        permutation
    }
    
    /// è®¡ç®—æ’åˆ—çš„é€†
    pub fn inverse_permutation(permutation: &[usize]) -> Vec<usize> {
        let n = permutation.len();
        let mut inverse = vec![0; n];
        
        for i in 0..n {
            inverse[permutation[i]] = i;
        }
        
        inverse
    }
    
    /// è®¡ç®—æ’åˆ—çš„ç¬¦å·
    pub fn permutation_sign(permutation: &[usize]) -> i32 {
        let mut sign = 1;
        let n = permutation.len();
        let mut visited = vec![false; n];
        
        for i in 0..n {
            if !visited[i] {
                let mut cycle_length = 0;
                let mut current = i;
                
                while !visited[current] {
                    visited[current] = true;
                    current = permutation[current];
                    cycle_length += 1;
                }
                
                if cycle_length % 2 == 0 {
                    sign *= -1;
                }
            }
        }
        
        sign
    }
    
    /// ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„å¯†é’¥ç»„åˆ
    pub fn generate_key_combinations(alphabet: &[char], key_length: usize) -> Vec<String> {
        let combinations = PermutationCombination::generate_combinations(alphabet, key_length);
        combinations.into_iter().map(|comb| comb.into_iter().collect()).collect()
    }
    
    /// è®¡ç®—å¯†é’¥ç©ºé—´å¤§å°
    pub fn key_space_size(alphabet_size: usize, key_length: usize) -> usize {
        PermutationCombination::permutation_count(alphabet_size, key_length)
    }
    
    /// ç”Ÿæˆéšæœºå­é›†
    pub fn generate_random_subset<T: Clone>(items: &[T], subset_size: usize) -> Vec<T> {
        let mut rng = rand::thread_rng();
        let mut items = items.to_vec();
        
        // Fisher-Yates æ´—ç‰Œç®—æ³•
        for i in (1..items.len()).rev() {
            let j = rng.gen_range(0..=i);
            items.swap(i, j);
        }
        
        items.into_iter().take(subset_size).collect()
    }
}

pub struct CombinatorialCryptanalysis;

impl CombinatorialCryptanalysis {
    /// æš´åŠ›ç ´è§£å¯†é’¥ç©ºé—´å¤§å°
    pub fn brute_force_complexity(alphabet_size: usize, key_length: usize) -> usize {
        PermutationCombination::permutation_count(alphabet_size, key_length)
    }
    
    /// ç”Ÿæ—¥æ”»å‡»å¤æ‚åº¦
    pub fn birthday_attack_complexity(space_size: usize) -> usize {
        ((2.0 * space_size as f64).sqrt() * 1.177) as usize
    }
    
    /// è®¡ç®—ç¢°æ’æ¦‚ç‡
    pub fn collision_probability(space_size: usize, num_samples: usize) -> f64 {
        if num_samples > space_size {
            return 1.0;
        }
        
        let mut probability = 1.0;
        for i in 0..num_samples {
            probability *= (space_size - i) as f64 / space_size as f64;
        }
        
        1.0 - probability
    }
    
    /// è®¡ç®—å­é›†å’Œé—®é¢˜çš„è§£çš„æ•°é‡
    pub fn subset_sum_solutions(numbers: &[i32], target: i32) -> usize {
        let n = numbers.len();
        let mut count = 0;
        
        // ä½¿ç”¨ä½æ©ç ç”Ÿæˆæ‰€æœ‰å­é›†
        for mask in 0..(1 << n) {
            let mut sum = 0;
            for i in 0..n {
                if mask & (1 << i) != 0 {
                    sum += numbers[i];
                }
            }
            if sum == target {
                count += 1;
            }
        }
        
        count
    }
}
```

### 5.2 ç®—æ³•è®¾è®¡åº”ç”¨

```rust
pub struct AlgorithmicPermutations;

impl AlgorithmicPermutations {
    /// ç”Ÿæˆä¸‹ä¸€ä¸ªæ’åˆ—ï¼ˆå­—å…¸åºï¼‰
    pub fn next_permutation<T: Ord>(permutation: &mut [T]) -> bool {
        let n = permutation.len();
        
        // æ‰¾åˆ°ç¬¬ä¸€ä¸ªé€’å‡çš„ä½ç½®
        let mut i = n - 2;
        while i < n && permutation[i] >= permutation[i + 1] {
            i = i.wrapping_sub(1);
        }
        
        if i >= n {
            return false; // å·²ç»æ˜¯æœ€åä¸€ä¸ªæ’åˆ—
        }
        
        // æ‰¾åˆ°å¤§äº permutation[i] çš„æœ€å°å…ƒç´ 
        let mut j = n - 1;
        while permutation[j] <= permutation[i] {
            j -= 1;
        }
        
        // äº¤æ¢
        permutation.swap(i, j);
        
        // åè½¬åç¼€
        permutation[i + 1..].reverse();
        
        true
    }
    
    /// ç”Ÿæˆæ‰€æœ‰æ’åˆ—ï¼ˆå­—å…¸åºï¼‰
    pub fn generate_all_permutations<T: Clone + Ord>(items: &[T]) -> Vec<Vec<T>> {
        let mut permutation: Vec<T> = items.to_vec();
        permutation.sort();
        
        let mut result = vec![permutation.clone()];
        
        while Self::next_permutation(&mut permutation) {
            result.push(permutation.clone());
        }
        
        result
    }
    
    /// ç”Ÿæˆä¸‹ä¸€ä¸ªç»„åˆï¼ˆå­—å…¸åºï¼‰
    pub fn next_combination(combination: &mut [usize], n: usize) -> bool {
        let k = combination.len();
        
        // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¯ä»¥å¢åŠ çš„ä½ç½®
        let mut i = k - 1;
        while i < k && combination[i] == n - k + i {
            i = i.wrapping_sub(1);
        }
        
        if i >= k {
            return false; // å·²ç»æ˜¯æœ€åä¸€ä¸ªç»„åˆ
        }
        
        // å¢åŠ å½“å‰ä½ç½®
        combination[i] += 1;
        
        // æ›´æ–°åé¢çš„ä½ç½®
        for j in i + 1..k {
            combination[j] = combination[j - 1] + 1;
        }
        
        true
    }
    
    /// ç”Ÿæˆæ‰€æœ‰ç»„åˆï¼ˆå­—å…¸åºï¼‰
    pub fn generate_all_combinations(n: usize, k: usize) -> Vec<Vec<usize>> {
        if k > n {
            return vec![];
        }
        
        let mut combination: Vec<usize> = (0..k).collect();
        let mut result = vec![combination.clone()];
        
        while Self::next_combination(&mut combination, n) {
            result.push(combination.clone());
        }
        
        result
    }
    
    /// è®¡ç®—æ’åˆ—çš„é€†åºæ•°
    pub fn inversion_count<T: Ord>(permutation: &[T]) -> usize {
        let mut count = 0;
        let n = permutation.len();
        
        for i in 0..n {
            for j in i + 1..n {
                if permutation[i] > permutation[j] {
                    count += 1;
                }
            }
        }
        
        count
    }
    
    /// è®¡ç®—æ’åˆ—çš„å¾ªç¯æ•°
    pub fn cycle_count(permutation: &[usize]) -> usize {
        let n = permutation.len();
        let mut visited = vec![false; n];
        let mut cycles = 0;
        
        for i in 0..n {
            if !visited[i] {
                cycles += 1;
                let mut current = i;
                while !visited[current] {
                    visited[current] = true;
                    current = permutation[current];
                }
            }
        }
        
        cycles
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸è®¡æ•°åŸç†çš„å…³ç³»

æ’åˆ—ç»„åˆæ˜¯è®¡æ•°åŸç†çš„å…·ä½“åº”ç”¨ï¼Œä¸ºè®¡ç®—æœ‰é™é›†åˆä¸­çš„é€‰æ‹©é—®é¢˜æä¾›æ–¹æ³•ã€‚

### 6.2 ä¸æ¦‚ç‡è®ºçš„å…³ç³»

æ’åˆ—ç»„åˆåœ¨æ¦‚ç‡è®ºä¸­ç”¨äºè®¡ç®—æ ·æœ¬ç©ºé—´çš„å¤§å°å’Œäº‹ä»¶å‘ç”Ÿçš„å¯èƒ½æ€§ã€‚

### 6.3 ä¸å›¾è®ºçš„å…³ç³»

æ’åˆ—ç»„åˆåœ¨å›¾è®ºä¸­ç”¨äºè®¡ç®—è·¯å¾„æ•°é‡ã€åŒ¹é…æ•°é‡ç­‰ç»„åˆé—®é¢˜ã€‚

### 6.4 ä¸ä»£æ•°ç»„åˆçš„å…³ç³»

æ’åˆ—ç»„åˆåœ¨ä»£æ•°ç»„åˆä¸­ç”¨äºç ”ç©¶ç”Ÿæˆå‡½æ•°å’Œç»„åˆæ’ç­‰å¼ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Brualdi, R. A. (2010). Introductory Combinatorics. Pearson.
2. Stanley, R. P. (2011). Enumerative Combinatorics. Cambridge University Press.
3. Graham, R. L., Knuth, D. E., & Patashnik, O. (1994). Concrete Mathematics. Addison-Wesley.
4. Aigner, M. (2007). A Course in Enumeration. Springer.
5. Wilf, H. S. (2006). Generatingfunctionology. A K Peters.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [02.11.1 è®¡æ•°åŸç†](../02.11.1_è®¡æ•°åŸç†.md)
- [02.11.3 ç”Ÿæˆå‡½æ•°](../02.11.3_ç”Ÿæˆå‡½æ•°.md)
- [02.11.4 å›¾è®ºåŸºç¡€](../02.11.4_å›¾è®ºåŸºç¡€.md)
- [02.10.1 æ•´é™¤ç†è®º](../02.10.1_æ•´é™¤ç†è®º.md) 