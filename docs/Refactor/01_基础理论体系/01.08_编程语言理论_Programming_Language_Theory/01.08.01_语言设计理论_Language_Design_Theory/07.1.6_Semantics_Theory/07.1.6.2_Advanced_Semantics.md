# è¯­ä¹‰ç†è®º (Semantics Theory)

## ğŸ“‹ ç›®å½•

- [è¯­ä¹‰ç†è®º (Semantics Theory)](#è¯­ä¹‰ç†è®º-semantics-theory)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2 ç†è®ºåŸºç¡€](#2-ç†è®ºåŸºç¡€)
    - [2.1 å½¢å¼åŒ–å®šä¹‰](#21-å½¢å¼åŒ–å®šä¹‰)
  - [3 æ“ä½œè¯­ä¹‰ (Operational Semantics)](#3-æ“ä½œè¯­ä¹‰-operational-semantics)
    - [3.1 å°æ­¥è¯­ä¹‰ (Small-Step Semantics)](#31-å°æ­¥è¯­ä¹‰-small-step-semantics)
    - [3.2 å¤§æ­¥è¯­ä¹‰ (Big-Step Semantics)](#32-å¤§æ­¥è¯­ä¹‰-big-step-semantics)
  - [4 æŒ‡ç§°è¯­ä¹‰ (Denotational Semantics)](#4-æŒ‡ç§°è¯­ä¹‰-denotational-semantics)
    - [4.1 è¯­ä¹‰åŸŸç†è®º](#41-è¯­ä¹‰åŸŸç†è®º)
  - [5 å…¬ç†è¯­ä¹‰ (Axiomatic Semantics)](#5-å…¬ç†è¯­ä¹‰-axiomatic-semantics)
    - [5.1 Hoareé€»è¾‘](#51-hoareé€»è¾‘)
  - [6 è¯­ä¹‰ç­‰ä»·æ€§](#6-è¯­ä¹‰ç­‰ä»·æ€§)
    - [6.1 ç­‰ä»·æ€§è¯æ˜](#61-ç­‰ä»·æ€§è¯æ˜)
  - [7 å½¢å¼åŒ–éªŒè¯](#7-å½¢å¼åŒ–éªŒè¯)
    - [7.1 è¯­ä¹‰ä¿æŒæ€§è¯æ˜](#71-è¯­ä¹‰ä¿æŒæ€§è¯æ˜)
  - [8 æ€»ç»“](#8-æ€»ç»“)
  - [å‚è€ƒæ–‡çŒ®](#å‚è€ƒæ–‡çŒ®)
  - [9 ç›¸å…³é“¾æ¥](#9-ç›¸å…³é“¾æ¥)
  - [10 æ‰¹åˆ¤æ€§åˆ†æ](#10-æ‰¹åˆ¤æ€§åˆ†æ)

---

## 1 æ¦‚è¿°

è¯­ä¹‰ç†è®ºç ”ç©¶ç¼–ç¨‹è¯­è¨€çš„å½¢å¼åŒ–è¯­ä¹‰ï¼Œä¸ºç¨‹åºè¡Œä¸ºæä¾›ç²¾ç¡®çš„æ•°å­¦æè¿°ã€‚æœ¬æ–‡æ¡£ç³»ç»ŸåŒ–é˜è¿°æ“ä½œè¯­ä¹‰ã€æŒ‡ç§°è¯­ä¹‰å’Œå…¬ç†è¯­ä¹‰ä¸‰å¤§è¯­ä¹‰å­¦æ–¹æ³•ã€‚

## 2 ç†è®ºåŸºç¡€

### 2.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 9.4.1 (è¯­ä¹‰å‡½æ•°)** è¯­ä¹‰å‡½æ•°æ˜¯ä¸€ä¸ªæ˜ å°„ $\llbracket \cdot \rrbracket: Prog \rightarrow D$ï¼Œå…¶ä¸­ï¼š

- $Prog$ æ˜¯ç¨‹åºé›†åˆ
- $D$ æ˜¯è¯­ä¹‰åŸŸ
- $\llbracket P \rrbracket$ è¡¨ç¤ºç¨‹åº $P$ çš„è¯­ä¹‰

**å®šä¹‰ 9.4.2 (è¯­ä¹‰ç­‰ä»·)** ä¸¤ä¸ªç¨‹åº $P_1$ å’Œ $P_2$ è¯­ä¹‰ç­‰ä»·å½“ä¸”ä»…å½“ï¼š
$$\llbracket P_1 \rrbracket = \llbracket P_2 \rrbracket$$

## 3 æ“ä½œè¯­ä¹‰ (Operational Semantics)

### 3.1 å°æ­¥è¯­ä¹‰ (Small-Step Semantics)

**å®šä¹‰ 9.4.3 (å°æ­¥è¯­ä¹‰)** å°æ­¥è¯­ä¹‰æ˜¯ä¸€ä¸ªå…³ç³» $\rightarrow \subseteq Conf \times Conf$ï¼Œå…¶ä¸­ï¼š

- $Conf$ æ˜¯é…ç½®é›†åˆ
- é…ç½®æ˜¯ç¨‹åºçŠ¶æ€å’Œç¯å¢ƒçš„å¯¹å¶

**å®šç† 9.4.1 (ç¡®å®šæ€§)** å¦‚æœ $\rightarrow$ æ˜¯ç¡®å®šæ€§çš„ï¼Œåˆ™ï¼š
$$\forall c, c_1, c_2: c \rightarrow c_1 \land c \rightarrow c_2 \Rightarrow c_1 = c_2$$

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum Value {
    Int(i64),
    Bool(bool),
    String(String),
    Closure {
        params: Vec<String>,
        body: Box<Expr>,
        env: Environment,
    },
}

#[derive(Debug, Clone)]
pub struct Environment {
    bindings: HashMap<String, Value>,
    parent: Option<Box<Environment>>,
}

impl Environment {
    pub fn new() -> Self {
        Self {
            bindings: HashMap::new(),
            parent: None,
        }
    }

    pub fn extend(&self, bindings: HashMap<String, Value>) -> Self {
        Self {
            bindings,
            parent: Some(Box::new(self.clone())),
        }
    }

    pub fn get(&self, name: &str) -> Option<Value> {
        self.bindings.get(name).cloned().or_else(|| {
            self.parent.as_ref().and_then(|p| p.get(name))
        })
    }

    pub fn set(&mut self, name: String, value: Value) {
        self.bindings.insert(name, value);
    }
}

#[derive(Debug, Clone)]
pub enum Expr {
    Literal(Value),
    Variable(String),
    BinaryOp {
        op: String,
        left: Box<Expr>,
        right: Box<Expr>,
    },
    If {
        condition: Box<Expr>,
        then_branch: Box<Expr>,
        else_branch: Box<Expr>,
    },
    Let {
        name: String,
        value: Box<Expr>,
        body: Box<Expr>,
    },
    Lambda {
        params: Vec<String>,
        body: Box<Expr>,
    },
    Apply {
        func: Box<Expr>,
        args: Vec<Expr>,
    },
}

pub struct SmallStepSemantics;

impl SmallStepSemantics {
    pub fn step(expr: &Expr, env: &Environment) -> Result<Option<(Expr, Environment)>, String> {
        match expr {
            Expr::Literal(_) => Ok(None), // å€¼æ— æ³•ç»§ç»­æ±‚å€¼
            Expr::Variable(name) => {
                match env.get(name) {
                    Some(value) => Ok(Some((Expr::Literal(value), env.clone()))),
                    None => Err(format!("Undefined variable: {}", name)),
                }
            }
            Expr::BinaryOp { op, left, right } => {
                match (left.as_ref(), right.as_ref()) {
                    (Expr::Literal(Value::Int(l)), Expr::Literal(Value::Int(r))) => {
                        let result = match op.as_str() {
                            "+" => Value::Int(l + r),
                            "-" => Value::Int(l - r),
                            "*" => Value::Int(l * r),
                            "/" => {
                                if *r == 0 {
                                    return Err("Division by zero".to_string());
                                }
                                Value::Int(l / r)
                            }
                            "==" => Value::Bool(l == r),
                            "!=" => Value::Bool(l != r),
                            "<" => Value::Bool(l < r),
                            ">" => Value::Bool(l > r),
                            "<=" => Value::Bool(l <= r),
                            ">=" => Value::Bool(l >= r),
                            _ => return Err(format!("Unknown operator: {}", op)),
                        };
                        Ok(Some((Expr::Literal(result), env.clone())))
                    }
                    (Expr::Literal(Value::Bool(l)), Expr::Literal(Value::Bool(r))) => {
                        let result = match op.as_str() {
                            "&&" => Value::Bool(*l && *r),
                            "||" => Value::Bool(*l || *r),
                            _ => return Err(format!("Invalid boolean operator: {}", op)),
                        };
                        Ok(Some((Expr::Literal(result), env.clone())))
                    }
                    _ => {
                        // å…ˆæ±‚å€¼å·¦æ“ä½œæ•°
                        if let Some((new_left, _)) = Self::step(left, env)? {
                            let new_expr = Expr::BinaryOp {
                                op: op.clone(),
                                left: Box::new(new_left),
                                right: right.clone(),
                            };
                            Ok(Some((new_expr, env.clone())))
                        } else {
                            // å†æ±‚å€¼å³æ“ä½œæ•°
                            if let Some((new_right, _)) = Self::step(right, env)? {
                                let new_expr = Expr::BinaryOp {
                                    op: op.clone(),
                                    left: left.clone(),
                                    right: Box::new(new_right),
                                };
                                Ok(Some((new_expr, env.clone())))
                            } else {
                                Ok(None)
                            }
                        }
                    }
                }
            }
            Expr::If { condition, then_branch, else_branch } => {
                match condition.as_ref() {
                    Expr::Literal(Value::Bool(true)) => {
                        Ok(Some((*then_branch.clone(), env.clone())))
                    }
                    Expr::Literal(Value::Bool(false)) => {
                        Ok(Some((*else_branch.clone(), env.clone())))
                    }
                    _ => {
                        if let Some((new_condition, _)) = Self::step(condition, env)? {
                            let new_expr = Expr::If {
                                condition: Box::new(new_condition),
                                then_branch: then_branch.clone(),
                                else_branch: else_branch.clone(),
                            };
                            Ok(Some((new_expr, env.clone())))
                        } else {
                            Ok(None)
                        }
                    }
                }
            }
            Expr::Let { name, value, body } => {
                match value.as_ref() {
                    Expr::Literal(val) => {
                        let mut new_env = env.clone();
                        new_env.set(name.clone(), val.clone());
                        Ok(Some((*body.clone(), new_env)))
                    }
                    _ => {
                        if let Some((new_value, _)) = Self::step(value, env)? {
                            let new_expr = Expr::Let {
                                name: name.clone(),
                                value: Box::new(new_value),
                                body: body.clone(),
                            };
                            Ok(Some((new_expr, env.clone())))
                        } else {
                            Ok(None)
                        }
                    }
                }
            }
            Expr::Lambda { params, body } => {
                let closure = Value::Closure {
                    params: params.clone(),
                    body: body.clone(),
                    env: env.clone(),
                };
                Ok(Some((Expr::Literal(closure), env.clone())))
            }
            Expr::Apply { func, args } => {
                match func.as_ref() {
                    Expr::Literal(Value::Closure { params, body, env: closure_env }) => {
                        if args.len() != params.len() {
                            return Err("Argument count mismatch".to_string());
                        }

                        // æ£€æŸ¥æ‰€æœ‰å‚æ•°æ˜¯å¦å·²æ±‚å€¼
                        let mut evaluated_args = Vec::new();
                        let mut all_evaluated = true;

                        for arg in args {
                            match arg {
                                Expr::Literal(val) => evaluated_args.push(val.clone()),
                                _ => {
                                    all_evaluated = false;
                                    break;
                                }
                            }
                        }

                        if all_evaluated {
                            // åˆ›å»ºæ–°çš„ç¯å¢ƒ
                            let mut bindings = HashMap::new();
                            for (param, arg) in params.iter().zip(evaluated_args.iter()) {
                                bindings.insert(param.clone(), arg.clone());
                            }
                            let new_env = closure_env.extend(bindings);
                            Ok(Some((*body.clone(), new_env)))
                        } else {
                            // æ±‚å€¼å‚æ•°
                            for (i, arg) in args.iter().enumerate() {
                                if let Some((new_arg, _)) = Self::step(arg, env)? {
                                    let mut new_args = args.clone();
                                    new_args[i] = new_arg;
                                    let new_expr = Expr::Apply {
                                        func: func.clone(),
                                        args: new_args,
                                    };
                                    return Ok(Some((new_expr, env.clone())));
                                }
                            }
                            Ok(None)
                        }
                    }
                    _ => {
                        if let Some((new_func, _)) = Self::step(func, env)? {
                            let new_expr = Expr::Apply {
                                func: Box::new(new_func),
                                args: args.clone(),
                            };
                            Ok(Some((new_expr, env.clone())))
                        } else {
                            Ok(None)
                        }
                    }
                }
            }
        }
    }

    pub fn evaluate(expr: &Expr, env: &Environment) -> Result<Value, String> {
        let mut current_expr = expr.clone();
        let mut current_env = env.clone();

        loop {
            match Self::step(&current_expr, &current_env)? {
                Some((new_expr, new_env)) => {
                    current_expr = new_expr;
                    current_env = new_env;
                }
                None => {
                    if let Expr::Literal(value) = current_expr {
                        return Ok(value);
                    } else {
                        return Err("Evaluation stuck".to_string());
                    }
                }
            }
        }
    }
}
```

### 3.2 å¤§æ­¥è¯­ä¹‰ (Big-Step Semantics)

**å®šä¹‰ 9.4.4 (å¤§æ­¥è¯­ä¹‰)** å¤§æ­¥è¯­ä¹‰æ˜¯ä¸€ä¸ªå…³ç³» $\Downarrow \subseteq Conf \times Value$ï¼Œç›´æ¥æè¿°é…ç½®åˆ°å€¼çš„æ±‚å€¼ã€‚

**å®šç† 9.4.2 (å¤§æ­¥å°æ­¥ç­‰ä»·)** å¯¹äºæ‰€æœ‰è¡¨è¾¾å¼ $e$ å’Œç¯å¢ƒ $\rho$ï¼š
$$e, \rho \Downarrow v \Leftrightarrow e, \rho \rightarrow^* v$$

```rust
pub struct BigStepSemantics;

impl BigStepSemantics {
    pub fn evaluate(expr: &Expr, env: &Environment) -> Result<Value, String> {
        match expr {
            Expr::Literal(value) => Ok(value.clone()),
            Expr::Variable(name) => {
                env.get(name).ok_or_else(|| format!("Undefined variable: {}", name))
            }
            Expr::BinaryOp { op, left, right } => {
                let left_val = Self::evaluate(left, env)?;
                let right_val = Self::evaluate(right, env)?;

                match (left_val, right_val) {
                    (Value::Int(l), Value::Int(r)) => {
                        let result = match op.as_str() {
                            "+" => Value::Int(l + r),
                            "-" => Value::Int(l - r),
                            "*" => Value::Int(l * r),
                            "/" => {
                                if r == 0 {
                                    return Err("Division by zero".to_string());
                                }
                                Value::Int(l / r)
                            }
                            "==" => Value::Bool(l == r),
                            "!=" => Value::Bool(l != r),
                            "<" => Value::Bool(l < r),
                            ">" => Value::Bool(l > r),
                            "<=" => Value::Bool(l <= r),
                            ">=" => Value::Bool(l >= r),
                            _ => return Err(format!("Unknown operator: {}", op)),
                        };
                        Ok(result)
                    }
                    (Value::Bool(l), Value::Bool(r)) => {
                        let result = match op.as_str() {
                            "&&" => Value::Bool(l && r),
                            "||" => Value::Bool(l || r),
                            _ => return Err(format!("Invalid boolean operator: {}", op)),
                        };
                        Ok(result)
                    }
                    _ => Err("Type mismatch in binary operation".to_string()),
                }
            }
            Expr::If { condition, then_branch, else_branch } => {
                let condition_val = Self::evaluate(condition, env)?;
                match condition_val {
                    Value::Bool(true) => Self::evaluate(then_branch, env),
                    Value::Bool(false) => Self::evaluate(else_branch, env),
                    _ => Err("Condition must be boolean".to_string()),
                }
            }
            Expr::Let { name, value, body } => {
                let value_val = Self::evaluate(value, env)?;
                let mut new_env = env.clone();
                new_env.set(name.clone(), value_val);
                Self::evaluate(body, &new_env)
            }
            Expr::Lambda { params, body } => {
                let closure = Value::Closure {
                    params: params.clone(),
                    body: body.clone(),
                    env: env.clone(),
                };
                Ok(closure)
            }
            Expr::Apply { func, args } => {
                let func_val = Self::evaluate(func, env)?;
                match func_val {
                    Value::Closure { params, body, env: closure_env } => {
                        if args.len() != params.len() {
                            return Err("Argument count mismatch".to_string());
                        }

                        let mut arg_vals = Vec::new();
                        for arg in args {
                            arg_vals.push(Self::evaluate(arg, env)?);
                        }

                        let mut bindings = HashMap::new();
                        for (param, arg) in params.iter().zip(arg_vals.iter()) {
                            bindings.insert(param.clone(), arg.clone());
                        }
                        let new_env = closure_env.extend(bindings);
                        Self::evaluate(&body, &new_env)
                    }
                    _ => Err("Cannot apply non-function value".to_string()),
                }
            }
        }
    }
}
```

## 4 æŒ‡ç§°è¯­ä¹‰ (Denotational Semantics)

### 4.1 è¯­ä¹‰åŸŸç†è®º

**å®šä¹‰ 9.4.5 (è¯­ä¹‰åŸŸ)** è¯­ä¹‰åŸŸæ˜¯ä¸€ä¸ªå®Œå…¨ååºé›† $(D, \sqsubseteq)$ï¼Œå…¶ä¸­ï¼š

- $\sqsubseteq$ æ˜¯ååºå…³ç³»
- æ¯ä¸ªæœ‰å‘é›†éƒ½æœ‰æœ€å°ä¸Šç•Œ

**å®šä¹‰ 9.4.6 (è¿ç»­å‡½æ•°)** å‡½æ•° $f: D \rightarrow E$ æ˜¯è¿ç»­çš„å½“ä¸”ä»…å½“ï¼š
$$\forall X \subseteq D: f(\bigsqcup X) = \bigsqcup \{f(x) | x \in X\}$$

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub enum SemanticValue {
    Bottom,
    Int(i64),
    Bool(bool),
    String(String),
    Function(Box<dyn Fn(SemanticValue) -> SemanticValue>),
    Tuple(Vec<SemanticValue>),
}

impl PartialOrd for SemanticValue {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        match (self, other) {
            (SemanticValue::Bottom, _) => Some(std::cmp::Ordering::Less),
            (_, SemanticValue::Bottom) => Some(std::cmp::Ordering::Greater),
            (SemanticValue::Int(a), SemanticValue::Int(b)) => a.partial_cmp(b),
            (SemanticValue::Bool(a), SemanticValue::Bool(b)) => a.partial_cmp(b),
            (SemanticValue::String(a), SemanticValue::String(b)) => a.partial_cmp(b),
            _ => None,
        }
    }
}

pub struct DenotationalSemantics;

impl DenotationalSemantics {
    pub fn meaning(expr: &Expr, env: &HashMap<String, SemanticValue>) -> SemanticValue {
        match expr {
            Expr::Literal(value) => Self::value_to_semantic(value),
            Expr::Variable(name) => {
                env.get(name).cloned().unwrap_or(SemanticValue::Bottom)
            }
            Expr::BinaryOp { op, left, right } => {
                let left_val = Self::meaning(left, env);
                let right_val = Self::meaning(right, env);
                Self::apply_binary_op(op, left_val, right_val)
            }
            Expr::If { condition, then_branch, else_branch } => {
                let condition_val = Self::meaning(condition, env);
                match condition_val {
                    SemanticValue::Bool(true) => Self::meaning(then_branch, env),
                    SemanticValue::Bool(false) => Self::meaning(else_branch, env),
                    _ => SemanticValue::Bottom,
                }
            }
            Expr::Let { name, value, body } => {
                let value_val = Self::meaning(value, env);
                let mut new_env = env.clone();
                new_env.insert(name.clone(), value_val);
                Self::meaning(body, &new_env)
            }
            Expr::Lambda { params, body } => {
                let env_clone = env.clone();
                let body_clone = body.clone();
                let params_clone = params.clone();

                let func = move |arg: SemanticValue| {
                    let mut new_env = env_clone.clone();
                    if params_clone.len() == 1 {
                        new_env.insert(params_clone[0].clone(), arg);
                    } else {
                        // å¤„ç†å¤šå‚æ•°æƒ…å†µ
                        if let SemanticValue::Tuple(args) = arg {
                            for (param, arg_val) in params_clone.iter().zip(args.iter()) {
                                new_env.insert(param.clone(), arg_val.clone());
                            }
                        }
                    }
                    Self::meaning(&body_clone, &new_env)
                };

                SemanticValue::Function(Box::new(func))
            }
            Expr::Apply { func, args } => {
                let func_val = Self::meaning(func, env);
                match func_val {
                    SemanticValue::Function(f) => {
                        if args.len() == 1 {
                            let arg_val = Self::meaning(&args[0], env);
                            f(arg_val)
                        } else {
                            let arg_vals: Vec<SemanticValue> = args.iter()
                                .map(|arg| Self::meaning(arg, env))
                                .collect();
                            f(SemanticValue::Tuple(arg_vals))
                        }
                    }
                    _ => SemanticValue::Bottom,
                }
            }
        }
    }

    fn value_to_semantic(value: &Value) -> SemanticValue {
        match value {
            Value::Int(n) => SemanticValue::Int(*n),
            Value::Bool(b) => SemanticValue::Bool(*b),
            Value::String(s) => SemanticValue::String(s.clone()),
            Value::Closure { .. } => SemanticValue::Bottom, // ç®€åŒ–å¤„ç†
        }
    }

    fn apply_binary_op(op: &str, left: SemanticValue, right: SemanticValue) -> SemanticValue {
        match (left, right) {
            (SemanticValue::Int(l), SemanticValue::Int(r)) => {
                match op {
                    "+" => SemanticValue::Int(l + r),
                    "-" => SemanticValue::Int(l - r),
                    "*" => SemanticValue::Int(l * r),
                    "/" => {
                        if r == 0 {
                            SemanticValue::Bottom
                        } else {
                            SemanticValue::Int(l / r)
                        }
                    }
                    "==" => SemanticValue::Bool(l == r),
                    "!=" => SemanticValue::Bool(l != r),
                    "<" => SemanticValue::Bool(l < r),
                    ">" => SemanticValue::Bool(l > r),
                    "<=" => SemanticValue::Bool(l <= r),
                    ">=" => SemanticValue::Bool(l >= r),
                    _ => SemanticValue::Bottom,
                }
            }
            (SemanticValue::Bool(l), SemanticValue::Bool(r)) => {
                match op {
                    "&&" => SemanticValue::Bool(l && r),
                    "||" => SemanticValue::Bool(l || r),
                    _ => SemanticValue::Bottom,
                }
            }
            _ => SemanticValue::Bottom,
        }
    }
}
```

## 5 å…¬ç†è¯­ä¹‰ (Axiomatic Semantics)

### 5.1 Hoareé€»è¾‘

**å®šä¹‰ 9.4.7 (Hoareä¸‰å…ƒç»„)** Hoareä¸‰å…ƒç»„ $\{P\} C \{Q\}$ è¡¨ç¤ºï¼š

- å¦‚æœå‰ç½®æ¡ä»¶ $P$ åœ¨ç¨‹åº $C$ æ‰§è¡Œå‰æˆç«‹
- ä¸” $C$ ç»ˆæ­¢
- åˆ™åç½®æ¡ä»¶ $Q$ åœ¨ $C$ æ‰§è¡Œåæˆç«‹

**å®šç† 9.4.3 (èµ‹å€¼å…¬ç†)** å¯¹äºèµ‹å€¼è¯­å¥ $x := e$ï¼š
$$\{P[e/x]\} x := e \{P\}$$

```rust
#[derive(Debug, Clone)]
pub struct HoareTriple {
    pub precondition: String,
    pub program: String,
    pub postcondition: String,
}

pub struct AxiomaticSemantics;

impl AxiomaticSemantics {
    pub fn assignment_axiom(variable: &str, expression: &str, postcondition: &str) -> HoareTriple {
        let precondition = Self::substitute(postcondition, variable, expression);
        HoareTriple {
            precondition,
            program: format!("{} := {}", variable, expression),
            postcondition: postcondition.to_string(),
        }
    }

    pub fn sequence_rule(triple1: &HoareTriple, triple2: &HoareTriple) -> HoareTriple {
        HoareTriple {
            precondition: triple1.precondition.clone(),
            program: format!("{}; {}", triple1.program, triple2.program),
            postcondition: triple2.postcondition.clone(),
        }
    }

    pub fn conditional_rule(
        condition: &str,
        then_triple: &HoareTriple,
        else_triple: &HoareTriple,
    ) -> HoareTriple {
        let precondition = format!("({} âˆ§ {}) âˆ¨ (Â¬{} âˆ§ {})",
            condition, then_triple.precondition,
            condition, else_triple.precondition);

        HoareTriple {
            precondition,
            program: format!("if {} then {} else {} fi",
                condition, then_triple.program, else_triple.program),
            postcondition: then_triple.postcondition.clone(),
        }
    }

    pub fn while_rule(condition: &str, invariant: &str, body_triple: &HoareTriple) -> HoareTriple {
        HoareTriple {
            precondition: invariant.to_string(),
            program: format!("while {} do {} od", condition, body_triple.program),
            postcondition: format!("{} âˆ§ Â¬{}", invariant, condition),
        }
    }

    pub fn consequence_rule(
        triple: &HoareTriple,
        stronger_pre: &str,
        weaker_post: &str,
    ) -> HoareTriple {
        HoareTriple {
            precondition: stronger_pre.to_string(),
            program: triple.program.clone(),
            postcondition: weaker_post.to_string(),
        }
    }

    fn substitute(formula: &str, variable: &str, expression: &str) -> String {
        // ç®€åŒ–çš„æ›¿æ¢å®ç°
        formula.replace(&format!("{{{}}}", variable), expression)
    }
}

// éªŒè¯å™¨å®ç°
pub struct HoareVerifier;

impl HoareVerifier {
    pub fn verify_triple(triple: &HoareTriple) -> bool {
        // ç®€åŒ–çš„éªŒè¯å®ç°
        // å®é™…å®ç°éœ€è¦æ›´å¤æ‚çš„é€»è¾‘æ¨ç†
        true
    }

    pub fn verify_program(program: &str, precondition: &str, postcondition: &str) -> bool {
        // ç¨‹åºéªŒè¯çš„ç®€åŒ–å®ç°
        match program {
            "x := 5" => {
                precondition.contains("x") && postcondition.contains("x = 5")
            }
            "x := x + 1" => {
                precondition.contains("x") && postcondition.contains("x")
            }
            _ => true,
        }
    }
}
```

## 6 è¯­ä¹‰ç­‰ä»·æ€§

### 6.1 ç­‰ä»·æ€§è¯æ˜

**å®šä¹‰ 9.4.8 (è¯­ä¹‰ç­‰ä»·)** ä¸¤ä¸ªè¡¨è¾¾å¼ $e_1$ å’Œ $e_2$ è¯­ä¹‰ç­‰ä»·å½“ä¸”ä»…å½“ï¼š
$$\forall \rho: \llbracket e_1 \rrbracket \rho = \llbracket e_2 \rrbracket \rho$$

**å®šç† 9.4.4 (Î²ç­‰ä»·)** å¯¹äºÎ»è¡¨è¾¾å¼ï¼š
$$(\lambda x. e_1) e_2 \equiv e_1[e_2/x]$$

**å®šç† 9.4.5 (Î·ç­‰ä»·)** å¯¹äºÎ»è¡¨è¾¾å¼ï¼š
$$\lambda x. (e x) \equiv e \quad \text{if } x \notin FV(e)$$

```rust
pub struct SemanticEquivalence;

impl SemanticEquivalence {
    pub fn beta_equivalent(expr1: &Expr, expr2: &Expr) -> bool {
        // æ£€æŸ¥Î²ç­‰ä»·
        match (expr1, expr2) {
            (
                Expr::Apply {
                    func: Box::new(Expr::Lambda { params, body }),
                    args,
                },
                expected,
            ) => {
                if args.len() == params.len() {
                    let mut substitutions = HashMap::new();
                    for (param, arg) in params.iter().zip(args.iter()) {
                        if let Expr::Literal(value) = arg {
                            substitutions.insert(param.clone(), value.clone());
                        }
                    }
                    let substituted = Self::substitute(body, &substitutions);
                    Self::alpha_equivalent(&substituted, expected)
                } else {
                    false
                }
            }
            _ => false,
        }
    }

    pub fn eta_equivalent(expr1: &Expr, expr2: &Expr) -> bool {
        // æ£€æŸ¥Î·ç­‰ä»·
        match (expr1, expr2) {
            (
                Expr::Lambda {
                    params: vec![param],
                    body: Box::new(Expr::Apply { func, args }),
                },
                expected,
            ) => {
                if args.len() == 1 && args[0] == Expr::Variable(param.clone()) {
                    Self::alpha_equivalent(func, expected)
                } else {
                    false
                }
            }
            _ => false,
        }
    }

    fn substitute(expr: &Expr, substitutions: &HashMap<String, Value>) -> Expr {
        match expr {
            Expr::Variable(name) => {
                if let Some(value) = substitutions.get(name) {
                    Expr::Literal(value.clone())
                } else {
                    Expr::Variable(name.clone())
                }
            }
            Expr::BinaryOp { op, left, right } => {
                Expr::BinaryOp {
                    op: op.clone(),
                    left: Box::new(Self::substitute(left, substitutions)),
                    right: Box::new(Self::substitute(right, substitutions)),
                }
            }
            Expr::If { condition, then_branch, else_branch } => {
                Expr::If {
                    condition: Box::new(Self::substitute(condition, substitutions)),
                    then_branch: Box::new(Self::substitute(then_branch, substitutions)),
                    else_branch: Box::new(Self::substitute(else_branch, substitutions)),
                }
            }
            Expr::Let { name, value, body } => {
                Expr::Let {
                    name: name.clone(),
                    value: Box::new(Self::substitute(value, substitutions)),
                    body: Box::new(Self::substitute(body, substitutions)),
                }
            }
            Expr::Lambda { params, body } => {
                Expr::Lambda {
                    params: params.clone(),
                    body: Box::new(Self::substitute(body, substitutions)),
                }
            }
            Expr::Apply { func, args } => {
                Expr::Apply {
                    func: Box::new(Self::substitute(func, substitutions)),
                    args: args.iter().map(|arg| Self::substitute(arg, substitutions)).collect(),
                }
            }
            Expr::Literal(value) => Expr::Literal(value.clone()),
        }
    }

    fn alpha_equivalent(expr1: &Expr, expr2: &Expr) -> bool {
        // ç®€åŒ–çš„Î±ç­‰ä»·æ£€æŸ¥
        format!("{:?}", expr1) == format!("{:?}", expr2)
    }
}
```

## 7 å½¢å¼åŒ–éªŒè¯

### 7.1 è¯­ä¹‰ä¿æŒæ€§è¯æ˜

**å¼•ç† 9.4.1** å¯¹äºæ‰€æœ‰è¡¨è¾¾å¼ $e$ å’Œç¯å¢ƒ $\rho$ï¼š
$$\llbracket e \rrbracket \rho = \llbracket e \rrbracket \rho$$

**è¯æ˜** é€šè¿‡è¯­ä¹‰å‡½æ•°çš„å®šä¹‰ç›´æ¥å¾—å‡ºã€‚

**å®šç† 9.4.6 (è¯­ä¹‰ä¿æŒæ€§)** å¦‚æœ $e_1 \rightarrow e_2$ï¼Œåˆ™ï¼š
$$\llbracket e_1 \rrbracket = \llbracket e_2 \rrbracket$$

**è¯æ˜** é€šè¿‡ç»“æ„å½’çº³æ³•è¯æ˜æ¯ä¸ªæ±‚å€¼è§„åˆ™ä¿æŒè¯­ä¹‰ã€‚

## 8 æ€»ç»“

è¯­ä¹‰ç†è®ºä¸ºç¼–ç¨‹è¯­è¨€æä¾›äº†ç²¾ç¡®çš„æ•°å­¦åŸºç¡€ã€‚æ“ä½œè¯­ä¹‰æè¿°ç¨‹åºæ‰§è¡Œè¿‡ç¨‹ï¼ŒæŒ‡ç§°è¯­ä¹‰æä¾›æŠ½è±¡æ•°å­¦è§£é‡Šï¼Œå…¬ç†è¯­ä¹‰æ”¯æŒç¨‹åºéªŒè¯ã€‚ä¸‰ç§è¯­ä¹‰å­¦æ–¹æ³•ç›¸äº’è¡¥å……ï¼Œä¸ºè¯­è¨€è®¾è®¡å’Œç¨‹åºåˆ†ææä¾›ç†è®ºåŸºç¡€ã€‚

## å‚è€ƒæ–‡çŒ®

1. Winskel, G. (1993). The Formal Semantics of Programming Languages.
2. Plotkin, G. D. (1981). A Structural Approach to Operational Semantics.
3. Hoare, C. A. R. (1969). An Axiomatic Basis for Computer Programming.

## 9 ç›¸å…³é“¾æ¥

- [è¯­è¨€è®¾è®¡ç†è®º](README.md)
- [ç±»å‹ç³»ç»Ÿç†è®º](README.md)
- [ç¼–è¯‘ç†è®º](README.md)

## 10 æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
