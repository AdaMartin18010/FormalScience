# ç¼–è¯‘ç†è®º (Compilation Theory)

## ğŸ“‹ ç›®å½•

- [1 æ¦‚è¿°](#1-æ¦‚è¿°)
- [2 ç†è®ºåŸºç¡€](#2-ç†è®ºåŸºç¡€)
  - [2.1 å½¢å¼åŒ–å®šä¹‰](#21-å½¢å¼åŒ–å®šä¹‰)
- [3 ç¼–è¯‘é˜¶æ®µ](#3-ç¼–è¯‘é˜¶æ®µ)
  - [3.1 è¯æ³•åˆ†æ (Lexical Analysis)](#31-è¯æ³•åˆ†æ-lexical-analysis)
  - [3.2 è¯­æ³•åˆ†æ (Syntax Analysis)](#32-è¯­æ³•åˆ†æ-syntax-analysis)
  - [3.3 è¯­ä¹‰åˆ†æ (Semantic Analysis)](#33-è¯­ä¹‰åˆ†æ-semantic-analysis)
  - [3.4 ä»£ç ç”Ÿæˆ (Code Generation)](#34-ä»£ç ç”Ÿæˆ-code-generation)
- [4 ä¼˜åŒ–æŠ€æœ¯](#4-ä¼˜åŒ–æŠ€æœ¯)
  - [4.1 å¸¸é‡æŠ˜å ](#41-å¸¸é‡æŠ˜å )
  - [4.2 æ­»ä»£ç æ¶ˆé™¤](#42-æ­»ä»£ç æ¶ˆé™¤)
  - [4.3 å¯„å­˜å™¨åˆ†é…](#43-å¯„å­˜å™¨åˆ†é…)
- [5 å®ç°ç¤ºä¾‹](#5-å®ç°ç¤ºä¾‹)
  - [5.1 å®Œæ•´ç¼–è¯‘å™¨å®ç°](#51-å®Œæ•´ç¼–è¯‘å™¨å®ç°)
- [6 å½¢å¼åŒ–éªŒè¯](#6-å½¢å¼åŒ–éªŒè¯)
  - [6.1 ç¼–è¯‘æ­£ç¡®æ€§è¯æ˜](#61-ç¼–è¯‘æ­£ç¡®æ€§è¯æ˜)
- [7 æ€»ç»“](#7-æ€»ç»“)
- [8 ç›¸å…³é“¾æ¥](#8-ç›¸å…³é“¾æ¥)
- [9 æ‰¹åˆ¤æ€§åˆ†æ](#9-æ‰¹åˆ¤æ€§åˆ†æ)

---

## 1 æ¦‚è¿°

ç¼–è¯‘ç†è®ºæ˜¯ç ”ç©¶å°†é«˜çº§ç¼–ç¨‹è¯­è¨€è½¬æ¢ä¸ºæœºå™¨å¯æ‰§è¡Œä»£ç çš„æ•°å­¦åŸç†å’Œç®—æ³•ã€‚æœ¬æ–‡æ¡£ç³»ç»ŸåŒ–é˜è¿°ç¼–è¯‘å™¨çš„å„ä¸ªé˜¶æ®µåŠå…¶ç†è®ºåŸºç¡€ã€‚

## 2 ç†è®ºåŸºç¡€

### 2.1 å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 9.3.1 (ç¼–è¯‘å™¨)** ç¼–è¯‘å™¨æ˜¯ä¸€ä¸ªå‡½æ•° $C: \Sigma^* \rightarrow \Omega^*$ï¼Œå…¶ä¸­ï¼š

- $\Sigma$ æ˜¯æºè¯­è¨€çš„å­—æ¯è¡¨
- $\Omega$ æ˜¯ç›®æ ‡è¯­è¨€çš„å­—æ¯è¡¨
- $C$ ä¿æŒè¯­ä¹‰ç­‰ä»·æ€§ï¼š$\forall s \in \Sigma^*, \llbracket s \rrbracket_S = \llbracket C(s) \rrbracket_T$

**å®šç† 9.3.1 (ç¼–è¯‘æ­£ç¡®æ€§)** å¯¹äºç¼–è¯‘å™¨ $C$ å’Œæºç¨‹åº $P$ï¼š
$$\vdash P \Rightarrow \vdash C(P)$$

## 3 ç¼–è¯‘é˜¶æ®µ

### 3.1 è¯æ³•åˆ†æ (Lexical Analysis)

**å®šä¹‰ 9.3.2 (è¯æ³•åˆ†æå™¨)** è¯æ³•åˆ†æå™¨æ˜¯ä¸€ä¸ªæœ‰é™çŠ¶æ€è‡ªåŠ¨æœº $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š

- $Q$ æ˜¯çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times \Sigma \rightarrow Q$ æ˜¯è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†åˆ

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum TokenType {
    Identifier,
    Number,
    String,
    Operator,
    Keyword,
    Delimiter,
    EOF,
}

#[derive(Debug, Clone)]
pub struct Token {
    pub token_type: TokenType,
    pub lexeme: String,
    pub line: usize,
    pub column: usize,
}

pub struct Lexer {
    source: Vec<char>,
    position: usize,
    line: usize,
    column: usize,
}

impl Lexer {
    pub fn new(source: &str) -> Self {
        Self {
            source: source.chars().collect(),
            position: 0,
            line: 1,
            column: 1,
        }
    }

    pub fn next_token(&mut self) -> Result<Token, String> {
        self.skip_whitespace();
        
        if self.position >= self.source.len() {
            return Ok(Token {
                token_type: TokenType::EOF,
                lexeme: String::new(),
                line: self.line,
                column: self.column,
            });
        }

        let ch = self.source[self.position];
        
        match ch {
            'a'..='z' | 'A'..='Z' | '_' => self.lex_identifier(),
            '0'..='9' => self.lex_number(),
            '"' => self.lex_string(),
            '+' | '-' | '*' | '/' | '=' | '<' | '>' => self.lex_operator(),
            '(' | ')' | '{' | '}' | ';' | ',' => self.lex_delimiter(),
            _ => Err(format!("Unexpected character: {}", ch)),
        }
    }

    fn lex_identifier(&mut self) -> Result<Token, String> {
        let start = self.position;
        let start_column = self.column;
        
        while self.position < self.source.len() {
            let ch = self.source[self.position];
            if ch.is_alphanumeric() || ch == '_' {
                self.position += 1;
                self.column += 1;
            } else {
                break;
            }
        }
        
        let lexeme: String = self.source[start..self.position].iter().collect();
        let token_type = self.classify_identifier(&lexeme);
        
        Ok(Token {
            token_type,
            lexeme,
            line: self.line,
            column: start_column,
        })
    }

    fn classify_identifier(&self, lexeme: &str) -> TokenType {
        match lexeme {
            "let" | "fn" | "if" | "else" | "while" | "return" => TokenType::Keyword,
            _ => TokenType::Identifier,
        }
    }

    fn lex_number(&mut self) -> Result<Token, String> {
        let start = self.position;
        let start_column = self.column;
        
        while self.position < self.source.len() {
            let ch = self.source[self.position];
            if ch.is_digit(10) || ch == '.' {
                self.position += 1;
                self.column += 1;
            } else {
                break;
            }
        }
        
        let lexeme: String = self.source[start..self.position].iter().collect();
        
        Ok(Token {
            token_type: TokenType::Number,
            lexeme,
            line: self.line,
            column: start_column,
        })
    }

    fn lex_string(&mut self) -> Result<Token, String> {
        let start_column = self.column;
        self.position += 1; // Skip opening quote
        self.column += 1;
        
        let start = self.position;
        
        while self.position < self.source.len() {
            let ch = self.source[self.position];
            if ch == '"' {
                break;
            }
            self.position += 1;
            self.column += 1;
        }
        
        if self.position >= self.source.len() {
            return Err("Unterminated string".to_string());
        }
        
        let lexeme: String = self.source[start..self.position].iter().collect();
        self.position += 1; // Skip closing quote
        self.column += 1;
        
        Ok(Token {
            token_type: TokenType::String,
            lexeme,
            line: self.line,
            column: start_column,
        })
    }

    fn lex_operator(&mut self) -> Result<Token, String> {
        let start_column = self.column;
        let ch = self.source[self.position];
        self.position += 1;
        self.column += 1;
        
        Ok(Token {
            token_type: TokenType::Operator,
            lexeme: ch.to_string(),
            line: self.line,
            column: start_column,
        })
    }

    fn lex_delimiter(&mut self) -> Result<Token, String> {
        let start_column = self.column;
        let ch = self.source[self.position];
        self.position += 1;
        self.column += 1;
        
        Ok(Token {
            token_type: TokenType::Delimiter,
            lexeme: ch.to_string(),
            line: self.line,
            column: start_column,
        })
    }

    fn skip_whitespace(&mut self) {
        while self.position < self.source.len() {
            let ch = self.source[self.position];
            match ch {
                ' ' | '\t' => {
                    self.position += 1;
                    self.column += 1;
                }
                '\n' => {
                    self.position += 1;
                    self.line += 1;
                    self.column = 1;
                }
                _ => break,
            }
        }
    }
}
```

### 3.2 è¯­æ³•åˆ†æ (Syntax Analysis)

**å®šä¹‰ 9.3.3 (ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•)** ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ $G = (N, T, P, S)$ï¼Œå…¶ä¸­ï¼š

- $N$ æ˜¯éç»ˆç»“ç¬¦é›†åˆ
- $T$ æ˜¯ç»ˆç»“ç¬¦é›†åˆ
- $P$ æ˜¯äº§ç”Ÿå¼é›†åˆ
- $S \in N$ æ˜¯å¼€å§‹ç¬¦å·

**å®šç† 9.3.2 (LL(1)æ–‡æ³•)** æ–‡æ³• $G$ æ˜¯ LL(1) çš„å½“ä¸”ä»…å½“ï¼š
$$\forall A \in N, \forall \alpha, \beta \in (N \cup T)^*: A \rightarrow \alpha, A \rightarrow \beta \Rightarrow FIRST(\alpha) \cap FIRST(\beta) = \emptyset$$

```rust
#[derive(Debug, Clone)]
pub enum ASTNode {
    Program(Vec<ASTNode>),
    FunctionDecl {
        name: String,
        params: Vec<String>,
        body: Box<ASTNode>,
    },
    VariableDecl {
        name: String,
        value: Box<ASTNode>,
    },
    BinaryOp {
        op: String,
        left: Box<ASTNode>,
        right: Box<ASTNode>,
    },
    Identifier(String),
    Literal(LiteralValue),
    IfStatement {
        condition: Box<ASTNode>,
        then_branch: Box<ASTNode>,
        else_branch: Option<Box<ASTNode>>,
    },
    WhileLoop {
        condition: Box<ASTNode>,
        body: Box<ASTNode>,
    },
    Return(Option<Box<ASTNode>>),
}

#[derive(Debug, Clone)]
pub enum LiteralValue {
    Number(f64),
    String(String),
    Boolean(bool),
}

pub struct Parser {
    tokens: Vec<Token>,
    position: usize,
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self {
        Self { tokens, position: 0 }
    }

    pub fn parse(&mut self) -> Result<ASTNode, String> {
        let mut statements = Vec::new();
        
        while self.position < self.tokens.len() {
            let stmt = self.parse_statement()?;
            statements.push(stmt);
        }
        
        Ok(ASTNode::Program(statements))
    }

    fn parse_statement(&mut self) -> Result<ASTNode, String> {
        let token = self.peek()?;
        
        match token.token_type {
            TokenType::Keyword => {
                match token.lexeme.as_str() {
                    "let" => self.parse_variable_declaration(),
                    "fn" => self.parse_function_declaration(),
                    "if" => self.parse_if_statement(),
                    "while" => self.parse_while_loop(),
                    "return" => self.parse_return_statement(),
                    _ => Err(format!("Unknown keyword: {}", token.lexeme)),
                }
            }
            _ => self.parse_expression_statement(),
        }
    }

    fn parse_variable_declaration(&mut self) -> Result<ASTNode, String> {
        self.expect_keyword("let")?;
        let name = self.expect_identifier()?;
        self.expect_operator("=")?;
        let value = self.parse_expression()?;
        self.expect_delimiter(";")?;
        
        Ok(ASTNode::VariableDecl {
            name,
            value: Box::new(value),
        })
    }

    fn parse_function_declaration(&mut self) -> Result<ASTNode, String> {
        self.expect_keyword("fn")?;
        let name = self.expect_identifier()?;
        self.expect_delimiter("(")?;
        
        let mut params = Vec::new();
        if !self.check_delimiter(")") {
            loop {
                params.push(self.expect_identifier()?);
                if self.check_delimiter(")") {
                    break;
                }
                self.expect_delimiter(",")?;
            }
        }
        self.expect_delimiter(")")?;
        
        let body = self.parse_block()?;
        
        Ok(ASTNode::FunctionDecl {
            name,
            params,
            body: Box::new(body),
        })
    }

    fn parse_expression(&mut self) -> Result<ASTNode, String> {
        self.parse_logical_or()
    }

    fn parse_logical_or(&mut self) -> Result<ASTNode, String> {
        let mut left = self.parse_logical_and()?;
        
        while self.check_operator("||") {
            let op = self.advance()?.lexeme;
            let right = self.parse_logical_and()?;
            left = ASTNode::BinaryOp {
                op,
                left: Box::new(left),
                right: Box::new(right),
            };
        }
        
        Ok(left)
    }

    fn parse_logical_and(&mut self) -> Result<ASTNode, String> {
        let mut left = self.parse_equality()?;
        
        while self.check_operator("&&") {
            let op = self.advance()?.lexeme;
            let right = self.parse_equality()?;
            left = ASTNode::BinaryOp {
                op,
                left: Box::new(left),
                right: Box::new(right),
            };
        }
        
        Ok(left)
    }

    fn parse_equality(&mut self) -> Result<ASTNode, String> {
        let mut left = self.parse_comparison()?;
        
        while self.check_operator("==") || self.check_operator("!=") {
            let op = self.advance()?.lexeme;
            let right = self.parse_comparison()?;
            left = ASTNode::BinaryOp {
                op,
                left: Box::new(left),
                right: Box::new(right),
            };
        }
        
        Ok(left)
    }

    fn parse_comparison(&mut self) -> Result<ASTNode, String> {
        let mut left = self.parse_term()?;
        
        while self.check_operator("<") || self.check_operator(">") || 
              self.check_operator("<=") || self.check_operator(">=") {
            let op = self.advance()?.lexeme;
            let right = self.parse_term()?;
            left = ASTNode::BinaryOp {
                op,
                left: Box::new(left),
                right: Box::new(right),
            };
        }
        
        Ok(left)
    }

    fn parse_term(&mut self) -> Result<ASTNode, String> {
        let mut left = self.parse_factor()?;
        
        while self.check_operator("+") || self.check_operator("-") {
            let op = self.advance()?.lexeme;
            let right = self.parse_factor()?;
            left = ASTNode::BinaryOp {
                op,
                left: Box::new(left),
                right: Box::new(right),
            };
        }
        
        Ok(left)
    }

    fn parse_factor(&mut self) -> Result<ASTNode, String> {
        let mut left = self.parse_primary()?;
        
        while self.check_operator("*") || self.check_operator("/") {
            let op = self.advance()?.lexeme;
            let right = self.parse_primary()?;
            left = ASTNode::BinaryOp {
                op,
                left: Box::new(left),
                right: Box::new(right),
            };
        }
        
        Ok(left)
    }

    fn parse_primary(&mut self) -> Result<ASTNode, String> {
        let token = self.peek()?;
        
        match token.token_type {
            TokenType::Number => {
                let value = token.lexeme.parse::<f64>().unwrap();
                self.advance()?;
                Ok(ASTNode::Literal(LiteralValue::Number(value)))
            }
            TokenType::String => {
                let value = token.lexeme.clone();
                self.advance()?;
                Ok(ASTNode::Literal(LiteralValue::String(value)))
            }
            TokenType::Identifier => {
                let name = token.lexeme.clone();
                self.advance()?;
                Ok(ASTNode::Identifier(name))
            }
            TokenType::Delimiter => {
                if token.lexeme == "(" {
                    self.advance()?;
                    let expr = self.parse_expression()?;
                    self.expect_delimiter(")")?;
                    Ok(expr)
                } else {
                    Err(format!("Unexpected delimiter: {}", token.lexeme))
                }
            }
            _ => Err(format!("Unexpected token: {:?}", token)),
        }
    }

    // Helper methods
    fn peek(&self) -> Result<&Token, String> {
        if self.position >= self.tokens.len() {
            Err("Unexpected end of input".to_string())
        } else {
            Ok(&self.tokens[self.position])
        }
    }

    fn advance(&mut self) -> Result<Token, String> {
        if self.position >= self.tokens.len() {
            Err("Unexpected end of input".to_string())
        } else {
            let token = self.tokens[self.position].clone();
            self.position += 1;
            Ok(token)
        }
    }

    fn expect_keyword(&mut self, keyword: &str) -> Result<(), String> {
        let token = self.peek()?;
        if token.token_type == TokenType::Keyword && token.lexeme == keyword {
            self.advance()?;
            Ok(())
        } else {
            Err(format!("Expected keyword '{}', got {:?}", keyword, token))
        }
    }

    fn expect_identifier(&mut self) -> Result<String, String> {
        let token = self.peek()?;
        if token.token_type == TokenType::Identifier {
            let name = token.lexeme.clone();
            self.advance()?;
            Ok(name)
        } else {
            Err(format!("Expected identifier, got {:?}", token))
        }
    }

    fn expect_operator(&mut self, op: &str) -> Result<(), String> {
        let token = self.peek()?;
        if token.token_type == TokenType::Operator && token.lexeme == op {
            self.advance()?;
            Ok(())
        } else {
            Err(format!("Expected operator '{}', got {:?}", op, token))
        }
    }

    fn expect_delimiter(&mut self, delim: &str) -> Result<(), String> {
        let token = self.peek()?;
        if token.token_type == TokenType::Delimiter && token.lexeme == delim {
            self.advance()?;
            Ok(())
        } else {
            Err(format!("Expected delimiter '{}', got {:?}", delim, token))
        }
    }

    fn check_operator(&self, op: &str) -> bool {
        if self.position >= self.tokens.len() {
            return false;
        }
        let token = &self.tokens[self.position];
        token.token_type == TokenType::Operator && token.lexeme == op
    }

    fn check_delimiter(&self, delim: &str) -> bool {
        if self.position >= self.tokens.len() {
            return false;
        }
        let token = &self.tokens[self.position];
        token.token_type == TokenType::Delimiter && token.lexeme == delim
    }
}
```

### 3.3 è¯­ä¹‰åˆ†æ (Semantic Analysis)

**å®šä¹‰ 9.3.4 (ç±»å‹ç¯å¢ƒ)** ç±»å‹ç¯å¢ƒæ˜¯ä¸€ä¸ªå‡½æ•° $\Gamma: Var \rightarrow Type$ï¼Œå°†å˜é‡æ˜ å°„åˆ°ç±»å‹ã€‚

**å®šä¹‰ 9.3.5 (ç±»å‹åˆ¤æ–­)** ç±»å‹åˆ¤æ–­æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $\Gamma \vdash e : \tau$ï¼Œè¡¨ç¤ºåœ¨ç¯å¢ƒ $\Gamma$ ä¸‹è¡¨è¾¾å¼ $e$ å…·æœ‰ç±»å‹ $\tau$ã€‚

**å®šç† 9.3.3 (ç±»å‹å®‰å…¨)** å¦‚æœ $\Gamma \vdash e : \tau$ ä¸” $e \rightarrow^* v$ï¼Œåˆ™ $\vdash v : \tau$ã€‚

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Int,
    Float,
    Bool,
    String,
    Function {
        params: Vec<Type>,
        return_type: Box<Type>,
    },
    Unit,
}

pub struct TypeChecker {
    environment: HashMap<String, Type>,
}

impl TypeChecker {
    pub fn new() -> Self {
        Self {
            environment: HashMap::new(),
        }
    }

    pub fn check_program(&mut self, program: &ASTNode) -> Result<Type, String> {
        match program {
            ASTNode::Program(statements) => {
                for stmt in statements {
                    self.check_statement(stmt)?;
                }
                Ok(Type::Unit)
            }
            _ => Err("Expected program node".to_string()),
        }
    }

    fn check_statement(&mut self, stmt: &ASTNode) -> Result<Type, String> {
        match stmt {
            ASTNode::VariableDecl { name, value } => {
                let value_type = self.check_expression(value)?;
                self.environment.insert(name.clone(), value_type.clone());
                Ok(Type::Unit)
            }
            ASTNode::FunctionDecl { name, params, body } => {
                let mut new_env = self.environment.clone();
                
                // Add parameters to environment
                for param in params {
                    new_env.insert(param.clone(), Type::Int); // Simplified
                }
                
                let mut checker = TypeChecker { environment: new_env };
                let body_type = checker.check_statement(body)?;
                
                let func_type = Type::Function {
                    params: vec![Type::Int; params.len()], // Simplified
                    return_type: Box::new(body_type),
                };
                
                self.environment.insert(name.clone(), func_type);
                Ok(Type::Unit)
            }
            ASTNode::Return(expr) => {
                match expr {
                    Some(e) => self.check_expression(e),
                    None => Ok(Type::Unit),
                }
            }
            _ => self.check_expression(stmt),
        }
    }

    fn check_expression(&self, expr: &ASTNode) -> Result<Type, String> {
        match expr {
            ASTNode::BinaryOp { op, left, right } => {
                let left_type = self.check_expression(left)?;
                let right_type = self.check_expression(right)?;
                
                match op.as_str() {
                    "+" | "-" | "*" | "/" => {
                        if left_type == Type::Int && right_type == Type::Int {
                            Ok(Type::Int)
                        } else if (left_type == Type::Float || left_type == Type::Int) &&
                                  (right_type == Type::Float || right_type == Type::Int) {
                            Ok(Type::Float)
                        } else {
                            Err(format!("Cannot apply {} to types {:?} and {:?}", op, left_type, right_type))
                        }
                    }
                    "==" | "!=" | "<" | ">" | "<=" | ">=" => {
                        if left_type == right_type {
                            Ok(Type::Bool)
                        } else {
                            Err(format!("Cannot compare types {:?} and {:?}", left_type, right_type))
                        }
                    }
                    "&&" | "||" => {
                        if left_type == Type::Bool && right_type == Type::Bool {
                            Ok(Type::Bool)
                        } else {
                            Err("Logical operators require boolean operands".to_string())
                        }
                    }
                    _ => Err(format!("Unknown operator: {}", op)),
                }
            }
            ASTNode::Identifier(name) => {
                self.environment.get(name)
                    .cloned()
                    .ok_or_else(|| format!("Undefined variable: {}", name))
            }
            ASTNode::Literal(value) => {
                match value {
                    LiteralValue::Number(n) => {
                        if n.fract() == 0.0 {
                            Ok(Type::Int)
                        } else {
                            Ok(Type::Float)
                        }
                    }
                    LiteralValue::String(_) => Ok(Type::String),
                    LiteralValue::Boolean(_) => Ok(Type::Bool),
                }
            }
            _ => Err("Unsupported expression type".to_string()),
        }
    }
}
```

### 3.4 ä»£ç ç”Ÿæˆ (Code Generation)

**å®šä¹‰ 9.3.6 (ä¸­é—´è¡¨ç¤º)** ä¸­é—´è¡¨ç¤ºæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $IR = (V, E, \phi)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯åŸºæœ¬å—é›†åˆ
- $E$ æ˜¯æ§åˆ¶æµè¾¹é›†åˆ
- $\phi$ æ˜¯å˜é‡å®šä¹‰æ˜ å°„

**å®šç† 9.3.4 (ä»£ç ç”Ÿæˆæ­£ç¡®æ€§)** å¯¹äºç¨‹åº $P$ å’Œç”Ÿæˆçš„ä»£ç  $C$ï¼š
$$\llbracket P \rrbracket = \llbracket C \rrbracket$$

```rust
#[derive(Debug, Clone)]
pub enum IRInstruction {
    Load { dest: String, value: i64 },
    Store { dest: String, src: String },
    Add { dest: String, left: String, right: String },
    Sub { dest: String, left: String, right: String },
    Mul { dest: String, left: String, right: String },
    Div { dest: String, left: String, right: String },
    Call { func: String, args: Vec<String>, dest: Option<String> },
    Return { value: Option<String> },
    Jump { label: String },
    JumpIf { condition: String, label: String },
    Label { name: String },
}

pub struct CodeGenerator {
    instructions: Vec<IRInstruction>,
    temp_counter: usize,
    label_counter: usize,
}

impl CodeGenerator {
    pub fn new() -> Self {
        Self {
            instructions: Vec::new(),
            temp_counter: 0,
            label_counter: 0,
        }
    }

    pub fn generate(&mut self, ast: &ASTNode) -> Result<Vec<IRInstruction>, String> {
        self.generate_node(ast)?;
        Ok(self.instructions.clone())
    }

    fn generate_node(&mut self, node: &ASTNode) -> Result<String, String> {
        match node {
            ASTNode::Program(statements) => {
                for stmt in statements {
                    self.generate_node(stmt)?;
                }
                Ok(String::new())
            }
            ASTNode::VariableDecl { name, value } => {
                let value_temp = self.generate_node(value)?;
                self.instructions.push(IRInstruction::Store {
                    dest: name.clone(),
                    src: value_temp,
                });
                Ok(name.clone())
            }
            ASTNode::BinaryOp { op, left, right } => {
                let left_temp = self.generate_node(left)?;
                let right_temp = self.generate_node(right)?;
                let result_temp = self.new_temp();
                
                let instruction = match op.as_str() {
                    "+" => IRInstruction::Add {
                        dest: result_temp.clone(),
                        left: left_temp,
                        right: right_temp,
                    },
                    "-" => IRInstruction::Sub {
                        dest: result_temp.clone(),
                        left: left_temp,
                        right: right_temp,
                    },
                    "*" => IRInstruction::Mul {
                        dest: result_temp.clone(),
                        left: left_temp,
                        right: right_temp,
                    },
                    "/" => IRInstruction::Div {
                        dest: result_temp.clone(),
                        left: left_temp,
                        right: right_temp,
                    },
                    _ => return Err(format!("Unsupported operator: {}", op)),
                };
                
                self.instructions.push(instruction);
                Ok(result_temp)
            }
            ASTNode::Identifier(name) => {
                Ok(name.clone())
            }
            ASTNode::Literal(value) => {
                let temp = self.new_temp();
                let int_value = match value {
                    LiteralValue::Number(n) => *n as i64,
                    LiteralValue::Boolean(b) => if *b { 1 } else { 0 },
                    _ => return Err("Unsupported literal type".to_string()),
                };
                
                self.instructions.push(IRInstruction::Load {
                    dest: temp.clone(),
                    value: int_value,
                });
                Ok(temp)
            }
            ASTNode::IfStatement { condition, then_branch, else_branch } => {
                let condition_temp = self.generate_node(condition)?;
                let then_label = self.new_label();
                let else_label = self.new_label();
                let end_label = self.new_label();
                
                // Jump to else branch if condition is false
                self.instructions.push(IRInstruction::JumpIf {
                    condition: condition_temp,
                    label: else_label.clone(),
                });
                
                // Generate then branch
                self.instructions.push(IRInstruction::Label { name: then_label });
                self.generate_node(then_branch)?;
                self.instructions.push(IRInstruction::Jump { label: end_label.clone() });
                
                // Generate else branch
                self.instructions.push(IRInstruction::Label { name: else_label });
                if let Some(else_branch) = else_branch {
                    self.generate_node(else_branch)?;
                }
                
                self.instructions.push(IRInstruction::Label { name: end_label });
                Ok(String::new())
            }
            ASTNode::WhileLoop { condition, body } => {
                let start_label = self.new_label();
                let body_label = self.new_label();
                let end_label = self.new_label();
                
                self.instructions.push(IRInstruction::Label { name: start_label.clone() });
                
                let condition_temp = self.generate_node(condition)?;
                self.instructions.push(IRInstruction::JumpIf {
                    condition: condition_temp,
                    label: body_label.clone(),
                });
                self.instructions.push(IRInstruction::Jump { label: end_label.clone() });
                
                self.instructions.push(IRInstruction::Label { name: body_label });
                self.generate_node(body)?;
                self.instructions.push(IRInstruction::Jump { label: start_label });
                
                self.instructions.push(IRInstruction::Label { name: end_label });
                Ok(String::new())
            }
            ASTNode::Return(expr) => {
                match expr {
                    Some(e) => {
                        let value_temp = self.generate_node(e)?;
                        self.instructions.push(IRInstruction::Return {
                            value: Some(value_temp),
                        });
                    }
                    None => {
                        self.instructions.push(IRInstruction::Return { value: None });
                    }
                }
                Ok(String::new())
            }
            _ => Err("Unsupported AST node type".to_string()),
        }
    }

    fn new_temp(&mut self) -> String {
        let temp = format!("t{}", self.temp_counter);
        self.temp_counter += 1;
        temp
    }

    fn new_label(&mut self) -> String {
        let label = format!("L{}", self.label_counter);
        self.label_counter += 1;
        label
    }
}
```

## 4 ä¼˜åŒ–æŠ€æœ¯

### 4.1 å¸¸é‡æŠ˜å 

**å®šä¹‰ 9.3.7 (å¸¸é‡æŠ˜å )** å¸¸é‡æŠ˜å æ˜¯ä¸€ä¸ªè½¬æ¢ $C$ï¼Œä½¿å¾—ï¼š
$$\forall e_1, e_2 \in Const: C(e_1 \oplus e_2) = eval(e_1 \oplus e_2)$$

### 4.2 æ­»ä»£ç æ¶ˆé™¤

**å®šä¹‰ 9.3.8 (å¯è¾¾æ€§)** åŸºæœ¬å— $b$ æ˜¯å¯è¾¾çš„å½“ä¸”ä»…å½“å­˜åœ¨ä»å…¥å£åˆ° $b$ çš„è·¯å¾„ã€‚

**å®šç† 9.3.5 (æ­»ä»£ç æ¶ˆé™¤)** åˆ é™¤ä¸å¯è¾¾çš„åŸºæœ¬å—ä¸ä¼šæ”¹å˜ç¨‹åºè¯­ä¹‰ã€‚

### 4.3 å¯„å­˜å™¨åˆ†é…

**å®šä¹‰ 9.3.9 (å›¾ç€è‰²)** å¯„å­˜å™¨åˆ†é…ç­‰ä»·äºå›¾ç€è‰²é—®é¢˜ï¼Œå…¶ä¸­ï¼š

- èŠ‚ç‚¹æ˜¯æ´»è·ƒå˜é‡
- è¾¹è¡¨ç¤ºå˜é‡åŒæ—¶æ´»è·ƒ
- é¢œè‰²æ˜¯å¯„å­˜å™¨

## 5 å®ç°ç¤ºä¾‹

### 5.1 å®Œæ•´ç¼–è¯‘å™¨å®ç°

```rust
pub struct Compiler {
    lexer: Lexer,
    parser: Parser,
    type_checker: TypeChecker,
    code_generator: CodeGenerator,
}

impl Compiler {
    pub fn new() -> Self {
        Self {
            lexer: Lexer::new(""),
            parser: Parser::new(Vec::new()),
            type_checker: TypeChecker::new(),
            code_generator: CodeGenerator::new(),
        }
    }

    pub fn compile(&mut self, source: &str) -> Result<Vec<IRInstruction>, String> {
        // è¯æ³•åˆ†æ
        let mut lexer = Lexer::new(source);
        let mut tokens = Vec::new();
        
        loop {
            let token = lexer.next_token()?;
            if token.token_type == TokenType::EOF {
                break;
            }
            tokens.push(token);
        }
        
        // è¯­æ³•åˆ†æ
        let mut parser = Parser::new(tokens);
        let ast = parser.parse()?;
        
        // è¯­ä¹‰åˆ†æ
        let mut type_checker = TypeChecker::new();
        type_checker.check_program(&ast)?;
        
        // ä»£ç ç”Ÿæˆ
        let mut code_generator = CodeGenerator::new();
        let ir = code_generator.generate(&ast)?;
        
        Ok(ir)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let source = r#"
        let x = 10;
        let y = 20;
        let result = x + y;
        return result;
    "#;
    
    let mut compiler = Compiler::new();
    match compiler.compile(source) {
        Ok(ir) => {
            println!("Generated IR:");
            for (i, instruction) in ir.iter().enumerate() {
                println!("{}: {:?}", i, instruction);
            }
        }
        Err(e) => println!("Compilation error: {}", e),
    }
}
```

## 6 å½¢å¼åŒ–éªŒè¯

### 6.1 ç¼–è¯‘æ­£ç¡®æ€§è¯æ˜

**å¼•ç† 9.3.1** å¯¹äºæ‰€æœ‰è¡¨è¾¾å¼ $e$ å’Œå€¼ $v$ï¼š
$$e \rightarrow^* v \Rightarrow \llbracket e \rrbracket = v$$

**è¯æ˜** é€šè¿‡ç»“æ„å½’çº³æ³•è¯æ˜ï¼š

1. åŸºç¡€æƒ…å†µï¼šå­—é¢é‡ç›´æ¥æ±‚å€¼ä¸ºè‡ªèº«
2. å½’çº³æ­¥éª¤ï¼šäºŒå…ƒè¿ç®—ã€å‡½æ•°è°ƒç”¨ç­‰ä¿æŒè¯­ä¹‰

**å®šç† 9.3.6 (ç¼–è¯‘æ­£ç¡®æ€§)** å¯¹äºç¨‹åº $P$ å’Œç¼–è¯‘ç»“æœ $C(P)$ï¼š
$$\llbracket P \rrbracket = \llbracket C(P) \rrbracket$$

**è¯æ˜** é€šè¿‡ç¼–è¯‘å„é˜¶æ®µçš„è¯­ä¹‰ä¿æŒæ€§è¯æ˜ã€‚

## 7 æ€»ç»“

ç¼–è¯‘ç†è®ºæä¾›äº†å°†é«˜çº§è¯­è¨€è½¬æ¢ä¸ºæœºå™¨ä»£ç çš„æ•°å­¦åŸºç¡€ã€‚é€šè¿‡è¯æ³•åˆ†æã€è¯­æ³•åˆ†æã€è¯­ä¹‰åˆ†æå’Œä»£ç ç”Ÿæˆå››ä¸ªé˜¶æ®µï¼Œç¡®ä¿ç¼–è¯‘çš„æ­£ç¡®æ€§å’Œæ•ˆç‡ã€‚å½¢å¼åŒ–æ–¹æ³•ä¸ºç¼–è¯‘å™¨å®ç°æä¾›äº†ä¸¥æ ¼çš„æ•°å­¦ä¿è¯ã€‚

## å‚è€ƒæ–‡çŒ®

1. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). Compilers: Principles, Techniques, and Tools.
2. Appel, A. W. (1998). Modern Compiler Implementation in ML.
3. Pierce, B. C. (2002). Types and Programming Languages.

## 8 ç›¸å…³é“¾æ¥

- [è¯­è¨€è®¾è®¡ç†è®º](README.md)
- [ç±»å‹ç³»ç»Ÿç†è®º](README.md)
- [å½¢å¼è¯­è¨€ç†è®º](README.md)

## 9 æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
