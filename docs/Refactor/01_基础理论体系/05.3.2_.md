# 05.3.2 è‡ªé€‚åº”æ§åˆ¶ç†è®º

## ğŸ“‹ ç›®å½•

- [1 æ¦‚è¿°](#1-æ¦‚è¿°)
- [2 æ ¸å¿ƒç›®æ ‡](#2-æ ¸å¿ƒç›®æ ‡)
- [3 åŸºæœ¬æ¦‚å¿µ](#3-åŸºæœ¬æ¦‚å¿µ)
  - [3.1 è‡ªé€‚åº”æ§åˆ¶å®šä¹‰](#31-è‡ªé€‚åº”æ§åˆ¶å®šä¹‰)
  - [3.2 è‡ªé€‚åº”æ§åˆ¶åˆ†ç±»](#32-è‡ªé€‚åº”æ§åˆ¶åˆ†ç±»)
  - [3.3 è‡ªé€‚åº”æ§åˆ¶é—®é¢˜](#33-è‡ªé€‚åº”æ§åˆ¶é—®é¢˜)
- [4 å‚æ•°è‡ªé€‚åº”æ§åˆ¶](#4-å‚æ•°è‡ªé€‚åº”æ§åˆ¶)
  - [4.1 çº¿æ€§å‚æ•°åŒ–ç³»ç»Ÿ](#41-çº¿æ€§å‚æ•°åŒ–ç³»ç»Ÿ)
  - [4.2 å‚æ•°ä¼°è®¡å¾‹](#42-å‚æ•°ä¼°è®¡å¾‹)
  - [4.3 è‡ªé€‚åº”æ§åˆ¶å¾‹](#43-è‡ªé€‚åº”æ§åˆ¶å¾‹)
- [5 æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶](#5-æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶)
  - [5.1 å‚è€ƒæ¨¡å‹](#51-å‚è€ƒæ¨¡å‹)
  - [5.2 MRACæ§åˆ¶å¾‹](#52-mracæ§åˆ¶å¾‹)
  - [5.3 ç¨³å®šæ€§åˆ†æ](#53-ç¨³å®šæ€§åˆ†æ)
- [6 ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶](#6-ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶)
  - [6.1 ç¥ç»ç½‘ç»œé€¼è¿‘](#61-ç¥ç»ç½‘ç»œé€¼è¿‘)
  - [6.2 ç¥ç»ç½‘ç»œè‡ªé€‚åº”å¾‹](#62-ç¥ç»ç½‘ç»œè‡ªé€‚åº”å¾‹)
  - [6.3 é²æ£’ç¥ç»ç½‘ç»œæ§åˆ¶](#63-é²æ£’ç¥ç»ç½‘ç»œæ§åˆ¶)
- [7 é²æ£’è‡ªé€‚åº”æ§åˆ¶](#7-é²æ£’è‡ªé€‚åº”æ§åˆ¶)
  - [7.1 æ­»åŒºè‡ªé€‚åº”æ§åˆ¶](#71-æ­»åŒºè‡ªé€‚åº”æ§åˆ¶)
  - [7.2 Ïƒä¿®æ­£](#72-Ïƒä¿®æ­£)
  - [7.3 æŠ•å½±ç®—æ³•](#73-æŠ•å½±ç®—æ³•)
- [8 è‡ªé€‚åº”è§‚æµ‹å™¨](#8-è‡ªé€‚åº”è§‚æµ‹å™¨)
  - [8.1 è‡ªé€‚åº”è§‚æµ‹å™¨è®¾è®¡](#81-è‡ªé€‚åº”è§‚æµ‹å™¨è®¾è®¡)
  - [8.2 è¾“å‡ºåé¦ˆè‡ªé€‚åº”æ§åˆ¶](#82-è¾“å‡ºåé¦ˆè‡ªé€‚åº”æ§åˆ¶)
- [9 ä»£ç å®ç°](#9-ä»£ç å®ç°)
  - [9.1 è‡ªé€‚åº”æ§åˆ¶ç³»ç»Ÿæ¡†æ¶](#91-è‡ªé€‚åº”æ§åˆ¶ç³»ç»Ÿæ¡†æ¶)
  - [9.2 é²æ£’è‡ªé€‚åº”æ§åˆ¶](#92-é²æ£’è‡ªé€‚åº”æ§åˆ¶)
  - [9.3 è‡ªé€‚åº”è§‚æµ‹å™¨](#93-è‡ªé€‚åº”è§‚æµ‹å™¨)
- [10 åº”ç”¨ç¤ºä¾‹](#10-åº”ç”¨ç¤ºä¾‹)
  - [10.1 å€’ç«‹æ‘†è‡ªé€‚åº”æ§åˆ¶](#101-å€’ç«‹æ‘†è‡ªé€‚åº”æ§åˆ¶)
  - [10.2 æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶ç¤ºä¾‹](#102-æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶ç¤ºä¾‹)
  - [10.3 ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶ç¤ºä¾‹](#103-ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶ç¤ºä¾‹)
- [11 ç›¸å…³ç†è®º](#11-ç›¸å…³ç†è®º)
  - [11.1 ä¸çº¿æ€§æ§åˆ¶ç†è®ºçš„å…³ç³»](#111-ä¸çº¿æ€§æ§åˆ¶ç†è®ºçš„å…³ç³»)
  - [11.2 ä¸éçº¿æ€§æ§åˆ¶ç†è®ºçš„å…³ç³»](#112-ä¸éçº¿æ€§æ§åˆ¶ç†è®ºçš„å…³ç³»)
  - [11.3 ä¸é²æ£’æ§åˆ¶çš„å…³ç³»](#113-ä¸é²æ£’æ§åˆ¶çš„å…³ç³»)
- [12 æ‰¹åˆ¤æ€§åˆ†æ](#12-æ‰¹åˆ¤æ€§åˆ†æ)
  - [12.1 å¤šå…ƒç†è®ºè§†è§’](#121-å¤šå…ƒç†è®ºè§†è§’)
  - [12.2 å±€é™æ€§åˆ†æ](#122-å±€é™æ€§åˆ†æ)
  - [12.3 äº‰è®®ä¸åˆ†æ­§](#123-äº‰è®®ä¸åˆ†æ­§)
  - [12.4 åº”ç”¨å‰æ™¯](#124-åº”ç”¨å‰æ™¯)
  - [12.5 æ”¹è¿›å»ºè®®](#125-æ”¹è¿›å»ºè®®)

---

## 1 æ¦‚è¿°

è‡ªé€‚åº”æ§åˆ¶ç†è®ºæ˜¯ç°ä»£æ§åˆ¶ç†è®ºçš„é‡è¦åˆ†æ”¯ï¼Œç ”ç©¶å¦‚ä½•è®¾è®¡æ§åˆ¶å™¨ä½¿å…¶èƒ½å¤Ÿè‡ªåŠ¨è°ƒæ•´å‚æ•°ä»¥é€‚åº”ç³»ç»Ÿå‚æ•°çš„å˜åŒ–æˆ–æœªçŸ¥æ€§ã€‚è‡ªé€‚åº”æ§åˆ¶ç†è®ºä¸ºå¤„ç†å‚æ•°ä¸ç¡®å®šæ€§å’Œæ—¶å˜ç³»ç»Ÿæä¾›äº†å¼ºæœ‰åŠ›çš„å·¥å…·ï¼Œå¹¿æ³›åº”ç”¨äºæœºå™¨äººã€èˆªç©ºèˆªå¤©ã€å·¥ä¸šè¿‡ç¨‹æ§åˆ¶ç­‰é¢†åŸŸã€‚

## 2 æ ¸å¿ƒç›®æ ‡

1. **å‚æ•°ä¼°è®¡**ï¼šåœ¨çº¿ä¼°è®¡ç³»ç»ŸæœªçŸ¥å‚æ•°
2. **æ§åˆ¶å™¨è°ƒæ•´**ï¼šæ ¹æ®å‚æ•°ä¼°è®¡è°ƒæ•´æ§åˆ¶å™¨
3. **ç¨³å®šæ€§ä¿è¯**ï¼šä¿è¯è‡ªé€‚åº”ç³»ç»Ÿçš„ç¨³å®šæ€§
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šä¼˜åŒ–ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡

## ğŸ“š ç›®å½•

- [05.3.2 è‡ªé€‚åº”æ§åˆ¶ç†è®º](#0532-è‡ªé€‚åº”æ§åˆ¶ç†è®º)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒç›®æ ‡](#-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 è‡ªé€‚åº”æ§åˆ¶å®šä¹‰](#11-è‡ªé€‚åº”æ§åˆ¶å®šä¹‰)
    - [1.2 è‡ªé€‚åº”æ§åˆ¶åˆ†ç±»](#12-è‡ªé€‚åº”æ§åˆ¶åˆ†ç±»)
    - [1.3 è‡ªé€‚åº”æ§åˆ¶é—®é¢˜](#13-è‡ªé€‚åº”æ§åˆ¶é—®é¢˜)
  - [2. å‚æ•°è‡ªé€‚åº”æ§åˆ¶](#2-å‚æ•°è‡ªé€‚åº”æ§åˆ¶)
    - [2.1 çº¿æ€§å‚æ•°åŒ–ç³»ç»Ÿ](#21-çº¿æ€§å‚æ•°åŒ–ç³»ç»Ÿ)
    - [2.2 å‚æ•°ä¼°è®¡å¾‹](#22-å‚æ•°ä¼°è®¡å¾‹)
    - [2.3 è‡ªé€‚åº”æ§åˆ¶å¾‹](#23-è‡ªé€‚åº”æ§åˆ¶å¾‹)
  - [3. æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶](#3-æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶)
    - [3.1 å‚è€ƒæ¨¡å‹](#31-å‚è€ƒæ¨¡å‹)
    - [3.2 MRACæ§åˆ¶å¾‹](#32-mracæ§åˆ¶å¾‹)
    - [3.3 ç¨³å®šæ€§åˆ†æ](#33-ç¨³å®šæ€§åˆ†æ)
  - [4. ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶](#4-ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶)
    - [4.1 ç¥ç»ç½‘ç»œé€¼è¿‘](#41-ç¥ç»ç½‘ç»œé€¼è¿‘)
    - [4.2 ç¥ç»ç½‘ç»œè‡ªé€‚åº”å¾‹](#42-ç¥ç»ç½‘ç»œè‡ªé€‚åº”å¾‹)
    - [4.3 é²æ£’ç¥ç»ç½‘ç»œæ§åˆ¶](#43-é²æ£’ç¥ç»ç½‘ç»œæ§åˆ¶)
  - [5. é²æ£’è‡ªé€‚åº”æ§åˆ¶](#5-é²æ£’è‡ªé€‚åº”æ§åˆ¶)
    - [5.1 æ­»åŒºè‡ªé€‚åº”æ§åˆ¶](#51-æ­»åŒºè‡ªé€‚åº”æ§åˆ¶)
    - [5.2 Ïƒä¿®æ­£](#52-Ïƒä¿®æ­£)
    - [5.3 æŠ•å½±ç®—æ³•](#53-æŠ•å½±ç®—æ³•)
  - [6. è‡ªé€‚åº”è§‚æµ‹å™¨](#6-è‡ªé€‚åº”è§‚æµ‹å™¨)
    - [6.1 è‡ªé€‚åº”è§‚æµ‹å™¨è®¾è®¡](#61-è‡ªé€‚åº”è§‚æµ‹å™¨è®¾è®¡)
    - [6.2 è¾“å‡ºåé¦ˆè‡ªé€‚åº”æ§åˆ¶](#62-è¾“å‡ºåé¦ˆè‡ªé€‚åº”æ§åˆ¶)
  - [7. ä»£ç å®ç°](#7-ä»£ç å®ç°)
    - [7.1 è‡ªé€‚åº”æ§åˆ¶ç³»ç»Ÿæ¡†æ¶](#71-è‡ªé€‚åº”æ§åˆ¶ç³»ç»Ÿæ¡†æ¶)
    - [7.2 é²æ£’è‡ªé€‚åº”æ§åˆ¶](#72-é²æ£’è‡ªé€‚åº”æ§åˆ¶)
    - [7.3 è‡ªé€‚åº”è§‚æµ‹å™¨](#73-è‡ªé€‚åº”è§‚æµ‹å™¨)
  - [8. åº”ç”¨ç¤ºä¾‹](#8-åº”ç”¨ç¤ºä¾‹)
    - [8.1 å€’ç«‹æ‘†è‡ªé€‚åº”æ§åˆ¶](#81-å€’ç«‹æ‘†è‡ªé€‚åº”æ§åˆ¶)
    - [8.2 æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶ç¤ºä¾‹](#82-æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶ç¤ºä¾‹)
    - [8.3 ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶ç¤ºä¾‹](#83-ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶ç¤ºä¾‹)
  - [9. ç›¸å…³ç†è®º](#9-ç›¸å…³ç†è®º)
    - [9.1 ä¸çº¿æ€§æ§åˆ¶ç†è®ºçš„å…³ç³»](#91-ä¸çº¿æ€§æ§åˆ¶ç†è®ºçš„å…³ç³»)
    - [9.2 ä¸éçº¿æ€§æ§åˆ¶ç†è®ºçš„å…³ç³»](#92-ä¸éçº¿æ€§æ§åˆ¶ç†è®ºçš„å…³ç³»)
    - [9.3 ä¸é²æ£’æ§åˆ¶çš„å…³ç³»](#93-ä¸é²æ£’æ§åˆ¶çš„å…³ç³»)
  - [10. å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)
    - [å¤šå…ƒç†è®ºè§†è§’](#å¤šå…ƒç†è®ºè§†è§’)
    - [å±€é™æ€§åˆ†æ](#å±€é™æ€§åˆ†æ)
    - [äº‰è®®ä¸åˆ†æ­§](#äº‰è®®ä¸åˆ†æ­§)
    - [åº”ç”¨å‰æ™¯](#åº”ç”¨å‰æ™¯)
    - [æ”¹è¿›å»ºè®®](#æ”¹è¿›å»ºè®®)

## 3 åŸºæœ¬æ¦‚å¿µ

### 3.1 è‡ªé€‚åº”æ§åˆ¶å®šä¹‰

**å®šä¹‰ 1.1.1** (è‡ªé€‚åº”æ§åˆ¶)
è‡ªé€‚åº”æ§åˆ¶æ˜¯ä¸€ç§æ§åˆ¶ç­–ç•¥ï¼Œå…¶ä¸­æ§åˆ¶å™¨èƒ½å¤Ÿè‡ªåŠ¨è°ƒæ•´å…¶å‚æ•°ä»¥é€‚åº”ç³»ç»Ÿå‚æ•°çš„å˜åŒ–æˆ–æœªçŸ¥æ€§ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
å¯¹äºç³»ç»Ÿ $\dot{x} = f(x, \theta, u)$ï¼Œå…¶ä¸­ $\theta$ æ˜¯æœªçŸ¥å‚æ•°ï¼Œè‡ªé€‚åº”æ§åˆ¶å¾‹ä¸ºï¼š

$$u = u_0(x, \hat{\theta}) + u_a(x, \hat{\theta})$$

å…¶ä¸­ $\hat{\theta}$ æ˜¯å‚æ•°ä¼°è®¡ï¼Œ$u_a$ æ˜¯è‡ªé€‚åº”é¡¹ã€‚

### 3.2 è‡ªé€‚åº”æ§åˆ¶åˆ†ç±»

**å®šä¹‰ 1.2.1** (è‡ªé€‚åº”æ§åˆ¶ç±»å‹)

1. **ç›´æ¥è‡ªé€‚åº”æ§åˆ¶**ï¼šç›´æ¥è°ƒæ•´æ§åˆ¶å™¨å‚æ•°
2. **é—´æ¥è‡ªé€‚åº”æ§åˆ¶**ï¼šå…ˆä¼°è®¡ç³»ç»Ÿå‚æ•°ï¼Œå†è®¾è®¡æ§åˆ¶å™¨
3. **æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶**ï¼šä½¿ç³»ç»Ÿè¾“å‡ºè·Ÿè¸ªå‚è€ƒæ¨¡å‹è¾“å‡º
4. **ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶**ï¼šä½¿ç”¨ç¥ç»ç½‘ç»œé€¼è¿‘æœªçŸ¥å‡½æ•°

### 3.3 è‡ªé€‚åº”æ§åˆ¶é—®é¢˜

**å®šä¹‰ 1.3.1** (è‡ªé€‚åº”æ§åˆ¶é—®é¢˜)
è‡ªé€‚åº”æ§åˆ¶é—®é¢˜å®šä¹‰ä¸ºï¼š

1. **å‚æ•°ä¼°è®¡**ï¼šè®¾è®¡å‚æ•°ä¼°è®¡å¾‹ $\dot{\hat{\theta}} = \tau(x, u, t)$
2. **æ§åˆ¶å™¨è®¾è®¡**ï¼šè®¾è®¡æ§åˆ¶å¾‹ $u = u(x, \hat{\theta}, t)$
3. **ç¨³å®šæ€§åˆ†æ**ï¼šä¿è¯é—­ç¯ç³»ç»Ÿç¨³å®šæ€§
4. **æ€§èƒ½åˆ†æ**ï¼šåˆ†æç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡

## 4 å‚æ•°è‡ªé€‚åº”æ§åˆ¶

### 4.1 çº¿æ€§å‚æ•°åŒ–ç³»ç»Ÿ

**å®šä¹‰ 2.1.1** (çº¿æ€§å‚æ•°åŒ–ç³»ç»Ÿ)
çº¿æ€§å‚æ•°åŒ–ç³»ç»Ÿå¯ä»¥è¡¨ç¤ºä¸ºï¼š

$$\dot{x} = A(\theta)x + B(\theta)u = \sum_{i=1}^{p} \theta_i (A_i x + B_i u)$$

å…¶ä¸­ $\theta_i$ æ˜¯æœªçŸ¥å‚æ•°ï¼Œ$A_i$ å’Œ $B_i$ æ˜¯å·²çŸ¥çŸ©é˜µã€‚

**ä¾‹ 2.1.1** (å€’ç«‹æ‘†å‚æ•°è‡ªé€‚åº”)
å€’ç«‹æ‘†ç³»ç»Ÿçš„å‚æ•°åŒ–æ¨¡å‹ï¼š

$$
\begin{align}
\dot{x}_1 &= x_2 \\
\dot{x}_2 &= \theta_1 \sin(x_1) + \theta_2 x_2 + \theta_3 u
\end{align}
$$

å…¶ä¸­ $\theta_1 = \frac{mgL}{I}$, $\theta_2 = -\frac{b}{I}$, $\theta_3 = \frac{1}{I}$ã€‚

### 4.2 å‚æ•°ä¼°è®¡å¾‹

**å®šç† 2.2.1** (å‚æ•°ä¼°è®¡å¾‹)
å¯¹äºç³»ç»Ÿ $\dot{x} = A(\theta)x + B(\theta)u$ï¼Œå‚æ•°ä¼°è®¡å¾‹ä¸ºï¼š

$$\dot{\hat{\theta}} = -\Gamma \phi(x, u) e^T P$$

å…¶ä¸­ï¼š

- $\Gamma > 0$ æ˜¯è‡ªé€‚åº”å¢ç›ŠçŸ©é˜µ
- $\phi(x, u)$ æ˜¯å›å½’å‘é‡
- $e = x - x_d$ æ˜¯è·Ÿè¸ªè¯¯å·®
- $P > 0$ æ˜¯æ­£å®šçŸ©é˜µ

**è¯æ˜**ï¼š
è€ƒè™‘æé›…æ™®è¯ºå¤«å‡½æ•°ï¼š

$$V = \frac{1}{2}e^T Pe + \frac{1}{2}\tilde{\theta}^T \Gamma^{-1} \tilde{\theta}$$

å…¶ä¸­ $\tilde{\theta} = \hat{\theta} - \theta$ æ˜¯å‚æ•°è¯¯å·®ã€‚

å…¶å¯¼æ•°ä¸ºï¼š

$$\dot{V} = e^T P \dot{e} + \tilde{\theta}^T \Gamma^{-1} \dot{\hat{\theta}}$$

ç”±äº $\dot{e} = A(\theta)x + B(\theta)u - \dot{x}_d$ï¼Œä»£å…¥å¾—åˆ°ï¼š

$$\dot{V} = e^T P(A(\theta)x + B(\theta)u - \dot{x}_d) + \tilde{\theta}^T \Gamma^{-1} \dot{\hat{\theta}}$$

é€‰æ‹©æ§åˆ¶å¾‹ï¼š

$$u = B^{-1}(\hat{\theta})(-A(\hat{\theta})x + \dot{x}_d - Ke)$$

å…¶ä¸­ $K$ ä½¿å¾— $A - BK$ ç¨³å®šã€‚

åˆ™ï¼š

$$\dot{V} = e^T P(A - BK)e + \tilde{\theta}^T \Gamma^{-1} \dot{\hat{\theta}} + e^T P \phi(x, u) \tilde{\theta}$$

é€‰æ‹©å‚æ•°ä¼°è®¡å¾‹ï¼š

$$\dot{\hat{\theta}} = -\Gamma \phi(x, u) e^T P$$

åˆ™ï¼š

$$\dot{V} = e^T P(A - BK)e \leq 0$$

å› æ­¤ç³»ç»Ÿæ˜¯ç¨³å®šçš„ã€‚

### 4.3 è‡ªé€‚åº”æ§åˆ¶å¾‹

**å®šç† 2.3.1** (è‡ªé€‚åº”æ§åˆ¶å¾‹)
å¯¹äºçº¿æ€§å‚æ•°åŒ–ç³»ç»Ÿï¼Œè‡ªé€‚åº”æ§åˆ¶å¾‹ä¸ºï¼š

$$u = B^{-1}(\hat{\theta})(-A(\hat{\theta})x + \dot{x}_d - Ke)$$

å…¶ä¸­ $K$ æ˜¯åé¦ˆå¢ç›ŠçŸ©é˜µï¼Œä½¿å¾— $A - BK$ ç¨³å®šã€‚

## 5 æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶

### 5.1 å‚è€ƒæ¨¡å‹

**å®šä¹‰ 3.1.1** (å‚è€ƒæ¨¡å‹)
å‚è€ƒæ¨¡å‹å®šä¹‰ä¸ºï¼š

$$\dot{x}_m = A_m x_m + B_m r$$

å…¶ä¸­ $A_m$ æ˜¯ç¨³å®šçš„ç³»ç»ŸçŸ©é˜µï¼Œ$B_m$ æ˜¯è¾“å…¥çŸ©é˜µï¼Œ$r$ æ˜¯å‚è€ƒè¾“å…¥ã€‚

**ä¾‹ 3.1.1** (äºŒé˜¶å‚è€ƒæ¨¡å‹)
äºŒé˜¶å‚è€ƒæ¨¡å‹ï¼š

$$
\begin{align}
\dot{x}_{m1} &= x_{m2} \\
\dot{x}_{m2} &= -a_1 x_{m1} - a_2 x_{m2} + b r
\end{align}
$$

å…¶ä¸­ $a_1, a_2 > 0$ ä½¿å¾—ç³»ç»Ÿç¨³å®šã€‚

### 5.2 MRACæ§åˆ¶å¾‹

**å®šç† 3.2.1** (MRACæ§åˆ¶å¾‹)
å¯¹äºç³»ç»Ÿ $\dot{x} = A(\theta)x + B(\theta)u$ï¼ŒMRACæ§åˆ¶å¾‹ä¸ºï¼š

$$u = K_x^T x + K_r^T r$$

å…¶ä¸­è‡ªé€‚åº”å¾‹ä¸ºï¼š

$$
\begin{align}
\dot{K}_x &= -\Gamma_x x e^T P B \\
\dot{K}_r &= -\Gamma_r r e^T P B
\end{align}
$$

å…¶ä¸­ $e = x - x_m$ æ˜¯è·Ÿè¸ªè¯¯å·®ã€‚

**è¯æ˜**ï¼š
è·Ÿè¸ªè¯¯å·®åŠ¨æ€ä¸ºï¼š

$$\dot{e} = A(\theta)x + B(\theta)u - A_m x_m - B_m r$$

ä»£å…¥æ§åˆ¶å¾‹ï¼š

$$\dot{e} = A(\theta)x + B(\theta)(K_x^T x + K_r^T r) - A_m x_m - B_m r$$

æ•´ç†å¾—åˆ°ï¼š

$$\dot{e} = A_m e + B(\theta)(K_x^T - K_x^{*T})x + B(\theta)(K_r^T - K_r^{*T})r$$

å…¶ä¸­ $K_x^*$ å’Œ $K_r^*$ æ˜¯ç†æƒ³å¢ç›Šã€‚

è€ƒè™‘æé›…æ™®è¯ºå¤«å‡½æ•°ï¼š

$$V = \frac{1}{2}e^T Pe + \frac{1}{2}\text{tr}(\tilde{K}_x^T \Gamma_x^{-1} \tilde{K}_x) + \frac{1}{2}\text{tr}(\tilde{K}_r^T \Gamma_r^{-1} \tilde{K}_r)$$

å…¶ä¸­ $\tilde{K}_x = K_x - K_x^*$, $\tilde{K}_r = K_r - K_r^*$ã€‚

å…¶å¯¼æ•°ä¸ºï¼š

$$\dot{V} = e^T P \dot{e} + \text{tr}(\tilde{K}_x^T \Gamma_x^{-1} \dot{K}_x) + \text{tr}(\tilde{K}_r^T \Gamma_r^{-1} \dot{K}_r)$$

é€‰æ‹©è‡ªé€‚åº”å¾‹ï¼š

$$
\begin{align}
\dot{K}_x &= -\Gamma_x x e^T P B \\
\dot{K}_r &= -\Gamma_r r e^T P B
\end{align}
$$

åˆ™ï¼š

$$\dot{V} = e^T P A_m e \leq 0$$

å› æ­¤ç³»ç»Ÿæ˜¯ç¨³å®šçš„ã€‚

### 5.3 ç¨³å®šæ€§åˆ†æ

**å®šç† 3.3.1** (MRACç¨³å®šæ€§)
å¦‚æœå‚è€ƒæ¨¡å‹ç¨³å®šä¸”æ»¡è¶³æŒç»­æ¿€åŠ±æ¡ä»¶ï¼Œåˆ™MRACç³»ç»Ÿæ˜¯æ¸è¿‘ç¨³å®šçš„ã€‚

**æŒç»­æ¿€åŠ±æ¡ä»¶**ï¼š
å­˜åœ¨å¸¸æ•° $T > 0$ å’Œ $\alpha > 0$ï¼Œä½¿å¾—ï¼š

$$\int_t^{t+T} \begin{bmatrix} x(\tau) \\ r(\tau) \end{bmatrix} \begin{bmatrix} x(\tau) \\ r(\tau) \end{bmatrix}^T d\tau \geq \alpha I$$

## 6 ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶

### 6.1 ç¥ç»ç½‘ç»œé€¼è¿‘

**å®šä¹‰ 4.1.1** (ç¥ç»ç½‘ç»œé€¼è¿‘)
å¯¹äºæœªçŸ¥å‡½æ•° $f(x)$ï¼Œå¯ä»¥ä½¿ç”¨ç¥ç»ç½‘ç»œé€¼è¿‘ï¼š

$$f(x) = W^T \phi(x) + \epsilon(x)$$

å…¶ä¸­ï¼š

- $W$ æ˜¯æƒé‡çŸ©é˜µ
- $\phi(x)$ æ˜¯åŸºå‡½æ•°å‘é‡
- $\epsilon(x)$ æ˜¯é€¼è¿‘è¯¯å·®

**ä¾‹ 4.1.1** (å¾„å‘åŸºå‡½æ•°ç½‘ç»œ)
å¾„å‘åŸºå‡½æ•°ç½‘ç»œï¼š

$$\phi_i(x) = \exp\left(-\frac{\|x - c_i\|^2}{2\sigma_i^2}\right)$$

å…¶ä¸­ $c_i$ æ˜¯ä¸­å¿ƒï¼Œ$\sigma_i$ æ˜¯å®½åº¦å‚æ•°ã€‚

### 6.2 ç¥ç»ç½‘ç»œè‡ªé€‚åº”å¾‹

**å®šç† 4.2.1** (ç¥ç»ç½‘ç»œè‡ªé€‚åº”å¾‹)
ç¥ç»ç½‘ç»œæƒé‡è‡ªé€‚åº”å¾‹ä¸ºï¼š

$$\dot{W} = -\Gamma \phi(x) e^T P$$

å…¶ä¸­ $\Gamma > 0$ æ˜¯è‡ªé€‚åº”å¢ç›ŠçŸ©é˜µã€‚

**è¯æ˜**ï¼š
è€ƒè™‘æé›…æ™®è¯ºå¤«å‡½æ•°ï¼š

$$V = \frac{1}{2}e^T Pe + \frac{1}{2}\text{tr}(\tilde{W}^T \Gamma^{-1} \tilde{W})$$

å…¶ä¸­ $\tilde{W} = \hat{W} - W$ æ˜¯æƒé‡è¯¯å·®ã€‚

å…¶å¯¼æ•°ä¸ºï¼š

$$\dot{V} = e^T P \dot{e} + \text{tr}(\tilde{W}^T \Gamma^{-1} \dot{\hat{W}})$$

ç”±äº $\dot{e} = f(x) - \hat{f}(x) - Ke = \tilde{W}^T \phi(x) + \epsilon(x) - Ke$ï¼Œ

é€‰æ‹©è‡ªé€‚åº”å¾‹ï¼š

$$\dot{\hat{W}} = -\Gamma \phi(x) e^T P$$

åˆ™ï¼š

$$\dot{V} = e^T P(\tilde{W}^T \phi(x) + \epsilon(x) - Ke) + \text{tr}(\tilde{W}^T \Gamma^{-1} \dot{\hat{W}})$$

$$= e^T P \epsilon(x) - e^T P K e \leq -\lambda_{\min}(K) \|e\|^2 + \|\epsilon\| \|e\|$$

å¦‚æœé€¼è¿‘è¯¯å·®æœ‰ç•Œï¼Œåˆ™ç³»ç»Ÿæ˜¯ç¨³å®šçš„ã€‚

### 6.3 é²æ£’ç¥ç»ç½‘ç»œæ§åˆ¶

**å®šç† 4.3.1** (é²æ£’ç¥ç»ç½‘ç»œæ§åˆ¶)
è€ƒè™‘é€¼è¿‘è¯¯å·®ï¼Œé²æ£’æ§åˆ¶å¾‹ä¸ºï¼š

$$u = \hat{f}(x) + v_r$$

å…¶ä¸­é²æ£’é¡¹ $v_r$ ä¸ºï¼š

$$v_r = -\eta \frac{e}{\|e\| + \delta}$$

å…¶ä¸­ $\eta > \|\epsilon\|$ æ˜¯é²æ£’å¢ç›Šï¼Œ$\delta > 0$ æ˜¯å°å¸¸æ•°ã€‚

## 7 é²æ£’è‡ªé€‚åº”æ§åˆ¶

### 7.1 æ­»åŒºè‡ªé€‚åº”æ§åˆ¶

**å®šä¹‰ 5.1.1** (æ­»åŒºè‡ªé€‚åº”æ§åˆ¶)
æ­»åŒºè‡ªé€‚åº”æ§åˆ¶ä½¿ç”¨æ­»åŒºå‡½æ•°æ¥é˜²æ­¢å‚æ•°æ¼‚ç§»ï¼š

$$
\dot{\hat{\theta}} = \begin{cases}
-\Gamma \phi(x, u) e^T P & \text{if } \|e\| > \delta \\
0 & \text{if } \|e\| \leq \delta
\end{cases}
$$

å…¶ä¸­ $\delta > 0$ æ˜¯æ­»åŒºå®½åº¦ã€‚

### 7.2 Ïƒä¿®æ­£

**å®šä¹‰ 5.2.1** (Ïƒä¿®æ­£)
Ïƒä¿®æ­£è‡ªé€‚åº”å¾‹ä¸ºï¼š

$$\dot{\hat{\theta}} = -\Gamma \phi(x, u) e^T P - \sigma \hat{\theta}$$

å…¶ä¸­ $\sigma > 0$ æ˜¯ä¿®æ­£å‚æ•°ã€‚

### 7.3 æŠ•å½±ç®—æ³•

**å®šä¹‰ 5.3.1** (æŠ•å½±ç®—æ³•)
æŠ•å½±ç®—æ³•ç¡®ä¿å‚æ•°ä¼°è®¡åœ¨å·²çŸ¥èŒƒå›´å†…ï¼š

$$\dot{\hat{\theta}} = \text{Proj}(-\Gamma \phi(x, u) e^T P, \hat{\theta})$$

å…¶ä¸­æŠ•å½±ç®—å­å®šä¹‰ä¸ºï¼š

$$
\text{Proj}(\tau, \hat{\theta}) = \begin{cases}
\tau & \text{if } \hat{\theta} \in \Omega \text{ or } \nabla P(\hat{\theta})^T \tau \leq 0 \\
\tau - \frac{\nabla P(\hat{\theta}) \nabla P(\hat{\theta})^T}{\|\nabla P(\hat{\theta})\|^2} \tau & \text{otherwise}
\end{cases}
$$

å…¶ä¸­ $P(\hat{\theta})$ æ˜¯å‚æ•°çº¦æŸå‡½æ•°ã€‚

## 8 è‡ªé€‚åº”è§‚æµ‹å™¨

### 8.1 è‡ªé€‚åº”è§‚æµ‹å™¨è®¾è®¡

**å®šä¹‰ 6.1.1** (è‡ªé€‚åº”è§‚æµ‹å™¨)
å¯¹äºç³»ç»Ÿ $\dot{x} = A(\theta)x + B(\theta)u$ï¼Œ$y = Cx$ï¼Œè‡ªé€‚åº”è§‚æµ‹å™¨ä¸ºï¼š

$$\dot{\hat{x}} = A(\hat{\theta})\hat{x} + B(\hat{\theta})u + L(y - \hat{y})$$

å…¶ä¸­ $\hat{y} = C\hat{x}$ï¼Œ$L$ æ˜¯è§‚æµ‹å™¨å¢ç›Šã€‚

**å®šç† 6.1.1** (è‡ªé€‚åº”è§‚æµ‹å™¨å¾‹)
å‚æ•°ä¼°è®¡å¾‹ä¸ºï¼š

$$\dot{\hat{\theta}} = -\Gamma \phi(\hat{x}, u) e_y^T P$$

å…¶ä¸­ $e_y = y - \hat{y}$ æ˜¯è¾“å‡ºè¯¯å·®ã€‚

### 8.2 è¾“å‡ºåé¦ˆè‡ªé€‚åº”æ§åˆ¶

**å®šç† 6.2.1** (è¾“å‡ºåé¦ˆè‡ªé€‚åº”æ§åˆ¶)
å¯¹äºç³»ç»Ÿ $\dot{x} = A(\theta)x + B(\theta)u$ï¼Œ$y = Cx$ï¼Œè¾“å‡ºåé¦ˆè‡ªé€‚åº”æ§åˆ¶å¾‹ä¸ºï¼š

$$u = K(\hat{\theta}) \hat{x}$$

å…¶ä¸­ $\hat{x}$ ç”±è‡ªé€‚åº”è§‚æµ‹å™¨æä¾›ã€‚

## 9 ä»£ç å®ç°

### 9.1 è‡ªé€‚åº”æ§åˆ¶ç³»ç»Ÿæ¡†æ¶

```rust
use nalgebra::{DMatrix, DVector};
use std::f64::consts::PI;

/// è‡ªé€‚åº”æ§åˆ¶ç³»ç»Ÿ
pub struct AdaptiveControlSystem {
    pub theta_hat: DVector<f64>,
    pub gamma: DMatrix<f64>,
    pub P: DMatrix<f64>,
    pub K: DMatrix<f64>,
}

impl AdaptiveControlSystem {
    pub fn new(n_params: usize) -> Self {
        Self {
            theta_hat: DVector::zeros(n_params),
            gamma: DMatrix::identity(n_params, n_params) * 10.0,
            P: DMatrix::identity(2, 2),
            K: DMatrix::from_row_slice(1, 2, &[2.0, 2.0]),
        }
    }

    /// å‚æ•°è‡ªé€‚åº”å¾‹
    pub fn update_parameters(&mut self, phi: &DVector<f64>, e: &DVector<f64>) {
        let update = &self.gamma * phi * e.transpose() * &self.P;
        self.theta_hat = &self.theta_hat - &update.column(0);
    }

    /// è®¡ç®—æ§åˆ¶è¾“å…¥
    pub fn compute_control(&self, x: &DVector<f64>, xd: &DVector<f64>, xd_dot: &DVector<f64>) -> DVector<f64> {
        let e = x - xd;
        let phi = self.regression_vector(x);

        // è‡ªé€‚åº”æ§åˆ¶å¾‹
        let u_nominal = -&self.K * &e + xd_dot;
        let u_adaptive = &phi.transpose() * &self.theta_hat;

        DVector::from_column_slice(&[u_nominal[0] + u_adaptive[0]])
    }

    /// å›å½’å‘é‡
    fn regression_vector(&self, x: &DVector<f64>) -> DVector<f64> {
        DVector::from_column_slice(&[
            x[0].sin(),
            x[1],
            1.0
        ])
    }
}

/// æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶ç³»ç»Ÿ
pub struct MRACSystem {
    pub Kx: DVector<f64>,
    pub Kr: DVector<f64>,
    pub gamma_x: DMatrix<f64>,
    pub gamma_r: DMatrix<f64>,
    pub Am: DMatrix<f64>,
    pub Bm: DVector<f64>,
    pub P: DMatrix<f64>,
}

impl MRACSystem {
    pub fn new() -> Self {
        Self {
            Kx: DVector::zeros(2),
            Kr: DVector::zeros(1),
            gamma_x: DMatrix::identity(2, 2) * 10.0,
            gamma_r: DMatrix::identity(1, 1) * 10.0,
            Am: DMatrix::from_row_slice(2, 2, &[-1.0, 1.0, -1.0, -1.0]),
            Bm: DVector::from_column_slice(&[0.0, 1.0]),
            P: DMatrix::identity(2, 2),
        }
    }

    /// æ›´æ–°å‚è€ƒæ¨¡å‹
    pub fn update_reference_model(&mut self, xm: &mut DVector<f64>, r: f64, dt: f64) {
        let dxm = &self.Am * xm + &self.Bm * r;
        *xm = xm + &(dxm * dt);
    }

    /// æ›´æ–°è‡ªé€‚åº”å‚æ•°
    pub fn update_parameters(&mut self, x: &DVector<f64>, r: f64, e: &DVector<f64>) {
        let update_x = &self.gamma_x * x * e.transpose() * &self.P * DVector::from_column_slice(&[0.0, 1.0]);
        let update_r = &self.gamma_r * DVector::from_column_slice(&[r]) * e.transpose() * &self.P * DVector::from_column_slice(&[0.0, 1.0]);

        self.Kx = &self.Kx - &update_x;
        self.Kr = &self.Kr - &update_r;
    }

    /// è®¡ç®—æ§åˆ¶è¾“å…¥
    pub fn compute_control(&self, x: &DVector<f64>, r: f64) -> f64 {
        self.Kx.transpose() * x + self.Kr[0] * r
    }
}

/// ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶ç³»ç»Ÿ
pub struct NeuralAdaptiveSystem {
    pub weights: DMatrix<f64>,
    pub centers: Vec<DVector<f64>>,
    pub widths: Vec<f64>,
    pub gamma: DMatrix<f64>,
    pub P: DMatrix<f64>,
}

impl NeuralAdaptiveSystem {
    pub fn new(n_neurons: usize, input_dim: usize) -> Self {
        let mut centers = Vec::new();
        let mut widths = Vec::new();

        for i in 0..n_neurons {
            centers.push(DVector::from_column_slice(&[
                (i as f64 - n_neurons as f64 / 2.0) * 0.5,
                (i as f64 - n_neurons as f64 / 2.0) * 0.5
            ]));
            widths.push(1.0);
        }

        Self {
            weights: DMatrix::zeros(n_neurons, 1),
            centers,
            widths,
            gamma: DMatrix::identity(n_neurons, n_neurons) * 10.0,
            P: DMatrix::identity(2, 2),
        }
    }

    /// è®¡ç®—å¾„å‘åŸºå‡½æ•°
    pub fn compute_basis_functions(&self, x: &DVector<f64>) -> DVector<f64> {
        let mut phi = DVector::zeros(self.centers.len());

        for i in 0..self.centers.len() {
            let diff = x - &self.centers[i];
            let distance_squared = diff.transpose() * &diff;
            phi[i] = (-distance_squared / (2.0 * self.widths[i] * self.widths[i])).exp();
        }

        phi
    }

    /// ç¥ç»ç½‘ç»œè¾“å‡º
    pub fn output(&self, x: &DVector<f64>) -> f64 {
        let phi = self.compute_basis_functions(x);
        (self.weights.transpose() * &phi)[0]
    }

    /// æ›´æ–°æƒé‡
    pub fn update_weights(&mut self, x: &DVector<f64>, e: &DVector<f64>) {
        let phi = self.compute_basis_functions(x);
        let update = &self.gamma * &phi * e.transpose() * &self.P * DVector::from_column_slice(&[0.0, 1.0]);
        self.weights = &self.weights - &update;
    }

    /// è®¡ç®—æ§åˆ¶è¾“å…¥
    pub fn compute_control(&self, x: &DVector<f64>, xd: &DVector<f64>, xd_dot: &DVector<f64>) -> f64 {
        let e = x - xd;
        let K = DMatrix::from_row_slice(1, 2, &[2.0, 2.0]);

        let u_nominal = -K * e + xd_dot;
        let u_neural = self.output(x);

        u_nominal[0] + u_neural
    }
}
```

### 9.2 é²æ£’è‡ªé€‚åº”æ§åˆ¶

```rust
/// é²æ£’è‡ªé€‚åº”æ§åˆ¶ç³»ç»Ÿ
pub struct RobustAdaptiveSystem {
    pub theta_hat: DVector<f64>,
    pub gamma: DMatrix<f64>,
    pub sigma: f64,
    pub eta: f64,
    pub delta: f64,
}

impl RobustAdaptiveSystem {
    pub fn new(n_params: usize) -> Self {
        Self {
            theta_hat: DVector::zeros(n_params),
            gamma: DMatrix::identity(n_params, n_params) * 10.0,
            sigma: 0.1,
            eta: 1.0,
            delta: 0.1,
        }
    }

    /// Ïƒä¿®æ­£è‡ªé€‚åº”å¾‹
    pub fn sigma_modification(&mut self, phi: &DVector<f64>, e: &DVector<f64>) {
        let update = &self.gamma * phi * e[0] - &self.gamma * &self.theta_hat * self.sigma;
        self.theta_hat = &self.theta_hat - &update;
    }

    /// æ­»åŒºè‡ªé€‚åº”å¾‹
    pub fn deadzone_modification(&mut self, phi: &DVector<f64>, e: &DVector<f64>) {
        if e.norm() > self.delta {
            let update = &self.gamma * phi * e[0];
            self.theta_hat = &self.theta_hat - &update;
        }
    }

    /// æŠ•å½±ç®—æ³•
    pub fn projection_algorithm(&mut self, phi: &DVector<f64>, e: &DVector<f64>) {
        let tau = &self.gamma * phi * e[0];

        // ç®€å•çš„æŠ•å½±ï¼šé™åˆ¶å‚æ•°èŒƒå›´
        for i in 0..self.theta_hat.len() {
            self.theta_hat[i] = self.theta_hat[i].max(-10.0).min(10.0);
        }

        self.theta_hat = &self.theta_hat - &tau;
    }

    /// é²æ£’æ§åˆ¶é¡¹
    pub fn robust_control_term(&self, e: &DVector<f64>) -> f64 {
        if e.norm() > self.delta {
            -self.eta * e[0] / (e.norm() + self.delta)
        } else {
            0.0
        }
    }
}
```

### 9.3 è‡ªé€‚åº”è§‚æµ‹å™¨

```rust
/// è‡ªé€‚åº”è§‚æµ‹å™¨
pub struct AdaptiveObserver {
    pub x_hat: DVector<f64>,
    pub theta_hat: DVector<f64>,
    pub L: DMatrix<f64>,
    pub gamma: DMatrix<f64>,
    pub P: DMatrix<f64>,
}

impl AdaptiveObserver {
    pub fn new(n_states: usize, n_params: usize) -> Self {
        Self {
            x_hat: DVector::zeros(n_states),
            theta_hat: DVector::zeros(n_params),
            L: DMatrix::from_row_slice(2, 1, &[2.0, 2.0]),
            gamma: DMatrix::identity(n_params, n_params) * 10.0,
            P: DMatrix::identity(2, 2),
        }
    }

    /// æ›´æ–°è§‚æµ‹å™¨çŠ¶æ€
    pub fn update_state(&mut self, u: f64, y: f64, dt: f64) {
        // ç®€åŒ–çš„ç³»ç»Ÿæ¨¡å‹
        let A = DMatrix::from_row_slice(2, 2, &[0.0, 1.0, 0.0, 0.0]);
        let B = DVector::from_column_slice(&[0.0, 1.0]);
        let C = DMatrix::from_row_slice(1, 2, &[1.0, 0.0]);

        let y_hat = [&C * &self.x_hat](0);
        let e_y = y - y_hat;

        // è§‚æµ‹å™¨åŠ¨æ€
        let dx_hat = &A * &self.x_hat + &B * u + &self.L * e_y;
        self.x_hat = &self.x_hat + &(dx_hat * dt);

        // å‚æ•°ä¼°è®¡
        let phi = self.regression_vector(&self.x_hat, u);
        let update = &self.gamma * &phi * e_y;
        self.theta_hat = &self.theta_hat - &update;
    }

    /// å›å½’å‘é‡
    fn regression_vector(&self, x: &DVector<f64>, u: f64) -> DVector<f64> {
        DVector::from_column_slice(&[
            x[0].sin(),
            x[1],
            u
        ])
    }
}
```

## 10 åº”ç”¨ç¤ºä¾‹

### 10.1 å€’ç«‹æ‘†è‡ªé€‚åº”æ§åˆ¶

```rust
/// å€’ç«‹æ‘†è‡ªé€‚åº”æ§åˆ¶ç¤ºä¾‹
pub fn inverted_pendulum_adaptive_control() {
    let mut adaptive_system = AdaptiveControlSystem::new(3);

    // ç³»ç»Ÿå‚æ•°ï¼ˆæœªçŸ¥ï¼‰
    let true_theta = DVector::from_column_slice(&[4.9, -0.1, 0.0]);

    // ä»¿çœŸå‚æ•°
    let dt = 0.01;
    let t_final = 10.0;
    let steps = (t_final / dt) as usize;

    let mut x = DVector::from_column_slice(&[0.5, 0.0]);
    let mut t = 0.0;

    println!("å€’ç«‹æ‘†è‡ªé€‚åº”æ§åˆ¶ä»¿çœŸç»“æœï¼š");

    for step in 0..steps {
        // æœŸæœ›è½¨è¿¹
        let xd = DVector::from_column_slice(&[0.5 * (t).sin(), 0.5 * (t).cos()]);
        let xd_dot = DVector::from_column_slice(&[0.5 * (t).cos(), -0.5 * (t).sin()]);

        // è®¡ç®—æ§åˆ¶è¾“å…¥
        let u = adaptive_system.compute_control(&x, &xd, &xd_dot);

        // ç³»ç»ŸåŠ¨æ€ï¼ˆä½¿ç”¨çœŸå®å‚æ•°ï¼‰
        let phi = adaptive_system.regression_vector(&x);
        let dx = DVector::from_column_slice(&[
            x[1],
            phi.transpose() * &true_theta + u[0]
        ]) * dt;

        x = &x + &dx;

        // æ›´æ–°è‡ªé€‚åº”å‚æ•°
        let e = &x - &xd;
        adaptive_system.update_parameters(&phi, &e);

        t += dt;

        if step % 100 == 0 {
            println!("t={:.1}s: å®é™…è§’åº¦={:.3}rad, æœŸæœ›è§’åº¦={:.3}rad, å‚æ•°ä¼°è®¡=[{:.3}, {:.3}, {:.3}]",
                t, x[0], xd[0], adaptive_system.theta_hat[0],
                adaptive_system.theta_hat[1], adaptive_system.theta_hat[2]);
        }
    }

    println!("æœ€ç»ˆå‚æ•°ä¼°è®¡: [{:.3}, {:.3}, {:.3}]",
        adaptive_system.theta_hat[0], adaptive_system.theta_hat[1], adaptive_system.theta_hat[2]);
    println!("çœŸå®å‚æ•°: [{:.3}, {:.3}, {:.3}]",
        true_theta[0], true_theta[1], true_theta[2]);
}
```

### 10.2 æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶ç¤ºä¾‹

```rust
/// æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶ç¤ºä¾‹
pub fn mrac_example() {
    let mut mrac_system = MRACSystem::new();

    // ä»¿çœŸå‚æ•°
    let dt = 0.01;
    let t_final = 10.0;
    let steps = (t_final / dt) as usize;

    let mut x = DVector::from_column_slice(&[0.5, 0.0]);
    let mut xm = DVector::from_column_slice(&[0.0, 0.0]);
    let mut t = 0.0;

    println!("æ¨¡å‹å‚è€ƒè‡ªé€‚åº”æ§åˆ¶ä»¿çœŸç»“æœï¼š");

    for step in 0..steps {
        // å‚è€ƒè¾“å…¥
        let r = 0.5 * (t).sin();

        // æ›´æ–°å‚è€ƒæ¨¡å‹
        mrac_system.update_reference_model(&mut xm, r, dt);

        // è®¡ç®—æ§åˆ¶è¾“å…¥
        let u = mrac_system.compute_control(&x, r);

        // ç³»ç»ŸåŠ¨æ€
        let dx = DVector::from_column_slice(&[
            x[1],
            -x[0].sin() - 0.1 * x[1] + u
        ]) * dt;

        x = &x + &dx;

        // æ›´æ–°è‡ªé€‚åº”å‚æ•°
        let e = &x - &xm;
        mrac_system.update_parameters(&x, r, &e);

        t += dt;

        if step % 100 == 0 {
            println!("t={:.1}s: å®é™…çŠ¶æ€=[{:.3}, {:.3}], å‚è€ƒçŠ¶æ€=[{:.3}, {:.3}], æ§åˆ¶={:.3}",
                t, x[0], x[1], xm[0], xm[1], u);
        }
    }
}
```

### 10.3 ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶ç¤ºä¾‹

```rust
/// ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶ç¤ºä¾‹
pub fn neural_adaptive_control_example() {
    let mut neural_system = NeuralAdaptiveSystem::new(10, 2);

    // ä»¿çœŸå‚æ•°
    let dt = 0.01;
    let t_final = 10.0;
    let steps = (t_final / dt) as usize;

    let mut x = DVector::from_column_slice(&[0.5, 0.0]);
    let mut t = 0.0;

    println!("ç¥ç»ç½‘ç»œè‡ªé€‚åº”æ§åˆ¶ä»¿çœŸç»“æœï¼š");

    for step in 0..steps {
        // æœŸæœ›è½¨è¿¹
        let xd = DVector::from_column_slice(&[0.5 * (t).sin(), 0.5 * (t).cos()]);
        let xd_dot = DVector::from_column_slice(&[0.5 * (t).cos(), -0.5 * (t).sin()]);

        // è®¡ç®—æ§åˆ¶è¾“å…¥
        let u = neural_system.compute_control(&x, &xd, &xd_dot);

        // ç³»ç»ŸåŠ¨æ€ï¼ˆåŒ…å«æœªçŸ¥éçº¿æ€§é¡¹ï¼‰
        let unknown_nonlinearity = 0.1 * x[0].sin() * x[1].cos();
        let dx = DVector::from_column_slice(&[
            x[1],
            u + unknown_nonlinearity
        ]) * dt;

        x = &x + &dx;

        // æ›´æ–°ç¥ç»ç½‘ç»œæƒé‡
        let e = &x - &xd;
        neural_system.update_weights(&x, &e);

        t += dt;

        if step % 100 == 0 {
            println!("t={:.1}s: å®é™…çŠ¶æ€=[{:.3}, {:.3}], æœŸæœ›çŠ¶æ€=[{:.3}, {:.3}], æ§åˆ¶={:.3}",
                t, x[0], x[1], xd[0], xd[1], u);
        }
    }
}
```

## 11 ç›¸å…³ç†è®º

### 11.1 ä¸çº¿æ€§æ§åˆ¶ç†è®ºçš„å…³ç³»

è‡ªé€‚åº”æ§åˆ¶ç†è®ºæ‰©å±•äº†çº¿æ€§æ§åˆ¶ç†è®ºï¼š

1. **å‚æ•°ä¸ç¡®å®šæ€§**ï¼šå¤„ç†å‚æ•°æœªçŸ¥æˆ–æ—¶å˜çš„ç³»ç»Ÿ
2. **åœ¨çº¿å­¦ä¹ **ï¼šå®æ—¶å­¦ä¹ å’Œè°ƒæ•´æ§åˆ¶å™¨å‚æ•°
3. **é²æ£’æ€§**ï¼šç»“åˆé²æ£’æ§åˆ¶ç†è®ºå¤„ç†ä¸ç¡®å®šæ€§

### 11.2 ä¸éçº¿æ€§æ§åˆ¶ç†è®ºçš„å…³ç³»

è‡ªé€‚åº”æ§åˆ¶ç†è®ºä¸éçº¿æ€§æ§åˆ¶ç†è®ºç»“åˆï¼š

1. **éçº¿æ€§è‡ªé€‚åº”**ï¼šå¤„ç†éçº¿æ€§ç³»ç»Ÿçš„å‚æ•°è‡ªé€‚åº”
2. **ç¥ç»ç½‘ç»œæ§åˆ¶**ï¼šä½¿ç”¨ç¥ç»ç½‘ç»œé€¼è¿‘æœªçŸ¥éçº¿æ€§å‡½æ•°
3. **åæ­¥æ³•è‡ªé€‚åº”**ï¼šç»“åˆåæ­¥æ³•è®¾è®¡è‡ªé€‚åº”æ§åˆ¶å™¨

### 11.3 ä¸é²æ£’æ§åˆ¶çš„å…³ç³»

è‡ªé€‚åº”æ§åˆ¶ç†è®ºä¸é²æ£’æ§åˆ¶ç†è®ºäº’è¡¥ï¼š

1. **ä¸ç¡®å®šæ€§ç±»å‹**ï¼šè‡ªé€‚åº”æ§åˆ¶å¤„ç†å‚æ•°ä¸ç¡®å®šæ€§ï¼Œé²æ£’æ§åˆ¶å¤„ç†æœ‰ç•Œä¸ç¡®å®šæ€§
2. **è®¾è®¡æ–¹æ³•**ï¼šè‡ªé€‚åº”æ§åˆ¶åœ¨çº¿å­¦ä¹ ï¼Œé²æ£’æ§åˆ¶ç¦»çº¿è®¾è®¡
3. **æ€§èƒ½ä¿è¯**ï¼šä¸¤è€…éƒ½æä¾›æ€§èƒ½ä¿è¯ï¼Œä½†æ–¹æ³•ä¸åŒ

## 10. å‚è€ƒæ–‡çŒ®

1. Ioannou, P. A., & Sun, J. (2012). Robust Adaptive Control. Dover Publications.
2. Narendra, K. S., & Annaswamy, A. M. (2012). Stable Adaptive Systems. Dover Publications.
3. Sastry, S., & Bodson, M. (2011). Adaptive Control: Stability, Convergence and Robustness. Dover Publications.
4. Krstic, M., Kanellakopoulos, I., & Kokotovic, P. V. (1995). Nonlinear and Adaptive Control Design. John Wiley & Sons.
5. Lewis, F. L., Jagannathan, S., & Yesildirek, A. (1999). Neural Network Control of Robot Manipulators and Nonlinear Systems. CRC Press.
6. Astrom, K. J., & Wittenmark, B. (2013). Adaptive Control. Dover Publications.
7. Landau, I. D., Lozano, R., M'Saad, M., & Karimi, A. (2011). Adaptive Control: Algorithms, Analysis and Applications. Springer.
8. Tao, G. (2014). Adaptive Control Design and Analysis. John Wiley & Sons.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [05.2.1 ç°ä»£æ§åˆ¶ç†è®º](05.2.1_ç°ä»£æ§åˆ¶ç†è®º.md)
- [05.2.2 æœ€ä¼˜æ§åˆ¶ç†è®º](05.2.2_æœ€ä¼˜æ§åˆ¶ç†è®º.md)
- [05.2.3 é²æ£’æ§åˆ¶ç†è®º](05.2.3_é²æ£’æ§åˆ¶ç†è®º.md)
- [05.3.1 éçº¿æ€§æ§åˆ¶ç†è®º](05.3.1_éçº¿æ€§æ§åˆ¶ç†è®º.md)

## 12 æ‰¹åˆ¤æ€§åˆ†æ

### 12.1 å¤šå…ƒç†è®ºè§†è§’

**è¾¨è¯†-æ§åˆ¶ä¸€ä½“è§†è§’**ï¼šå‚æ•°ä¼°è®¡ä¸æ§åˆ¶å¾‹ååŒä¿è¯ç¨³å®šä¸è·Ÿè¸ªï¼Œä½†è¾¨è¯†æ¿€åŠ±ä¸é—­ç¯æ€§èƒ½å­˜åœ¨å†…åœ¨å¼ åŠ›ã€‚

**é²æ£’èåˆè§†è§’**ï¼šÏƒä¿®æ­£ã€æ­»åŒºã€æŠ•å½±ç­‰ç¼“è§£æ¼‚ç§»ä¸å™ªå£°å½±å“ï¼Œä»£ä»·æ˜¯ç¨³æ€è¯¯å·®ä¸ä¿å®ˆæ€§ã€‚

**å­¦ä¹ å¢å¼ºè§†è§’**ï¼šNN/RBFç­‰æå‡é€¼è¿‘èƒ½åŠ›ï¼Œä½†å¼•å…¥å¯è§£é‡Šæ€§ä¸ç¨³å®šæ€§ä¿è¯éš¾é¢˜ã€‚

### 12.2 å±€é™æ€§åˆ†æ

**æŒç»­æ¿€åŠ±(PE)è¦æ±‚**ï¼šç¼ºä¹å……åˆ†æ¿€åŠ±æ—¶ï¼Œå‚æ•°ä¸å¯è¾¨è¯†ï¼Œå¯¼è‡´æ”¶æ•›ä¸æ€§èƒ½æ— ä¿è¯ã€‚

**éçº¿æ€§ä¸æ—¶å˜**ï¼šå¼ºéçº¿æ€§/å¿«é€Ÿæ—¶å˜ä¸‹ï¼Œç»å…¸æ¢¯åº¦/æœ€å°äºŒä¹˜é€‚ç”¨æ€§ä¸‹é™ï¼Œéœ€è¦å¤åˆè‡ªé€‚åº”ä¸é²æ£’é¡¹ã€‚

**å™ªå£°ä¸æ‰°åŠ¨**ï¼šæµ‹å™ªä¸æœªå»ºæ¨¡åŠ¨æ€ä¼šè¯±å¯¼å‚æ•°å‘æ•£ï¼›æ­£åˆ™åŒ–æé«˜ç¨³å¥æ€§ä½†ç‰ºç‰²æ€§èƒ½ã€‚

**å®ç°å¤æ‚åº¦**ï¼šåœ¨çº¿ä¼°è®¡ã€æŠ•å½±/é¥±å’Œä¸è§‚æµ‹å™¨è€¦åˆä½¿è®¾è®¡è°ƒå‚å¤æ‚ã€éªŒè¯æˆæœ¬é«˜ã€‚

### 12.3 äº‰è®®ä¸åˆ†æ­§

**ç›´æ¥vsé—´æ¥**ï¼šç›´æ¥æ³•å“åº”å¿«ä½†ç¨³å®šä¿è¯éš¾ï¼Œé—´æ¥æ³•ç†è®ºæ¸…æ™°ä½†å¯¹ä¼°è®¡è´¨é‡æ•æ„Ÿã€‚

**æœ€ä¼˜vsç¨³å®šä¼˜å…ˆ**ï¼šæ˜¯å¦å¼•å…¥æ€§èƒ½æœ€ä¼˜ç›®æ ‡ï¼ˆå¦‚æœ€å°æ–¹å·®ï¼‰ä¸ç¨³å®šæ€§çº¦æŸçš„æƒè¡¡è·¯å¾„ã€‚

**å­¦ä¹ è§„æ¨¡åŒ–**ï¼šå¤§è§„æ¨¡ç¥ç»è‡ªé€‚åº”çš„å®‰å…¨æ€§ä¸å¯éªŒè¯æ€§ä»å­˜åˆ†æ­§ã€‚

### 12.4 åº”ç”¨å‰æ™¯

**èˆªå¤©/æœºå™¨äºº**ï¼šè´Ÿè½½å˜åŒ–ã€ç¯å¢ƒä¸ç¡®å®šä¸‹çš„åœ¨çº¿é€‚é…éœ€æ±‚å¼ºã€‚

**å·¥ä¸šè¿‡ç¨‹ä¸èƒ½æº**ï¼šæ…¢æ¼‚ç§»ã€å·¥å†µåˆ‡æ¢ä¸‹çš„æ€§èƒ½ä¿æŒä¸èŠ‚èƒ½ä¼˜åŒ–ã€‚

**äººæœºåä½œä¸åŒ»ç–—**ï¼šä¸ªä½“å·®å¼‚ä¸æ—¶å˜ç‰¹æ€§éœ€è¦å®‰å…¨å¯è¯çš„è‡ªé€‚åº”ç­–ç•¥ã€‚

### 12.5 æ”¹è¿›å»ºè®®

**PEæ›¿ä»£ä¸æ¿€åŠ±è®¾è®¡**ï¼šé‡‡ç”¨å¤åˆè‡ªé€‚åº”ã€æœ‰é™è®°å¿†/æŒ‡ä»¤æ»¤æ³¢ç­‰æ„é€ â€œç­‰æ•ˆæ¿€åŠ±â€ã€‚

**é²æ£’-è‡ªé€‚åº”ä¸€ä½“åŒ–**ï¼šç»“åˆHâˆ/CBF/è§‚æµ‹å™¨ï¼Œå®ç°å®‰å…¨çº¦æŸä¸æœ€åæƒ…å†µä¿è¯ã€‚

**å¯è¯å­¦ä¹ **ï¼šåœ¨è‡ªé€‚åº”å¾‹ä¸­åµŒå…¥è¯æ®ç•Œä¸ä¸ç¡®å®šåº¦é‡ï¼ˆè´å¶æ–¯/åŒºé—´ï¼‰ï¼Œæå‡å¯éªŒè¯æ€§ã€‚
