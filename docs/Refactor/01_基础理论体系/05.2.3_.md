# 05.2.3 é²æ£’æ§åˆ¶ç†è®º

## ğŸ“‹ ç›®å½•

- [1 æ¦‚è¿°](#1-æ¦‚è¿°)
- [2 æ ¸å¿ƒç›®æ ‡](#2-æ ¸å¿ƒç›®æ ‡)
- [3 åŸºæœ¬æ¦‚å¿µ](#3-åŸºæœ¬æ¦‚å¿µ)
  - [3.1 é²æ£’æ€§å®šä¹‰](#31-é²æ£’æ€§å®šä¹‰)
  - [3.2 ä¸ç¡®å®šæ€§åˆ†ç±»](#32-ä¸ç¡®å®šæ€§åˆ†ç±»)
  - [3.3 é²æ£’æ§åˆ¶é—®é¢˜](#33-é²æ£’æ§åˆ¶é—®é¢˜)
- [4 ä¸ç¡®å®šæ€§å»ºæ¨¡](#4-ä¸ç¡®å®šæ€§å»ºæ¨¡)
  - [4.1 å‚æ•°ä¸ç¡®å®šæ€§](#41-å‚æ•°ä¸ç¡®å®šæ€§)
  - [4.2 éå‚æ•°ä¸ç¡®å®šæ€§](#42-éå‚æ•°ä¸ç¡®å®šæ€§)
  - [4.3 ç»“æ„ä¸ç¡®å®šæ€§](#43-ç»“æ„ä¸ç¡®å®šæ€§)
- [5 é²æ£’ç¨³å®šæ€§ç†è®º](#5-é²æ£’ç¨³å®šæ€§ç†è®º)
  - [5.1 å°å¢ç›Šå®šç†](#51-å°å¢ç›Šå®šç†)
  - [5.2 é²æ£’ç¨³å®šæ€§æ¡ä»¶](#52-é²æ£’ç¨³å®šæ€§æ¡ä»¶)
  - [5.3 ç»“æ„å¥‡å¼‚å€¼](#53-ç»“æ„å¥‡å¼‚å€¼)
- [6 Hæ§åˆ¶ç†è®º](#6-hæ§åˆ¶ç†è®º)
  - [6.1 HèŒƒæ•°](#61-hèŒƒæ•°)
  - [6.2 Hæ§åˆ¶é—®é¢˜](#62-hæ§åˆ¶é—®é¢˜)
  - [6.3 Hæ§åˆ¶å™¨è®¾è®¡](#63-hæ§åˆ¶å™¨è®¾è®¡)
  - [6.4 æ··åˆçµæ•åº¦é—®é¢˜](#64-æ··åˆçµæ•åº¦é—®é¢˜)
- [7 Î¼ç»¼åˆç†è®º](#7-Î¼ç»¼åˆç†è®º)
  - [7.1 Î¼ç»¼åˆé—®é¢˜](#71-Î¼ç»¼åˆé—®é¢˜)
  - [7.2 D-Kè¿­ä»£](#72-d-kè¿­ä»£)
  - [7.3 Î¼ä¸Šç•Œ](#73-Î¼ä¸Šç•Œ)
- [8 çº¿æ€§çŸ©é˜µä¸ç­‰å¼](#8-çº¿æ€§çŸ©é˜µä¸ç­‰å¼)
  - [8.1 LMIåŸºç¡€](#81-lmiåŸºç¡€)
  - [8.2 é²æ£’ç¨³å®šæ€§LMI](#82-é²æ£’ç¨³å®šæ€§lmi)
  - [8.3 Hæ§åˆ¶LMI](#83-hæ§åˆ¶lmi)
- [9 ä»£ç å®ç°](#9-ä»£ç å®ç°)
  - [9.1 é²æ£’æ§åˆ¶ç³»ç»Ÿæ¡†æ¶](#91-é²æ£’æ§åˆ¶ç³»ç»Ÿæ¡†æ¶)
  - [9.2 Î¼ç»¼åˆç®—æ³•](#92-Î¼ç»¼åˆç®—æ³•)
  - [9.3 LMIæ±‚è§£å™¨](#93-lmiæ±‚è§£å™¨)
- [10 åº”ç”¨ç¤ºä¾‹](#10-åº”ç”¨ç¤ºä¾‹)
  - [10.1 å€’ç«‹æ‘†é²æ£’æ§åˆ¶](#101-å€’ç«‹æ‘†é²æ£’æ§åˆ¶)
  - [10.2 Î¼ç»¼åˆç¤ºä¾‹](#102-Î¼ç»¼åˆç¤ºä¾‹)
- [11 ç›¸å…³ç†è®º](#11-ç›¸å…³ç†è®º)
  - [11.1 ä¸ç°ä»£æ§åˆ¶ç†è®ºçš„å…³ç³»](#111-ä¸ç°ä»£æ§åˆ¶ç†è®ºçš„å…³ç³»)
  - [11.2 ä¸æœ€ä¼˜æ§åˆ¶ç†è®ºçš„å…³ç³»](#112-ä¸æœ€ä¼˜æ§åˆ¶ç†è®ºçš„å…³ç³»)
  - [11.3 ä¸è‡ªé€‚åº”æ§åˆ¶çš„å…³ç³»](#113-ä¸è‡ªé€‚åº”æ§åˆ¶çš„å…³ç³»)
- [12 æ‰¹åˆ¤æ€§åˆ†æ](#12-æ‰¹åˆ¤æ€§åˆ†æ)
  - [12.1 å¤šå…ƒç†è®ºè§†è§’](#121-å¤šå…ƒç†è®ºè§†è§’)
  - [12.2 å±€é™æ€§åˆ†æ](#122-å±€é™æ€§åˆ†æ)
  - [12.3 äº‰è®®ä¸åˆ†æ­§](#123-äº‰è®®ä¸åˆ†æ­§)
  - [12.4 åº”ç”¨å‰æ™¯](#124-åº”ç”¨å‰æ™¯)
  - [12.5 æ”¹è¿›å»ºè®®](#125-æ”¹è¿›å»ºè®®)

---

## 1 æ¦‚è¿°

é²æ£’æ§åˆ¶ç†è®ºæ˜¯ç°ä»£æ§åˆ¶ç†è®ºçš„é‡è¦åˆ†æ”¯ï¼Œç ”ç©¶å¦‚ä½•è®¾è®¡æ§åˆ¶å™¨ä½¿å¾—ç³»ç»Ÿåœ¨å­˜åœ¨å‚æ•°ä¸ç¡®å®šæ€§ã€å¤–éƒ¨æ‰°åŠ¨å’Œå»ºæ¨¡è¯¯å·®çš„æƒ…å†µä¸‹ä»èƒ½ä¿æŒæœŸæœ›çš„æ€§èƒ½ã€‚é²æ£’æ§åˆ¶ç†è®ºä¸ºå¤æ‚ç³»ç»Ÿçš„æ§åˆ¶è®¾è®¡æä¾›äº†å¼ºæœ‰åŠ›çš„å·¥å…·ï¼Œå¹¿æ³›åº”ç”¨äºèˆªç©ºèˆªå¤©ã€æœºå™¨äººã€å·¥ä¸šè¿‡ç¨‹æ§åˆ¶ç­‰é¢†åŸŸã€‚

## 2 æ ¸å¿ƒç›®æ ‡

1. **ä¸ç¡®å®šæ€§å»ºæ¨¡**ï¼šå»ºç«‹ç³»ç»Ÿä¸ç¡®å®šæ€§çš„æ•°å­¦æ¨¡å‹
2. **é²æ£’ç¨³å®šæ€§**ï¼šä¿è¯ç³»ç»Ÿåœ¨ä¸ç¡®å®šæ€§ä¸‹çš„ç¨³å®šæ€§
3. **é²æ£’æ€§èƒ½**ï¼šä¿è¯ç³»ç»Ÿåœ¨ä¸ç¡®å®šæ€§ä¸‹çš„æ€§èƒ½æŒ‡æ ‡
4. **æ§åˆ¶å™¨è®¾è®¡**ï¼šè®¾è®¡å…·æœ‰é²æ£’æ€§çš„æ§åˆ¶å™¨

## ğŸ“š ç›®å½•

- [05.2.3 é²æ£’æ§åˆ¶ç†è®º](#0523-é²æ£’æ§åˆ¶ç†è®º)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒç›®æ ‡](#-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 é²æ£’æ€§å®šä¹‰](#11-é²æ£’æ€§å®šä¹‰)
    - [1.2 ä¸ç¡®å®šæ€§åˆ†ç±»](#12-ä¸ç¡®å®šæ€§åˆ†ç±»)
    - [1.3 é²æ£’æ§åˆ¶é—®é¢˜](#13-é²æ£’æ§åˆ¶é—®é¢˜)
  - [2. ä¸ç¡®å®šæ€§å»ºæ¨¡](#2-ä¸ç¡®å®šæ€§å»ºæ¨¡)
    - [2.1 å‚æ•°ä¸ç¡®å®šæ€§](#21-å‚æ•°ä¸ç¡®å®šæ€§)
    - [2.2 éå‚æ•°ä¸ç¡®å®šæ€§](#22-éå‚æ•°ä¸ç¡®å®šæ€§)
    - [2.3 ç»“æ„ä¸ç¡®å®šæ€§](#23-ç»“æ„ä¸ç¡®å®šæ€§)
  - [3. é²æ£’ç¨³å®šæ€§ç†è®º](#3-é²æ£’ç¨³å®šæ€§ç†è®º)
    - [3.1 å°å¢ç›Šå®šç†](#31-å°å¢ç›Šå®šç†)
    - [3.2 é²æ£’ç¨³å®šæ€§æ¡ä»¶](#32-é²æ£’ç¨³å®šæ€§æ¡ä»¶)
    - [3.3 ç»“æ„å¥‡å¼‚å€¼](#33-ç»“æ„å¥‡å¼‚å€¼)
  - [4. Hâˆæ§åˆ¶ç†è®º](#4-hæ§åˆ¶ç†è®º)
    - [4.1 HâˆèŒƒæ•°](#41-hèŒƒæ•°)
    - [4.2 Hâˆæ§åˆ¶é—®é¢˜](#42-hæ§åˆ¶é—®é¢˜)
    - [4.3 Hâˆæ§åˆ¶å™¨è®¾è®¡](#43-hæ§åˆ¶å™¨è®¾è®¡)
    - [4.4 æ··åˆçµæ•åº¦é—®é¢˜](#44-æ··åˆçµæ•åº¦é—®é¢˜)
  - [5. Î¼ç»¼åˆç†è®º](#5-Î¼ç»¼åˆç†è®º)
    - [5.1 Î¼ç»¼åˆé—®é¢˜](#51-Î¼ç»¼åˆé—®é¢˜)
    - [5.2 D-Kè¿­ä»£](#52-d-kè¿­ä»£)
    - [5.3 Î¼ä¸Šç•Œ](#53-Î¼ä¸Šç•Œ)
  - [6. çº¿æ€§çŸ©é˜µä¸ç­‰å¼](#6-çº¿æ€§çŸ©é˜µä¸ç­‰å¼)
    - [6.1 LMIåŸºç¡€](#61-lmiåŸºç¡€)
    - [6.2 é²æ£’ç¨³å®šæ€§LMI](#62-é²æ£’ç¨³å®šæ€§lmi)
    - [6.3 Hâˆæ§åˆ¶LMI](#63-hæ§åˆ¶lmi)
  - [7. ä»£ç å®ç°](#7-ä»£ç å®ç°)
    - [7.1 é²æ£’æ§åˆ¶ç³»ç»Ÿæ¡†æ¶](#71-é²æ£’æ§åˆ¶ç³»ç»Ÿæ¡†æ¶)
    - [7.2 Î¼ç»¼åˆç®—æ³•](#72-Î¼ç»¼åˆç®—æ³•)
    - [7.3 LMIæ±‚è§£å™¨](#73-lmiæ±‚è§£å™¨)
  - [8. åº”ç”¨ç¤ºä¾‹](#8-åº”ç”¨ç¤ºä¾‹)
    - [8.1 å€’ç«‹æ‘†é²æ£’æ§åˆ¶](#81-å€’ç«‹æ‘†é²æ£’æ§åˆ¶)
    - [8.2 Î¼ç»¼åˆç¤ºä¾‹](#82-Î¼ç»¼åˆç¤ºä¾‹)
  - [9. ç›¸å…³ç†è®º](#9-ç›¸å…³ç†è®º)
    - [9.1 ä¸ç°ä»£æ§åˆ¶ç†è®ºçš„å…³ç³»](#91-ä¸ç°ä»£æ§åˆ¶ç†è®ºçš„å…³ç³»)
    - [9.2 ä¸æœ€ä¼˜æ§åˆ¶ç†è®ºçš„å…³ç³»](#92-ä¸æœ€ä¼˜æ§åˆ¶ç†è®ºçš„å…³ç³»)
    - [9.3 ä¸è‡ªé€‚åº”æ§åˆ¶çš„å…³ç³»](#93-ä¸è‡ªé€‚åº”æ§åˆ¶çš„å…³ç³»)
  - [10. å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)
    - [å¤šå…ƒç†è®ºè§†è§’](#å¤šå…ƒç†è®ºè§†è§’)
    - [å±€é™æ€§åˆ†æ](#å±€é™æ€§åˆ†æ)
    - [äº‰è®®ä¸åˆ†æ­§](#äº‰è®®ä¸åˆ†æ­§)
    - [åº”ç”¨å‰æ™¯](#åº”ç”¨å‰æ™¯)
    - [æ”¹è¿›å»ºè®®](#æ”¹è¿›å»ºè®®)

## 3 åŸºæœ¬æ¦‚å¿µ

### 3.1 é²æ£’æ€§å®šä¹‰

**å®šä¹‰ 1.1.1** (é²æ£’æ€§)
ç³»ç»Ÿåœ¨å­˜åœ¨ä¸ç¡®å®šæ€§æ—¶ä»èƒ½ä¿æŒæœŸæœ›æ€§èƒ½çš„èƒ½åŠ›ç§°ä¸ºé²æ£’æ€§ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
è®¾æ ‡ç§°ç³»ç»Ÿä¸º $G_0(s)$ï¼Œä¸ç¡®å®šæ€§ä¸º $\Delta(s)$ï¼Œå®é™…ç³»ç»Ÿä¸º $G(s) = G_0(s) + \Delta(s)$ã€‚
å¦‚æœå¯¹äºæ‰€æœ‰ $\Delta(s) \in \mathcal{U}$ï¼ˆä¸ç¡®å®šæ€§é›†åˆï¼‰ï¼Œç³»ç»Ÿéƒ½èƒ½æ»¡è¶³æ€§èƒ½è¦æ±‚ï¼Œåˆ™ç§°ç³»ç»Ÿå…·æœ‰é²æ£’æ€§ã€‚

### 3.2 ä¸ç¡®å®šæ€§åˆ†ç±»

**å®šä¹‰ 1.2.1** (ä¸ç¡®å®šæ€§ç±»å‹)

1. **å‚æ•°ä¸ç¡®å®šæ€§**ï¼šç³»ç»Ÿå‚æ•°åœ¨æŸä¸ªèŒƒå›´å†…å˜åŒ–
2. **éå‚æ•°ä¸ç¡®å®šæ€§**ï¼šç³»ç»Ÿç»“æ„æˆ–é˜¶æ•°çš„ä¸ç¡®å®šæ€§
3. **å¤–éƒ¨æ‰°åŠ¨**ï¼šä½œç”¨äºç³»ç»Ÿçš„å¤–éƒ¨å¹²æ‰°
4. **å»ºæ¨¡è¯¯å·®**ï¼šæ•°å­¦æ¨¡å‹ä¸å®é™…ç³»ç»Ÿçš„å·®å¼‚

### 3.3 é²æ£’æ§åˆ¶é—®é¢˜

**å®šä¹‰ 1.3.1** (é²æ£’æ§åˆ¶é—®é¢˜)
é²æ£’æ§åˆ¶é—®é¢˜å®šä¹‰ä¸ºï¼šè®¾è®¡æ§åˆ¶å™¨ $K(s)$ï¼Œä½¿å¾—é—­ç¯ç³»ç»Ÿåœ¨å­˜åœ¨ä¸ç¡®å®šæ€§æ—¶æ»¡è¶³ï¼š

1. **é²æ£’ç¨³å®šæ€§**ï¼šé—­ç¯ç³»ç»Ÿå¯¹æ‰€æœ‰ä¸ç¡®å®šæ€§éƒ½ç¨³å®š
2. **é²æ£’æ€§èƒ½**ï¼šé—­ç¯ç³»ç»Ÿå¯¹æ‰€æœ‰ä¸ç¡®å®šæ€§éƒ½æ»¡è¶³æ€§èƒ½è¦æ±‚

## 4 ä¸ç¡®å®šæ€§å»ºæ¨¡

### 4.1 å‚æ•°ä¸ç¡®å®šæ€§

**å®šä¹‰ 2.1.1** (å‚æ•°ä¸ç¡®å®šæ€§æ¨¡å‹)
å‚æ•°ä¸ç¡®å®šæ€§å¯ä»¥å»ºæ¨¡ä¸ºï¼š

$$G(s, \theta) = G_0(s) + \sum_{i=1}^{p} \theta_i G_i(s)$$

å…¶ä¸­ $\theta_i \in [\theta_i^-, \theta_i^+]$ æ˜¯æœªçŸ¥å‚æ•°ã€‚

**ä¾‹ 2.1.1** (è´¨é‡-å¼¹ç°§-é˜»å°¼ç³»ç»Ÿ)
è€ƒè™‘è´¨é‡-å¼¹ç°§-é˜»å°¼ç³»ç»Ÿï¼š

$$m\ddot{x} + c\dot{x} + kx = u$$

å…¶ä¸­è´¨é‡ $m$ã€é˜»å°¼ç³»æ•° $c$ã€å¼¹ç°§å¸¸æ•° $k$ å­˜åœ¨ä¸ç¡®å®šæ€§ï¼š

$$m \in [m_0 - \Delta m, m_0 + \Delta m]$$
$$c \in [c_0 - \Delta c, c_0 + \Delta c]$$
$$k \in [k_0 - \Delta k, k_0 + \Delta k]$$

### 4.2 éå‚æ•°ä¸ç¡®å®šæ€§

**å®šä¹‰ 2.2.1** (éå‚æ•°ä¸ç¡®å®šæ€§æ¨¡å‹)
éå‚æ•°ä¸ç¡®å®šæ€§å¯ä»¥å»ºæ¨¡ä¸ºï¼š

$$G(s) = G_0(s)(1 + \Delta(s))$$

å…¶ä¸­ $\Delta(s)$ æ˜¯ç¨³å®šçš„ä¼ é€’å‡½æ•°ï¼Œæ»¡è¶³ï¼š

$$\|\Delta(s)\|_{\infty} \leq \gamma$$

### 4.3 ç»“æ„ä¸ç¡®å®šæ€§

**å®šä¹‰ 2.3.1** (ç»“æ„ä¸ç¡®å®šæ€§æ¨¡å‹)
ç»“æ„ä¸ç¡®å®šæ€§å¯ä»¥å»ºæ¨¡ä¸ºï¼š

$$G(s) = G_0(s) + \Delta(s)$$

å…¶ä¸­ $\Delta(s)$ å…·æœ‰ç‰¹å®šçš„ç»“æ„ï¼š

$$\Delta(s) = W_1(s)\Delta(s)W_2(s)$$

$W_1(s)$ å’Œ $W_2(s)$ æ˜¯å·²çŸ¥çš„æƒé‡å‡½æ•°ï¼Œ$\Delta(s)$ æ˜¯æœªçŸ¥çš„ç¨³å®šä¼ é€’å‡½æ•°ã€‚

## 5 é²æ£’ç¨³å®šæ€§ç†è®º

### 5.1 å°å¢ç›Šå®šç†

**å®šç† 3.1.1** (å°å¢ç›Šå®šç†)
è®¾ $M(s)$ å’Œ $\Delta(s)$ éƒ½æ˜¯ç¨³å®šçš„ä¼ é€’å‡½æ•°ï¼Œåˆ™åé¦ˆç³»ç»Ÿï¼š

$$y = M(s)(u + \Delta(s)y)$$

ç¨³å®šçš„å……åˆ†æ¡ä»¶æ˜¯ï¼š

$$\|M(s)\Delta(s)\|_{\infty} < 1$$

**è¯æ˜**ï¼š
è€ƒè™‘é—­ç¯ç³»ç»Ÿçš„ç‰¹å¾æ–¹ç¨‹ï¼š

$$1 - M(s)\Delta(s) = 0$$

å¦‚æœ $\|M(s)\Delta(s)\|_{\infty} < 1$ï¼Œåˆ™å¯¹äºæ‰€æœ‰ $s$ åœ¨å³åŠå¹³é¢ï¼Œéƒ½æœ‰ï¼š

$$|M(s)\Delta(s)| < 1$$

å› æ­¤ç‰¹å¾æ–¹ç¨‹åœ¨å³åŠå¹³é¢æ— é›¶ç‚¹ï¼Œç³»ç»Ÿç¨³å®šã€‚

### 5.2 é²æ£’ç¨³å®šæ€§æ¡ä»¶

**å®šç† 3.2.1** (é²æ£’ç¨³å®šæ€§æ¡ä»¶)
å¯¹äºä¸ç¡®å®šæ€§æ¨¡å‹ï¼š

$$G(s) = G_0(s)(1 + \Delta(s))$$

å…¶ä¸­ $\|\Delta(s)\|_{\infty} \leq \gamma$ï¼Œåˆ™é—­ç¯ç³»ç»Ÿé²æ£’ç¨³å®šçš„å……åˆ†æ¡ä»¶æ˜¯ï¼š

$$\|T(s)\|_{\infty} < \frac{1}{\gamma}$$

å…¶ä¸­ $T(s)$ æ˜¯é—­ç¯ä¼ é€’å‡½æ•°ã€‚

**è¯æ˜**ï¼š
é—­ç¯ç³»ç»Ÿå¯ä»¥è¡¨ç¤ºä¸ºï¼š

$$T(s) = \frac{G_0(s)K(s)}{1 + G_0(s)K(s)}$$

è€ƒè™‘ä¸ç¡®å®šæ€§åçš„é—­ç¯ç³»ç»Ÿï¼š

$$T_{\Delta}(s) = \frac{G_0(s)(1 + \Delta(s))K(s)}{1 + G_0(s)(1 + \Delta(s))K(s)}$$

ä½¿ç”¨å°å¢ç›Šå®šç†ï¼Œé²æ£’ç¨³å®šæ€§æ¡ä»¶ä¸ºï¼š

$$\|T(s)\Delta(s)\|_{\infty} < 1$$

ç”±äº $\|\Delta(s)\|_{\infty} \leq \gamma$ï¼Œå› æ­¤ï¼š

$$\|T(s)\|_{\infty} < \frac{1}{\gamma}$$

### 5.3 ç»“æ„å¥‡å¼‚å€¼

**å®šä¹‰ 3.3.1** (ç»“æ„å¥‡å¼‚å€¼)
å¯¹äºçŸ©é˜µ $M$ å’Œä¸ç¡®å®šæ€§ç»“æ„ $\Delta$ï¼Œç»“æ„å¥‡å¼‚å€¼å®šä¹‰ä¸ºï¼š

$$\mu_{\Delta}(M) = \frac{1}{\min\{\|\Delta\| : \det(I - M\Delta) = 0, \Delta \in \Delta\}}$$

å¦‚æœä¸å­˜åœ¨ $\Delta \in \Delta$ ä½¿å¾— $\det(I - M\Delta) = 0$ï¼Œåˆ™ $\mu_{\Delta}(M) = 0$ã€‚

**å®šç† 3.3.1** (Î¼å®šç†)
ç³»ç»Ÿé²æ£’ç¨³å®šçš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯ï¼š

$$\sup_{\omega} \mu_{\Delta}(M(j\omega)) < 1$$

## 6 Hæ§åˆ¶ç†è®º

### 6.1 HèŒƒæ•°

**å®šä¹‰ 4.1.1** (HâˆèŒƒæ•°)
å¯¹äºç¨³å®šçš„ä¼ é€’å‡½æ•° $G(s)$ï¼Œå…¶HâˆèŒƒæ•°å®šä¹‰ä¸ºï¼š

$$\|G(s)\|_{\infty} = \sup_{\omega} \sigma_{\max}(G(j\omega))$$

å…¶ä¸­ $\sigma_{\max}$ è¡¨ç¤ºæœ€å¤§å¥‡å¼‚å€¼ã€‚

### 6.2 Hæ§åˆ¶é—®é¢˜

**å®šä¹‰ 4.2.1** (Hâˆæ§åˆ¶é—®é¢˜)
Hâˆæ§åˆ¶é—®é¢˜å®šä¹‰ä¸ºï¼šè®¾è®¡æ§åˆ¶å™¨ $K(s)$ï¼Œä½¿å¾—ä»æ‰°åŠ¨ $w$ åˆ°æ€§èƒ½è¾“å‡º $z$ çš„ä¼ é€’å‡½æ•° $T_{zw}(s)$ çš„HâˆèŒƒæ•°æœ€å°ï¼š

$$\min_{K(s)} \|T_{zw}(s)\|_{\infty}$$

**æ ‡å‡†Hâˆæ§åˆ¶é—®é¢˜**ï¼š
è€ƒè™‘ç³»ç»Ÿï¼š

$$
\begin{align}
\dot{x} &= Ax + B_1w + B_2u \\
z &= C_1x + D_{11}w + D_{12}u \\
y &= C_2x + D_{21}w + D_{22}u
\end{align}
$$

å…¶ä¸­ï¼š

- $x$ æ˜¯çŠ¶æ€å‘é‡
- $w$ æ˜¯å¤–éƒ¨æ‰°åŠ¨
- $u$ æ˜¯æ§åˆ¶è¾“å…¥
- $z$ æ˜¯æ€§èƒ½è¾“å‡º
- $y$ æ˜¯æµ‹é‡è¾“å‡º

### 6.3 Hæ§åˆ¶å™¨è®¾è®¡

**å®šç† 4.3.1** (Hâˆæ§åˆ¶å™¨å­˜åœ¨æ¡ä»¶)
Hâˆæ§åˆ¶å™¨å­˜åœ¨çš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯ä»¥ä¸‹ä¸¤ä¸ªä»£æ•°é»å¡ææ–¹ç¨‹æœ‰æ­£å®šè§£ï¼š

$$A^TX + XA + X(\frac{1}{\gamma^2}B_1B_1^T - B_2B_2^T)X + C_1^TC_1 = 0$$

$$AY + YA^T + Y(\frac{1}{\gamma^2}C_1^TC_1 - C_2^TC_2)Y + B_1B_1^T = 0$$

å¹¶ä¸”æ»¡è¶³ï¼š

$$\rho(XY) < \gamma^2$$

å…¶ä¸­ $\rho$ è¡¨ç¤ºè°±åŠå¾„ã€‚

**å®šç† 4.3.2** (Hâˆæ§åˆ¶å™¨å…¬å¼)
å¦‚æœä¸Šè¿°æ¡ä»¶æ»¡è¶³ï¼Œåˆ™Hâˆæ§åˆ¶å™¨ä¸ºï¼š

$$
K(s) = \left[\begin{array}{c|c}
A_K & B_K \\
\hline
C_K & D_K
\end{array}\right]
$$

å…¶ä¸­ï¼š

$$
\begin{align}
A_K &= A + B_2F + HC_2 + \frac{1}{\gamma^2}B_1B_1^TX \\
B_K &= -H \\
C_K &= F \\
D_K &= 0
\end{align}
$$

$$F = -B_2^TX, \quad H = -YC_2^T$$

### 6.4 æ··åˆçµæ•åº¦é—®é¢˜

**å®šä¹‰ 4.4.1** (æ··åˆçµæ•åº¦é—®é¢˜)
æ··åˆçµæ•åº¦é—®é¢˜å®šä¹‰ä¸ºï¼š

$$
\min_{K(s)} \left\|\begin{bmatrix}
W_1(s)S(s) \\
W_2(s)T(s) \\
W_3(s)KS(s)
\end{bmatrix}\right\|_{\infty}
$$

å…¶ä¸­ï¼š

- $S(s) = (I + G(s)K(s))^{-1}$ æ˜¯çµæ•åº¦å‡½æ•°
- $T(s) = G(s)K(s)(I + G(s)K(s))^{-1}$ æ˜¯è¡¥çµæ•åº¦å‡½æ•°
- $W_1(s)$, $W_2(s)$, $W_3(s)$ æ˜¯æƒé‡å‡½æ•°

## 7 Î¼ç»¼åˆç†è®º

### 7.1 Î¼ç»¼åˆé—®é¢˜

**å®šä¹‰ 5.1.1** (Î¼ç»¼åˆé—®é¢˜)
Î¼ç»¼åˆé—®é¢˜å®šä¹‰ä¸ºï¼š

$$\min_{K(s)} \sup_{\omega} \mu_{\Delta}(M(j\omega))$$

å…¶ä¸­ $M(s)$ æ˜¯é—­ç¯ç³»ç»Ÿçš„ä¼ é€’å‡½æ•°çŸ©é˜µã€‚

### 7.2 D-Kè¿­ä»£

**ç®—æ³• 5.2.1** (D-Kè¿­ä»£)

1. åˆå§‹åŒ–ï¼šé€‰æ‹©åˆå§‹æ§åˆ¶å™¨ $K_0(s)$
2. Dæ­¥ï¼šå›ºå®šæ§åˆ¶å™¨ï¼Œä¼˜åŒ–ç¼©æ”¾çŸ©é˜µ $D$
3. Kæ­¥ï¼šå›ºå®šç¼©æ”¾çŸ©é˜µï¼Œä¼˜åŒ–æ§åˆ¶å™¨ $K$
4. é‡å¤æ­¥éª¤2-3ç›´åˆ°æ”¶æ•›

**Dæ­¥ä¼˜åŒ–**ï¼š
$$\min_{D} \sup_{\omega} \|DM(j\omega)D^{-1}\|_{\infty}$$

**Kæ­¥ä¼˜åŒ–**ï¼š
$$\min_{K} \sup_{\omega} \|DM(j\omega)D^{-1}\|_{\infty}$$

### 7.3 Î¼ä¸Šç•Œ

**å®šç† 5.3.1** (Î¼ä¸Šç•Œ)
å¯¹äºç»“æ„ä¸ç¡®å®šæ€§ $\Delta$ï¼ŒÎ¼çš„ä¸Šç•Œä¸ºï¼š

$$\mu_{\Delta}(M) \leq \inf_{D \in \mathcal{D}} \|DMD^{-1}\|_{\infty}$$

å…¶ä¸­ $\mathcal{D}$ æ˜¯ä¸ä¸ç¡®å®šæ€§ç»“æ„ç›¸å®¹çš„ç¼©æ”¾çŸ©é˜µé›†åˆã€‚

## 8 çº¿æ€§çŸ©é˜µä¸ç­‰å¼

### 8.1 LMIåŸºç¡€

**å®šä¹‰ 6.1.1** (çº¿æ€§çŸ©é˜µä¸ç­‰å¼)
çº¿æ€§çŸ©é˜µä¸ç­‰å¼å®šä¹‰ä¸ºï¼š

$$F(x) = F_0 + \sum_{i=1}^{m} x_i F_i > 0$$

å…¶ä¸­ $F_i$ æ˜¯å¯¹ç§°çŸ©é˜µï¼Œ$x_i$ æ˜¯æ ‡é‡å˜é‡ã€‚

### 8.2 é²æ£’ç¨³å®šæ€§LMI

**å®šç† 6.2.1** (é²æ£’ç¨³å®šæ€§LMI)
ç³»ç»Ÿ $\dot{x} = A(\theta)x$ é²æ£’ç¨³å®šçš„å……åˆ†æ¡ä»¶æ˜¯å­˜åœ¨æ­£å®šçŸ©é˜µ $P$ï¼Œä½¿å¾—ï¼š

$$A^T(\theta)P + PA(\theta) < 0$$

å¯¹æ‰€æœ‰ $\theta \in \Theta$ æˆç«‹ã€‚

**LMIå½¢å¼**ï¼š
å¦‚æœ $A(\theta)$ æ˜¯å‚æ•°ä¸ç¡®å®šæ€§çš„ä»¿å°„å‡½æ•°ï¼š

$$A(\theta) = A_0 + \sum_{i=1}^{p} \theta_i A_i$$

åˆ™é²æ£’ç¨³å®šæ€§æ¡ä»¶å¯ä»¥è¡¨ç¤ºä¸ºLMIï¼š

$$A_0^TP + PA_0 + \sum_{i=1}^{p} \theta_i(A_i^TP + PA_i) < 0$$

### 8.3 Hæ§åˆ¶LMI

**å®šç† 6.3.1** (Hâˆæ§åˆ¶LMI)
Hâˆæ§åˆ¶é—®é¢˜å¯ä»¥è¡¨ç¤ºä¸ºLMIï¼š

$$
\begin{bmatrix}
A^TX + XA + C_1^TC_1 & XB_1 & C_1^TD_{11} \\
B_1^TX & -\gamma I & D_{11}^T \\
D_{11}^TC_1 & D_{11} & -\gamma I
\end{bmatrix} < 0
$$

$$X > 0$$

## 9 ä»£ç å®ç°

### 9.1 é²æ£’æ§åˆ¶ç³»ç»Ÿæ¡†æ¶

```rust
use nalgebra::{DMatrix, DVector};
use std::f64::consts::PI;

/// ä¸ç¡®å®šæ€§æ¨¡å‹
pub enum UncertaintyType {
    Additive(DMatrix<f64>),
    Multiplicative(f64),
    Parametric(Vec<(f64, f64)>), // (nominal, bound)
}

/// é²æ£’æ§åˆ¶ç³»ç»Ÿ
pub struct RobustControlSystem {
    pub A: DMatrix<f64>,
    pub B: DMatrix<f64>,
    pub C: DMatrix<f64>,
    pub D: DMatrix<f64>,
    pub uncertainty: UncertaintyType,
}

impl RobustControlSystem {
    pub fn new(A: DMatrix<f64>, B: DMatrix<f64>, C: DMatrix<f64>, D: DMatrix<f64>) -> Self {
        Self {
            A, B, C, D,
            uncertainty: UncertaintyType::Additive(DMatrix::zeros(A.nrows(), A.ncols())),
        }
    }

    /// è®¾ç½®ä¸ç¡®å®šæ€§
    pub fn set_uncertainty(&mut self, uncertainty: UncertaintyType) {
        self.uncertainty = uncertainty;
    }

    /// è·å–æ‰°åŠ¨ç³»ç»ŸçŸ©é˜µ
    pub fn get_perturbed_system(&self, delta: f64) -> (DMatrix<f64>, DMatrix<f64>, DMatrix<f64>, DMatrix<f64>) {
        match &self.uncertainty {
            UncertaintyType::Additive(delta_A) => {
                let A_perturbed = &self.A + &(delta_A * delta);
                (A_perturbed.clone(), self.B.clone(), self.C.clone(), self.D.clone())
            }
            UncertaintyType::Multiplicative(bound) => {
                let A_perturbed = &self.A * (1.0 + delta * bound);
                (A_perturbed, self.B.clone(), self.C.clone(), self.D.clone())
            }
            UncertaintyType::Parametric(params) => {
                let mut A_perturbed = self.A.clone();
                for (i, (nominal, bound)) in params.iter().enumerate() {
                    let perturbation = delta * bound;
                    // å‡è®¾å‚æ•°ä¸ç¡®å®šæ€§å½±å“å¯¹è§’å…ƒç´ 
                    if i < A_perturbed.nrows() {
                        A_perturbed[(i, i)] = nominal + perturbation;
                    }
                }
                (A_perturbed, self.B.clone(), self.C.clone(), self.D.clone())
            }
        }
    }
}

/// Hâˆæ§åˆ¶å™¨
pub struct HInfinityController {
    pub A_k: DMatrix<f64>,
    pub B_k: DMatrix<f64>,
    pub C_k: DMatrix<f64>,
    pub D_k: DMatrix<f64>,
}

impl HInfinityController {
    /// è®¾è®¡Hâˆæ§åˆ¶å™¨
    pub fn design(system: &RobustControlSystem, gamma: f64) -> Option<Self> {
        let n = system.A.nrows();
        let p = system.C.nrows();
        let m = system.B.ncols();

        // æ„å»ºå¢å¹¿ç³»ç»ŸçŸ©é˜µ
        let B1 = DMatrix::identity(n, n); // æ‰°åŠ¨è¾“å…¥çŸ©é˜µ
        let C1 = DMatrix::identity(n, n); // æ€§èƒ½è¾“å‡ºçŸ©é˜µ
        let D11 = DMatrix::zeros(n, n);
        let D12 = system.B.clone();
        let D21 = DMatrix::zeros(p, n);
        let D22 = DMatrix::zeros(p, m);

        // æ±‚è§£ä»£æ•°é»å¡ææ–¹ç¨‹
        let X = Self::solve_riccati_x(&system.A, &B1, &system.B, &C1, gamma)?;
        let Y = Self::solve_riccati_y(&system.A, &B1, &C1, &system.C, gamma)?;

        // æ£€æŸ¥æ¡ä»¶
        let XY = &X * &Y;
        let spectral_radius = Self::spectral_radius(&XY);

        if spectral_radius >= gamma * gamma {
            return None;
        }

        // è®¡ç®—æ§åˆ¶å™¨çŸ©é˜µ
        let F = -system.B.transpose() * &X;
        let H = -&Y * &system.C.transpose();

        let A_k = &system.A + &system.B * &F + &H * &system.C +
                  &(B1 * &B1.transpose() * &X) / (gamma * gamma);
        let B_k = -H;
        let C_k = F;
        let D_k = DMatrix::zeros(m, p);

        Some(Self { A_k, B_k, C_k, D_k })
    }

    /// æ±‚è§£Xé»å¡ææ–¹ç¨‹
    fn solve_riccati_x(A: &DMatrix<f64>, B1: &DMatrix<f64>, B2: &DMatrix<f64>, C1: &DMatrix<f64>, gamma: f64) -> Option<DMatrix<f64>> {
        let n = A.nrows();
        let mut X = DMatrix::identity(n, n);

        for _ in 0..100 {
            let X_new = A.transpose() * &X + &X * A +
                       &X * (B1 * &B1.transpose() / (gamma * gamma) - B2 * &B2.transpose()) * &X +
                       C1.transpose() * C1;

            let diff = (&X_new - &X).norm();
            X = X_new;

            if diff < 1e-6 {
                return Some(X);
            }
        }

        None
    }

    /// æ±‚è§£Yé»å¡ææ–¹ç¨‹
    fn solve_riccati_y(A: &DMatrix<f64>, B1: &DMatrix<f64>, C1: &DMatrix<f64>, C2: &DMatrix<f64>, gamma: f64) -> Option<DMatrix<f64>> {
        let n = A.nrows();
        let mut Y = DMatrix::identity(n, n);

        for _ in 0..100 {
            let Y_new = A * &Y + &Y * A.transpose() +
                       &Y * (C1.transpose() * C1 / (gamma * gamma) - C2.transpose() * C2) * &Y +
                       B1 * &B1.transpose();

            let diff = (&Y_new - &Y).norm();
            Y = Y_new;

            if diff < 1e-6 {
                return Some(Y);
            }
        }

        None
    }

    /// è®¡ç®—è°±åŠå¾„
    fn spectral_radius(matrix: &DMatrix<f64>) -> f64 {
        let eigenvals = matrix.eigenvalues();
        eigenvals.iter().map(|&x| x.abs()).fold(0.0, f64::max)
    }

    /// è®¡ç®—æ§åˆ¶è¾“å…¥
    pub fn compute_control(&self, x: &DVector<f64>, y: &DVector<f64>) -> DVector<f64> {
        &self.C_k * x + &self.D_k * y
    }
}
```

### 9.2 Î¼ç»¼åˆç®—æ³•

```rust
/// Î¼ç»¼åˆæ±‚è§£å™¨
pub struct MuSynthesisSolver {
    pub max_iterations: usize,
    pub tolerance: f64,
}

impl MuSynthesisSolver {
    pub fn new() -> Self {
        Self {
            max_iterations: 50,
            tolerance: 1e-6,
        }
    }

    /// D-Kè¿­ä»£
    pub fn solve(&self, system: &RobustControlSystem, initial_controller: HInfinityController) -> HInfinityController {
        let mut controller = initial_controller;
        let mut mu_old = f64::INFINITY;

        for iteration in 0..self.max_iterations {
            // Dæ­¥ï¼šä¼˜åŒ–ç¼©æ”¾çŸ©é˜µ
            let D = self.optimize_d_scaling(system, &controller);

            // Kæ­¥ï¼šä¼˜åŒ–æ§åˆ¶å™¨
            controller = self.optimize_controller(system, &D)?;

            // è®¡ç®—Î¼å€¼
            let mu = self.compute_mu(system, &controller);

            println!("è¿­ä»£ {}: Î¼ = {:.6}", iteration + 1, mu);

            if (mu_old - mu).abs() < self.tolerance {
                println!("Î¼ç»¼åˆæ”¶æ•›");
                break;
            }

            mu_old = mu;
        }

        controller
    }

    /// ä¼˜åŒ–Dç¼©æ”¾çŸ©é˜µ
    fn optimize_d_scaling(&self, system: &RobustControlSystem, controller: &HInfinityController) -> DMatrix<f64> {
        let n = system.A.nrows();
        let mut D = DMatrix::identity(n, n);

        // ç®€åŒ–çš„Dä¼˜åŒ–ï¼šä½¿ç”¨å¯¹è§’ç¼©æ”¾
        for i in 0..n {
            let mut best_d = 1.0;
            let mut best_norm = f64::INFINITY;

            for d in (1..=10).map(|k| k as f64 * 0.1) {
                D[(i, i)] = d;
                let norm = self.compute_scaled_norm(system, controller, &D);

                if norm < best_norm {
                    best_norm = norm;
                    best_d = d;
                }
            }

            D[(i, i)] = best_d;
        }

        D
    }

    /// ä¼˜åŒ–æ§åˆ¶å™¨
    fn optimize_controller(&self, system: &RobustControlSystem, D: &DMatrix<f64>) -> Option<HInfinityController> {
        // ä½¿ç”¨ç¼©æ”¾åçš„ç³»ç»Ÿè®¾è®¡Hâˆæ§åˆ¶å™¨
        let scaled_system = self.scale_system(system, D);
        HInfinityController::design(&scaled_system, 1.0)
    }

    /// è®¡ç®—Î¼å€¼
    fn compute_mu(&self, system: &RobustControlSystem, controller: &HInfinityController) -> f64 {
        let mut max_mu = 0.0;

        // åœ¨é¢‘ç‡èŒƒå›´å†…è®¡ç®—Î¼
        for freq in (1..=100).map(|k| k as f64 * 0.1) {
            let omega = 2.0 * PI * freq;
            let mu_freq = self.compute_mu_at_frequency(system, controller, omega);
            max_mu = max_mu.max(mu_freq);
        }

        max_mu
    }

    /// åœ¨ç‰¹å®šé¢‘ç‡è®¡ç®—Î¼
    fn compute_mu_at_frequency(&self, system: &RobustControlSystem, controller: &HInfinityController, omega: f64) -> f64 {
        // è®¡ç®—é—­ç¯ä¼ é€’å‡½æ•°
        let M = self.compute_closed_loop_transfer(system, controller, omega);

        // ç®€åŒ–çš„Î¼è®¡ç®—ï¼šä½¿ç”¨å¥‡å¼‚å€¼ä¸Šç•Œ
        let singular_values = M.svd(true, true).singular_values;
        singular_values.iter().fold(0.0, |max, &s| max.max(s))
    }

    /// è®¡ç®—é—­ç¯ä¼ é€’å‡½æ•°
    fn compute_closed_loop_transfer(&self, system: &RobustControlSystem, controller: &HInfinityController, omega: f64) -> DMatrix<f64> {
        let n = system.A.nrows();
        let j_omega = DMatrix::identity(n, n) * (omega * 1.0i);

        // è®¡ç®—ç³»ç»Ÿä¼ é€’å‡½æ•°
        let G = (j_omega - &system.A).try_inverse().unwrap_or(DMatrix::zeros(n, n)) * &system.B;

        // è®¡ç®—æ§åˆ¶å™¨ä¼ é€’å‡½æ•°
        let K = (j_omega - &controller.A_k).try_inverse().unwrap_or(DMatrix::zeros(n, n)) * &controller.B_k;

        // è®¡ç®—é—­ç¯ä¼ é€’å‡½æ•°
        let I = DMatrix::identity(n, n);
        (I + &G * &K).try_inverse().unwrap_or(DMatrix::zeros(n, n)) * &G * &K
    }

    /// ç¼©æ”¾ç³»ç»Ÿ
    fn scale_system(&self, system: &RobustControlSystem, D: &DMatrix<f64>) -> RobustControlSystem {
        let D_inv = D.try_inverse().unwrap_or(DMatrix::identity(D.nrows(), D.ncols()));

        RobustControlSystem::new(
            &D * &system.A * &D_inv,
            &D * &system.B,
            &system.C * &D_inv,
            system.D.clone(),
        )
    }

    /// è®¡ç®—ç¼©æ”¾åçš„èŒƒæ•°
    fn compute_scaled_norm(&self, system: &RobustControlSystem, controller: &HInfinityController, D: &DMatrix<f64>) -> f64 {
        let scaled_system = self.scale_system(system, D);
        let M = self.compute_closed_loop_transfer(&scaled_system, controller, 1.0);
        M.norm()
    }
}
```

### 9.3 LMIæ±‚è§£å™¨

```rust
/// çº¿æ€§çŸ©é˜µä¸ç­‰å¼æ±‚è§£å™¨
pub struct LMISolver {
    pub max_iterations: usize,
    pub tolerance: f64,
}

impl LMISolver {
    pub fn new() -> Self {
        Self {
            max_iterations: 100,
            tolerance: 1e-6,
        }
    }

    /// æ±‚è§£é²æ£’ç¨³å®šæ€§LMI
    pub fn solve_robust_stability(&self, A_nominal: &DMatrix<f64>, A_uncertainty: &[DMatrix<f64>]) -> Option<DMatrix<f64>> {
        let n = A_nominal.nrows();
        let mut P = DMatrix::identity(n, n);

        for iteration in 0..self.max_iterations {
            let mut P_new = P.clone();

            // æ£€æŸ¥æ‰€æœ‰ä¸ç¡®å®šæ€§é¡¶ç‚¹
            for A_delta in A_uncertainty {
                let A_perturbed = A_nominal + A_delta;
                let constraint = A_perturbed.transpose() * &P + &P * &A_perturbed;

                // å¦‚æœçº¦æŸä¸æ»¡è¶³ï¼Œè°ƒæ•´P
                if constraint.trace() >= 0.0 {
                    let adjustment = -constraint * 0.1;
                    P_new = &P_new + &adjustment;
                }
            }

            // ç¡®ä¿Pæ­£å®š
            P_new = self.make_positive_definite(&P_new);

            let diff = (&P_new - &P).norm();
            P = P_new;

            if diff < self.tolerance {
                return Some(P);
            }
        }

        None
    }

    /// æ±‚è§£Hâˆæ§åˆ¶LMI
    pub fn solve_hinfinity_lmi(&self, system: &RobustControlSystem, gamma: f64) -> Option<DMatrix<f64>> {
        let n = system.A.nrows();
        let p = system.C.nrows();
        let mut X = DMatrix::identity(n, n);

        for iteration in 0..self.max_iterations {
            let mut X_new = X.clone();

            // æ„å»ºLMIçº¦æŸ
            let constraint = self.build_hinfinity_constraint(system, &X, gamma);

            // å¦‚æœçº¦æŸä¸æ»¡è¶³ï¼Œè°ƒæ•´X
            if constraint.trace() >= 0.0 {
                let adjustment = -constraint * 0.1;
                X_new = &X_new + &adjustment;
            }

            // ç¡®ä¿Xæ­£å®š
            X_new = self.make_positive_definite(&X_new);

            let diff = (&X_new - &X).norm();
            X = X_new;

            if diff < self.tolerance {
                return Some(X);
            }
        }

        None
    }

    /// æ„å»ºHâˆçº¦æŸ
    fn build_hinfinity_constraint(&self, system: &RobustControlSystem, X: &DMatrix<f64>, gamma: f64) -> DMatrix<f64> {
        let n = system.A.nrows();
        let p = system.C.nrows();

        // æ„å»ºå¢å¹¿çŸ©é˜µ
        let mut constraint = DMatrix::zeros(n + p + p, n + p + p);

        // å·¦ä¸Šè§’å—
        constraint.slice_mut((0, 0), (n, n)).copy_from(&(system.A.transpose() * X + X * &system.A + system.C.transpose() * &system.C));

        // å³ä¸Šè§’å—
        constraint.slice_mut((0, n), (n, p)).copy_from(&(X * &system.B));
        constraint.slice_mut((0, n + p), (n, p)).copy_from(&(system.C.transpose() * &system.D));

        // å·¦ä¸‹è§’å—
        constraint.slice_mut((n, 0), (p, n)).copy_from(&(system.B.transpose() * X));
        constraint.slice_mut((n + p, 0), (p, n)).copy_from(&(system.D.transpose() * &system.C));

        // å³ä¸‹è§’å—
        constraint[(n, n)] = -gamma;
        constraint[(n + p, n + p)] = -gamma;

        constraint
    }

    /// ä½¿çŸ©é˜µæ­£å®š
    fn make_positive_definite(&self, matrix: &DMatrix<f64>) -> DMatrix<f64> {
        let eigenvals = matrix.eigenvalues();
        let min_eigenval = eigenvals.iter().fold(f64::INFINITY, |min, &x| min.min(x.re));

        if min_eigenval <= 0.0 {
            let shift = -min_eigenval + 1e-6;
            matrix + DMatrix::identity(matrix.nrows(), matrix.ncols()) * shift
        } else {
            matrix.clone()
        }
    }
}
```

## 10 åº”ç”¨ç¤ºä¾‹

### 10.1 å€’ç«‹æ‘†é²æ£’æ§åˆ¶

```rust
/// å€’ç«‹æ‘†é²æ£’æ§åˆ¶ç¤ºä¾‹
pub fn inverted_pendulum_robust_control() {
    // æ ‡ç§°ç³»ç»Ÿå‚æ•°
    let M = 0.5; // å°è½¦è´¨é‡
    let m = 0.2; // æ‘†æ†è´¨é‡
    let b = 0.1; // æ‘©æ“¦ç³»æ•°
    let I = 0.006; // è½¬åŠ¨æƒ¯é‡
    let g = 9.8; // é‡åŠ›åŠ é€Ÿåº¦
    let l = 0.3; // æ‘†æ†é•¿åº¦

    // æ ‡ç§°ç³»ç»ŸçŸ©é˜µ
    let p = I * (M + m) + M * m * l * l;

    let A = DMatrix::from_row_slice(4, 4, &[
        0.0, 1.0, 0.0, 0.0,
        0.0, -(I + m * l * l) * b / p, m * m * g * l * l / p, 0.0,
        0.0, 0.0, 0.0, 1.0,
        0.0, -m * l * b / p, m * g * l * (M + m) / p, 0.0
    ]);

    let B = DMatrix::from_column_slice(4, 1, &[
        0.0,
        (I + m * l * l) / p,
        0.0,
        m * l / p
    ]);

    let C = DMatrix::from_row_slice(2, 4, &[
        1.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0
    ]);

    let D = DMatrix::zeros(2, 1);

    let mut system = RobustControlSystem::new(A, B, C, D);

    // è®¾ç½®å‚æ•°ä¸ç¡®å®šæ€§
    let mass_uncertainty = 0.1; // 10%çš„è´¨é‡ä¸ç¡®å®šæ€§
    system.set_uncertainty(UncertaintyType::Parametric(vec![
        (M, M * mass_uncertainty),
        (m, m * mass_uncertainty),
        (b, b * mass_uncertainty),
        (I, I * mass_uncertainty),
    ]));

    // è®¾è®¡Hâˆæ§åˆ¶å™¨
    let gamma = 1.0;
    if let Some(controller) = HInfinityController::design(&system, gamma) {
        println!("Hâˆæ§åˆ¶å™¨è®¾è®¡æˆåŠŸ");

        // æµ‹è¯•é²æ£’æ€§
        let x0 = DVector::from_column_slice(&[0.1, 0.0, 0.1, 0.0]);
        test_robustness(&system, &controller, &x0);
    } else {
        println!("Hâˆæ§åˆ¶å™¨è®¾è®¡å¤±è´¥");
    }
}

fn test_robustness(system: &RobustControlSystem, controller: &HInfinityController, x0: &DVector<f64>) {
    let dt = 0.01;
    let t_final = 10.0;
    let steps = (t_final / dt) as usize;

    // æµ‹è¯•ä¸åŒä¸ç¡®å®šæ€§æ°´å¹³
    for delta in [0.0, 0.5, 1.0] {
        println!("æµ‹è¯•ä¸ç¡®å®šæ€§æ°´å¹³: {:.1}", delta);

        let mut x = x0.clone();
        let mut t = 0.0;

        for step in 0..steps {
            let y = &system.C * &x;
            let u = controller.compute_control(&x, &y);

            // ä½¿ç”¨æ‰°åŠ¨ç³»ç»Ÿ
            let (A_pert, B_pert, _, _) = system.get_perturbed_system(delta);
            let dx = (&A_pert * &x + &B_pert * &u) * dt;
            x = &x + &dx;
            t += dt;

            if step % 100 == 0 {
                println!("t={:.1}s: ä½ç½®={:.3}m, è§’åº¦={:.3}rad", t, x[0], x[2]);
            }
        }

        println!("æœ€ç»ˆçŠ¶æ€: [{:.3}, {:.3}, {:.3}, {:.3}]", x[0], x[1], x[2], x[3]);
    }
}
```

### 10.2 Î¼ç»¼åˆç¤ºä¾‹

```rust
/// Î¼ç»¼åˆç¤ºä¾‹
pub fn mu_synthesis_example() {
    // åˆ›å»ºç³»ç»Ÿ
    let A = DMatrix::from_row_slice(2, 2, &[0.0, 1.0, -1.0, -0.1]);
    let B = DMatrix::from_column_slice(2, 1, &[0.0, 1.0]);
    let C = DMatrix::from_row_slice(1, 2, &[1.0, 0.0]);
    let D = DMatrix::zeros(1, 1);

    let mut system = RobustControlSystem::new(A, B, C, D);

    // è®¾ç½®ä¹˜æ³•ä¸ç¡®å®šæ€§
    system.set_uncertainty(UncertaintyType::Multiplicative(0.2));

    // åˆå§‹æ§åˆ¶å™¨
    let initial_controller = HInfinityController::design(&system, 2.0).unwrap();

    // Î¼ç»¼åˆ
    let solver = MuSynthesisSolver::new();
    let robust_controller = solver.solve(&system, initial_controller);

    println!("Î¼ç»¼åˆå®Œæˆ");

    // æ¯”è¾ƒæ€§èƒ½
    let x0 = DVector::from_column_slice(&[1.0, 0.0]);
    compare_controllers(&system, &initial_controller, &robust_controller, &x0);
}

fn compare_controllers(
    system: &RobustControlSystem,
    controller1: &HInfinityController,
    controller2: &HInfinityController,
    x0: &DVector<f64>
) {
    let dt = 0.01;
    let t_final = 5.0;
    let steps = (t_final / dt) as usize;

    // æµ‹è¯•æ§åˆ¶å™¨1
    let response1 = simulate_controller(system, controller1, x0, dt, steps);

    // æµ‹è¯•æ§åˆ¶å™¨2
    let response2 = simulate_controller(system, controller2, x0, dt, steps);

    println!("æ§åˆ¶å™¨æ¯”è¾ƒç»“æœï¼š");
    println!("Hâˆæ§åˆ¶å™¨æœ€ç»ˆçŠ¶æ€: [{:.3}, {:.3}]",
        response1.last().unwrap()[0], response1.last().unwrap()[1]);
    println!("Î¼ç»¼åˆæ§åˆ¶å™¨æœ€ç»ˆçŠ¶æ€: [{:.3}, {:.3}]",
        response2.last().unwrap()[0], response2.last().unwrap()[1]);
}

fn simulate_controller(
    system: &RobustControlSystem,
    controller: &HInfinityController,
    x0: &DVector<f64>,
    dt: f64,
    steps: usize
) -> Vec<DVector<f64>> {
    let mut x = x0.clone();
    let mut response = vec![x.clone()];

    for _ in 0..steps {
        let y = &system.C * &x;
        let u = controller.compute_control(&x, &y);

        let dx = (&system.A * &x + &system.B * &u) * dt;
        x = &x + &dx;
        response.push(x.clone());
    }

    response
}
```

## 11 ç›¸å…³ç†è®º

### 11.1 ä¸ç°ä»£æ§åˆ¶ç†è®ºçš„å…³ç³»

é²æ£’æ§åˆ¶ç†è®ºæ˜¯ç°ä»£æ§åˆ¶ç†è®ºçš„å‘å±•ï¼š

1. **ä¸ç¡®å®šæ€§å¤„ç†**ï¼šç°ä»£æ§åˆ¶ç†è®ºå‡è®¾ç²¾ç¡®æ¨¡å‹ï¼Œé²æ£’æ§åˆ¶ç†è®ºå¤„ç†ä¸ç¡®å®šæ€§
2. **æ€§èƒ½ä¿è¯**ï¼šé²æ£’æ§åˆ¶ç†è®ºæä¾›æ€§èƒ½ä¿è¯ï¼Œè€Œä¸ä»…ä»…æ˜¯ç¨³å®šæ€§
3. **è®¾è®¡æ–¹æ³•**ï¼šæä¾›äº†ç³»ç»ŸåŒ–çš„é²æ£’æ§åˆ¶å™¨è®¾è®¡æ–¹æ³•

### 11.2 ä¸æœ€ä¼˜æ§åˆ¶ç†è®ºçš„å…³ç³»

é²æ£’æ§åˆ¶ç†è®ºä¸æœ€ä¼˜æ§åˆ¶ç†è®ºå¯†åˆ‡ç›¸å…³ï¼š

1. **Hâˆæœ€ä¼˜æ§åˆ¶**ï¼šHâˆæ§åˆ¶æ˜¯æœ€ä¼˜æ§åˆ¶ç†è®ºåœ¨é²æ£’æ§åˆ¶ä¸­çš„åº”ç”¨
2. **æ€§èƒ½ä¼˜åŒ–**ï¼šåœ¨ä¸ç¡®å®šæ€§ä¸‹ä¼˜åŒ–æœ€åæƒ…å†µæ€§èƒ½
3. **çº¦æŸå¤„ç†**ï¼šå¤„ç†ä¸ç¡®å®šæ€§çº¦æŸä¸‹çš„ä¼˜åŒ–é—®é¢˜

### 11.3 ä¸è‡ªé€‚åº”æ§åˆ¶çš„å…³ç³»

é²æ£’æ§åˆ¶ç†è®ºä¸è‡ªé€‚åº”æ§åˆ¶ç†è®ºäº’è¡¥ï¼š

1. **ä¸ç¡®å®šæ€§ç±»å‹**ï¼šé²æ£’æ§åˆ¶å¤„ç†æœ‰ç•Œä¸ç¡®å®šæ€§ï¼Œè‡ªé€‚åº”æ§åˆ¶å¤„ç†æœªçŸ¥å‚æ•°
2. **åœ¨çº¿å­¦ä¹ **ï¼šè‡ªé€‚åº”æ§åˆ¶åœ¨çº¿å­¦ä¹ å‚æ•°ï¼Œé²æ£’æ§åˆ¶ç¦»çº¿è®¾è®¡
3. **æ€§èƒ½ä¿è¯**ï¼šä¸¤è€…éƒ½æä¾›æ€§èƒ½ä¿è¯ï¼Œä½†æ–¹æ³•ä¸åŒ

## 10. å‚è€ƒæ–‡çŒ®

1. Zhou, K., & Doyle, J. C. (1998). Essentials of Robust Control. Prentice Hall.
2. Skogestad, S., & Postlethwaite, I. (2005). Multivariable Feedback Control: Analysis and Design. John Wiley & Sons.
3. Packard, A., & Doyle, J. C. (1993). The complex structured singular value. Automatica, 29(1), 71-109.
4. Balas, G. J., Doyle, J. C., Glover, K., Packard, A., & Smith, R. (1991). Î¼-Analysis and Synthesis Toolbox. The MathWorks.
5. Boyd, S., El Ghaoui, L., Feron, E., & Balakrishnan, V. (1994). Linear Matrix Inequalities in System and Control Theory. SIAM.
6. Gahinet, P., & Apkarian, P. (1994). A linear matrix inequality approach to Hâˆ control. International Journal of Robust and Nonlinear Control, 4(4), 421-448.
7. Doyle, J. C., Francis, B. A., & Tannenbaum, A. R. (1992). Feedback Control Theory. Macmillan.
8. Vidyasagar, M. (2002). Nonlinear Systems Analysis. SIAM.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [05.2.1 ç°ä»£æ§åˆ¶ç†è®º](05.2.1_ç°ä»£æ§åˆ¶ç†è®º.md)
- [05.2.2 æœ€ä¼˜æ§åˆ¶ç†è®º](05.2.2_æœ€ä¼˜æ§åˆ¶ç†è®º.md)
- [05.3.1 éçº¿æ€§æ§åˆ¶ç†è®º](05.3.1_éçº¿æ€§æ§åˆ¶ç†è®º.md)
- [05.3.2 è‡ªé€‚åº”æ§åˆ¶ç†è®º](05.3.2_è‡ªé€‚åº”æ§åˆ¶ç†è®º.md)

## 12 æ‰¹åˆ¤æ€§åˆ†æ

### 12.1 å¤šå…ƒç†è®ºè§†è§’

**ä¸ç¡®å®šæ€§è§†è§’**ï¼šå°å¢ç›Š/Î½-gap/Î¼åˆ†æç­‰ç»Ÿä¸€å¯¹ä¸ç¡®å®šæ€§ä¸æ€§èƒ½çš„åº¦é‡ï¼Œä½†ä¿å®ˆæ€§ä¸å¯è®¡ç®—æ€§å¹¶å­˜ã€‚

**LMI/å‡¸ä¼˜åŒ–è§†è§’**ï¼šæŠŠè®¾è®¡è½¬åŒ–ä¸ºå‡¸é—®é¢˜ï¼Œå·¥ç¨‹å‹å¥½ï¼›ä½†ç»´åº¦å¢é•¿å¿«ï¼Œä¿å®ˆç•Œé™å½±å“æ€§èƒ½ä¸Šé™ã€‚

**é¢‘åŸŸ/æ—¶åŸŸèåˆè§†è§’**ï¼šæ··åˆçµæ•åº¦åœ¨é¢‘åŸŸæˆå½¢ï¼Œæ—¶åŸŸè½åœ°éœ€è€ƒè™‘é¥±å’Œ/æ—¶å»¶/é‡‡æ ·ç­‰å®ç°å› ç´ ã€‚

### 12.2 å±€é™æ€§åˆ†æ

**ä¿å®ˆæ€§**ï¼šä¸Šç•ŒåŒ–ï¼ˆå¦‚Î¼ä¸Šç•Œã€æƒé‡æ•´å½¢ï¼‰æ˜“å¼•å…¥æ€§èƒ½æŸå¤±ï¼›æƒé‡é€‰æ‹©é«˜åº¦ä¾èµ–ç»éªŒã€‚

**å»ºæ¨¡è´Ÿæ‹…**ï¼šæ„é€ åˆç†çš„ä¸ç¡®å®šæ€§é›†ä¸åŠ æƒå‡½æ•°å›°éš¾ï¼Œè¿‡çª„/è¿‡å®½éƒ½ä¼šè¯¯å¯¼è®¾è®¡ã€‚

**è®¡ç®—å¤æ‚åº¦**ï¼šÎ¼ç»¼åˆä¸å¤§è§„æ¨¡LMIåœ¨é«˜ç»´ç³»ç»Ÿã€ç»“æ„åŒ–Î”ä¸‹è®¡ç®—å¼€é”€å·¨å¤§ã€‚

### 12.3 äº‰è®®ä¸åˆ†æ­§

**HâˆvsÎ¼ç»¼åˆ**ï¼šå‰è€…å·¥ç¨‹å¯ç”¨æ€§é«˜ã€å®ç°æˆç†Ÿï¼Œåè€…æ›´ç²¾ç»†ä½†å¤æ‚åº¦ä¸å·¥å…·é—¨æ§›é«˜ã€‚

**é²æ£’vsæœ€ä¼˜**ï¼šé²æ£’ä¿å®ˆé€ æˆæ€§èƒ½æŠ˜æŸï¼Œæ˜¯å¦ä»¥åˆ†å¸ƒé²æ£’/é£é™©æ•æ„ŸèŒƒå¼ç¼“è§£å­˜åœ¨åˆ†æ­§ã€‚

**å®šå‹åŒ–æµç¨‹**ï¼šæƒé‡é€‰å‹ã€æ¨¡æ¿åŒ–ç»¼åˆä¸å®é™…éœ€æ±‚çš„â€œæ‹Ÿåˆâ€ç¨‹åº¦ï¼Œéš¾ä»¥æ ‡å‡†åŒ–ã€‚

### 12.4 åº”ç”¨å‰æ™¯

**å¤æ‚æœºç”µç³»ç»Ÿ**ï¼šèˆªç©ºèˆªå¤©/ç”µé©±/ç”µåŠ›ç”µå­ä¸­é²æ£’æ€§èƒ½ä¸å®‰å…¨åˆšéœ€ï¼Œå·¥å…·é“¾æŒç»­æˆç†Ÿã€‚

**ç½‘ç»œåŒ–ä¸æ—¶å»¶ç³»ç»Ÿ**ï¼šè”åˆé€šä¿¡ä¸ç¡®å®šæ€§ä¸æ§åˆ¶è®¾è®¡ï¼Œé¢å‘è½¦è”ç½‘ä¸å·¥ä¸šäº’è”ç½‘ã€‚

**æ•°æ®é©±åŠ¨é²æ£’**ï¼šå°†ç»Ÿè®¡ä¸ç¡®å®šæ€§ä¸ç»“æ„ä¸ç¡®å®šæ€§ç»“åˆï¼Œå‘å±•æ•°æ®æ”¯æŒçš„é²æ£’ç»¼åˆã€‚

### 12.5 æ”¹è¿›å»ºè®®

**æƒé‡ç³»ç»ŸåŒ–**ï¼šä»¥è§„èŒƒåŒ–æ€§èƒ½è§„æ ¼+è‡ªåŠ¨æƒé‡æ•´å½¢ï¼Œå‡å°‘äººä¸ºç»éªŒä¾èµ–ã€‚

**å¯è®¡ç®—æ€§ä¼˜åŒ–**ï¼šç¨€ç–/åˆ†å—/ä½ç§©æŠ€å·§ä¸éšæœºåŒ–æ•°å€¼æ–¹æ³•ï¼Œé™ä½LMIä¸Î¼ç»¼åˆçš„è§„æ¨¡ã€‚

**èåˆèŒƒå¼**ï¼šæŠŠé²æ£’æ§åˆ¶ä¸MPC/å­¦ä¹ æ§åˆ¶/å½¢å¼åŒ–éªŒè¯å¯¹æ¥ï¼Œå½¢æˆç«¯åˆ°ç«¯çš„ä¿éšœé“¾è·¯ã€‚
