# 16.1.1 ç®—æ³•è®¾è®¡ (Algorithm Design)

**åˆ›å»ºæ—¶é—´**: 2025-01-17
**æœ€åæ›´æ–°**: 2025-01-17
**æ–‡æ¡£çŠ¶æ€**: æ´»è·ƒ
**å…³è”æ¨¡å—**: `16_Algorithm_Theory`

## ğŸ“‹ ç›®å½•

- [16.1.1 ç®—æ³•è®¾è®¡ (Algorithm Design)](#1611-ç®—æ³•è®¾è®¡-algorithm-design)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2 ç†è®ºåŸºç¡€](#2-ç†è®ºåŸºç¡€)
    - [2.1 ç®—æ³•å½¢å¼åŒ–å®šä¹‰](#21-ç®—æ³•å½¢å¼åŒ–å®šä¹‰)
    - [2.2 å¤æ‚åº¦åˆ†æç†è®º](#22-å¤æ‚åº¦åˆ†æç†è®º)
  - [3 è®¾è®¡æ¨¡å¼](#3-è®¾è®¡æ¨¡å¼)
    - [3.1 åˆ†æ²»æ³• (Divide and Conquer)](#31-åˆ†æ²»æ³•-divide-and-conquer)
    - [3.2 åŠ¨æ€è§„åˆ’ (Dynamic Programming)](#32-åŠ¨æ€è§„åˆ’-dynamic-programming)
    - [3.3 è´ªå¿ƒç®—æ³• (Greedy Algorithm)](#33-è´ªå¿ƒç®—æ³•-greedy-algorithm)
  - [4 æ€§èƒ½æµ‹è¯•æ¡†æ¶](#4-æ€§èƒ½æµ‹è¯•æ¡†æ¶)
  - [5 ä¸æ¨¡å—å†…ä¸»é¢˜çš„å…³ç³»](#5-ä¸æ¨¡å—å†…ä¸»é¢˜çš„å…³ç³»)
  - [6 æ‰¹åˆ¤æ€§åˆ†æ](#6-æ‰¹åˆ¤æ€§åˆ†æ)
    - [6.1 å“²å­¦ç»´åº¦](#61-å“²å­¦ç»´åº¦)
    - [6.2 æ–¹æ³•è®ºç»´åº¦](#62-æ–¹æ³•è®ºç»´åº¦)
    - [6.3 å·¥ç¨‹ç»´åº¦](#63-å·¥ç¨‹ç»´åº¦)
    - [6.4 ç¤¾ä¼šæŠ€æœ¯ç»´åº¦](#64-ç¤¾ä¼šæŠ€æœ¯ç»´åº¦)
  - [7 å‚è§](#7-å‚è§)
  - [ğŸ“– å‚è€ƒæ–‡çŒ®](#-å‚è€ƒæ–‡çŒ®)

---

## 1 æ¦‚è¿°

ç®—æ³•è®¾è®¡æ˜¯è®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒï¼Œç ”ç©¶å¦‚ä½•æ„å»ºé«˜æ•ˆã€æ­£ç¡®ã€å¯ç»´æŠ¤çš„ç®—æ³•æ¥è§£å†³å®é™…é—®é¢˜ã€‚æœ¬æ–‡æ¡£æ¶µç›–ç®—æ³•è®¾è®¡çš„åŸºæœ¬åŸåˆ™ã€è®¾è®¡æ¨¡å¼ã€å¤æ‚åº¦åˆ†æå’Œå·¥ç¨‹å®ç°ã€‚

## 2 ç†è®ºåŸºç¡€

### 2.1 ç®—æ³•å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 16.1.1.1** (ç®—æ³•)
ç®—æ³•æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $A = (I, O, P, T, S)$ï¼Œå…¶ä¸­ï¼š

- $I$ æ˜¯è¾“å…¥é›†åˆ
- $O$ æ˜¯è¾“å‡ºé›†åˆ
- $P: I \rightarrow O$ æ˜¯å¤„ç†å‡½æ•°
- $T: \mathbb{N} \rightarrow \mathbb{N}$ æ˜¯æ—¶é—´å¤æ‚åº¦å‡½æ•°
- $S: \mathbb{N} \rightarrow \mathbb{N}$ æ˜¯ç©ºé—´å¤æ‚åº¦å‡½æ•°

**å®šä¹‰ 16.1.1.2** (ç®—æ³•æ­£ç¡®æ€§)
ç®—æ³• $A$ å¯¹äºé—®é¢˜ $P$ æ˜¯æ­£ç¡®çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
$\forall x \in I, A(x) \in O \land P(x, A(x))$

**å®šä¹‰ 16.1.1.3** (ç®—æ³•æœ€ä¼˜æ€§)
ç®—æ³• $A$ å¯¹äºé—®é¢˜ $P$ æ˜¯æœ€ä¼˜çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
$\forall A' \in \mathcal{A}, T_A(n) \leq T_{A'}(n)$

### 2.2 å¤æ‚åº¦åˆ†æç†è®º

**å®šç† 16.1.1.1** (æ—¶é—´å¤æ‚åº¦ä¸‹ç•Œ)
å¯¹äºæ¯”è¾ƒæ’åºç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ä¸‹ç•Œä¸º $\Omega(n \log n)$ã€‚

**è¯æ˜**:
æ¯”è¾ƒæ’åºçš„å†³ç­–æ ‘é«˜åº¦ä¸º $\log(n!)$ï¼Œç”±æ–¯ç‰¹æ—å…¬å¼ï¼š
$\log(n!) = n \log n - n + O(\log n) = \Omega(n \log n)$

**å®šç† 16.1.1.2** (ç©ºé—´å¤æ‚åº¦å…³ç³»)
å¯¹äºä»»æ„ç®—æ³• $A$ï¼Œ$S_A(n) \leq T_A(n)$

**è¯æ˜**:
ç®—æ³•åœ¨æ—¶é—´ $T_A(n)$ å†…æœ€å¤šè®¿é—® $T_A(n)$ ä¸ªå†…å­˜ä½ç½®ã€‚

## 3 è®¾è®¡æ¨¡å¼

### 3.1 åˆ†æ²»æ³• (Divide and Conquer)

**å®šä¹‰ 16.1.1.4** (åˆ†æ²»æ³•)
åˆ†æ²»æ³•å°†é—®é¢˜åˆ†è§£ä¸ºå­é—®é¢˜ï¼Œé€’å½’æ±‚è§£ï¼Œç„¶ååˆå¹¶ç»“æœï¼š

$T(n) = aT(n/b) + f(n)$

å…¶ä¸­ $a \geq 1, b > 1, f(n)$ æ˜¯åˆ†è§£å’Œåˆå¹¶çš„å¤æ‚åº¦ã€‚

**Rust å®ç°**:

```rust
/// åˆ†æ²»æ³•ç‰¹å¾
pub trait DivideAndConquer<T> {
    fn solve(&self, input: &[T]) -> Vec<T>;
    fn divide(&self, input: &[T]) -> (Vec<T>, Vec<T>);
    fn conquer(&self, left: Vec<T>, right: Vec<T>) -> Vec<T>;
    fn base_case(&self, input: &[T]) -> Option<Vec<T>>;
}

/// å½’å¹¶æ’åºå®ç°
pub struct MergeSort;

impl<T: Ord + Clone> DivideAndConquer<T> for MergeSort {
    fn solve(&self, input: &[T]) -> Vec<T> {
        if let Some(result) = self.base_case(input) {
            return result;
        }

        let (left, right) = self.divide(input);
        let sorted_left = self.solve(&left);
        let sorted_right = self.solve(&right);
        self.conquer(sorted_left, sorted_right)
    }

    fn divide(&self, input: &[T]) -> (Vec<T>, Vec<T>) {
        let mid = input.len() / 2;
        (input[..mid].to_vec(), input[mid..].to_vec())
    }

    fn conquer(&self, left: Vec<T>, right: Vec<T>) -> Vec<T> {
        let mut result = Vec::with_capacity(left.len() + right.len());
        let mut i = 0;
        let mut j = 0;

        while i < left.len() && j < right.len() {
            if left[i] <= right[j] {
                result.push(left[i].clone());
                i += 1;
            } else {
                result.push(right[j].clone());
                j += 1;
            }
        }

        result.extend_from_slice(&left[i..]);
        result.extend_from_slice(&right[j..]);
        result
    }

    fn base_case(&self, input: &[T]) -> Option<Vec<T>> {
        if input.len() <= 1 {
            Some(input.to_vec())
        } else {
            None
        }
    }
}

// å¤æ‚åº¦åˆ†æ
impl MergeSort {
    /// æ—¶é—´å¤æ‚åº¦: O(n log n)
    pub fn time_complexity(&self, n: usize) -> f64 {
        (n as f64) * (n as f64).log2()
    }

    /// ç©ºé—´å¤æ‚åº¦: O(n)
    pub fn space_complexity(&self, n: usize) -> f64 {
        n as f64
    }
}
```

### 3.2 åŠ¨æ€è§„åˆ’ (Dynamic Programming)

**å®šä¹‰ 16.1.1.5** (åŠ¨æ€è§„åˆ’)
åŠ¨æ€è§„åˆ’é€šè¿‡å­é—®é¢˜é‡å æ±‚è§£ï¼Œé¿å…é‡å¤è®¡ç®—ï¼š

$T(n) = \sum_{i=1}^k T(n_i) + O(1)$

**Rust å®ç°**:

```rust
/// åŠ¨æ€è§„åˆ’ç‰¹å¾
pub trait DynamicProgramming<T, U> {
    fn solve(&self, input: T) -> U;
    fn subproblems(&self, input: &T) -> Vec<T>;
    fn combine(&self, sub_results: Vec<U>) -> U;
    fn memoize(&self, input: &T) -> Option<U>;
}

/// æ–æ³¢é‚£å¥‘æ•°åˆ—å®ç°
pub struct FibonacciDP {
    memo: std::collections::HashMap<usize, u64>,
}

impl FibonacciDP {
    pub fn new() -> Self {
        Self {
            memo: std::collections::HashMap::new(),
        }
    }

    pub fn fibonacci(&mut self, n: usize) -> u64 {
        if let Some(&result) = self.memo.get(&n) {
            return result;
        }

        let result = match n {
            0 => 0,
            1 => 1,
            _ => self.fibonacci(n - 1) + self.fibonacci(n - 2),
        };

        self.memo.insert(n, result);
        result
    }

    /// æ—¶é—´å¤æ‚åº¦: O(n)
    pub fn time_complexity(&self, n: usize) -> f64 {
        n as f64
    }

    /// ç©ºé—´å¤æ‚åº¦: O(n)
    pub fn space_complexity(&self, n: usize) -> f64 {
        n as f64
    }
}
```

### 3.3 è´ªå¿ƒç®—æ³• (Greedy Algorithm)

**å®šä¹‰ 16.1.1.6** (è´ªå¿ƒç®—æ³•)
è´ªå¿ƒç®—æ³•åœ¨æ¯ä¸€æ­¥é€‰æ‹©å±€éƒ¨æœ€ä¼˜è§£ï¼ŒæœŸæœ›è¾¾åˆ°å…¨å±€æœ€ä¼˜ã€‚

**Rust å®ç°**:

```rust
/// è´ªå¿ƒç®—æ³•ç‰¹å¾
pub trait GreedyAlgorithm<T, U> {
    fn solve(&self, input: T) -> U;
    fn select_choice(&self, choices: &[T]) -> Option<&T>;
    fn is_feasible(&self, choice: &T, current_solution: &U) -> bool;
}

/// æ´»åŠ¨é€‰æ‹©é—®é¢˜å®ç°
pub struct ActivitySelector {
    activities: Vec<(u64, u64)>, // (å¼€å§‹æ—¶é—´, ç»“æŸæ—¶é—´)
}

impl ActivitySelector {
    pub fn new(activities: Vec<(u64, u64)>) -> Self {
        Self { activities }
    }

    pub fn select_activities(&self) -> Vec<usize> {
        let mut selected = Vec::new();
        let mut current_end = 0;

        for (i, &(start, end)) in self.activities.iter().enumerate() {
            if start >= current_end {
                selected.push(i);
                current_end = end;
            }
        }

        selected
    }

    /// æ—¶é—´å¤æ‚åº¦: O(n log n) (æ’åº) + O(n) (é€‰æ‹©) = O(n log n)
    pub fn time_complexity(&self, n: usize) -> f64 {
        (n as f64) * (n as f64).log2()
    }

    /// ç©ºé—´å¤æ‚åº¦: O(n)
    pub fn space_complexity(&self, n: usize) -> f64 {
        n as f64
    }
}
```

## 4 æ€§èƒ½æµ‹è¯•æ¡†æ¶

```rust
use std::time::Instant;

/// æ€§èƒ½æµ‹è¯•æ¡†æ¶
pub struct PerformanceBenchmark;

impl PerformanceBenchmark {
    /// è¿è¡Œæ€§èƒ½æµ‹è¯•
    pub fn benchmark<F, T>(name: &str, f: F, input: T) -> f64
    where
        F: Fn(T) -> (),
        T: Clone,
    {
        let start = Instant::now();
        f(input.clone());
        let duration = start.elapsed();

        println!("{}: {:?}", name, duration);
        duration.as_secs_f64()
    }

    /// å¤æ‚åº¦éªŒè¯
    pub fn verify_complexity<F>(name: &str, f: F, expected: f64)
    where
        F: Fn(usize) -> f64,
    {
        let sizes = vec![100, 1000, 10000];
        let mut ratios = Vec::new();

        for i in 1..sizes.len() {
            let ratio = f(sizes[i]) / f(sizes[i-1]);
            ratios.push(ratio);
        }

        println!("{} complexity ratios: {:?}", name, ratios);
    }
}
```

## 5 ä¸æ¨¡å—å†…ä¸»é¢˜çš„å…³ç³»

- **16.2 å¤æ‚åº¦ç†è®º**: æä¾›æ—¶é—´å¤æ‚åº¦ã€ç©ºé—´å¤æ‚åº¦åˆ†æåŸºç¡€
- **16.3 ä¼˜åŒ–ç†è®º**: ç®—æ³•ä¼˜åŒ–ç­–ç•¥å’Œå¹¶è¡ŒåŒ–æ–¹æ³•
- **16.4 è®¾è®¡æ¨¡å¼**: æ›´å¤šç®—æ³•è®¾è®¡æ¨¡å¼å’Œåº”ç”¨
- **16.5 é«˜çº§ç®—æ³•**: å¤æ‚ç®—æ³•è®¾è®¡å’Œåˆ†æ

## 6 æ‰¹åˆ¤æ€§åˆ†æ

### 6.1 å“²å­¦ç»´åº¦

- **è®¡ç®—å“²å­¦**: ç®—æ³•è®¾è®¡åæ˜ äº†è®¡ç®—æœ¬è´¨çš„å“²å­¦æ€è€ƒï¼Œä½“ç°äº†"è®¡ç®—å³ä¿¡æ¯å¤„ç†"çš„æ ¸å¿ƒè§‚ç‚¹
- **è®¤è¯†è®ºåŸºç¡€**: ç®—æ³•è®¾è®¡æ–¹æ³•è®ºä½“ç°äº†äººç±»å¯¹é—®é¢˜æ±‚è§£çš„è®¤çŸ¥æ¨¡å¼ï¼Œä»å…·ä½“åˆ°æŠ½è±¡ï¼Œä»ç®€å•åˆ°å¤æ‚
- **æœ¬ä½“è®ºåæ€**: ç®—æ³•ä½œä¸ºæŠ½è±¡å®ä½“ï¼Œå…¶å­˜åœ¨å½¢å¼ä»‹äºæ•°å­¦å¯¹è±¡å’Œç‰©ç†å®ç°ä¹‹é—´

### 6.2 æ–¹æ³•è®ºç»´åº¦

- **è®¾è®¡èŒƒå¼æ¯”è¾ƒ**: åˆ†æ²»æ³•ã€åŠ¨æ€è§„åˆ’ã€è´ªå¿ƒç®—æ³•å„æœ‰é€‚ç”¨åœºæ™¯ï¼Œéœ€è¦æ ¹æ®é—®é¢˜ç‰¹æ€§é€‰æ‹©
- **å½¢å¼åŒ–ç¨‹åº¦**: å½“å‰ç®—æ³•è®¾è®¡çš„å½¢å¼åŒ–ç¨‹åº¦æœ‰é™ï¼Œç¼ºä¹ç»Ÿä¸€çš„æ•°å­¦è¯­è¨€æè¿°
- **éªŒè¯æ–¹æ³•**: ç®—æ³•æ­£ç¡®æ€§éªŒè¯ä¸»è¦ä¾èµ–æµ‹è¯•å’Œè¯æ˜ï¼Œç¼ºä¹è‡ªåŠ¨åŒ–çš„å½¢å¼åŒ–éªŒè¯å·¥å…·

### 6.3 å·¥ç¨‹ç»´åº¦

- **å®ç°å¤æ‚åº¦**: ç†è®ºç®—æ³•åˆ°å·¥ç¨‹å®ç°çš„è½¬æ¢å­˜åœ¨æ€§èƒ½æŸå¤±å’Œæ­£ç¡®æ€§é£é™©
- **å¯ç»´æŠ¤æ€§**: å¤æ‚ç®—æ³•çš„ç»´æŠ¤å’Œè°ƒè¯•å›°éš¾ï¼Œéœ€è¦æ›´å¥½çš„å·¥å…·æ”¯æŒ
- **æ€§èƒ½æƒè¡¡**: æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦çš„æƒè¡¡éœ€è¦æ ¹æ®å…·ä½“åº”ç”¨åœºæ™¯å†³å®š

### 6.4 ç¤¾ä¼šæŠ€æœ¯ç»´åº¦

- **æ•™è‚²é—¨æ§›**: ç®—æ³•è®¾è®¡çš„å­¦ä¹ æ›²çº¿é™¡å³­ï¼Œéœ€è¦æ›´å¥½çš„æ•™å­¦æ–¹æ³•å’Œå·¥å…·
- **çŸ¥è¯†æ°‘ä¸»åŒ–**: ç®—æ³•è®¾è®¡çŸ¥è¯†åº”è¯¥æ›´åŠ æ™®åŠï¼Œé™ä½æŠ€æœ¯é—¨æ§›
- **è´£ä»»æ²»ç†**: ç®—æ³•è®¾è®¡è€…éœ€è¦å¯¹ç®—æ³•çš„å½±å“è´Ÿè´£ï¼Œè€ƒè™‘å…¬å¹³æ€§å’Œå¯è§£é‡Šæ€§

## 7 å‚è§

- [16.2 å¤æ‚åº¦ç†è®º](../16.2_Complexity_Theory/16.2.1_Time_Complexity.md)
- [16.3 ä¼˜åŒ–ç†è®º](../16.3_Optimization_Theory/16.3.1_Algorithm_Optimization.md)
- [ç»Ÿä¸€æœ¯è¯­è¡¨](../../04_Type_Theory/TERMINOLOGY_TABLE.md)

## ğŸ“– å‚è€ƒæ–‡çŒ®

1. Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). _Introduction to Algorithms_. MIT Press.
2. Knuth, D. E. (1997). _The Art of Computer Programming_. Addison-Wesley.
3. Sedgewick, R., & Wayne, K. (2011). _Algorithms_. Addison-Wesley.
4. Kleinberg, J., & Tardos, Ã‰. (2006). _Algorithm Design_. Pearson.
5. Dasgupta, S., Papadimitriou, C., & Vazirani, U. (2008). _Algorithms_. McGraw-Hill.
