# 16.1.2 å¤æ‚åº¦åˆ†æ (Complexity Analysis)

**åˆ›å»ºæ—¶é—´**: 2025-01-17  
**æœ€åæ›´æ–°**: 2025-01-17  
**æ–‡æ¡£çŠ¶æ€**: æ´»è·ƒ  
**å…³è”æ¨¡å—**: `16_Algorithm_Theory`

## ğŸ“‹ ç›®å½•

- [1 æ¦‚è¿°](#1-æ¦‚è¿°)
- [2 ç†è®ºåŸºç¡€](#2-ç†è®ºåŸºç¡€)
  - [2.1 æ—¶é—´å¤æ‚åº¦ç†è®º](#21-æ—¶é—´å¤æ‚åº¦ç†è®º)
  - [2.2 ç©ºé—´å¤æ‚åº¦ç†è®º](#22-ç©ºé—´å¤æ‚åº¦ç†è®º)
- [3 å¤æ‚åº¦åˆ†æå·¥å…·](#3-å¤æ‚åº¦åˆ†æå·¥å…·)
  - [3.1 Rust å¤æ‚åº¦åˆ†ææ¡†æ¶](#31-rust-å¤æ‚åº¦åˆ†ææ¡†æ¶)
  - [3.2 å¸¸è§ç®—æ³•å¤æ‚åº¦åˆ†æ](#32-å¸¸è§ç®—æ³•å¤æ‚åº¦åˆ†æ)
  - [3.3 æ€§èƒ½æµ‹è¯•å’ŒåŸºå‡†æµ‹è¯•](#33-æ€§èƒ½æµ‹è¯•å’ŒåŸºå‡†æµ‹è¯•)
- [4 å¤æ‚åº¦åˆ†æç¤ºä¾‹](#4-å¤æ‚åº¦åˆ†æç¤ºä¾‹)
  - [4.1 ç¤ºä¾‹1 æ’åºç®—æ³•æ¯”è¾ƒ](#41-ç¤ºä¾‹1-æ’åºç®—æ³•æ¯”è¾ƒ)
  - [4.2 ç¤ºä¾‹2 æœç´¢ç®—æ³•æ¯”è¾ƒ](#42-ç¤ºä¾‹2-æœç´¢ç®—æ³•æ¯”è¾ƒ)
- [5 ä¸æ¨¡å—å†…ä¸»é¢˜çš„å…³ç³»](#5-ä¸æ¨¡å—å†…ä¸»é¢˜çš„å…³ç³»)
- [6 æ‰¹åˆ¤æ€§åˆ†æ](#6-æ‰¹åˆ¤æ€§åˆ†æ)
  - [6.1 å“²å­¦ç»´åº¦](#61-å“²å­¦ç»´åº¦)
  - [6.2 æ–¹æ³•è®ºç»´åº¦](#62-æ–¹æ³•è®ºç»´åº¦)
  - [6.3 å·¥ç¨‹ç»´åº¦](#63-å·¥ç¨‹ç»´åº¦)
  - [6.4 ç¤¾ä¼šæŠ€æœ¯ç»´åº¦](#64-ç¤¾ä¼šæŠ€æœ¯ç»´åº¦)
- [7 å‚è§](#7-å‚è§)

---

## 1 æ¦‚è¿°

å¤æ‚åº¦åˆ†ææ˜¯ç®—æ³•ç†è®ºçš„æ ¸å¿ƒï¼Œç ”ç©¶ç®—æ³•åœ¨æ—¶é—´å’Œç©ºé—´èµ„æºæ¶ˆè€—ä¸Šçš„è¡¨ç°ã€‚æœ¬æ–‡æ¡£æ¶µç›–æ—¶é—´å¤æ‚åº¦ã€ç©ºé—´å¤æ‚åº¦ã€æ¸è¿›åˆ†æã€æœ€ä¼˜æ€§è¯æ˜ç­‰æ ¸å¿ƒæ¦‚å¿µã€‚

## 2 ç†è®ºåŸºç¡€

### 2.1 æ—¶é—´å¤æ‚åº¦ç†è®º

**å®šä¹‰ 16.1.2.1** (æ—¶é—´å¤æ‚åº¦)
ç®—æ³• $A$ çš„æ—¶é—´å¤æ‚åº¦å‡½æ•° $T_A: \mathbb{N} \rightarrow \mathbb{N}$ å®šä¹‰ä¸ºï¼š
$T_A(n) = \max\{t_A(x) \mid |x| = n\}$

å…¶ä¸­ $t_A(x)$ æ˜¯ç®—æ³• $A$ åœ¨è¾“å…¥ $x$ ä¸Šçš„æ‰§è¡Œæ—¶é—´ã€‚

**å®šä¹‰ 16.1.2.2** (æ¸è¿›è®°å·)
- **å¤§Oè®°å·**: $f(n) = O(g(n))$ å½“ä¸”ä»…å½“ $\exists c > 0, n_0 > 0, \forall n \geq n_0, f(n) \leq c \cdot g(n)$
- **å¤§Î©è®°å·**: $f(n) = \Omega(g(n))$ å½“ä¸”ä»…å½“ $\exists c > 0, n_0 > 0, \forall n \geq n_0, f(n) \geq c \cdot g(n)$
- **å¤§Î˜è®°å·**: $f(n) = \Theta(g(n))$ å½“ä¸”ä»…å½“ $f(n) = O(g(n))$ ä¸” $f(n) = \Omega(g(n))$

**å®šç† 16.1.2.1** (ä¸»å®šç†)
å¯¹äºé€’å½’å…³ç³» $T(n) = aT(n/b) + f(n)$ï¼Œå…¶ä¸­ $a \geq 1, b > 1$ï¼š

1. å¦‚æœ $f(n) = O(n^{\log_b a - \epsilon})$ï¼Œåˆ™ $T(n) = \Theta(n^{\log_b a})$
2. å¦‚æœ $f(n) = \Theta(n^{\log_b a})$ï¼Œåˆ™ $T(n) = \Theta(n^{\log_b a} \log n)$
3. å¦‚æœ $f(n) = \Omega(n^{\log_b a + \epsilon})$ï¼Œåˆ™ $T(n) = \Theta(f(n))$

### 2.2 ç©ºé—´å¤æ‚åº¦ç†è®º

**å®šä¹‰ 16.1.2.3** (ç©ºé—´å¤æ‚åº¦)
ç®—æ³• $A$ çš„ç©ºé—´å¤æ‚åº¦å‡½æ•° $S_A: \mathbb{N} \rightarrow \mathbb{N}$ å®šä¹‰ä¸ºï¼š
$S_A(n) = \max\{s_A(x) \mid |x| = n\}$

å…¶ä¸­ $s_A(x)$ æ˜¯ç®—æ³• $A$ åœ¨è¾“å…¥ $x$ ä¸Šçš„å†…å­˜ä½¿ç”¨é‡ã€‚

**å®šç† 16.1.2.2** (ç©ºé—´-æ—¶é—´å…³ç³»)
å¯¹äºä»»æ„ç®—æ³• $A$ï¼Œ$S_A(n) \leq T_A(n)$

**è¯æ˜**: ç®—æ³•åœ¨æ—¶é—´ $T_A(n)$ å†…æœ€å¤šè®¿é—® $T_A(n)$ ä¸ªå†…å­˜ä½ç½®ã€‚

## 3 å¤æ‚åº¦åˆ†æå·¥å…·

### 3.1 Rust å¤æ‚åº¦åˆ†ææ¡†æ¶

```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};

/// å¤æ‚åº¦åˆ†æç‰¹å¾
pub trait ComplexityAnalysis {
    fn time_complexity(&self, n: usize) -> f64;
    fn space_complexity(&self, n: usize) -> f64;
    fn analyze(&self, input_sizes: &[usize]) -> ComplexityReport;
}

/// å¤æ‚åº¦æŠ¥å‘Š
#[derive(Debug)]
pub struct ComplexityReport {
    pub time_measurements: Vec<(usize, f64)>,
    pub space_measurements: Vec<(usize, f64)>,
    pub time_complexity_class: String,
    pub space_complexity_class: String,
    pub theoretical_time: f64,
    pub theoretical_space: f64,
}

/// å¤æ‚åº¦åˆ†æå™¨
pub struct ComplexityAnalyzer;

impl ComplexityAnalyzer {
    /// æµ‹é‡ç®—æ³•æ‰§è¡Œæ—¶é—´
    pub fn measure_time<F, T>(f: F, input: T) -> f64 
    where 
        F: Fn(T) -> (),
        T: Clone,
    {
        let start = Instant::now();
        f(input);
        start.elapsed().as_secs_f64()
    }
    
    /// åˆ†ææ—¶é—´å¤æ‚åº¦
    pub fn analyze_time_complexity<F>(f: F, sizes: &[usize]) -> Vec<(usize, f64)>
    where 
        F: Fn(usize) -> f64,
    {
        sizes.iter()
            .map(|&size| (size, f(size)))
            .collect()
    }
    
    /// ç¡®å®šå¤æ‚åº¦ç±»åˆ«
    pub fn determine_complexity_class(measurements: &[(usize, f64)]) -> String {
        if measurements.len() < 2 {
            return "Unknown".to_string();
        }
        
        let ratios: Vec<f64> = measurements.windows(2)
            .map(|window| {
                let (n1, t1) = window[0];
                let (n2, t2) = window[1];
                t2 / t1
            })
            .collect();
        
        // åˆ†æå¢é•¿ç‡
        let avg_ratio = ratios.iter().sum::<f64>() / ratios.len() as f64;
        
        match avg_ratio {
            r if r < 1.5 => "O(1)".to_string(),
            r if r < 2.5 => "O(log n)".to_string(),
            r if r < 3.5 => "O(n)".to_string(),
            r if r < 6.0 => "O(n log n)".to_string(),
            r if r < 12.0 => "O(nÂ²)".to_string(),
            r if r < 25.0 => "O(nÂ³)".to_string(),
            _ => "O(2â¿)".to_string(),
        }
    }
}
```

### 3.2 å¸¸è§ç®—æ³•å¤æ‚åº¦åˆ†æ

```rust
/// æ’åºç®—æ³•å¤æ‚åº¦åˆ†æ
pub struct SortingComplexity;

impl SortingComplexity {
    /// å†’æ³¡æ’åº: O(nÂ²) æ—¶é—´, O(1) ç©ºé—´
    pub fn bubble_sort<T: Ord>(arr: &mut [T]) {
        let n = arr.len();
        for i in 0..n {
            for j in 0..n-i-1 {
                if arr[j] > arr[j+1] {
                    arr.swap(j, j+1);
                }
            }
        }
    }
    
    /// å¿«é€Ÿæ’åº: O(n log n) å¹³å‡æ—¶é—´, O(log n) ç©ºé—´
    pub fn quick_sort<T: Ord + Clone>(arr: &[T]) -> Vec<T> {
        if arr.len() <= 1 {
            return arr.to_vec();
        }
        
        let pivot = &arr[0];
        let (left, right): (Vec<_>, Vec<_>) = arr[1..]
            .iter()
            .partition(|&x| x <= pivot);
        
        let mut result = Self::quick_sort(&left);
        result.push(pivot.clone());
        result.extend(Self::quick_sort(&right));
        result
    }
    
    /// å †æ’åº: O(n log n) æ—¶é—´, O(1) ç©ºé—´
    pub fn heap_sort<T: Ord>(arr: &mut [T]) {
        // æ„å»ºæœ€å¤§å †
        for i in (0..arr.len()/2).rev() {
            Self::heapify(arr, i);
        }
        
        // é€ä¸ªæå–æœ€å¤§å€¼
        for i in (1..arr.len()).rev() {
            arr.swap(0, i);
            Self::heapify(&mut arr[..i], 0);
        }
    }
    
    fn heapify<T: Ord>(arr: &mut [T], mut i: usize) {
        let n = arr.len();
        loop {
            let mut largest = i;
            let left = 2 * i + 1;
            let right = 2 * i + 2;
            
            if left < n && arr[left] > arr[largest] {
                largest = left;
            }
            
            if right < n && arr[right] > arr[largest] {
                largest = right;
            }
            
            if largest == i {
                break;
            }
            
            arr.swap(i, largest);
            i = largest;
        }
    }
}

/// æœç´¢ç®—æ³•å¤æ‚åº¦åˆ†æ
pub struct SearchComplexity;

impl SearchComplexity {
    /// çº¿æ€§æœç´¢: O(n) æ—¶é—´, O(1) ç©ºé—´
    pub fn linear_search<T: PartialEq>(arr: &[T], target: &T) -> Option<usize> {
        arr.iter().position(|x| x == target)
    }
    
    /// äºŒåˆ†æœç´¢: O(log n) æ—¶é—´, O(1) ç©ºé—´
    pub fn binary_search<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
        let mut left = 0;
        let mut right = arr.len();
        
        while left < right {
            let mid = left + (right - left) / 2;
            match arr[mid].cmp(target) {
                std::cmp::Ordering::Equal => return Some(mid),
                std::cmp::Ordering::Less => left = mid + 1,
                std::cmp::Ordering::Greater => right = mid,
            }
        }
        None
    }
}
```

### 3.3 æ€§èƒ½æµ‹è¯•å’ŒåŸºå‡†æµ‹è¯•

```rust
/// æ€§èƒ½åŸºå‡†æµ‹è¯•æ¡†æ¶
pub struct BenchmarkFramework;

impl BenchmarkFramework {
    /// è¿è¡ŒåŸºå‡†æµ‹è¯•
    pub fn run_benchmark<F, T>(name: &str, f: F, inputs: &[T]) -> BenchmarkResult
    where 
        F: Fn(&T) -> (),
        T: Clone,
    {
        let mut measurements = Vec::new();
        
        for input in inputs {
            let start = Instant::now();
            f(input);
            let duration = start.elapsed();
            measurements.push(duration.as_secs_f64());
        }
        
        let avg_time = measurements.iter().sum::<f64>() / measurements.len() as f64;
        let min_time = measurements.iter().fold(f64::INFINITY, |a, &b| a.min(b));
        let max_time = measurements.iter().fold(0.0, |a, &b| a.max(*b));
        
        BenchmarkResult {
            name: name.to_string(),
            average_time: avg_time,
            min_time,
            max_time,
            measurements,
        }
    }
    
    /// å¤æ‚åº¦éªŒè¯
    pub fn verify_complexity<F>(name: &str, f: F, expected: &str, sizes: &[usize])
    where 
        F: Fn(usize) -> f64,
    {
        let measurements = ComplexityAnalyzer::analyze_time_complexity(f, sizes);
        let complexity_class = ComplexityAnalyzer::determine_complexity_class(&measurements);
        
        println!("{}: Expected {}, Measured {}", name, expected, complexity_class);
        
        if complexity_class == expected {
            println!("âœ… Complexity verification passed");
        } else {
            println!("âŒ Complexity verification failed");
        }
    }
}

#[derive(Debug)]
pub struct BenchmarkResult {
    pub name: String,
    pub average_time: f64,
    pub min_time: f64,
    pub max_time: f64,
    pub measurements: Vec<f64>,
}
```

## 4 å¤æ‚åº¦åˆ†æç¤ºä¾‹

### 4.1 ç¤ºä¾‹1 æ’åºç®—æ³•æ¯”è¾ƒ

```rust
fn main() {
    let sizes = vec![100, 1000, 10000];
    
    // æµ‹è¯•ä¸åŒæ’åºç®—æ³•çš„å¤æ‚åº¦
    ComplexityAnalyzer::verify_complexity(
        "Bubble Sort",
        |n| n as f64 * n as f64,
        "O(nÂ²)",
        &sizes
    );
    
    ComplexityAnalyzer::verify_complexity(
        "Quick Sort",
        |n| n as f64 * (n as f64).log2(),
        "O(n log n)",
        &sizes
    );
    
    ComplexityAnalyzer::verify_complexity(
        "Heap Sort",
        |n| n as f64 * (n as f64).log2(),
        "O(n log n)",
        &sizes
    );
}
```

### 4.2 ç¤ºä¾‹2 æœç´¢ç®—æ³•æ¯”è¾ƒ

```rust
fn main() {
    let sizes = vec![100, 1000, 10000, 100000];
    
    ComplexityAnalyzer::verify_complexity(
        "Linear Search",
        |n| n as f64,
        "O(n)",
        &sizes
    );
    
    ComplexityAnalyzer::verify_complexity(
        "Binary Search",
        |n| (n as f64).log2(),
        "O(log n)",
        &sizes
    );
}
```

## 5 ä¸æ¨¡å—å†…ä¸»é¢˜çš„å…³ç³»

- **16.1.1 ç®—æ³•è®¾è®¡**: æä¾›ç®—æ³•è®¾è®¡çš„åŸºç¡€ç†è®º
- **16.2 å¤æ‚åº¦ç†è®º**: æ›´æ·±å…¥çš„å¤æ‚åº¦ç†è®ºåˆ†æ
- **16.3 ä¼˜åŒ–ç†è®º**: ç®—æ³•ä¼˜åŒ–å’Œæ€§èƒ½æå‡æ–¹æ³•
- **16.4 è®¾è®¡æ¨¡å¼**: ç®—æ³•è®¾è®¡æ¨¡å¼çš„åº”ç”¨

## 6 æ‰¹åˆ¤æ€§åˆ†æ

### 6.1 å“²å­¦ç»´åº¦
- **è®¡ç®—å“²å­¦**: å¤æ‚åº¦åˆ†æåæ˜ äº†è®¡ç®—èµ„æºçš„æœ‰é™æ€§ï¼Œä½“ç°äº†"è®¡ç®—å³èµ„æºæ¶ˆè€—"çš„å“²å­¦è§‚ç‚¹
- **è®¤è¯†è®ºåŸºç¡€**: æ¸è¿›åˆ†æä½“ç°äº†äººç±»å¯¹ç®—æ³•æ€§èƒ½çš„è®¤çŸ¥æ¨¡å¼ï¼Œä»ç²¾ç¡®åˆ°è¿‘ä¼¼ï¼Œä»å…·ä½“åˆ°æŠ½è±¡
- **æœ¬ä½“è®ºåæ€**: å¤æ‚åº¦ä½œä¸ºç®—æ³•å›ºæœ‰å±æ€§ï¼Œå…¶å­˜åœ¨å½¢å¼ä»‹äºæ•°å­¦æŠ½è±¡å’Œç‰©ç†ç°å®ä¹‹é—´

### 6.2 æ–¹æ³•è®ºç»´åº¦
- **åˆ†ææ–¹æ³•æ¯”è¾ƒ**: ä¸åŒå¤æ‚åº¦åˆ†ææ–¹æ³•å„æœ‰ä¼˜ç¼ºç‚¹ï¼Œéœ€è¦æ ¹æ®å…·ä½“åœºæ™¯é€‰æ‹©
- **æµ‹é‡ç²¾åº¦**: å®é™…æµ‹é‡ä¸ç†è®ºåˆ†æçš„å·®å¼‚åæ˜ äº†æ¨¡å‹ç®€åŒ–çš„å±€é™æ€§
- **é¢„æµ‹èƒ½åŠ›**: å¤æ‚åº¦åˆ†æå¯¹å®é™…æ€§èƒ½çš„é¢„æµ‹èƒ½åŠ›æœ‰é™ï¼Œéœ€è¦ç»“åˆå…·ä½“ç¡¬ä»¶ç¯å¢ƒ

### 6.3 å·¥ç¨‹ç»´åº¦
- **å®ç°å½±å“**: ç®—æ³•å®ç°ç»†èŠ‚å¯¹å®é™…æ€§èƒ½æœ‰é‡å¤§å½±å“ï¼Œç†è®ºåˆ†æåªæ˜¯ä¸Šç•Œ
- **ç¡¬ä»¶ä¾èµ–**: ä¸åŒç¡¬ä»¶å¹³å°ä¸Šçš„æ€§èƒ½è¡¨ç°å·®å¼‚å¾ˆå¤§ï¼Œéœ€è¦å®é™…æµ‹è¯•éªŒè¯
- **ä¼˜åŒ–æƒè¡¡**: æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦çš„æƒè¡¡éœ€è¦æ ¹æ®å…·ä½“åº”ç”¨éœ€æ±‚å†³å®š

### 6.4 ç¤¾ä¼šæŠ€æœ¯ç»´åº¦
- **æ•™è‚²ä»·å€¼**: å¤æ‚åº¦åˆ†ææ˜¯ç®—æ³•æ•™è‚²çš„é‡è¦å†…å®¹ï¼Œä½†å­¦ä¹ æ›²çº¿è¾ƒé™¡
- **å·¥ç¨‹å®è·µ**: åœ¨å®é™…å·¥ç¨‹ä¸­ï¼Œå¤æ‚åº¦åˆ†æå¾€å¾€è¢«å¿½è§†ï¼Œå¯¼è‡´æ€§èƒ½é—®é¢˜
- **æ ‡å‡†åŒ–éœ€æ±‚**: éœ€è¦å»ºç«‹ç»Ÿä¸€çš„å¤æ‚åº¦åˆ†ææ ‡å‡†å’Œå·¥å…·

## 7 å‚è§

- [16.1.1 ç®—æ³•è®¾è®¡](./16.1.1_Algorithm_Design.md)
- [16.2 å¤æ‚åº¦ç†è®º](../16.2_Complexity_Theory/16.2.1_Time_Complexity.md)
- [ç»Ÿä¸€æœ¯è¯­è¡¨](../../04_Type_Theory/TERMINOLOGY_TABLE.md)

## ğŸ“– å‚è€ƒæ–‡çŒ®

1. Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms*. MIT Press.
2. Knuth, D. E. (1997). *The Art of Computer Programming*. Addison-Wesley.
3. Sedgewick, R., & Wayne, K. (2011). *Algorithms*. Addison-Wesley.
4. Kleinberg, J., & Tardos, Ã‰. (2006). *Algorithm Design*. Pearson.
5. Dasgupta, S., Papadimitriou, C., & Vazirani, U. (2008). *Algorithms*. McGraw-Hill. 