# 09.7 å¾®æ¶æ„è®¾è®¡ç†è®ºï¼ˆMicroarchitecture Design Theoryï¼‰

[è¿”å›è®¡ç®—æœºä½“ç³»ç»“æ„ç†è®ºä¸»é¢˜ç´¢å¼•](README.md)

> æœ¬æ–‡æ¡£ç³»ç»Ÿæ•´ç†å¾®æ¶æ„è®¾è®¡ç†è®ºï¼ŒåŒ…æ‹¬æµæ°´çº¿ã€ä¹±åºæ‰§è¡Œã€ç¼“å­˜ä¸€è‡´æ€§ã€å¾®æ“ä½œç­‰ï¼Œä¸¥æ ¼æ ‘å½¢ç¼–å·ã€ç›®å½•ã€æœ¬åœ°è·³è½¬é”šç‚¹ä¸äº¤å‰å¼•ç”¨ï¼Œå†…å®¹æŒç»­è§„èŒƒåŒ–ä¸­ã€‚

---

## ğŸ“‹ ç›®å½•

- [1 å¾®æ¶æ„è®¾è®¡ç†è®º](#1-å¾®æ¶æ„è®¾è®¡ç†è®º)
- [2 å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
  - [2.1 å¾®æ¶æ„åŸºç¡€](#21-å¾®æ¶æ„åŸºç¡€)
  - [2.2 æ€§èƒ½æ¨¡å‹](#22-æ€§èƒ½æ¨¡å‹)
- [3 æ ¸å¿ƒå®šç†](#3-æ ¸å¿ƒå®šç†)
  - [3.1 æµæ°´çº¿æ€§èƒ½å®šç†](#31-æµæ°´çº¿æ€§èƒ½å®šç†)
  - [3.2 åˆ†æ”¯é¢„æµ‹å®šç†](#32-åˆ†æ”¯é¢„æµ‹å®šç†)
- [4 ç®—æ³•å®ç°](#4-ç®—æ³•å®ç°)
  - [4.1 äº”çº§æµæ°´çº¿å®ç°](#41-äº”çº§æµæ°´çº¿å®ç°)
  - [4.2 åˆ†æ”¯é¢„æµ‹å™¨å®ç°](#42-åˆ†æ”¯é¢„æµ‹å™¨å®ç°)
  - [4.3 ç¼“å­˜å±‚æ¬¡å®ç°](#43-ç¼“å­˜å±‚æ¬¡å®ç°)
- [5 åº”ç”¨åœºæ™¯](#5-åº”ç”¨åœºæ™¯)
  - [5.1 å¤„ç†å™¨è®¾è®¡](#51-å¤„ç†å™¨è®¾è®¡)
  - [5.2 æ€§èƒ½ä¼˜åŒ–](#52-æ€§èƒ½ä¼˜åŒ–)
  - [5.3 ç³»ç»Ÿè®¾è®¡](#53-ç³»ç»Ÿè®¾è®¡)
- [6 ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
  - [6.1 è®¡ç®—æœºç»„ç»‡](#61-è®¡ç®—æœºç»„ç»‡)
  - [6.2 æ€§èƒ½åˆ†æ](#62-æ€§èƒ½åˆ†æ)
  - [6.3 å¹¶è¡Œè®¡ç®—](#63-å¹¶è¡Œè®¡ç®—)
- [7 æ‰¹åˆ¤æ€§åˆ†æ](#7-æ‰¹åˆ¤æ€§åˆ†æ)

---

## 1 å¾®æ¶æ„è®¾è®¡ç†è®º

## 2 å½¢å¼åŒ–å®šä¹‰

### 2.1 å¾®æ¶æ„åŸºç¡€

**å®šä¹‰ 9.1.03.1 (å¾®æ¶æ„)**
å¾®æ¶æ„ $\mu$ æ˜¯å¤„ç†å™¨å†…éƒ¨å®ç°ï¼Œå®šä¹‰ä¸ºï¼š
$$\mu = (\mathcal{P}, \mathcal{C}, \mathcal{B}, \mathcal{M})$$
å…¶ä¸­ï¼š

- $\mathcal{P}$ æ˜¯æµæ°´çº¿ç»“æ„
- $\mathcal{C}$ æ˜¯ç¼“å­˜å±‚æ¬¡
- $\mathcal{B}$ æ˜¯åˆ†æ”¯é¢„æµ‹å™¨
- $\mathcal{M}$ æ˜¯å†…å­˜å­ç³»ç»Ÿ

**å®šä¹‰ 9.1.03.2 (æµæ°´çº¿)**
æµæ°´çº¿ $\mathcal{P}$ æ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$\mathcal{P} = (S, R, H, D, W)$$
å…¶ä¸­ï¼š

- $S$ æ˜¯æµæ°´çº¿çº§æ•°
- $R$ æ˜¯æµæ°´çº¿å¯„å­˜å™¨
- $H$ æ˜¯å†’é™©æ£€æµ‹
- $D$ æ˜¯æ•°æ®é€šè·¯
- $W$ æ˜¯å†™å›å•å…ƒ

**å®šä¹‰ 9.1.03.3 (ç¼“å­˜å±‚æ¬¡)**
ç¼“å­˜å±‚æ¬¡ $\mathcal{C}$ æ˜¯ä¸€ä¸ªååºé›†ï¼š
$$\mathcal{C} = (L, \prec, \text{size}, \text{latency})$$
å…¶ä¸­ $L$ æ˜¯ç¼“å­˜çº§åˆ«ï¼Œ$\prec$ è¡¨ç¤ºåŒ…å«å…³ç³»ã€‚

### 2.2 æ€§èƒ½æ¨¡å‹

**å®šä¹‰ 9.1.03.4 (CPIæ¨¡å‹)**
æ¯æ¡æŒ‡ä»¤å¹³å‡å‘¨æœŸæ•°ï¼š
$$\text{CPI} = \text{CPI}_{\text{ideal}} + \text{CPI}_{\text{stall}} + \text{CPI}_{\text{branch}} + \text{CPI}_{\text{cache}}$$

**å®šä¹‰ 9.1.03.5 (æµæ°´çº¿æ•ˆç‡)**
æµæ°´çº¿æ•ˆç‡ï¼š
$$\eta = \frac{\text{Instructions}}{\text{Cycles}} = \frac{1}{\text{CPI}}$$

## 3 æ ¸å¿ƒå®šç†

### 3.1 æµæ°´çº¿æ€§èƒ½å®šç†

**å®šç† 9.1.03.1 (æµæ°´çº¿åŠ é€Ÿæ¯”)**
ç†æƒ³æµæ°´çº¿çš„åŠ é€Ÿæ¯”ä¸ºï¼š
$$S = \frac{n \times T_s}{T_s + (n-1) \times T_p}$$
å…¶ä¸­ $n$ æ˜¯æµæ°´çº¿çº§æ•°ï¼Œ$T_s$ æ˜¯ä¸²è¡Œæ‰§è¡Œæ—¶é—´ï¼Œ$T_p$ æ˜¯æµæ°´çº¿å‘¨æœŸã€‚

**è¯æ˜ï¼š**

1. ä¸²è¡Œæ‰§è¡Œæ—¶é—´ï¼š$T_s = n \times T_p$
2. æµæ°´çº¿æ‰§è¡Œæ—¶é—´ï¼š$T_p + (n-1) \times T_p$
3. åŠ é€Ÿæ¯”è®¡ç®—

### 3.2 åˆ†æ”¯é¢„æµ‹å®šç†

**å®šç† 9.1.03.2 (åˆ†æ”¯é¢„æµ‹å‡†ç¡®ç‡)**
åˆ†æ”¯é¢„æµ‹å‡†ç¡®ç‡å¯¹æ€§èƒ½çš„å½±å“ï¼š
$$\text{CPI}_{\text{branch}} = \text{branch\_freq} \times (1 - \text{accuracy}) \times \text{penalty}$$

**è¯æ˜ï¼š**

1. åˆ†æ”¯é¢‘ç‡å½±å“
2. é¢„æµ‹é”™è¯¯å¯¼è‡´æµæ°´çº¿æ¸…ç©º
3. æ€§èƒ½æŸå¤±è®¡ç®—

## 4 ç®—æ³•å®ç°

### 4.1 äº”çº§æµæ°´çº¿å®ç°

```rust
use std::collections::HashMap;

// æµæ°´çº¿é˜¶æ®µ
#[derive(Debug, Clone)]
enum PipelineStage {
    Fetch,
    Decode,
    Execute,
    Memory,
    WriteBack,
}

// æµæ°´çº¿å¯„å­˜å™¨
#[derive(Debug, Clone)]
struct PipelineRegister {
    instruction: Option<Instruction>,
    stage: PipelineStage,
    valid: bool,
    stall: bool,
    flush: bool,
    pc: usize,
    rs1_data: Option<i32>,
    rs2_data: Option<i32>,
    alu_result: Option<i32>,
    memory_data: Option<i32>,
}

// äº”çº§æµæ°´çº¿CPU
#[derive(Debug)]
struct FiveStagePipeline {
    registers: [i32; 32],
    memory: HashMap<usize, u8>,
    pc: usize,
    pipeline: Vec<PipelineRegister>,
    clock_cycles: usize,
    instructions_executed: usize,
    stalls: usize,
    flushes: usize,
}

impl FiveStagePipeline {
    fn new() -> Self {
        let mut pipeline = Vec::new();
        for _ in 0..5 {
            pipeline.push(PipelineRegister {
                instruction: None,
                stage: PipelineStage::Fetch,
                valid: false,
                stall: false,
                flush: false,
                pc: 0,
                rs1_data: None,
                rs2_data: None,
                alu_result: None,
                memory_data: None,
            });
        }
        
        Self {
            registers: [0; 32],
            memory: HashMap::new(),
            pc: 0,
            pipeline,
            clock_cycles: 0,
            instructions_executed: 0,
            stalls: 0,
            flushes: 0,
        }
    }

    // æµæ°´çº¿æ‰§è¡Œä¸€ä¸ªå‘¨æœŸ
    fn cycle(&mut self, program: &[Instruction]) {
        // å†™å›é˜¶æ®µ
        self.write_back_stage();
        
        // å†…å­˜é˜¶æ®µ
        self.memory_stage();
        
        // æ‰§è¡Œé˜¶æ®µ
        self.execute_stage();
        
        // è¯‘ç é˜¶æ®µ
        self.decode_stage();
        
        // å–æŒ‡é˜¶æ®µ
        self.fetch_stage(program);
        
        self.clock_cycles += 1;
    }

    // å–æŒ‡é˜¶æ®µ
    fn fetch_stage(&mut self, program: &[Instruction]) {
        let fetch_reg = &mut self.pipeline[0];
        
        if !fetch_reg.stall {
            let instruction_index = self.pc / 4;
            if instruction_index < program.len() {
                fetch_reg.instruction = Some(program[instruction_index].clone());
                fetch_reg.valid = true;
                fetch_reg.stage = PipelineStage::Fetch;
                fetch_reg.pc = self.pc;
                self.pc += 4;
            } else {
                fetch_reg.valid = false;
            }
        }
    }

    // è¯‘ç é˜¶æ®µ
    fn decode_stage(&mut self) {
        let decode_reg = &mut self.pipeline[1];
        let fetch_reg = &self.pipeline[0];
        
        if fetch_reg.valid && !fetch_reg.stall {
            decode_reg.instruction = fetch_reg.instruction.clone();
            decode_reg.valid = true;
            decode_reg.stage = PipelineStage::Decode;
            decode_reg.pc = fetch_reg.pc;
            
            // è¯»å–å¯„å­˜å™¨å€¼
            if let Some(instruction) = &decode_reg.instruction {
                match instruction {
                    Instruction::Add(_, rs1, rs2) |
                    Instruction::Sub(_, rs1, rs2) |
                    Instruction::Beq(rs1, rs2, _) => {
                        decode_reg.rs1_data = Some(self.registers[*rs1]);
                        decode_reg.rs2_data = Some(self.registers[*rs2]);
                    }
                    Instruction::Addi(_, rs1, _) |
                    Instruction::Lw(_, rs1, _) |
                    Instruction::Sw(_, rs1, _) => {
                        decode_reg.rs1_data = Some(self.registers[*rs1]);
                    }
                    _ => {}
                }
            }
        } else {
            decode_reg.valid = false;
        }
    }

    // æ‰§è¡Œé˜¶æ®µ
    fn execute_stage(&mut self) {
        let execute_reg = &mut self.pipeline[2];
        let decode_reg = &self.pipeline[1];
        
        if decode_reg.valid && !decode_reg.stall {
            execute_reg.instruction = decode_reg.instruction.clone();
            execute_reg.valid = true;
            execute_reg.stage = PipelineStage::Execute;
            execute_reg.pc = decode_reg.pc;
            execute_reg.rs1_data = decode_reg.rs1_data;
            execute_reg.rs2_data = decode_reg.rs2_data;
            
            // ALUæ“ä½œ
            if let Some(instruction) = &execute_reg.instruction {
                match instruction {
                    Instruction::Add(_, _, _) => {
                        if let (Some(rs1), Some(rs2)) = (execute_reg.rs1_data, execute_reg.rs2_data) {
                            execute_reg.alu_result = Some(rs1 + rs2);
                        }
                    }
                    Instruction::Sub(_, _, _) => {
                        if let (Some(rs1), Some(rs2)) = (execute_reg.rs1_data, execute_reg.rs2_data) {
                            execute_reg.alu_result = Some(rs1 - rs2);
                        }
                    }
                    Instruction::Addi(_, _, imm) => {
                        if let Some(rs1) = execute_reg.rs1_data {
                            execute_reg.alu_result = Some(rs1 + *imm);
                        }
                    }
                    Instruction::Beq(_, _, offset) => {
                        if let (Some(rs1), Some(rs2)) = (execute_reg.rs1_data, execute_reg.rs2_data) {
                            if rs1 == rs2 {
                                // åˆ†æ”¯é¢„æµ‹é”™è¯¯ï¼Œéœ€è¦æ¸…ç©ºæµæ°´çº¿
                                self.flush_pipeline();
                                self.pc = (execute_reg.pc as i32 + *offset) as usize;
                                self.flushes += 1;
                            }
                        }
                    }
                    _ => {}
                }
            }
        } else {
            execute_reg.valid = false;
        }
    }

    // å†…å­˜é˜¶æ®µ
    fn memory_stage(&mut self) {
        let memory_reg = &mut self.pipeline[3];
        let execute_reg = &self.pipeline[2];
        
        if execute_reg.valid && !execute_reg.stall {
            memory_reg.instruction = execute_reg.instruction.clone();
            memory_reg.valid = true;
            memory_reg.stage = PipelineStage::Memory;
            memory_reg.pc = execute_reg.pc;
            memory_reg.alu_result = execute_reg.alu_result;
            
            // å†…å­˜è®¿é—®
            if let Some(instruction) = &memory_reg.instruction {
                match instruction {
                    Instruction::Lw(_, _, offset) => {
                        if let (Some(rs1), Some(alu_result)) = (execute_reg.rs1_data, execute_reg.alu_result) {
                            let address = (rs1 + *offset) as usize;
                            let value = self.load_word(address);
                            memory_reg.memory_data = Some(value);
                        }
                    }
                    Instruction::Sw(_, _, offset) => {
                        if let (Some(rs1), Some(rs2)) = (execute_reg.rs1_data, execute_reg.rs2_data) {
                            let address = (rs1 + *offset) as usize;
                            self.store_word(address, rs2);
                        }
                    }
                    _ => {}
                }
            }
        } else {
            memory_reg.valid = false;
        }
    }

    // å†™å›é˜¶æ®µ
    fn write_back_stage(&mut self) {
        let writeback_reg = &self.pipeline[4];
        
        if writeback_reg.valid && !writeback_reg.stall {
            if let Some(instruction) = &writeback_reg.instruction {
                match instruction {
                    Instruction::Add(rd, _, _) |
                    Instruction::Sub(rd, _, _) |
                    Instruction::Addi(rd, _, _) => {
                        if let Some(alu_result) = writeback_reg.alu_result {
                            self.registers[*rd] = alu_result;
                        }
                    }
                    Instruction::Lw(rd, _, _) => {
                        if let Some(memory_data) = writeback_reg.memory_data {
                            self.registers[*rd] = memory_data;
                        }
                    }
                    _ => {}
                }
            }
            self.instructions_executed += 1;
        }
    }

    // æ¸…ç©ºæµæ°´çº¿
    fn flush_pipeline(&mut self) {
        for i in 0..4 {
            self.pipeline[i].flush = true;
            self.pipeline[i].valid = false;
        }
    }

    // å†…å­˜è®¿é—®å‡½æ•°
    fn load_word(&self, address: usize) -> i32 {
        let mut value = 0u32;
        for i in 0..4 {
            let byte = self.memory.get(&(address + i)).copied().unwrap_or(0);
            value |= (byte as u32) << (i * 8);
        }
        value as i32
    }

    fn store_word(&mut self, address: usize, value: i32) {
        let value_u = value as u32;
        for i in 0..4 {
            let byte = ((value_u >> (i * 8)) & 0xFF) as u8;
            self.memory.insert(address + i, byte);
        }
    }

    // è¿è¡Œç¨‹åº
    fn run(&mut self, program: &[Instruction]) -> Result<(), String> {
        let max_cycles = program.len() * 10;
        
        for _ in 0..max_cycles {
            self.cycle(program);
            
            if self.instructions_executed >= program.len() {
                break;
            }
        }
        
        Ok(())
    }

    // è·å–æ€§èƒ½ç»Ÿè®¡
    fn get_performance_stats(&self) -> (usize, f64, f64, f64) {
        let cpi = if self.instructions_executed > 0 {
            self.clock_cycles as f64 / self.instructions_executed as f64
        } else {
            0.0
        };
        
        let stall_rate = if self.clock_cycles > 0 {
            self.stalls as f64 / self.clock_cycles as f64
        } else {
            0.0
        };
        
        let flush_rate = if self.instructions_executed > 0 {
            self.flushes as f64 / self.instructions_executed as f64
        } else {
            0.0
        };
        
        (self.instructions_executed, cpi, stall_rate, flush_rate)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_five_stage_pipeline() {
        let mut cpu = FiveStagePipeline::new();
        
        let program = vec![
            Instruction::Addi(1, 0, 5),  // x1 = 5
            Instruction::Addi(2, 0, 3),  // x2 = 3
            Instruction::Add(3, 1, 2),   // x3 = x1 + x2
        ];
        
        cpu.run(&program).unwrap();
        let (instructions, cpi, stall_rate, flush_rate) = cpu.get_performance_stats();
        
        assert_eq!(cpu.registers[3], 8);
        assert!(cpi > 0.0);
    }
}
```

### 4.2 åˆ†æ”¯é¢„æµ‹å™¨å®ç°

```rust
use std::collections::HashMap;

// åˆ†æ”¯é¢„æµ‹å™¨ç±»å‹
#[derive(Debug)]
enum BranchPredictor {
    StaticAlwaysTaken,
    StaticAlwaysNotTaken,
    Bimodal(usize),           // 2-bité¥±å’Œè®¡æ•°å™¨
    GShare(usize, usize),     // å…¨å±€å†å² + æ¨¡å¼å†å²è¡¨
    Tournament(usize, usize), // æ··åˆé¢„æµ‹å™¨
}

// 2-bité¥±å’Œè®¡æ•°å™¨
#[derive(Debug, Clone)]
enum SaturatingCounter {
    StronglyNotTaken = 0,
    WeaklyNotTaken = 1,
    WeaklyTaken = 2,
    StronglyTaken = 3,
}

impl SaturatingCounter {
    fn new() -> Self {
        Self::WeaklyNotTaken
    }

    fn update(&mut self, taken: bool) {
        match self {
            Self::StronglyNotTaken => {
                if taken { *self = Self::WeaklyNotTaken; }
            }
            Self::WeaklyNotTaken => {
                if taken { *self = Self::WeaklyTaken; } else { *self = Self::StronglyNotTaken; }
            }
            Self::WeaklyTaken => {
                if taken { *self = Self::StronglyTaken; } else { *self = Self::WeaklyNotTaken; }
            }
            Self::StronglyTaken => {
                if !taken { *self = Self::WeaklyTaken; }
            }
        }
    }

    fn predict(&self) -> bool {
        matches!(self, Self::WeaklyTaken | Self::StronglyTaken)
    }
}

// åˆ†æ”¯é¢„æµ‹å™¨å®ç°
struct BranchPredictorImpl {
    predictor_type: BranchPredictor,
    bimodal_table: HashMap<usize, SaturatingCounter>,
    global_history: usize,
    gshare_table: HashMap<usize, SaturatingCounter>,
    tournament_table: HashMap<usize, SaturatingCounter>,
    predictions: usize,
    correct_predictions: usize,
}

impl BranchPredictorImpl {
    fn new(predictor_type: BranchPredictor) -> Self {
        Self {
            predictor_type,
            bimodal_table: HashMap::new(),
            global_history: 0,
            gshare_table: HashMap::new(),
            tournament_table: HashMap::new(),
            predictions: 0,
            correct_predictions: 0,
        }
    }

    // é¢„æµ‹åˆ†æ”¯
    fn predict(&mut self, pc: usize) -> bool {
        self.predictions += 1;
        
        match &self.predictor_type {
            BranchPredictor::StaticAlwaysTaken => true,
            BranchPredictor::StaticAlwaysNotTaken => false,
            BranchPredictor::Bimodal(table_size) => {
                let index = pc % table_size;
                let counter = self.bimodal_table.entry(index).or_insert_with(SaturatingCounter::new);
                counter.predict()
            }
            BranchPredictor::GShare(history_bits, table_size) => {
                let index = (pc ^ self.global_history) % table_size;
                let counter = self.gshare_table.entry(index).or_insert_with(SaturatingCounter::new);
                counter.predict()
            }
            BranchPredictor::Tournament(selector_bits, table_size) => {
                let selector_index = pc % table_size;
                let selector = self.tournament_table.entry(selector_index).or_insert_with(SaturatingCounter::new);
                
                // ç®€åŒ–çš„æ··åˆé¢„æµ‹ï¼šé€‰æ‹©bimodalæˆ–gshare
                if selector.predict() {
                    // ä½¿ç”¨gshare
                    let index = (pc ^ self.global_history) % table_size;
                    let counter = self.gshare_table.entry(index).or_insert_with(SaturatingCounter::new);
                    counter.predict()
                } else {
                    // ä½¿ç”¨bimodal
                    let index = pc % table_size;
                    let counter = self.bimodal_table.entry(index).or_insert_with(SaturatingCounter::new);
                    counter.predict()
                }
            }
        }
    }

    // æ›´æ–°é¢„æµ‹å™¨
    fn update(&mut self, pc: usize, taken: bool, predicted: bool) {
        if predicted == taken {
            self.correct_predictions += 1;
        }
        
        match &self.predictor_type {
            BranchPredictor::StaticAlwaysTaken |
            BranchPredictor::StaticAlwaysNotTaken => {
                // é™æ€é¢„æµ‹å™¨ä¸éœ€è¦æ›´æ–°
            }
            BranchPredictor::Bimodal(table_size) => {
                let index = pc % table_size;
                if let Some(counter) = self.bimodal_table.get_mut(&index) {
                    counter.update(taken);
                }
            }
            BranchPredictor::GShare(history_bits, table_size) => {
                let index = (pc ^ self.global_history) % table_size;
                if let Some(counter) = self.gshare_table.get_mut(&index) {
                    counter.update(taken);
                }
                
                // æ›´æ–°å…¨å±€å†å²
                self.global_history = ((self.global_history << 1) | (taken as usize)) & ((1 << history_bits) - 1);
            }
            BranchPredictor::Tournament(selector_bits, table_size) => {
                let selector_index = pc % table_size;
                if let Some(selector) = self.tournament_table.get_mut(&selector_index) {
                    // æ›´æ–°é€‰æ‹©å™¨ï¼šå¦‚æœgshareé¢„æµ‹æ­£ç¡®è€Œbimodalé”™è¯¯ï¼Œæˆ–ç›¸å
                    let gshare_index = (pc ^ self.global_history) % table_size;
                    let bimodal_index = pc % table_size;
                    
                    let gshare_correct = if let Some(counter) = self.gshare_table.get(&gshare_index) {
                        counter.predict() == taken
                    } else {
                        false
                    };
                    
                    let bimodal_correct = if let Some(counter) = self.bimodal_table.get(&bimodal_index) {
                        counter.predict() == taken
                    } else {
                        false
                    };
                    
                    if gshare_correct != bimodal_correct {
                        selector.update(gshare_correct);
                    }
                }
                
                // æ›´æ–°gshare
                let index = (pc ^ self.global_history) % table_size;
                if let Some(counter) = self.gshare_table.get_mut(&index) {
                    counter.update(taken);
                }
                
                // æ›´æ–°bimodal
                let index = pc % table_size;
                if let Some(counter) = self.bimodal_table.get_mut(&index) {
                    counter.update(taken);
                }
                
                // æ›´æ–°å…¨å±€å†å²
                self.global_history = ((self.global_history << 1) | (taken as usize)) & 0xFF;
            }
        }
    }

    // è·å–é¢„æµ‹å‡†ç¡®ç‡
    fn get_accuracy(&self) -> f64 {
        if self.predictions > 0 {
            self.correct_predictions as f64 / self.predictions as f64
        } else {
            0.0
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_branch_predictor() {
        let mut predictor = BranchPredictorImpl::new(BranchPredictor::Bimodal(1024));
        
        // æµ‹è¯•å¾ªç¯åˆ†æ”¯
        for _ in 0..100 {
            let predicted = predictor.predict(0x1000);
            predictor.update(0x1000, true, predicted);
        }
        
        let accuracy = predictor.get_accuracy();
        assert!(accuracy > 0.5); // åº”è¯¥å­¦ä¹ åˆ°å¾ªç¯æ¨¡å¼
    }
}
```

### 4.3 ç¼“å­˜å±‚æ¬¡å®ç°

```rust
use std::collections::HashMap;

// ç¼“å­˜è¡Œ
#[derive(Debug, Clone)]
struct CacheLine {
    tag: usize,
    data: Vec<u8>,
    valid: bool,
    dirty: bool,
    lru_counter: usize,
}

// ç¼“å­˜çº§åˆ«
#[derive(Debug)]
struct CacheLevel {
    lines: Vec<CacheLine>,
    line_size: usize,
    num_sets: usize,
    associativity: usize,
    hits: usize,
    misses: usize,
    clock: usize,
}

impl CacheLevel {
    fn new(line_size: usize, num_sets: usize, associativity: usize) -> Self {
        let num_lines = num_sets * associativity;
        let mut lines = Vec::with_capacity(num_lines);
        
        for _ in 0..num_lines {
            lines.push(CacheLine {
                tag: 0,
                data: vec![0; line_size],
                valid: false,
                dirty: false,
                lru_counter: 0,
            });
        }
        
        Self {
            lines,
            line_size,
            num_sets,
            associativity,
            hits: 0,
            misses: 0,
            clock: 0,
        }
    }

    // è®¿é—®ç¼“å­˜
    fn access(&mut self, address: usize, is_write: bool) -> bool {
        let (set_index, tag) = self.address_to_index_tag(address);
        self.clock += 1;
        
        if let Some(line_index) = self.find_line(set_index, tag) {
            // ç¼“å­˜å‘½ä¸­
            self.hits += 1;
            self.lines[line_index].lru_counter = self.clock;
            if is_write {
                self.lines[line_index].dirty = true;
            }
            true
        } else {
            // ç¼“å­˜æœªå‘½ä¸­
            self.misses += 1;
            let victim_index = self.select_victim(set_index);
            
            // å¦‚æœè¢«æ›¿æ¢çš„è¡Œæ˜¯è„çš„ï¼Œéœ€è¦å†™å›
            if self.lines[victim_index].valid && self.lines[victim_index].dirty {
                // è¿™é‡Œåº”è¯¥å†™å›ä¸‹ä¸€çº§ç¼“å­˜æˆ–å†…å­˜
            }
            
            // åŠ è½½æ–°æ•°æ®
            self.lines[victim_index].tag = tag;
            self.lines[victim_index].valid = true;
            self.lines[victim_index].dirty = is_write;
            self.lines[victim_index].lru_counter = self.clock;
            
            false
        }
    }

    fn address_to_index_tag(&self, address: usize) -> (usize, usize) {
        let set_index = (address / self.line_size) % self.num_sets;
        let tag = address / (self.line_size * self.num_sets);
        (set_index, tag)
    }

    fn find_line(&self, set_index: usize, tag: usize) -> Option<usize> {
        let start = set_index * self.associativity;
        let end = start + self.associativity;
        
        for i in start..end {
            if self.lines[i].valid && self.lines[i].tag == tag {
                return Some(i);
            }
        }
        None
    }

    fn select_victim(&self, set_index: usize) -> usize {
        let start = set_index * self.associativity;
        let end = start + self.associativity;
        
        let mut victim = start;
        let mut oldest = self.lines[start].lru_counter;
        
        for i in start..end {
            if !self.lines[i].valid {
                return i;
            }
            if self.lines[i].lru_counter < oldest {
                oldest = self.lines[i].lru_counter;
                victim = i;
            }
        }
        victim
    }

    fn get_hit_rate(&self) -> f64 {
        let total_accesses = self.hits + self.misses;
        if total_accesses > 0 {
            self.hits as f64 / total_accesses as f64
        } else {
            0.0
        }
    }
}

// ç¼“å­˜å±‚æ¬¡
#[derive(Debug)]
struct CacheHierarchy {
    levels: Vec<CacheLevel>,
    memory_accesses: usize,
}

impl CacheHierarchy {
    fn new() -> Self {
        let mut levels = Vec::new();
        
        // L1æ•°æ®ç¼“å­˜ï¼š32KBï¼Œ8è·¯ç»„ç›¸è”ï¼Œ64å­—èŠ‚è¡Œ
        levels.push(CacheLevel::new(64, 64, 8));
        
        // L2ç¼“å­˜ï¼š256KBï¼Œ8è·¯ç»„ç›¸è”ï¼Œ64å­—èŠ‚è¡Œ
        levels.push(CacheLevel::new(64, 512, 8));
        
        // L3ç¼“å­˜ï¼š8MBï¼Œ16è·¯ç»„ç›¸è”ï¼Œ64å­—èŠ‚è¡Œ
        levels.push(CacheLevel::new(64, 8192, 16));
        
        Self {
            levels,
            memory_accesses: 0,
        }
    }

    // è®¿é—®ç¼“å­˜å±‚æ¬¡
    fn access(&mut self, address: usize, is_write: bool) -> usize {
        for (level, cache) in self.levels.iter_mut().enumerate() {
            if cache.access(address, is_write) {
                return level; // åœ¨è¯¥çº§åˆ«å‘½ä¸­
            }
        }
        
        // æ‰€æœ‰ç¼“å­˜éƒ½æœªå‘½ä¸­ï¼Œè®¿é—®å†…å­˜
        self.memory_accesses += 1;
        self.levels.len()
    }

    // è·å–æ•´ä½“å‘½ä¸­ç‡
    fn get_overall_hit_rate(&self) -> f64 {
        let mut total_hits = 0;
        let mut total_misses = 0;
        
        for cache in &self.levels {
            total_hits += cache.hits;
            total_misses += cache.misses;
        }
        
        let total_accesses = total_hits + total_misses + self.memory_accesses;
        if total_accesses > 0 {
            total_hits as f64 / total_accesses as f64
        } else {
            0.0
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cache_hierarchy() {
        let mut hierarchy = CacheHierarchy::new();
        
        // æµ‹è¯•å±€éƒ¨æ€§è®¿é—®
        for i in 0..1000 {
            hierarchy.access(i * 64, false); // è¯»å–
        }
        
        // é‡å¤è®¿é—®ç›¸åŒåœ°å€
        for _ in 0..100 {
            hierarchy.access(0, false);
        }
        
        let hit_rate = hierarchy.get_overall_hit_rate();
        assert!(hit_rate > 0.0);
    }
}
```

## 5 åº”ç”¨åœºæ™¯

### 5.1 å¤„ç†å™¨è®¾è®¡

- é«˜æ€§èƒ½å¤„ç†å™¨è®¾è®¡
- ä½åŠŸè€—å¤„ç†å™¨è®¾è®¡
- åµŒå…¥å¼å¤„ç†å™¨è®¾è®¡

### 5.2 æ€§èƒ½ä¼˜åŒ–

- æµæ°´çº¿ä¼˜åŒ–
- ç¼“å­˜ä¼˜åŒ–
- åˆ†æ”¯é¢„æµ‹ä¼˜åŒ–

### 5.3 ç³»ç»Ÿè®¾è®¡

- å¤šæ ¸æ¶æ„è®¾è®¡
- å†…å­˜å­ç³»ç»Ÿè®¾è®¡
- I/Oç³»ç»Ÿè®¾è®¡

## 6 ç›¸å…³ç†è®º

### 6.1 è®¡ç®—æœºç»„ç»‡

- æ•°å­—é€»è¾‘è®¾è®¡
- æ—¶åºé€»è¾‘è®¾è®¡
- ç»„åˆé€»è¾‘è®¾è®¡

### 6.2 æ€§èƒ½åˆ†æ

- æ€§èƒ½å»ºæ¨¡
- ç“¶é¢ˆåˆ†æ
- å¯æ‰©å±•æ€§åˆ†æ

### 6.3 å¹¶è¡Œè®¡ç®—

- æŒ‡ä»¤çº§å¹¶è¡Œ
- æ•°æ®çº§å¹¶è¡Œ
- çº¿ç¨‹çº§å¹¶è¡Œ

## 6. å‚è€ƒæ–‡çŒ®

1. Hennessy, J. L., & Patterson, D. A. (2017). Computer Architecture: A Quantitative Approach.
2. Patterson, D. A., & Hennessy, J. L. (2017). Computer Organization and Design: The Hardware/Software Interface.
3. Smith, A. J. (1982). Cache memories.
4. Yeh, T., & Patt, Y. N. (1991). Two-level adaptive training branch prediction.
5. McFarling, S. (1993). Combining branch predictors.

## 7 æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
