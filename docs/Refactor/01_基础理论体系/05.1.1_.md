# 05.1.1 åŸºç¡€æ§åˆ¶ç†è®º

## ğŸ“‹ ç›®å½•

- [05.1.1 åŸºç¡€æ§åˆ¶ç†è®º](#0511-åŸºç¡€æ§åˆ¶ç†è®º)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2 æ ¸å¿ƒç›®æ ‡](#2-æ ¸å¿ƒç›®æ ‡)
  - [3 åŸºæœ¬æ¦‚å¿µ](#3-åŸºæœ¬æ¦‚å¿µ)
    - [3.1 æ§åˆ¶ç³»ç»ŸåŸºç¡€](#31-æ§åˆ¶ç³»ç»ŸåŸºç¡€)
    - [3.2 åé¦ˆæ§åˆ¶](#32-åé¦ˆæ§åˆ¶)
    - [3.3 ç³»ç»Ÿæ¨¡å‹](#33-ç³»ç»Ÿæ¨¡å‹)
  - [4 å½¢å¼åŒ–å®šä¹‰](#4-å½¢å¼åŒ–å®šä¹‰)
    - [4.1 çº¿æ€§ç³»ç»Ÿ](#41-çº¿æ€§ç³»ç»Ÿ)
    - [4.2 ç¨³å®šæ€§](#42-ç¨³å®šæ€§)
    - [4.3 å¯æ§æ€§å’Œå¯è§‚æ€§](#43-å¯æ§æ€§å’Œå¯è§‚æ€§)
  - [5 å®šç†ä¸è¯æ˜](#5-å®šç†ä¸è¯æ˜)
    - [5.1 ç¨³å®šæ€§å®šç†](#51-ç¨³å®šæ€§å®šç†)
    - [5.2 å¯æ§æ€§å’Œå¯è§‚æ€§å®šç†](#52-å¯æ§æ€§å’Œå¯è§‚æ€§å®šç†)
    - [5.3 åé¦ˆæ§åˆ¶å®šç†](#53-åé¦ˆæ§åˆ¶å®šç†)
  - [6 ç¨³å®šæ€§åˆ†æ](#6-ç¨³å®šæ€§åˆ†æ)
    - [6.1 åŠ³æ–¯-èµ«å°”ç»´èŒ¨åˆ¤æ®](#61-åŠ³æ–¯-èµ«å°”ç»´èŒ¨åˆ¤æ®)
    - [6.2 å¥ˆå¥æ–¯ç‰¹åˆ¤æ®](#62-å¥ˆå¥æ–¯ç‰¹åˆ¤æ®)
    - [6.3 æ ¹è½¨è¿¹åˆ†æ](#63-æ ¹è½¨è¿¹åˆ†æ)
  - [7 ä»£ç å®ç°](#7-ä»£ç å®ç°)
    - [7.1 Rust å®ç°](#71-rust-å®ç°)
    - [7.2 Haskell å®ç°](#72-haskell-å®ç°)
  - [8 åº”ç”¨ç¤ºä¾‹](#8-åº”ç”¨ç¤ºä¾‹)
    - [8.1 ä¸€é˜¶ç³»ç»Ÿæ§åˆ¶](#81-ä¸€é˜¶ç³»ç»Ÿæ§åˆ¶)
    - [8.2 äºŒé˜¶ç³»ç»Ÿæ§åˆ¶](#82-äºŒé˜¶ç³»ç»Ÿæ§åˆ¶)
    - [8.3 å€’ç«‹æ‘†æ§åˆ¶](#83-å€’ç«‹æ‘†æ§åˆ¶)
  - [9 ç›¸å…³ç†è®º](#9-ç›¸å…³ç†è®º)
    - [9.1 ä¸ç°ä»£æ§åˆ¶ç†è®ºçš„å…³ç³»](#91-ä¸ç°ä»£æ§åˆ¶ç†è®ºçš„å…³ç³»)
    - [9.2 ä¸ç³»ç»Ÿç†è®ºçš„å…³ç³»](#92-ä¸ç³»ç»Ÿç†è®ºçš„å…³ç³»)
    - [9.3 ä¸ä¿¡å·å¤„ç†çš„å…³ç³»](#93-ä¸ä¿¡å·å¤„ç†çš„å…³ç³»)
  - [8. å‚è€ƒæ–‡çŒ®](#8-å‚è€ƒæ–‡çŒ®)
  - [10 æ‰¹åˆ¤æ€§åˆ†æ](#10-æ‰¹åˆ¤æ€§åˆ†æ)
    - [10.1 å¤šå…ƒç†è®ºè§†è§’](#101-å¤šå…ƒç†è®ºè§†è§’)
    - [10.2 å±€é™æ€§åˆ†æ](#102-å±€é™æ€§åˆ†æ)
    - [10.3 äº‰è®®ä¸åˆ†æ­§](#103-äº‰è®®ä¸åˆ†æ­§)
    - [10.4 åº”ç”¨å‰æ™¯](#104-åº”ç”¨å‰æ™¯)
    - [10.5 æ”¹è¿›å»ºè®®](#105-æ”¹è¿›å»ºè®®)

---

## 1 æ¦‚è¿°

åŸºç¡€æ§åˆ¶ç†è®ºæ˜¯æ§åˆ¶è®ºçš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶å¦‚ä½•é€šè¿‡åé¦ˆæœºåˆ¶æ¥è°ƒèŠ‚ç³»ç»Ÿçš„è¡Œä¸ºï¼Œä½¿å…¶è¾¾åˆ°æœŸæœ›çš„çŠ¶æ€ã€‚è¯¥ç†è®ºä¸ºè‡ªåŠ¨æ§åˆ¶ç³»ç»Ÿè®¾è®¡æä¾›äº†ç†è®ºåŸºç¡€ï¼Œå¹¿æ³›åº”ç”¨äºå·¥ç¨‹ã€ç‰©ç†ã€ç”Ÿç‰©å’Œç¤¾ä¼šç³»ç»Ÿç­‰é¢†åŸŸã€‚

## 2 æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹æ§åˆ¶ç³»ç»Ÿçš„æ•°å­¦åŸºç¡€**
2. **å®šä¹‰åé¦ˆæ§åˆ¶çš„åŸºæœ¬æ¦‚å¿µ**
3. **ç ”ç©¶æ§åˆ¶ç³»ç»Ÿçš„ç¨³å®šæ€§**
4. **æä¾›æ§åˆ¶ç³»ç»Ÿè®¾è®¡æ–¹æ³•**
5. **åˆ†ææ§åˆ¶ç³»ç»Ÿåœ¨å·¥ç¨‹ä¸­çš„åº”ç”¨**

## 3 åŸºæœ¬æ¦‚å¿µ

### 3.1 æ§åˆ¶ç³»ç»ŸåŸºç¡€

**å®šä¹‰ 1.1.1 (æ§åˆ¶ç³»ç»Ÿ)**
æ§åˆ¶ç³»ç»Ÿæ˜¯ç”±æ§åˆ¶å™¨ã€è¢«æ§å¯¹è±¡ã€ä¼ æ„Ÿå™¨å’Œæ‰§è¡Œå™¨ç»„æˆçš„ç³»ç»Ÿï¼Œç”¨äºè°ƒèŠ‚è¢«æ§å¯¹è±¡çš„è¾“å‡ºä»¥è¾¾åˆ°æœŸæœ›çš„ç›®æ ‡ã€‚

**å®šä¹‰ 1.1.2 (å¼€ç¯æ§åˆ¶)**
å¼€ç¯æ§åˆ¶æ˜¯æ§åˆ¶å™¨çš„è¾“å‡ºä¸ä¾èµ–äºç³»ç»Ÿè¾“å‡ºçš„æ§åˆ¶æ–¹å¼ã€‚æ§åˆ¶å™¨çš„è¾“å‡ºä»…åŸºäºå‚è€ƒè¾“å…¥å’Œç³»ç»Ÿæ¨¡å‹ã€‚

**å®šä¹‰ 1.1.3 (é—­ç¯æ§åˆ¶)**
é—­ç¯æ§åˆ¶æ˜¯æ§åˆ¶å™¨çš„è¾“å‡ºä¾èµ–äºç³»ç»Ÿè¾“å‡ºçš„æ§åˆ¶æ–¹å¼ã€‚é€šè¿‡åé¦ˆæœºåˆ¶ï¼Œæ§åˆ¶å™¨èƒ½å¤Ÿæ ¹æ®ç³»ç»Ÿå®é™…è¾“å‡ºä¸æœŸæœ›è¾“å‡ºçš„åå·®æ¥è°ƒèŠ‚æ§åˆ¶ä¿¡å·ã€‚

### 3.2 åé¦ˆæ§åˆ¶

**å®šä¹‰ 1.2.1 (åé¦ˆ)**
åé¦ˆæ˜¯å°†ç³»ç»Ÿè¾“å‡ºçš„ä¸€éƒ¨åˆ†æˆ–å…¨éƒ¨è¿”å›åˆ°ç³»ç»Ÿè¾“å…¥çš„è¿‡ç¨‹ï¼Œç”¨äºè°ƒèŠ‚ç³»ç»Ÿè¡Œä¸ºã€‚

**å®šä¹‰ 1.2.2 (è´Ÿåé¦ˆ)**
è´Ÿåé¦ˆæ˜¯å°†ç³»ç»Ÿè¾“å‡ºä¸å‚è€ƒè¾“å…¥çš„å·®å€¼ä½œä¸ºæ§åˆ¶ä¿¡å·ï¼Œç”¨äºå‡å°ç³»ç»Ÿè¾“å‡ºä¸æœŸæœ›å€¼ä¹‹é—´çš„åå·®ã€‚

**å®šä¹‰ 1.2.3 (æ­£åé¦ˆ)**
æ­£åé¦ˆæ˜¯å°†ç³»ç»Ÿè¾“å‡ºä¸å‚è€ƒè¾“å…¥çš„å’Œä½œä¸ºæ§åˆ¶ä¿¡å·ï¼Œé€šå¸¸ç”¨äºæ”¾å¤§ç³»ç»Ÿå“åº”ã€‚

### 3.3 ç³»ç»Ÿæ¨¡å‹

**å®šä¹‰ 1.3.1 (çŠ¶æ€ç©ºé—´æ¨¡å‹)**
çŠ¶æ€ç©ºé—´æ¨¡å‹æ˜¯æè¿°ç³»ç»ŸåŠ¨æ€è¡Œä¸ºçš„æ•°å­¦æ¨¡å‹ï¼š
$$\dot{x}(t) = f(x(t), u(t), t)$$
$$y(t) = h(x(t), u(t), t)$$

å…¶ä¸­ï¼š

- $x(t)$ æ˜¯çŠ¶æ€å‘é‡
- $u(t)$ æ˜¯è¾“å…¥å‘é‡
- $y(t)$ æ˜¯è¾“å‡ºå‘é‡
- $f$ æ˜¯çŠ¶æ€æ–¹ç¨‹
- $h$ æ˜¯è¾“å‡ºæ–¹ç¨‹

**å®šä¹‰ 1.3.2 (ä¼ é€’å‡½æ•°)**
ä¼ é€’å‡½æ•°æ˜¯æè¿°çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿè¾“å…¥è¾“å‡ºå…³ç³»çš„å¤æ•°å‡½æ•°ï¼š
$$G(s) = \frac{Y(s)}{U(s)} = \frac{b_m s^m + b_{m-1} s^{m-1} + \cdots + b_0}{a_n s^n + a_{n-1} s^{n-1} + \cdots + a_0}$$

## 4 å½¢å¼åŒ–å®šä¹‰

### 4.1 çº¿æ€§ç³»ç»Ÿ

**å®šä¹‰ 2.1.1 (çº¿æ€§ç³»ç»Ÿ)**
çº¿æ€§ç³»ç»Ÿæ˜¯æ»¡è¶³å åŠ åŸç†çš„ç³»ç»Ÿï¼š
$$f(\alpha x_1 + \beta x_2) = \alpha f(x_1) + \beta f(x_2)$$

**å®šä¹‰ 2.1.2 (çº¿æ€§çŠ¶æ€ç©ºé—´æ¨¡å‹)**
çº¿æ€§çŠ¶æ€ç©ºé—´æ¨¡å‹çš„å½¢å¼ä¸ºï¼š
$$\dot{x}(t) = Ax(t) + Bu(t)$$
$$y(t) = Cx(t) + Du(t)$$

å…¶ä¸­ï¼š

- $A$ æ˜¯ç³»ç»ŸçŸ©é˜µ
- $B$ æ˜¯è¾“å…¥çŸ©é˜µ
- $C$ æ˜¯è¾“å‡ºçŸ©é˜µ
- $D$ æ˜¯ç›´æ¥ä¼ é€’çŸ©é˜µ

**å®šä¹‰ 2.1.3 (çº¿æ€§ä¼ é€’å‡½æ•°)**
çº¿æ€§ä¼ é€’å‡½æ•°æ˜¯æ‹‰æ™®æ‹‰æ–¯å˜æ¢åçš„è¾“å…¥è¾“å‡ºå…³ç³»ï¼š
$$G(s) = C(sI - A)^{-1}B + D$$

### 4.2 ç¨³å®šæ€§

**å®šä¹‰ 2.2.1 (æé›…æ™®è¯ºå¤«ç¨³å®šæ€§)**
ç³»ç»Ÿåœ¨å¹³è¡¡ç‚¹ $x_e$ å¤„æ˜¯æé›…æ™®è¯ºå¤«ç¨³å®šçš„ï¼Œå¦‚æœå¯¹äºä»»ä½• $\epsilon > 0$ï¼Œå­˜åœ¨ $\delta > 0$ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰æ»¡è¶³ $\|x(0) - x_e\| < \delta$ çš„åˆå§‹çŠ¶æ€ï¼Œéƒ½æœ‰ $\|x(t) - x_e\| < \epsilon$ å¯¹æ‰€æœ‰ $t \geq 0$ æˆç«‹ã€‚

**å®šä¹‰ 2.2.2 (æ¸è¿‘ç¨³å®šæ€§)**
ç³»ç»Ÿåœ¨å¹³è¡¡ç‚¹ $x_e$ å¤„æ˜¯æ¸è¿‘ç¨³å®šçš„ï¼Œå¦‚æœå®ƒæ˜¯æé›…æ™®è¯ºå¤«ç¨³å®šçš„ï¼Œå¹¶ä¸”å­˜åœ¨ $\delta > 0$ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰æ»¡è¶³ $\|x(0) - x_e\| < \delta$ çš„åˆå§‹çŠ¶æ€ï¼Œéƒ½æœ‰ $\lim_{t \to \infty} x(t) = x_e$ã€‚

**å®šä¹‰ 2.2.3 (æŒ‡æ•°ç¨³å®šæ€§)**
ç³»ç»Ÿåœ¨å¹³è¡¡ç‚¹ $x_e$ å¤„æ˜¯æŒ‡æ•°ç¨³å®šçš„ï¼Œå¦‚æœå­˜åœ¨å¸¸æ•° $M > 0$ å’Œ $\alpha > 0$ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰æ»¡è¶³ $\|x(0) - x_e\| < \delta$ çš„åˆå§‹çŠ¶æ€ï¼Œéƒ½æœ‰ $\|x(t) - x_e\| \leq M \|x(0) - x_e\| e^{-\alpha t}$ã€‚

### 4.3 å¯æ§æ€§å’Œå¯è§‚æ€§

**å®šä¹‰ 2.3.1 (å¯æ§æ€§)**
ç³»ç»Ÿæ˜¯å¯æ§çš„ï¼Œå¦‚æœå¯¹äºä»»ä½•åˆå§‹çŠ¶æ€ $x_0$ å’Œç›®æ ‡çŠ¶æ€ $x_f$ï¼Œå­˜åœ¨æœ‰é™æ—¶é—´ $T$ å’Œæ§åˆ¶è¾“å…¥ $u(t)$ï¼Œä½¿å¾— $x(T) = x_f$ã€‚

**å®šä¹‰ 2.3.2 (å¯è§‚æ€§)**
ç³»ç»Ÿæ˜¯å¯è§‚çš„ï¼Œå¦‚æœå¯¹äºä»»ä½•åˆå§‹çŠ¶æ€ $x_0$ï¼Œå­˜åœ¨æœ‰é™æ—¶é—´ $T$ï¼Œä½¿å¾—é€šè¿‡è¾“å‡º $y(t)$ åœ¨ $[0, T]$ ä¸Šçš„è§‚æµ‹å¯ä»¥å”¯ä¸€ç¡®å®š $x_0$ã€‚

**å®šä¹‰ 2.3.3 (å¯æ§æ€§çŸ©é˜µ)**
å¯æ§æ€§çŸ©é˜µå®šä¹‰ä¸ºï¼š
$$\mathcal{C} = [B \quad AB \quad A^2B \quad \cdots \quad A^{n-1}B]$$

**å®šä¹‰ 2.3.4 (å¯è§‚æ€§çŸ©é˜µ)**
å¯è§‚æ€§çŸ©é˜µå®šä¹‰ä¸ºï¼š
$$\mathcal{O} = \begin{bmatrix} C \\ CA \\ CA^2 \\ \vdots \\ CA^{n-1} \end{bmatrix}$$

## 5 å®šç†ä¸è¯æ˜

### 5.1 ç¨³å®šæ€§å®šç†

**å®šç† 3.1.1 (çº¿æ€§ç³»ç»Ÿç¨³å®šæ€§)**
çº¿æ€§ç³»ç»Ÿ $\dot{x} = Ax$ æ˜¯æ¸è¿‘ç¨³å®šçš„ï¼Œå½“ä¸”ä»…å½“ $A$ çš„æ‰€æœ‰ç‰¹å¾å€¼éƒ½å…·æœ‰è´Ÿå®éƒ¨ã€‚

**è¯æ˜**ï¼š

1. **å……åˆ†æ€§**ï¼šå¦‚æœ $A$ çš„æ‰€æœ‰ç‰¹å¾å€¼éƒ½å…·æœ‰è´Ÿå®éƒ¨ï¼Œåˆ™ç³»ç»Ÿçš„è§£ä¸º $x(t) = e^{At}x(0)$ï¼Œå…¶ä¸­ $e^{At}$ çš„æ‰€æœ‰å…ƒç´ éƒ½è¶‹äºé›¶ï¼Œå› æ­¤ç³»ç»Ÿæ˜¯æ¸è¿‘ç¨³å®šçš„ã€‚

2. **å¿…è¦æ€§**ï¼šå¦‚æœç³»ç»Ÿæ˜¯æ¸è¿‘ç¨³å®šçš„ï¼Œåˆ™å¯¹äºä»»ä½•åˆå§‹çŠ¶æ€ $x(0)$ï¼Œéƒ½æœ‰ $\lim_{t \to \infty} x(t) = 0$ã€‚è¿™æ„å‘³ç€ $e^{At}$ çš„æ‰€æœ‰å…ƒç´ éƒ½è¶‹äºé›¶ï¼Œå› æ­¤ $A$ çš„æ‰€æœ‰ç‰¹å¾å€¼éƒ½å¿…é¡»å…·æœ‰è´Ÿå®éƒ¨ã€‚$\square$

**å®šç† 3.1.2 (æé›…æ™®è¯ºå¤«ç¨³å®šæ€§å®šç†)**
å¦‚æœå­˜åœ¨æ­£å®šå‡½æ•° $V(x)$ ä½¿å¾— $\dot{V}(x) < 0$ å¯¹æ‰€æœ‰ $x \neq 0$ æˆç«‹ï¼Œåˆ™ç³»ç»Ÿåœ¨åŸç‚¹å¤„æ˜¯æ¸è¿‘ç¨³å®šçš„ã€‚

**è¯æ˜**ï¼š

1. $V(x) > 0$ å¯¹æ‰€æœ‰ $x \neq 0$ æˆç«‹ï¼Œå› æ­¤ $V(x)$ æ˜¯æ­£å®šçš„ã€‚
2. $\dot{V}(x) < 0$ å¯¹æ‰€æœ‰ $x \neq 0$ æˆç«‹ï¼Œå› æ­¤ $V(x)$ æ˜¯é€’å‡çš„ã€‚
3. ç”±äº $V(x)$ æœ‰ä¸‹ç•Œï¼ˆ$V(x) \geq 0$ï¼‰ä¸”é€’å‡ï¼Œå› æ­¤ $\lim_{t \to \infty} V(x(t)) = 0$ã€‚
4. ç”±äº $V(x)$ æ˜¯æ­£å®šçš„ï¼Œå› æ­¤ $\lim_{t \to \infty} x(t) = 0$ã€‚

å› æ­¤ï¼Œç³»ç»Ÿåœ¨åŸç‚¹å¤„æ˜¯æ¸è¿‘ç¨³å®šçš„ã€‚$\square$

### 5.2 å¯æ§æ€§å’Œå¯è§‚æ€§å®šç†

**å®šç† 3.2.1 (å¯æ§æ€§åˆ¤æ®)**
çº¿æ€§ç³»ç»Ÿæ˜¯å¯æ§çš„ï¼Œå½“ä¸”ä»…å½“å¯æ§æ€§çŸ©é˜µ $\mathcal{C}$ çš„ç§©ç­‰äº $n$ã€‚

**è¯æ˜**ï¼š

1. **å……åˆ†æ€§**ï¼šå¦‚æœ $\text{rank}(\mathcal{C}) = n$ï¼Œåˆ™å¯¹äºä»»ä½•åˆå§‹çŠ¶æ€ $x_0$ å’Œç›®æ ‡çŠ¶æ€ $x_f$ï¼Œå­˜åœ¨æ§åˆ¶è¾“å…¥ä½¿å¾—ç³»ç»Ÿä» $x_0$ è½¬ç§»åˆ° $x_f$ã€‚

2. **å¿…è¦æ€§**ï¼šå¦‚æœç³»ç»Ÿæ˜¯å¯æ§çš„ï¼Œåˆ™å¯¹äºä»»ä½•çŠ¶æ€è½¬ç§»ï¼Œéƒ½å­˜åœ¨ç›¸åº”çš„æ§åˆ¶è¾“å…¥ã€‚è¿™æ„å‘³ç€å¯æ§æ€§çŸ©é˜µå¿…é¡»æ»¡ç§©ã€‚$\square$

**å®šç† 3.2.2 (å¯è§‚æ€§åˆ¤æ®)**
çº¿æ€§ç³»ç»Ÿæ˜¯å¯è§‚çš„ï¼Œå½“ä¸”ä»…å½“å¯è§‚æ€§çŸ©é˜µ $\mathcal{O}$ çš„ç§©ç­‰äº $n$ã€‚

**è¯æ˜**ï¼š

1. **å……åˆ†æ€§**ï¼šå¦‚æœ $\text{rank}(\mathcal{O}) = n$ï¼Œåˆ™é€šè¿‡è¾“å‡ºè§‚æµ‹å¯ä»¥å”¯ä¸€ç¡®å®šåˆå§‹çŠ¶æ€ã€‚

2. **å¿…è¦æ€§**ï¼šå¦‚æœç³»ç»Ÿæ˜¯å¯è§‚çš„ï¼Œåˆ™åˆå§‹çŠ¶æ€å¯ä»¥é€šè¿‡è¾“å‡ºå”¯ä¸€ç¡®å®šï¼Œè¿™æ„å‘³ç€å¯è§‚æ€§çŸ©é˜µå¿…é¡»æ»¡ç§©ã€‚$\square$

### 5.3 åé¦ˆæ§åˆ¶å®šç†

**å®šç† 3.3.1 (æç‚¹é…ç½®å®šç†)**
å¦‚æœç³»ç»Ÿ $(A, B)$ æ˜¯å¯æ§çš„ï¼Œåˆ™é€šè¿‡çŠ¶æ€åé¦ˆ $u = -Kx$ å¯ä»¥å°†é—­ç¯ç³»ç»Ÿçš„æç‚¹é…ç½®åˆ°ä»»æ„ä½ç½®ã€‚

**è¯æ˜**ï¼š

1. ç”±äºç³»ç»Ÿæ˜¯å¯æ§çš„ï¼Œå­˜åœ¨ç›¸ä¼¼å˜æ¢å°†ç³»ç»Ÿè½¬æ¢ä¸ºå¯æ§æ ‡å‡†å½¢ã€‚
2. åœ¨å¯æ§æ ‡å‡†å½¢ä¸‹ï¼Œå¯ä»¥é€šè¿‡é€‰æ‹©åé¦ˆå¢ç›Š $K$ æ¥ä»»æ„é…ç½®é—­ç¯ç³»ç»Ÿçš„ç‰¹å¾å¤šé¡¹å¼ã€‚
3. å› æ­¤ï¼Œé—­ç¯ç³»ç»Ÿçš„æç‚¹å¯ä»¥é…ç½®åˆ°ä»»æ„ä½ç½®ã€‚$\square$

**å®šç† 3.3.2 (åˆ†ç¦»å®šç†)**
å¯¹äºçº¿æ€§ç³»ç»Ÿï¼ŒçŠ¶æ€åé¦ˆå’ŒçŠ¶æ€è§‚æµ‹å™¨çš„è®¾è®¡å¯ä»¥ç‹¬ç«‹è¿›è¡Œã€‚

**è¯æ˜**ï¼š

1. çŠ¶æ€åé¦ˆçš„è®¾è®¡åŸºäºå¯æ§æ€§ï¼ŒçŠ¶æ€è§‚æµ‹å™¨çš„è®¾è®¡åŸºäºå¯è§‚æ€§ã€‚
2. å¯æ§æ€§å’Œå¯è§‚æ€§æ˜¯ç‹¬ç«‹çš„æ€§è´¨ã€‚
3. å› æ­¤ï¼ŒçŠ¶æ€åé¦ˆå’ŒçŠ¶æ€è§‚æµ‹å™¨çš„è®¾è®¡å¯ä»¥ç‹¬ç«‹è¿›è¡Œã€‚$\square$

## 6 ç¨³å®šæ€§åˆ†æ

### 6.1 åŠ³æ–¯-èµ«å°”ç»´èŒ¨åˆ¤æ®

**å®šç† 4.1.1** (åŠ³æ–¯-èµ«å°”ç»´èŒ¨åˆ¤æ®)
å¤šé¡¹å¼ $P(s) = a_n s^n + a_{n-1} s^{n-1} + \cdots + a_0$ çš„æ‰€æœ‰æ ¹éƒ½æœ‰è´Ÿå®éƒ¨å½“ä¸”ä»…å½“ï¼š

1. æ‰€æœ‰ç³»æ•° $a_i > 0$
2. åŠ³æ–¯è¡¨çš„ç¬¬ä¸€åˆ—æ‰€æœ‰å…ƒç´ éƒ½ä¸ºæ­£

### 6.2 å¥ˆå¥æ–¯ç‰¹åˆ¤æ®

**å®šç† 4.1.2** (å¥ˆå¥æ–¯ç‰¹åˆ¤æ®)
é—­ç¯ç³»ç»Ÿç¨³å®šçš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯å¥ˆå¥æ–¯ç‰¹å›¾ç»•ç‚¹ $(-1, 0)$ çš„åœˆæ•°ç­‰äºå¼€ç¯ç³»ç»Ÿåœ¨å³åŠå¹³é¢çš„æç‚¹æ•°ã€‚

### 6.3 æ ¹è½¨è¿¹åˆ†æ

**å®šä¹‰ 4.1.1** (æ ¹è½¨è¿¹)
æ ¹è½¨è¿¹æ˜¯ç³»ç»Ÿç‰¹å¾æ–¹ç¨‹éšå¢ç›Šå˜åŒ–çš„æ ¹çš„è½¨è¿¹ã€‚

**æ€§è´¨**ï¼š

1. æ ¹è½¨è¿¹å§‹äºå¼€ç¯æç‚¹ï¼Œç»ˆäºå¼€ç¯é›¶ç‚¹æˆ–æ— ç©·è¿œ
2. æ ¹è½¨è¿¹å…³äºå®è½´å¯¹ç§°
3. æ ¹è½¨è¿¹çš„åˆ†æ”¯æ•°ç­‰äºç³»ç»Ÿé˜¶æ•°

## 7 ä»£ç å®ç°

### 7.1 Rust å®ç°

```rust
use nalgebra::{DMatrix, DVector, Matrix, Vector};
use std::f64::consts::PI;

/// çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿ
#[derive(Debug, Clone)]
pub struct LinearSystem {
    pub a: DMatrix<f64>,
    pub b: DMatrix<f64>,
    pub c: DMatrix<f64>,
    pub d: DMatrix<f64>,
}

impl LinearSystem {
    pub fn new(a: DMatrix<f64>, b: DMatrix<f64>, c: DMatrix<f64>, d: DMatrix<f64>) -> Self {
        Self { a, b, c, d }
    }

    pub fn order(&self) -> usize {
        self.a.nrows()
    }

    pub fn num_inputs(&self) -> usize {
        self.b.ncols()
    }

    pub fn num_outputs(&self) -> usize {
        self.c.nrows()
    }

    /// æ£€æŸ¥ç³»ç»Ÿç¨³å®šæ€§
    pub fn is_stable(&self) -> bool {
        let eigenvals = self.a.eigenvalues();
        eigenvals.iter().all(|&lambda| lambda.re < 0.0)
    }

    /// æ£€æŸ¥å¯æ§æ€§
    pub fn is_controllable(&self) -> bool {
        let n = self.order();
        let mut controllability_matrix = DMatrix::zeros(n, n * self.num_inputs());

        for i in 0..n {
            let power = self.a.pow(i as u32);
            let column = &power * &self.b;
            controllability_matrix.set_column(i * self.num_inputs(), &column);
        }

        controllability_matrix.rank() == n
    }

    /// æ£€æŸ¥å¯è§‚æ€§
    pub fn is_observable(&self) -> bool {
        let n = self.order();
        let mut observability_matrix = DMatrix::zeros(n * self.num_outputs(), n);

        for i in 0..n {
            let power = self.a.pow(i as u32);
            let row = &self.c * &power;
            observability_matrix.set_row(i * self.num_outputs(), &row);
        }

        observability_matrix.rank() == n
    }

    /// è®¡ç®—ä¼ é€’å‡½æ•°ï¼ˆç®€åŒ–å®ç°ï¼‰
    pub fn transfer_function(&self, s: f64) -> DMatrix<f64> {
        let n = self.order();
        let s_matrix = DMatrix::identity(n, n) * s;
        let denominator = s_matrix - &self.a;

        if let Some(inv) = denominator.try_inverse() {
            &self.c * &inv * &self.b + &self.d
        } else {
            DMatrix::zeros(self.num_outputs(), self.num_inputs())
        }
    }
}

/// PIDæ§åˆ¶å™¨
#[derive(Debug, Clone)]
pub struct PIDController {
    pub kp: f64,
    pub ki: f64,
    pub kd: f64,
    pub integral: f64,
    pub previous_error: f64,
    pub dt: f64,
}

impl PIDController {
    pub fn new(kp: f64, ki: f64, kd: f64, dt: f64) -> Self {
        Self {
            kp,
            ki,
            kd,
            integral: 0.0,
            previous_error: 0.0,
            dt,
        }
    }

    pub fn control(&mut self, error: f64) -> f64 {
        // ç§¯åˆ†é¡¹
        self.integral += error * self.dt;

        // å¾®åˆ†é¡¹
        let derivative = (error - self.previous_error) / self.dt;

        // PIDè¾“å‡º
        let output = self.kp * error + self.ki * self.integral + self.kd * derivative;

        self.previous_error = error;
        output
    }

    pub fn reset(&mut self) {
        self.integral = 0.0;
        self.previous_error = 0.0;
    }
}

/// é—­ç¯ç³»ç»Ÿ
pub struct ClosedLoopSystem {
    pub plant: LinearSystem,
    pub controller: PIDController,
}

impl ClosedLoopSystem {
    pub fn new(plant: LinearSystem, controller: PIDController) -> Self {
        Self { plant, controller }
    }

    pub fn simulate(&mut self, reference: f64, duration: f64, dt: f64) -> Vec<(f64, f64, f64)> {
        let mut results = Vec::new();
        let mut time = 0.0;
        let mut state = DVector::zeros(self.plant.order());
        let mut output = 0.0;

        self.controller.reset();

        while time <= duration {
            // è®¡ç®—è¯¯å·®
            let error = reference - output;

            // æ§åˆ¶å™¨è¾“å‡º
            let control_input = self.controller.control(error);

            // ç³»ç»Ÿå“åº”ï¼ˆç®€åŒ–å®ç°ï¼‰
            let input_vector = DVector::from_vec(vec![control_input]);
            let state_derivative = &self.plant.a * &state + &self.plant.b * &input_vector;
            state += state_derivative * dt;

            // ç³»ç»Ÿè¾“å‡º
            let output_vector = &self.plant.c * &state + &self.plant.d * &input_vector;
            output = output_vector[0];

            results.push((time, output, control_input));
            time += dt;
        }

        results
    }
}

/// ç¨³å®šæ€§åˆ†æå™¨
pub struct StabilityAnalyzer;

impl StabilityAnalyzer {
    /// åŠ³æ–¯-èµ«å°”ç»´èŒ¨åˆ¤æ®
    pub fn routh_hurwitz_criterion(coefficients: &[f64]) -> bool {
        if coefficients.is_empty() {
            return false;
        }

        // æ£€æŸ¥æ‰€æœ‰ç³»æ•°æ˜¯å¦ä¸ºæ­£
        if !coefficients.iter().all(|&c| c > 0.0) {
            return false;
        }

        let n = coefficients.len() - 1;
        let mut routh_table = vec![vec![0.0; n + 1]; n + 1];

        // å¡«å……å‰ä¸¤è¡Œ
        for i in 0..=n {
            routh_table[0][i] = if i < coefficients.len() { coefficients[i] } else { 0.0 };
        }

        for i in 0..n {
            routh_table[1][i] = if i + 1 < coefficients.len() { coefficients[i + 1] } else { 0.0 };
        }

        // è®¡ç®—å…¶ä½™è¡Œ
        for i in 2..=n {
            for j in 0..n {
                if routh_table[i-1][0] != 0.0 {
                    routh_table[i][j] = (routh_table[i-2][0] * routh_table[i-1][j+1]
                                        - routh_table[i-2][j+1] * routh_table[i-1][0])
                                        / routh_table[i-1][0];
                } else {
                    return false; // é›¶å…ƒç´ ï¼Œç³»ç»Ÿä¸ç¨³å®š
                }
            }
        }

        // æ£€æŸ¥ç¬¬ä¸€åˆ—ç¬¦å·
        routh_table.iter().all(|row| row[0] > 0.0)
    }

    /// è®¡ç®—ç‰¹å¾å€¼
    pub fn eigenvalues(matrix: &DMatrix<f64>) -> Vec<num_complex::Complex<f64>> {
        matrix.eigenvalues().iter().map(|&lambda| lambda).collect()
    }

    /// å¥ˆå¥æ–¯ç‰¹åˆ¤æ®ï¼ˆç®€åŒ–å®ç°ï¼‰
    pub fn nyquist_criterion(open_loop_tf: &dyn Fn(f64) -> num_complex::Complex<f64>,
                           right_half_poles: usize) -> bool {
        let mut encirclements = 0;
        let step = 2.0 * PI / 1000.0;

        for i in 0..1000 {
            let omega = i as f64 * step;
            let s = num_complex::Complex::new(0.0, omega);
            let g_s = open_loop_tf(omega);

            // æ£€æŸ¥æ˜¯å¦ç»• (-1, 0) ç‚¹
            if g_s.re < -1.0 && g_s.im.abs() < 0.1 {
                encirclements += 1;
            }
        }

        encirclements == right_half_poles
    }
}

/// æ ¹è½¨è¿¹åˆ†æå™¨
pub struct RootLocusAnalyzer;

impl RootLocusAnalyzer {
    /// è®¡ç®—æ ¹è½¨è¿¹ç‚¹
    pub fn calculate_root_locus(open_loop_poles: &[num_complex::Complex<f64>],
                               open_loop_zeros: &[num_complex::Complex<f64>],
                               gains: &[f64]) -> Vec<Vec<num_complex::Complex<f64>>> {
        let mut root_locus = Vec::new();

        for &gain in gains {
            let mut roots = Vec::new();

            // ç®€åŒ–å®ç°ï¼šä½¿ç”¨æ•°å€¼æ–¹æ³•æ±‚è§£ç‰¹å¾æ–¹ç¨‹
            for &pole in open_loop_poles {
                let root = pole + gain * num_complex::Complex::new(0.1, 0.1);
                roots.push(root);
            }

            root_locus.push(roots);
        }

        root_locus
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use nalgebra::DMatrix;

    #[test]
    fn test_linear_system() {
        let a = DMatrix::from_row_slice(2, 2, &[-1.0, 0.0, 0.0, -2.0]);
        let b = DMatrix::from_row_slice(2, 1, &[1.0, 1.0]);
        let c = DMatrix::from_row_slice(1, 2, &[1.0, 0.0]);
        let d = DMatrix::from_row_slice(1, 1, &[0.0]);

        let system = LinearSystem::new(a, b, c, d);

        assert!(system.is_stable());
        assert!(system.is_controllable());
        assert!(system.is_observable());
    }

    #[test]
    fn test_pid_controller() {
        let mut controller = PIDController::new(1.0, 0.1, 0.01, 0.01);

        let error = 1.0;
        let output = controller.control(error);

        assert!(output > 0.0);
    }

    #[test]
    fn test_routh_hurwitz() {
        let coefficients = vec![1.0, 3.0, 3.0, 1.0]; // (s+1)^3
        assert!(StabilityAnalyzer::routh_hurwitz_criterion(&coefficients));

        let unstable_coeffs = vec![1.0, -1.0, 1.0]; // ä¸ç¨³å®šç³»ç»Ÿ
        assert!(!StabilityAnalyzer::routh_hurwitz_criterion(&unstable_coeffs));
    }

    #[test]
    fn test_closed_loop_simulation() {
        let a = DMatrix::from_row_slice(2, 2, &[-1.0, 0.0, 0.0, -2.0]);
        let b = DMatrix::from_row_slice(2, 1, &[1.0, 1.0]);
        let c = DMatrix::from_row_slice(1, 2, &[1.0, 0.0]);
        let d = DMatrix::from_row_slice(1, 1, &[0.0]);

        let plant = LinearSystem::new(a, b, c, d);
        let controller = PIDController::new(1.0, 0.1, 0.01, 0.01);
        let mut system = ClosedLoopSystem::new(plant, controller);

        let results = system.simulate(1.0, 1.0, 0.01);
        assert!(!results.is_empty());
    }
}
```

### 7.2 Haskell å®ç°

```haskell
module BasicControlTheory where

import Data.Complex
import Data.Matrix
import Data.Vector
import qualified Data.Vector as V

-- çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿ
data LinearSystem = LinearSystem {
    a :: Matrix Double
    , b :: Matrix Double
    , c :: Matrix Double
    , d :: Matrix Double
} deriving (Show)

-- åˆ›å»ºçº¿æ€§ç³»ç»Ÿ
createLinearSystem :: Matrix Double -> Matrix Double -> Matrix Double -> Matrix Double -> LinearSystem
createLinearSystem = LinearSystem

-- ç³»ç»Ÿé˜¶æ•°
systemOrder :: LinearSystem -> Int
systemOrder = nrows . a

-- è¾“å…¥æ•°é‡
numInputs :: LinearSystem -> Int
numInputs = ncols . b

-- è¾“å‡ºæ•°é‡
numOutputs :: LinearSystem -> Int
numOutputs = nrows . c

-- ç‰¹å¾å€¼è®¡ç®—
eigenvalues :: Matrix Double -> [Complex Double]
eigenvalues matrix =
    let n = nrows matrix
        charPoly = characteristicPolynomial matrix
        roots = findRoots charPoly
    in roots

-- ç‰¹å¾å¤šé¡¹å¼ï¼ˆç®€åŒ–å®ç°ï¼‰
characteristicPolynomial :: Matrix Double -> [Double]
characteristicPolynomial matrix =
    let n = nrows matrix
        det = determinant (identity n - matrix)
    in [det] -- ç®€åŒ–å®ç°

-- æ±‚æ ¹ï¼ˆç®€åŒ–å®ç°ï¼‰
findRoots :: [Double] -> [Complex Double]
findRoots coeffs =
    case coeffs of
        [a, b, c] -> quadraticRoots a b c
        [a, b] -> [Complex (-b/a) 0]
        [a] -> [Complex 0 0]
        _ -> []

-- äºŒæ¬¡æ–¹ç¨‹æ±‚æ ¹
quadraticRoots :: Double -> Double -> Double -> [Complex Double]
quadraticRoots a b c =
    let discriminant = b*b - 4*a*c
    in if discriminant >= 0
       then [Complex ((-b + sqrt discriminant)/(2*a)) 0,
             Complex ((-b - sqrt discriminant)/(2*a)) 0]
       else [Complex (-b/(2*a)) (sqrt (-discriminant)/(2*a)),
             Complex (-b/(2*a)) (-sqrt (-discriminant)/(2*a))]

-- æ£€æŸ¥ç³»ç»Ÿç¨³å®šæ€§
isStable :: LinearSystem -> Bool
isStable system =
    let eigenvals = eigenvalues (a system)
    in all (\lambda -> realPart lambda < 0) eigenvals

-- å¯æ§æ€§çŸ©é˜µ
controllabilityMatrix :: LinearSystem -> Matrix Double
controllabilityMatrix system =
    let n = systemOrder system
        m = numInputs system
        matrices = [b system] ++ [a system `multStd` b system | _ <- [1..n-1]]
    in foldr1 (|||) matrices

-- æ£€æŸ¥å¯æ§æ€§
isControllable :: LinearSystem -> Bool
isControllable system =
    let controllability = controllabilityMatrix system
        rank = matrixRank controllability
    in rank == systemOrder system

-- å¯è§‚æ€§çŸ©é˜µ
observabilityMatrix :: LinearSystem -> Matrix Double
observabilityMatrix system =
    let n = systemOrder system
        matrices = [c system] ++ [c system `multStd` a system | _ <- [1..n-1]]
    in foldr1 (===) matrices

-- æ£€æŸ¥å¯è§‚æ€§
isObservable :: LinearSystem -> Bool
isObservable system =
    let observability = observabilityMatrix system
        rank = matrixRank observability
    in rank == systemOrder system

-- PIDæ§åˆ¶å™¨
data PIDController = PIDController {
    kp :: Double
    , ki :: Double
    , kd :: Double
    , integral :: Double
    , previousError :: Double
    , dt :: Double
} deriving (Show)

-- åˆ›å»ºPIDæ§åˆ¶å™¨
createPIDController :: Double -> Double -> Double -> Double -> PIDController
createPIDController kp' ki' kd' dt' = PIDController kp' ki' kd' 0.0 0.0 dt'

-- PIDæ§åˆ¶
pidControl :: PIDController -> Double -> (Double, PIDController)
pidControl controller error =
    let newIntegral = integral controller + error * dt controller
        derivative = (error - previousError controller) / dt controller
        output = kp controller * error + ki controller * newIntegral + kd controller * derivative
        newController = controller {
            integral = newIntegral,
            previousError = error
        }
    in (output, newController)

-- é‡ç½®PIDæ§åˆ¶å™¨
resetPID :: PIDController -> PIDController
resetPID controller = controller {
    integral = 0.0,
    previousError = 0.0
}

-- é—­ç¯ç³»ç»Ÿ
data ClosedLoopSystem = ClosedLoopSystem {
    plant :: LinearSystem
    , controller :: PIDController
} deriving (Show)

-- åˆ›å»ºé—­ç¯ç³»ç»Ÿ
createClosedLoopSystem :: LinearSystem -> PIDController -> ClosedLoopSystem
createClosedLoopSystem = ClosedLoopSystem

-- ç³»ç»Ÿä»¿çœŸ
simulateSystem :: ClosedLoopSystem -> Double -> Double -> Double -> [(Double, Double, Double)]
simulateSystem system reference duration dt =
    simulateStep system reference 0.0 (V.replicate (systemOrder (plant system)) 0.0) dt
  where
    simulateStep sys ref time state dt' =
        if time > duration
        then []
        else let output = calculateOutput (plant sys) state
                 error = ref - output
                 (control, newController) = pidControl (controller sys) error
                 newState = updateState (plant sys) state control dt'
                 newSys = sys { controller = newController }
             in (time, output, control) : simulateStep newSys ref (time + dt') newState dt'

-- è®¡ç®—è¾“å‡ºï¼ˆç®€åŒ–å®ç°ï¼‰
calculateOutput :: LinearSystem -> Vector Double -> Double
calculateOutput system state =
    let outputVector = c system `multStd` (colVector state)
    in outputVector ! (1, 1)

-- æ›´æ–°çŠ¶æ€ï¼ˆç®€åŒ–å®ç°ï¼‰
updateState :: LinearSystem -> Vector Double -> Double -> Double -> Vector Double
updateState system state input dt' =
    let inputVector = colVector (V.replicate (numInputs system) input)
        stateMatrix = colVector state
        derivative = a system `multStd` stateMatrix + b system `multStd` inputVector
        newState = stateMatrix + scaleMatrix dt' derivative
    in getCol 1 newState

-- ç¨³å®šæ€§åˆ†æå™¨
data StabilityAnalyzer = StabilityAnalyzer

-- åŠ³æ–¯-èµ«å°”ç»´èŒ¨åˆ¤æ®
routhHurwitzCriterion :: [Double] -> Bool
routhHurwitzCriterion coeffs =
    if null coeffs || any (<= 0) coeffs
    then False
    else let n = length coeffs - 1
             routhTable = buildRouthTable coeffs n
         in all (> 0) (map head routhTable)

-- æ„å»ºåŠ³æ–¯è¡¨
buildRouthTable :: [Double] -> Int -> [[Double]]
buildRouthTable coeffs n =
    let firstRow = coeffs ++ replicate (n - length coeffs + 1) 0.0
        secondRow = drop 1 coeffs ++ replicate (n - length coeffs) 0.0
        initialTable = [firstRow, secondRow]
    in foldr buildRow initialTable [2..n]
  where
    buildRow i table =
        let prevRow = table !! (i - 1)
            prevPrevRow = table !! (i - 2)
            newRow = [calculateRouthElement prevPrevRow prevRow j | j <- [0..n]]
        in table ++ [newRow]

    calculateRouthElement row1 row2 j =
        if j + 1 < length row2 && row2 !! 0 /= 0
        then (row1 !! 0 * row2 !! (j + 1) - row1 !! (j + 1) * row2 !! 0) / row2 !! 0
        else 0.0

-- å¥ˆå¥æ–¯ç‰¹åˆ¤æ®ï¼ˆç®€åŒ–å®ç°ï¼‰
nyquistCriterion :: (Double -> Complex Double) -> Int -> Bool
nyquistCriterion openLoopTF rightHalfPoles =
    let encirclements = countEncirclements openLoopTF
    in encirclements == rightHalfPoles

-- è®¡ç®—ç»•åœˆæ•°ï¼ˆç®€åŒ–å®ç°ï¼‰
countEncirclements :: (Double -> Complex Double) -> Int
countEncirclements tf =
    let frequencies = [0.01, 0.1..100.0]
        points = map tf frequencies
        crossings = filter (\z -> realPart z < -1.0 && abs (imagPart z) < 0.1) points
    in length crossings

-- æ ¹è½¨è¿¹åˆ†æ
data RootLocusAnalyzer = RootLocusAnalyzer

-- è®¡ç®—æ ¹è½¨è¿¹
calculateRootLocus :: [Complex Double] -> [Complex Double] -> [Double] -> [[Complex Double]]
calculateRootLocus poles zeros gains =
    map (\gain -> map (\pole -> pole + scale (gain * 0.1) (1.0 :+ 0.1)) poles) gains

-- ç¤ºä¾‹ç³»ç»Ÿ
exampleSystem :: LinearSystem
exampleSystem = createLinearSystem
    (fromList 2 2 [-1.0, 0.0, 0.0, -2.0])
    (fromList 2 1 [1.0, 1.0])
    (fromList 1 2 [1.0, 0.0])
    (fromList 1 1 [0.0])

-- ç¤ºä¾‹æ§åˆ¶å™¨
exampleController :: PIDController
exampleController = createPIDController 1.0 0.1 0.01 0.01

-- ç¤ºä¾‹é—­ç¯ç³»ç»Ÿ
exampleClosedLoop :: ClosedLoopSystem
exampleClosedLoop = createClosedLoopSystem exampleSystem exampleController

-- æµ‹è¯•å‡½æ•°
testSystemStability :: Bool
testSystemStability = isStable exampleSystem

testSystemControllability :: Bool
testSystemControllability = isControllable exampleSystem

testSystemObservability :: Bool
testSystemObservability = isObservable exampleSystem

testRouthHurwitz :: Bool
testRouthHurwitz = routhHurwitzCriterion [1.0, 3.0, 3.0, 1.0]

-- ä»¿çœŸç¤ºä¾‹
simulationExample :: [(Double, Double, Double)]
simulationExample = simulateSystem exampleClosedLoop 1.0 1.0 0.01
```

## 8 åº”ç”¨ç¤ºä¾‹

### 8.1 ä¸€é˜¶ç³»ç»Ÿæ§åˆ¶

**ç¤ºä¾‹ 6.1.1** (ä¸€é˜¶ç³»ç»Ÿ)
$$\dot{x} = -ax + bu$$
$$y = x$$

è¿™ä¸ªç³»ç»Ÿå¯ä»¥ç”¨PIDæ§åˆ¶å™¨è¿›è¡Œæ§åˆ¶ï¼Œå®ç°è¾“å‡ºè·Ÿè¸ªã€‚

### 8.2 äºŒé˜¶ç³»ç»Ÿæ§åˆ¶

**ç¤ºä¾‹ 6.1.2** (äºŒé˜¶ç³»ç»Ÿ)
$$\ddot{x} + 2\zeta\omega_n\dot{x} + \omega_n^2x = \omega_n^2u$$

è¿™ä¸ªç³»ç»Ÿä»£è¡¨å¼¹ç°§-è´¨é‡-é˜»å°¼å™¨ç³»ç»Ÿï¼Œå¯ä»¥ç”¨PIDæ§åˆ¶å™¨è°ƒèŠ‚é˜»å°¼æ¯”å’Œè‡ªç„¶é¢‘ç‡ã€‚

### 8.3 å€’ç«‹æ‘†æ§åˆ¶

**ç¤ºä¾‹ 6.1.3** (å€’ç«‹æ‘†)
å€’ç«‹æ‘†æ˜¯ä¸€ä¸ªéçº¿æ€§ç³»ç»Ÿï¼Œå¯ä»¥é€šè¿‡çº¿æ€§åŒ–åä½¿ç”¨PIDæ§åˆ¶å™¨è¿›è¡Œç¨³å®šæ§åˆ¶ã€‚

## 9 ç›¸å…³ç†è®º

### 9.1 ä¸ç°ä»£æ§åˆ¶ç†è®ºçš„å…³ç³»

åŸºç¡€æ§åˆ¶ç†è®ºæ˜¯ç°ä»£æ§åˆ¶ç†è®ºçš„åŸºç¡€ï¼Œä¸ºçŠ¶æ€ç©ºé—´æ–¹æ³•æä¾›æ¦‚å¿µæ¡†æ¶ã€‚

### 9.2 ä¸ç³»ç»Ÿç†è®ºçš„å…³ç³»

æ§åˆ¶ç†è®ºæ˜¯ç³»ç»Ÿç†è®ºçš„é‡è¦åˆ†æ”¯ï¼Œç ”ç©¶ç³»ç»Ÿçš„åŠ¨æ€è¡Œä¸ºå’Œæ§åˆ¶ã€‚

### 9.3 ä¸ä¿¡å·å¤„ç†çš„å…³ç³»

æ§åˆ¶ç†è®ºä¸­çš„é¢‘ç‡åŸŸåˆ†æä¸ä¿¡å·å¤„ç†å¯†åˆ‡ç›¸å…³ã€‚

## 8. å‚è€ƒæ–‡çŒ®

1. Ogata, K. (2010). _Modern Control Engineering_. Prentice Hall.
2. Franklin, G. F., Powell, J. D., & Emami-Naeini, A. (2015). _Feedback Control of Dynamic Systems_. Pearson.
3. Dorf, R. C., & Bishop, R. H. (2016). _Modern Control Systems_. Pearson.
4. Kuo, B. C., & Golnaraghi, F. (2017). _Automatic Control Systems_. Wiley.
5. Nise, N. S. (2019). _Control Systems Engineering_. Wiley.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [05.1.2 ç°ä»£æ§åˆ¶ç†è®º](../05_Control_Theory/05.1.2_ç°ä»£æ§åˆ¶ç†è®º.md)
- [05.1.3 éçº¿æ€§æ§åˆ¶ç†è®º](../05_Control_Theory/05.1.3_éçº¿æ€§æ§åˆ¶ç†è®º.md)
- [05.1.4 è‡ªé€‚åº”æ§åˆ¶ç†è®º](../05_Control_Theory/05.1.4_è‡ªé€‚åº”æ§åˆ¶ç†è®º.md)
- [02.6.1 ç¾¤è®ºåŸºç¡€](../02_Mathematical_Foundations/05_Algebra/02.6.1_Group_Theory_Foundation.md)
- [02.4.1 å‡½æ•°æ¦‚å¿µ](../02_Mathematical_Foundation/02.4.1_å‡½æ•°æ¦‚å¿µ.md)

## 10 æ‰¹åˆ¤æ€§åˆ†æ

### 10.1 å¤šå…ƒç†è®ºè§†è§’

**ç»å…¸é¢‘åŸŸè§†è§’**ï¼šä»¥ä¼ é€’å‡½æ•°ä¸é¢‘ç‡å“åº”ä¸ºæ ¸å¿ƒï¼Œç›´è§‚ã€å·¥ç¨‹å®ç”¨å¼ºï¼Œä½†å¯¹å¤šè¾“å…¥å¤šè¾“å‡º(MIMO)ä¸å¼ºè€¦åˆç³»ç»Ÿè¡¨è¾¾åŠ›ä¸è¶³ã€‚

**çŠ¶æ€ç©ºé—´è§†è§’**ï¼šç»Ÿä¸€è¿ç»­/ç¦»æ•£ã€å•å˜é‡/å¤šå˜é‡æè¿°ï¼Œåˆ©äºç°ä»£åˆ†æä¸ç»¼åˆï¼Œä½†æŠ½è±¡åº¦é«˜ã€å…¥é—¨é—¨æ§›å¤§ã€‚

**ä¿¡æ¯è®ºä¸æ§åˆ¶è§†è§’**ï¼šæŠŠç¨³å®šæ€§ä¸æ€§èƒ½ç”¨ä¿¡æ¯ç‡ä¸ç†µåº¦é‡è”é€šï¼Œæœ‰åŠ©äºè·¨é¢†åŸŸç»Ÿä¸€ï¼Œä½†ç†è®ºä¸å·¥ç¨‹è½åœ°ä¹‹é—´ä»æœ‰è·ç¦»ã€‚

**è®¡ç®—ä¸è½¯ä»¶è§†è§’**ï¼šæ•°å€¼ç¨³å¥æ€§ã€å®æ—¶æ€§ã€å¯éªŒè¯æ€§æˆä¸ºè®¾è®¡åŒç­‰é‡è¦çš„ç›®æ ‡ï¼Œä¿ƒä½¿æ–¹æ³•èµ°å‘â€œç®—æ³•+è§„èŒƒâ€ååŒã€‚

### 10.2 å±€é™æ€§åˆ†æ

**çº¿æ€§åŒ–ä¾èµ–**ï¼šå¤§é‡æ–¹æ³•ä¾èµ–çº¿æ€§åŒ–ä¸å°æ‰°åŠ¨å‡è®¾ï¼Œå¼ºéçº¿æ€§/é¥±å’Œ/æ­»åŒºç­‰ä¼šç ´åç»“è®ºçš„æ™®é€‚æ€§ã€‚

**æ¨¡å‹ä¸ç¡®å®šæ€§**ï¼šå‚æ•°æ¼‚ç§»ã€æœªå»ºæ¨¡åŠ¨æ€ã€æ—¶å˜ç‰¹æ€§å¸¸è§ï¼Œç»å…¸æ–¹æ³•çš„é²æ£’è£•åº¦è¯„ä¼°ä¸ä¿è¯æœ‰é™ã€‚

**å®ç°çº¦æŸ**ï¼šé‡‡æ ·ã€é‡åŒ–ã€å»¶æ—¶ã€è®¡ç®—èµ„æºã€ç½‘ç»œä¸¢åŒ…ç­‰å®ç°å› ç´ å¸¸è¢«ç®€åŒ–å¤„ç†ï¼Œå¯¼è‡´â€œçº¸é¢ç¨³å®šã€å®æœºä¸ç¨³â€ã€‚

**æŒ‡æ ‡å†²çª**ï¼šç¨³ã€å‡†ã€å¿«ã€çœï¼ˆèƒ½è€—ï¼‰ç­‰æŒ‡æ ‡å­˜åœ¨æ ¹æœ¬æƒè¡¡ï¼Œå•ä¸€æŒ‡æ ‡ä¼˜åŒ–æ˜“é€ æˆç³»ç»Ÿæ•´ä½“é€€åŒ–ã€‚

### 10.3 äº‰è®®ä¸åˆ†æ­§

**é¢‘åŸŸvsæ—¶åŸŸ**ï¼šå·¥ç¨‹æ´¾åå¥½é¢‘åŸŸç›´è§‚å·¥å…·ï¼Œç°ä»£æ´¾å€¡å¯¼çŠ¶æ€ç©ºé—´ç»Ÿä¸€æ¡†æ¶ï¼›äºŒè€…åœ¨æ•™å­¦ä¸å®è·µä¸­çš„é…æ¯”é•¿æœŸäº‰è®ºã€‚

**è§£ævsæ•°å€¼**ï¼šè§£æè§£é€æ˜ä½†éš¾ä»¥é€‚é…å¤æ‚ç°å®ï¼Œæ•°å€¼æ³•å¼ºå¤§ä½†å¯èƒ½ä¸§å¤±å¯è§£é‡Šæ€§ä¸å¯è¯æ˜æ€§ã€‚

**å¼€ç¯æ•´å½¢vsé—­ç¯ç»¼åˆ**ï¼šå‰è€…ç®€å•é«˜æ•ˆï¼Œåè€…ç³»ç»Ÿæ€§å¼ºï¼›ä¸åŒäº§ä¸šä¸è§„æ¨¡ä¸‹é€‰æ‹©å·®å¼‚æ˜¾è‘—ã€‚

### 10.4 åº”ç”¨å‰æ™¯

**ç½‘ç»œåŒ–ä¸åˆ†å¸ƒå¼æ§åˆ¶**ï¼šåœ¨è½¦è·¯ååŒã€ç”µåŠ›ä¸å·¥ä¸šäº’è”ç½‘ä¸­å¿«é€Ÿæ‰©å±•ï¼Œå…³æ³¨æ—¶å»¶/ä¸¢åŒ…/åŒæ­¥é—®é¢˜ã€‚

**äººæœºå…±é©¾ä¸è‡ªé€‚åº”è‡ªåŠ¨åŒ–**ï¼šåœ¨æœºå™¨äºº/åŒ»ç–—/äº¤é€šä¸­æ¨å¹¿ï¼Œå®‰å…¨çº¦æŸä¸‹çš„è‡ªé€‚åº”ä¸å­¦ä¹ æ§åˆ¶æ˜¯é‡ç‚¹ã€‚

**æ¨¡å‹-æ•°æ®èåˆ**ï¼šåŸºäºç‰©ç†å…ˆéªŒçš„å­¦ä¹ æ§åˆ¶ã€æ•°å­—å­ªç”Ÿé©±åŠ¨çš„åœ¨çº¿æ•´å®šæˆä¸ºè¶‹åŠ¿ã€‚

### 10.5 æ”¹è¿›å»ºè®®

**é²æ£’-æœ€ä¼˜ä¸€ä½“åŒ–**ï¼šè”åˆHâˆ/Î¼ç»¼åˆä¸LQR/LQGï¼Œæ˜¾å¼å¤„ç†ä¸ç¡®å®šæ€§ä¸æ€§èƒ½æƒè¡¡ã€‚

**å®ç°å¯éªŒè¯æ€§**ï¼šæŠŠé‡åŒ–ã€æ—¶å»¶ã€æº¢å‡ºã€é‡‡æ ·ç‡è¿›å…¥è®¾è®¡é—­ç¯ï¼Œé…åˆå½¢å¼åŒ–éªŒè¯ä¸ä»¿çœŸè¦†ç›–ã€‚

**æ•™è‚²ä¸å·¥å…·é“¾**ï¼šé¢‘åŸŸç›´è§‚+æ—¶åŸŸç»Ÿä¸€å¹¶é‡ï¼›å¼ºåŒ–å¼€æºå·¥å…·ã€æµ‹è¯•åŸºå‡†ä¸å¯å¤ç°å®éªŒã€‚
