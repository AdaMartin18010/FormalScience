# 04.8 ç±»å‹ç†è®ºåº”ç”¨ (Applications of Type Theory)

## ğŸ“‹ ç›®å½•

- [04.8 ç±»å‹ç†è®ºåº”ç”¨ (Applications of Type Theory)](#048-ç±»å‹ç†è®ºåº”ç”¨-applications-of-type-theory)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2 åº”ç”¨ç‰ˆå›¾](#2-åº”ç”¨ç‰ˆå›¾)
  - [3 æ¡ˆä¾‹](#3-æ¡ˆä¾‹)
  - [å‚è€ƒæ–‡çŒ®](#å‚è€ƒæ–‡çŒ®)
  - [4 æ‰¹åˆ¤æ€§åˆ†æ](#4-æ‰¹åˆ¤æ€§åˆ†æ)

---

## 1 æ¦‚è¿°

ç±»å‹ç†è®ºåœ¨ç¼–ç¨‹è¯­è¨€ã€å½¢å¼åŒ–éªŒè¯ã€åè®®/å¹¶å‘å»ºæ¨¡ä¸æ•°å­¦åŸºç¡€ä¸­æä¾›ç»Ÿä¸€çš„è§„æ ¼â€”è¯æ˜â€”ç¨‹åºèŒƒå¼ã€‚

## 2 åº”ç”¨ç‰ˆå›¾

- ç¼–ç¨‹è¯­è¨€ä¸ç¼–è¯‘å™¨ï¼šç±»å‹å®‰å…¨ã€æ¨æ–­ã€ä¼˜åŒ–ä¸ä¸­é—´è¡¨ç¤ºï¼ˆIRï¼‰çš„ç±»å‹åŒ–ä¸å˜å¼
- å½¢å¼åŒ–éªŒè¯ï¼šå®šç†è¯æ˜åŠ©æ‰‹ï¼ˆCoq/Lean/Agdaï¼‰ä¸å¯éªŒè¯å¼€å‘æµæ°´çº¿ï¼ˆTDDâ†’TDD with Typesï¼‰
- å¹¶å‘ä¸åè®®ï¼šçº¿æ€§/ä»¿å°„/ä¼šè¯ç±»å‹ä¿éšœé€šé“ä¸èµ„æºå®‰å…¨
- ç³»ç»Ÿä¸å®‰å…¨ï¼šæ‰€æœ‰æƒ/å€Ÿç”¨ã€èƒ½åŠ›ä¸ç­–ç•¥çš„ç±»å‹åŒ–æ²»ç†
- æ•°å­¦ä¸åŸºç¡€ï¼šä¾ç±»å‹ä¸ HoTT çš„å¯æ‰§è¡Œæ•°å­¦ä¸å¤ç°

## 3 æ¡ˆä¾‹

```rust
// æ‰€æœ‰æƒæ¨¡å‹ä¸‹çš„èµ„æºçº¿æ€§åŒ–ç¤ºä¾‹
use std::sync::{Arc, Mutex};

// çº¿æ€§èµ„æºç±»å‹
struct LinearResource {
    data: String,
    consumed: bool,
}

impl LinearResource {
    fn new(data: String) -> Self {
        LinearResource { data, consumed: false }
    }

    fn consume(mut self) -> String {
        if self.consumed {
            panic!("Resource already consumed");
        }
        self.consumed = true;
        self.data
    }
}

// ä¼šè¯ç±»å‹é£æ ¼çš„é€šé“
struct SessionChannel<T> {
    sender: Option<Arc<Mutex<Vec<T>>>>,
    receiver: Option<Arc<Mutex<Vec<T>>>>,
}

impl<T> SessionChannel<T> {
    fn new() -> Self {
        let channel = Arc::new(Mutex::new(Vec::new()));
        SessionChannel {
            sender: Some(Arc::clone(&channel)),
            receiver: Some(channel),
        }
    }

    fn send(&mut self, value: T) -> Result<(), &'static str> {
        if let Some(sender) = &self.sender {
            sender.lock().unwrap().push(value);
            Ok(())
        } else {
            Err("Sender already consumed")
        }
    }

    fn receive(&mut self) -> Result<Option<T>, &'static str> {
        if let Some(receiver) = &self.receiver {
            Ok(receiver.lock().unwrap().pop())
        } else {
            Err("Receiver already consumed")
        }
    }

    fn close_sender(&mut self) {
        self.sender = None;
    }

    fn close_receiver(&mut self) {
        self.receiver = None;
    }
}

fn main() {
    // çº¿æ€§èµ„æºä½¿ç”¨
    let resource = LinearResource::new("important data".to_string());
    let data = resource.consume();
    // resource.consume(); // ç¼–è¯‘é”™è¯¯ï¼švalue moved

    // ä¼šè¯ç±»å‹é€šé“
    let mut channel = SessionChannel::new();
    channel.send(42).unwrap();
    channel.send(100).unwrap();
    channel.close_sender();

    println!("Received: {:?}", channel.receive().unwrap());
    println!("Received: {:?}", channel.receive().unwrap());
    channel.close_receiver();
}
```

```coq
(* è§„æ ¼â€”ç¨‹åºâ€”è¯æ˜ä¸€ä½“åŒ–çš„æœ€å°ç¤ºä¾‹ *)
Require Import Coq.Lists.List.
Require Import Coq.Arith.PeanoNat.

(* è§„æ ¼ï¼šæ’åºå‡½æ•°çš„ç±»å‹ *)
Definition is_sorted (l: list nat) : Prop :=
  forall i j, i < j < length l -> nth i l 0 <= nth j l 0.

Definition is_permutation (l1 l2: list nat) : Prop :=
  forall x, count_occ Nat.eq_dec l1 x = count_occ Nat.eq_dec l2 x.

(* ç¨‹åºï¼šæ’å…¥æ’åºå®ç° *)
Fixpoint insert (x: nat) (l: list nat) : list nat :=
  match l with
  | nil => x :: nil
  | h :: t => if x <=? h then x :: l else h :: insert x t
  end.

Fixpoint insertion_sort (l: list nat) : list nat :=
  match l with
  | nil => nil
  | h :: t => insert h (insertion_sort t)
  end.

(* è¯æ˜ï¼šæ’åºå‡½æ•°çš„æ­£ç¡®æ€§ *)
Lemma insert_sorted: forall x l, is_sorted l -> is_sorted (insert x l).
Proof.
  intros x l H.
  induction l as [|h t IH].
  - simpl. unfold is_sorted. intros i j H1. inversion H1.
  - simpl. destruct (x <=? h) eqn:Hx.
    + unfold is_sorted. intros i j H1.
      destruct i, j; simpl; auto.
    + unfold is_sorted. intros i j H1.
      destruct i, j; simpl; auto.
      apply IH. exact H.
Qed.

Theorem insertion_sort_sorted: forall l, is_sorted (insertion_sort l).
Proof.
  induction l as [|h t IH].
  - simpl. unfold is_sorted. intros i j H. inversion H.
  - simpl. apply insert_sorted. exact IH.
Qed.

(* æå–åˆ°OCaml *)
Extraction Language OCaml.
Extraction "insertion_sort" insertion_sort.
```

## å‚è€ƒæ–‡çŒ®

- Pierce, Harperï¼›Coq/Lean/Agda æ–‡æ¡£ï¼›Wadler on Linear/Session Types

## 4 æ‰¹åˆ¤æ€§åˆ†æ

- å¤šå…ƒç†è®ºè§†è§’ï¼š
  - ç»Ÿä¸€å·¥å…·ç®±ï¼šä»¥ç±»å‹ä¸ºè§„æ ¼ï¼Œè¯æ˜ä¸ºç¨‹åºï¼Œé…åˆæå–/è¿è¡Œæ—¶æ–­è¨€å½¢æˆç«¯åˆ°ç«¯è´¨é‡é“¾è·¯ã€‚
  - é¢†åŸŸé€‚é…ï¼šç³»ç»Ÿã€å¹¶å‘ã€æ•°æ®ç§‘å­¦ä¸æ•°å­¦å„å–æ‰€éœ€ï¼ˆçº¿æ€§/ä»¿å°„ã€ä¾ç±»å‹ã€HoTTï¼‰ã€‚
- å±€é™æ€§åˆ†æï¼š
  - è¿ç§»æˆæœ¬ï¼šå¢é‡å¯¼å…¥ç±»å‹åŒ–è§„èŒƒéœ€é‡æ„æ¥å£ä¸ç”Ÿæ€ï¼›å›¢é˜Ÿèƒ½åŠ›ä¸IDE æ”¯æŒå†³å®šæ”¶ç›Šæ›²çº¿ã€‚
  - æ€§èƒ½ä¸å¤æ‚åº¦ï¼šå¼ºç±»å‹ä¸è‡ªåŠ¨åŒ–è¯æ˜å¼•å…¥ç¼–è¯‘ä¸å­¦ä¹ æˆæœ¬ï¼Œéœ€å·¥ç¨‹åŒ–çº¦æŸä¸åŸºçº¿ã€‚
- äº‰è®®ä¸åˆ†æ­§ï¼š
  - â€œç±»å‹å³å…¨éƒ¨â€è¿˜æ˜¯â€œç±»å‹+æµ‹è¯•+è¿è¡Œæ—¶ç›‘æ§â€çš„ç»„åˆæ‹³ï¼›ä¸åŒç»„ç»‡çš„é£é™©è¾¹ç•Œä¸åŒã€‚
- åº”ç”¨å‰æ™¯ï¼š
  - å¯éªŒè¯åŸºç¡€è®¾æ–½ã€åè®®ä¸ç¼–è¯‘å™¨ã€é¢†åŸŸç‰¹å®šè¯­è¨€ï¼ˆDSLï¼‰ä¸æ•™è‚²è¯¾ç¨‹çš„ç³»ç»ŸåŒ–å‡çº§ã€‚
- æ”¹è¿›å»ºè®®ï¼š
  - å»ºç«‹â€œæœ€å°å¯è¡Œè§„èŒƒåŒ…â€ï¼ˆç±»å‹åˆ«åã€è¯æ˜æ¨¡æ¿ã€CI è¯æ®ï¼‰ä¸åŸºå‡†é›†ï¼›æ¨å¹¿æ¸è¿›é‡‡ç”¨ç­–ç•¥ä¸å¤ç”¨åº“ã€‚
