# 04.4.1 ç±»å‹æ—

## ğŸ“‹ æ¦‚è¿°

ç±»å‹æ—æ˜¯ä¾èµ–ç±»å‹ç†è®ºçš„æ ¸å¿ƒæ¦‚å¿µï¼Œå…è®¸ç±»å‹ä¾èµ–äºå€¼ï¼Œä»è€Œå®ç°æ›´ç²¾ç¡®çš„ç±»å‹è¡¨è¾¾ã€‚æœ¬æ–‡æ¡£å»ºç«‹ä¸¥æ ¼çš„ç±»å‹æ—ç†è®ºæ¡†æ¶ï¼ŒåŒ…å«ç±»å‹æ—å®šä¹‰ã€ç´¢å¼•ç±»å‹ã€ä¾èµ–ç±»å‹æ—ã€ç±»å‹æ—è®¡ç®—ç­‰å†…å®¹ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ç±»å‹æ—çš„åŸºæœ¬æ¦‚å¿µå’Œå½¢å¼åŒ–å®šä¹‰
2. åˆ†æç±»å‹æ—ä¸ä¾èµ–ç±»å‹çš„å…³ç³»
3. ç ”ç©¶ç±»å‹æ—è®¡ç®—å’Œç±»å‹æ—æ¨ç†
4. æä¾›ç±»å‹æ—çš„å®é™…åº”ç”¨æ–¹æ³•

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç±»å‹æ—åŸºç¡€

**å®šä¹‰ 1.1.1** (ç±»å‹æ—)
ç±»å‹æ—æ˜¯ä»å€¼åˆ°ç±»å‹çš„å‡½æ•°ï¼š
$$F : A \rightarrow Type$$
å…¶ä¸­ $A$ æ˜¯ç´¢å¼•ç±»å‹ï¼Œ$Type$ æ˜¯ç±»å‹å®‡å®™ã€‚

**å®šä¹‰ 1.1.2** (ç´¢å¼•ç±»å‹)
ç´¢å¼•ç±»å‹æ˜¯ç±»å‹æ—çš„å‚æ•°ç±»å‹ï¼š

- è‡ªç„¶æ•°ç´¢å¼•ï¼š$F : \mathbb{N} \rightarrow Type$
- å¸ƒå°”ç´¢å¼•ï¼š$F : Bool \rightarrow Type$
- åˆ—è¡¨ç´¢å¼•ï¼š$F : List[A] \rightarrow Type$

**å®šä¹‰ 1.1.3** (ä¾èµ–ç±»å‹æ—)
ä¾èµ–ç±»å‹æ—å…è®¸ç±»å‹ä¾èµ–äºå¤šä¸ªå‚æ•°ï¼š
$$F : (x_1 : A_1) \rightarrow (x_2 : A_2) \rightarrow \ldots \rightarrow Type$$

### 1.2 ç±»å‹æ—çš„åŸºæœ¬ç‰¹å¾

**å®šä¹‰ 1.2.1** (ç±»å‹æ—è¯­æ³•)
ç±»å‹æ—è¯­æ³•å®šä¹‰ï¼š

```text
TypeFamily ::= type Name [Params] where
                | Name Index = Type
                | Name Index = Type
                | ...
Params ::= Param*
Param ::= Name : Type
Index ::= Term
```

**å®šä¹‰ 1.2.2** (ç±»å‹æ—è®¡ç®—)
ç±»å‹æ—è®¡ç®—æ˜¯ç±»å‹æ—çš„æ±‚å€¼è¿‡ç¨‹ï¼š
$$F(i) \leadsto T$$
å…¶ä¸­ $i$ æ˜¯ç´¢å¼•ï¼Œ$T$ æ˜¯è®¡ç®—å¾—åˆ°çš„ç±»å‹ã€‚

**å®šä¹‰ 1.2.3** (ç±»å‹æ—æ¨ç†)
ç±»å‹æ—æ¨ç†æ˜¯è‡ªåŠ¨æ¨å¯¼ç±»å‹æ—å®ä¾‹çš„è¿‡ç¨‹ï¼š

- æ¨¡å¼åŒ¹é…ï¼šåŸºäºç´¢å¼•çš„æ¨¡å¼åŒ¹é…
- é€’å½’å®šä¹‰ï¼šç±»å‹æ—çš„é€’å½’å®šä¹‰
- ç±»å‹æ—å®ä¾‹ï¼šå…·ä½“çš„ç±»å‹æ—å®ä¾‹

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ç±»å‹æ—ç±»å‹ç³»ç»Ÿ

**å®šä¹‰ 2.1.1** (ç±»å‹æ—ç±»å‹)
ç±»å‹æ—ç±»å‹ç³»ç»Ÿ $\mathcal{TF}$ åŒ…å«ï¼š

- åŸºæœ¬ç±»å‹ï¼š$T$
- ç±»å‹æ—ç±»å‹ï¼š$TypeFamily[A, B]$
- ç´¢å¼•ç±»å‹ï¼š$IndexType$
- ä¾èµ–ç±»å‹æ—ï¼š$\Pi x : A. F(x)$

**å®šä¹‰ 2.1.2** (ç±»å‹æ—è§„åˆ™)
ç±»å‹æ—æ¨å¯¼è§„åˆ™ï¼š
$$\frac{\Gamma \vdash i : A \quad \Gamma \vdash F : A \rightarrow Type}{\Gamma \vdash F(i) : Type} \text{ (Type Family Application)}$$
$$\frac{\Gamma \vdash F : A \rightarrow Type \quad \Gamma \vdash i_1 = i_2 : A}{\Gamma \vdash F(i_1) = F(i_2) : Type} \text{ (Type Family Equality)}$$

**å®šä¹‰ 2.1.3** (ç±»å‹æ—è®¡ç®—è§„åˆ™)
ç±»å‹æ—è®¡ç®—è§„åˆ™ï¼š
$$\frac{F(i) \leadsto T}{\Gamma \vdash F(i) \equiv T : Type} \text{ (Type Family Computation)}$$

### 2.2 ç´¢å¼•ç±»å‹ç³»ç»Ÿ

**å®šä¹‰ 2.2.1** (ç´¢å¼•ç±»å‹è¯­æ³•)
ç´¢å¼•ç±»å‹è¯­æ³•ï¼š

```text
IndexType ::= Nat | Bool | List[IndexType] | Vector[IndexType, Nat]
            | Fin[Nat] | Unit | Sum[IndexType, IndexType]
            | Product[IndexType, IndexType]
```

**å®šä¹‰ 2.2.2** (ç´¢å¼•ç±»å‹è§„åˆ™)
ç´¢å¼•ç±»å‹æ¨å¯¼è§„åˆ™ï¼š
$$\frac{\Gamma \vdash n : Nat}{\Gamma \vdash Fin(n) : Type} \text{ (Finite Type)}$$
$$\frac{\Gamma \vdash A : Type \quad \Gamma \vdash n : Nat}{\Gamma \vdash Vector[A, n] : Type} \text{ (Vector Type)}$$

**å®šä¹‰ 2.2.3** (ç´¢å¼•ç±»å‹è®¡ç®—)
ç´¢å¼•ç±»å‹è®¡ç®—è§„åˆ™ï¼š
$$Fin(0) \leadsto \emptyset$$
$$Fin(n+1) \leadsto \{0, 1, \ldots, n\}$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 ç±»å‹æ—åŸºæœ¬å®šç†

**å®šç† 3.1.1** (ç±»å‹æ—ä¸€è‡´æ€§å®šç†)
å¦‚æœç±»å‹æ— $F$ æ˜¯ä¸€è‡´çš„ï¼Œåˆ™å¯¹äºæ‰€æœ‰ç´¢å¼• $i$ï¼Œ$F(i)$ éƒ½æ˜¯è‰¯ç±»å‹çš„ã€‚

**è¯æ˜**ï¼š
é€šè¿‡ç»“æ„å½’çº³æ³•è¯æ˜ï¼š

1. åŸºç¡€æƒ…å†µï¼šåŸºæœ¬ç±»å‹æ—æ˜¯ä¸€è‡´çš„
2. é€’å½’æƒ…å†µï¼šé€’å½’ç±»å‹æ—çš„ä¸€è‡´æ€§
3. è®¡ç®—æƒ…å†µï¼šç±»å‹æ—è®¡ç®—ä¿æŒä¸€è‡´æ€§

**å®šç† 3.1.2** (ç±»å‹æ—ç»ˆæ­¢æ€§å®šç†)
ç±»å‹æ—è®¡ç®—æ€»æ˜¯ç»ˆæ­¢çš„ã€‚

**è¯æ˜**ï¼š
åŸºäºç±»å‹æ—çš„è‰¯åŸºæ€§ï¼š

- ç´¢å¼•ç±»å‹æ˜¯è‰¯åŸºçš„
- ç±»å‹æ—å®šä¹‰æ˜¯ç»“æ„é€’å½’çš„
- è®¡ç®—è§„åˆ™æ˜¯å•è°ƒé€’å‡çš„

### 3.2 ç´¢å¼•ç±»å‹å®šç†

**å®šç† 3.2.1** (ç´¢å¼•ç±»å‹å®Œå¤‡æ€§å®šç†)
ç´¢å¼•ç±»å‹ç³»ç»Ÿæ˜¯å®Œå¤‡çš„ï¼Œèƒ½å¤Ÿè¡¨è¾¾æ‰€æœ‰å¯è®¡ç®—çš„ç´¢å¼•ã€‚

**è¯æ˜**ï¼š
é€šè¿‡ç¼–ç è¯æ˜ï¼š

1. è‡ªç„¶æ•°ç¼–ç ï¼š$Nat \rightarrow IndexType$
2. å¸ƒå°”ç¼–ç ï¼š$Bool \rightarrow IndexType$
3. é€’å½’ç¼–ç ï¼šé€’å½’ç´¢å¼•ç±»å‹

**å®šç† 3.2.2** (ç´¢å¼•ç±»å‹å®‰å…¨æ€§å®šç†)
ç´¢å¼•ç±»å‹ç³»ç»Ÿä¿è¯ç´¢å¼•æ“ä½œçš„å®‰å…¨æ€§ã€‚

**è¯æ˜**ï¼š
åŸºäºç±»å‹æ£€æŸ¥ï¼š

1. ç´¢å¼•è¾¹ç•Œæ£€æŸ¥
2. ç´¢å¼•ç±»å‹åŒ¹é…
3. ç´¢å¼•æ“ä½œæœ‰æ•ˆæ€§

## 4. ä»£ç å®ç°

### 4.1 ç±»å‹æ—åŸºç¡€å®ç°

```rust
use std::collections::HashMap;

/// ç´¢å¼•ç±»å‹
#[derive(Debug, Clone, PartialEq)]
enum IndexType {
    Nat(usize),
    Bool(bool),
    List(Vec<IndexType>),
    Vector(Vec<IndexType>, usize),
    Fin(usize),
    Unit,
    Sum(Box<IndexType>, Box<IndexType>),
    Product(Box<IndexType>, Box<IndexType>),
}

/// ç±»å‹æ—
#[derive(Debug)]
struct TypeFamily {
    name: String,
    parameters: Vec<(String, Type)>,
    equations: Vec<TypeFamilyEquation>,
}

#[derive(Debug)]
struct TypeFamilyEquation {
    pattern: IndexType,
    result: Type,
}

#[derive(Debug, Clone)]
enum Type {
    Base(BaseType),
    Function(Box<Type>, Box<Type>),
    Product(Box<Type>, Box<Type>),
    Sum(Box<Type>, Box<Type>),
    TypeFamily(String, IndexType),
    Dependent(Box<Type>, Box<Type>),
}

#[derive(Debug, Clone)]
enum BaseType {
    Int,
    Bool,
    String,
    Unit,
}

impl TypeFamily {
    /// åˆ›å»ºç±»å‹æ—
    fn new(name: String) -> Self {
        TypeFamily {
            name,
            parameters: Vec::new(),
            equations: Vec::new(),
        }
    }
    
    /// æ·»åŠ å‚æ•°
    fn add_parameter(&mut self, name: String, typ: Type) {
        self.parameters.push((name, typ));
    }
    
    /// æ·»åŠ æ–¹ç¨‹
    fn add_equation(&mut self, pattern: IndexType, result: Type) {
        self.equations.push(TypeFamilyEquation { pattern, result });
    }
    
    /// è®¡ç®—ç±»å‹æ—
    fn compute(&self, index: &IndexType) -> Option<Type> {
        for equation in &self.equations {
            if self.pattern_match(&equation.pattern, index) {
                return Some(equation.result.clone());
            }
        }
        None
    }
    
    /// æ¨¡å¼åŒ¹é…
    fn pattern_match(&self, pattern: &IndexType, index: &IndexType) -> bool {
        match (pattern, index) {
            (IndexType::Nat(n1), IndexType::Nat(n2)) => n1 == n2,
            (IndexType::Bool(b1), IndexType::Bool(b2)) => b1 == b2,
            (IndexType::List(pats), IndexType::List(indices)) => {
                pats.len() == indices.len() && 
                pats.iter().zip(indices.iter()).all(|(p, i)| self.pattern_match(p, i))
            },
            (IndexType::Vector(pats, n1), IndexType::Vector(indices, n2)) => {
                n1 == n2 && 
                pats.len() == indices.len() && 
                pats.iter().zip(indices.iter()).all(|(p, i)| self.pattern_match(p, i))
            },
            (IndexType::Fin(n1), IndexType::Fin(n2)) => n1 == n2,
            (IndexType::Unit, IndexType::Unit) => true,
            (IndexType::Sum(p1, p2), IndexType::Sum(i1, i2)) => {
                self.pattern_match(p1, i1) && self.pattern_match(p2, i2)
            },
            (IndexType::Product(p1, p2), IndexType::Product(i1, i2)) => {
                self.pattern_match(p1, i1) && self.pattern_match(p2, i2)
            },
            _ => false
        }
    }
}

/// ç±»å‹æ—ç¯å¢ƒ
#[derive(Debug)]
struct TypeFamilyEnvironment {
    families: HashMap<String, TypeFamily>,
}

impl TypeFamilyEnvironment {
    /// åˆ›å»ºç±»å‹æ—ç¯å¢ƒ
    fn new() -> Self {
        TypeFamilyEnvironment {
            families: HashMap::new(),
        }
    }
    
    /// æ³¨å†Œç±»å‹æ—
    fn register_family(&mut self, family: TypeFamily) {
        self.families.insert(family.name.clone(), family);
    }
    
    /// æŸ¥æ‰¾ç±»å‹æ—
    fn lookup_family(&self, name: &str) -> Option<&TypeFamily> {
        self.families.get(name)
    }
    
    /// è®¡ç®—ç±»å‹æ—åº”ç”¨
    fn compute_family_application(&self, name: &str, index: &IndexType) -> Option<Type> {
        if let Some(family) = self.lookup_family(name) {
            family.compute(index)
        } else {
            None
        }
    }
}

/// ç´¢å¼•ç±»å‹è®¡ç®—å™¨
#[derive(Debug)]
struct IndexTypeCalculator {
    env: TypeFamilyEnvironment,
}

impl IndexTypeCalculator {
    /// åˆ›å»ºç´¢å¼•ç±»å‹è®¡ç®—å™¨
    fn new() -> Self {
        IndexTypeCalculator {
            env: TypeFamilyEnvironment::new(),
        }
    }
    
    /// è®¡ç®—ç´¢å¼•ç±»å‹
    fn compute_index_type(&self, index: &IndexType) -> Option<IndexType> {
        match index {
            IndexType::Nat(n) => Some(IndexType::Nat(*n)),
            IndexType::Bool(b) => Some(IndexType::Bool(*b)),
            IndexType::List(elements) => {
                let computed_elements: Vec<_> = elements.iter()
                    .filter_map(|e| self.compute_index_type(e))
                    .collect();
                if computed_elements.len() == elements.len() {
                    Some(IndexType::List(computed_elements))
                } else {
                    None
                }
            },
            IndexType::Vector(elements, size) => {
                let computed_elements: Vec<_> = elements.iter()
                    .filter_map(|e| self.compute_index_type(e))
                    .collect();
                if computed_elements.len() == elements.len() {
                    Some(IndexType::Vector(computed_elements, *size))
                } else {
                    None
                }
            },
            IndexType::Fin(n) => {
                if *n > 0 {
                    Some(IndexType::Fin(*n))
                } else {
                    None
                }
            },
            IndexType::Unit => Some(IndexType::Unit),
            IndexType::Sum(left, right) => {
                let computed_left = self.compute_index_type(left)?;
                let computed_right = self.compute_index_type(right)?;
                Some(IndexType::Sum(Box::new(computed_left), Box::new(computed_right)))
            },
            IndexType::Product(left, right) => {
                let computed_left = self.compute_index_type(left)?;
                let computed_right = self.compute_index_type(right)?;
                Some(IndexType::Product(Box::new(computed_left), Box::new(computed_right)))
            },
        }
    }
    
    /// æ£€æŸ¥ç´¢å¼•ç±»å‹æœ‰æ•ˆæ€§
    fn is_valid_index_type(&self, index: &IndexType) -> bool {
        match index {
            IndexType::Nat(_) => true,
            IndexType::Bool(_) => true,
            IndexType::List(elements) => {
                elements.iter().all(|e| self.is_valid_index_type(e))
            },
            IndexType::Vector(elements, size) => {
                elements.len() == *size && elements.iter().all(|e| self.is_valid_index_type(e))
            },
            IndexType::Fin(n) => *n > 0,
            IndexType::Unit => true,
            IndexType::Sum(left, right) => {
                self.is_valid_index_type(left) && self.is_valid_index_type(right)
            },
            IndexType::Product(left, right) => {
                self.is_valid_index_type(left) && self.is_valid_index_type(right)
            },
        }
    }
}
```

### 4.2 ä¾èµ–ç±»å‹æ—å®ç°

```rust
/// ä¾èµ–ç±»å‹æ—
#[derive(Debug)]
struct DependentTypeFamily {
    name: String,
    parameters: Vec<DependentParameter>,
    equations: Vec<DependentEquation>,
}

#[derive(Debug)]
struct DependentParameter {
    name: String,
    parameter_type: Type,
    dependent_constraints: Vec<DependentConstraint>,
}

#[derive(Debug)]
struct DependentConstraint {
    condition: IndexType,
    constraint: Type,
}

#[derive(Debug)]
struct DependentEquation {
    pattern: Vec<IndexType>,
    result: Type,
    constraints: Vec<DependentConstraint>,
}

impl DependentTypeFamily {
    /// åˆ›å»ºä¾èµ–ç±»å‹æ—
    fn new(name: String) -> Self {
        DependentTypeFamily {
            name,
            parameters: Vec::new(),
            equations: Vec::new(),
        }
    }
    
    /// æ·»åŠ ä¾èµ–å‚æ•°
    fn add_dependent_parameter(&mut self, name: String, param_type: Type, constraints: Vec<DependentConstraint>) {
        self.parameters.push(DependentParameter {
            name,
            parameter_type: param_type,
            dependent_constraints: constraints,
        });
    }
    
    /// æ·»åŠ ä¾èµ–æ–¹ç¨‹
    fn add_dependent_equation(&mut self, pattern: Vec<IndexType>, result: Type, constraints: Vec<DependentConstraint>) {
        self.equations.push(DependentEquation {
            pattern,
            result,
            constraints,
        });
    }
    
    /// è®¡ç®—ä¾èµ–ç±»å‹æ—
    fn compute_dependent(&self, indices: &[IndexType]) -> Option<Type> {
        for equation in &self.equations {
            if self.dependent_pattern_match(&equation.pattern, indices) {
                if self.check_constraints(&equation.constraints, indices) {
                    return Some(equation.result.clone());
                }
            }
        }
        None
    }
    
    /// ä¾èµ–æ¨¡å¼åŒ¹é…
    fn dependent_pattern_match(&self, pattern: &[IndexType], indices: &[IndexType]) -> bool {
        if pattern.len() != indices.len() {
            return false;
        }
        
        pattern.iter().zip(indices.iter()).all(|(p, i)| {
            self.pattern_match(p, i)
        })
    }
    
    /// æ£€æŸ¥ä¾èµ–çº¦æŸ
    fn check_constraints(&self, constraints: &[DependentConstraint], indices: &[IndexType]) -> bool {
        constraints.iter().all(|constraint| {
            self.evaluate_constraint(constraint, indices)
        })
    }
    
    /// è¯„ä¼°çº¦æŸ
    fn evaluate_constraint(&self, constraint: &DependentConstraint, indices: &[IndexType]) -> bool {
        // ç®€åŒ–çš„çº¦æŸè¯„ä¼°
        match &constraint.condition {
            IndexType::Bool(b) => *b,
            IndexType::Nat(n) => *n > 0,
            _ => true,
        }
    }
    
    /// æ¨¡å¼åŒ¹é…ï¼ˆå¤ç”¨åŸºç¡€å®ç°ï¼‰
    fn pattern_match(&self, pattern: &IndexType, index: &IndexType) -> bool {
        match (pattern, index) {
            (IndexType::Nat(n1), IndexType::Nat(n2)) => n1 == n2,
            (IndexType::Bool(b1), IndexType::Bool(b2)) => b1 == b2,
            (IndexType::List(pats), IndexType::List(indices)) => {
                pats.len() == indices.len() && 
                pats.iter().zip(indices.iter()).all(|(p, i)| self.pattern_match(p, i))
            },
            (IndexType::Vector(pats, n1), IndexType::Vector(indices, n2)) => {
                n1 == n2 && 
                pats.len() == indices.len() && 
                pats.iter().zip(indices.iter()).all(|(p, i)| self.pattern_match(p, i))
            },
            (IndexType::Fin(n1), IndexType::Fin(n2)) => n1 == n2,
            (IndexType::Unit, IndexType::Unit) => true,
            (IndexType::Sum(p1, p2), IndexType::Sum(i1, i2)) => {
                self.pattern_match(p1, i1) && self.pattern_match(p2, i2)
            },
            (IndexType::Product(p1, p2), IndexType::Product(i1, i2)) => {
                self.pattern_match(p1, i1) && self.pattern_match(p2, i2)
            },
            _ => false
        }
    }
}

/// ç±»å‹æ—æ¨ç†å™¨
#[derive(Debug)]
struct TypeFamilyInference {
    env: TypeFamilyEnvironment,
    dependent_env: HashMap<String, DependentTypeFamily>,
}

impl TypeFamilyInference {
    /// åˆ›å»ºç±»å‹æ—æ¨ç†å™¨
    fn new() -> Self {
        TypeFamilyInference {
            env: TypeFamilyEnvironment::new(),
            dependent_env: HashMap::new(),
        }
    }
    
    /// æ³¨å†Œä¾èµ–ç±»å‹æ—
    fn register_dependent_family(&mut self, family: DependentTypeFamily) {
        self.dependent_env.insert(family.name.clone(), family);
    }
    
    /// æ¨ç†ç±»å‹æ—å®ä¾‹
    fn infer_family_instance(&self, name: &str, indices: &[IndexType]) -> Option<Type> {
        // é¦–å…ˆå°è¯•æ™®é€šç±»å‹æ—
        if let Some(result) = self.env.compute_family_application(name, &indices[0]) {
            return Some(result);
        }
        
        // ç„¶åå°è¯•ä¾èµ–ç±»å‹æ—
        if let Some(family) = self.dependent_env.get(name) {
            return family.compute_dependent(indices);
        }
        
        None
    }
    
    /// æ¨ç†ç´¢å¼•ç±»å‹
    fn infer_index_type(&self, term: &str) -> Option<IndexType> {
        // ç®€åŒ–çš„ç´¢å¼•ç±»å‹æ¨ç†
        match term {
            "zero" => Some(IndexType::Nat(0)),
            "one" => Some(IndexType::Nat(1)),
            "true" => Some(IndexType::Bool(true)),
            "false" => Some(IndexType::Bool(false)),
            "unit" => Some(IndexType::Unit),
            _ => {
                // å°è¯•è§£æä¸ºè‡ªç„¶æ•°
                if let Ok(n) = term.parse::<usize>() {
                    Some(IndexType::Nat(n))
                } else {
                    None
                }
            }
        }
    }
    
    /// æ£€æŸ¥ç±»å‹æ—ä¸€è‡´æ€§
    fn check_family_consistency(&self, name: &str) -> bool {
        // æ£€æŸ¥æ™®é€šç±»å‹æ—
        if let Some(family) = self.env.lookup_family(name) {
            return self.check_basic_family_consistency(family);
        }
        
        // æ£€æŸ¥ä¾èµ–ç±»å‹æ—
        if let Some(family) = self.dependent_env.get(name) {
            return self.check_dependent_family_consistency(family);
        }
        
        false
    }
    
    /// æ£€æŸ¥åŸºç¡€ç±»å‹æ—ä¸€è‡´æ€§
    fn check_basic_family_consistency(&self, family: &TypeFamily) -> bool {
        // æ£€æŸ¥æ–¹ç¨‹æ˜¯å¦è¦†ç›–æ‰€æœ‰æƒ…å†µ
        // æ£€æŸ¥æ–¹ç¨‹ä¹‹é—´æ˜¯å¦å†²çª
        // æ£€æŸ¥é€’å½’å®šä¹‰æ˜¯å¦ç»ˆæ­¢
        true // ç®€åŒ–å®ç°
    }
    
    /// æ£€æŸ¥ä¾èµ–ç±»å‹æ—ä¸€è‡´æ€§
    fn check_dependent_family_consistency(&self, family: &DependentTypeFamily) -> bool {
        // æ£€æŸ¥ä¾èµ–çº¦æŸçš„ä¸€è‡´æ€§
        // æ£€æŸ¥æ–¹ç¨‹è¦†ç›–æ€§
        // æ£€æŸ¥é€’å½’ç»ˆæ­¢æ€§
        true // ç®€åŒ–å®ç°
    }
}
```

### 4.3 ç±»å‹æ—è®¡ç®—å®ç°

```rust
/// ç±»å‹æ—è®¡ç®—å™¨
#[derive(Debug)]
struct TypeFamilyCalculator {
    inference: TypeFamilyInference,
    calculator: IndexTypeCalculator,
}

impl TypeFamilyCalculator {
    /// åˆ›å»ºç±»å‹æ—è®¡ç®—å™¨
    fn new() -> Self {
        TypeFamilyCalculator {
            inference: TypeFamilyInference::new(),
            calculator: IndexTypeCalculator::new(),
        }
    }
    
    /// è®¡ç®—ç±»å‹æ—åº”ç”¨
    fn calculate_family_application(&self, name: &str, indices: &[IndexType]) -> Option<Type> {
        // é¦–å…ˆè®¡ç®—ç´¢å¼•ç±»å‹
        let computed_indices: Vec<_> = indices.iter()
            .filter_map(|i| self.calculator.compute_index_type(i))
            .collect();
        
        if computed_indices.len() != indices.len() {
            return None;
        }
        
        // æ¨ç†ç±»å‹æ—å®ä¾‹
        self.inference.infer_family_instance(name, &computed_indices)
    }
    
    /// è®¡ç®—ä¾èµ–ç±»å‹
    fn calculate_dependent_type(&self, base_type: &Type, index: &IndexType) -> Option<Type> {
        match base_type {
            Type::TypeFamily(name, _) => {
                self.calculate_family_application(name, &[index.clone()])
            },
            Type::Dependent(param_type, body_type) => {
                // è®¡ç®—ä¾èµ–ç±»å‹
                let computed_index = self.calculator.compute_index_type(index)?;
                if self.calculator.is_valid_index_type(&computed_index) {
                    Some(body_type.clone())
                } else {
                    None
                }
            },
            _ => Some(base_type.clone()),
        }
    }
    
    /// è®¡ç®—ç±»å‹ç­‰ä»·æ€§
    fn calculate_type_equality(&self, type1: &Type, type2: &Type) -> bool {
        match (type1, type2) {
            (Type::Base(b1), Type::Base(b2)) => b1 == b2,
            (Type::Function(arg1, ret1), Type::Function(arg2, ret2)) => {
                self.calculate_type_equality(arg1, arg2) && 
                self.calculate_type_equality(ret1, ret2)
            },
            (Type::Product(left1, right1), Type::Product(left2, right2)) => {
                self.calculate_type_equality(left1, left2) && 
                self.calculate_type_equality(right1, right2)
            },
            (Type::Sum(left1, right1), Type::Sum(left2, right2)) => {
                self.calculate_type_equality(left1, left2) && 
                self.calculate_type_equality(right1, right2)
            },
            (Type::TypeFamily(name1, index1), Type::TypeFamily(name2, index2)) => {
                name1 == name2 && index1 == index2
            },
            (Type::Dependent(param1, body1), Type::Dependent(param2, body2)) => {
                self.calculate_type_equality(param1, param2) && 
                self.calculate_type_equality(body1, body2)
            },
            _ => false
        }
    }
    
    /// è®¡ç®—ç±»å‹æ—å®ä¾‹
    fn calculate_family_instances(&self, name: &str) -> Vec<(Vec<IndexType>, Type)> {
        let mut instances = Vec::new();
        
        // ç”Ÿæˆå¯èƒ½çš„ç´¢å¼•ç»„åˆ
        let possible_indices = self.generate_possible_indices();
        
        for indices in possible_indices {
            if let Some(result_type) = self.calculate_family_application(name, &indices) {
                instances.push((indices, result_type));
            }
        }
        
        instances
    }
    
    /// ç”Ÿæˆå¯èƒ½çš„ç´¢å¼•ç»„åˆ
    fn generate_possible_indices(&self) -> Vec<Vec<IndexType>> {
        let mut indices = Vec::new();
        
        // ç”Ÿæˆè‡ªç„¶æ•°ç´¢å¼•
        for n in 0..5 {
            indices.push(vec![IndexType::Nat(n)]);
        }
        
        // ç”Ÿæˆå¸ƒå°”ç´¢å¼•
        indices.push(vec![IndexType::Bool(true)]);
        indices.push(vec![IndexType::Bool(false)]);
        
        // ç”Ÿæˆåˆ—è¡¨ç´¢å¼•
        indices.push(vec![IndexType::List(vec![IndexType::Nat(1), IndexType::Nat(2)])]);
        
        // ç”Ÿæˆå‘é‡ç´¢å¼•
        indices.push(vec![IndexType::Vector(vec![IndexType::Bool(true)], 1)]);
        
        indices
    }
    
    /// ä¼˜åŒ–ç±»å‹æ—è®¡ç®—
    fn optimize_family_computation(&self, name: &str) -> HashMap<String, Type> {
        let mut optimizations = HashMap::new();
        
        // è®¡ç®—å¸¸ç”¨å®ä¾‹
        let common_indices = vec![
            vec![IndexType::Nat(0)],
            vec![IndexType::Nat(1)],
            vec![IndexType::Bool(true)],
            vec![IndexType::Bool(false)],
        ];
        
        for indices in common_indices {
            if let Some(result_type) = self.calculate_family_application(name, &indices) {
                let key = format!("{}({:?})", name, indices);
                optimizations.insert(key, result_type);
            }
        }
        
        optimizations
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç±»å‹æ—å®šä¹‰å’Œä½¿ç”¨

```rust
// ç±»å‹æ—å®šä¹‰å’Œä½¿ç”¨ç¤ºä¾‹
fn type_family_example() {
    let mut env = TypeFamilyEnvironment::new();
    
    // å®šä¹‰å‘é‡é•¿åº¦ç±»å‹æ—
    let mut vector_length = TypeFamily::new("VectorLength".to_string());
    vector_length.add_parameter("A".to_string(), Type::Base(BaseType::Int));
    
    // æ·»åŠ æ–¹ç¨‹
    vector_length.add_equation(
        IndexType::Nat(0),
        Type::Base(BaseType::Unit)
    );
    vector_length.add_equation(
        IndexType::Nat(1),
        Type::Product(
            Box::new(Type::Base(BaseType::Int)),
            Box::new(Type::Base(BaseType::Unit))
        )
    );
    vector_length.add_equation(
        IndexType::Nat(2),
        Type::Product(
            Box::new(Type::Base(BaseType::Int)),
            Box::new(Type::Product(
                Box::new(Type::Base(BaseType::Int)),
                Box::new(Type::Base(BaseType::Unit))
            ))
        )
    );
    
    env.register_family(vector_length);
    
    // è®¡ç®—ç±»å‹æ—å®ä¾‹
    let length_0 = env.compute_family_application("VectorLength", &IndexType::Nat(0));
    let length_1 = env.compute_family_application("VectorLength", &IndexType::Nat(1));
    let length_2 = env.compute_family_application("VectorLength", &IndexType::Nat(2));
    
    println!("VectorLength(0) = {:?}", length_0);
    println!("VectorLength(1) = {:?}", length_1);
    println!("VectorLength(2) = {:?}", length_2);
}

// ä¾èµ–ç±»å‹æ—ç¤ºä¾‹
fn dependent_type_family_example() {
    let mut inference = TypeFamilyInference::new();
    
    // å®šä¹‰ä¾èµ–ç±»å‹æ—ï¼šFin n -> Type
    let mut fin_family = DependentTypeFamily::new("Fin".to_string());
    
    // æ·»åŠ ä¾èµ–å‚æ•°
    fin_family.add_dependent_parameter(
        "n".to_string(),
        Type::Base(BaseType::Int),
        vec![DependentConstraint {
            condition: IndexType::Bool(true), // n > 0
            constraint: Type::Base(BaseType::Unit),
        }]
    );
    
    // æ·»åŠ æ–¹ç¨‹
    fin_family.add_dependent_equation(
        vec![IndexType::Nat(1)],
        Type::Sum(
            Box::new(Type::Base(BaseType::Unit)),
            Box::new(Type::Base(BaseType::Unit))
        ),
        vec![]
    );
    
    fin_family.add_dependent_equation(
        vec![IndexType::Nat(2)],
        Type::Sum(
            Box::new(Type::Base(BaseType::Unit)),
            Box::new(Type::Sum(
                Box::new(Type::Base(BaseType::Unit)),
                Box::new(Type::Base(BaseType::Unit))
            ))
        ),
        vec![]
    );
    
    inference.register_dependent_family(fin_family);
    
    // è®¡ç®—ä¾èµ–ç±»å‹æ—å®ä¾‹
    let fin_1 = inference.infer_family_instance("Fin", &[IndexType::Nat(1)]);
    let fin_2 = inference.infer_family_instance("Fin", &[IndexType::Nat(2)]);
    
    println!("Fin(1) = {:?}", fin_1);
    println!("Fin(2) = {:?}", fin_2);
}

// ç±»å‹æ—è®¡ç®—ç¤ºä¾‹
fn type_family_calculation_example() {
    let calculator = TypeFamilyCalculator::new();
    
    // è®¡ç®—ç±»å‹æ—åº”ç”¨
    let indices = vec![IndexType::Nat(3), IndexType::Bool(true)];
    let result = calculator.calculate_family_application("TestFamily", &indices);
    println!("TestFamily({:?}) = {:?}", indices, result);
    
    // è®¡ç®—ä¾èµ–ç±»å‹
    let dependent_type = Type::Dependent(
        Box::new(Type::Base(BaseType::Int)),
        Box::new(Type::Base(BaseType::Bool))
    );
    let index = IndexType::Nat(5);
    let result = calculator.calculate_dependent_type(&dependent_type, &index);
    println!("DependentType({:?}) = {:?}", index, result);
    
    // è®¡ç®—ç±»å‹ç­‰ä»·æ€§
    let type1 = Type::Function(
        Box::new(Type::Base(BaseType::Int)),
        Box::new(Type::Base(BaseType::Bool))
    );
    let type2 = Type::Function(
        Box::new(Type::Base(BaseType::Int)),
        Box::new(Type::Base(BaseType::Bool))
    );
    let equal = calculator.calculate_type_equality(&type1, &type2);
    println!("Type equality: {}", equal);
    
    // è®¡ç®—ç±»å‹æ—å®ä¾‹
    let instances = calculator.calculate_family_instances("VectorLength");
    println!("VectorLength instances:");
    for (indices, typ) in instances {
        println!("  {:?} -> {:?}", indices, typ);
    }
    
    // ä¼˜åŒ–è®¡ç®—
    let optimizations = calculator.optimize_family_computation("VectorLength");
    println!("Optimizations:");
    for (key, typ) in optimizations {
        println!("  {} -> {:?}", key, typ);
    }
}

// ç´¢å¼•ç±»å‹è®¡ç®—ç¤ºä¾‹
fn index_type_calculation_example() {
    let calculator = IndexTypeCalculator::new();
    
    // è®¡ç®—ç´¢å¼•ç±»å‹
    let index = IndexType::List(vec![
        IndexType::Nat(1),
        IndexType::Nat(2),
        IndexType::Nat(3)
    ]);
    let computed = calculator.compute_index_type(&index);
    println!("Computed index: {:?}", computed);
    
    // æ£€æŸ¥ç´¢å¼•ç±»å‹æœ‰æ•ˆæ€§
    let valid = calculator.is_valid_index_type(&index);
    println!("Index valid: {}", valid);
    
    // æ¨ç†ç´¢å¼•ç±»å‹
    let inference = TypeFamilyInference::new();
    let inferred = inference.infer_index_type("42");
    println!("Inferred index: {:?}", inferred);
    
    // å¤æ‚ç´¢å¼•ç±»å‹
    let complex_index = IndexType::Product(
        Box::new(IndexType::Nat(5)),
        Box::new(IndexType::Sum(
            Box::new(IndexType::Bool(true)),
            Box::new(IndexType::Bool(false))
        ))
    );
    let computed_complex = calculator.compute_index_type(&complex_index);
    println!("Complex index: {:?}", computed_complex);
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸ä¾èµ–ç±»å‹ç†è®ºçš„å…³ç³»

ç±»å‹æ—ä¸ä¾èµ–ç±»å‹ç†è®ºçš„å…³ç³»ï¼š

1. **ä¾èµ–ç±»å‹**ï¼šç±»å‹æ—æ˜¯ä¾èµ–ç±»å‹çš„ç‰¹ä¾‹
2. **ç±»å‹è®¡ç®—**ï¼šç±»å‹æ—æä¾›ç±»å‹è®¡ç®—æœºåˆ¶
3. **ç±»å‹æ¨ç†**ï¼šç±»å‹æ—æ”¯æŒç±»å‹æ¨ç†
4. **ç±»å‹å®‰å…¨**ï¼šç±»å‹æ—ä¿è¯ç±»å‹å®‰å…¨

### 6.2 ä¸ç±»å‹ç³»ç»Ÿç†è®ºçš„å…³ç³»

ç±»å‹æ—ä¸ç±»å‹ç³»ç»Ÿç†è®ºçš„å…³ç³»ï¼š

1. **ç±»å‹æ‰©å±•**ï¼šç±»å‹æ—æ‰©å±•äº†ç±»å‹ç³»ç»Ÿ
2. **ç±»å‹è®¡ç®—**ï¼šç±»å‹æ—æä¾›è¿è¡Œæ—¶ç±»å‹è®¡ç®—
3. **ç±»å‹ç­‰ä»·**ï¼šç±»å‹æ—å®šä¹‰ç±»å‹ç­‰ä»·å…³ç³»
4. **ç±»å‹æ¨ç†**ï¼šç±»å‹æ—æ”¯æŒç±»å‹æ¨ç†

### 6.3 ä¸ç¨‹åºéªŒè¯çš„å…³ç³»

ç±»å‹æ—ä¸ç¨‹åºéªŒè¯çš„å…³ç³»ï¼š

1. **ç¨‹åºè§„èŒƒ**ï¼šç±»å‹æ—ç”¨äºç¨‹åºè§„èŒƒ
2. **ç¨‹åºè¯æ˜**ï¼šç±»å‹æ—æ”¯æŒç¨‹åºè¯æ˜
3. **ç¨‹åºæ­£ç¡®æ€§**ï¼šç±»å‹æ—ä¿è¯ç¨‹åºæ­£ç¡®æ€§
4. **å½¢å¼åŒ–éªŒè¯**ï¼šç±»å‹æ—æ”¯æŒå½¢å¼åŒ–éªŒè¯

## 7. å‚è€ƒæ–‡çŒ®

1. Brady, E. (2013). Idris, a general-purpose dependently typed programming language: Design and implementation. Journal of Functional Programming, 23(5), 552-593.
2. Norell, U. (2007). Towards a practical programming language based on dependent type theory. PhD thesis, Chalmers University of Technology.
3. Coquand, T., & Huet, G. (1988). The calculus of constructions. Information and computation, 76(2-3), 95-120.
4. Martin-LÃ¶f, P. (1984). Intuitionistic type theory. Bibliopolis.
5. Agda Development Team. (2016). The Agda programming language. Available at <http://wiki.portal.chalmers.se/agda>.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [04.1.4 ä¾èµ–ç±»å‹](../04.1.4_ä¾èµ–ç±»å‹.md)
- [04.4.2 ç¨‹åºéªŒè¯](../04.4.2_ç¨‹åºéªŒè¯.md)
- [04.4.3 è§„èŒƒè¯­è¨€](../04.4.3_è§„èŒƒè¯­è¨€.md)
- [04.3.4 å¹¶å‘ç±»å‹](../04.3.4_å¹¶å‘ç±»å‹.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- å“²å­¦ç»´åº¦ï¼šç±»å‹æ—ä½œä¸ºå‚æ•°åŒ–æŠ½è±¡çš„æ•°å­¦åŸºç¡€ï¼›ç´¢å¼•ä¸ç±»å‹çš„å…³ç³»æœ¬è´¨ã€‚
- æ–¹æ³•è®ºç»´åº¦ï¼šç±»å‹æ—çš„è®¾è®¡åŸåˆ™ä¸è¡¨è¾¾èƒ½åŠ›ï¼›ç´¢å¼•ç±»å‹çš„è¯­ä¹‰è§£é‡Šã€‚
- å·¥ç¨‹ç»´åº¦ï¼šç±»å‹æ—åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„åº”ç”¨ï¼›ä¸é¢å‘å¯¹è±¡æ³›å‹çš„å¯¹æ¯”ã€‚
- ç¤¾ä¼šæŠ€æœ¯ç»´åº¦ï¼šç±»å‹æ—å¯¹ç¼–ç¨‹è¯­è¨€è®¾è®¡çš„å½±å“ï¼›é«˜çº§ç±»å‹ç‰¹æ€§çš„æ•™è‚²æŒ‘æˆ˜ã€‚
