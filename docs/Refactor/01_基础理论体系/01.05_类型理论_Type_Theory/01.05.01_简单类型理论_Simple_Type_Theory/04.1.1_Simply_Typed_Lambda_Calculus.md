# 04.1.1 ç®€å•ç±»å‹Î»æ¼”ç®—

## ğŸ“‹ ç›®å½•

- [04.1.1 ç®€å•ç±»å‹Î»æ¼”ç®—](#0411-ç®€å•ç±»å‹Î»æ¼”ç®—)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2 æ ¸å¿ƒç›®æ ‡](#2-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•-1)
  - [3 åŸºæœ¬æ¦‚å¿µ](#3-åŸºæœ¬æ¦‚å¿µ)
    - [3.1 ç®€å•ç±»å‹Î»æ¼”ç®—çš„ç›´è§‚ç†è§£](#31-ç®€å•ç±»å‹Î»æ¼”ç®—çš„ç›´è§‚ç†è§£)
    - [3.2 STLCçš„åŸºæœ¬æ„é€ ](#32-stlcçš„åŸºæœ¬æ„é€ )
  - [4 å½¢å¼åŒ–å®šä¹‰](#4-å½¢å¼åŒ–å®šä¹‰)
    - [4.1 ç±»å‹å®šä¹‰](#41-ç±»å‹å®šä¹‰)
    - [4.2 é¡¹å®šä¹‰](#42-é¡¹å®šä¹‰)
    - [4.3 ç±»å‹ç¯å¢ƒ](#43-ç±»å‹ç¯å¢ƒ)
    - [4.4 ç±»å‹åˆ¤æ–­](#44-ç±»å‹åˆ¤æ–­)
  - [5 å®šç†ä¸è¯æ˜](#5-å®šç†ä¸è¯æ˜)
    - [5.1 ç±»å‹ä¿æŒå®šç†](#51-ç±»å‹ä¿æŒå®šç†)
    - [5.2 ç±»å‹å®‰å…¨å®šç†](#52-ç±»å‹å®‰å…¨å®šç†)
    - [5.3 å¼ºæ­£è§„åŒ–å®šç†](#53-å¼ºæ­£è§„åŒ–å®šç†)
    - [5.4 ä¸»ä½“å½’çº¦å®šç†](#54-ä¸»ä½“å½’çº¦å®šç†)
  - [6 ç±»å‹æ¨å¯¼](#6-ç±»å‹æ¨å¯¼)
    - [6.1 ç±»å‹æ¨å¯¼ç®—æ³•](#61-ç±»å‹æ¨å¯¼ç®—æ³•)
    - [6.2 ç±»å‹æ£€æŸ¥ç®—æ³•](#62-ç±»å‹æ£€æŸ¥ç®—æ³•)
    - [6.3 ç±»å‹æ¨æ–­ç®—æ³•](#63-ç±»å‹æ¨æ–­ç®—æ³•)
  - [7 ä»£ç å®ç°](#7-ä»£ç å®ç°)
    - [7.1 Rust å®ç°](#71-rust-å®ç°)
    - [7.2 Haskell å®ç°](#72-haskell-å®ç°)
  - [8 åº”ç”¨ç¤ºä¾‹](#8-åº”ç”¨ç¤ºä¾‹)
    - [8.1 æ’ç­‰å‡½æ•°](#81-æ’ç­‰å‡½æ•°)
    - [8.2 å‡½æ•°ç»„åˆ](#82-å‡½æ•°ç»„åˆ)
    - [8.3 æŸ¯é‡ŒåŒ–](#83-æŸ¯é‡ŒåŒ–)
  - [9 ç›¸å…³ç†è®º](#9-ç›¸å…³ç†è®º)
    - [9.1 ä¸æ— ç±»å‹Î»æ¼”ç®—çš„å…³ç³»](#91-ä¸æ— ç±»å‹Î»æ¼”ç®—çš„å…³ç³»)
    - [9.2 ä¸é€»è¾‘çš„å…³ç³»](#92-ä¸é€»è¾‘çš„å…³ç³»)
    - [9.3 ä¸ç¼–ç¨‹è¯­è¨€çš„å…³ç³»](#93-ä¸ç¼–ç¨‹è¯­è¨€çš„å…³ç³»)
  - [8. å‚è€ƒæ–‡çŒ®](#8-å‚è€ƒæ–‡çŒ®)
  - [10 æ‰¹åˆ¤æ€§åˆ†æ](#10-æ‰¹åˆ¤æ€§åˆ†æ)

---

## 1 æ¦‚è¿°

ç®€å•ç±»å‹Î»æ¼”ç®—ï¼ˆSimply Typed Lambda Calculus, STLCï¼‰æ˜¯ç±»å‹ç†è®ºçš„åŸºç¡€ï¼Œå®ƒæ‰©å±•äº†æ— ç±»å‹Î»æ¼”ç®—ï¼Œä¸ºæ¯ä¸ªè¡¨è¾¾å¼åˆ†é…ç±»å‹ã€‚STLCåœ¨å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ã€é€»è¾‘å­¦å’Œè®¡ç®—æœºç§‘å­¦ä¸­éƒ½æœ‰é‡è¦åº”ç”¨ã€‚

## 2 æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ç®€å•ç±»å‹Î»æ¼”ç®—çš„ä¸¥æ ¼å½¢å¼åŒ–å®šä¹‰
2. ç ”ç©¶ç±»å‹æ¨å¯¼å’Œç±»å‹æ£€æŸ¥ç®—æ³•
3. æ¢è®¨ç±»å‹å®‰å…¨å’Œç±»å‹ä¿æŒæ€§è´¨
4. åˆ†æSTLCçš„è¯­ä¹‰å’Œæ¨¡å‹
5. æä¾›å®Œæ•´çš„ä»£ç å®ç°

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ç±»å‹æ¨å¯¼](#4-ç±»å‹æ¨å¯¼)
5. [ä»£ç å®ç°](#5-ä»£ç å®ç°)
6. [åº”ç”¨ç¤ºä¾‹](#6-åº”ç”¨ç¤ºä¾‹)
7. [ç›¸å…³ç†è®º](#7-ç›¸å…³ç†è®º)
8. [å‚è€ƒæ–‡çŒ®](#8-å‚è€ƒæ–‡çŒ®)

## 3 åŸºæœ¬æ¦‚å¿µ

### 3.1 ç®€å•ç±»å‹Î»æ¼”ç®—çš„ç›´è§‚ç†è§£

ç®€å•ç±»å‹Î»æ¼”ç®—æ˜¯ä¸ºÎ»æ¼”ç®—æ·»åŠ ç±»å‹ç³»ç»Ÿçš„ç†è®ºï¼Œæ¯ä¸ªè¡¨è¾¾å¼éƒ½æœ‰æ˜ç¡®çš„ç±»å‹ï¼Œç±»å‹ç³»ç»Ÿç¡®ä¿ç¨‹åºçš„ç±»å‹å®‰å…¨æ€§ã€‚

**åŸºæœ¬ç±»å‹**ï¼š

- åŸºæœ¬ç±»å‹ï¼ˆå¦‚ `int`, `bool`ï¼‰
- å‡½æ•°ç±»å‹ï¼ˆå¦‚ `int â†’ bool`ï¼‰
- ç±»å‹å˜é‡ï¼ˆç”¨äºå¤šæ€æ€§ï¼‰

### 3.2 STLCçš„åŸºæœ¬æ„é€ 

1. **å˜é‡**ï¼š$x : \tau$
2. **æŠ½è±¡**ï¼š$\lambda x : \tau. M$
3. **åº”ç”¨**ï¼š$M N$
4. **ç±»å‹æ³¨è§£**ï¼šæ˜¾å¼ç±»å‹ä¿¡æ¯

## 4 å½¢å¼åŒ–å®šä¹‰

### 4.1 ç±»å‹å®šä¹‰

**å®šä¹‰ 2.1.1** (ç±»å‹)
ç±»å‹é›†åˆ $\mathcal{T}$ ç”±ä»¥ä¸‹è§„åˆ™å®šä¹‰ï¼š

1. **åŸºæœ¬ç±»å‹**ï¼šå¦‚æœ $\iota$ æ˜¯åŸºæœ¬ç±»å‹ï¼Œåˆ™ $\iota \in \mathcal{T}$
2. **å‡½æ•°ç±»å‹**ï¼šå¦‚æœ $\tau, \sigma \in \mathcal{T}$ï¼Œåˆ™ $\tau \to \sigma \in \mathcal{T}$
3. **ç±»å‹å˜é‡**ï¼šå¦‚æœ $\alpha$ æ˜¯ç±»å‹å˜é‡ï¼Œåˆ™ $\alpha \in \mathcal{T}$

### 4.2 é¡¹å®šä¹‰

**å®šä¹‰ 2.1.2** (é¡¹)
é¡¹é›†åˆ $\Lambda^\to$ ç”±ä»¥ä¸‹è§„åˆ™å®šä¹‰ï¼š

1. **å˜é‡**ï¼šå¦‚æœ $x$ æ˜¯å˜é‡ï¼Œ$\tau$ æ˜¯ç±»å‹ï¼Œåˆ™ $x^\tau \in \Lambda^\to$
2. **æŠ½è±¡**ï¼šå¦‚æœ $x$ æ˜¯å˜é‡ï¼Œ$\tau$ æ˜¯ç±»å‹ï¼Œ$M \in \Lambda^\to$ï¼Œåˆ™ $\lambda x : \tau. M \in \Lambda^\to$
3. **åº”ç”¨**ï¼šå¦‚æœ $M, N \in \Lambda^\to$ï¼Œåˆ™ $M N \in \Lambda^\to$

### 4.3 ç±»å‹ç¯å¢ƒ

**å®šä¹‰ 2.1.3** (ç±»å‹ç¯å¢ƒ)
ç±»å‹ç¯å¢ƒ $\Gamma$ æ˜¯å˜é‡åˆ°ç±»å‹çš„æœ‰é™æ˜ å°„ï¼š
$$\Gamma : \text{Var} \to \mathcal{T}$$

### 4.4 ç±»å‹åˆ¤æ–­

**å®šä¹‰ 2.1.4** (ç±»å‹åˆ¤æ–­)
ç±»å‹åˆ¤æ–­ $\Gamma \vdash M : \tau$ ç”±ä»¥ä¸‹è§„åˆ™å®šä¹‰ï¼š

**å˜é‡è§„åˆ™**ï¼š
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau}$$

**æŠ½è±¡è§„åˆ™**ï¼š
$$\frac{\Gamma, x : \tau \vdash M : \sigma}{\Gamma \vdash \lambda x : \tau. M : \tau \to \sigma}$$

**åº”ç”¨è§„åˆ™**ï¼š
$$\frac{\Gamma \vdash M : \tau \to \sigma \quad \Gamma \vdash N : \tau}{\Gamma \vdash M N : \sigma}$$

## 5 å®šç†ä¸è¯æ˜

### 5.1 ç±»å‹ä¿æŒå®šç†

**å®šç† 3.1.1** (ç±»å‹ä¿æŒ)
å¦‚æœ $\Gamma \vdash M : \tau$ ä¸” $M \to_\beta N$ï¼Œåˆ™ $\Gamma \vdash N : \tau$ã€‚

**è¯æ˜**ï¼š
å¯¹å½’çº¦æ­¥æ•°è¿›è¡Œå½’çº³ï¼š

- åŸºç¡€æƒ…å†µï¼š$M = N$ï¼Œæ˜¾ç„¶æˆç«‹
- å½’çº³æ­¥éª¤ï¼šå‡è®¾ $M \to_\beta M' \to_\beta N$ï¼Œç”±å½’çº³å‡è®¾ $\Gamma \vdash M' : \tau$ï¼Œå†ç”±ç±»å‹ä¿æŒæ€§å¾— $\Gamma \vdash N : \tau$

### 5.2 ç±»å‹å®‰å…¨å®šç†

**å®šç† 3.2.1** (ç±»å‹å®‰å…¨)
å¦‚æœ $\Gamma \vdash M : \tau$ï¼Œåˆ™ $M$ ä¸ä¼šäº§ç”Ÿç±»å‹é”™è¯¯ã€‚

**è¯æ˜**ï¼š
é€šè¿‡ç±»å‹ä¿æŒå®šç†å’Œå¼ºæ­£è§„åŒ–å®šç†ï¼Œç±»å‹è‰¯å¥½çš„é¡¹ä¸ä¼šäº§ç”Ÿè¿è¡Œæ—¶ç±»å‹é”™è¯¯ã€‚

### 5.3 å¼ºæ­£è§„åŒ–å®šç†

**å®šç† 3.3.1** (å¼ºæ­£è§„åŒ–)
å¦‚æœ $\Gamma \vdash M : \tau$ï¼Œåˆ™ $M$ å¼ºæ­£è§„åŒ–ã€‚

**è¯æ˜**ï¼š
é€šè¿‡å¯çº¦æ€§ï¼ˆreducibilityï¼‰æ–¹æ³•è¯æ˜ï¼Œæ¯ä¸ªç±»å‹è‰¯å¥½çš„é¡¹éƒ½æœ‰æœ‰é™é•¿åº¦çš„å½’çº¦åºåˆ—ã€‚

### 5.4 ä¸»ä½“å½’çº¦å®šç†

**å®šç† 3.4.1** (ä¸»ä½“å½’çº¦)
å¦‚æœ $\Gamma \vdash M : \tau$ ä¸” $M$ æœ‰å½’çº¦ï¼Œåˆ™å­˜åœ¨ä¸»ä½“å½’çº¦ã€‚

**è¯æ˜**ï¼š
é€šè¿‡å½’çº³æ³•è¯æ˜ï¼Œæ¯ä¸ªå¯å½’çº¦çš„é¡¹éƒ½æœ‰ä¸»ä½“å½’çº¦è·¯å¾„ã€‚

## 6 ç±»å‹æ¨å¯¼

### 6.1 ç±»å‹æ¨å¯¼ç®—æ³•

**ç®—æ³• 4.1.1** (ç±»å‹æ¨å¯¼)
ç»™å®šé¡¹ $M$ å’Œç±»å‹ç¯å¢ƒ $\Gamma$ï¼Œè®¡ç®— $M$ çš„ç±»å‹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ã€‚

**è¾“å…¥**ï¼šé¡¹ $M$ï¼Œç±»å‹ç¯å¢ƒ $\Gamma$
**è¾“å‡º**ï¼šç±»å‹ $\tau$ æˆ–å¤±è´¥

**ç®—æ³•æ­¥éª¤**ï¼š

1. å¦‚æœ $M = x$ï¼Œè¿”å› $\Gamma(x)$
2. å¦‚æœ $M = \lambda x : \tau. N$ï¼Œé€’å½’è®¡ç®— $\Gamma, x : \tau \vdash N : \sigma$ï¼Œè¿”å› $\tau \to \sigma$
3. å¦‚æœ $M = N P$ï¼Œé€’å½’è®¡ç®— $\Gamma \vdash N : \tau$ å’Œ $\Gamma \vdash P : \sigma$ï¼Œæ£€æŸ¥ $\tau = \sigma \to \rho$ï¼Œè¿”å› $\rho$

### 6.2 ç±»å‹æ£€æŸ¥ç®—æ³•

**ç®—æ³• 4.1.2** (ç±»å‹æ£€æŸ¥)
ç»™å®šé¡¹ $M$ã€ç±»å‹ $\tau$ å’Œç±»å‹ç¯å¢ƒ $\Gamma$ï¼Œæ£€æŸ¥ $\Gamma \vdash M : \tau$ æ˜¯å¦æˆç«‹ã€‚

**è¾“å…¥**ï¼šé¡¹ $M$ï¼Œç±»å‹ $\tau$ï¼Œç±»å‹ç¯å¢ƒ $\Gamma$
**è¾“å‡º**ï¼šçœŸæˆ–å‡

**ç®—æ³•æ­¥éª¤**ï¼š

1. æ¨å¯¼ $M$ çš„ç±»å‹ $\sigma$
2. æ£€æŸ¥ $\tau$ å’Œ $\sigma$ æ˜¯å¦ä¸€è‡´

### 6.3 ç±»å‹æ¨æ–­ç®—æ³•

**ç®—æ³• 4.1.3** (ç±»å‹æ¨æ–­)
ç»™å®šé¡¹ $M$ï¼Œæ¨æ–­æœ€ä¸€èˆ¬çš„ç±»å‹ã€‚

**è¾“å…¥**ï¼šé¡¹ $M$
**è¾“å‡º**ï¼šæœ€ä¸€èˆ¬ç±»å‹ $\tau$

**ç®—æ³•æ­¥éª¤**ï¼š

1. ä¸ºæ¯ä¸ªå˜é‡åˆ†é…ç±»å‹å˜é‡
2. ç”Ÿæˆç±»å‹çº¦æŸ
3. æ±‚è§£ç±»å‹çº¦æŸ
4. è¿”å›æœ€ä¸€èˆ¬è§£

## 7 ä»£ç å®ç°

### 7.1 Rust å®ç°

```rust
use std::collections::HashMap;
use std::fmt;

/// ç±»å‹å®šä¹‰
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    Base(String),
    Function(Box<Type>, Box<Type>),
    Variable(String),
}

impl Type {
    pub fn base(name: &str) -> Self {
        Type::Base(name.to_string())
    }

    pub fn function(domain: Type, codomain: Type) -> Self {
        Type::Function(Box::new(domain), Box::new(codomain))
    }

    pub fn variable(name: &str) -> Self {
        Type::Variable(name.to_string())
    }

    pub fn substitute(&self, var: &str, ty: &Type) -> Type {
        match self {
            Type::Base(_) => self.clone(),
            Type::Variable(name) if name == var => ty.clone(),
            Type::Variable(_) => self.clone(),
            Type::Function(domain, codomain) => Type::Function(
                Box::new(domain.substitute(var, ty)),
                Box::new(codomain.substitute(var, ty))
            ),
        }
    }

    pub fn unify(&self, other: &Type) -> Option<HashMap<String, Type>> {
        match (self, other) {
            (Type::Base(a), Type::Base(b)) if a == b => Some(HashMap::new()),
            (Type::Variable(var), ty) | (ty, Type::Variable(var)) => {
                let mut substitution = HashMap::new();
                substitution.insert(var.clone(), ty.clone());
                Some(substitution)
            }
            (Type::Function(dom1, cod1), Type::Function(dom2, cod2)) => {
                let dom_subst = dom1.unify(dom2)?;
                let cod_subst = cod1.substitute_all(&dom_subst).unify(&cod2.substitute_all(&dom_subst))?;
                Some(dom_subst.merge(cod_subst))
            }
            _ => None,
        }
    }

    pub fn substitute_all(&self, substitution: &HashMap<String, Type>) -> Type {
        match self {
            Type::Base(_) => self.clone(),
            Type::Variable(var) => substitution.get(var).cloned().unwrap_or(self.clone()),
            Type::Function(domain, codomain) => Type::Function(
                Box::new(domain.substitute_all(substitution)),
                Box::new(codomain.substitute_all(substitution))
            ),
        }
    }
}

/// é¡¹å®šä¹‰
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum Term {
    Variable(String),
    Abstraction(String, Type, Box<Term>),
    Application(Box<Term>, Box<Term>),
}

impl Term {
    pub fn variable(name: &str) -> Self {
        Term::Variable(name.to_string())
    }

    pub fn abstraction(var: &str, ty: Type, body: Term) -> Self {
        Term::Abstraction(var.to_string(), ty, Box::new(body))
    }

    pub fn application(func: Term, arg: Term) -> Self {
        Term::Application(Box::new(func), Box::new(arg))
    }

    pub fn free_variables(&self) -> Vec<String> {
        match self {
            Term::Variable(var) => vec![var.clone()],
            Term::Abstraction(var, _, body) => {
                let mut fv = body.free_variables();
                fv.retain(|v| v != var);
                fv
            }
            Term::Application(func, arg) => {
                let mut fv = func.free_variables();
                fv.extend(arg.free_variables());
                fv.sort();
                fv.dedup();
                fv
            }
        }
    }

    pub fn substitute(&self, var: &str, term: &Term) -> Term {
        match self {
            Term::Variable(name) if name == var => term.clone(),
            Term::Variable(_) => self.clone(),
            Term::Abstraction(name, ty, body) => {
                if name == var {
                    Term::Abstraction(name.clone(), ty.clone(), body.clone())
                } else {
                    let new_body = body.substitute(var, term);
                    Term::Abstraction(name.clone(), ty.clone(), Box::new(new_body))
                }
            }
            Term::Application(func, arg) => Term::Application(
                Box::new(func.substitute(var, term)),
                Box::new(arg.substitute(var, term))
            ),
        }
    }

    pub fn beta_reduce(&self) -> Option<Term> {
        match self {
            Term::Application(func, arg) => {
                if let Term::Abstraction(var, _, body) = func.as_ref() {
                    Some(body.substitute(var, arg))
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    pub fn normalize(&self) -> Term {
        let mut current = self.clone();
        while let Some(next) = current.beta_reduce() {
            current = next;
        }
        current
    }
}

/// ç±»å‹ç¯å¢ƒ
pub type TypeEnvironment = HashMap<String, Type>;

/// ç±»å‹æ¨å¯¼å™¨
pub struct TypeChecker {
    environment: TypeEnvironment,
}

impl TypeChecker {
    pub fn new() -> Self {
        Self {
            environment: HashMap::new(),
        }
    }

    pub fn with_environment(env: TypeEnvironment) -> Self {
        Self { environment: env }
    }

    pub fn add_binding(&mut self, var: &str, ty: Type) {
        self.environment.insert(var.to_string(), ty);
    }

    pub fn type_check(&self, term: &Term) -> Result<Type, String> {
        match term {
            Term::Variable(var) => {
                self.environment.get(var)
                    .cloned()
                    .ok_or_else(|| format!("æœªç»‘å®šçš„å˜é‡: {}", var))
            }
            Term::Abstraction(var, param_type, body) => {
                let mut new_env = self.environment.clone();
                new_env.insert(var.clone(), param_type.clone());
                let body_type = TypeChecker::with_environment(new_env).type_check(body)?;
                Ok(Type::function(param_type.clone(), body_type))
            }
            Term::Application(func, arg) => {
                let func_type = self.type_check(func)?;
                let arg_type = self.type_check(arg)?;

                match func_type {
                    Type::Function(domain, codomain) => {
                        if domain.as_ref() == &arg_type {
                            Ok(*codomain)
                        } else {
                            Err(format!("ç±»å‹ä¸åŒ¹é…: æœŸæœ› {}, å¾—åˆ° {}", domain.as_ref(), arg_type))
                        }
                    }
                    _ => Err(format!("éå‡½æ•°ç±»å‹: {}", func_type)),
                }
            }
        }
    }

    pub fn type_infer(&self, term: &Term) -> Result<Type, String> {
        // ç®€åŒ–å®ç°ï¼šä½¿ç”¨ç±»å‹æ£€æŸ¥
        self.type_check(term)
    }
}

/// ç±»å‹æ¨å¯¼å™¨ï¼ˆå¸¦ç±»å‹å˜é‡ï¼‰
pub struct TypeInferrer {
    environment: TypeEnvironment,
    type_vars: HashMap<String, Type>,
    counter: u32,
}

impl TypeInferrer {
    pub fn new() -> Self {
        Self {
            environment: HashMap::new(),
            type_vars: HashMap::new(),
            counter: 0,
        }
    }

    pub fn fresh_type_var(&mut self) -> Type {
        let name = format!("Î±{}", self.counter);
        self.counter += 1;
        Type::Variable(name)
    }

    pub fn infer(&mut self, term: &Term) -> Result<Type, String> {
        match term {
            Term::Variable(var) => {
                self.environment.get(var)
                    .cloned()
                    .ok_or_else(|| format!("æœªç»‘å®šçš„å˜é‡: {}", var))
            }
            Term::Abstraction(var, param_type, body) => {
                let mut new_env = self.environment.clone();
                new_env.insert(var.clone(), param_type.clone());
                let body_type = {
                    let mut inferrer = TypeInferrer::new();
                    inferrer.environment = new_env;
                    inferrer.infer(body)?
                };
                Ok(Type::function(param_type.clone(), body_type))
            }
            Term::Application(func, arg) => {
                let func_type = self.infer(func)?;
                let arg_type = self.infer(arg)?;

                let result_type = self.fresh_type_var();
                let expected_func_type = Type::function(arg_type, result_type.clone());

                if let Some(substitution) = func_type.unify(&expected_func_type) {
                    Ok(result_type.substitute_all(&substitution))
                } else {
                    Err(format!("ç±»å‹ä¸åŒ¹é…: æ— æ³•ç»Ÿä¸€ {} å’Œ {}", func_type, expected_func_type))
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_type_checking() {
        let mut checker = TypeChecker::new();
        checker.add_binding("x", Type::base("int"));

        // æ£€æŸ¥å˜é‡
        let var = Term::variable("x");
        assert_eq!(checker.type_check(&var), Ok(Type::base("int")));

        // æ£€æŸ¥æŠ½è±¡
        let abs = Term::abstraction("y", Type::base("bool"), Term::variable("y"));
        assert_eq!(checker.type_check(&abs), Ok(Type::function(Type::base("bool"), Type::base("bool"))));

        // æ£€æŸ¥åº”ç”¨
        let app = Term::application(
            Term::abstraction("z", Type::base("int"), Term::variable("z")),
            Term::variable("x")
        );
        assert_eq!(checker.type_check(&app), Ok(Type::base("int")));
    }

    #[test]
    fn test_beta_reduction() {
        // (Î»x:int. x) 5
        let term = Term::application(
            Term::abstraction("x", Type::base("int"), Term::variable("x")),
            Term::variable("5")
        );

        let reduced = term.beta_reduce();
        assert!(reduced.is_some());
        assert_eq!(reduced.unwrap(), Term::variable("5"));
    }

    #[test]
    fn test_type_inference() {
        let mut inferrer = TypeInferrer::new();

        // æ¨æ–­æ’ç­‰å‡½æ•°ç±»å‹
        let id = Term::abstraction("x", Type::variable("Î±"), Term::variable("x"));
        let inferred_type = inferrer.infer(&id);
        assert!(inferred_type.is_ok());

        // æ¨æ–­åº”ç”¨ç±»å‹
        let app = Term::application(id, Term::variable("y"));
        let app_type = inferrer.infer(&app);
        assert!(app_type.is_ok());
    }
}
```

### 7.2 Haskell å®ç°

```haskell
module SimplyTypedLambdaCalculus where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Maybe (fromJust)
import Data.List (nub)

-- ç±»å‹å®šä¹‰
data Type = Base String
          | Function Type Type
          | TypeVar String
          deriving (Eq, Show)

-- é¡¹å®šä¹‰
data Term = Variable String
          | Abstraction String Type Term
          | Application Term Term
          deriving (Eq, Show)

-- ç±»å‹ç¯å¢ƒ
type TypeEnvironment = Map String Type

-- ç±»å‹æ›¿æ¢
type Substitution = Map String Type

-- åˆ›å»ºåŸºæœ¬ç±»å‹
baseType :: String -> Type
baseType = Base

-- åˆ›å»ºå‡½æ•°ç±»å‹
functionType :: Type -> Type -> Type
functionType = Function

-- åˆ›å»ºç±»å‹å˜é‡
typeVar :: String -> Type
typeVar = TypeVar

-- åˆ›å»ºå˜é‡é¡¹
var :: String -> Term
var = Variable

-- åˆ›å»ºæŠ½è±¡é¡¹
abs :: String -> Type -> Term -> Term
abs = Abstraction

-- åˆ›å»ºåº”ç”¨é¡¹
app :: Term -> Term -> Term
app = Application

-- ç±»å‹æ›¿æ¢
substitute :: Type -> String -> Type -> Type
substitute (Base name) var ty = Base name
substitute (TypeVar name) var ty =
    if name == var then ty else TypeVar name
substitute (Function dom cod) var ty =
    Function (substitute dom var ty) (substitute cod var ty)

-- ç±»å‹ç»Ÿä¸€
unify :: Type -> Type -> Maybe Substitution
unify (Base a) (Base b) =
    if a == b then Just Map.empty else Nothing
unify (TypeVar var) ty =
    Just (Map.singleton var ty)
unify ty (TypeVar var) =
    Just (Map.singleton var ty)
unify (Function dom1 cod1) (Function dom2 cod2) = do
    subst1 <- unify dom1 dom2
    let cod1' = applySubstitution cod1 subst1
        cod2' = applySubstitution cod2 subst1
    subst2 <- unify cod1' cod2'
    return (composeSubstitutions subst1 subst2)
unify _ _ = Nothing

-- åº”ç”¨æ›¿æ¢
applySubstitution :: Type -> Substitution -> Type
applySubstitution ty subst =
    Map.foldrWithKey substitute ty subst

-- ç»„åˆæ›¿æ¢
composeSubstitutions :: Substitution -> Substitution -> Substitution
composeSubstitutions subst1 subst2 =
    Map.union (Map.map (flip applySubstitution subst2) subst1) subst2

-- ç±»å‹æ£€æŸ¥å™¨
data TypeChecker = TypeChecker {
    environment :: TypeEnvironment
}

-- åˆ›å»ºç±»å‹æ£€æŸ¥å™¨
createTypeChecker :: TypeChecker
createTypeChecker = TypeChecker Map.empty

-- æ·»åŠ ç»‘å®š
addBinding :: String -> Type -> TypeChecker -> TypeChecker
addBinding var ty checker =
    checker { environment = Map.insert var ty (environment checker) }

-- ç±»å‹æ£€æŸ¥
typeCheck :: TypeChecker -> Term -> Either String Type
typeCheck checker term = case term of
    Variable var ->
        case Map.lookup var (environment checker) of
            Just ty -> Right ty
            Nothing -> Left ("æœªç»‘å®šçš„å˜é‡: " ++ var)

    Abstraction var paramType body -> do
        let newEnv = Map.insert var paramType (environment checker)
        bodyType <- typeCheck (checker { environment = newEnv }) body
        return (Function paramType bodyType)

    Application func arg -> do
        funcType <- typeCheck checker func
        argType <- typeCheck checker arg
        case funcType of
            Function domain codomain ->
                if domain == argType
                then return codomain
                else Left ("ç±»å‹ä¸åŒ¹é…: æœŸæœ› " ++ show domain ++ ", å¾—åˆ° " ++ show argType)
            _ -> Left ("éå‡½æ•°ç±»å‹: " ++ show funcType)

-- ç±»å‹æ¨æ–­å™¨
data TypeInferrer = TypeInferrer {
    inferEnvironment :: TypeEnvironment,
    typeVarCounter :: Int
}

-- åˆ›å»ºç±»å‹æ¨æ–­å™¨
createTypeInferrer :: TypeInferrer
createTypeInferrer = TypeInferrer Map.empty 0

-- ç”Ÿæˆæ–°çš„ç±»å‹å˜é‡
freshTypeVar :: TypeInferrer -> (Type, TypeInferrer)
freshTypeVar inferrer =
    let var = TypeVar ("Î±" ++ show (typeVarCounter inferrer))
        newInferrer = inferrer { typeVarCounter = typeVarCounter inferrer + 1 }
    in (var, newInferrer)

-- ç±»å‹æ¨æ–­
typeInfer :: TypeInferrer -> Term -> Either String (Type, TypeInferrer)
typeInfer inferrer term = case term of
    Variable var ->
        case Map.lookup var (inferEnvironment inferrer) of
            Just ty -> Right (ty, inferrer)
            Nothing -> Left ("æœªç»‘å®šçš„å˜é‡: " ++ var)

    Abstraction var paramType body -> do
        let newEnv = Map.insert var paramType (inferEnvironment inferrer)
        (bodyType, newInferrer) <- typeInfer (inferrer { inferEnvironment = newEnv }) body
        return (Function paramType bodyType, newInferrer)

    Application func arg -> do
        (funcType, inferrer1) <- typeInfer inferrer func
        (argType, inferrer2) <- typeInfer inferrer1 arg
        (resultType, inferrer3) <- freshTypeVar inferrer2
        let expectedFuncType = Function argType resultType
        case unify funcType expectedFuncType of
            Just subst ->
                let finalType = applySubstitution resultType subst
                in return (finalType, inferrer3)
            Nothing ->
                Left ("ç±»å‹ä¸åŒ¹é…: æ— æ³•ç»Ÿä¸€ " ++ show funcType ++ " å’Œ " ++ show expectedFuncType)

-- è‡ªç”±å˜é‡
freeVariables :: Term -> [String]
freeVariables term = case term of
    Variable var -> [var]
    Abstraction var _ body ->
        filter (/= var) (freeVariables body)
    Application func arg ->
        nub (freeVariables func ++ freeVariables arg)

-- æ›¿æ¢
substitute :: Term -> String -> Term -> Term
substitute (Variable var) var' term =
    if var == var' then term else Variable var
substitute (Abstraction var ty body) var' term =
    if var == var'
    then Abstraction var ty body
    else Abstraction var ty (substitute body var' term)
substitute (Application func arg) var term =
    Application (substitute func var term) (substitute arg var term)

-- Î²å½’çº¦
betaReduce :: Term -> Maybe Term
betaReduce term = case term of
    Application (Abstraction var _ body) arg ->
        Just (substitute body var arg)
    _ -> Nothing

-- æ­£è§„åŒ–
normalize :: Term -> Term
normalize term =
    case betaReduce term of
        Just reduced -> normalize reduced
        Nothing -> term

-- ç¤ºä¾‹å‡½æ•°
exampleIdentity :: Term
exampleIdentity = abs "x" (typeVar "Î±") (var "x")

exampleApplication :: Term
exampleApplication = app exampleIdentity (var "y")

exampleComposition :: Term
exampleComposition = abs "f" (functionType (typeVar "Î±") (typeVar "Î²")) $
                     abs "g" (functionType (typeVar "Î²") (typeVar "Î³")) $
                     abs "x" (typeVar "Î±") $
                     app (var "f") (app (var "g") (var "x"))

-- æµ‹è¯•å‡½æ•°
testTypeChecking :: Bool
testTypeChecking =
    let checker = createTypeChecker
        result = typeCheck checker exampleIdentity
    in case result of
        Right (Function (TypeVar _) (TypeVar _)) -> True
        _ -> False

testTypeInference :: Bool
testTypeInference =
    let inferrer = createTypeInferrer
        result = typeInfer inferrer exampleApplication
    in case result of
        Right (_, _) -> True
        _ -> False

testBetaReduction :: Bool
testBetaReduction =
    let app = Application exampleIdentity (Variable "z")
        reduced = betaReduce app
    in case reduced of
        Just (Variable "z") -> True
        _ -> False

-- ç±»å‹æ¨å¯¼ç¤ºä¾‹
typeInferenceExample :: IO ()
typeInferenceExample = do
    let inferrer = createTypeInferrer
        result = typeInfer inferrer exampleIdentity
    case result of
        Right (ty, _) -> putStrLn ("æ¨æ–­ç±»å‹: " ++ show ty)
        Left err -> putStrLn ("é”™è¯¯: " ++ err)

-- å½’çº¦ç¤ºä¾‹
reductionExample :: IO ()
reductionExample = do
    let app = Application exampleIdentity (Variable "5")
        normal = normalize app
    putStrLn ("å½’çº¦ç»“æœ: " ++ show normal)
```

## 8 åº”ç”¨ç¤ºä¾‹

### 8.1 æ’ç­‰å‡½æ•°

**ç¤ºä¾‹ 6.1.1** (æ’ç­‰å‡½æ•°)
$$\lambda x : \alpha. x : \alpha \to \alpha$$

è¿™ä¸ªå‡½æ•°æ¥å—ä»»æ„ç±»å‹çš„å‚æ•°å¹¶è¿”å›ç›¸åŒçš„å€¼ã€‚

### 8.2 å‡½æ•°ç»„åˆ

**ç¤ºä¾‹ 6.1.2** (å‡½æ•°ç»„åˆ)
$$(\lambda f : \alpha \to \beta. \lambda g : \beta \to \gamma. \lambda x : \alpha. f(g(x))) : (\alpha \to \beta) \to (\beta \to \gamma) \to (\alpha \to \gamma)$$

è¿™ä¸ªå‡½æ•°å®ç°äº†å‡½æ•°çš„ç»„åˆæ“ä½œã€‚

### 8.3 æŸ¯é‡ŒåŒ–

**ç¤ºä¾‹ 6.1.3** (æŸ¯é‡ŒåŒ–)
$$(\lambda x : \alpha. \lambda y : \beta. x) : \alpha \to \beta \to \alpha$$

è¿™ä¸ªå‡½æ•°å±•ç¤ºäº†æŸ¯é‡ŒåŒ–çš„æ¦‚å¿µã€‚

## 9 ç›¸å…³ç†è®º

### 9.1 ä¸æ— ç±»å‹Î»æ¼”ç®—çš„å…³ç³»

STLCæ˜¯UTLCçš„ç±»å‹åŒ–æ‰©å±•ï¼Œä¿æŒäº†UTLCçš„è®¡ç®—æ€§è´¨ã€‚

### 9.2 ä¸é€»è¾‘çš„å…³ç³»

STLCä¸ç›´è§‰ä¸»ä¹‰é€»è¾‘çš„è•´æ¶µç‰‡æ®µå¯¹åº”ï¼Œè¿™æ˜¯Curry-HowardåŒæ„çš„åŸºç¡€ã€‚

### 9.3 ä¸ç¼–ç¨‹è¯­è¨€çš„å…³ç³»

STLCæ˜¯å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»Ÿçš„åŸºç¡€ï¼Œå¦‚Haskellã€MLç­‰ã€‚

## 8. å‚è€ƒæ–‡çŒ®

1. Pierce, B. C. (2002). _Types and Programming Languages_. MIT Press.
2. Hindley, J. R., & Seldin, J. P. (2008). _Lambda-Calculus and Combinators: An Introduction_. Cambridge University Press.
3. Barendregt, H. P. (1984). _The Lambda Calculus: Its Syntax and Semantics_. North-Holland.
4. Girard, J. Y., Lafont, Y., & Taylor, P. (1989). _Proofs and Types_. Cambridge University Press.
5. SÃ¸rensen, M. H., & Urzyczyn, P. (2006). _Lectures on the Curry-Howard Isomorphism_. Elsevier.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [04.1.2 ç±»å‹æ¨å¯¼](../04_Type_Theory/04.1.2_ç±»å‹æ¨å¯¼.md)
- [04.1.3 ç±»å‹å®‰å…¨](../04_Type_Theory/04.1.3_ç±»å‹å®‰å…¨.md)
- [04.1.4 ç±»å‹ä¿æŒ](../04_Type_Theory/04.1.4_ç±»å‹ä¿æŒ.md)
- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03_Formal_Language_Theory/03.2.2_ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•.md)
- [02.2.1 å‘½é¢˜é€»è¾‘](../02_Mathematical_Foundation/02.2.1_å‘½é¢˜é€»è¾‘.md)

## 10 æ‰¹åˆ¤æ€§åˆ†æ

- å“²å­¦ç»´åº¦ï¼šÎ»æ¼”ç®—ä½œä¸ºè®¡ç®—æœ¬è´¨çš„åˆ»ç”»ï¼Œä¸å›¾çµæœºçš„ç­‰ä»·æ€§ï¼›ç±»å‹ä½œä¸ºæ„é€ æ€§å­˜åœ¨çš„åŸºç¡€ã€‚
- æ–¹æ³•è®ºç»´åº¦ï¼šç±»å‹æ¨å¯¼çš„ç®—æ³•å¤æ‚æ€§ä¸è¡¨è¾¾èƒ½åŠ›ï¼›Î²å½’çº¦çš„è§„èŒƒåŒ–ä¸è®¡ç®—è¯­ä¹‰ã€‚
- å·¥ç¨‹ç»´åº¦ï¼šSTLCåœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„åŸºç¡€åœ°ä½ï¼›ç±»å‹å®‰å…¨ä¸è¿è¡Œæ—¶æ€§èƒ½çš„æƒè¡¡ã€‚
- ç¤¾ä¼šæŠ€æœ¯ç»´åº¦ï¼šÎ»æ¼”ç®—å¯¹ç¼–ç¨‹è¯­è¨€è®¾è®¡çš„å½±å“ï¼›ç±»å‹ç†è®ºæ•™è‚²çš„æ ‡å‡†åŒ–éœ€æ±‚ã€‚
