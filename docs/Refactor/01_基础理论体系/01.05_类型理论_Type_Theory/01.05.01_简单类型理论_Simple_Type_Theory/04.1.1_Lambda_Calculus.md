# 04.1.1 λ演算基础 (Lambda Calculus)

## 📚 目录

- [04.1.1 λ演算基础 (Lambda Calculus)](#0411-λ演算基础-lambda-calculus)
  - [📚 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1 概述](#1-概述)
  - [2 语法与操作](#2-语法与操作)
  - [3 编码与表达力](#3-编码与表达力)
  - [4 性质](#4-性质)
  - [5 代码片段](#5-代码片段)
  - [参考文献](#参考文献)
  - [6 批判性分析](#6-批判性分析)

## 📋 目录

- [04.1.1 λ演算基础 (Lambda Calculus)](#0411-λ演算基础-lambda-calculus)
  - [📚 目录](#-目录)
  - [📋 目录](#-目录-1)
  - [1 概述](#1-概述)
  - [2 语法与操作](#2-语法与操作)
  - [3 编码与表达力](#3-编码与表达力)
  - [4 性质](#4-性质)
  - [5 代码片段](#5-代码片段)
  - [参考文献](#参考文献)
  - [6 批判性分析](#6-批判性分析)

---

## 1 概述

λ演算是函数抽象与应用的最小计算模型，是可计算性与编程语言语义的共同根基。

## 2 语法与操作

- 语法：`e ::= x | λx.e | e e`
- 绑定/自由变量、替换与α-等价
- 归约：β-约简、η-约简；标准化序（正则序、应用序）

## 3 编码与表达力

- Church 数字、布尔与对、列表
- 原始递归与Y不动点：`Y f = f (Y f)`

## 4 性质

- 丘奇—图灵论题：λ演算与图灵机等价的计算表达力
- 正则序归约的规范化性质（若存在NF则能找到）

## 5 代码片段

```haskell
-- β-归约示例（伪 Haskell 表达 λ 语法）
-- (λx. x) y  ⇓  y
apply :: (a -> a) -> a -> a
apply f x = f x

-- Church 布尔与条件
tRue = \x y -> x
fAlse = \x y -> y
ifte = \b x y -> b x y
```

```haskell
-- Y 组合子（惰性语义下）
Y = \f -> (\x -> f (x x)) (\x -> f (x x))
-- fact = Y (\rec n -> if n==0 then 1 else n * rec (n-1))
```

```rust
// 简易替换骨架（示意）
#[derive(Clone)]
enum Term { Var(String), Lam(String, Box<Term>), App(Box<Term>, Box<Term>) }
```

## 参考文献

1. Barendregt, The Lambda Calculus: Its Syntax and Semantics.
2. Pierce, TAPL.

## 6 批判性分析

- 多元理论视角：
  - 计算与逻辑：λ演算与组合子、SK体系、最小逻辑之间的互译展现“语法即计算”的理念。
  - 代数与范畴：初代数/余代数与CCC语义提供更抽象的解释，连接到现代语义学。
- 局限性分析：
  - 无类型λ演算表达力强但缺乏静态保障；简单类型化后失去一般递归，需要不动点/效应来补齐工程需求。
- 争议与分歧：
  - 惰性/严格、正则序/应用序与工程语义（Haskell/OCaml/Rust）的对应与取舍。
- 应用前景：
  - 作为教材与验证工具的“最小核心”，便于推导到STLC/HM/System F 与依类型理论。
- 改进建议：
  - 提供可执行的归约器与标准化证明草图；补全Church编码到高层类型系统的迁移示例。
