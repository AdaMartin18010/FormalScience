# 04.1.4 System F（多态 λ 演算）

## 📚 目录

- [04.1.4 System F（多态 λ 演算）](#0414-system-f多态-λ-演算)
  - [📚 目录](#-目录)
  - [📋 概述](#-概述)
  - [语法与类型](#语法与类型)
  - [规则（轮廓）](#规则轮廓)
  - [表达力](#表达力)
  - [示例](#示例)
  - [参考文献](#参考文献)
  - [批判性分析](#批判性分析)

## 📋 概述

System F（Girard–Reynolds）在 STLC 上引入显式类型抽象与应用（`Λα. e` / `e [T]`），提供强表达力的参数多态，是类型理论与编译器理论的重要里程碑。

## 语法与类型

- 类型：`T ::= α | T -> T | ∀α. T`
- 项：`e ::= x | λx:T. e | e e | Λα. e | e [T]`

## 规则（轮廓）

- 类型抽象/应用：
  - Gen：`Γ ⊢ e : T  ⇒  Γ ⊢ Λα. e : ∀α. T`（α 不捕获自由）
  - Inst：`Γ ⊢ e : ∀α. T  ⇒  Γ ⊢ e [U] : T[α:=U]`

## 表达力

- 可编码 ADT / Church 编码；高阶多态；折叠/展开（fold/unfold）模式
- 作为多态 IR：便于跨语言/优化的中间表示

## 示例

```haskell
-- 多态恒等与映射（System F 风格伪代码）
-- 类型抽象：Λa. λx:a. x  :  ∀a. a -> a
idF = /\a. \(x :: a) -> x

-- 多态 map：Λa. Λb. λf:a->b. λxs:List a. ... : ∀a.∀b.(a->b)->List a->List b
mapF = /\a. /\b. \(f :: a -> b) ->
  fix (\self -> \(xs :: List a) ->
    case xs of
      Nil        -> Nil
      Cons x xs' -> Cons (f x) (self xs'))

-- 类型应用：idF[Int]  :  Int -> Int
idInt = idF [Int]
```

## 参考文献

- Girard, Reynolds；Pierce TAPL；编译器中间语言文献

## 批判性分析

- 多元理论视角：
  - 强多态表达：显式量化统一抽象与复用；与类型推断/注解策略共同决定工程体验。
  - 语义与实现：与逻辑（第二阶）与范畴（多终对象）有深层对应；在优化与代码生成中充当结构化IR。
- 局限性分析：
  - 推断困难：一般 System F 类型推断不可判定；工程上采用 HM+扩展或注解化子集。
  - 错误可解释性：显式量化对新手不友好，需要范式化风格与IDE 支持。
- 争议与分歧：
  - 显式 vs. 隐式量化的可维护性；与类型类/约束多态、GADTs 的关系与取舍。
- 应用前景：
  - 多态 IR、库抽象与可证明组合；与依类型/效果系统结合提升规格承载。
- 改进建议：
  - 教程化范式（编码 ADT、iterator/visitor 等模式）、调试与错误消息规范；与 HM/依类型的迁移“食谱”。
