# 04.1.2 Hindley-Milnerç±»å‹ç³»ç»Ÿ

## ğŸ“‹ ç›®å½•

- [1 æ¦‚è¿°](#1-æ¦‚è¿°)
- [2 æ ¸å¿ƒç›®æ ‡](#2-æ ¸å¿ƒç›®æ ‡)
- [3 åŸºæœ¬æ¦‚å¿µ](#3-åŸºæœ¬æ¦‚å¿µ)
  - [3.1 Hindley-Milnerç±»å‹ç³»ç»Ÿçš„ç›´è§‚ç†è§£](#31-hindley-milnerç±»å‹ç³»ç»Ÿçš„ç›´è§‚ç†è§£)
  - [3.2 æ ¸å¿ƒç‰¹å¾](#32-æ ¸å¿ƒç‰¹å¾)
  - [3.3 ç±»å‹è¡¨è¾¾å¼](#33-ç±»å‹è¡¨è¾¾å¼)
- [4 å½¢å¼åŒ–å®šä¹‰](#4-å½¢å¼åŒ–å®šä¹‰)
  - [4.1 ç±»å‹ç¯å¢ƒ](#41-ç±»å‹ç¯å¢ƒ)
  - [4.2 ç±»å‹è§„åˆ™](#42-ç±»å‹è§„åˆ™)
  - [4.3 ç±»å‹æ¨æ–­ç®—æ³•](#43-ç±»å‹æ¨æ–­ç®—æ³•)
- [5 å®šç†ä¸è¯æ˜](#5-å®šç†ä¸è¯æ˜)
  - [5.1 ä¸»è¦æ€§è´¨](#51-ä¸»è¦æ€§è´¨)
  - [5.2 ç»Ÿä¸€ç®—æ³•](#52-ç»Ÿä¸€ç®—æ³•)
- [6 ä»£ç å®ç°](#6-ä»£ç å®ç°)
  - [6.1 Rust å®ç°](#61-rust-å®ç°)
  - [6.2 Haskell å®ç°](#62-haskell-å®ç°)
- [7 åº”ç”¨ç¤ºä¾‹](#7-åº”ç”¨ç¤ºä¾‹)
  - [7.1 å¤šæ€å‡½æ•°](#71-å¤šæ€å‡½æ•°)
  - [7.2 é«˜é˜¶å‡½æ•°](#72-é«˜é˜¶å‡½æ•°)
  - [7.3 ç±»å‹ç±»](#73-ç±»å‹ç±»)
- [8 ç›¸å…³ç†è®º](#8-ç›¸å…³ç†è®º)
  - [8.1 ç±»å‹ç³»ç»Ÿ](#81-ç±»å‹ç³»ç»Ÿ)
  - [8.2 ç±»å‹æ¨æ–­](#82-ç±»å‹æ¨æ–­)
  - [8.3 ç¼–ç¨‹è¯­è¨€](#83-ç¼–ç¨‹è¯­è¨€)
- [9 æ‰¹åˆ¤æ€§åˆ†æ](#9-æ‰¹åˆ¤æ€§åˆ†æ)

---

## 1 æ¦‚è¿°

Hindley-Milnerç±»å‹ç³»ç»Ÿæ˜¯ç°ä»£å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€çš„æ ¸å¿ƒç±»å‹ç³»ç»Ÿï¼Œå®ƒç»“åˆäº†å‚æ•°å¤šæ€å’Œç±»å‹æ¨æ–­ï¼Œä¸ºç¼–ç¨‹è¯­è¨€æä¾›äº†å¼ºå¤§çš„ç±»å‹å®‰å…¨ä¿éšœã€‚è¯¥ç³»ç»Ÿç”±Roger Hindleyå’ŒRobin Milnerç‹¬ç«‹å‘ç°ï¼Œæ˜¯MLç³»åˆ—è¯­è¨€ï¼ˆå¦‚Haskellã€OCamlã€F#ï¼‰çš„åŸºç¡€ã€‚

## 2 æ ¸å¿ƒç›®æ ‡

1. **å½¢å¼åŒ–å®šä¹‰**ï¼šæä¾›Hindley-Milnerç±»å‹ç³»ç»Ÿçš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. **ç±»å‹æ¨æ–­**ï¼šå±•ç¤ºç±»å‹æ¨æ–­ç®—æ³•çš„å·¥ä½œåŸç†
3. **å¤šæ€æ€§**ï¼šè§£é‡Šå‚æ•°å¤šæ€çš„æ¦‚å¿µå’Œå®ç°
4. **åº”ç”¨ç¤ºä¾‹**ï¼šå±•ç¤ºåœ¨å®é™…ç¼–ç¨‹ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 3 åŸºæœ¬æ¦‚å¿µ

### 3.1 Hindley-Milnerç±»å‹ç³»ç»Ÿçš„ç›´è§‚ç†è§£

Hindley-Milnerç±»å‹ç³»ç»Ÿå…è®¸ç¨‹åºå‘˜ç¼–å†™å¤šæ€å‡½æ•°ï¼Œè€Œæ— éœ€æ˜¾å¼æŒ‡å®šç±»å‹ã€‚ç³»ç»Ÿèƒ½å¤Ÿè‡ªåŠ¨æ¨æ–­å‡ºæœ€ä¸€èˆ¬çš„ç±»å‹ï¼Œè¿™ç§ç±»å‹æ¨æ–­èƒ½åŠ›ä½¿å¾—ä»£ç æ—¢ç®€æ´åˆç±»å‹å®‰å…¨ã€‚

### 3.2 æ ¸å¿ƒç‰¹å¾

**å®šä¹‰ 1.2.1** (Hindley-Milnerç±»å‹ç³»ç»Ÿç‰¹å¾)

1. **å‚æ•°å¤šæ€**ï¼šç±»å‹å˜é‡å¯ä»¥è¡¨ç¤ºä»»æ„ç±»å‹
2. **ç±»å‹æ¨æ–­**ï¼šèƒ½å¤Ÿè‡ªåŠ¨æ¨æ–­è¡¨è¾¾å¼çš„ç±»å‹
3. **æœ€ä¸€èˆ¬ç±»å‹**ï¼šæ¨æ–­å‡ºçš„ç±»å‹æ˜¯æœ€ä¸€èˆ¬çš„ï¼ˆæœ€é€šç”¨çš„ï¼‰
4. **ç±»å‹å®‰å…¨**ï¼šä¿è¯ç±»å‹æ­£ç¡®çš„ç¨‹åºä¸ä¼šäº§ç”Ÿè¿è¡Œæ—¶ç±»å‹é”™è¯¯

### 3.3 ç±»å‹è¡¨è¾¾å¼

**å®šä¹‰ 1.3.1** (ç±»å‹è¡¨è¾¾å¼)
ç±»å‹è¡¨è¾¾å¼çš„è¯­æ³•å®šä¹‰ä¸ºï¼š
$$\tau ::= \alpha \mid \text{int} \mid \text{bool} \mid \tau_1 \to \tau_2 \mid \forall \alpha. \tau$$
å…¶ä¸­ $\alpha$ æ˜¯ç±»å‹å˜é‡ã€‚

## 4 å½¢å¼åŒ–å®šä¹‰

### 4.1 ç±»å‹ç¯å¢ƒ

**å®šä¹‰ 2.1.1** (ç±»å‹ç¯å¢ƒ)
ç±»å‹ç¯å¢ƒ $\Gamma$ æ˜¯ä¸€ä¸ªä»å˜é‡åˆ°ç±»å‹çš„æ˜ å°„ï¼š
$$\Gamma : \text{Var} \to \text{Type}$$

### 4.2 ç±»å‹è§„åˆ™

**å®šä¹‰ 2.2.1** (ç±»å‹è§„åˆ™)
Hindley-Milnerç±»å‹ç³»ç»Ÿçš„ç±»å‹è§„åˆ™å¦‚ä¸‹ï¼š

1. **å˜é‡è§„åˆ™**ï¼š
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau}$$

2. **åº”ç”¨è§„åˆ™**ï¼š
$$\frac{\Gamma \vdash e_1 : \tau_1 \to \tau_2 \quad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1 e_2 : \tau_2}$$

3. **æŠ½è±¡è§„åˆ™**ï¼š
$$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x. e : \tau_1 \to \tau_2}$$

4. **æ³›åŒ–è§„åˆ™**ï¼š
$$\frac{\Gamma \vdash e : \tau \quad \alpha \notin \text{free}(\Gamma)}{\Gamma \vdash e : \forall \alpha. \tau}$$

5. **å®ä¾‹åŒ–è§„åˆ™**ï¼š
$$\frac{\Gamma \vdash e : \forall \alpha. \tau}{\Gamma \vdash e : \tau[\alpha := \sigma]}$$

### 4.3 ç±»å‹æ¨æ–­ç®—æ³•

**ç®—æ³• 2.3.1** (Wç®—æ³•)
Wç®—æ³•æ˜¯Hindley-Milnerç±»å‹æ¨æ–­çš„æ ¸å¿ƒç®—æ³•ï¼š

1. **å˜é‡**ï¼š$W(\Gamma, x) = (\emptyset, \Gamma(x))$
2. **åº”ç”¨**ï¼š$W(\Gamma, e_1 e_2) = (S_1 \cup S_2 \cup S_3, S_3(\tau_2))$
   å…¶ä¸­ $(S_1, \tau_1) = W(\Gamma, e_1)$ï¼Œ$(S_2, \tau_2) = W(S_1(\Gamma), e_2)$ï¼Œ$S_3 = \text{unify}(\tau_1, \tau_2 \to \alpha)$
3. **æŠ½è±¡**ï¼š$W(\Gamma, \lambda x. e) = (S, S(\tau_1) \to \tau_2)$
   å…¶ä¸­ $(S, \tau_2) = W(\Gamma \cup \{x : \tau_1\}, e)$ï¼Œ$\tau_1$ æ˜¯æ–°çš„ç±»å‹å˜é‡

## 5 å®šç†ä¸è¯æ˜

### 5.1 ä¸»è¦æ€§è´¨

**å®šç† 3.1.1** (ç±»å‹æ¨æ–­çš„å®Œå¤‡æ€§)
å¦‚æœè¡¨è¾¾å¼ $e$ æœ‰ç±»å‹ $\tau$ï¼Œåˆ™Wç®—æ³•èƒ½å¤Ÿæ¨æ–­å‡º $\tau$ çš„æŸä¸ªå®ä¾‹ã€‚

**å®šç† 3.1.2** (æœ€ä¸€èˆ¬ç±»å‹)
Wç®—æ³•æ¨æ–­å‡ºçš„ç±»å‹æ˜¯æœ€ä¸€èˆ¬çš„ç±»å‹ã€‚

**å®šç† 3.1.3** (ç±»å‹å®‰å…¨)
å¦‚æœè¡¨è¾¾å¼é€šè¿‡ç±»å‹æ£€æŸ¥ï¼Œåˆ™å®ƒä¸ä¼šäº§ç”Ÿè¿è¡Œæ—¶ç±»å‹é”™è¯¯ã€‚

### 5.2 ç»Ÿä¸€ç®—æ³•

**ç®—æ³• 3.2.1** (ç»Ÿä¸€ç®—æ³•)
ç»Ÿä¸€ç®—æ³•ç”¨äºæ±‚è§£ç±»å‹çº¦æŸï¼š

```rust
fn unify(Ï„1: Type, Ï„2: Type) -> Result<Substitution, String> {
    match (Ï„1, Ï„2) {
        (Type::Var(Î±), Ï„) | (Ï„, Type::Var(Î±)) => {
            if occurs(Î±, Ï„) {
                Err("Occurs check failed".to_string())
            } else {
                Ok(Substitution::new(Î±, Ï„))
            }
        }
        (Type::Arrow(Ï„1, Ï„2), Type::Arrow(Ï„3, Ï„4)) => {
            let s1 = unify(Ï„1, Ï„3)?;
            let s2 = unify(s1.apply(Ï„2), s1.apply(Ï„4))?;
            Ok(s2.compose(s1))
        }
        (Type::Int, Type::Int) | (Type::Bool, Type::Bool) => {
            Ok(Substitution::empty())
        }
        _ => Err("Cannot unify types".to_string())
    }
}
```

## 6 ä»£ç å®ç°

### 6.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::fmt;

/// è¡¨ç¤ºç±»å‹
#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Var(String),
    Int,
    Bool,
    Arrow(Box<Type>, Box<Type>),
    ForAll(String, Box<Type>),
}

impl Type {
    /// åˆ›å»ºç±»å‹å˜é‡
    pub fn var(name: &str) -> Self {
        Type::Var(name.to_string())
    }
    
    /// åˆ›å»ºå‡½æ•°ç±»å‹
    pub fn arrow(from: Type, to: Type) -> Self {
        Type::Arrow(Box::new(from), Box::new(to))
    }
    
    /// åˆ›å»ºå…¨ç§°ç±»å‹
    pub fn forall(var: &str, body: Type) -> Self {
        Type::ForAll(var.to_string(), Box::new(body))
    }
    
    /// è·å–è‡ªç”±ç±»å‹å˜é‡
    pub fn free_vars(&self) -> HashSet<String> {
        match self {
            Type::Var(name) => {
                let mut vars = HashSet::new();
                vars.insert(name.clone());
                vars
            }
            Type::Int | Type::Bool => HashSet::new(),
            Type::Arrow(from, to) => {
                let mut vars = from.free_vars();
                vars.extend(to.free_vars());
                vars
            }
            Type::ForAll(var, body) => {
                let mut vars = body.free_vars();
                vars.remove(var);
                vars
            }
        }
    }
    
    /// åº”ç”¨æ›¿æ¢
    pub fn apply(&self, substitution: &Substitution) -> Type {
        match self {
            Type::Var(name) => {
                substitution.get(name).unwrap_or(self.clone())
            }
            Type::Int | Type::Bool => self.clone(),
            Type::Arrow(from, to) => {
                Type::Arrow(
                    Box::new(from.apply(substitution)),
                    Box::new(to.apply(substitution))
                )
            }
            Type::ForAll(var, body) => {
                if substitution.contains_key(var) {
                    // é¿å…å˜é‡æ•è·
                    let new_var = format!("{}'", var);
                    let new_body = body.apply(&Substitution::new(var, Type::var(&new_var)));
                    Type::ForAll(new_var, Box::new(new_body.apply(substitution)))
                } else {
                    Type::ForAll(var.clone(), Box::new(body.apply(substitution)))
                }
            }
        }
    }
}

/// è¡¨ç¤ºæ›¿æ¢
#[derive(Debug, Clone)]
pub struct Substitution {
    mapping: HashMap<String, Type>,
}

impl Substitution {
    pub fn new() -> Self {
        Substitution {
            mapping: HashMap::new(),
        }
    }
    
    pub fn with_binding(var: &str, typ: Type) -> Self {
        let mut sub = Substitution::new();
        sub.mapping.insert(var.to_string(), typ);
        sub
    }
    
    pub fn get(&self, var: &str) -> Option<&Type> {
        self.mapping.get(var)
    }
    
    pub fn contains_key(&self, var: &str) -> bool {
        self.mapping.contains_key(var)
    }
    
    pub fn insert(&mut self, var: String, typ: Type) {
        self.mapping.insert(var, typ);
    }
    
    /// ç»„åˆä¸¤ä¸ªæ›¿æ¢
    pub fn compose(&self, other: Substitution) -> Substitution {
        let mut result = Substitution::new();
        
        // åº”ç”¨otheråˆ°selfçš„æ˜ å°„
        for (var, typ) in &self.mapping {
            result.insert(var.clone(), typ.apply(&other));
        }
        
        // æ·»åŠ otherä¸­çš„æ˜ å°„
        for (var, typ) in other.mapping {
            if !result.contains_key(&var) {
                result.insert(var, typ);
            }
        }
        
        result
    }
    
    /// åº”ç”¨æ›¿æ¢åˆ°ç±»å‹ç¯å¢ƒ
    pub fn apply_to_env(&self, env: &TypeEnvironment) -> TypeEnvironment {
        let mut new_env = TypeEnvironment::new();
        for (var, typ) in &env.bindings {
            new_env.bind(var.clone(), typ.apply(self));
        }
        new_env
    }
}

/// è¡¨ç¤ºç±»å‹ç¯å¢ƒ
#[derive(Debug, Clone)]
pub struct TypeEnvironment {
    bindings: HashMap<String, Type>,
}

impl TypeEnvironment {
    pub fn new() -> Self {
        TypeEnvironment {
            bindings: HashMap::new(),
        }
    }
    
    pub fn bind(&mut self, var: String, typ: Type) {
        self.bindings.insert(var, typ);
    }
    
    pub fn lookup(&self, var: &str) -> Option<&Type> {
        self.bindings.get(var)
    }
    
    pub fn extend(&self, var: String, typ: Type) -> TypeEnvironment {
        let mut new_env = self.clone();
        new_env.bind(var, typ);
        new_env
    }
}

/// è¡¨ç¤ºè¡¨è¾¾å¼
#[derive(Debug, Clone)]
pub enum Expression {
    Var(String),
    Int(i32),
    Bool(bool),
    App(Box<Expression>, Box<Expression>),
    Abs(String, Box<Expression>),
    Let(String, Box<Expression>, Box<Expression>),
}

/// Hindley-Milnerç±»å‹æ¨æ–­å™¨
pub struct TypeInferrer {
    next_var: usize,
}

impl TypeInferrer {
    pub fn new() -> Self {
        TypeInferrer { next_var: 0 }
    }
    
    /// ç”Ÿæˆæ–°çš„ç±»å‹å˜é‡
    pub fn fresh_var(&mut self) -> Type {
        let var = format!("Î±{}", self.next_var);
        self.next_var += 1;
        Type::var(&var)
    }
    
    /// Wç®—æ³•ï¼šç±»å‹æ¨æ–­
    pub fn infer(&mut self, env: &TypeEnvironment, expr: &Expression) -> Result<(Substitution, Type), String> {
        match expr {
            Expression::Var(name) => {
                if let Some(typ) = env.lookup(name) {
                    Ok((Substitution::new(), typ.clone()))
                } else {
                    Err(format!("Unbound variable: {}", name))
                }
            }
            
            Expression::Int(_) => {
                Ok((Substitution::new(), Type::Int))
            }
            
            Expression::Bool(_) => {
                Ok((Substitution::new(), Type::Bool))
            }
            
            Expression::App(fun, arg) => {
                let (s1, fun_type) = self.infer(env, fun)?;
                let (s2, arg_type) = self.infer(&s1.apply_to_env(env), arg)?;
                let result_type = self.fresh_var();
                let s3 = self.unify(&s2.apply(&fun_type), &Type::arrow(s2.apply(&arg_type), result_type.clone()))?;
                Ok((s3.compose(s2.compose(s1)), s3.apply(&result_type)))
            }
            
            Expression::Abs(param, body) => {
                let param_type = self.fresh_var();
                let new_env = env.extend(param.clone(), param_type.clone());
                let (s, body_type) = self.infer(&new_env, body)?;
                Ok((s, Type::arrow(s.apply(&param_type), body_type)))
            }
            
            Expression::Let(var, value, body) => {
                let (s1, value_type) = self.infer(env, value)?;
                let generalized_type = self.generalize(&s1.apply_to_env(env), &value_type);
                let new_env = s1.apply_to_env(env).extend(var.clone(), generalized_type);
                let (s2, body_type) = self.infer(&new_env, body)?;
                Ok((s2.compose(s1), body_type))
            }
        }
    }
    
    /// ç»Ÿä¸€ç®—æ³•
    pub fn unify(&self, t1: &Type, t2: &Type) -> Result<Substitution, String> {
        match (t1, t2) {
            (Type::Var(Î±), Ï„) | (Ï„, Type::Var(Î±)) => {
                if self.occurs(Î±, Ï„) {
                    Err("Occurs check failed".to_string())
                } else {
                    Ok(Substitution::with_binding(Î±, Ï„.clone()))
                }
            }
            
            (Type::Arrow(Ï„1, Ï„2), Type::Arrow(Ï„3, Ï„4)) => {
                let s1 = self.unify(Ï„1, Ï„3)?;
                let s2 = self.unify(&s1.apply(Ï„2), &s1.apply(Ï„4))?;
                Ok(s2.compose(s1))
            }
            
            (Type::Int, Type::Int) | (Type::Bool, Type::Bool) => {
                Ok(Substitution::new())
            }
            
            _ => Err(format!("Cannot unify types: {:?} and {:?}", t1, t2))
        }
    }
    
    /// æ£€æŸ¥ç±»å‹å˜é‡æ˜¯å¦å‡ºç°åœ¨ç±»å‹ä¸­
    fn occurs(&self, var: &str, typ: &Type) -> bool {
        match typ {
            Type::Var(name) => name == var,
            Type::Int | Type::Bool => false,
            Type::Arrow(from, to) => self.occurs(var, from) || self.occurs(var, to),
            Type::ForAll(_, body) => self.occurs(var, body),
        }
    }
    
    /// æ³›åŒ–ç±»å‹
    fn generalize(&self, env: &TypeEnvironment, typ: &Type) -> Type {
        let free_vars = typ.free_vars();
        let env_free_vars = self.env_free_vars(env);
        let quantified_vars: Vec<String> = free_vars.difference(&env_free_vars).cloned().collect();
        
        let mut result = typ.clone();
        for var in quantified_vars {
            result = Type::ForAll(var, Box::new(result));
        }
        result
    }
    
    /// è·å–ç¯å¢ƒä¸­çš„è‡ªç”±å˜é‡
    fn env_free_vars(&self, env: &TypeEnvironment) -> HashSet<String> {
        let mut vars = HashSet::new();
        for typ in env.bindings.values() {
            vars.extend(typ.free_vars());
        }
        vars
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_simple_inference() {
        let mut inferrer = TypeInferrer::new();
        let env = TypeEnvironment::new();
        
        // æ¨æ–­æ•´æ•°
        let expr = Expression::Int(42);
        let (_, typ) = inferrer.infer(&env, &expr).unwrap();
        assert_eq!(typ, Type::Int);
        
        // æ¨æ–­å¸ƒå°”å€¼
        let expr = Expression::Bool(true);
        let (_, typ) = inferrer.infer(&env, &expr).unwrap();
        assert_eq!(typ, Type::Bool);
    }
    
    #[test]
    fn test_function_inference() {
        let mut inferrer = TypeInferrer::new();
        let mut env = TypeEnvironment::new();
        env.bind("id".to_string(), Type::forall("Î±", Type::arrow(Type::var("Î±"), Type::var("Î±"))));
        
        // æ¨æ–­å‡½æ•°åº”ç”¨
        let expr = Expression::App(
            Box::new(Expression::Var("id".to_string())),
            Box::new(Expression::Int(42))
        );
        
        let (_, typ) = inferrer.infer(&env, &expr).unwrap();
        assert_eq!(typ, Type::Int);
    }
    
    #[test]
    fn test_lambda_inference() {
        let mut inferrer = TypeInferrer::new();
        let env = TypeEnvironment::new();
        
        // æ¨æ–­lambdaè¡¨è¾¾å¼
        let expr = Expression::Abs(
            "x".to_string(),
            Box::new(Expression::Var("x".to_string()))
        );
        
        let (_, typ) = inferrer.infer(&env, &expr).unwrap();
        // åº”è¯¥æ˜¯ Î± -> Î± çš„å½¢å¼
        assert!(matches!(typ, Type::Arrow(_, _)));
    }
}
```

### 6.2 Haskell å®ç°

```haskell
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Control.Monad.State
import Control.Monad.Except

-- è¡¨ç¤ºç±»å‹
data Type = TVar String
          | TInt
          | TBool
          | TArrow Type Type
          | TForAll String Type
          deriving (Show, Eq, Ord)

-- è¡¨ç¤ºæ›¿æ¢
type Substitution = Map String Type

-- è¡¨ç¤ºç±»å‹ç¯å¢ƒ
type TypeEnv = Map String Type

-- è¡¨ç¤ºè¡¨è¾¾å¼
data Expression = Var String
                | IntLit Int
                | BoolLit Bool
                | App Expression Expression
                | Abs String Expression
                | Let String Expression Expression
                deriving (Show)

-- ç±»å‹æ¨æ–­çš„çŠ¶æ€
data InferState = InferState
    { nextVar :: Int
    } deriving Show

-- ç±»å‹æ¨æ–­çš„é”™è¯¯
data InferError = UnificationError String
                | UnboundVariable String
                | OccursCheckFailed
                deriving Show

-- ç±»å‹æ¨æ–­çš„monad
type InferM = ExceptT InferError (State InferState)

-- ç”Ÿæˆæ–°çš„ç±»å‹å˜é‡
freshVar :: InferM Type
freshVar = do
    state <- get
    put state { nextVar = nextVar state + 1 }
    return $ TVar $ "Î±" ++ show (nextVar state)

-- è·å–ç±»å‹çš„è‡ªç”±å˜é‡
freeVars :: Type -> Set String
freeVars (TVar name) = Set.singleton name
freeVars TInt = Set.empty
freeVars TBool = Set.empty
freeVars (TArrow t1 t2) = freeVars t1 `Set.union` freeVars t2
freeVars (TForAll var body) = Set.delete var (freeVars body)

-- åº”ç”¨æ›¿æ¢åˆ°ç±»å‹
applySubst :: Substitution -> Type -> Type
applySubst sub (TVar name) = Map.findWithDefault (TVar name) name sub
applySubst sub TInt = TInt
applySubst sub TBool = TBool
applySubst sub (TArrow t1 t2) = TArrow (applySubst sub t1) (applySubst sub t2)
applySubst sub (TForAll var body) = 
    if Map.member var sub
    then TForAll (var ++ "'") (applySubst (Map.delete var sub) body)
    else TForAll var (applySubst sub body)

-- ç»„åˆä¸¤ä¸ªæ›¿æ¢
composeSubst :: Substitution -> Substitution -> Substitution
composeSubst s1 s2 = Map.union (Map.map (applySubst s2) s1) s2

-- ç»Ÿä¸€ç®—æ³•
unify :: Type -> Type -> InferM Substitution
unify (TVar Î±) Ï„ = unifyVar Î± Ï„
unify Ï„ (TVar Î±) = unifyVar Î± Ï„
unify (TArrow Ï„1 Ï„2) (TArrow Ï„3 Ï„4) = do
    s1 <- unify Ï„1 Ï„3
    s2 <- unify (applySubst s1 Ï„2) (applySubst s1 Ï„4)
    return $ composeSubst s2 s1
unify TInt TInt = return Map.empty
unify TBool TBool = return Map.empty
unify t1 t2 = throwError $ UnificationError $ "Cannot unify " ++ show t1 ++ " and " ++ show t2

-- ç»Ÿä¸€ç±»å‹å˜é‡
unifyVar :: String -> Type -> InferM Substitution
unifyVar Î± Ï„
    | Ï„ == TVar Î± = return Map.empty
    | occurs Î± Ï„ = throwError OccursCheckFailed
    | otherwise = return $ Map.singleton Î± Ï„

-- æ£€æŸ¥ç±»å‹å˜é‡æ˜¯å¦å‡ºç°åœ¨ç±»å‹ä¸­
occurs :: String -> Type -> Bool
occurs Î± (TVar name) = Î± == name
occurs Î± TInt = False
occurs Î± TBool = False
occurs Î± (TArrow t1 t2) = occurs Î± t1 || occurs Î± t2
occurs Î± (TForAll var body) = occurs Î± body

-- Wç®—æ³•ï¼šç±»å‹æ¨æ–­
infer :: TypeEnv -> Expression -> InferM (Substitution, Type)
infer env (Var name) = case Map.lookup name env of
    Just typ -> return (Map.empty, typ)
    Nothing -> throwError $ UnboundVariable name

infer env (IntLit _) = return (Map.empty, TInt)

infer env (BoolLit _) = return (Map.empty, TBool)

infer env (App fun arg) = do
    (s1, funType) <- infer env fun
    (s2, argType) <- infer (applySubstToEnv s1 env) arg
    resultType <- freshVar
    s3 <- unify (applySubst s2 funType) (TArrow (applySubst s2 argType) resultType)
    return (composeSubst s3 (composeSubst s2 s1), applySubst s3 resultType)

infer env (Abs param body) = do
    paramType <- freshVar
    let newEnv = Map.insert param paramType env
    (s, bodyType) <- infer newEnv body
    return (s, TArrow (applySubst s paramType) bodyType)

infer env (Let var value body) = do
    (s1, valueType) <- infer env value
    let generalizedType = generalize (applySubstToEnv s1 env) valueType
    let newEnv = Map.insert var generalizedType (applySubstToEnv s1 env)
    (s2, bodyType) <- infer newEnv body
    return (composeSubst s2 s1, bodyType)

-- åº”ç”¨æ›¿æ¢åˆ°ç±»å‹ç¯å¢ƒ
applySubstToEnv :: Substitution -> TypeEnv -> TypeEnv
applySubstToEnv sub env = Map.map (applySubst sub) env

-- æ³›åŒ–ç±»å‹
generalize :: TypeEnv -> Type -> Type
generalize env typ = 
    let freeVarsInType = freeVars typ
        freeVarsInEnv = Set.unions $ map freeVars $ Map.elems env
        quantifiedVars = Set.difference freeVarsInType freeVarsInEnv
    in  foldr (\var acc -> TForAll var acc) typ (Set.toList quantifiedVars)

-- è¿è¡Œç±»å‹æ¨æ–­
runInference :: Expression -> Either InferError Type
runInference expr = 
    let initialState = InferState 0
        result = runState (runExceptT (infer Map.empty expr)) initialState
    in  case result of
        (Right (_, typ), _) -> Right typ
        (Left err, _) -> Left err

-- æµ‹è¯•å‡½æ•°
testInference :: IO ()
testInference = do
    putStrLn "Testing Hindley-Milner type inference:"
    
    -- æµ‹è¯•æ•´æ•°
    let intExpr = IntLit 42
    putStrLn $ "Int 42: " ++ show (runInference intExpr)
    
    -- æµ‹è¯•å¸ƒå°”å€¼
    let boolExpr = BoolLit True
    putStrLn $ "Bool True: " ++ show (runInference boolExpr)
    
    -- æµ‹è¯•lambdaè¡¨è¾¾å¼
    let lambdaExpr = Abs "x" (Var "x")
    putStrLn $ "Î»x.x: " ++ show (runInference lambdaExpr)
    
    -- æµ‹è¯•å‡½æ•°åº”ç”¨
    let appExpr = App (Abs "x" (Var "x")) (IntLit 42)
    putStrLn $ "(Î»x.x) 42: " ++ show (runInference appExpr)

main :: IO ()
main = testInference
```

## 7 åº”ç”¨ç¤ºä¾‹

### 7.1 å¤šæ€å‡½æ•°

**ç¤ºä¾‹ 5.1.1** (æ’ç­‰å‡½æ•°)

```haskell
id :: a -> a
id x = x
```

ç³»ç»Ÿè‡ªåŠ¨æ¨æ–­å‡ºæœ€ä¸€èˆ¬çš„ç±»å‹ $\forall \alpha. \alpha \to \alpha$ã€‚

### 7.2 é«˜é˜¶å‡½æ•°

**ç¤ºä¾‹ 5.1.2** (mapå‡½æ•°)

```haskell
map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs
```

### 7.3 ç±»å‹ç±»

**ç¤ºä¾‹ 5.1.3** (ç±»å‹ç±»çº¦æŸ)

```haskell
sum :: Num a => [a] -> a
sum [] = 0
sum (x:xs) = x + sum xs
```

## 8 ç›¸å…³ç†è®º

### 8.1 ç±»å‹ç³»ç»Ÿ

- **ç®€å•ç±»å‹Î»æ¼”ç®—**ï¼šHindley-Milnerçš„åŸºç¡€
- **ç³»ç»ŸF**ï¼šäºŒé˜¶å¤šæ€ç±»å‹ç³»ç»Ÿ
- **ä¾èµ–ç±»å‹**ï¼šæ›´å¼ºå¤§çš„ç±»å‹ç³»ç»Ÿ

### 8.2 ç±»å‹æ¨æ–­

- **Wç®—æ³•**ï¼šHindley-Milnerçš„æ ¸å¿ƒç®—æ³•
- **ç»Ÿä¸€ç®—æ³•**ï¼šæ±‚è§£ç±»å‹çº¦æŸ
- **æ³›åŒ–ç®—æ³•**ï¼šç”Ÿæˆå¤šæ€ç±»å‹

### 8.3 ç¼–ç¨‹è¯­è¨€

- **MLç³»åˆ—**ï¼šStandard MLã€OCamlã€F#
- **Haskell**ï¼šæœ€è‘—åçš„Hindley-Milnerå®ç°
- **Scala**ï¼šéƒ¨åˆ†æ”¯æŒHindley-Milner

## 7. å‚è€ƒæ–‡çŒ®

1. Milner, R. (1978). A theory of type polymorphism in programming. Journal of Computer and System Sciences, 17(3), 348-375.
2. Hindley, J. R. (1969). The principal type-scheme of an object in combinatory logic. Transactions of the American Mathematical Society, 146, 29-60.
3. Damas, L., & Milner, R. (1982). Principal type-schemes for functional programs. In Proceedings of the 9th ACM SIGPLAN-SIGACT symposium on Principles of programming languages (pp. 207-212).
4. Pierce, B. C. (2002). Types and Programming Languages. MIT Press.
5. Cardelli, L. (1987). Basic polymorphic typechecking. Science of Computer Programming, 8(2), 147-172.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [04.1.1 ç®€å•ç±»å‹Î»æ¼”ç®—](../04_Type_Theory/04.1.1_ç®€å•ç±»å‹Î»æ¼”ç®—.md)
- [04.1.3 ç³»ç»ŸF](../04_Type_Theory/04.1.3_ç³»ç»ŸF.md)
- [04.1.4 ä¾èµ–ç±»å‹](../04_Type_Theory/04.1.4_ä¾èµ–ç±»å‹.md)

## 9 æ‰¹åˆ¤æ€§åˆ†æ

- å“²å­¦ç»´åº¦ï¼šå¤šæ€æ€§ä½œä¸ºæŠ½è±¡çš„æœ¬è´¨ï¼Œä¸å…·ä½“å®ä¾‹åŒ–çš„è¾©è¯å…³ç³»ï¼›ç±»å‹æ¨æ–­çš„è‡ªåŠ¨åŒ–ä¸äººç±»è®¤çŸ¥ã€‚
- æ–¹æ³•è®ºç»´åº¦ï¼šHMç®—æ³•çš„åˆ¤å®šæ€§ä¸è¡¨è¾¾èƒ½åŠ›ï¼›letå¤šæ€ä¸ç³»ç»ŸFçš„è¯­ä¹‰å·®å¼‚ã€‚
- å·¥ç¨‹ç»´åº¦ï¼šç±»å‹æ¨æ–­åœ¨å‡½æ•°å¼è¯­è¨€ä¸­çš„æˆåŠŸåº”ç”¨ï¼›ä¸é¢å‘å¯¹è±¡å¤šæ€çš„å…¼å®¹æ€§æŒ‘æˆ˜ã€‚
- ç¤¾ä¼šæŠ€æœ¯ç»´åº¦ï¼šHMç³»ç»Ÿå¯¹ç¼–ç¨‹è¯­è¨€è®¾è®¡çš„å½±å“ï¼›ç±»å‹æ¨æ–­å·¥å…·çš„ç”¨æˆ·ä½“éªŒä¼˜åŒ–ã€‚
