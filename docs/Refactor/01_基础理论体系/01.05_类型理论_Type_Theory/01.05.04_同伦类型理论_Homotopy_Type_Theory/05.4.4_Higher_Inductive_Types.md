# 04.4.4 é«˜é˜¶å½’çº³ç±»å‹

## ğŸ“‹ ç›®å½•

- [04.4.4 é«˜é˜¶å½’çº³ç±»å‹](#0444-é«˜é˜¶å½’çº³ç±»å‹)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2 æ ¸å¿ƒç›®æ ‡](#2-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•-1)
  - [3 åŸºæœ¬æ¦‚å¿µ](#3-åŸºæœ¬æ¦‚å¿µ)
    - [3.1 é«˜é˜¶å½’çº³ç±»å‹åŸºç¡€](#31-é«˜é˜¶å½’çº³ç±»å‹åŸºç¡€)
    - [3.2 é«˜é˜¶å½’çº³ç±»å‹ç‰¹å¾](#32-é«˜é˜¶å½’çº³ç±»å‹ç‰¹å¾)
  - [4 å½¢å¼åŒ–å®šä¹‰](#4-å½¢å¼åŒ–å®šä¹‰)
    - [4.1 åœ†ç±»å‹ç³»ç»Ÿ](#41-åœ†ç±»å‹ç³»ç»Ÿ)
    - [4.2 çƒé¢ç±»å‹ç³»ç»Ÿ](#42-çƒé¢ç±»å‹ç³»ç»Ÿ)
  - [5 å®šç†ä¸è¯æ˜](#5-å®šç†ä¸è¯æ˜)
    - [5.1 é«˜é˜¶å½’çº³ç±»å‹åŸºæœ¬å®šç†](#51-é«˜é˜¶å½’çº³ç±»å‹åŸºæœ¬å®šç†)
  - [6 ä»£ç å®ç°](#6-ä»£ç å®ç°)
    - [6.1 é«˜é˜¶å½’çº³ç±»å‹åŸºç¡€å®ç°](#61-é«˜é˜¶å½’çº³ç±»å‹åŸºç¡€å®ç°)
  - [7 åº”ç”¨ç¤ºä¾‹](#7-åº”ç”¨ç¤ºä¾‹)
    - [7.1 é«˜é˜¶å½’çº³ç±»å‹ä½¿ç”¨](#71-é«˜é˜¶å½’çº³ç±»å‹ä½¿ç”¨)
  - [8 ç›¸å…³ç†è®º](#8-ç›¸å…³ç†è®º)
    - [8.1 ä¸åŒä¼¦ç±»å‹è®ºçš„å…³ç³»](#81-ä¸åŒä¼¦ç±»å‹è®ºçš„å…³ç³»)
    - [8.2 ä¸ç±»å‹ç†è®ºçš„å…³ç³»](#82-ä¸ç±»å‹ç†è®ºçš„å…³ç³»)
    - [8.3 ä¸æ‹“æ‰‘å­¦çš„å…³ç³»](#83-ä¸æ‹“æ‰‘å­¦çš„å…³ç³»)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
  - [9 æ‰¹åˆ¤æ€§åˆ†æ](#9-æ‰¹åˆ¤æ€§åˆ†æ)

---

## 1 æ¦‚è¿°

é«˜é˜¶å½’çº³ç±»å‹æ˜¯åŒä¼¦ç±»å‹è®ºä¸­çš„é«˜çº§æ¦‚å¿µï¼Œå…è®¸åœ¨ç±»å‹å®šä¹‰ä¸­åŒ…å«è·¯å¾„æ„é€ å‡½æ•°ã€‚æœ¬æ–‡æ¡£å»ºç«‹ä¸¥æ ¼çš„é«˜é˜¶å½’çº³ç±»å‹ç†è®ºæ¡†æ¶ï¼ŒåŒ…å«é«˜é˜¶å½’çº³ç±»å‹ã€åœ†ç±»å‹ã€çƒé¢ç±»å‹ã€ç¯é¢ç±»å‹ç­‰å†…å®¹ã€‚

## 2 æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹é«˜é˜¶å½’çº³ç±»å‹çš„åŸºæœ¬æ¦‚å¿µå’Œå½¢å¼åŒ–å®šä¹‰
2. åˆ†æé«˜é˜¶å½’çº³ç±»å‹ä¸ç»å…¸å½’çº³ç±»å‹çš„å…³ç³»
3. ç ”ç©¶é«˜é˜¶å½’çº³ç±»å‹çš„è®¾è®¡å’Œå®ç°
4. æä¾›é«˜é˜¶å½’çº³ç±»å‹çš„å®é™…åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 3 åŸºæœ¬æ¦‚å¿µ

### 3.1 é«˜é˜¶å½’çº³ç±»å‹åŸºç¡€

**å®šä¹‰ 1.1.1** (é«˜é˜¶å½’çº³ç±»å‹)
é«˜é˜¶å½’çº³ç±»å‹æ˜¯åŒ…å«è·¯å¾„æ„é€ å‡½æ•°çš„å½’çº³ç±»å‹ï¼š
$$HIT(A) = \text{Point}(A) + \text{Path}(A) + \text{TwoCell}(A) + \cdots$$

**å®šä¹‰ 1.1.2** (è·¯å¾„æ„é€ å‡½æ•°)
è·¯å¾„æ„é€ å‡½æ•°å®šä¹‰ç±»å‹ä¸­çš„è·¯å¾„ï¼š
$$\text{Path}(A) = \Pi_{a,b:A} \text{Path}_A(a, b)$$

**å®šä¹‰ 1.1.3** (äºŒç»´èƒè…”æ„é€ å‡½æ•°)
äºŒç»´èƒè…”æ„é€ å‡½æ•°å®šä¹‰è·¯å¾„ä¹‹é—´çš„è·¯å¾„ï¼š
$$\text{TwoCell}(A) = \Pi_{p,q:\text{Path}_A(a,b)} \text{Path}_{\text{Path}_A(a,b)}(p, q)$$

### 3.2 é«˜é˜¶å½’çº³ç±»å‹ç‰¹å¾

**å®šä¹‰ 1.2.1** (é«˜é˜¶å½’çº³ç±»å‹è¯­æ³•)
é«˜é˜¶å½’çº³ç±»å‹è¯­æ³•ï¼š

```text
HIT ::= data Name where
         | Point : Type
         | Path : Point -> Point -> Type
         | TwoCell : Path -> Path -> Type
         | HigherCell : [Path] -> Type
```

**å®šä¹‰ 1.2.2** (é«˜é˜¶å½’çº³ç±»å‹è§„åˆ™)
é«˜é˜¶å½’çº³ç±»å‹æ¨å¯¼è§„åˆ™ï¼š
$$\frac{\Gamma \vdash A : Type \quad \Gamma \vdash a : A}{\Gamma \vdash \text{point}(a) : HIT(A)} \text{ (Point Formation)}$$
$$\frac{\Gamma \vdash p : \text{Path}_A(a, b)}{\Gamma \vdash \text{path}(p) : \text{Path}_{HIT(A)}(\text{point}(a), \text{point}(b))} \text{ (Path Formation)}$$

**å®šä¹‰ 1.2.3** (é«˜é˜¶å½’çº³ç±»å‹è¯­ä¹‰)
é«˜é˜¶å½’çº³ç±»å‹è¯­ä¹‰ï¼š
$$\llbracket HIT(A) \rrbracket = \text{Free}(\text{Point}(A) + \text{Path}(A) + \text{TwoCell}(A))$$

## 4 å½¢å¼åŒ–å®šä¹‰

### 4.1 åœ†ç±»å‹ç³»ç»Ÿ

**å®šä¹‰ 2.1.1** (åœ†ç±»å‹)
åœ†ç±»å‹æ˜¯æœ€ç®€å•çš„é«˜é˜¶å½’çº³ç±»å‹ï¼š
$$S^1 = \text{data } S^1 \text{ where } | \text{base} : S^1 | \text{loop} : \text{Path}_{S^1}(\text{base}, \text{base})$$

**å®šä¹‰ 2.1.2** (åœ†ç±»å‹è§„åˆ™)
åœ†ç±»å‹æ¨å¯¼è§„åˆ™ï¼š
$$\frac{}{\Gamma \vdash \text{base} : S^1} \text{ (Base Formation)}$$
$$\frac{}{\Gamma \vdash \text{loop} : \text{Path}_{S^1}(\text{base}, \text{base})} \text{ (Loop Formation)}$$

**å®šä¹‰ 2.1.3** (åœ†ç±»å‹è¯­ä¹‰)
åœ†ç±»å‹è¯­ä¹‰ï¼š
$$\llbracket S^1 \rrbracket = \{x \in \mathbb{R}^2 \mid |x| = 1\}$$

### 4.2 çƒé¢ç±»å‹ç³»ç»Ÿ

**å®šä¹‰ 2.2.1** (çƒé¢ç±»å‹)
çƒé¢ç±»å‹æ˜¯åœ†ç±»å‹çš„é«˜ç»´æ¨å¹¿ï¼š
$$S^n = \text{data } S^n \text{ where } | \text{base} : S^n | \text{cell}_n : \text{Path}_{S^n}(\text{base}, \text{base})$$

**å®šä¹‰ 2.2.2** (çƒé¢ç±»å‹è§„åˆ™)
çƒé¢ç±»å‹æ¨å¯¼è§„åˆ™ï¼š
$$\frac{}{\Gamma \vdash \text{base} : S^n} \text{ (Sphere Base Formation)}$$
$$\frac{}{\Gamma \vdash \text{cell}_n : \text{Path}_{S^n}(\text{base}, \text{base})} \text{ (Sphere Cell Formation)}$$

## 5 å®šç†ä¸è¯æ˜

### 5.1 é«˜é˜¶å½’çº³ç±»å‹åŸºæœ¬å®šç†

**å®šç† 3.1.1** (é«˜é˜¶å½’çº³ç±»å‹å­˜åœ¨æ€§å®šç†)
å¯¹äºä»»ä½•ç±»å‹ $A$ï¼Œå­˜åœ¨é«˜é˜¶å½’çº³ç±»å‹ $HIT(A)$ã€‚

**è¯æ˜**ï¼š
é€šè¿‡æ„é€ æ€§è¯æ˜ï¼š

1. å®šä¹‰ç‚¹æ„é€ å‡½æ•°ï¼š$\text{point} : A \rightarrow HIT(A)$
2. å®šä¹‰è·¯å¾„æ„é€ å‡½æ•°ï¼š$\text{path} : \text{Path}_A(a, b) \rightarrow \text{Path}_{HIT(A)}(\text{point}(a), \text{point}(b))$
3. å®šä¹‰äºŒç»´èƒè…”æ„é€ å‡½æ•°ï¼š$\text{twoCell} : \text{Path}_{\text{Path}_A(a,b)}(p, q) \rightarrow \text{Path}_{\text{Path}_{HIT(A)}(\text{point}(a), \text{point}(b))}(\text{path}(p), \text{path}(q))$

**å®šç† 3.1.2** (åœ†ç±»å‹åŸºæœ¬ç¾¤å®šç†)
åœ†ç±»å‹çš„åŸºæœ¬ç¾¤æ˜¯æ•´æ•°ç¾¤ï¼š
$$\pi_1(S^1) \cong \mathbb{Z}$$

**è¯æ˜**ï¼š
é€šè¿‡åŒä¼¦ç†è®ºï¼š

1. æ„é€ è¦†ç›–ç©ºé—´ï¼š$\mathbb{R} \rightarrow S^1$
2. è®¡ç®—åŸºæœ¬ç¾¤ï¼š$\pi_1(S^1) = \mathbb{Z}$
3. éªŒè¯ç¾¤ç»“æ„

## 6 ä»£ç å®ç°

### 6.1 é«˜é˜¶å½’çº³ç±»å‹åŸºç¡€å®ç°

```rust
use std::collections::HashMap;

/// é«˜é˜¶å½’çº³ç±»å‹
#[derive(Debug, Clone)]
enum HigherInductiveType {
    Point(DependentType),
    Path(DependentType, Term, Term),
    TwoCell(DependentType, Path, Path),
    HigherCell(DependentType, Vec<Path>),
}

/// è·¯å¾„
#[derive(Debug, Clone)]
enum Path {
    Refl(Term),
    Loop(Term),
    Concatenation(Box<Path>, Box<Path>),
    Inverse(Box<Path>),
}

/// é«˜é˜¶å½’çº³ç±»å‹ç³»ç»Ÿ
#[derive(Debug)]
struct HigherInductiveTypeSystem {
    types: HashMap<String, HigherInductiveType>,
    constructors: HashMap<String, Constructor>,
    eliminators: HashMap<String, Eliminator>,
}

/// æ„é€ å‡½æ•°
#[derive(Debug, Clone)]
struct Constructor {
    name: String,
    arguments: Vec<DependentType>,
    return_type: DependentType,
    path_constructors: Vec<PathConstructor>,
}

/// è·¯å¾„æ„é€ å‡½æ•°
#[derive(Debug, Clone)]
struct PathConstructor {
    name: String,
    domain: Vec<Term>,
    codomain: Vec<Term>,
    path_type: PathType,
}

/// æ¶ˆé™¤å™¨
#[derive(Debug, Clone)]
struct Eliminator {
    name: String,
    motive: DependentType,
    methods: Vec<Method>,
    return_type: DependentType,
}

/// æ–¹æ³•
#[derive(Debug, Clone)]
struct Method {
    name: String,
    pattern: Pattern,
    body: Term,
    type_signature: DependentType,
}

impl HigherInductiveTypeSystem {
    /// åˆ›å»ºé«˜é˜¶å½’çº³ç±»å‹ç³»ç»Ÿ
    fn new() -> Self {
        HigherInductiveTypeSystem {
            types: HashMap::new(),
            constructors: HashMap::new(),
            eliminators: HashMap::new(),
        }
    }

    /// æ„é€ åœ†ç±»å‹
    fn construct_circle_type(&self) -> HigherInductiveType {
        let base_type = DependentType::Base(BaseType::Unit);
        let base_point = Term::Constructor("base".to_string(), vec![]);
        let loop_path = Path::Loop(base_point.clone());

        HigherInductiveType::Path(base_type, base_point, base_point)
    }

    /// æ„é€ çƒé¢ç±»å‹
    fn construct_sphere_type(&self, dimension: usize) -> HigherInductiveType {
        let base_type = DependentType::Base(BaseType::Unit);
        let base_point = Term::Constructor("base".to_string(), vec![]);

        match dimension {
            0 => HigherInductiveType::Point(base_type),
            1 => {
                let loop_path = Path::Loop(base_point.clone());
                HigherInductiveType::Path(base_type, base_point.clone(), base_point)
            },
            2 => {
                let loop_path = Path::Loop(base_point.clone());
                let two_cell = Path::Refl(loop_path.clone());
                HigherInductiveType::TwoCell(base_type, loop_path, loop_path)
            },
            _ => HigherInductiveType::HigherCell(base_type, vec![])
        }
    }

    /// æ„é€ ç¯é¢ç±»å‹
    fn construct_torus_type(&self) -> HigherInductiveType {
        let base_type = DependentType::Base(BaseType::Unit);
        let base_point = Term::Constructor("base".to_string(), vec![]);

        // æ„é€ ä¸¤ä¸ªç¯è·¯
        let meridian = Path::Loop(base_point.clone());
        let longitude = Path::Loop(base_point.clone());

        // æ„é€ äºŒç»´èƒè…”
        HigherInductiveType::TwoCell(base_type, meridian, longitude)
    }

    /// æ„é€ æ¥”å’Œç±»å‹
    fn construct_wedge_sum_type(&self, type1: &DependentType, type2: &DependentType) -> HigherInductiveType {
        // æ„é€ ç§¯ç±»å‹
        let product_type = DependentType::DependentPair(
            "pair".to_string(),
            Box::new(type1.clone()),
            Box::new(type2.clone())
        );

        // æ„é€ æ¥”å’Œ
        HigherInductiveType::Point(product_type)
    }

    /// é«˜é˜¶å½’çº³ç±»å‹æ¶ˆé™¤
    fn eliminate_higher_type(&self, higher_type: &HigherInductiveType, motive: &DependentType) -> Result<Term, String> {
        match higher_type {
            HigherInductiveType::Point(base_type) => {
                // ç‚¹ç±»å‹æ¶ˆé™¤
                Ok(Term::Lambda(
                    "x".to_string(),
                    Box::new(base_type.clone()),
                    Box::new(Term::Variable("x".to_string()))
                ))
            },
            HigherInductiveType::Path(base_type, start, end) => {
                // è·¯å¾„ç±»å‹æ¶ˆé™¤
                let path_var = Term::Variable("p".to_string());
                Ok(Term::Lambda(
                    "p".to_string(),
                    Box::new(DependentType::TypeFamily("Path".to_string(), vec![start.clone(), end.clone()])),
                    Box::new(path_var)
                ))
            },
            HigherInductiveType::TwoCell(base_type, path1, path2) => {
                // äºŒç»´èƒè…”ç±»å‹æ¶ˆé™¤
                let cell_var = Term::Variable("cell".to_string());
                Ok(Term::Lambda(
                    "cell".to_string(),
                    Box::new(base_type.clone()),
                    Box::new(cell_var)
                ))
            },
            HigherInductiveType::HigherCell(base_type, _) => {
                // é«˜é˜¶èƒè…”ç±»å‹æ¶ˆé™¤
                let cell_var = Term::Variable("cell".to_string());
                Ok(Term::Lambda(
                    "cell".to_string(),
                    Box::new(base_type.clone()),
                    Box::new(cell_var)
                ))
            },
        }
    }

    /// è®¡ç®—é«˜é˜¶å½’çº³ç±»å‹
    fn compute_higher_type(&self, higher_type: &HigherInductiveType) -> Result<DependentType, String> {
        match higher_type {
            HigherInductiveType::Point(base_type) => Ok(base_type.clone()),
            HigherInductiveType::Path(base_type, _, _) => {
                Ok(DependentType::TypeFamily("Path".to_string(), vec![]))
            },
            HigherInductiveType::TwoCell(base_type, _, _) => Ok(base_type.clone()),
            HigherInductiveType::HigherCell(base_type, _) => Ok(base_type.clone()),
        }
    }
}
```

## 7 åº”ç”¨ç¤ºä¾‹

### 7.1 é«˜é˜¶å½’çº³ç±»å‹ä½¿ç”¨

```rust
// é«˜é˜¶å½’çº³ç±»å‹ä½¿ç”¨ç¤ºä¾‹
fn higher_inductive_type_example() {
    let mut hit_system = HigherInductiveTypeSystem::new();

    // æ„é€ åœ†ç±»å‹
    let circle = hit_system.construct_circle_type();
    println!("åœ†ç±»å‹: {:?}", circle);

    // æ„é€ çƒé¢ç±»å‹
    let sphere_0 = hit_system.construct_sphere_type(0);
    let sphere_1 = hit_system.construct_sphere_type(1);
    let sphere_2 = hit_system.construct_sphere_type(2);

    println!("0ç»´çƒé¢: {:?}", sphere_0);
    println!("1ç»´çƒé¢: {:?}", sphere_1);
    println!("2ç»´çƒé¢: {:?}", sphere_2);

    // æ„é€ ç¯é¢ç±»å‹
    let torus = hit_system.construct_torus_type();
    println!("ç¯é¢ç±»å‹: {:?}", torus);

    // æ„é€ æ¥”å’Œç±»å‹
    let nat_type = DependentType::Base(BaseType::Nat);
    let bool_type = DependentType::Base(BaseType::Bool);
    let wedge_sum = hit_system.construct_wedge_sum_type(&nat_type, &bool_type);
    println!("æ¥”å’Œç±»å‹: {:?}", wedge_sum);

    // é«˜é˜¶å½’çº³ç±»å‹æ¶ˆé™¤
    let motive = DependentType::Base(BaseType::Nat);
    let elimination = hit_system.eliminate_higher_type(&circle, &motive);
    println!("åœ†ç±»å‹æ¶ˆé™¤: {:?}", elimination);

    // è®¡ç®—é«˜é˜¶å½’çº³ç±»å‹
    let computed_type = hit_system.compute_higher_type(&circle);
    println!("åœ†ç±»å‹è®¡ç®—: {:?}", computed_type);
}

// ç»¼åˆåº”ç”¨ç¤ºä¾‹
fn comprehensive_hit_example() {
    println!("=== é«˜é˜¶å½’çº³ç±»å‹ç³»ç»Ÿ ===");
    higher_inductive_type_example();

    // é«˜é˜¶å½’çº³ç±»å‹æ—åº”ç”¨
    println!("\n=== é«˜é˜¶å½’çº³ç±»å‹æ—åº”ç”¨ ===");

    let mut hit_system = HigherInductiveTypeSystem::new();

    // æ„é€ é«˜é˜¶å½’çº³ç±»å‹æ—
    let hit_family = DependentType::DependentFunction(
        "A".to_string(),
        Box::new(DependentType::Universe(0)),
        Box::new(DependentType::Universe(0))
    );

    println!("é«˜é˜¶å½’çº³ç±»å‹æ—: {:?}", hit_family);

    // æ„é€ é«˜é˜¶å½’çº³ç±»å‹å®ä¾‹
    let nat_type = DependentType::Base(BaseType::Nat);
    let hit_instance = hit_system.construct_circle_type();
    println!("é«˜é˜¶å½’çº³ç±»å‹å®ä¾‹: {:?}", hit_instance);

    // æ„é€ é«˜é˜¶å½’çº³ç±»å‹è®¡ç®—
    let computation = hit_system.compute_higher_type(&hit_instance);
    println!("é«˜é˜¶å½’çº³ç±»å‹è®¡ç®—: {:?}", computation);
}
```

## 8 ç›¸å…³ç†è®º

### 8.1 ä¸åŒä¼¦ç±»å‹è®ºçš„å…³ç³»

é«˜é˜¶å½’çº³ç±»å‹ä¸åŒä¼¦ç±»å‹è®ºçš„å…³ç³»ï¼š

1. **æ ¸å¿ƒæ¦‚å¿µ**ï¼šé«˜é˜¶å½’çº³ç±»å‹æ˜¯åŒä¼¦ç±»å‹è®ºçš„æ ¸å¿ƒæ¦‚å¿µ
2. **è·¯å¾„æ„é€ **ï¼šé«˜é˜¶å½’çº³ç±»å‹æ”¯æŒè·¯å¾„æ„é€ 
3. **åŒä¼¦ä¸å˜é‡**ï¼šé«˜é˜¶å½’çº³ç±»å‹æ˜¯åŒä¼¦ä¸å˜é‡
4. **å‡ ä½•è§£é‡Š**ï¼šé«˜é˜¶å½’çº³ç±»å‹æœ‰å‡ ä½•è§£é‡Š

### 8.2 ä¸ç±»å‹ç†è®ºçš„å…³ç³»

é«˜é˜¶å½’çº³ç±»å‹ä¸ç±»å‹ç†è®ºçš„å…³ç³»ï¼š

1. **ç±»å‹æ‰©å±•**ï¼šé«˜é˜¶å½’çº³ç±»å‹æ‰©å±•äº†ç±»å‹ç³»ç»Ÿ
2. **å½’çº³ç±»å‹**ï¼šé«˜é˜¶å½’çº³ç±»å‹æ˜¯å½’çº³ç±»å‹çš„é«˜çº§å½¢å¼
3. **ç±»å‹å®‰å…¨**ï¼šé«˜é˜¶å½’çº³ç±»å‹ä¿è¯ç±»å‹å®‰å…¨
4. **ç¨‹åºéªŒè¯**ï¼šé«˜é˜¶å½’çº³ç±»å‹ç”¨äºç¨‹åºéªŒè¯

### 8.3 ä¸æ‹“æ‰‘å­¦çš„å…³ç³»

é«˜é˜¶å½’çº³ç±»å‹ä¸æ‹“æ‰‘å­¦çš„å…³ç³»ï¼š

1. **å‡ ä½•å¯¹è±¡**ï¼šé«˜é˜¶å½’çº³ç±»å‹è¡¨ç¤ºå‡ ä½•å¯¹è±¡
2. **åŒä¼¦ç¾¤**ï¼šé«˜é˜¶å½’çº³ç±»å‹ä¸åŒä¼¦ç¾¤ç›¸å…³
3. **åŸºæœ¬ç¾¤**ï¼šé«˜é˜¶å½’çº³ç±»å‹ä¸åŸºæœ¬ç¾¤ç›¸å…³
4. **åŒä¼¦ä¸å˜é‡**ï¼šé«˜é˜¶å½’çº³ç±»å‹æ˜¯åŒä¼¦ä¸å˜é‡

## 7. å‚è€ƒæ–‡çŒ®

1. Univalent Foundations Program. (2013). Homotopy type theory: Univalent foundations of mathematics. Institute for Advanced Study.
2. Awodey, S., & Warren, M. A. (2009). Homotopy theoretic models of identity types. Mathematical Proceedings of the Cambridge Philosophical Society, 146(1), 45-55.
3. Voevodsky, V. (2014). The origins and motivations of univalent foundations. Notices of the AMS, 61(9), 1064-1069.
4. Coquand, T., & Huet, G. (1988). The calculus of constructions. Information and computation, 76(2-3), 95-120.
5. Martin-LÃ¶f, P. (1984). Intuitionistic type theory. Bibliopolis.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [04.5.3 åŒä¼¦ç­‰ä»·](../04.5.3_åŒä¼¦ç­‰ä»·.md)
- [04.5.5 åŒä¼¦ä¸å˜é‡](../04.5.5_åŒä¼¦ä¸å˜é‡.md)
- [04.5.6 åŒä¼¦ç¾¤](../04.5.6_åŒä¼¦ç¾¤.md)
- [04.5.1 åŒä¼¦ç†è®º](../04.5.1_åŒä¼¦ç†è®º.md)

## 9 æ‰¹åˆ¤æ€§åˆ†æ

- å“²å­¦ç»´åº¦ï¼šé«˜é˜¶å½’çº³ç±»å‹ä½œä¸ºæ„é€ çš„æ–°èŒƒå¼ï¼›ç‚¹ä¸è·¯å¾„çš„ç»Ÿä¸€æ„é€ ã€‚
- æ–¹æ³•è®ºç»´åº¦ï¼šé«˜é˜¶å½’çº³ç±»å‹çš„è®¾è®¡åŸåˆ™ï¼›ä¸ç»å…¸å½’çº³ç±»å‹çš„ç†è®ºå…³ç³»ã€‚
- å·¥ç¨‹ç»´åº¦ï¼šé«˜é˜¶å½’çº³ç±»å‹åœ¨å®šç†è¯æ˜ä¸­çš„åº”ç”¨ï¼›é«˜ç»´æ„é€ çš„å¯å®ç°æ€§ã€‚
- ç¤¾ä¼šæŠ€æœ¯ç»´åº¦ï¼šé«˜é˜¶å½’çº³ç±»å‹å¯¹ç±»å‹ç†è®ºçš„å½±å“ï¼›é«˜ç»´ç±»å‹æ•™è‚²çš„é©æ–°ã€‚
