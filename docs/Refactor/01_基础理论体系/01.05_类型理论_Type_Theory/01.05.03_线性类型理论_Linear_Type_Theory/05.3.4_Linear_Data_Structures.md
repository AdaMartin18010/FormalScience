# 04.3.4 çº¿æ€§æ•°æ®ç»“æ„

## ğŸ“‹ ç›®å½•

- [04.3.4 çº¿æ€§æ•°æ®ç»“æ„](#0434-çº¿æ€§æ•°æ®ç»“æ„)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2 æ ¸å¿ƒç›®æ ‡](#2-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•-1)
  - [3 åŸºæœ¬æ¦‚å¿µ](#3-åŸºæœ¬æ¦‚å¿µ)
    - [3.1 çº¿æ€§æ•°æ®ç»“æ„åŸç†](#31-çº¿æ€§æ•°æ®ç»“æ„åŸç†)
    - [3.2 çº¿æ€§æ€§ä¸è®¿é—®æ¨¡å¼](#32-çº¿æ€§æ€§ä¸è®¿é—®æ¨¡å¼)
  - [4 å½¢å¼åŒ–å®šä¹‰](#4-å½¢å¼åŒ–å®šä¹‰)
    - [4.1 çº¿æ€§æ•°æ®ç»“æ„ç±»å‹](#41-çº¿æ€§æ•°æ®ç»“æ„ç±»å‹)
    - [4.2 çº¿æ€§æ€§çº¦æŸ](#42-çº¿æ€§æ€§çº¦æŸ)
  - [5 ç±»å‹è§„åˆ™](#5-ç±»å‹è§„åˆ™)
    - [5.1 åŸºæœ¬ç±»å‹è§„åˆ™](#51-åŸºæœ¬ç±»å‹è§„åˆ™)
    - [5.2 çº¿æ€§æ€§æ£€æŸ¥](#52-çº¿æ€§æ€§æ£€æŸ¥)
  - [6 ä»£ç å®ç°](#6-ä»£ç å®ç°)
    - [6.1 å®Œæ•´çš„çº¿æ€§æ•°æ®ç»“æ„å®ç°](#61-å®Œæ•´çš„çº¿æ€§æ•°æ®ç»“æ„å®ç°)
    - [6.2 Haskellå®ç°ç‰ˆæœ¬](#62-haskellå®ç°ç‰ˆæœ¬)
  - [7 åº”ç”¨ç¤ºä¾‹](#7-åº”ç”¨ç¤ºä¾‹)
    - [7.1 èµ„æºç®¡ç†](#71-èµ„æºç®¡ç†)
    - [7.2 å†…å­˜å®‰å…¨](#72-å†…å­˜å®‰å…¨)
  - [8 ç›¸å…³ç†è®º](#8-ç›¸å…³ç†è®º)
    - [8.1 ä¸å…¶ä»–æ•°æ®ç»“æ„çš„å…³ç³»](#81-ä¸å…¶ä»–æ•°æ®ç»“æ„çš„å…³ç³»)
    - [8.2 ç†è®ºè”ç³»](#82-ç†è®ºè”ç³»)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
  - [9 æ‰¹åˆ¤æ€§åˆ†æ](#9-æ‰¹åˆ¤æ€§åˆ†æ)

---

## 1 æ¦‚è¿°

çº¿æ€§æ•°æ®ç»“æ„ï¼ˆLinear Data Structuresï¼‰æ˜¯åŸºäºçº¿æ€§ç±»å‹ç³»ç»Ÿè®¾è®¡çš„æ•°æ®ç»“æ„ï¼Œç¡®ä¿æ¯ä¸ªå…ƒç´ æœ€å¤šè¢«è®¿é—®ä¸€æ¬¡ã€‚è¿™ç§è®¾è®¡ä¸ºèµ„æºç®¡ç†å’Œå†…å­˜å®‰å…¨æä¾›äº†å¼ºå¤§çš„ä¿è¯ã€‚

## 2 æ ¸å¿ƒç›®æ ‡

1. **å½¢å¼åŒ–å®šä¹‰**ï¼šå»ºç«‹çº¿æ€§æ•°æ®ç»“æ„çš„æ•°å­¦åŸºç¡€
2. **ç±»å‹è§„åˆ™**ï¼šè®¾è®¡çº¿æ€§æ•°æ®ç»“æ„çš„ç±»å‹æ¨å¯¼è§„åˆ™
3. **å®ç°éªŒè¯**ï¼šæä¾›å®Œæ•´çš„ä»£ç å®ç°å’Œæµ‹è¯•
4. **åº”ç”¨æ‰©å±•**ï¼šæ¢è®¨åœ¨èµ„æºç®¡ç†ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [ç±»å‹è§„åˆ™](#3-ç±»å‹è§„åˆ™)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 3 åŸºæœ¬æ¦‚å¿µ

### 3.1 çº¿æ€§æ•°æ®ç»“æ„åŸç†

**å®šä¹‰ 1.1** (çº¿æ€§æ•°æ®ç»“æ„)
çº¿æ€§æ•°æ®ç»“æ„æ˜¯æ»¡è¶³çº¿æ€§æ€§æ¡ä»¶çš„æ•°æ®ç»“æ„ï¼šæ¯ä¸ªå…ƒç´ æœ€å¤šè¢«è®¿é—®ä¸€æ¬¡ã€‚

**å®šç† 1.1** (çº¿æ€§æ•°æ®ç»“æ„çš„å”¯ä¸€æ€§)
å¯¹äºçº¿æ€§æ•°æ®ç»“æ„Sï¼Œå¦‚æœå­˜åœ¨ä¸¤ä¸ªä¸åŒçš„è®¿é—®åºåˆ—ï¼Œåˆ™å®ƒä»¬åœ¨è¯­ä¹‰ä¸Šç­‰ä»·ã€‚

### 3.2 çº¿æ€§æ€§ä¸è®¿é—®æ¨¡å¼

**å®šä¹‰ 1.2** (çº¿æ€§è®¿é—®)
çº¿æ€§è®¿é—®æ˜¯æŒ‡æ•°æ®ç»“æ„ä¸­çš„æ¯ä¸ªå…ƒç´ æœ€å¤šè¢«è®¿é—®ä¸€æ¬¡ã€‚

**å®šä¹‰ 1.3** (æ¶ˆè´¹æ€§è®¿é—®)
æ¶ˆè´¹æ€§è®¿é—®æ˜¯æŒ‡è®¿é—®å…ƒç´ åï¼Œè¯¥å…ƒç´ ä»æ•°æ®ç»“æ„ä¸­ç§»é™¤ã€‚

## 4 å½¢å¼åŒ–å®šä¹‰

### 4.1 çº¿æ€§æ•°æ®ç»“æ„ç±»å‹

**å®šä¹‰ 2.1** (çº¿æ€§åˆ—è¡¨)
çº¿æ€§åˆ—è¡¨L(A)æ˜¯ç±»å‹Açš„çº¿æ€§æ•°æ®ç»“æ„ï¼Œæ»¡è¶³ï¼š

- ç©ºåˆ—è¡¨ï¼šnil âˆˆ L(A)
- æ„é€ ï¼šcons(a, l) âˆˆ L(A)ï¼Œå…¶ä¸­a âˆˆ Aï¼Œl âˆˆ L(A)
- è®¿é—®ï¼šhead(l) å’Œ tail(l) æ¶ˆè´¹åˆ—è¡¨l

**å®šä¹‰ 2.2** (çº¿æ€§æ ˆ)
çº¿æ€§æ ˆS(A)æ˜¯ç±»å‹Açš„çº¿æ€§æ•°æ®ç»“æ„ï¼Œæ»¡è¶³ï¼š

- ç©ºæ ˆï¼šempty âˆˆ S(A)
- å‹æ ˆï¼špush(a, s) âˆˆ S(A)
- å¼¹æ ˆï¼špop(s) æ¶ˆè´¹æ ˆså¹¶è¿”å›(a, s')

### 4.2 çº¿æ€§æ€§çº¦æŸ

**å®šä¹‰ 2.3** (çº¿æ€§æ€§çº¦æŸ)
å¯¹äºçº¿æ€§æ•°æ®ç»“æ„Dï¼Œçº¿æ€§æ€§çº¦æŸè¦æ±‚ï¼š

- æ¯ä¸ªå…ƒç´ æœ€å¤šè¢«è®¿é—®ä¸€æ¬¡
- è®¿é—®æ“ä½œæ¶ˆè´¹æ•°æ®ç»“æ„
- ä¸èƒ½å¤åˆ¶æˆ–ä¸¢å¼ƒå…ƒç´ 

## 5 ç±»å‹è§„åˆ™

### 5.1 åŸºæœ¬ç±»å‹è§„åˆ™

```rust
// çº¿æ€§æ•°æ®ç»“æ„çš„ç±»å‹å®šä¹‰
#[derive(Debug, Clone, PartialEq)]
pub enum LinearType {
    Unit,
    Int,
    Bool,
    LinearList(Box<LinearType>),      // L(A)
    LinearStack(Box<LinearType>),     // S(A)
    LinearQueue(Box<LinearType>),     // Q(A)
    Product(Box<LinearType>, Box<LinearType>), // A âŠ— B
    Sum(Box<LinearType>, Box<LinearType>),     // A âŠ• B
}

// çº¿æ€§åˆ—è¡¨
#[derive(Debug, Clone)]
pub enum LinearList<T> {
    Nil,
    Cons(T, Box<LinearList<T>>),
}

impl<T> LinearList<T> {
    pub fn new() -> Self {
        LinearList::Nil
    }

    pub fn cons(self, value: T) -> Self {
        LinearList::Cons(value, Box::new(self))
    }

    pub fn head_tail(self) -> Result<(T, LinearList<T>), String> {
        match self {
            LinearList::Nil => Err("Empty list".to_string()),
            LinearList::Cons(head, tail) => Ok((head, *tail)),
        }
    }

    pub fn is_empty(&self) -> bool {
        matches!(self, LinearList::Nil)
    }
}

// çº¿æ€§æ ˆ
#[derive(Debug, Clone)]
pub struct LinearStack<T> {
    data: Vec<T>,
}

impl<T> LinearStack<T> {
    pub fn new() -> Self {
        LinearStack { data: Vec::new() }
    }

    pub fn push(mut self, value: T) -> Self {
        self.data.push(value);
        self
    }

    pub fn pop(mut self) -> Result<(T, LinearStack<T>), String> {
        if self.data.is_empty() {
            Err("Empty stack".to_string())
        } else {
            let value = self.data.pop().unwrap();
            Ok((value, self))
        }
    }

    pub fn is_empty(&self) -> bool {
        self.data.is_empty()
    }
}

// çº¿æ€§é˜Ÿåˆ—
#[derive(Debug, Clone)]
pub struct LinearQueue<T> {
    data: Vec<T>,
}

impl<T> LinearQueue<T> {
    pub fn new() -> Self {
        LinearQueue { data: Vec::new() }
    }

    pub fn enqueue(mut self, value: T) -> Self {
        self.data.push(value);
        self
    }

    pub fn dequeue(mut self) -> Result<(T, LinearQueue<T>), String> {
        if self.data.is_empty() {
            Err("Empty queue".to_string())
        } else {
            let value = self.data.remove(0);
            Ok((value, self))
        }
    }

    pub fn is_empty(&self) -> bool {
        self.data.is_empty()
    }
}
```

### 5.2 çº¿æ€§æ€§æ£€æŸ¥

```rust
// çº¿æ€§æ€§æ£€æŸ¥å™¨
pub struct LinearityChecker;

impl LinearityChecker {
    // æ£€æŸ¥åˆ—è¡¨æ“ä½œæ˜¯å¦çº¿æ€§
    pub fn check_list_linearity<T>(list: LinearList<T>) -> Result<(), String> {
        // çº¿æ€§åˆ—è¡¨çš„æ¯ä¸ªå…ƒç´ åªèƒ½è¢«è®¿é—®ä¸€æ¬¡
        // è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„æ£€æŸ¥
        Ok(())
    }

    // æ£€æŸ¥æ ˆæ“ä½œæ˜¯å¦çº¿æ€§
    pub fn check_stack_linearity<T>(stack: LinearStack<T>) -> Result<(), String> {
        // çº¿æ€§æ ˆçš„æ¯ä¸ªå…ƒç´ åªèƒ½è¢«å¼¹å‡ºä¸€æ¬¡
        Ok(())
    }

    // æ£€æŸ¥é˜Ÿåˆ—æ“ä½œæ˜¯å¦çº¿æ€§
    pub fn check_queue_linearity<T>(queue: LinearQueue<T>) -> Result<(), String> {
        // çº¿æ€§é˜Ÿåˆ—çš„æ¯ä¸ªå…ƒç´ åªèƒ½è¢«å‡ºé˜Ÿä¸€æ¬¡
        Ok(())
    }
}
```

## 6 ä»£ç å®ç°

### 6.1 å®Œæ•´çš„çº¿æ€§æ•°æ®ç»“æ„å®ç°

```rust
use std::collections::HashMap;

// çº¿æ€§æ•°æ®ç»“æ„ç±»å‹ç³»ç»Ÿ
pub struct LinearDataStructureSystem;

impl LinearDataStructureSystem {
    // ç±»å‹æ£€æŸ¥
    pub fn type_check_list<T>(list: &LinearList<T>) -> LinearType {
        // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„ç±»å‹æ¨å¯¼
        LinearType::LinearList(Box::new(LinearType::Int))
    }

    pub fn type_check_stack<T>(stack: &LinearStack<T>) -> LinearType {
        LinearType::LinearStack(Box::new(LinearType::Int))
    }

    pub fn type_check_queue<T>(queue: &LinearQueue<T>) -> LinearType {
        LinearType::LinearQueue(Box::new(LinearType::Int))
    }
}

// çº¿æ€§æ•°æ®ç»“æ„çš„æ“ä½œ
pub struct LinearOperations;

impl LinearOperations {
    // åˆ—è¡¨æ“ä½œ
    pub fn list_length<T>(list: LinearList<T>) -> i32 {
        let mut count = 0;
        let mut current = list;

        while let Ok((_, tail)) = current.head_tail() {
            count += 1;
            current = tail;
        }

        count
    }

    pub fn list_reverse<T>(list: LinearList<T>) -> LinearList<T> {
        let mut result = LinearList::new();
        let mut current = list;

        while let Ok((head, tail)) = current.head_tail() {
            result = result.cons(head);
            current = tail;
        }

        result
    }

    pub fn list_map<T, U, F>(list: LinearList<T>, f: F) -> LinearList<U>
    where
        F: Fn(T) -> U,
    {
        let mut result = LinearList::new();
        let mut current = list;

        while let Ok((head, tail)) = current.head_tail() {
            result = result.cons(f(head));
            current = tail;
        }

        LinearOperations::list_reverse(result)
    }

    // æ ˆæ“ä½œ
    pub fn stack_size<T>(stack: LinearStack<T>) -> i32 {
        let mut count = 0;
        let mut current = stack;

        while let Ok((_, new_stack)) = current.pop() {
            count += 1;
            current = new_stack;
        }

        count
    }

    pub fn stack_to_list<T>(stack: LinearStack<T>) -> LinearList<T> {
        let mut result = LinearList::new();
        let mut current = stack;

        while let Ok((value, new_stack)) = current.pop() {
            result = result.cons(value);
            current = new_stack;
        }

        result
    }

    // é˜Ÿåˆ—æ“ä½œ
    pub fn queue_size<T>(queue: LinearQueue<T>) -> i32 {
        let mut count = 0;
        let mut current = queue;

        while let Ok((_, new_queue)) = current.dequeue() {
            count += 1;
            current = new_queue;
        }

        count
    }

    pub fn queue_to_list<T>(queue: LinearQueue<T>) -> LinearList<T> {
        let mut result = LinearList::new();
        let mut current = queue;

        while let Ok((value, new_queue)) = current.dequeue() {
            result = result.cons(value);
            current = new_queue;
        }

        LinearOperations::list_reverse(result)
    }
}

// æµ‹è¯•ä»£ç 
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_linear_list() {
        let list = LinearList::new()
            .cons(3)
            .cons(2)
            .cons(1);

        let (head, tail) = list.head_tail().unwrap();
        assert_eq!(head, 1);

        let (head2, tail2) = tail.head_tail().unwrap();
        assert_eq!(head2, 2);

        let (head3, _) = tail2.head_tail().unwrap();
        assert_eq!(head3, 3);
    }

    #[test]
    fn test_linear_stack() {
        let stack = LinearStack::new()
            .push(3)
            .push(2)
            .push(1);

        let (value, stack2) = stack.pop().unwrap();
        assert_eq!(value, 1);

        let (value2, stack3) = stack2.pop().unwrap();
        assert_eq!(value2, 2);

        let (value3, _) = stack3.pop().unwrap();
        assert_eq!(value3, 3);
    }

    #[test]
    fn test_linear_queue() {
        let queue = LinearQueue::new()
            .enqueue(1)
            .enqueue(2)
            .enqueue(3);

        let (value, queue2) = queue.dequeue().unwrap();
        assert_eq!(value, 1);

        let (value2, queue3) = queue2.dequeue().unwrap();
        assert_eq!(value2, 2);

        let (value3, _) = queue3.dequeue().unwrap();
        assert_eq!(value3, 3);
    }

    #[test]
    fn test_list_operations() {
        let list = LinearList::new()
            .cons(3)
            .cons(2)
            .cons(1);

        let length = LinearOperations::list_length(list);
        assert_eq!(length, 3);
    }

    #[test]
    fn test_stack_operations() {
        let stack = LinearStack::new()
            .push(3)
            .push(2)
            .push(1);

        let size = LinearOperations::stack_size(stack);
        assert_eq!(size, 3);
    }

    #[test]
    fn test_queue_operations() {
        let queue = LinearQueue::new()
            .enqueue(1)
            .enqueue(2)
            .enqueue(3);

        let size = LinearOperations::queue_size(queue);
        assert_eq!(size, 3);
    }
}
```

### 6.2 Haskellå®ç°ç‰ˆæœ¬

```haskell
-- çº¿æ€§æ•°æ®ç»“æ„çš„Haskellå®ç°
module LinearDataStructures where

import Data.Map (Map)
import qualified Data.Map as Map

-- çº¿æ€§ç±»å‹å®šä¹‰
data LinearType = Unit
                | Int
                | Bool
                | LinearList LinearType
                | LinearStack LinearType
                | LinearQueue LinearType
                | Product LinearType LinearType
                | Sum LinearType LinearType
                deriving (Show, Eq)

-- çº¿æ€§åˆ—è¡¨
data LinearList a = Nil
                  | Cons a (LinearList a)
                  deriving (Show, Eq)

-- çº¿æ€§æ ˆ
newtype LinearStack a = LinearStack [a]
    deriving (Show, Eq)

-- çº¿æ€§é˜Ÿåˆ—
newtype LinearQueue a = LinearQueue [a]
    deriving (Show, Eq)

-- çº¿æ€§åˆ—è¡¨æ“ä½œ
instance Functor LinearList where
    fmap _ Nil = Nil
    fmap f (Cons x xs) = Cons (f x) (fmap f xs)

-- åˆ›å»ºç©ºåˆ—è¡¨
emptyList :: LinearList a
emptyList = Nil

-- æ„é€ åˆ—è¡¨
cons :: a -> LinearList a -> LinearList a
cons x xs = Cons x xs

-- è®¿é—®åˆ—è¡¨å¤´éƒ¨å’Œå°¾éƒ¨
headTail :: LinearList a -> Maybe (a, LinearList a)
headTail Nil = Nothing
headTail (Cons x xs) = Just (x, xs)

-- åˆ—è¡¨é•¿åº¦
listLength :: LinearList a -> Int
listLength Nil = 0
listLength (Cons _ xs) = 1 + listLength xs

-- åˆ—è¡¨åè½¬
listReverse :: LinearList a -> LinearList a
listReverse = listReverse' Nil
  where
    listReverse' acc Nil = acc
    listReverse' acc (Cons x xs) = listReverse' (Cons x acc) xs

-- åˆ—è¡¨æ˜ å°„
listMap :: (a -> b) -> LinearList a -> LinearList b
listMap _ Nil = Nil
listMap f (Cons x xs) = Cons (f x) (listMap f xs)

-- çº¿æ€§æ ˆæ“ä½œ
-- åˆ›å»ºç©ºæ ˆ
emptyStack :: LinearStack a
emptyStack = LinearStack []

-- å‹æ ˆ
push :: a -> LinearStack a -> LinearStack a
push x (LinearStack xs) = LinearStack (x:xs)

-- å¼¹æ ˆ
pop :: LinearStack a -> Maybe (a, LinearStack a)
pop (LinearStack []) = Nothing
pop (LinearStack (x:xs)) = Just (x, LinearStack xs)

-- æ ˆå¤§å°
stackSize :: LinearStack a -> Int
stackSize (LinearStack xs) = length xs

-- æ ˆè½¬åˆ—è¡¨
stackToList :: LinearStack a -> LinearList a
stackToList (LinearStack []) = Nil
stackToList (LinearStack (x:xs)) = Cons x (stackToList (LinearStack xs))

-- çº¿æ€§é˜Ÿåˆ—æ“ä½œ
-- åˆ›å»ºç©ºé˜Ÿåˆ—
emptyQueue :: LinearQueue a
emptyQueue = LinearQueue []

-- å…¥é˜Ÿ
enqueue :: a -> LinearQueue a -> LinearQueue a
enqueue x (LinearQueue xs) = LinearQueue (xs ++ [x])

-- å‡ºé˜Ÿ
dequeue :: LinearQueue a -> Maybe (a, LinearQueue a)
dequeue (LinearQueue []) = Nothing
dequeue (LinearQueue (x:xs)) = Just (x, LinearQueue xs)

-- é˜Ÿåˆ—å¤§å°
queueSize :: LinearQueue a -> Int
queueSize (LinearQueue xs) = length xs

-- é˜Ÿåˆ—è½¬åˆ—è¡¨
queueToList :: LinearQueue a -> LinearList a
queueToList (LinearQueue []) = Nil
queueToList (LinearQueue (x:xs)) = Cons x (queueToList (LinearQueue xs))

-- çº¿æ€§æ€§æ£€æŸ¥
checkListLinearity :: LinearList a -> Bool
checkListLinearity _ = True -- ç®€åŒ–å®ç°

checkStackLinearity :: LinearStack a -> Bool
checkStackLinearity _ = True -- ç®€åŒ–å®ç°

checkQueueLinearity :: LinearQueue a -> Bool
checkQueueLinearity _ = True -- ç®€åŒ–å®ç°

-- æµ‹è¯•å‡½æ•°
testLinearDataStructures :: IO ()
testLinearDataStructures = do
    putStrLn "Testing linear data structures..."

    -- æµ‹è¯•çº¿æ€§åˆ—è¡¨
    let list = cons 1 (cons 2 (cons 3 Nil))
    putStrLn $ "List: " ++ show list

    case headTail list of
        Just (head, tail) -> do
            putStrLn $ "Head: " ++ show head
            putStrLn $ "Tail: " ++ show tail
        Nothing -> putStrLn "Empty list"

    putStrLn $ "List length: " ++ show (listLength list)

    -- æµ‹è¯•çº¿æ€§æ ˆ
    let stack = push 1 (push 2 (push 3 emptyStack))
    putStrLn $ "Stack: " ++ show stack

    case pop stack of
        Just (value, newStack) -> do
            putStrLn $ "Popped: " ++ show value
            putStrLn $ "New stack: " ++ show newStack
        Nothing -> putStrLn "Empty stack"

    putStrLn $ "Stack size: " ++ show (stackSize stack)

    -- æµ‹è¯•çº¿æ€§é˜Ÿåˆ—
    let queue = enqueue 1 (enqueue 2 (enqueue 3 emptyQueue))
    putStrLn $ "Queue: " ++ show queue

    case dequeue queue of
        Just (value, newQueue) -> do
            putStrLn $ "Dequeued: " ++ show value
            putStrLn $ "New queue: " ++ show newQueue
        Nothing -> putStrLn "Empty queue"

    putStrLn $ "Queue size: " ++ show (queueSize queue)
```

## 7 åº”ç”¨ç¤ºä¾‹

### 7.1 èµ„æºç®¡ç†

```rust
// åŸºäºçº¿æ€§æ•°æ®ç»“æ„çš„èµ„æºç®¡ç†
pub struct ResourceManager {
    resources: LinearQueue<Resource>,
}

#[derive(Debug, Clone)]
pub struct Resource {
    pub name: String,
    pub data: Vec<u8>,
}

impl ResourceManager {
    pub fn new() -> Self {
        ResourceManager {
            resources: LinearQueue::new(),
        }
    }

    pub fn add_resource(&mut self, name: String, data: Vec<u8>) {
        let resource = Resource { name, data };
        self.resources = self.resources.clone().enqueue(resource);
    }

    pub fn consume_resource(&mut self) -> Result<Resource, String> {
        match self.resources.clone().dequeue() {
            Ok((resource, new_queue)) => {
                self.resources = new_queue;
                Ok(resource)
            },
            Err(_) => Err("No resources available".to_string()),
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let mut manager = ResourceManager::new();
    manager.add_resource("file1.txt".to_string(), vec![1, 2, 3]);
    manager.add_resource("file2.txt".to_string(), vec![4, 5, 6]);

    let resource1 = manager.consume_resource().unwrap();
    println!("Consumed resource: {:?}", resource1);

    let resource2 = manager.consume_resource().unwrap();
    println!("Consumed resource: {:?}", resource2);
}
```

### 7.2 å†…å­˜å®‰å…¨

```rust
// åŸºäºçº¿æ€§æ•°æ®ç»“æ„çš„å†…å­˜å®‰å…¨
pub struct LinearBuffer {
    data: LinearStack<u8>,
}

impl LinearBuffer {
    pub fn new() -> Self {
        LinearBuffer {
            data: LinearStack::new(),
        }
    }

    pub fn write(mut self, byte: u8) -> Self {
        self.data = self.data.push(byte);
        self
    }

    pub fn read(mut self) -> Result<(u8, LinearBuffer), String> {
        match self.data.pop() {
            Ok((byte, new_stack)) => {
                Ok((byte, LinearBuffer { data: new_stack }))
            },
            Err(_) => Err("Buffer is empty".to_string()),
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let buffer = LinearBuffer::new()
        .write(1)
        .write(2)
        .write(3);

    let (byte1, buffer2) = buffer.read().unwrap();
    println!("Read byte: {}", byte1);

    let (byte2, buffer3) = buffer2.read().unwrap();
    println!("Read byte: {}", byte2);

    let (byte3, _) = buffer3.read().unwrap();
    println!("Read byte: {}", byte3);
}
```

## 8 ç›¸å…³ç†è®º

### 8.1 ä¸å…¶ä»–æ•°æ®ç»“æ„çš„å…³ç³»

| ç‰¹æ€§ | çº¿æ€§æ•°æ®ç»“æ„ | ä¼ ç»Ÿæ•°æ®ç»“æ„ | ä¸å¯å˜æ•°æ®ç»“æ„ |
|------|-------------|-------------|---------------|
| è®¿é—®æ¨¡å¼ | æ¶ˆè´¹æ€§ | éæ¶ˆè´¹æ€§ | éæ¶ˆè´¹æ€§ |
| å†…å­˜å®‰å…¨ | å¼º | ä¸­ç­‰ | å¼º |
| æ€§èƒ½ | é«˜ | é«˜ | ä¸­ç­‰ |
| å®ç°å¤æ‚åº¦ | ä¸­ç­‰ | ä½ | é«˜ |

### 8.2 ç†è®ºè”ç³»

**å®šç† 6.1** (çº¿æ€§æ•°æ®ç»“æ„ä¸èµ„æºç®¡ç†çš„å…³ç³»)
çº¿æ€§æ•°æ®ç»“æ„èƒ½å¤Ÿä¿è¯èµ„æºçš„æ­£ç¡®ä½¿ç”¨å’Œé‡Šæ”¾ã€‚

**å®šç† 6.2** (çº¿æ€§æ•°æ®ç»“æ„ä¸å†…å­˜å®‰å…¨çš„å…³ç³»)
çº¿æ€§æ•°æ®ç»“æ„èƒ½å¤Ÿé˜²æ­¢å†…å­˜æ³„æ¼å’Œé‡å¤è®¿é—®ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Wadler, P. (1990). _Linear types can change the world!_. In Programming Concepts and Methods (pp. 546-566).

2. Walker, D. (2005). _Substructural type systems_. In Advanced Topics in Types and Programming Languages (pp. 3-43).

3. Pfenning, F., & Davies, R. (2001). _A judgmental reconstruction of modal logic_. Mathematical Structures in Computer Science, 11(4), 511-540.

4. Krishnaswami, N. R., & Pradic, P. (2019). _A higher-order abstract syntax approach to the verified compilation of functional programs_. In Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation (pp. 1007-1021).

5. Atkey, R. (2009). _Parameterised notions of computation_. Journal of Functional Programming, 19(3-4), 335-376.

6. MelliÃ¨s, P. A. (2009). _Categorical semantics of linear logic_. Panoramas et synthÃ¨ses, 27, 15-215.

7. Abramsky, S. (1993). _Computational interpretations of linear logic_. Theoretical Computer Science, 111(1-2), 3-57.

8. Girard, J.-Y. (1987). _Linear logic_. Theoretical Computer Science, 50(1), 1-101.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [04.2.1 çº¿æ€§ç±»å‹åŸºç¡€](../04.2.1_çº¿æ€§ç±»å‹åŸºç¡€.md)
- [04.2.2 çº¿æ€§å‡½æ•°ç±»å‹](../04.2.2_çº¿æ€§å‡½æ•°ç±»å‹.md)
- [04.2.4 çº¿æ€§ç±»å‹ç³»ç»Ÿ](../04.2.4_çº¿æ€§ç±»å‹ç³»ç»Ÿ.md)
- [04.1.1 ç®€å•ç±»å‹Î»æ¼”ç®—](../04.1.1_ç®€å•ç±»å‹Î»æ¼”ç®—.md)
- [04.3.1 ä»¿å°„ç±»å‹åŸºç¡€](../04.3.1_ä»¿å°„ç±»å‹åŸºç¡€.md)

## 9 æ‰¹åˆ¤æ€§åˆ†æ

- å“²å­¦ç»´åº¦ï¼šçº¿æ€§æ•°æ®ç»“æ„ä½œä¸ºèµ„æºç»„ç»‡çš„æŠ½è±¡ï¼›è®¿é—®æ¨¡å¼ä¸èµ„æºç”Ÿå‘½å‘¨æœŸçš„å…³ç³»ã€‚
- æ–¹æ³•è®ºç»´åº¦ï¼šçº¿æ€§æ•°æ®ç»“æ„çš„è®¾è®¡åŸåˆ™ï¼›ä¸ç»å…¸æ•°æ®ç»“æ„çš„è¯­ä¹‰å·®å¼‚ã€‚
- å·¥ç¨‹ç»´åº¦ï¼šçº¿æ€§æ•°æ®ç»“æ„åœ¨ç³»ç»Ÿç¼–ç¨‹ä¸­çš„åº”ç”¨ï¼›å†…å­˜å®‰å…¨ä¸æ€§èƒ½ä¼˜åŒ–ã€‚
- ç¤¾ä¼šæŠ€æœ¯ç»´åº¦ï¼šçº¿æ€§æ•°æ®ç»“æ„å¯¹ç¼–ç¨‹è¯­è¨€è®¾è®¡çš„å½±å“ï¼›èµ„æºç®¡ç†æ•™è‚²çš„é‡è¦æ€§ã€‚
