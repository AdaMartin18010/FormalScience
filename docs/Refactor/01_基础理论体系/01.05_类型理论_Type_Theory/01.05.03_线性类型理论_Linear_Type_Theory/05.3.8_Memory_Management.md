# 04.3.8 å†…å­˜ç®¡ç†

## ğŸ“‹ ç›®å½•

- [04.3.8 å†…å­˜ç®¡ç†](#0438-å†…å­˜ç®¡ç†)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 æ¦‚è¿°](#1-æ¦‚è¿°)
  - [2 æ ¸å¿ƒç›®æ ‡](#2-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•-1)
  - [3 åŸºæœ¬æ¦‚å¿µ](#3-åŸºæœ¬æ¦‚å¿µ)
    - [3.1 å†…å­˜ç®¡ç†åŸºç¡€](#31-å†…å­˜ç®¡ç†åŸºç¡€)
    - [3.2 å†…å­˜ç®¡ç†ç­–ç•¥](#32-å†…å­˜ç®¡ç†ç­–ç•¥)
  - [4 å½¢å¼åŒ–å®šä¹‰](#4-å½¢å¼åŒ–å®šä¹‰)
    - [4.1 å†…å­˜æ¨¡å‹](#41-å†…å­˜æ¨¡å‹)
    - [4.2 åƒåœ¾å›æ”¶ç†è®º](#42-åƒåœ¾å›æ”¶ç†è®º)
  - [5 å®šç†ä¸è¯æ˜](#5-å®šç†ä¸è¯æ˜)
    - [5.1 å†…å­˜ç®¡ç†åŸºæœ¬å®šç†](#51-å†…å­˜ç®¡ç†åŸºæœ¬å®šç†)
    - [5.2 å†…å­˜å®‰å…¨å®šç†](#52-å†…å­˜å®‰å…¨å®šç†)
  - [6 ä»£ç å®ç°](#6-ä»£ç å®ç°)
    - [6.1 å†…å­˜åˆ†é…å™¨](#61-å†…å­˜åˆ†é…å™¨)
    - [6.2 å†…å­˜å®‰å…¨æ£€æŸ¥å™¨](#62-å†…å­˜å®‰å…¨æ£€æŸ¥å™¨)
    - [6.3 å†…å­˜æ± å®ç°](#63-å†…å­˜æ± å®ç°)
  - [7 åº”ç”¨ç¤ºä¾‹](#7-åº”ç”¨ç¤ºä¾‹)
    - [7.1 å†…å­˜åˆ†é…å™¨ä½¿ç”¨](#71-å†…å­˜åˆ†é…å™¨ä½¿ç”¨)
  - [8 ç›¸å…³ç†è®º](#8-ç›¸å…³ç†è®º)
    - [8.1 ä¸ç±»å‹ç†è®ºçš„å…³ç³»](#81-ä¸ç±»å‹ç†è®ºçš„å…³ç³»)
    - [8.2 ä¸ç³»ç»Ÿç¼–ç¨‹çš„å…³ç³»](#82-ä¸ç³»ç»Ÿç¼–ç¨‹çš„å…³ç³»)
    - [8.3 ä¸åƒåœ¾å›æ”¶çš„å…³ç³»](#83-ä¸åƒåœ¾å›æ”¶çš„å…³ç³»)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
  - [9 æ‰¹åˆ¤æ€§åˆ†æ](#9-æ‰¹åˆ¤æ€§åˆ†æ)

---

## 1 æ¦‚è¿°

å†…å­˜ç®¡ç†æ˜¯ç¼–ç¨‹è¯­è¨€ç†è®ºçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œç ”ç©¶ç¨‹åºè¿è¡Œæ—¶å†…å­˜çš„åˆ†é…ã€ä½¿ç”¨å’Œå›æ”¶ã€‚æœ¬æ–‡æ¡£å»ºç«‹ä¸¥æ ¼çš„å†…å­˜ç®¡ç†ç†è®ºæ¡†æ¶ï¼ŒåŒ…å«å†…å­˜åˆ†é…ç­–ç•¥ã€åƒåœ¾å›æ”¶ç®—æ³•ã€å†…å­˜å®‰å…¨ä¿è¯ç­‰å†…å®¹ã€‚

## 2 æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹å†…å­˜ç®¡ç†çš„åŸºæœ¬æ¦‚å¿µå’Œå½¢å¼åŒ–å®šä¹‰
2. åˆ†æä¸åŒå†…å­˜ç®¡ç†ç­–ç•¥çš„ç†è®ºåŸºç¡€
3. ç ”ç©¶åƒåœ¾å›æ”¶ç®—æ³•çš„è®¾è®¡åŸç†
4. æä¾›å†…å­˜å®‰å…¨çš„å½¢å¼åŒ–ä¿è¯

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 3 åŸºæœ¬æ¦‚å¿µ

### 3.1 å†…å­˜ç®¡ç†åŸºç¡€

**å®šä¹‰ 1.1.1** (å†…å­˜ç©ºé—´)
å†…å­˜ç©ºé—´æ˜¯ç¨‹åºå¯ç”¨çš„åœ°å€ç©ºé—´ï¼Œè¡¨ç¤ºä¸ºï¼š
$$M = \{0, 1, 2, \ldots, N-1\}$$
å…¶ä¸­ $N$ æ˜¯å†…å­˜å¤§å°ã€‚

**å®šä¹‰ 1.1.2** (å†…å­˜åˆ†é…)
å†…å­˜åˆ†é…æ˜¯å°†å†…å­˜ç©ºé—´åˆ†é…ç»™ç¨‹åºå¯¹è±¡çš„è¿‡ç¨‹ï¼š
$$alloc: Size \rightarrow Address \cup \{\bot\}$$
å…¶ä¸­ $Size$ æ˜¯å¯¹è±¡å¤§å°ï¼Œ$Address$ æ˜¯å†…å­˜åœ°å€ï¼Œ$\bot$ è¡¨ç¤ºåˆ†é…å¤±è´¥ã€‚

**å®šä¹‰ 1.1.3** (å†…å­˜é‡Šæ”¾)
å†…å­˜é‡Šæ”¾æ˜¯å›æ”¶ä¸å†ä½¿ç”¨çš„å†…å­˜ç©ºé—´ï¼š
$$free: Address \rightarrow \{true, false\}$$

### 3.2 å†…å­˜ç®¡ç†ç­–ç•¥

**å®šä¹‰ 1.2.1** (æ‰‹åŠ¨å†…å­˜ç®¡ç†)
æ‰‹åŠ¨å†…å­˜ç®¡ç†è¦æ±‚ç¨‹åºå‘˜æ˜¾å¼åˆ†é…å’Œé‡Šæ”¾å†…å­˜ï¼š

- ä¼˜ç‚¹ï¼šç²¾ç¡®æ§åˆ¶ï¼Œæ— è¿è¡Œæ—¶å¼€é”€
- ç¼ºç‚¹ï¼šå®¹æ˜“å‡ºé”™ï¼Œå†…å­˜æ³„æ¼ï¼Œæ‚¬å‚æŒ‡é’ˆ

**å®šä¹‰ 1.2.2** (è‡ªåŠ¨å†…å­˜ç®¡ç†)
è‡ªåŠ¨å†…å­˜ç®¡ç†ç”±è¿è¡Œæ—¶ç³»ç»Ÿè‡ªåŠ¨ç®¡ç†å†…å­˜ï¼š

- ä¼˜ç‚¹ï¼šå®‰å…¨ï¼Œæ— å†…å­˜æ³„æ¼
- ç¼ºç‚¹ï¼šè¿è¡Œæ—¶å¼€é”€ï¼Œä¸ç¡®å®šæ€§

**å®šä¹‰ 1.2.3** (æ‰€æœ‰æƒå†…å­˜ç®¡ç†)
æ‰€æœ‰æƒå†…å­˜ç®¡ç†åŸºäºæ‰€æœ‰æƒç³»ç»Ÿï¼š

- ä¼˜ç‚¹ï¼šç¼–è¯‘æ—¶ä¿è¯ï¼Œé›¶è¿è¡Œæ—¶å¼€é”€
- ç¼ºç‚¹ï¼šç¼–ç¨‹å¤æ‚æ€§å¢åŠ 

## 4 å½¢å¼åŒ–å®šä¹‰

### 4.1 å†…å­˜æ¨¡å‹

**å®šä¹‰ 2.1.1** (å†…å­˜çŠ¶æ€)
å†…å­˜çŠ¶æ€ $S = (H, F, A)$ å…¶ä¸­ï¼š

- $H$ æ˜¯å †å†…å­˜æ˜ å°„ï¼š$Address \rightarrow Value$
- $F$ æ˜¯ç©ºé—²å†…å­˜é›†åˆ
- $A$ æ˜¯å·²åˆ†é…å†…å­˜é›†åˆ

**å®šä¹‰ 2.1.2** (å†…å­˜æ“ä½œ)
å†…å­˜æ“ä½œåŒ…æ‹¬ï¼š

- åˆ†é…ï¼š$S \xrightarrow{alloc(size)} S'$
- é‡Šæ”¾ï¼š$S \xrightarrow{free(addr)} S'$
- è¯»å–ï¼š$S \xrightarrow{read(addr)} value$
- å†™å…¥ï¼š$S \xrightarrow{write(addr, value)} S'$

**å®šä¹‰ 2.1.3** (å†…å­˜å®‰å…¨)
å†…å­˜å®‰å…¨è¦æ±‚ï¼š

- æ— æ‚¬å‚æŒ‡é’ˆï¼š$\forall addr \in A, addr \in F \Rightarrow addr \notin A$
- æ— è¶Šç•Œè®¿é—®ï¼š$\forall addr \in A, addr + size(addr) \leq N$
- æ— é‡å¤é‡Šæ”¾ï¼š$\forall addr \in F, addr \notin A$

### 4.2 åƒåœ¾å›æ”¶ç†è®º

**å®šä¹‰ 2.2.1** (å¯è¾¾æ€§)
å¯¹è±¡ $o$ æ˜¯å¯è¾¾çš„ï¼Œå½“ä¸”ä»…å½“ï¼š

- $o$ æ˜¯æ ¹å¯¹è±¡ï¼Œæˆ–
- å­˜åœ¨å¯è¾¾å¯¹è±¡ $o'$ å¼•ç”¨ $o$

**å®šä¹‰ 2.2.2** (åƒåœ¾å¯¹è±¡)
åƒåœ¾å¯¹è±¡æ˜¯ä¸å¯è¾¾çš„å¯¹è±¡ï¼š
$$Garbage = \{o \in Objects \mid \neg Reachable(o)\}$$

**å®šä¹‰ 2.2.3** (åƒåœ¾å›æ”¶)
åƒåœ¾å›æ”¶æ˜¯è¯†åˆ«å’Œå›æ”¶åƒåœ¾å¯¹è±¡çš„è¿‡ç¨‹ï¼š
$$GC: MemoryState \rightarrow MemoryState$$

## 5 å®šç†ä¸è¯æ˜

### 5.1 å†…å­˜ç®¡ç†åŸºæœ¬å®šç†

**å®šç† 3.1.1** (å†…å­˜åˆ†é…å®šç†)
å¦‚æœå†…å­˜ä¸­æœ‰è¶³å¤Ÿçš„è¿ç»­ç©ºé—²ç©ºé—´ï¼Œåˆ™åˆ†é…æ“ä½œæˆåŠŸã€‚

**è¯æ˜**ï¼š
è®¾ $F$ æ˜¯ç©ºé—²å†…å­˜é›†åˆï¼Œ$size$ æ˜¯è¯·æ±‚çš„å¤§å°ã€‚
å¦‚æœå­˜åœ¨è¿ç»­çš„ç©ºé—²åŒºåŸŸ $[addr, addr + size) \subseteq F$ï¼Œ
åˆ™ $alloc(size) = addr$ æˆåŠŸã€‚

**å®šç† 3.1.2** (åƒåœ¾å›æ”¶æ­£ç¡®æ€§å®šç†)
åƒåœ¾å›æ”¶ä¸ä¼šå›æ”¶å¯è¾¾å¯¹è±¡ã€‚

**è¯æ˜**ï¼š
é€šè¿‡å¯è¾¾æ€§å®šä¹‰ï¼Œåƒåœ¾å›æ”¶åªå›æ”¶ä¸å¯è¾¾å¯¹è±¡ï¼š
$$\forall o \in Objects, Reachable(o) \Rightarrow o \notin Garbage$$
å› æ­¤ï¼Œå¯è¾¾å¯¹è±¡ä¸ä¼šè¢«å›æ”¶ã€‚

### 5.2 å†…å­˜å®‰å…¨å®šç†

**å®šç† 3.2.1** (æ‰€æœ‰æƒå†…å­˜å®‰å…¨å®šç†)
æ‰€æœ‰æƒç³»ç»Ÿä¿è¯å†…å­˜å®‰å…¨ã€‚

**è¯æ˜**ï¼š

1. æ¯ä¸ªå¯¹è±¡åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…
2. æ‰€æœ‰è€…è´Ÿè´£å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸ
3. å¯¹è±¡ç¦»å¼€ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾
4. å€Ÿç”¨æ£€æŸ¥é˜²æ­¢æ‚¬å‚æŒ‡é’ˆ

**å®šç† 3.2.2** (åƒåœ¾å›æ”¶å®‰å…¨å®šç†)
æ ‡è®°-æ¸…é™¤åƒåœ¾å›æ”¶ç®—æ³•æ˜¯å®‰å…¨çš„ã€‚

**è¯æ˜**ï¼š

1. æ ‡è®°é˜¶æ®µï¼šæ ‡è®°æ‰€æœ‰å¯è¾¾å¯¹è±¡
2. æ¸…é™¤é˜¶æ®µï¼šå›æ”¶æœªæ ‡è®°å¯¹è±¡
3. åªæœ‰ä¸å¯è¾¾å¯¹è±¡è¢«å›æ”¶
4. å¯è¾¾å¯¹è±¡ä¿æŒä¸å˜

## 6 ä»£ç å®ç°

### 6.1 å†…å­˜åˆ†é…å™¨

```rust
use std::collections::BTreeMap;

/// å†…å­˜å—
#[derive(Debug, Clone)]
struct MemoryBlock {
    address: usize,
    size: usize,
    is_allocated: bool,
}

/// å†…å­˜åˆ†é…å™¨
#[derive(Debug)]
struct MemoryAllocator {
    blocks: BTreeMap<usize, MemoryBlock>,
    total_size: usize,
    allocated_size: usize,
}

impl MemoryAllocator {
    /// åˆ›å»ºå†…å­˜åˆ†é…å™¨
    fn new(total_size: usize) -> Self {
        let mut blocks = BTreeMap::new();
        blocks.insert(0, MemoryBlock {
            address: 0,
            size: total_size,
            is_allocated: false,
        });

        MemoryAllocator {
            blocks,
            total_size,
            allocated_size: 0,
        }
    }

    /// åˆ†é…å†…å­˜
    fn allocate(&mut self, size: usize) -> Option<usize> {
        // æŸ¥æ‰¾æœ€ä½³åŒ¹é…çš„ç©ºé—²å—
        let mut best_fit = None;
        let mut min_waste = usize::MAX;

        for (&addr, block) in &self.blocks {
            if !block.is_allocated && block.size >= size {
                let waste = block.size - size;
                if waste < min_waste {
                    min_waste = waste;
                    best_fit = Some(addr);
                }
            }
        }

        if let Some(addr) = best_fit {
            self.split_block(addr, size);
            self.allocated_size += size;
            Some(addr)
        } else {
            None
        }
    }

    /// åˆ†å‰²å†…å­˜å—
    fn split_block(&mut self, addr: usize, size: usize) {
        if let Some(block) = self.blocks.get(&addr) {
            if block.size > size {
                // åˆ†å‰²å—
                let new_addr = addr + size;
                let new_size = block.size - size;

                self.blocks.insert(new_addr, MemoryBlock {
                    address: new_addr,
                    size: new_size,
                    is_allocated: false,
                });
            }

            // æ›´æ–°åŸå—
            self.blocks.insert(addr, MemoryBlock {
                address: addr,
                size,
                is_allocated: true,
            });
        }
    }

    /// é‡Šæ”¾å†…å­˜
    fn deallocate(&mut self, addr: usize) -> bool {
        if let Some(block) = self.blocks.get(&addr) {
            if block.is_allocated {
                // æ ‡è®°ä¸ºæœªåˆ†é…
                self.blocks.insert(addr, MemoryBlock {
                    address: addr,
                    size: block.size,
                    is_allocated: false,
                });

                self.allocated_size -= block.size;

                // åˆå¹¶ç›¸é‚»çš„ç©ºé—²å—
                self.merge_blocks();

                true
            } else {
                false
            }
        } else {
            false
        }
    }

    /// åˆå¹¶ç›¸é‚»çš„ç©ºé—²å—
    fn merge_blocks(&mut self) {
        let mut to_remove = Vec::new();
        let mut to_add = Vec::new();

        let mut blocks: Vec<_> = self.blocks.iter().collect();
        blocks.sort_by_key(|(addr, _)| **addr);

        for i in 0..blocks.len() - 1 {
            let (addr1, block1) = blocks[i];
            let (addr2, block2) = blocks[i + 1];

            if !block1.is_allocated && !block2.is_allocated {
                // åˆå¹¶ç›¸é‚»çš„ç©ºé—²å—
                to_remove.push(**addr1);
                to_remove.push(**addr2);

                to_add.push((**addr1, MemoryBlock {
                    address: **addr1,
                    size: block1.size + block2.size,
                    is_allocated: false,
                }));
            }
        }

        // æ‰§è¡Œåˆå¹¶
        for addr in to_remove {
            self.blocks.remove(&addr);
        }

        for (addr, block) in to_add {
            self.blocks.insert(addr, block);
        }
    }

    /// è·å–å†…å­˜ä½¿ç”¨æƒ…å†µ
    fn get_memory_info(&self) -> (usize, usize, f64) {
        let used = self.allocated_size;
        let total = self.total_size;
        let usage = used as f64 / total as f64;
        (used, total, usage)
    }
}

/// åƒåœ¾å›æ”¶å™¨
#[derive(Debug)]
struct GarbageCollector {
    objects: HashMap<usize, GCObject>,
    roots: HashSet<usize>,
    mark_phase: bool,
}

#[derive(Debug, Clone)]
struct GCObject {
    id: usize,
    size: usize,
    references: Vec<usize>,
    marked: bool,
}

impl GarbageCollector {
    /// åˆ›å»ºåƒåœ¾å›æ”¶å™¨
    fn new() -> Self {
        GarbageCollector {
            objects: HashMap::new(),
            roots: HashSet::new(),
            mark_phase: false,
        }
    }

    /// åˆ›å»ºå¯¹è±¡
    fn create_object(&mut self, size: usize) -> usize {
        let id = self.objects.len();
        let object = GCObject {
            id,
            size,
            references: Vec::new(),
            marked: false,
        };

        self.objects.insert(id, object);
        id
    }

    /// æ·»åŠ æ ¹å¯¹è±¡
    fn add_root(&mut self, object_id: usize) {
        self.roots.insert(object_id);
    }

    /// ç§»é™¤æ ¹å¯¹è±¡
    fn remove_root(&mut self, object_id: usize) {
        self.roots.remove(&object_id);
    }

    /// æ·»åŠ å¼•ç”¨
    fn add_reference(&mut self, from: usize, to: usize) {
        if let Some(object) = self.objects.get_mut(&from) {
            object.references.push(to);
        }
    }

    /// æ ‡è®°é˜¶æ®µ
    fn mark_phase(&mut self) {
        // é‡ç½®æ‰€æœ‰æ ‡è®°
        for object in self.objects.values_mut() {
            object.marked = false;
        }

        // ä»æ ¹å¯¹è±¡å¼€å§‹æ ‡è®°
        for &root_id in &self.roots {
            self.mark_object(root_id);
        }
    }

    /// æ ‡è®°å¯¹è±¡åŠå…¶å¼•ç”¨
    fn mark_object(&mut self, object_id: usize) {
        if let Some(object) = self.objects.get_mut(&object_id) {
            if !object.marked {
                object.marked = true;

                // é€’å½’æ ‡è®°å¼•ç”¨çš„å¯¹è±¡
                for &ref_id in &object.references {
                    self.mark_object(ref_id);
                }
            }
        }
    }

    /// æ¸…é™¤é˜¶æ®µ
    fn sweep_phase(&mut self) -> usize {
        let mut freed_objects = 0;
        let mut to_remove = Vec::new();

        for (id, object) in &self.objects {
            if !object.marked {
                to_remove.push(*id);
                freed_objects += 1;
            }
        }

        // ç§»é™¤æœªæ ‡è®°çš„å¯¹è±¡
        for id in to_remove {
            self.objects.remove(&id);
        }

        freed_objects
    }

    /// æ‰§è¡Œåƒåœ¾å›æ”¶
    fn collect_garbage(&mut self) -> usize {
        self.mark_phase();
        self.sweep_phase()
    }

    /// è·å–å†…å­˜ä½¿ç”¨æƒ…å†µ
    fn get_memory_info(&self) -> (usize, usize) {
        let total_objects = self.objects.len();
        let total_size: usize = self.objects.values().map(|obj| obj.size).sum();
        (total_objects, total_size)
    }
}
```

### 6.2 å†…å­˜å®‰å…¨æ£€æŸ¥å™¨

```rust
/// å†…å­˜å®‰å…¨æ£€æŸ¥å™¨
#[derive(Debug)]
struct MemorySafetyChecker {
    allocated_regions: HashMap<usize, MemoryRegion>,
    access_log: Vec<MemoryAccess>,
}

#[derive(Debug, Clone)]
struct MemoryRegion {
    address: usize,
    size: usize,
    owner: String,
    access_count: usize,
}

#[derive(Debug, Clone)]
struct MemoryAccess {
    address: usize,
    size: usize,
    access_type: AccessType,
    timestamp: u64,
}

#[derive(Debug, Clone)]
enum AccessType {
    Read,
    Write,
    Allocate,
    Deallocate,
}

impl MemorySafetyChecker {
    /// åˆ›å»ºå†…å­˜å®‰å…¨æ£€æŸ¥å™¨
    fn new() -> Self {
        MemorySafetyChecker {
            allocated_regions: HashMap::new(),
            access_log: Vec::new(),
        }
    }

    /// åˆ†é…å†…å­˜
    fn allocate(&mut self, address: usize, size: usize, owner: String) -> Result<(), String> {
        // æ£€æŸ¥åœ°å€å†²çª
        for (addr, region) in &self.allocated_regions {
            if self.regions_overlap(address, size, *addr, region.size) {
                return Err(format!("å†…å­˜åœ°å€å†²çª: {} ä¸ {} é‡å ", address, addr));
            }
        }

        let region = MemoryRegion {
            address,
            size,
            owner,
            access_count: 0,
        };

        self.allocated_regions.insert(address, region);

        self.log_access(MemoryAccess {
            address,
            size,
            access_type: AccessType::Allocate,
            timestamp: self.get_timestamp(),
        });

        Ok(())
    }

    /// é‡Šæ”¾å†…å­˜
    fn deallocate(&mut self, address: usize) -> Result<(), String> {
        if !self.allocated_regions.contains_key(&address) {
            return Err(format!("é‡Šæ”¾æœªåˆ†é…çš„å†…å­˜: {}", address));
        }

        self.allocated_regions.remove(&address);

        self.log_access(MemoryAccess {
            address,
            size: 0,
            access_type: AccessType::Deallocate,
            timestamp: self.get_timestamp(),
        });

        Ok(())
    }

    /// æ£€æŸ¥å†…å­˜è®¿é—®
    fn check_access(&mut self, address: usize, size: usize, access_type: AccessType) -> Result<(), String> {
        // æ£€æŸ¥æ˜¯å¦è®¿é—®å·²åˆ†é…çš„å†…å­˜
        let mut found_region = false;
        for (region_addr, region) in &self.allocated_regions {
            if address >= *region_addr && address + size <= region_addr + region.size {
                found_region = true;
                break;
            }
        }

        if !found_region {
            return Err(format!("è®¿é—®æœªåˆ†é…çš„å†…å­˜: {} (å¤§å°: {})", address, size));
        }

        // æ£€æŸ¥è¶Šç•Œè®¿é—®
        for (region_addr, region) in &self.allocated_regions {
            if address >= *region_addr && address < region_addr + region.size {
                if address + size > region_addr + region.size {
                    return Err(format!("å†…å­˜è®¿é—®è¶Šç•Œ: {} + {} > {}", address, size, region_addr + region.size));
                }
            }
        }

        // è®°å½•è®¿é—®
        self.log_access(MemoryAccess {
            address,
            size,
            access_type,
            timestamp: self.get_timestamp(),
        });

        Ok(())
    }

    /// æ£€æŸ¥åŒºåŸŸé‡å 
    fn regions_overlap(&self, addr1: usize, size1: usize, addr2: usize, size2: usize) -> bool {
        addr1 < addr2 + size2 && addr2 < addr1 + size1
    }

    /// è®°å½•è®¿é—®æ—¥å¿—
    fn log_access(&mut self, access: MemoryAccess) {
        self.access_log.push(access);
    }

    /// è·å–æ—¶é—´æˆ³
    fn get_timestamp(&self) -> u64 {
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs()
    }

    /// æ£€æµ‹å†…å­˜æ³„æ¼
    fn detect_memory_leaks(&self) -> Vec<usize> {
        self.allocated_regions.keys().cloned().collect()
    }

    /// è·å–è®¿é—®ç»Ÿè®¡
    fn get_access_stats(&self) -> HashMap<AccessType, usize> {
        let mut stats = HashMap::new();

        for access in &self.access_log {
            *stats.entry(access.access_type.clone()).or_insert(0) += 1;
        }

        stats
    }
}

/// æ™ºèƒ½æŒ‡é’ˆ
#[derive(Debug)]
struct SmartPointer<T> {
    data: Option<T>,
    reference_count: usize,
}

impl<T> SmartPointer<T> {
    /// åˆ›å»ºæ™ºèƒ½æŒ‡é’ˆ
    fn new(data: T) -> Self {
        SmartPointer {
            data: Some(data),
            reference_count: 1,
        }
    }

    /// è·å–å¼•ç”¨
    fn get_ref(&self) -> Option<&T> {
        self.data.as_ref()
    }

    /// è·å–å¯å˜å¼•ç”¨
    fn get_mut(&mut self) -> Option<&mut T> {
        self.data.as_mut()
    }

    /// å¢åŠ å¼•ç”¨è®¡æ•°
    fn increment_ref_count(&mut self) {
        self.reference_count += 1;
    }

    /// å‡å°‘å¼•ç”¨è®¡æ•°
    fn decrement_ref_count(&mut self) -> bool {
        self.reference_count -= 1;
        if self.reference_count == 0 {
            self.data.take();
            true
        } else {
            false
        }
    }

    /// è·å–å¼•ç”¨è®¡æ•°
    fn get_ref_count(&self) -> usize {
        self.reference_count
    }
}

impl<T> Clone for SmartPointer<T> {
    fn clone(&self) -> Self {
        let mut new_ptr = SmartPointer {
            data: self.data.clone(),
            reference_count: 1,
        };
        new_ptr.increment_ref_count();
        new_ptr
    }
}

impl<T> Drop for SmartPointer<T> {
    fn drop(&mut self) {
        self.decrement_ref_count();
    }
}
```

### 6.3 å†…å­˜æ± å®ç°

```rust
/// å†…å­˜æ± 
#[derive(Debug)]
struct MemoryPool {
    pools: HashMap<usize, Vec<usize>>, // å—å¤§å° -> ç©ºé—²åœ°å€åˆ—è¡¨
    allocated: HashSet<usize>,
    total_size: usize,
    used_size: usize,
}

impl MemoryPool {
    /// åˆ›å»ºå†…å­˜æ± 
    fn new() -> Self {
        MemoryPool {
            pools: HashMap::new(),
            allocated: HashSet::new(),
            total_size: 0,
            used_size: 0,
        }
    }

    /// åˆå§‹åŒ–å†…å­˜æ± 
    fn initialize(&mut self, block_sizes: &[usize], pool_sizes: &[usize]) {
        let mut current_address = 0;

        for (&block_size, &pool_size) in block_sizes.iter().zip(pool_sizes.iter()) {
            let num_blocks = pool_size / block_size;
            let mut addresses = Vec::new();

            for i in 0..num_blocks {
                addresses.push(current_address + i * block_size);
            }

            self.pools.insert(block_size, addresses);
            self.total_size += pool_size;
            current_address += pool_size;
        }
    }

    /// åˆ†é…å†…å­˜
    fn allocate(&mut self, size: usize) -> Option<usize> {
        // æ‰¾åˆ°åˆé€‚çš„å—å¤§å°
        let block_size = self.find_suitable_block_size(size);

        if let Some(addresses) = self.pools.get_mut(&block_size) {
            if let Some(address) = addresses.pop() {
                self.allocated.insert(address);
                self.used_size += block_size;
                Some(address)
            } else {
                None
            }
        } else {
            None
        }
    }

    /// é‡Šæ”¾å†…å­˜
    fn deallocate(&mut self, address: usize) -> bool {
        if !self.allocated.contains(&address) {
            return false;
        }

        // æ‰¾åˆ°å¯¹åº”çš„å—å¤§å°
        for (&block_size, addresses) in &mut self.pools {
            if address % block_size == 0 {
                addresses.push(address);
                self.allocated.remove(&address);
                self.used_size -= block_size;
                return true;
            }
        }

        false
    }

    /// æ‰¾åˆ°åˆé€‚çš„å—å¤§å°
    fn find_suitable_block_size(&self, size: usize) -> usize {
        let mut best_size = usize::MAX;

        for &block_size in self.pools.keys() {
            if block_size >= size && block_size < best_size {
                best_size = block_size;
            }
        }

        best_size
    }

    /// è·å–å†…å­˜ä½¿ç”¨æƒ…å†µ
    fn get_usage_info(&self) -> (usize, usize, f64) {
        let used = self.used_size;
        let total = self.total_size;
        let usage = if total > 0 { used as f64 / total as f64 } else { 0.0 };
        (used, total, usage)
    }

    /// è·å–æ± çŠ¶æ€
    fn get_pool_status(&self) -> HashMap<usize, (usize, usize)> {
        let mut status = HashMap::new();

        for (&block_size, addresses) in &self.pools {
            let total_blocks = self.total_size / block_size;
            let free_blocks = addresses.len();
            let used_blocks = total_blocks - free_blocks;
            status.insert(block_size, (used_blocks, free_blocks));
        }

        status
    }
}
```

## 7 åº”ç”¨ç¤ºä¾‹

### 7.1 å†…å­˜åˆ†é…å™¨ä½¿ç”¨

```rust
// å†…å­˜åˆ†é…å™¨ä½¿ç”¨ç¤ºä¾‹
fn memory_allocator_example() {
    let mut allocator = MemoryAllocator::new(1024);

    // åˆ†é…å†…å­˜
    let addr1 = allocator.allocate(64).unwrap();
    let addr2 = allocator.allocate(128).unwrap();
    let addr3 = allocator.allocate(256).unwrap();

    println!("åˆ†é…çš„å†…å­˜åœ°å€: {}, {}, {}", addr1, addr2, addr3);

    // è·å–å†…å­˜ä½¿ç”¨æƒ…å†µ
    let (used, total, usage) = allocator.get_memory_info();
    println!("å†…å­˜ä½¿ç”¨: {}/{} ({:.2}%)", used, total, usage * 100.0);

    // é‡Šæ”¾å†…å­˜
    allocator.deallocate(addr2);

    // é‡æ–°åˆ†é…
    let addr4 = allocator.allocate(64).unwrap();
    println!("é‡æ–°åˆ†é…åœ°å€: {}", addr4);

    // æœ€ç»ˆä½¿ç”¨æƒ…å†µ
    let (used, total, usage) = allocator.get_memory_info();
    println!("æœ€ç»ˆå†…å­˜ä½¿ç”¨: {}/{} ({:.2}%)", used, total, usage * 100.0);
}

// åƒåœ¾å›æ”¶å™¨ç¤ºä¾‹
fn garbage_collector_example() {
    let mut gc = GarbageCollector::new();

    // åˆ›å»ºå¯¹è±¡
    let obj1 = gc.create_object(64);
    let obj2 = gc.create_object(128);
    let obj3 = gc.create_object(256);

    // è®¾ç½®æ ¹å¯¹è±¡
    gc.add_root(obj1);

    // æ·»åŠ å¼•ç”¨
    gc.add_reference(obj1, obj2);
    gc.add_reference(obj2, obj3);

    // è·å–åˆå§‹çŠ¶æ€
    let (objects, size) = gc.get_memory_info();
    println!("åˆå§‹çŠ¶æ€: {} ä¸ªå¯¹è±¡, {} å­—èŠ‚", objects, size);

    // æ‰§è¡Œåƒåœ¾å›æ”¶
    let freed = gc.collect_garbage();
    println!("åƒåœ¾å›æ”¶é‡Šæ”¾äº† {} ä¸ªå¯¹è±¡", freed);

    // ç§»é™¤æ ¹å¯¹è±¡
    gc.remove_root(obj1);

    // å†æ¬¡åƒåœ¾å›æ”¶
    let freed = gc.collect_garbage();
    println!("ç§»é™¤æ ¹å¯¹è±¡åé‡Šæ”¾äº† {} ä¸ªå¯¹è±¡", freed);

    // æœ€ç»ˆçŠ¶æ€
    let (objects, size) = gc.get_memory_info();
    println!("æœ€ç»ˆçŠ¶æ€: {} ä¸ªå¯¹è±¡, {} å­—èŠ‚", objects, size);
}

// å†…å­˜å®‰å…¨æ£€æŸ¥ç¤ºä¾‹
fn memory_safety_example() {
    let mut checker = MemorySafetyChecker::new();

    // åˆ†é…å†…å­˜
    checker.allocate(0, 64, "obj1".to_string()).unwrap();
    checker.allocate(64, 128, "obj2".to_string()).unwrap();

    // æ£€æŸ¥æ­£å¸¸è®¿é—®
    checker.check_access(0, 32, AccessType::Read).unwrap();
    checker.check_access(64, 64, AccessType::Write).unwrap();

    // æ£€æŸ¥è¶Šç•Œè®¿é—®ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
    match checker.check_access(0, 128, AccessType::Read) {
        Ok(_) => println!("è®¿é—®æˆåŠŸ"),
        Err(e) => println!("è®¿é—®å¤±è´¥: {}", e),
    }

    // æ£€æŸ¥æœªåˆ†é…å†…å­˜è®¿é—®ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
    match checker.check_access(256, 32, AccessType::Read) {
        Ok(_) => println!("è®¿é—®æˆåŠŸ"),
        Err(e) => println!("è®¿é—®å¤±è´¥: {}", e),
    }

    // é‡Šæ”¾å†…å­˜
    checker.deallocate(0).unwrap();

    // æ£€æŸ¥å·²é‡Šæ”¾å†…å­˜è®¿é—®ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
    match checker.check_access(0, 32, AccessType::Read) {
        Ok(_) => println!("è®¿é—®æˆåŠŸ"),
        Err(e) => println!("è®¿é—®å¤±è´¥: {}", e),
    }

    // æ£€æµ‹å†…å­˜æ³„æ¼
    let leaks = checker.detect_memory_leaks();
    println!("å†…å­˜æ³„æ¼: {:?}", leaks);

    // è·å–è®¿é—®ç»Ÿè®¡
    let stats = checker.get_access_stats();
    println!("è®¿é—®ç»Ÿè®¡: {:?}", stats);
}

// æ™ºèƒ½æŒ‡é’ˆç¤ºä¾‹
fn smart_pointer_example() {
    // åˆ›å»ºæ™ºèƒ½æŒ‡é’ˆ
    let mut ptr1 = SmartPointer::new(42);
    println!("åˆå§‹å¼•ç”¨è®¡æ•°: {}", ptr1.get_ref_count());

    // å…‹éš†æ™ºèƒ½æŒ‡é’ˆ
    let ptr2 = ptr1.clone();
    println!("å…‹éš†åå¼•ç”¨è®¡æ•°: {}", ptr1.get_ref_count());

    // è·å–å€¼
    if let Some(value) = ptr1.get_ref() {
        println!("å€¼: {}", value);
    }

    // ä¿®æ”¹å€¼
    if let Some(value) = ptr1.get_mut() {
        *value = 100;
    }

    // æ£€æŸ¥ä¸¤ä¸ªæŒ‡é’ˆçš„å€¼
    println!("ptr1 å€¼: {:?}", ptr1.get_ref());
    println!("ptr2 å€¼: {:?}", ptr2.get_ref());

    // æ‰‹åŠ¨å‡å°‘å¼•ç”¨è®¡æ•°
    ptr1.decrement_ref_count();
    println!("å‡å°‘å¼•ç”¨åè®¡æ•°: {}", ptr1.get_ref_count());
}

// å†…å­˜æ± ç¤ºä¾‹
fn memory_pool_example() {
    let mut pool = MemoryPool::new();

    // åˆå§‹åŒ–å†…å­˜æ± 
    let block_sizes = vec![16, 32, 64, 128];
    let pool_sizes = vec![256, 512, 1024, 2048];
    pool.initialize(&block_sizes, &pool_sizes);

    // åˆ†é…å†…å­˜
    let addr1 = pool.allocate(20).unwrap(); // ä½¿ç”¨32å­—èŠ‚å—
    let addr2 = pool.allocate(50).unwrap(); // ä½¿ç”¨64å­—èŠ‚å—
    let addr3 = pool.allocate(100).unwrap(); // ä½¿ç”¨128å­—èŠ‚å—

    println!("åˆ†é…åœ°å€: {}, {}, {}", addr1, addr2, addr3);

    // è·å–ä½¿ç”¨æƒ…å†µ
    let (used, total, usage) = pool.get_usage_info();
    println!("å†…å­˜ä½¿ç”¨: {}/{} ({:.2}%)", used, total, usage * 100.0);

    // è·å–æ± çŠ¶æ€
    let status = pool.get_pool_status();
    for (block_size, (used_blocks, free_blocks)) in status {
        println!("{} å­—èŠ‚å—: å·²ç”¨ {}, ç©ºé—² {}", block_size, used_blocks, free_blocks);
    }

    // é‡Šæ”¾å†…å­˜
    pool.deallocate(addr2);

    // é‡æ–°åˆ†é…
    let addr4 = pool.allocate(30).unwrap();
    println!("é‡æ–°åˆ†é…åœ°å€: {}", addr4);

    // æœ€ç»ˆçŠ¶æ€
    let (used, total, usage) = pool.get_usage_info();
    println!("æœ€ç»ˆå†…å­˜ä½¿ç”¨: {}/{} ({:.2}%)", used, total, usage * 100.0);
}
```

## 8 ç›¸å…³ç†è®º

### 8.1 ä¸ç±»å‹ç†è®ºçš„å…³ç³»

å†…å­˜ç®¡ç†ä¸ç±»å‹ç†è®ºçš„å…³ç³»ï¼š

1. **ç±»å‹å®‰å…¨**ï¼šç±»å‹ç³»ç»Ÿä¿è¯å†…å­˜è®¿é—®å®‰å…¨
2. **æ‰€æœ‰æƒç±»å‹**ï¼šæ‰€æœ‰æƒç³»ç»Ÿæä¾›å†…å­˜å®‰å…¨ä¿è¯
3. **ç”Ÿå‘½å‘¨æœŸ**ï¼šç”Ÿå‘½å‘¨æœŸç®¡ç†å†…å­˜æœ‰æ•ˆæ€§
4. **å€Ÿç”¨æ£€æŸ¥**ï¼šå€Ÿç”¨æ£€æŸ¥é˜²æ­¢å†…å­˜é”™è¯¯

### 8.2 ä¸ç³»ç»Ÿç¼–ç¨‹çš„å…³ç³»

å†…å­˜ç®¡ç†ä¸ç³»ç»Ÿç¼–ç¨‹çš„å…³ç³»ï¼š

1. **æ€§èƒ½ä¼˜åŒ–**ï¼šå†…å­˜ç®¡ç†å½±å“ç¨‹åºæ€§èƒ½
2. **èµ„æºç®¡ç†**ï¼šå†…å­˜æ˜¯é‡è¦çš„ç³»ç»Ÿèµ„æº
3. **å®‰å…¨ä¿è¯**ï¼šå†…å­˜å®‰å…¨æ˜¯ç³»ç»Ÿå®‰å…¨çš„åŸºç¡€
4. **å¹¶å‘æ§åˆ¶**ï¼šå†…å­˜ç®¡ç†éœ€è¦è€ƒè™‘å¹¶å‘è®¿é—®

### 8.3 ä¸åƒåœ¾å›æ”¶çš„å…³ç³»

å†…å­˜ç®¡ç†ä¸åƒåœ¾å›æ”¶çš„å…³ç³»ï¼š

1. **è‡ªåŠ¨ç®¡ç†**ï¼šåƒåœ¾å›æ”¶è‡ªåŠ¨ç®¡ç†å†…å­˜
2. **æ€§èƒ½æƒè¡¡**ï¼šåƒåœ¾å›æ”¶çš„æ€§èƒ½å¼€é”€
3. **ç®—æ³•é€‰æ‹©**ï¼šä¸åŒåƒåœ¾å›æ”¶ç®—æ³•çš„é€‚ç”¨åœºæ™¯
4. **è°ƒä¼˜ç­–ç•¥**ï¼šåƒåœ¾å›æ”¶å‚æ•°çš„è°ƒä¼˜

## 7. å‚è€ƒæ–‡çŒ®

1. Wilson, P. R. (1992). Uniprocessor garbage collection techniques. ACM Computing Surveys, 24(4), 337-372.
2. Jones, R., & Lins, R. (1996). Garbage collection: algorithms for automatic dynamic memory management. John Wiley & Sons.
3. Bacon, D. F., et al. (2003). The Metronome: A simpler approach to garbage collection in real-time systems. ACM OOPSLA, 466-478.
4. Blackburn, S. M., et al. (2004). Myths and realities: The performance impact of garbage collection. ACM SIGMETRICS, 25-36.
5. Detlefs, D., et al. (2004). Garbage-first garbage collection. ACM OOPSLA, 37-48.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [04.3.2 æ‰€æœ‰æƒç³»ç»Ÿ](../04.3.2_æ‰€æœ‰æƒç³»ç»Ÿ.md)
- [04.2.3 çº¿æ€§æ•°æ®ç»“æ„](../04.2.3_çº¿æ€§æ•°æ®ç»“æ„.md)
- [04.2.4 çº¿æ€§ç±»å‹ç³»ç»Ÿ](../04.2.4_çº¿æ€§ç±»å‹ç³»ç»Ÿ.md)
- [03.8.4 è®¤çŸ¥è¯­è¨€](../03_Formal_Language_Theory/03.8_Language_Frontiers/03.8.4_Cognitive_Languages.md)

## 9 æ‰¹åˆ¤æ€§åˆ†æ

- å“²å­¦ç»´åº¦ï¼šå†…å­˜ç®¡ç†ä½œä¸ºèµ„æºç®¡ç†çš„æ ¸å¿ƒï¼›è‡ªåŠ¨åŒ–ä¸æ§åˆ¶çš„è¾©è¯å…³ç³»ã€‚
- æ–¹æ³•è®ºç»´åº¦ï¼šå†…å­˜ç®¡ç†ç­–ç•¥çš„è®¾è®¡åŸåˆ™ï¼›åƒåœ¾å›æ”¶çš„ç†è®ºåŸºç¡€ã€‚
- å·¥ç¨‹ç»´åº¦ï¼šå†…å­˜ç®¡ç†åœ¨ç³»ç»Ÿç¼–ç¨‹ä¸­çš„åº”ç”¨ï¼›æ€§èƒ½ä¸å®‰å…¨æ€§çš„æƒè¡¡ã€‚
- ç¤¾ä¼šæŠ€æœ¯ç»´åº¦ï¼šå†…å­˜ç®¡ç†å¯¹ç¼–ç¨‹è¯­è¨€è®¾è®¡çš„å½±å“ï¼›ç³»ç»Ÿç¼–ç¨‹æ•™è‚²çš„æ ‡å‡†åŒ–ã€‚
