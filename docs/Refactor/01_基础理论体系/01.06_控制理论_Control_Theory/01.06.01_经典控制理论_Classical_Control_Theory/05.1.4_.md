# 05.1.4 ç³»ç»Ÿè¾¨è¯†ç†è®º

## ğŸ“‹ ç›®å½•

- [1 æ¦‚è¿°](#1-æ¦‚è¿°)
- [2 æ ¸å¿ƒç›®æ ‡](#2-æ ¸å¿ƒç›®æ ‡)
- [3 åŸºæœ¬æ¦‚å¿µ](#3-åŸºæœ¬æ¦‚å¿µ)
  - [3.1 ç³»ç»Ÿè¾¨è¯†å®šä¹‰](#31-ç³»ç»Ÿè¾¨è¯†å®šä¹‰)
  - [3.2 è¾¨è¯†é—®é¢˜åˆ†ç±»](#32-è¾¨è¯†é—®é¢˜åˆ†ç±»)
  - [3.3 è¾¨è¯†å‡†åˆ™](#33-è¾¨è¯†å‡†åˆ™)
- [4 å‚æ•°è¾¨è¯†](#4-å‚æ•°è¾¨è¯†)
  - [4.1 æœ€å°äºŒä¹˜è¾¨è¯†](#41-æœ€å°äºŒä¹˜è¾¨è¯†)
  - [4.2 é€’æ¨æœ€å°äºŒä¹˜](#42-é€’æ¨æœ€å°äºŒä¹˜)
  - [4.3 æœ€å¤§ä¼¼ç„¶è¾¨è¯†](#43-æœ€å¤§ä¼¼ç„¶è¾¨è¯†)
- [5 çŠ¶æ€ä¼°è®¡](#5-çŠ¶æ€ä¼°è®¡)
  - [5.1 å¡å°”æ›¼æ»¤æ³¢](#51-å¡å°”æ›¼æ»¤æ³¢)
  - [5.2 æ‰©å±•å¡å°”æ›¼æ»¤æ³¢](#52-æ‰©å±•å¡å°”æ›¼æ»¤æ³¢)
  - [5.3 ç²’å­æ»¤æ³¢](#53-ç²’å­æ»¤æ³¢)
- [6 æ¨¡å‹ç»“æ„è¾¨è¯†](#6-æ¨¡å‹ç»“æ„è¾¨è¯†)
  - [6.1 æ¨¡å‹é˜¶æ•°è¾¨è¯†](#61-æ¨¡å‹é˜¶æ•°è¾¨è¯†)
  - [6.2 æ¨¡å‹ç»“æ„é€‰æ‹©](#62-æ¨¡å‹ç»“æ„é€‰æ‹©)
- [7 é€’å½’è¾¨è¯†](#7-é€’å½’è¾¨è¯†)
  - [7.1 é€’å½’æœ€å°äºŒä¹˜](#71-é€’å½’æœ€å°äºŒä¹˜)
  - [7.2 é€’å½’æœ€å¤§ä¼¼ç„¶](#72-é€’å½’æœ€å¤§ä¼¼ç„¶)
- [8 é²æ£’è¾¨è¯†](#8-é²æ£’è¾¨è¯†)
  - [8.1 é²æ£’è¾¨è¯†é—®é¢˜](#81-é²æ£’è¾¨è¯†é—®é¢˜)
  - [8.2 Hè¾¨è¯†](#82-hè¾¨è¯†)
  - [8.3 é›†å‘˜è¾¨è¯†](#83-é›†å‘˜è¾¨è¯†)
- [9 éçº¿æ€§ç³»ç»Ÿè¾¨è¯†](#9-éçº¿æ€§ç³»ç»Ÿè¾¨è¯†)
  - [9.1 éçº¿æ€§æ¨¡å‹ç»“æ„](#91-éçº¿æ€§æ¨¡å‹ç»“æ„)
  - [9.2 éçº¿æ€§å‚æ•°è¾¨è¯†](#92-éçº¿æ€§å‚æ•°è¾¨è¯†)
- [10 æ¨¡å‹éªŒè¯](#10-æ¨¡å‹éªŒè¯)
  - [10.1 æ®‹å·®åˆ†æ](#101-æ®‹å·®åˆ†æ)
  - [10.2 äº¤å‰éªŒè¯](#102-äº¤å‰éªŒè¯)
  - [10.3 æ¨¡å‹æ¯”è¾ƒ](#103-æ¨¡å‹æ¯”è¾ƒ)
- [11 ä»£ç å®ç°](#11-ä»£ç å®ç°)
  - [11.1 ç³»ç»Ÿè¾¨è¯†å™¨](#111-ç³»ç»Ÿè¾¨è¯†å™¨)
  - [11.2 æµ‹è¯•ä»£ç ](#112-æµ‹è¯•ä»£ç )
- [12 åº”ç”¨ç¤ºä¾‹](#12-åº”ç”¨ç¤ºä¾‹)
  - [12.1 çº¿æ€§ç³»ç»Ÿè¾¨è¯†](#121-çº¿æ€§ç³»ç»Ÿè¾¨è¯†)
  - [12.2 éçº¿æ€§ç³»ç»Ÿè¾¨è¯†](#122-éçº¿æ€§ç³»ç»Ÿè¾¨è¯†)
  - [12.3 çŠ¶æ€ä¼°è®¡ç¤ºä¾‹](#123-çŠ¶æ€ä¼°è®¡ç¤ºä¾‹)
- [13 ç›¸å…³ç†è®º](#13-ç›¸å…³ç†è®º)
  - [13.1 æ§åˆ¶ç†è®º](#131-æ§åˆ¶ç†è®º)
  - [13.2 çŠ¶æ€ä¼°è®¡ç†è®º](#132-çŠ¶æ€ä¼°è®¡ç†è®º)
  - [13.3 è‡ªé€‚åº”æ§åˆ¶ç†è®º](#133-è‡ªé€‚åº”æ§åˆ¶ç†è®º)
  - [13.4 é²æ£’æ§åˆ¶ç†è®º](#134-é²æ£’æ§åˆ¶ç†è®º)
- [14 æ‰¹åˆ¤æ€§åˆ†æ](#14-æ‰¹åˆ¤æ€§åˆ†æ)
  - [14.1 å¤šå…ƒç†è®ºè§†è§’](#141-å¤šå…ƒç†è®ºè§†è§’)
  - [14.2 å±€é™æ€§åˆ†æ](#142-å±€é™æ€§åˆ†æ)
  - [14.3 äº‰è®®ä¸åˆ†æ­§](#143-äº‰è®®ä¸åˆ†æ­§)
  - [14.4 åº”ç”¨å‰æ™¯](#144-åº”ç”¨å‰æ™¯)
  - [14.5 æ”¹è¿›å»ºè®®](#145-æ”¹è¿›å»ºè®®)

---

## 1 æ¦‚è¿°

ç³»ç»Ÿè¾¨è¯†ç†è®ºæ˜¯æ§åˆ¶ç†è®ºçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œç ”ç©¶å¦‚ä½•ä»ç³»ç»Ÿçš„è¾“å…¥è¾“å‡ºæ•°æ®ä¸­è¯†åˆ«ç³»ç»Ÿçš„æ•°å­¦æ¨¡å‹ã€‚ç³»ç»Ÿè¾¨è¯†ä¸ºæ§åˆ¶ç³»ç»Ÿè®¾è®¡æä¾›äº†å¿…è¦çš„æ¨¡å‹åŸºç¡€ï¼Œæ˜¯ç°ä»£æ§åˆ¶ç†è®ºä¸å¯æˆ–ç¼ºçš„å·¥å…·ã€‚

## 2 æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹ç³»ç»Ÿè¾¨è¯†çš„æ•°å­¦æ¡†æ¶**
2. **ç ”ç©¶å‚æ•°è¾¨è¯†æ–¹æ³•**
3. **å‘å±•çŠ¶æ€ä¼°è®¡ç†è®º**
4. **æä¾›æ¨¡å‹éªŒè¯å’Œé€‰æ‹©æ–¹æ³•**

## ğŸ“š ç›®å½•

- [05.1.4 ç³»ç»Ÿè¾¨è¯†ç†è®º](#0514-ç³»ç»Ÿè¾¨è¯†ç†è®º)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒç›®æ ‡](#-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 ç³»ç»Ÿè¾¨è¯†å®šä¹‰](#11-ç³»ç»Ÿè¾¨è¯†å®šä¹‰)
    - [1.2 è¾¨è¯†é—®é¢˜åˆ†ç±»](#12-è¾¨è¯†é—®é¢˜åˆ†ç±»)
    - [1.3 è¾¨è¯†å‡†åˆ™](#13-è¾¨è¯†å‡†åˆ™)
  - [2. å‚æ•°è¾¨è¯†](#2-å‚æ•°è¾¨è¯†)
    - [2.1 æœ€å°äºŒä¹˜è¾¨è¯†](#21-æœ€å°äºŒä¹˜è¾¨è¯†)
    - [2.2 é€’æ¨æœ€å°äºŒä¹˜](#22-é€’æ¨æœ€å°äºŒä¹˜)
    - [2.3 æœ€å¤§ä¼¼ç„¶è¾¨è¯†](#23-æœ€å¤§ä¼¼ç„¶è¾¨è¯†)
  - [3. çŠ¶æ€ä¼°è®¡](#3-çŠ¶æ€ä¼°è®¡)
    - [3.1 å¡å°”æ›¼æ»¤æ³¢](#31-å¡å°”æ›¼æ»¤æ³¢)
    - [3.2 æ‰©å±•å¡å°”æ›¼æ»¤æ³¢](#32-æ‰©å±•å¡å°”æ›¼æ»¤æ³¢)
    - [3.3 ç²’å­æ»¤æ³¢](#33-ç²’å­æ»¤æ³¢)
  - [4. æ¨¡å‹ç»“æ„è¾¨è¯†](#4-æ¨¡å‹ç»“æ„è¾¨è¯†)
    - [4.1 æ¨¡å‹é˜¶æ•°è¾¨è¯†](#41-æ¨¡å‹é˜¶æ•°è¾¨è¯†)
    - [4.2 æ¨¡å‹ç»“æ„é€‰æ‹©](#42-æ¨¡å‹ç»“æ„é€‰æ‹©)
  - [5. é€’å½’è¾¨è¯†](#5-é€’å½’è¾¨è¯†)
    - [5.1 é€’å½’æœ€å°äºŒä¹˜](#51-é€’å½’æœ€å°äºŒä¹˜)
    - [5.2 é€’å½’æœ€å¤§ä¼¼ç„¶](#52-é€’å½’æœ€å¤§ä¼¼ç„¶)
  - [6. é²æ£’è¾¨è¯†](#6-é²æ£’è¾¨è¯†)
    - [6.1 é²æ£’è¾¨è¯†é—®é¢˜](#61-é²æ£’è¾¨è¯†é—®é¢˜)
    - [6.2 Hâˆè¾¨è¯†](#62-hè¾¨è¯†)
    - [6.3 é›†å‘˜è¾¨è¯†](#63-é›†å‘˜è¾¨è¯†)
  - [7. éçº¿æ€§ç³»ç»Ÿè¾¨è¯†](#7-éçº¿æ€§ç³»ç»Ÿè¾¨è¯†)
    - [7.1 éçº¿æ€§æ¨¡å‹ç»“æ„](#71-éçº¿æ€§æ¨¡å‹ç»“æ„)
    - [7.2 éçº¿æ€§å‚æ•°è¾¨è¯†](#72-éçº¿æ€§å‚æ•°è¾¨è¯†)
  - [8. æ¨¡å‹éªŒè¯](#8-æ¨¡å‹éªŒè¯)
    - [8.1 æ®‹å·®åˆ†æ](#81-æ®‹å·®åˆ†æ)
    - [8.2 äº¤å‰éªŒè¯](#82-äº¤å‰éªŒè¯)
    - [8.3 æ¨¡å‹æ¯”è¾ƒ](#83-æ¨¡å‹æ¯”è¾ƒ)
  - [9. ä»£ç å®ç°](#9-ä»£ç å®ç°)
    - [9.1 ç³»ç»Ÿè¾¨è¯†å™¨](#91-ç³»ç»Ÿè¾¨è¯†å™¨)
    - [9.2 æµ‹è¯•ä»£ç ](#92-æµ‹è¯•ä»£ç )
  - [10. åº”ç”¨ç¤ºä¾‹](#10-åº”ç”¨ç¤ºä¾‹)
    - [10.1 çº¿æ€§ç³»ç»Ÿè¾¨è¯†](#101-çº¿æ€§ç³»ç»Ÿè¾¨è¯†)
    - [10.2 éçº¿æ€§ç³»ç»Ÿè¾¨è¯†](#102-éçº¿æ€§ç³»ç»Ÿè¾¨è¯†)
    - [10.3 çŠ¶æ€ä¼°è®¡ç¤ºä¾‹](#103-çŠ¶æ€ä¼°è®¡ç¤ºä¾‹)
  - [11. ç›¸å…³ç†è®º](#11-ç›¸å…³ç†è®º)
    - [11.1 æ§åˆ¶ç†è®º](#111-æ§åˆ¶ç†è®º)
    - [11.2 çŠ¶æ€ä¼°è®¡ç†è®º](#112-çŠ¶æ€ä¼°è®¡ç†è®º)
    - [11.3 è‡ªé€‚åº”æ§åˆ¶ç†è®º](#113-è‡ªé€‚åº”æ§åˆ¶ç†è®º)
    - [11.4 é²æ£’æ§åˆ¶ç†è®º](#114-é²æ£’æ§åˆ¶ç†è®º)
  - [12. å‚è€ƒæ–‡çŒ®](#12-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)
    - [å¤šå…ƒç†è®ºè§†è§’](#å¤šå…ƒç†è®ºè§†è§’)
    - [å±€é™æ€§åˆ†æ](#å±€é™æ€§åˆ†æ)
    - [äº‰è®®ä¸åˆ†æ­§](#äº‰è®®ä¸åˆ†æ­§)
    - [åº”ç”¨å‰æ™¯](#åº”ç”¨å‰æ™¯)
    - [æ”¹è¿›å»ºè®®](#æ”¹è¿›å»ºè®®)

## 3 åŸºæœ¬æ¦‚å¿µ

### 3.1 ç³»ç»Ÿè¾¨è¯†å®šä¹‰

**å®šä¹‰ 1.1.1** (ç³»ç»Ÿè¾¨è¯†)
ç³»ç»Ÿè¾¨è¯†æ˜¯ä»ç³»ç»Ÿçš„è¾“å…¥è¾“å‡ºæ•°æ®ä¸­ç¡®å®šç³»ç»Ÿæ•°å­¦æ¨¡å‹çš„è¿‡ç¨‹ï¼ŒåŒ…æ‹¬æ¨¡å‹ç»“æ„é€‰æ‹©å’Œå‚æ•°ä¼°è®¡ã€‚

### 3.2 è¾¨è¯†é—®é¢˜åˆ†ç±»

**å®šä¹‰ 1.1.2** (è¾¨è¯†é—®é¢˜åˆ†ç±»)

1. **å‚æ•°è¾¨è¯†**: å·²çŸ¥æ¨¡å‹ç»“æ„ï¼Œä¼°è®¡æ¨¡å‹å‚æ•°
2. **ç»“æ„è¾¨è¯†**: ç¡®å®šæ¨¡å‹çš„æ•°å­¦ç»“æ„
3. **çŠ¶æ€ä¼°è®¡**: ä»è¾“å‡ºæ•°æ®ä¼°è®¡ç³»ç»ŸçŠ¶æ€
4. **æ¨¡å‹éªŒè¯**: éªŒè¯è¾¨è¯†æ¨¡å‹çš„å‡†ç¡®æ€§

### 3.3 è¾¨è¯†å‡†åˆ™

**å®šä¹‰ 1.1.3** (è¾¨è¯†å‡†åˆ™)
è¾¨è¯†é—®é¢˜é€šå¸¸åŸºäºä»¥ä¸‹å‡†åˆ™ï¼š

1. **æœ€å°äºŒä¹˜å‡†åˆ™**: æœ€å°åŒ–é¢„æµ‹è¯¯å·®çš„å¹³æ–¹å’Œ
2. **æœ€å¤§ä¼¼ç„¶å‡†åˆ™**: æœ€å¤§åŒ–è§‚æµ‹æ•°æ®çš„ä¼¼ç„¶å‡½æ•°
3. **è´å¶æ–¯å‡†åˆ™**: åŸºäºå…ˆéªŒçŸ¥è¯†çš„åéªŒæ¦‚ç‡æœ€å¤§åŒ–

## 4 å‚æ•°è¾¨è¯†

### 4.1 æœ€å°äºŒä¹˜è¾¨è¯†

**å®šä¹‰ 2.1.1** (æœ€å°äºŒä¹˜è¾¨è¯†)
å¯¹äºçº¿æ€§ç³»ç»Ÿ $y(t) = \phi^T(t)\theta + e(t)$ï¼Œæœ€å°äºŒä¹˜ä¼°è®¡ä¸ºï¼š
$$\hat{\theta} = \arg\min_{\theta} \sum_{t=1}^N [y(t) - \phi^T(t)\theta]^2$$

**å®šç† 2.1.1** (æœ€å°äºŒä¹˜è§£)
æœ€å°äºŒä¹˜ä¼°è®¡çš„è§£æè§£ä¸ºï¼š
$$\hat{\theta} = \left[\sum_{t=1}^N \phi(t)\phi^T(t)\right]^{-1} \sum_{t=1}^N \phi(t)y(t)$$

**è¯æ˜**ï¼š
è®¾ $J(\theta) = \sum_{t=1}^N [y(t) - \phi^T(t)\theta]^2$ï¼Œåˆ™ï¼š
$$\frac{\partial J}{\partial \theta} = -2\sum_{t=1}^N \phi[t](y(t) - \phi^T(t)\theta) = 0$$

æ•´ç†å¾—ï¼š
$$\sum_{t=1}^N \phi(t)\phi^T(t)\theta = \sum_{t=1}^N \phi(t)y(t)$$

å› æ­¤ï¼š
$$\hat{\theta} = \left[\sum_{t=1}^N \phi(t)\phi^T(t)\right]^{-1} \sum_{t=1}^N \phi(t)y(t)$$

### 4.2 é€’æ¨æœ€å°äºŒä¹˜

**ç®—æ³• 2.1.1** (é€’æ¨æœ€å°äºŒä¹˜)
é€’æ¨æœ€å°äºŒä¹˜ç®—æ³•ä¸ºï¼š
$$
\begin{align}
\hat{\theta}(t) &= \hat{\theta}(t-1) + K[t](y(t) - \phi^T(t)\hat{\theta}(t-1)) \\
K(t) &= P(t-1)\phi[t](\lambda + \phi^T(t)P(t-1)\phi(t))^{-1} \\
P(t) &= \frac{1}{\lambda}[I - K(t)\phi^T(t)]P(t-1)
\end{align}
$$

å…¶ä¸­ $\lambda$ æ˜¯é—å¿˜å› å­ï¼Œ$0 < \lambda \leq 1$ã€‚

### 4.3 æœ€å¤§ä¼¼ç„¶è¾¨è¯†

**å®šä¹‰ 2.1.2** (æœ€å¤§ä¼¼ç„¶è¾¨è¯†)
å¯¹äºç³»ç»Ÿ $y(t) = G(q^{-1})u(t) + H(q^{-1})e(t)$ï¼Œæœ€å¤§ä¼¼ç„¶ä¼°è®¡ä¸ºï¼š
$$\hat{\theta} = \arg\max_{\theta} p(y^N|\theta)$$

å…¶ä¸­ $p(y^N|\theta)$ æ˜¯è§‚æµ‹æ•°æ®çš„ä¼¼ç„¶å‡½æ•°ã€‚

**å®šç† 2.1.2** (é«˜æ–¯å™ªå£°ä¸‹çš„æœ€å¤§ä¼¼ç„¶)
åœ¨é«˜æ–¯å™ªå£°å‡è®¾ä¸‹ï¼Œæœ€å¤§ä¼¼ç„¶ä¼°è®¡ç­‰ä»·äºæœ€å°åŒ–é¢„æµ‹è¯¯å·®çš„æ–¹å·®ã€‚

## 5 çŠ¶æ€ä¼°è®¡

### 5.1 å¡å°”æ›¼æ»¤æ³¢

**ç®—æ³• 3.1.1** (å¡å°”æ›¼æ»¤æ³¢)
å¯¹äºç³»ç»Ÿï¼š
$$
\begin{align}
x(t+1) &= Ax(t) + Bu(t) + w(t) \\
y(t) &= Cx(t) + v(t)
\end{align}
$$

å¡å°”æ›¼æ»¤æ³¢ç®—æ³•ä¸ºï¼š
$$
\begin{align}
\hat{x}(t|t-1) &= A\hat{x}(t-1|t-1) + Bu(t-1) \\
P(t|t-1) &= AP(t-1|t-1)A^T + Q \\
K(t) &= P(t|t-1)C^T[CP(t|t-1)C^T + R]^{-1} \\
\hat{x}(t|t) &= \hat{x}(t|t-1) + K[t](y(t) - C\hat{x}(t|t-1)) \\
P(t|t) &= [I - K(t)C]P(t|t-1)
\end{align}
$$

### 5.2 æ‰©å±•å¡å°”æ›¼æ»¤æ³¢

**ç®—æ³• 3.1.2** (æ‰©å±•å¡å°”æ›¼æ»¤æ³¢)
å¯¹äºéçº¿æ€§ç³»ç»Ÿï¼š
$$
\begin{align}
x(t+1) &= f(x(t), u(t)) + w(t) \\
y(t) &= h(x(t)) + v(t)
\end{align}
$$

æ‰©å±•å¡å°”æ›¼æ»¤æ³¢ç®—æ³•ä¸ºï¼š
$$
\begin{align}
\hat{x}(t|t-1) &= f(\hat{x}(t-1|t-1), u(t-1)) \\
P(t|t-1) &= F(t-1)P(t-1|t-1)F^T(t-1) + Q \\
K(t) &= P(t|t-1)H^T[t](H(t)P(t|t-1)H^T(t) + R)^{-1} \\
\hat{x}(t|t) &= \hat{x}(t|t-1) + K[t](y(t) - h(\hat{x}(t|t-1))) \\
P(t|t) &= [I - K(t)H(t)]P(t|t-1)
\end{align}
$$

å…¶ä¸­ $F(t) = \frac{\partial f}{\partial x}|_{\hat{x}(t|t)}$ï¼Œ$H(t) = \frac{\partial h}{\partial x}|_{\hat{x}(t|t-1)}$ã€‚

### 5.3 ç²’å­æ»¤æ³¢

**ç®—æ³• 3.1.3** (ç²’å­æ»¤æ³¢)
ç²’å­æ»¤æ³¢ç®—æ³•ä¸ºï¼š

1. **åˆå§‹åŒ–**: ç”Ÿæˆ $N$ ä¸ªç²’å­ $x_0^{(i)} \sim p(x_0)$
2. **é¢„æµ‹**: $x_t^{(i)} \sim p(x_t|x_{t-1}^{(i)}, u_t)$
3. **æ›´æ–°**: è®¡ç®—æƒé‡ $w_t^{(i)} = p(y_t|x_t^{(i)})$
4. **é‡é‡‡æ ·**: æ ¹æ®æƒé‡é‡æ–°é‡‡æ ·ç²’å­
5. **ä¼°è®¡**: $\hat{x}_t = \sum_{i=1}^N w_t^{(i)}x_t^{(i)}$

## 6 æ¨¡å‹ç»“æ„è¾¨è¯†

### 6.1 æ¨¡å‹é˜¶æ•°è¾¨è¯†

**å®šä¹‰ 4.1.1** (æ¨¡å‹é˜¶æ•°è¾¨è¯†)
ç¡®å®šç³»ç»Ÿæ¨¡å‹çš„æœ€å°é˜¶æ•°ï¼Œä½¿å¾—æ¨¡å‹èƒ½å¤Ÿå……åˆ†æè¿°ç³»ç»ŸåŠ¨æ€ç‰¹æ€§ã€‚

**æ–¹æ³• 4.1.1** (ä¿¡æ¯å‡†åˆ™)
å¸¸ç”¨çš„ä¿¡æ¯å‡†åˆ™åŒ…æ‹¬ï¼š

1. **AICå‡†åˆ™**: $AIC = N\ln(\hat{\sigma}^2) + 2n$
2. **BICå‡†åˆ™**: $BIC = N\ln(\hat{\sigma}^2) + n\ln(N)$
3. **MDLå‡†åˆ™**: $MDL = N\ln(\hat{\sigma}^2) + n\ln(N)/2$

å…¶ä¸­ $N$ æ˜¯æ•°æ®é•¿åº¦ï¼Œ$n$ æ˜¯å‚æ•°ä¸ªæ•°ï¼Œ$\hat{\sigma}^2$ æ˜¯æ®‹å·®æ–¹å·®ã€‚

### 6.2 æ¨¡å‹ç»“æ„é€‰æ‹©

**ç®—æ³• 4.1.1** (æ¨¡å‹ç»“æ„é€‰æ‹©)

1. **å€™é€‰æ¨¡å‹ç”Ÿæˆ**: ç”Ÿæˆå¤šä¸ªå€™é€‰æ¨¡å‹ç»“æ„
2. **å‚æ•°ä¼°è®¡**: å¯¹æ¯ä¸ªå€™é€‰æ¨¡å‹è¿›è¡Œå‚æ•°ä¼°è®¡
3. **æ¨¡å‹éªŒè¯**: éªŒè¯æ¯ä¸ªæ¨¡å‹çš„æ€§èƒ½
4. **æœ€ä¼˜é€‰æ‹©**: æ ¹æ®ä¿¡æ¯å‡†åˆ™é€‰æ‹©æœ€ä¼˜æ¨¡å‹

## 7 é€’å½’è¾¨è¯†

### 7.1 é€’å½’æœ€å°äºŒä¹˜

**ç®—æ³• 5.1.1** (é€’å½’æœ€å°äºŒä¹˜)
é€’å½’æœ€å°äºŒä¹˜ç®—æ³•çš„çŸ©é˜µå½¢å¼ä¸ºï¼š
$$
\begin{align}
\hat{\theta}(t) &= \hat{\theta}(t-1) + K(t)\varepsilon(t) \\
\varepsilon(t) &= y(t) - \phi^T(t)\hat{\theta}(t-1) \\
K(t) &= P(t-1)\phi[t](\lambda + \phi^T(t)P(t-1)\phi(t))^{-1} \\
P(t) &= \frac{1}{\lambda}[I - K(t)\phi^T(t)]P(t-1)
\end{align}
$$

### 7.2 é€’å½’æœ€å¤§ä¼¼ç„¶

**ç®—æ³• 5.1.2** (é€’å½’æœ€å¤§ä¼¼ç„¶)
é€’å½’æœ€å¤§ä¼¼ç„¶ç®—æ³•ä¸ºï¼š
$$
\begin{align}
\hat{\theta}(t) &= \hat{\theta}(t-1) + K(t)\varepsilon(t) \\
\varepsilon(t) &= y(t) - \hat{y}(t|t-1) \\
K(t) &= P(t-1)\psi[t](\lambda + \psi^T(t)P(t-1)\psi(t))^{-1} \\
P(t) &= \frac{1}{\lambda}[I - K(t)\psi^T(t)]P(t-1)
\end{align}
$$

å…¶ä¸­ $\psi(t) = -\frac{\partial \varepsilon(t)}{\partial \theta}|_{\hat{\theta}(t-1)}$ã€‚

## 8 é²æ£’è¾¨è¯†

### 8.1 é²æ£’è¾¨è¯†é—®é¢˜

**å®šä¹‰ 6.1.1** (é²æ£’è¾¨è¯†)
åœ¨å­˜åœ¨æ¨¡å‹ä¸ç¡®å®šæ€§å’Œå™ªå£°çš„æƒ…å†µä¸‹ï¼Œè®¾è®¡å¯¹æ‰°åŠ¨ä¸æ•æ„Ÿçš„è¾¨è¯†ç®—æ³•ã€‚

### 8.2 Hè¾¨è¯†

**ç®—æ³• 6.1.1** (Hâˆè¾¨è¯†)
Hâˆè¾¨è¯†ç®—æ³•ä¸ºï¼š
$$\hat{\theta} = \arg\min_{\theta} \max_{w \in W} \frac{\|y - \hat{y}(\theta)\|_2}{\|w\|_2}$$

å…¶ä¸­ $W$ æ˜¯æ‰°åŠ¨é›†åˆã€‚

### 8.3 é›†å‘˜è¾¨è¯†

**å®šä¹‰ 6.1.2** (é›†å‘˜è¾¨è¯†)
é›†å‘˜è¾¨è¯†çš„ç›®æ ‡æ˜¯ç¡®å®šå‚æ•°çš„ä¸ç¡®å®šæ€§é›†åˆï¼Œè€Œä¸æ˜¯ç‚¹ä¼°è®¡ã€‚

**ç®—æ³• 6.1.2** (é›†å‘˜è¾¨è¯†)
é›†å‘˜è¾¨è¯†ç®—æ³•ä¸ºï¼š
$$\Theta(t) = \{\theta : |y(t) - \phi^T(t)\theta| \leq \gamma(t)\}$$

å…¶ä¸­ $\gamma(t)$ æ˜¯å™ªå£°è¾¹ç•Œã€‚

## 9 éçº¿æ€§ç³»ç»Ÿè¾¨è¯†

### 9.1 éçº¿æ€§æ¨¡å‹ç»“æ„

**å®šä¹‰ 7.1.1** (éçº¿æ€§æ¨¡å‹ç»“æ„)
å¸¸ç”¨çš„éçº¿æ€§æ¨¡å‹ç»“æ„åŒ…æ‹¬ï¼š

1. **NARXæ¨¡å‹**: $y(t) = f(y(t-1), ..., y(t-n_y), u(t-1), ..., u(t-n_u))$
2. **ç¥ç»ç½‘ç»œæ¨¡å‹**: $y(t) = NN(y(t-1), ..., y(t-n_y), u(t-1), ..., u(t-n_u))$
3. **æ¨¡ç³Šæ¨¡å‹**: $y(t) = \sum_{i=1}^M w_i f_i(y(t-1), ..., y(t-n_y), u(t-1), ..., u(t-n_u))$

### 9.2 éçº¿æ€§å‚æ•°è¾¨è¯†

**ç®—æ³• 7.1.1** (éçº¿æ€§æœ€å°äºŒä¹˜)
éçº¿æ€§æœ€å°äºŒä¹˜ç®—æ³•ä¸ºï¼š
$$\hat{\theta} = \arg\min_{\theta} \sum_{t=1}^N [y(t) - f(\phi(t), \theta)]^2$$

**ç®—æ³• 7.1.2** (æ¢¯åº¦ä¸‹é™)
æ¢¯åº¦ä¸‹é™ç®—æ³•ä¸ºï¼š
$$\theta(t+1) = \theta(t) - \mu \nabla J(\theta(t))$$

å…¶ä¸­ $\mu$ æ˜¯å­¦ä¹ ç‡ï¼Œ$\nabla J(\theta)$ æ˜¯ç›®æ ‡å‡½æ•°çš„æ¢¯åº¦ã€‚

## 10 æ¨¡å‹éªŒè¯

### 10.1 æ®‹å·®åˆ†æ

**å®šä¹‰ 8.1.1** (æ®‹å·®åˆ†æ)
æ®‹å·®å®šä¹‰ä¸ºï¼š
$$\varepsilon(t) = y(t) - \hat{y}(t)$$

**æ–¹æ³• 8.1.1** (æ®‹å·®æ£€éªŒ)

1. **ç™½å™ªå£°æ£€éªŒ**: æ£€éªŒæ®‹å·®æ˜¯å¦ä¸ºç™½å™ªå£°
2. **ç‹¬ç«‹æ€§æ£€éªŒ**: æ£€éªŒæ®‹å·®ä¸è¾“å…¥æ˜¯å¦ç‹¬ç«‹
3. **æ­£æ€æ€§æ£€éªŒ**: æ£€éªŒæ®‹å·®æ˜¯å¦æœä»æ­£æ€åˆ†å¸ƒ

### 10.2 äº¤å‰éªŒè¯

**æ–¹æ³• 8.2.1** (äº¤å‰éªŒè¯)

1. **æ•°æ®åˆ†å‰²**: å°†æ•°æ®åˆ†ä¸ºè®­ç»ƒé›†å’ŒéªŒè¯é›†
2. **æ¨¡å‹è®­ç»ƒ**: åœ¨è®­ç»ƒé›†ä¸Šè®­ç»ƒæ¨¡å‹
3. **æ¨¡å‹éªŒè¯**: åœ¨éªŒè¯é›†ä¸ŠéªŒè¯æ¨¡å‹æ€§èƒ½
4. **æ€§èƒ½è¯„ä¼°**: è®¡ç®—éªŒè¯è¯¯å·®

### 10.3 æ¨¡å‹æ¯”è¾ƒ

**æ–¹æ³• 8.3.1** (æ¨¡å‹æ¯”è¾ƒ)

1. **æ‹Ÿåˆä¼˜åº¦**: æ¯”è¾ƒæ¨¡å‹å¯¹æ•°æ®çš„æ‹Ÿåˆç¨‹åº¦
2. **é¢„æµ‹èƒ½åŠ›**: æ¯”è¾ƒæ¨¡å‹çš„é¢„æµ‹æ€§èƒ½
3. **å¤æ‚åº¦**: æ¯”è¾ƒæ¨¡å‹çš„å¤æ‚åº¦
4. **é²æ£’æ€§**: æ¯”è¾ƒæ¨¡å‹çš„é²æ£’æ€§

## 11 ä»£ç å®ç°

### 11.1 ç³»ç»Ÿè¾¨è¯†å™¨

```rust
use nalgebra::{DMatrix, DVector, Matrix, Vector};
use rand::Rng;
use std::f64::consts::PI;

/// ç³»ç»Ÿè¾¨è¯†å™¨
pub struct SystemIdentifier {
    pub theta: DVector<f64>,
    pub p: DMatrix<f64>,
    pub lambda: f64,
}

impl SystemIdentifier {
    /// åˆ›å»ºæ–°çš„ç³»ç»Ÿè¾¨è¯†å™¨
    pub fn new(n_params: usize, lambda: f64) -> Self {
        Self {
            theta: DVector::zeros(n_params),
            p: DMatrix::identity(n_params, n_params) * 1000.0,
            lambda,
        }
    }

    /// æœ€å°äºŒä¹˜è¾¨è¯†
    pub fn least_squares_identification(&mut self, phi: &DVector<f64>, y: f64) {
        let prediction = phi.dot(&self.theta);
        let error = y - prediction;

        let k = &self.p * phi / (self.lambda + phi.dot(&(&self.p * phi)));
        self.theta += &k * error;

        let i_k_phi = DMatrix::identity(self.theta.len(), self.theta.len()) - &k * phi.transpose();
        self.p = &i_k_phi * &self.p / self.lambda;
    }

    /// æ‰¹é‡æœ€å°äºŒä¹˜è¾¨è¯†
    pub fn batch_least_squares(&self, phi_matrix: &DMatrix<f64>, y_vector: &DVector<f64>) -> DVector<f64> {
        let phi_t_phi = phi_matrix.transpose() * phi_matrix;
        let phi_t_y = phi_matrix.transpose() * y_vector;

        phi_t_phi.try_inverse().unwrap() * phi_t_y
    }

    /// è·å–å‚æ•°ä¼°è®¡
    pub fn get_parameters(&self) -> &DVector<f64> {
        &self.theta
    }

    /// è·å–å‚æ•°åæ–¹å·®çŸ©é˜µ
    pub fn get_covariance(&self) -> &DMatrix<f64> {
        &self.p
    }
}

/// å¡å°”æ›¼æ»¤æ³¢å™¨
pub struct KalmanFilter {
    pub x: DVector<f64>,
    pub p: DMatrix<f64>,
    pub a: DMatrix<f64>,
    pub b: DMatrix<f64>,
    pub c: DMatrix<f64>,
    pub q: DMatrix<f64>,
    pub r: DMatrix<f64>,
}

impl KalmanFilter {
    /// åˆ›å»ºæ–°çš„å¡å°”æ›¼æ»¤æ³¢å™¨
    pub fn new(a: DMatrix<f64>, b: DMatrix<f64>, c: DMatrix<f64>,
               q: DMatrix<f64>, r: DMatrix<f64>) -> Self {
        let n = a.nrows();
        Self {
            x: DVector::zeros(n),
            p: DMatrix::identity(n, n),
            a, b, c, q, r,
        }
    }

    /// é¢„æµ‹æ­¥éª¤
    pub fn predict(&mut self, u: &DVector<f64>) {
        // çŠ¶æ€é¢„æµ‹
        self.x = &self.a * &self.x + &self.b * u;

        // åæ–¹å·®é¢„æµ‹
        self.p = &self.a * &self.p * &self.a.transpose() + &self.q;
    }

    /// æ›´æ–°æ­¥éª¤
    pub fn update(&mut self, y: f64) {
        let y_pred = self.c.dot(&self.x);
        let error = y - y_pred;

        // å¡å°”æ›¼å¢ç›Š
        let s = &self.c * &self.p * &self.c.transpose() + self.r[(0, 0)];
        let k = &self.p * &self.c.transpose() / s;

        // çŠ¶æ€æ›´æ–°
        self.x += &k * error;

        // åæ–¹å·®æ›´æ–°
        let i_kc = DMatrix::identity(self.x.len(), self.x.len()) - &k * &self.c;
        self.p = &i_kc * &self.p;
    }

    /// è·å–çŠ¶æ€ä¼°è®¡
    pub fn get_state(&self) -> &DVector<f64> {
        &self.x
    }

    /// è·å–çŠ¶æ€åæ–¹å·®
    pub fn get_state_covariance(&self) -> &DMatrix<f64> {
        &self.p
    }
}

/// æ‰©å±•å¡å°”æ›¼æ»¤æ³¢å™¨
pub struct ExtendedKalmanFilter {
    pub x: DVector<f64>,
    pub p: DMatrix<f64>,
    pub q: DMatrix<f64>,
    pub r: f64,
}

impl ExtendedKalmanFilter {
    /// åˆ›å»ºæ–°çš„æ‰©å±•å¡å°”æ›¼æ»¤æ³¢å™¨
    pub fn new(n_states: usize, q: DMatrix<f64>, r: f64) -> Self {
        Self {
            x: DVector::zeros(n_states),
            p: DMatrix::identity(n_states, n_states),
            q, r,
        }
    }

    /// é¢„æµ‹æ­¥éª¤
    pub fn predict<F>(&mut self, u: &DVector<f64>, f: F)
    where F: Fn(&DVector<f64>, &DVector<f64>) -> DVector<f64> {
        // çŠ¶æ€é¢„æµ‹
        self.x = f(&self.x, u);

        // è®¡ç®—é›…å¯æ¯”çŸ©é˜µ
        let f_jacobian = self.compute_jacobian_f(&self.x, u, &f);

        // åæ–¹å·®é¢„æµ‹
        self.p = &f_jacobian * &self.p * &f_jacobian.transpose() + &self.q;
    }

    /// æ›´æ–°æ­¥éª¤
    pub fn update<H>(&mut self, y: f64, h: H)
    where H: Fn(&DVector<f64>) -> f64 {
        let y_pred = h(&self.x);
        let error = y - y_pred;

        // è®¡ç®—è§‚æµ‹é›…å¯æ¯”çŸ©é˜µ
        let h_jacobian = self.compute_jacobian_h(&self.x, &h);

        // å¡å°”æ›¼å¢ç›Š
        let s = &h_jacobian * &self.p * &h_jacobian.transpose() + self.r;
        let k = &self.p * &h_jacobian.transpose() / s;

        // çŠ¶æ€æ›´æ–°
        self.x += &k * error;

        // åæ–¹å·®æ›´æ–°
        let i_kh = DMatrix::identity(self.x.len(), self.x.len()) - &k * &h_jacobian;
        self.p = &i_kh * &self.p;
    }

    /// è®¡ç®—çŠ¶æ€è½¬ç§»é›…å¯æ¯”çŸ©é˜µ
    fn compute_jacobian_f<F>(&self, x: &DVector<f64>, u: &DVector<f64>, f: &F) -> DMatrix<f64>
    where F: Fn(&DVector<f64>, &DVector<f64>) -> DVector<f64> {
        let n = x.len();
        let mut jacobian = DMatrix::zeros(n, n);
        let h = 1e-6;

        for i in 0..n {
            let mut x_plus = x.clone();
            x_plus[i] += h;
            let f_plus = f(&x_plus, u);
            let f_orig = f(x, u);

            for j in 0..n {
                jacobian[(j, i)] = (f_plus[j] - f_orig[j]) / h;
            }
        }

        jacobian
    }

    /// è®¡ç®—è§‚æµ‹é›…å¯æ¯”çŸ©é˜µ
    fn compute_jacobian_h<H>(&self, x: &DVector<f64>, h: &H) -> DMatrix<f64>
    where H: Fn(&DVector<f64>) -> f64 {
        let n = x.len();
        let mut jacobian = DMatrix::zeros(1, n);
        let h_val = 1e-6;

        for i in 0..n {
            let mut x_plus = x.clone();
            x_plus[i] += h_val;
            let h_plus = h(&x_plus);
            let h_orig = h(x);

            jacobian[(0, i)] = (h_plus - h_orig) / h_val;
        }

        jacobian
    }
}

/// æ¨¡å‹éªŒè¯å™¨
pub struct ModelValidator;

impl ModelValidator {
    /// è®¡ç®—æ®‹å·®
    pub fn compute_residuals(y_true: &[f64], y_pred: &[f64]) -> Vec<f64> {
        y_true.iter().zip(y_pred.iter())
            .map(|(&y_t, &y_p)| y_t - y_p)
            .collect()
    }

    /// è®¡ç®—å‡æ–¹è¯¯å·®
    pub fn mean_squared_error(y_true: &[f64], y_pred: &[f64]) -> f64 {
        let n = y_true.len() as f64;
        y_true.iter().zip(y_pred.iter())
            .map(|(&y_t, &y_p)| (y_t - y_p).powi(2))
            .sum::<f64>() / n
    }

    /// è®¡ç®—å†³å®šç³»æ•°
    pub fn coefficient_of_determination(y_true: &[f64], y_pred: &[f64]) -> f64 {
        let y_mean = y_true.iter().sum::<f64>() / y_true.len() as f64;
        let ss_tot = y_true.iter().map(|&y| (y - y_mean).powi(2)).sum::<f64>();
        let ss_res = y_true.iter().zip(y_pred.iter())
            .map(|(&y_t, &y_p)| (y_t - y_p).powi(2))
            .sum::<f64>();

        1.0 - ss_res / ss_tot
    }

    /// ç™½å™ªå£°æ£€éªŒ
    pub fn whiteness_test(residuals: &[f64], max_lag: usize) -> f64 {
        let n = residuals.len();
        let mut autocorr = vec![0.0; max_lag + 1];

        // è®¡ç®—è‡ªç›¸å…³å‡½æ•°
        for lag in 0..=max_lag {
            let mut sum = 0.0;
            for i in 0..n-lag {
                sum += residuals[i] * residuals[i + lag];
            }
            autocorr[lag] = sum / (n - lag) as f64;
        }

        // è®¡ç®—Qç»Ÿè®¡é‡
        let q_stat = n as f64 * (n + 2.0) * autocorr.iter().skip(1)
            .map(|&r| r.powi(2) / (n - 1) as f64)
            .sum::<f64>();

        q_stat
    }

    /// AICå‡†åˆ™
    pub fn aic_criterion(residuals: &[f64], n_params: usize) -> f64 {
        let n = residuals.len() as f64;
        let mse = Self::mean_squared_error(residuals, &vec![0.0; residuals.len()]);
        n * mse.ln() + 2.0 * n_params as f64
    }

    /// BICå‡†åˆ™
    pub fn bic_criterion(residuals: &[f64], n_params: usize) -> f64 {
        let n = residuals.len() as f64;
        let mse = Self::mean_squared_error(residuals, &vec![0.0; residuals.len()]);
        n * mse.ln() + n_params as f64 * n.ln()
    }
}

/// éçº¿æ€§ç³»ç»Ÿè¾¨è¯†å™¨
pub struct NonlinearSystemIdentifier {
    pub weights: Vec<f64>,
    pub learning_rate: f64,
}

impl NonlinearSystemIdentifier {
    /// åˆ›å»ºæ–°çš„éçº¿æ€§ç³»ç»Ÿè¾¨è¯†å™¨
    pub fn new(n_weights: usize, learning_rate: f64) -> Self {
        let mut rng = rand::thread_rng();
        let weights = (0..n_weights).map(|_| rng.gen_range(-0.1..0.1)).collect();

        Self {
            weights,
            learning_rate,
        }
    }

    /// ç¥ç»ç½‘ç»œå‰å‘ä¼ æ’­
    pub fn forward(&self, inputs: &[f64]) -> f64 {
        let mut output = 0.0;
        for (i, &input) in inputs.iter().enumerate() {
            output += self.weights[i] * input;
        }
        output += self.weights[inputs.len()]; // åç½®é¡¹
        output.tanh() // æ¿€æ´»å‡½æ•°
    }

    /// æ¢¯åº¦ä¸‹é™è®­ç»ƒ
    pub fn train(&mut self, inputs: &[f64], target: f64) {
        let prediction = self.forward(inputs);
        let error = target - prediction;

        // è®¡ç®—æ¢¯åº¦
        let mut gradients = vec![0.0; self.weights.len()];
        let activation_derivative = 1.0 - prediction.powi(2); // tanhçš„å¯¼æ•°

        for (i, &input) in inputs.iter().enumerate() {
            gradients[i] = -error * activation_derivative * input;
        }
        gradients[inputs.len()] = -error * activation_derivative; // åç½®æ¢¯åº¦

        // æ›´æ–°æƒé‡
        for (i, gradient) in gradients.iter().enumerate() {
            self.weights[i] -= self.learning_rate * gradient;
        }
    }

    /// æ‰¹é‡è®­ç»ƒ
    pub fn batch_train(&mut self, training_data: &[(&[f64], f64)], epochs: usize) {
        for _ in 0..epochs {
            for &(inputs, target) in training_data {
                self.train(inputs, target);
            }
        }
    }
}
```

### 11.2 æµ‹è¯•ä»£ç 

```rust
# [cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_least_squares_identification() {
        let mut identifier = SystemIdentifier::new(2, 0.95);

        // æ¨¡æ‹Ÿæ•°æ®: y = 2*x1 + 3*x2 + noise
        let phi1 = DVector::from_vec(vec![1.0, 2.0]);
        let phi2 = DVector::from_vec(vec![2.0, 1.0]);
        let phi3 = DVector::from_vec(vec![3.0, 0.5]);

        identifier.least_squares_identification(&phi1, 8.0);
        identifier.least_squares_identification(&phi2, 7.0);
        identifier.least_squares_identification(&phi3, 7.5);

        let params = identifier.get_parameters();
        println!("ä¼°è®¡å‚æ•°: {:?}", params);

        // éªŒè¯å‚æ•°ä¼°è®¡çš„åˆç†æ€§
        assert!((params[0] - 2.0).abs() < 1.0);
        assert!((params[1] - 3.0).abs() < 1.0);
    }

    #[test]
    fn test_kalman_filter() {
        // ç®€å•çš„ä¸€ç»´ç³»ç»Ÿ
        let a = DMatrix::from_row_slice(1, 1, &[1.0]);
        let b = DMatrix::from_row_slice(1, 1, &[1.0]);
        let c = DMatrix::from_row_slice(1, 1, &[1.0]);
        let q = DMatrix::from_row_slice(1, 1, &[0.1]);
        let r = DMatrix::from_row_slice(1, 1, &[1.0]);

        let mut kf = KalmanFilter::new(a, b, c, q, r);

        let u = DVector::from_vec(vec![1.0]);
        let y = 5.0;

        kf.predict(&u);
        kf.update(y);

        let state = kf.get_state();
        println!("çŠ¶æ€ä¼°è®¡: {:?}", state);

        assert!(state[0].abs() > 0.0);
    }

    #[test]
    fn test_model_validation() {
        let y_true = vec![1.0, 2.0, 3.0, 4.0, 5.0];
        let y_pred = vec![1.1, 1.9, 3.1, 3.9, 5.1];

        let mse = ModelValidator::mean_squared_error(&y_true, &y_pred);
        let r2 = ModelValidator::coefficient_of_determination(&y_true, &y_pred);

        println!("MSE: {:.4}", mse);
        println!("RÂ²: {:.4}", r2);

        assert!(mse > 0.0);
        assert!(r2 > 0.9);
    }

    #[test]
    fn test_nonlinear_identification() {
        let mut identifier = NonlinearSystemIdentifier::new(3, 0.01);

        // è®­ç»ƒæ•°æ®: y = tanh(2*x1 + 3*x2 + 1)
        let training_data = vec![
            (&[1.0, 2.0], (2.0*1.0 + 3.0*2.0 + 1.0).tanh()),
            (&[2.0, 1.0], (2.0*2.0 + 3.0*1.0 + 1.0).tanh()),
            (&[0.5, 1.5], (2.0*0.5 + 3.0*1.5 + 1.0).tanh()),
        ];

        identifier.batch_train(&training_data, 1000);

        // æµ‹è¯•é¢„æµ‹
        let test_input = [1.0, 1.0];
        let prediction = identifier.forward(&test_input);
        let expected = (2.0*1.0 + 3.0*1.0 + 1.0).tanh();

        println!("é¢„æµ‹å€¼: {:.4}, æœŸæœ›å€¼: {:.4}", prediction, expected);
        assert!((prediction - expected).abs() < 0.1);
    }
}
```

## 12 åº”ç”¨ç¤ºä¾‹

### 12.1 çº¿æ€§ç³»ç»Ÿè¾¨è¯†

```rust
/// çº¿æ€§ç³»ç»Ÿè¾¨è¯†ç¤ºä¾‹
pub fn linear_system_identification_example() {
    println!("çº¿æ€§ç³»ç»Ÿè¾¨è¯†ç¤ºä¾‹:");

    // çœŸå®ç³»ç»Ÿ: y(t) = 2*u(t-1) + 3*u(t-2) + 0.5*y(t-1) + noise
    let mut identifier = SystemIdentifier::new(4, 0.95);

    let mut u_history = vec![0.0; 3];
    let mut y_history = vec![0.0; 3];

    // ç”Ÿæˆè®­ç»ƒæ•°æ®
    let mut rng = rand::thread_rng();
    for t in 0..100 {
        let u = rng.gen_range(-1.0..1.0);
        let noise = rng.gen_range(-0.1..0.1);

        // çœŸå®è¾“å‡º
        let y_true = 2.0 * u_history[1] + 3.0 * u_history[2] + 0.5 * y_history[1] + noise;

        // å›å½’å‘é‡
        let phi = DVector::from_vec(vec![
            u_history[1], u_history[2], y_history[1], 1.0
        ]);

        // åœ¨çº¿è¾¨è¯†
        identifier.least_squares_identification(&phi, y_true);

        // æ›´æ–°å†å²
        u_history.rotate_right(1);
        u_history[0] = u;
        y_history.rotate_right(1);
        y_history[0] = y_true;

        if t % 20 == 0 {
            let params = identifier.get_parameters();
            println!("t={}: å‚æ•°ä¼°è®¡: [{:.3}, {:.3}, {:.3}, {:.3}]",
                     t, params[0], params[1], params[2], params[3]);
        }
    }

    let final_params = identifier.get_parameters();
    println!("\næœ€ç»ˆå‚æ•°ä¼°è®¡:");
    println!("a1 (çœŸå®å€¼: 2.0): {:.3}", final_params[0]);
    println!("a2 (çœŸå®å€¼: 3.0): {:.3}", final_params[1]);
    println!("b1 (çœŸå®å€¼: 0.5): {:.3}", final_params[2]);
    println!("bias: {:.3}", final_params[3]);
}
```

### 12.2 éçº¿æ€§ç³»ç»Ÿè¾¨è¯†

```rust
/// éçº¿æ€§ç³»ç»Ÿè¾¨è¯†ç¤ºä¾‹
pub fn nonlinear_system_identification_example() {
    println!("éçº¿æ€§ç³»ç»Ÿè¾¨è¯†ç¤ºä¾‹:");

    // çœŸå®ç³»ç»Ÿ: y(t) = tanh(2*u(t-1) + 3*u(t-2)) + noise
    let mut identifier = NonlinearSystemIdentifier::new(4, 0.01);

    let mut u_history = vec![0.0; 3];
    let mut y_history = vec![0.0; 3];

    // ç”Ÿæˆè®­ç»ƒæ•°æ®
    let mut rng = rand::thread_rng();
    let mut training_data = Vec::new();

    for _ in 0..1000 {
        let u = rng.gen_range(-1.0..1.0);
        let noise = rng.gen_range(-0.05..0.05);

        // çœŸå®è¾“å‡º
        let y_true = (2.0 * u_history[1] + 3.0 * u_history[2]).tanh() + noise;

        // è¾“å…¥ç‰¹å¾
        let inputs = vec![u_history[1], u_history[2], y_history[1], 1.0];
        training_data.push((inputs, y_true));

        // æ›´æ–°å†å²
        u_history.rotate_right(1);
        u_history[0] = u;
        y_history.rotate_right(1);
        y_history[0] = y_true;
    }

    // è®­ç»ƒç¥ç»ç½‘ç»œ
    identifier.batch_train(&training_data.iter().map(|(i, t)| (i.as_slice(), *t)).collect::<Vec<_>>(), 100);

    println!("è®­ç»ƒå®Œæˆ");
    println!("æƒé‡: {:?}", identifier.weights);

    // æµ‹è¯•é¢„æµ‹
    let test_inputs = vec![
        vec![1.0, 0.5, 0.0, 1.0],
        vec![0.5, 1.0, 0.0, 1.0],
        vec![0.0, 0.0, 0.0, 1.0],
    ];

    println!("\né¢„æµ‹æµ‹è¯•:");
    for (i, inputs) in test_inputs.iter().enumerate() {
        let prediction = identifier.forward(inputs);
        let expected = (2.0 * inputs[0] + 3.0 * inputs[1]).tanh();
        println!("æµ‹è¯•{}: é¢„æµ‹={:.4}, æœŸæœ›={:.4}, è¯¯å·®={:.4}",
                 i+1, prediction, expected, (prediction - expected).abs());
    }
}
```

### 12.3 çŠ¶æ€ä¼°è®¡ç¤ºä¾‹

```rust
/// çŠ¶æ€ä¼°è®¡ç¤ºä¾‹
pub fn state_estimation_example() {
    println!("çŠ¶æ€ä¼°è®¡ç¤ºä¾‹:");

    // ç®€å•çš„ä¸€ç»´è¿åŠ¨ç³»ç»Ÿ
    let a = DMatrix::from_row_slice(2, 2, &[1.0, 1.0, 0.0, 1.0]); // ä½ç½®å’Œé€Ÿåº¦
    let b = DMatrix::from_row_slice(2, 1, &[0.5, 1.0]); // åŠ é€Ÿåº¦è¾“å…¥
    let c = DMatrix::from_row_slice(1, 2, &[1.0, 0.0]); // åªè§‚æµ‹ä½ç½®
    let q = DMatrix::from_row_slice(2, 2, &[0.1, 0.0, 0.0, 0.1]); // è¿‡ç¨‹å™ªå£°
    let r = DMatrix::from_row_slice(1, 1, &[1.0]); // è§‚æµ‹å™ªå£°

    let mut kf = KalmanFilter::new(a, b, c, q, r);

    // çœŸå®çŠ¶æ€
    let mut true_position = 0.0;
    let mut true_velocity = 0.0;

    let mut rng = rand::thread_rng();

    println!("æ—¶é—´ | çœŸå®ä½ç½® | è§‚æµ‹ä½ç½® | ä¼°è®¡ä½ç½® | ä¼°è®¡é€Ÿåº¦");

    for t in 0..20 {
        // çœŸå®ç³»ç»Ÿ
        let acceleration = 1.0; // æ’å®šåŠ é€Ÿåº¦
        true_velocity += acceleration;
        true_position += true_velocity;

        // æ·»åŠ è¿‡ç¨‹å™ªå£°
        true_position += rng.gen_range(-0.1..0.1);
        true_velocity += rng.gen_range(-0.1..0.1);

        // è§‚æµ‹ï¼ˆå¸¦å™ªå£°ï¼‰
        let observed_position = true_position + rng.gen_range(-0.5..0.5);

        // å¡å°”æ›¼æ»¤æ³¢
        let u = DVector::from_vec(vec![acceleration]);
        kf.predict(&u);
        kf.update(observed_position);

        let state = kf.get_state();

        if t % 5 == 0 {
            println!("{:2} | {:8.3} | {:8.3} | {:8.3} | {:8.3}",
                     t, true_position, observed_position, state[0], state[1]);
        }
    }

    println!("\næœ€ç»ˆçŠ¶æ€ä¼°è®¡:");
    let final_state = kf.get_state();
    println!("ä½ç½®: {:.3} (çœŸå®: {:.3})", final_state[0], true_position);
    println!("é€Ÿåº¦: {:.3} (çœŸå®: {:.3})", final_state[1], true_velocity);
}
```

## 13 ç›¸å…³ç†è®º

### 13.1 æ§åˆ¶ç†è®º

- [05.1.1 åŸºç¡€æ§åˆ¶ç†è®º](05.1.1_åŸºç¡€æ§åˆ¶ç†è®º.md)
- [05.1.2 çº¿æ€§ç³»ç»Ÿç†è®º](05.1.2_çº¿æ€§ç³»ç»Ÿç†è®º.md)
- [05.1.3 ç³»ç»Ÿç¨³å®šæ€§ç†è®º](05.1.3_ç³»ç»Ÿç¨³å®šæ€§ç†è®º.md)

### 13.2 çŠ¶æ€ä¼°è®¡ç†è®º

- [05.2.4 çŠ¶æ€ä¼°è®¡ç†è®º](05.2.4_çŠ¶æ€ä¼°è®¡ç†è®º.md)
- [05.2.3 æœ€ä¼˜æ§åˆ¶ç†è®º](05.2.3_æœ€ä¼˜æ§åˆ¶ç†è®º.md)

### 13.3 è‡ªé€‚åº”æ§åˆ¶ç†è®º

- [05.5.1 è‡ªé€‚åº”æ§åˆ¶åŸºç¡€](05.5.1_è‡ªé€‚åº”æ§åˆ¶åŸºç¡€.md)
- [05.5.2 è‡ªæ ¡æ­£æ§åˆ¶](05.5.2_è‡ªæ ¡æ­£æ§åˆ¶.md)

### 13.4 é²æ£’æ§åˆ¶ç†è®º

- [05.4.1 é²æ£’æ§åˆ¶åŸºç¡€](05.4.1_é²æ£’æ§åˆ¶åŸºç¡€.md)
- [05.4.2 Î¼ç»¼åˆæ–¹æ³•](05.4.2_Î¼ç»¼åˆæ–¹æ³•.md)

## 12. å‚è€ƒæ–‡çŒ®

1. **Ljung, L.** (1999). *System Identification: Theory for the User*. Prentice Hall.
2. **SÃ¶derstrÃ¶m, T., & Stoica, P.** (1989). *System Identification*. Prentice Hall.
3. **Nelles, O.** (2001). *Nonlinear System Identification: From Classical Approaches to Neural Networks and Fuzzy Models*. Springer.
4. **Anderson, B. D. O., & Moore, J. B.** (1979). *Optimal Filtering*. Prentice Hall.
5. **Haykin, S.** (2001). *Kalman Filtering and Neural Networks*. Wiley.
6. **Doucet, A., de Freitas, N., & Gordon, N.** (2001). *Sequential Monte Carlo Methods in Practice*. Springer.
7. **Akaike, H.** (1974). *A New Look at the Statistical Model Identification*. IEEE Transactions on Automatic Control.
8. **Schwarz, G.** (1978). *Estimating the Dimension of a Model*. The Annals of Statistics.
9. **Rissanen, J.** (1978). *Modeling by Shortest Data Description*. Automatica.
10. **Zhou, K., & Doyle, J. C.** (1998). *Essentials of Robust Control*. Prentice Hall.

---

**å…³é”®è¯**: ç³»ç»Ÿè¾¨è¯†ã€å‚æ•°è¾¨è¯†ã€çŠ¶æ€ä¼°è®¡ã€å¡å°”æ›¼æ»¤æ³¢ã€æ¨¡å‹éªŒè¯ã€æœ€å°äºŒä¹˜ã€æœ€å¤§ä¼¼ç„¶

**ç›¸å…³æ–‡æ¡£**:

- [05.1.1 åŸºç¡€æ§åˆ¶ç†è®º](05.1.1_åŸºç¡€æ§åˆ¶ç†è®º.md)
- [05.1.2 çº¿æ€§ç³»ç»Ÿç†è®º](05.1.2_çº¿æ€§ç³»ç»Ÿç†è®º.md)
- [05.1.3 ç³»ç»Ÿç¨³å®šæ€§ç†è®º](05.1.3_ç³»ç»Ÿç¨³å®šæ€§ç†è®º.md)

## 14 æ‰¹åˆ¤æ€§åˆ†æ

### 14.1 å¤šå…ƒç†è®ºè§†è§’

**ç»Ÿè®¡è§†è§’**ï¼šä»¥ä¼°è®¡é‡æ— åæ€§ã€ä¸€è‡´æ€§ã€æ–¹å·®æœ€å°ä¸ºç›®æ ‡ï¼Œç†è®ºä¸¥è°¨ä½†å‡è®¾ï¼ˆç‹¬ç«‹åŒåˆ†å¸ƒã€å™ªå£°é«˜æ–¯æ€§ï¼‰åœ¨å·¥ç¨‹ä¸­å¸¸è¢«ç ´åã€‚

**æ§åˆ¶è§†è§’**ï¼šè¾¨è¯†æœåŠ¡äºæ§åˆ¶ï¼Œé‡è§†å¯æ§/å¯è§‚ä¸é—­ç¯æ€§èƒ½ï¼›è¾¨è¯†-æ§åˆ¶åˆ†ç¦»å¹¶ä¸æ€»æ˜¯æˆç«‹ï¼Œéœ€è”åˆè®¾è®¡ã€‚

**è®¡ç®—è§†è§’**ï¼šå®æ—¶ã€åœ¨çº¿ã€å¤§æ•°æ®ä¸é«˜ç»´çš„æ•°å€¼ç¨³å®šæ€§ä¸å¤æ‚åº¦æ˜¯æ ¸å¿ƒæŒ‘æˆ˜ã€‚

### 14.2 å±€é™æ€§åˆ†æ

**æ¨¡å‹å¤±é…**ï¼šç»“æ„é€‰é”™çš„ç³»ç»Ÿæ€§åå·®æ¯”å‚æ•°è¯¯å·®æ›´è‡´å‘½ï¼›é»‘ç›’æ¨¡å‹è§£é‡Šæ€§ä¸è¶³ã€è¿ç§»å›°éš¾ã€‚

**å™ªå£°ä¸æ‰°åŠ¨**ï¼šè¾“å…¥-å™ªå£°ç›¸å…³ã€æµ‹é‡é¥±å’Œã€ä¼ æ„Ÿå™¨æ¼‚ç§»ä¼šè¿èƒŒç»å…¸å‡è®¾ï¼Œå¯¼è‡´ä¼°è®¡åå·®ã€‚

**é—­ç¯è¾¨è¯†éš¾é¢˜**ï¼šæ§åˆ¶å™¨å­˜åœ¨æ—¶çš„å†…ç”Ÿæ€§ä½¿æœ€å°äºŒä¹˜å¤±æ•ˆï¼Œéœ€è¦IV/PEMç­‰æ›´å¤æ‚æ–¹æ³•ã€‚

**æ•°æ®è´¨é‡ä¸å¯æ¿€åŠ±æ€§**ï¼šæ¿€åŠ±ä¸è¶³ã€æ•°æ®è¦†ç›–ä¸å…¨å°†å¯¼è‡´ä¸å¯è¾¨è¯†æˆ–ç—…æ€ã€‚

### 14.3 äº‰è®®ä¸åˆ†æ­§

**ç™½ç›’vsé»‘ç›’**ï¼šç‰©ç†æ„ä¹‰ä¸æ³›åŒ–èƒ½åŠ›çš„æƒè¡¡ï¼›å¯è§£é‡Šæ€§ä¸é¢„æµ‹ç²¾åº¦çš„å–èˆå› é¢†åŸŸè€Œå¼‚ã€‚

**ç¦»çº¿vsåœ¨çº¿**ï¼šç¦»çº¿ç²¾åº¦é«˜ã€åœ¨çº¿é€‚åº”å¼ºï¼Œå¦‚ä½•å¹³è¡¡å“åº”é€Ÿåº¦ä¸ç¨³å¥æ€§é•¿æœŸäº‰è®ºã€‚

**ç»Ÿè®¡æœ€ä¼˜vsæ§åˆ¶æœ€ä¼˜**ï¼šç»Ÿè®¡æ„ä¹‰ä¸‹çš„æœ€ä¼˜ä¸ç­‰äºé—­ç¯æ€§èƒ½æœ€ä¼˜ï¼Œç›®æ ‡å‡½æ•°åº”å¦‚ä½•ç»Ÿä¸€ï¼Ÿ

### 14.4 åº”ç”¨å‰æ™¯

**å·¥ä¸šäº’è”ç½‘ä¸é¢„æµ‹è¿ç»´**ï¼šå¤§è§„æ¨¡è¿‡ç¨‹æ•°æ®ä¸è¾¹ç¼˜è®¡ç®—æ¨åŠ¨åœ¨çº¿è¾¨è¯†ä¸å¥åº·ç›‘æµ‹ã€‚

**æ•°æ®é©±åŠ¨æ§åˆ¶**ï¼šVRFTã€subspace+DPCã€ç‰©ç†å…ˆéªŒç¥ç»ç½‘ç»œ(PINN)ç­‰èåˆæ–¹æ³•å¿«é€Ÿå‘å±•ã€‚

**å®‰å…¨å…³é”®ç³»ç»Ÿ**ï¼šåœ¨èˆªç©º/åŒ»ç–—/ç”µåŠ›ä¸­ï¼Œå¸¦çº¦æŸã€å¸¦è¯æ®çš„è¾¨è¯†ä¸éªŒè¯éœ€æ±‚ä¸Šå‡ã€‚

### 14.5 æ”¹è¿›å»ºè®®

**è”åˆè®¾è®¡**ï¼šå°†è¾¨è¯†ä¸æ§åˆ¶ã€æ•…éšœè¯Šæ–­ã€çŠ¶æ€ä¼°è®¡ååŒå»ºæ¨¡ä¸ä¼˜åŒ–ã€‚

**ç¨³å¥ç»Ÿè®¡**ï¼šå¼•å…¥ç¨€ç–/åˆ†ä½/Mä¼°è®¡ä¸å› æœå·¥å…·ï¼Œç¼“è§£å¼‚å¸¸ä¸ç›¸å…³å™ªå£°å½±å“ã€‚

**ç»“æ„å­¦ä¹ **ï¼šè‡ªåŠ¨åŒ–æ¨¡å‹ç»“æ„æœç´¢ï¼ˆä¿¡æ¯å‡†åˆ™+å…ˆéªŒ+å¯è§£é‡Šçº¦æŸï¼‰ï¼Œæå‡å¯è¿ç§»æ€§ã€‚

**éªŒè¯ä¸åŸºå‡†**ï¼šå»ºç«‹è·¨é¢†åŸŸå…¬å…±æ•°æ®é›†ã€å¯å¤ç°å®éªŒä¸è¯„ä»·åŸºå‡†ï¼Œå½¢æˆå·¥ç¨‹é—­ç¯ã€‚
