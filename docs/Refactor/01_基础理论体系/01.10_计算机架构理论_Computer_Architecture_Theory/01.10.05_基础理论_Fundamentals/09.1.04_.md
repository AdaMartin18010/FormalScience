# å†…å­˜å±‚æ¬¡ç†è®º

## ğŸ“‹ ç›®å½•

- [å†…å­˜å±‚æ¬¡ç†è®º](#å†…å­˜å±‚æ¬¡ç†è®º)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 å½¢å¼åŒ–å®šä¹‰](#1-å½¢å¼åŒ–å®šä¹‰)
    - [1.1 å†…å­˜å±‚æ¬¡åŸºç¡€](#11-å†…å­˜å±‚æ¬¡åŸºç¡€)
    - [1.2 æ€§èƒ½æ¨¡å‹](#12-æ€§èƒ½æ¨¡å‹)
  - [2 æ ¸å¿ƒå®šç†](#2-æ ¸å¿ƒå®šç†)
    - [2.1 ç¼“å­˜æ€§èƒ½å®šç†](#21-ç¼“å­˜æ€§èƒ½å®šç†)
    - [2.2 å†…å­˜å¢™å®šç†](#22-å†…å­˜å¢™å®šç†)
  - [3 ç®—æ³•å®ç°](#3-ç®—æ³•å®ç°)
    - [3.1 å¤šçº§ç¼“å­˜å®ç°](#31-å¤šçº§ç¼“å­˜å®ç°)
    - [3.2 é¢„å–å™¨å®ç°](#32-é¢„å–å™¨å®ç°)
    - [3.3 å†…å­˜æ§åˆ¶å™¨å®ç°](#33-å†…å­˜æ§åˆ¶å™¨å®ç°)
  - [4 åº”ç”¨åœºæ™¯](#4-åº”ç”¨åœºæ™¯)
    - [4.1 å¤„ç†å™¨è®¾è®¡](#41-å¤„ç†å™¨è®¾è®¡)
    - [4.2 æ€§èƒ½ä¼˜åŒ–](#42-æ€§èƒ½ä¼˜åŒ–)
    - [4.3 ç³»ç»Ÿè®¾è®¡](#43-ç³»ç»Ÿè®¾è®¡)
  - [5 ç›¸å…³ç†è®º](#5-ç›¸å…³ç†è®º)
    - [5.1 è®¡ç®—æœºç»„ç»‡](#51-è®¡ç®—æœºç»„ç»‡)
    - [5.2 æ€§èƒ½åˆ†æ](#52-æ€§èƒ½åˆ†æ)
    - [5.3 å¹¶è¡Œè®¡ç®—](#53-å¹¶è¡Œè®¡ç®—)
  - [6. å‚è€ƒæ–‡çŒ®](#6-å‚è€ƒæ–‡çŒ®)
  - [6 æ‰¹åˆ¤æ€§åˆ†æ](#6-æ‰¹åˆ¤æ€§åˆ†æ)

---

## 1 å½¢å¼åŒ–å®šä¹‰

### 1.1 å†…å­˜å±‚æ¬¡åŸºç¡€

**å®šä¹‰ 9.1.04.1 (å†…å­˜å±‚æ¬¡)**
å†…å­˜å±‚æ¬¡ $\mathcal{M}$ æ˜¯ä¸€ä¸ªååºé›†ï¼š
$$\mathcal{M} = (L, \prec, \text{size}, \text{latency}, \text{bandwidth})$$
å…¶ä¸­ï¼š

- $L$ æ˜¯å†…å­˜çº§åˆ«é›†åˆ
- $\prec$ è¡¨ç¤ºè®¿é—®å»¶è¿Ÿå…³ç³»ï¼š$L_i \prec L_j$ è¡¨ç¤º $L_i$ æ¯” $L_j$ æ›´å¿«
- $\text{size}: L \rightarrow \mathbb{N}$ æ˜¯å®¹é‡å‡½æ•°
- $\text{latency}: L \rightarrow \mathbb{R}^+$ æ˜¯å»¶è¿Ÿå‡½æ•°
- $\text{bandwidth}: L \rightarrow \mathbb{R}^+$ æ˜¯å¸¦å®½å‡½æ•°

**å®šä¹‰ 9.1.04.2 (ç¼“å­˜)**
ç¼“å­˜ $C$ æ˜¯ä¸€ä¸ªå››å…ƒç»„ï¼š
$$C = (\text{size}, \text{associativity}, \text{line\_size}, \text{policy})$$
å…¶ä¸­ï¼š

- $\text{size}$ æ˜¯ç¼“å­˜æ€»å®¹é‡
- $\text{associativity}$ æ˜¯ç»„ç›¸è”åº¦
- $\text{line\_size}$ æ˜¯ç¼“å­˜è¡Œå¤§å°
- $\text{policy}$ æ˜¯æ›¿æ¢ç­–ç•¥

**å®šä¹‰ 9.1.04.3 (å±€éƒ¨æ€§)**
ç¨‹åºè®¿é—®æ¨¡å¼å…·æœ‰å±€éƒ¨æ€§ï¼Œå®šä¹‰ä¸ºï¼š

- æ—¶é—´å±€éƒ¨æ€§ï¼š$\text{Pr}[A(t) = A(t+\Delta t)] > \text{Pr}[A(t) = A(t+\Delta t')]$ å¯¹äº $\Delta t < \Delta t'$
- ç©ºé—´å±€éƒ¨æ€§ï¼š$\text{Pr}[A(t) = a] > \text{Pr}[A(t) = b]$ å¯¹äº $|a - A(t-1)| < |b - A(t-1)|$

### 1.2 æ€§èƒ½æ¨¡å‹

**å®šä¹‰ 9.1.04.4 (å¹³å‡è®¿é—®æ—¶é—´)**
å¹³å‡è®¿é—®æ—¶é—´ï¼š
$$T_{\text{avg}} = T_h + (1 - h) \times T_m$$
å…¶ä¸­ $h$ æ˜¯å‘½ä¸­ç‡ï¼Œ$T_h$ æ˜¯å‘½ä¸­æ—¶é—´ï¼Œ$T_m$ æ˜¯æœªå‘½ä¸­æ—¶é—´ã€‚

**å®šä¹‰ 9.1.04.5 (å†…å­˜å¸¦å®½)**
å†…å­˜å¸¦å®½ï¼š
$$B = \frac{\text{data\_size}}{\text{access\_time}}$$

## 2 æ ¸å¿ƒå®šç†

### 2.1 ç¼“å­˜æ€§èƒ½å®šç†

**å®šç† 9.1.04.1 (ç¼“å­˜å‘½ä¸­ç‡ä¸å®¹é‡)**
ç¼“å­˜å‘½ä¸­ç‡ $h$ ä¸å®¹é‡ $S$ çš„å…³ç³»ï¼š
$$h(S) = 1 - \frac{1}{1 + \alpha \times S}$$
å…¶ä¸­ $\alpha$ æ˜¯ç¨‹åºå±€éƒ¨æ€§å‚æ•°ã€‚

**è¯æ˜ï¼š**

1. åŸºäºç¨‹åºè®¿é—®æ¨¡å¼å»ºæ¨¡
2. ä½¿ç”¨æ¦‚ç‡è®ºåˆ†æ
3. å®¹é‡å¢åŠ å¯¼è‡´å‘½ä¸­ç‡æå‡

### 2.2 å†…å­˜å¢™å®šç†

**å®šç† 9.1.04.2 (å†…å­˜å¢™)**
å¤„ç†å™¨æ€§èƒ½ä¸å†…å­˜æ€§èƒ½å·®è·éšæ—¶é—´å¢é•¿ï¼š
$$\frac{\text{CPU\_performance}}{\text{Memory\_performance}} \propto t^2$$

**è¯æ˜ï¼š**

1. CPUæ€§èƒ½æŒ‰æŒ‡æ•°å¢é•¿
2. å†…å­˜æ€§èƒ½å¢é•¿ç¼“æ…¢
3. å·®è·ä¸æ–­æ‰©å¤§

## 3 ç®—æ³•å®ç°

### 3.1 å¤šçº§ç¼“å­˜å®ç°

```rust
use std::collections::HashMap;

// ç¼“å­˜è¡Œ
#[derive(Debug, Clone)]
struct CacheLine {
    tag: usize,
    data: Vec<u8>,
    valid: bool,
    dirty: bool,
    lru_counter: usize,
    access_count: usize,
}

// æ›¿æ¢ç­–ç•¥
#[derive(Debug, Clone)]
enum ReplacementPolicy {
    LRU,    // æœ€è¿‘æœ€å°‘ä½¿ç”¨
    FIFO,   // å…ˆè¿›å…ˆå‡º
    Random, // éšæœºæ›¿æ¢
    LFU,    // æœ€å°‘ä½¿ç”¨
}

// å†™ç­–ç•¥
#[derive(Debug, Clone)]
enum WritePolicy {
    WriteThrough,  // å†™ç›´è¾¾
    WriteBack,     // å†™å›
    WriteAllocate, // å†™åˆ†é…
    NoWriteAllocate, // ä¸å†™åˆ†é…
}

// ç¼“å­˜çº§åˆ«
#[derive(Debug)]
struct CacheLevel {
    lines: Vec<CacheLine>,
    line_size: usize,
    num_sets: usize,
    associativity: usize,
    replacement_policy: ReplacementPolicy,
    write_policy: WritePolicy,
    hits: usize,
    misses: usize,
    clock: usize,
    total_accesses: usize,
}

impl CacheLevel {
    fn new(
        line_size: usize,
        num_sets: usize,
        associativity: usize,
        replacement_policy: ReplacementPolicy,
        write_policy: WritePolicy,
    ) -> Self {
        let num_lines = num_sets * associativity;
        let mut lines = Vec::with_capacity(num_lines);

        for _ in 0..num_lines {
            lines.push(CacheLine {
                tag: 0,
                data: vec![0; line_size],
                valid: false,
                dirty: false,
                lru_counter: 0,
                access_count: 0,
            });
        }

        Self {
            lines,
            line_size,
            num_sets,
            associativity,
            replacement_policy,
            write_policy,
            hits: 0,
            misses: 0,
            clock: 0,
            total_accesses: 0,
        }
    }

    // è®¿é—®ç¼“å­˜
    fn access(&mut self, address: usize, is_write: bool) -> (bool, Option<Vec<u8>>) {
        let (set_index, tag) = self.address_to_index_tag(address);
        self.clock += 1;
        self.total_accesses += 1;

        if let Some(line_index) = self.find_line(set_index, tag) {
            // ç¼“å­˜å‘½ä¸­
            self.hits += 1;
            self.update_line_stats(line_index, is_write);

            let data = self.lines[line_index].data.clone();
            (true, Some(data))
        } else {
            // ç¼“å­˜æœªå‘½ä¸­
            self.misses += 1;
            let victim_index = self.select_victim(set_index);
            let evicted_data = self.evict_line(victim_index);

            // åŠ è½½æ–°æ•°æ®
            self.load_line(victim_index, tag, address, is_write);

            (false, evicted_data)
        }
    }

    fn address_to_index_tag(&self, address: usize) -> (usize, usize) {
        let set_index = (address / self.line_size) % self.num_sets;
        let tag = address / (self.line_size * self.num_sets);
        (set_index, tag)
    }

    fn find_line(&self, set_index: usize, tag: usize) -> Option<usize> {
        let start = set_index * self.associativity;
        let end = start + self.associativity;

        for i in start..end {
            if self.lines[i].valid && self.lines[i].tag == tag {
                return Some(i);
            }
        }
        None
    }

    fn select_victim(&self, set_index: usize) -> usize {
        let start = set_index * self.associativity;
        let end = start + self.associativity;

        match self.replacement_policy {
            ReplacementPolicy::LRU => {
                let mut victim = start;
                let mut oldest = self.lines[start].lru_counter;

                for i in start..end {
                    if !self.lines[i].valid {
                        return i;
                    }
                    if self.lines[i].lru_counter < oldest {
                        oldest = self.lines[i].lru_counter;
                        victim = i;
                    }
                }
                victim
            }
            ReplacementPolicy::FIFO => {
                let mut victim = start;
                let mut oldest = self.lines[start].lru_counter;

                for i in start..end {
                    if !self.lines[i].valid {
                        return i;
                    }
                    if self.lines[i].lru_counter < oldest {
                        oldest = self.lines[i].lru_counter;
                        victim = i;
                    }
                }
                victim
            }
            ReplacementPolicy::Random => {
                use std::collections::hash_map::DefaultHasher;
                use std::hash::{Hash, Hasher};

                let mut hasher = DefaultHasher::new();
                self.clock.hash(&mut hasher);
                set_index.hash(&mut hasher);

                let hash = hasher.finish() as usize;
                start + (hash % self.associativity)
            }
            ReplacementPolicy::LFU => {
                let mut victim = start;
                let mut min_count = self.lines[start].access_count;

                for i in start..end {
                    if !self.lines[i].valid {
                        return i;
                    }
                    if self.lines[i].access_count < min_count {
                        min_count = self.lines[i].access_count;
                        victim = i;
                    }
                }
                victim
            }
        }
    }

    fn update_line_stats(&mut self, line_index: usize, is_write: bool) {
        self.lines[line_index].lru_counter = self.clock;
        self.lines[line_index].access_count += 1;

        if is_write {
            match self.write_policy {
                WritePolicy::WriteThrough => {
                    // å†™ç›´è¾¾ï¼šç«‹å³å†™å›ä¸‹ä¸€çº§
                    self.lines[line_index].dirty = false;
                }
                WritePolicy::WriteBack => {
                    // å†™å›ï¼šæ ‡è®°ä¸ºè„
                    self.lines[line_index].dirty = true;
                }
                _ => {}
            }
        }
    }

    fn evict_line(&mut self, line_index: usize) -> Option<Vec<u8>> {
        if self.lines[line_index].valid && self.lines[line_index].dirty {
            Some(self.lines[line_index].data.clone())
        } else {
            None
        }
    }

    fn load_line(&mut self, line_index: usize, tag: usize, address: usize, is_write: bool) {
        self.lines[line_index].tag = tag;
        self.lines[line_index].valid = true;
        self.lines[line_index].lru_counter = self.clock;
        self.lines[line_index].access_count = 1;

        // æ ¹æ®å†™ç­–ç•¥å†³å®šæ˜¯å¦æ ‡è®°ä¸ºè„
        match self.write_policy {
            WritePolicy::WriteAllocate => {
                self.lines[line_index].dirty = is_write;
            }
            WritePolicy::NoWriteAllocate => {
                self.lines[line_index].dirty = false;
            }
            _ => {
                self.lines[line_index].dirty = false;
            }
        }

        // è¿™é‡Œåº”è¯¥ä»ä¸‹ä¸€çº§åŠ è½½æ•°æ®ï¼Œç®€åŒ–å®ç°ä¸­çœç•¥
    }

    fn get_hit_rate(&self) -> f64 {
        if self.total_accesses > 0 {
            self.hits as f64 / self.total_accesses as f64
        } else {
            0.0
        }
    }

    fn get_miss_rate(&self) -> f64 {
        if self.total_accesses > 0 {
            self.misses as f64 / self.total_accesses as f64
        } else {
            0.0
        }
    }
}

// å†…å­˜å±‚æ¬¡
#[derive(Debug)]
struct MemoryHierarchy {
    levels: Vec<CacheLevel>,
    main_memory: HashMap<usize, u8>,
    memory_accesses: usize,
    total_latency: usize,
}

impl MemoryHierarchy {
    fn new() -> Self {
        let mut levels = Vec::new();

        // L1æ•°æ®ç¼“å­˜ï¼š32KBï¼Œ8è·¯ç»„ç›¸è”ï¼Œ64å­—èŠ‚è¡Œï¼Œå†™å›ç­–ç•¥
        levels.push(CacheLevel::new(
            64,
            64,
            8,
            ReplacementPolicy::LRU,
            WritePolicy::WriteBack,
        ));

        // L2ç¼“å­˜ï¼š256KBï¼Œ8è·¯ç»„ç›¸è”ï¼Œ64å­—èŠ‚è¡Œï¼Œå†™å›ç­–ç•¥
        levels.push(CacheLevel::new(
            64,
            512,
            8,
            ReplacementPolicy::LRU,
            WritePolicy::WriteBack,
        ));

        // L3ç¼“å­˜ï¼š8MBï¼Œ16è·¯ç»„ç›¸è”ï¼Œ64å­—èŠ‚è¡Œï¼Œå†™å›ç­–ç•¥
        levels.push(CacheLevel::new(
            64,
            8192,
            16,
            ReplacementPolicy::LRU,
            WritePolicy::WriteBack,
        ));

        Self {
            levels,
            main_memory: HashMap::new(),
            memory_accesses: 0,
            total_latency: 0,
        }
    }

    // è®¿é—®å†…å­˜å±‚æ¬¡
    fn access(&mut self, address: usize, is_write: bool) -> (usize, Vec<u8>) {
        let mut current_latency = 0;
        let mut data = Vec::new();

        // å°è¯•åœ¨å„çº§ç¼“å­˜ä¸­æŸ¥æ‰¾
        for (level, cache) in self.levels.iter_mut().enumerate() {
            current_latency += self.get_level_latency(level);

            let (hit, cache_data) = cache.access(address, is_write);
            if hit {
                if let Some(cached_data) = cache_data {
                    data = cached_data;
                }
                self.total_latency += current_latency;
                return (level, data);
            }
        }

        // æ‰€æœ‰ç¼“å­˜éƒ½æœªå‘½ä¸­ï¼Œè®¿é—®ä¸»å†…å­˜
        current_latency += 100; // ä¸»å†…å­˜å»¶è¿Ÿ
        self.memory_accesses += 1;
        self.total_latency += current_latency;

        // ä»ä¸»å†…å­˜è¯»å–æ•°æ®ï¼ˆç®€åŒ–å®ç°ï¼‰
        data = vec![0; 64]; // å‡è®¾ç¼“å­˜è¡Œå¤§å°ä¸º64å­—èŠ‚

        (self.levels.len(), data)
    }

    fn get_level_latency(&self, level: usize) -> usize {
        match level {
            0 => 1,   // L1ç¼“å­˜ï¼š1ä¸ªå‘¨æœŸ
            1 => 10,  // L2ç¼“å­˜ï¼š10ä¸ªå‘¨æœŸ
            2 => 50,  // L3ç¼“å­˜ï¼š50ä¸ªå‘¨æœŸ
            _ => 100, // ä¸»å†…å­˜ï¼š100ä¸ªå‘¨æœŸ
        }
    }

    // è·å–æ•´ä½“å‘½ä¸­ç‡
    fn get_overall_hit_rate(&self) -> f64 {
        let mut total_hits = 0;
        let mut total_accesses = 0;

        for cache in &self.levels {
            total_hits += cache.hits;
            total_accesses += cache.total_accesses;
        }

        if total_accesses > 0 {
            total_hits as f64 / total_accesses as f64
        } else {
            0.0
        }
    }

    // è·å–å¹³å‡è®¿é—®å»¶è¿Ÿ
    fn get_average_latency(&self) -> f64 {
        let total_accesses = self.memory_accesses;
        for cache in &self.levels {
            total_accesses += cache.total_accesses;
        }

        if total_accesses > 0 {
            self.total_latency as f64 / total_accesses as f64
        } else {
            0.0
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_memory_hierarchy() {
        let mut hierarchy = MemoryHierarchy::new();

        // æµ‹è¯•å±€éƒ¨æ€§è®¿é—®
        for i in 0..1000 {
            hierarchy.access(i * 64, false); // è¯»å–
        }

        // é‡å¤è®¿é—®ç›¸åŒåœ°å€
        for _ in 0..100 {
            hierarchy.access(0, false);
        }

        let hit_rate = hierarchy.get_overall_hit_rate();
        let avg_latency = hierarchy.get_average_latency();

        assert!(hit_rate > 0.0);
        assert!(avg_latency > 0.0);
    }
}
```

### 3.2 é¢„å–å™¨å®ç°

```rust
use std::collections::HashMap;

// é¢„å–ç­–ç•¥
#[derive(Debug, Clone)]
enum PrefetchPolicy {
    None,
    Sequential,      // é¡ºåºé¢„å–
    Stride,          // æ­¥é•¿é¢„å–
    Pattern,         // æ¨¡å¼é¢„å–
}

// é¢„å–å™¨
#[derive(Debug)]
struct Prefetcher {
    policy: PrefetchPolicy,
    stride_table: HashMap<usize, (usize, usize)>, // PC -> (stride, confidence)
    pattern_table: HashMap<usize, Vec<usize>>,    // PC -> è®¿é—®æ¨¡å¼
    prefetch_queue: Vec<usize>,                   // é¢„å–é˜Ÿåˆ—
    prefetch_hits: usize,
    prefetch_misses: usize,
}

impl Prefetcher {
    fn new(policy: PrefetchPolicy) -> Self {
        Self {
            policy,
            stride_table: HashMap::new(),
            pattern_table: HashMap::new(),
            prefetch_queue: Vec::new(),
            prefetch_hits: 0,
            prefetch_misses: 0,
        }
    }

    // å¤„ç†è®¿é—®è¯·æ±‚
    fn process_access(&mut self, pc: usize, address: usize) -> Vec<usize> {
        let mut prefetch_addresses = Vec::new();

        match self.policy {
            PrefetchPolicy::None => {}
            PrefetchPolicy::Sequential => {
                // é¡ºåºé¢„å–ï¼šé¢„å–ä¸‹ä¸€ä¸ªç¼“å­˜è¡Œ
                let next_address = (address / 64 + 1) * 64;
                prefetch_addresses.push(next_address);
            }
            PrefetchPolicy::Stride => {
                // æ­¥é•¿é¢„å–
                if let Some((stride, confidence)) = self.stride_table.get_mut(&pc) {
                    if *confidence > 2 {
                        let next_address = address + *stride;
                        prefetch_addresses.push(next_address);
                    }
                }

                // æ›´æ–°æ­¥é•¿è¡¨
                self.update_stride_table(pc, address);
            }
            PrefetchPolicy::Pattern => {
                // æ¨¡å¼é¢„å–
                if let Some(pattern) = self.pattern_table.get_mut(&pc) {
                    if pattern.len() >= 2 {
                        // åŸºäºå†å²æ¨¡å¼é¢„æµ‹ä¸‹ä¸€ä¸ªåœ°å€
                        let last_diff = pattern[pattern.len() - 1] - pattern[pattern.len() - 2];
                        let next_address = address + last_diff;
                        prefetch_addresses.push(next_address);
                    }
                }

                // æ›´æ–°æ¨¡å¼è¡¨
                self.update_pattern_table(pc, address);
            }
        }

        // å°†é¢„å–åœ°å€åŠ å…¥é˜Ÿåˆ—
        self.prefetch_queue.extend(prefetch_addresses.clone());

        prefetch_addresses
    }

    fn update_stride_table(&mut self, pc: usize, address: usize) {
        if let Some((stride, confidence)) = self.stride_table.get_mut(&pc) {
            let new_stride = address - *stride;
            if new_stride == *stride {
                *confidence += 1;
            } else {
                *confidence = 0;
                *stride = new_stride;
            }
        } else {
            self.stride_table.insert(pc, (0, 0));
        }
    }

    fn update_pattern_table(&mut self, pc: usize, address: usize) {
        let pattern = self.pattern_table.entry(pc).or_insert_with(Vec::new);
        pattern.push(address);

        // ä¿æŒæ¨¡å¼å†å²åœ¨åˆç†èŒƒå›´å†…
        if pattern.len() > 10 {
            pattern.remove(0);
        }
    }

    // æ£€æŸ¥é¢„å–å‘½ä¸­
    fn check_prefetch_hit(&mut self, address: usize) -> bool {
        if let Some(index) = self.prefetch_queue.iter().position(|&x| x == address) {
            self.prefetch_queue.remove(index);
            self.prefetch_hits += 1;
            true
        } else {
            self.prefetch_misses += 1;
            false
        }
    }

    // è·å–é¢„å–å‡†ç¡®ç‡
    fn get_prefetch_accuracy(&self) -> f64 {
        let total_prefetches = self.prefetch_hits + self.prefetch_misses;
        if total_prefetches > 0 {
            self.prefetch_hits as f64 / total_prefetches as f64
        } else {
            0.0
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_prefetcher() {
        let mut prefetcher = Prefetcher::new(PrefetchPolicy::Stride);

        // æµ‹è¯•æ­¥é•¿è®¿é—®æ¨¡å¼
        for i in 0..100 {
            let address = i * 64;
            let pc = 0x1000;
            prefetcher.process_access(pc, address);
        }

        let accuracy = prefetcher.get_prefetch_accuracy();
        assert!(accuracy >= 0.0);
    }
}
```

### 3.3 å†…å­˜æ§åˆ¶å™¨å®ç°

```rust
use std::collections::VecDeque;

// å†…å­˜è¯·æ±‚ç±»å‹
#[derive(Debug, Clone)]
enum MemoryRequest {
    Read { address: usize, size: usize },
    Write { address: usize, data: Vec<u8> },
}

// å†…å­˜æ§åˆ¶å™¨
#[derive(Debug)]
struct MemoryController {
    request_queue: VecDeque<MemoryRequest>,
    current_request: Option<MemoryRequest>,
    busy_cycles: usize,
    total_cycles: usize,
    total_requests: usize,
    memory_banks: usize,
    bank_busy: Vec<usize>,
}

impl MemoryController {
    fn new(memory_banks: usize) -> Self {
        Self {
            request_queue: VecDeque::new(),
            current_request: None,
            busy_cycles: 0,
            total_cycles: 0,
            total_requests: 0,
            memory_banks,
            bank_busy: vec![0; memory_banks],
        }
    }

    // æäº¤å†…å­˜è¯·æ±‚
    fn submit_request(&mut self, request: MemoryRequest) {
        self.request_queue.push_back(request);
        self.total_requests += 1;
    }

    // æ‰§è¡Œä¸€ä¸ªå‘¨æœŸ
    fn cycle(&mut self) -> Option<MemoryRequest> {
        self.total_cycles += 1;

        // æ›´æ–°é“¶è¡Œå¿™çŠ¶æ€
        for bank in &mut self.bank_busy {
            if *bank > 0 {
                *bank -= 1;
            }
        }

        // å¤„ç†å½“å‰è¯·æ±‚
        if let Some(ref request) = self.current_request {
            self.busy_cycles += 1;

            // æ£€æŸ¥è¯·æ±‚æ˜¯å¦å®Œæˆ
            if self.is_request_complete(request) {
                let completed_request = self.current_request.take();
                return completed_request;
            }
        }

        // å¼€å§‹å¤„ç†æ–°è¯·æ±‚
        if self.current_request.is_none() {
            if let Some(request) = self.select_next_request() {
                self.current_request = Some(request.clone());
                self.start_request(&request);
            }
        }

        None
    }

    fn is_request_complete(&self, request: &MemoryRequest) -> bool {
        // ç®€åŒ–çš„å®Œæˆæ¡ä»¶ï¼šå›ºå®šå»¶è¿Ÿ
        match request {
            MemoryRequest::Read { .. } => self.busy_cycles >= 10,
            MemoryRequest::Write { .. } => self.busy_cycles >= 5,
        }
    }

    fn select_next_request(&mut self) -> Option<MemoryRequest> {
        // ç®€å•çš„FIFOè°ƒåº¦
        self.request_queue.pop_front()
    }

    fn start_request(&mut self, request: &MemoryRequest) {
        self.busy_cycles = 0;

        // è®¡ç®—é“¶è¡Œå†²çª
        let bank = match request {
            MemoryRequest::Read { address, .. } |
            MemoryRequest::Write { address, .. } => {
                address / 64 % self.memory_banks
            }
        };

        if self.bank_busy[bank] > 0 {
            // é“¶è¡Œå†²çªï¼Œå¢åŠ å»¶è¿Ÿ
            self.busy_cycles += self.bank_busy[bank];
        }

        // è®¾ç½®é“¶è¡Œå¿™çŠ¶æ€
        self.bank_busy[bank] = match request {
            MemoryRequest::Read { .. } => 10,
            MemoryRequest::Write { .. } => 5,
        };
    }

    // è·å–å†…å­˜åˆ©ç”¨ç‡
    fn get_memory_utilization(&self) -> f64 {
        if self.total_cycles > 0 {
            self.busy_cycles as f64 / self.total_cycles as f64
        } else {
            0.0
        }
    }

    // è·å–å¹³å‡å»¶è¿Ÿ
    fn get_average_latency(&self) -> f64 {
        if self.total_requests > 0 {
            self.total_cycles as f64 / self.total_requests as f64
        } else {
            0.0
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_memory_controller() {
        let mut controller = MemoryController::new(4);

        // æäº¤ä¸€äº›å†…å­˜è¯·æ±‚
        for i in 0..10 {
            let request = MemoryRequest::Read {
                address: i * 64,
                size: 64,
            };
            controller.submit_request(request);
        }

        // æ‰§è¡Œå‡ ä¸ªå‘¨æœŸ
        for _ in 0..50 {
            controller.cycle();
        }

        let utilization = controller.get_memory_utilization();
        let avg_latency = controller.get_average_latency();

        assert!(utilization >= 0.0 && utilization <= 1.0);
        assert!(avg_latency > 0.0);
    }
}
```

## 4 åº”ç”¨åœºæ™¯

### 4.1 å¤„ç†å™¨è®¾è®¡

- ç¼“å­˜å±‚æ¬¡è®¾è®¡
- å†…å­˜æ§åˆ¶å™¨è®¾è®¡
- é¢„å–å™¨è®¾è®¡

### 4.2 æ€§èƒ½ä¼˜åŒ–

- ç¼“å­˜ä¼˜åŒ–
- å†…å­˜å¸¦å®½ä¼˜åŒ–
- å»¶è¿Ÿä¼˜åŒ–

### 4.3 ç³»ç»Ÿè®¾è®¡

- å†…å­˜å­ç³»ç»Ÿè®¾è®¡
- å­˜å‚¨å±‚æ¬¡è®¾è®¡
- I/Oç³»ç»Ÿè®¾è®¡

## 5 ç›¸å…³ç†è®º

### 5.1 è®¡ç®—æœºç»„ç»‡

- å­˜å‚¨ç³»ç»Ÿè®¾è®¡
- å†…å­˜ç®¡ç†
- ç¼“å­˜è®¾è®¡

### 5.2 æ€§èƒ½åˆ†æ

- å†…å­˜æ€§èƒ½å»ºæ¨¡
- ç“¶é¢ˆåˆ†æ
- å¯æ‰©å±•æ€§åˆ†æ

### 5.3 å¹¶è¡Œè®¡ç®—

- å†…å­˜ä¸€è‡´æ€§
- ç¼“å­˜ä¸€è‡´æ€§
- åˆ†å¸ƒå¼å­˜å‚¨

## 6. å‚è€ƒæ–‡çŒ®

1. Hennessy, J. L., & Patterson, D. A. (2017). Computer Architecture: A Quantitative Approach.
2. Smith, A. J. (1982). Cache memories.
3. Jouppi, N. P. (1990). Improving direct-mapped cache performance by the addition of a small fully-associative cache and prefetch buffers.
4. Baer, J. L., & Chen, W. H. (1991). An effective on-chip preloading scheme for data caches.
5. Chen, T. F., & Baer, J. L. (1994). A performance study of software and hardware data prefetching schemes.

## 6 æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
