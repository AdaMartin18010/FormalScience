# 09.5 ä½“ç³»ç»“æ„åŸºç¡€ç†è®ºï¼ˆFundamental Theory of Computer Architectureï¼‰

[è¿”å›è®¡ç®—æœºä½“ç³»ç»“æ„ç†è®ºä¸»é¢˜ç´¢å¼•](README.md)

> æœ¬æ–‡æ¡£ç³»ç»Ÿæ•´ç†è®¡ç®—æœºä½“ç³»ç»“æ„çš„åŸºç¡€ç†è®ºï¼ŒåŒ…æ‹¬å†¯Â·è¯ºä¾æ›¼ç»“æ„ã€å­˜å‚¨å±‚æ¬¡ã€æŒ‡ä»¤ç³»ç»Ÿã€ä½“ç³»ç»“æ„æŠ½è±¡ç­‰ï¼Œä¸¥æ ¼æ ‘å½¢ç¼–å·ã€ç›®å½•ã€æœ¬åœ°è·³è½¬é”šç‚¹ä¸äº¤å‰å¼•ç”¨ï¼Œå†…å®¹æŒç»­è§„èŒƒåŒ–ä¸­ã€‚

---

## ğŸ“‹ ç›®å½•

- [09.5 ä½“ç³»ç»“æ„åŸºç¡€ç†è®ºï¼ˆFundamental Theory of Computer Architectureï¼‰](#095-ä½“ç³»ç»“æ„åŸºç¡€ç†è®ºfundamental-theory-of-computer-architecture)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 è®¡ç®—æœºä½“ç³»ç»“æ„åŸºç¡€ç†è®º](#1-è®¡ç®—æœºä½“ç³»ç»“æ„åŸºç¡€ç†è®º)
  - [2 å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
    - [2.1 ä½“ç³»ç»“æ„åŸºç¡€](#21-ä½“ç³»ç»“æ„åŸºç¡€)
    - [2.2 æ€§èƒ½æ¨¡å‹](#22-æ€§èƒ½æ¨¡å‹)
  - [3 æ ¸å¿ƒå®šç†](#3-æ ¸å¿ƒå®šç†)
    - [3.1 å­˜å‚¨å±‚æ¬¡å®šç†](#31-å­˜å‚¨å±‚æ¬¡å®šç†)
    - [3.2 æµæ°´çº¿æ€§èƒ½å®šç†](#32-æµæ°´çº¿æ€§èƒ½å®šç†)
  - [4 ç®—æ³•å®ç°](#4-ç®—æ³•å®ç°)
    - [4.1 ç®€å•CPUæ¨¡æ‹Ÿå™¨](#41-ç®€å•cpuæ¨¡æ‹Ÿå™¨)
    - [4.2 ç¼“å­˜æ¨¡æ‹Ÿå™¨](#42-ç¼“å­˜æ¨¡æ‹Ÿå™¨)
    - [4.3 æµæ°´çº¿æ¨¡æ‹Ÿå™¨](#43-æµæ°´çº¿æ¨¡æ‹Ÿå™¨)
  - [5 åº”ç”¨åœºæ™¯](#5-åº”ç”¨åœºæ™¯)
    - [5.1 å¤„ç†å™¨è®¾è®¡](#51-å¤„ç†å™¨è®¾è®¡)
    - [5.2 æ€§èƒ½ä¼˜åŒ–](#52-æ€§èƒ½ä¼˜åŒ–)
    - [5.3 ç³»ç»Ÿè®¾è®¡](#53-ç³»ç»Ÿè®¾è®¡)
  - [6 ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
    - [6.1 è®¡ç®—æœºç»„ç»‡](#61-è®¡ç®—æœºç»„ç»‡)
    - [6.2 æ€§èƒ½åˆ†æ](#62-æ€§èƒ½åˆ†æ)
    - [6.3 å¹¶è¡Œè®¡ç®—](#63-å¹¶è¡Œè®¡ç®—)
  - [6. å‚è€ƒæ–‡çŒ®](#6-å‚è€ƒæ–‡çŒ®)
  - [7 æ‰¹åˆ¤æ€§åˆ†æ](#7-æ‰¹åˆ¤æ€§åˆ†æ)

---

## 1 è®¡ç®—æœºä½“ç³»ç»“æ„åŸºç¡€ç†è®º

## 2 å½¢å¼åŒ–å®šä¹‰

### 2.1 ä½“ç³»ç»“æ„åŸºç¡€

**å®šä¹‰ 9.1.01.1 (è®¡ç®—æœºä½“ç³»ç»“æ„)**
è®¡ç®—æœºä½“ç³»ç»“æ„æ˜¯ç¡¬ä»¶ä¸è½¯ä»¶ä¹‹é—´çš„æ¥å£è§„èŒƒï¼Œå®šä¹‰ä¸ºä¸‰å…ƒç»„ï¼š
$$\mathcal{A} = (\mathcal{I}, \mathcal{S}, \mathcal{M})$$
å…¶ä¸­ï¼š

- $\mathcal{I}$ æ˜¯æŒ‡ä»¤é›†æ¶æ„
- $\mathcal{S}$ æ˜¯å­˜å‚¨å±‚æ¬¡ç»“æ„
- $\mathcal{M}$ æ˜¯å†…å­˜æ¨¡å‹

**å®šä¹‰ 9.1.01.2 (æŒ‡ä»¤é›†æ¶æ„)**
æŒ‡ä»¤é›†æ¶æ„ $\mathcal{I}$ åŒ…å«ï¼š

- æŒ‡ä»¤æ ¼å¼ï¼š$\text{Format}: \text{Instruction} \rightarrow \text{Opcode} \times \text{Operands}$
- å¯»å€æ¨¡å¼ï¼š$\text{Addressing}: \text{Mode} \rightarrow \text{Address}$
- å¯„å­˜å™¨é›†ï¼š$\mathcal{R} = \{R_0, R_1, \ldots, R_{n-1}\}$

**å®šä¹‰ 9.1.01.3 (å­˜å‚¨å±‚æ¬¡)**
å­˜å‚¨å±‚æ¬¡ $\mathcal{S}$ æ˜¯ä¸€ä¸ªååºé›† $(L, \prec)$ï¼Œå…¶ä¸­ï¼š

- $L$ æ˜¯å­˜å‚¨çº§åˆ«é›†åˆ
- $\prec$ è¡¨ç¤ºè®¿é—®å»¶è¿Ÿå…³ç³»ï¼š$L_i \prec L_j$ è¡¨ç¤º $L_i$ æ¯” $L_j$ æ›´å¿«

### 2.2 æ€§èƒ½æ¨¡å‹

**å®šä¹‰ 9.1.01.4 (æ€§èƒ½åº¦é‡)**
è®¡ç®—æœºæ€§èƒ½ $P$ å®šä¹‰ä¸ºï¼š
$$P = \frac{1}{\text{CPI} \times T_c}$$
å…¶ä¸­ï¼š

- $\text{CPI}$ æ˜¯æ¯æ¡æŒ‡ä»¤çš„å¹³å‡å‘¨æœŸæ•°
- $T_c$ æ˜¯æ—¶é’Ÿå‘¨æœŸæ—¶é—´

**å®šä¹‰ 9.1.01.5 (Amdahlå®šå¾‹)**
åŠ é€Ÿæ¯” $S$ ä¸ºï¼š
$$S = \frac{1}{(1-f) + \frac{f}{n}}$$
å…¶ä¸­ $f$ æ˜¯å¯å¹¶è¡ŒåŒ–éƒ¨åˆ†æ¯”ä¾‹ï¼Œ$n$ æ˜¯å¤„ç†å™¨æ•°é‡ã€‚

## 3 æ ¸å¿ƒå®šç†

### 3.1 å­˜å‚¨å±‚æ¬¡å®šç†

**å®šç† 9.1.01.1 (å­˜å‚¨å±‚æ¬¡å±€éƒ¨æ€§)**
ç¨‹åºè®¿é—®å…·æœ‰æ—¶é—´å’Œç©ºé—´å±€éƒ¨æ€§ï¼š

- æ—¶é—´å±€éƒ¨æ€§ï¼šæœ€è¿‘è®¿é—®çš„æ•°æ®å¾ˆå¯èƒ½å†æ¬¡è¢«è®¿é—®
- ç©ºé—´å±€éƒ¨æ€§ï¼šç›¸é‚»åœ°å€çš„æ•°æ®å¾ˆå¯èƒ½è¢«è¿ç»­è®¿é—®

**è¯æ˜ï¼š**

1. å¾ªç¯ç»“æ„å¯¼è‡´æ—¶é—´å±€éƒ¨æ€§
2. æ•°ç»„è®¿é—®å¯¼è‡´ç©ºé—´å±€éƒ¨æ€§
3. ç¨‹åºç»“æ„åˆ†ææ”¯æŒå±€éƒ¨æ€§å‡è®¾

### 3.2 æµæ°´çº¿æ€§èƒ½å®šç†

**å®šç† 9.1.01.2 (æµæ°´çº¿åŠ é€Ÿæ¯”)**
ç†æƒ³æµæ°´çº¿çš„åŠ é€Ÿæ¯”ä¸ºï¼š
$$S = \frac{n \times T_s}{T_s + (n-1) \times T_p}$$
å…¶ä¸­ $n$ æ˜¯æµæ°´çº¿çº§æ•°ï¼Œ$T_s$ æ˜¯ä¸²è¡Œæ‰§è¡Œæ—¶é—´ï¼Œ$T_p$ æ˜¯æµæ°´çº¿å‘¨æœŸã€‚

**è¯æ˜ï¼š**

1. ä¸²è¡Œæ‰§è¡Œæ—¶é—´ï¼š$T_s = n \times T_p$
2. æµæ°´çº¿æ‰§è¡Œæ—¶é—´ï¼š$T_p + (n-1) \times T_p$
3. åŠ é€Ÿæ¯”è®¡ç®—

## 4 ç®—æ³•å®ç°

### 4.1 ç®€å•CPUæ¨¡æ‹Ÿå™¨

```rust
use std::collections::HashMap;

// æŒ‡ä»¤ç±»å‹
#[derive(Debug, Clone)]
enum Instruction {
    Add(usize, usize, usize),    // add rd, rs1, rs2
    Sub(usize, usize, usize),    // sub rd, rs1, rs2
    Load(usize, usize),          // load rd, offset(rs)
    Store(usize, usize),         // store rs, offset(rd)
    Branch(usize, usize, i32),   // beq rs1, rs2, offset
    Jump(i32),                   // j offset
}

// CPUçŠ¶æ€
#[derive(Debug)]
struct CPU {
    registers: [i32; 32],
    memory: HashMap<usize, i32>,
    pc: usize,
    clock_cycles: usize,
}

impl CPU {
    fn new() -> Self {
        Self {
            registers: [0; 32],
            memory: HashMap::new(),
            pc: 0,
            clock_cycles: 0,
        }
    }

    // æ‰§è¡ŒæŒ‡ä»¤
    fn execute(&mut self, instruction: &Instruction) -> Result<(), String> {
        match instruction {
            Instruction::Add(rd, rs1, rs2) => {
                self.registers[*rd] = self.registers[*rs1] + self.registers[*rs2];
                self.pc += 4;
            }
            Instruction::Sub(rd, rs1, rs2) => {
                self.registers[*rd] = self.registers[*rs1] - self.registers[*rs2];
                self.pc += 4;
            }
            Instruction::Load(rd, rs) => {
                let address = self.registers[*rs] as usize;
                let value = self.memory.get(&address).copied().unwrap_or(0);
                self.registers[*rd] = value;
                self.pc += 4;
            }
            Instruction::Store(rs, rd) => {
                let address = self.registers[*rd] as usize;
                self.memory.insert(address, self.registers[*rs]);
                self.pc += 4;
            }
            Instruction::Branch(rs1, rs2, offset) => {
                if self.registers[*rs1] == self.registers[*rs2] {
                    self.pc = (self.pc as i32 + offset) as usize;
                } else {
                    self.pc += 4;
                }
            }
            Instruction::Jump(offset) => {
                self.pc = (self.pc as i32 + offset) as usize;
            }
        }
        self.clock_cycles += 1;
        Ok(())
    }

    // è¿è¡Œç¨‹åº
    fn run(&mut self, program: &[Instruction]) -> Result<(), String> {
        while self.pc < program.len() * 4 {
            let instruction_index = self.pc / 4;
            if instruction_index < program.len() {
                self.execute(&program[instruction_index])?;
            } else {
                break;
            }
        }
        Ok(())
    }

    // è·å–æ€§èƒ½ç»Ÿè®¡
    fn get_performance_stats(&self) -> (usize, f64) {
        let total_instructions = self.pc / 4;
        let cpi = if total_instructions > 0 {
            self.clock_cycles as f64 / total_instructions as f64
        } else {
            0.0
        };
        (total_instructions, cpi)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cpu_execution() {
        let mut cpu = CPU::new();

        // ç®€å•ç¨‹åºï¼šè®¡ç®— 5 + 3
        let program = vec![
            Instruction::Add(1, 0, 0),  // r1 = r0 + r0 (0)
            Instruction::Add(1, 1, 1),  // r1 = r1 + r1 (0)
            Instruction::Add(1, 1, 1),  // r1 = r1 + r1 (0)
            Instruction::Add(1, 1, 1),  // r1 = r1 + r1 (0)
            Instruction::Add(1, 1, 1),  // r1 = r1 + r1 (0) = 0
        ];

        cpu.run(&program).unwrap();
        assert_eq!(cpu.registers[1], 0);
    }
}
```

### 4.2 ç¼“å­˜æ¨¡æ‹Ÿå™¨

```rust
use std::collections::HashMap;

// ç¼“å­˜è¡Œ
#[derive(Debug, Clone)]
struct CacheLine {
    tag: usize,
    data: Vec<u8>,
    valid: bool,
    dirty: bool,
    lru_counter: usize,
}

// ç¼“å­˜
#[derive(Debug)]
struct Cache {
    lines: Vec<CacheLine>,
    line_size: usize,
    num_sets: usize,
    associativity: usize,
    hits: usize,
    misses: usize,
    clock: usize,
}

impl Cache {
    fn new(line_size: usize, num_sets: usize, associativity: usize) -> Self {
        let num_lines = num_sets * associativity;
        let mut lines = Vec::with_capacity(num_lines);

        for _ in 0..num_lines {
            lines.push(CacheLine {
                tag: 0,
                data: vec![0; line_size],
                valid: false,
                dirty: false,
                lru_counter: 0,
            });
        }

        Self {
            lines,
            line_size,
            num_sets,
            associativity,
            hits: 0,
            misses: 0,
            clock: 0,
        }
    }

    // è®¡ç®—åœ°å€çš„ç´¢å¼•å’Œæ ‡ç­¾
    fn address_to_index_tag(&self, address: usize) -> (usize, usize) {
        let line_offset = address % self.line_size;
        let set_index = (address / self.line_size) % self.num_sets;
        let tag = address / (self.line_size * self.num_sets);
        (set_index, tag)
    }

    // æŸ¥æ‰¾ç¼“å­˜è¡Œ
    fn find_line(&self, set_index: usize, tag: usize) -> Option<usize> {
        let start = set_index * self.associativity;
        let end = start + self.associativity;

        for i in start..end {
            if self.lines[i].valid && self.lines[i].tag == tag {
                return Some(i);
            }
        }
        None
    }

    // é€‰æ‹©æ›¿æ¢è¡Œï¼ˆLRUç­–ç•¥ï¼‰
    fn select_victim(&self, set_index: usize) -> usize {
        let start = set_index * self.associativity;
        let end = start + self.associativity;

        let mut victim = start;
        let mut oldest = self.lines[start].lru_counter;

        for i in start..end {
            if !self.lines[i].valid {
                return i; // æ‰¾åˆ°æ— æ•ˆè¡Œ
            }
            if self.lines[i].lru_counter < oldest {
                oldest = self.lines[i].lru_counter;
                victim = i;
            }
        }
        victim
    }

    // è®¿é—®ç¼“å­˜
    fn access(&mut self, address: usize, is_write: bool) -> bool {
        let (set_index, tag) = self.address_to_index_tag(address);
        self.clock += 1;

        if let Some(line_index) = self.find_line(set_index, tag) {
            // ç¼“å­˜å‘½ä¸­
            self.hits += 1;
            self.lines[line_index].lru_counter = self.clock;
            if is_write {
                self.lines[line_index].dirty = true;
            }
            true
        } else {
            // ç¼“å­˜æœªå‘½ä¸­
            self.misses += 1;
            let victim_index = self.select_victim(set_index);

            // å¦‚æœè¢«æ›¿æ¢çš„è¡Œæ˜¯è„çš„ï¼Œéœ€è¦å†™å›
            if self.lines[victim_index].valid && self.lines[victim_index].dirty {
                // è¿™é‡Œåº”è¯¥å†™å›å†…å­˜ï¼Œç®€åŒ–å®ç°ä¸­çœç•¥
            }

            // åŠ è½½æ–°æ•°æ®
            self.lines[victim_index].tag = tag;
            self.lines[victim_index].valid = true;
            self.lines[victim_index].dirty = is_write;
            self.lines[victim_index].lru_counter = self.clock;

            false
        }
    }

    // è·å–å‘½ä¸­ç‡
    fn get_hit_rate(&self) -> f64 {
        let total_accesses = self.hits + self.misses;
        if total_accesses > 0 {
            self.hits as f64 / total_accesses as f64
        } else {
            0.0
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cache_access() {
        let mut cache = Cache::new(64, 4, 2); // 64å­—èŠ‚è¡Œï¼Œ4ç»„ï¼Œ2è·¯ç»„ç›¸è”

        // æµ‹è¯•å±€éƒ¨æ€§è®¿é—®
        for i in 0..100 {
            cache.access(i * 64, false); // è¯»å–
        }

        // é‡å¤è®¿é—®ç›¸åŒåœ°å€
        for _ in 0..10 {
            cache.access(0, false);
        }

        assert!(cache.get_hit_rate() > 0.0);
    }
}
```

### 4.3 æµæ°´çº¿æ¨¡æ‹Ÿå™¨

```rust
use std::collections::VecDeque;

// æµæ°´çº¿é˜¶æ®µ
#[derive(Debug, Clone)]
enum PipelineStage {
    Fetch,
    Decode,
    Execute,
    Memory,
    WriteBack,
}

// æµæ°´çº¿å¯„å­˜å™¨
#[derive(Debug, Clone)]
struct PipelineRegister {
    instruction: Option<Instruction>,
    stage: PipelineStage,
    valid: bool,
    stall: bool,
}

// æµæ°´çº¿CPU
#[derive(Debug)]
struct PipelineCPU {
    registers: [i32; 32],
    memory: HashMap<usize, i32>,
    pc: usize,
    pipeline: VecDeque<PipelineRegister>,
    clock_cycles: usize,
    instructions_executed: usize,
}

impl PipelineCPU {
    fn new() -> Self {
        let mut pipeline = VecDeque::new();
        for _ in 0..5 {
            pipeline.push_back(PipelineRegister {
                instruction: None,
                stage: PipelineStage::Fetch,
                valid: false,
                stall: false,
            });
        }

        Self {
            registers: [0; 32],
            memory: HashMap::new(),
            pc: 0,
            pipeline,
            clock_cycles: 0,
            instructions_executed: 0,
        }
    }

    // æµæ°´çº¿æ‰§è¡Œä¸€ä¸ªå‘¨æœŸ
    fn cycle(&mut self, program: &[Instruction]) {
        // å†™å›é˜¶æ®µ
        if let Some(reg) = self.pipeline.back_mut() {
            if reg.valid && !reg.stall {
                if let Some(instruction) = &reg.instruction {
                    self.write_back(instruction);
                    self.instructions_executed += 1;
                }
            }
        }

        // å†…å­˜é˜¶æ®µ
        if let Some(reg) = self.pipeline.get_mut(3) {
            if reg.valid && !reg.stall {
                if let Some(instruction) = &reg.instruction {
                    self.memory_access(instruction);
                }
            }
        }

        // æ‰§è¡Œé˜¶æ®µ
        if let Some(reg) = self.pipeline.get_mut(2) {
            if reg.valid && !reg.stall {
                if let Some(instruction) = &reg.instruction {
                    self.execute(instruction);
                }
            }
        }

        // è¯‘ç é˜¶æ®µ
        if let Some(reg) = self.pipeline.get_mut(1) {
            if reg.valid && !reg.stall {
                if let Some(instruction) = &reg.instruction {
                    self.decode(instruction);
                }
            }
        }

        // å–æŒ‡é˜¶æ®µ
        if let Some(reg) = self.pipeline.get_mut(0) {
            if !reg.stall {
                self.fetch(program, reg);
            }
        }

        self.clock_cycles += 1;
    }

    fn fetch(&mut self, program: &[Instruction], reg: &mut PipelineRegister) {
        let instruction_index = self.pc / 4;
        if instruction_index < program.len() {
            reg.instruction = Some(program[instruction_index].clone());
            reg.valid = true;
            reg.stage = PipelineStage::Fetch;
            self.pc += 4;
        } else {
            reg.valid = false;
        }
    }

    fn decode(&mut self, _instruction: &Instruction) {
        // ç®€åŒ–çš„è¯‘ç é˜¶æ®µ
    }

    fn execute(&mut self, instruction: &Instruction) {
        match instruction {
            Instruction::Add(rd, rs1, rs2) => {
                self.registers[*rd] = self.registers[*rs1] + self.registers[*rs2];
            }
            Instruction::Sub(rd, rs1, rs2) => {
                self.registers[*rd] = self.registers[*rs1] - self.registers[*rs2];
            }
            _ => {}
        }
    }

    fn memory_access(&mut self, instruction: &Instruction) {
        match instruction {
            Instruction::Load(rd, rs) => {
                let address = self.registers[*rs] as usize;
                let value = self.memory.get(&address).copied().unwrap_or(0);
                self.registers[*rd] = value;
            }
            Instruction::Store(rs, rd) => {
                let address = self.registers[*rd] as usize;
                self.memory.insert(address, self.registers[*rs]);
            }
            _ => {}
        }
    }

    fn write_back(&mut self, _instruction: &Instruction) {
        // å†™å›é˜¶æ®µé€šå¸¸ä¸éœ€è¦é¢å¤–æ“ä½œ
    }

    // è¿è¡Œç¨‹åº
    fn run(&mut self, program: &[Instruction]) -> Result<(), String> {
        let max_cycles = program.len() * 10; // è®¾ç½®æœ€å¤§å‘¨æœŸæ•°

        for _ in 0..max_cycles {
            self.cycle(program);

            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æŒ‡ä»¤éƒ½æ‰§è¡Œå®Œæˆ
            if self.instructions_executed >= program.len() {
                break;
            }
        }

        Ok(())
    }

    // è·å–æ€§èƒ½ç»Ÿè®¡
    fn get_performance_stats(&self) -> (usize, f64) {
        let cpi = if self.instructions_executed > 0 {
            self.clock_cycles as f64 / self.instructions_executed as f64
        } else {
            0.0
        };
        (self.instructions_executed, cpi)
    }
}
```

## 5 åº”ç”¨åœºæ™¯

### 5.1 å¤„ç†å™¨è®¾è®¡

- RISC vs CISCæ¶æ„
- æµæ°´çº¿è®¾è®¡
- è¶…æ ‡é‡å¤„ç†å™¨

### 5.2 æ€§èƒ½ä¼˜åŒ–

- ç¼“å­˜ä¼˜åŒ–
- åˆ†æ”¯é¢„æµ‹
- æŒ‡ä»¤çº§å¹¶è¡Œ

### 5.3 ç³»ç»Ÿè®¾è®¡

- å†…å­˜å±‚æ¬¡è®¾è®¡
- I/Oç³»ç»Ÿè®¾è®¡
- å¤šæ ¸æ¶æ„

## 6 ç›¸å…³ç†è®º

### 6.1 è®¡ç®—æœºç»„ç»‡

- æ•°å­—é€»è¾‘è®¾è®¡
- å¾®æ¶æ„è®¾è®¡
- ç³»ç»Ÿæ¶æ„

### 6.2 æ€§èƒ½åˆ†æ

- æ€§èƒ½å»ºæ¨¡
- ç“¶é¢ˆåˆ†æ
- å¯æ‰©å±•æ€§

### 6.3 å¹¶è¡Œè®¡ç®—

- å¤šæ ¸æ¶æ„
- åˆ†å¸ƒå¼ç³»ç»Ÿ
- å¹¶è¡Œç®—æ³•

## 6. å‚è€ƒæ–‡çŒ®

1. Hennessy, J. L., & Patterson, D. A. (2017). Computer Architecture: A Quantitative Approach.
2. Patterson, D. A., & Hennessy, J. L. (2017). Computer Organization and Design: The Hardware/Software Interface.
3. Amdahl, G. M. (1967). Validity of the single processor approach to achieving large scale computing capabilities.
4. Smith, A. J. (1982). Cache memories.
5. Hennessy, J. L., & Patterson, D. A. (1990). Computer Architecture: A Quantitative Approach.

## 7 æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
