# 09.6 æŒ‡ä»¤é›†æ¶æ„ç†è®ºï¼ˆInstruction Set Architecture Theoryï¼‰

[è¿”å›è®¡ç®—æœºä½“ç³»ç»“æ„ç†è®ºä¸»é¢˜ç´¢å¼•](README.md)

> æœ¬æ–‡æ¡£ç³»ç»Ÿæ•´ç†æŒ‡ä»¤é›†æ¶æ„ç†è®ºï¼ŒåŒ…æ‹¬ISAåˆ†ç±»ã€æŒ‡ä»¤æ ¼å¼ã€å¯»å€æ–¹å¼ã€æŒ‡ä»¤æµæ°´çº¿ç­‰ï¼Œä¸¥æ ¼æ ‘å½¢ç¼–å·ã€ç›®å½•ã€æœ¬åœ°è·³è½¬é”šç‚¹ä¸äº¤å‰å¼•ç”¨ï¼Œå†…å®¹æŒç»­è§„èŒƒåŒ–ä¸­ã€‚

---

## ğŸ“‹ ç›®å½•

- [1 æŒ‡ä»¤é›†æ¶æ„ç†è®º](#1-æŒ‡ä»¤é›†æ¶æ„ç†è®º)
- [2 å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
  - [2.1 æŒ‡ä»¤é›†åŸºç¡€](#21-æŒ‡ä»¤é›†åŸºç¡€)
  - [2.2 å¯»å€æ¨¡å¼](#22-å¯»å€æ¨¡å¼)
- [3 æ ¸å¿ƒå®šç†](#3-æ ¸å¿ƒå®šç†)
  - [3.1 æŒ‡ä»¤é›†å®Œå¤‡æ€§å®šç†](#31-æŒ‡ä»¤é›†å®Œå¤‡æ€§å®šç†)
  - [3.2 æŒ‡ä»¤ç¼–ç å®šç†](#32-æŒ‡ä»¤ç¼–ç å®šç†)
- [4 ç®—æ³•å®ç°](#4-ç®—æ³•å®ç°)
  - [4.1 RISC-VæŒ‡ä»¤é›†æ¨¡æ‹Ÿå™¨](#41-risc-væŒ‡ä»¤é›†æ¨¡æ‹Ÿå™¨)
  - [4.2 æŒ‡ä»¤ç¼–ç å™¨](#42-æŒ‡ä»¤ç¼–ç å™¨)
- [5 åº”ç”¨åœºæ™¯](#5-åº”ç”¨åœºæ™¯)
  - [5.1 å¤„ç†å™¨è®¾è®¡](#51-å¤„ç†å™¨è®¾è®¡)
  - [5.2 ç¼–è¯‘å™¨è®¾è®¡](#52-ç¼–è¯‘å™¨è®¾è®¡)
  - [5.3 ç³»ç»Ÿè½¯ä»¶](#53-ç³»ç»Ÿè½¯ä»¶)
- [6 ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
  - [6.1 è®¡ç®—æœºç»„ç»‡](#61-è®¡ç®—æœºç»„ç»‡)
  - [6.2 ç¼–è¯‘åŸç†](#62-ç¼–è¯‘åŸç†)
  - [6.3 æ“ä½œç³»ç»Ÿ](#63-æ“ä½œç³»ç»Ÿ)
- [7 æ‰¹åˆ¤æ€§åˆ†æ](#7-æ‰¹åˆ¤æ€§åˆ†æ)

---

## 1 æŒ‡ä»¤é›†æ¶æ„ç†è®º

## 2 å½¢å¼åŒ–å®šä¹‰

### 2.1 æŒ‡ä»¤é›†åŸºç¡€

**å®šä¹‰ 9.1.02.1 (æŒ‡ä»¤é›†æ¶æ„)**
æŒ‡ä»¤é›†æ¶æ„ $\mathcal{ISA}$ æ˜¯ä¸€ä¸ªå››å…ƒç»„ï¼š
$$\mathcal{ISA} = (\mathcal{I}, \mathcal{R}, \mathcal{M}, \mathcal{A})$$
å…¶ä¸­ï¼š

- $\mathcal{I}$ æ˜¯æŒ‡ä»¤é›†
- $\mathcal{R}$ æ˜¯å¯„å­˜å™¨é›†
- $\mathcal{M}$ æ˜¯å†…å­˜æ¨¡å‹
- $\mathcal{A}$ æ˜¯å¯»å€æ¨¡å¼é›†

**å®šä¹‰ 9.1.02.2 (æŒ‡ä»¤)**
æŒ‡ä»¤ $i \in \mathcal{I}$ æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼š
$$i = (\text{opcode}, \text{operands}, \text{encoding})$$
å…¶ä¸­ï¼š

- $\text{opcode}$ æ˜¯æ“ä½œç 
- $\text{operands}$ æ˜¯æ“ä½œæ•°åˆ—è¡¨
- $\text{encoding}$ æ˜¯äºŒè¿›åˆ¶ç¼–ç 

**å®šä¹‰ 9.1.02.3 (æŒ‡ä»¤æ ¼å¼)**
æŒ‡ä»¤æ ¼å¼ $F$ æ˜¯ä¸€ä¸ªæ˜ å°„ï¼š
$$F: \mathcal{I} \rightarrow \{0,1\}^*$$
å°†æŒ‡ä»¤æ˜ å°„åˆ°äºŒè¿›åˆ¶è¡¨ç¤ºã€‚

### 2.2 å¯»å€æ¨¡å¼

**å®šä¹‰ 9.1.02.4 (å¯»å€æ¨¡å¼)**
å¯»å€æ¨¡å¼ $\alpha \in \mathcal{A}$ æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$$\alpha: \text{Operand} \rightarrow \text{Address}$$
å°†æ“ä½œæ•°æ˜ å°„åˆ°å†…å­˜åœ°å€ã€‚

**å®šä¹‰ 9.1.02.5 (å¯„å­˜å™¨å¯»å€)**
å¯„å­˜å™¨å¯»å€ï¼š$\alpha_r(r) = \text{content}(r)$

**å®šä¹‰ 9.1.02.6 (ç«‹å³æ•°å¯»å€)**
ç«‹å³æ•°å¯»å€ï¼š$\alpha_i(imm) = imm$

**å®šä¹‰ 9.1.02.7 (åŸºå€å¯»å€)**
åŸºå€å¯»å€ï¼š$\alpha_b(base, offset) = \text{content}(base) + offset$

## 3 æ ¸å¿ƒå®šç†

### 3.1 æŒ‡ä»¤é›†å®Œå¤‡æ€§å®šç†

**å®šç† 9.1.02.1 (å›¾çµå®Œå¤‡æ€§)**
ä¸€ä¸ªæŒ‡ä»¤é›†æ˜¯å›¾çµå®Œå¤‡çš„ï¼Œå½“ä¸”ä»…å½“å®ƒåŒ…å«ï¼š

1. æ¡ä»¶åˆ†æ”¯æŒ‡ä»¤
2. æ— æ¡ä»¶è·³è½¬æŒ‡ä»¤
3. æ•°æ®æ“ä½œæŒ‡ä»¤
4. å†…å­˜è®¿é—®æŒ‡ä»¤

**è¯æ˜ï¼š**

1. å¯ä»¥æ¨¡æ‹Ÿå›¾çµæœºçš„çŠ¶æ€è½¬ç§»
2. å¯ä»¥å®ç°ä»»æ„è®¡ç®—
3. å¯ä»¥æ„é€ é€šç”¨ç¨‹åº

### 3.2 æŒ‡ä»¤ç¼–ç å®šç†

**å®šç† 9.1.02.2 (æŒ‡ä»¤ç¼–ç å”¯ä¸€æ€§)**
å¯¹äºç»™å®šçš„æŒ‡ä»¤é›†ï¼Œå­˜åœ¨å”¯ä¸€çš„ç¼–ç æ–¹æ¡ˆï¼Œä½¿å¾—ï¼š
$$\forall i_1, i_2 \in \mathcal{I}: i_1 \neq i_2 \Rightarrow F(i_1) \neq F(i_2)$$

**è¯æ˜ï¼š**

1. ç¼–ç å‡½æ•°æ˜¯å•å°„
2. ä¸åŒæŒ‡ä»¤æœ‰ä¸åŒçš„æ“ä½œç 
3. æ“ä½œæ•°ç¼–ç ä¸é‡å 

## 4 ç®—æ³•å®ç°

### 4.1 RISC-VæŒ‡ä»¤é›†æ¨¡æ‹Ÿå™¨

```rust
use std::collections::HashMap;

// RISC-VæŒ‡ä»¤ç±»å‹
#[derive(Debug, Clone)]
enum RiscvInstruction {
    // Rå‹æŒ‡ä»¤
    Add(usize, usize, usize),    // add rd, rs1, rs2
    Sub(usize, usize, usize),    // sub rd, rs1, rs2
    Sll(usize, usize, usize),    // sll rd, rs1, rs2
    Slt(usize, usize, usize),    // slt rd, rs1, rs2
    Sltu(usize, usize, usize),   // sltu rd, rs1, rs2
    Xor(usize, usize, usize),    // xor rd, rs1, rs2
    Srl(usize, usize, usize),    // srl rd, rs1, rs2
    Sra(usize, usize, usize),    // sra rd, rs1, rs2
    Or(usize, usize, usize),     // or rd, rs1, rs2
    And(usize, usize, usize),    // and rd, rs1, rs2
    
    // Iå‹æŒ‡ä»¤
    Addi(usize, usize, i32),     // addi rd, rs1, imm
    Slti(usize, usize, i32),     // slti rd, rs1, imm
    Sltiu(usize, usize, i32),    // sltiu rd, rs1, imm
    Xori(usize, usize, i32),     // xori rd, rs1, imm
    Ori(usize, usize, i32),      // ori rd, rs1, imm
    Andi(usize, usize, i32),     // andi rd, rs1, imm
    Slli(usize, usize, u32),     // slli rd, rs1, shamt
    Srli(usize, usize, u32),     // srli rd, rs1, shamt
    Srai(usize, usize, u32),     // srai rd, rs1, shamt
    Lw(usize, usize, i32),       // lw rd, offset(rs1)
    Lh(usize, usize, i32),       // lh rd, offset(rs1)
    Lhu(usize, usize, i32),      // lhu rd, offset(rs1)
    Lb(usize, usize, i32),       // lb rd, offset(rs1)
    Lbu(usize, usize, i32),      // lbu rd, offset(rs1)
    Jalr(usize, usize, i32),     // jalr rd, offset(rs1)
    
    // Så‹æŒ‡ä»¤
    Sw(usize, usize, i32),       // sw rs2, offset(rs1)
    Sh(usize, usize, i32),       // sh rs2, offset(rs1)
    Sb(usize, usize, i32),       // sb rs2, offset(rs1)
    
    // Bå‹æŒ‡ä»¤
    Beq(usize, usize, i32),      // beq rs1, rs2, offset
    Bne(usize, usize, i32),      // bne rs1, rs2, offset
    Blt(usize, usize, i32),      // blt rs1, rs2, offset
    Bge(usize, usize, i32),      // bge rs1, rs2, offset
    Bltu(usize, usize, i32),     // bltu rs1, rs2, offset
    Bgeu(usize, usize, i32),     // bgeu rs1, rs2, offset
    
    // Uå‹æŒ‡ä»¤
    Lui(usize, i32),             // lui rd, imm
    Auipc(usize, i32),           // auipc rd, imm
    
    // Jå‹æŒ‡ä»¤
    Jal(usize, i32),             // jal rd, offset
}

// RISC-V CPU
#[derive(Debug)]
struct RiscvCPU {
    registers: [i32; 32],
    memory: HashMap<usize, u8>,
    pc: usize,
    clock_cycles: usize,
}

impl RiscvCPU {
    fn new() -> Self {
        Self {
            registers: [0; 32],
            memory: HashMap::new(),
            pc: 0,
            clock_cycles: 0,
        }
    }

    // æ‰§è¡ŒæŒ‡ä»¤
    fn execute(&mut self, instruction: &RiscvInstruction) -> Result<(), String> {
        match instruction {
            // Rå‹æŒ‡ä»¤
            RiscvInstruction::Add(rd, rs1, rs2) => {
                self.registers[*rd] = self.registers[*rs1].wrapping_add(self.registers[*rs2]);
                self.pc += 4;
            }
            RiscvInstruction::Sub(rd, rs1, rs2) => {
                self.registers[*rd] = self.registers[*rs1].wrapping_sub(self.registers[*rs2]);
                self.pc += 4;
            }
            RiscvInstruction::Sll(rd, rs1, rs2) => {
                let shamt = (self.registers[*rs2] & 0x1F) as u32;
                self.registers[*rd] = self.registers[*rs1] << shamt;
                self.pc += 4;
            }
            RiscvInstruction::Slt(rd, rs1, rs2) => {
                self.registers[*rd] = if self.registers[*rs1] < self.registers[*rs2] { 1 } else { 0 };
                self.pc += 4;
            }
            RiscvInstruction::Sltu(rd, rs1, rs2) => {
                let rs1_u = self.registers[*rs1] as u32;
                let rs2_u = self.registers[*rs2] as u32;
                self.registers[*rd] = if rs1_u < rs2_u { 1 } else { 0 };
                self.pc += 4;
            }
            RiscvInstruction::Xor(rd, rs1, rs2) => {
                self.registers[*rd] = self.registers[*rs1] ^ self.registers[*rs2];
                self.pc += 4;
            }
            RiscvInstruction::Srl(rd, rs1, rs2) => {
                let shamt = (self.registers[*rs2] & 0x1F) as u32;
                self.registers[*rd] = (self.registers[*rs1] as u32 >> shamt) as i32;
                self.pc += 4;
            }
            RiscvInstruction::Sra(rd, rs1, rs2) => {
                let shamt = (self.registers[*rs2] & 0x1F) as u32;
                self.registers[*rd] = self.registers[*rs1] >> shamt;
                self.pc += 4;
            }
            RiscvInstruction::Or(rd, rs1, rs2) => {
                self.registers[*rd] = self.registers[*rs1] | self.registers[*rs2];
                self.pc += 4;
            }
            RiscvInstruction::And(rd, rs1, rs2) => {
                self.registers[*rd] = self.registers[*rs1] & self.registers[*rs2];
                self.pc += 4;
            }
            
            // Iå‹æŒ‡ä»¤
            RiscvInstruction::Addi(rd, rs1, imm) => {
                self.registers[*rd] = self.registers[*rs1].wrapping_add(*imm);
                self.pc += 4;
            }
            RiscvInstruction::Slti(rd, rs1, imm) => {
                self.registers[*rd] = if self.registers[*rs1] < *imm { 1 } else { 0 };
                self.pc += 4;
            }
            RiscvInstruction::Sltiu(rd, rs1, imm) => {
                let rs1_u = self.registers[*rs1] as u32;
                let imm_u = *imm as u32;
                self.registers[*rd] = if rs1_u < imm_u { 1 } else { 0 };
                self.pc += 4;
            }
            RiscvInstruction::Xori(rd, rs1, imm) => {
                self.registers[*rd] = self.registers[*rs1] ^ *imm;
                self.pc += 4;
            }
            RiscvInstruction::Ori(rd, rs1, imm) => {
                self.registers[*rd] = self.registers[*rs1] | *imm;
                self.pc += 4;
            }
            RiscvInstruction::Andi(rd, rs1, imm) => {
                self.registers[*rd] = self.registers[*rs1] & *imm;
                self.pc += 4;
            }
            RiscvInstruction::Slli(rd, rs1, shamt) => {
                self.registers[*rd] = self.registers[*rs1] << shamt;
                self.pc += 4;
            }
            RiscvInstruction::Srli(rd, rs1, shamt) => {
                self.registers[*rd] = (self.registers[*rs1] as u32 >> shamt) as i32;
                self.pc += 4;
            }
            RiscvInstruction::Srai(rd, rs1, shamt) => {
                self.registers[*rd] = self.registers[*rs1] >> shamt;
                self.pc += 4;
            }
            RiscvInstruction::Lw(rd, rs1, offset) => {
                let address = (self.registers[*rs1] + *offset) as usize;
                let value = self.load_word(address);
                self.registers[*rd] = value;
                self.pc += 4;
            }
            RiscvInstruction::Lh(rd, rs1, offset) => {
                let address = (self.registers[*rs1] + *offset) as usize;
                let value = self.load_halfword(address) as i16 as i32;
                self.registers[*rd] = value;
                self.pc += 4;
            }
            RiscvInstruction::Lhu(rd, rs1, offset) => {
                let address = (self.registers[*rs1] + *offset) as usize;
                let value = self.load_halfword(address) as i32;
                self.registers[*rd] = value;
                self.pc += 4;
            }
            RiscvInstruction::Lb(rd, rs1, offset) => {
                let address = (self.registers[*rs1] + *offset) as usize;
                let value = self.load_byte(address) as i8 as i32;
                self.registers[*rd] = value;
                self.pc += 4;
            }
            RiscvInstruction::Lbu(rd, rs1, offset) => {
                let address = (self.registers[*rs1] + *offset) as usize;
                let value = self.load_byte(address) as i32;
                self.registers[*rd] = value;
                self.pc += 4;
            }
            RiscvInstruction::Jalr(rd, rs1, offset) => {
                let target = (self.registers[*rs1] + *offset) & !1;
                self.registers[*rd] = (self.pc + 4) as i32;
                self.pc = target as usize;
            }
            
            // Så‹æŒ‡ä»¤
            RiscvInstruction::Sw(rs2, rs1, offset) => {
                let address = (self.registers[*rs1] + *offset) as usize;
                self.store_word(address, self.registers[*rs2]);
                self.pc += 4;
            }
            RiscvInstruction::Sh(rs2, rs1, offset) => {
                let address = (self.registers[*rs1] + *offset) as usize;
                self.store_halfword(address, self.registers[*rs2] as u16);
                self.pc += 4;
            }
            RiscvInstruction::Sb(rs2, rs1, offset) => {
                let address = (self.registers[*rs1] + *offset) as usize;
                self.store_byte(address, self.registers[*rs2] as u8);
                self.pc += 4;
            }
            
            // Bå‹æŒ‡ä»¤
            RiscvInstruction::Beq(rs1, rs2, offset) => {
                if self.registers[*rs1] == self.registers[*rs2] {
                    self.pc = (self.pc as i32 + *offset) as usize;
                } else {
                    self.pc += 4;
                }
            }
            RiscvInstruction::Bne(rs1, rs2, offset) => {
                if self.registers[*rs1] != self.registers[*rs2] {
                    self.pc = (self.pc as i32 + *offset) as usize;
                } else {
                    self.pc += 4;
                }
            }
            RiscvInstruction::Blt(rs1, rs2, offset) => {
                if self.registers[*rs1] < self.registers[*rs2] {
                    self.pc = (self.pc as i32 + *offset) as usize;
                } else {
                    self.pc += 4;
                }
            }
            RiscvInstruction::Bge(rs1, rs2, offset) => {
                if self.registers[*rs1] >= self.registers[*rs2] {
                    self.pc = (self.pc as i32 + *offset) as usize;
                } else {
                    self.pc += 4;
                }
            }
            RiscvInstruction::Bltu(rs1, rs2, offset) => {
                let rs1_u = self.registers[*rs1] as u32;
                let rs2_u = self.registers[*rs2] as u32;
                if rs1_u < rs2_u {
                    self.pc = (self.pc as i32 + *offset) as usize;
                } else {
                    self.pc += 4;
                }
            }
            RiscvInstruction::Bgeu(rs1, rs2, offset) => {
                let rs1_u = self.registers[*rs1] as u32;
                let rs2_u = self.registers[*rs2] as u32;
                if rs1_u >= rs2_u {
                    self.pc = (self.pc as i32 + *offset) as usize;
                } else {
                    self.pc += 4;
                }
            }
            
            // Uå‹æŒ‡ä»¤
            RiscvInstruction::Lui(rd, imm) => {
                self.registers[*rd] = *imm << 12;
                self.pc += 4;
            }
            RiscvInstruction::Auipc(rd, imm) => {
                self.registers[*rd] = (self.pc + (*imm << 12) as usize) as i32;
                self.pc += 4;
            }
            
            // Jå‹æŒ‡ä»¤
            RiscvInstruction::Jal(rd, offset) => {
                self.registers[*rd] = (self.pc + 4) as i32;
                self.pc = (self.pc as i32 + *offset) as usize;
            }
        }
        
        self.clock_cycles += 1;
        Ok(())
    }

    // å†…å­˜è®¿é—®å‡½æ•°
    fn load_word(&self, address: usize) -> i32 {
        let mut value = 0u32;
        for i in 0..4 {
            let byte = self.memory.get(&(address + i)).copied().unwrap_or(0);
            value |= (byte as u32) << (i * 8);
        }
        value as i32
    }

    fn load_halfword(&self, address: usize) -> u16 {
        let mut value = 0u16;
        for i in 0..2 {
            let byte = self.memory.get(&(address + i)).copied().unwrap_or(0);
            value |= (byte as u16) << (i * 8);
        }
        value
    }

    fn load_byte(&self, address: usize) -> u8 {
        self.memory.get(&address).copied().unwrap_or(0)
    }

    fn store_word(&mut self, address: usize, value: i32) {
        let value_u = value as u32;
        for i in 0..4 {
            let byte = ((value_u >> (i * 8)) & 0xFF) as u8;
            self.memory.insert(address + i, byte);
        }
    }

    fn store_halfword(&mut self, address: usize, value: u16) {
        for i in 0..2 {
            let byte = ((value >> (i * 8)) & 0xFF) as u8;
            self.memory.insert(address + i, byte);
        }
    }

    fn store_byte(&mut self, address: usize, value: u8) {
        self.memory.insert(address, value);
    }

    // è¿è¡Œç¨‹åº
    fn run(&mut self, program: &[RiscvInstruction]) -> Result<(), String> {
        while self.pc < program.len() * 4 {
            let instruction_index = self.pc / 4;
            if instruction_index < program.len() {
                self.execute(&program[instruction_index])?;
            } else {
                break;
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_riscv_arithmetic() {
        let mut cpu = RiscvCPU::new();
        
        // æµ‹è¯•ç®—æœ¯æŒ‡ä»¤ï¼šè®¡ç®— 5 + 3
        let program = vec![
            RiscvInstruction::Addi(1, 0, 5),  // x1 = 5
            RiscvInstruction::Addi(2, 0, 3),  // x2 = 3
            RiscvInstruction::Add(3, 1, 2),   // x3 = x1 + x2
        ];
        
        cpu.run(&program).unwrap();
        assert_eq!(cpu.registers[3], 8);
    }

    #[test]
    fn test_riscv_branch() {
        let mut cpu = RiscvCPU::new();
        
        // æµ‹è¯•åˆ†æ”¯æŒ‡ä»¤
        let program = vec![
            RiscvInstruction::Addi(1, 0, 5),  // x1 = 5
            RiscvInstruction::Addi(2, 0, 5),  // x2 = 5
            RiscvInstruction::Beq(1, 2, 8),   // if x1 == x2, skip next instruction
            RiscvInstruction::Addi(3, 0, 1),  // x3 = 1 (should be skipped)
            RiscvInstruction::Addi(4, 0, 10), // x4 = 10
        ];
        
        cpu.run(&program).unwrap();
        assert_eq!(cpu.registers[3], 0); // åº”è¯¥è¢«è·³è¿‡
        assert_eq!(cpu.registers[4], 10);
    }
}
```

### 4.2 æŒ‡ä»¤ç¼–ç å™¨

```rust
// æŒ‡ä»¤ç¼–ç å™¨
struct InstructionEncoder;

impl InstructionEncoder {
    // Rå‹æŒ‡ä»¤ç¼–ç 
    fn encode_r_type(opcode: u32, rd: u32, funct3: u32, rs1: u32, rs2: u32, funct7: u32) -> u32 {
        (funct7 << 25) | (rs2 << 20) | (rs1 << 15) | (funct3 << 12) | (rd << 7) | opcode
    }

    // Iå‹æŒ‡ä»¤ç¼–ç 
    fn encode_i_type(opcode: u32, rd: u32, funct3: u32, rs1: u32, imm: i32) -> u32 {
        let imm_u = (imm & 0xFFF) as u32;
        (imm_u << 20) | (rs1 << 15) | (funct3 << 12) | (rd << 7) | opcode
    }

    // Så‹æŒ‡ä»¤ç¼–ç 
    fn encode_s_type(opcode: u32, funct3: u32, rs1: u32, rs2: u32, imm: i32) -> u32 {
        let imm_u = (imm & 0xFFF) as u32;
        let imm_11_5 = (imm_u >> 5) & 0x7F;
        let imm_4_0 = imm_u & 0x1F;
        (imm_11_5 << 25) | (rs2 << 20) | (rs1 << 15) | (funct3 << 12) | (imm_4_0 << 7) | opcode
    }

    // Bå‹æŒ‡ä»¤ç¼–ç 
    fn encode_b_type(opcode: u32, funct3: u32, rs1: u32, rs2: u32, imm: i32) -> u32 {
        let imm_u = (imm & 0x1FFF) as u32;
        let imm_12 = (imm_u >> 12) & 1;
        let imm_11 = (imm_u >> 11) & 1;
        let imm_10_5 = (imm_u >> 5) & 0x3F;
        let imm_4_1 = (imm_u >> 1) & 0xF;
        
        (imm_12 << 31) | (imm_10_5 << 25) | (rs2 << 20) | (rs1 << 15) | 
        (funct3 << 12) | (imm_4_1 << 8) | (imm_11 << 7) | opcode
    }

    // Uå‹æŒ‡ä»¤ç¼–ç 
    fn encode_u_type(opcode: u32, rd: u32, imm: i32) -> u32 {
        let imm_u = (imm & 0xFFFFF000) as u32;
        (imm_u << 12) | (rd << 7) | opcode
    }

    // Jå‹æŒ‡ä»¤ç¼–ç 
    fn encode_j_type(opcode: u32, rd: u32, imm: i32) -> u32 {
        let imm_u = (imm & 0x1FFFFF) as u32;
        let imm_20 = (imm_u >> 20) & 1;
        let imm_19_12 = (imm_u >> 12) & 0xFF;
        let imm_11 = (imm_u >> 11) & 1;
        let imm_10_1 = (imm_u >> 1) & 0x3FF;
        
        (imm_20 << 31) | (imm_10_1 << 21) | (imm_11 << 20) | 
        (imm_19_12 << 12) | (rd << 7) | opcode
    }

    // ç¼–ç å…·ä½“æŒ‡ä»¤
    fn encode_add(rd: u32, rs1: u32, rs2: u32) -> u32 {
        Self::encode_r_type(0x33, rd, 0, rs1, rs2, 0)
    }

    fn encode_addi(rd: u32, rs1: u32, imm: i32) -> u32 {
        Self::encode_i_type(0x13, rd, 0, rs1, imm)
    }

    fn encode_lw(rd: u32, rs1: u32, imm: i32) -> u32 {
        Self::encode_i_type(0x03, rd, 2, rs1, imm)
    }

    fn encode_sw(rs2: u32, rs1: u32, imm: i32) -> u32 {
        Self::encode_s_type(0x23, 2, rs1, rs2, imm)
    }

    fn encode_beq(rs1: u32, rs2: u32, imm: i32) -> u32 {
        Self::encode_b_type(0x63, 0, rs1, rs2, imm)
    }

    fn encode_jal(rd: u32, imm: i32) -> u32 {
        Self::encode_j_type(0x6F, rd, imm)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_instruction_encoding() {
        // æµ‹è¯•ADDæŒ‡ä»¤ç¼–ç 
        let encoded = InstructionEncoder::encode_add(1, 2, 3);
        assert_eq!(encoded, 0x003100B3); // add x1, x2, x3
        
        // æµ‹è¯•ADDIæŒ‡ä»¤ç¼–ç 
        let encoded = InstructionEncoder::encode_addi(1, 2, 5);
        assert_eq!(encoded, 0x00510093); // addi x1, x2, 5
    }
}
```

## 5 åº”ç”¨åœºæ™¯

### 5.1 å¤„ç†å™¨è®¾è®¡

- RISC vs CISCæ¶æ„é€‰æ‹©
- æŒ‡ä»¤é›†æ‰©å±•è®¾è®¡
- å¾®æ¶æ„ä¼˜åŒ–

### 5.2 ç¼–è¯‘å™¨è®¾è®¡

- æŒ‡ä»¤é€‰æ‹©
- å¯„å­˜å™¨åˆ†é…
- ä»£ç ç”Ÿæˆ

### 5.3 ç³»ç»Ÿè½¯ä»¶

- æ“ä½œç³»ç»Ÿå†…æ ¸
- è®¾å¤‡é©±åŠ¨ç¨‹åº
- ç³»ç»Ÿè°ƒç”¨æ¥å£

## 6 ç›¸å…³ç†è®º

### 6.1 è®¡ç®—æœºç»„ç»‡

- æ•°å­—é€»è¾‘è®¾è®¡
- å¾®æ¶æ„è®¾è®¡
- ç³»ç»Ÿæ¶æ„

### 6.2 ç¼–è¯‘åŸç†

- æŒ‡ä»¤é€‰æ‹©
- å¯„å­˜å™¨åˆ†é…
- ä»£ç ä¼˜åŒ–

### 6.3 æ“ä½œç³»ç»Ÿ

- ç³»ç»Ÿè°ƒç”¨
- ä¸­æ–­å¤„ç†
- å†…å­˜ç®¡ç†

## 6. å‚è€ƒæ–‡çŒ®

1. Patterson, D. A., & Hennessy, J. L. (2017). Computer Organization and Design: The Hardware/Software Interface.
2. Waterman, A., & AsanoviÄ‡, K. (2017). The RISC-V Instruction Set Manual.
3. Hennessy, J. L., & Patterson, D. A. (2017). Computer Architecture: A Quantitative Approach.
4. Patterson, D. A. (1985). Reduced instruction set computers.
5. Hennessy, J. L. (1984). VLSI processor architecture.


## 7 æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
