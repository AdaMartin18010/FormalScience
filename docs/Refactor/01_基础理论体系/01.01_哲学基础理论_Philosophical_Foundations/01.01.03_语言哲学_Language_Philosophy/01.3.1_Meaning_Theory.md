# 01.3.1 æ„ä¹‰ç†è®º (Meaning Theory)

## ğŸ“‹ ç›®å½•

- [01.3.1 æ„ä¹‰ç†è®º (Meaning Theory)](#0131-æ„ä¹‰ç†è®º-meaning-theory)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1 ç†è®ºæ¦‚è¿°](#1-ç†è®ºæ¦‚è¿°)
  - [2 å½¢å¼åŒ–è¯­ä¹‰](#2-å½¢å¼åŒ–è¯­ä¹‰)
    - [2.1 æ ¸å¿ƒå®šä¹‰](#21-æ ¸å¿ƒå®šä¹‰)
    - [2.2 æ ¸å¿ƒå®šç†](#22-æ ¸å¿ƒå®šç†)
  - [3 å¤šè¡¨å¾æ–¹å¼](#3-å¤šè¡¨å¾æ–¹å¼)
    - [3.1 å›¾å½¢è¡¨å¾](#31-å›¾å½¢è¡¨å¾)
    - [3.2 è¡¨æ ¼è¡¨å¾](#32-è¡¨æ ¼è¡¨å¾)
    - [3.3 æ•°å­¦è¡¨å¾](#33-æ•°å­¦è¡¨å¾)
    - [3.4 ä¼ªä»£ç è¡¨å¾](#34-ä¼ªä»£ç è¡¨å¾)
  - [4 Rustå®ç°](#4-rustå®ç°)
  - [5 å“²å­¦æ€§æ‰¹åˆ¤ä¸å±•æœ›](#5-å“²å­¦æ€§æ‰¹åˆ¤ä¸å±•æœ›)
    - [5.1 æœ¬ä½“è®ºåæ€](#51-æœ¬ä½“è®ºåæ€)
    - [5.2 è®¤è¯†è®ºæ‰¹åˆ¤](#52-è®¤è¯†è®ºæ‰¹åˆ¤)
    - [5.3 ç¤¾ä¼šå½±å“åˆ†æ](#53-ç¤¾ä¼šå½±å“åˆ†æ)
    - [5.4 ç»ˆæå“²å­¦å»ºè®®](#54-ç»ˆæå“²å­¦å»ºè®®)
  - [ğŸ“š å‚è€ƒæ–‡çŒ®](#-å‚è€ƒæ–‡çŒ®)

---

## 1 ç†è®ºæ¦‚è¿°

æ„ä¹‰ç†è®ºç ”ç©¶è¯­è¨€è¡¨è¾¾å¼çš„æ„ä¹‰æœ¬è´¨ã€æ„ä¹‰å…³ç³»ä»¥åŠæ„ä¹‰çš„ç¡®å®šæ–¹å¼ã€‚
æœ¬ç†è®ºæ¶µç›–æŒ‡ç§°è®ºã€è§‚å¿µè®ºã€ä½¿ç”¨è®ºã€çœŸå€¼æ¡ä»¶è®ºç­‰æ ¸å¿ƒæ¦‚å¿µï¼Œä¸ºç†è§£è¯­è¨€æ„ä¹‰çš„å“²å­¦åŸºç¡€æä¾›ç†è®ºæ”¯æ’‘ã€‚

## 2 å½¢å¼åŒ–è¯­ä¹‰

### 2.1 æ ¸å¿ƒå®šä¹‰

**å®šä¹‰ 1.1** (è¯­è¨€è¡¨è¾¾å¼)
è¯­è¨€è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ï¼š$E = (S, M, R)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯ç¬¦å·åºåˆ—
- $M$ æ˜¯æ„ä¹‰å†…å®¹
- $R$ æ˜¯æŒ‡ç§°å¯¹è±¡

**å®šä¹‰ 1.2** (æŒ‡ç§°è®º)
æŒ‡ç§°è®ºè®¤ä¸ºæ„ä¹‰å³æŒ‡ç§°ï¼š$\text{Meaning}(E) = \text{Reference}(E)$

**å®šä¹‰ 1.3** (è§‚å¿µè®º)
è§‚å¿µè®ºè®¤ä¸ºæ„ä¹‰å³è§‚å¿µï¼š$\text{Meaning}(E) = \text{Idea}(E)$

**å®šä¹‰ 1.4** (ä½¿ç”¨è®º)
ä½¿ç”¨è®ºè®¤ä¸ºæ„ä¹‰å³ä½¿ç”¨ï¼š$\text{Meaning}(E) = \text{Use}(E)$

**å®šä¹‰ 1.5** (çœŸå€¼æ¡ä»¶è®º)
çœŸå€¼æ¡ä»¶è®ºè®¤ä¸ºæ„ä¹‰å³çœŸå€¼æ¡ä»¶ï¼š$\text{Meaning}(E) = \{\text{Conditions} : E \text{ is true}\}$

### 2.2 æ ¸å¿ƒå®šç†

**å®šç† 1.1** (æ„ä¹‰çš„ç»„åˆæ€§)
å¤åˆè¡¨è¾¾å¼çš„æ„ä¹‰ç”±å…¶ç»„æˆéƒ¨åˆ†çš„æ„ä¹‰å†³å®šï¼š$\text{Meaning}(E_1 \oplus E_2) = f(\text{Meaning}(E_1), \text{Meaning}(E_2))$

**å®šç† 1.2** (æ„ä¹‰çš„ç³»ç»Ÿæ€§)
è¯­è¨€è¡¨è¾¾å¼çš„æ„ä¹‰å…·æœ‰ç³»ç»Ÿæ€§ï¼š$\forall E_1, E_2 \in L, \text{Systematic}(E_1, E_2) \rightarrow \text{Systematic}(\text{Meaning}(E_1), \text{Meaning}(E_2))$

**å®šç† 1.3** (æ„ä¹‰çš„å¯å­¦ä¹ æ€§)
æ„ä¹‰å…·æœ‰å¯å­¦ä¹ æ€§ï¼š$\forall E \in L, \exists \text{Learning Procedure} : \text{Learn}(\text{Meaning}(E))$

**å®šç† 1.4** (æ„ä¹‰çš„å…¬å…±æ€§)
æ„ä¹‰å…·æœ‰å…¬å…±æ€§ï¼š$\forall S_1, S_2 \in \text{Speakers}, \text{Meaning}(E, S_1) = \text{Meaning}(E, S_2)$

## 3 å¤šè¡¨å¾æ–¹å¼

### 3.1 å›¾å½¢è¡¨å¾

```mermaid
graph TD
    A[æ„ä¹‰ç†è®º] --> B[æŒ‡ç§°è®º]
    A --> C[è§‚å¿µè®º]
    A --> D[ä½¿ç”¨è®º]
    A --> E[çœŸå€¼æ¡ä»¶è®º]

    B --> F[ç¬¦å·]
    B --> G[æŒ‡ç§°å¯¹è±¡]
    B --> H[æŒ‡ç§°å…³ç³»]

    C --> I[ç¬¦å·]
    C --> J[å¿ƒç†è§‚å¿µ]
    C --> K[è§‚å¿µå…³è”]

    D --> L[ç¬¦å·]
    D --> M[ä½¿ç”¨è§„åˆ™]
    D --> N[è¯­å¢ƒä¾èµ–]

    E --> O[ç¬¦å·]
    E --> P[çœŸå€¼æ¡ä»¶]
    E --> Q[ä¸–ç•ŒçŠ¶æ€]

    subgraph æ„ä¹‰å…³ç³»
        R[è¡¨è¾¾å¼] --> S[æ„ä¹‰]
        S --> T[æŒ‡ç§°]
        S --> U[è§‚å¿µ]
        S --> V[ä½¿ç”¨]
        S --> W[çœŸå€¼æ¡ä»¶]
    end
```

### 3.2 è¡¨æ ¼è¡¨å¾

| æ„ä¹‰ç†è®º | æ„ä¹‰æœ¬è´¨ | ä¸»è¦ä¸»å¼  | ä¼˜åŠ¿ | å±€é™æ€§ |
|----------|----------|----------|------|--------|
| æŒ‡ç§°è®º | æŒ‡ç§°å¯¹è±¡ | æ„ä¹‰å³æŒ‡ç§° | ç›´è§‚ | æŠ½è±¡è¯å¤„ç†å›°éš¾ |
| è§‚å¿µè®º | å¿ƒç†è§‚å¿µ | æ„ä¹‰å³è§‚å¿µ | å¿ƒç†ç°å®æ€§ | ç§äººæ€§é—®é¢˜ |
| ä½¿ç”¨è®º | ä½¿ç”¨æ–¹å¼ | æ„ä¹‰å³ä½¿ç”¨ | å®ç”¨æ€§å¼º | ç³»ç»Ÿæ€§ä¸è¶³ |
| çœŸå€¼æ¡ä»¶è®º | çœŸå€¼æ¡ä»¶ | æ„ä¹‰å³çœŸå€¼æ¡ä»¶ | å½¢å¼åŒ–ç¨‹åº¦é«˜ | éé™ˆè¿°å¥å¤„ç†å›°éš¾ |

### 3.3 æ•°å­¦è¡¨å¾

**æŒ‡ç§°è®º**ï¼š
$\text{Meaning}(E) = \{x : E \text{ refers to } x\}$

**è§‚å¿µè®º**ï¼š
$\text{Meaning}(E) = \{I : I \text{ is the idea associated with } E\}$

**ä½¿ç”¨è®º**ï¼š
$\text{Meaning}(E) = \{U : U \text{ is a use of } E\}$

**çœŸå€¼æ¡ä»¶è®º**ï¼š
$\text{Meaning}(E) = \{w : E \text{ is true in } w\}$

### 3.4 ä¼ªä»£ç è¡¨å¾

```python
class MeaningTheory:
    def __init__(self, theory_type):
        self.theory_type = theory_type

    def reference_theory(self, expression):
        """æŒ‡ç§°è®º"""
        return self.get_reference(expression)

    def ideational_theory(self, expression):
        """è§‚å¿µè®º"""
        return self.get_idea(expression)

    def use_theory(self, expression):
        """ä½¿ç”¨è®º"""
        return self.get_use_pattern(expression)

    def truth_conditional_theory(self, expression):
        """çœŸå€¼æ¡ä»¶è®º"""
        return self.get_truth_conditions(expression)
```

## 4 Rustå®ç°

```rust
use std::collections::HashMap;

/// æ„ä¹‰ç†è®º
#[derive(Debug, Clone)]
pub struct MeaningTheory {
    pub theory_type: TheoryType,
    pub expressions: HashMap<String, Expression>,
    pub meanings: HashMap<String, Meaning>,
    pub references: HashMap<String, Reference>,
}

/// è¯­è¨€è¡¨è¾¾å¼
#[derive(Debug, Clone)]
pub struct Expression {
    pub symbol: String,
    pub syntactic_category: SyntacticCategory,
    pub semantic_features: Vec<SemanticFeature>,
}

/// æ„ä¹‰
#[derive(Debug, Clone)]
pub struct Meaning {
    pub content: String,
    pub meaning_type: MeaningType,
    pub context_dependent: bool,
    pub compositionality: f64,
}

/// æŒ‡ç§°
#[derive(Debug, Clone)]
pub struct Reference {
    pub object: String,
    pub reference_type: ReferenceType,
    pub existence_status: ExistenceStatus,
}

/// ç†è®ºç±»å‹
#[derive(Debug, Clone)]
pub enum TheoryType {
    Referential,      // æŒ‡ç§°è®º
    Ideational,       // è§‚å¿µè®º
    UseTheory,        // ä½¿ç”¨è®º
    TruthConditional, // çœŸå€¼æ¡ä»¶è®º
}

/// å¥æ³•èŒƒç•´
#[derive(Debug, Clone)]
pub enum SyntacticCategory {
    Noun,           // åè¯
    Verb,           // åŠ¨è¯
    Adjective,      // å½¢å®¹è¯
    Adverb,         // å‰¯è¯
    Preposition,    // ä»‹è¯
    Conjunction,    // è¿è¯
}

/// è¯­ä¹‰ç‰¹å¾
#[derive(Debug, Clone)]
pub struct SemanticFeature {
    pub name: String,
    pub value: String,
    pub feature_type: FeatureType,
}

/// æ„ä¹‰ç±»å‹
#[derive(Debug, Clone)]
pub enum MeaningType {
    Referential,    // æŒ‡ç§°æ„ä¹‰
    Ideational,     // è§‚å¿µæ„ä¹‰
    UseBased,       // ä½¿ç”¨æ„ä¹‰
    TruthConditional, // çœŸå€¼æ¡ä»¶æ„ä¹‰
}

/// æŒ‡ç§°ç±»å‹
#[derive(Debug, Clone)]
pub enum ReferenceType {
    Direct,         // ç›´æ¥æŒ‡ç§°
    Indirect,       // é—´æ¥æŒ‡ç§°
    Descriptive,    // æè¿°æ€§æŒ‡ç§°
    Causal,         // å› æœæŒ‡ç§°
}

/// å­˜åœ¨çŠ¶æ€
#[derive(Debug, Clone)]
pub enum ExistenceStatus {
    Exists,         // å­˜åœ¨
    DoesNotExist,   // ä¸å­˜åœ¨
    Fictional,      // è™šæ„
    Abstract,       // æŠ½è±¡
}

/// ç‰¹å¾ç±»å‹
#[derive(Debug, Clone)]
pub enum FeatureType {
    Semantic,       // è¯­ä¹‰ç‰¹å¾
    Pragmatic,      // è¯­ç”¨ç‰¹å¾
    Contextual,     // è¯­å¢ƒç‰¹å¾
}

impl MeaningTheory {
    /// åˆ›å»ºæ–°çš„æ„ä¹‰ç†è®º
    pub fn new(theory_type: TheoryType) -> Self {
        Self {
            theory_type,
            expressions: HashMap::new(),
            meanings: HashMap::new(),
            references: HashMap::new(),
        }
    }

    /// æ·»åŠ è¡¨è¾¾å¼
    pub fn add_expression(&mut self, expression: Expression) {
        self.expressions.insert(expression.symbol.clone(), expression);
    }

    /// æ·»åŠ æ„ä¹‰
    pub fn add_meaning(&mut self, symbol: String, meaning: Meaning) {
        self.meanings.insert(symbol, meaning);
    }

    /// æ·»åŠ æŒ‡ç§°
    pub fn add_reference(&mut self, symbol: String, reference: Reference) {
        self.references.insert(symbol, reference);
    }

    /// æŒ‡ç§°è®ºæ„ä¹‰åˆ†æ
    pub fn referential_meaning(&self, expression: &Expression) -> Option<&Reference> {
        self.references.get(&expression.symbol)
    }

    /// è§‚å¿µè®ºæ„ä¹‰åˆ†æ
    pub fn ideational_meaning(&self, expression: &Expression) -> Option<String> {
        // ç®€åŒ–çš„è§‚å¿µåˆ†æ
        Some(format!("è§‚å¿µ_{}", expression.symbol))
    }

    /// ä½¿ç”¨è®ºæ„ä¹‰åˆ†æ
    pub fn use_based_meaning(&self, expression: &Expression) -> Vec<String> {
        // ç®€åŒ–çš„ä½¿ç”¨æ¨¡å¼åˆ†æ
        vec![
            format!("ä½¿ç”¨æ¨¡å¼1_{}", expression.symbol),
            format!("ä½¿ç”¨æ¨¡å¼2_{}", expression.symbol),
        ]
    }

    /// çœŸå€¼æ¡ä»¶è®ºæ„ä¹‰åˆ†æ
    pub fn truth_conditional_meaning(&self, expression: &Expression) -> Vec<String> {
        // ç®€åŒ–çš„çœŸå€¼æ¡ä»¶åˆ†æ
        vec![
            format!("çœŸå€¼æ¡ä»¶1_{}", expression.symbol),
            format!("çœŸå€¼æ¡ä»¶2_{}", expression.symbol),
        ]
    }

    /// è·å–è¡¨è¾¾å¼çš„æ„ä¹‰
    pub fn get_meaning(&self, expression: &Expression) -> Meaning {
        match self.theory_type {
            TheoryType::Referential => {
                let reference = self.referential_meaning(expression);
                Meaning {
                    content: reference.map(|r| r.object.clone()).unwrap_or_default(),
                    meaning_type: MeaningType::Referential,
                    context_dependent: false,
                    compositionality: 0.8,
                }
            },
            TheoryType::Ideational => {
                let idea = self.ideational_meaning(expression);
                Meaning {
                    content: idea.unwrap_or_default(),
                    meaning_type: MeaningType::Ideational,
                    context_dependent: true,
                    compositionality: 0.6,
                }
            },
            TheoryType::UseTheory => {
                let uses = self.use_based_meaning(expression);
                Meaning {
                    content: uses.join(", "),
                    meaning_type: MeaningType::UseBased,
                    context_dependent: true,
                    compositionality: 0.4,
                }
            },
            TheoryType::TruthConditional => {
                let conditions = self.truth_conditional_meaning(expression);
                Meaning {
                    content: conditions.join(", "),
                    meaning_type: MeaningType::TruthConditional,
                    context_dependent: false,
                    compositionality: 0.9,
                }
            },
        }
    }

    /// åˆ†ææ„ä¹‰çš„ç»„åˆæ€§
    pub fn analyze_compositionality(&self, expression: &Expression) -> f64 {
        let meaning = self.get_meaning(expression);
        meaning.compositionality
    }

    /// åˆ†ææ„ä¹‰çš„ç³»ç»Ÿæ€§
    pub fn analyze_systematicity(&self, expression1: &Expression, expression2: &Expression) -> bool {
        // ç®€åŒ–çš„ç³»ç»Ÿæ€§åˆ†æ
        expression1.syntactic_category == expression2.syntactic_category
    }

    /// åˆ†ææ„ä¹‰çš„å¯å­¦ä¹ æ€§
    pub fn analyze_learnability(&self, expression: &Expression) -> f64 {
        // ç®€åŒ–çš„å¯å­¦ä¹ æ€§åˆ†æ
        match expression.syntactic_category {
            SyntacticCategory::Noun => 0.9,
            SyntacticCategory::Verb => 0.8,
            SyntacticCategory::Adjective => 0.7,
            SyntacticCategory::Adverb => 0.6,
            SyntacticCategory::Preposition => 0.5,
            SyntacticCategory::Conjunction => 0.4,
        }
    }

    /// åˆ†ææ„ä¹‰çš„å…¬å…±æ€§
    pub fn analyze_publicity(&self, expression: &Expression) -> bool {
        // ç®€åŒ–çš„å…¬å…±æ€§åˆ†æ
        !expression.semantic_features.is_empty()
    }
}

impl Expression {
    /// åˆ›å»ºæ–°çš„è¡¨è¾¾å¼
    pub fn new(symbol: String, category: SyntacticCategory) -> Self {
        Self {
            symbol,
            syntactic_category: category,
            semantic_features: Vec::new(),
        }
    }

    /// æ·»åŠ è¯­ä¹‰ç‰¹å¾
    pub fn add_semantic_feature(&mut self, feature: SemanticFeature) {
        self.semantic_features.push(feature);
    }

    /// è·å–è¡¨è¾¾å¼çš„å¤æ‚åº¦
    pub fn complexity(&self) -> usize {
        self.semantic_features.len()
    }
}

impl Meaning {
    /// åˆ›å»ºæ–°çš„æ„ä¹‰
    pub fn new(content: String, meaning_type: MeaningType) -> Self {
        Self {
            content,
            meaning_type,
            context_dependent: false,
            compositionality: 0.5,
        }
    }

    /// è®¾ç½®è¯­å¢ƒä¾èµ–æ€§
    pub fn set_context_dependent(&mut self, context_dependent: bool) {
        self.context_dependent = context_dependent;
    }

    /// è®¾ç½®ç»„åˆæ€§
    pub fn set_compositionality(&mut self, compositionality: f64) {
        self.compositionality = compositionality.max(0.0).min(1.0);
    }

    /// è·å–æ„ä¹‰å¼ºåº¦
    pub fn get_meaning_strength(&self) -> f64 {
        let base_strength = if self.context_dependent { 0.7 } else { 0.9 };
        base_strength * self.compositionality
    }
}

impl Reference {
    /// åˆ›å»ºæ–°çš„æŒ‡ç§°
    pub fn new(object: String, reference_type: ReferenceType) -> Self {
        Self {
            object,
            reference_type,
            existence_status: ExistenceStatus::Exists,
        }
    }

    /// è®¾ç½®å­˜åœ¨çŠ¶æ€
    pub fn set_existence_status(&mut self, status: ExistenceStatus) {
        self.existence_status = status;
    }

    /// æ£€æŸ¥æŒ‡ç§°æ˜¯å¦æœ‰æ•ˆ
    pub fn is_valid(&self) -> bool {
        matches!(self.existence_status, ExistenceStatus::Exists)
    }
}

/// æ„ä¹‰åˆ†æå™¨
#[derive(Debug)]
pub struct MeaningAnalyzer {
    pub theories: Vec<MeaningTheory>,
    pub analysis_results: HashMap<String, AnalysisResult>,
}

/// åˆ†æç»“æœ
#[derive(Debug)]
pub struct AnalysisResult {
    pub expression: String,
    pub meanings: Vec<Meaning>,
    pub compositionality_score: f64,
    pub systematicity_score: f64,
    pub learnability_score: f64,
    pub publicity_score: f64,
}

impl MeaningAnalyzer {
    /// åˆ›å»ºæ–°çš„æ„ä¹‰åˆ†æå™¨
    pub fn new() -> Self {
        Self {
            theories: Vec::new(),
            analysis_results: HashMap::new(),
        }
    }

    /// æ·»åŠ æ„ä¹‰ç†è®º
    pub fn add_theory(&mut self, theory: MeaningTheory) {
        self.theories.push(theory);
    }

    /// åˆ†æè¡¨è¾¾å¼
    pub fn analyze_expression(&mut self, expression: &Expression) -> AnalysisResult {
        let mut meanings = Vec::new();
        let mut compositionality_scores = Vec::new();
        let mut systematicity_scores = Vec::new();
        let mut learnability_scores = Vec::new();
        let mut publicity_scores = Vec::new();

        for theory in &self.theories {
            let meaning = theory.get_meaning(expression);
            meanings.push(meaning.clone());

            compositionality_scores.push(theory.analyze_compositionality(expression));
            learnability_scores.push(theory.analyze_learnability(expression));
            publicity_scores.push(if theory.analyze_publicity(expression) { 1.0 } else { 0.0 });
        }

        // è®¡ç®—ç³»ç»Ÿæ€§åˆ†æ•°
        if self.theories.len() > 1 {
            for i in 0..self.theories.len() - 1 {
                for j in i + 1..self.theories.len() {
                    let systematicity = self.theories[i].analyze_systematicity(expression, expression);
                    systematicity_scores.push(if systematicity { 1.0 } else { 0.0 });
                }
            }
        }

        AnalysisResult {
            expression: expression.symbol.clone(),
            meanings,
            compositionality_score: compositionality_scores.iter().sum::<f64>() / compositionality_scores.len() as f64,
            systematicity_score: systematicity_scores.iter().sum::<f64>() / systematicity_scores.len() as f64,
            learnability_score: learnability_scores.iter().sum::<f64>() / learnability_scores.len() as f64,
            publicity_score: publicity_scores.iter().sum::<f64>() / publicity_scores.len() as f64,
        }
    }

    /// æ¯”è¾ƒä¸åŒç†è®º
    pub fn compare_theories(&self, expression: &Expression) -> TheoryComparison {
        let mut comparison = TheoryComparison {
            expression: expression.symbol.clone(),
            theory_scores: HashMap::new(),
        };

        for (i, theory) in self.theories.iter().enumerate() {
            let meaning = theory.get_meaning(expression);
            let score = meaning.get_meaning_strength();
            comparison.theory_scores.insert(format!("ç†è®º_{}", i), score);
        }

        comparison
    }
}

/// ç†è®ºæ¯”è¾ƒ
#[derive(Debug)]
pub struct TheoryComparison {
    pub expression: String,
    pub theory_scores: HashMap<String, f64>,
}

// ç¤ºä¾‹ä½¿ç”¨
fn main() {
    // åˆ›å»ºæŒ‡ç§°è®º
    let mut referential_theory = MeaningTheory::new(TheoryType::Referential);

    // æ·»åŠ è¡¨è¾¾å¼å’ŒæŒ‡ç§°
    let mut cat_expression = Expression::new("çŒ«".to_string(), SyntacticCategory::Noun);
    cat_expression.add_semantic_feature(SemanticFeature {
        name: "åŠ¨ç‰©".to_string(),
        value: "æ˜¯".to_string(),
        feature_type: FeatureType::Semantic,
    });

    referential_theory.add_expression(cat_expression.clone());
    referential_theory.add_reference("çŒ«".to_string(), Reference::new(
        "çŒ«ç§‘åŠ¨ç‰©".to_string(),
        ReferenceType::Direct,
    ));

    // åˆ›å»ºä½¿ç”¨è®º
    let mut use_theory = MeaningTheory::new(TheoryType::UseTheory);
    use_theory.add_expression(cat_expression.clone());

    // åˆ›å»ºæ„ä¹‰åˆ†æå™¨
    let mut analyzer = MeaningAnalyzer::new();
    analyzer.add_theory(referential_theory);
    analyzer.add_theory(use_theory);

    // åˆ†æè¡¨è¾¾å¼
    let result = analyzer.analyze_expression(&cat_expression);
    println!("æ„ä¹‰åˆ†æç»“æœ: {:?}", result);

    // æ¯”è¾ƒç†è®º
    let comparison = analyzer.compare_theories(&cat_expression);
    println!("ç†è®ºæ¯”è¾ƒ: {:?}", comparison);

    // æµ‹è¯•ä¸åŒç†è®ºçš„æ„ä¹‰åˆ†æ
    let referential_meaning = referential_theory.get_meaning(&cat_expression);
    println!("æŒ‡ç§°è®ºæ„ä¹‰: {:?}", referential_meaning);

    let use_meaning = use_theory.get_meaning(&cat_expression);
    println!("ä½¿ç”¨è®ºæ„ä¹‰: {:?}", use_meaning);
}
```

## 5 å“²å­¦æ€§æ‰¹åˆ¤ä¸å±•æœ›

### 5.1 æœ¬ä½“è®ºåæ€

**æ„ä¹‰çš„æœ¬ä½“è®ºåœ°ä½**ï¼š
æ„ä¹‰æ˜¯ä¸–ç•Œçš„å®¢è§‚ç‰¹å¾ï¼Œè¿˜æ˜¯äººç±»è®¤çŸ¥çš„æ„é€ ï¼Ÿè¿™ä¸ªé—®é¢˜æ¶‰åŠæ„ä¹‰çš„å½¢è€Œä¸Šå­¦åŸºç¡€ã€‚

**æŒ‡ç§°çš„å®åœ¨æ€§**ï¼š
æŒ‡ç§°å…³ç³»æ˜¯å¦åæ˜ äº†ä¸–ç•Œçš„çœŸå®ç»“æ„ï¼Œè¿˜æ˜¯ä»…ä»…æ˜¯è¯­è¨€ä½¿ç”¨çš„çº¦å®šï¼Ÿè¿™ä¸ªé—®é¢˜æ¶‰åŠæŒ‡ç§°çš„å®åœ¨æ€§ã€‚

**æ„ä¹‰çš„å…¬å…±æ€§**ï¼š
æ„ä¹‰æ˜¯å¦å…·æœ‰å…¬å…±æ€§ï¼Œè¿˜æ˜¯ä»…ä»…æ˜¯ç§äººæ€§çš„å¿ƒç†çŠ¶æ€ï¼Ÿè¿™ä¸ªé—®é¢˜æ¶‰åŠæ„ä¹‰çš„æœ¬è´¨ã€‚

### 5.2 è®¤è¯†è®ºæ‰¹åˆ¤

**æ„ä¹‰çŸ¥è¯†çš„è®¤è¯†è®ºæŒ‘æˆ˜**ï¼š
æˆ‘ä»¬å¦‚ä½•çŸ¥é“è¡¨è¾¾å¼çš„æ„ä¹‰ï¼Ÿæ„ä¹‰çŸ¥è¯†çš„åŸºç¡€æ˜¯ä»€ä¹ˆï¼Ÿè¿™äº›é—®é¢˜æ¶‰åŠæ„ä¹‰çŸ¥è¯†çš„è®¤è¯†è®ºã€‚

**æ„ä¹‰çš„ç¡®å®šæ€§**ï¼š
æ„ä¹‰æ˜¯å¦å…·æœ‰ç¡®å®šæ€§ï¼Œè¿˜æ˜¯å…·æœ‰ä¸ç¡®å®šæ€§ï¼Ÿè¿™ä¸ªé—®é¢˜æ¶‰åŠæ„ä¹‰çš„è®¤è¯†è®ºåœ°ä½ã€‚

**æ„ä¹‰çš„å¯å­¦ä¹ æ€§**ï¼š
æ„ä¹‰å¦‚ä½•è¢«å­¦ä¹ ï¼Ÿå­¦ä¹ è¿‡ç¨‹çš„è®¤è¯†è®ºåŸºç¡€æ˜¯ä»€ä¹ˆï¼Ÿè¿™ä¸ªé—®é¢˜æ¶‰åŠæ„ä¹‰å­¦ä¹ çš„è®¤è¯†è®ºã€‚

### 5.3 ç¤¾ä¼šå½±å“åˆ†æ

**æ„ä¹‰ç†è®ºçš„ç¤¾ä¼šä»·å€¼**ï¼š
æ„ä¹‰ç†è®ºä¸ºè¯­è¨€ç†è§£å’Œäº¤æµæä¾›äº†ç†è®ºåŸºç¡€ã€‚å®ƒå¸®åŠ©äººä»¬ç†è§£è¯­è¨€ä½¿ç”¨çš„æœºåˆ¶ã€‚

**æ„ä¹‰ç†è®ºçš„ç¤¾ä¼šè´£ä»»**ï¼š
æ„ä¹‰ç†è®ºçš„å‘å±•éœ€è¦è€ƒè™‘ç¤¾ä¼šå½±å“å’Œä¼¦ç†è´£ä»»ã€‚æ„ä¹‰ç†è®ºåº”è¯¥æœåŠ¡äºäººç±»çš„ç¦ç¥‰ï¼Œè€Œä¸æ˜¯åŠ å‰§ç¤¾ä¼šä¸å¹³ç­‰ã€‚

**æ„ä¹‰ç†è®ºçš„æ°‘ä¸»åŒ–**ï¼š
æ„ä¹‰ç†è®ºåº”è¯¥æ›´åŠ æ°‘ä¸»åŒ–ï¼Œè®©æ›´å¤šäººèƒ½å¤Ÿç†è§£å’Œå‚ä¸è¯­è¨€å“²å­¦çš„è®¨è®ºã€‚

### 5.4 ç»ˆæå“²å­¦å»ºè®®

**å¤šå…ƒæ„ä¹‰ç†è®ºçš„èåˆ**ï¼š
æœªæ¥åº”è¯¥å‘å±•å¤šå…ƒåŒ–çš„æ„ä¹‰ç†è®ºä½“ç³»ï¼Œèåˆä¸åŒå­¦ç§‘å’Œå“²å­¦ä¼ ç»Ÿçš„æ„ä¹‰æ€æƒ³ã€‚éœ€è¦å»ºç«‹è·¨å­¦ç§‘çš„æ„ä¹‰å“²å­¦æ¡†æ¶ã€‚

**æ„ä¹‰ç†è®ºçš„ç”Ÿæ€åŒ–**ï¼š
æ„ä¹‰ç†è®ºåº”è¯¥æ›´åŠ å…³æ³¨ç”Ÿæ€ç³»ç»Ÿçš„æ•´ä½“æ€§ï¼Œå‘å±•ç”Ÿæ€å‹å¥½çš„è¯­è¨€å“²å­¦ã€‚éœ€è¦è€ƒè™‘æ„ä¹‰ç†è®ºçš„ç¯å¢ƒå½±å“ã€‚

**æ„ä¹‰ç†è®ºçš„ä¼¦ç†åŒ–**ï¼š
æ„ä¹‰ç†è®ºçš„å‘å±•åº”è¯¥æ›´åŠ æ³¨é‡ä¼¦ç†è€ƒè™‘ï¼Œç¡®ä¿æ„ä¹‰ç†è®ºå‘å±•ç¬¦åˆäººç±»çš„æ ¹æœ¬åˆ©ç›Šå’Œä»·å€¼è§‚ã€‚

**æ„ä¹‰ç†è®ºçš„å“²å­¦åŒ–**ï¼š
æ„ä¹‰ç†è®ºåº”è¯¥ä¸å“²å­¦æ€è€ƒç›¸ç»“åˆï¼Œå‘å±•å…·æœ‰å“²å­¦æ·±åº¦çš„æ„ä¹‰ç†è®ºä½“ç³»ã€‚

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Frege, G. _On Sense and Reference_. In Translations from the Philosophical Writings of Gottlob Frege, 1952.
2. Russell, B. _On Denoting_. Mind, 1905.
3. Wittgenstein, L. _Philosophical Investigations_. Blackwell, 1953.
4. Davidson, D. _Truth and Meaning_. Synthese, 1967.
5. Grice, H. P. _Meaning_. Philosophical Review, 1957.
6. Kripke, S. _Naming and Necessity_. Harvard University Press, 1980.
7. Putnam, H. _The Meaning of 'Meaning'_. In Mind, Language and Reality, 1975.
8. Dummett, M. _Frege: Philosophy of Language_. Harvard University Press, 1981.
