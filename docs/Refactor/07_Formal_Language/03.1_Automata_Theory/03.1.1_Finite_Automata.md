# 03.1.1 æœ‰é™è‡ªåŠ¨æœº (Finite Automata)

## ğŸ“š æ¦‚è¿°

æœ‰é™è‡ªåŠ¨æœºæ˜¯æœ€ç®€å•çš„è®¡ç®—æ¨¡å‹ï¼Œèƒ½å¤Ÿè¯†åˆ«æ­£åˆ™è¯­è¨€ã€‚å®ƒç”±æœ‰é™æ•°é‡çš„çŠ¶æ€ã€è¾“å…¥ç¬¦å·å’ŒçŠ¶æ€è½¬ç§»è§„åˆ™ç»„æˆï¼Œæ˜¯è‡ªåŠ¨æœºç†è®ºçš„åŸºç¡€ã€‚

## ğŸ” ä¸»è¦ç±»å‹

### ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (DFA)

**å®šä¹‰ 3.1.1** (ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº)
ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š

1. $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†
2. $\Sigma$ æ˜¯æœ‰é™è¾“å…¥å­—æ¯è¡¨
3. $\delta: Q \times \Sigma \to Q$ æ˜¯è½¬ç§»å‡½æ•°
4. $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
5. $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†

**å®šä¹‰ 3.1.2** (DFAçš„æ‰©å±•è½¬ç§»å‡½æ•°)
æ‰©å±•è½¬ç§»å‡½æ•° $\hat{\delta}: Q \times \Sigma^* \to Q$ å®šä¹‰ä¸ºï¼š

1. $\hat{\delta}(q, \varepsilon) = q$
2. $\hat{\delta}(q, wa) = \delta(\hat{\delta}(q, w), a)$

**å®šä¹‰ 3.1.3** (DFAæ¥å—çš„è¯­è¨€)
DFA $M$ æ¥å—çš„è¯­è¨€å®šä¹‰ä¸ºï¼š
$$L(M) = \{w \in \Sigma^* \mid \hat{\delta}(q_0, w) \in F\}$$

**ç‰¹ç‚¹**ï¼š

- ç¡®å®šæ€§ï¼šæ¯ä¸ªçŠ¶æ€å¯¹æ¯ä¸ªè¾“å…¥ç¬¦å·æœ‰å”¯ä¸€çš„è½¬ç§»
- æ— è®°å¿†ï¼šåªä¾èµ–å½“å‰çŠ¶æ€å’Œè¾“å…¥ç¬¦å·
- è®¡ç®—èƒ½åŠ›ï¼šå¯ä»¥è¯†åˆ«æ‰€æœ‰æ­£åˆ™è¯­è¨€

### éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (NFA)

**å®šä¹‰ 3.1.4** (éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº)
éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š

1. $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†
2. $\Sigma$ æ˜¯æœ‰é™è¾“å…¥å­—æ¯è¡¨
3. $\delta: Q \times \Sigma \to 2^Q$ æ˜¯è½¬ç§»å‡½æ•°
4. $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
5. $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†

**å®šä¹‰ 3.1.5** (NFAçš„æ‰©å±•è½¬ç§»å‡½æ•°)
æ‰©å±•è½¬ç§»å‡½æ•° $\hat{\delta}: Q \times \Sigma^* \to 2^Q$ å®šä¹‰ä¸ºï¼š

1. $\hat{\delta}(q, \varepsilon) = \{q\}$
2. $\hat{\delta}(q, wa) = \bigcup_{p \in \hat{\delta}(q, w)} \delta(p, a)$

**å®šä¹‰ 3.1.6** (NFAæ¥å—çš„è¯­è¨€)
NFA $M$ æ¥å—çš„è¯­è¨€å®šä¹‰ä¸ºï¼š
$$L(M) = \{w \in \Sigma^* \mid \hat{\delta}(q_0, w) \cap F \neq \emptyset\}$$

**ç‰¹ç‚¹**ï¼š

- éç¡®å®šæ€§ï¼šä¸€ä¸ªçŠ¶æ€å¯¹ä¸€ä¸ªè¾“å…¥ç¬¦å·å¯èƒ½æœ‰å¤šä¸ªå¯èƒ½çš„è½¬ç§»
- å¹¶è¡Œè®¡ç®—ï¼šå¯ä»¥åŒæ—¶å¤„äºå¤šä¸ªçŠ¶æ€
- è®¡ç®—èƒ½åŠ›ï¼šä¸DFAç­‰ä»·ï¼Œéƒ½è¯†åˆ«æ­£åˆ™è¯­è¨€

### å¸¦Îµ-è½¬ç§»çš„éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (Îµ-NFA)

**å®šä¹‰ 3.1.7** (Îµ-NFA)
Îµ-NFAæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š

1. $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†
2. $\Sigma$ æ˜¯æœ‰é™è¾“å…¥å­—æ¯è¡¨
3. $\delta: Q \times (\Sigma \cup \{\varepsilon\}) \to 2^Q$ æ˜¯è½¬ç§»å‡½æ•°
4. $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
5. $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†

**å®šä¹‰ 3.1.8** (Îµ-é—­åŒ…)
çŠ¶æ€ $q$ çš„Îµ-é—­åŒ… $ECLOSE(q)$ å®šä¹‰ä¸ºï¼š
$$ECLOSE(q) = \{p \in Q \mid q \stackrel{\varepsilon^*}{\Rightarrow} p\}$$
å…¶ä¸­ $\stackrel{\varepsilon^*}{\Rightarrow}$ è¡¨ç¤ºé€šè¿‡é›¶ä¸ªæˆ–å¤šä¸ªÎµ-è½¬ç§»å¯è¾¾ã€‚

**ç‰¹ç‚¹**ï¼š

- ç©ºè½¬ç§»ï¼šå¯ä»¥åœ¨ä¸è¯»å–è¾“å…¥ç¬¦å·çš„æƒ…å†µä¸‹æ”¹å˜çŠ¶æ€
- çµæ´»æ€§ï¼šç®€åŒ–äº†è‡ªåŠ¨æœºçš„æ„é€ 
- è®¡ç®—èƒ½åŠ›ï¼šä¸DFAå’ŒNFAç­‰ä»·

## ğŸ”— ç­‰ä»·æ€§ä¸è½¬æ¢

### DFAä¸NFAçš„ç­‰ä»·æ€§

**å®šç† 3.1.2** (DFAä¸NFAçš„ç­‰ä»·æ€§)
å¯¹äºæ¯ä¸ªNFAï¼Œå­˜åœ¨ç­‰ä»·çš„DFAã€‚

**è¯æ˜**ï¼š
æ„é€ DFA $M' = (Q', \Sigma, \delta', q_0', F')$ï¼Œå…¶ä¸­ï¼š

- $Q' = 2^Q$ï¼ˆNFAçŠ¶æ€é›†çš„å¹‚é›†ï¼‰
- $q_0' = \{q_0\}$
- $F' = \{S \subseteq Q \mid S \cap F \neq \emptyset\}$
- $\delta'(S, a) = \bigcup_{q \in S} \delta(q, a)$

å¯ä»¥è¯æ˜ï¼Œå¯¹äºä»»æ„è¾“å…¥ä¸² $w$ï¼Œ$\hat{\delta}'(q_0', w) = \hat{\delta}(q_0, w)$ï¼Œå› æ­¤ $L(M') = L(M)$ã€‚

### Îµ-NFAä¸NFAçš„ç­‰ä»·æ€§

**å®šç† 3.1.3** (Îµ-NFAä¸NFAçš„ç­‰ä»·æ€§)
å¯¹äºæ¯ä¸ªÎµ-NFAï¼Œå­˜åœ¨ç­‰ä»·çš„NFAã€‚

**è¯æ˜**ï¼š
æ„é€ NFA $M' = (Q, \Sigma, \delta', q_0, F')$ï¼Œå…¶ä¸­ï¼š

- $\delta'(q, a) = \bigcup_{p \in ECLOSE(q)} \bigcup_{r \in \delta(p, a)} ECLOSE(r)$
- $F' = \{q \in Q \mid ECLOSE(q) \cap F \neq \emptyset\}$

å¯ä»¥è¯æ˜ $L(M') = L(M)$ã€‚

## ğŸ“Š æ­£åˆ™è¯­è¨€çš„æ€§è´¨

### å°é—­æ€§

**å®šç† 3.1.4** (æœ‰é™è‡ªåŠ¨æœºçš„å°é—­æ€§)
æ­£åˆ™è¯­è¨€åœ¨ä»¥ä¸‹è¿ç®—ä¸‹å°é—­ï¼š

1. å¹¶é›†
2. äº¤é›†
3. è¡¥é›†
4. è¿æ¥
5. å…‹æ—é—­åŒ…

**è¯æ˜**ï¼š
å¯ä»¥é€šè¿‡æ„é€ ç›¸åº”çš„è‡ªåŠ¨æœºæ¥è¯æ˜è¿™äº›å°é—­æ€§ã€‚ä¾‹å¦‚ï¼Œå¯¹äºä¸¤ä¸ªæ­£åˆ™è¯­è¨€ $L_1$ å’Œ $L_2$ï¼Œå¯ä»¥æ„é€ è¯†åˆ« $L_1 \cup L_2$ çš„NFAï¼Œç„¶åè½¬æ¢ä¸ºDFAã€‚

### æ³µå¼•ç†

**å®šç† 3.1.5** (æ­£åˆ™è¯­è¨€æ³µå¼•ç†)
å¦‚æœ $L$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œé‚£ä¹ˆå­˜åœ¨å¸¸æ•° $n$ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰ $w \in L$ ä¸” $|w| \geq n$ï¼Œå­˜åœ¨åˆ†è§£ $w = xyz$ï¼Œæ»¡è¶³ï¼š

1. $|xy| \leq n$
2. $|y| > 0$
3. å¯¹äºæ‰€æœ‰ $i \geq 0$ï¼Œ$xy^iz \in L$

**è¯æ˜**ï¼š
è®¾ $M = (Q, \Sigma, \delta, q_0, F)$ æ˜¯è¯†åˆ« $L$ çš„DFAï¼Œä»¤ $n = |Q|$ã€‚

å¯¹äºä»»æ„ $w \in L$ ä¸” $|w| \geq n$ï¼Œè€ƒè™‘ $M$ åœ¨å¤„ç† $w$ æ—¶çš„çŠ¶æ€åºåˆ—ï¼š
$$q_0 \stackrel{w_1}{\to} q_1 \stackrel{w_2}{\to} \cdots \stackrel{w_n}{\to} q_n \stackrel{w_{n+1}}{\to} \cdots \stackrel{w_m}{\to} q_m$$

ç”±äº $|Q| = n$ï¼Œæ ¹æ®é¸½å·¢åŸç†ï¼Œåœ¨å‰ $n+1$ ä¸ªçŠ¶æ€ä¸­å¿…æœ‰ä¸¤ä¸ªç›¸åŒï¼Œè®¾ä¸º $q_i = q_j$ï¼ˆ$i < j \leq n$ï¼‰ã€‚

ä»¤ $x = w_1 \cdots w_i$ï¼Œ$y = w_{i+1} \cdots w_j$ï¼Œ$z = w_{j+1} \cdots w_m$ï¼Œåˆ™ï¼š

- $|xy| = j \leq n$
- $|y| = j - i > 0$
- å¯¹äºä»»æ„ $k \geq 0$ï¼Œ$xy^kz \in L$

**åº”ç”¨**ï¼šæ³µå¼•ç†å¸¸ç”¨äºè¯æ˜æŸä¸ªè¯­è¨€ä¸æ˜¯æ­£åˆ™è¯­è¨€ã€‚

**ä¾‹ 3.1.1**ï¼šè¯æ˜ $L = \{a^nb^n \mid n \geq 0\}$ ä¸æ˜¯æ­£åˆ™è¯­è¨€ã€‚

**è¯æ˜**ï¼šå‡è®¾ $L$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œè®¾æ³µå¼•ç†å¸¸æ•°ä¸º $n$ã€‚è€ƒè™‘å­—ç¬¦ä¸² $w = a^nb^n$ã€‚

æ ¹æ®æ³µå¼•ç†ï¼Œå­˜åœ¨åˆ†è§£ $w = xyz$ï¼Œå…¶ä¸­ $|xy| \leq n$ï¼Œ$|y| > 0$ï¼Œä¸” $xy^iz \in L$ å¯¹æ‰€æœ‰ $i \geq 0$ æˆç«‹ã€‚

ç”±äº $|xy| \leq n$ï¼Œ$y$ åªèƒ½åŒ…å« $a$ã€‚è®¾ $y = a^k$ï¼ˆ$k > 0$ï¼‰ï¼Œåˆ™ $xy^2z = a^{n+k}b^n \notin L$ï¼ŒçŸ›ç›¾ã€‚

å› æ­¤ $L$ ä¸æ˜¯æ­£åˆ™è¯­è¨€ã€‚

## ğŸ”„ ä¸æ­£åˆ™è¡¨è¾¾å¼çš„ç­‰ä»·æ€§

**å®šç† 3.1.6** (å…‹æ—å®šç†)
ä¸€ä¸ªè¯­è¨€æ˜¯æ­£åˆ™çš„ï¼Œå½“ä¸”ä»…å½“å®ƒå¯ä»¥è¢«æ­£åˆ™è¡¨è¾¾å¼è¡¨ç¤ºã€‚

**è¯æ˜**ï¼š

1. ä»æ­£åˆ™è¡¨è¾¾å¼åˆ°Îµ-NFAï¼šå¯ä»¥ä¸ºæ¯ä¸ªæ­£åˆ™è¡¨è¾¾å¼æ„é€ ç­‰ä»·çš„Îµ-NFA
2. ä»Îµ-NFAåˆ°æ­£åˆ™è¡¨è¾¾å¼ï¼šå¯ä»¥é€šè¿‡çŠ¶æ€æ¶ˆé™¤æ³•å°†Îµ-NFAè½¬æ¢ä¸ºç­‰ä»·çš„æ­£åˆ™è¡¨è¾¾å¼

## ğŸ’» Rustå®ç°

### DFAå®ç°

```rust
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct State(String);

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Symbol(char);

pub struct DFA {
    states: HashSet<State>,
    alphabet: HashSet<Symbol>,
    transitions: HashMap<(State, Symbol), State>,
    initial_state: State,
    accepting_states: HashSet<State>,
}

impl DFA {
    pub fn new(
        states: HashSet<State>,
        alphabet: HashSet<Symbol>,
        transitions: HashMap<(State, Symbol), State>,
        initial_state: State,
        accepting_states: HashSet<State>,
    ) -> Self {
        DFA {
            states,
            alphabet,
            transitions,
            initial_state,
            accepting_states,
        }
    }

    pub fn accepts(&self, input: &str) -> bool {
        let mut current_state = self.initial_state.clone();
        
        for c in input.chars() {
            let symbol = Symbol(c);
            if let Some(&next_state) = self.transitions.get(&(current_state.clone(), symbol)) {
                current_state = next_state.clone();
            } else {
                return false; // æ— è½¬ç§»ï¼Œæ‹’ç»
            }
        }
        
        self.accepting_states.contains(&current_state)
    }

    pub fn minimize(&self) -> DFA {
        // å®ç°DFAæœ€å°åŒ–ç®—æ³•
        // 1. ç§»é™¤ä¸å¯è¾¾çŠ¶æ€
        // 2. åˆå¹¶ç­‰ä»·çŠ¶æ€
        // 3. é‡æ–°æ ‡è®°çŠ¶æ€
        unimplemented!("DFAæœ€å°åŒ–ç®—æ³•")
    }
}
```

### NFAå®ç°

```rust
pub struct NFA {
    states: HashSet<State>,
    alphabet: HashSet<Symbol>,
    transitions: HashMap<(State, Symbol), HashSet<State>>,
    initial_state: State,
    accepting_states: HashSet<State>,
}

impl NFA {
    pub fn new(
        states: HashSet<State>,
        alphabet: HashSet<Symbol>,
        transitions: HashMap<(State, Symbol), HashSet<State>>,
        initial_state: State,
        accepting_states: HashSet<State>,
    ) -> Self {
        NFA {
            states,
            alphabet,
            transitions,
            initial_state,
            accepting_states,
        }
    }

    pub fn accepts(&self, input: &str) -> bool {
        let mut current_states = HashSet::new();
        current_states.insert(self.initial_state.clone());
        
        for c in input.chars() {
            let symbol = Symbol(c);
            let mut next_states = HashSet::new();
            
            for state in &current_states {
                if let Some(targets) = self.transitions.get(&(state.clone(), symbol)) {
                    next_states.extend(targets.clone());
                }
            }
            
            if next_states.is_empty() {
                return false; // æ— è½¬ç§»ï¼Œæ‹’ç»
            }
            
            current_states = next_states;
        }
        
        current_states.iter().any(|s| self.accepting_states.contains(s))
    }

    pub fn to_dfa(&self) -> DFA {
        // å­é›†æ„é€ æ³•ï¼šå°†NFAè½¬æ¢ä¸ºç­‰ä»·çš„DFA
        let mut dfa_states = HashSet::new();
        let mut dfa_transitions = HashMap::new();
        let mut dfa_accepting_states = HashSet::new();
        
        // åˆå§‹çŠ¶æ€
        let initial_dfa_state = HashSet::from([self.initial_state.clone()]);
        dfa_states.insert(initial_dfa_state.clone());
        
        // å·¥ä½œé˜Ÿåˆ—
        let mut queue = vec![initial_dfa_state.clone()];
        let mut processed = HashSet::new();
        
        while let Some(current_dfa_state) = queue.pop() {
            if processed.contains(&current_dfa_state) {
                continue;
            }
            processed.insert(current_dfa_state.clone());
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºæ¥å—çŠ¶æ€
            if current_dfa_state.iter().any(|s| self.accepting_states.contains(s)) {
                dfa_accepting_states.insert(current_dfa_state.clone());
            }
            
            // ä¸ºæ¯ä¸ªè¾“å…¥ç¬¦å·è®¡ç®—è½¬ç§»
            for symbol in &self.alphabet {
                let mut next_states = HashSet::new();
                
                for nfa_state in &current_dfa_state {
                    if let Some(targets) = self.transitions.get(&(nfa_state.clone(), symbol.clone())) {
                        next_states.extend(targets.clone());
                    }
                }
                
                if !next_states.is_empty() {
                    dfa_states.insert(next_states.clone());
                    dfa_transitions.insert((current_dfa_state.clone(), symbol.clone()), next_states.clone());
                    
                    if !processed.contains(&next_states) {
                        queue.push(next_states);
                    }
                }
            }
        }
        
        DFA::new(
            dfa_states,
            self.alphabet.clone(),
            dfa_transitions,
            initial_dfa_state,
            dfa_accepting_states,
        )
    }
}
```

### æ­£åˆ™è¡¨è¾¾å¼å¼•æ“

```rust
pub struct RegexEngine {
    nfa: NFA,
}

impl RegexEngine {
    pub fn new(pattern: &str) -> Result<Self, RegexError> {
        // å°†æ­£åˆ™è¡¨è¾¾å¼è§£æä¸ºè¯­æ³•æ ‘
        let ast = RegexParser::parse(pattern)?;
        
        // å°†è¯­æ³•æ ‘è½¬æ¢ä¸ºNFA
        let nfa = ast.to_nfa();
        
        Ok(RegexEngine { nfa })
    }
    
    pub fn matches(&self, text: &str) -> bool {
        self.nfa.accepts(text)
    }
    
    pub fn find_all(&self, text: &str) -> Vec<Match> {
        let mut matches = Vec::new();
        let mut start = 0;
        
        while start < text.len() {
            if let Some((end, matched_text)) = self.find_match_at(text, start) {
                matches.push(Match {
                    start,
                    end,
                    text: matched_text.to_string(),
                });
                start = end;
            } else {
                start += 1;
            }
        }
        
        matches
    }
    
    fn find_match_at(&self, text: &str, start: usize) -> Option<(usize, &str)> {
        // åœ¨æŒ‡å®šä½ç½®æŸ¥æ‰¾åŒ¹é…
        for end in start..=text.len() {
            let substring = &text[start..end];
            if self.nfa.accepts(substring) {
                return Some((end, substring));
            }
        }
        None
    }
}

#[derive(Debug)]
pub struct Match {
    pub start: usize,
    pub end: usize,
    pub text: String,
}
```

## ğŸ› ï¸ åº”ç”¨

### 1. è¯æ³•åˆ†æ

æœ‰é™è‡ªåŠ¨æœºåœ¨ç¼–è¯‘å™¨ä¸­ç”¨äºæ ‡è®°è¯†åˆ«ï¼š

```rust
pub struct Lexer {
    dfa: DFA,
    source: String,
    position: usize,
}

impl Lexer {
    pub fn new(dfa: DFA, source: String) -> Self {
        Lexer {
            dfa,
            source,
            position: 0,
        }
    }

    pub fn next_token(&mut self) -> Option<Token> {
        let mut current_state = self.dfa.initial_state.clone();
        let start_pos = self.position;
        
        while self.position < self.source.len() {
            let current_char = self.source.chars().nth(self.position).unwrap();
            let symbol = Symbol(current_char);
            
            if let Some(&next_state) = self.dfa.transitions.get(&(current_state.clone(), symbol)) {
                current_state = next_state;
                self.position += 1;
            } else {
                break;
            }
        }
        
        if self.dfa.accepting_states.contains(&current_state) {
            let lexeme = &self.source[start_pos..self.position];
            Some(Token::new(self.get_token_type(&current_state), lexeme.to_string()))
        } else {
            None
        }
    }
    
    fn get_token_type(&self, state: &State) -> TokenType {
        // æ ¹æ®çŠ¶æ€ç¡®å®šæ ‡è®°ç±»å‹
        match state.0.as_str() {
            "IDENTIFIER" => TokenType::Identifier,
            "NUMBER" => TokenType::Number,
            "STRING" => TokenType::String,
            "KEYWORD" => TokenType::Keyword,
            _ => TokenType::Unknown,
        }
    }
}

#[derive(Debug)]
pub enum TokenType {
    Identifier,
    Number,
    String,
    Keyword,
    Unknown,
}

#[derive(Debug)]
pub struct Token {
    pub token_type: TokenType,
    pub lexeme: String,
}

impl Token {
    pub fn new(token_type: TokenType, lexeme: String) -> Self {
        Token { token_type, lexeme }
    }
}
```

### 2. æ¨¡å¼åŒ¹é…

ç”¨äºå­—ç¬¦ä¸²æœç´¢å’Œæ­£åˆ™è¡¨è¾¾å¼å®ç°ï¼š

```rust
pub struct PatternMatcher {
    dfa: DFA,
}

impl PatternMatcher {
    pub fn new(pattern: &str) -> Result<Self, PatternError> {
        // å°†æ¨¡å¼è½¬æ¢ä¸ºDFA
        let nfa = pattern_to_nfa(pattern)?;
        let dfa = nfa.to_dfa();
        
        Ok(PatternMatcher { dfa })
    }
    
    pub fn find(&self, text: &str) -> Option<usize> {
        for start in 0..text.len() {
            if self.matches_at(text, start) {
                return Some(start);
            }
        }
        None
    }
    
    pub fn matches_at(&self, text: &str, start: usize) -> bool {
        let mut current_state = self.dfa.initial_state.clone();
        
        for i in start..text.len() {
            let c = text.chars().nth(i).unwrap();
            let symbol = Symbol(c);
            
            if let Some(&next_state) = self.dfa.transitions.get(&(current_state.clone(), symbol)) {
                current_state = next_state;
            } else {
                return false;
            }
        }
        
        self.dfa.accepting_states.contains(&current_state)
    }
}
```

### 3. åè®®éªŒè¯

éªŒè¯é€šä¿¡åè®®çš„æ­£ç¡®æ€§ï¼š

```rust
pub struct ProtocolValidator {
    protocol_dfa: DFA,
}

impl ProtocolValidator {
    pub fn new(protocol_spec: &str) -> Result<Self, ProtocolError> {
        // ä»åè®®è§„èŒƒæ„é€ DFA
        let dfa = protocol_spec_to_dfa(protocol_spec)?;
        Ok(ProtocolValidator { protocol_dfa: dfa })
    }
    
    pub fn validate_sequence(&self, sequence: &str) -> ValidationResult {
        if self.protocol_dfa.accepts(sequence) {
            ValidationResult::Valid
        } else {
            ValidationResult::Invalid("åè®®åºåˆ—ä¸ç¬¦åˆè§„èŒƒ".to_string())
        }
    }
    
    pub fn find_violations(&self, sequence: &str) -> Vec<Violation> {
        let mut violations = Vec::new();
        let mut current_state = self.protocol_dfa.initial_state.clone();
        
        for (i, c) in sequence.chars().enumerate() {
            let symbol = Symbol(c);
            
            if let Some(&next_state) = self.protocol_dfa.transitions.get(&(current_state.clone(), symbol)) {
                current_state = next_state;
            } else {
                violations.push(Violation {
                    position: i,
                    message: format!("åœ¨ä½ç½® {} å¤„å‘ç°æ— æ•ˆè½¬ç§»", i),
                });
                break;
            }
        }
        
        if !self.protocol_dfa.accepting_states.contains(&current_state) {
            violations.push(Violation {
                position: sequence.len(),
                message: "åºåˆ—æœªåœ¨æœ‰æ•ˆçŠ¶æ€ç»“æŸ".to_string(),
            });
        }
        
        violations
    }
}

#[derive(Debug)]
pub enum ValidationResult {
    Valid,
    Invalid(String),
}

#[derive(Debug)]
pub struct Violation {
    pub position: usize,
    pub message: String,
}
```

### 4. æ•°å­—ç”µè·¯è®¾è®¡

çŠ¶æ€æœºåœ¨ç¡¬ä»¶è®¾è®¡ä¸­çš„åº”ç”¨ï¼š

```rust
pub struct StateMachine {
    current_state: State,
    transitions: HashMap<(State, Symbol), State>,
    outputs: HashMap<State, Vec<bool>>,
}

impl StateMachine {
    pub fn new(
        initial_state: State,
        transitions: HashMap<(State, Symbol), State>,
        outputs: HashMap<State, Vec<bool>>,
    ) -> Self {
        StateMachine {
            current_state: initial_state,
            transitions,
            outputs,
        }
    }
    
    pub fn step(&mut self, input: Symbol) -> Option<Vec<bool>> {
        if let Some(&next_state) = self.transitions.get(&(self.current_state.clone(), input)) {
            self.current_state = next_state;
            self.outputs.get(&self.current_state).cloned()
        } else {
            None
        }
    }
    
    pub fn get_current_state(&self) -> &State {
        &self.current_state
    }
    
    pub fn reset(&mut self, initial_state: State) {
        self.current_state = initial_state;
    }
}
```

## ğŸ”— ç›¸å…³å†…å®¹

- [03.2.1 æ­£åˆ™æ–‡æ³•](../03.2_Formal_Grammars/03.2.1_Regular_Grammar.md) - ä¸æœ‰é™è‡ªåŠ¨æœºç­‰ä»·çš„æ–‡æ³•
- [03.3.1 ä¹”å§†æ–¯åŸºè°±ç³»](../03.3_Language_Hierarchy/03.3.1_Chomsky_Hierarchy.md) - æ­£åˆ™è¯­è¨€åœ¨è¯­è¨€å±‚æ¬¡ä¸­çš„ä½ç½®
- [03.1.2 ä¸‹æ¨è‡ªåŠ¨æœº](./03.1.2_Pushdown_Automata.md) - æ¯”æœ‰é™è‡ªåŠ¨æœºæ›´å¼ºå¤§çš„è®¡ç®—æ¨¡å‹

---

**æ›´æ–°æ—¶é—´**: 2025-01-16  
**ç‰ˆæœ¬**: 3.0  
**çŠ¶æ€**: å·²å®Œæˆï¼ˆåŒ…å«æ³µå¼•ç†ã€Rustå®ç°ã€è¯¦ç»†åº”ç”¨æ¡ˆä¾‹ï¼‰
