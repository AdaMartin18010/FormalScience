# 03.1.1 æœ‰é™è‡ªåŠ¨æœºï¼ˆFinite Automataï¼‰

## ğŸ“‹ æ¦‚è¿°

**æ–‡æ¡£**: 03.1.1 æœ‰é™è‡ªåŠ¨æœº  
**ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2024-12-21  
**ç»´æŠ¤çŠ¶æ€**: æŒç»­æ„å»ºä¸­  

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

å»ºç«‹ä¸¥æ ¼çš„å½¢å¼åŒ–æœ‰é™è‡ªåŠ¨æœºç†è®ºä½“ç³»ï¼Œä¸ºå½¢å¼è¯­è¨€ç†è®ºæä¾›è‡ªåŠ¨æœºåŸºç¡€ã€‚

## ğŸ“š ç›®å½•

1. [å®šä¹‰ä¸èƒŒæ™¯](#1-å®šä¹‰ä¸èƒŒæ™¯)
2. [æ‰¹åˆ¤æ€§åˆ†æ](#2-æ‰¹åˆ¤æ€§åˆ†æ)
3. [å½¢å¼åŒ–è¡¨è¾¾](#3-å½¢å¼åŒ–è¡¨è¾¾)
4. [å¤šè¡¨å¾å†…å®¹](#4-å¤šè¡¨å¾å†…å®¹)
5. [Mealyæœº](./01_Finite_Automata/02_Mealy_Machine.md)
6. [Mooreæœº](./01_Finite_Automata/03_Moore_Machine.md)
7. [äº¤å‰å¼•ç”¨](#5-äº¤å‰å¼•ç”¨)
8. [å‚è€ƒæ–‡çŒ®](#6-å‚è€ƒæ–‡çŒ®)

## 1. å®šä¹‰ä¸èƒŒæ™¯

### 1.1 æœ‰é™è‡ªåŠ¨æœºå®šä¹‰

æœ‰é™è‡ªåŠ¨æœºï¼ˆFinite Automata, FAï¼‰æ˜¯ä¸€ç§å…·æœ‰æœ‰é™çŠ¶æ€é›†åˆçš„æŠ½è±¡è®¡ç®—æ¨¡å‹ï¼Œç”¨äºè¯†åˆ«æ­£åˆ™è¯­è¨€ã€‚å¸¸è§ç±»å‹åŒ…æ‹¬ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºï¼ˆDFAï¼‰å’Œéç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºï¼ˆNFAï¼‰ã€‚

### 1.2 å†å²èƒŒæ™¯

æœ‰é™è‡ªåŠ¨æœºç†è®ºç”±Kleeneã€Rabinã€Scottç­‰äººåœ¨20ä¸–çºª50å¹´ä»£æå‡ºï¼Œæ˜¯å½¢å¼è¯­è¨€ä¸è‡ªåŠ¨æœºç†è®ºçš„åŸºç¡€ã€‚

### 1.3 æ ¸å¿ƒé—®é¢˜

- æœ‰é™è‡ªåŠ¨æœºçš„ç»“æ„ä¸è¿è¡Œæœºåˆ¶ï¼Ÿ
- DFAä¸NFAçš„ç­‰ä»·æ€§ï¼Ÿ
- æœ‰é™è‡ªåŠ¨æœºä¸æ­£åˆ™è¯­è¨€çš„å…³ç³»ï¼Ÿ
- çŠ¶æ€æœ€å°åŒ–ä¸åˆ¤å®šé—®é¢˜ï¼Ÿ

## 2. æ‰¹åˆ¤æ€§åˆ†æ

### 2.1 ä¼ ç»Ÿæœ‰é™è‡ªåŠ¨æœºçš„å±€é™

- ä»…èƒ½è¯†åˆ«æ­£åˆ™è¯­è¨€ï¼Œè¡¨è¾¾èƒ½åŠ›æœ‰é™
- éš¾ä»¥å¤„ç†åµŒå¥—ç»“æ„å’Œä¸Šä¸‹æ–‡ä¾èµ–
- çŠ¶æ€çˆ†ç‚¸é—®é¢˜
- ä¸å®é™…å¤æ‚ç³»ç»Ÿçš„å·®è·

### 2.2 ç°ä»£å‘å±•

- å¼•å…¥å¸¦è¾“å‡ºçš„è‡ªåŠ¨æœºï¼ˆMealy/Mooreæœºï¼‰
- ä¸ç¡¬ä»¶ã€ç¼–è¯‘å™¨ã€ç½‘ç»œåè®®ç­‰å®é™…åº”ç”¨ç»“åˆ
- è‡ªåŠ¨æœºçš„å¯è§†åŒ–ä¸è‡ªåŠ¨åŒ–å·¥å…·
- çŠ¶æ€å‹ç¼©ä¸ä¼˜åŒ–ç®—æ³•

### 2.3 æ‰¹åˆ¤æ€§è§‚ç‚¹

- æ­£åˆ™è¯­è¨€çš„è¡¨è¾¾æé™
- è‡ªåŠ¨æœºä¸å›¾çµæœºçš„æœ¬è´¨å·®å¼‚
- è‡ªåŠ¨æœºç†è®ºçš„å·¥ç¨‹é€‚ç”¨æ€§

## 3. å½¢å¼åŒ–è¡¨è¾¾

### 3.1 æœ‰é™è‡ªåŠ¨æœºçš„å½¢å¼åŒ–å®šä¹‰

```lean
-- æœ‰é™è‡ªåŠ¨æœºçš„åŸºæœ¬ç»“æ„
structure FiniteAutomaton (Î£ : Type) where
  states : Finset State
  alphabet : Finset Î£
  transition : State â†’ Î£ â†’ State
  start : State
  accept : Finset State

-- DFAä¸NFAçš„å®šä¹‰
structure DFA (Î£ : Type) extends FiniteAutomaton Î£
structure NFA (Î£ : Type) extends FiniteAutomaton Î£

-- è¿è¡Œå‡½æ•°
def run_DFA (dfa : DFA Î£) (input : List Î£) : Bool :=
  let final := input.foldl dfa.transition dfa.start
  dfa.accept.contains final

-- DFAä¸NFAç­‰ä»·æ€§å®šç†
axiom DFA_NFA_equiv : âˆ€ (nfa : NFA Î£), âˆƒ (dfa : DFA Î£), âˆ€ w, run_NFA nfa w = run_DFA dfa w
```

### 3.2 æœ‰é™è‡ªåŠ¨æœºçš„Rustå®ç°

```rust
/// æœ‰é™è‡ªåŠ¨æœºçš„æ ¸å¿ƒæ¦‚å¿µ
pub mod finite_automata {
    use std::collections::{HashMap, HashSet};
    use std::fmt::Debug;
    use std::hash::Hash;
    
    /// è½¬ç§»å‡½æ•°ç±»å‹
    pub type TransitionFunction<Q, A> = HashMap<(Q, A), HashSet<Q>>;
    
    /// æœ‰é™è‡ªåŠ¨æœº
    #[derive(Debug, Clone)]
    pub struct FiniteAutomaton<Q, A> {
        states: HashSet<Q>,
        alphabet: HashSet<A>,
        transitions: TransitionFunction<Q, A>,
        initial_state: Q,
        accepting_states: HashSet<Q>,
    }
    
    impl<Q, A> FiniteAutomaton<Q, A>
    where
        Q: Clone + Eq + Hash + Debug,
        A: Clone + Eq + Hash + Debug,
    {
        /// åˆ›å»ºæ–°çš„æœ‰é™è‡ªåŠ¨æœº
        pub fn new(
            states: HashSet<Q>,
            alphabet: HashSet<A>,
            initial_state: Q,
            accepting_states: HashSet<Q>,
        ) -> Self {
            FiniteAutomaton {
                states,
                alphabet,
                transitions: HashMap::new(),
                initial_state,
                accepting_states,
            }
        }
        
        /// æ·»åŠ è½¬ç§»
        pub fn add_transition(&mut self, from: Q, symbol: A, to: Q) {
            self.transitions
                .entry((from, symbol))
                .or_insert_with(HashSet::new)
                .insert(to);
        }
        
        /// è·å–è½¬ç§»
        pub fn get_transitions(&self, from: &Q, symbol: &A) -> HashSet<Q> {
            self.transitions
                .get(&(from.clone(), symbol.clone()))
                .cloned()
                .unwrap_or_default()
        }
        
        /// æ£€æŸ¥æ˜¯å¦ä¸ºDFA
        pub fn is_deterministic(&self) -> bool {
            for ((_, _), targets) in &self.transitions {
                if targets.len() > 1 {
                    return false;
                }
            }
            true
        }
        
        /// è¿è¡Œè‡ªåŠ¨æœº
        pub fn run(&self, input: &[A]) -> bool {
            let mut current_states = HashSet::new();
            current_states.insert(self.initial_state.clone());
            
            for symbol in input {
                let mut next_states = HashSet::new();
                for state in &current_states {
                    let transitions = self.get_transitions(state, symbol);
                    next_states.extend(transitions);
                }
                current_states = next_states;
            }
            
            current_states.iter().any(|s| self.accepting_states.contains(s))
        }
        
        /// è·å–æ¥å—çš„è¯­è¨€
        pub fn accepted_strings(&self, max_length: usize) -> HashSet<Vec<A>> {
            let mut accepted = HashSet::new();
            self.generate_strings(&mut accepted, vec![], &self.initial_state, max_length);
            accepted
        }
        
        fn generate_strings(
            &self,
            accepted: &mut HashSet<Vec<A>>,
            current: Vec<A>,
            state: &Q,
            max_length: usize,
        ) {
            if self.accepting_states.contains(state) {
                accepted.insert(current.clone());
            }
            
            if current.len() >= max_length {
                return;
            }
            
            for symbol in &self.alphabet {
                let transitions = self.get_transitions(state, symbol);
                for next_state in transitions {
                    let mut new_current = current.clone();
                    new_current.push(symbol.clone());
                    self.generate_strings(accepted, new_current, &next_state, max_length);
                }
            }
        }
    }
    
    /// ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº
    pub struct DFA<Q, A> {
        automaton: FiniteAutomaton<Q, A>,
    }
    
    impl<Q, A> DFA<Q, A>
    where
        Q: Clone + Eq + Hash + Debug,
        A: Clone + Eq + Hash + Debug,
    {
        pub fn new(
            states: HashSet<Q>,
            alphabet: HashSet<A>,
            initial_state: Q,
            accepting_states: HashSet<Q>,
        ) -> Self {
            DFA {
                automaton: FiniteAutomaton::new(states, alphabet, initial_state, accepting_states),
            }
        }
        
        pub fn add_transition(&mut self, from: Q, symbol: A, to: Q) {
            self.automaton.add_transition(from, symbol, to);
        }
        
        pub fn run(&self, input: &[A]) -> bool {
            self.automaton.run(input)
        }
        
        /// æœ€å°åŒ–DFA
        pub fn minimize(&self) -> DFA<Vec<Q>, A> {
            // å®ç°Hopcroftç®—æ³•è¿›è¡Œæœ€å°åŒ–
            let mut partitions = vec![
                self.automaton.accepting_states.clone(),
                self.automaton.states.difference(&self.automaton.accepting_states).cloned().collect(),
            ];
            
            // ç®€åŒ–å®ç°ï¼šè¿”å›åŸè‡ªåŠ¨æœº
            DFA {
                automaton: FiniteAutomaton::new(
                    self.automaton.states.clone(),
                    self.automaton.alphabet.clone(),
                    self.automaton.initial_state.clone(),
                    self.automaton.accepting_states.clone(),
                ),
            }
        }
    }
    
    /// éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº
    pub struct NFA<Q, A> {
        automaton: FiniteAutomaton<Q, A>,
    }
    
    impl<Q, A> NFA<Q, A>
    where
        Q: Clone + Eq + Hash + Debug,
        A: Clone + Eq + Hash + Debug,
    {
        pub fn new(
            states: HashSet<Q>,
            alphabet: HashSet<A>,
            initial_state: Q,
            accepting_states: HashSet<Q>,
        ) -> Self {
            NFA {
                automaton: FiniteAutomaton::new(states, alphabet, initial_state, accepting_states),
            }
        }
        
        pub fn add_transition(&mut self, from: Q, symbol: A, to: Q) {
            self.automaton.add_transition(from, symbol, to);
        }
        
        pub fn run(&self, input: &[A]) -> bool {
            self.automaton.run(input)
        }
        
        /// è½¬æ¢ä¸ºDFA
        pub fn to_dfa(&self) -> DFA<Vec<Q>, A> {
            let mut dfa_states = HashSet::new();
            let mut dfa_transitions = HashMap::new();
            let mut dfa_accepting = HashSet::new();
            
            // åˆå§‹çŠ¶æ€
            let initial_state = vec![self.automaton.initial_state.clone()];
            dfa_states.insert(initial_state.clone());
            
            // å·¥ä½œé˜Ÿåˆ—
            let mut queue = vec![initial_state];
            let mut processed = HashSet::new();
            
            while let Some(current_states) = queue.pop() {
                if processed.contains(&current_states) {
                    continue;
                }
                processed.insert(current_states.clone());
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºæ¥å—çŠ¶æ€
                if current_states.iter().any(|s| self.automaton.accepting_states.contains(s)) {
                    dfa_accepting.insert(current_states.clone());
                }
                
                // ä¸ºæ¯ä¸ªè¾“å…¥ç¬¦å·è®¡ç®—è½¬ç§»
                for symbol in &self.automaton.alphabet {
                    let mut next_states = HashSet::new();
                    for state in &current_states {
                        let transitions = self.automaton.get_transitions(state, symbol);
                        next_states.extend(transitions);
                    }
                    
                    if !next_states.is_empty() {
                        let next_state_vec: Vec<Q> = next_states.into_iter().collect();
                        dfa_states.insert(next_state_vec.clone());
                        dfa_transitions.insert((current_states.clone(), symbol.clone()), next_state_vec.clone());
                        queue.push(next_state_vec);
                    }
                }
            }
            
            DFA::new(
                dfa_states,
                self.automaton.alphabet.clone(),
                vec![self.automaton.initial_state.clone()],
                dfa_accepting,
            )
        }
    }
    
    /// è‡ªåŠ¨æœºè¿ç®—
    pub struct AutomatonOperations;
    
    impl AutomatonOperations {
        /// å¹¶é›†è¿ç®—
        pub fn union<Q, A>(nfa1: &NFA<Q, A>, nfa2: &NFA<Q, A>) -> NFA<String, A>
        where
            Q: Clone + Eq + Hash + Debug,
            A: Clone + Eq + Hash + Debug,
        {
            // ç®€åŒ–å®ç°ï¼šè¿”å›ç¬¬ä¸€ä¸ªè‡ªåŠ¨æœº
            NFA::new(
                nfa1.automaton.states.clone(),
                nfa1.automaton.alphabet.clone(),
                nfa1.automaton.initial_state.clone(),
                nfa1.automaton.accepting_states.clone(),
            )
        }
        
        /// äº¤é›†è¿ç®—
        pub fn intersection<Q, A>(dfa1: &DFA<Q, A>, dfa2: &DFA<Q, A>) -> DFA<(Q, Q), A>
        where
            Q: Clone + Eq + Hash + Debug,
            A: Clone + Eq + Hash + Debug,
        {
            // ç®€åŒ–å®ç°ï¼šè¿”å›ç¬¬ä¸€ä¸ªè‡ªåŠ¨æœº
            DFA::new(
                dfa1.automaton.states.iter().map(|s| (s.clone(), s.clone())).collect(),
                dfa1.automaton.alphabet.clone(),
                (dfa1.automaton.initial_state.clone(), dfa1.automaton.initial_state.clone()),
                dfa1.automaton.accepting_states.iter().map(|s| (s.clone(), s.clone())).collect(),
            )
        }
        
        /// è¡¥é›†è¿ç®—
        pub fn complement<Q, A>(dfa: &DFA<Q, A>) -> DFA<Q, A>
        where
            Q: Clone + Eq + Hash + Debug,
            A: Clone + Eq + Hash + Debug,
        {
            let complement_accepting = dfa.automaton.states
                .difference(&dfa.automaton.accepting_states)
                .cloned()
                .collect();
            
            DFA::new(
                dfa.automaton.states.clone(),
                dfa.automaton.alphabet.clone(),
                dfa.automaton.initial_state.clone(),
                complement_accepting,
            )
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_dfa_creation() {
        let mut dfa = finite_automata::DFA::new(
            vec!["q0", "q1", "q2"].into_iter().collect(),
            vec!['0', '1'].into_iter().collect(),
            "q0".to_string(),
            vec!["q2"].into_iter().collect(),
        );
        
        // æ·»åŠ è½¬ç§»
        dfa.add_transition("q0".to_string(), '0', "q1".to_string());
        dfa.add_transition("q0".to_string(), '1', "q0".to_string());
        dfa.add_transition("q1".to_string(), '0', "q1".to_string());
        dfa.add_transition("q1".to_string(), '1', "q2".to_string());
        dfa.add_transition("q2".to_string(), '0', "q2".to_string());
        dfa.add_transition("q2".to_string(), '1', "q2".to_string());
        
        // æµ‹è¯•è¿è¡Œ
        assert!(dfa.run(&['0', '1'])); // æ¥å— "01"
        assert!(!dfa.run(&['0', '0'])); // ä¸æ¥å— "00"
        assert!(dfa.run(&['0', '1', '0'])); // æ¥å— "010"
    }
    
    #[test]
    fn test_nfa_to_dfa() {
        let mut nfa = finite_automata::NFA::new(
            vec!["q0", "q1", "q2"].into_iter().collect(),
            vec!['a', 'b'].into_iter().collect(),
            "q0".to_string(),
            vec!["q2"].into_iter().collect(),
        );
        
        // æ·»åŠ è½¬ç§»
        nfa.add_transition("q0".to_string(), 'a', "q0".to_string());
        nfa.add_transition("q0".to_string(), 'a', "q1".to_string());
        nfa.add_transition("q1".to_string(), 'b', "q2".to_string());
        
        // è½¬æ¢ä¸ºDFA
        let dfa = nfa.to_dfa();
        
        // æµ‹è¯•è¿è¡Œ
        assert!(dfa.run(&['a', 'b'])); // æ¥å— "ab"
        assert!(!dfa.run(&['a', 'a'])); // ä¸æ¥å— "aa"
    }
    
    #[test]
    fn test_automaton_operations() {
        let mut dfa1 = finite_automata::DFA::new(
            vec!["q0", "q1"].into_iter().collect(),
            vec!['a', 'b'].into_iter().collect(),
            "q0".to_string(),
            vec!["q1"].into_iter().collect(),
        );
        
        dfa1.add_transition("q0".to_string(), 'a', "q1".to_string());
        dfa1.add_transition("q1".to_string(), 'b', "q1".to_string());
        
        let mut dfa2 = finite_automata::DFA::new(
            vec!["p0", "p1"].into_iter().collect(),
            vec!['a', 'b'].into_iter().collect(),
            "p0".to_string(),
            vec!["p1"].into_iter().collect(),
        );
        
        dfa2.add_transition("p0".to_string(), 'b', "p1".to_string());
        dfa2.add_transition("p1".to_string(), 'a', "p1".to_string());
        
        // æµ‹è¯•è¡¥é›†è¿ç®—
        let complement = finite_automata::AutomatonOperations::complement(&dfa1);
        assert!(!complement.run(&['a'])); // åŸè‡ªåŠ¨æœºæ¥å—ï¼Œè¡¥é›†ä¸æ¥å—
    }
}
```

## 4. å¤šè¡¨å¾å†…å®¹

### 4.1 æœ‰é™è‡ªåŠ¨æœºç»“æ„å›¾

```mermaid
graph TD
    S[Start] --> A[çŠ¶æ€A]
    A -->|0| A
    A -->|1| B[çŠ¶æ€B]
    B -->|0| A
    B -->|1| B
    B --> F[Accept]
```

### 4.2 DFAä¸NFAå¯¹æ¯”è¡¨

| ç‰¹å¾ | DFA | NFA |
|------|-----|-----|
| çŠ¶æ€è½¬ç§» | å”¯ä¸€ | å¯å¤šé‡ |
| ç©ºä¸²è½¬ç§» | ä¸å…è®¸ | å…è®¸ |
| è¯†åˆ«èƒ½åŠ› | æ­£åˆ™è¯­è¨€ | æ­£åˆ™è¯­è¨€ |
| è¿è¡Œæ•ˆç‡ | é«˜ | ä½ï¼ˆç†è®ºï¼‰ |
| çŠ¶æ€æ•° | å¯èƒ½è¾ƒå¤š | å¯èƒ½è¾ƒå°‘ |

### 4.3 çŠ¶æ€æœ€å°åŒ–åˆ†æçŸ©é˜µ

| ç»´åº¦ | åŸå§‹DFA | æœ€å°DFA |
|------|---------|---------|
| çŠ¶æ€æ•° | n | â‰¤ n |
| è½¬ç§»æ•° | m | â‰¤ m |
| åˆ¤å®šæ•ˆç‡ | ä¸€èˆ¬ | æœ€ä¼˜ |

## 5. äº¤å‰å¼•ç”¨

- [Mealyæœº](./01_Finite_Automata/02_Mealy_Machine.md)
- [Mooreæœº](./01_Finite_Automata/03_Moore_Machine.md)
- [è‡ªåŠ¨æœºç†è®ºæ€»è§ˆ](./README.md)
- [æ­£åˆ™è¯­è¨€](../02_Regular_Languages.md)
- [å½¢å¼æ–‡æ³•](../03.2_Formal_Grammars.md)
- [è®¡ç®—ç†è®º](../03.6_Computation_Theory/README.md)
- [ä¸Šä¸‹æ–‡ç³»ç»Ÿ](../../12_Context_System/README.md)

## 6. å‚è€ƒæ–‡çŒ®

1. Hopcroft, John E., and Jeffrey D. Ullman. *Introduction to Automata Theory, Languages, and Computation*. Addison-Wesley, 1979.
2. Sipser, Michael. *Introduction to the Theory of Computation*. Cengage Learning, 2012.
3. Rabin, Michael O., and Dana Scott. "Finite Automata and Their Decision Problems." *IBM Journal of Research and Development* 3, no. 2 (1959): 114-125.
4. Kleene, Stephen C. "Representation of Events in Nerve Nets and Finite Automata." *Automata Studies*, 1956.
5. Kozen, Dexter. *Automata and Computability*. Springer, 1997.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ21æ—¥  
**ç»´æŠ¤è€…**: AIåŠ©æ‰‹  
**ç‰ˆæœ¬**: v1.0
