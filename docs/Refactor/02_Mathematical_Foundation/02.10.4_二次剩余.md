# 02.10.4 äºŒæ¬¡å‰©ä½™

## ğŸ“‹ æ¦‚è¿°

äºŒæ¬¡å‰©ä½™ç†è®ºæ˜¯æ•°è®ºçš„é‡è¦åˆ†æ”¯ï¼Œç ”ç©¶æ¨¡ç´ æ•°ä¸‹çš„äºŒæ¬¡æ–¹ç¨‹è§£çš„å­˜åœ¨æ€§é—®é¢˜ã€‚å®ƒåœ¨å¯†ç å­¦ã€ç¼–ç ç†è®ºå’Œä»£æ•°æ•°è®ºä¸­æœ‰é‡è¦åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹äºŒæ¬¡å‰©ä½™çš„åŸºç¡€ç†è®ºä½“ç³»**
2. **ç ”ç©¶å‹’è®©å¾·ç¬¦å·çš„æ€§è´¨**
3. **å‘å±•äºŒæ¬¡å‰©ä½™çš„åˆ¤å®šç®—æ³•**
4. **æ¢ç´¢äºŒæ¬¡å‰©ä½™åœ¨å¯†ç å­¦ä¸­çš„åº”ç”¨**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 äºŒæ¬¡å‰©ä½™å®šä¹‰

è®¾ $p$ ä¸ºå¥‡ç´ æ•°ï¼Œ$a$ ä¸ºä¸ $p$ äº’ç´ çš„æ•´æ•°ã€‚å¦‚æœå­˜åœ¨æ•´æ•° $x$ ä½¿å¾—ï¼š

$$x^2 \equiv a \pmod{p}$$

åˆ™ç§° $a$ æ˜¯æ¨¡ $p$ çš„**äºŒæ¬¡å‰©ä½™**ï¼Œå¦åˆ™ç§° $a$ æ˜¯æ¨¡ $p$ çš„**äºŒæ¬¡éå‰©ä½™**ã€‚

### 1.2 å‹’è®©å¾·ç¬¦å·

å¯¹äºå¥‡ç´ æ•° $p$ å’Œæ•´æ•° $a$ï¼Œå®šä¹‰å‹’è®©å¾·ç¬¦å·ï¼š

$$\left(\frac{a}{p}\right) = \begin{cases}
1 & \text{if } a \text{ is a quadratic residue modulo } p \\
-1 & \text{if } a \text{ is a quadratic non-residue modulo } p \\
0 & \text{if } p \mid a
\end{cases}$$

### 1.3 äºŒæ¬¡å‰©ä½™çš„ä¾‹å­

æ¨¡7çš„äºŒæ¬¡å‰©ä½™ï¼š1, 2, 4
æ¨¡7çš„äºŒæ¬¡éå‰©ä½™ï¼š3, 5, 6

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 äºŒæ¬¡å‰©ä½™åˆ¤å®šå‡½æ•°

å¯¹äºå¥‡ç´ æ•° $p$ å’Œæ•´æ•° $a$ï¼Œå®šä¹‰äºŒæ¬¡å‰©ä½™åˆ¤å®šå‡½æ•°ï¼š

$$\text{isQuadraticResidue}(a, p) = \begin{cases}
\text{true} & \text{if } \exists x \in \mathbb{Z}, x^2 \equiv a \pmod{p} \\
\text{false} & \text{otherwise}
\end{cases}$$

### 2.2 å‹’è®©å¾·ç¬¦å·è®¡ç®—

å‹’è®©å¾·ç¬¦å·å¯ä»¥é€šè¿‡æ¬§æ‹‰å‡†åˆ™è®¡ç®—ï¼š

$$\left(\frac{a}{p}\right) \equiv a^{\frac{p-1}{2}} \pmod{p}$$

### 2.3 äºŒæ¬¡å‰©ä½™è®¡æ•°

æ¨¡ $p$ çš„äºŒæ¬¡å‰©ä½™ä¸ªæ•°ä¸º $\frac{p-1}{2}$ï¼ŒäºŒæ¬¡éå‰©ä½™ä¸ªæ•°ä¹Ÿä¸º $\frac{p-1}{2}$ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 æ¬§æ‹‰å‡†åˆ™

**å®šç† 3.1.1** (æ¬§æ‹‰å‡†åˆ™)ï¼šè®¾ $p$ ä¸ºå¥‡ç´ æ•°ï¼Œ$a$ ä¸ºä¸ $p$ äº’ç´ çš„æ•´æ•°ï¼Œåˆ™ï¼š

$$\left(\frac{a}{p}\right) \equiv a^{\frac{p-1}{2}} \pmod{p}$$

**è¯æ˜**ï¼š
1. å¦‚æœ $a$ æ˜¯äºŒæ¬¡å‰©ä½™ï¼Œåˆ™å­˜åœ¨ $x$ ä½¿å¾— $x^2 \equiv a \pmod{p}$
   - ç”±è´¹é©¬å°å®šç†ï¼š$a^{\frac{p-1}{2}} \equiv (x^2)^{\frac{p-1}{2}} \equiv x^{p-1} \equiv 1 \pmod{p}$

2. å¦‚æœ $a$ æ˜¯äºŒæ¬¡éå‰©ä½™ï¼Œåˆ™ $a^{\frac{p-1}{2}} \equiv -1 \pmod{p}$
   - è¿™æ˜¯å› ä¸º $a^{p-1} \equiv 1 \pmod{p}$ï¼Œæ‰€ä»¥ $a^{\frac{p-1}{2}} \equiv \pm 1 \pmod{p}$
   - å¦‚æœ $a^{\frac{p-1}{2}} \equiv 1 \pmod{p}$ï¼Œåˆ™ $a$ æ˜¯äºŒæ¬¡å‰©ä½™ï¼ŒçŸ›ç›¾

### 3.2 äºŒæ¬¡äº’åå¾‹

**å®šç† 3.2.1** (äºŒæ¬¡äº’åå¾‹)ï¼šè®¾ $p, q$ ä¸ºä¸åŒçš„å¥‡ç´ æ•°ï¼Œåˆ™ï¼š

$$\left(\frac{p}{q}\right) \left(\frac{q}{p}\right) = (-1)^{\frac{p-1}{2} \cdot \frac{q-1}{2}}$$

**è¯æ˜**ï¼š
è¿™æ˜¯æ•°è®ºä¸­æœ€æ·±åˆ»çš„å®šç†ä¹‹ä¸€ï¼Œè¯æ˜æ¶‰åŠé«˜æ–¯å’Œå’Œä»£æ•°æ•°è®ºçš„é«˜çº§æŠ€å·§ã€‚

### 3.3 å‹’è®©å¾·ç¬¦å·çš„æ€§è´¨

**å®šç† 3.3.1**ï¼šå‹’è®©å¾·ç¬¦å·å…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼š

1. **ä¹˜æ³•æ€§**ï¼š$\left(\frac{ab}{p}\right) = \left(\frac{a}{p}\right) \left(\frac{b}{p}\right)$

2. **å‘¨æœŸæ€§**ï¼š$\left(\frac{a + kp}{p}\right) = \left(\frac{a}{p}\right)$

3. **å¹³æ–¹æ€§**ï¼š$\left(\frac{a^2}{p}\right) = 1$ (å½“ $p \nmid a$ æ—¶)

**è¯æ˜**ï¼š
1. **ä¹˜æ³•æ€§**ï¼šç”±æ¬§æ‹‰å‡†åˆ™ï¼Œ
   $$\left(\frac{ab}{p}\right) \equiv (ab)^{\frac{p-1}{2}} \equiv a^{\frac{p-1}{2}} b^{\frac{p-1}{2}} \equiv \left(\frac{a}{p}\right) \left(\frac{b}{p}\right) \pmod{p}$$

2. **å‘¨æœŸæ€§**ï¼šæ˜¾ç„¶ï¼Œå› ä¸º $(a + kp)^{\frac{p-1}{2}} \equiv a^{\frac{p-1}{2}} \pmod{p}$

3. **å¹³æ–¹æ€§**ï¼š$(a^2)^{\frac{p-1}{2}} = a^{p-1} \equiv 1 \pmod{p}$

### 3.4 é«˜æ–¯å¼•ç†

**å®šç† 3.4.1** (é«˜æ–¯å¼•ç†)ï¼šè®¾ $p$ ä¸ºå¥‡ç´ æ•°ï¼Œ$a$ ä¸ºä¸ $p$ äº’ç´ çš„æ•´æ•°ã€‚è€ƒè™‘é›†åˆï¼š

$$S = \{a, 2a, 3a, \ldots, \frac{p-1}{2}a\}$$

è®¾ $m$ ä¸º $S$ ä¸­æ¨¡ $p$ åå¤§äº $\frac{p}{2}$ çš„å…ƒç´ çš„ä¸ªæ•°ï¼Œåˆ™ï¼š

$$\left(\frac{a}{p}\right) = (-1)^m$$

## 4. ä»£ç å®ç°

### 4.1 Rustå®ç°

```rust
use num_bigint::{BigInt, BigUint};
use num_traits::{One, Zero};

/// äºŒæ¬¡å‰©ä½™ç†è®ºå®ç°
pub struct QuadraticResidue;

impl QuadraticResidue {
    /// è®¡ç®—å‹’è®©å¾·ç¬¦å·
    pub fn legendre_symbol(a: i64, p: i64) -> i32 {
        if p <= 0 || p % 2 == 0 {
            panic!("p must be a positive odd integer");
        }
        
        let a = a % p;
        if a == 0 {
            return 0;
        }
        
        if a == 1 {
            return 1;
        }
        
        if a % 2 == 0 {
            return Self::legendre_symbol(a / 2, p) * if p % 8 == 1 || p % 8 == 7 { 1 } else { -1 };
        }
        
        if a == -1 {
            return if p % 4 == 1 { 1 } else { -1 };
        }
        
        // äºŒæ¬¡äº’åå¾‹
        if a < 0 {
            return Self::legendre_symbol(-a, p) * if p % 4 == 1 { 1 } else { -1 };
        }
        
        if a >= p {
            return Self::legendre_symbol(a % p, p);
        }
        
        if a == 2 {
            return if p % 8 == 1 || p % 8 == 7 { 1 } else { -1 };
        }
        
        // äºŒæ¬¡äº’åå¾‹
        if a < p {
            let factor = if (a % 4 == 3) && (p % 4 == 3) { -1 } else { 1 };
            return factor * Self::legendre_symbol(p, a);
        }
        
        0
    }
    
    /// åˆ¤æ–­æ˜¯å¦ä¸ºäºŒæ¬¡å‰©ä½™
    pub fn is_quadratic_residue(a: i64, p: i64) -> bool {
        Self::legendre_symbol(a, p) == 1
    }
    
    /// è®¡ç®—äºŒæ¬¡å‰©ä½™çš„å¹³æ–¹æ ¹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    pub fn square_root_mod_p(a: i64, p: i64) -> Option<Vec<i64>> {
        if !Self::is_quadratic_residue(a, p) {
            return None;
        }
        
        if p == 2 {
            return Some(vec![a % 2]);
        }
        
        if p % 4 == 3 {
            // ç®€å•æƒ…å†µï¼šp â‰¡ 3 (mod 4)
            let x = Self::mod_pow(a, (p + 1) / 4, p);
            return Some(vec![x, p - x]);
        }
        
        // ä¸€èˆ¬æƒ…å†µï¼šä½¿ç”¨Tonelli-Shanksç®—æ³•
        Self::tonelli_shanks(a, p)
    }
    
    /// Tonelli-Shanksç®—æ³•è®¡ç®—å¹³æ–¹æ ¹
    fn tonelli_shanks(a: i64, p: i64) -> Option<Vec<i64>> {
        // æ‰¾åˆ°äºŒæ¬¡éå‰©ä½™
        let mut q = 2;
        while Self::is_quadratic_residue(q, p) {
            q += 1;
        }
        
        let mut s = 0;
        let mut t = p - 1;
        while t % 2 == 0 {
            s += 1;
            t /= 2;
        }
        
        let mut m = s;
        let mut c = Self::mod_pow(q, t, p);
        let mut r = Self::mod_pow(a, (t + 1) / 2, p);
        let mut t_val = Self::mod_pow(a, t, p);
        
        while t_val != 1 {
            let mut i = 0;
            let mut temp = t_val;
            while temp != 1 && i < m {
                temp = (temp * temp) % p;
                i += 1;
            }
            
            if i == 0 {
                return None;
            }
            
            let b = Self::mod_pow(c, 1 << (m - i - 1), p);
            m = i;
            c = (b * b) % p;
            r = (r * b) % p;
            t_val = (t_val * c) % p;
        }
        
        Some(vec![r, p - r])
    }
    
    /// æ¨¡å¹‚è¿ç®—
    fn mod_pow(mut base: i64, mut exp: i64, modulus: i64) -> i64 {
        if modulus == 1 {
            return 0;
        }
        
        let mut result = 1;
        base = base % modulus;
        
        while exp > 0 {
            if exp % 2 == 1 {
                result = (result * base) % modulus;
            }
            exp = exp >> 1;
            base = (base * base) % modulus;
        }
        
        result
    }
    
    /// è®¡ç®—äºŒæ¬¡å‰©ä½™çš„æ•°é‡
    pub fn count_quadratic_residues(p: i64) -> usize {
        if p <= 0 || p % 2 == 0 {
            panic!("p must be a positive odd integer");
        }
        
        ((p - 1) / 2) as usize
    }
    
    /// ç”Ÿæˆæ‰€æœ‰äºŒæ¬¡å‰©ä½™
    pub fn generate_quadratic_residues(p: i64) -> Vec<i64> {
        if p <= 0 || p % 2 == 0 {
            panic!("p must be a positive odd integer");
        }
        
        let mut residues = Vec::new();
        for x in 1..p {
            let residue = (x * x) % p;
            if !residues.contains(&residue) {
                residues.push(residue);
            }
        }
        residues.sort();
        residues
    }
    
    /// é«˜æ–¯å¼•ç†å®ç°
    pub fn gauss_lemma(a: i64, p: i64) -> i32 {
        if p <= 0 || p % 2 == 0 {
            panic!("p must be a positive odd integer");
        }
        
        let mut count = 0;
        let half_p = p / 2;
        
        for i in 1..=half_p {
            let product = (a * i) % p;
            if product > half_p {
                count += 1;
            }
        }
        
        if count % 2 == 0 { 1 } else { -1 }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_legendre_symbol() {
        assert_eq!(QuadraticResidue::legendre_symbol(1, 7), 1);
        assert_eq!(QuadraticResidue::legendre_symbol(2, 7), 1);
        assert_eq!(QuadraticResidue::legendre_symbol(3, 7), -1);
        assert_eq!(QuadraticResidue::legendre_symbol(4, 7), 1);
        assert_eq!(QuadraticResidue::legendre_symbol(5, 7), -1);
        assert_eq!(QuadraticResidue::legendre_symbol(6, 7), -1);
        assert_eq!(QuadraticResidue::legendre_symbol(0, 7), 0);
    }
    
    #[test]
    fn test_is_quadratic_residue() {
        assert!(QuadraticResidue::is_quadratic_residue(1, 7));
        assert!(QuadraticResidue::is_quadratic_residue(2, 7));
        assert!(!QuadraticResidue::is_quadratic_residue(3, 7));
        assert!(QuadraticResidue::is_quadratic_residue(4, 7));
        assert!(!QuadraticResidue::is_quadratic_residue(5, 7));
    }
    
    #[test]
    fn test_square_root_mod_p() {
        let roots = QuadraticResidue::square_root_mod_p(2, 7);
        assert_eq!(roots, Some(vec![3, 4]));
        
        let roots = QuadraticResidue::square_root_mod_p(4, 7);
        assert_eq!(roots, Some(vec![2, 5]));
        
        let roots = QuadraticResidue::square_root_mod_p(3, 7);
        assert_eq!(roots, None);
    }
    
    #[test]
    fn test_count_quadratic_residues() {
        assert_eq!(QuadraticResidue::count_quadratic_residues(7), 3);
        assert_eq!(QuadraticResidue::count_quadratic_residues(11), 5);
        assert_eq!(QuadraticResidue::count_quadratic_residues(13), 6);
    }
    
    #[test]
    fn test_generate_quadratic_residues() {
        let residues = QuadraticResidue::generate_quadratic_residues(7);
        assert_eq!(residues, vec![1, 2, 4]);
        
        let residues = QuadraticResidue::generate_quadratic_residues(11);
        assert_eq!(residues, vec![1, 3, 4, 5, 9]);
    }
    
    #[test]
    fn test_gauss_lemma() {
        assert_eq!(QuadraticResidue::gauss_lemma(2, 7), 1);
        assert_eq!(QuadraticResidue::gauss_lemma(3, 7), -1);
        assert_eq!(QuadraticResidue::gauss_lemma(4, 7), 1);
    }
}
```

### 4.2 Haskellå®ç°

```haskell
module QuadraticResidue where

import Data.List (nub, sort)

-- äºŒæ¬¡å‰©ä½™ç†è®ºå®ç°
class QuadraticResidue a where
    legendreSymbol :: a -> a -> Int
    isQuadraticResidue :: a -> a -> Bool
    squareRootModP :: a -> a -> Maybe [a]
    countQuadraticResidues :: a -> Int
    generateQuadraticResidues :: a -> [a]
    gaussLemma :: a -> a -> Int

instance QuadraticResidue Integer where
    -- è®¡ç®—å‹’è®©å¾·ç¬¦å·
    legendreSymbol a p
        | p <= 0 || even p = error "p must be a positive odd integer"
        | a `mod` p == 0 = 0
        | a `mod` p == 1 = 1
        | even (a `mod` p) = legendreSymbol (a `div` 2) p * 
            if p `mod` 8 == 1 || p `mod` 8 == 7 then 1 else -1
        | a `mod` p == p - 1 = if p `mod` 4 == 1 then 1 else -1
        | a < 0 = legendreSymbol (-a) p * if p `mod` 4 == 1 then 1 else -1
        | a >= p = legendreSymbol (a `mod` p) p
        | a == 2 = if p `mod` 8 == 1 || p `mod` 8 == 7 then 1 else -1
        | otherwise = factor * legendreSymbol p a
        where
            factor = if (a `mod` 4 == 3) && (p `mod` 4 == 3) then -1 else 1
    
    -- åˆ¤æ–­æ˜¯å¦ä¸ºäºŒæ¬¡å‰©ä½™
    isQuadraticResidue a p = legendreSymbol a p == 1
    
    -- è®¡ç®—å¹³æ–¹æ ¹
    squareRootModP a p
        | not (isQuadraticResidue a p) = Nothing
        | p == 2 = Just [a `mod` 2]
        | p `mod` 4 == 3 = Just [x, p - x]
        | otherwise = tonelliShanks a p
        where
            x = modPow a ((p + 1) `div` 4) p
    
    -- Tonelli-Shanksç®—æ³•
    tonelliShanks a p = do
        let q = findQuadraticNonResidue p
        let (s, t) = factorizePower2 (p - 1)
        let m = s
        let c = modPow q t p
        let r = modPow a ((t + 1) `div` 2) p
        let t_val = modPow a t p
        Just $ tonelliShanksHelper m c r t_val p
    
    tonelliShanksHelper m c r t_val p
        | t_val == 1 = [r, p - r]
        | otherwise = tonelliShanksHelper new_m new_c new_r new_t_val p
        where
            (i, _) = findOrder t_val m p
            b = modPow c (2^(m - i - 1)) p
            new_m = i
            new_c = (b * b) `mod` p
            new_r = (r * b) % p
            new_t_val = (t_val * new_c) `mod` p
    
    -- è®¡ç®—äºŒæ¬¡å‰©ä½™æ•°é‡
    countQuadraticResidues p
        | p <= 0 || even p = error "p must be a positive odd integer"
        | otherwise = fromIntegral $ (p - 1) `div` 2
    
    -- ç”Ÿæˆæ‰€æœ‰äºŒæ¬¡å‰©ä½™
    generateQuadraticResidues p
        | p <= 0 || even p = error "p must be a positive odd integer"
        | otherwise = sort $ nub [x^2 `mod` p | x <- [1..p-1]]
    
    -- é«˜æ–¯å¼•ç†
    gaussLemma a p
        | p <= 0 || even p = error "p must be a positive odd integer"
        | otherwise = if count `mod` 2 == 0 then 1 else -1
        where
            half_p = p `div` 2
            count = length [i | i <- [1..half_p], (a * i) `mod` p > half_p]

-- è¾…åŠ©å‡½æ•°
modPow :: Integer -> Integer -> Integer -> Integer
modPow base exp modulus
    | modulus == 1 = 0
    | otherwise = modPowHelper base exp modulus 1
    where
        modPowHelper _ 0 _ result = result
        modPowHelper base exp modulus result
            | odd exp = modPowHelper new_base new_exp modulus new_result
            | otherwise = modPowHelper new_base new_exp modulus result
            where
                new_base = (base * base) `mod` modulus
                new_exp = exp `div` 2
                new_result = (result * base) `mod` modulus

findQuadraticNonResidue :: Integer -> Integer
findQuadraticNonResidue p = head [q | q <- [2..], not (isQuadraticResidue q p)]
    where
        isQuadraticResidue a p = legendreSymbol a p == 1
        legendreSymbol a p = 1 -- ç®€åŒ–å®ç°

factorizePower2 :: Integer -> (Integer, Integer)
factorizePower2 n = factorizePower2Helper n 0
    where
        factorizePower2Helper n s
            | even n = factorizePower2Helper (n `div` 2) (s + 1)
            | otherwise = (s, n)

findOrder :: Integer -> Integer -> Integer -> (Integer, Integer)
findOrder t_val m p = findOrderHelper t_val m p 0
    where
        findOrderHelper t_val m p i
            | t_val == 1 = (i, t_val)
            | i >= m = (m, t_val)
            | otherwise = findOrderHelper new_t_val m p (i + 1)
            where
                new_t_val = (t_val * t_val) `mod` p

-- æµ‹è¯•å‡½æ•°
testQuadraticResidue :: IO ()
testQuadraticResidue = do
    putStrLn "Testing Quadratic Residue Theory..."
    
    -- æµ‹è¯•å‹’è®©å¾·ç¬¦å·
    putStrLn $ "legendreSymbol 1 7: " ++ show (legendreSymbol 1 7)
    putStrLn $ "legendreSymbol 2 7: " ++ show (legendreSymbol 2 7)
    putStrLn $ "legendreSymbol 3 7: " ++ show (legendreSymbol 3 7)
    putStrLn $ "legendreSymbol 4 7: " ++ show (legendreSymbol 4 7)
    
    -- æµ‹è¯•äºŒæ¬¡å‰©ä½™åˆ¤å®š
    putStrLn $ "isQuadraticResidue 2 7: " ++ show (isQuadraticResidue 2 7)
    putStrLn $ "isQuadraticResidue 3 7: " ++ show (isQuadraticResidue 3 7)
    
    -- æµ‹è¯•å¹³æ–¹æ ¹è®¡ç®—
    putStrLn $ "squareRootModP 2 7: " ++ show (squareRootModP 2 7)
    putStrLn $ "squareRootModP 4 7: " ++ show (squareRootModP 4 7)
    
    -- æµ‹è¯•äºŒæ¬¡å‰©ä½™è®¡æ•°
    putStrLn $ "countQuadraticResidues 7: " ++ show (countQuadraticResidues 7)
    putStrLn $ "countQuadraticResidues 11: " ++ show (countQuadraticResidues 11)
    
    -- æµ‹è¯•ç”ŸæˆäºŒæ¬¡å‰©ä½™
    putStrLn $ "generateQuadraticResidues 7: " ++ show (generateQuadraticResidues 7)
    putStrLn $ "generateQuadraticResidues 11: " ++ show (generateQuadraticResidues 11)
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å¯†ç å­¦åº”ç”¨

äºŒæ¬¡å‰©ä½™åœ¨RabinåŠ å¯†ç³»ç»Ÿä¸­çš„åº”ç”¨ï¼š

```rust
use num_bigint::{BigInt, BigUint};
use rand::Rng;

pub struct RabinCipher {
    public_key: BigUint,
    private_key: (BigUint, BigUint),
}

impl RabinCipher {
    pub fn new(bit_length: usize) -> Self {
        let mut rng = rand::thread_rng();
        
        // ç”Ÿæˆä¸¤ä¸ªå½¢å¦‚ 4k+3 çš„ç´ æ•°
        let p = Self::generate_prime_4k_plus_3(bit_length / 2, &mut rng);
        let q = Self::generate_prime_4k_plus_3(bit_length / 2, &mut rng);
        
        let n = &p * &q;
        
        RabinCipher {
            public_key: n,
            private_key: (p, q),
        }
    }
    
    fn generate_prime_4k_plus_3(bits: usize, rng: &mut impl rand::Rng) -> BigUint {
        loop {
            let candidate = rng.gen_biguint(bits);
            if Self::is_prime_4k_plus_3(&candidate) {
                return candidate;
            }
        }
    }
    
    fn is_prime_4k_plus_3(n: &BigUint) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥æ˜¯å¦ä¸ºå½¢å¦‚ 4k+3 çš„ç´ æ•°
        let n_u64 = n.to_u64().unwrap_or(0);
        if n_u64 > 0 {
            return n_u64 % 4 == 3 && PrimeTheory::is_prime(n_u64);
        }
        true // ç®€åŒ–å®ç°
    }
    
    pub fn encrypt(&self, message: &BigUint) -> BigUint {
        // åŠ å¯†ï¼šc = m^2 mod n
        message.modpow(&BigUint::from(2u32), &self.public_key)
    }
    
    pub fn decrypt(&self, ciphertext: &BigUint) -> Vec<BigUint> {
        let p = &self.private_key.0;
        let q = &self.private_key.1;
        
        // è®¡ç®—å¹³æ–¹æ ¹æ¨¡ p å’Œ q
        let p_u64 = p.to_u64().unwrap_or(0);
        let q_u64 = q.to_u64().unwrap_or(0);
        let c_u64 = ciphertext.to_u64().unwrap_or(0);
        
        if p_u64 > 0 && q_u64 > 0 && c_u64 > 0 {
            let roots_p = QuadraticResidue::square_root_mod_p(c_u64 as i64, p_u64 as i64);
            let roots_q = QuadraticResidue::square_root_mod_p(c_u64 as i64, q_u64 as i64);
            
            if let (Some(rp), Some(rq)) = (roots_p, roots_q) {
                // ä½¿ç”¨ä¸­å›½å‰©ä½™å®šç†ç»„åˆè§£
                let mut solutions = Vec::new();
                for &rp_val in &rp {
                    for &rq_val in &rq {
                        let solution = Self::chinese_remainder(
                            rp_val as u64, p_u64,
                            rq_val as u64, q_u64
                        );
                        if let Some(sol) = solution {
                            solutions.push(BigUint::from(sol));
                        }
                    }
                }
                return solutions;
            }
        }
        
        vec![]
    }
    
    fn chinese_remainder(a1: u64, n1: u64, a2: u64, n2: u64) -> Option<u64> {
        // æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚è§£
        let (gcd, x, _) = Self::extended_gcd(n1 as i64, n2 as i64);
        
        if gcd != 1 {
            return None;
        }
        
        let x = ((x % n2 as i64) + n2 as i64) % n2 as i64;
        let solution = (a1 as i64 + (a2 - a1) as i64 * x * n1 as i64) % (n1 * n2) as i64;
        
        Some(solution as u64)
    }
    
    fn extended_gcd(a: i64, b: i64) -> (i64, i64, i64) {
        if b == 0 {
            (a, 1, 0)
        } else {
            let (gcd, x, y) = Self::extended_gcd(b, a % b);
            (gcd, y, x - (a / b) * y)
        }
    }
}
```

### 5.2 äºŒæ¬¡å‰©ä½™åˆ†å¸ƒå¯è§†åŒ–

```rust
use plotters::prelude::*;

pub fn plot_quadratic_residues(p: i64) -> Result<(), Box<dyn std::error::Error>> {
    let root = BitMapBackend::new("quadratic_residues.png", (800, 600)).into_drawing_area();
    root.fill(&WHITE)?;
    
    let residues = QuadraticResidue::generate_quadratic_residues(p);
    let non_residues: Vec<i64> = (1..p)
        .filter(|&x| !residues.contains(&x))
        .collect();
    
    let mut chart = ChartBuilder::on(&root)
        .caption(&format!("Quadratic Residues Modulo {}", p), ("sans-serif", 30))
        .margin(5)
        .x_label_area_size(40)
        .y_label_area_size(40)
        .build_cartesian_2d(0..p, 0..2)?;
    
    chart.configure_mesh().draw()?;
    
    // ç»˜åˆ¶äºŒæ¬¡å‰©ä½™
    for &residue in &residues {
        chart.draw_series(std::iter::once(Circle::new((residue, 1), 3, RED.filled())))?;
    }
    
    // ç»˜åˆ¶äºŒæ¬¡éå‰©ä½™
    for &non_residue in &non_residues {
        chart.draw_series(std::iter::once(Circle::new((non_residue, 0), 3, BLUE.filled())))?;
    }
    
    root.present()?;
    Ok(())
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸åŒä½™ç†è®ºçš„å…³ç³»

äºŒæ¬¡å‰©ä½™ç†è®ºæ˜¯æ¨¡è¿ç®—ç†è®ºçš„é‡è¦åº”ç”¨ï¼Œç ”ç©¶æ¨¡ç´ æ•°ä¸‹çš„äºŒæ¬¡æ–¹ç¨‹ã€‚

### 6.2 ä¸ç´ æ•°ç†è®ºçš„å…³ç³»

äºŒæ¬¡å‰©ä½™çš„æ€§è´¨ä¸ç´ æ•°çš„æ€§è´¨å¯†åˆ‡ç›¸å…³ï¼Œç‰¹åˆ«æ˜¯å‹’è®©å¾·ç¬¦å·çš„è®¡ç®—ã€‚

### 6.3 ä¸ä»£æ•°æ•°è®ºçš„å…³ç³»

äºŒæ¬¡å‰©ä½™ç†è®ºåœ¨ä»£æ•°æ•°è®ºä¸­æ¨å¹¿ä¸ºé«˜æ¬¡å‰©ä½™ç†è®ºã€‚

### 6.4 ä¸å¯†ç å­¦çš„å…³ç³»

äºŒæ¬¡å‰©ä½™åœ¨RabinåŠ å¯†ã€é›¶çŸ¥è¯†è¯æ˜ç­‰å¯†ç å­¦åè®®ä¸­æœ‰é‡è¦åº”ç”¨ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Ireland, K., & Rosen, M. (2013). A Classical Introduction to Modern Number Theory. Springer.
2. Hardy, G. H., & Wright, E. M. (2008). An Introduction to the Theory of Numbers. Oxford University Press.
3. Crandall, R., & Pomerance, C. (2005). Prime Numbers: A Computational Perspective. Springer.
4. Cohen, H. (2013). A Course in Computational Algebraic Number Theory. Springer.
5. Bach, E., & Shallit, J. (1996). Algorithmic Number Theory. MIT Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [02.10.1 æ•´é™¤ç†è®º](../02.10.1_æ•´é™¤ç†è®º.md)
- [02.10.2 åŒä½™ç†è®º](../02.10.2_åŒä½™ç†è®º.md)
- [02.10.3 ç´ æ•°ç†è®º](../02.10.3_ç´ æ•°ç†è®º.md)
- [02.11.1 è®¡æ•°åŸç†](../02.11.1_è®¡æ•°åŸç†.md) 