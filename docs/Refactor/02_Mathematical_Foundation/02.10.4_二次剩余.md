# 02.10.4 ‰∫åÊ¨°Ââ©‰Ωô

## üìã Ê¶ÇËø∞

‰∫åÊ¨°Ââ©‰ΩôÁêÜËÆ∫ÊòØÊï∞ËÆ∫ÁöÑÈáçË¶ÅÂàÜÊîØÔºåÁ†îÁ©∂Ê®°Á¥†Êï∞‰∏ãÁöÑ‰∫åÊ¨°ÊñπÁ®ãËß£ÁöÑÂ≠òÂú®ÊÄßÈóÆÈ¢ò„ÄÇÂÆÉÂú®ÂØÜÁ†ÅÂ≠¶„ÄÅÁºñÁ†ÅÁêÜËÆ∫Âíå‰ª£Êï∞Êï∞ËÆ∫‰∏≠ÊúâÈáçË¶ÅÂ∫îÁî®„ÄÇ

## üéØ Ê†∏ÂøÉÁõÆÊ†á

1. **Âª∫Á´ã‰∫åÊ¨°Ââ©‰ΩôÁöÑÂü∫Á°ÄÁêÜËÆ∫‰ΩìÁ≥ª**
2. **Á†îÁ©∂ÂãíËÆ©Âæ∑Á¨¶Âè∑ÁöÑÊÄßË¥®**
3. **ÂèëÂ±ï‰∫åÊ¨°Ââ©‰ΩôÁöÑÂà§ÂÆöÁÆóÊ≥ï**
4. **Êé¢Á¥¢‰∫åÊ¨°Ââ©‰ΩôÂú®ÂØÜÁ†ÅÂ≠¶‰∏≠ÁöÑÂ∫îÁî®**

## üìö ÁõÆÂΩï

1. [Âü∫Êú¨Ê¶ÇÂøµ](#1-Âü∫Êú¨Ê¶ÇÂøµ)
2. [ÂΩ¢ÂºèÂåñÂÆö‰πâ](#2-ÂΩ¢ÂºèÂåñÂÆö‰πâ)
3. [ÂÆöÁêÜ‰∏éËØÅÊòé](#3-ÂÆöÁêÜ‰∏éËØÅÊòé)
4. [‰ª£Á†ÅÂÆûÁé∞](#4-‰ª£Á†ÅÂÆûÁé∞)
5. [Â∫îÁî®Á§∫‰æã](#5-Â∫îÁî®Á§∫‰æã)
6. [Áõ∏ÂÖ≥ÁêÜËÆ∫](#6-Áõ∏ÂÖ≥ÁêÜËÆ∫)
7. [ÂèÇËÄÉÊñáÁåÆ](#7-ÂèÇËÄÉÊñáÁåÆ)

## 1. Âü∫Êú¨Ê¶ÇÂøµ

### 1.1 ‰∫åÊ¨°Ââ©‰ΩôÂÆö‰πâ

ËÆæ $p$ ‰∏∫Â•áÁ¥†Êï∞Ôºå$a$ ‰∏∫‰∏é $p$ ‰∫íÁ¥†ÁöÑÊï¥Êï∞„ÄÇÂ¶ÇÊûúÂ≠òÂú®Êï¥Êï∞ $x$ ‰ΩøÂæóÔºö

$$x^2 \equiv a \pmod{p}$$

ÂàôÁß∞ $a$ ÊòØÊ®° $p$ ÁöÑ**‰∫åÊ¨°Ââ©‰Ωô**ÔºåÂê¶ÂàôÁß∞ $a$ ÊòØÊ®° $p$ ÁöÑ**‰∫åÊ¨°ÈùûÂâ©‰Ωô**„ÄÇ

### 1.2 ÂãíËÆ©Âæ∑Á¨¶Âè∑

ÂØπ‰∫éÂ•áÁ¥†Êï∞ $p$ ÂíåÊï¥Êï∞ $a$ÔºåÂÆö‰πâÂãíËÆ©Âæ∑Á¨¶Âè∑Ôºö

$$\left(\frac{a}{p}\right) = \begin{cases}
1 & \text{if } a \text{ is a quadratic residue modulo } p \\
-1 & \text{if } a \text{ is a quadratic non-residue modulo } p \\
0 & \text{if } p \mid a
\end{cases}$$

### 1.3 ‰∫åÊ¨°Ââ©‰ΩôÁöÑ‰æãÂ≠ê

Ê®°7ÁöÑ‰∫åÊ¨°Ââ©‰ΩôÔºö1, 2, 4
Ê®°7ÁöÑ‰∫åÊ¨°ÈùûÂâ©‰ΩôÔºö3, 5, 6

## 2. ÂΩ¢ÂºèÂåñÂÆö‰πâ

### 2.1 ‰∫åÊ¨°Ââ©‰ΩôÂà§ÂÆöÂáΩÊï∞

ÂØπ‰∫éÂ•áÁ¥†Êï∞ $p$ ÂíåÊï¥Êï∞ $a$ÔºåÂÆö‰πâ‰∫åÊ¨°Ââ©‰ΩôÂà§ÂÆöÂáΩÊï∞Ôºö

$$\text{isQuadraticResidue}(a, p) = \begin{cases}
\text{true} & \text{if } \exists x \in \mathbb{Z}, x^2 \equiv a \pmod{p} \\
\text{false} & \text{otherwise}
\end{cases}$$

### 2.2 ÂãíËÆ©Âæ∑Á¨¶Âè∑ËÆ°ÁÆó

ÂãíËÆ©Âæ∑Á¨¶Âè∑ÂèØ‰ª•ÈÄöËøáÊ¨ßÊãâÂáÜÂàôËÆ°ÁÆóÔºö

$$\left(\frac{a}{p}\right) \equiv a^{\frac{p-1}{2}} \pmod{p}$$

### 2.3 ‰∫åÊ¨°Ââ©‰ΩôËÆ°Êï∞

Ê®° $p$ ÁöÑ‰∫åÊ¨°Ââ©‰Ωô‰∏™Êï∞‰∏∫ $\frac{p-1}{2}$Ôºå‰∫åÊ¨°ÈùûÂâ©‰Ωô‰∏™Êï∞‰πü‰∏∫ $\frac{p-1}{2}$„ÄÇ

## 3. ÂÆöÁêÜ‰∏éËØÅÊòé

### 3.1 Ê¨ßÊãâÂáÜÂàô

**ÂÆöÁêÜ 3.1.1** (Ê¨ßÊãâÂáÜÂàô)ÔºöËÆæ $p$ ‰∏∫Â•áÁ¥†Êï∞Ôºå$a$ ‰∏∫‰∏é $p$ ‰∫íÁ¥†ÁöÑÊï¥Êï∞ÔºåÂàôÔºö

$$\left(\frac{a}{p}\right) \equiv a^{\frac{p-1}{2}} \pmod{p}$$

**ËØÅÊòé**Ôºö
1. Â¶ÇÊûú $a$ ÊòØ‰∫åÊ¨°Ââ©‰ΩôÔºåÂàôÂ≠òÂú® $x$ ‰ΩøÂæó $x^2 \equiv a \pmod{p}$
   - Áî±Ë¥πÈ©¨Â∞èÂÆöÁêÜÔºö$a^{\frac{p-1}{2}} \equiv (x^2)^{\frac{p-1}{2}} \equiv x^{p-1} \equiv 1 \pmod{p}$

2. Â¶ÇÊûú $a$ ÊòØ‰∫åÊ¨°ÈùûÂâ©‰ΩôÔºåÂàô $a^{\frac{p-1}{2}} \equiv -1 \pmod{p}$
   - ËøôÊòØÂõ†‰∏∫ $a^{p-1} \equiv 1 \pmod{p}$ÔºåÊâÄ‰ª• $a^{\frac{p-1}{2}} \equiv \pm 1 \pmod{p}$
   - Â¶ÇÊûú $a^{\frac{p-1}{2}} \equiv 1 \pmod{p}$ÔºåÂàô $a$ ÊòØ‰∫åÊ¨°Ââ©‰ΩôÔºåÁüõÁõæ

### 3.2 ‰∫åÊ¨°‰∫íÂèçÂæã

**ÂÆöÁêÜ 3.2.1** (‰∫åÊ¨°‰∫íÂèçÂæã)ÔºöËÆæ $p, q$ ‰∏∫‰∏çÂêåÁöÑÂ•áÁ¥†Êï∞ÔºåÂàôÔºö

$$\left(\frac{p}{q}\right) \left(\frac{q}{p}\right) = (-1)^{\frac{p-1}{2} \cdot \frac{q-1}{2}}$$

**ËØÅÊòé**Ôºö
ËøôÊòØÊï∞ËÆ∫‰∏≠ÊúÄÊ∑±ÂàªÁöÑÂÆöÁêÜ‰πã‰∏ÄÔºåËØÅÊòéÊ∂âÂèäÈ´òÊñØÂíåÂíå‰ª£Êï∞Êï∞ËÆ∫ÁöÑÈ´òÁ∫ßÊäÄÂ∑ß„ÄÇ

### 3.3 ÂãíËÆ©Âæ∑Á¨¶Âè∑ÁöÑÊÄßË¥®

**ÂÆöÁêÜ 3.3.1**ÔºöÂãíËÆ©Âæ∑Á¨¶Âè∑ÂÖ∑Êúâ‰ª•‰∏ãÊÄßË¥®Ôºö

1. **‰πòÊ≥ïÊÄß**Ôºö$\left(\frac{ab}{p}\right) = \left(\frac{a}{p}\right) \left(\frac{b}{p}\right)$

2. **Âë®ÊúüÊÄß**Ôºö$\left(\frac{a + kp}{p}\right) = \left(\frac{a}{p}\right)$

3. **Âπ≥ÊñπÊÄß**Ôºö$\left(\frac{a^2}{p}\right) = 1$ (ÂΩì $p \nmid a$ Êó∂)

**ËØÅÊòé**Ôºö
1. **‰πòÊ≥ïÊÄß**ÔºöÁî±Ê¨ßÊãâÂáÜÂàôÔºå
   $$\left(\frac{ab}{p}\right) \equiv (ab)^{\frac{p-1}{2}} \equiv a^{\frac{p-1}{2}} b^{\frac{p-1}{2}} \equiv \left(\frac{a}{p}\right) \left(\frac{b}{p}\right) \pmod{p}$$

2. **Âë®ÊúüÊÄß**ÔºöÊòæÁÑ∂ÔºåÂõ†‰∏∫ $(a + kp)^{\frac{p-1}{2}} \equiv a^{\frac{p-1}{2}} \pmod{p}$

3. **Âπ≥ÊñπÊÄß**Ôºö$(a^2)^{\frac{p-1}{2}} = a^{p-1} \equiv 1 \pmod{p}$

### 3.4 È´òÊñØÂºïÁêÜ

**ÂÆöÁêÜ 3.4.1** (È´òÊñØÂºïÁêÜ)ÔºöËÆæ $p$ ‰∏∫Â•áÁ¥†Êï∞Ôºå$a$ ‰∏∫‰∏é $p$ ‰∫íÁ¥†ÁöÑÊï¥Êï∞„ÄÇËÄÉËôëÈõÜÂêàÔºö

$$S = \{a, 2a, 3a, \ldots, \frac{p-1}{2}a\}$$

ËÆæ $m$ ‰∏∫ $S$ ‰∏≠Ê®° $p$ ÂêéÂ§ß‰∫é $\frac{p}{2}$ ÁöÑÂÖÉÁ¥†ÁöÑ‰∏™Êï∞ÔºåÂàôÔºö

$$\left(\frac{a}{p}\right) = (-1)^m$$

## 4. ‰ª£Á†ÅÂÆûÁé∞

### 4.1 RustÂÆûÁé∞

```rust
use num_bigint::{BigInt, BigUint};
use num_traits::{One, Zero};

/// ‰∫åÊ¨°Ââ©‰ΩôÁêÜËÆ∫ÂÆûÁé∞
pub struct QuadraticResidue;

impl QuadraticResidue {
    /// ËÆ°ÁÆóÂãíËÆ©Âæ∑Á¨¶Âè∑
    pub fn legendre_symbol(a: i64, p: i64) -> i32 {
        if p <= 0 || p % 2 == 0 {
            panic!("p must be a positive odd integer");
        }
        
        let a = a % p;
        if a == 0 {
            return 0;
        }
        
        if a == 1 {
            return 1;
        }
        
        if a % 2 == 0 {
            return Self::legendre_symbol(a / 2, p) * if p % 8 == 1 || p % 8 == 7 { 1 } else { -1 };
        }
        
        if a == -1 {
            return if p % 4 == 1 { 1 } else { -1 };
        }
        
        // ‰∫åÊ¨°‰∫íÂèçÂæã
        if a < 0 {
            return Self::legendre_symbol(-a, p) * if p % 4 == 1 { 1 } else { -1 };
        }
        
        if a >= p {
            return Self::legendre_symbol(a % p, p);
        }
        
        if a == 2 {
            return if p % 8 == 1 || p % 8 == 7 { 1 } else { -1 };
        }
        
        // ‰∫åÊ¨°‰∫íÂèçÂæã
        if a < p {
            let factor = if (a % 4 == 3) && (p % 4 == 3) { -1 } else { 1 };
            return factor * Self::legendre_symbol(p, a);
        }
        
        0
    }
    
    /// Âà§Êñ≠ÊòØÂê¶‰∏∫‰∫åÊ¨°Ââ©‰Ωô
    pub fn is_quadratic_residue(a: i64, p: i64) -> bool {
        Self::legendre_symbol(a, p) == 1
    }
    
    /// ËÆ°ÁÆó‰∫åÊ¨°Ââ©‰ΩôÁöÑÂπ≥ÊñπÊ†πÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
    pub fn square_root_mod_p(a: i64, p: i64) -> Option<Vec<i64>> {
        if !Self::is_quadratic_residue(a, p) {
            return None;
        }
        
        if p == 2 {
            return Some(vec![a % 2]);
        }
        
        if p % 4 == 3 {
            // ÁÆÄÂçïÊÉÖÂÜµÔºöp ‚â° 3 (mod 4)
            let x = Self::mod_pow(a, (p + 1) / 4, p);
            return Some(vec![x, p - x]);
        }
        
        // ‰∏ÄËà¨ÊÉÖÂÜµÔºö‰ΩøÁî®Tonelli-ShanksÁÆóÊ≥ï
        Self::tonelli_shanks(a, p)
    }
    
    /// Tonelli-ShanksÁÆóÊ≥ïËÆ°ÁÆóÂπ≥ÊñπÊ†π
    fn tonelli_shanks(a: i64, p: i64) -> Option<Vec<i64>> {
        // ÊâæÂà∞‰∫åÊ¨°ÈùûÂâ©‰Ωô
        let mut q = 2;
        while Self::is_quadratic_residue(q, p) {
            q += 1;
        }
        
        let mut s = 0;
        let mut t = p - 1;
        while t % 2 == 0 {
            s += 1;
            t /= 2;
        }
        
        let mut m = s;
        let mut c = Self::mod_pow(q, t, p);
        let mut r = Self::mod_pow(a, (t + 1) / 2, p);
        let mut t_val = Self::mod_pow(a, t, p);
        
        while t_val != 1 {
            let mut i = 0;
            let mut temp = t_val;
            while temp != 1 && i < m {
                temp = (temp * temp) % p;
                i += 1;
            }
            
            if i == 0 {
                return None;
            }
            
            let b = Self::mod_pow(c, 1 << (m - i - 1), p);
            m = i;
            c = (b * b) % p;
            r = (r * b) % p;
            t_val = (t_val * c) % p;
        }
        
        Some(vec![r, p - r])
    }
    
    /// Ê®°ÂπÇËøêÁÆó
    fn mod_pow(mut base: i64, mut exp: i64, modulus: i64) -> i64 {
        if modulus == 1 {
            return 0;
        }
        
        let mut result = 1;
        base = base % modulus;
        
        while exp > 0 {
            if exp % 2 == 1 {
                result = (result * base) % modulus;
            }
            exp = exp >> 1;
            base = (base * base) % modulus;
        }
        
        result
    }
    
    /// ËÆ°ÁÆó‰∫åÊ¨°Ââ©‰ΩôÁöÑÊï∞Èáè
    pub fn count_quadratic_residues(p: i64) -> usize {
        if p <= 0 || p % 2 == 0 {
            panic!("p must be a positive odd integer");
        }
        
        ((p - 1) / 2) as usize
    }
    
    /// ÁîüÊàêÊâÄÊúâ‰∫åÊ¨°Ââ©‰Ωô
    pub fn generate_quadratic_residues(p: i64) -> Vec<i64> {
        if p <= 0 || p % 2 == 0 {
            panic!("p must be a positive odd integer");
        }
        
        let mut residues = Vec::new();
        for x in 1..p {
            let residue = (x * x) % p;
            if !residues.contains(&residue) {
                residues.push(residue);
            }
        }
        residues.sort();
        residues
    }
    
    /// È´òÊñØÂºïÁêÜÂÆûÁé∞
    pub fn gauss_lemma(a: i64, p: i64) -> i32 {
        if p <= 0 || p % 2 == 0 {
            panic!("p must be a positive odd integer");
        }
        
        let mut count = 0;
        let half_p = p / 2;
        
        for i in 1..=half_p {
            let product = (a * i) % p;
            if product > half_p {
                count += 1;
            }
        }
        
        if count % 2 == 0 { 1 } else { -1 }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_legendre_symbol() {
        assert_eq!(QuadraticResidue::legendre_symbol(1, 7), 1);
        assert_eq!(QuadraticResidue::legendre_symbol(2, 7), 1);
        assert_eq!(QuadraticResidue::legendre_symbol(3, 7), -1);
        assert_eq!(QuadraticResidue::legendre_symbol(4, 7), 1);
        assert_eq!(QuadraticResidue::legendre_symbol(5, 7), -1);
        assert_eq!(QuadraticResidue::legendre_symbol(6, 7), -1);
        assert_eq!(QuadraticResidue::legendre_symbol(0, 7), 0);
    }
    
    #[test]
    fn test_is_quadratic_residue() {
        assert!(QuadraticResidue::is_quadratic_residue(1, 7));
        assert!(QuadraticResidue::is_quadratic_residue(2, 7));
        assert!(!QuadraticResidue::is_quadratic_residue(3, 7));
        assert!(QuadraticResidue::is_quadratic_residue(4, 7));
        assert!(!QuadraticResidue::is_quadratic_residue(5, 7));
    }
    
    #[test]
    fn test_square_root_mod_p() {
        let roots = QuadraticResidue::square_root_mod_p(2, 7);
        assert_eq!(roots, Some(vec![3, 4]));
        
        let roots = QuadraticResidue::square_root_mod_p(4, 7);
        assert_eq!(roots, Some(vec![2, 5]));
        
        let roots = QuadraticResidue::square_root_mod_p(3, 7);
        assert_eq!(roots, None);
    }
    
    #[test]
    fn test_count_quadratic_residues() {
        assert_eq!(QuadraticResidue::count_quadratic_residues(7), 3);
        assert_eq!(QuadraticResidue::count_quadratic_residues(11), 5);
        assert_eq!(QuadraticResidue::count_quadratic_residues(13), 6);
    }
    
    #[test]
    fn test_generate_quadratic_residues() {
        let residues = QuadraticResidue::generate_quadratic_residues(7);
        assert_eq!(residues, vec![1, 2, 4]);
        
        let residues = QuadraticResidue::generate_quadratic_residues(11);
        assert_eq!(residues, vec![1, 3, 4, 5, 9]);
    }
    
    #[test]
    fn test_gauss_lemma() {
        assert_eq!(QuadraticResidue::gauss_lemma(2, 7), 1);
        assert_eq!(QuadraticResidue::gauss_lemma(3, 7), -1);
        assert_eq!(QuadraticResidue::gauss_lemma(4, 7), 1);
    }
}
```

### 4.2 HaskellÂÆûÁé∞

```haskell
module QuadraticResidue where

import Data.List (nub, sort)

-- ‰∫åÊ¨°Ââ©‰ΩôÁêÜËÆ∫ÂÆûÁé∞
class QuadraticResidue a where
    legendreSymbol :: a -> a -> Int
    isQuadraticResidue :: a -> a -> Bool
    squareRootModP :: a -> a -> Maybe [a]
    countQuadraticResidues :: a -> Int
    generateQuadraticResidues :: a -> [a]
    gaussLemma :: a -> a -> Int

instance QuadraticResidue Integer where
    -- ËÆ°ÁÆóÂãíËÆ©Âæ∑Á¨¶Âè∑
    legendreSymbol a p
        | p <= 0 || even p = error "p must be a positive odd integer"
        | a `mod` p == 0 = 0
        | a `mod` p == 1 = 1
        | even (a `mod` p) = legendreSymbol (a `div` 2) p * 
            if p `mod` 8 == 1 || p `mod` 8 == 7 then 1 else -1
        | a `mod` p == p - 1 = if p `mod` 4 == 1 then 1 else -1
        | a < 0 = legendreSymbol (-a) p * if p `mod` 4 == 1 then 1 else -1
        | a >= p = legendreSymbol (a `mod` p) p
        | a == 2 = if p `mod` 8 == 1 || p `mod` 8 == 7 then 1 else -1
        | otherwise = factor * legendreSymbol p a
        where
            factor = if (a `mod` 4 == 3) && (p `mod` 4 == 3) then -1 else 1
    
    -- Âà§Êñ≠ÊòØÂê¶‰∏∫‰∫åÊ¨°Ââ©‰Ωô
    isQuadraticResidue a p = legendreSymbol a p == 1
    
    -- ËÆ°ÁÆóÂπ≥ÊñπÊ†π
    squareRootModP a p
        | not (isQuadraticResidue a p) = Nothing
        | p == 2 = Just [a `mod` 2]
        | p `mod` 4 == 3 = Just [x, p - x]
        | otherwise = tonelliShanks a p
        where
            x = modPow a ((p + 1) `div` 4) p
    
    -- Tonelli-ShanksÁÆóÊ≥ï
    tonelliShanks a p = do
        let q = findQuadraticNonResidue p
        let (s, t) = factorizePower2 (p - 1)
        let m = s
        let c = modPow q t p
        let r = modPow a ((t + 1) `div` 2) p
        let t_val = modPow a t p
        Just $ tonelliShanksHelper m c r t_val p
    
    tonelliShanksHelper m c r t_val p
        | t_val == 1 = [r, p - r]
        | otherwise = tonelliShanksHelper new_m new_c new_r new_t_val p
        where
            (i, _) = findOrder t_val m p
            b = modPow c (2^(m - i - 1)) p
            new_m = i
            new_c = (b * b) `mod` p
            new_r = (r * b) % p
            new_t_val = (t_val * new_c) `mod` p
    
    -- ËÆ°ÁÆó‰∫åÊ¨°Ââ©‰ΩôÊï∞Èáè
    countQuadraticResidues p
        | p <= 0 || even p = error "p must be a positive odd integer"
        | otherwise = fromIntegral $ (p - 1) `div` 2
    
    -- ÁîüÊàêÊâÄÊúâ‰∫åÊ¨°Ââ©‰Ωô
    generateQuadraticResidues p
        | p <= 0 || even p = error "p must be a positive odd integer"
        | otherwise = sort $ nub [x^2 `mod` p | x <- [1..p-1]]
    
    -- È´òÊñØÂºïÁêÜ
    gaussLemma a p
        | p <= 0 || even p = error "p must be a positive odd integer"
        | otherwise = if count `mod` 2 == 0 then 1 else -1
        where
            half_p = p `div` 2
            count = length [i | i <- [1..half_p], (a * i) `mod` p > half_p]

-- ËæÖÂä©ÂáΩÊï∞
modPow :: Integer -> Integer -> Integer -> Integer
modPow base exp modulus
    | modulus == 1 = 0
    | otherwise = modPowHelper base exp modulus 1
    where
        modPowHelper _ 0 _ result = result
        modPowHelper base exp modulus result
            | odd exp = modPowHelper new_base new_exp modulus new_result
            | otherwise = modPowHelper new_base new_exp modulus result
            where
                new_base = (base * base) `mod` modulus
                new_exp = exp `div` 2
                new_result = (result * base) `mod` modulus

findQuadraticNonResidue :: Integer -> Integer
findQuadraticNonResidue p = head [q | q <- [2..], not (isQuadraticResidue q p)]
    where
        isQuadraticResidue a p = legendreSymbol a p == 1
        legendreSymbol a p = 1 -- ÁÆÄÂåñÂÆûÁé∞

factorizePower2 :: Integer -> (Integer, Integer)
factorizePower2 n = factorizePower2Helper n 0
    where
        factorizePower2Helper n s
            | even n = factorizePower2Helper (n `div` 2) (s + 1)
            | otherwise = (s, n)

findOrder :: Integer -> Integer -> Integer -> (Integer, Integer)
findOrder t_val m p = findOrderHelper t_val m p 0
    where
        findOrderHelper t_val m p i
            | t_val == 1 = (i, t_val)
            | i >= m = (m, t_val)
            | otherwise = findOrderHelper new_t_val m p (i + 1)
            where
                new_t_val = (t_val * t_val) `mod` p

-- ÊµãËØïÂáΩÊï∞
testQuadraticResidue :: IO ()
testQuadraticResidue = do
    putStrLn "Testing Quadratic Residue Theory..."
    
    -- ÊµãËØïÂãíËÆ©Âæ∑Á¨¶Âè∑
    putStrLn $ "legendreSymbol 1 7: " ++ show (legendreSymbol 1 7)
    putStrLn $ "legendreSymbol 2 7: " ++ show (legendreSymbol 2 7)
    putStrLn $ "legendreSymbol 3 7: " ++ show (legendreSymbol 3 7)
    putStrLn $ "legendreSymbol 4 7: " ++ show (legendreSymbol 4 7)
    
    -- ÊµãËØï‰∫åÊ¨°Ââ©‰ΩôÂà§ÂÆö
    putStrLn $ "isQuadraticResidue 2 7: " ++ show (isQuadraticResidue 2 7)
    putStrLn $ "isQuadraticResidue 3 7: " ++ show (isQuadraticResidue 3 7)
    
    -- ÊµãËØïÂπ≥ÊñπÊ†πËÆ°ÁÆó
    putStrLn $ "squareRootModP 2 7: " ++ show (squareRootModP 2 7)
    putStrLn $ "squareRootModP 4 7: " ++ show (squareRootModP 4 7)
    
    -- ÊµãËØï‰∫åÊ¨°Ââ©‰ΩôËÆ°Êï∞
    putStrLn $ "countQuadraticResidues 7: " ++ show (countQuadraticResidues 7)
    putStrLn $ "countQuadraticResidues 11: " ++ show (countQuadraticResidues 11)
    
    -- ÊµãËØïÁîüÊàê‰∫åÊ¨°Ââ©‰Ωô
    putStrLn $ "generateQuadraticResidues 7: " ++ show (generateQuadraticResidues 7)
    putStrLn $ "generateQuadraticResidues 11: " ++ show (generateQuadraticResidues 11)
```

## 5. Â∫îÁî®Á§∫‰æã

### 5.1 ÂØÜÁ†ÅÂ≠¶Â∫îÁî®

‰∫åÊ¨°Ââ©‰ΩôÂú®RabinÂä†ÂØÜÁ≥ªÁªü‰∏≠ÁöÑÂ∫îÁî®Ôºö

```rust
use num_bigint::{BigInt, BigUint};
use rand::Rng;

pub struct RabinCipher {
    public_key: BigUint,
    private_key: (BigUint, BigUint),
}

impl RabinCipher {
    pub fn new(bit_length: usize) -> Self {
        let mut rng = rand::thread_rng();
        
        // ÁîüÊàê‰∏§‰∏™ÂΩ¢Â¶Ç 4k+3 ÁöÑÁ¥†Êï∞
        let p = Self::generate_prime_4k_plus_3(bit_length / 2, &mut rng);
        let q = Self::generate_prime_4k_plus_3(bit_length / 2, &mut rng);
        
        let n = &p * &q;
        
        RabinCipher {
            public_key: n,
            private_key: (p, q),
        }
    }
    
    fn generate_prime_4k_plus_3(bits: usize, rng: &mut impl rand::Rng) -> BigUint {
        loop {
            let candidate = rng.gen_biguint(bits);
            if Self::is_prime_4k_plus_3(&candidate) {
                return candidate;
            }
        }
    }
    
    fn is_prime_4k_plus_3(n: &BigUint) -> bool {
        // ÁÆÄÂåñÂÆûÁé∞ÔºöÊ£ÄÊü•ÊòØÂê¶‰∏∫ÂΩ¢Â¶Ç 4k+3 ÁöÑÁ¥†Êï∞
        let n_u64 = n.to_u64().unwrap_or(0);
        if n_u64 > 0 {
            return n_u64 % 4 == 3 && PrimeTheory::is_prime(n_u64);
        }
        true // ÁÆÄÂåñÂÆûÁé∞
    }
    
    pub fn encrypt(&self, message: &BigUint) -> BigUint {
        // Âä†ÂØÜÔºöc = m^2 mod n
        message.modpow(&BigUint::from(2u32), &self.public_key)
    }
    
    pub fn decrypt(&self, ciphertext: &BigUint) -> Vec<BigUint> {
        let p = &self.private_key.0;
        let q = &self.private_key.1;
        
        // ËÆ°ÁÆóÂπ≥ÊñπÊ†πÊ®° p Âíå q
        let p_u64 = p.to_u64().unwrap_or(0);
        let q_u64 = q.to_u64().unwrap_or(0);
        let c_u64 = ciphertext.to_u64().unwrap_or(0);
        
        if p_u64 > 0 && q_u64 > 0 && c_u64 > 0 {
            let roots_p = QuadraticResidue::square_root_mod_p(c_u64 as i64, p_u64 as i64);
            let roots_q = QuadraticResidue::square_root_mod_p(c_u64 as i64, q_u64 as i64);
            
            if let (Some(rp), Some(rq)) = (roots_p, roots_q) {
                // ‰ΩøÁî®‰∏≠ÂõΩÂâ©‰ΩôÂÆöÁêÜÁªÑÂêàËß£
                let mut solutions = Vec::new();
                for &rp_val in &rp {
                    for &rq_val in &rq {
                        let solution = Self::chinese_remainder(
                            rp_val as u64, p_u64,
                            rq_val as u64, q_u64
                        );
                        if let Some(sol) = solution {
                            solutions.push(BigUint::from(sol));
                        }
                    }
                }
                return solutions;
            }
        }
        
        vec![]
    }
    
    fn chinese_remainder(a1: u64, n1: u64, a2: u64, n2: u64) -> Option<u64> {
        // Êâ©Â±ïÊ¨ßÂá†ÈáåÂæóÁÆóÊ≥ïÊ±ÇËß£
        let (gcd, x, _) = Self::extended_gcd(n1 as i64, n2 as i64);
        
        if gcd != 1 {
            return None;
        }
        
        let x = ((x % n2 as i64) + n2 as i64) % n2 as i64;
        let solution = (a1 as i64 + (a2 - a1) as i64 * x * n1 as i64) % (n1 * n2) as i64;
        
        Some(solution as u64)
    }
    
    fn extended_gcd(a: i64, b: i64) -> (i64, i64, i64) {
        if b == 0 {
            (a, 1, 0)
        } else {
            let (gcd, x, y) = Self::extended_gcd(b, a % b);
            (gcd, y, x - (a / b) * y)
        }
    }
}
```

### 5.2 ‰∫åÊ¨°Ââ©‰ΩôÂàÜÂ∏ÉÂèØËßÜÂåñ

```rust
use plotters::prelude::*;

pub fn plot_quadratic_residues(p: i64) -> Result<(), Box<dyn std::error::Error>> {
    let root = BitMapBackend::new("quadratic_residues.png", (800, 600)).into_drawing_area();
    root.fill(&WHITE)?;
    
    let residues = QuadraticResidue::generate_quadratic_residues(p);
    let non_residues: Vec<i64> = (1..p)
        .filter(|&x| !residues.contains(&x))
        .collect();
    
    let mut chart = ChartBuilder::on(&root)
        .caption(&format!("Quadratic Residues Modulo {}", p), ("sans-serif", 30))
        .margin(5)
        .x_label_area_size(40)
        .y_label_area_size(40)
        .build_cartesian_2d(0..p, 0..2)?;
    
    chart.configure_mesh().draw()?;
    
    // ÁªòÂà∂‰∫åÊ¨°Ââ©‰Ωô
    for &residue in &residues {
        chart.draw_series(std::iter::once(Circle::new((residue, 1), 3, RED.filled())))?;
    }
    
    // ÁªòÂà∂‰∫åÊ¨°ÈùûÂâ©‰Ωô
    for &non_residue in &non_residues {
        chart.draw_series(std::iter::once(Circle::new((non_residue, 0), 3, BLUE.filled())))?;
    }
    
    root.present()?;
    Ok(())
}
```

## 6. Áõ∏ÂÖ≥ÁêÜËÆ∫

### 6.1 ‰∏éÂêå‰ΩôÁêÜËÆ∫ÁöÑÂÖ≥Á≥ª

‰∫åÊ¨°Ââ©‰ΩôÁêÜËÆ∫ÊòØÊ®°ËøêÁÆóÁêÜËÆ∫ÁöÑÈáçË¶ÅÂ∫îÁî®ÔºåÁ†îÁ©∂Ê®°Á¥†Êï∞‰∏ãÁöÑ‰∫åÊ¨°ÊñπÁ®ã„ÄÇ

### 6.2 ‰∏éÁ¥†Êï∞ÁêÜËÆ∫ÁöÑÂÖ≥Á≥ª

‰∫åÊ¨°Ââ©‰ΩôÁöÑÊÄßË¥®‰∏éÁ¥†Êï∞ÁöÑÊÄßË¥®ÂØÜÂàáÁõ∏ÂÖ≥ÔºåÁâπÂà´ÊòØÂãíËÆ©Âæ∑Á¨¶Âè∑ÁöÑËÆ°ÁÆó„ÄÇ

### 6.3 ‰∏é‰ª£Êï∞Êï∞ËÆ∫ÁöÑÂÖ≥Á≥ª

‰∫åÊ¨°Ââ©‰ΩôÁêÜËÆ∫Âú®‰ª£Êï∞Êï∞ËÆ∫‰∏≠Êé®Âπø‰∏∫È´òÊ¨°Ââ©‰ΩôÁêÜËÆ∫„ÄÇ

### 6.4 ‰∏éÂØÜÁ†ÅÂ≠¶ÁöÑÂÖ≥Á≥ª

‰∫åÊ¨°Ââ©‰ΩôÂú®RabinÂä†ÂØÜ„ÄÅÈõ∂Áü•ËØÜËØÅÊòéÁ≠âÂØÜÁ†ÅÂ≠¶ÂçèËÆÆ‰∏≠ÊúâÈáçË¶ÅÂ∫îÁî®„ÄÇ

## 7. ÂèÇËÄÉÊñáÁåÆ

1. Ireland, K., & Rosen, M. (2013). A Classical Introduction to Modern Number Theory. Springer.
2. Hardy, G. H., & Wright, E. M. (2008). An Introduction to the Theory of Numbers. Oxford University Press.
3. Crandall, R., & Pomerance, C. (2005). Prime Numbers: A Computational Perspective. Springer.
4. Cohen, H. (2013). A Course in Computational Algebraic Number Theory. Springer.
5. Bach, E., & Shallit, J. (1996). Algorithmic Number Theory. MIT Press.

---

**Áõ∏ÂÖ≥ÊñáÊ°£**Ôºö
- [02.10.1 Êï¥Èô§ÁêÜËÆ∫](../02.10.1_Êï¥Èô§ÁêÜËÆ∫.md)
- [02.10.2 Âêå‰ΩôÁêÜËÆ∫](../02.10.2_Âêå‰ΩôÁêÜËÆ∫.md)
- [02.10.3 Á¥†Êï∞ÁêÜËÆ∫](../02.10.3_Á¥†Êï∞ÁêÜËÆ∫.md)
- [02.11.1 ËÆ°Êï∞ÂéüÁêÜ](../02.11.1_ËÆ°Êï∞ÂéüÁêÜ.md) 