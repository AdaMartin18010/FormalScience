# 02.9.3 å¾®åˆ†å­¦

## ğŸ“‹ æ¦‚è¿°

å¾®åˆ†å­¦æ˜¯æ•°å­¦åˆ†æçš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶å‡½æ•°çš„å±€éƒ¨å˜åŒ–ç‡å’Œåˆ‡çº¿æ€§è´¨ã€‚æœ¬æ–‡æ¡£å»ºç«‹ä¸¥æ ¼çš„å¾®åˆ†å­¦ç†è®ºæ¡†æ¶ï¼ŒåŒ…å«å½¢å¼åŒ–å®šä¹‰ã€å®šç†è¯æ˜å’Œå®é™…åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ä¸¥æ ¼çš„å¾®åˆ†æ¦‚å¿µå’Œå½¢å¼åŒ–å®šä¹‰
2. è¯æ˜å¾®åˆ†å­¦çš„åŸºæœ¬å®šç†
3. æä¾›å®Œæ•´çš„ä»£ç å®ç°
4. å±•ç¤ºå¾®åˆ†å­¦åœ¨å½¢å¼ç§‘å­¦ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å¯¼æ•°çš„ç›´è§‚ç†è§£

å¯¼æ•°æè¿°å‡½æ•°åœ¨æŸç‚¹çš„ç¬æ—¶å˜åŒ–ç‡ï¼Œå‡ ä½•ä¸Šè¡¨ç¤ºåˆ‡çº¿çš„æ–œç‡ã€‚

**å®šä¹‰ 1.1.1** (å¯¼æ•°ç›´è§‚å®šä¹‰)
è®¾å‡½æ•° $f: \mathbb{R} \to \mathbb{R}$ï¼Œç‚¹ $x_0 \in \mathbb{R}$ï¼Œå¦‚æœæé™
$$\lim_{h \to 0} \frac{f(x_0 + h) - f(x_0)}{h}$$
å­˜åœ¨ï¼Œåˆ™ç§°è¯¥æé™ä¸º $f$ åœ¨ $x_0$ å¤„çš„å¯¼æ•°ï¼Œè®°ä½œ $f'(x_0)$ã€‚

### 1.2 å¯å¾®æ€§

**å®šä¹‰ 1.2.1** (å¯å¾®å‡½æ•°)
å‡½æ•° $f$ åœ¨ç‚¹ $x_0$ å¤„å¯å¾®ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨çº¿æ€§å‡½æ•° $L: \mathbb{R} \to \mathbb{R}$ ä½¿å¾—ï¼š
$$\lim_{h \to 0} \frac{f(x_0 + h) - f(x_0) - L(h)}{h} = 0$$

### 1.3 å¾®åˆ†ç®—å­

**å®šä¹‰ 1.3.1** (å¾®åˆ†ç®—å­)
å¾®åˆ†ç®—å­ $D$ æ˜¯ä¸€ä¸ªä»å¯å¾®å‡½æ•°ç©ºé—´åˆ°å‡½æ•°ç©ºé—´çš„çº¿æ€§ç®—å­ï¼š
$$D: C^1(\mathbb{R}) \to C(\mathbb{R})$$
$$D(f) = f'$$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ä¸¥æ ¼å¯¼æ•°å®šä¹‰

**å®šä¹‰ 2.1.1** (Îµ-Î´ å¯¼æ•°å®šä¹‰)
å‡½æ•° $f: \mathbb{R} \to \mathbb{R}$ åœ¨ç‚¹ $x_0$ å¤„å¯å¯¼ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨å®æ•° $L$ï¼Œä½¿å¾—å¯¹ä»»æ„ $\varepsilon > 0$ï¼Œå­˜åœ¨ $\delta > 0$ï¼Œå½“ $0 < |h| < \delta$ æ—¶ï¼š
$$\left|\frac{f(x_0 + h) - f(x_0)}{h} - L\right| < \varepsilon$$

æ­¤æ—¶ $L = f'(x_0)$ã€‚

### 2.2 é«˜é˜¶å¯¼æ•°

**å®šä¹‰ 2.2.1** (né˜¶å¯¼æ•°)
å‡½æ•° $f$ çš„ n é˜¶å¯¼æ•°é€’å½’å®šä¹‰ä¸ºï¼š
$$f^{(0)} = f$$
$$f^{(n)} = (f^{(n-1)})' \quad (n \geq 1)$$

### 2.3 åå¯¼æ•°

**å®šä¹‰ 2.3.1** (åå¯¼æ•°)
è®¾ $f: \mathbb{R}^n \to \mathbb{R}$ï¼Œåœ¨ç‚¹ $x = (x_1, \ldots, x_n)$ å¤„å…³äºç¬¬ $i$ ä¸ªå˜é‡çš„åå¯¼æ•°å®šä¹‰ä¸ºï¼š
$$\frac{\partial f}{\partial x_i}(x) = \lim_{h \to 0} \frac{f(x_1, \ldots, x_i + h, \ldots, x_n) - f(x_1, \ldots, x_n)}{h}$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬æ±‚å¯¼æ³•åˆ™

**å®šç† 3.1.1** (çº¿æ€§æ€§)
è®¾ $f, g$ åœ¨ $x_0$ å¤„å¯å¯¼ï¼Œ$\alpha, \beta \in \mathbb{R}$ï¼Œåˆ™ï¼š
$$(\alpha f + \beta g)'(x_0) = \alpha f'(x_0) + \beta g'(x_0)$$

**è¯æ˜**ï¼š
$$\begin{align}
(\alpha f + \beta g)'(x_0) &= \lim_{h \to 0} \frac{(\alpha f + \beta g)(x_0 + h) - (\alpha f + \beta g)(x_0)}{h} \\
&= \lim_{h \to 0} \frac{\alpha f(x_0 + h) + \beta g(x_0 + h) - \alpha f(x_0) - \beta g(x_0)}{h} \\
&= \alpha \lim_{h \to 0} \frac{f(x_0 + h) - f(x_0)}{h} + \beta \lim_{h \to 0} \frac{g(x_0 + h) - g(x_0)}{h} \\
&= \alpha f'(x_0) + \beta g'(x_0)
\end{align}$$

**å®šç† 3.1.2** (ä¹˜ç§¯æ³•åˆ™)
è®¾ $f, g$ åœ¨ $x_0$ å¤„å¯å¯¼ï¼Œåˆ™ï¼š
$$(fg)'(x_0) = f'(x_0)g(x_0) + f(x_0)g'(x_0)$$

**è¯æ˜**ï¼š
$$\begin{align}
(fg)'(x_0) &= \lim_{h \to 0} \frac{f(x_0 + h)g(x_0 + h) - f(x_0)g(x_0)}{h} \\
&= \lim_{h \to 0} \frac{f(x_0 + h)g(x_0 + h) - f(x_0)g(x_0 + h) + f(x_0)g(x_0 + h) - f(x_0)g(x_0)}{h} \\
&= \lim_{h \to 0} \frac{f(x_0 + h) - f(x_0)}{h} \cdot g(x_0 + h) + f(x_0) \cdot \frac{g(x_0 + h) - g(x_0)}{h} \\
&= f'(x_0)g(x_0) + f(x_0)g'(x_0)
\end{align}$$

### 3.2 é“¾å¼æ³•åˆ™

**å®šç† 3.2.1** (é“¾å¼æ³•åˆ™)
è®¾ $f$ åœ¨ $g(x_0)$ å¤„å¯å¯¼ï¼Œ$g$ åœ¨ $x_0$ å¤„å¯å¯¼ï¼Œåˆ™ï¼š
$$(f \circ g)'(x_0) = f'(g(x_0)) \cdot g'(x_0)$$

**è¯æ˜**ï¼š
è®¾ $y_0 = g(x_0)$ï¼Œåˆ™ï¼š
$$\begin{align}
(f \circ g)'(x_0) &= \lim_{h \to 0} \frac{f(g(x_0 + h)) - f(g(x_0))}{h} \\
&= \lim_{h \to 0} \frac{f(g(x_0 + h)) - f(g(x_0))}{g(x_0 + h) - g(x_0)} \cdot \frac{g(x_0 + h) - g(x_0)}{h} \\
&= f'(g(x_0)) \cdot g'(x_0)
\end{align}$$

### 3.3 ä¸­å€¼å®šç†

**å®šç† 3.3.1** (æ‹‰æ ¼æœ—æ—¥ä¸­å€¼å®šç†)
è®¾ $f$ åœ¨é—­åŒºé—´ $[a, b]$ ä¸Šè¿ç»­ï¼Œåœ¨å¼€åŒºé—´ $(a, b)$ ä¸Šå¯å¯¼ï¼Œåˆ™å­˜åœ¨ $\xi \in (a, b)$ ä½¿å¾—ï¼š
$$f(b) - f(a) = f'(\xi)(b - a)$$

**è¯æ˜**ï¼š
æ„é€ è¾…åŠ©å‡½æ•°ï¼š
$$F(x) = f(x) - f(a) - \frac{f(b) - f(a)}{b - a}(x - a)$$

åˆ™ $F(a) = F(b) = 0$ï¼Œç”±ç½—å°”å®šç†ï¼Œå­˜åœ¨ $\xi \in (a, b)$ ä½¿å¾— $F'(\xi) = 0$ï¼Œå³ï¼š
$$f'(\xi) - \frac{f(b) - f(a)}{b - a} = 0$$

å› æ­¤ï¼š
$$f(b) - f(a) = f'(\xi)(b - a)$$

## 4. ä»£ç å®ç°

### 4.1 Rust å®ç°

```rust
use std::f64;

/// æ•°å€¼å¾®åˆ†å®ç°
pub struct NumericalDifferentiation;

impl NumericalDifferentiation {
    /// ä½¿ç”¨ä¸­å¿ƒå·®åˆ†è®¡ç®—æ•°å€¼å¯¼æ•°
    pub fn central_difference<F>(f: F, x: f64, h: f64) -> f64 
    where
        F: Fn(f64) -> f64,
    {
        (f(x + h) - f(x - h)) / (2.0 * h)
    }
    
    /// ä½¿ç”¨å‰å‘å·®åˆ†è®¡ç®—æ•°å€¼å¯¼æ•°
    pub fn forward_difference<F>(f: F, x: f64, h: f64) -> f64 
    where
        F: Fn(f64) -> f64,
    {
        (f(x + h) - f(x)) / h
    }
    
    /// è‡ªé€‚åº”æ­¥é•¿çš„æ•°å€¼å¾®åˆ†
    pub fn adaptive_differentiation<F>(f: F, x: f64, tolerance: f64) -> f64 
    where
        F: Fn(f64) -> f64,
    {
        let mut h = 1e-6;
        let mut prev_derivative = Self::central_difference(&f, x, h);
        
        loop {
            h /= 2.0;
            let current_derivative = Self::central_difference(&f, x, h);
            
            if (current_derivative - prev_derivative).abs() < tolerance {
                return current_derivative;
            }
            
            prev_derivative = current_derivative;
        }
    }
}

/// ç¬¦å·å¾®åˆ†å®ç°
pub struct SymbolicDifferentiation;

impl SymbolicDifferentiation {
    /// å¤šé¡¹å¼æ±‚å¯¼
    pub fn differentiate_polynomial(coefficients: &[f64]) -> Vec<f64> {
        coefficients
            .iter()
            .enumerate()
            .skip(1)
            .map(|(i, &coeff)| coeff * i as f64)
            .collect()
    }
    
    /// åŸºæœ¬å‡½æ•°æ±‚å¯¼
    pub fn differentiate_basic_function(func_type: &str, x: f64) -> f64 {
        match func_type {
            "sin" => x.cos(),
            "cos" => -x.sin(),
            "exp" => x.exp(),
            "ln" => 1.0 / x,
            "power" => x.powf(x - 1.0),
            _ => panic!("Unknown function type"),
        }
    }
}

/// è‡ªåŠ¨å¾®åˆ†å®ç°
#[derive(Debug, Clone)]
pub struct DualNumber {
    pub real: f64,
    pub dual: f64,
}

impl DualNumber {
    pub fn new(real: f64, dual: f64) -> Self {
        Self { real, dual }
    }
    
    pub fn constant(x: f64) -> Self {
        Self::new(x, 0.0)
    }
    
    pub fn variable(x: f64) -> Self {
        Self::new(x, 1.0)
    }
}

impl std::ops::Add for DualNumber {
    type Output = Self;
    
    fn add(self, other: Self) -> Self {
        Self::new(self.real + other.real, self.dual + other.dual)
    }
}

impl std::ops::Mul for DualNumber {
    type Output = Self;
    
    fn mul(self, other: Self) -> Self {
        Self::new(
            self.real * other.real,
            self.real * other.dual + self.dual * other.real,
        )
    }
}

impl DualNumber {
    pub fn sin(self) -> Self {
        Self::new(self.real.sin(), self.dual * self.real.cos())
    }
    
    pub fn cos(self) -> Self {
        Self::new(self.real.cos(), -self.dual * self.real.sin())
    }
    
    pub fn exp(self) -> Self {
        let exp_real = self.real.exp();
        Self::new(exp_real, self.dual * exp_real)
    }
}

/// è‡ªåŠ¨å¾®åˆ†å‡½æ•°
pub fn automatic_differentiation<F>(f: F, x: f64) -> f64 
where
    F: Fn(DualNumber) -> DualNumber,
{
    let dual_x = DualNumber::variable(x);
    let result = f(dual_x);
    result.dual
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_numerical_differentiation() {
        let f = |x: f64| x.powi(2);
        let derivative = NumericalDifferentiation::central_difference(f, 2.0, 1e-6);
        assert!((derivative - 4.0).abs() < 1e-5);
    }
    
    #[test]
    fn test_symbolic_differentiation() {
        let coefficients = vec![1.0, 2.0, 3.0]; // 1 + 2x + 3xÂ²
        let derivative = SymbolicDifferentiation::differentiate_polynomial(&coefficients);
        assert_eq!(derivative, vec![2.0, 6.0]); // 2 + 6x
    }
    
    #[test]
    fn test_automatic_differentiation() {
        let f = |x: DualNumber| x * x; // xÂ²
        let derivative = automatic_differentiation(f, 3.0);
        assert!((derivative - 6.0).abs() < 1e-10);
    }
}
```

### 4.2 Haskell å®ç°

```haskell
-- æ•°å€¼å¾®åˆ†
module Differentiation where

import Data.List

-- ä¸­å¿ƒå·®åˆ†
centralDifference :: (Double -> Double) -> Double -> Double -> Double
centralDifference f x h = (f (x + h) - f (x - h)) / (2 * h)

-- å‰å‘å·®åˆ†
forwardDifference :: (Double -> Double) -> Double -> Double -> Double
forwardDifference f x h = (f (x + h) - f x) / h

-- è‡ªé€‚åº”æ­¥é•¿å¾®åˆ†
adaptiveDifferentiation :: (Double -> Double) -> Double -> Double -> Double
adaptiveDifferentiation f x tolerance = go 1e-6
  where
    go h = let
        current = centralDifference f x h
        next = centralDifference f x (h / 2)
        in if abs (next - current) < tolerance
           then next
           else go (h / 2)

-- ç¬¦å·å¾®åˆ†
data Expression = 
    Constant Double
  | Variable String
  | Add Expression Expression
  | Multiply Expression Expression
  | Power Expression Double
  | Sin Expression
  | Cos Expression
  | Exp Expression
  | Ln Expression

-- ç¬¦å·æ±‚å¯¼
differentiate :: Expression -> Expression
differentiate (Constant _) = Constant 0
differentiate (Variable _) = Constant 1
differentiate (Add e1 e2) = Add (differentiate e1) (differentiate e2)
differentiate (Multiply e1 e2) = 
    Add (Multiply (differentiate e1) e2) (Multiply e1 (differentiate e2))
differentiate (Power e n) = 
    Multiply (Multiply (Constant n) (Power e (n - 1))) (differentiate e)
differentiate (Sin e) = Multiply (Cos e) (differentiate e)
differentiate (Cos e) = Multiply (Multiply (Constant (-1)) (Sin e)) (differentiate e)
differentiate (Exp e) = Multiply (Exp e) (differentiate e)
differentiate (Ln e) = Multiply (Power e (-1)) (differentiate e)

-- è‡ªåŠ¨å¾®åˆ†
data Dual = Dual Double Double

instance Num Dual where
    (Dual a b) + (Dual c d) = Dual (a + c) (b + d)
    (Dual a b) * (Dual c d) = Dual (a * c) (a * d + b * c)
    negate (Dual a b) = Dual (-a) (-b)
    abs (Dual a b) = Dual (abs a) (if a >= 0 then b else -b)
    signum (Dual a _) = Dual (signum a) 0
    fromInteger n = Dual (fromInteger n) 0

instance Floating Dual where
    pi = Dual pi 0
    exp (Dual a b) = Dual (exp a) (b * exp a)
    log (Dual a b) = Dual (log a) (b / a)
    sin (Dual a b) = Dual (sin a) (b * cos a)
    cos (Dual a b) = Dual (cos a) (-b * sin a)
    asin (Dual a b) = Dual (asin a) (b / sqrt (1 - a^2))
    acos (Dual a b) = Dual (acos a) (-b / sqrt (1 - a^2))
    atan (Dual a b) = Dual (atan a) (b / (1 + a^2))
    sinh (Dual a b) = Dual (sinh a) (b * cosh a)
    cosh (Dual a b) = Dual (cosh a) (b * sinh a)
    asinh (Dual a b) = Dual (asinh a) (b / sqrt (1 + a^2))
    acosh (Dual a b) = Dual (acosh a) (b / sqrt (a^2 - 1))
    atanh (Dual a b) = Dual (atanh a) (b / (1 - a^2))

-- è‡ªåŠ¨å¾®åˆ†å‡½æ•°
automaticDifferentiation :: (Dual -> Dual) -> Double -> Double
automaticDifferentiation f x = dual
  where
    Dual _ dual = f (Dual x 1)

-- æµ‹è¯•å‡½æ•°
testDifferentiation :: IO ()
testDifferentiation = do
    let f x = x^2
    putStrLn "æ•°å€¼å¾®åˆ†æµ‹è¯•:"
    print $ centralDifference f 2.0 1e-6
    putStrLn "è‡ªåŠ¨å¾®åˆ†æµ‹è¯•:"
    print $ automaticDifferentiation (\x -> x * x) 2.0
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ä¼˜åŒ–ç®—æ³•ä¸­çš„åº”ç”¨

```rust
/// æ¢¯åº¦ä¸‹é™ä¼˜åŒ–
pub struct GradientDescent {
    learning_rate: f64,
    tolerance: f64,
    max_iterations: usize,
}

impl GradientDescent {
    pub fn new(learning_rate: f64, tolerance: f64, max_iterations: usize) -> Self {
        Self {
            learning_rate,
            tolerance,
            max_iterations,
        }
    }
    
    pub fn optimize<F, G>(&self, f: F, grad_f: G, initial_x: f64) -> f64 
    where
        F: Fn(f64) -> f64,
        G: Fn(f64) -> f64,
    {
        let mut x = initial_x;
        
        for iteration in 0..self.max_iterations {
            let gradient = grad_f(x);
            
            if gradient.abs() < self.tolerance {
                println!("æ”¶æ•›äºç¬¬ {} æ¬¡è¿­ä»£", iteration);
                break;
            }
            
            x -= self.learning_rate * gradient;
        }
        
        x
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let optimizer = GradientDescent::new(0.01, 1e-6, 1000);
    
    // æœ€å°åŒ–å‡½æ•° f(x) = xÂ² + 2x + 1
    let f = |x: f64| x.powi(2) + 2.0 * x + 1.0;
    let grad_f = |x: f64| 2.0 * x + 2.0;
    
    let minimum = optimizer.optimize(f, grad_f, 5.0);
    println!("æœ€å°å€¼ç‚¹: x = {}", minimum);
    println!("æœ€å°å€¼: f(x) = {}", f(minimum));
}
```

### 5.2 ç‰©ç†æ¨¡æ‹Ÿä¸­çš„åº”ç”¨

```rust
/// å¼¹ç°§-è´¨é‡ç³»ç»Ÿæ¨¡æ‹Ÿ
pub struct SpringMassSystem {
    mass: f64,
    spring_constant: f64,
    damping_coefficient: f64,
}

impl SpringMassSystem {
    pub fn new(mass: f64, spring_constant: f64, damping_coefficient: f64) -> Self {
        Self {
            mass,
            spring_constant,
            damping_coefficient,
        }
    }
    
    /// è®¡ç®—åŠ é€Ÿåº¦ (ä½¿ç”¨ç‰›é¡¿ç¬¬äºŒå®šå¾‹)
    pub fn acceleration(&self, position: f64, velocity: f64) -> f64 {
        let spring_force = -self.spring_constant * position;
        let damping_force = -self.damping_coefficient * velocity;
        (spring_force + damping_force) / self.mass
    }
    
    /// æ¬§æ‹‰æ–¹æ³•æ•°å€¼ç§¯åˆ†
    pub fn simulate(&self, initial_position: f64, initial_velocity: f64, 
                   time_step: f64, total_time: f64) -> Vec<(f64, f64, f64)> {
        let mut positions = Vec::new();
        let mut position = initial_position;
        let mut velocity = initial_velocity;
        let mut time = 0.0;
        
        while time <= total_time {
            let acceleration = self.acceleration(position, velocity);
            
            positions.push((time, position, velocity));
            
            // æ¬§æ‹‰ç§¯åˆ†
            position += velocity * time_step;
            velocity += acceleration * time_step;
            time += time_step;
        }
        
        positions
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸ç§¯åˆ†å­¦çš„å…³ç³»

å¾®åˆ†å­¦ä¸ç§¯åˆ†å­¦é€šè¿‡å¾®ç§¯åˆ†åŸºæœ¬å®šç†ç´§å¯†è”ç³»ï¼š

**å®šç† 6.1.1** (å¾®ç§¯åˆ†åŸºæœ¬å®šç†)
è®¾ $f$ åœ¨ $[a, b]$ ä¸Šè¿ç»­ï¼Œ$F$ æ˜¯ $f$ çš„åŸå‡½æ•°ï¼Œåˆ™ï¼š
$$\int_a^b f(x) dx = F(b) - F(a)$$

### 6.2 ä¸æ³°å‹’çº§æ•°çš„å…³ç³»

**å®šç† 6.2.1** (æ³°å‹’å®šç†)
è®¾ $f$ åœ¨ $x_0$ çš„é‚»åŸŸå†…å…·æœ‰ $n+1$ é˜¶å¯¼æ•°ï¼Œåˆ™ï¼š
$$f(x) = \sum_{k=0}^n \frac{f^{(k)}(x_0)}{k!}(x - x_0)^k + R_n(x)$$

å…¶ä¸­ä½™é¡¹ $R_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!}(x - x_0)^{n+1}$ï¼Œ$\xi$ åœ¨ $x_0$ ä¸ $x$ ä¹‹é—´ã€‚

### 6.3 ä¸å¾®åˆ†æ–¹ç¨‹çš„å…³ç³»

å¾®åˆ†å­¦ä¸ºå¾®åˆ†æ–¹ç¨‹ç†è®ºæä¾›åŸºç¡€ï¼š

**å®šä¹‰ 6.3.1** (å¸¸å¾®åˆ†æ–¹ç¨‹)
å½¢å¦‚ $F(x, y, y', y'', \ldots, y^{(n)}) = 0$ çš„æ–¹ç¨‹ç§°ä¸º n é˜¶å¸¸å¾®åˆ†æ–¹ç¨‹ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. **Rudin, W.** (1976). *Principles of Mathematical Analysis*. McGraw-Hill.
2. **Apostol, T. M.** (1974). *Mathematical Analysis*. Addison-Wesley.
3. **Spivak, M.** (2008). *Calculus*. Publish or Perish.
4. **Courant, R., & John, F.** (1999). *Introduction to Calculus and Analysis*. Springer.
5. **DieudonnÃ©, J.** (1969). *Foundations of Modern Analysis*. Academic Press.

---

**ç›¸å…³æ–‡æ¡£**:
- [02.9.1 æé™ç†è®º](../02.9.1_æé™ç†è®º.md)
- [02.9.2 è¿ç»­æ€§](../02.9.2_è¿ç»­æ€§.md)
- [02.9.4 ç§¯åˆ†å­¦](../02.9.4_ç§¯åˆ†å­¦.md)
- [02.4.1 å‡½æ•°æ¦‚å¿µ](../02.4.1_å‡½æ•°æ¦‚å¿µ.md)
- [02.4.2 å‡½æ•°æ€§è´¨](../02.4.2_å‡½æ•°æ€§è´¨.md) 