# 02.1.4 é›†åˆå…³ç³»ç†è®º

## ğŸ“‹ æ¦‚è¿°

é›†åˆå…³ç³»ç†è®ºç ”ç©¶é›†åˆä¹‹é—´çš„å„ç§å…³ç³»ç±»å‹å’Œæ€§è´¨ã€‚æœ¬ç†è®ºæ¢è®¨é›†åˆé—´çš„åŒ…å«ã€ç›¸ç­‰ã€ç›¸äº¤ã€ä¸ç›¸äº¤ç­‰å…³ç³»ï¼Œä¸ºç†è§£é›†åˆé—´çš„å¤æ‚è”ç³»æä¾›å½¢å¼åŒ–æ¡†æ¶ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹é›†åˆå…³ç³»çš„å½¢å¼åŒ–ç†è®º**
2. **åˆ†æä¸åŒå…³ç³»ç±»å‹çš„é€»è¾‘æ€§è´¨**
3. **æ„å»ºå…³ç³»è¿ç®—çš„å½¢å¼åŒ–ç³»ç»Ÿ**
4. **æä¾›å…³ç³»æ¨ç†çš„æ•°å­¦æ–¹æ³•**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å…³ç³»ç±»å‹](#3-å…³ç³»ç±»å‹)
4. [å…³ç³»è¿ç®—](#4-å…³ç³»è¿ç®—)
5. [å½¢å¼åŒ–è¯æ˜](#5-å½¢å¼åŒ–è¯æ˜)
6. [ä»£ç å®ç°](#6-ä»£ç å®ç°)
7. [åº”ç”¨ç¤ºä¾‹](#7-åº”ç”¨ç¤ºä¾‹)
8. [ç›¸å…³ç†è®º](#8-ç›¸å…³ç†è®º)
9. [å‚è€ƒæ–‡çŒ®](#9-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 é›†åˆå…³ç³»çš„å®šä¹‰

**å®šä¹‰ 1.1** (é›†åˆå…³ç³»)
é›†åˆå…³ç³»æ˜¯æŒ‡é›†åˆä¹‹é—´å­˜åœ¨çš„å„ç§è”ç³»å’Œä¾èµ–å…³ç³»ï¼Œè¿™äº›å…³ç³»å†³å®šäº†é›†åˆçš„ç»“æ„å’Œæ€§è´¨ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
è®¾ $A, B$ ä¸ºé›†åˆï¼Œåˆ™é›†åˆå…³ç³»å¯ä»¥è¡¨ç¤ºä¸ºï¼š
$$\text{SetRelation} = \langle A, B, R \rangle$$
å…¶ä¸­ $R$ æ˜¯å…³ç³»ç±»å‹ï¼Œå¦‚åŒ…å«ã€ç›¸äº¤ç­‰ã€‚

### 1.2 å…³ç³»çš„åŸºæœ¬æ€§è´¨

**å®šä¹‰ 1.2** (å…³ç³»æ€§è´¨)
é›†åˆå…³ç³»å…·æœ‰ä»¥ä¸‹åŸºæœ¬æ€§è´¨ï¼š

- **è‡ªåæ€§** (Reflexivity)ï¼š$\forall A: A \subseteq A$
- **å¯¹ç§°æ€§** (Symmetry)ï¼š$\forall A, B: A = B \Rightarrow B = A$
- **ä¼ é€’æ€§** (Transitivity)ï¼š$\forall A, B, C: A \subseteq B \land B \subseteq C \Rightarrow A \subseteq C$
- **åå¯¹ç§°æ€§** (Antisymmetry)ï¼š$\forall A, B: A \subseteq B \land B \subseteq A \Rightarrow A = B$

### 1.3 å…³ç³»åˆ†ç±»

**å®šä¹‰ 1.3** (å…³ç³»åˆ†ç±»)
é›†åˆå…³ç³»å¯ä»¥åˆ†ä¸ºä»¥ä¸‹ä¸»è¦ç±»å‹ï¼š

- **åŒ…å«å…³ç³»** (Inclusion)ï¼š$A \subseteq B$
- **ç›¸ç­‰å…³ç³»** (Equality)ï¼š$A = B$
- **ç›¸äº¤å…³ç³»** (Intersection)ï¼š$A \cap B \neq \emptyset$
- **ä¸ç›¸äº¤å…³ç³»** (Disjoint)ï¼š$A \cap B = \emptyset$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 åŒ…å«å…³ç³»

**å®šä¹‰ 2.1** (åŒ…å«å…³ç³»)
é›†åˆ $A$ åŒ…å«äºé›†åˆ $B$ï¼Œè®°ä½œ $A \subseteq B$ï¼Œå½“ä¸”ä»…å½“ï¼š
$$A \subseteq B \iff \forall x: x \in A \Rightarrow x \in B$$

**çœŸåŒ…å«å…³ç³»**ï¼š
$$A \subset B \iff A \subseteq B \land A \neq B$$

### 2.2 ç›¸ç­‰å…³ç³»

**å®šä¹‰ 2.2** (ç›¸ç­‰å…³ç³»)
é›†åˆ $A$ ç­‰äºé›†åˆ $B$ï¼Œè®°ä½œ $A = B$ï¼Œå½“ä¸”ä»…å½“ï¼š
$$A = B \iff A \subseteq B \land B \subseteq A$$

**å¤–å»¶æ€§å…¬ç†**ï¼š
$$A = B \iff \forall x: x \in A \iff x \in B$$

### 2.3 ç›¸äº¤å…³ç³»

**å®šä¹‰ 2.3** (ç›¸äº¤å…³ç³»)
é›†åˆ $A$ ä¸é›†åˆ $B$ ç›¸äº¤ï¼Œå½“ä¸”ä»…å½“ï¼š
$$A \cap B \neq \emptyset \iff \exists x: x \in A \land x \in B$$

**ä¸ç›¸äº¤å…³ç³»**ï¼š
$$A \cap B = \emptyset \iff \forall x: x \notin A \lor x \notin B$$

## 3. å…³ç³»ç±»å‹

### 3.1 åŒ…å«å…³ç³»

**å®šä¹‰ 3.1** (åŒ…å«å…³ç³»æ€§è´¨)
åŒ…å«å…³ç³» $\subseteq$ å…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼š

1. **è‡ªåæ€§**ï¼š$\forall A: A \subseteq A$
2. **ä¼ é€’æ€§**ï¼š$\forall A, B, C: A \subseteq B \land B \subseteq C \Rightarrow A \subseteq C$
3. **åå¯¹ç§°æ€§**ï¼š$\forall A, B: A \subseteq B \land B \subseteq A \Rightarrow A = B$

### 3.2 ç›¸ç­‰å…³ç³»

**å®šä¹‰ 3.2** (ç›¸ç­‰å…³ç³»æ€§è´¨)
ç›¸ç­‰å…³ç³» $=$ å…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼š

1. **è‡ªåæ€§**ï¼š$\forall A: A = A$
2. **å¯¹ç§°æ€§**ï¼š$\forall A, B: A = B \Rightarrow B = A$
3. **ä¼ é€’æ€§**ï¼š$\forall A, B, C: A = B \land B = C \Rightarrow A = C$

### 3.3 ç›¸äº¤å…³ç³»

**å®šä¹‰ 3.3** (ç›¸äº¤å…³ç³»æ€§è´¨)
ç›¸äº¤å…³ç³»å…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼š

1. **å¯¹ç§°æ€§**ï¼š$A \cap B \neq \emptyset \iff B \cap A \neq \emptyset$
2. **éè‡ªåæ€§**ï¼š$A \cap A \neq \emptyset$ (å½“ $A \neq \emptyset$ æ—¶)
3. **éä¼ é€’æ€§**ï¼š$A \cap B \neq \emptyset \land B \cap C \neq \emptyset \not\Rightarrow A \cap C \neq \emptyset$

### 3.4 ä¸ç›¸äº¤å…³ç³»

**å®šä¹‰ 3.4** (ä¸ç›¸äº¤å…³ç³»æ€§è´¨)
ä¸ç›¸äº¤å…³ç³»å…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼š

1. **å¯¹ç§°æ€§**ï¼š$A \cap B = \emptyset \iff B \cap A = \emptyset$
2. **è‡ªåæ€§**ï¼š$\emptyset \cap \emptyset = \emptyset$
3. **ä¼ é€’æ€§**ï¼š$A \cap B = \emptyset \land B \cap C = \emptyset \Rightarrow A \cap C = \emptyset$

## 4. å…³ç³»è¿ç®—

### 4.1 å…³ç³»å¤åˆ

**å®šä¹‰ 4.1** (å…³ç³»å¤åˆ)
å…³ç³» $R$ å’Œ $S$ çš„å¤åˆ $R \circ S$ å®šä¹‰ä¸ºï¼š
$$R \circ S = \{(A, C) \mid \exists B: (A, B) \in R \land (B, C) \in S\}$$

### 4.2 å…³ç³»é€†

**å®šä¹‰ 4.2** (å…³ç³»é€†)
å…³ç³» $R$ çš„é€† $R^{-1}$ å®šä¹‰ä¸ºï¼š
$$R^{-1} = \{(B, A) \mid (A, B) \in R\}$$

### 4.3 å…³ç³»é—­åŒ…

**å®šä¹‰ 4.3** (å…³ç³»é—­åŒ…)
å…³ç³»çš„é—­åŒ…è¿ç®—ï¼š

- **è‡ªåé—­åŒ…**ï¼š$R^r = R \cup \{(A, A) \mid A \in \mathcal{U}\}$
- **å¯¹ç§°é—­åŒ…**ï¼š$R^s = R \cup R^{-1}$
- **ä¼ é€’é—­åŒ…**ï¼š$R^t = \bigcup_{n=1}^{\infty} R^n$

## 5. å½¢å¼åŒ–è¯æ˜

### 5.1 åŒ…å«å…³ç³»å®šç†

**å®šç† 5.1** (åŒ…å«å…³ç³»ä¼ é€’æ€§)
åŒ…å«å…³ç³»æ˜¯ä¼ é€’çš„ï¼š$\forall A, B, C: A \subseteq B \land B \subseteq C \Rightarrow A \subseteq C$

**è¯æ˜**ï¼š

1. å‡è®¾ $A \subseteq B$ å’Œ $B \subseteq C$
2. æ ¹æ®åŒ…å«å®šä¹‰ï¼š$\forall x: x \in A \Rightarrow x \in B$
3. æ ¹æ®åŒ…å«å®šä¹‰ï¼š$\forall x: x \in B \Rightarrow x \in C$
4. ç”±é€»è¾‘ä¼ é€’æ€§ï¼š$\forall x: x \in A \Rightarrow x \in C$
5. å› æ­¤ $A \subseteq C$

### 5.2 ç›¸ç­‰å…³ç³»å®šç†

**å®šç† 5.2** (ç›¸ç­‰å…³ç³»ç­‰ä»·æ€§)
ç›¸ç­‰å…³ç³»æ˜¯ç­‰ä»·å…³ç³»ã€‚

**è¯æ˜**ï¼š

1. **è‡ªåæ€§**ï¼š$\forall A: A = A$ (æ˜¾ç„¶)
2. **å¯¹ç§°æ€§**ï¼š$\forall A, B: A = B \Rightarrow B = A$ (ç”±å®šä¹‰)
3. **ä¼ é€’æ€§**ï¼š$\forall A, B, C: A = B \land B = C \Rightarrow A = C$ (ç”±åŒ…å«å…³ç³»ä¼ é€’æ€§)

### 5.3 ç›¸äº¤å…³ç³»å®šç†

**å®šç† 5.3** (ç›¸äº¤å…³ç³»å¯¹ç§°æ€§)
ç›¸äº¤å…³ç³»æ˜¯å¯¹ç§°çš„ï¼š$A \cap B \neq \emptyset \iff B \cap A \neq \emptyset$

**è¯æ˜**ï¼š

1. å‡è®¾ $A \cap B \neq \emptyset$
2. å­˜åœ¨ $x$ ä½¿å¾— $x \in A \land x \in B$
3. å› æ­¤ $x \in B \land x \in A$
4. æ‰€ä»¥ $B \cap A \neq \emptyset$
5. åä¹‹äº¦ç„¶

### 5.4 å¾·æ‘©æ ¹å®šå¾‹

**å®šç† 5.4** (å¾·æ‘©æ ¹å®šå¾‹)
å¯¹äºä»»æ„é›†åˆ $A, B$ï¼š
$$(A \cup B)^c = A^c \cap B^c$$
$$(A \cap B)^c = A^c \cup B^c$$

**è¯æ˜**ï¼š

1. å¯¹äºç¬¬ä¸€ä¸ªç­‰å¼ï¼š
   - $x \in (A \cup B)^c \iff x \notin A \cup B$
   - $\iff x \notin A \land x \notin B$
   - $\iff x \in A^c \land x \in B^c$
   - $\iff x \in A^c \cap B^c$

2. å¯¹äºç¬¬äºŒä¸ªç­‰å¼ï¼š
   - $x \in (A \cap B)^c \iff x \notin A \cap B$
   - $\iff x \notin A \lor x \notin B$
   - $\iff x \in A^c \lor x \in B^c$
   - $\iff x \in A^c \cup B^c$

## 6. ä»£ç å®ç°

### 6.1 Rust å®ç°

```rust
use std::collections::HashSet;
use std::hash::Hash;

/// é›†åˆå…³ç³»ç±»å‹
#[derive(Debug, Clone, PartialEq)]
pub enum SetRelation {
    Subset,      // A âŠ† B
    ProperSubset, // A âŠ‚ B
    Equal,       // A = B
    Intersects,  // A âˆ© B â‰  âˆ…
    Disjoint,    // A âˆ© B = âˆ…
}

/// é›†åˆå…³ç³»ç³»ç»Ÿ
#[derive(Debug, Clone)]
pub struct SetRelationSystem<T> {
    relations: Vec<(HashSet<T>, SetRelation, HashSet<T>)>,
}

impl<T> SetRelationSystem<T>
where
    T: Hash + Eq + Clone,
{
    pub fn new() -> Self {
        Self {
            relations: Vec::new(),
        }
    }

    /// æ·»åŠ å…³ç³»
    pub fn add_relation(&mut self, a: HashSet<T>, relation: SetRelation, b: HashSet<T>) {
        self.relations.push((a, relation, b));
    }

    /// æ£€æŸ¥åŒ…å«å…³ç³»
    pub fn is_subset(&self, a: &HashSet<T>, b: &HashSet<T>) -> bool {
        a.iter().all(|x| b.contains(x))
    }

    /// æ£€æŸ¥çœŸåŒ…å«å…³ç³»
    pub fn is_proper_subset(&self, a: &HashSet<T>, b: &HashSet<T>) -> bool {
        self.is_subset(a, b) && a != b
    }

    /// æ£€æŸ¥ç›¸ç­‰å…³ç³»
    pub fn is_equal(&self, a: &HashSet<T>, b: &HashSet<T>) -> bool {
        a == b
    }

    /// æ£€æŸ¥ç›¸äº¤å…³ç³»
    pub fn is_intersects(&self, a: &HashSet<T>, b: &HashSet<T>) -> bool {
        a.iter().any(|x| b.contains(x))
    }

    /// æ£€æŸ¥ä¸ç›¸äº¤å…³ç³»
    pub fn is_disjoint(&self, a: &HashSet<T>, b: &HashSet<T>) -> bool {
        !self.is_intersects(a, b)
    }

    /// è®¡ç®—äº¤é›†
    pub fn intersection(&self, a: &HashSet<T>, b: &HashSet<T>) -> HashSet<T> {
        a.intersection(b).cloned().collect()
    }

    /// è®¡ç®—å¹¶é›†
    pub fn union(&self, a: &HashSet<T>, b: &HashSet<T>) -> HashSet<T> {
        a.union(b).cloned().collect()
    }

    /// è®¡ç®—å·®é›†
    pub fn difference(&self, a: &HashSet<T>, b: &HashSet<T>) -> HashSet<T> {
        a.difference(b).cloned().collect()
    }

    /// è®¡ç®—è¡¥é›†ï¼ˆç›¸å¯¹äºå…¨é›†ï¼‰
    pub fn complement(&self, a: &HashSet<T>, universe: &HashSet<T>) -> HashSet<T> {
        universe.difference(a).cloned().collect()
    }

    /// éªŒè¯å…³ç³»æ€§è´¨
    pub fn verify_properties(&self) -> HashMap<String, bool> {
        let mut results = HashMap::new();
        
        // æ£€æŸ¥åŒ…å«å…³ç³»çš„ä¼ é€’æ€§
        let mut transitive = true;
        for (a, rel1, b) in &self.relations {
            if *rel1 == SetRelation::Subset {
                for (c, rel2, d) in &self.relations {
                    if *rel2 == SetRelation::Subset && b == c {
                        if !self.is_subset(a, d) {
                            transitive = false;
                            break;
                        }
                    }
                }
            }
        }
        results.insert("transitivity".to_string(), transitive);
        
        // æ£€æŸ¥ç›¸ç­‰å…³ç³»çš„å¯¹ç§°æ€§
        let mut symmetric = true;
        for (a, rel, b) in &self.relations {
            if *rel == SetRelation::Equal {
                if !self.is_equal(b, a) {
                    symmetric = false;
                    break;
                }
            }
        }
        results.insert("symmetry".to_string(), symmetric);
        
        results
    }

    /// å…³ç³»æ¨ç†
    pub fn infer_relations(&self, a: &HashSet<T>, b: &HashSet<T>) -> Vec<SetRelation> {
        let mut relations = Vec::new();
        
        if self.is_equal(a, b) {
            relations.push(SetRelation::Equal);
        }
        
        if self.is_proper_subset(a, b) {
            relations.push(SetRelation::ProperSubset);
        } else if self.is_subset(a, b) {
            relations.push(SetRelation::Subset);
        }
        
        if self.is_intersects(a, b) {
            relations.push(SetRelation::Intersects);
        } else {
            relations.push(SetRelation::Disjoint);
        }
        
        relations
    }
}

/// é›†åˆå…³ç³»æ¨ç†å™¨
#[derive(Debug, Clone)]
pub struct SetRelationReasoner<T> {
    system: SetRelationSystem<T>,
}

impl<T> SetRelationReasoner<T>
where
    T: Hash + Eq + Clone,
{
    pub fn new(system: SetRelationSystem<T>) -> Self {
        Self { system }
    }

    /// å¾·æ‘©æ ¹å®šå¾‹éªŒè¯
    pub fn verify_de_morgan(&self, a: &HashSet<T>, b: &HashSet<T>, universe: &HashSet<T>) -> bool {
        let union_complement = self.system.complement(&self.system.union(a, b), universe);
        let intersection_complements = self.system.intersection(
            &self.system.complement(a, universe),
            &self.system.complement(b, universe)
        );
        
        let intersection_complement = self.system.complement(&self.system.intersection(a, b), universe);
        let union_complements = self.system.union(
            &self.system.complement(a, universe),
            &self.system.complement(b, universe)
        );
        
        union_complement == intersection_complements && intersection_complement == union_complements
    }

    /// å…³ç³»ä¼ é€’æ¨ç†
    pub fn transitive_inference(&self, a: &HashSet<T>, b: &HashSet<T>, c: &HashSet<T>) -> bool {
        if self.system.is_subset(a, b) && self.system.is_subset(b, c) {
            self.system.is_subset(a, c)
        } else {
            false
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_set_relations() {
        let mut system = SetRelationSystem::new();
        
        // åˆ›å»ºé›†åˆ
        let a: HashSet<i32> = vec![1, 2, 3].into_iter().collect();
        let b: HashSet<i32> = vec![1, 2, 3, 4, 5].into_iter().collect();
        let c: HashSet<i32> = vec![3, 4, 5, 6].into_iter().collect();
        
        // æ·»åŠ å…³ç³»
        system.add_relation(a.clone(), SetRelation::Subset, b.clone());
        system.add_relation(b.clone(), SetRelation::Intersects, c.clone());
        
        // éªŒè¯å…³ç³»
        assert!(system.is_subset(&a, &b));
        assert!(system.is_proper_subset(&a, &b));
        assert!(system.is_intersects(&b, &c));
        assert!(system.is_disjoint(&a, &c));
        
        // æµ‹è¯•æ¨ç†å™¨
        let reasoner = SetRelationReasoner::new(system);
        assert!(reasoner.transitive_inference(&a, &b, &c));
        
        // æµ‹è¯•å¾·æ‘©æ ¹å®šå¾‹
        let universe: HashSet<i32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();
        assert!(reasoner.verify_de_morgan(&a, &c, &universe));
    }
}
```

### 6.2 Haskell å®ç°

```haskell
module SetRelationTheory where

import Data.Set (Set)
import qualified Data.Set as Set
import Data.Map (Map)
import qualified Data.Map as Map

-- é›†åˆå…³ç³»ç±»å‹
data SetRelation = Subset | ProperSubset | Equal | Intersects | Disjoint
    deriving (Show, Eq)

-- é›†åˆå…³ç³»ç³»ç»Ÿ
data SetRelationSystem a = SetRelationSystem
    { relations :: [(Set a, SetRelation, Set a)]
    } deriving (Show, Eq)

-- åˆ›å»ºç©ºå…³ç³»ç³»ç»Ÿ
emptySetRelationSystem :: SetRelationSystem a
emptySetRelationSystem = SetRelationSystem []

-- æ·»åŠ å…³ç³»
addRelation :: (Ord a) => Set a -> SetRelation -> Set a -> SetRelationSystem a -> SetRelationSystem a
addRelation a rel b system = system
    { relations = (a, rel, b) : relations system
    }

-- æ£€æŸ¥åŒ…å«å…³ç³»
isSubset :: (Ord a) => Set a -> Set a -> Bool
isSubset a b = Set.isSubsetOf a b

-- æ£€æŸ¥çœŸåŒ…å«å…³ç³»
isProperSubset :: (Ord a) => Set a -> Set a -> Bool
isProperSubset a b = Set.isSubsetOf a b && a /= b

-- æ£€æŸ¥ç›¸ç­‰å…³ç³»
isEqual :: (Ord a) => Set a -> Set a -> Bool
isEqual a b = a == b

-- æ£€æŸ¥ç›¸äº¤å…³ç³»
isIntersects :: (Ord a) => Set a -> Set a -> Bool
isIntersects a b = not (Set.null (Set.intersection a b))

-- æ£€æŸ¥ä¸ç›¸äº¤å…³ç³»
isDisjoint :: (Ord a) => Set a -> Set a -> Bool
isDisjoint a b = Set.null (Set.intersection a b)

-- è®¡ç®—äº¤é›†
intersection :: (Ord a) => Set a -> Set a -> Set a
intersection a b = Set.intersection a b

-- è®¡ç®—å¹¶é›†
union :: (Ord a) => Set a -> Set a -> Set a
union a b = Set.union a b

-- è®¡ç®—å·®é›†
difference :: (Ord a) => Set a -> Set a -> Set a
difference a b = Set.difference a b

-- è®¡ç®—è¡¥é›†
complement :: (Ord a) => Set a -> Set a -> Set a
complement a universe = Set.difference universe a

-- éªŒè¯å…³ç³»æ€§è´¨
verifyProperties :: (Ord a) => SetRelationSystem a -> Map String Bool
verifyProperties system = Map.fromList
    [ ("transitivity", verifyTransitivity system)
    , ("symmetry", verifySymmetry system)
    ]
  where
    verifyTransitivity sys = 
        all (\(a, rel1, b) -> 
            if rel1 == Subset then
                all (\(c, rel2, d) -> 
                    if rel2 == Subset && b == c then isSubset a d else True
                ) (relations sys)
            else True
        ) (relations sys)
    
    verifySymmetry sys = 
        all (\(a, rel, b) -> 
            if rel == Equal then isEqual b a else True
        ) (relations sys)

-- å…³ç³»æ¨ç†
inferRelations :: (Ord a) => Set a -> Set a -> [SetRelation]
inferRelations a b = 
    let relations = []
        relations' = if isEqual a b then Equal : relations else relations
        relations'' = if isProperSubset a b then ProperSubset : relations' else relations'
        relations''' = if isSubset a b then Subset : relations'' else relations''
        relations'''' = if isIntersects a b then Intersects : relations''' else relations'''
        relations''''' = if isDisjoint a b then Disjoint : relations'''' else relations''''
    in relations'''''

-- é›†åˆå…³ç³»æ¨ç†å™¨
data SetRelationReasoner a = SetRelationReasoner
    { system :: SetRelationSystem a
    } deriving (Show, Eq)

-- å¾·æ‘©æ ¹å®šå¾‹éªŒè¯
verifyDeMorgan :: (Ord a) => Set a -> Set a -> Set a -> Bool
verifyDeMorgan a b universe = 
    let unionComplement = complement (union a b) universe
        intersectionComplements = intersection (complement a universe) (complement b universe)
        
        intersectionComplement = complement (intersection a b) universe
        unionComplements = union (complement a universe) (complement b universe)
    in unionComplement == intersectionComplements && intersectionComplement == unionComplements

-- å…³ç³»ä¼ é€’æ¨ç†
transitiveInference :: (Ord a) => Set a -> Set a -> Set a -> Bool
transitiveInference a b c = 
    if isSubset a b && isSubset b c then isSubset a c else False

-- ç¤ºä¾‹ä½¿ç”¨
example :: IO ()
example = do
    let system = emptySetRelationSystem
        
        -- åˆ›å»ºé›†åˆ
        a = Set.fromList [1, 2, 3]
        b = Set.fromList [1, 2, 3, 4, 5]
        c = Set.fromList [3, 4, 5, 6]
        
        -- æ„å»ºç³»ç»Ÿ
        system' = addRelation a Subset b system
        system'' = addRelation b Intersects c system'
        
        -- åˆ›å»ºæ¨ç†å™¨
        reasoner = SetRelationReasoner system''
        
        -- éªŒè¯å…³ç³»
        putStrLn "Set Relation Theory Example:"
        putStrLn $ "A is subset of B: " ++ show (isSubset a b)
        putStrLn $ "A is proper subset of B: " ++ show (isProperSubset a b)
        putStrLn $ "B intersects with C: " ++ show (isIntersects b c)
        putStrLn $ "A is disjoint with C: " ++ show (isDisjoint a c)
        putStrLn $ "Transitive inference: " ++ show (transitiveInference a b c)
        
        -- æµ‹è¯•å¾·æ‘©æ ¹å®šå¾‹
        let universe = Set.fromList [1..10]
        putStrLn $ "De Morgan's laws hold: " ++ show (verifyDeMorgan a c universe)

main :: IO ()
main = example
```

## 7. åº”ç”¨ç¤ºä¾‹

### 7.1 æ•°å­¦é›†åˆå…³ç³»

**ç¤ºä¾‹ 7.1** (æ•°é›†å…³ç³»)

```rust
// æ•°é›†å…³ç³»åˆ†æ
let mut number_sets = SetRelationSystem::new();

// åˆ›å»ºæ•°é›†
let natural_numbers: HashSet<i32> = vec![1, 2, 3, 4, 5].into_iter().collect();
let integers: HashSet<i32> = vec![-2, -1, 0, 1, 2, 3, 4, 5].into_iter().collect();
let even_numbers: HashSet<i32> = vec![2, 4, 6, 8, 10].into_iter().collect();

number_sets.add_relation(natural_numbers.clone(), SetRelation::Subset, integers.clone());
number_sets.add_relation(even_numbers.clone(), SetRelation::Intersects, natural_numbers.clone());

// éªŒè¯å…³ç³»
assert!(number_sets.is_subset(&natural_numbers, &integers));
assert!(number_sets.is_intersects(&even_numbers, &natural_numbers));
```

### 7.2 é€»è¾‘é›†åˆå…³ç³»

**ç¤ºä¾‹ 7.2** (é€»è¾‘é›†åˆå…³ç³»)

```rust
// é€»è¾‘é›†åˆå…³ç³»åˆ†æ
let mut logic_sets = SetRelationSystem::new();

// åˆ›å»ºé€»è¾‘é›†åˆ
let tautologies: HashSet<String> = vec!["p âˆ¨ Â¬p".to_string(), "p â†’ p".to_string()].into_iter().collect();
let valid_formulas: HashSet<String> = vec!["p âˆ¨ Â¬p".to_string(), "p â†’ p".to_string(), "p âˆ§ q".to_string()].into_iter().collect();
let contradictions: HashSet<String> = vec!["p âˆ§ Â¬p".to_string(), "Â¬(p âˆ¨ Â¬p)".to_string()].into_iter().collect();

logic_sets.add_relation(tautologies.clone(), SetRelation::Subset, valid_formulas.clone());
logic_sets.add_relation(contradictions.clone(), SetRelation::Disjoint, tautologies.clone());

// éªŒè¯å…³ç³»
assert!(logic_sets.is_subset(&tautologies, &valid_formulas));
assert!(logic_sets.is_disjoint(&contradictions, &tautologies));
```

## 8. ç›¸å…³ç†è®º

### 8.1 ä¸é›†åˆè®ºçš„å…³ç³»

é›†åˆå…³ç³»ç†è®ºæ˜¯é›†åˆè®ºçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œä¸ºé›†åˆè¿ç®—æä¾›ç†è®ºåŸºç¡€ã€‚

### 8.2 ä¸é€»è¾‘å­¦çš„å…³ç³»

é›†åˆå…³ç³»ä¸é€»è¾‘å…³ç³»æœ‰å¯†åˆ‡çš„è”ç³»ï¼Œå¯ä»¥é€šè¿‡é€»è¾‘è¿ç®—æ¥åˆ†æé›†åˆå…³ç³»ã€‚

### 8.3 ä¸ä»£æ•°ç»“æ„çš„å…³ç³»

é›†åˆå…³ç³»å¯ä»¥å½¢æˆä»£æ•°ç»“æ„ï¼Œå¦‚å¸ƒå°”ä»£æ•°ã€æ ¼è®ºç­‰ã€‚

## 9. å‚è€ƒæ–‡çŒ®

1. Halmos, P. R. *Naive Set Theory*. Springer, 1974.
2. Jech, T. *Set Theory*. Springer, 2003.
3. Kunen, K. *Set Theory: An Introduction to Independence Proofs*. North-Holland, 1980.
4. Enderton, H. B. *Elements of Set Theory*. Academic Press, 1977.
5. Suppes, P. *Axiomatic Set Theory*. Dover, 1972.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.1.1 æœ´ç´ é›†åˆè®º](../02.1.1_æœ´ç´ é›†åˆè®º.md)
- [02.1.2 å…¬ç†é›†åˆè®º](../02.1.2_å…¬ç†é›†åˆè®º.md)
- [02.1.3 é›†åˆè¿ç®—](../02.1.3_é›†åˆè¿ç®—.md)
- [02.5.1 å…³ç³»æ¦‚å¿µ](../../02_Mathematical_Foundation/02.5.1_å…³ç³»æ¦‚å¿µ.md)
- [02.5.2 å…³ç³»æ€§è´¨](../../02_Mathematical_Foundation/02.5.2_å…³ç³»æ€§è´¨.md)
