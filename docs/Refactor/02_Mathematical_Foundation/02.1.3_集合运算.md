# 02.1.3 é›†åˆè¿ç®—

## ğŸ“‹ æ¦‚è¿°

é›†åˆè¿ç®—æ˜¯é›†åˆè®ºçš„æ ¸å¿ƒå†…å®¹ï¼Œç ”ç©¶é›†åˆä¹‹é—´çš„åŸºæœ¬æ“ä½œå’Œè¿ç®—è§„å¾‹ã€‚é›†åˆè¿ç®—åŒ…æ‹¬å¹¶é›†ã€äº¤é›†ã€å·®é›†ã€è¡¥é›†ç­‰åŸºæœ¬è¿ç®—ï¼Œä»¥åŠç¬›å¡å°”ç§¯ã€å¹‚é›†ç­‰é«˜çº§è¿ç®—ã€‚è¿™äº›è¿ç®—æ„æˆäº†æ•°å­¦çš„åŸºç¡€å·¥å…·ï¼Œå¹¿æ³›åº”ç”¨äºå„ä¸ªæ•°å­¦åˆ†æ”¯ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **åŸºæœ¬è¿ç®—å®šä¹‰**: å®šä¹‰é›†åˆçš„åŸºæœ¬è¿ç®—
2. **è¿ç®—æ€§è´¨ç ”ç©¶**: ç ”ç©¶é›†åˆè¿ç®—çš„ä»£æ•°æ€§è´¨
3. **è¿ç®—å¾‹è¯æ˜**: è¯æ˜é›†åˆè¿ç®—çš„åŸºæœ¬å®šå¾‹
4. **åº”ç”¨ç¤ºä¾‹**: å±•ç¤ºé›†åˆè¿ç®—çš„å®é™…åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 åŸºæœ¬é›†åˆè¿ç®—

#### 1.1.1 å¹¶é›† (Union)

**å®šä¹‰**: ä¸¤ä¸ªé›†åˆçš„å¹¶é›†æ˜¯åŒ…å«æ‰€æœ‰å±äºä»»ä¸€é›†åˆçš„å…ƒç´ çš„é›†åˆã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$A \cup B = \{x \mid x \in A \text{ æˆ– } x \in B\}$$

#### 1.1.2 äº¤é›† (Intersection)

**å®šä¹‰**: ä¸¤ä¸ªé›†åˆçš„äº¤é›†æ˜¯åŒ…å«æ‰€æœ‰åŒæ—¶å±äºä¸¤ä¸ªé›†åˆçš„å…ƒç´ çš„é›†åˆã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$A \cap B = \{x \mid x \in A \text{ ä¸” } x \in B\}$$

#### 1.1.3 å·®é›† (Difference)

**å®šä¹‰**: é›†åˆAä¸é›†åˆBçš„å·®é›†æ˜¯åŒ…å«æ‰€æœ‰å±äºAä½†ä¸å±äºBçš„å…ƒç´ çš„é›†åˆã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$A \setminus B = \{x \mid x \in A \text{ ä¸” } x \notin B\}$$

#### 1.1.4 è¡¥é›† (Complement)

**å®šä¹‰**: é›†åˆAåœ¨å…¨é›†Uä¸­çš„è¡¥é›†æ˜¯åŒ…å«æ‰€æœ‰ä¸å±äºAçš„å…ƒç´ çš„é›†åˆã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$A^c = U \setminus A = \{x \mid x \in U \text{ ä¸” } x \notin A\}$$

### 1.2 é«˜çº§é›†åˆè¿ç®—

#### 1.2.1 ç¬›å¡å°”ç§¯ (Cartesian Product)

**å®šä¹‰**: ä¸¤ä¸ªé›†åˆçš„ç¬›å¡å°”ç§¯æ˜¯æ‰€æœ‰æœ‰åºå¯¹çš„é›†åˆã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$A \times B = \{(a, b) \mid a \in A \text{ ä¸” } b \in B\}$$

#### 1.2.2 å¹‚é›† (Power Set)

**å®šä¹‰**: é›†åˆAçš„å¹‚é›†æ˜¯Açš„æ‰€æœ‰å­é›†çš„é›†åˆã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\mathcal{P}(A) = \{X \mid X \subseteq A\}$$

#### 1.2.3 å¯¹ç§°å·® (Symmetric Difference)

**å®šä¹‰**: ä¸¤ä¸ªé›†åˆçš„å¯¹ç§°å·®æ˜¯åŒ…å«å±äºå…¶ä¸­ä¸€ä¸ªé›†åˆä½†ä¸å±äºå¦ä¸€ä¸ªé›†åˆçš„å…ƒç´ çš„é›†åˆã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$A \triangle B = (A \setminus B) \cup (B \setminus A)$$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 é›†åˆè¿ç®—çš„å…¬ç†åŒ–å®šä¹‰

**é›†åˆè¿ç®—å…¬ç†ç³»ç»Ÿ**:

1. **å¹¶é›†å…¬ç†**: $\forall A, B \exists C \forall x (x \in C \leftrightarrow x \in A \vee x \in B)$
2. **äº¤é›†å…¬ç†**: $\forall A, B \exists C \forall x (x \in C \leftrightarrow x \in A \wedge x \in B)$
3. **å·®é›†å…¬ç†**: $\forall A, B \exists C \forall x (x \in C \leftrightarrow x \in A \wedge x \notin B)$
4. **å¹‚é›†å…¬ç†**: $\forall A \exists B \forall x (x \in B \leftrightarrow x \subseteq A)$

### 2.2 é›†åˆè¿ç®—çš„æ€§è´¨

#### 2.2.1 åŸºæœ¬æ€§è´¨

1. **å¹‚ç­‰æ€§**: $A \cup A = A$, $A \cap A = A$
2. **äº¤æ¢æ€§**: $A \cup B = B \cup A$, $A \cap B = B \cap A$
3. **ç»“åˆæ€§**: $(A \cup B) \cup C = A \cup (B \cup C)$, $(A \cap B) \cap C = A \cap (B \cap C)$
4. **åˆ†é…æ€§**: $A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$, $A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$

#### 2.2.2 å¾·æ‘©æ ¹å¾‹

1. **å¹¶é›†çš„è¡¥é›†**: $(A \cup B)^c = A^c \cap B^c$
2. **äº¤é›†çš„è¡¥é›†**: $(A \cap B)^c = A^c \cup B^c$

### 2.3 é›†åˆè¿ç®—çš„ä»£æ•°ç»“æ„

**å¸ƒå°”ä»£æ•°ç»“æ„**:
- é›†åˆåœ¨å¹¶é›†å’Œäº¤é›†è¿ç®—ä¸‹æ„æˆå¸ƒå°”ä»£æ•°
- ç©ºé›†æ˜¯å¹¶é›†è¿ç®—çš„å•ä½å…ƒ
- å…¨é›†æ˜¯äº¤é›†è¿ç®—çš„å•ä½å…ƒ
- æ¯ä¸ªé›†åˆéƒ½æœ‰è¡¥é›†ä½œä¸ºé€†å…ƒ

## 3. å®šç†ä¸è¯æ˜

### 3.1 é›†åˆè¿ç®—åŸºæœ¬å®šç†

#### 3.1.1 å¹¶é›†ç»“åˆå¾‹

**å®šç†**: $(A \cup B) \cup C = A \cup (B \cup C)$

**è¯æ˜**:
1. è®¾ $x \in (A \cup B) \cup C$
2. åˆ™ $x \in A \cup B$ æˆ– $x \in C$
3. å¦‚æœ $x \in A \cup B$ï¼Œåˆ™ $x \in A$ æˆ– $x \in B$
4. å› æ­¤ $x \in A$ æˆ– $x \in B$ æˆ– $x \in C$
5. æ‰€ä»¥ $x \in A \cup (B \cup C)$
6. åŒç†å¯è¯åå‘åŒ…å«
7. å› æ­¤ $(A \cup B) \cup C = A \cup (B \cup C)$

#### 3.1.2 åˆ†é…å¾‹

**å®šç†**: $A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$

**è¯æ˜**:
1. è®¾ $x \in A \cup (B \cap C)$
2. åˆ™ $x \in A$ æˆ– $x \in B \cap C$
3. å¦‚æœ $x \in A$ï¼Œåˆ™ $x \in A \cup B$ ä¸” $x \in A \cup C$
4. å¦‚æœ $x \in B \cap C$ï¼Œåˆ™ $x \in B$ ä¸” $x \in C$
5. å› æ­¤ $x \in A \cup B$ ä¸” $x \in A \cup C$
6. æ‰€ä»¥ $x \in (A \cup B) \cap (A \cup C)$
7. åŒç†å¯è¯åå‘åŒ…å«
8. å› æ­¤ $A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$

#### 3.1.3 å¾·æ‘©æ ¹å¾‹

**å®šç†**: $(A \cup B)^c = A^c \cap B^c$

**è¯æ˜**:
1. è®¾ $x \in (A \cup B)^c$
2. åˆ™ $x \notin A \cup B$
3. å› æ­¤ $x \notin A$ ä¸” $x \notin B$
4. æ‰€ä»¥ $x \in A^c$ ä¸” $x \in B^c$
5. å› æ­¤ $x \in A^c \cap B^c$
6. åŒç†å¯è¯åå‘åŒ…å«
7. å› æ­¤ $(A \cup B)^c = A^c \cap B^c$

### 3.2 å¹‚é›†è¿ç®—å®šç†

#### 3.2.1 å¹‚é›†åŸºæ•°å®šç†

**å®šç†**: å¦‚æœ $|A| = n$ï¼Œåˆ™ $|\mathcal{P}(A)| = 2^n$

**è¯æ˜**:
1. å¯¹äºAçš„æ¯ä¸ªå­é›†ï¼Œæ¯ä¸ªå…ƒç´ è¦ä¹ˆå±äºè¯¥å­é›†ï¼Œè¦ä¹ˆä¸å±äº
2. å¯¹äºnä¸ªå…ƒç´ ï¼Œæœ‰ $2^n$ ç§ä¸åŒçš„ç»„åˆ
3. å› æ­¤å¹‚é›†æœ‰ $2^n$ ä¸ªå…ƒç´ 

#### 3.2.2 ç¬›å¡å°”ç§¯åŸºæ•°å®šç†

**å®šç†**: å¦‚æœ $|A| = m$ ä¸” $|B| = n$ï¼Œåˆ™ $|A \times B| = mn$

**è¯æ˜**:
1. å¯¹äºAä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œå¯ä»¥ä¸Bä¸­çš„nä¸ªå…ƒç´ é…å¯¹
2. å› æ­¤æ€»å…±æœ‰ $m \times n$ ä¸ªæœ‰åºå¯¹
3. æ‰€ä»¥ $|A \times B| = mn$

### 3.3 é›†åˆè¿ç®—çš„æ¨å¹¿

#### 3.3.1 å¹¿ä¹‰å¹¶é›†

**å®šä¹‰**: é›†åˆæ—çš„å¹¿ä¹‰å¹¶é›†
$$\bigcup_{i \in I} A_i = \{x \mid \exists i \in I: x \in A_i\}$$

#### 3.3.2 å¹¿ä¹‰äº¤é›†

**å®šä¹‰**: é›†åˆæ—çš„å¹¿ä¹‰äº¤é›†
$$\bigcap_{i \in I} A_i = \{x \mid \forall i \in I: x \in A_i\}$$

## 4. ä»£ç å®ç°

### 4.1 é›†åˆè¿ç®—å®ç° (Rust)

```rust
use std::collections::HashSet;
use std::hash::Hash;

/// é›†åˆè¿ç®—ç³»ç»Ÿ
pub struct SetOperations<T: Hash + Eq + Clone> {
    universe: HashSet<T>,
}

impl<T: Hash + Eq + Clone> SetOperations<T> {
    /// åˆ›å»ºæ–°çš„é›†åˆè¿ç®—ç³»ç»Ÿ
    pub fn new(universe: HashSet<T>) -> Self {
        Self { universe }
    }

    /// å¹¶é›†è¿ç®—
    pub fn union(&self, a: &HashSet<T>, b: &HashSet<T>) -> HashSet<T> {
        a.union(b).cloned().collect()
    }

    /// äº¤é›†è¿ç®—
    pub fn intersection(&self, a: &HashSet<T>, b: &HashSet<T>) -> HashSet<T> {
        a.intersection(b).cloned().collect()
    }

    /// å·®é›†è¿ç®—
    pub fn difference(&self, a: &HashSet<T>, b: &HashSet<T>) -> HashSet<T> {
        a.difference(b).cloned().collect()
    }

    /// è¡¥é›†è¿ç®—
    pub fn complement(&self, a: &HashSet<T>) -> HashSet<T> {
        self.universe.difference(a).cloned().collect()
    }

    /// å¯¹ç§°å·®è¿ç®—
    pub fn symmetric_difference(&self, a: &HashSet<T>, b: &HashSet<T>) -> HashSet<T> {
        let diff1 = self.difference(a, b);
        let diff2 = self.difference(b, a);
        self.union(&diff1, &diff2)
    }

    /// ç¬›å¡å°”ç§¯è¿ç®—
    pub fn cartesian_product(&self, a: &HashSet<T>, b: &HashSet<T>) -> HashSet<(T, T)> {
        let mut product = HashSet::new();
        for x in a {
            for y in b {
                product.insert((x.clone(), y.clone()));
            }
        }
        product
    }

    /// å¹‚é›†è¿ç®—
    pub fn power_set(&self, a: &HashSet<T>) -> HashSet<HashSet<T>> {
        let elements: Vec<T> = a.iter().cloned().collect();
        let mut power_set = HashSet::new();
        power_set.insert(HashSet::new()); // ç©ºé›†

        // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„å­é›†
        for i in 1..(1 << elements.len()) {
            let mut subset = HashSet::new();
            for j in 0..elements.len() {
                if (i >> j) & 1 == 1 {
                    subset.insert(elements[j].clone());
                }
            }
            power_set.insert(subset);
        }
        power_set
    }

    /// æ£€æŸ¥åŒ…å«å…³ç³»
    pub fn is_subset(&self, a: &HashSet<T>, b: &HashSet<T>) -> bool {
        a.is_subset(b)
    }

    /// æ£€æŸ¥ç›¸ç­‰å…³ç³»
    pub fn is_equal(&self, a: &HashSet<T>, b: &HashSet<T>) -> bool {
        a == b
    }

    /// éªŒè¯é›†åˆè¿ç®—å¾‹
    pub fn verify_laws(&self, a: &HashSet<T>, b: &HashSet<T>, c: &HashSet<T>) -> HashMap<String, bool> {
        let mut results = HashMap::new();

        // å¹‚ç­‰å¾‹
        results.insert("idempotent_union".to_string(), 
            self.is_equal(&self.union(a, a), a));
        results.insert("idempotent_intersection".to_string(), 
            self.is_equal(&self.intersection(a, a), a));

        // äº¤æ¢å¾‹
        results.insert("commutative_union".to_string(), 
            self.is_equal(&self.union(a, b), &self.union(b, a)));
        results.insert("commutative_intersection".to_string(), 
            self.is_equal(&self.intersection(a, b), &self.intersection(b, a)));

        // ç»“åˆå¾‹
        results.insert("associative_union".to_string(), 
            self.is_equal(&self.union(&self.union(a, b), c), 
                         &self.union(a, &self.union(b, c))));
        results.insert("associative_intersection".to_string(), 
            self.is_equal(&self.intersection(&self.intersection(a, b), c), 
                         &self.intersection(a, &self.intersection(b, c))));

        // åˆ†é…å¾‹
        results.insert("distributive_union_over_intersection".to_string(), 
            self.is_equal(&self.union(a, &self.intersection(b, c)), 
                         &self.intersection(&self.union(a, b), &self.union(a, c))));
        results.insert("distributive_intersection_over_union".to_string(), 
            self.is_equal(&self.intersection(a, &self.union(b, c)), 
                         &self.union(&self.intersection(a, b), &self.intersection(a, c))));

        // å¾·æ‘©æ ¹å¾‹
        results.insert("de_morgan_union".to_string(), 
            self.is_equal(&self.complement(&self.union(a, b)), 
                         &self.intersection(&self.complement(a), &self.complement(b))));
        results.insert("de_morgan_intersection".to_string(), 
            self.is_equal(&self.complement(&self.intersection(a, b)), 
                         &self.union(&self.complement(a), &self.complement(b))));

        results
    }

    /// è®¡ç®—é›†åˆåŸºæ•°
    pub fn cardinality(&self, a: &HashSet<T>) -> usize {
        a.len()
    }

    /// å¹¿ä¹‰å¹¶é›†
    pub fn generalized_union(&self, sets: &[HashSet<T>]) -> HashSet<T> {
        let mut result = HashSet::new();
        for set in sets {
            result.extend(set.iter().cloned());
        }
        result
    }

    /// å¹¿ä¹‰äº¤é›†
    pub fn generalized_intersection(&self, sets: &[HashSet<T>]) -> HashSet<T> {
        if sets.is_empty() {
            return HashSet::new();
        }
        let mut result = sets[0].clone();
        for set in &sets[1..] {
            result = self.intersection(&result, set);
        }
        result
    }
}

/// é›†åˆè¿ç®—çš„ä»£æ•°ç»“æ„
pub struct SetAlgebra<T: Hash + Eq + Clone> {
    operations: SetOperations<T>,
    empty_set: HashSet<T>,
    universe: HashSet<T>,
}

impl<T: Hash + Eq + Clone> SetAlgebra<T> {
    /// åˆ›å»ºæ–°çš„é›†åˆä»£æ•°
    pub fn new(universe: HashSet<T>) -> Self {
        let empty_set = HashSet::new();
        let operations = SetOperations::new(universe.clone());
        Self {
            operations,
            empty_set,
            universe,
        }
    }

    /// è·å–ç©ºé›†
    pub fn empty_set(&self) -> &HashSet<T> {
        &self.empty_set
    }

    /// è·å–å…¨é›†
    pub fn universe(&self) -> &HashSet<T> {
        &self.universe
    }

    /// å¸ƒå°”ä»£æ•°è¿ç®—
    pub fn boolean_operations(&self, a: &HashSet<T>, b: &HashSet<T>) -> HashMap<String, HashSet<T>> {
        let mut results = HashMap::new();
        results.insert("union".to_string(), self.operations.union(a, b));
        results.insert("intersection".to_string(), self.operations.intersection(a, b));
        results.insert("difference".to_string(), self.operations.difference(a, b));
        results.insert("complement_a".to_string(), self.operations.complement(a));
        results.insert("complement_b".to_string(), self.operations.complement(b));
        results.insert("symmetric_difference".to_string(), self.operations.symmetric_difference(a, b));
        results
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_operations() {
        let mut universe = HashSet::new();
        universe.insert(1);
        universe.insert(2);
        universe.insert(3);
        universe.insert(4);
        universe.insert(5);

        let operations = SetOperations::new(universe);
        
        let mut a = HashSet::new();
        a.insert(1);
        a.insert(2);
        a.insert(3);

        let mut b = HashSet::new();
        b.insert(2);
        b.insert(3);
        b.insert(4);

        // æµ‹è¯•å¹¶é›†
        let union_result = operations.union(&a, &b);
        assert_eq!(union_result.len(), 4);
        assert!(union_result.contains(&1));
        assert!(union_result.contains(&2));
        assert!(union_result.contains(&3));
        assert!(union_result.contains(&4));

        // æµ‹è¯•äº¤é›†
        let intersection_result = operations.intersection(&a, &b);
        assert_eq!(intersection_result.len(), 2);
        assert!(intersection_result.contains(&2));
        assert!(intersection_result.contains(&3));

        // æµ‹è¯•å·®é›†
        let difference_result = operations.difference(&a, &b);
        assert_eq!(difference_result.len(), 1);
        assert!(difference_result.contains(&1));
    }

    #[test]
    fn test_power_set() {
        let mut universe = HashSet::new();
        universe.insert(1);
        universe.insert(2);
        universe.insert(3);

        let operations = SetOperations::new(universe);
        
        let mut a = HashSet::new();
        a.insert(1);
        a.insert(2);

        let power_set = operations.power_set(&a);
        assert_eq!(power_set.len(), 4); // 2^2 = 4
    }

    #[test]
    fn test_set_laws() {
        let mut universe = HashSet::new();
        universe.insert(1);
        universe.insert(2);
        universe.insert(3);
        universe.insert(4);

        let operations = SetOperations::new(universe);
        
        let mut a = HashSet::new();
        a.insert(1);
        a.insert(2);

        let mut b = HashSet::new();
        b.insert(2);
        b.insert(3);

        let mut c = HashSet::new();
        c.insert(3);
        c.insert(4);

        let laws = operations.verify_laws(&a, &b, &c);
        
        // éªŒè¯æ‰€æœ‰å®šå¾‹éƒ½æˆç«‹
        for (law, result) in laws {
            assert!(result, "Law {} failed", law);
        }
    }
}
```

### 4.2 é›†åˆè¿ç®—å®ç° (Haskell)

```haskell
module SetOperations where

import Data.Set (Set)
import qualified Data.Set as Set
import Data.Map (Map)
import qualified Data.Map as Map

-- é›†åˆè¿ç®—ç±»å‹ç±»
class SetOperations a where
    union :: Set a -> Set a -> Set a
    intersection :: Set a -> Set a -> Set a
    difference :: Set a -> Set a -> Set a
    complement :: Set a -> Set a -> Set a -- ç›¸å¯¹äºå…¨é›†çš„è¡¥é›†
    symmetricDifference :: Set a -> Set a -> Set a
    cartesianProduct :: Set a -> Set a -> Set (a, a)
    powerSet :: Set a -> Set (Set a)
    isSubset :: Set a -> Set a -> Bool
    isEqual :: Set a -> Set a -> Bool

-- é›†åˆè¿ç®—å®ä¾‹
instance (Ord a) => SetOperations a where
    union = Set.union
    intersection = Set.intersection
    difference = Set.difference
    complement universe set = Set.difference universe set
    symmetricDifference a b = Set.union (Set.difference a b) (Set.difference b a)
    cartesianProduct a b = Set.fromList [(x, y) | x <- Set.toList a, y <- Set.toList b]
    powerSet set = Set.fromList (generatePowerSet (Set.toList set))
    isSubset = Set.isSubsetOf
    isEqual = (==)

-- ç”Ÿæˆå¹‚é›†
generatePowerSet :: [a] -> [Set a]
generatePowerSet [] = [Set.empty]
generatePowerSet (x:xs) = 
    let subsets = generatePowerSet xs
    in subsets ++ map (Set.insert x) subsets

-- é›†åˆè¿ç®—éªŒè¯
verifySetLaws :: (Ord a) => Set a -> Set a -> Set a -> Map String Bool
verifySetLaws a b c = Map.fromList
    [ ("idempotent_union", isEqual (union a a) a)
    , ("idempotent_intersection", isEqual (intersection a a) a)
    , ("commutative_union", isEqual (union a b) (union b a))
    , ("commutative_intersection", isEqual (intersection a b) (intersection b a))
    , ("associative_union", isEqual (union (union a b) c) (union a (union b c)))
    , ("associative_intersection", isEqual (intersection (intersection a b) c) (intersection a (intersection b c)))
    , ("distributive_union_over_intersection", 
       isEqual (union a (intersection b c)) (intersection (union a b) (union a c)))
    , ("distributive_intersection_over_union", 
       isEqual (intersection a (union b c)) (union (intersection a b) (intersection a c)))
    ]

-- å¹¿ä¹‰é›†åˆè¿ç®—
generalizedUnion :: (Ord a) => [Set a] -> Set a
generalizedUnion = foldr union Set.empty

generalizedIntersection :: (Ord a) => [Set a] -> Set a
generalizedIntersection [] = Set.empty
generalizedIntersection (x:xs) = foldr intersection x xs

-- é›†åˆåŸºæ•°
cardinality :: Set a -> Int
cardinality = Set.size

-- é›†åˆè¿ç®—åˆ†æ
analyzeSetOperations :: (Ord a) => Set a -> Set a -> SetOperationAnalysis
analyzeSetOperations a b = SetOperationAnalysis
    { unionSize = cardinality (union a b)
    , intersectionSize = cardinality (intersection a b)
    , differenceSize = cardinality (difference a b)
    , symmetricDifferenceSize = cardinality (symmetricDifference a b)
    , powerSetSize = cardinality (powerSet a)
    , cartesianProductSize = cardinality (cartesianProduct a b)
    }

data SetOperationAnalysis = SetOperationAnalysis
    { unionSize :: Int
    , intersectionSize :: Int
    , differenceSize :: Int
    , symmetricDifferenceSize :: Int
    , powerSetSize :: Int
    , cartesianProductSize :: Int
    }
    deriving (Eq, Ord, Show)

-- é›†åˆè¿ç®—ç¤ºä¾‹
setOperationsExample :: IO ()
setOperationsExample = do
    let a = Set.fromList [1, 2, 3, 4]
        b = Set.fromList [3, 4, 5, 6]
        c = Set.fromList [5, 6, 7, 8]
        
        -- åŸºæœ¬è¿ç®—
        unionResult = union a b
        intersectionResult = intersection a b
        differenceResult = difference a b
        symmetricDiffResult = symmetricDifference a b
        
        -- é«˜çº§è¿ç®—
        powerSetResult = powerSet (Set.fromList [1, 2])
        cartesianResult = cartesianProduct (Set.fromList [1, 2]) (Set.fromList ['a', 'b'])
        
        -- å®šå¾‹éªŒè¯
        laws = verifySetLaws a b c
        
        -- åˆ†æ
        analysis = analyzeSetOperations a b
    
    putStrLn "Set Operations Example:"
    putStrLn $ "Set A: " ++ show (Set.toList a)
    putStrLn $ "Set B: " ++ show (Set.toList b)
    putStrLn $ "Union: " ++ show (Set.toList unionResult)
    putStrLn $ "Intersection: " ++ show (Set.toList intersectionResult)
    putStrLn $ "Difference: " ++ show (Set.toList differenceResult)
    putStrLn $ "Symmetric Difference: " ++ show (Set.toList symmetricDiffResult)
    putStrLn $ "Power Set of {1,2}: " ++ show (map Set.toList (Set.toList powerSetResult))
    putStrLn $ "Cartesian Product: " ++ show (Set.toList cartesianResult)
    putStrLn $ "Laws verification: " ++ show laws
    putStrLn $ "Analysis: " ++ show analysis
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 æ•°æ®åº“æŸ¥è¯¢ç³»ç»Ÿ

```rust
// æ•°æ®åº“æŸ¥è¯¢ç³»ç»Ÿç¤ºä¾‹
fn database_query_system() {
    let mut universe = HashSet::new();
    universe.insert("user1".to_string());
    universe.insert("user2".to_string());
    universe.insert("user3".to_string());
    universe.insert("user4".to_string());
    universe.insert("user5".to_string());

    let operations = SetOperations::new(universe);
    
    // ç”¨æˆ·é›†åˆ
    let mut admin_users = HashSet::new();
    admin_users.insert("user1".to_string());
    admin_users.insert("user2".to_string());
    admin_users.insert("user3".to_string());

    let mut premium_users = HashSet::new();
    premium_users.insert("user2".to_string());
    premium_users.insert("user3".to_string());
    premium_users.insert("user4".to_string());

    let mut active_users = HashSet::new();
    active_users.insert("user1".to_string());
    active_users.insert("user3".to_string());
    active_users.insert("user5".to_string());

    // æŸ¥è¯¢æ“ä½œ
    let admin_and_premium = operations.intersection(&admin_users, &premium_users);
    let admin_or_premium = operations.union(&admin_users, &premium_users);
    let admin_only = operations.difference(&admin_users, &premium_users);
    let active_admin = operations.intersection(&admin_users, &active_users);

    println!("Admin and Premium users: {:?}", admin_and_premium);
    println!("Admin or Premium users: {:?}", admin_or_premium);
    println!("Admin only users: {:?}", admin_only);
    println!("Active admin users: {:?}", active_admin);
}
```

### 5.2 å›¾è®ºåº”ç”¨

```haskell
-- å›¾è®ºåº”ç”¨ç¤ºä¾‹
graphTheoryExample :: IO ()
graphTheoryExample = do
    let vertices = Set.fromList [1, 2, 3, 4, 5]
        edges1 = Set.fromList [(1, 2), (2, 3), (3, 4)]
        edges2 = Set.fromList [(2, 3), (3, 4), (4, 5)]
        
        -- å›¾çš„å¹¶é›†å’Œäº¤é›†
        unionEdges = union edges1 edges2
        intersectionEdges = intersection edges1 edges2
        differenceEdges = difference edges1 edges2
        
        -- è®¡ç®—é¡¶ç‚¹é›†
        vertices1 = Set.fromList [v | (v, _) <- Set.toList edges1] `union` 
                   Set.fromList [v | (_, v) <- Set.toList edges1]
        vertices2 = Set.fromList [v | (v, _) <- Set.toList edges2] `union` 
                   Set.fromList [v | (_, v) <- Set.toList edges2]
        
        -- å›¾çš„è¡¥é›†
        allPossibleEdges = cartesianProduct vertices vertices
        complementEdges1 = difference allPossibleEdges edges1
    
    putStrLn "Graph Theory Example:"
    putStrLn $ "Vertices: " ++ show (Set.toList vertices)
    putStrLn $ "Edges 1: " ++ show (Set.toList edges1)
    putStrLn $ "Edges 2: " ++ show (Set.toList edges2)
    putStrLn $ "Union of edges: " ++ show (Set.toList unionEdges)
    putStrLn $ "Intersection of edges: " ++ show (Set.toList intersectionEdges)
    putStrLn $ "Difference of edges: " ++ show (Set.toList differenceEdges)
    putStrLn $ "Vertices in graph 1: " ++ show (Set.toList vertices1)
    putStrLn $ "Vertices in graph 2: " ++ show (Set.toList vertices2)
    putStrLn $ "Complement of graph 1: " ++ show (take 10 (Set.toList complementEdges1))
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸æœ´ç´ é›†åˆè®ºçš„å…³ç³»

é›†åˆè¿ç®—æ˜¯æœ´ç´ é›†åˆè®ºçš„æ ¸å¿ƒå†…å®¹ï¼š
- **åŸºæœ¬è¿ç®—**: å¹¶é›†ã€äº¤é›†ã€å·®é›†ã€è¡¥é›†
- **è¿ç®—æ€§è´¨**: äº¤æ¢å¾‹ã€ç»“åˆå¾‹ã€åˆ†é…å¾‹
- **ä»£æ•°ç»“æ„**: å¸ƒå°”ä»£æ•°ç»“æ„

### 6.2 ä¸å…¬ç†é›†åˆè®ºçš„å…³ç³»

é›†åˆè¿ç®—åœ¨å…¬ç†é›†åˆè®ºä¸­çš„åŸºç¡€ï¼š
- **å¹¶é›†å…¬ç†**: ä¿è¯å¹¶é›†è¿ç®—çš„å­˜åœ¨
- **å¹‚é›†å…¬ç†**: ä¿è¯å¹‚é›†è¿ç®—çš„å­˜åœ¨
- **é€‰æ‹©å…¬ç†**: å½±å“æŸäº›é›†åˆè¿ç®—çš„æ€§è´¨

### 6.3 ä¸å…³ç³»ç†è®ºçš„å…³ç³»

é›†åˆè¿ç®—åœ¨å…³ç³»ç†è®ºä¸­çš„åº”ç”¨ï¼š
- **å…³ç³»è¿ç®—**: åŸºäºé›†åˆè¿ç®—
- **å…³ç³»ä»£æ•°**: æ‰©å±•çš„é›†åˆä»£æ•°
- **æ•°æ®åº“ç†è®º**: å…³ç³»æ•°æ®åº“çš„åŸºç¡€

## 7. å‚è€ƒæ–‡çŒ®

1. **Halmos, P. R.** (1974). *Naive Set Theory*. Springer-Verlag.
2. **Jech, T.** (2003). *Set Theory*. Springer-Verlag.
3. **Kunen, K.** (1980). *Set Theory: An Introduction to Independence Proofs*. North-Holland.
4. **Suppes, P.** (1972). *Axiomatic Set Theory*. Dover Publications.
5. **Enderton, H. B.** (1977). *Elements of Set Theory*. Academic Press.
6. **Devlin, K.** (1993). *The Joy of Sets: Fundamentals of Contemporary Set Theory*. Springer-Verlag.
7. **Fraenkel, A. A., Bar-Hillel, Y., & Levy, A.** (1973). *Foundations of Set Theory*. North-Holland.

---

**ç›¸å…³æ–‡æ¡£**:
- [02.1.1 æœ´ç´ é›†åˆè®º](../02.1.1_æœ´ç´ é›†åˆè®º.md)
- [02.1.2 å…¬ç†é›†åˆè®º](../02.1.2_å…¬ç†é›†åˆè®º.md)
- [02.1.4 é›†åˆå…³ç³»](../02.1.4_é›†åˆå…³ç³».md)
- [02.5.1 å…³ç³»æ¦‚å¿µ](../02.5.1_å…³ç³»æ¦‚å¿µ.md)

**è¿”å›**: [æ•°å­¦åŸºç¡€ç†è®º](../README.md) | [ä¸»ç´¢å¼•](../../00_Master_Index/README.md) 