# 02.1.3 é›†åˆè¿ç®—

## ğŸ“‹ æ¦‚è¿°

é›†åˆè¿ç®—æ˜¯é›†åˆè®ºä¸­ç ”ç©¶é›†åˆä¹‹é—´æ“ä½œå’Œå˜æ¢çš„æ ¸å¿ƒç†è®ºã€‚å®ƒæ¢è®¨é›†åˆçš„å¹¶é›†ã€äº¤é›†ã€å·®é›†ã€è¡¥é›†ç­‰åŸºæœ¬è¿ç®—ï¼Œä»¥åŠè¿™äº›è¿ç®—çš„æ€§è´¨å’Œè§„å¾‹ï¼Œä¸ºæ•°å­¦åˆ†æå’Œå…¶ä»–æ•°å­¦åˆ†æ”¯æä¾›åŸºç¡€å·¥å…·ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹é›†åˆè¿ç®—çš„å½¢å¼åŒ–ä½“ç³»**
2. **åˆ†æé›†åˆè¿ç®—çš„åŸºæœ¬æ€§è´¨**
3. **æ¢è®¨é›†åˆè¿ç®—çš„ä»£æ•°ç»“æ„**
4. **æ„å»ºé›†åˆè¿ç®—çš„åº”ç”¨æ¡†æ¶**
5. **ç ”ç©¶é›†åˆè¿ç®—çš„ç®—æ³•å®ç°**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 é›†åˆè¿ç®—æ¦‚å¿µ

**å®šä¹‰ 1.1.1** (é›†åˆè¿ç®—)
é›†åˆè¿ç®—æ˜¯æŒ‡å¯¹é›†åˆè¿›è¡Œçš„åŸºæœ¬æ“ä½œï¼Œä¸»è¦åŒ…æ‹¬ï¼š
- **ä¸€å…ƒè¿ç®—**: å¯¹å•ä¸ªé›†åˆè¿›è¡Œçš„æ“ä½œ
- **äºŒå…ƒè¿ç®—**: å¯¹ä¸¤ä¸ªé›†åˆè¿›è¡Œçš„æ“ä½œ
- **å¤šå…ƒè¿ç®—**: å¯¹å¤šä¸ªé›†åˆè¿›è¡Œçš„æ“ä½œ

### 1.2 åŸºæœ¬é›†åˆè¿ç®—

**å®šä¹‰ 1.1.2** (åŸºæœ¬é›†åˆè¿ç®—)
é›†åˆçš„åŸºæœ¬è¿ç®—åŒ…æ‹¬ï¼š

1. **å¹¶é›†**: $A \cup B = \{x : x \in A \lor x \in B\}$
2. **äº¤é›†**: $A \cap B = \{x : x \in A \land x \in B\}$
3. **å·®é›†**: $A \setminus B = \{x : x \in A \land x \notin B\}$
4. **å¯¹ç§°å·®é›†**: $A \triangle B = (A \setminus B) \cup (B \setminus A)$
5. **è¡¥é›†**: $A^c = \{x : x \notin A\}$

### 1.3 é›†åˆè¿ç®—ç±»å‹

**å®šä¹‰ 1.1.3** (é›†åˆè¿ç®—åˆ†ç±»)
é›†åˆè¿ç®—å¯ä»¥åˆ†ä¸ºä»¥ä¸‹ç±»å‹ï¼š

1. **å¸ƒå°”è¿ç®—**: å¹¶é›†ã€äº¤é›†ã€è¡¥é›†ç­‰
2. **ç¬›å¡å°”ç§¯**: $A \times B = \{(a,b) : a \in A \land b \in B\}$
3. **å¹‚é›†è¿ç®—**: $\mathcal{P}(A) = \{B : B \subseteq A\}$
4. **å¹¿ä¹‰è¿ç®—**: å¯¹ä»»æ„é›†åˆæ—çš„è¿ç®—

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 é›†åˆè¿ç®—çš„å…¬ç†åŒ–å®šä¹‰

**å®šä¹‰ 1.2.1** (å¹¶é›†è¿ç®—)
å¯¹äºä»»æ„é›†åˆ $A$ å’Œ $B$ï¼Œå¹¶é›†è¿ç®—å®šä¹‰ä¸ºï¼š
$$A \cup B = \{x : x \in A \lor x \in B\}$$

**å®šä¹‰ 1.2.2** (äº¤é›†è¿ç®—)
å¯¹äºä»»æ„é›†åˆ $A$ å’Œ $B$ï¼Œäº¤é›†è¿ç®—å®šä¹‰ä¸ºï¼š
$$A \cap B = \{x : x \in A \land x \in B\}$$

**å®šä¹‰ 1.2.3** (å·®é›†è¿ç®—)
å¯¹äºä»»æ„é›†åˆ $A$ å’Œ $B$ï¼Œå·®é›†è¿ç®—å®šä¹‰ä¸ºï¼š
$$A \setminus B = \{x : x \in A \land x \notin B\}$$

**å®šä¹‰ 1.2.4** (å¯¹ç§°å·®é›†è¿ç®—)
å¯¹äºä»»æ„é›†åˆ $A$ å’Œ $B$ï¼Œå¯¹ç§°å·®é›†è¿ç®—å®šä¹‰ä¸ºï¼š
$$A \triangle B = (A \setminus B) \cup (B \setminus A)$$

**å®šä¹‰ 1.2.5** (è¡¥é›†è¿ç®—)
å¯¹äºä»»æ„é›†åˆ $A$ å’Œå…¨é›† $U$ï¼Œè¡¥é›†è¿ç®—å®šä¹‰ä¸ºï¼š
$$A^c = U \setminus A = \{x \in U : x \notin A\}$$

### 2.2 å¹¿ä¹‰é›†åˆè¿ç®—

**å®šä¹‰ 1.2.6** (å¹¿ä¹‰å¹¶é›†)
å¯¹äºé›†åˆæ— $\mathcal{F}$ï¼Œå¹¿ä¹‰å¹¶é›†å®šä¹‰ä¸ºï¼š
$$\bigcup \mathcal{F} = \{x : \exists A \in \mathcal{F}(x \in A)\}$$

**å®šä¹‰ 1.2.7** (å¹¿ä¹‰äº¤é›†)
å¯¹äºéç©ºé›†åˆæ— $\mathcal{F}$ï¼Œå¹¿ä¹‰äº¤é›†å®šä¹‰ä¸ºï¼š
$$\bigcap \mathcal{F} = \{x : \forall A \in \mathcal{F}(x \in A)\}$$

**å®šä¹‰ 1.2.8** (ç¬›å¡å°”ç§¯)
å¯¹äºé›†åˆ $A$ å’Œ $B$ï¼Œç¬›å¡å°”ç§¯å®šä¹‰ä¸ºï¼š
$$A \times B = \{(a,b) : a \in A \land b \in B\}$$

**å®šä¹‰ 1.2.9** (å¹‚é›†è¿ç®—)
å¯¹äºé›†åˆ $A$ï¼Œå¹‚é›†è¿ç®—å®šä¹‰ä¸ºï¼š
$$\mathcal{P}(A) = \{B : B \subseteq A\}$$

### 2.3 é›†åˆè¿ç®—çš„ä»£æ•°ç»“æ„

**å®šä¹‰ 1.2.10** (å¸ƒå°”ä»£æ•°)
é›†åˆçš„å¸ƒå°”ä»£æ•°æ˜¯ä¸€ä¸ªå…­å…ƒç»„ $(2^U, \cup, \cap, ^c, \emptyset, U)$ï¼Œå…¶ä¸­ï¼š
- $2^U$ æ˜¯å…¨é›† $U$ çš„å¹‚é›†
- $\cup$ æ˜¯å¹¶é›†è¿ç®—
- $\cap$ æ˜¯äº¤é›†è¿ç®—
- $^c$ æ˜¯è¡¥é›†è¿ç®—
- $\emptyset$ æ˜¯ç©ºé›†
- $U$ æ˜¯å…¨é›†

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬è¿ç®—æ€§è´¨

**å®šç† 1.3.1** (äº¤æ¢å¾‹)
å¯¹äºä»»æ„é›†åˆ $A$ å’Œ $B$ï¼Œæœ‰ï¼š
$$A \cup B = B \cup A$$
$$A \cap B = B \cap A$$

**è¯æ˜**:
1. è¯æ˜å¹¶é›†äº¤æ¢å¾‹ $A \cup B = B \cup A$:
   - $x \in A \cup B$ å½“ä¸”ä»…å½“ $x \in A$ æˆ– $x \in B$
   - å½“ä¸”ä»…å½“ $x \in B$ æˆ– $x \in A$
   - å½“ä¸”ä»…å½“ $x \in B \cup A$

2. è¯æ˜äº¤é›†äº¤æ¢å¾‹ $A \cap B = B \cap A$:
   - $x \in A \cap B$ å½“ä¸”ä»…å½“ $x \in A$ ä¸” $x \in B$
   - å½“ä¸”ä»…å½“ $x \in B$ ä¸” $x \in A$
   - å½“ä¸”ä»…å½“ $x \in B \cap A$

**å®šç† 1.3.2** (ç»“åˆå¾‹)
å¯¹äºä»»æ„é›†åˆ $A$ã€$B$ å’Œ $C$ï¼Œæœ‰ï¼š
$$(A \cup B) \cup C = A \cup (B \cup C)$$
$$(A \cap B) \cap C = A \cap (B \cap C)$$

**è¯æ˜**:
1. è¯æ˜å¹¶é›†ç»“åˆå¾‹ $(A \cup B) \cup C = A \cup (B \cup C)$:
   - $x \in (A \cup B) \cup C$ å½“ä¸”ä»…å½“ $x \in A \cup B$ æˆ– $x \in C$
   - å½“ä¸”ä»…å½“ $(x \in A$ æˆ– $x \in B)$ æˆ– $x \in C$
   - å½“ä¸”ä»…å½“ $x \in A$ æˆ– $(x \in B$ æˆ– $x \in C)$
   - å½“ä¸”ä»…å½“ $x \in A \cup (B \cup C)$

2. è¯æ˜äº¤é›†ç»“åˆå¾‹ $(A \cap B) \cap C = A \cap (B \cap C)$:
   - $x \in (A \cap B) \cap C$ å½“ä¸”ä»…å½“ $x \in A \cap B$ ä¸” $x \in C$
   - å½“ä¸”ä»…å½“ $(x \in A$ ä¸” $x \in B)$ ä¸” $x \in C$
   - å½“ä¸”ä»…å½“ $x \in A$ ä¸” $(x \in B$ ä¸” $x \in C)$
   - å½“ä¸”ä»…å½“ $x \in A \cap (B \cap C)$

**å®šç† 1.3.3** (åˆ†é…å¾‹)
å¯¹äºä»»æ„é›†åˆ $A$ã€$B$ å’Œ $C$ï¼Œæœ‰ï¼š
$$A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$$
$$A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$$

**è¯æ˜**:
1. è¯æ˜äº¤é›†å¯¹å¹¶é›†çš„åˆ†é…å¾‹ $A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$:
   - $x \in A \cap (B \cup C)$ å½“ä¸”ä»…å½“ $x \in A$ ä¸” $x \in (B \cup C)$
   - å½“ä¸”ä»…å½“ $x \in A$ ä¸” $(x \in B$ æˆ– $x \in C)$
   - å½“ä¸”ä»…å½“ $(x \in A$ ä¸” $x \in B)$ æˆ– $(x \in A$ ä¸” $x \in C)$
   - å½“ä¸”ä»…å½“ $x \in (A \cap B) \cup (A \cap C)$

2. è¯æ˜å¹¶é›†å¯¹äº¤é›†çš„åˆ†é…å¾‹ $A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$:
   - $x \in A \cup (B \cap C)$ å½“ä¸”ä»…å½“ $x \in A$ æˆ– $x \in (B \cap C)$
   - å½“ä¸”ä»…å½“ $x \in A$ æˆ– $(x \in B$ ä¸” $x \in C)$
   - å½“ä¸”ä»…å½“ $(x \in A$ æˆ– $x \in B)$ ä¸” $(x \in A$ æˆ– $x \in C)$
   - å½“ä¸”ä»…å½“ $x \in (A \cup B) \cap (A \cup C)$

### 3.2 å¾·æ‘©æ ¹å¾‹

**å®šç† 1.3.4** (å¾·æ‘©æ ¹å¾‹)
å¯¹äºä»»æ„é›†åˆ $A$ å’Œ $B$ï¼Œæœ‰ï¼š
$$(A \cup B)^c = A^c \cap B^c$$
$$(A \cap B)^c = A^c \cup B^c$$

**è¯æ˜**:
1. è¯æ˜ $(A \cup B)^c = A^c \cap B^c$:
   - $x \in (A \cup B)^c$ å½“ä¸”ä»…å½“ $x \notin A \cup B$
   - å½“ä¸”ä»…å½“ $x \notin A$ ä¸” $x \notin B$
   - å½“ä¸”ä»…å½“ $x \in A^c$ ä¸” $x \in B^c$
   - å½“ä¸”ä»…å½“ $x \in A^c \cap B^c$

2. è¯æ˜ $(A \cap B)^c = A^c \cup B^c$:
   - $x \in (A \cap B)^c$ å½“ä¸”ä»…å½“ $x \notin A \cap B$
   - å½“ä¸”ä»…å½“ $x \notin A$ æˆ– $x \notin B$
   - å½“ä¸”ä»…å½“ $x \in A^c$ æˆ– $x \in B^c$
   - å½“ä¸”ä»…å½“ $x \in A^c \cup B^c$

### 3.3 å¹‚é›†è¿ç®—æ€§è´¨

**å®šç† 1.3.5** (å¹‚é›†è¿ç®—æ€§è´¨)
å¯¹äºä»»æ„é›†åˆ $A$ å’Œ $B$ï¼Œæœ‰ï¼š
1. $A \subseteq B$ å½“ä¸”ä»…å½“ $\mathcal{P}(A) \subseteq \mathcal{P}(B)$
2. $\mathcal{P}(A \cap B) = \mathcal{P}(A) \cap \mathcal{P}(B)$
3. $\mathcal{P}(A \cup B) \supseteq \mathcal{P}(A) \cup \mathcal{P}(B)$

**è¯æ˜**:
1. è¯æ˜ $A \subseteq B$ å½“ä¸”ä»…å½“ $\mathcal{P}(A) \subseteq \mathcal{P}(B)$:
   - å‡è®¾ $A \subseteq B$
   - å¯¹äºä»»æ„ $X \in \mathcal{P}(A)$ï¼Œæœ‰ $X \subseteq A \subseteq B$
   - å› æ­¤ $X \in \mathcal{P}(B)$
   - æ‰€ä»¥ $\mathcal{P}(A) \subseteq \mathcal{P}(B)$
   
   - åä¹‹ï¼Œå‡è®¾ $\mathcal{P}(A) \subseteq \mathcal{P}(B)$
   - ç”±äº $A \in \mathcal{P}(A)$ï¼Œæœ‰ $A \in \mathcal{P}(B)$
   - å› æ­¤ $A \subseteq B$

2. è¯æ˜ $\mathcal{P}(A \cap B) = \mathcal{P}(A) \cap \mathcal{P}(B)$:
   - $X \in \mathcal{P}(A \cap B)$ å½“ä¸”ä»…å½“ $X \subseteq A \cap B$
   - å½“ä¸”ä»…å½“ $X \subseteq A$ ä¸” $X \subseteq B$
   - å½“ä¸”ä»…å½“ $X \in \mathcal{P}(A)$ ä¸” $X \in \mathcal{P}(B)$
   - å½“ä¸”ä»…å½“ $X \in \mathcal{P}(A) \cap \mathcal{P}(B)$

3. è¯æ˜ $\mathcal{P}(A \cup B) \supseteq \mathcal{P}(A) \cup \mathcal{P}(B)$:
   - å¯¹äºä»»æ„ $X \in \mathcal{P}(A) \cup \mathcal{P}(B)$
   - æœ‰ $X \in \mathcal{P}(A)$ æˆ– $X \in \mathcal{P}(B)$
   - å› æ­¤ $X \subseteq A$ æˆ– $X \subseteq B$
   - æ‰€ä»¥ $X \subseteq A \cup B$
   - å› æ­¤ $X \in \mathcal{P}(A \cup B)$

### 3.4 ç¬›å¡å°”ç§¯æ€§è´¨

**å®šç† 1.3.6** (ç¬›å¡å°”ç§¯æ€§è´¨)
å¯¹äºä»»æ„é›†åˆ $A$ã€$B$ã€$C$ å’Œ $D$ï¼Œæœ‰ï¼š
1. $(A \cup B) \times C = (A \times C) \cup (B \times C)$
2. $(A \cap B) \times C = (A \times C) \cap (B \times C)$
3. $(A \setminus B) \times C = (A \times C) \setminus (B \times C)$

**è¯æ˜**:
1. è¯æ˜ $(A \cup B) \times C = (A \times C) \cup (B \times C)$:
   - $(x,y) \in (A \cup B) \times C$ å½“ä¸”ä»…å½“ $x \in A \cup B$ ä¸” $y \in C$
   - å½“ä¸”ä»…å½“ $(x \in A$ æˆ– $x \in B)$ ä¸” $y \in C$
   - å½“ä¸”ä»…å½“ $(x \in A$ ä¸” $y \in C)$ æˆ– $(x \in B$ ä¸” $y \in C)$
   - å½“ä¸”ä»…å½“ $(x,y) \in A \times C$ æˆ– $(x,y) \in B \times C$
   - å½“ä¸”ä»…å½“ $(x,y) \in (A \times C) \cup (B \times C)$

2. è¯æ˜ $(A \cap B) \times C = (A \times C) \cap (B \times C)$:
   - $(x,y) \in (A \cap B) \times C$ å½“ä¸”ä»…å½“ $x \in A \cap B$ ä¸” $y \in C$
   - å½“ä¸”ä»…å½“ $(x \in A$ ä¸” $x \in B)$ ä¸” $y \in C$
   - å½“ä¸”ä»…å½“ $(x \in A$ ä¸” $y \in C)$ ä¸” $(x \in B$ ä¸” $y \in C)$
   - å½“ä¸”ä»…å½“ $(x,y) \in A \times C$ ä¸” $(x,y) \in B \times C$
   - å½“ä¸”ä»…å½“ $(x,y) \in (A \times C) \cap (B \times C)$

3. è¯æ˜ $(A \setminus B) \times C = (A \times C) \setminus (B \times C)$:
   - $(x,y) \in (A \setminus B) \times C$ å½“ä¸”ä»…å½“ $x \in A \setminus B$ ä¸” $y \in C$
   - å½“ä¸”ä»…å½“ $x \in A$ ä¸” $x \notin B$ ä¸” $y \in C$
   - å½“ä¸”ä»…å½“ $(x,y) \in A \times C$ ä¸” $(x,y) \notin B \times C$
   - å½“ä¸”ä»…å½“ $(x,y) \in (A \times C) \setminus (B \times C)$

## 4. ä»£ç å®ç°

### 4.1 é›†åˆè¿ç®—åŸºç¡€å®ç°

```rust
use std::collections::HashSet;
use std::fmt;
use std::hash::{Hash, Hasher};

/// é›†åˆå…ƒç´ ç±»å‹
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SetElement {
    /// è‡ªç„¶æ•°
    Natural(usize),
    /// å­—ç¬¦ä¸²
    String(String),
    /// æœ‰åºå¯¹
    OrderedPair(Box<SetElement>, Box<SetElement>),
    /// é›†åˆ
    Set(HashSet<SetElement>),
}

impl fmt::Display for SetElement {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            SetElement::Natural(n) => write!(f, "{}", n),
            SetElement::String(s) => write!(f, "\"{}\"", s),
            SetElement::OrderedPair(a, b) => write!(f, "({}, {})", a, b),
            SetElement::Set(elements) => {
                write!(f, "{{")?;
                let mut first = true;
                for element in elements {
                    if !first {
                        write!(f, ", ")?;
                    }
                    write!(f, "{}", element)?;
                    first = false;
                }
                write!(f, "}}")
            }
        }
    }
}

/// é›†åˆè¿ç®—
pub struct SetOperations;

impl SetOperations {
    /// åˆ›å»ºç©ºé›†
    pub fn empty_set() -> SetElement {
        SetElement::Set(HashSet::new())
    }
    
    /// åˆ›å»ºå•å…ƒç´ é›†
    pub fn singleton(element: SetElement) -> SetElement {
        let mut set = HashSet::new();
        set.insert(element);
        SetElement::Set(set)
    }
    
    /// å¹¶é›†è¿ç®—
    pub fn union(a: &SetElement, b: &SetElement) -> Option<SetElement> {
        if let (SetElement::Set(set_a), SetElement::Set(set_b)) = (a, b) {
            let mut result = set_a.clone();
            result.extend(set_b.clone());
            Some(SetElement::Set(result))
        } else {
            None
        }
    }
    
    /// äº¤é›†è¿ç®—
    pub fn intersection(a: &SetElement, b: &SetElement) -> Option<SetElement> {
        if let (SetElement::Set(set_a), SetElement::Set(set_b)) = (a, b) {
            let result: HashSet<SetElement> = set_a.intersection(set_b).cloned().collect();
            Some(SetElement::Set(result))
        } else {
            None
        }
    }
    
    /// å·®é›†è¿ç®—
    pub fn difference(a: &SetElement, b: &SetElement) -> Option<SetElement> {
        if let (SetElement::Set(set_a), SetElement::Set(set_b)) = (a, b) {
            let result: HashSet<SetElement> = set_a.difference(set_b).cloned().collect();
            Some(SetElement::Set(result))
        } else {
            None
        }
    }
    
    /// å¯¹ç§°å·®é›†è¿ç®—
    pub fn symmetric_difference(a: &SetElement, b: &SetElement) -> Option<SetElement> {
        if let (SetElement::Set(set_a), SetElement::Set(set_b)) = (a, b) {
            let diff_ab: HashSet<SetElement> = set_a.difference(set_b).cloned().collect();
            let diff_ba: HashSet<SetElement> = set_b.difference(set_a).cloned().collect();
            let mut result = diff_ab;
            result.extend(diff_ba);
            Some(SetElement::Set(result))
        } else {
            None
        }
    }
    
    /// è¡¥é›†è¿ç®—
    pub fn complement(a: &SetElement, universe: &SetElement) -> Option<SetElement> {
        Self::difference(universe, a)
    }
    
    /// å¹‚é›†è¿ç®—
    pub fn power_set(a: &SetElement) -> Option<SetElement> {
        if let SetElement::Set(set_a) = a {
            let mut power_set = HashSet::new();
            power_set.insert(SetElement::Set(HashSet::new())); // ç©ºé›†
            
            // ç”Ÿæˆæ‰€æœ‰å­é›†
            let elements: Vec<SetElement> = set_a.iter().cloned().collect();
            for i in 0..(1 << elements.len()) {
                let mut subset = HashSet::new();
                for j in 0..elements.len() {
                    if (i >> j) & 1 == 1 {
                        subset.insert(elements[j].clone());
                    }
                }
                power_set.insert(SetElement::Set(subset));
            }
            
            Some(SetElement::Set(power_set))
        } else {
            None
        }
    }
    
    /// ç¬›å¡å°”ç§¯è¿ç®—
    pub fn cartesian_product(a: &SetElement, b: &SetElement) -> Option<SetElement> {
        if let (SetElement::Set(set_a), SetElement::Set(set_b)) = (a, b) {
            let mut result = HashSet::new();
            for element_a in set_a {
                for element_b in set_b {
                    result.insert(SetElement::OrderedPair(
                        Box::new(element_a.clone()),
                        Box::new(element_b.clone())
                    ));
                }
            }
            Some(SetElement::Set(result))
        } else {
            None
        }
    }
    
    /// å¹¿ä¹‰å¹¶é›†è¿ç®—
    pub fn generalized_union(sets: &[SetElement]) -> Option<SetElement> {
        let mut result = HashSet::new();
        
        for set in sets {
            if let SetElement::Set(elements) = set {
                result.extend(elements.clone());
            } else {
                return None;
            }
        }
        
        Some(SetElement::Set(result))
    }
    
    /// å¹¿ä¹‰äº¤é›†è¿ç®—
    pub fn generalized_intersection(sets: &[SetElement]) -> Option<SetElement> {
        if sets.is_empty() {
            return None;
        }
        
        let mut result = if let SetElement::Set(elements) = &sets[0] {
            elements.clone()
        } else {
            return None;
        };
        
        for set in &sets[1..] {
            if let SetElement::Set(elements) = set {
                result = result.intersection(elements).cloned().collect();
            } else {
                return None;
            }
        }
        
        Some(SetElement::Set(result))
    }
}

/// é›†åˆä»£æ•°
pub struct SetAlgebra;

impl SetAlgebra {
    /// éªŒè¯äº¤æ¢å¾‹
    pub fn verify_commutativity(a: &SetElement, b: &SetElement) -> bool {
        let union_ab = SetOperations::union(a, b);
        let union_ba = SetOperations::union(b, a);
        let intersection_ab = SetOperations::intersection(a, b);
        let intersection_ba = SetOperations::intersection(b, a);
        
        union_ab == union_ba && intersection_ab == intersection_ba
    }
    
    /// éªŒè¯ç»“åˆå¾‹
    pub fn verify_associativity(a: &SetElement, b: &SetElement, c: &SetElement) -> bool {
        let union_ab = SetOperations::union(a, b);
        let union_bc = SetOperations::union(b, c);
        
        let left_union = if let Some(union_ab) = union_ab {
            SetOperations::union(&union_ab, c)
        } else {
            None
        };
        
        let right_union = if let Some(union_bc) = union_bc {
            SetOperations::union(a, &union_bc)
        } else {
            None
        };
        
        left_union == right_union
    }
    
    /// éªŒè¯åˆ†é…å¾‹
    pub fn verify_distributivity(a: &SetElement, b: &SetElement, c: &SetElement) -> bool {
        let union_bc = SetOperations::union(b, c);
        let intersection_bc = SetOperations::intersection(b, c);
        
        // éªŒè¯äº¤é›†å¯¹å¹¶é›†çš„åˆ†é…å¾‹
        let left_distribution = if let Some(union_bc) = union_bc {
            SetOperations::intersection(a, &union_bc)
        } else {
            None
        };
        
        let intersection_ab = SetOperations::intersection(a, b);
        let intersection_ac = SetOperations::intersection(a, c);
        let right_distribution = if let (Some(ab), Some(ac)) = (intersection_ab, intersection_ac) {
            SetOperations::union(&ab, &ac)
        } else {
            None
        };
        
        left_distribution == right_distribution
    }
    
    /// éªŒè¯å¾·æ‘©æ ¹å¾‹
    pub fn verify_de_morgan(a: &SetElement, b: &SetElement, universe: &SetElement) -> bool {
        let union_ab = SetOperations::union(a, b);
        let intersection_ab = SetOperations::intersection(a, b);
        
        // éªŒè¯ (A âˆª B)^c = A^c âˆ© B^c
        let left_de_morgan = if let Some(union_ab) = union_ab {
            SetOperations::complement(&union_ab, universe)
        } else {
            None
        };
        
        let complement_a = SetOperations::complement(a, universe);
        let complement_b = SetOperations::complement(b, universe);
        let right_de_morgan = if let (Some(ca), Some(cb)) = (complement_a, complement_b) {
            SetOperations::intersection(&ca, &cb)
        } else {
            None
        };
        
        left_de_morgan == right_de_morgan
    }
}

/// é›†åˆè¿ç®—ä¼˜åŒ–
pub struct SetOptimizer;

impl SetOptimizer {
    /// ä¼˜åŒ–é›†åˆè¿ç®—è¡¨è¾¾å¼
    pub fn optimize_expression(expression: &str) -> String {
        // ç®€åŒ–å®ç°ï¼šåŸºæœ¬çš„è¡¨è¾¾å¼ä¼˜åŒ–
        expression.to_string()
    }
    
    /// è®¡ç®—é›†åˆè¿ç®—çš„å¤æ‚åº¦
    pub fn calculate_complexity(operation: &str, size_a: usize, size_b: usize) -> usize {
        match operation {
            "union" => size_a + size_b,
            "intersection" => std::cmp::min(size_a, size_b),
            "difference" => size_a,
            "symmetric_difference" => size_a + size_b,
            "cartesian_product" => size_a * size_b,
            "power_set" => 1 << size_a,
            _ => 0
        }
    }
    
    /// å¹¶è¡Œé›†åˆè¿ç®—
    pub fn parallel_union(sets: &[SetElement]) -> Option<SetElement> {
        // ç®€åŒ–å®ç°ï¼šä¸²è¡Œå¤„ç†
        SetOperations::generalized_union(sets)
    }
}

/// é›†åˆè¿ç®—æµ‹è¯•
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_basic_operations() {
        // åˆ›å»ºæµ‹è¯•é›†åˆ
        let a = SetElement::Set({
            let mut set = HashSet::new();
            set.insert(SetElement::Natural(1));
            set.insert(SetElement::Natural(2));
            set.insert(SetElement::Natural(3));
            set
        });
        
        let b = SetElement::Set({
            let mut set = HashSet::new();
            set.insert(SetElement::Natural(2));
            set.insert(SetElement::Natural(3));
            set.insert(SetElement::Natural(4));
            set
        });
        
        // æµ‹è¯•å¹¶é›†
        let union = SetOperations::union(&a, &b).unwrap();
        println!("A âˆª B = {}", union);
        
        // æµ‹è¯•äº¤é›†
        let intersection = SetOperations::intersection(&a, &b).unwrap();
        println!("A âˆ© B = {}", intersection);
        
        // æµ‹è¯•å·®é›†
        let difference = SetOperations::difference(&a, &b).unwrap();
        println!("A \\ B = {}", difference);
        
        // æµ‹è¯•å¯¹ç§°å·®é›†
        let symmetric_diff = SetOperations::symmetric_difference(&a, &b).unwrap();
        println!("A â–³ B = {}", symmetric_diff);
    }
    
    #[test]
    fn test_advanced_operations() {
        let a = SetElement::Set({
            let mut set = HashSet::new();
            set.insert(SetElement::Natural(1));
            set.insert(SetElement::Natural(2));
            set
        });
        
        let b = SetElement::Set({
            let mut set = HashSet::new();
            set.insert(SetElement::Natural(3));
            set.insert(SetElement::Natural(4));
            set
        });
        
        // æµ‹è¯•ç¬›å¡å°”ç§¯
        let cartesian = SetOperations::cartesian_product(&a, &b).unwrap();
        println!("A Ã— B = {}", cartesian);
        
        // æµ‹è¯•å¹‚é›†
        let power_set = SetOperations::power_set(&a).unwrap();
        println!("P(A) = {}", power_set);
    }
    
    #[test]
    fn test_algebraic_properties() {
        let a = SetElement::Set({
            let mut set = HashSet::new();
            set.insert(SetElement::Natural(1));
            set.insert(SetElement::Natural(2));
            set
        });
        
        let b = SetElement::Set({
            let mut set = HashSet::new();
            set.insert(SetElement::Natural(2));
            set.insert(SetElement::Natural(3));
            set
        });
        
        let c = SetElement::Set({
            let mut set = HashSet::new();
            set.insert(SetElement::Natural(3));
            set.insert(SetElement::Natural(4));
            set
        });
        
        // éªŒè¯äº¤æ¢å¾‹
        assert!(SetAlgebra::verify_commutativity(&a, &b));
        
        // éªŒè¯ç»“åˆå¾‹
        assert!(SetAlgebra::verify_associativity(&a, &b, &c));
        
        // éªŒè¯åˆ†é…å¾‹
        assert!(SetAlgebra::verify_distributivity(&a, &b, &c));
    }
    
    #[test]
    fn test_complexity_calculation() {
        let complexity_union = SetOptimizer::calculate_complexity("union", 100, 200);
        let complexity_intersection = SetOptimizer::calculate_complexity("intersection", 100, 200);
        let complexity_cartesian = SetOptimizer::calculate_complexity("cartesian_product", 10, 20);
        
        println!("å¹¶é›†å¤æ‚åº¦: {}", complexity_union);
        println!("äº¤é›†å¤æ‚åº¦: {}", complexity_intersection);
        println!("ç¬›å¡å°”ç§¯å¤æ‚åº¦: {}", complexity_cartesian);
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

**ç¤ºä¾‹ 1**: æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
```rust
// æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
fn optimize_database_query() {
    // æ¨¡æ‹Ÿæ•°æ®åº“è¡¨
    let users = SetElement::Set({
        let mut set = HashSet::new();
        set.insert(SetElement::String("user1".to_string()));
        set.insert(SetElement::String("user2".to_string()));
        set.insert(SetElement::String("user3".to_string()));
        set
    });
    
    let active_users = SetElement::Set({
        let mut set = HashSet::new();
        set.insert(SetElement::String("user1".to_string()));
        set.insert(SetElement::String("user2".to_string()));
        set
    });
    
    let premium_users = SetElement::Set({
        let mut set = HashSet::new();
        set.insert(SetElement::String("user2".to_string()));
        set.insert(SetElement::String("user3".to_string()));
        set
    });
    
    // æŸ¥è¯¢ï¼šæ´»è·ƒä¸”é«˜çº§çš„ç”¨æˆ·
    let active_premium = SetOperations::intersection(&active_users, &premium_users).unwrap();
    println!("æ´»è·ƒä¸”é«˜çº§ç”¨æˆ·: {}", active_premium);
    
    // æŸ¥è¯¢ï¼šæ‰€æœ‰ç”¨æˆ·ä¸­éæ´»è·ƒçš„
    let inactive_users = SetOperations::difference(&users, &active_users).unwrap();
    println!("éæ´»è·ƒç”¨æˆ·: {}", inactive_users);
}
```

### 5.2 å›¾å½¢ç®—æ³•

**ç¤ºä¾‹ 2**: å›¾å½¢ç®—æ³•ä¸­çš„é›†åˆè¿ç®—
```rust
// å›¾å½¢ç®—æ³•ä¸­çš„é›†åˆè¿ç®—
fn graph_algorithms() {
    // é¡¶ç‚¹é›†
    let vertices = SetElement::Set({
        let mut set = HashSet::new();
        for i in 1..=5 {
            set.insert(SetElement::Natural(i));
        }
        set
    });
    
    // è¾¹é›†
    let edges = SetElement::Set({
        let mut set = HashSet::new();
        set.insert(SetElement::OrderedPair(
            Box::new(SetElement::Natural(1)),
            Box::new(SetElement::Natural(2))
        ));
        set.insert(SetElement::OrderedPair(
            Box::new(SetElement::Natural(2)),
            Box::new(SetElement::Natural(3))
        ));
        set.insert(SetElement::OrderedPair(
            Box::new(SetElement::Natural(3)),
            Box::new(SetElement::Natural(4))
        ));
        set
    });
    
    // è®¡ç®—å›¾çš„è¡¥é›†
    let all_possible_edges = SetOperations::cartesian_product(&vertices, &vertices).unwrap();
    let complement_edges = SetOperations::difference(&all_possible_edges, &edges).unwrap();
    
    println!("åŸå›¾è¾¹é›†: {}", edges);
    println!("è¡¥å›¾è¾¹é›†: {}", complement_edges);
}
```

### 5.3 æ¦‚ç‡è®ºåº”ç”¨

**ç¤ºä¾‹ 3**: æ¦‚ç‡è®ºä¸­çš„é›†åˆè¿ç®—
```rust
// æ¦‚ç‡è®ºä¸­çš„é›†åˆè¿ç®—
fn probability_applications() {
    // æ ·æœ¬ç©ºé—´
    let sample_space = SetElement::Set({
        let mut set = HashSet::new();
        for i in 1..=6 {
            set.insert(SetElement::Natural(i));
        }
        set
    });
    
    // äº‹ä»¶Aï¼šæ·å‡ºå¶æ•°
    let event_a = SetElement::Set({
        let mut set = HashSet::new();
        set.insert(SetElement::Natural(2));
        set.insert(SetElement::Natural(4));
        set.insert(SetElement::Natural(6));
        set
    });
    
    // äº‹ä»¶Bï¼šæ·å‡ºå¤§äº3çš„æ•°
    let event_b = SetElement::Set({
        let mut set = HashSet::new();
        set.insert(SetElement::Natural(4));
        set.insert(SetElement::Natural(5));
        set.insert(SetElement::Natural(6));
        set
    });
    
    // è®¡ç®—å„ç§æ¦‚ç‡äº‹ä»¶
    let a_union_b = SetOperations::union(&event_a, &event_b).unwrap();
    let a_intersection_b = SetOperations::intersection(&event_a, &event_b).unwrap();
    let a_complement = SetOperations::complement(&event_a, &sample_space).unwrap();
    
    println!("A âˆª B (Aæˆ–Bå‘ç”Ÿ): {}", a_union_b);
    println!("A âˆ© B (Aä¸”Bå‘ç”Ÿ): {}", a_intersection_b);
    println!("A^c (Aä¸å‘ç”Ÿ): {}", a_complement);
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸æœ´ç´ é›†åˆè®ºçš„å…³ç³»

é›†åˆè¿ç®—æ˜¯æœ´ç´ é›†åˆè®ºçš„æ ¸å¿ƒï¼š
- **åŸºæœ¬è¿ç®—**: é›†åˆè¿ç®—æ„æˆæœ´ç´ é›†åˆè®ºçš„åŸºç¡€
- **è¿ç®—æ€§è´¨**: é›†åˆè¿ç®—çš„æ€§è´¨åæ˜ é›†åˆçš„æœ¬è´¨
- **è¿ç®—è§„å¾‹**: é›†åˆè¿ç®—çš„è§„å¾‹ä¸ºé›†åˆè®ºæä¾›ç»“æ„

### 6.2 ä¸å…¬ç†é›†åˆè®ºçš„å…³ç³»

é›†åˆè¿ç®—åœ¨å…¬ç†é›†åˆè®ºä¸­å½¢å¼åŒ–ï¼š
- **å…¬ç†åŒ–å®šä¹‰**: é›†åˆè¿ç®—é€šè¿‡å…¬ç†ä¸¥æ ¼å®šä¹‰
- **ä¸€è‡´æ€§**: é›†åˆè¿ç®—çš„å…¬ç†åŒ–ç¡®ä¿ç†è®ºä¸€è‡´æ€§
- **å®Œå¤‡æ€§**: å…¬ç†é›†åˆè®ºä¸ºé›†åˆè¿ç®—æä¾›å®Œå¤‡åŸºç¡€

### 6.3 ä¸ä»£æ•°ç†è®ºçš„å…³ç³»

é›†åˆè¿ç®—å½¢æˆä»£æ•°ç»“æ„ï¼š
- **å¸ƒå°”ä»£æ•°**: é›†åˆè¿ç®—æ„æˆå¸ƒå°”ä»£æ•°
- **æ ¼è®º**: é›†åˆè¿ç®—å½¢æˆæ ¼ç»“æ„
- **èŒƒç•´è®º**: é›†åˆè¿ç®—åœ¨èŒƒç•´è®ºä¸­æœ‰è‡ªç„¶æ¨å¹¿

## 7. å‚è€ƒæ–‡çŒ®

1. Halmos, P. R. (1974). *Naive set theory*. Springer Science & Business Media.

2. Jech, T. (2003). *Set theory*. Springer Science & Business Media.

3. Kunen, K. (2011). *Set theory*. College Publications.

4. Enderton, H. B. (1977). *Elements of set theory*. Academic Press.

5. Suppes, P. (1972). *Axiomatic set theory*. Dover Publications.

---

**ç›¸å…³æ–‡æ¡£**:
- [02.1.1 æœ´ç´ é›†åˆè®º](02.1.1_æœ´ç´ é›†åˆè®º.md)
- [02.1.2 å…¬ç†é›†åˆè®º](02.1.2_å…¬ç†é›†åˆè®º.md)
- [02.1.4 é›†åˆå…³ç³»](02.1.4_é›†åˆå…³ç³».md)
- [02.5.1 å…³ç³»æ¦‚å¿µ](../05_Relation_Theory/02.5.1_å…³ç³»æ¦‚å¿µ.md)

**è¿”å›**: [æ•°å­¦åŸºç¡€ç†è®º](../README.md) | [ä¸»ç´¢å¼•](../../00_Master_Index/README.md) 