# é›†åˆè®º (Set Theory)

## ğŸ“š **ç›®å½•ç»“æ„**

```
01_Set_Theory/
â”œâ”€â”€ README.md                           # å½“å‰æ–‡ä»¶ - é›†åˆè®ºæ€»è§ˆ
â”œâ”€â”€ 01_Naive_Set_Theory/                # æœ´ç´ é›†åˆè®º
â”‚   â”œâ”€â”€ 01_Set_Basics.md                # é›†åˆåŸºç¡€
â”‚   â”œâ”€â”€ 02_Set_Operations.md            # é›†åˆè¿ç®—
â”‚   â””â”€â”€ 03_Set_Relations.md             # é›†åˆå…³ç³»
â”œâ”€â”€ 02_Axiomatic_Set_Theory/            # å…¬ç†åŒ–é›†åˆè®º
â”‚   â”œâ”€â”€ 01_ZFC_Axioms.md                # ZFCå…¬ç†ç³»ç»Ÿ
â”‚   â”œâ”€â”€ 02_Ordinals.md                  # åºæ•°ç†è®º
â”‚   â””â”€â”€ 03_Cardinals.md                 # åŸºæ•°ç†è®º
â””â”€â”€ 03_Set_Theory_Applications/         # é›†åˆè®ºåº”ç”¨
    â”œâ”€â”€ 01_Relations.md                 # å…³ç³»ç†è®º
    â”œâ”€â”€ 02_Functions.md                 # å‡½æ•°ç†è®º
    â””â”€â”€ 03_Equivalence.md               # ç­‰ä»·å…³ç³»
```

## ğŸ¯ **æ ¸å¿ƒä¸»é¢˜**

### 1. æœ´ç´ é›†åˆè®º (Naive Set Theory)
- [01_Naive_Set_Theory/](01_Naive_Set_Theory/) - æœ´ç´ é›†åˆè®ºæ€»è§ˆ
  - [é›†åˆåŸºç¡€](01_Naive_Set_Theory/01_Set_Basics.md) - é›†åˆçš„åŸºæœ¬æ¦‚å¿µå’Œæ€§è´¨
  - [é›†åˆè¿ç®—](01_Naive_Set_Theory/02_Set_Operations.md) - å¹¶é›†ã€äº¤é›†ã€å·®é›†ç­‰è¿ç®—
  - [é›†åˆå…³ç³»](01_Naive_Set_Theory/03_Set_Relations.md) - åŒ…å«ã€ç›¸ç­‰ã€å­é›†ç­‰å…³ç³»

### 2. å…¬ç†åŒ–é›†åˆè®º (Axiomatic Set Theory)
- [02_Axiomatic_Set_Theory/](02_Axiomatic_Set_Theory/) - å…¬ç†åŒ–é›†åˆè®ºæ€»è§ˆ
  - [ZFCå…¬ç†ç³»ç»Ÿ](02_Axiomatic_Set_Theory/01_ZFC_Axioms.md) - Zermelo-Fraenkelå…¬ç†ç³»ç»Ÿ
  - [åºæ•°ç†è®º](02_Axiomatic_Set_Theory/02_Ordinals.md) - åºæ•°çš„å®šä¹‰å’Œæ€§è´¨
  - [åŸºæ•°ç†è®º](02_Axiomatic_Set_Theory/03_Cardinals.md) - åŸºæ•°çš„å®šä¹‰å’Œæ¯”è¾ƒ

### 3. é›†åˆè®ºåº”ç”¨ (Set Theory Applications)
- [03_Set_Theory_Applications/](03_Set_Theory_Applications/) - é›†åˆè®ºåº”ç”¨æ€»è§ˆ
  - [å…³ç³»ç†è®º](03_Set_Theory_Applications/01_Relations.md) - åŸºäºé›†åˆçš„å…³ç³»å®šä¹‰
  - [å‡½æ•°ç†è®º](03_Set_Theory_Applications/02_Functions.md) - åŸºäºé›†åˆçš„å‡½æ•°å®šä¹‰
  - [ç­‰ä»·å…³ç³»](03_Set_Theory_Applications/03_Equivalence.md) - ç­‰ä»·å…³ç³»å’Œå•†é›†

## ğŸ“Š **ç†è®ºæ¡†æ¶**

### é›†åˆè®ºçš„åŸºæœ¬é—®é¢˜

1. **é›†åˆçš„å­˜åœ¨æ€§**
   - ä»€ä¹ˆæ˜¯é›†åˆï¼Ÿ
   - å“ªäº›å¯¹è±¡æ„æˆé›†åˆï¼Ÿ
   - é›†åˆçš„å­˜åœ¨æ¡ä»¶ï¼Ÿ

2. **é›†åˆçš„æ„é€ **
   - å¦‚ä½•æ„é€ æ–°é›†åˆï¼Ÿ
   - é›†åˆè¿ç®—çš„åˆæ³•æ€§ï¼Ÿ
   - é›†åˆæ„é€ çš„é™åˆ¶ï¼Ÿ

3. **é›†åˆçš„æ¯”è¾ƒ**
   - é›†åˆçš„å¤§å°å¦‚ä½•æ¯”è¾ƒï¼Ÿ
   - æ— é™é›†åˆçš„æ€§è´¨ï¼Ÿ
   - åŸºæ•°ä¸åºæ•°çš„å…³ç³»ï¼Ÿ

## ğŸ”— **å½¢å¼åŒ–è¡¨ç¤º**

### é›†åˆç±»å‹ç³»ç»Ÿ

```rust
// é›†åˆçš„åŸºæœ¬ç±»å‹
trait Set<T> {
    /// åˆ¤æ–­å…ƒç´ æ˜¯å¦å±äºé›†åˆ
    fn contains(&self, element: &T) -> bool;
    
    /// åˆ¤æ–­æ˜¯å¦ä¸ºå­é›†
    fn is_subset(&self, other: &Set<T>) -> bool;
    
    /// åˆ¤æ–­æ˜¯å¦ç›¸ç­‰
    fn is_equal(&self, other: &Set<T>) -> bool;
    
    /// è·å–é›†åˆå¤§å°
    fn cardinality(&self) -> Cardinality;
}

// é›†åˆè¿ç®—
trait SetOperations<T> {
    /// å¹¶é›†
    fn union(&self, other: &Set<T>) -> Set<T>;
    
    /// äº¤é›†
    fn intersection(&self, other: &Set<T>) -> Set<T>;
    
    /// å·®é›†
    fn difference(&self, other: &Set<T>) -> Set<T>;
    
    /// å¯¹ç§°å·®é›†
    fn symmetric_difference(&self, other: &Set<T>) -> Set<T>;
    
    /// å¹‚é›†
    fn power_set(&self) -> Set<Set<T>>;
}

// åŸºæ•°ç±»å‹
enum Cardinality {
    Finite(usize),
    CountablyInfinite,
    UncountablyInfinite,
}
```

### é›†åˆè®ºå…¬ç†ç³»ç»Ÿ

```haskell
-- é›†åˆç±»å‹ç±»
class Set a where
    contains :: a -> Element -> Bool
    isSubset :: a -> a -> Bool
    isEqual :: a -> a -> Bool
    cardinality :: a -> Cardinality

-- é›†åˆè¿ç®—ç±»å‹ç±»
class SetOperations a where
    union :: a -> a -> a
    intersection :: a -> a -> a
    difference :: a -> a -> a
    symmetricDifference :: a -> a -> a
    powerSet :: a -> Set a

-- åŸºæ•°ç±»å‹
data Cardinality = Finite Int | CountablyInfinite | UncountablyInfinite
```

## ğŸ“ **æ ¸å¿ƒå®šç†**

### é›†åˆç›¸ç­‰æ€§å®šç†

**å®šç† 1.1** (å¤–å»¶æ€§å…¬ç†)
ä¸¤ä¸ªé›†åˆç›¸ç­‰å½“ä¸”ä»…å½“å®ƒä»¬åŒ…å«ç›¸åŒçš„å…ƒç´ ã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š
$$\forall A \forall B(A = B \leftrightarrow \forall x(x \in A \leftrightarrow x \in B))$$

**è¯æ˜**ï¼š
1. **å‡è®¾**ï¼šè®¾ $A$ å’Œ $B$ æ˜¯ä»»æ„é›†åˆ
2. **ç›®æ ‡**ï¼šè¯æ˜ $A = B \leftrightarrow \forall x(x \in A \leftrightarrow x \in B)$
3. **è¯æ˜æ­¥éª¤**ï¼š
   
   a) **å¿…è¦æ€§**ï¼šå¦‚æœ $A = B$ï¼Œåˆ™æ ¹æ®åŒä¸€æ€§ï¼Œ$A$ å’Œ $B$ çš„æ‰€æœ‰å±æ€§ç›¸åŒ
   
   b) åŒ…å«å…³ç³»æ˜¯é›†åˆçš„å±æ€§ï¼Œå› æ­¤ $\forall x(x \in A \leftrightarrow x \in B)$
   
   c) **å……åˆ†æ€§**ï¼šå¦‚æœ $\forall x(x \in A \leftrightarrow x \in B)$ï¼Œåˆ™ $A$ å’Œ $B$ åŒ…å«ç›¸åŒå…ƒç´ 
   
   d) æ ¹æ®å¤–å»¶æ€§å…¬ç†ï¼Œ$A = B$

4. **ç»“è®º**ï¼š$A = B \leftrightarrow \forall x(x \in A \leftrightarrow x \in B)$

### å¹‚é›†å­˜åœ¨æ€§å®šç†

**å®šç† 1.2** (å¹‚é›†å…¬ç†)
å¯¹äºä»»ä½•é›†åˆ $A$ï¼Œå­˜åœ¨é›†åˆ $P(A)$ åŒ…å« $A$ çš„æ‰€æœ‰å­é›†ã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š
$$\forall A \exists P \forall x(x \in P \leftrightarrow x \subseteq A)$$

**è¯æ˜**ï¼š
1. **å‡è®¾**ï¼šè®¾ $A$ æ˜¯ä»»æ„é›†åˆ
2. **ç›®æ ‡**ï¼šè¯æ˜å­˜åœ¨é›†åˆ $P$ ä½¿å¾— $\forall x(x \in P \leftrightarrow x \subseteq A)$
3. **è¯æ˜æ­¥éª¤**ï¼š
   
   a) æ ¹æ®å¹‚é›†å…¬ç†ï¼Œå¯¹äºä»»ä½•é›†åˆ $A$ï¼Œå­˜åœ¨å¹‚é›† $P(A)$
   
   b) å¹‚é›† $P(A)$ çš„å®šä¹‰æ˜¯ï¼š$P(A) = \{x : x \subseteq A\}$
   
   c) å› æ­¤ï¼Œ$\forall x(x \in P(A) \leftrightarrow x \subseteq A)$

4. **ç»“è®º**ï¼š$\forall A \exists P \forall x(x \in P \leftrightarrow x \subseteq A)$

### é€‰æ‹©å…¬ç†ç­‰ä»·å½¢å¼

**å®šç† 1.3** (ä½æ©å¼•ç†)
æ¯ä¸ªååºé›†éƒ½æœ‰æå¤§é“¾ã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š
$$\forall P(\text{PartiallyOrdered}(P) \rightarrow \exists C(\text{Chain}(C) \land \text{Maximal}(C)))$$

**è¯æ˜**ï¼š
1. **å‡è®¾**ï¼šè®¾ $P$ æ˜¯ååºé›†
2. **ç›®æ ‡**ï¼šè¯æ˜ $P$ æœ‰æå¤§é“¾
3. **è¯æ˜æ­¥éª¤**ï¼š
   
   a) æ ¹æ®é€‰æ‹©å…¬ç†ï¼Œå­˜åœ¨é€‰æ‹©å‡½æ•°
   
   b) ä½¿ç”¨è¶…é™å½’çº³æ„é€ æå¤§é“¾
   
   c) æ¯ä¸ªæ­¥éª¤éƒ½é€‰æ‹©ä¸‹ä¸€ä¸ªå…ƒç´ 
   
   d) å½“æ— æ³•ç»§ç»­æ—¶ï¼Œå¾—åˆ°æå¤§é“¾

4. **ç»“è®º**ï¼š$\forall P(\text{PartiallyOrdered}(P) \rightarrow \exists C(\text{Chain}(C) \land \text{Maximal}(C)))$

## ğŸ”§ **è¯æ˜ç³»ç»Ÿ**

### é›†åˆè®ºè¯æ˜è§„åˆ™

**è§„åˆ™ 1.1** (å¤–å»¶æ€§è§„åˆ™)
å¦‚æœä¸¤ä¸ªé›†åˆåŒ…å«ç›¸åŒå…ƒç´ ï¼Œåˆ™å®ƒä»¬ç›¸ç­‰ã€‚

$$\frac{\forall x(x \in A \leftrightarrow x \in B)}{A = B} \quad \text{(å¤–å»¶æ€§)}$$

**è§„åˆ™ 1.2** (å­é›†è§„åˆ™)
å¦‚æœ $A$ çš„æ¯ä¸ªå…ƒç´ éƒ½å±äº $B$ï¼Œåˆ™ $A \subseteq B$ã€‚

$$\frac{\forall x(x \in A \rightarrow x \in B)}{A \subseteq B} \quad \text{(å­é›†)}$$

**è§„åˆ™ 1.3** (å¹‚é›†è§„åˆ™)
å¦‚æœ $A \subseteq B$ï¼Œåˆ™ $A \in P(B)$ã€‚

$$\frac{A \subseteq B}{A \in P(B)} \quad \text{(å¹‚é›†)}$$

### è¯æ˜ç¤ºä¾‹

**ç¤ºä¾‹ 1.1**ï¼šè¯æ˜ $A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$

**è¯æ˜**ï¼š

1. **ç›®æ ‡**ï¼šè¯æ˜åˆ†é…å¾‹
2. **è¯æ˜æ­¥éª¤**ï¼š
   
   a) è®¾ $x$ æ˜¯ä»»æ„å…ƒç´ 
   
   b) $x \in A \cap (B \cup C)$
   
   c) $\leftrightarrow x \in A \land x \in (B \cup C)$
   
   d) $\leftrightarrow x \in A \land (x \in B \lor x \in C)$
   
   e) $\leftrightarrow (x \in A \land x \in B) \lor (x \in A \land x \in C)$
   
   f) $\leftrightarrow x \in (A \cap B) \lor x \in (A \cap C)$
   
   g) $\leftrightarrow x \in (A \cap B) \cup (A \cap C)$

3. **ç»“è®º**ï¼š$A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$

## ğŸ’» **åº”ç”¨ç¤ºä¾‹**

### æ•°å­¦ä¸­çš„åº”ç”¨

```rust
// è‡ªç„¶æ•°é›†åˆ
struct NaturalNumbers {
    elements: Vec<usize>,
}

impl Set<usize> for NaturalNumbers {
    fn contains(&self, element: &usize) -> bool {
        self.elements.contains(element)
    }
    
    fn is_subset(&self, other: &Set<usize>) -> bool {
        self.elements.iter().all(|x| other.contains(x))
    }
    
    fn cardinality(&self) -> Cardinality {
        Cardinality::CountablyInfinite
    }
}

// å®æ•°é›†åˆ
struct RealNumbers {
    // å®æ•°çš„è¡¨ç¤º
}

impl Set<f64> for RealNumbers {
    fn contains(&self, element: &f64) -> bool {
        // å®æ•°åŒ…å«æ‰€æœ‰æœ‰ç†æ•°å’Œæ— ç†æ•°
        true
    }
    
    fn cardinality(&self) -> Cardinality {
        Cardinality::UncountablyInfinite
    }
}
```

### è®¡ç®—æœºç§‘å­¦ä¸­çš„åº”ç”¨

```rust
// é›†åˆæ•°æ®ç»“æ„
struct HashSet<T: Hash + Eq> {
    data: std::collections::HashSet<T>,
}

impl<T: Hash + Eq> Set<T> for HashSet<T> {
    fn contains(&self, element: &T) -> bool {
        self.data.contains(element)
    }
    
    fn is_subset(&self, other: &Set<T>) -> bool {
        self.data.iter().all(|x| other.contains(x))
    }
    
    fn cardinality(&self) -> Cardinality {
        Cardinality::Finite(self.data.len())
    }
}

impl<T: Hash + Eq> SetOperations<T> for HashSet<T> {
    fn union(&self, other: &Set<T>) -> Set<T> {
        let mut result = self.data.clone();
        // å®ç°å¹¶é›†è¿ç®—
        HashSet { data: result }
    }
    
    fn intersection(&self, other: &Set<T>) -> Set<T> {
        let result: std::collections::HashSet<_> = 
            self.data.intersection(&other.data).cloned().collect();
        HashSet { data: result }
    }
}
```

## ğŸ”„ **ä¸å…¶ä»–ç†è®ºçš„å…³è”**

### ä¸é€»è¾‘å­¦çš„å…³è”

- **é›†åˆä¸è°“è¯**ï¼šé›†åˆå¯ä»¥è¡¨ç¤ºä¸ºè°“è¯çš„æ‰©å±•
- **é›†åˆä¸é‡è¯**ï¼šå­˜åœ¨é‡è¯å’Œå…¨ç§°é‡è¯ä¸é›†åˆè¿ç®—å¯¹åº”
- **é›†åˆä¸æ¨ç†**ï¼šé›†åˆè®ºä¸ºé€»è¾‘æ¨ç†æä¾›è¯­ä¹‰åŸºç¡€

### ä¸æ•°å­¦çš„å…³è”

- **é›†åˆä¸å‡½æ•°**ï¼šå‡½æ•°æ˜¯ç‰¹æ®Šçš„äºŒå…ƒå…³ç³»
- **é›†åˆä¸å…³ç³»**ï¼šå…³ç³»æ˜¯é›†åˆçš„ç¬›å¡å°”ç§¯çš„å­é›†
- **é›†åˆä¸ä»£æ•°**ï¼šä»£æ•°ç»“æ„åŸºäºé›†åˆå®šä¹‰

### ä¸å½¢å¼ç§‘å­¦çš„å…³è”

- **é›†åˆä¸ç±»å‹**ï¼šç±»å‹å¯ä»¥è§†ä¸ºé›†åˆ
- **é›†åˆä¸è¯­è¨€**ï¼šå½¢å¼è¯­è¨€çš„å­—æ¯è¡¨æ˜¯é›†åˆ
- **é›†åˆä¸ç³»ç»Ÿ**ï¼šç³»ç»ŸçŠ¶æ€ç©ºé—´æ˜¯é›†åˆ

## ğŸš€ **å¿«é€Ÿå¯¼èˆª**

### æ ¸å¿ƒæ¦‚å¿µ
- [é›†åˆåŸºç¡€](01_Naive_Set_Theory/01_Set_Basics.md)
- [é›†åˆè¿ç®—](01_Naive_Set_Theory/02_Set_Operations.md)
- [ZFCå…¬ç†](02_Axiomatic_Set_Theory/01_ZFC_Axioms.md)

### åº”ç”¨é¢†åŸŸ
- [å…³ç³»ç†è®º](03_Set_Theory_Applications/01_Relations.md)
- [å‡½æ•°ç†è®º](03_Set_Theory_Applications/02_Functions.md)
- [ç­‰ä»·å…³ç³»](03_Set_Theory_Applications/03_Equivalence.md)

---

**æœ€åæ›´æ–°**: 2024-12-20  
**ç‰ˆæœ¬**: v1.0.0  
**ç»´æŠ¤è€…**: é›†åˆè®ºç†è®ºå›¢é˜Ÿ
