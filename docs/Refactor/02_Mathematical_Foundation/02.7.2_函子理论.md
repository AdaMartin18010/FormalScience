# 02.7.2 å‡½å­ç†è®º

## ğŸ“‹ æ¦‚è¿°

å‡½å­æ˜¯èŒƒç•´è®ºä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå®ƒæè¿°äº†èŒƒç•´ä¹‹é—´çš„æ˜ å°„å…³ç³»ã€‚å‡½å­ä¸ä»…ä¿æŒäº†èŒƒç•´çš„ç»“æ„ï¼Œè¿˜ä¸ºä¸åŒæ•°å­¦é¢†åŸŸä¹‹é—´å»ºç«‹äº†æ¡¥æ¢ã€‚æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»å‡½å­çš„å®šä¹‰ã€æ€§è´¨å’Œåº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. ç†è§£å‡½å­çš„åŸºæœ¬æ¦‚å¿µå’Œæ€§è´¨
2. æŒæ¡åå˜å’Œåå˜å‡½å­çš„åŒºåˆ«
3. å­¦ä¹ å‡½å­çš„é‡è¦ä¾‹å­å’Œåº”ç”¨
4. ä¸ºè‡ªç„¶å˜æ¢å’Œæé™ç†è®ºå¥ å®šåŸºç¡€

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å‡½å­çš„å®šä¹‰

**å®šä¹‰ 1.1.1** (åå˜å‡½å­)
è®¾ $\mathcal{C}$ å’Œ $\mathcal{D}$ æ˜¯ä¸¤ä¸ªèŒƒç•´ã€‚ä¸€ä¸ªåå˜å‡½å­ $F: \mathcal{C} \to \mathcal{D}$ ç”±ä»¥ä¸‹æ•°æ®ç»„æˆï¼š

1. **å¯¹è±¡æ˜ å°„**ï¼š$F: \text{Ob}(\mathcal{C}) \to \text{Ob}(\mathcal{D})$
2. **æ€å°„æ˜ å°„**ï¼š$F: \text{Mor}(\mathcal{C}) \to \text{Mor}(\mathcal{D})$

æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š

**å‡½å­å…¬ç† 1.1.1** (æ’ç­‰ä¿æŒ)
å¯¹äº $\mathcal{C}$ ä¸­çš„ä»»æ„å¯¹è±¡ $A$ï¼Œæœ‰ï¼š
$$F(1_A) = 1_{F(A)}$$

**å‡½å­å…¬ç† 1.1.2** (å¤åˆä¿æŒ)
å¯¹äº $\mathcal{C}$ ä¸­çš„ä»»æ„æ€å°„ $f: A \to B$ å’Œ $g: B \to C$ï¼Œæœ‰ï¼š
$$F(g \circ f) = F(g) \circ F(f)$$

### 1.2 åå˜å‡½å­

**å®šä¹‰ 1.2.1** (åå˜å‡½å­)
åå˜å‡½å­ $F: \mathcal{C} \to \mathcal{D}$ ä¸åå˜å‡½å­çš„åŒºåˆ«åœ¨äºå¤åˆä¿æŒå…¬ç†ï¼š

**å‡½å­å…¬ç† 1.2.1** (åå˜å¤åˆä¿æŒ)
å¯¹äº $\mathcal{C}$ ä¸­çš„ä»»æ„æ€å°„ $f: A \to B$ å’Œ $g: B \to C$ï¼Œæœ‰ï¼š
$$F(g \circ f) = F(f) \circ F(g)$$

### 1.3 åŸºæœ¬ä¾‹å­

**ä¾‹å­ 1.3.1** (æ’ç­‰å‡½å­)
æ’ç­‰å‡½å­ $1_{\mathcal{C}}: \mathcal{C} \to \mathcal{C}$ å®šä¹‰ä¸ºï¼š
- $1_{\mathcal{C}}(A) = A$ å¯¹æ‰€æœ‰å¯¹è±¡ $A$
- $1_{\mathcal{C}}(f) = f$ å¯¹æ‰€æœ‰æ€å°„ $f$

**ä¾‹å­ 1.3.2** (é—å¿˜å‡½å­)
é—å¿˜å‡½å­ $U: \mathbf{Grp} \to \mathbf{Set}$ å®šä¹‰ä¸ºï¼š
- $U(G) = G$ (å¿˜è®°ç¾¤ç»“æ„ï¼Œåªä¿ç•™é›†åˆ)
- $U(f) = f$ (å¿˜è®°ç¾¤åŒæ€ï¼Œåªä¿ç•™å‡½æ•°)

**ä¾‹å­ 1.3.3** (è‡ªç”±å‡½å­)
è‡ªç”±å‡½å­ $F: \mathbf{Set} \to \mathbf{Grp}$ å®šä¹‰ä¸ºï¼š
- $F(X) = F(X)$ (é›†åˆ $X$ çš„è‡ªç”±ç¾¤)
- $F(f) = \bar{f}$ (å‡½æ•° $f$ çš„ç¾¤åŒæ€å»¶æ‹“)

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å‡½å­çš„ç±»å‹ç±»å®šä¹‰

```haskell
-- åå˜å‡½å­ç±»å‹ç±»
class Functor f where
    fmap :: (a -> b) -> f a -> f b

-- å‡½å­å…¬ç†éªŒè¯
class Functor f => FunctorLaws f where
    -- æ’ç­‰ä¿æŒ
    identity :: f a -> Bool
    identity fa = fmap id fa == fa
    
    -- å¤åˆä¿æŒ
    composition :: (b -> c) -> (a -> b) -> f a -> Bool
    composition g f fa = fmap (g . f) fa == fmap g (fmap f fa)

-- åå˜å‡½å­ç±»å‹ç±»
class Contravariant f where
    contramap :: (b -> a) -> f a -> f b

-- åŒå‡½å­ç±»å‹ç±»
class Bifunctor f where
    bimap :: (a -> c) -> (b -> d) -> f a b -> f c d
```

### 2.2 å‡½å­çš„æ€§è´¨

**å®šä¹‰ 2.2.1** (å¿ å®å‡½å­)
å‡½å­ $F: \mathcal{C} \to \mathcal{D}$ ç§°ä¸ºå¿ å®çš„ï¼Œå¦‚æœå¯¹äºä»»æ„å¯¹è±¡ $A, B \in \mathcal{C}$ï¼Œæ˜ å°„ï¼š
$$F: \text{Hom}_{\mathcal{C}}(A, B) \to \text{Hom}_{\mathcal{D}}(F(A), F(B))$$
æ˜¯å•å°„ã€‚

**å®šä¹‰ 2.2.2** (æ»¡å‡½å­)
å‡½å­ $F: \mathcal{C} \to \mathcal{D}$ ç§°ä¸ºæ»¡çš„ï¼Œå¦‚æœä¸Šè¿°æ˜ å°„æ˜¯æ»¡å°„ã€‚

**å®šä¹‰ 2.2.3** (å®Œå…¨å‡½å­)
å‡½å­ $F: \mathcal{C} \to \mathcal{D}$ ç§°ä¸ºå®Œå…¨çš„ï¼Œå¦‚æœå®ƒæ—¢æ˜¯å¿ å®çš„åˆæ˜¯æ»¡çš„ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬å®šç†

**å®šç† 3.1.1** (å‡½å­ä¿æŒåŒæ„)
å¦‚æœ $F: \mathcal{C} \to \mathcal{D}$ æ˜¯å‡½å­ï¼Œä¸” $f: A \to B$ æ˜¯ $\mathcal{C}$ ä¸­çš„åŒæ„ï¼Œåˆ™ $F(f): F(A) \to F(B)$ æ˜¯ $\mathcal{D}$ ä¸­çš„åŒæ„ã€‚

**è¯æ˜**ï¼š
è®¾ $g: B \to A$ æ˜¯ $f$ çš„é€†ã€‚åˆ™ï¼š
$$F(f) \circ F(g) = F(f \circ g) = F(1_B) = 1_{F(B)}$$
$$F(g) \circ F(f) = F(g \circ f) = F(1_A) = 1_{F(A)}$$

**å®šç† 3.1.2** (å‡½å­å¤åˆ)
å¦‚æœ $F: \mathcal{C} \to \mathcal{D}$ å’Œ $G: \mathcal{D} \to \mathcal{E}$ éƒ½æ˜¯å‡½å­ï¼Œåˆ™ $G \circ F: \mathcal{C} \to \mathcal{E}$ ä¹Ÿæ˜¯å‡½å­ã€‚

**è¯æ˜**ï¼š
å¯¹äºæ’ç­‰ä¿æŒï¼š
$$(G \circ F)(1_A) = G(F(1_A)) = G(1_{F(A)}) = 1_{G(F(A))} = 1_{(G \circ F)(A)}$$

å¯¹äºå¤åˆä¿æŒï¼š
$$(G \circ F)(g \circ f) = G(F(g \circ f)) = G(F(g) \circ F(f)) = G(F(g)) \circ G(F(f)) = (G \circ F)(g) \circ (G \circ F)(f)$$

### 3.2 é‡è¦æ€§è´¨

**å‘½é¢˜ 3.2.1** (å‡½å­ä¿æŒå•æ€å°„å’Œæ»¡æ€å°„)
å¦‚æœ $F: \mathcal{C} \to \mathcal{D}$ æ˜¯å¿ å®å‡½å­ï¼Œåˆ™ï¼š
1. å¦‚æœ $f$ æ˜¯å•æ€å°„ï¼Œåˆ™ $F(f)$ ä¹Ÿæ˜¯å•æ€å°„
2. å¦‚æœ $f$ æ˜¯æ»¡æ€å°„ï¼Œåˆ™ $F(f)$ ä¹Ÿæ˜¯æ»¡æ€å°„

**è¯æ˜**ï¼š
è®¾ $f: A \to B$ æ˜¯å•æ€å°„ï¼Œ$g, h: C \to A$ æ»¡è¶³ $F(f) \circ F(g) = F(f) \circ F(h)$ã€‚
ç”±äº $F$ æ˜¯å¿ å®çš„ï¼Œ$f \circ g = f \circ h$ï¼Œä»è€Œ $g = h$ã€‚

## 4. ä»£ç å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::HashMap;

/// å‡½å­çš„åŸºæœ¬å®šä¹‰
pub trait Functor<A, B> {
    type F;
    
    /// å‡½å­æ˜ å°„
    fn fmap<F>(self, f: F) -> Self::F
    where
        F: Fn(A) -> B;
}

/// åå˜å‡½å­
pub trait Contravariant<A, B> {
    type F;
    
    /// åå˜æ˜ å°„
    fn contramap<F>(self, f: F) -> Self::F
    where
        F: Fn(B) -> A;
}

/// åŒå‡½å­
pub trait Bifunctor<A, B, C, D> {
    type F;
    
    /// åŒæ˜ å°„
    fn bimap<F, G>(self, f: F, g: G) -> Self::F
    where
        F: Fn(A) -> C,
        G: Fn(B) -> D;
}

/// Option å‡½å­å®ç°
impl<A, B> Functor<A, B> for Option<A> {
    type F = Option<B>;
    
    fn fmap<F>(self, f: F) -> Self::F
    where
        F: Fn(A) -> B,
    {
        match self {
            Some(a) => Some(f(a)),
            None => None,
        }
    }
}

/// Result å‡½å­å®ç°
impl<A, B, E> Functor<A, B> for Result<A, E> {
    type F = Result<B, E>;
    
    fn fmap<F>(self, f: F) -> Self::F
    where
        F: Fn(A) -> B,
    {
        match self {
            Ok(a) => Ok(f(a)),
            Err(e) => Err(e),
        }
    }
}

/// Vec å‡½å­å®ç°
impl<A, B> Functor<A, B> for Vec<A> {
    type F = Vec<B>;
    
    fn fmap<F>(self, f: F) -> Self::F
    where
        F: Fn(A) -> B,
    {
        self.into_iter().map(f).collect()
    }
}

/// å‡½å­éªŒè¯å™¨
pub struct FunctorValidator<F> {
    _phantom: std::marker::PhantomData<F>,
}

impl<F, A, B> FunctorValidator<F>
where
    F: Functor<A, B>,
{
    /// éªŒè¯æ’ç­‰ä¿æŒ
    pub fn verify_identity(fa: F) -> bool
    where
        F: Functor<A, A>,
    {
        // è¿™é‡Œéœ€è¦å…·ä½“çš„å®ç°æ¥éªŒè¯æ’ç­‰ä¿æŒ
        true
    }
    
    /// éªŒè¯å¤åˆä¿æŒ
    pub fn verify_composition<C>(
        fa: F,
        f: impl Fn(A) -> B,
        g: impl Fn(B) -> C,
    ) -> bool
    where
        F: Functor<A, C>,
    {
        // éªŒè¯å¤åˆä¿æŒ
        true
    }
}

/// èŒƒç•´ä¹‹é—´çš„å‡½å­
pub trait CategoryFunctor<C1, C2> {
    type Object;
    type Morphism;
    
    /// å¯¹è±¡æ˜ å°„
    fn map_object(&self, obj: &C1::Object) -> C2::Object;
    
    /// æ€å°„æ˜ å°„
    fn map_morphism(&self, morphism: &C1::Morphism) -> C2::Morphism;
}

/// æ’ç­‰å‡½å­
pub struct IdentityFunctor<C> {
    _phantom: std::marker::PhantomData<C>,
}

impl<C> CategoryFunctor<C, C> for IdentityFunctor<C>
where
    C: Category,
{
    type Object = C::Object;
    type Morphism = C::Morphism;
    
    fn map_object(&self, obj: &C::Object) -> C::Object {
        obj.clone()
    }
    
    fn map_morphism(&self, morphism: &C::Morphism) -> C::Morphism {
        morphism.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_option_functor() {
        let opt = Some(5);
        let result = opt.fmap(|x| x * 2);
        assert_eq!(result, Some(10));
    }
    
    #[test]
    fn test_result_functor() {
        let res: Result<i32, &str> = Ok(5);
        let result = res.fmap(|x| x * 2);
        assert_eq!(result, Ok(10));
    }
    
    #[test]
    fn test_vec_functor() {
        let vec = vec![1, 2, 3];
        let result = vec.fmap(|x| x * 2);
        assert_eq!(result, vec![2, 4, 6]);
    }
}
```

### 4.2 Haskell å®ç°

```haskell
-- å‡½å­ç±»å‹ç±»
class Functor f where
    fmap :: (a -> b) -> f a -> f b

-- åå˜å‡½å­ç±»å‹ç±»
class Contravariant f where
    contramap :: (b -> a) -> f a -> f b

-- åŒå‡½å­ç±»å‹ç±»
class Bifunctor f where
    bimap :: (a -> c) -> (b -> d) -> f a b -> f c d

-- Option å‡½å­å®ä¾‹
instance Functor Maybe where
    fmap _ Nothing = Nothing
    fmap f (Just a) = Just (f a)

-- List å‡½å­å®ä¾‹
instance Functor [] where
    fmap = map

-- Either åŒå‡½å­å®ä¾‹
instance Bifunctor Either where
    bimap f _ (Left a) = Left (f a)
    bimap _ g (Right b) = Right (g b)

-- å‡½å­å…¬ç†éªŒè¯
class Functor f => FunctorLaws f where
    -- æ’ç­‰ä¿æŒ
    identity :: f a -> Bool
    identity fa = fmap id fa == fa
    
    -- å¤åˆä¿æŒ
    composition :: (b -> c) -> (a -> b) -> f a -> Bool
    composition g f fa = fmap (g . f) fa == fmap g (fmap f fa)

-- å‡½å­å¤åˆ
newtype Compose f g a = Compose { getCompose :: f (g a) }

instance (Functor f, Functor g) => Functor (Compose f g) where
    fmap f (Compose fga) = Compose (fmap (fmap f) fga)

-- æ’ç­‰å‡½å­
newtype Identity a = Identity { runIdentity :: a }

instance Functor Identity where
    fmap f (Identity a) = Identity (f a)

-- é—å¿˜å‡½å­ï¼ˆä»ç¾¤åˆ°é›†åˆï¼‰
newtype ForgetGroup a = ForgetGroup { unForgetGroup :: a }

instance Functor ForgetGroup where
    fmap f (ForgetGroup a) = ForgetGroup (f a)
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„åº”ç”¨

å‡½å­åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­æ— å¤„ä¸åœ¨ï¼š

```rust
/// å‡½å­åœ¨é”™è¯¯å¤„ç†ä¸­çš„åº”ç”¨
pub trait Monad<A, B>: Functor<A, B> {
    type M;
    
    /// ç»‘å®šæ“ä½œ
    fn bind<F>(self, f: F) -> Self::M
    where
        F: Fn(A) -> Self::M;
    
    /// è¿”å›æ“ä½œ
    fn return_(a: A) -> Self::M;
}

impl<A, B> Monad<A, B> for Option<A> {
    type M = Option<B>;
    
    fn bind<F>(self, f: F) -> Self::M
    where
        F: Fn(A) -> Self::M,
    {
        match self {
            Some(a) => f(a),
            None => None,
        }
    }
    
    fn return_(a: A) -> Self::M {
        Some(a)
    }
}

/// å‡½å­åœ¨è§£æå™¨ä¸­çš„åº”ç”¨
pub struct Parser<A> {
    parse: Box<dyn Fn(&str) -> Result<(A, &str), String>>,
}

impl<A, B> Functor<A, B> for Parser<A> {
    type F = Parser<B>;
    
    fn fmap<F>(self, f: F) -> Self::F
    where
        F: Fn(A) -> B,
    {
        Parser {
            parse: Box::new(move |input| {
                let (result, remaining) = (self.parse)(input)?;
                Ok((f(result), remaining))
            }),
        }
    }
}
```

### 5.2 æ•°å­¦ç»“æ„ä¸­çš„åº”ç”¨

```rust
/// ä»£æ•°ç»“æ„çš„å‡½å­
pub trait AlgebraicFunctor<A, B> {
    type Structure;
    
    /// ä¿æŒä»£æ•°ç»“æ„çš„æ˜ å°„
    fn algebraic_map<F>(self, f: F) -> Self::Structure
    where
        F: Fn(A) -> B;
}

/// ç¾¤åŒæ€çš„å‡½å­
pub struct GroupHomomorphism<G, H> {
    map: Box<dyn Fn(G) -> H>,
}

impl<G, H> AlgebraicFunctor<G, H> for GroupHomomorphism<G, H> {
    type Structure = GroupHomomorphism<G, H>;
    
    fn algebraic_map<F>(self, f: F) -> Self::Structure
    where
        F: Fn(G) -> H,
    {
        GroupHomomorphism {
            map: Box::new(move |g| f((self.map)(g))),
        }
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸èŒƒç•´è®ºçš„å…³ç³»

å‡½å­æ˜¯èŒƒç•´è®ºçš„æ ¸å¿ƒæ¦‚å¿µï¼š

- **èŒƒç•´** â†’ **å¯¹è±¡**
- **å‡½å­** â†’ **æ€å°„**
- **å‡½å­å¤åˆ** â†’ **æ€å°„å¤åˆ**
- **æ’ç­‰å‡½å­** â†’ **æ’ç­‰æ€å°„**

### 6.2 ä¸ä»£æ•°ç»“æ„çš„å…³ç³»

å‡½å­ä¸ºä»£æ•°ç»“æ„æä¾›äº†ç»Ÿä¸€çš„å¤„ç†æ–¹å¼ï¼š

- **ç¾¤** â†’ **ç¾¤èŒƒç•´ä¸­çš„å¯¹è±¡**
- **ç¾¤åŒæ€** â†’ **ç¾¤èŒƒç•´ä¸­çš„æ€å°„**
- **ç¯** â†’ **ç¯èŒƒç•´ä¸­çš„å¯¹è±¡**
- **ç¯åŒæ€** â†’ **ç¯èŒƒç•´ä¸­çš„æ€å°„**

### 6.3 ä¸è®¡ç®—æœºç§‘å­¦çš„å…³ç³»

å‡½å­åœ¨è®¡ç®—æœºç§‘å­¦ä¸­çš„åº”ç”¨ï¼š

- **ç±»å‹ç³»ç»Ÿ** â†’ **ç±»å‹èŒƒç•´**
- **å‡½æ•°** â†’ **æ€å°„**
- **é«˜é˜¶å‡½æ•°** â†’ **å‡½å­**
- **å•å­** â†’ **ç‰¹æ®Šå‡½å­**

## 7. å‚è€ƒæ–‡çŒ®

1. Mac Lane, S. (1998). *Categories for the Working Mathematician*. Springer.
2. Awodey, S. (2010). *Category Theory*. Oxford University Press.
3. Barr, M., & Wells, C. (1990). *Category Theory for Computing Science*. Prentice Hall.
4. Pierce, B. C. (1991). *Basic Category Theory for Computer Scientists*. MIT Press.
5. Spivak, D. I. (2014). *Category Theory for the Sciences*. MIT Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [02.7.1 èŒƒç•´æ¦‚å¿µ](../02_Mathematical_Foundation/02.7.1_èŒƒç•´æ¦‚å¿µ.md)
- [02.7.3 è‡ªç„¶å˜æ¢](../02_Mathematical_Foundation/02.7.3_è‡ªç„¶å˜æ¢.md)
- [02.7.4 æé™ç†è®º](../02_Mathematical_Foundation/02.7.4_æé™ç†è®º.md)
- [04.1.1 ç®€å•ç±»å‹ç†è®º](../04_Type_Theory/04.1.1_ç®€å•ç±»å‹ç†è®º.md)
- [08.1.1 è¯­è¨€è®¾è®¡åŸç†](../08_Programming_Language_Theory/08.1.1_è¯­è¨€è®¾è®¡åŸç†.md) 