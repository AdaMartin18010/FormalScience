# 02.6.4 æ¨¡è®ºåŸºç¡€

## ğŸ“‹ æ¦‚è¿°

æ¨¡è®ºæ˜¯æŠ½è±¡ä»£æ•°çš„é‡è¦åˆ†æ”¯ï¼Œç ”ç©¶ç¯ä¸Šçš„æ¨¡ç»“æ„ã€‚æ¨¡æ˜¯å‘é‡ç©ºé—´çš„æ¨å¹¿ï¼Œåœ¨è¡¨ç¤ºè®ºã€åŒè°ƒä»£æ•°ã€ä»£æ•°å‡ ä½•ç­‰é¢†åŸŸæœ‰å¹¿æ³›åº”ç”¨ã€‚æ¨¡è®ºä¸ºç ”ç©¶ç¯çš„ç»“æ„å’Œæ€§è´¨æä¾›äº†å¼ºå¤§çš„å·¥å…·ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹æ¨¡çš„ä¸¥æ ¼å½¢å¼åŒ–å®šä¹‰
2. ç ”ç©¶æ¨¡çš„åŸºæœ¬æ€§è´¨å’Œç»“æ„
3. æ¢è®¨æ¨¡åŒæ€å’Œå­æ¨¡ç†è®º
4. åˆ†æè‡ªç”±æ¨¡å’ŒæŠ•å°„æ¨¡
5. æä¾›å®Œæ•´çš„ä»£ç å®ç°

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [æ¨¡åŒæ€](#4-æ¨¡åŒæ€)
5. [ä»£ç å®ç°](#5-ä»£ç å®ç°)
6. [åº”ç”¨ç¤ºä¾‹](#6-åº”ç”¨ç¤ºä¾‹)
7. [ç›¸å…³ç†è®º](#7-ç›¸å…³ç†è®º)
8. [å‚è€ƒæ–‡çŒ®](#8-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ¨¡çš„ç›´è§‚ç†è§£

æ¨¡æ˜¯ç¯ä¸Šçš„ä»£æ•°ç»“æ„ï¼Œå…·æœ‰åŠ æ³•å’Œæ ‡é‡ä¹˜æ³•è¿ç®—ã€‚æ¨¡å¯ä»¥çœ‹ä½œæ˜¯å‘é‡ç©ºé—´çš„æ¨å¹¿ï¼Œå…¶ä¸­æ ‡é‡æ¥è‡ªç¯è€Œä¸æ˜¯åŸŸã€‚

**ç»å…¸ä¾‹å­**ï¼š
- é˜¿è´å°”ç¾¤ä½œä¸º $\mathbb{Z}$-æ¨¡
- å‘é‡ç©ºé—´ä½œä¸ºåŸŸä¸Šçš„æ¨¡
- ç†æƒ³ä½œä¸ºç¯ä¸Šçš„æ¨¡

### 1.2 æ¨¡çš„åŸºæœ¬æ€§è´¨

1. **åŠ æ³•ç¾¤æ€§è´¨**ï¼šæ¨¡çš„åŠ æ³•æ„æˆé˜¿è´å°”ç¾¤
2. **æ ‡é‡ä¹˜æ³•æ€§è´¨**ï¼šæ»¡è¶³åˆ†é…å¾‹å’Œç»“åˆå¾‹
3. **å•ä½å…ƒæ€§è´¨**ï¼šç¯çš„å•ä½å…ƒæ˜¯æ ‡é‡ä¹˜æ³•çš„å•ä½å…ƒ

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å·¦æ¨¡çš„å®šä¹‰

**å®šä¹‰ 2.1.1** (å·¦R-æ¨¡)
è®¾ $R$ æ˜¯ç¯ï¼Œå·¦R-æ¨¡æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(M, +, \cdot)$ï¼Œå…¶ä¸­ $M$ æ˜¯éç©ºé›†åˆï¼Œ$+$ æ˜¯ $M$ ä¸Šçš„äºŒå…ƒè¿ç®—ï¼Œ$\cdot$ æ˜¯ $R \times M \to M$ çš„æ˜ å°„ï¼Œæ»¡è¶³ä»¥ä¸‹å…¬ç†ï¼š

**åŠ æ³•å…¬ç†**ï¼š
1. **ç»“åˆå¾‹**ï¼š$(a + b) + c = a + (b + c)$
2. **äº¤æ¢å¾‹**ï¼š$a + b = b + a$
3. **é›¶å…ƒç´ **ï¼šå­˜åœ¨ $0 \in M$ ä½¿å¾— $a + 0 = 0 + a = a$
4. **é€†å…ƒç´ **ï¼šå¯¹æ¯ä¸ª $a \in M$ï¼Œå­˜åœ¨ $-a \in M$ ä½¿å¾— $a + (-a) = (-a) + a = 0$

**æ ‡é‡ä¹˜æ³•å…¬ç†**ï¼š
5. **å·¦åˆ†é…å¾‹**ï¼š$r \cdot (a + b) = r \cdot a + r \cdot b$
6. **å³åˆ†é…å¾‹**ï¼š$(r + s) \cdot a = r \cdot a + s \cdot a$
7. **ç»“åˆå¾‹**ï¼š$(r \cdot s) \cdot a = r \cdot (s \cdot a)$
8. **å•ä½å…ƒ**ï¼š$1_R \cdot a = a$

### 2.2 å³æ¨¡çš„å®šä¹‰

**å®šä¹‰ 2.1.2** (å³R-æ¨¡)
å³R-æ¨¡çš„å®šä¹‰ç±»ä¼¼ï¼Œä½†æ ‡é‡ä¹˜æ³•æ˜¯ $M \times R \to M$ çš„æ˜ å°„ï¼Œæ»¡è¶³ç›¸åº”çš„å…¬ç†ã€‚

### 2.3 åŒæ¨¡çš„å®šä¹‰

**å®šä¹‰ 2.1.3** (åŒæ¨¡)
è®¾ $R$ å’Œ $S$ æ˜¯ç¯ï¼Œ$(R,S)$-åŒæ¨¡æ˜¯åŒæ—¶å…·æœ‰å·¦R-æ¨¡å’Œå³S-æ¨¡ç»“æ„çš„é›†åˆï¼Œä¸”æ»¡è¶³ï¼š
$$(r \cdot a) \cdot s = r \cdot (a \cdot s)$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 æ¨¡çš„åŸºæœ¬æ€§è´¨

**å®šç† 3.1.1** (æ¨¡çš„åŸºæœ¬æ€§è´¨)
è®¾ $M$ æ˜¯å·¦R-æ¨¡ï¼Œåˆ™ï¼š

1. **é›¶å…ƒç´ å”¯ä¸€æ€§**ï¼šé›¶å…ƒç´  $0_M$ æ˜¯å”¯ä¸€çš„
2. **é€†å…ƒç´ å”¯ä¸€æ€§**ï¼šæ¯ä¸ªå…ƒç´ çš„åŠ æ³•é€†å…ƒç´ æ˜¯å”¯ä¸€çš„
3. **é›¶ä¹˜æ€§è´¨**ï¼š$0_R \cdot a = 0_M$ å’Œ $r \cdot 0_M = 0_M$
4. **è´Ÿå·æ€§è´¨**ï¼š$(-r) \cdot a = r \cdot (-a) = -(r \cdot a)$

**è¯æ˜**ï¼š
1. è®¾ $0'$ æ˜¯å¦ä¸€ä¸ªé›¶å…ƒç´ ï¼Œåˆ™ $0_M = 0_M + 0' = 0'$
2. è®¾ $a'$ æ˜¯ $a$ çš„å¦ä¸€ä¸ªé€†å…ƒç´ ï¼Œåˆ™ $a' = a' + 0_M = a' + (a + (-a)) = (a' + a) + (-a) = 0_M + (-a) = -a$
3. $0_R \cdot a = (0_R + 0_R) \cdot a = 0_R \cdot a + 0_R \cdot a$ï¼Œæ‰€ä»¥ $0_R \cdot a = 0_M$
4. $0_M = 0_R \cdot a = (r + (-r)) \cdot a = r \cdot a + (-r) \cdot a$ï¼Œæ‰€ä»¥ $(-r) \cdot a = -(r \cdot a)$

### 3.2 å­æ¨¡çš„å®šä¹‰å’Œæ€§è´¨

**å®šä¹‰ 3.2.1** (å­æ¨¡)
è®¾ $M$ æ˜¯å·¦R-æ¨¡ï¼Œ$N \subseteq M$ æ˜¯ $M$ çš„éç©ºå­é›†ã€‚å¦‚æœ $N$ åœ¨ $M$ çš„è¿ç®—ä¸‹ä¹Ÿæ„æˆå·¦R-æ¨¡ï¼Œåˆ™ç§° $N$ ä¸º $M$ çš„å­æ¨¡ã€‚

**å®šç† 3.2.1** (å­æ¨¡åˆ¤å®šå®šç†)
è®¾ $M$ æ˜¯å·¦R-æ¨¡ï¼Œ$N \subseteq M$ æ˜¯éç©ºå­é›†ï¼Œåˆ™ $N$ æ˜¯å­æ¨¡å½“ä¸”ä»…å½“ï¼š
1. $a, b \in N \Rightarrow a - b \in N$
2. $a \in N, r \in R \Rightarrow r \cdot a \in N$

**è¯æ˜**ï¼š
å¿…è¦æ€§æ˜¾ç„¶ã€‚å……åˆ†æ€§ï¼šç”±æ¡ä»¶1çŸ¥ $N$ æ˜¯åŠ æ³•å­ç¾¤ï¼Œç”±æ¡ä»¶2çŸ¥ $N$ å¯¹æ ‡é‡ä¹˜æ³•å°é—­ï¼Œå…¶ä»–å…¬ç†åœ¨ $N$ ä¸­è‡ªç„¶æˆç«‹ã€‚

### 3.3 å•†æ¨¡

**å®šä¹‰ 3.3.1** (å•†æ¨¡)
è®¾ $M$ æ˜¯å·¦R-æ¨¡ï¼Œ$N$ æ˜¯ $M$ çš„å­æ¨¡ï¼Œåˆ™å•†æ¨¡ $M/N$ å®šä¹‰ä¸ºï¼š
$$M/N = \{a + N \mid a \in M\}$$
å…¶ä¸­è¿ç®—å®šä¹‰ä¸ºï¼š
- $(a + N) + (b + N) = (a + b) + N$
- $r \cdot (a + N) = (r \cdot a) + N$

**å®šç† 3.3.1** (å•†æ¨¡çš„åŸºæœ¬æ€§è´¨)
è®¾ $M$ æ˜¯å·¦R-æ¨¡ï¼Œ$N$ æ˜¯å­æ¨¡ï¼Œåˆ™ï¼š
1. $M/N$ æ˜¯å·¦R-æ¨¡
2. è‡ªç„¶æ˜ å°„ $\pi: M \to M/N$ æ˜¯æ»¡åŒæ€
3. $\ker \pi = N$

## 4. æ¨¡åŒæ€

### 4.1 æ¨¡åŒæ€çš„å®šä¹‰

**å®šä¹‰ 4.1.1** (æ¨¡åŒæ€)
è®¾ $M$ å’Œ $N$ æ˜¯å·¦R-æ¨¡ï¼Œæ˜ å°„ $f: M \to N$ ç§°ä¸ºæ¨¡åŒæ€ï¼Œå¦‚æœï¼š
1. $f(a + b) = f(a) + f(b)$
2. $f(r \cdot a) = r \cdot f(a)$

### 4.2 æ¨¡åŒæ€çš„åŸºæœ¬æ€§è´¨

**å®šç† 4.2.1** (æ¨¡åŒæ€çš„åŸºæœ¬æ€§è´¨)
è®¾ $f: M \to N$ æ˜¯æ¨¡åŒæ€ï¼Œåˆ™ï¼š
1. $f(0_M) = 0_N$
2. $f(-a) = -f(a)$
3. $\ker f$ æ˜¯ $M$ çš„å­æ¨¡
4. $\text{im} f$ æ˜¯ $N$ çš„å­æ¨¡

### 4.3 åŒæ„å®šç†

**å®šç† 4.3.1** (ç¬¬ä¸€åŒæ„å®šç†)
è®¾ $f: M \to N$ æ˜¯æ¨¡åŒæ€ï¼Œåˆ™ï¼š
$$M/\ker f \cong \text{im} f$$

**å®šç† 4.3.2** (ç¬¬äºŒåŒæ„å®šç†)
è®¾ $M$ æ˜¯å·¦R-æ¨¡ï¼Œ$N$ å’Œ $K$ æ˜¯ $M$ çš„å­æ¨¡ï¼Œåˆ™ï¼š
$$(N + K)/K \cong N/(N \cap K)$$

## 5. ä»£ç å®ç°

### 5.1 Rust å®ç°

```rust
use std::ops::{Add, Mul, Neg, Sub};
use std::collections::HashMap;

/// ç¯ç‰¹å¾
pub trait Ring: Add<Output = Self> + Mul<Output = Self> + Neg<Output = Self> + 
                Sub<Output = Self> + Clone + Eq {
    fn zero() -> Self;
    fn one() -> Self;
    fn is_zero(&self) -> bool;
    fn is_one(&self) -> bool;
}

/// å·¦R-æ¨¡ç‰¹å¾
pub trait LeftModule<R: Ring>: Add<Output = Self> + Neg<Output = Self> + 
                               Sub<Output = Self> + Clone + Eq {
    fn zero() -> Self;
    fn is_zero(&self) -> bool;
    fn scalar_multiply(&self, scalar: &R) -> Self;
}

/// æ•´æ•°ç¯å®ç°
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct IntegerRing(pub i32);

impl Add for IntegerRing {
    type Output = Self;
    
    fn add(self, other: Self) -> Self {
        IntegerRing(self.0 + other.0)
    }
}

impl Mul for IntegerRing {
    type Output = Self;
    
    fn mul(self, other: Self) -> Self {
        IntegerRing(self.0 * other.0)
    }
}

impl Neg for IntegerRing {
    type Output = Self;
    
    fn neg(self) -> Self {
        IntegerRing(-self.0)
    }
}

impl Sub for IntegerRing {
    type Output = Self;
    
    fn sub(self, other: Self) -> Self {
        IntegerRing(self.0 - other.0)
    }
}

impl Ring for IntegerRing {
    fn zero() -> Self {
        IntegerRing(0)
    }
    
    fn one() -> Self {
        IntegerRing(1)
    }
    
    fn is_zero(&self) -> bool {
        self.0 == 0
    }
    
    fn is_one(&self) -> bool {
        self.0 == 1
    }
}

/// é˜¿è´å°”ç¾¤ä½œä¸ºZ-æ¨¡
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct AbelianGroup {
    pub elements: Vec<i32>,
}

impl AbelianGroup {
    pub fn new(elements: Vec<i32>) -> Self {
        Self { elements }
    }
    
    pub fn zero() -> Self {
        Self { elements: vec![0] }
    }
    
    pub fn add(&self, other: &Self) -> Self {
        let mut result = self.elements.clone();
        result.extend(other.elements.iter().cloned());
        Self { elements: result }
    }
    
    pub fn negate(&self) -> Self {
        Self {
            elements: self.elements.iter().map(|x| -x).collect()
        }
    }
    
    pub fn scalar_multiply(&self, scalar: &IntegerRing) -> Self {
        Self {
            elements: self.elements.iter().map(|x| x * scalar.0).collect()
        }
    }
}

impl Add for AbelianGroup {
    type Output = Self;
    
    fn add(self, other: Self) -> Self {
        self.add(&other)
    }
}

impl Neg for AbelianGroup {
    type Output = Self;
    
    fn neg(self) -> Self {
        self.negate()
    }
}

impl Sub for AbelianGroup {
    type Output = Self;
    
    fn sub(self, other: Self) -> Self {
        self.add(&other.negate())
    }
}

impl LeftModule<IntegerRing> for AbelianGroup {
    fn zero() -> Self {
        Self::zero()
    }
    
    fn is_zero(&self) -> bool {
        self.elements.iter().all(|x| *x == 0)
    }
    
    fn scalar_multiply(&self, scalar: &IntegerRing) -> Self {
        self.scalar_multiply(scalar)
    }
}

/// å‘é‡ç©ºé—´ä½œä¸ºåŸŸä¸Šçš„æ¨¡
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct VectorSpace {
    pub components: Vec<f64>,
}

impl VectorSpace {
    pub fn new(components: Vec<f64>) -> Self {
        Self { components }
    }
    
    pub fn zero(dimension: usize) -> Self {
        Self {
            components: vec![0.0; dimension]
        }
    }
    
    pub fn add(&self, other: &Self) -> Self {
        if self.components.len() != other.components.len() {
            panic!("å‘é‡ç»´åº¦ä¸åŒ¹é…");
        }
        Self {
            components: self.components.iter()
                .zip(other.components.iter())
                .map(|(a, b)| a + b)
                .collect()
        }
    }
    
    pub fn negate(&self) -> Self {
        Self {
            components: self.components.iter().map(|x| -x).collect()
        }
    }
    
    pub fn scalar_multiply(&self, scalar: f64) -> Self {
        Self {
            components: self.components.iter().map(|x| x * scalar).collect()
        }
    }
    
    pub fn dimension(&self) -> usize {
        self.components.len()
    }
}

impl Add for VectorSpace {
    type Output = Self;
    
    fn add(self, other: Self) -> Self {
        self.add(&other)
    }
}

impl Neg for VectorSpace {
    type Output = Self;
    
    fn neg(self) -> Self {
        self.negate()
    }
}

impl Sub for VectorSpace {
    type Output = Self;
    
    fn sub(self, other: Self) -> Self {
        self.add(&other.negate())
    }
}

// å°†f64è§†ä¸ºåŸŸ
impl Ring for f64 {
    fn zero() -> Self {
        0.0
    }
    
    fn one() -> Self {
        1.0
    }
    
    fn is_zero(&self) -> bool {
        *self == 0.0
    }
    
    fn is_one(&self) -> bool {
        *self == 1.0
    }
}

impl LeftModule<f64> for VectorSpace {
    fn zero() -> Self {
        Self::zero(0)
    }
    
    fn is_zero(&self) -> bool {
        self.components.iter().all(|x| *x == 0.0)
    }
    
    fn scalar_multiply(&self, scalar: &f64) -> Self {
        self.scalar_multiply(*scalar)
    }
}

/// å­æ¨¡
pub struct Submodule<M: LeftModule<R>, R: Ring> {
    pub module: M,
    pub elements: Vec<M>,
}

impl<M: LeftModule<R>, R: Ring> Submodule<M, R> {
    pub fn new(module: M) -> Self {
        Self {
            module,
            elements: Vec::new(),
        }
    }
    
    pub fn add_element(&mut self, element: M) {
        self.elements.push(element);
    }
    
    pub fn is_submodule(&self) -> bool {
        // æ£€æŸ¥æ˜¯å¦æ»¡è¶³å­æ¨¡æ¡ä»¶
        if self.elements.is_empty() {
            return true;
        }
        
        // æ£€æŸ¥åŠ æ³•å°é—­æ€§
        for i in 0..self.elements.len() {
            for j in i..self.elements.len() {
                let sum = self.elements[i].clone() + self.elements[j].clone();
                if !self.elements.contains(&sum) {
                    return false;
                }
            }
        }
        
        // æ£€æŸ¥æ ‡é‡ä¹˜æ³•å°é—­æ€§
        for element in &self.elements {
            let scalar = R::one();
            let product = element.scalar_multiply(&scalar);
            if !self.elements.contains(&product) {
                return false;
            }
        }
        
        true
    }
}

/// æ¨¡åŒæ€
pub trait ModuleHomomorphism<M: LeftModule<R>, N: LeftModule<R>, R: Ring> {
    fn apply(&self, element: &M) -> N;
    fn kernel(&self) -> Vec<M>;
    fn image(&self) -> Vec<N>;
}

/// çº¿æ€§å˜æ¢ä½œä¸ºæ¨¡åŒæ€
pub struct LinearTransformation {
    pub matrix: Vec<Vec<f64>>,
}

impl LinearTransformation {
    pub fn new(matrix: Vec<Vec<f64>>) -> Self {
        Self { matrix }
    }
    
    pub fn apply(&self, vector: &VectorSpace) -> VectorSpace {
        if self.matrix.is_empty() || vector.dimension() != self.matrix[0].len() {
            panic!("çŸ©é˜µç»´åº¦ä¸åŒ¹é…");
        }
        
        let mut result = vec![0.0; self.matrix.len()];
        for i in 0..self.matrix.len() {
            for j in 0..self.matrix[i].len() {
                result[i] += self.matrix[i][j] * vector.components[j];
            }
        }
        
        VectorSpace::new(result)
    }
}

impl ModuleHomomorphism<VectorSpace, VectorSpace, f64> for LinearTransformation {
    fn apply(&self, element: &VectorSpace) -> VectorSpace {
        self.apply(element)
    }
    
    fn kernel(&self) -> Vec<VectorSpace> {
        // ç®€åŒ–å®ç°ï¼šè¿”å›é›¶å‘é‡
        vec![VectorSpace::zero(self.matrix[0].len())]
    }
    
    fn image(&self) -> Vec<VectorSpace> {
        // ç®€åŒ–å®ç°ï¼šè¿”å›æ‰€æœ‰å¯èƒ½çš„è¾“å‡º
        vec![VectorSpace::zero(self.matrix.len())]
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_abelian_group_module() {
        let group1 = AbelianGroup::new(vec![1, 2, 3]);
        let group2 = AbelianGroup::new(vec![4, 5, 6]);
        let scalar = IntegerRing(2);
        
        let sum = group1.clone() + group2.clone();
        let product = group1.scalar_multiply(&scalar);
        
        assert_eq!(sum.elements.len(), 6);
        assert_eq!(product.elements, vec![2, 4, 6]);
    }
    
    #[test]
    fn test_vector_space_module() {
        let v1 = VectorSpace::new(vec![1.0, 2.0, 3.0]);
        let v2 = VectorSpace::new(vec![4.0, 5.0, 6.0]);
        let scalar = 2.0;
        
        let sum = v1.clone() + v2.clone();
        let product = v1.scalar_multiply(scalar);
        
        assert_eq!(sum.components, vec![5.0, 7.0, 9.0]);
        assert_eq!(product.components, vec![2.0, 4.0, 6.0]);
    }
    
    #[test]
    fn test_linear_transformation() {
        let matrix = vec![
            vec![1.0, 0.0],
            vec![0.0, 1.0]
        ];
        let transformation = LinearTransformation::new(matrix);
        let vector = VectorSpace::new(vec![1.0, 2.0]);
        
        let result = transformation.apply(&vector);
        assert_eq!(result.components, vec![1.0, 2.0]);
    }
}
```

### 5.2 Haskell å®ç°

```haskell
module ModuleTheory where

import Data.List (nub)
import qualified Data.Map as Map

-- ç¯ç±»å‹ç±»
class (Eq a) => Ring a where
    zero :: a
    one :: a
    add :: a -> a -> a
    multiply :: a -> a -> a
    negate :: a -> a
    subtract :: a -> a -> a
    isZero :: a -> Bool
    isOne :: a -> Bool
    subtract a b = add a (negate b)
    isZero x = x == zero
    isOne x = x == one

-- å·¦R-æ¨¡ç±»å‹ç±»
class (Ring r, Eq m) => LeftModule r m where
    moduleZero :: m
    moduleAdd :: m -> m -> m
    moduleNegate :: m -> m
    scalarMultiply :: r -> m -> m
    moduleSubtract :: m -> m -> m
    moduleIsZero :: m -> Bool
    moduleSubtract a b = moduleAdd a (moduleNegate b)
    moduleIsZero x = x == moduleZero

-- æ•´æ•°ç¯å®ä¾‹
newtype IntegerRing = IntegerRing { unIntegerRing :: Integer }
    deriving (Eq, Show)

instance Ring IntegerRing where
    zero = IntegerRing 0
    one = IntegerRing 1
    add (IntegerRing a) (IntegerRing b) = IntegerRing (a + b)
    multiply (IntegerRing a) (IntegerRing b) = IntegerRing (a * b)
    negate (IntegerRing a) = IntegerRing (-a)

-- é˜¿è´å°”ç¾¤ä½œä¸ºZ-æ¨¡
data AbelianGroup = AbelianGroup { elements :: [Integer] }
    deriving (Eq, Show)

instance LeftModule IntegerRing AbelianGroup where
    moduleZero = AbelianGroup [0]
    moduleAdd (AbelianGroup a) (AbelianGroup b) = AbelianGroup (a ++ b)
    moduleNegate (AbelianGroup a) = AbelianGroup (map negate a)
    scalarMultiply (IntegerRing r) (AbelianGroup a) = AbelianGroup (map (* r) a)

-- å‘é‡ç©ºé—´ä½œä¸ºåŸŸä¸Šçš„æ¨¡
data VectorSpace = VectorSpace { components :: [Double] }
    deriving (Eq, Show)

instance Ring Double where
    zero = 0.0
    one = 1.0
    add = (+)
    multiply = (*)
    negate = negate

instance LeftModule Double VectorSpace where
    moduleZero = VectorSpace []
    moduleAdd (VectorSpace a) (VectorSpace b) = 
        if length a == length b
        then VectorSpace (zipWith (+) a b)
        else error "å‘é‡ç»´åº¦ä¸åŒ¹é…"
    moduleNegate (VectorSpace a) = VectorSpace (map negate a)
    scalarMultiply r (VectorSpace a) = VectorSpace (map (* r) a)

-- å­æ¨¡
data Submodule r m = Submodule {
    baseModule :: m,
    subElements :: [m]
} deriving (Show)

-- åˆ›å»ºå­æ¨¡
createSubmodule :: (LeftModule r m) => m -> Submodule r m
createSubmodule base = Submodule base []

-- æ·»åŠ å­æ¨¡å…ƒç´ 
addSubmoduleElement :: (LeftModule r m) => Submodule r m -> m -> Submodule r m
addSubmoduleElement (Submodule base elements) element = 
    Submodule base (element : elements)

-- æ£€æŸ¥æ˜¯å¦ä¸ºå­æ¨¡
isSubmodule :: (LeftModule r m) => Submodule r m -> Bool
isSubmodule (Submodule _ elements) = 
    if null elements
    then True
    else let zero' = moduleZero
             addClosed = all (\e1 -> all (\e2 -> 
                 moduleAdd e1 e2 `elem` elements) elements) elements
             scalarClosed = all (\e -> 
                 let scalar = one
                     product = scalarMultiply scalar e
                 in product `elem` elements) elements
         in addClosed && scalarClosed

-- å•†æ¨¡
data QuotientModule r m = QuotientModule {
    originalModule :: m,
    submodule :: Submodule r m
} deriving (Show)

-- åˆ›å»ºå•†æ¨¡
createQuotientModule :: (LeftModule r m) => m -> Submodule r m -> QuotientModule r m
createQuotientModule original sub = QuotientModule original sub

-- é™ªé›†
coset :: (LeftModule r m) => QuotientModule r m -> m -> [m]
coset (QuotientModule original (Submodule _ subElements)) element = 
    [moduleAdd element e | e <- subElements]

-- æ¨¡åŒæ€
class (LeftModule r m, LeftModule r n) => ModuleHomomorphism r m n where
    hom :: m -> n
    kernel :: m -> [m]
    image :: [m] -> [n]

-- çº¿æ€§å˜æ¢ä½œä¸ºæ¨¡åŒæ€
data LinearTransformation = LinearTransformation {
    matrix :: [[Double]]
} deriving (Show)

-- åº”ç”¨çº¿æ€§å˜æ¢
applyTransformation :: LinearTransformation -> VectorSpace -> VectorSpace
applyTransformation (LinearTransformation matrix) (VectorSpace vector) = 
    let result = [sum [matrix !! i !! j * vector !! j | j <- [0..length vector - 1]]
                  | i <- [0..length matrix - 1]]
    in VectorSpace result

instance ModuleHomomorphism Double VectorSpace VectorSpace where
    hom = applyTransformation (LinearTransformation [])
    kernel _ = [moduleZero]
    image _ = [moduleZero]

-- è‡ªç”±æ¨¡
data FreeModule r = FreeModule {
    basis :: [String],
    coefficients :: Map String r
} deriving (Show)

-- åˆ›å»ºè‡ªç”±æ¨¡
createFreeModule :: (Ring r) => [String] -> FreeModule r
createFreeModule basis = FreeModule basis Map.empty

-- æ·»åŠ ç³»æ•°
addCoefficient :: (Ring r) => FreeModule r -> String -> r -> FreeModule r
addCoefficient (FreeModule basis coeffs) element coef = 
    FreeModule basis (Map.insert element coef coeffs)

-- æ¨¡çš„ç›´å’Œ
directSum :: (LeftModule r m, LeftModule r n) => m -> n -> (m, n)
directSum m n = (m, n)

-- æ¨¡çš„å¼ é‡ç§¯ï¼ˆç®€åŒ–å®ç°ï¼‰
tensorProduct :: (LeftModule r m, LeftModule r n) => m -> n -> [(m, n)]
tensorProduct m n = [(m, n)]

-- ç¤ºä¾‹å‡½æ•°
exampleAbelianGroup :: AbelianGroup
exampleAbelianGroup = AbelianGroup [1, 2, 3, 4, 5]

exampleVectorSpace :: VectorSpace
exampleVectorSpace = VectorSpace [1.0, 2.0, 3.0]

exampleLinearTransformation :: LinearTransformation
exampleLinearTransformation = LinearTransformation [
    [1.0, 0.0],
    [0.0, 1.0]
]

-- æ¨¡è¿ç®—ç¤ºä¾‹
moduleOperations :: (LeftModule r m) => m -> m -> r -> (m, m, m)
moduleOperations a b scalar = 
    (moduleAdd a b, moduleSubtract a b, scalarMultiply scalar a)

-- å­æ¨¡ç”Ÿæˆ
generateSubmodule :: (LeftModule r m) => [m] -> Submodule r m
generateSubmodule elements = 
    let base = if null elements then moduleZero else head elements
    in foldr addSubmoduleElement (createSubmodule base) elements

-- æ¨¡çš„ç»´æ•°ï¼ˆå¯¹äºæœ‰é™ç”Ÿæˆæ¨¡ï¼‰
moduleDimension :: (LeftModule r m) => m -> Int
moduleDimension _ = 1 -- ç®€åŒ–å®ç°

-- æ¨¡çš„ç§©
moduleRank :: (LeftModule r m) => m -> Int
moduleRank _ = 1 -- ç®€åŒ–å®ç°
```

## 6. åº”ç”¨ç¤ºä¾‹

### 6.1 é˜¿è´å°”ç¾¤ä½œä¸ºZ-æ¨¡

**ç¤ºä¾‹ 6.1.1** (é˜¿è´å°”ç¾¤çš„åŸºæœ¬æ€§è´¨)
ä»»ä½•é˜¿è´å°”ç¾¤éƒ½å¯ä»¥è‡ªç„¶åœ°è§†ä¸º $\mathbb{Z}$-æ¨¡ï¼Œå…¶ä¸­æ ‡é‡ä¹˜æ³•å®šä¹‰ä¸ºï¼š
$$n \cdot a = \underbrace{a + a + \cdots + a}_{n \text{æ¬¡}}$$

### 6.2 å‘é‡ç©ºé—´ä½œä¸ºåŸŸä¸Šçš„æ¨¡

**ç¤ºä¾‹ 6.1.2** (å‘é‡ç©ºé—´çš„æ€§è´¨)
å‘é‡ç©ºé—´æ˜¯åŸŸä¸Šçš„æ¨¡ï¼Œå…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼š
- åŠ æ³•ç¾¤ï¼š$(V, +)$ æ˜¯é˜¿è´å°”ç¾¤
- æ ‡é‡ä¹˜æ³•ï¼šæ»¡è¶³åˆ†é…å¾‹å’Œç»“åˆå¾‹
- åŸºï¼šå­˜åœ¨çº¿æ€§æ— å…³çš„ç”Ÿæˆé›†

### 6.3 ç†æƒ³ä½œä¸ºç¯ä¸Šçš„æ¨¡

**ç¤ºä¾‹ 6.1.3** (ç†æƒ³çš„æ€§è´¨)
ç¯ $R$ çš„ç†æƒ³ $I$ å¯ä»¥è§†ä¸º $R$-æ¨¡ï¼Œå…¶ä¸­æ ‡é‡ä¹˜æ³•å°±æ˜¯ç¯çš„ä¹˜æ³•ã€‚

## 7. ç›¸å…³ç†è®º

### 7.1 ä¸ç¯è®ºçš„å…³ç³»

æ¨¡æ˜¯ç¯ä¸Šçš„ä»£æ•°ç»“æ„ï¼Œä¸ºç ”ç©¶ç¯çš„æ€§è´¨æä¾›äº†é‡è¦å·¥å…·ã€‚

### 7.2 ä¸çº¿æ€§ä»£æ•°çš„å…³ç³»

å‘é‡ç©ºé—´æ˜¯åŸŸä¸Šçš„æ¨¡ï¼Œæ¨¡è®ºæ˜¯çº¿æ€§ä»£æ•°çš„æ¨å¹¿ã€‚

### 7.3 ä¸åŒè°ƒä»£æ•°çš„å…³ç³»

æ¨¡è®ºæ˜¯åŒè°ƒä»£æ•°çš„åŸºç¡€ï¼Œç”¨äºç ”ç©¶ä»£æ•°ç»“æ„çš„åŒè°ƒæ€§è´¨ã€‚

## 8. å‚è€ƒæ–‡çŒ®

1. Dummit, D. S., & Foote, R. M. (2004). *Abstract Algebra*. John Wiley & Sons.
2. Hungerford, T. W. (2003). *Algebra*. Springer-Verlag.
3. Lang, S. (2002). *Algebra*. Springer-Verlag.
4. Rotman, J. J. (2009). *An Introduction to Homological Algebra*. Springer.
5. Weibel, C. A. (1994). *An Introduction to Homological Algebra*. Cambridge University Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [02.6.1 ç¾¤è®ºåŸºç¡€](../02_Mathematical_Foundation/02.6.1_Group_Theory_Foundation.md)
- [02.6.2 ç¯è®ºåŸºç¡€](../02_Mathematical_Foundation/02.6.2_ç¯è®ºåŸºç¡€.md)
- [02.6.3 åŸŸè®ºåŸºç¡€](../02_Mathematical_Foundation/02.6.3_åŸŸè®ºåŸºç¡€.md)
- [02.1.1 æœ´ç´ é›†åˆè®º](../02_Mathematical_Foundation/02.1.1_æœ´ç´ é›†åˆè®º.md)
- [02.5.1 å…³ç³»æ¦‚å¿µ](../02_Mathematical_Foundation/02.5.1_Relation_Concept.md) 