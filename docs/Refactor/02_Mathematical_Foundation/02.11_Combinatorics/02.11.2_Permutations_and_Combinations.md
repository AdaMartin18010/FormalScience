# 02.11.2 æ’åˆ—ç»„åˆç†è®º

## ğŸ“‹ æ¦‚è¿°

æ’åˆ—ç»„åˆç†è®ºæ˜¯ç»„åˆæ•°å­¦çš„åŸºç¡€ï¼Œç ”ç©¶æœ‰é™é›†åˆä¸­å…ƒç´ çš„æœ‰åºå’Œæ— åºé€‰æ‹©é—®é¢˜ã€‚æœ¬ç†è®ºä¸ºå›¾è®ºã€æ¦‚ç‡è®ºã€ä¿¡æ¯è®ºç­‰æä¾›åŸºç¡€å·¥å…·ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹æ’åˆ—ç»„åˆçš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. è¯æ˜åŸºæœ¬è®¡æ•°å…¬å¼å’Œæ€§è´¨
3. æä¾›é«˜æ•ˆçš„ç®—æ³•å®ç°
4. å±•ç¤ºåœ¨å½¢å¼ç§‘å­¦ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ç®—æ³•å®ç°](#4-ç®—æ³•å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ’åˆ— (Permutation)

**å®šä¹‰ 1.1.1** (æ’åˆ—)
è®¾ $S$ ä¸ºæœ‰é™é›†åˆï¼Œ$|S| = n$ï¼Œä» $S$ ä¸­é€‰æ‹© $r$ ä¸ªå…ƒç´ çš„æœ‰åºæ’åˆ—æ•°ä¸ºï¼š
$$P(n,r) = \frac{n!}{(n-r)!}$$

### 1.2 ç»„åˆ (Combination)

**å®šä¹‰ 1.1.2** (ç»„åˆ)
è®¾ $S$ ä¸ºæœ‰é™é›†åˆï¼Œ$|S| = n$ï¼Œä» $S$ ä¸­é€‰æ‹© $r$ ä¸ªå…ƒç´ çš„ç»„åˆæ•°ä¸ºï¼š
$$C(n,r) = \binom{n}{r} = \frac{n!}{r!(n-r)!}$$

### 1.3 å¤šé‡æ’åˆ—

**å®šä¹‰ 1.1.3** (å¤šé‡æ’åˆ—)
è®¾ $S$ ä¸ºå¤šé‡é›†ï¼Œå…¶ä¸­å…ƒç´  $a_i$ å‡ºç° $n_i$ æ¬¡ï¼Œ$i = 1,2,\ldots,k$ï¼Œåˆ™ $S$ çš„æ’åˆ—æ•°ä¸ºï¼š
$$\frac{n!}{n_1!n_2!\cdots n_k!}$$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ’åˆ—çš„å½¢å¼åŒ–

**å®šä¹‰ 2.1.1** (æ’åˆ—å‡½æ•°)
æ’åˆ—å‡½æ•° $P: \mathbb{N} \times \mathbb{N} \to \mathbb{N}$ å®šä¹‰ä¸ºï¼š
$$P(n,r) = \begin{cases}
n! & \text{if } r = n \\
\frac{n!}{(n-r)!} & \text{if } 0 \leq r < n \\
0 & \text{if } r > n
\end{cases}$$

### 2.2 ç»„åˆçš„å½¢å¼åŒ–

**å®šä¹‰ 2.1.2** (ç»„åˆå‡½æ•°)
ç»„åˆå‡½æ•° $C: \mathbb{N} \times \mathbb{N} \to \mathbb{N}$ å®šä¹‰ä¸ºï¼š
$$C(n,r) = \begin{cases}
\frac{n!}{r!(n-r)!} & \text{if } 0 \leq r \leq n \\
0 & \text{if } r > n \text{ or } r < 0
\end{cases}$$

### 2.3 äºŒé¡¹å¼ç³»æ•°

**å®šä¹‰ 2.1.3** (äºŒé¡¹å¼ç³»æ•°)
äºŒé¡¹å¼ç³»æ•° $\binom{n}{r}$ å®šä¹‰ä¸ºï¼š
$$\binom{n}{r} = C(n,r) = \frac{n!}{r!(n-r)!}$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬æ€§è´¨

**å®šç† 3.1.1** (å¯¹ç§°æ€§)
å¯¹äºæ‰€æœ‰ $n, r \in \mathbb{N}$ï¼Œ$0 \leq r \leq n$ï¼š
$$\binom{n}{r} = \binom{n}{n-r}$$

**è¯æ˜**ï¼š
$$\binom{n}{r} = \frac{n!}{r!(n-r)!} = \frac{n!}{(n-r)!(n-(n-r))!} = \binom{n}{n-r}$$

**å®šç† 3.1.2** (å¸•æ–¯å¡æ’ç­‰å¼)
å¯¹äºæ‰€æœ‰ $n, r \in \mathbb{N}$ï¼Œ$1 \leq r \leq n$ï¼š
$$\binom{n}{r} = \binom{n-1}{r} + \binom{n-1}{r-1}$$

**è¯æ˜**ï¼š
$$\begin{align}
\binom{n-1}{r} + \binom{n-1}{r-1} &= \frac{(n-1)!}{r!(n-1-r)!} + \frac{(n-1)!}{(r-1)!(n-r)!} \\
&= \frac{(n-1)!(n-r)}{r!(n-r)!} + \frac{(n-1)!r}{r!(n-r)!} \\
&= \frac{(n-1)!(n-r+r)}{r!(n-r)!} \\
&= \frac{n!}{r!(n-r)!} = \binom{n}{r}
\end{align}$$

### 3.2 äºŒé¡¹å¼å®šç†

**å®šç† 3.2.1** (äºŒé¡¹å¼å®šç†)
å¯¹äºæ‰€æœ‰ $n \in \mathbb{N}$ å’Œ $x, y \in \mathbb{R}$ï¼š
$$(x+y)^n = \sum_{k=0}^{n} \binom{n}{k} x^{n-k} y^k$$

**è¯æ˜**ï¼š
ä½¿ç”¨æ•°å­¦å½’çº³æ³•ï¼š
- åŸºç¡€æƒ…å†µï¼š$n=0$ æ—¶ï¼Œ$(x+y)^0 = 1 = \binom{0}{0} x^0 y^0$
- å½’çº³å‡è®¾ï¼šå‡è®¾å¯¹ $n-1$ æˆç«‹
- å½’çº³æ­¥éª¤ï¼š
$$\begin{align}
(x+y)^n &= (x+y)(x+y)^{n-1} \\
&= (x+y)\sum_{k=0}^{n-1} \binom{n-1}{k} x^{n-1-k} y^k \\
&= \sum_{k=0}^{n-1} \binom{n-1}{k} x^{n-k} y^k + \sum_{k=0}^{n-1} \binom{n-1}{k} x^{n-1-k} y^{k+1} \\
&= \sum_{k=0}^{n} \left(\binom{n-1}{k} + \binom{n-1}{k-1}\right) x^{n-k} y^k \\
&= \sum_{k=0}^{n} \binom{n}{k} x^{n-k} y^k
\end{align}$$

### 3.3 ç”Ÿæˆå‡½æ•°

**å®šç† 3.3.1** (ç»„åˆç”Ÿæˆå‡½æ•°)
å¯¹äºå›ºå®š $n$ï¼Œç»„åˆæ•° $\binom{n}{r}$ çš„ç”Ÿæˆå‡½æ•°ä¸ºï¼š
$$\sum_{r=0}^{n} \binom{n}{r} x^r = (1+x)^n$$

**è¯æ˜**ï¼š
åœ¨äºŒé¡¹å¼å®šç†ä¸­ä»¤ $y=1$ å³å¯å¾—åˆ°ã€‚

## 4. ç®—æ³•å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::HashMap;

/// æ’åˆ—ç»„åˆè®¡ç®—å™¨
pub struct Combinatorics;

impl Combinatorics {
    /// è®¡ç®—æ’åˆ—æ•° P(n,r)
    pub fn permutation(n: u64, r: u64) -> u64 {
        if r > n {
            return 0;
        }
        if r == 0 {
            return 1;
        }

        let mut result = 1;
        for i in (n - r + 1)..=n {
            result *= i;
        }
        result
    }

    /// è®¡ç®—ç»„åˆæ•° C(n,r)
    pub fn combination(n: u64, r: u64) -> u64 {
        if r > n || r == 0 {
            return if r == 0 { 1 } else { 0 };
        }

        // ä½¿ç”¨å¯¹ç§°æ€§ä¼˜åŒ–
        let r = r.min(n - r);

        let mut result = 1;
        for i in 0..r {
            result = result * (n - i) / (i + 1);
        }
        result
    }

    /// è®¡ç®—å¤šé‡æ’åˆ—æ•°
    pub fn multiset_permutation(counts: &[u64]) -> u64 {
        let total: u64 = counts.iter().sum();
        let mut result = Self::factorial(total);

        for &count in counts {
            if count > 1 {
                result /= Self::factorial(count);
            }
        }
        result
    }

    /// è®¡ç®—é˜¶ä¹˜
    pub fn factorial(n: u64) -> u64 {
        if n <= 1 {
            return 1;
        }
        n * Self::factorial(n - 1)
    }

    /// ç”Ÿæˆæ‰€æœ‰æ’åˆ—
    pub fn generate_permutations<T: Clone + Ord>(items: &[T]) -> Vec<Vec<T>> {
        let mut items = items.to_vec();
        items.sort();

        let mut result = Vec::new();
        let mut used = vec![false; items.len()];
        let mut current = Vec::new();

        Self::backtrack_permutations(&items, &mut used, &mut current, &mut result);
        result
    }

    /// ç”Ÿæˆæ‰€æœ‰ç»„åˆ
    pub fn generate_combinations<T: Clone>(items: &[T], r: usize) -> Vec<Vec<T>> {
        let mut result = Vec::new();
        let mut current = Vec::new();

        Self::backtrack_combinations(items, r, 0, &mut current, &mut result);
        result
    }

    /// å›æº¯ç”Ÿæˆæ’åˆ—
    fn backtrack_permutations<T: Clone>(
        items: &[T],
        used: &mut [bool],
        current: &mut Vec<T>,
        result: &mut Vec<Vec<T>>
    ) {
        if current.len() == items.len() {
            result.push(current.clone());
            return;
        }

        for i in 0..items.len() {
            if !used[i] {
                used[i] = true;
                current.push(items[i].clone());
                Self::backtrack_permutations(items, used, current, result);
                current.pop();
                used[i] = false;
            }
        }
    }

    /// å›æº¯ç”Ÿæˆç»„åˆ
    fn backtrack_combinations<T: Clone>(
        items: &[T],
        r: usize,
        start: usize,
        current: &mut Vec<T>,
        result: &mut Vec<Vec<T>>
    ) {
        if current.len() == r {
            result.push(current.clone());
            return;
        }

        for i in start..items.len() {
            current.push(items[i].clone());
            Self::backtrack_combinations(items, r, i + 1, current, result);
            current.pop();
        }
    }
}

/// äºŒé¡¹å¼ç³»æ•°è®¡ç®—å™¨
pub struct BinomialCoefficient {
    cache: HashMap<(u64, u64), u64>,
}

impl BinomialCoefficient {
    pub fn new() -> Self {
        Self {
            cache: HashMap::new(),
        }
    }

    /// è®¡ç®—äºŒé¡¹å¼ç³»æ•° C(n,r)
    pub fn calculate(&mut self, n: u64, r: u64) -> u64 {
        if let Some(&result) = self.cache.get(&(n, r)) {
            return result;
        }

        let result = Combinatorics::combination(n, r);
        self.cache.insert((n, r), result);
        result
    }

    /// ç”Ÿæˆå¸•æ–¯å¡ä¸‰è§’å½¢
    pub fn pascal_triangle(n: u64) -> Vec<Vec<u64>> {
        let mut triangle = Vec::new();

        for i in 0..=n {
            let mut row = Vec::new();
            for j in 0..=i {
                row.push(Combinatorics::combination(i, j));
            }
            triangle.push(row);
        }

        triangle
    }
}

# [cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_permutation() {
        assert_eq!(Combinatorics::permutation(5, 3), 60);
        assert_eq!(Combinatorics::permutation(5, 5), 120);
        assert_eq!(Combinatorics::permutation(5, 0), 1);
        assert_eq!(Combinatorics::permutation(5, 6), 0);
    }

    #[test]
    fn test_combination() {
        assert_eq!(Combinatorics::combination(5, 3), 10);
        assert_eq!(Combinatorics::combination(5, 5), 1);
        assert_eq!(Combinatorics::combination(5, 0), 1);
        assert_eq!(Combinatorics::combination(5, 6), 0);
    }

    #[test]
    fn test_multiset_permutation() {
        // è®¡ç®— "MISSISSIPPI" çš„æ’åˆ—æ•°
        let counts = vec![1, 4, 4, 2]; // M, I, S, P
        assert_eq!(Combinatorics::multiset_permutation(&counts), 34650);
    }

    #[test]
    fn test_generate_permutations() {
        let items = vec![1, 2, 3];
        let permutations = Combinatorics::generate_permutations(&items);
        assert_eq!(permutations.len(), 6);
        assert!(permutations.contains(&vec![1, 2, 3]));
        assert!(permutations.contains(&vec![3, 2, 1]));
    }

    #[test]
    fn test_generate_combinations() {
        let items = vec![1, 2, 3, 4];
        let combinations = Combinatorics::generate_combinations(&items, 2);
        assert_eq!(combinations.len(), 6);
        assert!(combinations.contains(&vec![1, 2]));
        assert!(combinations.contains(&vec![3, 4]));
    }

    #[test]
    fn test_binomial_coefficient() {
        let mut bc = BinomialCoefficient::new();
        assert_eq!(bc.calculate(5, 3), 10);
        assert_eq!(bc.calculate(10, 5), 252);
    }

    #[test]
    fn test_pascal_triangle() {
        let triangle = BinomialCoefficient::pascal_triangle(5);
        assert_eq!(triangle[5], vec![1, 5, 10, 10, 5, 1]);
    }
}
```

### 4.2 Haskell å®ç°

```haskell
module Combinatorics where

import Data.List (sort)

-- æ’åˆ—æ•°è®¡ç®—
permutation :: Integer -> Integer -> Integer
permutation n r
  | r > n = 0
  | r == 0 = 1
  | otherwise = product [n-r+1..n]

-- ç»„åˆæ•°è®¡ç®—
combination :: Integer -> Integer -> Integer
combination n r
  | r > n || r < 0 = 0
  | r == 0 = 1
  | otherwise = let r' = min r (n - r)
                in product [n-r'+1..n] `div` product [1..r']

-- é˜¶ä¹˜è®¡ç®—
factorial :: Integer -> Integer
factorial n
  | n <= 1 = 1
  | otherwise = n * factorial (n - 1)

-- å¤šé‡æ’åˆ—æ•°è®¡ç®—
multisetPermutation :: [Integer] -> Integer
multisetPermutation counts =
  let total = sum counts
      denominator = product $ map factorial counts
  in factorial total `div` denominator

-- ç”Ÿæˆæ‰€æœ‰æ’åˆ—
permutations :: Ord a => [a] -> [[a]]
permutations = sort . permutations' . sort
  where
    permutations' [] = [[]]
    permutations' xs = [x:ys | x <- xs, ys <- permutations' (delete x xs)]
      where delete _ [] = []
            delete y (z:zs) = if y == z then zs else z : delete y zs

-- ç”Ÿæˆæ‰€æœ‰ç»„åˆ
combinations :: [a] -> Int -> [[a]]
combinations _ 0 = [[]]
combinations [] _ = []
combinations (x:xs) r =
  map (x:) (combinations xs (r-1)) ++ combinations xs r

-- äºŒé¡¹å¼ç³»æ•°
binomial :: Integer -> Integer -> Integer
binomial = combination

-- å¸•æ–¯å¡ä¸‰è§’å½¢
pascalTriangle :: Integer -> [[Integer]]
pascalTriangle n = [[binomial i j | j <- [0..i]] | i <- [0..n]]

-- äºŒé¡¹å¼å±•å¼€
binomialExpansion :: Integer -> (Integer, Integer) -> Integer
binomialExpansion n (x, y) = sum [binomial n k * x^(n-k) * y^k | k <- [0..n]]

-- æ–¯ç‰¹æ—æ•° (ç¬¬äºŒç±»)
stirlingSecond :: Integer -> Integer -> Integer
stirlingSecond n k
  | k == 0 = if n == 0 then 1 else 0
  | k == 1 = 1
  | k == n = 1
  | k > n = 0
  | otherwise = k * stirlingSecond (n-1) k + stirlingSecond (n-1) (k-1)

-- å¡ç‰¹å…°æ•°
catalan :: Integer -> Integer
catalan n = combination (2*n) n `div` (n + 1)

-- æµ‹è¯•å‡½æ•°
main :: IO ()
main = do
  putStrLn "æ’åˆ—ç»„åˆæµ‹è¯•:"
  putStrLn $ "P(5,3) = " ++ show (permutation 5 3)
  putStrLn $ "C(5,3) = " ++ show (combination 5 3)
  putStrLn $ "å¤šé‡æ’åˆ— 'MISSISSIPPI' = " ++ show (multisetPermutation [1,4,4,2])
  putStrLn $ "å¸•æ–¯å¡ä¸‰è§’å½¢ç¬¬5è¡Œ: " ++ show (pascalTriangle 5 !! 5)
  putStrLn $ "å¡ç‰¹å…°æ•° C(4) = " ++ show (catalan 4)
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 æ¦‚ç‡è®ºåº”ç”¨

**ç¤ºä¾‹ 5.1.1** (äºŒé¡¹åˆ†å¸ƒ)
åœ¨ $n$ æ¬¡ç‹¬ç«‹ä¼¯åŠªåˆ©è¯•éªŒä¸­ï¼Œæ°å¥½ $k$ æ¬¡æˆåŠŸçš„æ¦‚ç‡ä¸ºï¼š
$$P(X = k) = \binom{n}{k} p^k (1-p)^{n-k}$$

### 5.2 ä¿¡æ¯è®ºåº”ç”¨

**ç¤ºä¾‹ 5.1.2** (æ±‰æ˜è·ç¦»)
åœ¨ $n$ ä½äºŒè¿›åˆ¶ä¸²ä¸­ï¼Œæ±‰æ˜è·ç¦»ä¸º $d$ çš„ä¸²å¯¹æ•°é‡ä¸ºï¼š
$$\binom{n}{d} 2^{n-d}$$

### 5.3 å›¾è®ºåº”ç”¨

**ç¤ºä¾‹ 5.1.3** (å®Œå…¨å›¾)
$n$ ä¸ªé¡¶ç‚¹çš„å®Œå…¨å›¾ $K_n$ çš„è¾¹æ•°ä¸ºï¼š
$$|E(K_n)| = \binom{n}{2} = \frac{n(n-1)}{2}$$

### 5.4 å¯†ç å­¦åº”ç”¨

**ç¤ºä¾‹ 5.1.4** (ç»„åˆå¯†é’¥)
ä» $n$ ä¸ªå¯†é’¥ä¸­é€‰æ‹© $k$ ä¸ªç»„æˆç»„åˆå¯†é’¥çš„æ–¹æ¡ˆæ•°ä¸ºï¼š
$$\binom{n}{k}$$

## 6. ç›¸å…³ç†è®º

### 6.1 ç”Ÿæˆå‡½æ•°ç†è®º
- [02.11.3 ç”Ÿæˆå‡½æ•°](./02.11.3_Generating_Functions.md)

### 6.2 å›¾è®ºåŸºç¡€
- [02.11.4 å›¾è®ºåŸºç¡€](./02.11.4_Graph_Theory_Basics.md)

### 6.3 æ¦‚ç‡è®º
- [02.12.1 æ¦‚ç‡åŸºç¡€](../02.12_Probability_Theory/02.12.1_Probability_Basics.md)

### 6.4 æ•°è®º
- [02.10.1 æ•´é™¤ç†è®º](../02.10_Number_Theory/02.10.1_Divisibility_Theory.md)

## 7. å‚è€ƒæ–‡çŒ®

1. Graham, R. L., Knuth, D. E., & Patashnik, O. (1994). *Concrete Mathematics: A Foundation for Computer Science*. Addison-Wesley.

2. Stanley, R. P. (2011). *Enumerative Combinatorics Volume 1*. Cambridge University Press.

3. Aigner, M. (2007). *A Course in Enumeration*. Springer.

4. Wilf, H. S. (2006). *Generatingfunctionology*. A K Peters.

5. Cameron, P. J. (1994). *Combinatorics: Topics, Techniques, Algorithms*. Cambridge University Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [ä¸Šä¸€çº§ï¼š02.11 ç»„åˆæ•°å­¦](../README.md)
- [ä¸‹ä¸€çº§ï¼š02.11.3 ç”Ÿæˆå‡½æ•°](./02.11.3_Generating_Functions.md)
- [ä¸»ç´¢å¼•ï¼šå½¢å¼ç§‘å­¦ç†è®ºä½“ç³»](../../00_Master_Index/README.md)
