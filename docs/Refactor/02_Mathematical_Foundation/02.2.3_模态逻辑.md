# 02.2.3 æ¨¡æ€é€»è¾‘ç†è®º

## ğŸ“‹ æ¦‚è¿°

æ¨¡æ€é€»è¾‘ç†è®ºæ˜¯å½¢å¼é€»è¾‘çš„é‡è¦åˆ†æ”¯ï¼Œç ”ç©¶åŒ…å«æ¨¡æ€ç®—å­ï¼ˆå¦‚"å¿…ç„¶"ã€"å¯èƒ½"ï¼‰çš„é€»è¾‘ç³»ç»Ÿã€‚æœ¬ç†è®ºä¸ºå“²å­¦ã€è®¡ç®—æœºç§‘å­¦å’Œäººå·¥æ™ºèƒ½ä¸­çš„æ¨¡æ€æ¨ç†æä¾›å½¢å¼åŒ–åŸºç¡€ï¼Œæ˜¯ç†è§£å¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦çš„æ ¸å¿ƒå·¥å…·ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹æ¨¡æ€é€»è¾‘çš„å½¢å¼åŒ–ç†è®º**
2. **åˆ†æä¸åŒæ¨¡æ€ç³»ç»Ÿçš„é€»è¾‘æ€§è´¨**
3. **æ„å»ºå¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦æ¡†æ¶**
4. **æä¾›æ¨¡æ€æ¨ç†çš„å½¢å¼åŒ–æ–¹æ³•**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [æ¨¡æ€ç³»ç»Ÿ](#3-æ¨¡æ€ç³»ç»Ÿ)
4. [å¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦](#4-å¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦)
5. [å½¢å¼åŒ–è¯æ˜](#5-å½¢å¼åŒ–è¯æ˜)
6. [ä»£ç å®ç°](#6-ä»£ç å®ç°)
7. [åº”ç”¨ç¤ºä¾‹](#7-åº”ç”¨ç¤ºä¾‹)
8. [ç›¸å…³ç†è®º](#8-ç›¸å…³ç†è®º)
9. [å‚è€ƒæ–‡çŒ®](#9-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ¨¡æ€é€»è¾‘çš„å®šä¹‰

**å®šä¹‰ 1.1** (æ¨¡æ€é€»è¾‘)
æ¨¡æ€é€»è¾‘æ˜¯ç ”ç©¶åŒ…å«æ¨¡æ€ç®—å­çš„é€»è¾‘ç³»ç»Ÿï¼Œå…¶ä¸­æ¨¡æ€ç®—å­è¡¨ç¤º"å¿…ç„¶"ã€"å¯èƒ½"ç­‰æ¦‚å¿µã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
æ¨¡æ€é€»è¾‘ç³»ç»Ÿ $\mathcal{M}$ æ˜¯ä¸€ä¸ªäº”å…ƒç»„ï¼š
$$\mathcal{M} = \langle \mathcal{L}, \mathcal{W}, \mathcal{R}, \mathcal{V}, \mathcal{I} \rangle$$
å…¶ä¸­ï¼š
- $\mathcal{L}$ æ˜¯æ¨¡æ€è¯­è¨€
- $\mathcal{W}$ æ˜¯å¯èƒ½ä¸–ç•Œé›†åˆ
- $\mathcal{R} \subseteq \mathcal{W} \times \mathcal{W}$ æ˜¯å¯åŠå…³ç³»
- $\mathcal{V}$ æ˜¯èµ‹å€¼å‡½æ•°
- $\mathcal{I}$ æ˜¯è§£é‡Šå‡½æ•°

### 1.2 æ¨¡æ€ç®—å­

**å®šä¹‰ 1.2** (æ¨¡æ€ç®—å­)
æ¨¡æ€é€»è¾‘åŒ…å«ä»¥ä¸‹åŸºæœ¬æ¨¡æ€ç®—å­ï¼š
- **å¿…ç„¶ç®—å­** $\square$ï¼šè¡¨ç¤º"å¿…ç„¶"
- **å¯èƒ½ç®—å­** $\diamond$ï¼šè¡¨ç¤º"å¯èƒ½"

**å…³ç³»**ï¼š
$$\diamond \phi \iff \neg \square \neg \phi$$
$$\square \phi \iff \neg \diamond \neg \phi$$

### 1.3 æ¨¡æ€å…¬å¼

**å®šä¹‰ 1.3** (æ¨¡æ€å…¬å¼)
æ¨¡æ€å…¬å¼æ˜¯é€’å½’å®šä¹‰çš„ï¼š
1. åŸå­å‘½é¢˜æ˜¯æ¨¡æ€å…¬å¼
2. å¦‚æœ $\phi$ æ˜¯æ¨¡æ€å…¬å¼ï¼Œåˆ™ $\neg\phi$ æ˜¯æ¨¡æ€å…¬å¼
3. å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯æ¨¡æ€å…¬å¼ï¼Œåˆ™ $(\phi \land \psi)$, $(\phi \lor \psi)$, $(\phi \rightarrow \psi)$, $(\phi \leftrightarrow \psi)$ æ˜¯æ¨¡æ€å…¬å¼
4. å¦‚æœ $\phi$ æ˜¯æ¨¡æ€å…¬å¼ï¼Œåˆ™ $\square\phi$ å’Œ $\diamond\phi$ æ˜¯æ¨¡æ€å…¬å¼

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ¨¡æ€æ¡†æ¶

**å®šä¹‰ 2.1** (æ¨¡æ€æ¡†æ¶)
æ¨¡æ€æ¡†æ¶æ˜¯ä¸€ä¸ªäºŒå…ƒç»„ $\mathcal{F} = \langle W, R \rangle$ï¼Œå…¶ä¸­ï¼š
- $W$ æ˜¯å¯èƒ½ä¸–ç•Œé›†åˆ
- $R \subseteq W \times W$ æ˜¯å¯åŠå…³ç³»

**å¯åŠå…³ç³»æ€§è´¨**ï¼š
- **è‡ªåæ€§**ï¼š$\forall w \in W: wRw$
- **å¯¹ç§°æ€§**ï¼š$\forall w, v \in W: wRv \Rightarrow vRw$
- **ä¼ é€’æ€§**ï¼š$\forall w, v, u \in W: wRv \land vRu \Rightarrow wRu$
- **æ¬§å‡ é‡Œå¾—æ€§**ï¼š$\forall w, v, u \in W: wRv \land wRu \Rightarrow vRu$

### 2.2 æ¨¡æ€æ¨¡å‹

**å®šä¹‰ 2.2** (æ¨¡æ€æ¨¡å‹)
æ¨¡æ€æ¨¡å‹æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $\mathcal{M} = \langle W, R, V \rangle$ï¼Œå…¶ä¸­ï¼š
- $\langle W, R \rangle$ æ˜¯æ¨¡æ€æ¡†æ¶
- $V: \text{Prop} \times W \rightarrow \mathbb{B}$ æ˜¯èµ‹å€¼å‡½æ•°

### 2.3 æ»¡è¶³å…³ç³»

**å®šä¹‰ 2.3** (æ»¡è¶³å…³ç³»)
æ¨¡æ€æ¨¡å‹ $\mathcal{M}$ åœ¨ä¸–ç•Œ $w$ ä¸­æ»¡è¶³å…¬å¼ $\phi$ï¼Œè®°ä½œ $\mathcal{M}, w \models \phi$ï¼Œå®šä¹‰ä¸ºï¼š
1. $\mathcal{M}, w \models p$ å½“ä¸”ä»…å½“ $V(p, w) = \text{true}$
2. $\mathcal{M}, w \models \neg\phi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \not\models \phi$
3. $\mathcal{M}, w \models \phi \land \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \phi$ ä¸” $\mathcal{M}, w \models \psi$
4. $\mathcal{M}, w \models \phi \lor \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \phi$ æˆ– $\mathcal{M}, w \models \psi$
5. $\mathcal{M}, w \models \phi \rightarrow \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \not\models \phi$ æˆ– $\mathcal{M}, w \models \psi$
6. $\mathcal{M}, w \models \square\phi$ å½“ä¸”ä»…å½“ $\forall v \in W: wRv \Rightarrow \mathcal{M}, v \models \phi$
7. $\mathcal{M}, w \models \diamond\phi$ å½“ä¸”ä»…å½“ $\exists v \in W: wRv \land \mathcal{M}, v \models \phi$

## 3. æ¨¡æ€ç³»ç»Ÿ

### 3.1 åŸºæœ¬æ¨¡æ€ç³»ç»Ÿ

**å®šä¹‰ 3.1** (åŸºæœ¬æ¨¡æ€ç³»ç»Ÿ)
åŸºæœ¬æ¨¡æ€ç³»ç»ŸåŒ…å«ä»¥ä¸‹å…¬ç†å’Œè§„åˆ™ï¼š

**å…¬ç†**ï¼š
- **Kå…¬ç†**ï¼š$\square(\phi \rightarrow \psi) \rightarrow (\square\phi \rightarrow \square\psi)$
- **Tå…¬ç†**ï¼š$\square\phi \rightarrow \phi$
- **4å…¬ç†**ï¼š$\square\phi \rightarrow \square\square\phi$
- **5å…¬ç†**ï¼š$\diamond\phi \rightarrow \square\diamond\phi$
- **Bå…¬ç†**ï¼š$\phi \rightarrow \square\diamond\phi$
- **Då…¬ç†**ï¼š$\square\phi \rightarrow \diamond\phi$

**æ¨ç†è§„åˆ™**ï¼š
- **åˆ†ç¦»è§„åˆ™**ï¼š$\phi, \phi \rightarrow \psi \vdash \psi$
- **å¿…ç„¶åŒ–è§„åˆ™**ï¼š$\phi \vdash \square\phi$

### 3.2 å¸¸è§æ¨¡æ€ç³»ç»Ÿ

**å®šä¹‰ 3.2** (å¸¸è§æ¨¡æ€ç³»ç»Ÿ)
1. **Kç³»ç»Ÿ**ï¼šåªåŒ…å«Kå…¬ç†
2. **Tç³»ç»Ÿ**ï¼šK + Tå…¬ç†
3. **S4ç³»ç»Ÿ**ï¼šK + T + 4å…¬ç†
4. **S5ç³»ç»Ÿ**ï¼šK + T + 4 + 5å…¬ç†
5. **Bç³»ç»Ÿ**ï¼šK + T + Bå…¬ç†
6. **Dç³»ç»Ÿ**ï¼šK + Då…¬ç†

### 3.3 å¯¹åº”ç†è®º

**å®šä¹‰ 3.3** (å¯¹åº”ç†è®º)
æ¨¡æ€å…¬ç†ä¸å¯åŠå…³ç³»æ€§è´¨å¯¹åº”ï¼š
- **Tå…¬ç†** $\leftrightarrow$ è‡ªåæ€§
- **4å…¬ç†** $\leftrightarrow$ ä¼ é€’æ€§
- **5å…¬ç†** $\leftrightarrow$ æ¬§å‡ é‡Œå¾—æ€§
- **Bå…¬ç†** $\leftrightarrow$ å¯¹ç§°æ€§
- **Då…¬ç†** $\leftrightarrow$ åºåˆ—æ€§

## 4. å¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦

### 4.1 å¯èƒ½ä¸–ç•Œ

**å®šä¹‰ 4.1** (å¯èƒ½ä¸–ç•Œ)
å¯èƒ½ä¸–ç•Œæ˜¯é€»è¾‘ä¸Šä¸€è‡´çš„ä¸–ç•ŒçŠ¶æ€ï¼Œç”¨ $w \in W$ è¡¨ç¤ºã€‚

**å¯èƒ½ä¸–ç•Œæ€§è´¨**ï¼š
- **é€»è¾‘ä¸€è‡´æ€§**ï¼šæ¯ä¸ªå¯èƒ½ä¸–ç•Œå†…éƒ¨é€»è¾‘ä¸€è‡´
- **å®Œå¤‡æ€§**ï¼šæ¯ä¸ªå¯èƒ½ä¸–ç•ŒåŒ…å«æ‰€æœ‰ç›¸å…³å‘½é¢˜çš„çœŸå€¼
- **å¯åŠæ€§**ï¼šä¸–ç•Œé—´é€šè¿‡å¯åŠå…³ç³»è¿æ¥

### 4.2 å¯åŠå…³ç³»

**å®šä¹‰ 4.2** (å¯åŠå…³ç³»)
å¯åŠå…³ç³» $R$ è¡¨ç¤ºå¯èƒ½ä¸–ç•Œä¹‹é—´çš„å¯è¾¾æ€§ï¼š
$$w_1 R w_2 \iff w_2 \text{ is accessible from } w_1$$

**å¯åŠå…³ç³»ç±»å‹**ï¼š
- **ç­‰ä»·å…³ç³»**ï¼šè‡ªåã€å¯¹ç§°ã€ä¼ é€’
- **ååºå…³ç³»**ï¼šè‡ªåã€åå¯¹ç§°ã€ä¼ é€’
- **é¢„åºå…³ç³»**ï¼šè‡ªåã€ä¼ é€’

### 4.3 èµ‹å€¼å‡½æ•°

**å®šä¹‰ 4.3** (èµ‹å€¼å‡½æ•°)
èµ‹å€¼å‡½æ•° $V$ å°†å‘½é¢˜æ˜ å°„åˆ°å¯èƒ½ä¸–ç•Œçš„çœŸå€¼ï¼š
$$V: \text{Prop} \times W \rightarrow \mathbb{B}$$

**èµ‹å€¼æ€§è´¨**ï¼š
- **å±€éƒ¨æ€§**ï¼šæ¯ä¸ªä¸–ç•Œçš„èµ‹å€¼ç‹¬ç«‹
- **ä¸€è‡´æ€§**ï¼šåŒä¸€ä¸–ç•Œå†…èµ‹å€¼ä¸€è‡´
- **å¯æ‰©å±•æ€§**ï¼šå¯ä»¥æ‰©å±•åˆ°å¤æ‚å…¬å¼

## 5. å½¢å¼åŒ–è¯æ˜

### 5.1 å®Œå¤‡æ€§å®šç†

**å®šç† 5.1** (æ¨¡æ€é€»è¾‘å®Œå¤‡æ€§)
å¯¹äºæ¯ä¸ªæ¨¡æ€ç³»ç»Ÿ $S$ï¼Œå¦‚æœ $\Gamma \models_S \phi$ï¼Œåˆ™ $\Gamma \vdash_S \phi$ã€‚

**è¯æ˜**ï¼š
1. æ„é€ å…¸èŒƒæ¨¡å‹
2. è¯æ˜å…¸èŒƒæ¨¡å‹æ»¡è¶³æ‰€æœ‰å¯æ»¡è¶³çš„å…¬å¼é›†
3. åˆ©ç”¨ç´§è‡´æ€§å®šç†å®Œæˆè¯æ˜

### 5.2 ç´§è‡´æ€§å®šç†

**å®šç† 5.2** (æ¨¡æ€é€»è¾‘ç´§è‡´æ€§)
å¦‚æœå…¬å¼é›† $\Gamma$ çš„æ¯ä¸ªæœ‰é™å­é›†éƒ½æ˜¯å¯æ»¡è¶³çš„ï¼Œåˆ™ $\Gamma$ æœ¬èº«æ˜¯å¯æ»¡è¶³çš„ã€‚

**è¯æ˜**ï¼š
1. åˆ©ç”¨è¶…ç§¯æ„é€ 
2. åº”ç”¨è¶…æ»¤å­ç†è®º
3. è¯æ˜æ„é€ çš„æ¨¡å‹æ»¡è¶³ $\Gamma$

### 5.3 å¯¹åº”å®šç†

**å®šç† 5.3** (å¯¹åº”å®šç†)
æ¨¡æ€å…¬ç†ä¸å¯åŠå…³ç³»æ€§è´¨ä¹‹é—´å­˜åœ¨å¯¹åº”å…³ç³»ã€‚

**è¯æ˜**ï¼š
1. è¯æ˜å…¬ç†è•´å«å…³ç³»æ€§è´¨
2. è¯æ˜å…³ç³»æ€§è´¨è•´å«å…¬ç†
3. æ„é€ åä¾‹è¯æ˜å¿…è¦æ€§

### 5.4 å¯åˆ¤å®šæ€§å®šç†

**å®šç† 5.4** (å¯åˆ¤å®šæ€§)
åŸºæœ¬æ¨¡æ€é€»è¾‘æ˜¯å¯åˆ¤å®šçš„ã€‚

**è¯æ˜**ï¼š
1. åˆ©ç”¨æœ‰é™æ¨¡å‹æ€§è´¨
2. æ„é€ æœ‰ç•Œæ¨¡å‹æ£€æŸ¥ç®—æ³•
3. è¯æ˜ç®—æ³•çš„æ­£ç¡®æ€§å’Œç»ˆæ­¢æ€§

## 6. ä»£ç å®ç°

### 6.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::fmt;

/// å‘½é¢˜
#[derive(Debug, Clone, Hash, Eq, PartialEq)]
pub struct Proposition {
    name: String,
}

impl Proposition {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

/// æ¨¡æ€å…¬å¼
#[derive(Debug, Clone)]
pub enum ModalFormula {
    Proposition(Proposition),
    Negation(Box<ModalFormula>),
    Conjunction(Box<ModalFormula>, Box<ModalFormula>),
    Disjunction(Box<ModalFormula>, Box<ModalFormula>),
    Implication(Box<ModalFormula>, Box<ModalFormula>),
    Equivalence(Box<ModalFormula>, Box<ModalFormula>),
    Necessity(Box<ModalFormula>),
    Possibility(Box<ModalFormula>),
}

impl ModalFormula {
    pub fn proposition(name: String) -> Self {
        ModalFormula::Proposition(Proposition::new(name))
    }

    pub fn negation(formula: ModalFormula) -> Self {
        ModalFormula::Negation(Box::new(formula))
    }

    pub fn conjunction(left: ModalFormula, right: ModalFormula) -> Self {
        ModalFormula::Conjunction(Box::new(left), Box::new(right))
    }

    pub fn disjunction(left: ModalFormula, right: ModalFormula) -> Self {
        ModalFormula::Disjunction(Box::new(left), Box::new(right))
    }

    pub fn implication(antecedent: ModalFormula, consequent: ModalFormula) -> Self {
        ModalFormula::Implication(Box::new(antecedent), Box::new(consequent))
    }

    pub fn equivalence(left: ModalFormula, right: ModalFormula) -> Self {
        ModalFormula::Equivalence(Box::new(left), Box::new(right))
    }

    pub fn necessity(formula: ModalFormula) -> Self {
        ModalFormula::Necessity(Box::new(formula))
    }

    pub fn possibility(formula: ModalFormula) -> Self {
        ModalFormula::Possibility(Box::new(formula))
    }

    /// è½¬æ¢ä¸ºå¦å®šèŒƒå¼
    pub fn to_negation_normal_form(&self) -> ModalFormula {
        match self {
            ModalFormula::Proposition(p) => ModalFormula::Proposition(p.clone()),
            ModalFormula::Negation(formula) => match formula.as_ref() {
                ModalFormula::Proposition(p) => ModalFormula::Negation(Box::new(ModalFormula::Proposition(p.clone()))),
                ModalFormula::Negation(f) => f.to_negation_normal_form(),
                ModalFormula::Conjunction(left, right) => {
                    ModalFormula::Disjunction(
                        Box::new(ModalFormula::negation(left.clone())),
                        Box::new(ModalFormula::negation(right.clone()))
                    )
                }
                ModalFormula::Disjunction(left, right) => {
                    ModalFormula::Conjunction(
                        Box::new(ModalFormula::negation(left.clone())),
                        Box::new(ModalFormula::negation(right.clone()))
                    )
                }
                ModalFormula::Necessity(f) => ModalFormula::Possibility(Box::new(ModalFormula::negation(f.clone()))),
                ModalFormula::Possibility(f) => ModalFormula::Necessity(Box::new(ModalFormula::negation(f.clone()))),
                _ => self.clone(),
            },
            ModalFormula::Conjunction(left, right) => {
                ModalFormula::Conjunction(
                    Box::new(left.to_negation_normal_form()),
                    Box::new(right.to_negation_normal_form())
                )
            }
            ModalFormula::Disjunction(left, right) => {
                ModalFormula::Disjunction(
                    Box::new(left.to_negation_normal_form()),
                    Box::new(right.to_negation_normal_form())
                )
            }
            ModalFormula::Implication(antecedent, consequent) => {
                ModalFormula::Disjunction(
                    Box::new(ModalFormula::negation(antecedent.clone())),
                    Box::new(consequent.clone())
                ).to_negation_normal_form()
            }
            ModalFormula::Equivalence(left, right) => {
                ModalFormula::Conjunction(
                    Box::new(ModalFormula::implication(left.clone(), right.clone())),
                    Box::new(ModalFormula::implication(right.clone(), left.clone()))
                ).to_negation_normal_form()
            }
            ModalFormula::Necessity(formula) => {
                ModalFormula::Necessity(Box::new(formula.to_negation_normal_form()))
            }
            ModalFormula::Possibility(formula) => {
                ModalFormula::Possibility(Box::new(formula.to_negation_normal_form()))
            }
        }
    }
}

/// å¯èƒ½ä¸–ç•Œ
#[derive(Debug, Clone, Hash, Eq, PartialEq)]
pub struct PossibleWorld {
    id: String,
    propositions: HashSet<Proposition>,
}

impl PossibleWorld {
    pub fn new(id: String) -> Self {
        Self {
            id,
            propositions: HashSet::new(),
        }
    }

    pub fn add_proposition(&mut self, proposition: Proposition) {
        self.propositions.insert(proposition);
    }

    pub fn has_proposition(&self, proposition: &Proposition) -> bool {
        self.propositions.contains(proposition)
    }
}

/// å¯åŠå…³ç³»
#[derive(Debug, Clone)]
pub struct AccessibilityRelation {
    relations: HashSet<(PossibleWorld, PossibleWorld)>,
}

impl AccessibilityRelation {
    pub fn new() -> Self {
        Self {
            relations: HashSet::new(),
        }
    }

    pub fn add_relation(&mut self, from: PossibleWorld, to: PossibleWorld) {
        self.relations.insert((from, to));
    }

    pub fn is_accessible(&self, from: &PossibleWorld, to: &PossibleWorld) -> bool {
        self.relations.contains(&(from.clone(), to.clone()))
    }

    pub fn get_accessible_worlds(&self, from: &PossibleWorld) -> Vec<&PossibleWorld> {
        self.relations.iter()
            .filter(|(w1, _)| w1 == from)
            .map(|(_, w2)| w2)
            .collect()
    }

    /// æ£€æŸ¥è‡ªåæ€§
    pub fn is_reflexive(&self) -> bool {
        self.relations.iter().all(|(w1, w2)| w1 == w2)
    }

    /// æ£€æŸ¥å¯¹ç§°æ€§
    pub fn is_symmetric(&self) -> bool {
        self.relations.iter().all(|(w1, w2)| {
            self.relations.contains(&(w2.clone(), w1.clone()))
        })
    }

    /// æ£€æŸ¥ä¼ é€’æ€§
    pub fn is_transitive(&self) -> bool {
        self.relations.iter().all(|(w1, w2)| {
            self.get_accessible_worlds(w2).iter().all(|w3| {
                self.relations.contains(&(w1.clone(), (*w3).clone()))
            })
        })
    }
}

/// æ¨¡æ€æ¨¡å‹
#[derive(Debug, Clone)]
pub struct ModalModel {
    worlds: Vec<PossibleWorld>,
    accessibility: AccessibilityRelation,
}

impl ModalModel {
    pub fn new() -> Self {
        Self {
            worlds: Vec::new(),
            accessibility: AccessibilityRelation::new(),
        }
    }

    pub fn add_world(&mut self, world: PossibleWorld) {
        self.worlds.push(world);
    }

    pub fn add_accessibility(&mut self, from: PossibleWorld, to: PossibleWorld) {
        self.accessibility.add_relation(from, to);
    }

    /// è¯„ä¼°å…¬å¼
    pub fn evaluate(&self, formula: &ModalFormula, world: &PossibleWorld) -> bool {
        match formula {
            ModalFormula::Proposition(p) => world.has_proposition(p),
            ModalFormula::Negation(f) => !self.evaluate(f, world),
            ModalFormula::Conjunction(left, right) => {
                self.evaluate(left, world) && self.evaluate(right, world)
            }
            ModalFormula::Disjunction(left, right) => {
                self.evaluate(left, world) || self.evaluate(right, world)
            }
            ModalFormula::Implication(antecedent, consequent) => {
                !self.evaluate(antecedent, world) || self.evaluate(consequent, world)
            }
            ModalFormula::Equivalence(left, right) => {
                self.evaluate(left, world) == self.evaluate(right, world)
            }
            ModalFormula::Necessity(f) => {
                self.accessibility.get_accessible_worlds(world).iter()
                    .all(|w| self.evaluate(f, w))
            }
            ModalFormula::Possibility(f) => {
                self.accessibility.get_accessible_worlds(world).iter()
                    .any(|w| self.evaluate(f, w))
            }
        }
    }

    /// æ£€æŸ¥å…¬å¼æœ‰æ•ˆæ€§
    pub fn is_valid(&self, formula: &ModalFormula) -> bool {
        self.worlds.iter().all(|world| self.evaluate(formula, world))
    }

    /// æ£€æŸ¥å…¬å¼å¯æ»¡è¶³æ€§
    pub fn is_satisfiable(&self, formula: &ModalFormula) -> bool {
        self.worlds.iter().any(|world| self.evaluate(formula, world))
    }
}

/// æ¨¡æ€é€»è¾‘æ¨ç†å™¨
#[derive(Debug, Clone)]
pub struct ModalLogicReasoner {
    model: ModalModel,
}

impl ModalLogicReasoner {
    pub fn new(model: ModalModel) -> Self {
        Self { model }
    }

    /// æ£€æŸ¥å…¬ç†
    pub fn check_axiom_k(&self, phi: &ModalFormula, psi: &ModalFormula) -> bool {
        let axiom = ModalFormula::implication(
            ModalFormula::necessity(ModalFormula::implication(phi.clone(), psi.clone())),
            ModalFormula::implication(
                ModalFormula::necessity(phi.clone()),
                ModalFormula::necessity(psi.clone())
            )
        );
        self.model.is_valid(&axiom)
    }

    pub fn check_axiom_t(&self, phi: &ModalFormula) -> bool {
        let axiom = ModalFormula::implication(
            ModalFormula::necessity(phi.clone()),
            phi.clone()
        );
        self.model.is_valid(&axiom)
    }

    pub fn check_axiom_4(&self, phi: &ModalFormula) -> bool {
        let axiom = ModalFormula::implication(
            ModalFormula::necessity(phi.clone()),
            ModalFormula::necessity(ModalFormula::necessity(phi.clone()))
        );
        self.model.is_valid(&axiom)
    }

    pub fn check_axiom_5(&self, phi: &ModalFormula) -> bool {
        let axiom = ModalFormula::implication(
            ModalFormula::possibility(phi.clone()),
            ModalFormula::necessity(ModalFormula::possibility(phi.clone()))
        );
        self.model.is_valid(&axiom)
    }

    /// æ£€æŸ¥é€»è¾‘è•´æ¶µ
    pub fn entails(&self, premises: &[ModalFormula], conclusion: &ModalFormula) -> bool {
        // ç®€åŒ–ç‰ˆæœ¬ï¼šæ£€æŸ¥æ‰€æœ‰å‰æä¸ºçœŸæ—¶ç»“è®ºæ˜¯å¦ä¸ºçœŸ
        self.model.worlds.iter().all(|world| {
            let all_premises_true = premises.iter()
                .all(|premise| self.model.evaluate(premise, world));
            
            if all_premises_true {
                self.model.evaluate(conclusion, world)
            } else {
                true // å¦‚æœå‰æä¸éƒ½ä¸ºçœŸï¼Œåˆ™è•´æ¶µæˆç«‹
            }
        })
    }

    /// æ¨¡æ€æ¨ç†ï¼šä»å¿…ç„¶æ¨å‡ºå¯èƒ½
    pub fn necessity_implies_possibility(&self, phi: &ModalFormula) -> bool {
        let implication = ModalFormula::implication(
            ModalFormula::necessity(phi.clone()),
            ModalFormula::possibility(phi.clone())
        );
        self.model.is_valid(&implication)
    }

    /// æ¨¡æ€æ¨ç†ï¼šä»å¯èƒ½æ¨å‡ºå¿…ç„¶ï¼ˆåœ¨S5ç³»ç»Ÿä¸­ï¼‰
    pub fn possibility_implies_necessity(&self, phi: &ModalFormula) -> bool {
        let implication = ModalFormula::implication(
            ModalFormula::possibility(phi.clone()),
            ModalFormula::necessity(phi.clone())
        );
        self.model.is_valid(&implication)
    }
}

/// æ¨¡æ€ç³»ç»Ÿæ„é€ å™¨
#[derive(Debug, Clone)]
pub struct ModalSystemBuilder {
    model: ModalModel,
}

impl ModalSystemBuilder {
    pub fn new() -> Self {
        Self {
            model: ModalModel::new(),
        }
    }

    pub fn add_world(mut self, world: PossibleWorld) -> Self {
        self.model.add_world(world);
        self
    }

    pub fn add_accessibility(mut self, from: PossibleWorld, to: PossibleWorld) -> Self {
        self.model.add_accessibility(from, to);
        self
    }

    pub fn build(self) -> ModalModel {
        self.model
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_modal_logic() {
        // åˆ›å»ºæ¨¡æ€æ¨¡å‹
        let mut model = ModalModel::new();
        
        // åˆ›å»ºå¯èƒ½ä¸–ç•Œ
        let mut world1 = PossibleWorld::new("w1".to_string());
        let mut world2 = PossibleWorld::new("w2".to_string());
        
        // æ·»åŠ å‘½é¢˜
        let p = Proposition::new("p".to_string());
        let q = Proposition::new("q".to_string());
        
        world1.add_proposition(p.clone());
        world2.add_proposition(q.clone());
        
        model.add_world(world1.clone());
        model.add_world(world2.clone());
        
        // æ·»åŠ å¯åŠå…³ç³»
        model.add_accessibility(world1.clone(), world1.clone());
        model.add_accessibility(world1.clone(), world2.clone());
        model.add_accessibility(world2.clone(), world2.clone());
        
        // åˆ›å»ºæ¨ç†å™¨
        let reasoner = ModalLogicReasoner::new(model);
        
        // æµ‹è¯•å…¬å¼
        let phi = ModalFormula::proposition("p".to_string());
        let psi = ModalFormula::proposition("q".to_string());
        
        // æµ‹è¯•å…¬ç†
        assert!(reasoner.check_axiom_k(&phi, &psi));
        assert!(reasoner.check_axiom_t(&phi));
        
        // æµ‹è¯•æ¨¡æ€æ¨ç†
        assert!(reasoner.necessity_implies_possibility(&phi));
    }

    #[test]
    fn test_negation_normal_form() {
        let p = ModalFormula::proposition("p".to_string());
        let q = ModalFormula::proposition("q".to_string());
        
        let formula = ModalFormula::implication(p, q);
        let nnf = formula.to_negation_normal_form();
        
        // éªŒè¯å¦å®šèŒƒå¼ä¸åŒ…å«è•´å«
        match nnf {
            ModalFormula::Disjunction(_, _) => assert!(true),
            _ => assert!(false, "Should be disjunction"),
        }
    }
}
```

### 6.2 Haskell å®ç°

```haskell
module ModalLogic where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Maybe (fromMaybe)

-- å‘½é¢˜
data Proposition = Proposition String deriving (Show, Eq, Ord)

-- æ¨¡æ€å…¬å¼
data ModalFormula = Prop Proposition
                  | Negation ModalFormula
                  | Conjunction ModalFormula ModalFormula
                  | Disjunction ModalFormula ModalFormula
                  | Implication ModalFormula ModalFormula
                  | Equivalence ModalFormula ModalFormula
                  | Necessity ModalFormula
                  | Possibility ModalFormula
                  deriving (Show, Eq)

-- å¯èƒ½ä¸–ç•Œ
data PossibleWorld = PossibleWorld
    { worldId :: String
    , propositions :: Set Proposition
    } deriving (Show, Eq, Ord)

-- å¯åŠå…³ç³»
data AccessibilityRelation = AccessibilityRelation
    { relations :: Set (PossibleWorld, PossibleWorld)
    } deriving (Show, Eq)

-- æ¨¡æ€æ¨¡å‹
data ModalModel = ModalModel
    { worlds :: [PossibleWorld]
    , accessibility :: AccessibilityRelation
    } deriving (Show, Eq)

-- åˆ›å»ºç©ºæ¨¡æ€æ¨¡å‹
emptyModalModel :: ModalModel
emptyModalModel = ModalModel [] (AccessibilityRelation Set.empty)

-- æ·»åŠ ä¸–ç•Œ
addWorld :: PossibleWorld -> ModalModel -> ModalModel
addWorld world model = model { worlds = world : worlds model }

-- æ·»åŠ å¯åŠå…³ç³»
addAccessibility :: PossibleWorld -> PossibleWorld -> ModalModel -> ModalModel
addAccessibility from to model = model
    { accessibility = AccessibilityRelation (Set.insert (from, to) (relations (accessibility model)))
    }

-- æ£€æŸ¥å¯åŠæ€§
isAccessible :: PossibleWorld -> PossibleWorld -> AccessibilityRelation -> Bool
isAccessible from to relation = Set.member (from, to) (relations relation)

-- è·å–å¯åŠä¸–ç•Œ
getAccessibleWorlds :: PossibleWorld -> AccessibilityRelation -> [PossibleWorld]
getAccessibleWorlds world relation = 
    [w2 | (w1, w2) <- Set.toList (relations relation), w1 == world]

-- æ£€æŸ¥è‡ªåæ€§
isReflexive :: AccessibilityRelation -> Bool
isReflexive relation = all (\(w1, w2) -> w1 == w2) (Set.toList (relations relation))

-- æ£€æŸ¥å¯¹ç§°æ€§
isSymmetric :: AccessibilityRelation -> Bool
isSymmetric relation = all (\(w1, w2) -> Set.member (w2, w1) (relations relation)) (Set.toList (relations relation))

-- æ£€æŸ¥ä¼ é€’æ€§
isTransitive :: AccessibilityRelation -> Bool
isTransitive relation = 
    all (\(w1, w2) -> 
        all (\w3 -> Set.member (w1, w3) (relations relation)) 
            (getAccessibleWorlds w2 relation)
    ) (Set.toList (relations relation))

-- è¯„ä¼°å…¬å¼
evaluate :: ModalFormula -> PossibleWorld -> ModalModel -> Bool
evaluate (Prop p) world _ = Set.member p (propositions world)
evaluate (Negation f) world model = not (evaluate f world model)
evaluate (Conjunction left right) world model = 
    evaluate left world model && evaluate right world model
evaluate (Disjunction left right) world model = 
    evaluate left world model || evaluate right world model
evaluate (Implication antecedent consequent) world model = 
    not (evaluate antecedent world model) || evaluate consequent world model
evaluate (Equivalence left right) world model = 
    evaluate left world model == evaluate right world model
evaluate (Necessity f) world model = 
    all (\w -> evaluate f w model) (getAccessibleWorlds world (accessibility model))
evaluate (Possibility f) world model = 
    any (\w -> evaluate f w model) (getAccessibleWorlds world (accessibility model))

-- æ£€æŸ¥å…¬å¼æœ‰æ•ˆæ€§
isValid :: ModalFormula -> ModalModel -> Bool
isValid formula model = all (\world -> evaluate formula world model) (worlds model)

-- æ£€æŸ¥å…¬å¼å¯æ»¡è¶³æ€§
isSatisfiable :: ModalFormula -> ModalModel -> Bool
isSatisfiable formula model = any (\world -> evaluate formula world model) (worlds model)

-- è½¬æ¢ä¸ºå¦å®šèŒƒå¼
toNegationNormalForm :: ModalFormula -> ModalFormula
toNegationNormalForm (Prop p) = Prop p
toNegationNormalForm (Negation f) = case f of
    Prop p -> Negation (Prop p)
    Negation g -> toNegationNormalForm g
    Conjunction left right -> 
        Disjunction (toNegationNormalForm (Negation left)) (toNegationNormalForm (Negation right))
    Disjunction left right -> 
        Conjunction (toNegationNormalForm (Negation left)) (toNegationNormalForm (Negation right))
    Necessity g -> Possibility (toNegationNormalForm (Negation g))
    Possibility g -> Necessity (toNegationNormalForm (Negation g))
    _ -> Negation (toNegationNormalForm f)
toNegationNormalForm (Conjunction left right) = 
    Conjunction (toNegationNormalForm left) (toNegationNormalForm right)
toNegationNormalForm (Disjunction left right) = 
    Disjunction (toNegationNormalForm left) (toNegationNormalForm right)
toNegationNormalForm (Implication antecedent consequent) = 
    toNegationNormalForm (Disjunction (Negation antecedent) consequent)
toNegationNormalForm (Equivalence left right) = 
    toNegationNormalForm (Conjunction 
        (Implication left right) 
        (Implication right left))
toNegationNormalForm (Necessity f) = Necessity (toNegationNormalForm f)
toNegationNormalForm (Possibility f) = Possibility (toNegationNormalForm f)

-- æ¨¡æ€é€»è¾‘æ¨ç†å™¨
data ModalLogicReasoner = ModalLogicReasoner
    { model :: ModalModel
    } deriving (Show, Eq)

-- æ£€æŸ¥å…¬ç†K
checkAxiomK :: ModalFormula -> ModalFormula -> ModalLogicReasoner -> Bool
checkAxiomK phi psi reasoner = 
    let axiom = Implication 
        (Necessity (Implication phi psi))
        (Implication (Necessity phi) (Necessity psi))
    in isValid axiom (model reasoner)

-- æ£€æŸ¥å…¬ç†T
checkAxiomT :: ModalFormula -> ModalLogicReasoner -> Bool
checkAxiomT phi reasoner = 
    let axiom = Implication (Necessity phi) phi
    in isValid axiom (model reasoner)

-- æ£€æŸ¥å…¬ç†4
checkAxiom4 :: ModalFormula -> ModalLogicReasoner -> Bool
checkAxiom4 phi reasoner = 
    let axiom = Implication (Necessity phi) (Necessity (Necessity phi))
    in isValid axiom (model reasoner)

-- æ£€æŸ¥å…¬ç†5
checkAxiom5 :: ModalFormula -> ModalLogicReasoner -> Bool
checkAxiom5 phi reasoner = 
    let axiom = Implication (Possibility phi) (Necessity (Possibility phi))
    in isValid axiom (model reasoner)

-- æ£€æŸ¥é€»è¾‘è•´æ¶µ
entails :: [ModalFormula] -> ModalFormula -> ModalLogicReasoner -> Bool
entails premises conclusion reasoner = 
    all (\world -> 
        let allPremisesTrue = all (\premise -> evaluate premise world (model reasoner)) premises
        in if allPremisesTrue then evaluate conclusion world (model reasoner) else True
    ) (worlds (model reasoner))

-- æ¨¡æ€æ¨ç†ï¼šä»å¿…ç„¶æ¨å‡ºå¯èƒ½
necessityImpliesPossibility :: ModalFormula -> ModalLogicReasoner -> Bool
necessityImpliesPossibility phi reasoner = 
    let implication = Implication (Necessity phi) (Possibility phi)
    in isValid implication (model reasoner)

-- ç¤ºä¾‹ä½¿ç”¨
example :: IO ()
example = do
    let -- åˆ›å»ºå¯èƒ½ä¸–ç•Œ
        world1 = PossibleWorld "w1" (Set.singleton (Proposition "p"))
        world2 = PossibleWorld "w2" (Set.singleton (Proposition "q"))
        
        -- åˆ›å»ºæ¨¡å‹
        model = addWorld world2 (addWorld world1 emptyModalModel)
        model' = addAccessibility world1 world1 model
        model'' = addAccessibility world1 world2 model'
        model''' = addAccessibility world2 world2 model''
        
        -- åˆ›å»ºæ¨ç†å™¨
        reasoner = ModalLogicReasoner model'''
        
        -- æµ‹è¯•å…¬å¼
        phi = Prop (Proposition "p")
        psi = Prop (Proposition "q")
    
    putStrLn "Modal Logic Example:"
    putStrLn $ "Axiom K holds: " ++ show (checkAxiomK phi psi reasoner)
    putStrLn $ "Axiom T holds: " ++ show (checkAxiomT phi reasoner)
    putStrLn $ "Necessity implies possibility: " ++ show (necessityImpliesPossibility phi reasoner)
    putStrLn $ "Model is reflexive: " ++ show (isReflexive (accessibility model'''))
    putStrLn $ "Model is transitive: " ++ show (isTransitive (accessibility model'''))

main :: IO ()
main = example
```

## 7. åº”ç”¨ç¤ºä¾‹

### 7.1 å“²å­¦æ¨¡æ€é€»è¾‘

**ç¤ºä¾‹ 7.1** (å½¢è€Œä¸Šå­¦æ¨¡æ€)
```rust
// å½¢è€Œä¸Šå­¦æ¨¡æ€åˆ†æ
let mut metaphysics = ModalModel::new();

// åˆ›å»ºå¯èƒ½ä¸–ç•Œ
let mut actual_world = PossibleWorld::new("actual".to_string());
let mut possible_world1 = PossibleWorld::new("possible1".to_string());
let mut possible_world2 = PossibleWorld::new("possible2".to_string());

// æ·»åŠ å½¢è€Œä¸Šå­¦å‘½é¢˜
let exists = Proposition::new("exists".to_string());
let is_conscious = Proposition::new("is_conscious".to_string());

actual_world.add_proposition(exists.clone());
actual_world.add_proposition(is_conscious.clone());
possible_world1.add_proposition(exists.clone());
possible_world2.add_proposition(exists.clone());

metaphysics.add_world(actual_world.clone());
metaphysics.add_world(possible_world1.clone());
metaphysics.add_world(possible_world2.clone());

// è®¾ç½®å¯åŠå…³ç³»ï¼ˆæ‰€æœ‰ä¸–ç•Œç›¸äº’å¯è¾¾ï¼‰
metaphysics.add_accessibility(actual_world.clone(), actual_world.clone());
metaphysics.add_accessibility(actual_world.clone(), possible_world1.clone());
metaphysics.add_accessibility(actual_world.clone(), possible_world2.clone());

// åˆ›å»ºæ¨ç†å™¨
let reasoner = ModalLogicReasoner::new(metaphysics);

// æµ‹è¯•å½¢è€Œä¸Šå­¦å‘½é¢˜
let existence_necessary = ModalFormula::necessity(ModalFormula::proposition("exists".to_string()));
let consciousness_possible = ModalFormula::possibility(ModalFormula::proposition("is_conscious".to_string()));

assert!(reasoner.model.is_valid(&existence_necessary));
assert!(reasoner.model.is_satisfiable(&consciousness_possible));
```

### 7.2 è®¡ç®—æœºç§‘å­¦æ¨¡æ€é€»è¾‘

**ç¤ºä¾‹ 7.2** (ç¨‹åºéªŒè¯)
```rust
// ç¨‹åºéªŒè¯æ¨¡æ€é€»è¾‘
let mut program_model = ModalModel::new();

// åˆ›å»ºç¨‹åºçŠ¶æ€
let mut initial_state = PossibleWorld::new("initial".to_string());
let mut running_state = PossibleWorld::new("running".to_string());
let mut final_state = PossibleWorld::new("final".to_string());

// æ·»åŠ ç¨‹åºå±æ€§
let is_safe = Proposition::new("is_safe".to_string());
let is_terminating = Proposition::new("is_terminating".to_string());

initial_state.add_proposition(is_safe.clone());
running_state.add_proposition(is_safe.clone());
final_state.add_proposition(is_safe.clone());
final_state.add_proposition(is_terminating.clone());

program_model.add_world(initial_state.clone());
program_model.add_world(running_state.clone());
program_model.add_world(final_state.clone());

// è®¾ç½®ç¨‹åºè½¬æ¢å…³ç³»
program_model.add_accessibility(initial_state.clone(), running_state.clone());
program_model.add_accessibility(running_state.clone(), final_state.clone());

// åˆ›å»ºæ¨ç†å™¨
let reasoner = ModalLogicReasoner::new(program_model);

// éªŒè¯ç¨‹åºå±æ€§
let always_safe = ModalFormula::necessity(ModalFormula::proposition("is_safe".to_string()));
let eventually_terminating = ModalFormula::possibility(ModalFormula::proposition("is_terminating".to_string()));

assert!(reasoner.model.is_valid(&always_safe));
assert!(reasoner.model.is_satisfiable(&eventually_terminating));
```

## 8. ç›¸å…³ç†è®º

### 8.1 ä¸å‘½é¢˜é€»è¾‘çš„å…³ç³»

æ¨¡æ€é€»è¾‘æ˜¯å‘½é¢˜é€»è¾‘çš„æ‰©å±•ï¼Œé€šè¿‡æ·»åŠ æ¨¡æ€ç®—å­å¢å¼ºäº†è¡¨è¾¾èƒ½åŠ›ã€‚

### 8.2 ä¸è°“è¯é€»è¾‘çš„å…³ç³»

æ¨¡æ€é€»è¾‘å¯ä»¥ä¸è°“è¯é€»è¾‘ç»“åˆï¼Œå½¢æˆæ¨¡æ€è°“è¯é€»è¾‘ï¼Œç”¨äºæ›´å¤æ‚çš„æ¨ç†ã€‚

### 8.3 ä¸å¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦çš„å…³ç³»

å¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦ä¸ºæ¨¡æ€é€»è¾‘æä¾›äº†ç›´è§‚çš„è¯­ä¹‰è§£é‡Šï¼Œæ˜¯ç†è§£æ¨¡æ€æ¦‚å¿µçš„é‡è¦å·¥å…·ã€‚

## 9. å‚è€ƒæ–‡çŒ®

1. Hughes, G. E., & Cresswell, M. J. *A New Introduction to Modal Logic*. Routledge, 1996.
2. Blackburn, P., de Rijke, M., & Venema, Y. *Modal Logic*. Cambridge University Press, 2001.
3. Chellas, B. F. *Modal Logic: An Introduction*. Cambridge University Press, 1980.
4. Kripke, S. *Semantical Considerations on Modal Logic*. Acta Philosophica Fennica, 1963.
5. van Benthem, J. *Modal Logic for Open Minds*. CSLI Publications, 2010.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [02.2.1 å‘½é¢˜é€»è¾‘](../02.2.1_å‘½é¢˜é€»è¾‘.md)
- [02.2.2 è°“è¯é€»è¾‘](../02.2.2_è°“è¯é€»è¾‘.md)
- [02.2.4 ç›´è§‰é€»è¾‘](../02.2.4_ç›´è§‰é€»è¾‘.md)
- [01.1.3 æ¨¡æ€ç†è®º](../../01_Philosophical_Foundation/01.1.3_æ¨¡æ€ç†è®º.md)
- [01.3.3 å­˜åœ¨æ¨¡æ€](../../01_Philosophical_Foundation/01.3.3_å­˜åœ¨æ¨¡æ€.md) 