# 02.2.3 Ê®°ÊÄÅÈÄªËæëÁêÜËÆ∫

## üìã Ê¶ÇËø∞

Ê®°ÊÄÅÈÄªËæëÁêÜËÆ∫ÊòØÂΩ¢ÂºèÈÄªËæëÁöÑÈáçË¶ÅÂàÜÊîØÔºåÁ†îÁ©∂ÂåÖÂê´Ê®°ÊÄÅÁÆóÂ≠êÔºàÂ¶Ç"ÂøÖÁÑ∂"„ÄÅ"ÂèØËÉΩ"ÔºâÁöÑÈÄªËæëÁ≥ªÁªü„ÄÇÊú¨ÁêÜËÆ∫‰∏∫Âì≤Â≠¶„ÄÅËÆ°ÁÆóÊú∫ÁßëÂ≠¶Âíå‰∫∫Â∑•Êô∫ËÉΩ‰∏≠ÁöÑÊ®°ÊÄÅÊé®ÁêÜÊèê‰æõÂΩ¢ÂºèÂåñÂü∫Á°ÄÔºåÊòØÁêÜËß£ÂèØËÉΩ‰∏ñÁïåËØ≠‰πâÂ≠¶ÁöÑÊ†∏ÂøÉÂ∑•ÂÖ∑„ÄÇ

## üéØ Ê†∏ÂøÉÁõÆÊ†á

1. **Âª∫Á´ãÊ®°ÊÄÅÈÄªËæëÁöÑÂΩ¢ÂºèÂåñÁêÜËÆ∫**
2. **ÂàÜÊûê‰∏çÂêåÊ®°ÊÄÅÁ≥ªÁªüÁöÑÈÄªËæëÊÄßË¥®**
3. **ÊûÑÂª∫ÂèØËÉΩ‰∏ñÁïåËØ≠‰πâÂ≠¶Ê°ÜÊû∂**
4. **Êèê‰æõÊ®°ÊÄÅÊé®ÁêÜÁöÑÂΩ¢ÂºèÂåñÊñπÊ≥ï**

## üìö ÁõÆÂΩï

1. [Âü∫Êú¨Ê¶ÇÂøµ](#1-Âü∫Êú¨Ê¶ÇÂøµ)
2. [ÂΩ¢ÂºèÂåñÂÆö‰πâ](#2-ÂΩ¢ÂºèÂåñÂÆö‰πâ)
3. [Ê®°ÊÄÅÁ≥ªÁªü](#3-Ê®°ÊÄÅÁ≥ªÁªü)
4. [ÂèØËÉΩ‰∏ñÁïåËØ≠‰πâÂ≠¶](#4-ÂèØËÉΩ‰∏ñÁïåËØ≠‰πâÂ≠¶)
5. [ÂΩ¢ÂºèÂåñËØÅÊòé](#5-ÂΩ¢ÂºèÂåñËØÅÊòé)
6. [‰ª£Á†ÅÂÆûÁé∞](#6-‰ª£Á†ÅÂÆûÁé∞)
7. [Â∫îÁî®Á§∫‰æã](#7-Â∫îÁî®Á§∫‰æã)
8. [Áõ∏ÂÖ≥ÁêÜËÆ∫](#8-Áõ∏ÂÖ≥ÁêÜËÆ∫)
9. [ÂèÇËÄÉÊñáÁåÆ](#9-ÂèÇËÄÉÊñáÁåÆ)

## 1. Âü∫Êú¨Ê¶ÇÂøµ

### 1.1 Ê®°ÊÄÅÈÄªËæëÁöÑÂÆö‰πâ

**ÂÆö‰πâ 1.1** (Ê®°ÊÄÅÈÄªËæë)
Ê®°ÊÄÅÈÄªËæëÊòØÁ†îÁ©∂ÂåÖÂê´Ê®°ÊÄÅÁÆóÂ≠êÁöÑÈÄªËæëÁ≥ªÁªüÔºåÂÖ∂‰∏≠Ê®°ÊÄÅÁÆóÂ≠êË°®Á§∫"ÂøÖÁÑ∂"„ÄÅ"ÂèØËÉΩ"Á≠âÊ¶ÇÂøµ„ÄÇ

**ÂΩ¢ÂºèÂåñÂÆö‰πâ**Ôºö
Ê®°ÊÄÅÈÄªËæëÁ≥ªÁªü $\mathcal{M}$ ÊòØ‰∏Ä‰∏™‰∫îÂÖÉÁªÑÔºö
$$\mathcal{M} = \langle \mathcal{L}, \mathcal{W}, \mathcal{R}, \mathcal{V}, \mathcal{I} \rangle$$
ÂÖ∂‰∏≠Ôºö
- $\mathcal{L}$ ÊòØÊ®°ÊÄÅËØ≠Ë®Ä
- $\mathcal{W}$ ÊòØÂèØËÉΩ‰∏ñÁïåÈõÜÂêà
- $\mathcal{R} \subseteq \mathcal{W} \times \mathcal{W}$ ÊòØÂèØÂèäÂÖ≥Á≥ª
- $\mathcal{V}$ ÊòØËµãÂÄºÂáΩÊï∞
- $\mathcal{I}$ ÊòØËß£ÈáäÂáΩÊï∞

### 1.2 Ê®°ÊÄÅÁÆóÂ≠ê

**ÂÆö‰πâ 1.2** (Ê®°ÊÄÅÁÆóÂ≠ê)
Ê®°ÊÄÅÈÄªËæëÂåÖÂê´‰ª•‰∏ãÂü∫Êú¨Ê®°ÊÄÅÁÆóÂ≠êÔºö
- **ÂøÖÁÑ∂ÁÆóÂ≠ê** $\square$ÔºöË°®Á§∫"ÂøÖÁÑ∂"
- **ÂèØËÉΩÁÆóÂ≠ê** $\diamond$ÔºöË°®Á§∫"ÂèØËÉΩ"

**ÂÖ≥Á≥ª**Ôºö
$$\diamond \phi \iff \neg \square \neg \phi$$
$$\square \phi \iff \neg \diamond \neg \phi$$

### 1.3 Ê®°ÊÄÅÂÖ¨Âºè

**ÂÆö‰πâ 1.3** (Ê®°ÊÄÅÂÖ¨Âºè)
Ê®°ÊÄÅÂÖ¨ÂºèÊòØÈÄíÂΩíÂÆö‰πâÁöÑÔºö
1. ÂéüÂ≠êÂëΩÈ¢òÊòØÊ®°ÊÄÅÂÖ¨Âºè
2. Â¶ÇÊûú $\phi$ ÊòØÊ®°ÊÄÅÂÖ¨ÂºèÔºåÂàô $\neg\phi$ ÊòØÊ®°ÊÄÅÂÖ¨Âºè
3. Â¶ÇÊûú $\phi$ Âíå $\psi$ ÊòØÊ®°ÊÄÅÂÖ¨ÂºèÔºåÂàô $(\phi \land \psi)$, $(\phi \lor \psi)$, $(\phi \rightarrow \psi)$, $(\phi \leftrightarrow \psi)$ ÊòØÊ®°ÊÄÅÂÖ¨Âºè
4. Â¶ÇÊûú $\phi$ ÊòØÊ®°ÊÄÅÂÖ¨ÂºèÔºåÂàô $\square\phi$ Âíå $\diamond\phi$ ÊòØÊ®°ÊÄÅÂÖ¨Âºè

## 2. ÂΩ¢ÂºèÂåñÂÆö‰πâ

### 2.1 Ê®°ÊÄÅÊ°ÜÊû∂

**ÂÆö‰πâ 2.1** (Ê®°ÊÄÅÊ°ÜÊû∂)
Ê®°ÊÄÅÊ°ÜÊû∂ÊòØ‰∏Ä‰∏™‰∫åÂÖÉÁªÑ $\mathcal{F} = \langle W, R \rangle$ÔºåÂÖ∂‰∏≠Ôºö
- $W$ ÊòØÂèØËÉΩ‰∏ñÁïåÈõÜÂêà
- $R \subseteq W \times W$ ÊòØÂèØÂèäÂÖ≥Á≥ª

**ÂèØÂèäÂÖ≥Á≥ªÊÄßË¥®**Ôºö
- **Ëá™ÂèçÊÄß**Ôºö$\forall w \in W: wRw$
- **ÂØπÁß∞ÊÄß**Ôºö$\forall w, v \in W: wRv \Rightarrow vRw$
- **‰º†ÈÄíÊÄß**Ôºö$\forall w, v, u \in W: wRv \land vRu \Rightarrow wRu$
- **Ê¨ßÂá†ÈáåÂæóÊÄß**Ôºö$\forall w, v, u \in W: wRv \land wRu \Rightarrow vRu$

### 2.2 Ê®°ÊÄÅÊ®°Âûã

**ÂÆö‰πâ 2.2** (Ê®°ÊÄÅÊ®°Âûã)
Ê®°ÊÄÅÊ®°ÂûãÊòØ‰∏Ä‰∏™‰∏âÂÖÉÁªÑ $\mathcal{M} = \langle W, R, V \rangle$ÔºåÂÖ∂‰∏≠Ôºö
- $\langle W, R \rangle$ ÊòØÊ®°ÊÄÅÊ°ÜÊû∂
- $V: \text{Prop} \times W \rightarrow \mathbb{B}$ ÊòØËµãÂÄºÂáΩÊï∞

### 2.3 Êª°Ë∂≥ÂÖ≥Á≥ª

**ÂÆö‰πâ 2.3** (Êª°Ë∂≥ÂÖ≥Á≥ª)
Ê®°ÊÄÅÊ®°Âûã $\mathcal{M}$ Âú®‰∏ñÁïå $w$ ‰∏≠Êª°Ë∂≥ÂÖ¨Âºè $\phi$ÔºåËÆ∞‰Ωú $\mathcal{M}, w \models \phi$ÔºåÂÆö‰πâ‰∏∫Ôºö
1. $\mathcal{M}, w \models p$ ÂΩì‰∏î‰ªÖÂΩì $V(p, w) = \text{true}$
2. $\mathcal{M}, w \models \neg\phi$ ÂΩì‰∏î‰ªÖÂΩì $\mathcal{M}, w \not\models \phi$
3. $\mathcal{M}, w \models \phi \land \psi$ ÂΩì‰∏î‰ªÖÂΩì $\mathcal{M}, w \models \phi$ ‰∏î $\mathcal{M}, w \models \psi$
4. $\mathcal{M}, w \models \phi \lor \psi$ ÂΩì‰∏î‰ªÖÂΩì $\mathcal{M}, w \models \phi$ Êàñ $\mathcal{M}, w \models \psi$
5. $\mathcal{M}, w \models \phi \rightarrow \psi$ ÂΩì‰∏î‰ªÖÂΩì $\mathcal{M}, w \not\models \phi$ Êàñ $\mathcal{M}, w \models \psi$
6. $\mathcal{M}, w \models \square\phi$ ÂΩì‰∏î‰ªÖÂΩì $\forall v \in W: wRv \Rightarrow \mathcal{M}, v \models \phi$
7. $\mathcal{M}, w \models \diamond\phi$ ÂΩì‰∏î‰ªÖÂΩì $\exists v \in W: wRv \land \mathcal{M}, v \models \phi$

## 3. Ê®°ÊÄÅÁ≥ªÁªü

### 3.1 Âü∫Êú¨Ê®°ÊÄÅÁ≥ªÁªü

**ÂÆö‰πâ 3.1** (Âü∫Êú¨Ê®°ÊÄÅÁ≥ªÁªü)
Âü∫Êú¨Ê®°ÊÄÅÁ≥ªÁªüÂåÖÂê´‰ª•‰∏ãÂÖ¨ÁêÜÂíåËßÑÂàôÔºö

**ÂÖ¨ÁêÜ**Ôºö
- **KÂÖ¨ÁêÜ**Ôºö$\square(\phi \rightarrow \psi) \rightarrow (\square\phi \rightarrow \square\psi)$
- **TÂÖ¨ÁêÜ**Ôºö$\square\phi \rightarrow \phi$
- **4ÂÖ¨ÁêÜ**Ôºö$\square\phi \rightarrow \square\square\phi$
- **5ÂÖ¨ÁêÜ**Ôºö$\diamond\phi \rightarrow \square\diamond\phi$
- **BÂÖ¨ÁêÜ**Ôºö$\phi \rightarrow \square\diamond\phi$
- **DÂÖ¨ÁêÜ**Ôºö$\square\phi \rightarrow \diamond\phi$

**Êé®ÁêÜËßÑÂàô**Ôºö
- **ÂàÜÁ¶ªËßÑÂàô**Ôºö$\phi, \phi \rightarrow \psi \vdash \psi$
- **ÂøÖÁÑ∂ÂåñËßÑÂàô**Ôºö$\phi \vdash \square\phi$

### 3.2 Â∏∏ËßÅÊ®°ÊÄÅÁ≥ªÁªü

**ÂÆö‰πâ 3.2** (Â∏∏ËßÅÊ®°ÊÄÅÁ≥ªÁªü)
1. **KÁ≥ªÁªü**ÔºöÂè™ÂåÖÂê´KÂÖ¨ÁêÜ
2. **TÁ≥ªÁªü**ÔºöK + TÂÖ¨ÁêÜ
3. **S4Á≥ªÁªü**ÔºöK + T + 4ÂÖ¨ÁêÜ
4. **S5Á≥ªÁªü**ÔºöK + T + 4 + 5ÂÖ¨ÁêÜ
5. **BÁ≥ªÁªü**ÔºöK + T + BÂÖ¨ÁêÜ
6. **DÁ≥ªÁªü**ÔºöK + DÂÖ¨ÁêÜ

### 3.3 ÂØπÂ∫îÁêÜËÆ∫

**ÂÆö‰πâ 3.3** (ÂØπÂ∫îÁêÜËÆ∫)
Ê®°ÊÄÅÂÖ¨ÁêÜ‰∏éÂèØÂèäÂÖ≥Á≥ªÊÄßË¥®ÂØπÂ∫îÔºö
- **TÂÖ¨ÁêÜ** $\leftrightarrow$ Ëá™ÂèçÊÄß
- **4ÂÖ¨ÁêÜ** $\leftrightarrow$ ‰º†ÈÄíÊÄß
- **5ÂÖ¨ÁêÜ** $\leftrightarrow$ Ê¨ßÂá†ÈáåÂæóÊÄß
- **BÂÖ¨ÁêÜ** $\leftrightarrow$ ÂØπÁß∞ÊÄß
- **DÂÖ¨ÁêÜ** $\leftrightarrow$ Â∫èÂàóÊÄß

## 4. ÂèØËÉΩ‰∏ñÁïåËØ≠‰πâÂ≠¶

### 4.1 ÂèØËÉΩ‰∏ñÁïå

**ÂÆö‰πâ 4.1** (ÂèØËÉΩ‰∏ñÁïå)
ÂèØËÉΩ‰∏ñÁïåÊòØÈÄªËæë‰∏ä‰∏ÄËá¥ÁöÑ‰∏ñÁïåÁä∂ÊÄÅÔºåÁî® $w \in W$ Ë°®Á§∫„ÄÇ

**ÂèØËÉΩ‰∏ñÁïåÊÄßË¥®**Ôºö
- **ÈÄªËæë‰∏ÄËá¥ÊÄß**ÔºöÊØè‰∏™ÂèØËÉΩ‰∏ñÁïåÂÜÖÈÉ®ÈÄªËæë‰∏ÄËá¥
- **ÂÆåÂ§áÊÄß**ÔºöÊØè‰∏™ÂèØËÉΩ‰∏ñÁïåÂåÖÂê´ÊâÄÊúâÁõ∏ÂÖ≥ÂëΩÈ¢òÁöÑÁúüÂÄº
- **ÂèØÂèäÊÄß**Ôºö‰∏ñÁïåÈó¥ÈÄöËøáÂèØÂèäÂÖ≥Á≥ªËøûÊé•

### 4.2 ÂèØÂèäÂÖ≥Á≥ª

**ÂÆö‰πâ 4.2** (ÂèØÂèäÂÖ≥Á≥ª)
ÂèØÂèäÂÖ≥Á≥ª $R$ Ë°®Á§∫ÂèØËÉΩ‰∏ñÁïå‰πãÈó¥ÁöÑÂèØËææÊÄßÔºö
$$w_1 R w_2 \iff w_2 \text{ is accessible from } w_1$$

**ÂèØÂèäÂÖ≥Á≥ªÁ±ªÂûã**Ôºö
- **Á≠â‰ª∑ÂÖ≥Á≥ª**ÔºöËá™Âèç„ÄÅÂØπÁß∞„ÄÅ‰º†ÈÄí
- **ÂÅèÂ∫èÂÖ≥Á≥ª**ÔºöËá™Âèç„ÄÅÂèçÂØπÁß∞„ÄÅ‰º†ÈÄí
- **È¢ÑÂ∫èÂÖ≥Á≥ª**ÔºöËá™Âèç„ÄÅ‰º†ÈÄí

### 4.3 ËµãÂÄºÂáΩÊï∞

**ÂÆö‰πâ 4.3** (ËµãÂÄºÂáΩÊï∞)
ËµãÂÄºÂáΩÊï∞ $V$ Â∞ÜÂëΩÈ¢òÊò†Â∞ÑÂà∞ÂèØËÉΩ‰∏ñÁïåÁöÑÁúüÂÄºÔºö
$$V: \text{Prop} \times W \rightarrow \mathbb{B}$$

**ËµãÂÄºÊÄßË¥®**Ôºö
- **Â±ÄÈÉ®ÊÄß**ÔºöÊØè‰∏™‰∏ñÁïåÁöÑËµãÂÄºÁã¨Á´ã
- **‰∏ÄËá¥ÊÄß**ÔºöÂêå‰∏Ä‰∏ñÁïåÂÜÖËµãÂÄº‰∏ÄËá¥
- **ÂèØÊâ©Â±ïÊÄß**ÔºöÂèØ‰ª•Êâ©Â±ïÂà∞Â§çÊùÇÂÖ¨Âºè

## 5. ÂΩ¢ÂºèÂåñËØÅÊòé

### 5.1 ÂÆåÂ§áÊÄßÂÆöÁêÜ

**ÂÆöÁêÜ 5.1** (Ê®°ÊÄÅÈÄªËæëÂÆåÂ§áÊÄß)
ÂØπ‰∫éÊØè‰∏™Ê®°ÊÄÅÁ≥ªÁªü $S$ÔºåÂ¶ÇÊûú $\Gamma \models_S \phi$ÔºåÂàô $\Gamma \vdash_S \phi$„ÄÇ

**ËØÅÊòé**Ôºö
1. ÊûÑÈÄ†ÂÖ∏ËåÉÊ®°Âûã
2. ËØÅÊòéÂÖ∏ËåÉÊ®°ÂûãÊª°Ë∂≥ÊâÄÊúâÂèØÊª°Ë∂≥ÁöÑÂÖ¨ÂºèÈõÜ
3. Âà©Áî®Á¥ßËá¥ÊÄßÂÆöÁêÜÂÆåÊàêËØÅÊòé

### 5.2 Á¥ßËá¥ÊÄßÂÆöÁêÜ

**ÂÆöÁêÜ 5.2** (Ê®°ÊÄÅÈÄªËæëÁ¥ßËá¥ÊÄß)
Â¶ÇÊûúÂÖ¨ÂºèÈõÜ $\Gamma$ ÁöÑÊØè‰∏™ÊúâÈôêÂ≠êÈõÜÈÉΩÊòØÂèØÊª°Ë∂≥ÁöÑÔºåÂàô $\Gamma$ Êú¨Ë∫´ÊòØÂèØÊª°Ë∂≥ÁöÑ„ÄÇ

**ËØÅÊòé**Ôºö
1. Âà©Áî®Ë∂ÖÁßØÊûÑÈÄ†
2. Â∫îÁî®Ë∂ÖÊª§Â≠êÁêÜËÆ∫
3. ËØÅÊòéÊûÑÈÄ†ÁöÑÊ®°ÂûãÊª°Ë∂≥ $\Gamma$

### 5.3 ÂØπÂ∫îÂÆöÁêÜ

**ÂÆöÁêÜ 5.3** (ÂØπÂ∫îÂÆöÁêÜ)
Ê®°ÊÄÅÂÖ¨ÁêÜ‰∏éÂèØÂèäÂÖ≥Á≥ªÊÄßË¥®‰πãÈó¥Â≠òÂú®ÂØπÂ∫îÂÖ≥Á≥ª„ÄÇ

**ËØÅÊòé**Ôºö
1. ËØÅÊòéÂÖ¨ÁêÜËï¥Âê´ÂÖ≥Á≥ªÊÄßË¥®
2. ËØÅÊòéÂÖ≥Á≥ªÊÄßË¥®Ëï¥Âê´ÂÖ¨ÁêÜ
3. ÊûÑÈÄ†Âèç‰æãËØÅÊòéÂøÖË¶ÅÊÄß

### 5.4 ÂèØÂà§ÂÆöÊÄßÂÆöÁêÜ

**ÂÆöÁêÜ 5.4** (ÂèØÂà§ÂÆöÊÄß)
Âü∫Êú¨Ê®°ÊÄÅÈÄªËæëÊòØÂèØÂà§ÂÆöÁöÑ„ÄÇ

**ËØÅÊòé**Ôºö
1. Âà©Áî®ÊúâÈôêÊ®°ÂûãÊÄßË¥®
2. ÊûÑÈÄ†ÊúâÁïåÊ®°ÂûãÊ£ÄÊü•ÁÆóÊ≥ï
3. ËØÅÊòéÁÆóÊ≥ïÁöÑÊ≠£Á°ÆÊÄßÂíåÁªàÊ≠¢ÊÄß

## 6. ‰ª£Á†ÅÂÆûÁé∞

### 6.1 Rust ÂÆûÁé∞

```rust
use std::collections::{HashMap, HashSet};
use std::fmt;

/// ÂëΩÈ¢ò
#[derive(Debug, Clone, Hash, Eq, PartialEq)]
pub struct Proposition {
    name: String,
}

impl Proposition {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

/// Ê®°ÊÄÅÂÖ¨Âºè
#[derive(Debug, Clone)]
pub enum ModalFormula {
    Proposition(Proposition),
    Negation(Box<ModalFormula>),
    Conjunction(Box<ModalFormula>, Box<ModalFormula>),
    Disjunction(Box<ModalFormula>, Box<ModalFormula>),
    Implication(Box<ModalFormula>, Box<ModalFormula>),
    Equivalence(Box<ModalFormula>, Box<ModalFormula>),
    Necessity(Box<ModalFormula>),
    Possibility(Box<ModalFormula>),
}

impl ModalFormula {
    pub fn proposition(name: String) -> Self {
        ModalFormula::Proposition(Proposition::new(name))
    }

    pub fn negation(formula: ModalFormula) -> Self {
        ModalFormula::Negation(Box::new(formula))
    }

    pub fn conjunction(left: ModalFormula, right: ModalFormula) -> Self {
        ModalFormula::Conjunction(Box::new(left), Box::new(right))
    }

    pub fn disjunction(left: ModalFormula, right: ModalFormula) -> Self {
        ModalFormula::Disjunction(Box::new(left), Box::new(right))
    }

    pub fn implication(antecedent: ModalFormula, consequent: ModalFormula) -> Self {
        ModalFormula::Implication(Box::new(antecedent), Box::new(consequent))
    }

    pub fn equivalence(left: ModalFormula, right: ModalFormula) -> Self {
        ModalFormula::Equivalence(Box::new(left), Box::new(right))
    }

    pub fn necessity(formula: ModalFormula) -> Self {
        ModalFormula::Necessity(Box::new(formula))
    }

    pub fn possibility(formula: ModalFormula) -> Self {
        ModalFormula::Possibility(Box::new(formula))
    }

    /// ËΩ¨Êç¢‰∏∫Âê¶ÂÆöËåÉÂºè
    pub fn to_negation_normal_form(&self) -> ModalFormula {
        match self {
            ModalFormula::Proposition(p) => ModalFormula::Proposition(p.clone()),
            ModalFormula::Negation(formula) => match formula.as_ref() {
                ModalFormula::Proposition(p) => ModalFormula::Negation(Box::new(ModalFormula::Proposition(p.clone()))),
                ModalFormula::Negation(f) => f.to_negation_normal_form(),
                ModalFormula::Conjunction(left, right) => {
                    ModalFormula::Disjunction(
                        Box::new(ModalFormula::negation(left.clone())),
                        Box::new(ModalFormula::negation(right.clone()))
                    )
                }
                ModalFormula::Disjunction(left, right) => {
                    ModalFormula::Conjunction(
                        Box::new(ModalFormula::negation(left.clone())),
                        Box::new(ModalFormula::negation(right.clone()))
                    )
                }
                ModalFormula::Necessity(f) => ModalFormula::Possibility(Box::new(ModalFormula::negation(f.clone()))),
                ModalFormula::Possibility(f) => ModalFormula::Necessity(Box::new(ModalFormula::negation(f.clone()))),
                _ => self.clone(),
            },
            ModalFormula::Conjunction(left, right) => {
                ModalFormula::Conjunction(
                    Box::new(left.to_negation_normal_form()),
                    Box::new(right.to_negation_normal_form())
                )
            }
            ModalFormula::Disjunction(left, right) => {
                ModalFormula::Disjunction(
                    Box::new(left.to_negation_normal_form()),
                    Box::new(right.to_negation_normal_form())
                )
            }
            ModalFormula::Implication(antecedent, consequent) => {
                ModalFormula::Disjunction(
                    Box::new(ModalFormula::negation(antecedent.clone())),
                    Box::new(consequent.clone())
                ).to_negation_normal_form()
            }
            ModalFormula::Equivalence(left, right) => {
                ModalFormula::Conjunction(
                    Box::new(ModalFormula::implication(left.clone(), right.clone())),
                    Box::new(ModalFormula::implication(right.clone(), left.clone()))
                ).to_negation_normal_form()
            }
            ModalFormula::Necessity(formula) => {
                ModalFormula::Necessity(Box::new(formula.to_negation_normal_form()))
            }
            ModalFormula::Possibility(formula) => {
                ModalFormula::Possibility(Box::new(formula.to_negation_normal_form()))
            }
        }
    }
}

/// ÂèØËÉΩ‰∏ñÁïå
#[derive(Debug, Clone, Hash, Eq, PartialEq)]
pub struct PossibleWorld {
    id: String,
    propositions: HashSet<Proposition>,
}

impl PossibleWorld {
    pub fn new(id: String) -> Self {
        Self {
            id,
            propositions: HashSet::new(),
        }
    }

    pub fn add_proposition(&mut self, proposition: Proposition) {
        self.propositions.insert(proposition);
    }

    pub fn has_proposition(&self, proposition: &Proposition) -> bool {
        self.propositions.contains(proposition)
    }
}

/// ÂèØÂèäÂÖ≥Á≥ª
#[derive(Debug, Clone)]
pub struct AccessibilityRelation {
    relations: HashSet<(PossibleWorld, PossibleWorld)>,
}

impl AccessibilityRelation {
    pub fn new() -> Self {
        Self {
            relations: HashSet::new(),
        }
    }

    pub fn add_relation(&mut self, from: PossibleWorld, to: PossibleWorld) {
        self.relations.insert((from, to));
    }

    pub fn is_accessible(&self, from: &PossibleWorld, to: &PossibleWorld) -> bool {
        self.relations.contains(&(from.clone(), to.clone()))
    }

    pub fn get_accessible_worlds(&self, from: &PossibleWorld) -> Vec<&PossibleWorld> {
        self.relations.iter()
            .filter(|(w1, _)| w1 == from)
            .map(|(_, w2)| w2)
            .collect()
    }

    /// Ê£ÄÊü•Ëá™ÂèçÊÄß
    pub fn is_reflexive(&self) -> bool {
        self.relations.iter().all(|(w1, w2)| w1 == w2)
    }

    /// Ê£ÄÊü•ÂØπÁß∞ÊÄß
    pub fn is_symmetric(&self) -> bool {
        self.relations.iter().all(|(w1, w2)| {
            self.relations.contains(&(w2.clone(), w1.clone()))
        })
    }

    /// Ê£ÄÊü•‰º†ÈÄíÊÄß
    pub fn is_transitive(&self) -> bool {
        self.relations.iter().all(|(w1, w2)| {
            self.get_accessible_worlds(w2).iter().all(|w3| {
                self.relations.contains(&(w1.clone(), (*w3).clone()))
            })
        })
    }
}

/// Ê®°ÊÄÅÊ®°Âûã
#[derive(Debug, Clone)]
pub struct ModalModel {
    worlds: Vec<PossibleWorld>,
    accessibility: AccessibilityRelation,
}

impl ModalModel {
    pub fn new() -> Self {
        Self {
            worlds: Vec::new(),
            accessibility: AccessibilityRelation::new(),
        }
    }

    pub fn add_world(&mut self, world: PossibleWorld) {
        self.worlds.push(world);
    }

    pub fn add_accessibility(&mut self, from: PossibleWorld, to: PossibleWorld) {
        self.accessibility.add_relation(from, to);
    }

    /// ËØÑ‰º∞ÂÖ¨Âºè
    pub fn evaluate(&self, formula: &ModalFormula, world: &PossibleWorld) -> bool {
        match formula {
            ModalFormula::Proposition(p) => world.has_proposition(p),
            ModalFormula::Negation(f) => !self.evaluate(f, world),
            ModalFormula::Conjunction(left, right) => {
                self.evaluate(left, world) && self.evaluate(right, world)
            }
            ModalFormula::Disjunction(left, right) => {
                self.evaluate(left, world) || self.evaluate(right, world)
            }
            ModalFormula::Implication(antecedent, consequent) => {
                !self.evaluate(antecedent, world) || self.evaluate(consequent, world)
            }
            ModalFormula::Equivalence(left, right) => {
                self.evaluate(left, world) == self.evaluate(right, world)
            }
            ModalFormula::Necessity(f) => {
                self.accessibility.get_accessible_worlds(world).iter()
                    .all(|w| self.evaluate(f, w))
            }
            ModalFormula::Possibility(f) => {
                self.accessibility.get_accessible_worlds(world).iter()
                    .any(|w| self.evaluate(f, w))
            }
        }
    }

    /// Ê£ÄÊü•ÂÖ¨ÂºèÊúâÊïàÊÄß
    pub fn is_valid(&self, formula: &ModalFormula) -> bool {
        self.worlds.iter().all(|world| self.evaluate(formula, world))
    }

    /// Ê£ÄÊü•ÂÖ¨ÂºèÂèØÊª°Ë∂≥ÊÄß
    pub fn is_satisfiable(&self, formula: &ModalFormula) -> bool {
        self.worlds.iter().any(|world| self.evaluate(formula, world))
    }
}

/// Ê®°ÊÄÅÈÄªËæëÊé®ÁêÜÂô®
#[derive(Debug, Clone)]
pub struct ModalLogicReasoner {
    model: ModalModel,
}

impl ModalLogicReasoner {
    pub fn new(model: ModalModel) -> Self {
        Self { model }
    }

    /// Ê£ÄÊü•ÂÖ¨ÁêÜ
    pub fn check_axiom_k(&self, phi: &ModalFormula, psi: &ModalFormula) -> bool {
        let axiom = ModalFormula::implication(
            ModalFormula::necessity(ModalFormula::implication(phi.clone(), psi.clone())),
            ModalFormula::implication(
                ModalFormula::necessity(phi.clone()),
                ModalFormula::necessity(psi.clone())
            )
        );
        self.model.is_valid(&axiom)
    }

    pub fn check_axiom_t(&self, phi: &ModalFormula) -> bool {
        let axiom = ModalFormula::implication(
            ModalFormula::necessity(phi.clone()),
            phi.clone()
        );
        self.model.is_valid(&axiom)
    }

    pub fn check_axiom_4(&self, phi: &ModalFormula) -> bool {
        let axiom = ModalFormula::implication(
            ModalFormula::necessity(phi.clone()),
            ModalFormula::necessity(ModalFormula::necessity(phi.clone()))
        );
        self.model.is_valid(&axiom)
    }

    pub fn check_axiom_5(&self, phi: &ModalFormula) -> bool {
        let axiom = ModalFormula::implication(
            ModalFormula::possibility(phi.clone()),
            ModalFormula::necessity(ModalFormula::possibility(phi.clone()))
        );
        self.model.is_valid(&axiom)
    }

    /// Ê£ÄÊü•ÈÄªËæëËï¥Ê∂µ
    pub fn entails(&self, premises: &[ModalFormula], conclusion: &ModalFormula) -> bool {
        // ÁÆÄÂåñÁâàÊú¨ÔºöÊ£ÄÊü•ÊâÄÊúâÂâçÊèê‰∏∫ÁúüÊó∂ÁªìËÆ∫ÊòØÂê¶‰∏∫Áúü
        self.model.worlds.iter().all(|world| {
            let all_premises_true = premises.iter()
                .all(|premise| self.model.evaluate(premise, world));
            
            if all_premises_true {
                self.model.evaluate(conclusion, world)
            } else {
                true // Â¶ÇÊûúÂâçÊèê‰∏çÈÉΩ‰∏∫ÁúüÔºåÂàôËï¥Ê∂µÊàêÁ´ã
            }
        })
    }

    /// Ê®°ÊÄÅÊé®ÁêÜÔºö‰ªéÂøÖÁÑ∂Êé®Âá∫ÂèØËÉΩ
    pub fn necessity_implies_possibility(&self, phi: &ModalFormula) -> bool {
        let implication = ModalFormula::implication(
            ModalFormula::necessity(phi.clone()),
            ModalFormula::possibility(phi.clone())
        );
        self.model.is_valid(&implication)
    }

    /// Ê®°ÊÄÅÊé®ÁêÜÔºö‰ªéÂèØËÉΩÊé®Âá∫ÂøÖÁÑ∂ÔºàÂú®S5Á≥ªÁªü‰∏≠Ôºâ
    pub fn possibility_implies_necessity(&self, phi: &ModalFormula) -> bool {
        let implication = ModalFormula::implication(
            ModalFormula::possibility(phi.clone()),
            ModalFormula::necessity(phi.clone())
        );
        self.model.is_valid(&implication)
    }
}

/// Ê®°ÊÄÅÁ≥ªÁªüÊûÑÈÄ†Âô®
#[derive(Debug, Clone)]
pub struct ModalSystemBuilder {
    model: ModalModel,
}

impl ModalSystemBuilder {
    pub fn new() -> Self {
        Self {
            model: ModalModel::new(),
        }
    }

    pub fn add_world(mut self, world: PossibleWorld) -> Self {
        self.model.add_world(world);
        self
    }

    pub fn add_accessibility(mut self, from: PossibleWorld, to: PossibleWorld) -> Self {
        self.model.add_accessibility(from, to);
        self
    }

    pub fn build(self) -> ModalModel {
        self.model
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_modal_logic() {
        // ÂàõÂª∫Ê®°ÊÄÅÊ®°Âûã
        let mut model = ModalModel::new();
        
        // ÂàõÂª∫ÂèØËÉΩ‰∏ñÁïå
        let mut world1 = PossibleWorld::new("w1".to_string());
        let mut world2 = PossibleWorld::new("w2".to_string());
        
        // Ê∑ªÂä†ÂëΩÈ¢ò
        let p = Proposition::new("p".to_string());
        let q = Proposition::new("q".to_string());
        
        world1.add_proposition(p.clone());
        world2.add_proposition(q.clone());
        
        model.add_world(world1.clone());
        model.add_world(world2.clone());
        
        // Ê∑ªÂä†ÂèØÂèäÂÖ≥Á≥ª
        model.add_accessibility(world1.clone(), world1.clone());
        model.add_accessibility(world1.clone(), world2.clone());
        model.add_accessibility(world2.clone(), world2.clone());
        
        // ÂàõÂª∫Êé®ÁêÜÂô®
        let reasoner = ModalLogicReasoner::new(model);
        
        // ÊµãËØïÂÖ¨Âºè
        let phi = ModalFormula::proposition("p".to_string());
        let psi = ModalFormula::proposition("q".to_string());
        
        // ÊµãËØïÂÖ¨ÁêÜ
        assert!(reasoner.check_axiom_k(&phi, &psi));
        assert!(reasoner.check_axiom_t(&phi));
        
        // ÊµãËØïÊ®°ÊÄÅÊé®ÁêÜ
        assert!(reasoner.necessity_implies_possibility(&phi));
    }

    #[test]
    fn test_negation_normal_form() {
        let p = ModalFormula::proposition("p".to_string());
        let q = ModalFormula::proposition("q".to_string());
        
        let formula = ModalFormula::implication(p, q);
        let nnf = formula.to_negation_normal_form();
        
        // È™åËØÅÂê¶ÂÆöËåÉÂºè‰∏çÂåÖÂê´Ëï¥Âê´
        match nnf {
            ModalFormula::Disjunction(_, _) => assert!(true),
            _ => assert!(false, "Should be disjunction"),
        }
    }
}
```

### 6.2 Haskell ÂÆûÁé∞

```haskell
module ModalLogic where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Maybe (fromMaybe)

-- ÂëΩÈ¢ò
data Proposition = Proposition String deriving (Show, Eq, Ord)

-- Ê®°ÊÄÅÂÖ¨Âºè
data ModalFormula = Prop Proposition
                  | Negation ModalFormula
                  | Conjunction ModalFormula ModalFormula
                  | Disjunction ModalFormula ModalFormula
                  | Implication ModalFormula ModalFormula
                  | Equivalence ModalFormula ModalFormula
                  | Necessity ModalFormula
                  | Possibility ModalFormula
                  deriving (Show, Eq)

-- ÂèØËÉΩ‰∏ñÁïå
data PossibleWorld = PossibleWorld
    { worldId :: String
    , propositions :: Set Proposition
    } deriving (Show, Eq, Ord)

-- ÂèØÂèäÂÖ≥Á≥ª
data AccessibilityRelation = AccessibilityRelation
    { relations :: Set (PossibleWorld, PossibleWorld)
    } deriving (Show, Eq)

-- Ê®°ÊÄÅÊ®°Âûã
data ModalModel = ModalModel
    { worlds :: [PossibleWorld]
    , accessibility :: AccessibilityRelation
    } deriving (Show, Eq)

-- ÂàõÂª∫Á©∫Ê®°ÊÄÅÊ®°Âûã
emptyModalModel :: ModalModel
emptyModalModel = ModalModel [] (AccessibilityRelation Set.empty)

-- Ê∑ªÂä†‰∏ñÁïå
addWorld :: PossibleWorld -> ModalModel -> ModalModel
addWorld world model = model { worlds = world : worlds model }

-- Ê∑ªÂä†ÂèØÂèäÂÖ≥Á≥ª
addAccessibility :: PossibleWorld -> PossibleWorld -> ModalModel -> ModalModel
addAccessibility from to model = model
    { accessibility = AccessibilityRelation (Set.insert (from, to) (relations (accessibility model)))
    }

-- Ê£ÄÊü•ÂèØÂèäÊÄß
isAccessible :: PossibleWorld -> PossibleWorld -> AccessibilityRelation -> Bool
isAccessible from to relation = Set.member (from, to) (relations relation)

-- Ëé∑ÂèñÂèØÂèä‰∏ñÁïå
getAccessibleWorlds :: PossibleWorld -> AccessibilityRelation -> [PossibleWorld]
getAccessibleWorlds world relation = 
    [w2 | (w1, w2) <- Set.toList (relations relation), w1 == world]

-- Ê£ÄÊü•Ëá™ÂèçÊÄß
isReflexive :: AccessibilityRelation -> Bool
isReflexive relation = all (\(w1, w2) -> w1 == w2) (Set.toList (relations relation))

-- Ê£ÄÊü•ÂØπÁß∞ÊÄß
isSymmetric :: AccessibilityRelation -> Bool
isSymmetric relation = all (\(w1, w2) -> Set.member (w2, w1) (relations relation)) (Set.toList (relations relation))

-- Ê£ÄÊü•‰º†ÈÄíÊÄß
isTransitive :: AccessibilityRelation -> Bool
isTransitive relation = 
    all (\(w1, w2) -> 
        all (\w3 -> Set.member (w1, w3) (relations relation)) 
            (getAccessibleWorlds w2 relation)
    ) (Set.toList (relations relation))

-- ËØÑ‰º∞ÂÖ¨Âºè
evaluate :: ModalFormula -> PossibleWorld -> ModalModel -> Bool
evaluate (Prop p) world _ = Set.member p (propositions world)
evaluate (Negation f) world model = not (evaluate f world model)
evaluate (Conjunction left right) world model = 
    evaluate left world model && evaluate right world model
evaluate (Disjunction left right) world model = 
    evaluate left world model || evaluate right world model
evaluate (Implication antecedent consequent) world model = 
    not (evaluate antecedent world model) || evaluate consequent world model
evaluate (Equivalence left right) world model = 
    evaluate left world model == evaluate right world model
evaluate (Necessity f) world model = 
    all (\w -> evaluate f w model) (getAccessibleWorlds world (accessibility model))
evaluate (Possibility f) world model = 
    any (\w -> evaluate f w model) (getAccessibleWorlds world (accessibility model))

-- Ê£ÄÊü•ÂÖ¨ÂºèÊúâÊïàÊÄß
isValid :: ModalFormula -> ModalModel -> Bool
isValid formula model = all (\world -> evaluate formula world model) (worlds model)

-- Ê£ÄÊü•ÂÖ¨ÂºèÂèØÊª°Ë∂≥ÊÄß
isSatisfiable :: ModalFormula -> ModalModel -> Bool
isSatisfiable formula model = any (\world -> evaluate formula world model) (worlds model)

-- ËΩ¨Êç¢‰∏∫Âê¶ÂÆöËåÉÂºè
toNegationNormalForm :: ModalFormula -> ModalFormula
toNegationNormalForm (Prop p) = Prop p
toNegationNormalForm (Negation f) = case f of
    Prop p -> Negation (Prop p)
    Negation g -> toNegationNormalForm g
    Conjunction left right -> 
        Disjunction (toNegationNormalForm (Negation left)) (toNegationNormalForm (Negation right))
    Disjunction left right -> 
        Conjunction (toNegationNormalForm (Negation left)) (toNegationNormalForm (Negation right))
    Necessity g -> Possibility (toNegationNormalForm (Negation g))
    Possibility g -> Necessity (toNegationNormalForm (Negation g))
    _ -> Negation (toNegationNormalForm f)
toNegationNormalForm (Conjunction left right) = 
    Conjunction (toNegationNormalForm left) (toNegationNormalForm right)
toNegationNormalForm (Disjunction left right) = 
    Disjunction (toNegationNormalForm left) (toNegationNormalForm right)
toNegationNormalForm (Implication antecedent consequent) = 
    toNegationNormalForm (Disjunction (Negation antecedent) consequent)
toNegationNormalForm (Equivalence left right) = 
    toNegationNormalForm (Conjunction 
        (Implication left right) 
        (Implication right left))
toNegationNormalForm (Necessity f) = Necessity (toNegationNormalForm f)
toNegationNormalForm (Possibility f) = Possibility (toNegationNormalForm f)

-- Ê®°ÊÄÅÈÄªËæëÊé®ÁêÜÂô®
data ModalLogicReasoner = ModalLogicReasoner
    { model :: ModalModel
    } deriving (Show, Eq)

-- Ê£ÄÊü•ÂÖ¨ÁêÜK
checkAxiomK :: ModalFormula -> ModalFormula -> ModalLogicReasoner -> Bool
checkAxiomK phi psi reasoner = 
    let axiom = Implication 
        (Necessity (Implication phi psi))
        (Implication (Necessity phi) (Necessity psi))
    in isValid axiom (model reasoner)

-- Ê£ÄÊü•ÂÖ¨ÁêÜT
checkAxiomT :: ModalFormula -> ModalLogicReasoner -> Bool
checkAxiomT phi reasoner = 
    let axiom = Implication (Necessity phi) phi
    in isValid axiom (model reasoner)

-- Ê£ÄÊü•ÂÖ¨ÁêÜ4
checkAxiom4 :: ModalFormula -> ModalLogicReasoner -> Bool
checkAxiom4 phi reasoner = 
    let axiom = Implication (Necessity phi) (Necessity (Necessity phi))
    in isValid axiom (model reasoner)

-- Ê£ÄÊü•ÂÖ¨ÁêÜ5
checkAxiom5 :: ModalFormula -> ModalLogicReasoner -> Bool
checkAxiom5 phi reasoner = 
    let axiom = Implication (Possibility phi) (Necessity (Possibility phi))
    in isValid axiom (model reasoner)

-- Ê£ÄÊü•ÈÄªËæëËï¥Ê∂µ
entails :: [ModalFormula] -> ModalFormula -> ModalLogicReasoner -> Bool
entails premises conclusion reasoner = 
    all (\world -> 
        let allPremisesTrue = all (\premise -> evaluate premise world (model reasoner)) premises
        in if allPremisesTrue then evaluate conclusion world (model reasoner) else True
    ) (worlds (model reasoner))

-- Ê®°ÊÄÅÊé®ÁêÜÔºö‰ªéÂøÖÁÑ∂Êé®Âá∫ÂèØËÉΩ
necessityImpliesPossibility :: ModalFormula -> ModalLogicReasoner -> Bool
necessityImpliesPossibility phi reasoner = 
    let implication = Implication (Necessity phi) (Possibility phi)
    in isValid implication (model reasoner)

-- Á§∫‰æã‰ΩøÁî®
example :: IO ()
example = do
    let -- ÂàõÂª∫ÂèØËÉΩ‰∏ñÁïå
        world1 = PossibleWorld "w1" (Set.singleton (Proposition "p"))
        world2 = PossibleWorld "w2" (Set.singleton (Proposition "q"))
        
        -- ÂàõÂª∫Ê®°Âûã
        model = addWorld world2 (addWorld world1 emptyModalModel)
        model' = addAccessibility world1 world1 model
        model'' = addAccessibility world1 world2 model'
        model''' = addAccessibility world2 world2 model''
        
        -- ÂàõÂª∫Êé®ÁêÜÂô®
        reasoner = ModalLogicReasoner model'''
        
        -- ÊµãËØïÂÖ¨Âºè
        phi = Prop (Proposition "p")
        psi = Prop (Proposition "q")
    
    putStrLn "Modal Logic Example:"
    putStrLn $ "Axiom K holds: " ++ show (checkAxiomK phi psi reasoner)
    putStrLn $ "Axiom T holds: " ++ show (checkAxiomT phi reasoner)
    putStrLn $ "Necessity implies possibility: " ++ show (necessityImpliesPossibility phi reasoner)
    putStrLn $ "Model is reflexive: " ++ show (isReflexive (accessibility model'''))
    putStrLn $ "Model is transitive: " ++ show (isTransitive (accessibility model'''))

main :: IO ()
main = example
```

## 7. Â∫îÁî®Á§∫‰æã

### 7.1 Âì≤Â≠¶Ê®°ÊÄÅÈÄªËæë

**Á§∫‰æã 7.1** (ÂΩ¢ËÄå‰∏äÂ≠¶Ê®°ÊÄÅ)
```rust
// ÂΩ¢ËÄå‰∏äÂ≠¶Ê®°ÊÄÅÂàÜÊûê
let mut metaphysics = ModalModel::new();

// ÂàõÂª∫ÂèØËÉΩ‰∏ñÁïå
let mut actual_world = PossibleWorld::new("actual".to_string());
let mut possible_world1 = PossibleWorld::new("possible1".to_string());
let mut possible_world2 = PossibleWorld::new("possible2".to_string());

// Ê∑ªÂä†ÂΩ¢ËÄå‰∏äÂ≠¶ÂëΩÈ¢ò
let exists = Proposition::new("exists".to_string());
let is_conscious = Proposition::new("is_conscious".to_string());

actual_world.add_proposition(exists.clone());
actual_world.add_proposition(is_conscious.clone());
possible_world1.add_proposition(exists.clone());
possible_world2.add_proposition(exists.clone());

metaphysics.add_world(actual_world.clone());
metaphysics.add_world(possible_world1.clone());
metaphysics.add_world(possible_world2.clone());

// ËÆæÁΩÆÂèØÂèäÂÖ≥Á≥ªÔºàÊâÄÊúâ‰∏ñÁïåÁõ∏‰∫íÂèØËææÔºâ
metaphysics.add_accessibility(actual_world.clone(), actual_world.clone());
metaphysics.add_accessibility(actual_world.clone(), possible_world1.clone());
metaphysics.add_accessibility(actual_world.clone(), possible_world2.clone());

// ÂàõÂª∫Êé®ÁêÜÂô®
let reasoner = ModalLogicReasoner::new(metaphysics);

// ÊµãËØïÂΩ¢ËÄå‰∏äÂ≠¶ÂëΩÈ¢ò
let existence_necessary = ModalFormula::necessity(ModalFormula::proposition("exists".to_string()));
let consciousness_possible = ModalFormula::possibility(ModalFormula::proposition("is_conscious".to_string()));

assert!(reasoner.model.is_valid(&existence_necessary));
assert!(reasoner.model.is_satisfiable(&consciousness_possible));
```

### 7.2 ËÆ°ÁÆóÊú∫ÁßëÂ≠¶Ê®°ÊÄÅÈÄªËæë

**Á§∫‰æã 7.2** (Á®ãÂ∫èÈ™åËØÅ)
```rust
// Á®ãÂ∫èÈ™åËØÅÊ®°ÊÄÅÈÄªËæë
let mut program_model = ModalModel::new();

// ÂàõÂª∫Á®ãÂ∫èÁä∂ÊÄÅ
let mut initial_state = PossibleWorld::new("initial".to_string());
let mut running_state = PossibleWorld::new("running".to_string());
let mut final_state = PossibleWorld::new("final".to_string());

// Ê∑ªÂä†Á®ãÂ∫èÂ±ûÊÄß
let is_safe = Proposition::new("is_safe".to_string());
let is_terminating = Proposition::new("is_terminating".to_string());

initial_state.add_proposition(is_safe.clone());
running_state.add_proposition(is_safe.clone());
final_state.add_proposition(is_safe.clone());
final_state.add_proposition(is_terminating.clone());

program_model.add_world(initial_state.clone());
program_model.add_world(running_state.clone());
program_model.add_world(final_state.clone());

// ËÆæÁΩÆÁ®ãÂ∫èËΩ¨Êç¢ÂÖ≥Á≥ª
program_model.add_accessibility(initial_state.clone(), running_state.clone());
program_model.add_accessibility(running_state.clone(), final_state.clone());

// ÂàõÂª∫Êé®ÁêÜÂô®
let reasoner = ModalLogicReasoner::new(program_model);

// È™åËØÅÁ®ãÂ∫èÂ±ûÊÄß
let always_safe = ModalFormula::necessity(ModalFormula::proposition("is_safe".to_string()));
let eventually_terminating = ModalFormula::possibility(ModalFormula::proposition("is_terminating".to_string()));

assert!(reasoner.model.is_valid(&always_safe));
assert!(reasoner.model.is_satisfiable(&eventually_terminating));
```

## 8. Áõ∏ÂÖ≥ÁêÜËÆ∫

### 8.1 ‰∏éÂëΩÈ¢òÈÄªËæëÁöÑÂÖ≥Á≥ª

Ê®°ÊÄÅÈÄªËæëÊòØÂëΩÈ¢òÈÄªËæëÁöÑÊâ©Â±ïÔºåÈÄöËøáÊ∑ªÂä†Ê®°ÊÄÅÁÆóÂ≠êÂ¢ûÂº∫‰∫ÜË°®ËææËÉΩÂäõ„ÄÇ

### 8.2 ‰∏éË∞ìËØçÈÄªËæëÁöÑÂÖ≥Á≥ª

Ê®°ÊÄÅÈÄªËæëÂèØ‰ª•‰∏éË∞ìËØçÈÄªËæëÁªìÂêàÔºåÂΩ¢ÊàêÊ®°ÊÄÅË∞ìËØçÈÄªËæëÔºåÁî®‰∫éÊõ¥Â§çÊùÇÁöÑÊé®ÁêÜ„ÄÇ

### 8.3 ‰∏éÂèØËÉΩ‰∏ñÁïåËØ≠‰πâÂ≠¶ÁöÑÂÖ≥Á≥ª

ÂèØËÉΩ‰∏ñÁïåËØ≠‰πâÂ≠¶‰∏∫Ê®°ÊÄÅÈÄªËæëÊèê‰æõ‰∫ÜÁõ¥ËßÇÁöÑËØ≠‰πâËß£ÈáäÔºåÊòØÁêÜËß£Ê®°ÊÄÅÊ¶ÇÂøµÁöÑÈáçË¶ÅÂ∑•ÂÖ∑„ÄÇ

## 9. ÂèÇËÄÉÊñáÁåÆ

1. Hughes, G. E., & Cresswell, M. J. *A New Introduction to Modal Logic*. Routledge, 1996.
2. Blackburn, P., de Rijke, M., & Venema, Y. *Modal Logic*. Cambridge University Press, 2001.
3. Chellas, B. F. *Modal Logic: An Introduction*. Cambridge University Press, 1980.
4. Kripke, S. *Semantical Considerations on Modal Logic*. Acta Philosophica Fennica, 1963.
5. van Benthem, J. *Modal Logic for Open Minds*. CSLI Publications, 2010.

---

**Áõ∏ÂÖ≥ÊñáÊ°£**Ôºö
- [02.2.1 ÂëΩÈ¢òÈÄªËæë](../02.2.1_ÂëΩÈ¢òÈÄªËæë.md)
- [02.2.2 Ë∞ìËØçÈÄªËæë](../02.2.2_Ë∞ìËØçÈÄªËæë.md)
- [02.2.4 Áõ¥ËßâÈÄªËæë](../02.2.4_Áõ¥ËßâÈÄªËæë.md)
- [01.1.3 Ê®°ÊÄÅÁêÜËÆ∫](../../01_Philosophical_Foundation/01.1.3_Ê®°ÊÄÅÁêÜËÆ∫.md)
- [01.3.3 Â≠òÂú®Ê®°ÊÄÅ](../../01_Philosophical_Foundation/01.3.3_Â≠òÂú®Ê®°ÊÄÅ.md) 