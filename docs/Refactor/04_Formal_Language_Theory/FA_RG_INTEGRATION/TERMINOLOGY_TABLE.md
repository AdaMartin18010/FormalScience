# 正则文法与有限自动机统一术语表

## 1. 基本概念对应关系

| 正则文法 | 有限自动机 | 说明 |
|---------|-----------|------|
| 非终结符 $V$ | 状态集 $Q$ | 正则文法中的非终结符对应自动机中的状态 |
| 终结符 $\Sigma$ | 输入字母表 $\Sigma$ | 两者使用相同的符号和概念 |
| 起始符号 $S$ | 初始状态 $q_0$ | 正则文法的起始符号对应自动机的初始状态 |
| 产生式集合 $P$ | 转移函数 $\delta$ | 产生式规则对应状态转移 |
| 形如 $A \to a$ 的产生式 | 通向接受状态的转移 | 终结产生式对应接受状态 |
| - | 接受状态集 $F$ | 正则文法需要额外的产生式来表示接受状态 |

## 2. 文法类型与自动机类型对应

| 正则文法类型 | 自动机类型 | 对应关系 |
|------------|-----------|---------|
| 右线性文法 | DFA/NFA | 右线性文法可以直接转换为NFA |
| 左线性文法 | DFA/NFA | 左线性文法需要先转换为右线性文法或直接构造逆向自动机 |
| 产生式形如 $A \to aB$ | 状态转移 $\delta(A, a) = B$ | 直接映射关系 |
| 产生式形如 $A \to a$ | 状态转移到接受状态 | 表示接受过程 |
| 产生式形如 $A \to \varepsilon$ | $\varepsilon$-转移或接受空串 | 对应空串处理 |

## 3. 数学符号统一

| 符号 | 正则文法中的含义 | 有限自动机中的含义 | 统一表示 |
|-----|---------------|-------------------|----------|
| $\Sigma$ | 终结符集合 | 输入字母表 | 输入符号集合 |
| $\varepsilon$ | 空串 | 空转移 | 空串/空转移 |
| $L(G)$ | 文法G生成的语言 | - | - |
| $L(M)$ | - | 自动机M接受的语言 | $L(A)$：表示自动机或文法A定义的语言 |
| $\delta$ | - | 转移函数 | 保持为转移函数 |
| $\hat{\delta}$ | - | 扩展转移函数 | 保持为扩展转移函数 |
| $V$ | 非终结符集合 | - | - |
| $Q$ | - | 状态集合 | 状态集合/非终结符集合 |
| $P$ | 产生式集合 | - | 转换规则集合 |

## 4. 运算与性质术语

| 术语 | 正则文法表示 | 有限自动机表示 | 统一定义 |
|-----|------------|---------------|---------|
| 并运算 | 文法合并 | 自动机并集构造 | 语言的并集 $L_1 \cup L_2$ |
| 连接运算 | 文法串联 | NFA串联 | 语言的连接 $L_1 \cdot L_2$ |
| 克林闭包 | 递归产生式 | 自动机循环结构 | 语言的克林闭包 $L^*$ |
| 可判定性 | 成员资格 | 字符串接受 | 判断字符串是否属于语言 $w \in L$ |
| 闭包性质 | 文法转换保持性质 | 自动机构造保持性质 | 在特定运算下保持正则性 |

## 5. 算法复杂度表示

| 算法 | 正则文法中的复杂度 | 有限自动机中的复杂度 | 统一表示 |
|-----|-----------------|-------------------|---------|
| 成员资格判定 | - | $O(n)$，n为输入长度 | $O(n)$ |
| 空性检测 | - | $O(\|Q\|)$，Q为状态集 | $O(\|V\|)$ 或 $O(\|Q\|)$ |
| 等价性检测 | - | $O(2^{\|Q\|})$ | $O(2^{\|V\|})$ 或 $O(2^{\|Q\|})$ |
| 最小化 | - | $O(\|Q\|^2)$ | $O(\|V\|^2)$ 或 $O(\|Q\|^2)$ |

## 6. 转换算法术语

| 转换方向 | 算法名称 | 复杂度 | 关键步骤 |
|---------|---------|------|---------|
| 右线性文法→NFA | 直接构造法 | $O(\|P\|)$ | 产生式直接映射为转移 |
| NFA→右线性文法 | 状态产生式映射 | $O(\|Q\|\|\Sigma\|)$ | 每个转移映射为产生式 |
| 右线性文法→左线性文法 | 反向构造法 | $O(\|P\|)$ | 反转产生式方向 |
| DFA→最小DFA | Hopcroft算法 | $O(\|Q\|\log\|Q\|)$ | 状态等价类划分 |

## 7. 经典示例统一术语

| 示例 | 正则文法表示 | 有限自动机表示 |
|-----|------------|---------------|
| $(a\|b)^*abb$ | $S \to aS \| bS \| aA$\>$A \to bB$\>$B \to b$ | 五状态DFA，识别以abb结尾的字符串 |
| $a^*b^*$ | $S \to aS \| T$\>$T \to bT \| \varepsilon$ | 三状态DFA，先接受任意个a，然后接受任意个b |

## 8. 代码实现统一

为确保代码实现的一致性，我们将采用以下命名约定：

```rust
// 通用类型
type Symbol = char;       // 终结符/输入符号
type State = String;      // 非终结符/状态
type StateSet = HashSet<State>; // 状态集/非终结符集

// 有限自动机
struct FiniteAutomaton {
    states: StateSet,              // Q 状态集
    alphabet: HashSet<Symbol>,     // Σ 输入字母表
    transitions: HashMap<(State, Symbol), StateSet>, // δ 转移函数
    initial_state: State,          // q₀ 初始状态
    accepting_states: StateSet,    // F 接受状态集
}

// 正则文法
struct RegularGrammar {
    non_terminals: StateSet,       // V 非终结符集
    terminals: HashSet<Symbol>,    // Σ 终结符集
    productions: HashMap<State, Vec<String>>, // P 产生式集
    start_symbol: State,           // S 起始符号
}

// 转换函数接口
trait Convertible {
    fn to_finite_automaton(&self) -> FiniteAutomaton;
    fn to_regular_grammar(&self) -> RegularGrammar;
}
```
