# 3.1.1 æ–‡æ³•åŸºæœ¬æ¦‚å¿µ (Basic Concepts of Formal Grammar)

## ğŸ¯ **æ¦‚è¿°**

æ–‡æ³•åŸºæœ¬æ¦‚å¿µæ˜¯å½¢å¼è¯­è¨€ç†è®ºçš„åŸºç¡€ï¼Œå®šä¹‰äº†å¦‚ä½•é€šè¿‡è§„åˆ™ç³»ç»Ÿç”Ÿæˆè¯­è¨€ï¼Œä¸ºç†è§£è¯­è¨€çš„è¯­æ³•ç»“æ„æä¾›å½¢å¼åŒ–æ¡†æ¶ã€‚

## ğŸ“‹ **ç›®å½•**

1. [åŸºæœ¬å®šä¹‰](#1-åŸºæœ¬å®šä¹‰)
2. [æ–‡æ³•ç±»å‹](#2-æ–‡æ³•ç±»å‹)
3. [æ¨å¯¼è¿‡ç¨‹](#3-æ¨å¯¼è¿‡ç¨‹)
4. [æ–‡æ³•ç­‰ä»·æ€§](#4-æ–‡æ³•ç­‰ä»·æ€§)
5. [æ–‡æ³•å˜æ¢](#5-æ–‡æ³•å˜æ¢)
6. [æ–‡æ³•åˆ†æ](#6-æ–‡æ³•åˆ†æ)
7. [åº”ç”¨å®ä¾‹](#7-åº”ç”¨å®ä¾‹)
8. [æ‰©å±•ä¸å±•æœ›](#8-æ‰©å±•ä¸å±•æœ›)

## 1. åŸºæœ¬å®šä¹‰

### å®šä¹‰ 3.1.1 (æ–‡æ³•)

æ–‡æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ $G = (V, T, P, S)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯éç»ˆç»“ç¬¦é›†åˆ
- $T$ æ˜¯ç»ˆç»“ç¬¦é›†åˆ
- $P$ æ˜¯äº§ç”Ÿå¼è§„åˆ™é›†åˆ
- $S \in V$ æ˜¯å¼€å§‹ç¬¦å·

**å½¢å¼åŒ–è¡¨ç¤ºï¼š**
$$G = (V, T, P, S)$$

å…¶ä¸­ $V \cap T = \emptyset$ï¼Œ$P \subseteq (V \cup T)^* V (V \cup T)^* \times (V \cup T)^*$

```rust
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Grammar {
    pub non_terminals: Set<Symbol>,
    pub terminals: Set<Symbol>,
    pub productions: Set<Production>,
    pub start_symbol: Symbol,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Symbol {
    pub name: String,
    pub is_terminal: bool,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Production {
    pub left_hand_side: Vec<Symbol>,
    pub right_hand_side: Vec<Symbol>,
}

impl Grammar {
    pub fn new(
        non_terminals: Set<Symbol>,
        terminals: Set<Symbol>,
        productions: Set<Production>,
        start_symbol: Symbol,
    ) -> Result<Self, GrammarError> {
        // éªŒè¯æ–‡æ³•å®šä¹‰çš„æœ‰æ•ˆæ€§
        if non_terminals.contains(&start_symbol) {
            Ok(Self {
                non_terminals,
                terminals,
                productions,
                start_symbol,
            })
        } else {
            Err(GrammarError::InvalidStartSymbol)
        }
    }
    
    pub fn is_valid(&self) -> bool {
        // æ£€æŸ¥éç»ˆç»“ç¬¦å’Œç»ˆç»“ç¬¦ä¸ç›¸äº¤
        let intersection: Set<_> = self.non_terminals
            .intersection(&self.terminals)
            .collect();
        if !intersection.is_empty() {
            return false;
        }
        
        // æ£€æŸ¥æ‰€æœ‰äº§ç”Ÿå¼ä¸­çš„ç¬¦å·éƒ½åœ¨ç›¸åº”çš„é›†åˆä¸­
        for production in &self.productions {
            for symbol in &production.left_hand_side {
                if !self.non_terminals.contains(symbol) && 
                   !self.terminals.contains(symbol) {
                    return false;
                }
            }
            for symbol in &production.right_hand_side {
                if !self.non_terminals.contains(symbol) && 
                   !self.terminals.contains(symbol) {
                    return false;
                }
            }
        }
        
        true
    }
}
```

### å®šä¹‰ 3.1.2 (è¯­è¨€)

æ–‡æ³• $G$ ç”Ÿæˆçš„è¯­è¨€ $L(G)$ æ˜¯æ‰€æœ‰å¯ä»¥ä»å¼€å§‹ç¬¦å·æ¨å¯¼å‡ºçš„ç»ˆç»“ç¬¦ä¸²çš„é›†åˆã€‚

**å½¢å¼åŒ–å®šä¹‰ï¼š**
$$L(G) = \{w \in T^* \mid S \Rightarrow^* w\}$$

å…¶ä¸­ $\Rightarrow^*$ è¡¨ç¤ºé›¶æ­¥æˆ–å¤šæ­¥æ¨å¯¼ã€‚

```rust
impl Grammar {
    pub fn generate_language(&self, max_length: usize) -> Set<String> {
        let mut language = Set::new();
        let mut worklist = vec![vec![self.start_symbol.clone()]];
        
        while let Some(current) = worklist.pop() {
            if self.is_terminal_string(&current) {
                let word = self.symbols_to_string(&current);
                if word.len() <= max_length {
                    language.insert(word);
                }
            } else if self.symbols_to_string(&current).len() <= max_length {
                // åº”ç”¨æ‰€æœ‰å¯èƒ½çš„äº§ç”Ÿå¼
                for production in &self.productions {
                    if let Some(new_string) = self.apply_production(&current, production) {
                        worklist.push(new_string);
                    }
                }
            }
        }
        
        language
    }
    
    fn is_terminal_string(&self, symbols: &[Symbol]) -> bool {
        symbols.iter().all(|s| s.is_terminal)
    }
    
    fn symbols_to_string(&self, symbols: &[Symbol]) -> String {
        symbols.iter()
            .map(|s| s.name.clone())
            .collect::<Vec<_>>()
            .join("")
    }
    
    fn apply_production(&self, current: &[Symbol], production: &Production) -> Option<Vec<Symbol>> {
        // æŸ¥æ‰¾å¯ä»¥åº”ç”¨äº§ç”Ÿå¼çš„ä½ç½®
        for i in 0..=current.len() {
            if i + production.left_hand_side.len() <= current.len() {
                let slice = &current[i..i + production.left_hand_side.len()];
                if slice == production.left_hand_side.as_slice() {
                    let mut result = current[..i].to_vec();
                    result.extend(production.right_hand_side.clone());
                    result.extend(current[i + production.left_hand_side.len()..].to_vec());
                    return Some(result);
                }
            }
        }
        None
    }
}
```

## 2. æ–‡æ³•ç±»å‹

### 2.1 æ— é™åˆ¶æ–‡æ³•

**å®šä¹‰ 3.1.3 (æ— é™åˆ¶æ–‡æ³•)**
æ— é™åˆ¶æ–‡æ³•å…è®¸ä»»æ„å½¢å¼çš„äº§ç”Ÿå¼è§„åˆ™ã€‚

**å½¢å¼åŒ–å®šä¹‰ï¼š**
$$P \subseteq (V \cup T)^* \times (V \cup T)^*$$

### 2.2 ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•

**å®šä¹‰ 3.1.4 (ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•)**
ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•çš„äº§ç”Ÿå¼å½¢å¼ä¸º $\alpha A \beta \rightarrow \alpha \gamma \beta$ï¼Œå…¶ä¸­ $A \in V$ï¼Œ$\alpha, \beta \in (V \cup T)^*$ï¼Œ$\gamma \in (V \cup T)^+$ã€‚

**å½¢å¼åŒ–å®šä¹‰ï¼š**
$$P \subseteq \{(V \cup T)^* V (V \cup T)^* \rightarrow (V \cup T)^+\}$$

```rust
#[derive(Debug)]
pub enum GrammarType {
    Unrestricted,
    ContextSensitive,
    ContextFree,
    Regular,
}

impl Grammar {
    pub fn get_type(&self) -> GrammarType {
        // æ£€æŸ¥æ˜¯å¦ä¸ºæ­£åˆ™æ–‡æ³•
        if self.is_regular() {
            return GrammarType::Regular;
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•
        if self.is_context_free() {
            return GrammarType::ContextFree;
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•
        if self.is_context_sensitive() {
            return GrammarType::ContextSensitive;
        }
        
        GrammarType::Unrestricted
    }
    
    fn is_regular(&self) -> bool {
        for production in &self.productions {
            if production.left_hand_side.len() != 1 {
                return false;
            }
            
            let left = &production.left_hand_side[0];
            if left.is_terminal {
                return false;
            }
            
            // å³éƒ¨å¿…é¡»æ˜¯å•ä¸ªç»ˆç»“ç¬¦æˆ–ç»ˆç»“ç¬¦åè·Ÿéç»ˆç»“ç¬¦
            match production.right_hand_side.len() {
                1 => {
                    if !production.right_hand_side[0].is_terminal {
                        return false;
                    }
                },
                2 => {
                    if !production.right_hand_side[0].is_terminal ||
                       production.right_hand_side[1].is_terminal {
                        return false;
                    }
                },
                _ => return false,
            }
        }
        true
    }
    
    fn is_context_free(&self) -> bool {
        for production in &self.productions {
            if production.left_hand_side.len() != 1 {
                return false;
            }
            
            if production.left_hand_side[0].is_terminal {
                return false;
            }
        }
        true
    }
    
    fn is_context_sensitive(&self) -> bool {
        for production in &self.productions {
            // æ£€æŸ¥å·¦éƒ¨æ˜¯å¦åŒ…å«éç»ˆç»“ç¬¦
            let has_non_terminal = production.left_hand_side.iter()
                .any(|s| !s.is_terminal);
            
            if !has_non_terminal {
                return false;
            }
            
            // æ£€æŸ¥å³éƒ¨é•¿åº¦æ˜¯å¦å¤§äºç­‰äºå·¦éƒ¨é•¿åº¦
            if production.right_hand_side.len() < production.left_hand_side.len() {
                return false;
            }
        }
        true
    }
}
```

### 2.3 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•

**å®šä¹‰ 3.1.5 (ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•)**
ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•çš„äº§ç”Ÿå¼å½¢å¼ä¸º $A \rightarrow \alpha$ï¼Œå…¶ä¸­ $A \in V$ï¼Œ$\alpha \in (V \cup T)^*$ã€‚

**å½¢å¼åŒ–å®šä¹‰ï¼š**
$$P \subseteq V \times (V \cup T)^*$$

### 2.4 æ­£åˆ™æ–‡æ³•

**å®šä¹‰ 3.1.6 (æ­£åˆ™æ–‡æ³•)**
æ­£åˆ™æ–‡æ³•çš„äº§ç”Ÿå¼å½¢å¼ä¸º $A \rightarrow aB$ æˆ– $A \rightarrow a$ï¼Œå…¶ä¸­ $A, B \in V$ï¼Œ$a \in T$ã€‚

**å½¢å¼åŒ–å®šä¹‰ï¼š**
$$P \subseteq V \times (T \cup TV)$$

## 3. æ¨å¯¼è¿‡ç¨‹

### 3.1 ç›´æ¥æ¨å¯¼

**å®šä¹‰ 3.1.7 (ç›´æ¥æ¨å¯¼)**
å¦‚æœå­˜åœ¨äº§ç”Ÿå¼ $\alpha \rightarrow \beta \in P$ï¼Œä¸” $\gamma \alpha \delta \in (V \cup T)^*$ï¼Œåˆ™ç§° $\gamma \alpha \delta$ ç›´æ¥æ¨å¯¼å‡º $\gamma \beta \delta$ï¼Œè®°ä½œ $\gamma \alpha \delta \Rightarrow \gamma \beta \delta$ã€‚

**å½¢å¼åŒ–å®šä¹‰ï¼š**
$$\alpha \Rightarrow \beta \leftrightarrow \exists \gamma, \delta, \alpha', \beta': \alpha = \gamma \alpha' \delta \land \beta = \gamma \beta' \delta \land (\alpha' \rightarrow \beta') \in P$$

```rust
impl Grammar {
    pub fn direct_derivation(&self, from: &[Symbol], to: &[Symbol]) -> bool {
        // æŸ¥æ‰¾å¯ä»¥åº”ç”¨çš„äº§ç”Ÿå¼
        for production in &self.productions {
            if let Some(result) = self.apply_production(from, production) {
                if result == to {
                    return true;
                }
            }
        }
        false
    }
    
    pub fn find_all_derivations(&self, from: &[Symbol]) -> Vec<Vec<Symbol>> {
        let mut derivations = Vec::new();
        
        for production in &self.productions {
            if let Some(result) = self.apply_production(from, production) {
                derivations.push(result);
            }
        }
        
        derivations
    }
}
```

### 3.2 å¤šæ­¥æ¨å¯¼

**å®šä¹‰ 3.1.8 (å¤šæ­¥æ¨å¯¼)**
å¤šæ­¥æ¨å¯¼æ˜¯ç›´æ¥æ¨å¯¼çš„ä¼ é€’é—­åŒ…ï¼Œè®°ä½œ $\Rightarrow^*$ã€‚

**å½¢å¼åŒ–å®šä¹‰ï¼š**
$$\alpha \Rightarrow^* \beta \leftrightarrow \alpha = \beta \lor \exists \gamma: \alpha \Rightarrow \gamma \land \gamma \Rightarrow^* \beta$$

```rust
impl Grammar {
    pub fn multi_step_derivation(&self, from: &[Symbol], to: &[Symbol]) -> bool {
        let mut visited = Set::new();
        let mut worklist = vec![from.to_vec()];
        
        while let Some(current) = worklist.pop() {
            if current == to {
                return true;
            }
            
            let current_key = self.symbols_to_string(&current);
            if visited.contains(&current_key) {
                continue;
            }
            visited.insert(current_key);
            
            // æ·»åŠ æ‰€æœ‰å¯èƒ½çš„ç›´æ¥æ¨å¯¼
            for derivation in self.find_all_derivations(&current) {
                worklist.push(derivation);
            }
        }
        
        false
    }
    
    pub fn find_derivation_path(&self, from: &[Symbol], to: &[Symbol]) -> Option<Vec<Vec<Symbol>>> {
        let mut visited = Map::new();
        let mut worklist = vec![(from.to_vec(), vec![from.to_vec()])];
        
        while let Some((current, path)) = worklist.pop() {
            if current == to {
                return Some(path);
            }
            
            let current_key = self.symbols_to_string(&current);
            if visited.contains_key(&current_key) {
                continue;
            }
            visited.insert(current_key, true);
            
            // æ·»åŠ æ‰€æœ‰å¯èƒ½çš„ç›´æ¥æ¨å¯¼
            for derivation in self.find_all_derivations(&current) {
                let mut new_path = path.clone();
                new_path.push(derivation.clone());
                worklist.push((derivation, new_path));
            }
        }
        
        None
    }
}
```

## 4. æ–‡æ³•ç­‰ä»·æ€§

### 4.1 è¯­è¨€ç­‰ä»·æ€§

**å®šä¹‰ 3.1.9 (è¯­è¨€ç­‰ä»·æ€§)**
ä¸¤ä¸ªæ–‡æ³• $G_1$ å’Œ $G_2$ è¯­è¨€ç­‰ä»·ï¼Œå½“ä¸”ä»…å½“ $L(G_1) = L(G_2)$ã€‚

**å½¢å¼åŒ–å®šä¹‰ï¼š**
$$G_1 \equiv_L G_2 \leftrightarrow L(G_1) = L(G_2)$$

```rust
impl Grammar {
    pub fn is_language_equivalent(&self, other: &Grammar) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ¯”è¾ƒæœ‰é™é•¿åº¦çš„è¯­è¨€
        let max_length = 10;
        let lang1 = self.generate_language(max_length);
        let lang2 = other.generate_language(max_length);
        
        lang1 == lang2
    }
}
```

### 4.2 ç»“æ„ç­‰ä»·æ€§

**å®šä¹‰ 3.1.10 (ç»“æ„ç­‰ä»·æ€§)**
ä¸¤ä¸ªæ–‡æ³• $G_1$ å’Œ $G_2$ ç»“æ„ç­‰ä»·ï¼Œå½“ä¸”ä»…å½“å®ƒä»¬çš„æ¨å¯¼æ ‘ç»“æ„ç›¸åŒã€‚

## 5. æ–‡æ³•å˜æ¢

### 5.1 æ¶ˆé™¤å·¦é€’å½’

**å®šä¹‰ 3.1.11 (å·¦é€’å½’)**
æ–‡æ³•ä¸­å­˜åœ¨å½¢å¦‚ $A \rightarrow A\alpha$ çš„äº§ç”Ÿå¼ã€‚

**ç®—æ³• 3.1.1 (æ¶ˆé™¤ç›´æ¥å·¦é€’å½’)**
å¯¹äºäº§ç”Ÿå¼ $A \rightarrow A\alpha_1 \mid A\alpha_2 \mid \cdots \mid A\alpha_m \mid \beta_1 \mid \beta_2 \mid \cdots \mid \beta_n$ï¼Œå…¶ä¸­ $\beta_i$ ä¸ä»¥ $A$ å¼€å¤´ï¼Œå˜æ¢ä¸ºï¼š

- $A \rightarrow \beta_1A' \mid \beta_2A' \mid \cdots \mid \beta_nA'$
- $A' \rightarrow \alpha_1A' \mid \alpha_2A' \mid \cdots \mid \alpha_mA' \mid \epsilon$

```rust
impl Grammar {
    pub fn eliminate_left_recursion(&self) -> Grammar {
        let mut new_grammar = self.clone();
        let mut new_productions = Set::new();
        
        for non_terminal in &self.non_terminals {
            let mut recursive_productions = Vec::new();
            let mut non_recursive_productions = Vec::new();
            
            for production in &self.productions {
                if production.left_hand_side.len() == 1 && 
                   production.left_hand_side[0] == *non_terminal {
                    if production.right_hand_side.len() > 0 &&
                       production.right_hand_side[0] == *non_terminal {
                        recursive_productions.push(production.clone());
                    } else {
                        non_recursive_productions.push(production.clone());
                    }
                }
            }
            
            if !recursive_productions.is_empty() {
                // åˆ›å»ºæ–°çš„éç»ˆç»“ç¬¦
                let new_non_terminal = Symbol {
                    name: format!("{}'", non_terminal.name),
                    is_terminal: false,
                };
                
                // æ·»åŠ æ–°çš„äº§ç”Ÿå¼
                for production in &non_recursive_productions {
                    let mut new_production = production.clone();
                    new_production.right_hand_side.push(new_non_terminal.clone());
                    new_productions.insert(new_production);
                }
                
                for production in &recursive_productions {
                    let mut new_production = Production {
                        left_hand_side: vec![new_non_terminal.clone()],
                        right_hand_side: production.right_hand_side[1..].to_vec(),
                    };
                    new_production.right_hand_side.push(new_non_terminal.clone());
                    new_productions.insert(new_production);
                }
                
                // æ·»åŠ ç©ºäº§ç”Ÿå¼
                new_productions.insert(Production {
                    left_hand_side: vec![new_non_terminal.clone()],
                    right_hand_side: vec![],
                });
                
                new_grammar.non_terminals.insert(new_non_terminal);
            } else {
                // ä¿æŒåŸæœ‰äº§ç”Ÿå¼
                for production in &non_recursive_productions {
                    new_productions.insert(production.clone());
                }
            }
        }
        
        new_grammar.productions = new_productions;
        new_grammar
    }
}
```

### 5.2 æå–å·¦å…¬å› å­

**å®šä¹‰ 3.1.12 (å·¦å…¬å› å­)**
å¤šä¸ªäº§ç”Ÿå¼å…·æœ‰ç›¸åŒçš„å‰ç¼€ã€‚

**ç®—æ³• 3.1.2 (æå–å·¦å…¬å› å­)**
å¯¹äºäº§ç”Ÿå¼ $A \rightarrow \alpha\beta_1 \mid \alpha\beta_2 \mid \cdots \mid \alpha\beta_n$ï¼Œå˜æ¢ä¸ºï¼š

- $A \rightarrow \alpha A'$
- $A' \rightarrow \beta_1 \mid \beta_2 \mid \cdots \mid \beta_n$

```rust
impl Grammar {
    pub fn extract_left_factors(&self) -> Grammar {
        let mut new_grammar = self.clone();
        let mut new_productions = Set::new();
        
        for non_terminal in &self.non_terminals {
            let mut productions_for_nt = Vec::new();
            
            for production in &self.productions {
                if production.left_hand_side.len() == 1 && 
                   production.left_hand_side[0] == *non_terminal {
                    productions_for_nt.push(production.clone());
                }
            }
            
            if productions_for_nt.len() > 1 {
                // å¯»æ‰¾å·¦å…¬å› å­
                let mut common_prefixes = Map::new();
                
                for production in &productions_for_nt {
                    for prefix_len in 1..=production.right_hand_side.len() {
                        let prefix = production.right_hand_side[..prefix_len].to_vec();
                        let suffix = production.right_hand_side[prefix_len..].to_vec();
                        
                        common_prefixes.entry(prefix)
                            .or_insert_with(Vec::new)
                            .push(suffix);
                    }
                }
                
                // é€‰æ‹©æœ€é•¿çš„å…¬å› å­
                let mut best_prefix = Vec::new();
                let mut best_suffixes = Vec::new();
                
                for (prefix, suffixes) in common_prefixes {
                    if suffixes.len() > 1 && prefix.len() > best_prefix.len() {
                        best_prefix = prefix;
                        best_suffixes = suffixes;
                    }
                }
                
                if !best_prefix.is_empty() {
                    // åˆ›å»ºæ–°çš„éç»ˆç»“ç¬¦
                    let new_non_terminal = Symbol {
                        name: format!("{}_factor", non_terminal.name),
                        is_terminal: false,
                    };
                    
                    // æ·»åŠ æ–°çš„äº§ç”Ÿå¼
                    new_productions.insert(Production {
                        left_hand_side: vec![non_terminal.clone()],
                        right_hand_side: [best_prefix, vec![new_non_terminal.clone()]].concat(),
                    });
                    
                    for suffix in best_suffixes {
                        new_productions.insert(Production {
                            left_hand_side: vec![new_non_terminal.clone()],
                            right_hand_side: suffix,
                        });
                    }
                    
                    new_grammar.non_terminals.insert(new_non_terminal);
                } else {
                    // ä¿æŒåŸæœ‰äº§ç”Ÿå¼
                    for production in &productions_for_nt {
                        new_productions.insert(production.clone());
                    }
                }
            } else {
                // ä¿æŒåŸæœ‰äº§ç”Ÿå¼
                for production in &productions_for_nt {
                    new_productions.insert(production.clone());
                }
            }
        }
        
        new_grammar.productions = new_productions;
        new_grammar
    }
}
```

## 6. æ–‡æ³•åˆ†æ

### 6.1 å¯ç©ºæ€§åˆ†æ

**å®šä¹‰ 3.1.13 (å¯ç©ºéç»ˆç»“ç¬¦)**
éç»ˆç»“ç¬¦ $A$ æ˜¯å¯ç©ºçš„ï¼Œå½“ä¸”ä»…å½“ $A \Rightarrow^* \epsilon$ã€‚

**ç®—æ³• 3.1.3 (å¯ç©ºæ€§åˆ†æ)**:

1. åˆå§‹åŒ–ï¼šæ‰€æœ‰éç»ˆç»“ç¬¦éƒ½æ ‡è®°ä¸ºä¸å¯ç©º
2. å¯¹äºæ¯ä¸ªäº§ç”Ÿå¼ $A \rightarrow \alpha$ï¼Œå¦‚æœ $\alpha$ ä¸­æ‰€æœ‰ç¬¦å·éƒ½æ˜¯å¯ç©ºçš„ï¼Œåˆ™æ ‡è®° $A$ ä¸ºå¯ç©º
3. é‡å¤æ­¥éª¤2ç›´åˆ°æ²¡æœ‰å˜åŒ–

```rust
impl Grammar {
    pub fn find_nullable_non_terminals(&self) -> Set<Symbol> {
        let mut nullable = Set::new();
        let mut changed = true;
        
        while changed {
            changed = false;
            
            for production in &self.productions {
                if production.left_hand_side.len() == 1 {
                    let left = &production.left_hand_side[0];
                    
                    if !left.is_terminal && !nullable.contains(left) {
                        // æ£€æŸ¥å³éƒ¨æ˜¯å¦å¯ç©º
                        let mut right_nullable = true;
                        for symbol in &production.right_hand_side {
                            if symbol.is_terminal || !nullable.contains(symbol) {
                                right_nullable = false;
                                break;
                            }
                        }
                        
                        if right_nullable {
                            nullable.insert(left.clone());
                            changed = true;
                        }
                    }
                }
            }
        }
        
        nullable
    }
}
```

### 6.2 å¯è¾¾æ€§åˆ†æ

**å®šä¹‰ 3.1.14 (å¯è¾¾éç»ˆç»“ç¬¦)**
éç»ˆç»“ç¬¦ $A$ æ˜¯å¯è¾¾çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨ä»å¼€å§‹ç¬¦å·åˆ° $A$ çš„æ¨å¯¼è·¯å¾„ã€‚

**ç®—æ³• 3.1.4 (å¯è¾¾æ€§åˆ†æ)**:

1. åˆå§‹åŒ–ï¼šåªæœ‰å¼€å§‹ç¬¦å·æ˜¯å¯è¾¾çš„
2. å¯¹äºæ¯ä¸ªå¯è¾¾çš„éç»ˆç»“ç¬¦ï¼Œå°†å…¶äº§ç”Ÿå¼å³éƒ¨çš„éç»ˆç»“ç¬¦æ ‡è®°ä¸ºå¯è¾¾
3. é‡å¤æ­¥éª¤2ç›´åˆ°æ²¡æœ‰å˜åŒ–

```rust
impl Grammar {
    pub fn find_reachable_non_terminals(&self) -> Set<Symbol> {
        let mut reachable = Set::new();
        reachable.insert(self.start_symbol.clone());
        let mut changed = true;
        
        while changed {
            changed = false;
            
            for production in &self.productions {
                if production.left_hand_side.len() == 1 {
                    let left = &production.left_hand_side[0];
                    
                    if reachable.contains(left) {
                        for symbol in &production.right_hand_side {
                            if !symbol.is_terminal && !reachable.contains(symbol) {
                                reachable.insert(symbol.clone());
                                changed = true;
                            }
                        }
                    }
                }
            }
        }
        
        reachable
    }
}
```

## 7. åº”ç”¨å®ä¾‹

### 7.1 ç®—æœ¯è¡¨è¾¾å¼æ–‡æ³•

**å®šä¹‰ 3.1.15 (ç®—æœ¯è¡¨è¾¾å¼æ–‡æ³•)**:

```rust
impl Grammar {
    pub fn arithmetic_expression_grammar() -> Grammar {
        let e = Symbol { name: "E".to_string(), is_terminal: false };
        let t = Symbol { name: "T".to_string(), is_terminal: false };
        let f = Symbol { name: "F".to_string(), is_terminal: false };
        
        let plus = Symbol { name: "+".to_string(), is_terminal: true };
        let minus = Symbol { name: "-".to_string(), is_terminal: true };
        let times = Symbol { name: "*".to_string(), is_terminal: true };
        let divide = Symbol { name: "/".to_string(), is_terminal: true };
        let lparen = Symbol { name: "(".to_string(), is_terminal: true };
        let rparen = Symbol { name: ")".to_string(), is_terminal: true };
        let id = Symbol { name: "id".to_string(), is_terminal: true };
        
        let mut productions = Set::new();
        
        // E -> E + T | E - T | T
        productions.insert(Production {
            left_hand_side: vec![e.clone()],
            right_hand_side: vec![e.clone(), plus.clone(), t.clone()],
        });
        productions.insert(Production {
            left_hand_side: vec![e.clone()],
            right_hand_side: vec![e.clone(), minus.clone(), t.clone()],
        });
        productions.insert(Production {
            left_hand_side: vec![e.clone()],
            right_hand_side: vec![t.clone()],
        });
        
        // T -> T * F | T / F | F
        productions.insert(Production {
            left_hand_side: vec![t.clone()],
            right_hand_side: vec![t.clone(), times.clone(), f.clone()],
        });
        productions.insert(Production {
            left_hand_side: vec![t.clone()],
            right_hand_side: vec![t.clone(), divide.clone(), f.clone()],
        });
        productions.insert(Production {
            left_hand_side: vec![t.clone()],
            right_hand_side: vec![f.clone()],
        });
        
        // F -> (E) | id
        productions.insert(Production {
            left_hand_side: vec![f.clone()],
            right_hand_side: vec![lparen.clone(), e.clone(), rparen.clone()],
        });
        productions.insert(Production {
            left_hand_side: vec![f.clone()],
            right_hand_side: vec![id.clone()],
        });
        
        Grammar::new(
            Set::from([e.clone(), t.clone(), f.clone()]),
            Set::from([plus, minus, times, divide, lparen, rparen, id]),
            productions,
            e,
        ).unwrap()
    }
}
```

### 7.2 ç¼–ç¨‹è¯­è¨€æ–‡æ³•

**å®šä¹‰ 3.1.16 (ç®€å•ç¼–ç¨‹è¯­è¨€æ–‡æ³•)**:

```rust
impl Grammar {
    pub fn simple_programming_language_grammar() -> Grammar {
        // å®šä¹‰éç»ˆç»“ç¬¦
        let program = Symbol { name: "Program".to_string(), is_terminal: false };
        let statement = Symbol { name: "Statement".to_string(), is_terminal: false };
        let assignment = Symbol { name: "Assignment".to_string(), is_terminal: false };
        let expression = Symbol { name: "Expression".to_string(), is_terminal: false };
        let term = Symbol { name: "Term".to_string(), is_terminal: false };
        let factor = Symbol { name: "Factor".to_string(), is_terminal: false };
        
        // å®šä¹‰ç»ˆç»“ç¬¦
        let identifier = Symbol { name: "id".to_string(), is_terminal: true };
        let number = Symbol { name: "number".to_string(), is_terminal: true };
        let equals = Symbol { name: "=".to_string(), is_terminal: true };
        let plus = Symbol { name: "+".to_string(), is_terminal: true };
        let minus = Symbol { name: "-".to_string(), is_terminal: true };
        let semicolon = Symbol { name: ";".to_string(), is_terminal: true };
        
        let mut productions = Set::new();
        
        // Program -> Statement | Program Statement
        productions.insert(Production {
            left_hand_side: vec![program.clone()],
            right_hand_side: vec![statement.clone()],
        });
        productions.insert(Production {
            left_hand_side: vec![program.clone()],
            right_hand_side: vec![program.clone(), statement.clone()],
        });
        
        // Statement -> Assignment
        productions.insert(Production {
            left_hand_side: vec![statement.clone()],
            right_hand_side: vec![assignment.clone()],
        });
        
        // Assignment -> id = Expression ;
        productions.insert(Production {
            left_hand_side: vec![assignment.clone()],
            right_hand_side: vec![identifier.clone(), equals.clone(), expression.clone(), semicolon.clone()],
        });
        
        // Expression -> Term | Expression + Term | Expression - Term
        productions.insert(Production {
            left_hand_side: vec![expression.clone()],
            right_hand_side: vec![term.clone()],
        });
        productions.insert(Production {
            left_hand_side: vec![expression.clone()],
            right_hand_side: vec![expression.clone(), plus.clone(), term.clone()],
        });
        productions.insert(Production {
            left_hand_side: vec![expression.clone()],
            right_hand_side: vec![expression.clone(), minus.clone(), term.clone()],
        });
        
        // Term -> Factor
        productions.insert(Production {
            left_hand_side: vec![term.clone()],
            right_hand_side: vec![factor.clone()],
        });
        
        // Factor -> id | number
        productions.insert(Production {
            left_hand_side: vec![factor.clone()],
            right_hand_side: vec![identifier.clone()],
        });
        productions.insert(Production {
            left_hand_side: vec![factor.clone()],
            right_hand_side: vec![number.clone()],
        });
        
        Grammar::new(
            Set::from([program.clone(), statement, assignment, expression, term, factor]),
            Set::from([identifier, number, equals, plus, minus, semicolon]),
            productions,
            program,
        ).unwrap()
    }
}
```

## 8. æ‰©å±•ä¸å±•æœ›

### 8.1 å±æ€§æ–‡æ³•

**å®šä¹‰ 3.1.17 (å±æ€§æ–‡æ³•)**
å±æ€§æ–‡æ³•åœ¨ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•åŸºç¡€ä¸Šå¢åŠ äº†è¯­ä¹‰å±æ€§ã€‚

```rust
#[derive(Debug)]
pub struct AttributeGrammar {
    pub grammar: Grammar,
    pub attributes: Map<Symbol, Vec<Attribute>>,
    pub semantic_rules: Vec<SemanticRule>,
}

#[derive(Debug)]
pub struct Attribute {
    pub name: String,
    pub attribute_type: AttributeType,
    pub is_inherited: bool,
}

#[derive(Debug)]
pub enum AttributeType {
    Integer,
    Float,
    String,
    Boolean,
}

#[derive(Debug)]
pub struct SemanticRule {
    pub production: Production,
    pub rules: Vec<AttributeRule>,
}

#[derive(Debug)]
pub struct AttributeRule {
    pub target: AttributeReference,
    pub expression: AttributeExpression,
}

#[derive(Debug)]
pub struct AttributeReference {
    pub symbol_index: usize,
    pub attribute_name: String,
}

#[derive(Debug)]
pub enum AttributeExpression {
    Literal(String),
    AttributeRef(AttributeReference),
    BinaryOp(Box<AttributeExpression>, String, Box<AttributeExpression>),
}
```

### 8.2 æ¦‚ç‡æ–‡æ³•

**å®šä¹‰ 3.1.18 (æ¦‚ç‡æ–‡æ³•)**
æ¦‚ç‡æ–‡æ³•ä¸ºæ¯ä¸ªäº§ç”Ÿå¼åˆ†é…æ¦‚ç‡å€¼ã€‚

```rust
#[derive(Debug)]
pub struct ProbabilisticGrammar {
    pub grammar: Grammar,
    pub probabilities: Map<Production, f64>,
}

impl ProbabilisticGrammar {
    pub fn new(grammar: Grammar) -> Self {
        Self {
            grammar,
            probabilities: Map::new(),
        }
    }
    
    pub fn set_probability(&mut self, production: Production, probability: f64) {
        self.probabilities.insert(production, probability);
    }
    
    pub fn get_probability(&self, production: &Production) -> f64 {
        self.probabilities.get(production).unwrap_or(&0.0).clone()
    }
    
    pub fn normalize_probabilities(&mut self) {
        // æŒ‰å·¦éƒ¨éç»ˆç»“ç¬¦åˆ†ç»„
        let mut groups = Map::new();
        
        for production in &self.grammar.productions {
            if production.left_hand_side.len() == 1 {
                let left = &production.left_hand_side[0];
                groups.entry(left.clone())
                    .or_insert_with(Vec::new)
                    .push(production.clone());
            }
        }
        
        // å¯¹æ¯ç»„äº§ç”Ÿå¼è¿›è¡Œå½’ä¸€åŒ–
        for (left, productions) in groups {
            let total_prob = productions.iter()
                .map(|p| self.get_probability(p))
                .sum::<f64>();
            
            if total_prob > 0.0 {
                for production in productions {
                    let current_prob = self.get_probability(&production);
                    self.set_probability(production, current_prob / total_prob);
                }
            }
        }
    }
}
```

## ğŸ“š **å‚è€ƒæ–‡çŒ®**

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to automata theory, languages, and computation.
2. Sipser, M. (2012). Introduction to the theory of computation.
3. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). Compilers: Principles, techniques, and tools.
4. Grune, D., & Jacobs, C. J. (2008). Parsing techniques: A practical guide.
5. Knuth, D. E. (1968). Semantics of context-free languages.

## ğŸ”— **ç›¸å…³é“¾æ¥**

- [ä¹”å§†æ–¯åŸºå±‚æ¬¡](02_ä¹”å§†æ–¯åŸºå±‚æ¬¡.md)
- [ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](03_ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•.md)
- [æ­£åˆ™æ–‡æ³•](04_æ­£åˆ™æ–‡æ³•.md)
- [æ–‡æ³•å˜æ¢](05_æ–‡æ³•å˜æ¢.md)
- [è‡ªåŠ¨æœºç†è®º](README.md)
- [è®¡ç®—å¤æ‚æ€§ç†è®º](README.md)


## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
