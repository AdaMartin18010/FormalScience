# 03.3.1.1 æ­£åˆ™è¯­è¨€ (Regular Languages)

## ğŸ“š æ¦‚è¿°ä¸å®šä¹‰

æ­£åˆ™è¯­è¨€æ˜¯ä¹”å§†æ–¯åŸºå±‚æ¬¡ç»“æ„ä¸­æœ€åŸºç¡€çš„è¯­è¨€ç±»å‹ï¼ˆ3å‹è¯­è¨€ï¼‰ï¼Œåœ¨å½¢å¼è¯­è¨€ç†è®ºå’Œè®¡ç®—æœºç§‘å­¦ä¸­å æœ‰é‡è¦åœ°ä½ã€‚

### å®šä¹‰æ–¹å¼

**å®šä¹‰ 1.1** (æ­£åˆ™è¯­è¨€)
æ­£åˆ™è¯­è¨€å¯é€šè¿‡ä»¥ä¸‹ç­‰ä»·çš„æ–¹å¼å®šä¹‰ï¼š

1. èƒ½è¢«æ­£åˆ™è¡¨è¾¾å¼æè¿°çš„è¯­è¨€
2. èƒ½è¢«æœ‰é™è‡ªåŠ¨æœºæ¥å—çš„è¯­è¨€
3. èƒ½è¢«æ­£åˆ™æ–‡æ³•ï¼ˆ3å‹æ–‡æ³•ï¼‰ç”Ÿæˆçš„è¯­è¨€

### ä¸å…¶ä»–è¯­è¨€ç±»çš„å…³ç³»

æ­£åˆ™è¯­è¨€æ˜¯ä¹”å§†æ–¯åŸºè°±ç³»ä¸­è¡¨è¾¾èƒ½åŠ›æœ€å¼±çš„è¯­è¨€ç±»å‹ï¼š

- $\mathcal{L}_\text{Regular} \subset \mathcal{L}_\text{Context-Free}$
- ä¸èƒ½è¡¨ç¤ºåµŒå¥—çš„åŒ¹é…ç»“æ„ï¼ˆå¦‚æ‹¬å·åŒ¹é…ï¼‰
- å¯ä»¥è¢«æœ‰é™å†…å­˜çš„è®¡ç®—æ¨¡å‹è¯†åˆ«

### åŸºæœ¬æ€§è´¨

- **æœ‰é™çŠ¶æ€æ€§**: å¯ä»¥é€šè¿‡æœ‰é™æ•°é‡çš„çŠ¶æ€è¡¨ç¤º
- **å±€éƒ¨æ€§**: ä¸éœ€è¦"è®°å¿†"å…ˆå‰å¤„ç†çš„æ— é™é•¿åº¦çš„è¾“å…¥
- **é—­åŒ…æ€§**: åœ¨å¹¶ã€è¿æ¥ã€æ˜Ÿé—­åŒ…ç­‰æ“ä½œä¸‹ä¿æŒå°é—­
- **å¯åˆ¤å®šæ€§**: æ‰€æœ‰é‡è¦é—®é¢˜ï¼ˆæˆå‘˜èµ„æ ¼ã€ç­‰ä»·æ€§ã€åŒ…å«æ€§ç­‰ï¼‰å‡å¯åˆ¤å®š

## ğŸ” è¡¨ç¤ºæ–¹æ³•

### æ­£åˆ™è¡¨è¾¾å¼

**å®šä¹‰ 2.1** (æ­£åˆ™è¡¨è¾¾å¼)
æ­£åˆ™è¡¨è¾¾å¼æ˜¯æè¿°æ­£åˆ™è¯­è¨€çš„ç¬¦å·è¡¨è¾¾å¼ï¼Œé€’å½’å®šä¹‰å¦‚ä¸‹ï¼š

1. $\emptyset$ è¡¨ç¤ºç©ºè¯­è¨€
2. $\varepsilon$ è¡¨ç¤ºç©ºå­—ç¬¦ä¸²è¯­è¨€ $\{\varepsilon\}$
3. $a \in \Sigma$ è¡¨ç¤ºå•å­—ç¬¦è¯­è¨€ $\{a\}$
4. å¦‚æœ $r_1, r_2$ æ˜¯æ­£åˆ™è¡¨è¾¾å¼ï¼Œåˆ™ï¼š
   - $r_1 + r_2$ (æˆ– $r_1 | r_2$) è¡¨ç¤ºå¹¶è¿ç®—
   - $r_1 \cdot r_2$ (æˆ– $r_1 r_2$) è¡¨ç¤ºè¿æ¥è¿ç®—
   - $r_1^*$ è¡¨ç¤ºå…‹æ—æ˜Ÿå·è¿ç®—ï¼ˆ0æ¬¡æˆ–å¤šæ¬¡é‡å¤ï¼‰

**ä¾‹å­**:

- $(a|b)^*$ æè¿°ç”±å­—ç¬¦ $a$ å’Œ $b$ ç»„æˆçš„æ‰€æœ‰å­—ç¬¦ä¸²
- $a^*b^*$ æè¿°å…ˆæœ‰0ä¸ªæˆ–å¤šä¸ª $a$ï¼Œç„¶åæ˜¯0ä¸ªæˆ–å¤šä¸ª $b$ çš„å­—ç¬¦ä¸²
- $(ab)^*$ æè¿°ç”± $ab$ é‡å¤0æ¬¡æˆ–å¤šæ¬¡ç»„æˆçš„å­—ç¬¦ä¸²

### æœ‰é™è‡ªåŠ¨æœº

**å®šä¹‰ 2.2** (ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºï¼ŒDFA)
ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºæ˜¯äº”å…ƒç»„ $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š

- $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times \Sigma \to Q$ æ˜¯è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†

**å®šä¹‰ 2.3** (éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºï¼ŒNFA)
éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºæ˜¯äº”å…ƒç»„ $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š

- $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times (\Sigma \cup \{\varepsilon\}) \to 2^Q$ æ˜¯è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†

**å®šç† 2.4** (DFAä¸NFAç­‰ä»·æ€§)
å¯¹äºä»»æ„NFAï¼Œå­˜åœ¨ç­‰ä»·çš„DFAæ¥å—ç›¸åŒçš„è¯­è¨€ã€‚

### æ­£åˆ™æ–‡æ³•

**å®šä¹‰ 2.5** (æ­£åˆ™æ–‡æ³•)
æ­£åˆ™æ–‡æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ $G = (V, \Sigma, P, S)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯éç»ˆç»“ç¬¦é›†åˆ
- $\Sigma$ æ˜¯ç»ˆç»“ç¬¦é›†åˆ
- $P$ æ˜¯äº§ç”Ÿå¼è§„åˆ™é›†åˆï¼Œæ¯ä¸ªäº§ç”Ÿå¼å½¢å¼ä¸ºï¼š
  - å³çº¿æ€§ï¼š$A \to aB$ æˆ– $A \to a$
  - å·¦çº¿æ€§ï¼š$A \to Ba$ æˆ– $A \to a$
- $S \in V$ æ˜¯å¼€å§‹ç¬¦å·

**å®šç† 2.6** (æ­£åˆ™æ–‡æ³•ç­‰ä»·æ€§)
å³çº¿æ€§æ–‡æ³•å’Œå·¦çº¿æ€§æ–‡æ³•ç”Ÿæˆçš„è¯­è¨€ç±»å®Œå…¨ç›¸åŒï¼Œå³æ­£åˆ™è¯­è¨€ç±»ã€‚

## ğŸ§  ç†è®ºåŸºç¡€

### é—­åŒ…æ€§è´¨

**å®šç† 3.1** (é—­åŒ…æ€§è´¨)
æ­£åˆ™è¯­è¨€ç±»åœ¨ä»¥ä¸‹æ“ä½œä¸‹å°é—­ï¼š

1. **å¹¶è¿ç®—**: å¦‚æœ $L_1, L_2$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œåˆ™ $L_1 \cup L_2$ ä¹Ÿæ˜¯æ­£åˆ™è¯­è¨€
2. **è¿æ¥è¿ç®—**: å¦‚æœ $L_1, L_2$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œåˆ™ $L_1 \cdot L_2$ ä¹Ÿæ˜¯æ­£åˆ™è¯­è¨€
3. **æ˜Ÿé—­åŒ…**: å¦‚æœ $L$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œåˆ™ $L^*$ ä¹Ÿæ˜¯æ­£åˆ™è¯­è¨€
4. **è¡¥è¿ç®—**: å¦‚æœ $L$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œåˆ™ $\Sigma^* - L$ ä¹Ÿæ˜¯æ­£åˆ™è¯­è¨€
5. **äº¤è¿ç®—**: å¦‚æœ $L_1, L_2$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œåˆ™ $L_1 \cap L_2$ ä¹Ÿæ˜¯æ­£åˆ™è¯­è¨€
6. **å·®è¿ç®—**: å¦‚æœ $L_1, L_2$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œåˆ™ $L_1 - L_2$ ä¹Ÿæ˜¯æ­£åˆ™è¯­è¨€
7. **é€†è¿ç®—**: å¦‚æœ $L$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œåˆ™ $L^R$ ä¹Ÿæ˜¯æ­£åˆ™è¯­è¨€

### æ³µå¼•ç†åŠåº”ç”¨

**å®šç† 3.2** (æ³µå¼•ç†)
å¯¹äºä»»æ„æ­£åˆ™è¯­è¨€ $L$ï¼Œå­˜åœ¨å¸¸æ•° $p > 0$ï¼Œä½¿å¾—å¯¹äºä»»æ„ $w \in L$ï¼Œè‹¥ $|w| \geq p$ï¼Œåˆ™ $w$ å¯ä»¥åˆ†è§£ä¸º $w = xyz$ï¼Œæ»¡è¶³ï¼š

1. $|y| > 0$
2. $|xy| \leq p$
3. å¯¹äºä»»æ„ $i \geq 0$ï¼Œéƒ½æœ‰ $xy^iz \in L$

**åº”ç”¨**:
æ³µå¼•ç†å¸¸ç”¨äºè¯æ˜æŸä¸ªè¯­è¨€ä¸æ˜¯æ­£åˆ™è¯­è¨€ã€‚

**ä¾‹å­**:
è¯æ˜ $L = \{a^n b^n \mid n \geq 1\}$ ä¸æ˜¯æ­£åˆ™è¯­è¨€ã€‚

**è¯æ˜**:
å‡è®¾ $L$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œåˆ™å­˜åœ¨æ³µå¼•ç†å¸¸æ•° $p$ã€‚è€ƒè™‘å­—ç¬¦ä¸² $w = a^p b^p \in L$ï¼Œæ ¹æ®æ³µå¼•ç†ï¼Œ$w$ å¯ä»¥åˆ†è§£ä¸º $w = xyz$ï¼Œæ»¡è¶³ä¸Šè¿°ä¸‰ä¸ªæ¡ä»¶ã€‚

ç”±äº $|xy| \leq p$ï¼Œæ‰€ä»¥ $xy$ åªåŒ…å« $a$ï¼Œå› æ­¤ $y = a^k$ï¼Œå…¶ä¸­ $k > 0$ã€‚

è€ƒè™‘ $xy^0z = xz$ï¼Œæ ¹æ®æ³µå¼•ç†ï¼Œ$xz \in L$ã€‚ä½† $xz$ åŒ…å«çš„ $a$ æ•°é‡å°‘äº $p$ï¼Œè€Œ $b$ æ•°é‡ä»ä¸º $p$ï¼Œå› æ­¤ $xz \notin L$ï¼ŒçŸ›ç›¾ã€‚

æ‰€ä»¥ $L$ ä¸æ˜¯æ­£åˆ™è¯­è¨€ã€‚

### åˆ¤å®šæ€§é—®é¢˜

**å®šç† 3.3** (åˆ¤å®šé—®é¢˜)
å¯¹äºæ­£åˆ™è¯­è¨€ï¼Œä»¥ä¸‹é—®é¢˜å‡å¯åˆ¤å®šï¼š

1. **æˆå‘˜èµ„æ ¼é—®é¢˜**: ç»™å®š DFA $M$ å’Œå­—ç¬¦ä¸² $w$ï¼Œåˆ¤æ–­ $w \in L(M)$
2. **ç©ºæ€§é—®é¢˜**: ç»™å®š DFA $M$ï¼Œåˆ¤æ–­ $L(M) = \emptyset$
3. **ç­‰ä»·æ€§é—®é¢˜**: ç»™å®š DFA $M_1$ å’Œ $M_2$ï¼Œåˆ¤æ–­ $L(M_1) = L(M_2)$
4. **åŒ…å«æ€§é—®é¢˜**: ç»™å®š DFA $M_1$ å’Œ $M_2$ï¼Œåˆ¤æ–­ $L(M_1) \subseteq L(M_2)$
5. **æœ‰é™æ€§é—®é¢˜**: ç»™å®š DFA $M$ï¼Œåˆ¤æ–­ $L(M)$ æ˜¯å¦æœ‰é™

## ğŸ› ï¸ ç®—æ³•ä¸å®ç°

### è‡ªåŠ¨æœºæ„é€ 

**ç®—æ³• 4.1** (å­é›†æ„é€ æ³•)
å°† NFA è½¬æ¢ä¸ºç­‰ä»·çš„ DFAï¼š

```rust
fn nfa_to_dfa(nfa: &NFA) -> DFA {
    let initial_state = epsilon_closure(&nfa.initial_state);
    let mut dfa_states = HashSet::new();
    let mut dfa_transitions = HashMap::new();
    let mut unprocessed = vec![initial_state.clone()];
    
    while let Some(current_state) = unprocessed.pop() {
        if dfa_states.contains(&current_state) {
            continue;
        }
        
        dfa_states.insert(current_state.clone());
        
        // è®¡ç®—æ¯ä¸ªè¾“å…¥ç¬¦å·çš„çŠ¶æ€è½¬æ¢
        for symbol in &nfa.alphabet {
            let next_state = move_and_closure(&nfa, &current_state, *symbol);
            
            if !next_state.is_empty() && !dfa_states.contains(&next_state) {
                unprocessed.push(next_state.clone());
            }
            
            dfa_transitions.insert((current_state.clone(), *symbol), next_state);
        }
    }
    
    // æ„å»ºDFA
    let mut dfa = DFA::new();
    dfa.states = dfa_states;
    dfa.initial_state = initial_state;
    dfa.transitions = dfa_transitions;
    dfa.accepting_states = dfa_states.iter()
        .filter(|s| s.iter().any(|q| nfa.accepting_states.contains(q)))
        .cloned()
        .collect();
    
    dfa
}

fn epsilon_closure(states: &HashSet<State>) -> HashSet<State> {
    // å®ç°Îµ-é—­åŒ…è®¡ç®—
    let mut result = states.clone();
    let mut stack: Vec<_> = states.iter().cloned().collect();
    
    while let Some(state) = stack.pop() {
        for &next_state in &nfa.epsilon_transitions[&state] {
            if !result.contains(&next_state) {
                result.insert(next_state);
                stack.push(next_state);
            }
        }
    }
    
    result
}

fn move_and_closure(nfa: &NFA, states: &HashSet<State>, symbol: Symbol) -> HashSet<State> {
    // å®ç°çŠ¶æ€è½¬ç§»åçš„Îµ-é—­åŒ…è®¡ç®—
    let mut next_states = HashSet::new();
    
    for &state in states {
        if let Some(next) = nfa.transitions.get(&(state, symbol)) {
            next_states.extend(next);
        }
    }
    
    epsilon_closure(&next_states)
}
```

### çŠ¶æ€æœ€å°åŒ–

**ç®—æ³• 4.2** (DFAæœ€å°åŒ–)
é€šè¿‡åˆ†å‰²ç­‰ä»·ç±»å®ç°DFAçš„æœ€å°åŒ–ï¼š

```rust
fn minimize_dfa(dfa: &DFA) -> DFA {
    // åˆ é™¤ä¸å¯è¾¾çŠ¶æ€
    let reachable_states = compute_reachable_states(dfa);
    
    // åˆå§‹åˆ†å‰²ï¼šæ¥å—çŠ¶æ€å’Œéæ¥å—çŠ¶æ€
    let mut partitions = vec![
        dfa.states.difference(&dfa.accepting_states).cloned().collect(),
        dfa.accepting_states.clone()
    ];
    
    // è¿­ä»£ç»†åŒ–åˆ†å‰²
    let mut changed = true;
    while changed {
        changed = false;
        
        let mut new_partitions = Vec::new();
        for partition in partitions {
            let splits = split_partition(&dfa, &partition);
            if splits.len() > 1 {
                changed = true;
                new_partitions.extend(splits);
            } else {
                new_partitions.push(partition);
            }
        }
        
        partitions = new_partitions;
    }
    
    // æ„å»ºæœ€å°åŒ–DFA
    construct_minimized_dfa(dfa, &partitions)
}
```

### æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…

**ç®—æ³• 4.3** (Thompson æ„é€ æ³•)
å°†æ­£åˆ™è¡¨è¾¾å¼è½¬æ¢ä¸º NFAï¼š

```rust
fn regex_to_nfa(regex: &RegExp) -> NFA {
    match regex {
        RegExp::Empty => construct_empty_nfa(),
        RegExp::Epsilon => construct_epsilon_nfa(),
        RegExp::Symbol(a) => construct_symbol_nfa(*a),
        RegExp::Union(r1, r2) => {
            let nfa1 = regex_to_nfa(r1);
            let nfa2 = regex_to_nfa(r2);
            union_nfa(nfa1, nfa2)
        },
        RegExp::Concat(r1, r2) => {
            let nfa1 = regex_to_nfa(r1);
            let nfa2 = regex_to_nfa(r2);
            concat_nfa(nfa1, nfa2)
        },
        RegExp::Star(r) => {
            let nfa = regex_to_nfa(r);
            star_nfa(nfa)
        }
    }
}
```

## ğŸ’¼ åº”ç”¨åœºæ™¯

### ç¼–è¯‘å™¨è¯æ³•åˆ†æ

æ­£åˆ™è¯­è¨€å’Œæœ‰é™è‡ªåŠ¨æœºåœ¨ç¼–è¯‘å™¨è®¾è®¡ä¸­ç”¨äºå®ç°è¯æ³•åˆ†æå™¨ï¼ˆæ‰«æå™¨ï¼‰ï¼Œè¯†åˆ«æ ‡è¯†ç¬¦ã€å…³é”®å­—ã€å¸¸é‡ç­‰è¯æ³•å•å…ƒã€‚

```rust
fn create_lexer() -> Lexer {
    let mut lexer = Lexer::new();
    
    // å®šä¹‰å…³é”®å­—æ¨¡å¼
    lexer.add_pattern("if|else|while|for|return", TokenType::Keyword);
    
    // å®šä¹‰æ ‡è¯†ç¬¦æ¨¡å¼
    lexer.add_pattern("[a-zA-Z_][a-zA-Z0-9_]*", TokenType::Identifier);
    
    // å®šä¹‰æ•°å­—æ¨¡å¼
    lexer.add_pattern("[0-9]+(\.[0-9]+)?([eE][+-]?[0-9]+)?", TokenType::Number);
    
    // å®šä¹‰æ“ä½œç¬¦æ¨¡å¼
    lexer.add_pattern("[+\\-*/=<>!]=?", TokenType::Operator);
    
    lexer
}
```

### æ–‡æœ¬å¤„ç†

æ­£åˆ™è¡¨è¾¾å¼è¢«å¹¿æ³›åº”ç”¨äºæ–‡æœ¬æœç´¢ã€æ›¿æ¢å’ŒéªŒè¯ï¼Œæ˜¯ç°ä»£æ–‡æœ¬å¤„ç†çš„åŸºç¡€å·¥å…·ã€‚

```rust
fn validate_email(email: &str) -> bool {
    let email_regex = Regex::new(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$").unwrap();
    email_regex.is_match(email)
}
```

### åè®®éªŒè¯

åœ¨ç½‘ç»œåè®®ä¸­ï¼Œæ­£åˆ™è¯­è¨€ç”¨äºéªŒè¯æŠ¥æ–‡æ ¼å¼å’ŒçŠ¶æ€è½¬æ¢çš„æ­£ç¡®æ€§ã€‚

```rust
fn parse_http_request(request: &str) -> Option<HttpRequest> {
    let request_regex = Regex::new(
        r"^(GET|POST|PUT|DELETE) ([^ ]+) HTTP/(\d\.\d)\r\n"
    ).unwrap();
    
    if let Some(captures) = request_regex.captures(request) {
        Some(HttpRequest {
            method: captures[1].to_string(),
            path: captures[2].to_string(),
            version: captures[3].to_string(),
            // è¿›ä¸€æ­¥è§£æè¯·æ±‚å¤´...
        })
    } else {
        None
    }
}
```

## ğŸ”— ç›¸å…³å†…å®¹

- [03.3.1 ä¹”å§†æ–¯åŸºè°±ç³»](03.3.1_Chomsky_Hierarchy.md) - å½¢å¼è¯­è¨€å±‚æ¬¡æ¦‚è¿°
- [03.3.1.2 ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€](03.3.1.2_Context_Free_Languages.md) - æ­£åˆ™è¯­è¨€çš„è¶…é›†
- [03.2.1 æ­£åˆ™æ–‡æ³•](../03.2_Formal_Grammars/03.2.1_Regular_Grammar.md) - ç”Ÿæˆæ­£åˆ™è¯­è¨€çš„æ–‡æ³•
- [03.4.1 æœ‰é™è‡ªåŠ¨æœº](../03.4_Automata_Theory/03.4.1_Finite_Automata.md) - è¯†åˆ«æ­£åˆ™è¯­è¨€çš„è®¡ç®—æ¨¡å‹

---

**æ›´æ–°æ—¶é—´**: 2024-12-30  
**ç‰ˆæœ¬**: 1.0  
**çŠ¶æ€**: å®Œæˆåˆç¨¿


## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
