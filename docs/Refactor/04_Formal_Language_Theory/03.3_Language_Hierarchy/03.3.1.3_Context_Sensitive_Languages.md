# 03.3.1.3 ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ (Context-Sensitive Languages)

## ğŸ“š æ¦‚è¿°ä¸å®šä¹‰

ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€æ˜¯ä¹”å§†æ–¯åŸºå±‚æ¬¡ç»“æ„ä¸­çš„ç¬¬ä¸‰ç±»è¯­è¨€ï¼ˆ1å‹è¯­è¨€ï¼‰ï¼Œåœ¨å½¢å¼è¯­è¨€ç†è®ºå’Œè®¡ç®—æœºç§‘å­¦ä¸­å…·æœ‰é‡è¦æ„ä¹‰ã€‚

### å®šä¹‰ä¸ç‰¹å¾

**å®šä¹‰ 1.1** (ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€)
è¯­è¨€ $L$ æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³• $G$ï¼Œä½¿å¾— $L = L(G)$ã€‚

**å®šä¹‰ 1.2** (ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•)
ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ $G = (V, \Sigma, P, S)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯éç»ˆç»“ç¬¦é›†åˆ
- $\Sigma$ æ˜¯ç»ˆç»“ç¬¦é›†åˆ ($V \cap \Sigma = \emptyset$)
- $P$ æ˜¯äº§ç”Ÿå¼è§„åˆ™é›†åˆï¼Œæ¯ä¸ªè§„åˆ™å½¢å¼ä¸º $\alpha A \beta \rightarrow \alpha \gamma \beta$ï¼Œå…¶ä¸­ $A \in V$ ä¸” $\alpha, \beta, \gamma \in (V \cup \Sigma)^*$ï¼Œ$\gamma \neq \varepsilon$
- $S \in V$ æ˜¯å¼€å§‹ç¬¦å·

**ç‰¹å¾**:

- å…·æœ‰ä¸Šä¸‹æ–‡ä¾èµ–ç‰¹æ€§
- èƒ½å¤Ÿè¡¨ç¤ºäº¤å‰ä¾èµ–å…³ç³»ï¼ˆå¦‚ $a^n b^n c^n$ï¼‰
- æ”¯æŒæœ‰é™è®¡ç®—æ¨¡å‹ï¼ˆçº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºï¼‰
- ä¿æŒå­—ç¬¦ä¸²é•¿åº¦éå‡æ€§è´¨ï¼ˆé™¤ç‰¹æ®Šçš„ $S \to \varepsilon$ è§„åˆ™å¤–ï¼‰

### åœ¨ä¹”å§†æ–¯åŸºå±‚æ¬¡ä¸­çš„ä½ç½®

ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€åœ¨ä¹”å§†æ–¯åŸºè°±ç³»ä¸­å¤„äºè¾ƒé«˜å±‚æ¬¡ï¼š

- $\mathcal{L}_\text{Context-Free} \subset \mathcal{L}_\text{Context-Sensitive} \subset \mathcal{L}_\text{Recursively-Enumerable}$
- æ¯”ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€è¡¨è¾¾èƒ½åŠ›æ›´å¼ºï¼Œèƒ½å¤„ç†äº¤å‰ä¾èµ–å…³ç³»
- æ¯”é€’å½’å¯æšä¸¾è¯­è¨€è¡¨è¾¾èƒ½åŠ›æ›´å¼±ï¼Œå—é™äºçº¿æ€§ç©ºé—´è®¡ç®—

### åŸºæœ¬æ€§è´¨

- **ä¸Šä¸‹æ–‡ä¾èµ–æ€§**: ç¬¦å·çš„æ›¿æ¢å—å…¶ä¸Šä¸‹æ–‡å½±å“
- **äº¤å‰ä¾èµ–æ€§**: èƒ½å¤„ç†å¤šé‡ä¾èµ–å…³ç³»
- **éç¼©çŸ­æ€§**: äº§ç”Ÿå¼ä¸å‡å°‘å­—ç¬¦ä¸²é•¿åº¦ï¼ˆç‰¹æ®Šçš„ $S \to \varepsilon$ é™¤å¤–ï¼‰
- **é—­åŒ…æ€§**: åœ¨å¹¶ã€è¿æ¥ã€äº¤ã€æ˜Ÿé—­åŒ…ç­‰è®¸å¤šè¿ç®—ä¸‹ä¿æŒå°é—­
- **å¯åˆ¤å®šæ€§**: æˆå‘˜èµ„æ ¼é—®é¢˜å¯åˆ¤å®šï¼Œä½†éœ€è¦æŒ‡æ•°æ—¶é—´

## ğŸ” è¡¨ç¤ºæ–¹æ³•

### ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•

**å®šä¹‰ 2.1** (ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•ï¼Œç»†èŠ‚)
äº§ç”Ÿå¼è§„åˆ™å¯ä»¥å†™ä¸º $\alpha A \beta \rightarrow \alpha \gamma \beta$ï¼Œå…¶ä¸­ï¼š

- $A$ æ˜¯å•ä¸ªéç»ˆç»“ç¬¦
- $\alpha, \beta$ æ˜¯ä¸Šä¸‹æ–‡ï¼Œå¯ä»¥åŒ…å«ç»ˆç»“ç¬¦å’Œéç»ˆç»“ç¬¦
- $\gamma$ æ˜¯æ›¿æ¢ä¸²ï¼Œä¸èƒ½ä¸ºç©ºä¸²ï¼ˆ$\gamma \neq \varepsilon$ï¼‰ï¼Œé™¤éæœ‰å•ç‹¬è§„åˆ™ $S \to \varepsilon$ ä¸” $S$ ä¸å‡ºç°åœ¨ä»»ä½•è§„åˆ™å³ä¾§

**ä¾‹å­**:
æ–‡æ³• $G = (\{S, A, B, C\}, \{a, b, c\}, P, S)$ï¼Œå…¶ä¸­ $P$ åŒ…å«:

```text
S â†’ ABC
AB â†’ aAB
BC â†’ BC
aC â†’ aaC
C â†’ c
aB â†’ ab
bB â†’ bb
```

ç”Ÿæˆè¯­è¨€ $L(G) = \{a^n b^n c^n \mid n \geq 1\}$ã€‚

### çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº

**å®šä¹‰ 2.2** (çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºï¼ŒLBA)
çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $M = (Q, \Sigma, \Gamma, \delta, q_0, \#, F)$ï¼Œå…¶ä¸­ï¼š

- $Q$ æ˜¯çŠ¶æ€é›†
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\Gamma$ æ˜¯å·¥ä½œå­—æ¯è¡¨ï¼Œ$\Sigma \subset \Gamma$
- $\delta: Q \times \Gamma \to 2^{Q \times \Gamma \times \{L, R\}}$ æ˜¯è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $\#$ æ˜¯è¾¹ç•Œç¬¦å·
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†

LBAä¸å›¾çµæœºç±»ä¼¼ï¼Œä½†å…¶å·¥ä½œå¸¦å—é™äºè¾“å…¥é•¿åº¦ï¼ˆçº¿æ€§ç©ºé—´ï¼‰ã€‚

**å®šç† 2.3** (LBAç­‰ä»·æ€§)
è¯­è¨€ $L$ æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº $M$ï¼Œä½¿å¾— $L = L(M)$ã€‚

### éç¼©çŸ­æ–‡æ³•

**å®šä¹‰ 2.4** (éç¼©çŸ­æ–‡æ³•)
éç¼©çŸ­æ–‡æ³•æ˜¯ä¸€ä¸ªä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•ï¼Œå…¶ä¸­æ‰€æœ‰äº§ç”Ÿå¼ $\alpha \to \beta$ æ»¡è¶³ $|\alpha| \leq |\beta|$ï¼ˆé•¿åº¦éå‡ï¼‰ã€‚

**å®šç† 2.5** (éç¼©çŸ­æ–‡æ³•ç­‰ä»·æ€§)
éç¼©çŸ­æ–‡æ³•ä¸ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•åœ¨ç”Ÿæˆèƒ½åŠ›ä¸Šç­‰ä»·ï¼ˆå¯èƒ½éœ€è¦å¢åŠ ç‰¹æ®Šè§„åˆ™ $S \to \varepsilon$ï¼‰ã€‚

## ğŸ§  ç†è®ºåŸºç¡€

### æ–‡æ³•è½¬æ¢å’Œè§„èŒƒå½¢å¼

**å®šç† 3.1** (KurodaèŒƒå¼)
æ¯ä¸ªä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•éƒ½å¯ä»¥è½¬æ¢ä¸ºç­‰ä»·çš„KurodaèŒƒå¼ï¼Œå…¶ä¸­æ¯ä¸ªäº§ç”Ÿå¼å½¢å¼ä¸ºä»¥ä¸‹ä¹‹ä¸€ï¼š

- $A \to BC$ (å…¶ä¸­ $A, B, C \in V$)
- $A \to a$ (å…¶ä¸­ $A \in V, a \in \Sigma$)
- $AB \to CD$ (å…¶ä¸­ $A, B, C, D \in V$)
- $S \to \varepsilon$ (ä»…å½“ $\varepsilon \in L(G)$ï¼Œä¸” $S$ ä¸å‡ºç°åœ¨ä»»ä½•è§„åˆ™å³ä¾§)

**ç®—æ³• 3.2** (ç®€åŒ–ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•)

```rust
fn simplify_csg(grammar: &ContextSensitiveGrammar) -> ContextSensitiveGrammar {
    // 1. æ¶ˆé™¤æ— ç”¨ç¬¦å·
    let mut simplified = eliminate_useless_symbols(grammar);
    
    // 2. è§„èŒƒåŒ–äº§ç”Ÿå¼å½¢å¼
    let mut new_rules = Vec::new();
    let mut new_non_terminals = simplified.non_terminals.clone();
    
    for rule in &simplified.rules {
        match rule {
            Rule::ContextSensitive(lhs, rhs) => {
                // å¤„ç†å½¢å¦‚ Î±AÎ² â†’ Î±Î³Î² çš„è§„åˆ™
                if let Some((alpha, A, beta)) = extract_context(lhs) {
                    if A.is_non_terminal() {
                        if is_kuroda_form(&alpha, A, &beta, rhs) {
                            new_rules.push(rule.clone());
                        } else {
                            // å¼•å…¥æ–°çš„éç»ˆç»“ç¬¦å’Œè§„åˆ™ä»¥å®ç°Kurodaå½¢å¼
                            let kuroda_rules = transform_to_kuroda(&mut new_non_terminals, 
                                                                 &alpha, A, &beta, rhs);
                            new_rules.extend(kuroda_rules);
                        }
                    }
                }
            },
            Rule::StartToEpsilon => {
                // ä¿ç•™ S â†’ Îµ è§„åˆ™
                new_rules.push(rule.clone());
            }
        }
    }
    
    // 3. æ„é€ æ–°çš„æ–‡æ³•
    ContextSensitiveGrammar {
        non_terminals: new_non_terminals,
        terminals: simplified.terminals.clone(),
        rules: new_rules,
        start_symbol: simplified.start_symbol.clone()
    }
}

fn is_kuroda_form(alpha: &[Symbol], A: &Symbol, beta: &[Symbol], rhs: &[Symbol]) -> bool {
    if alpha.is_empty() && beta.is_empty() && rhs.len() == 1 && rhs[0].is_terminal() {
        return true; // A â†’ a
    }
    
    if alpha.is_empty() && beta.is_empty() && rhs.len() == 2 && 
       rhs[0].is_non_terminal() && rhs[1].is_non_terminal() {
        return true; // A â†’ BC
    }
    
    if alpha.is_empty() && beta.is_empty() && A.is_non_terminal() && 
       lhs.len() == 2 && rhs.len() == 2 && 
       lhs[0].is_non_terminal() && lhs[1].is_non_terminal() &&
       rhs[0].is_non_terminal() && rhs[1].is_non_terminal() {
        return true; // AB â†’ CD
    }
    
    false
}
```

### é—­åŒ…æ€§è´¨

**å®šç† 3.3** (é—­åŒ…æ€§è´¨)
ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ç±»åœ¨ä»¥ä¸‹æ“ä½œä¸‹å°é—­ï¼š

1. **å¹¶è¿ç®—**: å¦‚æœ $L_1, L_2$ æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼Œåˆ™ $L_1 \cup L_2$ ä¹Ÿæ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€
2. **è¿æ¥è¿ç®—**: å¦‚æœ $L_1, L_2$ æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼Œåˆ™ $L_1 \cdot L_2$ ä¹Ÿæ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€
3. **æ˜Ÿé—­åŒ…**: å¦‚æœ $L$ æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼Œåˆ™ $L^*$ ä¹Ÿæ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€
4. **äº¤è¿ç®—**: å¦‚æœ $L_1, L_2$ æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼Œåˆ™ $L_1 \cap L_2$ ä¹Ÿæ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€
5. **è¡¥è¿ç®—**: å¦‚æœ $L$ æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼Œåˆ™ $\Sigma^* - L$ ä¹Ÿæ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼ˆä¸é€’å½’è¯­è¨€ç­‰ä»·ï¼‰
6. **åŒæ€æ˜ å°„**: å¦‚æœ $L$ æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼Œ$h$ æ˜¯åŒæ€ï¼Œåˆ™ $h(L)$ ä¹Ÿæ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€
7. **é€†åŒæ€æ˜ å°„**: å¦‚æœ $L$ æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼Œ$h$ æ˜¯åŒæ€ï¼Œåˆ™ $h^{-1}(L)$ ä¹Ÿæ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€
8. **ä¸æ­£åˆ™è¯­è¨€çš„äº¤**: å¦‚æœ $L_1$ æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼Œ$L_2$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œåˆ™ $L_1 \cap L_2$ ä¹Ÿæ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€

### åˆ¤å®šæ€§é—®é¢˜

**å®šç† 3.4** (åˆ¤å®šé—®é¢˜)
å¯¹äºä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼Œæœ‰ä»¥ä¸‹åˆ¤å®šæ€§ç»“æœï¼š

1. **æˆå‘˜èµ„æ ¼é—®é¢˜**: å¯åˆ¤å®šï¼ˆPSPACEå®Œå…¨ï¼‰
2. **ç©ºæ€§é—®é¢˜**: å¯åˆ¤å®š
3. **æœ‰é™æ€§é—®é¢˜**: å¯åˆ¤å®š
4. **ç­‰ä»·æ€§é—®é¢˜**: ä¸å¯åˆ¤å®š
5. **åŒ…å«æ€§é—®é¢˜**: ä¸å¯åˆ¤å®š

**å®šç† 3.5** (å¤æ‚æ€§ç†è®ºç»“æœ)
ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ä¸ä»¥ä¸‹å¤æ‚æ€§ç±»æœ‰ç´§å¯†è”ç³»ï¼š

1. **NSPACE(n)**: éç¡®å®šæ€§çº¿æ€§ç©ºé—´
2. **PSPACE**: å¤šé¡¹å¼ç©ºé—´
3. **EXPTIME**: æŒ‡æ•°æ—¶é—´

## ğŸ”¢ ç®—æ³•ä¸å¤æ‚æ€§

### æˆå‘˜èµ„æ ¼é—®é¢˜

**ç®—æ³• 4.1** (ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€æˆå‘˜èµ„æ ¼æ£€æŸ¥)
ç»™å®šä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³• $G$ å’Œå­—ç¬¦ä¸² $w$ï¼Œåˆ¤æ–­ $w \in L(G)$ï¼š

```rust
fn check_membership_csg(grammar: &ContextSensitiveGrammar, input: &str) -> bool {
    // å°†è¾“å…¥å­—ç¬¦ä¸²è½¬æ¢ä¸ºç¬¦å·åºåˆ—
    let w: Vec<Symbol> = input.chars()
        .map(|c| Symbol::Terminal(c.to_string()))
        .collect();
    
    // åˆå§‹åŒ–å·¥ä½œé›†åˆ
    let max_length = w.len() + 1; // ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€å¯èƒ½æœ‰Sâ†’Îµè§„åˆ™
    let mut working_set: HashSet<Vec<Symbol>> = HashSet::new();
    working_set.insert(vec![Symbol::NonTerminal(grammar.start_symbol.clone())]);
    
    // è¿½è¸ªå·²ç»æ£€æŸ¥è¿‡çš„å¥å‹ï¼Œä»¥é¿å…é‡å¤å·¥ä½œ
    let mut visited = HashSet::new();
    
    // å¾ªç¯ç›´åˆ°æ²¡æœ‰æ–°çš„å¥å‹å¯ä»¥ç”Ÿæˆ
    let mut changed = true;
    while changed {
        changed = false;
        let mut new_sentential_forms = HashSet::new();
        
        for sentential_form in &working_set {
            if sentential_form == &w {
                return true; // æ‰¾åˆ°åŒ¹é…
            }
            
            if sentential_form.len() > max_length || visited.contains(sentential_form) {
                continue;
            }
            
            visited.insert(sentential_form.clone());
            
            // å°è¯•åº”ç”¨æ¯æ¡äº§ç”Ÿå¼è§„åˆ™
            for rule in &grammar.rules {
                match rule {
                    Rule::ContextSensitive(lhs, rhs) => {
                        // å°è¯•åœ¨å½“å‰å¥å‹ä¸­åº”ç”¨ä¸Šä¸‹æ–‡ç›¸å…³è§„åˆ™
                        let new_forms = apply_rule(sentential_form, lhs, rhs);
                        for new_form in new_forms {
                            if !visited.contains(&new_form) {
                                new_sentential_forms.insert(new_form);
                                changed = true;
                            }
                        }
                    },
                    Rule::StartToEpsilon => {
                        // å¤„ç†ç‰¹æ®Šçš„Sâ†’Îµè§„åˆ™
                        if sentential_form == &[Symbol::NonTerminal(grammar.start_symbol.clone())] {
                            let epsilon = Vec::new(); // ç©ºåºåˆ—
                            if !visited.contains(&epsilon) {
                                new_sentential_forms.insert(epsilon);
                                changed = true;
                            }
                        }
                    }
                }
            }
        }
        
        // æ›´æ–°å·¥ä½œé›†åˆ
        working_set.extend(new_sentential_forms);
    }
    
    // æ£€æŸ¥æ˜¯å¦ç”Ÿæˆäº†ç›®æ ‡å­—ç¬¦ä¸²
    working_set.contains(&w)
}

fn apply_rule(form: &[Symbol], lhs: &[Symbol], rhs: &[Symbol]) -> Vec<Vec<Symbol>> {
    let mut results = Vec::new();
    
    for i in 0..=form.len() - lhs.len() {
        if form[i..i + lhs.len()] == *lhs {
            let mut new_form = Vec::with_capacity(form.len() - lhs.len() + rhs.len());
            new_form.extend_from_slice(&form[0..i]);
            new_form.extend_from_slice(rhs);
            new_form.extend_from_slice(&form[i + lhs.len()..]);
            results.push(new_form);
        }
    }
    
    results
}
```

### ç©ºæ€§é—®é¢˜

**ç®—æ³• 4.2** (ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ç©ºæ€§é—®é¢˜)
åˆ¤æ–­ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³• $G$ ç”Ÿæˆçš„è¯­è¨€æ˜¯å¦ä¸ºç©ºï¼š

```rust
fn is_empty_csg(grammar: &ContextSensitiveGrammar) -> bool {
    // å¦‚æœæ–‡æ³•æœ‰Sâ†’Îµè§„åˆ™ï¼Œåˆ™è¯­è¨€ä¸ä¸ºç©º
    for rule in &grammar.rules {
        if let Rule::StartToEpsilon = rule {
            return false;
        }
    }
    
    // è®¡ç®—å¯è¾¾ç»ˆç»“ç¬¦åºåˆ—
    let mut reachable_terminals = HashSet::new();
    let mut changed = true;
    
    while changed {
        changed = false;
        
        for rule in &grammar.rules {
            if let Rule::ContextSensitive(lhs, rhs) = rule {
                // æ£€æŸ¥å·¦ä¾§æ˜¯å¦å¯è¾¾
                if is_reachable(lhs, &reachable_terminals, &grammar.start_symbol) {
                    // æ ‡è®°å³ä¾§ä¸ºå¯è¾¾
                    if mark_reachable(rhs, &mut reachable_terminals) {
                        changed = true;
                    }
                }
            }
        }
    }
    
    // æ£€æŸ¥æ˜¯å¦æœ‰å®Œå…¨ç”±ç»ˆç»“ç¬¦ç»„æˆçš„å¯è¾¾åºåˆ—
    for seq in &reachable_terminals {
        if seq.iter().all(|s| s.is_terminal()) {
            return false; // æ‰¾åˆ°è‡³å°‘ä¸€ä¸ªç»ˆç»“ç¬¦åºåˆ—ï¼Œè¯­è¨€ä¸ä¸ºç©º
        }
    }
    
    true // æ²¡æœ‰æ‰¾åˆ°ç»ˆç»“ç¬¦åºåˆ—ï¼Œè¯­è¨€ä¸ºç©º
}
```

### å¤æ‚åº¦åˆ†æ

**å®šç† 4.3** (æˆå‘˜èµ„æ ¼é—®é¢˜å¤æ‚åº¦)
ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€çš„æˆå‘˜èµ„æ ¼é—®é¢˜æ˜¯PSPACEå®Œå…¨çš„ã€‚

**è¯æ˜**:

1. **PSPACE-hardness**: é€šè¿‡ä»çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºæ¥å—é—®é¢˜çš„å½’çº¦
2. **PSPACE-membership**: é€šè¿‡éç¡®å®šæ€§çº¿æ€§ç©ºé—´ç®—æ³•æ¨¡æ‹Ÿæ¨å¯¼è¿‡ç¨‹

**å®šç† 4.4** (ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ä¸ç¡®å®šæ€§å›¾çµæœº)
æ¯ä¸ªä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€éƒ½å¯ä»¥è¢«ä¸€ä¸ªå…·æœ‰ $2^{O(n)}$ æ—¶é—´å¤æ‚åº¦å’Œçº¿æ€§ç©ºé—´å¤æ‚åº¦çš„ç¡®å®šæ€§å›¾çµæœºè¯†åˆ«ã€‚

## ğŸ’¼ åº”ç”¨åœºæ™¯

### è‡ªç„¶è¯­è¨€å¤„ç†

ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•åœ¨è‡ªç„¶è¯­è¨€å¤„ç†ä¸­ç”¨äºæ¨¡æ‹Ÿæ›´å¤æ‚çš„è¯­æ³•ç»“æ„ï¼š

```rust
// ç®€å•çš„è·¨åº¦åˆ†æå™¨
fn parse_crossed_dependencies(tokens: &[Word]) -> Option<DependencyTree> {
    // å¤„ç†å½¢å¦‚ "Peter Jan Marie zag helpen zwemmen" çš„è·å…°è¯­äº¤å‰ä¾èµ–
    // (Peter Jan Marie saw help swim = "Peter saw Jan help Marie swim")
    
    // æ£€æŸ¥åè¯-åŠ¨è¯å¯¹åº”å…³ç³»
    if tokens.len() < 6 || tokens.len() % 2 != 0 {
        return None;
    }
    
    let nouns_count = tokens.len() / 2;
    for i in 0..nouns_count {
        if tokens[i].pos != POS::Noun {
            return None;
        }
    }
    
    for i in nouns_count..tokens.len() {
        if tokens[i].pos != POS::Verb {
            return None;
        }
    }
    
    // æ„å»ºä¾èµ–æ ‘
    let mut root = DependencyNode {
        word: tokens[nouns_count].clone(), // ç¬¬ä¸€ä¸ªåŠ¨è¯ä½œä¸ºæ ¹èŠ‚ç‚¹
        children: Vec::new(),
    };
    
    let mut current = &mut root;
    for i in 1..nouns_count {
        let noun_idx = i;
        let verb_idx = nouns_count + i;
        
        let new_node = DependencyNode {
            word: tokens[verb_idx].clone(),
            children: vec![
                DependencyNode {
                    word: tokens[noun_idx].clone(),
                    children: Vec::new(),
                }
            ],
        };
        
        current.children.push(new_node);
        current = current.children.last_mut().unwrap();
    }
    
    Some(DependencyTree { root })
}
```

### å›¾åƒè¯­æ³•

ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ç”¨äºäºŒç»´å›¾åƒçš„ç”Ÿæˆå’Œåˆ†æï¼š

```rust
// äºŒç»´å›¾åƒæ–‡æ³•å®ç°
struct ImageGrammar {
    non_terminals: HashSet<char>,
    terminals: HashSet<char>, // è¡¨ç¤ºåƒç´ æˆ–å›¾åƒåŸè¯­
    rules: Vec<ImageRule>,
    start_symbol: char,
}

struct ImageRule {
    lhs: Vec<Vec<char>>, // äºŒç»´å·¦ä¾§æ¨¡å¼
    rhs: Vec<Vec<char>>, // äºŒç»´å³ä¾§æ¨¡å¼
}

impl ImageGrammar {
    fn generate(&self, steps: usize) -> Vec<Vec<char>> {
        let mut image = vec![vec![self.start_symbol]];
        
        for _ in 0..steps {
            image = self.apply_rules(image);
        }
        
        // ç§»é™¤æ‰€æœ‰éç»ˆç«¯ç¬¦å·
        self.clean_non_terminals(&mut image);
        image
    }
    
    fn apply_rules(&self, current: Vec<Vec<char>>) -> Vec<Vec<char>> {
        // åœ¨äºŒç»´ç½‘æ ¼ä¸­åº”ç”¨ä¸Šä¸‹æ–‡ç›¸å…³è§„åˆ™
        for rule in &self.rules {
            if let Some(new_image) = self.apply_rule(&current, rule) {
                return new_image;
            }
        }
        
        current // æ²¡æœ‰è§„åˆ™é€‚ç”¨æ—¶ä¿æŒä¸å˜
    }
    
    fn apply_rule(&self, image: &Vec<Vec<char>>, rule: &ImageRule) -> Option<Vec<Vec<char>>> {
        // å®ç°åœ¨äºŒç»´å›¾åƒä¸­æœç´¢å’Œåº”ç”¨è§„åˆ™çš„é€»è¾‘
        // ...çœç•¥å¤æ‚å®ç°...
        None // ç®€åŒ–å®ç°
    }
    
    fn clean_non_terminals(&self, image: &mut Vec<Vec<char>>) {
        for row in image.iter_mut() {
            for cell in row.iter_mut() {
                if self.non_terminals.contains(cell) {
                    *cell = ' '; // ç”¨ç©ºç™½æ›¿æ¢éç»ˆç»“ç¬¦
                }
            }
        }
    }
}
```

### ç”Ÿç‰©åºåˆ—åˆ†æ

ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ç”¨äºåˆ†æDNAå’ŒRNAçš„å¤æ‚ç»“æ„ï¼š

```rust
// RNAäºŒçº§ç»“æ„åˆ†æ
struct RNAStructureAnalyzer {
    grammar: ContextSensitiveGrammar,
}

impl RNAStructureAnalyzer {
    fn new() -> Self {
        // æ„å»ºç”¨äºRNAç»“æ„åˆ†æçš„ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•
        let mut grammar = ContextSensitiveGrammar::new();
        
        // æ·»åŠ åŸºæœ¬é…å¯¹è§„åˆ™
        grammar.add_rule("A", "U"); // Aä¸Ué…å¯¹
        grammar.add_rule("U", "A");
        grammar.add_rule("G", "C"); // Gä¸Cé…å¯¹
        grammar.add_rule("C", "G");
        
        // æ·»åŠ ä¸Šä¸‹æ–‡è§„åˆ™ï¼Œç”¨äºå¤„ç†å‡ç»“
        grammar.add_context_rule("S X S", "S P S", Some("Pä»£è¡¨é…å¯¹"));
        grammar.add_context_rule("P A", "A P", None); // å…è®¸ç¢±åŸºç©¿è¿‡é…å¯¹
        grammar.add_context_rule("P U", "U P", None);
        grammar.add_context_rule("P G", "G P", None);
        grammar.add_context_rule("P C", "C P", None);
        
        // è®¾ç½®èµ·å§‹ç¬¦å·
        grammar.set_start_symbol("S");
        
        RNAStructureAnalyzer { grammar }
    }
    
    fn analyze(&self, sequence: &str) -> Option<RNAStructure> {
        // ä½¿ç”¨ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•åˆ†æRNAåºåˆ—
        let symbols: Vec<_> = sequence.chars().collect();
        if self.grammar.accepts(&symbols) {
            // æ„é€ RNAäºŒçº§ç»“æ„
            let mut structure = RNAStructure::new(sequence);
            
            // è¯†åˆ«èŒç¯å’Œå‡ç»“
            self.identify_stem_loops(&mut structure);
            self.identify_pseudo_knots(&mut structure);
            
            Some(structure)
        } else {
            None
        }
    }
    
    fn identify_stem_loops(&self, structure: &mut RNAStructure) {
        // å®ç°èŒç¯ç»“æ„è¯†åˆ«
    }
    
    fn identify_pseudo_knots(&self, structure: &mut RNAStructure) {
        // å®ç°å‡ç»“ç»“æ„è¯†åˆ«ï¼Œè¿™éœ€è¦ä¸Šä¸‹æ–‡ç›¸å…³èƒ½åŠ›
    }
}
```

## ğŸ”— ç›¸å…³å†…å®¹

- [03.3.1 ä¹”å§†æ–¯åŸºè°±ç³»](./03.3.1_Chomsky_Hierarchy.md) - å½¢å¼è¯­è¨€å±‚æ¬¡æ¦‚è¿°
- [03.3.1.2 ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€](./03.3.1.2_Context_Free_Languages.md) - ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€çš„å­é›†
- [03.3.1.4 é€’å½’å¯æšä¸¾è¯­è¨€](./03.3.1.4_Recursively_Enumerable_Languages.md) - ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€çš„è¶…é›†
- [03.2.3 ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•](../03.2_Formal_Grammars/03.2.3_Context_Sensitive_Grammar.md) - ç”Ÿæˆä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€çš„æ–‡æ³•
- [03.4.3 çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº](../03.4_Automata_Theory/03.4.3_Linear_Bounded_Automata.md) - è¯†åˆ«ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€çš„è®¡ç®—æ¨¡å‹

---

**æ›´æ–°æ—¶é—´**: 2024-12-30  
**ç‰ˆæœ¬**: 1.0  
**çŠ¶æ€**: å®Œæˆåˆç¨¿
