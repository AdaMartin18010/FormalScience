# 03.1.4 图灵机 (Turing Machine)

## 📚 概述

图灵机是最强大的计算模型，由英国数学家艾伦·图灵于1936年提出。它具有无限长的工作带和可以在带上任意移动的读写头，能够识别所有递归可枚举语言，是现代计算机的理论基础。

## 🔍 形式定义

### 标准图灵机

**定义 3.1.19** (图灵机)
图灵机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$，其中：

1. $Q$ 是有限状态集
2. $\Sigma$ 是输入字母表
3. $\Gamma$ 是带字母表，$\Sigma \subset \Gamma$
4. $\delta: Q \times \Gamma \to Q \times \Gamma \times \{L, R\}$ 是转移函数
5. $q_0 \in Q$ 是初始状态
6. $B \in \Gamma - \Sigma$ 是空白符号
7. $F \subseteq Q$ 是接受状态集

## 🔄 配置与计算

### 配置

**定义 3.1.20** (图灵机配置)
图灵机的配置是一个三元组 $(q, \alpha, i)$，其中：

- $q \in Q$ 是当前状态
- $\alpha \in \Gamma^*$ 是当前带内容
- $i$ 是读写头位置，$1 \leq i \leq |\alpha|$

### 转移关系

**定义 3.1.21** (转移关系)
配置转移关系 $\vdash$ 定义为：
如果 $\delta(q, \alpha_i) = (p, b, D)$，则：

- 如果 $D = R$，则 $(q, \alpha, i) \vdash (p, \alpha', i+1)$，其中 $\alpha'$ 是将 $\alpha$ 中第 $i$ 个符号替换为 $b$ 的结果
- 如果 $D = L$，则 $(q, \alpha, i) \vdash (p, \alpha', i-1)$，其中 $\alpha'$ 是将 $\alpha$ 中第 $i$ 个符号替换为 $b$ 的结果

如果读写头移动超出当前带内容，则自动扩展带，添加空白符号。

### 接受语言

**定义 3.1.22** (接受语言)
图灵机 $M$ 接受的语言定义为：
$$L(M) = \{w \in \Sigma^* \mid (q_0, w, 1) \vdash^* (q, \alpha, i), q \in F\}$$

其中 $\vdash^*$ 表示转移关系的自反传递闭包。

## 📊 图灵机的变体

### 多带图灵机

**定义 3.1.23** (多带图灵机)
多带图灵机有多个工作带，每个带有自己的读写头，可以独立移动。

**定理 3.1.12** (多带图灵机的等价性)
对于每个多带图灵机，存在等价的单带图灵机。

### 非确定性图灵机

**定义 3.1.24** (非确定性图灵机)
非确定性图灵机的转移函数为 $\delta: Q \times \Gamma \to 2^{Q \times \Gamma \times \{L, R\}}$。

**定理 3.1.13** (非确定性图灵机的等价性)
对于每个非确定性图灵机，存在等价的确定性图灵机。

### 通用图灵机

**定义 3.1.25** (通用图灵机)
通用图灵机是一个可以模拟任何图灵机的图灵机。

**定理 3.1.14** (通用图灵机的存在性)
存在通用图灵机 $U$，它可以接受输入 $\langle M, w \rangle$ 并模拟图灵机 $M$ 对输入 $w$ 的计算。

## 🧠 可计算性理论

### 图灵可计算函数

**定义 3.1.26** (图灵可计算函数)
函数 $f: \Sigma^* \to \Sigma^*$ 是图灵可计算的，当且仅当存在图灵机 $M$，使得对于任意 $w \in \Sigma^*$，$M$ 在输入 $w$ 上停机，且最终带内容为 $f(w)$。

### 停机问题

**定理 3.1.15** (停机问题的不可判定性)
停机问题是不可判定的，即不存在图灵机可以判定任意图灵机 $M$ 是否在任意输入 $w$ 上停机。

**证明概要**：
使用对角线法证明，假设存在这样的图灵机 $H$，构造一个图灵机 $D$ 使得 $D$ 在输入 $\langle M \rangle$ 上的行为与 $M$ 在输入 $\langle M \rangle$ 上的行为相反，导出矛盾。

### 递归可枚举语言

**定义 3.1.27** (递归可枚举语言)
语言 $L$ 是递归可枚举的，当且仅当存在图灵机 $M$ 使得 $L = L(M)$。

**定义 3.1.28** (递归语言)
语言 $L$ 是递归的，当且仅当 $L$ 和 $\overline{L}$ 都是递归可枚举的。

**定理 3.1.16** (递归语言的判定性)
语言 $L$ 是递归的，当且仅当存在总是停机的图灵机 $M$ 使得 $L = L(M)$。

## 🔗 与其他计算模型的等价性

### 丘奇-图灵论题

**定理 3.1.17** (丘奇-图灵论题)
任何"有效计算"都可以由图灵机实现。

这不是一个可证明的数学定理，而是一个广泛接受的假设，表明图灵机模型捕获了直觉上的"算法"概念。

### 等价计算模型

以下计算模型与图灵机在计算能力上等价：

1. **λ演算**：丘奇发明的函数式计算模型
2. **递归函数**：基于原始递归和μ递归的计算模型
3. **寄存器机**：基于寄存器操作的计算模型
4. **标签系统**：基于符号重写的计算模型
5. **细胞自动机**：基于局部规则的并行计算模型

## 🛠️ 应用

1. **计算理论**：定义算法和可计算性的基础
2. **复杂性理论**：研究计算问题的复杂度
3. **形式验证**：验证程序和系统的正确性
4. **人工智能**：理解智能的计算限制

## 🔗 实现示例

```python
class TuringMachine:
    def __init__(self, states, input_alphabet, tape_alphabet, 
                 transitions, start_state, blank_symbol, 
                 accept_states):
        self.states = states
        self.input_alphabet = input_alphabet
        self.tape_alphabet = tape_alphabet
        self.transitions = transitions
        self.start_state = start_state
        self.blank_symbol = blank_symbol
        self.accept_states = accept_states
    
    def accepts(self, input_string):
        # 初始配置
        current_state = self.start_state
        tape = list(input_string)
        head_position = 0
        
        # 最大步数（防止无限循环）
        max_steps = 10000
        steps = 0
        
        while steps < max_steps:
            steps += 1
            
            # 检查是否接受
            if current_state in self.accept_states:
                return True
            
            # 扩展带（如果需要）
            while head_position < 0:
                tape.insert(0, self.blank_symbol)
                head_position += 1
            
            while head_position >= len(tape):
                tape.append(self.blank_symbol)
            
            # 获取当前符号
            current_symbol = tape[head_position]
            
            # 查找转移
            if (current_state, current_symbol) not in self.transitions:
                return False
            
            next_state, new_symbol, direction = self.transitions[(current_state, current_symbol)]
            
            # 更新带内容
            tape[head_position] = new_symbol
            
            # 移动读写头
            if direction == 'R':
                head_position += 1
            else:  # direction == 'L'
                head_position -= 1
            
            # 更新状态
            current_state = next_state
        
        return False  # 达到最大步数仍未接受
```

## 🔗 相关内容

- [03.1.3 线性有界自动机](./03.1.3_Linear_Bounded_Automata.md) - 受限的图灵机
- [03.2.4 无限制文法](../03.2_Formal_Grammars/03.2.4_Unrestricted_Grammar.md) - 与图灵机等价的文法
- [03.6.1 可计算性理论](../03.6_Computation_Theory/03.6.1_Computability_Theory.md) - 基于图灵机的可计算性研究
- [03.6.2 复杂性理论](../03.6_Computation_Theory/03.6.2_Complexity_Theory.md) - 研究计算问题的复杂度

---

**更新时间**: 2024-12-25  
**版本**: 2.0  
**状态**: 已完成
