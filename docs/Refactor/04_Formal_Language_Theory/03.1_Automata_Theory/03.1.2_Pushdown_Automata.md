# 03.1.2 下推自动机 (Pushdown Automata)

## 📚 概述

下推自动机是比有限自动机更强大的计算模型，通过引入一个栈结构来增强其记忆能力。下推自动机能够识别上下文无关语言，是编译器设计中语法分析的理论基础。

## 🔍 主要类型

### 非确定性下推自动机 (NPDA)

**定义 3.1.10** (非确定性下推自动机)
非确定性下推自动机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$，其中：

1. $Q$ 是有限状态集
2. $\Sigma$ 是输入字母表
3. $\Gamma$ 是栈字母表
4. $\delta: Q \times (\Sigma \cup \{\varepsilon\}) \times \Gamma \to 2^{Q \times \Gamma^*}$ 是转移函数
5. $q_0 \in Q$ 是初始状态
6. $Z_0 \in \Gamma$ 是初始栈符号
7. $F \subseteq Q$ 是接受状态集

**特点**：

- 非确定性：一个配置可能有多个后继配置
- 栈记忆：可以存储无限长度的信息
- 计算能力：可以识别所有上下文无关语言

### 确定性下推自动机 (DPDA)

**定义 3.1.9** (确定性下推自动机)
确定性下推自动机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$，其中：

1. $Q$ 是有限状态集
2. $\Sigma$ 是输入字母表
3. $\Gamma$ 是栈字母表
4. $\delta: Q \times (\Sigma \cup \{\varepsilon\}) \times \Gamma \to Q \times \Gamma^*$ 是转移函数
5. $q_0 \in Q$ 是初始状态
6. $Z_0 \in \Gamma$ 是初始栈符号
7. $F \subseteq Q$ 是接受状态集

**约束条件**：对于任意 $q \in Q$, $a \in \Sigma$, $Z \in \Gamma$，如果 $\delta(q, \varepsilon, Z)$ 已定义，则对所有 $b \in \Sigma$，$\delta(q, b, Z)$ 未定义。

**特点**：

- 确定性：每个配置最多有一个后继配置
- 计算能力：识别确定性上下文无关语言，是上下文无关语言的真子集

## 🔄 配置与计算

### 配置

**定义 3.1.11** (配置)
下推自动机的配置是一个三元组 $(q, w, \gamma)$，其中：

- $q \in Q$ 是当前状态
- $w \in \Sigma^*$ 是剩余输入串
- $\gamma \in \Gamma^*$ 是栈内容

### 转移关系

**定义 3.1.12** (转移关系)
配置转移关系 $\vdash$ 定义为：
$(q, aw, Z\gamma) \vdash (p, w, \alpha\gamma)$ 当且仅当 $(p, \alpha) \in \delta(q, a, Z)$

其中 $a \in \Sigma \cup \{\varepsilon\}$，$Z$ 是栈顶符号，$\alpha$ 是替换栈顶的符号串。

### 接受方式

**定义 3.1.13** (终态接受)
下推自动机 $M$ 终态接受的语言定义为：
$$L(M) = \{w \in \Sigma^* \mid (q_0, w, Z_0) \vdash^* (q, \varepsilon, \gamma), q \in F\}$$

**定义 3.1.14** (空栈接受)
下推自动机 $M$ 空栈接受的语言定义为：
$$N(M) = \{w \in \Sigma^* \mid (q_0, w, Z_0) \vdash^* (q, \varepsilon, \varepsilon)\}$$

## 📊 理论性质

### 与上下文无关语言的等价性

**定理 3.1.5** (NPDA与上下文无关语言的等价性)
NPDA接受的语言类恰好是上下文无关语言类。

**证明概要**：

1. 从上下文无关文法到NPDA：可以构造一个NPDA来模拟文法的推导过程
2. 从NPDA到上下文无关文法：可以构造一个文法来模拟NPDA的计算过程

### DPDA与NPDA的不等价性

**定理 3.1.6** (DPDA与NPDA的不等价性)
存在被NPDA接受但不被任何DPDA接受的语言。

**证明**：
考虑语言 $L = \{ww^R \mid w \in \{a,b\}^*\}$，其中 $w^R$ 是 $w$ 的反转。可以构造NPDA接受L，但可以证明不存在DPDA接受L。

### 终态接受与空栈接受的等价性

**定理 3.1.7** (接受方式的等价性)
对于每个终态接受的NPDA，存在一个空栈接受的NPDA接受相同的语言，反之亦然。

**证明概要**：

1. 从终态接受到空栈接受：在接受状态时清空栈
2. 从空栈接受到终态接受：在栈空时进入接受状态

## 🛠️ 应用

1. **语法分析**：编译器中的语法分析器
2. **括号匹配**：检查括号是否匹配
3. **回文识别**：识别形如 $ww^R$ 的回文
4. **表达式求值**：计算算术表达式的值

## 🔗 实现示例

```python
class PDA:
    def __init__(self, states, input_alphabet, stack_alphabet, 
                 transitions, start_state, start_stack_symbol, 
                 accept_states):
        self.states = states
        self.input_alphabet = input_alphabet
        self.stack_alphabet = stack_alphabet
        self.transitions = transitions
        self.start_state = start_state
        self.start_stack_symbol = start_stack_symbol
        self.accept_states = accept_states
    
    def accepts(self, input_string):
        # 初始配置
        configurations = [(self.start_state, input_string, [self.start_stack_symbol])]
        
        while configurations:
            state, remaining_input, stack = configurations.pop(0)
            
            # 检查是否接受
            if not remaining_input and state in self.accept_states:
                return True
            
            # 获取当前栈顶
            stack_top = stack[-1] if stack else None
            
            # 尝试ε转移
            if (state, '', stack_top) in self.transitions:
                for next_state, new_stack_top in self.transitions[(state, '', stack_top)]:
                    new_stack = stack[:-1] + list(new_stack_top)
                    configurations.append((next_state, remaining_input, new_stack))
            
            # 尝试常规转移
            if remaining_input and (state, remaining_input[0], stack_top) in self.transitions:
                for next_state, new_stack_top in self.transitions[(state, remaining_input[0], stack_top)]:
                    new_stack = stack[:-1] + list(new_stack_top)
                    configurations.append((next_state, remaining_input[1:], new_stack))
        
        return False
```

## 🔗 相关内容

- [03.1.1 有限自动机](./03.1.1_Finite_Automata.md) - 比下推自动机更简单的计算模型
- [03.1.3 线性有界自动机](./03.1.3_Linear_Bounded_Automata.md) - 比下推自动机更强大的计算模型
- [03.2.2 上下文无关文法](../03.2_Formal_Grammars/03.2.2_Context_Free_Grammar.md) - 与下推自动机等价的文法
- [03.4 解析理论](../03.4_Parsing_Theory.md) - 基于下推自动机的语法分析方法

---

**更新时间**: 2024-12-25  
**版本**: 2.0  
**状态**: 已完成
