# 03.1.3 线性有界自动机 (Linear Bounded Automata)

## 📚 概述

线性有界自动机（LBA）是一种受限的图灵机，其工作带的长度与输入串的长度成线性关系。它是介于下推自动机和图灵机之间的计算模型，能够识别上下文相关语言，但不能识别所有递归可枚举语言。

## 🔍 形式定义

**定义 3.1.15** (线性有界自动机)
线性有界自动机是一个七元组 $M = (Q, \Sigma, \Gamma, \delta, q_0, \#, F)$，其中：

1. $Q$ 是有限状态集
2. $\Sigma$ 是输入字母表
3. $\Gamma$ 是带字母表，$\Sigma \subset \Gamma$
4. $\delta: Q \times \Gamma \to Q \times \Gamma \times \{L, R\}$ 是转移函数
5. $q_0 \in Q$ 是初始状态
6. $\#$ 是带边界标记，$\# \in \Gamma - \Sigma$
7. $F \subseteq Q$ 是接受状态集

**约束条件**：

- 计算只能在输入串占据的带单元及其两端的边界标记上进行
- 边界标记不能被改写或越过

## 🔄 配置与计算

### 配置

**定义 3.1.16** (线性有界自动机配置)
线性有便自动机的配置是一个三元组 $(q, w, i)$，其中：

- $q \in Q$ 是当前状态
- $w \in \Gamma^*$ 是当前带内容
- $i$ 是读写头位置，$1 \leq i \leq |w|$

### 转移关系

**定义 3.1.17** (转移关系)
配置转移关系 $\vdash$ 定义为：
如果 $\delta(q, w_i) = (p, b, D)$，则：

- 如果 $D = R$ 且 $i < |w|$，则 $(q, w, i) \vdash (p, w'，i+1)$，其中 $w'$ 是将 $w$ 中第 $i$ 个符号替换为 $b$ 的结果
- 如果 $D = L$ 且 $i > 1$，则 $(q, w, i) \vdash (p, w', i-1)$，其中 $w'$ 是将 $w$ 中第 $i$ 个符号替换为 $b$ 的结果

### 接受语言

**定义 3.1.18** (接受语言)
线性有界自动机 $M$ 接受的语言定义为：
$$L(M) = \{w \in \Sigma^* \mid (q_0, \# w \#, 1) \vdash^* (q, u, i), q \in F\}$$

其中 $\vdash^*$ 表示转移关系的自反传递闭包。

## 📊 理论性质

### 与上下文相关语言的等价性

**定理 3.1.8** (LBA与上下文相关语言的等价性)
线性有界自动机接受的语言类恰好是上下文相关语言类。

**证明概要**：

1. 从上下文相关文法到LBA：可以构造一个LBA来模拟文法的推导过程
2. 从LBA到上下文相关文法：可以构造一个文法来模拟LBA的计算过程

### 封闭性

**定理 3.1.9** (上下文相关语言的封闭性)
上下文相关语言在以下运算下封闭：

1. 并集
2. 交集
3. 连接
4. 克林闭包
5. 补集

### 判定性质

**定理 3.1.10** (LBA的可判定性)
线性有界自动机的空语言问题是可判定的。

**证明概要**：
由于LBA的配置数量是有限的（不超过 $|Q| \times |\Gamma|^n \times n$，其中 $n$ 是输入长度），可以通过枚举所有可能的配置来判定是否存在接受计算。

**定理 3.1.11** (LBA的等价性问题)
线性有界自动机的等价性问题是不可判定的。

## 🔗 与其他自动机的关系

```text
计算能力层次：FA < PDA < LBA < TM
```

1. **有限自动机(FA)**：只能识别正则语言
2. **下推自动机(PDA)**：可以识别上下文无关语言
3. **线性有界自动机(LBA)**：可以识别上下文相关语言
4. **图灵机(TM)**：可以识别所有递归可枚举语言

## 🛠️ 应用

1. **自然语言处理**：处理具有上下文相关特性的自然语言
2. **编译优化**：需要上下文信息的编译器优化
3. **模式识别**：识别具有上下文依赖的模式
4. **生物序列分析**：DNA和蛋白质序列中的上下文相关模式

## 🔗 实现示例

```python
class LBA:
    def __init__(self, states, input_alphabet, tape_alphabet, 
                 transitions, start_state, boundary_marker, 
                 accept_states):
        self.states = states
        self.input_alphabet = input_alphabet
        self.tape_alphabet = tape_alphabet
        self.transitions = transitions
        self.start_state = start_state
        self.boundary_marker = boundary_marker
        self.accept_states = accept_states
    
    def accepts(self, input_string):
        # 初始配置
        current_state = self.start_state
        tape = [self.boundary_marker] + list(input_string) + [self.boundary_marker]
        head_position = 1  # 初始位置在左边界标记之后
        
        # 最大步数（防止无限循环）
        max_steps = len(self.states) * len(tape) * len(tape)
        steps = 0
        
        while steps < max_steps:
            steps += 1
            
            # 检查是否接受
            if current_state in self.accept_states:
                return True
            
            # 获取当前符号
            current_symbol = tape[head_position]
            
            # 查找转移
            if (current_state, current_symbol) not in self.transitions:
                return False
            
            next_state, new_symbol, direction = self.transitions[(current_state, current_symbol)]
            
            # 更新带内容
            tape[head_position] = new_symbol
            
            # 移动读写头
            if direction == 'R' and head_position < len(tape) - 1:
                head_position += 1
            elif direction == 'L' and head_position > 1:
                head_position -= 1
            else:
                # 尝试越过边界
                return False
            
            # 更新状态
            current_state = next_state
        
        return False  # 达到最大步数仍未接受
```

## 🔗 相关内容

- [03.1.2 下推自动机](./03.1.2_Pushdown_Automata.md) - 比线性有界自动机更简单的计算模型
- [03.1.4 图灵机](./03.1.4_Turing_Machine.md) - 比线性有界自动机更强大的计算模型
- [03.2.3 上下文相关文法](../03.2_Formal_Grammars/03.2.3_Context_Sensitive_Grammar.md) - 与线性有界自动机等价的文法
- [03.3 语言层次](../03.3_Language_Hierarchy.md) - 线性有界自动机在语言层次中的位置

---

**更新时间**: 2024-12-25  
**版本**: 2.0  
**状态**: 已完成
