# 03.6.2 å¤æ‚æ€§ç†è®º

## ğŸ“‹ æ¦‚è¿°

å¤æ‚æ€§ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦çš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶è®¡ç®—é—®é¢˜çš„èµ„æºéœ€æ±‚ï¼Œç‰¹åˆ«æ˜¯æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦ã€‚è¯¥ç†è®ºä¸ºç®—æ³•è®¾è®¡å’Œé—®é¢˜åˆ†ç±»æä¾›äº†ç†è®ºåŸºç¡€ï¼Œæ˜¯ç†è§£è®¡ç®—æ•ˆç‡å’Œé—®é¢˜å¯è§£æ€§çš„é‡è¦å·¥å…·ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹å¤æ‚æ€§çš„æ•°å­¦åŸºç¡€**
2. **å®šä¹‰æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦**
3. **ç ”ç©¶å¤æ‚æ€§ç±»åŠå…¶å…³ç³»**
4. **æä¾›å¤æ‚æ€§åˆ†ææ–¹æ³•**
5. **åˆ†æå¤æ‚æ€§åœ¨ç®—æ³•è®¾è®¡ä¸­çš„åº”ç”¨**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ—¶é—´å¤æ‚åº¦

**å®šä¹‰ 1.1.1 (æ—¶é—´å¤æ‚åº¦)**
ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ç®—æ³•æ‰§è¡Œæ‰€éœ€æ—¶é—´ä¸è¾“å…¥è§„æ¨¡çš„å…³ç³»ï¼Œé€šå¸¸ç”¨å¤§Oè®°å·è¡¨ç¤ºã€‚

**å®šä¹‰ 1.1.2 (å¤§Oè®°å·)**
å‡½æ•° $f(n) = O(g(n))$ï¼Œå¦‚æœå­˜åœ¨å¸¸æ•° $c > 0$ å’Œ $n_0 > 0$ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰ $n \geq n_0$ï¼Œéƒ½æœ‰ $f(n) \leq c \cdot g(n)$ã€‚

**å®šä¹‰ 1.1.3 (å¸¸è§æ—¶é—´å¤æ‚åº¦ç±»)**:

- $O(1)$ï¼šå¸¸æ•°æ—¶é—´
- $O(\log n)$ï¼šå¯¹æ•°æ—¶é—´
- $O(n)$ï¼šçº¿æ€§æ—¶é—´
- $O(n \log n)$ï¼šçº¿æ€§å¯¹æ•°æ—¶é—´
- $O(n^2)$ï¼šå¹³æ–¹æ—¶é—´
- $O(n^3)$ï¼šç«‹æ–¹æ—¶é—´
- $O(2^n)$ï¼šæŒ‡æ•°æ—¶é—´
- $O(n!)$ï¼šé˜¶ä¹˜æ—¶é—´

### 1.2 ç©ºé—´å¤æ‚åº¦

**å®šä¹‰ 1.2.1 (ç©ºé—´å¤æ‚åº¦)**
ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦æ˜¯ç®—æ³•æ‰§è¡Œæ‰€éœ€å†…å­˜ç©ºé—´ä¸è¾“å…¥è§„æ¨¡çš„å…³ç³»ã€‚

**å®šä¹‰ 1.2.2 (ç©ºé—´å¤æ‚åº¦åˆ†ç±»)**:

- $O(1)$ï¼šå¸¸æ•°ç©ºé—´
- $O(\log n)$ï¼šå¯¹æ•°ç©ºé—´
- $O(n)$ï¼šçº¿æ€§ç©ºé—´
- $O(n^2)$ï¼šå¹³æ–¹ç©ºé—´
- $O(2^n)$ï¼šæŒ‡æ•°ç©ºé—´

### 1.3 å¤æ‚æ€§ç±»

**å®šä¹‰ 1.3.1 (Pç±»)**
Pç±»æ˜¯æ‰€æœ‰å¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…è¢«ç¡®å®šæ€§å›¾çµæœºè§£å†³çš„é—®é¢˜çš„é›†åˆã€‚

**å®šä¹‰ 1.3.2 (NPç±»)**
NPç±»æ˜¯æ‰€æœ‰å¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…è¢«éç¡®å®šæ€§å›¾çµæœºè§£å†³çš„é—®é¢˜çš„é›†åˆï¼Œç­‰ä»·äºæ‰€æœ‰å¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…éªŒè¯è§£çš„é—®é¢˜çš„é›†åˆã€‚

**å®šä¹‰ 1.3.3 (NPå®Œå…¨é—®é¢˜)**
ä¸€ä¸ªé—®é¢˜Læ˜¯NPå®Œå…¨çš„ï¼Œå¦‚æœï¼š

1. $L \in \text{NP}$
2. å¯¹äºæ‰€æœ‰ $L' \in \text{NP}$ï¼Œéƒ½æœ‰ $L' \leq_p L$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å›¾çµæœºçš„æ—¶é—´å¤æ‚åº¦

**å®šä¹‰ 2.1.1 (å›¾çµæœºçš„æ—¶é—´å¤æ‚åº¦)**
å›¾çµæœº $M$ åœ¨è¾“å…¥ $w$ ä¸Šçš„æ—¶é—´å¤æ‚åº¦ $T_M(w)$ æ˜¯ $M$ åœ¨è¾“å…¥ $w$ ä¸Šåœæœºæ‰€éœ€çš„æ­¥æ•°ã€‚

**å®šä¹‰ 2.1.2 (æ—¶é—´å¤æ‚åº¦å‡½æ•°)**
å›¾çµæœº $M$ çš„æ—¶é—´å¤æ‚åº¦å‡½æ•° $T_M: \mathbb{N} \to \mathbb{N}$ å®šä¹‰ä¸ºï¼š
$$T_M(n) = \max\{T_M(w) : |w| = n\}$$

**å®šä¹‰ 2.1.3 (æ—¶é—´å¤æ‚æ€§ç±»)**
å¯¹äºæ—¶é—´å‡½æ•° $t: \mathbb{N} \to \mathbb{N}$ï¼Œæ—¶é—´å¤æ‚æ€§ç±» $\text{TIME}(t(n))$ å®šä¹‰ä¸ºï¼š
$$\text{TIME}(t(n)) = \{L : \exists \text{å›¾çµæœº} M, M \text{åœ¨æ—¶é—´} O(t(n)) \text{å†…åˆ¤å®š} L\}$$

### 2.2 å›¾çµæœºçš„ç©ºé—´å¤æ‚åº¦

**å®šä¹‰ 2.2.1 (å›¾çµæœºçš„ç©ºé—´å¤æ‚åº¦)**
å›¾çµæœº $M$ åœ¨è¾“å…¥ $w$ ä¸Šçš„ç©ºé—´å¤æ‚åº¦ $S_M(w)$ æ˜¯ $M$ åœ¨è¾“å…¥ $w$ ä¸Šåœæœºæ—¶ä½¿ç”¨çš„å·¥ä½œç£å¸¦çš„æœ€å¤§æ ¼å­æ•°ã€‚

**å®šä¹‰ 2.2.2 (ç©ºé—´å¤æ‚åº¦å‡½æ•°)**
å›¾çµæœº $M$ çš„ç©ºé—´å¤æ‚åº¦å‡½æ•° $S_M: \mathbb{N} \to \mathbb{N}$ å®šä¹‰ä¸ºï¼š
$$S_M(n) = \max\{S_M(w) : |w| = n\}$$

**å®šä¹‰ 2.2.3 (ç©ºé—´å¤æ‚æ€§ç±»)**
å¯¹äºç©ºé—´å‡½æ•° $s: \mathbb{N} \to \mathbb{N}$ï¼Œç©ºé—´å¤æ‚æ€§ç±» $\text{SPACE}(s(n))$ å®šä¹‰ä¸ºï¼š
$$\text{SPACE}(s(n)) = \{L : \exists \text{å›¾çµæœº} M, M \text{åœ¨ç©ºé—´} O(s(n)) \text{å†…åˆ¤å®š} L\}$$

### 2.3 å½’çº¦å’Œå®Œå…¨æ€§

**å®šä¹‰ 2.3.1 (å¤šé¡¹å¼æ—¶é—´å½’çº¦)**
è¯­è¨€ $A$ å¤šé¡¹å¼æ—¶é—´å½’çº¦åˆ°è¯­è¨€ $B$ï¼Œè®°ä½œ $A \leq_p B$ï¼Œå¦‚æœå­˜åœ¨å¤šé¡¹å¼æ—¶é—´å¯è®¡ç®—çš„å‡½æ•° $f$ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰ $w$ï¼š
$$w \in A \iff f(w) \in B$$

**å®šä¹‰ 2.3.2 (NPå®Œå…¨æ€§)**
è¯­è¨€ $L$ æ˜¯NPå®Œå…¨çš„ï¼Œå¦‚æœï¼š

1. $L \in \text{NP}$
2. å¯¹äºæ‰€æœ‰ $L' \in \text{NP}$ï¼Œéƒ½æœ‰ $L' \leq_p L$

**å®šä¹‰ 2.3.3 (NPéš¾é—®é¢˜)**
è¯­è¨€ $L$ æ˜¯NPéš¾çš„ï¼Œå¦‚æœå¯¹äºæ‰€æœ‰ $L' \in \text{NP}$ï¼Œéƒ½æœ‰ $L' \leq_p L$ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 æ—¶é—´å±‚æ¬¡å®šç†

**å®šç† 3.1.1 (æ—¶é—´å±‚æ¬¡å®šç†)**
å¯¹äºä»»ä½•æ—¶é—´å¯æ„é€ çš„å‡½æ•° $t_1$ å’Œ $t_2$ï¼Œå¦‚æœ $t_1(n) \log t_1(n) = o(t_2(n))$ï¼Œåˆ™ï¼š
$$\text{TIME}(t_1(n)) \subsetneq \text{TIME}(t_2(n))$$

**è¯æ˜**ï¼š
æ„é€ ä¸€ä¸ªè¯­è¨€ $L$ï¼Œä½¿å¾— $L \in \text{TIME}(t_2(n))$ ä½† $L \notin \text{TIME}(t_1(n))$ã€‚

å®šä¹‰ $L = \{\langle M \rangle : M \text{åœ¨æ—¶é—´} t_1(n) \text{å†…æ‹’ç»} \langle M \rangle\}$ã€‚

å¦‚æœ $L \in \text{TIME}(t_1(n))$ï¼Œåˆ™å­˜åœ¨å›¾çµæœº $M_L$ åœ¨æ—¶é—´ $t_1(n)$ å†…åˆ¤å®š $L$ã€‚è€ƒè™‘ $\langle M_L \rangle \in L$ çš„æƒ…å†µï¼š

- å¦‚æœ $M_L$ æ¥å— $\langle M_L \rangle$ï¼Œåˆ™ $\langle M_L \rangle \notin L$ï¼ŒçŸ›ç›¾
- å¦‚æœ $M_L$ æ‹’ç» $\langle M_L \rangle$ï¼Œåˆ™ $\langle M_L \rangle \in L$ï¼ŒçŸ›ç›¾

å› æ­¤ $L \notin \text{TIME}(t_1(n))$ã€‚$\square$

### 3.2 ç©ºé—´å±‚æ¬¡å®šç†

**å®šç† 3.2.1 (ç©ºé—´å±‚æ¬¡å®šç†)**
å¯¹äºä»»ä½•ç©ºé—´å¯æ„é€ çš„å‡½æ•° $s_1$ å’Œ $s_2$ï¼Œå¦‚æœ $s_1(n) = o(s_2(n))$ï¼Œåˆ™ï¼š
$$\text{SPACE}(s_1(n)) \subsetneq \text{SPACE}(s_2(n))$$

**è¯æ˜**ï¼š
ç±»ä¼¼äºæ—¶é—´å±‚æ¬¡å®šç†çš„è¯æ˜ï¼Œæ„é€ ä¸€ä¸ªè¯­è¨€ $L$ï¼Œä½¿å¾— $L \in \text{SPACE}(s_2(n))$ ä½† $L \notin \text{SPACE}(s_1(n))$ã€‚$\square$

### 3.3 Pä¸NPçš„å…³ç³»

**å®šç† 3.3.1 (PåŒ…å«äºNP)**
$\text{P} \subseteq \text{NP}$

**è¯æ˜**ï¼š
ä»»ä½•åœ¨å¤šé¡¹å¼æ—¶é—´å†…å¯è§£å†³çš„é—®é¢˜éƒ½å¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…éªŒè¯è§£ï¼Œå› æ­¤ $\text{P} \subseteq \text{NP}$ã€‚$\square$

**å®šç† 3.3.2 (Pæ˜¯å¦ç­‰äºNP)**
Pæ˜¯å¦ç­‰äºNPæ˜¯è®¡ç®—æœºç§‘å­¦ä¸­æœ€é‡è¦çš„æœªè§£å†³é—®é¢˜ä¹‹ä¸€ã€‚

**è¯æ˜**ï¼š
è¿™ä¸ªé—®é¢˜ç›®å‰å°šæœªè§£å†³ã€‚å¦‚æœ $\text{P} = \text{NP}$ï¼Œåˆ™è®¸å¤šNPå®Œå…¨é—®é¢˜éƒ½æœ‰å¤šé¡¹å¼æ—¶é—´ç®—æ³•ã€‚å¦‚æœ $\text{P} \neq \text{NP}$ï¼Œåˆ™è¿™äº›é—®é¢˜æ˜¯çœŸæ­£å›°éš¾çš„ã€‚$\square$

### 3.4 NPå®Œå…¨é—®é¢˜çš„å­˜åœ¨æ€§

**å®šç† 3.4.1 (åº“å…‹-åˆ—æ–‡å®šç†)**
SATé—®é¢˜æ˜¯NPå®Œå…¨çš„ã€‚

**è¯æ˜**ï¼š

1. SAT $\in$ NPï¼šå¯ä»¥åœ¨å¤šé¡¹å¼æ—¶é—´å†…éªŒè¯èµ‹å€¼æ˜¯å¦æ»¡è¶³å…¬å¼
2. å¯¹äºä»»ä½• $L \in \text{NP}$ï¼Œå­˜åœ¨å¤šé¡¹å¼æ—¶é—´å½’çº¦ $L \leq_p \text{SAT}$

æ„é€ å½’çº¦ï¼šå¯¹äºä»»ä½•NPé—®é¢˜ï¼Œå¯ä»¥æ„é€ ä¸€ä¸ªå¸ƒå°”å…¬å¼ï¼Œä½¿å¾—è¯¥å…¬å¼å¯æ»¡è¶³å½“ä¸”ä»…å½“åŸé—®é¢˜æœ‰è§£ã€‚$\square$

## 4. ä»£ç å®ç°

### 4.1 å¤æ‚åº¦åˆ†æå·¥å…·

```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};

/// å¤æ‚åº¦åˆ†æå™¨
pub struct ComplexityAnalyzer {
    pub measurements: HashMap<String, Vec<Duration>>,
}

/// ç®—æ³•å¤æ‚åº¦
#[derive(Debug, Clone, PartialEq)]
pub enum Complexity {
    Constant,
    Logarithmic,
    Linear,
    Linearithmic,
    Quadratic,
    Cubic,
    Exponential,
    Factorial,
    Custom(String),
}

/// å¤æ‚åº¦åˆ†æç»“æœ
#[derive(Debug, Clone)]
pub struct ComplexityResult {
    pub algorithm_name: String,
    pub input_sizes: Vec<usize>,
    pub execution_times: Vec<Duration>,
    pub estimated_complexity: Complexity,
    pub big_o_notation: String,
}

impl ComplexityAnalyzer {
    pub fn new() -> Self {
        Self {
            measurements: HashMap::new(),
        }
    }

    /// æµ‹é‡ç®—æ³•æ‰§è¡Œæ—¶é—´
    pub fn measure_algorithm<F>(&mut self, name: &str, input_size: usize, algorithm: F) -> Duration
    where
        F: FnOnce() -> (),
    {
        let start = Instant::now();
        algorithm();
        let duration = start.elapsed();
        
        self.measurements
            .entry(name.to_string())
            .or_insert_with(Vec::new)
            .push(duration);
        
        duration
    }

    /// åˆ†æå¤æ‚åº¦
    pub fn analyze_complexity(&self, name: &str) -> Option<ComplexityResult> {
        let times = self.measurements.get(name)?;
        if times.len() < 2 {
            return None;
        }

        // ç®€åŒ–çš„å¤æ‚åº¦åˆ†æ
        let complexity = self.estimate_complexity(times);
        let big_o = self.get_big_o_notation(&complexity);

        Some(ComplexityResult {
            algorithm_name: name.to_string(),
            input_sizes: (1..=times.len()).collect(),
            execution_times: times.clone(),
            estimated_complexity: complexity,
            big_o_notation: big_o,
        })
    }

    /// ä¼°è®¡å¤æ‚åº¦
    fn estimate_complexity(&self, times: &[Duration]) -> Complexity {
        if times.len() < 2 {
            return Complexity::Constant;
        }

        let ratios: Vec<f64> = times
            .windows(2)
            .map(|w| w[1].as_nanos() as f64 / w[0].as_nanos() as f64)
            .collect();

        let avg_ratio = ratios.iter().sum::<f64>() / ratios.len() as f64;

        match avg_ratio {
            r if r < 1.1 => Complexity::Constant,
            r if r < 1.5 => Complexity::Logarithmic,
            r if r < 2.5 => Complexity::Linear,
            r if r < 4.0 => Complexity::Linearithmic,
            r if r < 8.0 => Complexity::Quadratic,
            r if r < 16.0 => Complexity::Cubic,
            r if r < 100.0 => Complexity::Exponential,
            _ => Complexity::Factorial,
        }
    }

    /// è·å–å¤§Oè®°å·
    fn get_big_o_notation(&self, complexity: &Complexity) -> String {
        match complexity {
            Complexity::Constant => "O(1)".to_string(),
            Complexity::Logarithmic => "O(log n)".to_string(),
            Complexity::Linear => "O(n)".to_string(),
            Complexity::Linearithmic => "O(n log n)".to_string(),
            Complexity::Quadratic => "O(nÂ²)".to_string(),
            Complexity::Cubic => "O(nÂ³)".to_string(),
            Complexity::Exponential => "O(2â¿)".to_string(),
            Complexity::Factorial => "O(n!)".to_string(),
            Complexity::Custom(s) => format!("O({})", s),
        }
    }
}

/// ç®—æ³•å¤æ‚åº¦åˆ†æ
pub struct AlgorithmComplexity;

impl AlgorithmComplexity {
    /// å¸¸æ•°æ—¶é—´ç®—æ³•
    pub fn constant_time_algorithm(_n: usize) {
        // å¸¸æ•°æ—¶é—´æ“ä½œ
        let _result = 1 + 1;
    }

    /// çº¿æ€§æ—¶é—´ç®—æ³•
    pub fn linear_time_algorithm(n: usize) {
        for i in 0..n {
            let _result = i * 2;
        }
    }

    /// å¹³æ–¹æ—¶é—´ç®—æ³•
    pub fn quadratic_time_algorithm(n: usize) {
        for i in 0..n {
            for j in 0..n {
                let _result = i * j;
            }
        }
    }

    /// æŒ‡æ•°æ—¶é—´ç®—æ³•
    pub fn exponential_time_algorithm(n: usize) -> u64 {
        if n <= 1 {
            return n as u64;
        }
        Self::exponential_time_algorithm(n - 1) + Self::exponential_time_algorithm(n - 2)
    }

    /// å¯¹æ•°æ—¶é—´ç®—æ³•
    pub fn logarithmic_time_algorithm(n: usize) -> usize {
        let mut result = 0;
        let mut i = n;
        while i > 0 {
            result += 1;
            i /= 2;
        }
        result
    }
}

/// NPå®Œå…¨é—®é¢˜ç¤ºä¾‹
pub struct NPCompleteProblems;

impl NPCompleteProblems {
    /// 3-SATé—®é¢˜
    pub fn three_sat_solver(clauses: &[(bool, bool, bool)]) -> Option<Vec<bool>> {
        let n = clauses.len();
        // å°è¯•æ‰€æœ‰å¯èƒ½çš„èµ‹å€¼
        for assignment in 0..(1 << n) {
            let mut vars = vec![false; n];
            for i in 0..n {
                vars[i] = (assignment >> i) & 1 == 1;
            }
            
            if Self::evaluate_clauses(clauses, &vars) {
                return Some(vars);
            }
        }
        None
    }

    /// è¯„ä¼°å­å¥
    fn evaluate_clauses(clauses: &[(bool, bool, bool)], vars: &[bool]) -> bool {
        clauses.iter().all(|&(a, b, c)| {
            let val_a = if a { vars[0] } else { !vars[0] };
            let val_b = if b { vars[1] } else { !vars[1] };
            let val_c = if c { vars[2] } else { !vars[2] };
            val_a || val_b || val_c
        })
    }

    /// æ—…è¡Œå•†é—®é¢˜
    pub fn traveling_salesman(cities: &[(f64, f64)]) -> Option<Vec<usize>> {
        let n = cities.len();
        if n <= 1 {
            return Some(vec![0]);
        }

        // è®¡ç®—æ‰€æœ‰åŸå¸‚é—´çš„è·ç¦»
        let mut distances = vec![vec![0.0; n]; n];
        for i in 0..n {
            for j in 0..n {
                let dx = cities[i].0 - cities[j].0;
                let dy = cities[i].1 - cities[j].1;
                distances[i][j] = (dx * dx + dy * dy).sqrt();
            }
        }

        // å°è¯•æ‰€æœ‰å¯èƒ½çš„è·¯å¾„
        let mut best_path = None;
        let mut best_distance = f64::INFINITY;

        Self::permute_and_check(&mut vec![0; n], 1, n, &distances, &mut best_path, &mut best_distance);

        best_path
    }

    /// ç”Ÿæˆæ’åˆ—å¹¶æ£€æŸ¥
    fn permute_and_check(
        path: &mut [usize],
        start: usize,
        n: usize,
        distances: &[Vec<f64>],
        best_path: &mut Option<Vec<usize>>,
        best_distance: &mut f64,
    ) {
        if start == n {
            // è®¡ç®—å½“å‰è·¯å¾„çš„æ€»è·ç¦»
            let mut distance = distances[path[n - 1]][0];
            for i in 0..(n - 1) {
                distance += distances[path[i]][path[i + 1]];
            }
            
            if distance < *best_distance {
                *best_distance = distance;
                *best_path = Some(path.to_vec());
            }
            return;
        }

        for i in start..n {
            path.swap(start, i);
            Self::permute_and_check(path, start + 1, n, distances, best_path, best_distance);
            path.swap(start, i);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_complexity_analyzer() {
        let mut analyzer = ComplexityAnalyzer::new();
        
        // æµ‹è¯•å¸¸æ•°æ—¶é—´ç®—æ³•
        for i in 1..=5 {
            analyzer.measure_algorithm("constant", i, || {
                AlgorithmComplexity::constant_time_algorithm(i);
            });
        }
        
        let result = analyzer.analyze_complexity("constant");
        assert!(result.is_some());
        assert_eq!(result.unwrap().estimated_complexity, Complexity::Constant);
    }

    #[test]
    fn test_np_complete_problems() {
        // æµ‹è¯•3-SAT
        let clauses = vec![(true, true, false), (false, true, true)];
        let solution = NPCompleteProblems::three_sat_solver(&clauses);
        assert!(solution.is_some());
        
        // æµ‹è¯•æ—…è¡Œå•†é—®é¢˜
        let cities = vec![(0.0, 0.0), (1.0, 1.0), (2.0, 0.0)];
        let path = NPCompleteProblems::traveling_salesman(&cities);
        assert!(path.is_some());
    }
}
```

### 4.2 Haskellå®ç°

```haskell
-- å¤æ‚åº¦ç±»å‹
data Complexity = Constant
                | Logarithmic
                | Linear
                | Linearithmic
                | Quadratic
                | Cubic
                | Exponential
                | Factorial
                | Custom String
                deriving (Eq, Show)

-- å¤æ‚åº¦åˆ†æç»“æœ
data ComplexityResult = ComplexityResult
    { algorithmName :: String
    , inputSizes :: [Int]
    , executionTimes :: [Double]
    , estimatedComplexity :: Complexity
    , bigONotation :: String
    } deriving (Show)

-- å¤æ‚åº¦åˆ†æå™¨
data ComplexityAnalyzer = ComplexityAnalyzer
    { measurements :: [(String, [Double])]
    }

-- åˆ›å»ºå¤æ‚åº¦åˆ†æå™¨
createAnalyzer :: ComplexityAnalyzer
createAnalyzer = ComplexityAnalyzer []

-- æµ‹é‡ç®—æ³•æ‰§è¡Œæ—¶é—´
measureAlgorithm :: String -> Int -> IO () -> IO Double
measureAlgorithm name inputSize algorithm = do
    start <- getCurrentTime
    algorithm
    end <- getCurrentTime
    let duration = diffUTCTime end start
    return $ realToFrac duration

-- åˆ†æå¤æ‚åº¦
analyzeComplexity :: ComplexityAnalyzer -> String -> Maybe ComplexityResult
analyzeComplexity analyzer name = do
    times <- lookup name (measurements analyzer)
    if length times < 2
        then Nothing
        else Just $ estimateComplexity name times

-- ä¼°è®¡å¤æ‚åº¦
estimateComplexity :: String -> [Double] -> ComplexityResult
estimateComplexity name times =
    let ratios = zipWith (/) (tail times) times
        avgRatio = sum ratios / fromIntegral (length ratios)
        complexity = case avgRatio of
            r | r < 1.1 -> Constant
            r | r < 1.5 -> Logarithmic
            r | r < 2.5 -> Linear
            r | r < 4.0 -> Linearithmic
            r | r < 8.0 -> Quadratic
            r | r < 16.0 -> Cubic
            r | r < 100.0 -> Exponential
            _ -> Factorial
        bigO = getBigONotation complexity
    in ComplexityResult name [1..length times] times complexity bigO

-- è·å–å¤§Oè®°å·
getBigONotation :: Complexity -> String
getBigONotation complexity = case complexity of
    Constant -> "O(1)"
    Logarithmic -> "O(log n)"
    Linear -> "O(n)"
    Linearithmic -> "O(n log n)"
    Quadratic -> "O(nÂ²)"
    Cubic -> "O(nÂ³)"
    Exponential -> "O(2â¿)"
    Factorial -> "O(n!)"
    Custom s -> "O(" ++ s ++ ")"

-- ç®—æ³•å¤æ‚åº¦ç¤ºä¾‹
constantTimeAlgorithm :: Int -> Int
constantTimeAlgorithm _ = 1

linearTimeAlgorithm :: Int -> Int
linearTimeAlgorithm n = sum [1..n]

quadraticTimeAlgorithm :: Int -> Int
quadraticTimeAlgorithm n = sum [i * j | i <- [1..n], j <- [1..n]]

exponentialTimeAlgorithm :: Int -> Integer
exponentialTimeAlgorithm n
    | n <= 1 = fromIntegral n
    | otherwise = exponentialTimeAlgorithm (n - 1) + exponentialTimeAlgorithm (n - 2)

logarithmicTimeAlgorithm :: Int -> Int
logarithmicTimeAlgorithm n = go n 0
  where
    go 0 acc = acc
    go i acc = go (i `div` 2) (acc + 1)

-- NPå®Œå…¨é—®é¢˜ç¤ºä¾‹
-- 3-SATé—®é¢˜
type Clause = (Bool, Bool, Bool)
type Assignment = [Bool]

threeSatSolver :: [Clause] -> Maybe Assignment
threeSatSolver clauses = find (evaluateClauses clauses) allAssignments
  where
    n = length clauses
    allAssignments = map (assignmentFromInt n) [0..(2^n - 1)]

evaluateClauses :: [Clause] -> Assignment -> Bool
evaluateClauses clauses vars = all (evaluateClause vars) clauses

evaluateClause :: Assignment -> Clause -> Bool
evaluateClause vars (a, b, c) =
    let valA = if a then vars !! 0 else not (vars !! 0)
        valB = if b then vars !! 1 else not (vars !! 1)
        valC = if c then vars !! 2 else not (vars !! 2)
    in valA || valB || valC

assignmentFromInt :: Int -> Int -> Assignment
assignmentFromInt n x = [((x `div` (2^i)) `mod` 2) == 1 | i <- [0..(n-1)]]

-- æ—…è¡Œå•†é—®é¢˜
type City = (Double, Double)
type Path = [Int]

travelingSalesman :: [City] -> Maybe Path
travelingSalesman cities
    | length cities <= 1 = Just [0]
    | otherwise = findBestPath cities

findBestPath :: [City] -> Maybe Path
findBestPath cities = 
    let n = length cities
        distances = [[distance (cities !! i) (cities !! j) | j <- [0..n-1]] | i <- [0..n-1]]
        allPaths = permutations [0..n-1]
        pathDistances = [(path, calculatePathDistance path distances) | path <- allPaths]
        bestPath = minimumBy (comparing snd) pathDistances
    in Just (fst bestPath)

distance :: City -> City -> Double
distance (x1, y1) (x2, y2) = sqrt ((x2 - x1)^2 + (y2 - y1)^2)

calculatePathDistance :: Path -> [[Double]] -> Double
calculatePathDistance path distances = 
    let n = length path
        loopDistance = distances !! (path !! (n-1)) !! (path !! 0)
        pathDistance = sum [distances !! (path !! i) !! (path !! (i+1)) | i <- [0..(n-2)]]
    in pathDistance + loopDistance

-- æµ‹è¯•å‡½æ•°
testComplexityAnalysis :: IO ()
testComplexityAnalysis = do
    putStrLn "æµ‹è¯•å¤æ‚åº¦åˆ†æ:"
    
    -- æµ‹è¯•å¸¸æ•°æ—¶é—´ç®—æ³•
    let constantTimes = [constantTimeAlgorithm i | i <- [1..5]]
    putStrLn $ "å¸¸æ•°æ—¶é—´ç®—æ³•: " ++ show constantTimes
    
    -- æµ‹è¯•çº¿æ€§æ—¶é—´ç®—æ³•
    let linearTimes = [linearTimeAlgorithm i | i <- [1..5]]
    putStrLn $ "çº¿æ€§æ—¶é—´ç®—æ³•: " ++ show linearTimes
    
    -- æµ‹è¯•å¹³æ–¹æ—¶é—´ç®—æ³•
    let quadraticTimes = [quadraticTimeAlgorithm i | i <- [1..3]]
    putStrLn $ "å¹³æ–¹æ—¶é—´ç®—æ³•: " ++ show quadraticTimes

testNPCompleteProblems :: IO ()
testNPCompleteProblems = do
    putStrLn "æµ‹è¯•NPå®Œå…¨é—®é¢˜:"
    
    -- æµ‹è¯•3-SAT
    let clauses = [(True, True, False), (False, True, True)]
    let satSolution = threeSatSolver clauses
    putStrLn $ "3-SATè§£: " ++ show satSolution
    
    -- æµ‹è¯•æ—…è¡Œå•†é—®é¢˜
    let cities = [(0.0, 0.0), (1.0, 1.0), (2.0, 0.0)]
    let tspSolution = travelingSalesman cities
    putStrLn $ "æ—…è¡Œå•†é—®é¢˜è§£: " ++ show tspSolution
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 æ’åºç®—æ³•å¤æ‚åº¦åˆ†æ

```rust
/// æ’åºç®—æ³•å¤æ‚åº¦åˆ†æ
pub struct SortingComplexity;

impl SortingComplexity {
    /// å†’æ³¡æ’åº - O(nÂ²)
    pub fn bubble_sort<T: Ord + Clone>(arr: &mut [T]) {
        let n = arr.len();
        for i in 0..n {
            for j in 0..(n - i - 1) {
                if arr[j] > arr[j + 1] {
                    arr.swap(j, j + 1);
                }
            }
        }
    }

    /// å¿«é€Ÿæ’åº - O(n log n) å¹³å‡æƒ…å†µ
    pub fn quick_sort<T: Ord + Clone>(arr: &mut [T]) {
        if arr.len() <= 1 {
            return;
        }
        
        let pivot_index = Self::partition(arr);
        Self::quick_sort(&mut arr[..pivot_index]);
        Self::quick_sort(&mut arr[pivot_index + 1..]);
    }

    /// åˆ†åŒºå‡½æ•°
    fn partition<T: Ord + Clone>(arr: &mut [T]) -> usize {
        let pivot_index = arr.len() - 1;
        let mut i = 0;
        
        for j in 0..pivot_index {
            if arr[j] <= arr[pivot_index] {
                arr.swap(i, j);
                i += 1;
            }
        }
        
        arr.swap(i, pivot_index);
        i
    }

    /// å½’å¹¶æ’åº - O(n log n)
    pub fn merge_sort<T: Ord + Clone>(arr: &mut [T]) {
        if arr.len() <= 1 {
            return;
        }
        
        let mid = arr.len() / 2;
        Self::merge_sort(&mut arr[..mid]);
        Self::merge_sort(&mut arr[mid..]);
        Self::merge(arr, mid);
    }

    /// å½’å¹¶å‡½æ•°
    fn merge<T: Ord + Clone>(arr: &mut [T], mid: usize) {
        let left = arr[..mid].to_vec();
        let right = arr[mid..].to_vec();
        
        let mut i = 0;
        let mut j = 0;
        let mut k = 0;
        
        while i < left.len() && j < right.len() {
            if left[i] <= right[j] {
                arr[k] = left[i].clone();
                i += 1;
            } else {
                arr[k] = right[j].clone();
                j += 1;
            }
            k += 1;
        }
        
        while i < left.len() {
            arr[k] = left[i].clone();
            i += 1;
            k += 1;
        }
        
        while j < right.len() {
            arr[k] = right[j].clone();
            j += 1;
            k += 1;
        }
    }
}

#[test]
fn test_sorting_complexity() {
    let mut arr1 = vec![3, 1, 4, 1, 5, 9, 2, 6];
    let mut arr2 = arr1.clone();
    let mut arr3 = arr1.clone();
    
    SortingComplexity::bubble_sort(&mut arr1);
    SortingComplexity::quick_sort(&mut arr2);
    SortingComplexity::merge_sort(&mut arr3);
    
    assert_eq!(arr1, vec![1, 1, 2, 3, 4, 5, 6, 9]);
    assert_eq!(arr2, vec![1, 1, 2, 3, 4, 5, 6, 9]);
    assert_eq!(arr3, vec![1, 1, 2, 3, 4, 5, 6, 9]);
}
```

### 5.2 å›¾ç®—æ³•å¤æ‚åº¦åˆ†æ

```rust
/// å›¾ç®—æ³•å¤æ‚åº¦åˆ†æ
pub struct GraphComplexity;

impl GraphComplexity {
    /// æ·±åº¦ä¼˜å…ˆæœç´¢ - O(V + E)
    pub fn dfs(graph: &[Vec<usize>], start: usize) -> Vec<usize> {
        let mut visited = vec![false; graph.len()];
        let mut result = Vec::new();
        Self::dfs_recursive(graph, start, &mut visited, &mut result);
        result
    }

    fn dfs_recursive(
        graph: &[Vec<usize>],
        vertex: usize,
        visited: &mut [bool],
        result: &mut Vec<usize>,
    ) {
        visited[vertex] = true;
        result.push(vertex);
        
        for &neighbor in &graph[vertex] {
            if !visited[neighbor] {
                Self::dfs_recursive(graph, neighbor, visited, result);
            }
        }
    }

    /// å¹¿åº¦ä¼˜å…ˆæœç´¢ - O(V + E)
    pub fn bfs(graph: &[Vec<usize>], start: usize) -> Vec<usize> {
        let mut visited = vec![false; graph.len()];
        let mut queue = std::collections::VecDeque::new();
        let mut result = Vec::new();
        
        visited[start] = true;
        queue.push_back(start);
        
        while let Some(vertex) = queue.pop_front() {
            result.push(vertex);
            
            for &neighbor in &graph[vertex] {
                if !visited[neighbor] {
                    visited[neighbor] = true;
                    queue.push_back(neighbor);
                }
            }
        }
        
        result
    }

    /// Dijkstraç®—æ³• - O(VÂ²) æˆ– O((V + E) log V) ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—
    pub fn dijkstra(graph: &[Vec<(usize, u32)>], start: usize) -> Vec<u32> {
        let n = graph.len();
        let mut distances = vec![u32::MAX; n];
        let mut visited = vec![false; n];
        
        distances[start] = 0;
        
        for _ in 0..n {
            let u = Self::min_distance(&distances, &visited);
            visited[u] = true;
            
            for &(v, weight) in &graph[u] {
                if !visited[v] && distances[u] != u32::MAX {
                    let new_distance = distances[u] + weight;
                    if new_distance < distances[v] {
                        distances[v] = new_distance;
                    }
                }
            }
        }
        
        distances
    }

    fn min_distance(distances: &[u32], visited: &[bool]) -> usize {
        let mut min = u32::MAX;
        let mut min_index = 0;
        
        for (i, &distance) in distances.iter().enumerate() {
            if !visited[i] && distance < min {
                min = distance;
                min_index = i;
            }
        }
        
        min_index
    }
}

#[test]
fn test_graph_complexity() {
    let graph = vec![
        vec![1, 2],     // 0 -> 1, 2
        vec![0, 2, 3],  // 1 -> 0, 2, 3
        vec![0, 1, 3],  // 2 -> 0, 1, 3
        vec![1, 2],     // 3 -> 1, 2
    ];
    
    let dfs_result = GraphComplexity::dfs(&graph, 0);
    let bfs_result = GraphComplexity::bfs(&graph, 0);
    
    assert!(!dfs_result.is_empty());
    assert!(!bfs_result.is_empty());
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å¯è®¡ç®—æ€§ç†è®ºçš„å…³ç³»

**å®šç† 6.1.1 (å¯è®¡ç®—æ€§ä¸å¤æ‚æ€§çš„å…³ç³»)**
å¯è®¡ç®—æ€§æ˜¯å¤æ‚æ€§çš„å‰ææ¡ä»¶ã€‚ä¸€ä¸ªé—®é¢˜å¿…é¡»æ˜¯å¯è®¡ç®—çš„ï¼Œæ‰èƒ½è®¨è®ºå…¶è®¡ç®—å¤æ‚æ€§ã€‚

**è¯æ˜**ï¼š
å¦‚æœä¸€ä¸ªé—®é¢˜æ˜¯ä¸å¯è®¡ç®—çš„ï¼Œé‚£ä¹ˆä¸å­˜åœ¨ä»»ä½•ç®—æ³•æ¥è§£å†³å®ƒï¼Œå› æ­¤æ— æ³•å®šä¹‰å…¶æ—¶é—´å¤æ‚åº¦æˆ–ç©ºé—´å¤æ‚åº¦ã€‚$\square$

### 6.2 ä¸ç®—æ³•è®¾è®¡çš„å…³ç³»

**å®šç† 6.2.1 (å¤æ‚åº¦ä¸ç®—æ³•è®¾è®¡)**
å¤æ‚åº¦åˆ†æä¸ºç®—æ³•è®¾è®¡æä¾›äº†é‡è¦çš„æŒ‡å¯¼åŸåˆ™ã€‚

**è¯æ˜**ï¼š
é€šè¿‡å¤æ‚åº¦åˆ†æï¼Œæˆ‘ä»¬å¯ä»¥ï¼š

1. æ¯”è¾ƒä¸åŒç®—æ³•çš„æ•ˆç‡
2. ç¡®å®šç®—æ³•çš„é€‚ç”¨åœºæ™¯
3. æŒ‡å¯¼ç®—æ³•ä¼˜åŒ–æ–¹å‘
4. é¢„æµ‹ç®—æ³•åœ¨å®é™…åº”ç”¨ä¸­çš„æ€§èƒ½

### 6.3 ä¸é—®é¢˜åˆ†ç±»çš„å…³ç³»

**å®šç† 6.3.1 (å¤æ‚åº¦ç±»ä¸é—®é¢˜åˆ†ç±»)**
å¤æ‚åº¦ç±»ä¸ºé—®é¢˜åˆ†ç±»æä¾›äº†é‡è¦çš„ç†è®ºæ¡†æ¶ã€‚

**è¯æ˜**ï¼š
ä¸åŒçš„å¤æ‚åº¦ç±»å¯¹åº”ä¸åŒç±»å‹çš„é—®é¢˜ï¼š

- Pç±»ï¼šå¤šé¡¹å¼æ—¶é—´å¯è§£çš„é—®é¢˜
- NPç±»ï¼šå¤šé¡¹å¼æ—¶é—´å¯éªŒè¯çš„é—®é¢˜
- NPå®Œå…¨ç±»ï¼šNPä¸­æœ€å›°éš¾çš„é—®é¢˜
- PSPACEç±»ï¼šå¤šé¡¹å¼ç©ºé—´å¯è§£çš„é—®é¢˜

## 7. å‚è€ƒæ–‡çŒ®

1. Sipser, M. (2012). *Introduction to the theory of computation* (3rd ed.). Cengage Learning.

2. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to automata theory, languages, and computation* (3rd ed.). Pearson.

3. Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to algorithms* (3rd ed.). MIT Press.

4. Papadimitriou, C. H. (1994). *Computational complexity*. Addison-Wesley.

5. Arora, S., & Barak, B. (2009). *Computational complexity: A modern approach*. Cambridge University Press.

6. Garey, M. R., & Johnson, D. S. (1979). *Computers and intractability: A guide to the theory of NP-completeness*. W. H. Freeman.

7. Cook, S. A. (1971). The complexity of theorem-proving procedures. *Proceedings of the Third Annual ACM Symposium on Theory of Computing*, 151-158.

8. Levin, L. A. (1973). Universal sequential search problems. *Problems of Information Transmission*, 9(3), 265-266.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [03.6.1 å¯è®¡ç®—æ€§ç†è®º](03.6.1_Computability_Theory.md)
- [03.6.3 ç®—æ³•åˆ†æ](03.6.3_ç®—æ³•åˆ†æ.md)
- [03.6.4 è®¡ç®—æ¨¡å‹](03.6.4_è®¡ç®—æ¨¡å‹.md)
- [02.2.1 å‘½é¢˜é€»è¾‘](../02_Mathematical_Foundation/02.2.1_å‘½é¢˜é€»è¾‘.md)
- [02.11.1 è®¡æ•°åŸç†](../02_Mathematical_Foundation/02.11.1_è®¡æ•°åŸç†.md)
