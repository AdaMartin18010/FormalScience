# 公理语义 (Axiomatic Semantics)

## 定义

**公理语义**是一种形式化方法，通过逻辑断言来描述程序的性质和行为。它关注的是程序执行前后状态之间的关系，而不是执行过程的细节。

### 形式定义

公理语义使用霍尔三元组 (Hoare Triple) 来表示程序的行为：

$$\{P\} \ C \ \{Q\}$$

其中 $P$ 是前置条件，$C$ 是程序，$Q$ 是后置条件。这个三元组表示：如果程序 $C$ 在满足前置条件 $P$ 的状态下开始执行，那么如果它终止，则终止状态将满足后置条件 $Q$。

## 基本原理

公理语义的核心思想是将程序验证转化为逻辑推理问题。通过定义一组公理和推理规则，可以形式化地证明程序的正确性。

### 霍尔逻辑 (Hoare Logic)

霍尔逻辑是公理语义的基础，它包括以下核心规则：

#### 1. 赋值公理 (Assignment Axiom)

$$\{Q[E/x]\} \ x := E \ \{Q\}$$

其中 $Q[E/x]$ 表示将 $Q$ 中的所有自由出现的 $x$ 替换为表达式 $E$。

#### 2. 序列规则 (Sequence Rule)

$$\frac{\{P\} \ C_1 \ \{R\} \quad \{R\} \ C_2 \ \{Q\}}{\{P\} \ C_1; C_2 \ \{Q\}}$$

#### 3. 条件规则 (Conditional Rule)

$$\frac{\{P \land B\} \ C_1 \ \{Q\} \quad \{P \land \neg B\} \ C_2 \ \{Q\}}{\{P\} \ \text{if } B \text{ then } C_1 \text{ else } C_2 \ \{Q\}}$$

#### 4. 循环规则 (Loop Rule)

$$\frac{\{P \land B\} \ C \ \{P\}}{\{P\} \ \text{while } B \text{ do } C \ \{P \land \neg B\}}$$

其中 $P$ 是循环不变量。

#### 5. 结果加强规则 (Consequence Rule)

$$\frac{P' \Rightarrow P \quad \{P\} \ C \ \{Q\} \quad Q \Rightarrow Q'}{\{P'\} \ C \ \{Q'\}}$$

## 证明系统

### 1. 部分正确性 (Partial Correctness)

部分正确性表示：如果程序终止，则结果满足规范。用符号 $\vdash \{P\} \ C \ \{Q\}$ 表示可以在霍尔逻辑中证明三元组 $\{P\} \ C \ \{Q\}$。

### 2. 完全正确性 (Total Correctness)

完全正确性表示：程序一定会终止，且结果满足规范。用符号 $\vdash_t \{P\} \ C \ \{Q\}$ 表示。完全正确性需要额外的证明规则来保证终止性。

#### 循环规则（完全正确性版本）

$$\frac{\{P \land B \land t = z\} \ C \ \{P \land t < z\} \quad P \land B \Rightarrow t > 0}{\{P\} \ \text{while } B \text{ do } C \ \{P \land \neg B\}}$$

其中 $t$ 是一个非负整数表达式，$z$ 是一个不在程序中出现的变量。

## 实例：简单命令式语言

考虑一个包含赋值、顺序执行、条件和循环的简单语言。

### 语法

```text
C ::= x := E            // 赋值
    | C1; C2            // 顺序执行
    | if B then C1 else C2  // 条件
    | while B do C      // 循环
    | skip              // 空操作

E ::= n                 // 整数常量
    | x                 // 变量
    | E1 + E2           // 加法
    | E1 - E2           // 减法
    | E1 * E2           // 乘法

B ::= true              // 布尔常量真
    | false             // 布尔常量假
    | E1 = E2           // 相等比较
    | E1 < E2           // 小于比较
    | not B             // 布尔否定
    | B1 and B2         // 布尔与
```

### 推导示例

#### 例1：交换两个变量

程序：

```text
t := x;
x := y;
y := t
```

证明：

```text
{x = X ∧ y = Y}
  t := x;
{t = X ∧ y = Y}
  x := y;
{t = X ∧ x = Y}
  y := t
{x = Y ∧ y = X}
```

#### 例2：计算阶乘

程序：

```text
y := 1;
while x > 0 do (
  y := y * x;
  x := x - 1
)
```

证明：

```text
{x = X ∧ X ≥ 0}
  y := 1;
{y = 1 ∧ x = X ∧ X ≥ 0}
  // 循环不变量: y * x! = X!
  while x > 0 do (
    {y * x! = X! ∧ x > 0}
      y := y * x;
    {y = y_old * x ∧ y_old * x! = X! ∧ x > 0}
    {y * (x-1)! = X!}
      x := x - 1
    {y * x! = X!}
  )
{y * x! = X! ∧ x ≤ 0}
{y * 1 = X! ∧ x = 0}
{y = X!}
```

## 高级概念

### 1. 断言语言

断言通常使用一阶谓词逻辑表示，包括：

- **变量**：表示程序状态中的值
- **常量**：表示固定值
- **函数**：表示数学函数
- **谓词**：表示关系
- **量词**：∀（全称量词）和∃（存在量词）
- **逻辑连接词**：∧（与）、∨（或）、¬（非）、→（蕴含）

### 2. 最弱前置条件 (Weakest Precondition)

最弱前置条件 $wp(C, Q)$ 是使得程序 $C$ 执行后满足后置条件 $Q$ 的最弱（最一般）前置条件。

#### 计算规则

- $wp(\text{skip}, Q) = Q$
- $wp(x := E, Q) = Q[E/x]$
- $wp(C_1; C_2, Q) = wp(C_1, wp(C_2, Q))$
- $wp(\text{if } B \text{ then } C_1 \text{ else } C_2, Q) = (B \rightarrow wp(C_1, Q)) \land (\neg B \rightarrow wp(C_2, Q))$
- $wp(\text{while } B \text{ do } C, Q) = \text{gfp}(\lambda X. (B \rightarrow wp(C, X)) \land (\neg B \rightarrow Q))$

其中 $\text{gfp}$ 表示最大不动点。

### 3. 最强后置条件 (Strongest Postcondition)

最强后置条件 $sp(P, C)$ 是程序 $C$ 从满足前置条件 $P$ 的状态开始执行后，能够保证的最强后置条件。

#### 计算规则

- $sp(P, \text{skip}) = P$
- $sp(P, x := E) = \exists x_0. (P[x_0/x] \land x = E[x_0/x])$
- $sp(P, C_1; C_2) = sp(sp(P, C_1), C_2)$
- $sp(P, \text{if } B \text{ then } C_1 \text{ else } C_2) = sp(P \land B, C_1) \lor sp(P \land \neg B, C_2)$
- $sp(P, \text{while } B \text{ do } C) = \text{lfp}(\lambda X. X \lor sp(P \land B, C))$

其中 $\text{lfp}$ 表示最小不动点。

## 应用与扩展

### 1. 程序验证

公理语义是程序验证的理论基础，可用于：

- **功能正确性**：证明程序满足其规范
- **安全性属性**：证明程序不会进入不安全状态
- **活性属性**：证明程序最终会达到某个期望状态

### 2. 程序推导

公理语义可用于从规范推导程序：

- **精化方法**：从抽象规范逐步细化到具体实现
- **正确性构造**：构造满足给定规范的程序

### 3. 并发程序

扩展霍尔逻辑以处理并发程序：

- **Owicki-Gries方法**：使用干扰自由条件
- **依赖逻辑**：使用依赖关系处理细粒度并发
- **分离逻辑**：使用资源分离处理堆内存并发

### 4. 面向对象程序

扩展公理语义以处理面向对象特性：

- **不变量**：类不变量和接口规范
- **继承**：子类型关系的行为规范
- **封装**：模块化验证技术

## 公理语义的特点

### 优势

1. **抽象性**：关注程序行为而非实现细节
2. **组合性**：支持模块化验证和推理
3. **形式化**：提供严格的数学基础
4. **验证友好**：适合程序正确性证明

### 局限性

1. **表达能力**：难以表达某些程序属性（如资源使用）
2. **自动化困难**：完全自动化证明通常是不可判定的
3. **规范复杂性**：复杂程序的规范可能非常庞大
4. **实现距离**：与程序实现的联系不直接

## 与其他语义方法的比较

| 特性 | 公理语义 | 操作语义 | 指称语义 |
|------|---------|---------|---------|
| 关注点 | 逻辑性质 | 执行过程 | 数学映射 |
| 抽象级别 | 高 | 低 | 高 |
| 组合性 | 中 | 低 | 高 |
| 实现易度 | 低 | 高 | 中 |
| 验证易度 | 高 | 中 | 高 |
| 直观性 | 中 | 高 | 低 |

## 实际应用

1. **形式化方法工具**：如Dafny、Why3、Frama-C等
2. **安全关键系统验证**：如航空电子设备、医疗设备软件
3. **编译器验证**：证明编译器实现的正确性
4. **算法验证**：证明算法满足其规范

## 参考资源

- [操作语义](./03.5.1_Operational_Semantics.md) - 另一种主要的语义模型
- [指称语义](./03.5.2_Denotational_Semantics.md) - 基于数学函数的语义模型
- [代数语义](./03.5.4_Algebraic_Semantics.md) - 基于代数结构的语义模型
- [形式验证](../03.7.4_形式验证.md) - 公理语义在验证中的应用

---

**注**：本文档遵循统一的学术标准，包括形式定义、定理证明、算法描述和实例分析。
