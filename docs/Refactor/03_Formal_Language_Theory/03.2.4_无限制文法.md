# 03.2.4 æ— é™åˆ¶æ–‡æ³•

## ğŸ“‹ æ¦‚è¿°

æ— é™åˆ¶æ–‡æ³•ï¼ˆUnrestricted Grammarï¼‰æ˜¯ä¹”å§†æ–¯åŸºè°±ç³»ä¸­æœ€ä¸€èˆ¬çš„æ–‡æ³•ç±»å‹ï¼Œä¹Ÿç§°ä¸º0å‹æ–‡æ³•ã€‚å®ƒå¯¹åº”å›¾çµæœºè¯†åˆ«çš„è¯­è¨€ç±»ï¼Œå³é€’å½’å¯æšä¸¾è¯­è¨€ã€‚æ— é™åˆ¶æ–‡æ³•å…·æœ‰æœ€å¤§çš„è¡¨è¾¾èƒ½åŠ›ï¼Œä½†åŒæ—¶ä¹Ÿæœ€éš¾å¤„ç†ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å½¢å¼åŒ–å®šä¹‰**ï¼šæä¾›æ— é™åˆ¶æ–‡æ³•çš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. **è¯­è¨€ç±»åˆ†æ**ï¼šç ”ç©¶æ— é™åˆ¶æ–‡æ³•ç”Ÿæˆçš„è¯­è¨€ç±»
3. **è®¡ç®—èƒ½åŠ›**ï¼šå±•ç¤ºæ— é™åˆ¶æ–‡æ³•çš„è®¡ç®—èƒ½åŠ›
4. **åº”ç”¨ç¤ºä¾‹**ï¼šå±•ç¤ºæ— é™åˆ¶æ–‡æ³•çš„å®é™…åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ— é™åˆ¶æ–‡æ³•çš„ç›´è§‚ç†è§£

æ— é™åˆ¶æ–‡æ³•æ˜¯æœ€ä¸€èˆ¬çš„é‡å†™ç³»ç»Ÿï¼Œå®ƒå…è®¸åœ¨å­—ç¬¦ä¸²çš„ä»»ä½•ä½ç½®è¿›è¡Œä»»æ„æ›¿æ¢ã€‚è¿™ç§çµæ´»æ€§ä½¿å¾—æ— é™åˆ¶æ–‡æ³•èƒ½å¤Ÿç”Ÿæˆæ‰€æœ‰å›¾çµæœºå¯è¯†åˆ«çš„è¯­è¨€ã€‚

### 1.2 åŸºæœ¬å®šä¹‰

**å®šä¹‰ 1.2.1** (æ— é™åˆ¶æ–‡æ³•)
ä¸€ä¸ªæ— é™åˆ¶æ–‡æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ $G = (V, \Sigma, P, S)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯å˜å…ƒé›†åˆï¼ˆéç»ˆç»“ç¬¦ï¼‰
- $\Sigma$ æ˜¯ç»ˆç»“ç¬¦é›†åˆ
- $P$ æ˜¯äº§ç”Ÿå¼é›†åˆï¼Œæ¯ä¸ªäº§ç”Ÿå¼å½¢å¦‚ $\alpha \to \beta$ï¼Œå…¶ä¸­ $\alpha, \beta \in (V \cup \Sigma)^*$
- $S \in V$ æ˜¯èµ·å§‹å˜å…ƒ

### 1.3 æ¨å¯¼å…³ç³»

**å®šä¹‰ 1.3.1** (ç›´æ¥æ¨å¯¼)
è®¾ $G = (V, \Sigma, P, S)$ æ˜¯æ— é™åˆ¶æ–‡æ³•ï¼Œ$\alpha, \beta \in (V \cup \Sigma)^*$ã€‚å¦‚æœå­˜åœ¨äº§ç”Ÿå¼ $\gamma \to \delta \in P$ å’Œå­—ç¬¦ä¸² $u, v$ï¼Œä½¿å¾— $\alpha = u\gamma v$ ä¸” $\beta = u\delta v$ï¼Œåˆ™ç§° $\alpha$ ç›´æ¥æ¨å¯¼å‡º $\beta$ï¼Œè®°ä½œ $\alpha \Rightarrow \beta$ã€‚

**å®šä¹‰ 1.3.2** (æ¨å¯¼)
å¦‚æœå­˜åœ¨å­—ç¬¦ä¸²åºåˆ— $\alpha_0, \alpha_1, \ldots, \alpha_n$ï¼Œä½¿å¾— $\alpha_0 \Rightarrow \alpha_1 \Rightarrow \cdots \Rightarrow \alpha_n$ï¼Œåˆ™ç§° $\alpha_0$ æ¨å¯¼å‡º $\alpha_n$ï¼Œè®°ä½œ $\alpha_0 \Rightarrow^* \alpha_n$ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 è¯­è¨€å®šä¹‰

**å®šä¹‰ 2.1.1** (ç”Ÿæˆçš„è¯­è¨€)
è®¾ $G = (V, \Sigma, P, S)$ æ˜¯æ— é™åˆ¶æ–‡æ³•ï¼Œåˆ™ $G$ ç”Ÿæˆçš„è¯­è¨€ä¸ºï¼š
$$L(G) = \{w \in \Sigma^* \mid S \Rightarrow^* w\}$$

### 2.2 é€’å½’å¯æšä¸¾è¯­è¨€

**å®šä¹‰ 2.2.1** (é€’å½’å¯æšä¸¾è¯­è¨€)
ä¸€ä¸ªè¯­è¨€ $L$ æ˜¯é€’å½’å¯æšä¸¾çš„ï¼Œå¦‚æœå­˜åœ¨æ— é™åˆ¶æ–‡æ³• $G$ ä½¿å¾— $L = L(G)$ã€‚

### 2.3 å›¾çµæœºç­‰ä»·æ€§

**å®šç† 2.3.1** (å›¾çµæœºç­‰ä»·æ€§)
ä¸€ä¸ªè¯­è¨€æ˜¯é€’å½’å¯æšä¸¾çš„å½“ä¸”ä»…å½“å®ƒè¢«æŸä¸ªå›¾çµæœºè¯†åˆ«ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬æ€§è´¨

**å®šç† 3.1.1** (æ— é™åˆ¶æ–‡æ³•çš„è¡¨è¾¾èƒ½åŠ›)
æ— é™åˆ¶æ–‡æ³•èƒ½å¤Ÿç”Ÿæˆæ‰€æœ‰é€’å½’å¯æšä¸¾è¯­è¨€ã€‚

**è¯æ˜**ï¼š
é€šè¿‡æ„é€ æ€§è¯æ˜ï¼Œå¯ä»¥å°†ä»»æ„å›¾çµæœºè½¬æ¢ä¸ºç­‰ä»·çš„æ— é™åˆ¶æ–‡æ³•ã€‚

### 3.2 ä¸å¯åˆ¤å®šæ€§

**å®šç† 3.2.1** (åœæœºé—®é¢˜)
å¯¹äºæ— é™åˆ¶æ–‡æ³•ï¼Œä»¥ä¸‹é—®é¢˜æ˜¯ä¸å¯åˆ¤å®šçš„ï¼š

1. ç»™å®šæ–‡æ³• $G$ å’Œå­—ç¬¦ä¸² $w$ï¼Œåˆ¤æ–­ $w \in L(G)$
2. ç»™å®šæ–‡æ³• $G$ï¼Œåˆ¤æ–­ $L(G) = \emptyset$
3. ç»™å®šæ–‡æ³• $G$ï¼Œåˆ¤æ–­ $L(G) = \Sigma^*$

### 3.3 è¯­è¨€ç±»çš„åŒ…å«å…³ç³»

**å®šç† 3.3.1** (ä¹”å§†æ–¯åŸºè°±ç³»)
è®¾ $\mathcal{L}_0$ è¡¨ç¤ºé€’å½’å¯æšä¸¾è¯­è¨€ç±»ï¼Œ$\mathcal{L}_1$ è¡¨ç¤ºä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ç±»ï¼Œ$\mathcal{L}_2$ è¡¨ç¤ºä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ç±»ï¼Œ$\mathcal{L}_3$ è¡¨ç¤ºæ­£åˆ™è¯­è¨€ç±»ï¼Œåˆ™ï¼š
$$\mathcal{L}_3 \subset \mathcal{L}_2 \subset \mathcal{L}_1 \subset \mathcal{L}_0$$

## 4. ä»£ç å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::fmt;

/// è¡¨ç¤ºä¸€ä¸ªäº§ç”Ÿå¼
#[derive(Debug, Clone)]
pub struct Production {
    pub left: String,
    pub right: String,
}

impl Production {
    pub fn new(left: String, right: String) -> Self {
        Production { left, right }
    }
}

/// è¡¨ç¤ºä¸€ä¸ªæ— é™åˆ¶æ–‡æ³•
#[derive(Debug)]
pub struct UnrestrictedGrammar {
    pub variables: HashSet<char>,
    pub terminals: HashSet<char>,
    pub productions: Vec<Production>,
    pub start_symbol: char,
}

impl UnrestrictedGrammar {
    pub fn new(
        variables: HashSet<char>,
        terminals: HashSet<char>,
        productions: Vec<Production>,
        start_symbol: char,
    ) -> Result<Self, String> {
        // éªŒè¯èµ·å§‹ç¬¦å·åœ¨å˜å…ƒä¸­
        if !variables.contains(&start_symbol) {
            return Err("Start symbol must be in variables".to_string());
        }
        
        // éªŒè¯äº§ç”Ÿå¼çš„ç¬¦å·éƒ½åœ¨å­—æ¯è¡¨ä¸­
        for production in &productions {
            for ch in production.left.chars() {
                if ch != 'Îµ' && !variables.contains(&ch) && !terminals.contains(&ch) {
                    return Err(format!("Invalid symbol '{}' in left side", ch));
                }
            }
            for ch in production.right.chars() {
                if ch != 'Îµ' && !variables.contains(&ch) && !terminals.contains(&ch) {
                    return Err(format!("Invalid symbol '{}' in right side", ch));
                }
            }
        }
        
        Ok(UnrestrictedGrammar {
            variables,
            terminals,
            productions,
            start_symbol,
        })
    }
    
    /// æ£€æŸ¥ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦å¯ä»¥ç”±æ–‡æ³•ç”Ÿæˆ
    pub fn generates(&self, input: &str) -> bool {
        let mut current = self.start_symbol.to_string();
        
        // ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢å¯»æ‰¾æ¨å¯¼
        let mut queue = vec![current.clone()];
        let mut visited = HashSet::new();
        visited.insert(current);
        
        while let Some(current_str) = queue.pop() {
            if current_str == input {
                return true;
            }
            
            // å°è¯•æ‰€æœ‰å¯èƒ½çš„äº§ç”Ÿå¼
            for production in &self.productions {
                let mut pos = 0;
                while let Some(start) = current_str[pos..].find(&production.left) {
                    let actual_start = pos + start;
                    let mut new_str = current_str.clone();
                    new_str.replace_range(actual_start..actual_start + production.left.len(), &production.right);
                    
                    if !visited.contains(&new_str) {
                        visited.insert(new_str.clone());
                        queue.push(new_str);
                    }
                    
                    pos = actual_start + 1;
                }
            }
        }
        
        false
    }
    
    /// ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„æ¨å¯¼æ­¥éª¤
    pub fn derive(&self, max_steps: usize) -> Vec<String> {
        let mut derivations = vec![self.start_symbol.to_string()];
        let mut visited = HashSet::new();
        visited.insert(self.start_symbol.to_string());
        
        for _ in 0..max_steps {
            let mut new_derivations = Vec::new();
            let mut has_new = false;
            
            for current in &derivations {
                for production in &self.productions {
                    let mut pos = 0;
                    while let Some(start) = current[pos..].find(&production.left) {
                        let actual_start = pos + start;
                        let mut new_str = current.clone();
                        new_str.replace_range(actual_start..actual_start + production.left.len(), &production.right);
                        
                        if !visited.contains(&new_str) {
                            visited.insert(new_str.clone());
                            new_derivations.push(new_str);
                            has_new = true;
                        }
                        
                        pos = actual_start + 1;
                    }
                }
            }
            
            if !has_new {
                break;
            }
            
            derivations.extend(new_derivations);
        }
        
        derivations
    }
    
    /// æ£€æŸ¥æ–‡æ³•æ˜¯å¦ä¸ºç©º
    pub fn is_empty(&self) -> bool {
        // å°è¯•ç”Ÿæˆä¸€äº›å­—ç¬¦ä¸²ï¼Œçœ‹æ˜¯å¦èƒ½ç”Ÿæˆä»»ä½•ç»ˆç»“ç¬¦ä¸²
        let derivations = self.derive(10);
        for derivation in derivations {
            if derivation.chars().all(|c| self.terminals.contains(&c)) {
                return false;
            }
        }
        true
    }
}

/// æ„é€ ä¸€ä¸ªç®€å•çš„æ— é™åˆ¶æ–‡æ³•ç¤ºä¾‹
pub fn create_simple_grammar() -> UnrestrictedGrammar {
    let variables: HashSet<char> = vec!['S', 'A', 'B'].into_iter().collect();
    let terminals: HashSet<char> = vec!['a', 'b'].into_iter().collect();
    
    let productions = vec![
        Production::new("S".to_string(), "aSb".to_string()),
        Production::new("S".to_string(), "AB".to_string()),
        Production::new("A".to_string(), "aA".to_string()),
        Production::new("A".to_string(), "Îµ".to_string()),
        Production::new("B".to_string(), "bB".to_string()),
        Production::new("B".to_string(), "Îµ".to_string()),
    ];
    
    UnrestrictedGrammar::new(variables, terminals, productions, 'S').unwrap()
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_simple_grammar() {
        let grammar = create_simple_grammar();
        
        // æµ‹è¯•ä¸€äº›å­—ç¬¦ä¸²
        assert!(grammar.generates("ab"));
        assert!(grammar.generates("aabb"));
        assert!(grammar.generates(""));
        
        // æµ‹è¯•æ¨å¯¼
        let derivations = grammar.derive(5);
        println!("Derivations: {:?}", derivations);
        assert!(!derivations.is_empty());
    }
    
    #[test]
    fn test_grammar_validation() {
        let variables: HashSet<char> = vec!['S'].into_iter().collect();
        let terminals: HashSet<char> = vec!['a'].into_iter().collect();
        let productions = vec![
            Production::new("S".to_string(), "a".to_string()),
        ];
        
        let grammar = UnrestrictedGrammar::new(variables, terminals, productions, 'S');
        assert!(grammar.is_ok());
    }
}
```

### 4.2 Haskell å®ç°

```haskell
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Map (Map)
import qualified Data.Map as Map
import Data.List (find, nub)

-- è¡¨ç¤ºä¸€ä¸ªäº§ç”Ÿå¼
data Production = Production
    { left :: String
    , right :: String
    } deriving (Show, Eq, Ord)

-- è¡¨ç¤ºä¸€ä¸ªæ— é™åˆ¶æ–‡æ³•
data UnrestrictedGrammar = UnrestrictedGrammar
    { variables :: Set Char
    , terminals :: Set Char
    , productions :: [Production]
    , startSymbol :: Char
    } deriving (Show)

-- åˆ›å»ºæ–‡æ³•
createGrammar :: Set Char -> Set Char -> [Production] -> Char -> Maybe UnrestrictedGrammar
createGrammar vars terms prods start
    | Set.member start vars = Just $ UnrestrictedGrammar vars terms prods start
    | otherwise = Nothing

-- æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦å¯ä»¥ç”±æ–‡æ³•ç”Ÿæˆ
generates :: UnrestrictedGrammar -> String -> Bool
generates grammar input = 
    let derivations = derive grammar 20
    in  any (\d -> d == input && all (\c -> Set.member c (terminals grammar)) d) derivations

-- ç”Ÿæˆæ¨å¯¼
derive :: UnrestrictedGrammar -> Int -> [String]
derive grammar maxSteps = 
    let initial = [startSymbol grammar]
        derivations = iterate (step grammar) initial
    in  concat $ take maxSteps derivations

-- å•æ­¥æ¨å¯¼
step :: UnrestrictedGrammar -> [String] -> [String]
step grammar currentStrings = 
    nub $ concatMap (applyProductions grammar) currentStrings

-- åº”ç”¨äº§ç”Ÿå¼
applyProductions :: UnrestrictedGrammar -> String -> [String]
applyProductions grammar str = 
    concatMap (applyProduction str) (productions grammar)

-- åº”ç”¨å•ä¸ªäº§ç”Ÿå¼
applyProduction :: String -> Production -> [String]
applyProduction str (Production left right) = 
    let positions = findSubstringPositions left str
    in  map (\pos -> replaceAt str pos left right) positions

-- æŸ¥æ‰¾å­ä¸²ä½ç½®
findSubstringPositions :: String -> String -> [Int]
findSubstringPositions sub str = 
    [i | i <- [0..length str - length sub], 
     take (length sub) (drop i str) == sub]

-- åœ¨æŒ‡å®šä½ç½®æ›¿æ¢
replaceAt :: String -> Int -> String -> String -> String
replaceAt str pos old new = 
    take pos str ++ new ++ drop (pos + length old) str

-- æ£€æŸ¥æ–‡æ³•æ˜¯å¦ä¸ºç©º
isEmpty :: UnrestrictedGrammar -> Bool
isEmpty grammar = 
    let derivations = derive grammar 10
        terminalStrings = filter (all (\c -> Set.member c (terminals grammar))) derivations
    in  null terminalStrings

-- åˆ›å»ºç¤ºä¾‹æ–‡æ³•
createExampleGrammar :: UnrestrictedGrammar
createExampleGrammar = 
    let variables = Set.fromList "SAB"
        terminals = Set.fromList "ab"
        productions = 
            [ Production "S" "aSb"
            , Production "S" "AB"
            , Production "A" "aA"
            , Production "A" ""
            , Production "B" "bB"
            , Production "B" ""
            ]
    in  UnrestrictedGrammar variables terminals productions 'S'

-- æµ‹è¯•å‡½æ•°
testGrammar :: IO ()
testGrammar = do
    let grammar = createExampleGrammar
    
    putStrLn "Testing unrestricted grammar:"
    putStrLn $ "Generates 'ab': " ++ show (generates grammar "ab")
    putStrLn $ "Generates 'aabb': " ++ show (generates grammar "aabb")
    putStrLn $ "Generates '': " ++ show (generates grammar "")
    
    let derivations = take 10 $ derive grammar 5
    putStrLn $ "Sample derivations: " ++ show derivations
    
    putStrLn $ "Is empty: " ++ show (isEmpty grammar)

main :: IO ()
main = testGrammar
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 è¯­è¨€ç”Ÿæˆ

**ç¤ºä¾‹ 5.1.1** (ç”Ÿæˆ $a^nb^n$)
è€ƒè™‘æ–‡æ³•ï¼š
$$S \to aSb \mid \varepsilon$$

è¿™ä¸ªæ–‡æ³•ç”Ÿæˆè¯­è¨€ $\{a^nb^n \mid n \geq 0\}$ã€‚

### 5.2 è®¡ç®—èƒ½åŠ›

**ç¤ºä¾‹ 5.2.1** (æ¨¡æ‹Ÿå›¾çµæœº)
æ— é™åˆ¶æ–‡æ³•å¯ä»¥æ¨¡æ‹Ÿå›¾çµæœºçš„è®¡ç®—è¿‡ç¨‹ï¼Œé€šè¿‡äº§ç”Ÿå¼æ¥è¡¨ç¤ºçŠ¶æ€è½¬æ¢ã€‚

### 5.3 è‡ªç„¶è¯­è¨€å¤„ç†

**ç¤ºä¾‹ 5.3.1** (è‡ªç„¶è¯­è¨€è¯­æ³•)
è™½ç„¶æ— é™åˆ¶æ–‡æ³•ç†è®ºä¸Šå¯ä»¥æè¿°ä»»ä½•è¯­è¨€ï¼Œä½†åœ¨å®é™…çš„è‡ªç„¶è¯­è¨€å¤„ç†ä¸­ï¼Œé€šå¸¸ä½¿ç”¨æ›´å—é™çš„æ–‡æ³•ç±»å‹ã€‚

## 6. ç›¸å…³ç†è®º

### 6.1 ä¹”å§†æ–¯åŸºè°±ç³»

- **0å‹æ–‡æ³•**ï¼šæ— é™åˆ¶æ–‡æ³•ï¼Œå¯¹åº”é€’å½’å¯æšä¸¾è¯­è¨€
- **1å‹æ–‡æ³•**ï¼šä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•ï¼Œå¯¹åº”ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€
- **2å‹æ–‡æ³•**ï¼šä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ï¼Œå¯¹åº”ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€
- **3å‹æ–‡æ³•**ï¼šæ­£åˆ™æ–‡æ³•ï¼Œå¯¹åº”æ­£åˆ™è¯­è¨€

### 6.2 è®¡ç®—å¤æ‚æ€§

æ— é™åˆ¶æ–‡æ³•çš„è§£æé—®é¢˜æ˜¯ä¸å¯åˆ¤å®šçš„ï¼Œè¿™åæ˜ äº†é€’å½’å¯æšä¸¾è¯­è¨€çš„å¤æ‚æ€§ã€‚

### 6.3 è¯­è¨€ç±»çš„æ€§è´¨

- **é€’å½’å¯æšä¸¾è¯­è¨€**ï¼šå¯ä»¥è¢«å›¾çµæœºè¯†åˆ«
- **é€’å½’è¯­è¨€**ï¼šå¯ä»¥è¢«æ€»æ˜¯åœæœºçš„å›¾çµæœºè¯†åˆ«
- **ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€**ï¼šå¯ä»¥è¢«çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºè¯†åˆ«

## 7. å‚è€ƒæ–‡çŒ®

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to Automata Theory, Languages, and Computation. Pearson.
2. Sipser, M. (2012). Introduction to the Theory of Computation. Cengage Learning.
3. Chomsky, N. (1956). Three models for the description of language. IRE Transactions on Information Theory, 2(3), 113-124.
4. Davis, M., Sigal, R., & Weyuker, E. J. (1994). Computability, Complexity, and Languages. Academic Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [03.2.1 æ­£åˆ™æ–‡æ³•](../03_Formal_Language_Theory/03.2.1_æ­£åˆ™æ–‡æ³•.md)
- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03_Formal_Language_Theory/03.2.2_ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•.md)
- [03.2.3 ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•](../03_Formal_Language_Theory/03.2.3_ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•.md)
- [03.3.1 ä¹”å§†æ–¯åŸºè°±ç³»](../03_Formal_Language_Theory/03.3.1_ä¹”å§†æ–¯åŸºè°±ç³».md)
