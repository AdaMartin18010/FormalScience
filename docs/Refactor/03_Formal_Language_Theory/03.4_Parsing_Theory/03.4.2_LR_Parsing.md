# 03.4.2 LRè§£æç†è®º

## ğŸ“‹ æ¦‚è¿°

LRè§£ææ˜¯ä¸€ç§è‡ªåº•å‘ä¸Šçš„è¯­æ³•åˆ†ææ–¹æ³•ï¼Œèƒ½å¤Ÿå¤„ç†æ¯”LLè§£ææ›´å¹¿æ³›çš„æ–‡æ³•ç±»ã€‚
æœ¬ç†è®ºå»ºç«‹LRè§£æçš„æ•°å­¦åŸºç¡€ã€ç®—æ³•å®ç°å’Œåº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹LRæ–‡æ³•çš„ä¸¥æ ¼å®šä¹‰
2. è¯æ˜LRè§£æçš„æ­£ç¡®æ€§
3. æä¾›é«˜æ•ˆçš„è§£æç®—æ³•
4. å±•ç¤ºåœ¨ç¼–è¯‘å™¨ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

- [03.4.2 LRè§£æç†è®º](#0342-lrè§£æç†è®º)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒç›®æ ‡](#-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 LRæ–‡æ³•](#11-lræ–‡æ³•)
    - [1.2 è§„èŒƒå½’çº¦](#12-è§„èŒƒå½’çº¦)
    - [1.3 å¥æŸ„](#13-å¥æŸ„)
  - [2. å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
    - [2.1 LRçŠ¶æ€](#21-lrçŠ¶æ€)
    - [2.2 LRè§£æè¡¨](#22-lrè§£æè¡¨)
  - [3. å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
    - [3.1 LRè§£ææ­£ç¡®æ€§](#31-lrè§£ææ­£ç¡®æ€§)
    - [3.2 å†²çªæ£€æµ‹](#32-å†²çªæ£€æµ‹)
  - [4. ç®—æ³•å®ç°](#4-ç®—æ³•å®ç°)
    - [4.1 Rust å®ç°](#41-rust-å®ç°)
  - [5. åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
    - [5.1 ç¼–è¯‘å™¨å‰ç«¯](#51-ç¼–è¯‘å™¨å‰ç«¯)
    - [5.2 è‡ªç„¶è¯­è¨€å¤„ç†](#52-è‡ªç„¶è¯­è¨€å¤„ç†)
    - [5.3 é…ç½®è§£æ](#53-é…ç½®è§£æ)
  - [6. ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
    - [6.1 æ–‡æ³•ç†è®º](#61-æ–‡æ³•ç†è®º)
    - [6.2 è‡ªåŠ¨æœºç†è®º](#62-è‡ªåŠ¨æœºç†è®º)
    - [6.3 è¯­ä¹‰ç†è®º](#63-è¯­ä¹‰ç†è®º)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)
    - [å¤šå…ƒè§†è§’](#å¤šå…ƒè§†è§’)
    - [å±€é™ä¸äº‰è®®](#å±€é™ä¸äº‰è®®)
    - [åº”ç”¨å‰æ™¯](#åº”ç”¨å‰æ™¯)
    - [å®è·µå»ºè®®](#å®è·µå»ºè®®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 LRæ–‡æ³•

**å®šä¹‰ 1.1.1** (LR(k)æ–‡æ³•)
æ–‡æ³• $G$ æ˜¯LR(k)æ–‡æ³•ï¼Œå½“ä¸”ä»…å½“å¯¹äºä»»æ„ä¸¤ä¸ªä¸åŒçš„å³å¥å‹ï¼Œå…¶è§„èŒƒå‰ç¼€åœ¨å‘å‰çœ‹kä¸ªç¬¦å·åèƒ½å¤ŸåŒºåˆ†ã€‚

### 1.2 è§„èŒƒå½’çº¦

**å®šä¹‰ 1.1.2** (è§„èŒƒå½’çº¦)
è§„èŒƒå½’çº¦æ˜¯è‡ªåº•å‘ä¸Šè§£æä¸­çš„æ ¸å¿ƒæ“ä½œï¼Œå°†å¥æŸ„å½’çº¦ä¸ºéç»ˆç»“ç¬¦ã€‚

### 1.3 å¥æŸ„

**å®šä¹‰ 1.1.3** (å¥æŸ„)
å¥æŸ„æ˜¯å³å¥å‹ä¸­èƒ½å¤Ÿç«‹å³å½’çº¦çš„äº§ç”Ÿå¼å³éƒ¨ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 LRçŠ¶æ€

**å®šä¹‰ 2.1.1** (LRé¡¹ç›®)
LRé¡¹ç›®æ˜¯å½¢å¦‚ $[A \to \alpha \cdot \beta, a]$ çš„äºŒå…ƒç»„ï¼Œå…¶ä¸­ $A \to \alpha \beta$ æ˜¯äº§ç”Ÿå¼ï¼Œ$a$ æ˜¯å‘å‰çœ‹ç¬¦å·ã€‚

### 2.2 LRè§£æè¡¨

**å®šä¹‰ 2.1.2** (LRè§£æè¡¨)
LRè§£æè¡¨åŒ…å«ACTIONå’ŒGOTOä¸¤ä¸ªéƒ¨åˆ†ï¼š

- ACTION[s,a]: çŠ¶æ€sä¸‹è¾“å…¥açš„åŠ¨ä½œ
- GOTO[s,A]: çŠ¶æ€sä¸‹éç»ˆç»“ç¬¦Açš„è½¬ç§»

## 3. å®šç†ä¸è¯æ˜

### 3.1 LRè§£ææ­£ç¡®æ€§

**å®šç† 3.1.1** (LRè§£ææ­£ç¡®æ€§)
å¦‚æœæ–‡æ³• $G$ æ˜¯LR(k)æ–‡æ³•ï¼Œåˆ™LR(k)è§£æå™¨èƒ½æ­£ç¡®è¯†åˆ« $L(G)$ ä¸­çš„æ‰€æœ‰å¥å­ã€‚

**è¯æ˜**ï¼š
ä½¿ç”¨å½’çº³æ³•è¯æ˜è§£æè¿‡ç¨‹çš„æ­£ç¡®æ€§ã€‚

### 3.2 å†²çªæ£€æµ‹

**å®šç† 3.2.1** (LRå†²çª)
æ–‡æ³• $G$ ä¸æ˜¯LR(k)æ–‡æ³•ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨çŠ¶æ€åŒ…å«ç§»è¿›-å½’çº¦å†²çªæˆ–å½’çº¦-å½’çº¦å†²çªã€‚

## 4. ç®—æ³•å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::fmt;

/// LRé¡¹ç›®
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LRItem {
    pub production: Production,
    pub dot_position: usize,
    pub lookahead: String,
}

/// LRçŠ¶æ€
#[derive(Debug, Clone)]
pub struct LRState {
    pub items: HashSet<LRItem>,
    pub state_id: usize,
}

/// LRè§£æåŠ¨ä½œ
#[derive(Debug, Clone)]
pub enum LRAction {
    Shift(usize),      // ç§»è¿›åˆ°çŠ¶æ€
    Reduce(Production), // å½’çº¦
    Accept,            // æ¥å—
    Error,             // é”™è¯¯
}

/// LRè§£æå™¨
#[derive(Debug)]
pub struct LRParser {
    grammar: Grammar,
    states: Vec<LRState>,
    action_table: HashMap<(usize, String), LRAction>,
    goto_table: HashMap<(usize, String), usize>,
}

impl LRItem {
    /// åˆ›å»ºLRé¡¹ç›®
    pub fn new(production: Production, dot_position: usize, lookahead: String) -> Self {
        Self {
            production,
            dot_position,
            lookahead,
        }
    }
    
    /// è·å–ç‚¹åçš„ç¬¦å·
    pub fn symbol_after_dot(&self) -> Option<&Symbol> {
        if self.dot_position < self.production.right.len() {
            Some(&self.production.right[self.dot_position])
        } else {
            None
        }
    }
    
    /// é¡¹ç›®æ˜¯å¦å®Œæˆ
    pub fn is_complete(&self) -> bool {
        self.dot_position >= self.production.right.len()
    }
    
    /// è·å–ä¸‹ä¸€ä¸ªé¡¹ç›®
    pub fn next_item(&self) -> Option<LRItem> {
        if !self.is_complete() {
            Some(LRItem {
                production: self.production.clone(),
                dot_position: self.dot_position + 1,
                lookahead: self.lookahead.clone(),
            })
        } else {
            None
        }
    }
}

impl LRState {
    /// åˆ›å»ºæ–°çŠ¶æ€
    pub fn new(state_id: usize) -> Self {
        Self {
            items: HashSet::new(),
            state_id,
        }
    }
    
    /// æ·»åŠ é¡¹ç›®
    pub fn add_item(&mut self, item: LRItem) {
        self.items.insert(item);
    }
    
    /// è·å–æ‰€æœ‰é¡¹ç›®
    pub fn get_items(&self) -> &HashSet<LRItem> {
        &self.items
    }
    
    /// æ£€æŸ¥æ˜¯å¦åŒ…å«é¡¹ç›®
    pub fn contains_item(&self, item: &LRItem) -> bool {
        self.items.contains(item)
    }
}

impl LRParser {
    /// åˆ›å»ºLRè§£æå™¨
    pub fn new(grammar: Grammar) -> Self {
        let mut parser = Self {
            grammar,
            states: Vec::new(),
            action_table: HashMap::new(),
            goto_table: HashMap::new(),
        };
        
        parser.build_lr_states();
        parser.build_parse_tables();
        
        parser
    }
    
    /// æ„å»ºLRçŠ¶æ€
    fn build_lr_states(&mut self) {
        // åˆ›å»ºåˆå§‹çŠ¶æ€
        let initial_state = self.create_initial_state();
        self.states.push(initial_state);
        
        // æ„å»ºæ‰€æœ‰çŠ¶æ€
        let mut state_queue = vec![0];
        let mut processed = HashSet::new();
        
        while let Some(state_id) = state_queue.pop() {
            if processed.contains(&state_id) {
                continue;
            }
            processed.insert(state_id);
            
            let state = &self.states[state_id];
            let closures = self.compute_closure(&state.items);
            
            // ä¸ºæ¯ä¸ªç¬¦å·è®¡ç®—è½¬ç§»
            for symbol in self.get_all_symbols() {
                let goto_items = self.compute_goto(&closures, &symbol);
                
                if !goto_items.is_empty() {
                    let next_state_id = self.find_or_create_state(goto_items);
                    
                    if !processed.contains(&next_state_id) {
                        state_queue.push(next_state_id);
                    }
                    
                    // è®°å½•è½¬ç§»
                    if symbol.is_terminal() {
                        self.action_table.insert(
                            (state_id, symbol.to_string()),
                            LRAction::Shift(next_state_id)
                        );
                    } else {
                        self.goto_table.insert(
                            (state_id, symbol.to_string()),
                            next_state_id
                        );
                    }
                }
            }
        }
    }
    
    /// åˆ›å»ºåˆå§‹çŠ¶æ€
    fn create_initial_state(&self) -> LRState {
        let mut state = LRState::new(0);
        
        // æ·»åŠ å¢å¹¿äº§ç”Ÿå¼çš„åˆå§‹é¡¹ç›®
        let augmented_production = Production {
            left: "S'".to_string(),
            right: vec![Symbol::NonTerminal(self.grammar.start_symbol.clone())],
        };
        
        let initial_item = LRItem::new(
            augmented_production,
            0,
            "$".to_string() // ç»“æŸç¬¦
        );
        
        state.add_item(initial_item);
        state
    }
    
    /// è®¡ç®—é—­åŒ…
    fn compute_closure(&self, items: &HashSet<LRItem>) -> HashSet<LRItem> {
        let mut closure = items.clone();
        let mut changed = true;
        
        while changed {
            changed = false;
            let mut new_items = HashSet::new();
            
            for item in &closure {
                if let Some(symbol) = item.symbol_after_dot() {
                    if let Symbol::NonTerminal(nt) = symbol {
                        // è·å–è¯¥éç»ˆç»“ç¬¦çš„æ‰€æœ‰äº§ç”Ÿå¼
                        let productions = self.grammar.get_productions(nt);
                        
                        for production in productions {
                            // è®¡ç®—å‘å‰çœ‹ç¬¦å·
                            let lookaheads = self.compute_lookaheads(item, nt);
                            
                            for lookahead in lookaheads {
                                let new_item = LRItem::new(
                                    production.clone(),
                                    0,
                                    lookahead
                                );
                                
                                if !closure.contains(&new_item) {
                                    new_items.insert(new_item);
                                    changed = true;
                                }
                            }
                        }
                    }
                }
            }
            
            closure.extend(new_items);
        }
        
        closure
    }
    
    /// è®¡ç®—GOTO
    fn compute_goto(&self, items: &HashSet<LRItem>, symbol: &Symbol) -> HashSet<LRItem> {
        let mut goto_items = HashSet::new();
        
        for item in items {
            if let Some(next_symbol) = item.symbol_after_dot() {
                if next_symbol == symbol {
                    if let Some(next_item) = item.next_item() {
                        goto_items.insert(next_item);
                    }
                }
            }
        }
        
        self.compute_closure(&goto_items)
    }
    
    /// è®¡ç®—å‘å‰çœ‹ç¬¦å·
    fn compute_lookaheads(&self, item: &LRItem, nt: &str) -> HashSet<String> {
        let mut lookaheads = HashSet::new();
        
        // è·å–ç‚¹åçš„ç¬¦å·ä¸²
        let beta = &item.production.right[item.dot_position + 1..];
        
        if beta.is_empty() {
            // å¦‚æœÎ²ä¸ºç©ºï¼Œå‘å‰çœ‹ç¬¦å·å°±æ˜¯é¡¹ç›®çš„å‘å‰çœ‹ç¬¦å·
            lookaheads.insert(item.lookahead.clone());
        } else {
            // è®¡ç®—FIRST(Î²)
            let first_beta = self.compute_first_of_sequence(beta);
            
            for symbol in first_beta {
                if symbol != "Îµ" {
                    lookaheads.insert(symbol);
                }
            }
            
            // å¦‚æœÎ²èƒ½æ¨å¯¼å‡ºÎµï¼Œæ·»åŠ é¡¹ç›®çš„å‘å‰çœ‹ç¬¦å·
            if first_beta.contains("Îµ") {
                lookaheads.insert(item.lookahead.clone());
            }
        }
        
        lookaheads
    }
    
    /// è®¡ç®—ç¬¦å·ä¸²çš„FIRSTé›†åˆ
    fn compute_first_of_sequence(&self, sequence: &[Symbol]) -> HashSet<String> {
        let mut first = HashSet::new();
        
        for symbol in sequence {
            match symbol {
                Symbol::Terminal(t) => {
                    first.insert(t.clone());
                    break;
                }
                Symbol::NonTerminal(nt) => {
                    let nt_first = self.compute_first(nt);
                    first.extend(nt_first.iter().filter(|&s| s != "Îµ").cloned());
                    
                    if !nt_first.contains("Îµ") {
                        break;
                    }
                }
            }
        }
        
        // å¦‚æœæ‰€æœ‰ç¬¦å·éƒ½èƒ½æ¨å¯¼å‡ºÎµï¼Œæ·»åŠ Îµ
        if sequence.iter().all(|s| {
            if let Symbol::NonTerminal(nt) = s {
                self.compute_first(nt).contains("Îµ")
            } else {
                false
            }
        }) {
            first.insert("Îµ".to_string());
        }
        
        first
    }
    
    /// è®¡ç®—éç»ˆç»“ç¬¦çš„FIRSTé›†åˆ
    fn compute_first(&self, nt: &str) -> HashSet<String> {
        let mut first = HashSet::new();
        let productions = self.grammar.get_productions(nt);
        
        for production in productions {
            if production.right.is_empty() {
                first.insert("Îµ".to_string());
            } else {
                let seq_first = self.compute_first_of_sequence(&production.right);
                first.extend(seq_first);
            }
        }
        
        first
    }
    
    /// æŸ¥æ‰¾æˆ–åˆ›å»ºçŠ¶æ€
    fn find_or_create_state(&mut self, items: HashSet<LRItem>) -> usize {
        // æŸ¥æ‰¾ç°æœ‰çŠ¶æ€
        for (i, state) in self.states.iter().enumerate() {
            if state.items == items {
                return i;
            }
        }
        
        // åˆ›å»ºæ–°çŠ¶æ€
        let new_state_id = self.states.len();
        let mut new_state = LRState::new(new_state_id);
        
        for item in items {
            new_state.add_item(item);
        }
        
        self.states.push(new_state);
        new_state_id
    }
    
    /// è·å–æ‰€æœ‰ç¬¦å·
    fn get_all_symbols(&self) -> Vec<Symbol> {
        let mut symbols = Vec::new();
        
        // æ·»åŠ æ‰€æœ‰ç»ˆç»“ç¬¦
        for terminal in &self.grammar.terminals {
            symbols.push(Symbol::Terminal(terminal.clone()));
        }
        
        // æ·»åŠ æ‰€æœ‰éç»ˆç»“ç¬¦
        for non_terminal in &self.grammar.non_terminals {
            symbols.push(Symbol::NonTerminal(non_terminal.clone()));
        }
        
        symbols
    }
    
    /// æ„å»ºè§£æè¡¨
    fn build_parse_tables(&mut self) {
        for (state_id, state) in self.states.iter().enumerate() {
            for item in &state.items {
                if item.is_complete() {
                    // å½’çº¦åŠ¨ä½œ
                    if item.production.left == "S'" {
                        // æ¥å—åŠ¨ä½œ
                        self.action_table.insert(
                            (state_id, item.lookahead.clone()),
                            LRAction::Accept
                        );
                    } else {
                        // å½’çº¦åŠ¨ä½œ
                        self.action_table.insert(
                            (state_id, item.lookahead.clone()),
                            LRAction::Reduce(item.production.clone())
                        );
                    }
                }
            }
        }
    }
    
    /// è§£æè¾“å…¥
    pub fn parse(&self, input: &[String]) -> Result<Vec<Production>, String> {
        let mut stack = vec![0]; // çŠ¶æ€æ ˆ
        let mut symbol_stack = Vec::new(); // ç¬¦å·æ ˆ
        let mut input_pos = 0;
        let mut derivations = Vec::new();
        
        loop {
            let current_state = stack.last().unwrap();
            let current_input = if input_pos < input.len() {
                &input[input_pos]
            } else {
                "$"
            };
            
            if let Some(action) = self.action_table.get(&(*current_state, current_input.to_string())) {
                match action {
                    LRAction::Shift(next_state) => {
                        stack.push(*next_state);
                        symbol_stack.push(Symbol::Terminal(current_input.to_string()));
                        input_pos += 1;
                    }
                    
                    LRAction::Reduce(production) => {
                        derivations.push(production.clone());
                        
                        // å¼¹å‡ºäº§ç”Ÿå¼å³éƒ¨é•¿åº¦çš„ç¬¦å·å’ŒçŠ¶æ€
                        let rhs_len = production.right.len();
                        for _ in 0..rhs_len {
                            stack.pop();
                            symbol_stack.pop();
                        }
                        
                        // è·å–å½’çº¦åçš„çŠ¶æ€
                        let current_state = stack.last().unwrap();
                        let lhs_symbol = Symbol::NonTerminal(production.left.clone());
                        
                        if let Some(&next_state) = self.goto_table.get(&(*current_state, production.left)) {
                            stack.push(next_state);
                            symbol_stack.push(lhs_symbol);
                        } else {
                            return Err("GOTO table error".to_string());
                        }
                    }
                    
                    LRAction::Accept => {
                        return Ok(derivations);
                    }
                    
                    LRAction::Error => {
                        return Err(format!("Parse error at position {}", input_pos));
                    }
                }
            } else {
                return Err(format!("No action for state {} and input '{}'", current_state, current_input));
            }
        }
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºLR(1)æ–‡æ³•
    pub fn is_lr1(&self) -> bool {
        for (key, action) in &self.action_table {
            if let LRAction::Reduce(_) = action {
                // æ£€æŸ¥æ˜¯å¦æœ‰ç§»è¿›-å½’çº¦å†²çª
                if let Some(LRAction::Shift(_)) = self.action_table.get(key) {
                    return false;
                }
            }
        }
        
        // æ£€æŸ¥å½’çº¦-å½’çº¦å†²çª
        let mut reduce_actions = HashMap::new();
        for (key, action) in &self.action_table {
            if let LRAction::Reduce(production) = action {
                if let Some(existing) = reduce_actions.get(key) {
                    if existing != production {
                        return false;
                    }
                } else {
                    reduce_actions.insert(key.clone(), production.clone());
                }
            }
        }
        
        true
    }
}

/// ç¤ºä¾‹æ–‡æ³•
pub struct ExampleGrammars;

impl ExampleGrammars {
    /// ç®—æœ¯è¡¨è¾¾å¼æ–‡æ³•
    pub fn arithmetic_grammar() -> Grammar {
        let mut grammar = Grammar::new("E".to_string());
        
        // E -> E + T | T
        grammar.add_production("E".to_string(), vec![
            Symbol::NonTerminal("E".to_string()),
            Symbol::Terminal("+".to_string()),
            Symbol::NonTerminal("T".to_string())
        ]);
        grammar.add_production("E".to_string(), vec![
            Symbol::NonTerminal("T".to_string())
        ]);
        
        // T -> T * F | F
        grammar.add_production("T".to_string(), vec![
            Symbol::NonTerminal("T".to_string()),
            Symbol::Terminal("*".to_string()),
            Symbol::NonTerminal("F".to_string())
        ]);
        grammar.add_production("T".to_string(), vec![
            Symbol::NonTerminal("F".to_string())
        ]);
        
        // F -> (E) | id
        grammar.add_production("F".to_string(), vec![
            Symbol::Terminal("(".to_string()),
            Symbol::NonTerminal("E".to_string()),
            Symbol::Terminal(")".to_string())
        ]);
        grammar.add_production("F".to_string(), vec![
            Symbol::Terminal("id".to_string())
        ]);
        
        grammar
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_arithmetic_grammar() {
        let grammar = ExampleGrammars::arithmetic_grammar();
        let parser = LRParser::new(grammar);
        
        assert!(parser.is_lr1());
    }
    
    #[test]
    fn test_parse_simple_expression() {
        let grammar = ExampleGrammars::arithmetic_grammar();
        let parser = LRParser::new(grammar);
        
        let input = vec!["id".to_string(), "+".to_string(), "id".to_string()];
        let result = parser.parse(&input);
        
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_parse_complex_expression() {
        let grammar = ExampleGrammars::arithmetic_grammar();
        let parser = LRParser::new(grammar);
        
        let input = vec![
            "id".to_string(), "*".to_string(), "(".to_string(),
            "id".to_string(), "+".to_string(), "id".to_string(),
            ")".to_string()
        ];
        let result = parser.parse(&input);
        
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_parse_error() {
        let grammar = ExampleGrammars::arithmetic_grammar();
        let parser = LRParser::new(grammar);
        
        let input = vec!["id".to_string(), "id".to_string()]; // ç¼ºå°‘è¿ç®—ç¬¦
        let result = parser.parse(&input);
        
        assert!(result.is_err());
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç¼–è¯‘å™¨å‰ç«¯

- è¯­æ³•åˆ†æå™¨
- æŠ½è±¡è¯­æ³•æ ‘æ„å»º
- é”™è¯¯æ¢å¤

### 5.2 è‡ªç„¶è¯­è¨€å¤„ç†

- å¥æ³•åˆ†æ
- ä¾å­˜å…³ç³»è§£æ
- è¯­ä¹‰è§’è‰²æ ‡æ³¨

### 5.3 é…ç½®è§£æ

- JSONè§£æå™¨
- XMLè§£æå™¨
- é…ç½®æ–‡ä»¶è§£æ

## 6. ç›¸å…³ç†è®º

### 6.1 æ–‡æ³•ç†è®º

- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03.2_Formal_Grammars/03.2.2_Context_Free_Grammar.md)

### 6.2 è‡ªåŠ¨æœºç†è®º

- [03.1.1 æœ‰é™è‡ªåŠ¨æœº](../01_Automata_Theory/03.1.1_Finite_Automata.md)

### 6.3 è¯­ä¹‰ç†è®º

- [03.5.1 æ“ä½œè¯­ä¹‰](../03.5.1_Operational_Semantics.md)

## 7. å‚è€ƒæ–‡çŒ®

1. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). *Compilers: Principles, Techniques, and Tools*. Pearson.

2. Grune, D., & Jacobs, C. J. (2008). *Parsing Techniques: A Practical Guide*. Springer.

3. Sippu, S., & Soisalon-Soininen, E. (1990). *Parsing Theory: Volume I: Languages and Parsing*. Springer.

4. Dick, P. (1991). *A Practical Guide to Compiler Construction*. Springer.

5. Appel, A. W. (1998). *Modern Compiler Implementation in ML*. Cambridge University Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [ä¸Šä¸€çº§ï¼š03.4 è§£æç†è®º](README.md)
- [ä¸‹ä¸€çº§ï¼š03.4.3 é€’å½’ä¸‹é™è§£æ](03.4.3_Recursive_Descent_Parsing.md)
- [ä¸»ç´¢å¼•ï¼šå½¢å¼ç§‘å­¦ç†è®ºä½“ç³»](README.md)

## æ‰¹åˆ¤æ€§åˆ†æ

### å¤šå…ƒè§†è§’

- ä¸LLï¼šLRæ—è¦†ç›–æ›´å¹¿ä¸”å¤©ç„¶æ”¯æŒå·¦é€’å½’ï¼›ä½†æ„è¡¨å¤æ‚ã€è°ƒè¯•æˆæœ¬é«˜ã€‚LLé€‚åˆæ•™å­¦ä¸è½»é‡DSLï¼ŒLRé€‚åˆä¸»æµè¯­è¨€å‰ç«¯ã€‚
- ä¸GLRï¼šGLRå¤„ç†æ­§ä¹‰æ›´çµæ´»ï¼Œä½†è¿è¡Œæ—¶æˆæœ¬é«˜ï¼›LRåœ¨ç¡®å®šæ€§è¯­æ³•ä¸Šæ›´é«˜æ•ˆã€‚
- ä¸è¯­ä¹‰è”åŠ¨ï¼šLRå¸¸ä¸ä¸­é—´è¡¨ç¤ºå’Œå±æ€§æ–‡æ³•å¯¹æ¥ï¼Œä¿ƒè¿›è¯­ä¹‰åŠ¨ä½œæœ‰åºæ‰§è¡Œã€‚

### å±€é™ä¸äº‰è®®

- è¡¨è§„æ¨¡ä¸ç”Ÿæˆæ—¶é—´ï¼šLR(1)è¡¨å¯èƒ½çˆ†ç‚¸ï¼Œå·¥ç¨‹ä¸Šå¤šç”¨ LALR(1) æŠ˜è¡·ï¼Œå­˜åœ¨å†²çªåˆå¹¶çš„è¯­ä¹‰é£é™©ã€‚
- é”™è¯¯æ¢å¤ï¼šä¼˜é›…çš„é”™è¯¯æ¢å¤ä¸è‰¯å¥½æç¤ºå¹¶ä¸å®¹æ˜“ï¼Œéœ€è¦é¢å¤–è®¾è®¡ï¼ˆåŒæ­¥é›†ã€çŸ­è¯­å±‚æ¬¡ä¿®å¤ï¼‰ã€‚
- å¯ç»´æŠ¤æ€§ï¼šæ–‡æ³•å¾®è°ƒå¯èƒ½å¯¼è‡´çŠ¶æ€æ¿€å¢æˆ–æ–°å†²çªï¼Œéœ€è‡ªåŠ¨åŒ–å›å½’ä¸å¯è§†åŒ–å·¥å…·ã€‚

### åº”ç”¨å‰æ™¯

- ç”Ÿäº§çº§ç¼–è¯‘å™¨/è§£é‡Šå™¨å‰ç«¯çš„äº‹å®æ ‡å‡†ï¼ˆYacc/Bison/ANTLR LR æ¨¡å¼ç­‰ï¼‰ã€‚
- è¯­è¨€æœåŠ¡ï¼šå€ŸåŠ©å¢é‡ LR/GLR æŠ€æœ¯ï¼Œæ”¯æ’‘ IDE è¯­æ³•æœåŠ¡ä¸é‡æ„ã€‚
- å®‰å…¨è§£æï¼šåœ¨åè®®åŠé…ç½®è§£æä¸­æä¾›æ›´ä¸¥æ ¼çš„åˆ¤å®šèƒ½åŠ›ã€‚

### å®è·µå»ºè®®

- æ¨¡å¼é€‰æ‹©ï¼šä¼˜å…ˆ LALR(1)ï¼›é‡åˆ°å¤æ‚æ­§ä¹‰å†è€ƒè™‘ GLRï¼›å°å‹å­è¯­æ³•å¯ç”¨ LL/ç»„åˆå­ã€‚
- è‡ªåŠ¨åŒ–æ£€æŸ¥ï¼šæ„å»ºå†²çªä»ªè¡¨æ¿ã€æœ€å°åä¾‹ç”Ÿæˆä¸å·®åˆ†æµ‹è¯•ã€‚
- ä¸è¯­ä¹‰é›†æˆï¼šå°†è¯­ä¹‰åŠ¨ä½œä¸ä¸­é—´è¡¨ç¤ºæ„é€ è§£è€¦ï¼Œä¿æŒè§£æä¸è¯­ä¹‰çš„æ¸…æ™°è¾¹ç•Œã€‚
