# 03.4.1 LLè§£æç†è®º

## ç›®å½• | Contents

- [03.4.1 LLè§£æç†è®º](#0341-llè§£æç†è®º)
  - [ç›®å½• | Contents](#ç›®å½•--contents)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒç›®æ ‡](#-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 LLæ–‡æ³•](#11-llæ–‡æ³•)
    - [1.2 FIRSTé›†åˆ](#12-firsté›†åˆ)
    - [1.3 FOLLOWé›†åˆ](#13-followé›†åˆ)
  - [2. å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
    - [2.1 LLè§£æè¡¨](#21-llè§£æè¡¨)
    - [2.2 è§£ææ ˆæ“ä½œ](#22-è§£ææ ˆæ“ä½œ)
  - [3. å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
    - [3.1 LLè§£ææ­£ç¡®æ€§](#31-llè§£ææ­£ç¡®æ€§)
    - [3.2 å†²çªæ£€æµ‹](#32-å†²çªæ£€æµ‹)
  - [4. ç®—æ³•å®ç°](#4-ç®—æ³•å®ç°)
    - [4.1 Rust å®ç°](#41-rust-å®ç°)
  - [5. åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
    - [5.1 ç¼–è¯‘å™¨å‰ç«¯](#51-ç¼–è¯‘å™¨å‰ç«¯)
    - [5.2 è‡ªç„¶è¯­è¨€å¤„ç†](#52-è‡ªç„¶è¯­è¨€å¤„ç†)
    - [5.3 é…ç½®è§£æ](#53-é…ç½®è§£æ)
  - [6. ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
    - [6.1 æ–‡æ³•ç†è®º](#61-æ–‡æ³•ç†è®º)
    - [6.2 è‡ªåŠ¨æœºç†è®º](#62-è‡ªåŠ¨æœºç†è®º)
    - [6.3 è¯­ä¹‰ç†è®º](#63-è¯­ä¹‰ç†è®º)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)
    - [å¤šå…ƒè§†è§’](#å¤šå…ƒè§†è§’)
    - [å±€é™ä¸äº‰è®®](#å±€é™ä¸äº‰è®®)
    - [åº”ç”¨å‰æ™¯](#åº”ç”¨å‰æ™¯)
    - [å®è·µå»ºè®®](#å®è·µå»ºè®®)

## ğŸ“‹ æ¦‚è¿°

LLè§£ææ˜¯ä¸€ç§è‡ªé¡¶å‘ä¸‹çš„è¯­æ³•åˆ†ææ–¹æ³•ï¼Œé€‚ç”¨äºLL(k)æ–‡æ³•ã€‚
æœ¬ç†è®ºå»ºç«‹LLè§£æçš„æ•°å­¦åŸºç¡€ã€ç®—æ³•å®ç°å’Œåº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹LLæ–‡æ³•çš„ä¸¥æ ¼å®šä¹‰
2. è¯æ˜LLè§£æçš„æ­£ç¡®æ€§
3. æä¾›é«˜æ•ˆçš„è§£æç®—æ³•
4. å±•ç¤ºåœ¨ç¼–è¯‘å™¨ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ç®—æ³•å®ç°](#4-ç®—æ³•å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 LLæ–‡æ³•

**å®šä¹‰ 1.1.1** (LL(k)æ–‡æ³•)
æ–‡æ³• $G$ æ˜¯LL(k)æ–‡æ³•ï¼Œå½“ä¸”ä»…å½“å¯¹äºä»»æ„ä¸¤ä¸ªä¸åŒçš„äº§ç”Ÿå¼ $A \to \alpha$ å’Œ $A \to \beta$ï¼Œæœ‰ï¼š
$$FIRST_k(\alpha FOLLOW_k(A)) \cap FIRST_k(\beta FOLLOW_k(A)) = \emptyset$$

### 1.2 FIRSTé›†åˆ

**å®šä¹‰ 1.1.2** (FIRSTé›†åˆ)
å¯¹äºç¬¦å·ä¸² $\alpha$ï¼Œ$FIRST_k(\alpha)$ æ˜¯ $\alpha$ èƒ½æ¨å¯¼å‡ºçš„æ‰€æœ‰é•¿åº¦ä¸º $k$ çš„å‰ç¼€çš„é›†åˆã€‚

### 1.3 FOLLOWé›†åˆ

**å®šä¹‰ 1.1.3** (FOLLOWé›†åˆ)
å¯¹äºéç»ˆç»“ç¬¦ $A$ï¼Œ$FOLLOW_k(A)$ æ˜¯ç´§è·Ÿåœ¨ $A$ åé¢çš„é•¿åº¦ä¸º $k$ çš„ç¬¦å·ä¸²é›†åˆã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 LLè§£æè¡¨

**å®šä¹‰ 2.1.1** (LLè§£æè¡¨)
LL(k)è§£æè¡¨ $M$ å®šä¹‰ä¸ºï¼š
$$
M[A, a] = \begin{cases}
A \to \alpha & \text{if } a \in FIRST_k(\alpha FOLLOW_k(A)) \\
\text{error} & \text{otherwise}
\end{cases}
$$

### 2.2 è§£ææ ˆæ“ä½œ

**å®šä¹‰ 2.1.2** (è§£ææ ˆ)
è§£ææ ˆ $S$ æ˜¯ç¬¦å·æ ˆï¼Œæ”¯æŒä»¥ä¸‹æ“ä½œï¼š

- $push(\alpha)$: å°†ç¬¦å·ä¸² $\alpha$ å‹å…¥æ ˆ
- $pop()$: å¼¹å‡ºæ ˆé¡¶ç¬¦å·
- $top()$: è¿”å›æ ˆé¡¶ç¬¦å·

## 3. å®šç†ä¸è¯æ˜

### 3.1 LLè§£ææ­£ç¡®æ€§

**å®šç† 3.1.1** (LLè§£ææ­£ç¡®æ€§)
å¦‚æœæ–‡æ³• $G$ æ˜¯LL(k)æ–‡æ³•ï¼Œåˆ™LL(k)è§£æå™¨èƒ½æ­£ç¡®è¯†åˆ« $L(G)$ ä¸­çš„æ‰€æœ‰å¥å­ã€‚

**è¯æ˜**ï¼š
ä½¿ç”¨å½’çº³æ³•è¯æ˜è§£æè¿‡ç¨‹çš„æ­£ç¡®æ€§ã€‚

### 3.2 å†²çªæ£€æµ‹

**å®šç† 3.2.1** (LLå†²çª)
æ–‡æ³• $G$ ä¸æ˜¯LL(k)æ–‡æ³•ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨éç»ˆç»“ç¬¦ $A$ å’Œä¸¤ä¸ªäº§ç”Ÿå¼ $A \to \alpha$ å’Œ $A \to \beta$ï¼Œä½¿å¾—ï¼š
$$FIRST_k(\alpha FOLLOW_k(A)) \cap FIRST_k(\beta FOLLOW_k(A)) \neq \emptyset$$

## 4. ç®—æ³•å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::fmt;

/// ç¬¦å·ç±»å‹
# [derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Symbol {
    Terminal(String),
    NonTerminal(String),
    Epsilon,
    EndOfInput,
}

/// äº§ç”Ÿå¼
# [derive(Debug, Clone)]
pub struct Production {
    pub left: String,
    pub right: Vec<Symbol>,
}

/// LLæ–‡æ³•
# [derive(Debug)]
pub struct LLGrammar {
    pub productions: Vec<Production>,
    pub start_symbol: String,
    pub terminals: HashSet<String>,
    pub non_terminals: HashSet<String>,
}

/// LLè§£æå™¨
# [derive(Debug)]
pub struct LLParser {
    grammar: LLGrammar,
    first_sets: HashMap<Symbol, HashSet<Vec<Symbol>>>,
    follow_sets: HashMap<String, HashSet<Vec<Symbol>>>,
    parse_table: HashMap<(String, Vec<Symbol>), Production>,
}

impl LLGrammar {
    /// åˆ›å»ºæ–°æ–‡æ³•
    pub fn new(start_symbol: String) -> Self {
        Self {
            productions: Vec::new(),
            start_symbol,
            terminals: HashSet::new(),
            non_terminals: HashSet::new(),
        }
    }

    /// æ·»åŠ äº§ç”Ÿå¼
    pub fn add_production(&mut self, left: String, right: Vec<Symbol>) {
        self.non_terminals.insert(left.clone());

        for symbol in &right {
            match symbol {
                Symbol::Terminal(t) => { self.terminals.insert(t.clone()); }
                Symbol::NonTerminal(nt) => { self.non_terminals.insert(nt.clone()); }
                _ => {}
            }
        }

        self.productions.push(Production { left, right });
    }

    /// è·å–äº§ç”Ÿå¼
    pub fn get_productions(&self, non_terminal: &str) -> Vec<&Production> {
        self.productions.iter()
            .filter(|p| p.left == non_terminal)
            .collect()
    }
}

impl LLParser {
    /// åˆ›å»ºLLè§£æå™¨
    pub fn new(grammar: LLGrammar) -> Self {
        let mut parser = Self {
            grammar,
            first_sets: HashMap::new(),
            follow_sets: HashMap::new(),
            parse_table: HashMap::new(),
        };

        parser.compute_first_sets();
        parser.compute_follow_sets();
        parser.build_parse_table();

        parser
    }

    /// è®¡ç®—FIRSTé›†åˆ
    fn compute_first_sets(&mut self) {
        // åˆå§‹åŒ–
        for terminal in &self.grammar.terminals {
            let symbol = Symbol::Terminal(terminal.clone());
            let mut first = HashSet::new();
            first.insert(vec![symbol.clone()]);
            self.first_sets.insert(symbol, first);
        }

        // è¿­ä»£è®¡ç®—
        let mut changed = true;
        while changed {
            changed = false;

            for production in &self.grammar.productions {
                let first = self.compute_first_of_sequence(&production.right);
                let left_symbol = Symbol::NonTerminal(production.left.clone());

                if let Some(existing) = self.first_sets.get_mut(&left_symbol) {
                    let old_size = existing.len();
                    existing.extend(first);
                    if existing.len() > old_size {
                        changed = true;
                    }
                } else {
                    self.first_sets.insert(left_symbol, first);
                    changed = true;
                }
            }
        }
    }

    /// è®¡ç®—ç¬¦å·ä¸²çš„FIRSTé›†åˆ
    fn compute_first_of_sequence(&self, sequence: &[Symbol]) -> HashSet<Vec<Symbol>> {
        let mut result = HashSet::new();
        let mut current = vec![];

        for symbol in sequence {
            match symbol {
                Symbol::Epsilon => {
                    result.insert(current);
                    break;
                }
                _ => {
                    if let Some(first) = self.first_sets.get(symbol) {
                        for prefix in first {
                            let mut new_prefix = current.clone();
                            new_prefix.extend(prefix.clone());
                            if new_prefix.len() <= 1 { // LL(1)æƒ…å†µ
                                result.insert(new_prefix);
                            }
                        }

                        // æ£€æŸ¥æ˜¯å¦åŒ…å«Îµ
                        if first.iter().any(|p| p.is_empty()) {
                            current.push(symbol.clone());
                        } else {
                            break;
                        }
                    } else {
                        current.push(symbol.clone());
                        break;
                    }
                }
            }
        }

        result
    }

    /// è®¡ç®—FOLLOWé›†åˆ
    fn compute_follow_sets(&mut self) {
        // åˆå§‹åŒ–
        for non_terminal in &self.grammar.non_terminals {
            self.follow_sets.insert(non_terminal.clone(), HashSet::new());
        }

        // å¼€å§‹ç¬¦å·çš„FOLLOWåŒ…å«ç»“æŸç¬¦
        let start_follow = self.follow_sets.get_mut(&self.grammar.start_symbol).unwrap();
        start_follow.insert(vec![Symbol::EndOfInput]);

        // è¿­ä»£è®¡ç®—
        let mut changed = true;
        while changed {
            changed = false;

            for production in &self.grammar.productions {
                let right = &production.right;

                for i in 0..right.len() {
                    if let Symbol::NonTerminal(nt) = &right[i] {
                        let beta = &right[i+1..];
                        let first_beta = self.compute_first_of_sequence(beta);

                        let follow_nt = self.follow_sets.get_mut(nt).unwrap();
                        let old_size = follow_nt.len();

                        // æ·»åŠ FIRST(Î²)ä¸­çš„éÎµç¬¦å·
                        for prefix in &first_beta {
                            if !prefix.is_empty() {
                                follow_nt.insert(prefix.clone());
                            }
                        }

                        // å¦‚æœÎ²èƒ½æ¨å¯¼å‡ºÎµï¼Œæ·»åŠ FOLLOW(A)
                        if first_beta.iter().any(|p| p.is_empty()) {
                            if let Some(follow_a) = self.follow_sets.get(&production.left) {
                                follow_nt.extend(follow_a.clone());
                            }
                        }

                        if follow_nt.len() > old_size {
                            changed = true;
                        }
                    }
                }
            }
        }
    }

    /// æ„å»ºè§£æè¡¨
    fn build_parse_table(&mut self) {
        for production in &self.grammar.productions {
            let first = self.compute_first_of_sequence(&production.right);

            for prefix in first {
                if prefix.is_empty() {
                    // Îµäº§ç”Ÿå¼
                    if let Some(follow) = self.follow_sets.get(&production.left) {
                        for symbol in follow {
                            self.parse_table.insert(
                                (production.left.clone(), symbol.clone()),
                                production.clone()
                            );
                        }
                    }
                } else {
                    // éÎµäº§ç”Ÿå¼
                    self.parse_table.insert(
                        (production.left.clone(), prefix),
                        production.clone()
                    );
                }
            }
        }
    }

    /// è§£æè¾“å…¥
    pub fn parse(&self, input: &[String]) -> Result<Vec<Production>, String> {
        let mut stack = vec![Symbol::NonTerminal(self.grammar.start_symbol.clone())];
        let mut input_pos = 0;
        let mut derivations = Vec::new();

        while !stack.is_empty() {
            let top = stack.pop().unwrap();

            match top {
                Symbol::Terminal(term) => {
                    if input_pos < input.len() && input[input_pos] == term {
                        input_pos += 1;
                    } else {
                        return Err(format!("Expected '{}', found '{}'", term,
                            if input_pos < input.len() { &input[input_pos] } else { "EOF" }));
                    }
                }
                Symbol::NonTerminal(nt) => {
                    let lookahead = if input_pos < input.len() {
                        vec![Symbol::Terminal(input[input_pos].clone())]
                    } else {
                        vec![Symbol::EndOfInput]
                    };

                    if let Some(production) = self.parse_table.get(&(nt.clone(), lookahead)) {
                        derivations.push(production.clone());

                        // å°†äº§ç”Ÿå¼å³éƒ¨é€†åºå‹å…¥æ ˆ
                        for symbol in production.right.iter().rev() {
                            if *symbol != Symbol::Epsilon {
                                stack.push(symbol.clone());
                            }
                        }
                    } else {
                        return Err(format!("No production for '{}' with lookahead '{:?}'", nt, lookahead));
                    }
                }
                Symbol::Epsilon => {
                    // è·³è¿‡Îµ
                }
                Symbol::EndOfInput => {
                    if input_pos >= input.len() {
                        break;
                    } else {
                        return Err("Unexpected input after end of input".to_string());
                    }
                }
            }
        }

        if input_pos < input.len() {
            return Err("Input not fully consumed".to_string());
        }

        Ok(derivations)
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºLL(1)æ–‡æ³•
    pub fn is_ll1(&self) -> bool {
        for non_terminal in &self.grammar.non_terminals {
            let productions = self.grammar.get_productions(non_terminal);

            for i in 0..productions.len() {
                for j in (i+1)..productions.len() {
                    let first_i = self.compute_first_of_sequence(&productions[i].right);
                    let first_j = self.compute_first_of_sequence(&productions[j].right);

                    // æ£€æŸ¥FIRSTé›†åˆçš„äº¤é›†
                    for prefix_i in &first_i {
                        for prefix_j in &first_j {
                            if prefix_i == prefix_j {
                                return false;
                            }
                        }
                    }

                    // æ£€æŸ¥Îµäº§ç”Ÿå¼çš„FOLLOWå†²çª
                    if first_i.iter().any(|p| p.is_empty()) {
                        if let Some(follow) = self.follow_sets.get(non_terminal) {
                            for symbol in follow {
                                if first_j.iter().any(|p| p == symbol) {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }

        true
    }
}

/// ç¤ºä¾‹æ–‡æ³•
pub struct ExampleGrammars;

impl ExampleGrammars {
    /// ç®—æœ¯è¡¨è¾¾å¼æ–‡æ³•
    pub fn arithmetic_grammar() -> LLGrammar {
        let mut grammar = LLGrammar::new("E".to_string());

        // E -> TE'
        grammar.add_production("E".to_string(), vec![
            Symbol::NonTerminal("T".to_string()),
            Symbol::NonTerminal("E'".to_string())
        ]);

        // E' -> +TE' | Îµ
        grammar.add_production("E'".to_string(), vec![
            Symbol::Terminal("+".to_string()),
            Symbol::NonTerminal("T".to_string()),
            Symbol::NonTerminal("E'".to_string())
        ]);
        grammar.add_production("E'".to_string(), vec![Symbol::Epsilon]);

        // T -> FT'
        grammar.add_production("T".to_string(), vec![
            Symbol::NonTerminal("F".to_string()),
            Symbol::NonTerminal("T'".to_string())
        ]);

        // T' -> *FT' | Îµ
        grammar.add_production("T'".to_string(), vec![
            Symbol::Terminal("*".to_string()),
            Symbol::NonTerminal("F".to_string()),
            Symbol::NonTerminal("T'".to_string())
        ]);
        grammar.add_production("T'".to_string(), vec![Symbol::Epsilon]);

        // F -> (E) | id
        grammar.add_production("F".to_string(), vec![
            Symbol::Terminal("(".to_string()),
            Symbol::NonTerminal("E".to_string()),
            Symbol::Terminal(")".to_string())
        ]);
        grammar.add_production("F".to_string(), vec![Symbol::Terminal("id".to_string())]);

        grammar
    }
}

# [cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_arithmetic_grammar() {
        let grammar = ExampleGrammars::arithmetic_grammar();
        let parser = LLParser::new(grammar);

        assert!(parser.is_ll1());
    }

    #[test]
    fn test_parse_simple_expression() {
        let grammar = ExampleGrammars::arithmetic_grammar();
        let parser = LLParser::new(grammar);

        let input = vec!["id".to_string(), "+".to_string(), "id".to_string()];
        let result = parser.parse(&input);

        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_complex_expression() {
        let grammar = ExampleGrammars::arithmetic_grammar();
        let parser = LLParser::new(grammar);

        let input = vec![
            "id".to_string(), "*".to_string(), "(".to_string(),
            "id".to_string(), "+".to_string(), "id".to_string(),
            ")".to_string()
        ];
        let result = parser.parse(&input);

        assert!(result.is_ok());
    }

    #[test]
    fn test_parse_error() {
        let grammar = ExampleGrammars::arithmetic_grammar();
        let parser = LLParser::new(grammar);

        let input = vec!["id".to_string(), "id".to_string()]; // ç¼ºå°‘è¿ç®—ç¬¦
        let result = parser.parse(&input);

        assert!(result.is_err());
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç¼–è¯‘å™¨å‰ç«¯

- è¯­æ³•åˆ†æå™¨
- æŠ½è±¡è¯­æ³•æ ‘æ„å»º
- é”™è¯¯æ¢å¤

### 5.2 è‡ªç„¶è¯­è¨€å¤„ç†

- å¥æ³•åˆ†æ
- ä¾å­˜å…³ç³»è§£æ
- è¯­ä¹‰è§’è‰²æ ‡æ³¨

### 5.3 é…ç½®è§£æ

- JSONè§£æå™¨
- XMLè§£æå™¨
- é…ç½®æ–‡ä»¶è§£æ

## 6. ç›¸å…³ç†è®º

### 6.1 æ–‡æ³•ç†è®º

- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03.2_Formal_Grammars/03.2.2_Context_Free_Grammar.md)

### 6.2 è‡ªåŠ¨æœºç†è®º

- [03.1.1 æœ‰é™è‡ªåŠ¨æœº](../01_Automata_Theory/03.1.1_Finite_Automata.md)

### 6.3 è¯­ä¹‰ç†è®º

- [03.5.1 æ“ä½œè¯­ä¹‰](../03.5.1_Operational_Semantics.md)

## 7. å‚è€ƒæ–‡çŒ®

1. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). *Compilers: Principles, Techniques, and Tools*. Pearson.

2. Grune, D., & Jacobs, C. J. (2008). *Parsing Techniques: A Practical Guide*. Springer.

3. Sippu, S., & Soisalon-Soininen, E. (1990). *Parsing Theory: Volume I: Languages and Parsing*. Springer.

4. Dick, P. (1991). *A Practical Guide to Compiler Construction*. Springer.

5. Appel, A. W. (1998). *Modern Compiler Implementation in ML*. Cambridge University Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [ä¸Šä¸€çº§ï¼š03.4 è§£æç†è®º](README.md)
- [ä¸‹ä¸€çº§ï¼š03.4.2 LRè§£æ](03.4.2_LR_Parsing.md)
- [ä¸»ç´¢å¼•ï¼šå½¢å¼ç§‘å­¦ç†è®ºä½“ç³»](README.md)

## æ‰¹åˆ¤æ€§åˆ†æ

### å¤šå…ƒè§†è§’

- ä¸LR/è‡ªåº•å‘ä¸Šï¼šLLæ›´ç›´è§‚ã€æ˜“å®ç°ï¼Œä½†è¦†ç›–é¢çª„ï¼›LRè¦†ç›–æ›´å¹¿ä¸”æŠ—å·¦é€’å½’ã€‚æ•™å­¦ä¸åŸå‹åœºæ™¯ä¼˜å…ˆLLï¼Œç”Ÿäº§è¯­æ³•ä¼˜å…ˆLR/LALR/GLRã€‚
- ä¸é€’å½’ä¸‹é™ï¼šLLè¡¨é©±åŠ¨ä¸æ‰‹å†™é€’å½’ä¸‹é™äº’è¡¥ï¼›å‰è€…è§„æ•´ã€åè€…çµæ´»æ’å…¥è¯­ä¹‰åŠ¨ä½œä¸é”™è¯¯æ¢å¤ã€‚
- ä¸è¯­ä¹‰ç†è®ºï¼šLLæ›´é€‚åˆä¸æ“ä½œè¯­ä¹‰è”åŠ¨ï¼›ä¸æŒ‡ç§°/å…¬ç†è¯­ä¹‰éœ€é¢å¤–ä¸€è‡´æ€§ä¸å……åˆ†æ€§è®ºè¯ã€‚

### å±€é™ä¸äº‰è®®

- å·¦é€’å½’ä¸äºŒä¹‰æ€§ï¼šéœ€è½¬æ¢æ–‡æ³•ï¼›è½¬æ¢åå¯è¯»æ€§ä¸ç»´æŠ¤æ€§ä¸‹é™ã€‚
- FIRST/FOLLOW è¿‘ä¼¼ï¼šå¤æ‚è¯­è¨€ç‰¹æ€§å¼•å…¥çš„ä¸Šä¸‹æ–‡ä¾èµ–è¶…å‡ºLLæ¡†æ¶èƒ½åŠ›ã€‚
- é”™è¯¯æ¢å¤ï¼šè¡¨é©±åŠ¨LLçš„é«˜è´¨é‡é”™è¯¯æ¢å¤å¤æ‚ï¼Œå¸¸éœ€æ‰‹å†™ç­–ç•¥ã€‚

### åº”ç”¨å‰æ™¯

- DSL/é…ç½®è¯­è¨€ï¼šç»“æ„ç®€å•ã€éœ€æ±‚ç¨³å®šï¼Œé€‚é…LLè§£ææµæ°´çº¿ã€‚
- æ•™å­¦ä¸éªŒè¯ï¼šç”¨äºå±•ç¤ºè§£æåŸç†ã€æ„é€ æ€§è¯æ˜ä¸ç­‰ä»·æ€§éªŒè¯ã€‚
- å·¥å…·é“¾ï¼šä¸è¯­æ³•é«˜äº®ã€è¡¥å…¨ã€ç®€å•lintç»“åˆã€‚

### å®è·µå»ºè®®

- æ–‡æ³•è®¾è®¡ï¼šå…ˆæ¶ˆå·¦é€’å½’ã€æå–å…¬å…±å‰ç¼€ï¼Œæ§åˆ¶å†²çªæºã€‚
- ç»„åˆç­–ç•¥ï¼šä¸ºå¤æ‚å­è¯­è¨€åˆ‡æ¢åˆ° LR/GLRï¼Œæˆ–å±€éƒ¨ä½¿ç”¨è§£æå™¨ç»„åˆå­ã€‚
- è´¨é‡ä¿éšœï¼šå»ºç«‹è‡ªåŠ¨åŒ– FIRST/FOLLOW æ£€æŸ¥ä¸å†²çªæŠ¥å‘Šã€å›å½’æµ‹è¯•é›†ã€‚
