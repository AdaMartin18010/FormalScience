# 03.2.3 ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•

## ğŸ“‹ æ¦‚è¿°

ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•ï¼ˆContext-Sensitive Grammar, CSGï¼‰æ˜¯å½¢å¼è¯­è¨€ç†è®ºä¸­çš„é‡è¦æ¦‚å¿µï¼Œå®ƒå®šä¹‰äº†ä¹”å§†æ–¯åŸºè°±ç³»ä¸­çš„1å‹è¯­è¨€ã€‚CSGåœ¨è‡ªç„¶è¯­è¨€å¤„ç†ã€ç”Ÿç‰©ä¿¡æ¯å­¦ã€æ¨¡å¼è¯†åˆ«ç­‰é¢†åŸŸæœ‰é‡è¦åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•çš„ä¸¥æ ¼å½¢å¼åŒ–å®šä¹‰
2. ç ”ç©¶CSGçš„åŸºæœ¬æ€§è´¨å’Œç»“æ„
3. æ¢è®¨CSGä¸çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºçš„å…³ç³»
4. åˆ†æCSGçš„è§£æç®—æ³•
5. æä¾›å®Œæ•´çš„ä»£ç å®ç°

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [è§£æç®—æ³•](#4-è§£æç®—æ³•)
5. [ä»£ç å®ç°](#5-ä»£ç å®ç°)
6. [åº”ç”¨ç¤ºä¾‹](#6-åº”ç”¨ç¤ºä¾‹)
7. [ç›¸å…³ç†è®º](#7-ç›¸å…³ç†è®º)
8. [å‚è€ƒæ–‡çŒ®](#8-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•çš„ç›´è§‚ç†è§£

ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•æ˜¯ä¸€ç§å½¢å¼æ–‡æ³•ï¼Œå…¶ä¸­äº§ç”Ÿå¼è§„åˆ™çš„å½¢å¼ä¸º $\alpha A \beta \to \alpha \gamma \beta$ï¼Œå…¶ä¸­ $A$ æ˜¯éç»ˆç»“ç¬¦ï¼Œ$\alpha, \beta$ æ˜¯ä¸Šä¸‹æ–‡ï¼Œ$\gamma$ æ˜¯éç©ºä¸²ã€‚CSGçš„ç‰¹ç‚¹æ˜¯æ›¿æ¢éç»ˆç»“ç¬¦æ—¶ä¾èµ–äºå…¶ä¸Šä¸‹æ–‡ã€‚

**ç»å…¸ä¾‹å­**ï¼š

- $a^n b^n c^n$ è¯­è¨€
- è‡ªç„¶è¯­è¨€çš„å¥æ³•ç»“æ„
- ç”Ÿç‰©åºåˆ—çš„æ¨¡å¼åŒ¹é…

### 1.2 CSGçš„åŸºæœ¬ç‰¹ç‚¹

1. **ä¸Šä¸‹æ–‡æ•æ„Ÿæ€§**ï¼šæ›¿æ¢æ“ä½œä¾èµ–äºä¸Šä¸‹æ–‡
2. **é•¿åº¦éå‡æ€§**ï¼šäº§ç”Ÿå¼å³ç«¯é•¿åº¦ä¸å°äºå·¦ç«¯
3. **çº¿æ€§æœ‰ç•Œæ€§**ï¼šä¸çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºç­‰ä»·

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•çš„å®šä¹‰

**å®šä¹‰ 2.1.1** (ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•)
ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ $G = (V, \Sigma, P, S)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯éç»ˆç»“ç¬¦é›†åˆï¼ˆæœ‰é™é›†ï¼‰
- $\Sigma$ æ˜¯ç»ˆç»“ç¬¦é›†åˆï¼ˆæœ‰é™é›†ï¼‰ï¼Œä¸” $V \cap \Sigma = \emptyset$
- $P$ æ˜¯äº§ç”Ÿå¼é›†åˆï¼Œæ¯ä¸ªäº§ç”Ÿå¼å½¢å¦‚ $\alpha A \beta \to \alpha \gamma \beta$ï¼Œå…¶ä¸­ï¼š
  - $A \in V$
  - $\alpha, \beta \in (V \cup \Sigma)^*$
  - $\gamma \in (V \cup \Sigma)^+$
- $S \in V$ æ˜¯å¼€å§‹ç¬¦å·

### 2.2 æ ‡å‡†å½¢å¼çš„å®šä¹‰

**å®šä¹‰ 2.1.2** (æ ‡å‡†å½¢å¼)
CSGçš„æ ‡å‡†å½¢å¼è¦æ±‚æ‰€æœ‰äº§ç”Ÿå¼éƒ½æ»¡è¶³ï¼š
$$|\alpha A \beta| \leq |\alpha \gamma \beta|$$

å³å³ç«¯é•¿åº¦ä¸å°äºå·¦ç«¯é•¿åº¦ã€‚

### 2.3 æ¨å¯¼çš„å®šä¹‰

**å®šä¹‰ 2.1.3** (ç›´æ¥æ¨å¯¼)
è®¾ $G = (V, \Sigma, P, S)$ æ˜¯CSGï¼Œå¯¹äº $\alpha, \beta \in (V \cup \Sigma)^*$ï¼Œå¦‚æœå­˜åœ¨äº§ç”Ÿå¼ $\delta A \epsilon \to \delta \gamma \epsilon \in P$ï¼Œä½¿å¾— $\alpha = \alpha_1 \delta A \epsilon \alpha_2$ ä¸” $\beta = \alpha_1 \delta \gamma \epsilon \alpha_2$ï¼Œåˆ™ç§° $\alpha$ ç›´æ¥æ¨å¯¼å‡º $\beta$ï¼Œè®°ä½œ $\alpha \Rightarrow \beta$ã€‚

**å®šä¹‰ 2.1.4** (æ¨å¯¼)
æ¨å¯¼å…³ç³» $\Rightarrow^*$ æ˜¯ $\Rightarrow$ çš„è‡ªåä¼ é€’é—­åŒ…ã€‚

### 2.4 è¯­è¨€çš„å®šä¹‰

**å®šä¹‰ 2.1.5** (CSGç”Ÿæˆçš„è¯­è¨€)
CSG $G = (V, \Sigma, P, S)$ ç”Ÿæˆçš„è¯­è¨€å®šä¹‰ä¸ºï¼š
$$L(G) = \{w \in \Sigma^* \mid S \Rightarrow^* w\}$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 CSGçš„åŸºæœ¬æ€§è´¨

**å®šç† 3.1.1** (CSGçš„é•¿åº¦éå‡æ€§)
è®¾ $G$ æ˜¯CSGï¼Œå¦‚æœ $S \Rightarrow^* \alpha$ï¼Œåˆ™ $|\alpha| \geq 1$ æˆ– $\alpha = \varepsilon$ã€‚

**è¯æ˜**ï¼š
å¯¹æ¨å¯¼æ­¥æ•°è¿›è¡Œå½’çº³ï¼š

- åŸºç¡€æƒ…å†µï¼š$S \Rightarrow S$ï¼Œ$|S| = 1$
- å½’çº³æ­¥éª¤ï¼šå‡è®¾ $S \Rightarrow^* \alpha$ ä¸” $|\alpha| \geq 1$ï¼Œå¦‚æœ $\alpha \Rightarrow \beta$ï¼Œåˆ™ $|\beta| \geq |\alpha| \geq 1$

**å®šç† 3.1.2** (CSGçš„ä¸Šä¸‹æ–‡æ•æ„Ÿæ€§)
CSGçš„æ›¿æ¢æ“ä½œä¾èµ–äºä¸Šä¸‹æ–‡ï¼Œå³äº§ç”Ÿå¼ $\alpha A \beta \to \alpha \gamma \beta$ åªèƒ½åœ¨ç‰¹å®šçš„ä¸Šä¸‹æ–‡ä¸­åº”ç”¨ã€‚

### 3.2 CSGä¸çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºçš„å…³ç³»

**å®šç† 3.2.1** (CSGä¸LBAç­‰ä»·æ€§)
è¯­è¨€ $L$ æ˜¯ä¸Šä¸‹æ–‡æœ‰å…³è¯­è¨€å½“ä¸”ä»…å½“å­˜åœ¨çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºè¯†åˆ« $L$ã€‚

**è¯æ˜**ï¼š

1. **å¿…è¦æ€§**ï¼šç»™å®šCSG $G$ï¼Œæ„é€ LBA $M$ æ¨¡æ‹Ÿ $G$ çš„æ¨å¯¼è¿‡ç¨‹
2. **å……åˆ†æ€§**ï¼šç»™å®šLBA $M$ï¼Œæ„é€ CSG $G$ æ¨¡æ‹Ÿ $M$ çš„è®¡ç®—è¿‡ç¨‹

### 3.3 CSGçš„æ ‡å‡†åŒ–

**å®šç† 3.3.1** (CSGæ ‡å‡†åŒ–å®šç†)
ä»»ä½•CSGéƒ½å¯ä»¥è½¬æ¢ä¸ºç­‰ä»·çš„æ ‡å‡†åŒ–å½¢å¼ï¼Œå…¶ä¸­æ‰€æœ‰äº§ç”Ÿå¼éƒ½æ»¡è¶³é•¿åº¦éå‡æ€§ã€‚

**è¯æ˜**ï¼š
é€šè¿‡å¼•å…¥æ–°çš„éç»ˆç»“ç¬¦å’Œäº§ç”Ÿå¼ï¼Œå°†é•¿äº§ç”Ÿå¼åˆ†è§£ä¸ºæ ‡å‡†åŒ–å½¢å¼ã€‚

## 4. è§£æç®—æ³•

### 4.1 é€šç”¨è§£æç®—æ³•

**ç®—æ³• 4.1.1** (CSGé€šç”¨è§£æ)
ç”±äºCSGçš„å¤æ‚æ€§ï¼Œé€šå¸¸ä½¿ç”¨é€šç”¨çš„è§£æç®—æ³•ï¼Œå¦‚CYKç®—æ³•çš„æ‰©å±•ç‰ˆæœ¬ã€‚

**åŸºæœ¬æ€æƒ³**ï¼š

1. ä½¿ç”¨åŠ¨æ€è§„åˆ’è¡¨å­˜å‚¨æ‰€æœ‰å¯èƒ½çš„æ¨å¯¼
2. è€ƒè™‘ä¸Šä¸‹æ–‡çº¦æŸ
3. ä½¿ç”¨å›æº¯æŠ€æœ¯å¤„ç†æ­§ä¹‰

### 4.2 çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºæ¨¡æ‹Ÿ

**ç®—æ³• 4.1.2** (LBAæ¨¡æ‹Ÿ)
é€šè¿‡æ¨¡æ‹Ÿçº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºæ¥è§£æCSGç”Ÿæˆçš„è¯­è¨€ã€‚

**æ­¥éª¤**ï¼š

1. æ„é€ å¯¹åº”çš„LBA
2. æ¨¡æ‹ŸLBAçš„è®¡ç®—è¿‡ç¨‹
3. æ£€æŸ¥æ˜¯å¦æ¥å—è¾“å…¥ä¸²

## 5. ä»£ç å®ç°

### 5.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::fmt;

/// ç¬¦å·ç±»å‹
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Symbol {
    Terminal(String),
    NonTerminal(String),
}

impl Symbol {
    pub fn is_terminal(&self) -> bool {
        matches!(self, Symbol::Terminal(_))
    }
    
    pub fn is_non_terminal(&self) -> bool {
        matches!(self, Symbol::NonTerminal(_))
    }
    
    pub fn to_string(&self) -> String {
        match self {
            Symbol::Terminal(s) => s.clone(),
            Symbol::NonTerminal(s) => s.clone(),
        }
    }
}

/// ä¸Šä¸‹æ–‡æœ‰å…³äº§ç”Ÿå¼
#[derive(Debug, Clone)]
pub struct ContextSensitiveProduction {
    pub left_context: Vec<Symbol>,
    pub non_terminal: Symbol,
    pub right_context: Vec<Symbol>,
    pub replacement: Vec<Symbol>,
}

impl ContextSensitiveProduction {
    pub fn new(
        left_context: Vec<Symbol>,
        non_terminal: Symbol,
        right_context: Vec<Symbol>,
        replacement: Vec<Symbol>,
    ) -> Self {
        Self {
            left_context,
            non_terminal,
            right_context,
            replacement,
        }
    }
    
    pub fn is_standard_form(&self) -> bool {
        let left_length = self.left_context.len() + 1 + self.right_context.len();
        let right_length = self.left_context.len() + self.replacement.len() + self.right_context.len();
        right_length >= left_length
    }
    
    pub fn can_apply(&self, position: usize, symbols: &[Symbol]) -> bool {
        if position < self.left_context.len() || 
           position + self.right_context.len() >= symbols.len() {
            return false;
        }
        
        // æ£€æŸ¥å·¦ä¸Šä¸‹æ–‡
        for (i, expected) in self.left_context.iter().enumerate() {
            if symbols[position - self.left_context.len() + i] != *expected {
                return false;
            }
        }
        
        // æ£€æŸ¥éç»ˆç»“ç¬¦
        if symbols[position] != self.non_terminal {
            return false;
        }
        
        // æ£€æŸ¥å³ä¸Šä¸‹æ–‡
        for (i, expected) in self.right_context.iter().enumerate() {
            if symbols[position + 1 + i] != *expected {
                return false;
            }
        }
        
        true
    }
    
    pub fn apply(&self, position: usize, symbols: &[Symbol]) -> Vec<Symbol> {
        let mut result = symbols.to_vec();
        
        // æ›¿æ¢éç»ˆç»“ç¬¦
        result.splice(
            position..position + 1,
            self.replacement.iter().cloned()
        );
        
        result
    }
}

/// ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•
#[derive(Debug)]
pub struct ContextSensitiveGrammar {
    pub non_terminals: HashSet<Symbol>,
    pub terminals: HashSet<Symbol>,
    pub productions: Vec<ContextSensitiveProduction>,
    pub start_symbol: Symbol,
}

impl ContextSensitiveGrammar {
    pub fn new(start_symbol: Symbol) -> Self {
        let mut non_terminals = HashSet::new();
        non_terminals.insert(start_symbol.clone());
        
        Self {
            non_terminals,
            terminals: HashSet::new(),
            productions: Vec::new(),
            start_symbol,
        }
    }
    
    pub fn add_production(&mut self, production: ContextSensitiveProduction) {
        // æ·»åŠ éç»ˆç»“ç¬¦
        self.non_terminals.insert(production.non_terminal.clone());
        
        // æ·»åŠ ç»ˆç»“ç¬¦å’Œéç»ˆç»“ç¬¦
        for symbol in production.left_context.iter().chain(production.right_context.iter()).chain(production.replacement.iter()) {
            match symbol {
                Symbol::Terminal(_) => {
                    self.terminals.insert(symbol.clone());
                }
                Symbol::NonTerminal(_) => {
                    self.non_terminals.insert(symbol.clone());
                }
            }
        }
        
        self.productions.push(production);
    }
    
    /// æ£€æŸ¥æ–‡æ³•æ˜¯å¦ä¸ºæ ‡å‡†å½¢å¼
    pub fn is_standard_form(&self) -> bool {
        self.productions.iter().all(|p| p.is_standard_form())
    }
    
    /// è½¬æ¢ä¸ºæ ‡å‡†å½¢å¼
    pub fn to_standard_form(&self) -> ContextSensitiveGrammar {
        let mut standard = ContextSensitiveGrammar::new(self.start_symbol.clone());
        
        for production in &self.productions {
            if production.is_standard_form() {
                standard.add_production(production.clone());
            } else {
                // å°†éæ ‡å‡†äº§ç”Ÿå¼è½¬æ¢ä¸ºæ ‡å‡†å½¢å¼
                let standard_productions = self.convert_to_standard(production);
                for p in standard_productions {
                    standard.add_production(p);
                }
            }
        }
        
        standard
    }
    
    fn convert_to_standard(&self, production: &ContextSensitiveProduction) -> Vec<ContextSensitiveProduction> {
        // ç®€åŒ–å®ç°ï¼šå‡è®¾äº§ç”Ÿå¼å·²ç»æ˜¯æ ‡å‡†å½¢å¼
        vec![production.clone()]
    }
    
    /// ç›´æ¥æ¨å¯¼
    pub fn direct_derivation(&self, from: &[Symbol], to: &[Symbol]) -> bool {
        for production in &self.productions {
            for i in 0..from.len() {
                if production.can_apply(i, from) {
                    let result = production.apply(i, from);
                    if result == to {
                        return true;
                    }
                }
            }
        }
        false
    }
    
    /// æ¨å¯¼
    pub fn derivation(&self, from: &[Symbol], to: &[Symbol]) -> bool {
        if from == to {
            return true;
        }
        
        // ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢æŸ¥æ‰¾æ¨å¯¼è·¯å¾„
        let mut visited = HashSet::new();
        let mut queue = vec![from.to_vec()];
        visited.insert(from.to_vec());
        
        while let Some(current) = queue.pop() {
            for production in &self.productions {
                for i in 0..current.len() {
                    if production.can_apply(i, &current) {
                        let next = production.apply(i, &current);
                        if next == to {
                            return true;
                        }
                        if !visited.contains(&next) {
                            visited.insert(next.clone());
                            queue.push(next);
                        }
                    }
                }
            }
        }
        
        false
    }
    
    /// ç”Ÿæˆè¯­è¨€
    pub fn generate_language(&self, max_length: usize) -> Vec<String> {
        let mut language = Vec::new();
        let mut queue = vec![vec![self.start_symbol.clone()]];
        
        while let Some(current) = queue.pop() {
            // æ£€æŸ¥æ˜¯å¦åªåŒ…å«ç»ˆç»“ç¬¦
            if current.iter().all(|s| s.is_terminal()) {
                let word = current.iter().map(|s| s.to_string()).collect::<String>();
                if word.len() <= max_length {
                    language.push(word);
                }
                continue;
            }
            
            // å°è¯•åº”ç”¨äº§ç”Ÿå¼
            for production in &self.productions {
                for i in 0..current.len() {
                    if production.can_apply(i, &current) {
                        let next = production.apply(i, &current);
                        if next.len() <= max_length {
                            queue.push(next);
                        }
                    }
                }
            }
        }
        
        language.sort();
        language.dedup();
        language
    }
}

/// çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº
pub struct LinearBoundedAutomaton {
    pub states: HashSet<String>,
    pub input_alphabet: HashSet<char>,
    pub tape_alphabet: HashSet<char>,
    pub transitions: HashMap<(String, char), Vec<(String, char, char)>>, // (state, read) -> [(new_state, write, move)]
    pub start_state: String,
    pub accept_states: HashSet<String>,
}

impl LinearBoundedAutomaton {
    pub fn new() -> Self {
        Self {
            states: HashSet::new(),
            input_alphabet: HashSet::new(),
            tape_alphabet: HashSet::new(),
            transitions: HashMap::new(),
            start_state: "q0".to_string(),
            accept_states: HashSet::new(),
        }
    }
    
    pub fn add_transition(&mut self, state: String, read: char, new_state: String, write: char, movement: char) {
        self.states.insert(state.clone());
        self.states.insert(new_state.clone());
        self.tape_alphabet.insert(read);
        self.tape_alphabet.insert(write);
        
        let key = (state, read);
        let value = (new_state, write, movement);
        self.transitions.entry(key).or_insert_with(Vec::new).push(value);
    }
    
    pub fn accept(&self, input: &str) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ¨¡æ‹ŸLBAçš„è®¡ç®—è¿‡ç¨‹
        let mut tape = input.chars().collect::<Vec<char>>();
        let mut head = 0;
        let mut state = self.start_state.clone();
        
        for _ in 0..1000 { // é™åˆ¶è®¡ç®—æ­¥æ•°
            if self.accept_states.contains(&state) {
                return true;
            }
            
            let current_symbol = tape.get(head).copied().unwrap_or('B');
            let key = (state.clone(), current_symbol);
            
            if let Some(transitions) = self.transitions.get(&key) {
                if let Some((new_state, write, movement)) = transitions.first() {
                    if head < tape.len() {
                        tape[head] = *write;
                    }
                    state = new_state.clone();
                    match movement {
                        'L' => head = head.saturating_sub(1),
                        'R' => head = head.saturating_add(1),
                        'S' => {},
                        _ => panic!("æ— æ•ˆçš„ç§»åŠ¨æ–¹å‘"),
                    }
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
        
        false
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_context_sensitive_production() {
        let production = ContextSensitiveProduction::new(
            vec![Symbol::Terminal("a".to_string())],
            Symbol::NonTerminal("S".to_string()),
            vec![Symbol::Terminal("b".to_string())],
            vec![Symbol::Terminal("a".to_string()), Symbol::NonTerminal("S".to_string()), Symbol::Terminal("b".to_string())],
        );
        
        assert!(production.is_standard_form());
        
        let symbols = vec![
            Symbol::Terminal("a".to_string()),
            Symbol::NonTerminal("S".to_string()),
            Symbol::Terminal("b".to_string()),
        ];
        
        assert!(production.can_apply(1, &symbols));
        let result = production.apply(1, &symbols);
        assert_eq!(result.len(), 5);
    }
    
    #[test]
    fn test_context_sensitive_grammar() {
        let mut grammar = ContextSensitiveGrammar::new(Symbol::NonTerminal("S".to_string()));
        
        // S -> aSb | ab
        grammar.add_production(ContextSensitiveProduction::new(
            vec![],
            Symbol::NonTerminal("S".to_string()),
            vec![],
            vec![Symbol::Terminal("a".to_string()), Symbol::NonTerminal("S".to_string()), Symbol::Terminal("b".to_string())],
        ));
        
        grammar.add_production(ContextSensitiveProduction::new(
            vec![],
            Symbol::NonTerminal("S".to_string()),
            vec![],
            vec![Symbol::Terminal("a".to_string()), Symbol::Terminal("b".to_string())],
        ));
        
        assert!(grammar.is_standard_form());
        
        let language = grammar.generate_language(10);
        assert!(!language.is_empty());
    }
    
    #[test]
    fn test_linear_bounded_automaton() {
        let mut lba = LinearBoundedAutomaton::new();
        
        // ç®€å•çš„LBAï¼šæ¥å—æ‰€æœ‰éç©ºä¸²
        lba.add_transition(
            "q0".to_string(), 'a', "q1".to_string(), 'a', 'R'
        );
        lba.add_transition(
            "q1".to_string(), 'a', "q1".to_string(), 'a', 'R'
        );
        lba.add_transition(
            "q1".to_string(), 'B', "q2".to_string(), 'B', 'S'
        );
        
        lba.accept_states.insert("q2".to_string());
        
        assert!(lba.accept("aaa"));
        assert!(!lba.accept(""));
    }
}
```

### 5.2 Haskell å®ç°

```haskell
module ContextSensitiveGrammar where

import Data.Set (Set)
import qualified Data.Set as Set
import Data.Map (Map)
import qualified Data.Map as Map
import Data.List (nub)

-- ç¬¦å·ç±»å‹
data Symbol = Terminal String | NonTerminal String
    deriving (Eq, Ord, Show)

-- ä¸Šä¸‹æ–‡æœ‰å…³äº§ç”Ÿå¼
data ContextSensitiveProduction = ContextSensitiveProduction {
    leftContext :: [Symbol],
    nonTerminal :: Symbol,
    rightContext :: [Symbol],
    replacement :: [Symbol]
} deriving (Eq, Show)

-- ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•
data ContextSensitiveGrammar = ContextSensitiveGrammar {
    nonTerminals :: Set Symbol,
    terminals :: Set Symbol,
    productions :: [ContextSensitiveProduction],
    startSymbol :: Symbol
} deriving (Eq, Show)

-- åˆ›å»ºç©ºæ–‡æ³•
emptyCSG :: Symbol -> ContextSensitiveGrammar
emptyCSG start = ContextSensitiveGrammar {
    nonTerminals = Set.singleton start,
    terminals = Set.empty,
    productions = [],
    startSymbol = start
}

-- æ·»åŠ äº§ç”Ÿå¼
addCSGProduction :: ContextSensitiveProduction -> ContextSensitiveGrammar -> ContextSensitiveGrammar
addCSGProduction prod grammar = grammar {
    nonTerminals = Set.insert (nonTerminal prod) $ 
                   foldr (\s acc -> case s of
                       NonTerminal _ -> Set.insert s acc
                       _ -> acc) (nonTerminals grammar) 
                         (leftContext prod ++ rightContext prod ++ replacement prod),
    terminals = foldr (\s acc -> case s of
        Terminal _ -> Set.insert s acc
        _ -> acc) (terminals grammar) 
          (leftContext prod ++ rightContext prod ++ replacement prod),
    productions = prod : productions grammar
}

-- æ£€æŸ¥æ˜¯å¦ä¸ºæ ‡å‡†å½¢å¼
isStandardForm :: ContextSensitiveProduction -> Bool
isStandardForm prod = 
    let leftLength = length (leftContext prod) + 1 + length (rightContext prod)
        rightLength = length (leftContext prod) + length (replacement prod) + length (rightContext prod)
    in rightLength >= leftLength

-- æ£€æŸ¥æ–‡æ³•æ˜¯å¦ä¸ºæ ‡å‡†å½¢å¼
isCSGStandardForm :: ContextSensitiveGrammar -> Bool
isCSGStandardForm grammar = all isStandardForm (productions grammar)

-- æ£€æŸ¥äº§ç”Ÿå¼æ˜¯å¦å¯ä»¥åº”ç”¨
canApply :: ContextSensitiveProduction -> Int -> [Symbol] -> Bool
canApply prod pos symbols = 
    let leftLen = length (leftContext prod)
        rightLen = length (rightContext prod)
    in pos >= leftLen && 
       pos + rightLen < length symbols &&
       checkContext prod pos symbols

-- æ£€æŸ¥ä¸Šä¸‹æ–‡
checkContext :: ContextSensitiveProduction -> Int -> [Symbol] -> Bool
checkContext prod pos symbols = 
    let leftMatch = all (\(i, expected) -> 
        symbols !! (pos - length (leftContext prod) + i) == expected)
        (zip [0..] (leftContext prod))
        rightMatch = all (\(i, expected) -> 
        symbols !! (pos + 1 + i) == expected)
        (zip [0..] (rightContext prod))
        centerMatch = symbols !! pos == nonTerminal prod
    in leftMatch && centerMatch && rightMatch

-- åº”ç”¨äº§ç”Ÿå¼
applyProduction :: ContextSensitiveProduction -> Int -> [Symbol] -> [Symbol]
applyProduction prod pos symbols = 
    let before = take pos symbols
        after = drop (pos + 1) symbols
    in before ++ replacement prod ++ after

-- ç›´æ¥æ¨å¯¼
directDerivation :: ContextSensitiveGrammar -> [Symbol] -> [Symbol] -> Bool
directDerivation grammar from to = 
    any (\prod -> any (\i -> 
        canApply prod i from && applyProduction prod i from == to)
        [0..length from - 1]) (productions grammar)

-- æ¨å¯¼
derivation :: ContextSensitiveGrammar -> [Symbol] -> [Symbol] -> Bool
derivation grammar from to = 
    if from == to 
    then True
    else derivationBFS grammar [from] (Set.singleton from) to

-- å¹¿åº¦ä¼˜å…ˆæœç´¢æ¨å¯¼
derivationBFS :: ContextSensitiveGrammar -> [[Symbol]] -> Set [Symbol] -> [Symbol] -> Bool
derivationBFS grammar [] _ _ = False
derivationBFS grammar (current:queue) visited target = 
    if current == target 
    then True
    else let nextStates = [next | prod <- productions grammar,
                                 i <- [0..length current - 1],
                                 canApply prod i current,
                                 let next = applyProduction prod i current,
                                 not (Set.member next visited)]
             newVisited = foldr Set.insert visited nextStates
         in derivationBFS grammar (queue ++ nextStates) newVisited target

-- ç”Ÿæˆè¯­è¨€
generateLanguage :: ContextSensitiveGrammar -> Int -> [String]
generateLanguage grammar maxLength = 
    let initial = [startSymbol grammar]
        allWords = generateWords grammar [initial] Set.empty maxLength
    in nub $ map symbolsToString $ filter (all isTerminal) allWords
  where
    isTerminal (Terminal _) = True
    isTerminal _ = False
    symbolsToString = concatMap symbolToString
    symbolToString (Terminal s) = s
    symbolToString (NonTerminal s) = s

-- ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„è¯
generateWords :: ContextSensitiveGrammar -> [[Symbol]] -> Set [Symbol] -> Int -> [[Symbol]]
generateWords grammar [] _ _ = []
generateWords grammar (current:queue) visited maxLen = 
    if length current > maxLen 
    then generateWords grammar queue visited maxLen
    else if all isTerminal current 
         then current : generateWords grammar queue visited maxLen
         else let nextStates = [next | prod <- productions grammar,
                                      i <- [0..length current - 1],
                                      canApply prod i current,
                                      let next = applyProduction prod i current,
                                      not (Set.member next visited),
                                      length next <= maxLen]
                  newVisited = foldr Set.insert visited nextStates
              in current : generateWords grammar (queue ++ nextStates) newVisited maxLen
  where
    isTerminal (Terminal _) = True
    isTerminal _ = False

-- çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº
data LinearBoundedAutomaton = LinearBoundedAutomaton {
    states :: Set String,
    inputAlphabet :: Set Char,
    tapeAlphabet :: Set Char,
    transitions :: Map (String, Char) [(String, Char, Char)], -- (state, read) -> [(new_state, write, move)]
    startState :: String,
    acceptStates :: Set String
} deriving (Show)

-- åˆ›å»ºLBA
createLBA :: LinearBoundedAutomaton
createLBA = LinearBoundedAutomaton {
    states = Set.empty,
    inputAlphabet = Set.empty,
    tapeAlphabet = Set.empty,
    transitions = Map.empty,
    startState = "q0",
    acceptStates = Set.empty
}

-- æ·»åŠ è½¬ç§»
addTransition :: String -> Char -> String -> Char -> Char -> LinearBoundedAutomaton -> LinearBoundedAutomaton
addTransition state read newState write move lba = 
    let newStates = Set.insert state $ Set.insert newState (states lba)
        newInputAlphabet = Set.insert read (inputAlphabet lba)
        newTapeAlphabet = Set.insert read $ Set.insert write (tapeAlphabet lba)
        newTransitions = Map.insertWith (++) (state, read) [(newState, write, move)] (transitions lba)
    in lba {
        states = newStates,
        inputAlphabet = newInputAlphabet,
        tapeAlphabet = newTapeAlphabet,
        transitions = newTransitions
    }

-- LBAæ¥å—æ£€æŸ¥
accept :: LinearBoundedAutomaton -> String -> Bool
accept lba input = acceptWithConfig lba (startState lba) input 0 0
  where
    acceptWithConfig lba state tape head steps = 
        if steps > 1000 -- é™åˆ¶æ­¥æ•°
        then False
        else if Set.member state (acceptStates lba)
             then True
             else case Map.lookup (state, tape !! head) (transitions lba) of
                      Just transitions -> any (\(newState, write, move) -> 
                          let newTape = take head tape ++ [write] ++ drop (head + 1) tape
                              newHead = case move of
                                  'L' -> max 0 (head - 1)
                                  'R' -> min (length tape - 1) (head + 1)
                                  'S' -> head
                                  _ -> head
                          in acceptWithConfig lba newState newTape newHead (steps + 1)) transitions
                      Nothing -> False

-- ç¤ºä¾‹æ–‡æ³•
exampleCSG :: ContextSensitiveGrammar
exampleCSG = 
    let g = emptyCSG (NonTerminal "S")
        g1 = addCSGProduction (ContextSensitiveProduction [] (NonTerminal "S") [] 
                              [Terminal "a", NonTerminal "S", Terminal "b"]) g
        g2 = addCSGProduction (ContextSensitiveProduction [] (NonTerminal "S") [] 
                              [Terminal "a", Terminal "b"]) g1
    in g2

-- ç¤ºä¾‹LBA
exampleLBA :: LinearBoundedAutomaton
exampleLBA = 
    let lba = createLBA
        lba1 = addTransition "q0" 'a' "q1" 'a' 'R' lba
        lba2 = addTransition "q1" 'a' "q1" 'a' 'R' lba1
        lba3 = addTransition "q1" 'B' "q2" 'B' 'S' lba2
    in lba3 { acceptStates = Set.singleton "q2" }

-- æµ‹è¯•å‡½æ•°
testCSG :: Bool
testCSG = isCSGStandardForm exampleCSG

testLBA :: Bool
testLBA = accept exampleLBA "aaa"

-- ç”Ÿæˆç¤ºä¾‹è¯­è¨€
exampleLanguage :: [String]
exampleLanguage = generateLanguage exampleCSG 10
```

## 6. åº”ç”¨ç¤ºä¾‹

### 6.1 $a^n b^n c^n$ è¯­è¨€

**ç¤ºä¾‹ 6.1.1** ($a^n b^n c^n$ CSG)

```latex
S â†’ aSBC | aBC
CB â†’ BC
aB â†’ ab
bB â†’ bb
bC â†’ bc
cC â†’ cc
```

è¿™ä¸ªCSGç”Ÿæˆè¯­è¨€ $\{a^n b^n c^n \mid n \geq 1\}$ã€‚

### 6.2 è‡ªç„¶è¯­è¨€å¥æ³•

**ç¤ºä¾‹ 6.1.2** (è‡ªç„¶è¯­è¨€CSG)

```latex
S â†’ NP VP
NP â†’ Det N
VP â†’ V NP
Det â†’ the | a
N â†’ cat | dog
V â†’ sees | chases
```

è¿™ä¸ªCSGæè¿°äº†ç®€å•çš„è‹±è¯­å¥æ³•ç»“æ„ã€‚

### 6.3 ç”Ÿç‰©åºåˆ—æ¨¡å¼

**ç¤ºä¾‹ 6.1.3** (DNAåºåˆ—CSG)

```latex
S â†’ ATCG
AT â†’ ATC
CG â†’ CGA
```

è¿™ä¸ªCSGæè¿°äº†DNAåºåˆ—çš„æ¨¡å¼åŒ¹é…è§„åˆ™ã€‚

## 7. ç›¸å…³ç†è®º

### 7.1 ä¸è‡ªåŠ¨æœºçš„å…³ç³»

CSGä¸çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºï¼ˆLBAï¼‰ç­‰ä»·ï¼Œè¿™æ˜¯ä¹”å§†æ–¯åŸºè°±ç³»çš„é‡è¦ç»“æœã€‚

### 7.2 ä¸è¯­è¨€å±‚æ¬¡çš„å…³ç³»

CSGå®šä¹‰çš„è¯­è¨€æ˜¯ä¸Šä¸‹æ–‡æœ‰å…³è¯­è¨€ï¼Œæ˜¯ä¹”å§†æ–¯åŸºè°±ç³»ä¸­çš„1å‹è¯­è¨€ã€‚

### 7.3 ä¸è®¡ç®—å¤æ‚æ€§çš„å…³ç³»

CSGçš„è§£æé—®é¢˜æ˜¯PSPACEå®Œå…¨çš„ï¼Œæ¯”CFGæ›´å¤æ‚ã€‚

## 8. å‚è€ƒæ–‡çŒ®

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation*. Pearson.
2. Sipser, M. (2012). *Introduction to the Theory of Computation*. Cengage Learning.
3. Chomsky, N. (1959). On certain formal properties of grammars. *Information and Control*, 2(2), 137-167.
4. Kuroda, S. Y. (1964). Classes of languages and linear-bounded automata. *Information and Control*, 7(2), 207-223.
5. Landweber, P. S. (1963). Three theorems on phrase structure grammars of type 1. *Information and Control*, 6(2), 131-136.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [03.1.3 çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº](../03_Formal_Language_Theory/03.1.3_çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº.md)
- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03_Formal_Language_Theory/03.2.2_ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•.md)
- [03.2.4 æ— é™åˆ¶æ–‡æ³•](../03_Formal_Language_Theory/03.2.4_æ— é™åˆ¶æ–‡æ³•.md)
- [03.3.1 ä¹”å§†æ–¯åŸºè°±ç³»](../03_Formal_Language_Theory/03.3.1_ä¹”å§†æ–¯åŸºè°±ç³».md)
- [03.4.1 LLè§£æ](../03_Formal_Language_Theory/03.4.1_LLè§£æ.md)
