# 03.8.2 ç”Ÿç‰©è¯­è¨€

## ğŸ“‹ æ¦‚è¿°

ç”Ÿç‰©è¯­è¨€æ˜¯å½¢å¼è¯­è¨€ç†è®ºåœ¨ç”Ÿç‰©å­¦é¢†åŸŸçš„åº”ç”¨ï¼Œç ”ç©¶ç”Ÿç‰©ä¿¡æ¯çš„å½¢å¼åŒ–è¡¨è¾¾å’Œå¤„ç†ã€‚æœ¬æ–‡æ¡£å»ºç«‹ä¸¥æ ¼çš„ç”Ÿç‰©è¯­è¨€ç†è®ºæ¡†æ¶ï¼ŒåŒ…å«DNAåºåˆ—è¯­è¨€ã€è›‹ç™½è´¨åºåˆ—è¯­è¨€ã€ç”Ÿç‰©è®¡ç®—æ¨¡å‹ç­‰å†…å®¹ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ç”Ÿç‰©è¯­è¨€çš„åŸºæœ¬æ¦‚å¿µå’Œå½¢å¼åŒ–å®šä¹‰
2. åˆ†æDNAå’Œè›‹ç™½è´¨åºåˆ—çš„å½¢å¼è¯­è¨€ç‰¹å¾
3. ç ”ç©¶ç”Ÿç‰©è®¡ç®—æ¨¡å‹ä¸å½¢å¼è¯­è¨€çš„å…³ç³»
4. æä¾›ç”Ÿç‰©ä¿¡æ¯å¤„ç†çš„å½¢å¼åŒ–æ–¹æ³•

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç”Ÿç‰©ä¿¡æ¯åŸºç¡€

**å®šä¹‰ 1.1.1** (DNAåºåˆ—)
DNAåºåˆ—æ˜¯ç”±å››ä¸ªæ ¸è‹·é…¸Aã€Tã€Cã€Gç»„æˆçš„å­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸ºï¼š
$$S = s_1s_2\cdots s_n$$
å…¶ä¸­ $s_i \in \{A, T, C, G\}$ã€‚

**å®šä¹‰ 1.1.2** (è›‹ç™½è´¨åºåˆ—)
è›‹ç™½è´¨åºåˆ—æ˜¯ç”±20ç§æ°¨åŸºé…¸ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸ºï¼š
$$P = p_1p_2\cdots p_m$$
å…¶ä¸­ $p_i \in \{A, R, N, D, C, Q, E, G, H, I, L, K, M, F, P, S, T, W, Y, V\}$ã€‚

**å®šä¹‰ 1.1.3** (ç”Ÿç‰©è¯­è¨€)
ç”Ÿç‰©è¯­è¨€æ˜¯ç”¨äºæè¿°ç”Ÿç‰©ä¿¡æ¯çš„å½¢å¼è¯­è¨€ï¼ŒåŒ…æ‹¬DNAè¯­è¨€ã€è›‹ç™½è´¨è¯­è¨€ã€RNAè¯­è¨€ç­‰ã€‚

### 1.2 ç”Ÿç‰©è¯­è¨€çš„åŸºæœ¬ç‰¹å¾

**å®šä¹‰ 1.2.1** (ç”Ÿç‰©åºåˆ—è¯­è¨€)
ç”Ÿç‰©åºåˆ—è¯­è¨€ $L_B$ æ˜¯ç”Ÿç‰©åºåˆ—çš„é›†åˆï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š

- æœ‰é™å­—æ¯è¡¨ï¼šDNAä¸º$\{A, T, C, G\}$ï¼Œè›‹ç™½è´¨ä¸º20ç§æ°¨åŸºé…¸
- åºåˆ—é•¿åº¦ï¼šå¯ä»¥æ˜¯å›ºå®šé•¿åº¦æˆ–å¯å˜é•¿åº¦
- ç”Ÿç‰©å­¦çº¦æŸï¼šéµå¾ªç”Ÿç‰©å­¦è§„å¾‹å’Œè¿›åŒ–çº¦æŸ

**å®šä¹‰ 1.2.2** (ç”Ÿç‰©è¯­æ³•)
ç”Ÿç‰©è¯­æ³•æ˜¯æè¿°ç”Ÿç‰©åºåˆ—ç»“æ„çš„è§„åˆ™ç³»ç»Ÿï¼ŒåŒ…æ‹¬ï¼š

- å¯åŠ¨å­åºåˆ—æ¨¡å¼
- ç¼–ç åºåˆ—ç»“æ„
- è°ƒæ§åºåˆ—æ¨¡å¼
- é‡å¤åºåˆ—æ¨¡å¼

**å®šä¹‰ 1.2.3** (ç”Ÿç‰©è¯­ä¹‰)
ç”Ÿç‰©è¯­ä¹‰å°†ç”Ÿç‰©åºåˆ—æ˜ å°„åˆ°ç”Ÿç‰©å­¦åŠŸèƒ½ï¼š

- åŸºå› è¡¨è¾¾è°ƒæ§
- è›‹ç™½è´¨åŠŸèƒ½
- è¿›åŒ–å…³ç³»
- ç–¾ç—…å…³è”

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 DNAè¯­è¨€

**å®šä¹‰ 2.1.1** (DNAå­—æ¯è¡¨)
DNAå­—æ¯è¡¨ $\Sigma_{DNA} = \{A, T, C, G\}$ï¼Œå…¶ä¸­ï¼š

- A (è…ºå˜Œå‘¤) ä¸ T (èƒ¸è…ºå˜§å•¶) é…å¯¹
- C (èƒå˜§å•¶) ä¸ G (é¸Ÿå˜Œå‘¤) é…å¯¹

**å®šä¹‰ 2.1.2** (DNAäº’è¡¥æ€§)
DNAåºåˆ— $S = s_1s_2\cdots s_n$ çš„äº’è¡¥åºåˆ—ä¸ºï¼š
$$S^c = c(s_1)c(s_2)\cdots c(s_n)$$
å…¶ä¸­ $c(A) = T, c(T) = A, c(C) = G, c(G) = C$ã€‚

**å®šä¹‰ 2.1.3** (DNAå›æ–‡)
DNAåºåˆ— $S$ æ˜¯å›æ–‡ï¼Œå½“ä¸”ä»…å½“ $S = S^c$ã€‚

### 2.2 è›‹ç™½è´¨è¯­è¨€

**å®šä¹‰ 2.2.1** (è›‹ç™½è´¨å­—æ¯è¡¨)
è›‹ç™½è´¨å­—æ¯è¡¨ $\Sigma_{Protein}$ åŒ…å«20ç§æ ‡å‡†æ°¨åŸºé…¸ï¼š
$$\Sigma_{Protein} = \{A, R, N, D, C, Q, E, G, H, I, L, K, M, F, P, S, T, W, Y, V\}$$

**å®šä¹‰ 2.2.2** (æ°¨åŸºé…¸æ€§è´¨)
æ°¨åŸºé…¸å…·æœ‰å¤šç§æ€§è´¨ï¼š

- ç–æ°´æ€§/äº²æ°´æ€§
- ç”µè·æ€§è´¨
- åˆ†å­é‡
- ä¾§é“¾ç»“æ„

**å®šä¹‰ 2.2.3** (è›‹ç™½è´¨ç»“æ„)
è›‹ç™½è´¨ç»“æ„åˆ†ä¸ºå››ä¸ªå±‚æ¬¡ï¼š

- ä¸€çº§ç»“æ„ï¼šæ°¨åŸºé…¸åºåˆ—
- äºŒçº§ç»“æ„ï¼šÎ±èºæ—‹ã€Î²æŠ˜å 
- ä¸‰çº§ç»“æ„ï¼šç©ºé—´æ„è±¡
- å››çº§ç»“æ„ï¼šäºšåŸºç»„è£…

### 2.3 ç”Ÿç‰©è¯­æ³•

**å®šä¹‰ 2.3.1** (ç”Ÿç‰©æ­£åˆ™è¡¨è¾¾å¼)
ç”Ÿç‰©æ­£åˆ™è¡¨è¾¾å¼ç”¨äºæè¿°ç”Ÿç‰©åºåˆ—æ¨¡å¼ï¼š

- $[ATCG]$ï¼šä»»æ„æ ¸è‹·é…¸
- $[AT]^+$ï¼šä¸€ä¸ªæˆ–å¤šä¸ªAæˆ–T
- $(ATCG){3}$ï¼šæ°å¥½3ä¸ªæ ¸è‹·é…¸
- $(ATCG)*$ï¼šé›¶ä¸ªæˆ–å¤šä¸ªæ ¸è‹·é…¸

**å®šä¹‰ 2.3.2** (ç”Ÿç‰©ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•)
ç”Ÿç‰©ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³• $G_B = (V_B, \Sigma_B, R_B, S_B)$ å…¶ä¸­ï¼š

- $V_B$ æ˜¯ç”Ÿç‰©éç»ˆç»“ç¬¦é›†åˆ
- $\Sigma_B$ æ˜¯ç”Ÿç‰©ç»ˆç»“ç¬¦é›†åˆ
- $R_B$ æ˜¯ç”Ÿç‰©é‡å†™è§„åˆ™é›†åˆ
- $S_B$ æ˜¯ç”Ÿç‰©å¼€å§‹ç¬¦å·

## 3. å®šç†ä¸è¯æ˜

### 3.1 DNAè¯­è¨€çš„åŸºæœ¬å®šç†

**å®šç† 3.1.1** (DNAäº’è¡¥æ€§å®šç†)
å¯¹äºä»»æ„DNAåºåˆ— $S$ï¼Œæœ‰ $(S^c)^c = S$ã€‚

**è¯æ˜**ï¼š
è®¾ $S = s_1s_2\cdots s_n$ï¼Œåˆ™ï¼š
$$S^c = c(s_1)c(s_2)\cdots c(s_n)$$
$$(S^c)^c = c(c(s_1))c(c(s_2))\cdots c(c(s_n)) = s_1s_2\cdots s_n = S$$

**å®šç† 3.1.2** (DNAå›æ–‡è¯†åˆ«)
DNAåºåˆ— $S$ æ˜¯å›æ–‡å½“ä¸”ä»…å½“ $S = S^R$ï¼Œå…¶ä¸­ $S^R$ æ˜¯ $S$ çš„åè½¬ã€‚

**è¯æ˜**ï¼š
å¦‚æœ $S$ æ˜¯å›æ–‡ï¼Œåˆ™ $S = S^c$ã€‚
ç”±äº $S^c = S^R$ï¼ˆäº’è¡¥åºåˆ—ç­‰äºåè½¬åºåˆ—ï¼‰ï¼Œæ‰€ä»¥ $S = S^R$ã€‚
åä¹‹ï¼Œå¦‚æœ $S = S^R$ï¼Œåˆ™ $S = S^c$ï¼Œæ‰€ä»¥ $S$ æ˜¯å›æ–‡ã€‚

### 3.2 ç”Ÿç‰©åºåˆ—åˆ†æå®šç†

**å®šç† 3.2.1** (æœ€é•¿å…¬å…±å­åºåˆ—)
ä¸¤ä¸ªç”Ÿç‰©åºåˆ—çš„æœ€é•¿å…¬å…±å­åºåˆ—å¯ä»¥é€šè¿‡åŠ¨æ€è§„åˆ’ç®—æ³•åœ¨ $O(mn)$ æ—¶é—´å†…è®¡ç®—ã€‚

**è¯æ˜**ï¼š
è®¾ $S_1$ å’Œ $S_2$ æ˜¯ä¸¤ä¸ªåºåˆ—ï¼Œé•¿åº¦åˆ†åˆ«ä¸º $m$ å’Œ $n$ã€‚
å®šä¹‰ $LCS(i,j)$ ä¸º $S_1[1..i]$ å’Œ $S_2[1..j]$ çš„æœ€é•¿å…¬å…±å­åºåˆ—é•¿åº¦ã€‚
é€’æ¨å…³ç³»ï¼š
$$LCS(i,j) = \begin{cases}
0 & \text{if } i=0 \text{ or } j=0 \\
LCS(i-1,j-1) + 1 & \text{if } S_1[i] = S_2[j] \\
\max(LCS(i-1,j), LCS(i,j-1)) & \text{otherwise}
\end{cases}$$

**å®šç† 3.2.2** (åºåˆ—ç›¸ä¼¼æ€§åº¦é‡)
åºåˆ—ç›¸ä¼¼æ€§å¯ä»¥é€šè¿‡ç¼–è¾‘è·ç¦»ã€åºåˆ—æ¯”å¯¹å¾—åˆ†ç­‰æ–¹æ³•åº¦é‡ã€‚

## 4. ä»£ç å®ç°

### 4.1 DNAåºåˆ—å¤„ç†

```rust
use std::collections::HashMap;

/// DNAæ ¸è‹·é…¸æšä¸¾
# [derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
enum Nucleotide {
    A, T, C, G,
}

impl Nucleotide {
    /// è·å–äº’è¡¥æ ¸è‹·é…¸
    fn complement(&self) -> Nucleotide {
        match self {
            Nucleotide::A => Nucleotide::T,
            Nucleotide::T => Nucleotide::A,
            Nucleotide::C => Nucleotide::G,
            Nucleotide::G => Nucleotide::C,
        }
    }

    /// ä»å­—ç¬¦åˆ›å»ºæ ¸è‹·é…¸
    fn from_char(c: char) -> Option<Nucleotide> {
        match c.to_ascii_uppercase() {
            'A' => Some(Nucleotide::A),
            'T' => Some(Nucleotide::T),
            'C' => Some(Nucleotide::C),
            'G' => Some(Nucleotide::G),
            _ => None,
        }
    }

    /// è½¬æ¢ä¸ºå­—ç¬¦
    fn to_char(&self) -> char {
        match self {
            Nucleotide::A => 'A',
            Nucleotide::T => 'T',
            Nucleotide::C => 'C',
            Nucleotide::G => 'G',
        }
    }
}

/// DNAåºåˆ—
# [derive(Debug, Clone)]
struct DNASequence {
    nucleotides: Vec<Nucleotide>,
}

impl DNASequence {
    /// ä»å­—ç¬¦ä¸²åˆ›å»ºDNAåºåˆ—
    fn from_string(s: &str) -> Result<Self, String> {
        let nucleotides: Result<Vec<Nucleotide>, _> = s
            .chars()
            .map(Nucleotide::from_char)
            .collect();

        match nucleotides {
            Ok(nucs) => Ok(DNASequence { nucleotides: nucs }),
            Err(_) => Err("Invalid DNA sequence".to_string()),
        }
    }

    /// è·å–åºåˆ—é•¿åº¦
    fn length(&self) -> usize {
        self.nucleotides.len()
    }

    /// è·å–äº’è¡¥åºåˆ—
    fn complement(&self) -> DNASequence {
        let comp_nucleotides: Vec<Nucleotide> = self.nucleotides
            .iter()
            .map(|n| n.complement())
            .collect();
        DNASequence { nucleotides: comp_nucleotides }
    }

    /// è·å–åå‘äº’è¡¥åºåˆ—
    fn reverse_complement(&self) -> DNASequence {
        let mut comp = self.complement();
        comp.nucleotides.reverse();
        comp
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºå›æ–‡
    fn is_palindrome(&self) -> bool {
        self.nucleotides == self.reverse_complement().nucleotides
    }

    /// è®¡ç®—GCå«é‡
    fn gc_content(&self) -> f64 {
        let gc_count = self.nucleotides
            .iter()
            .filter(|&&n| n == Nucleotide::G || n == Nucleotide::C)
            .count();
        gc_count as f64 / self.length() as f64
    }

    /// æŸ¥æ‰¾å­åºåˆ—
    fn find_subsequence(&self, pattern: &DNASequence) -> Vec<usize> {
        let mut positions = Vec::new();
        let pattern_len = pattern.length();

        for i in 0..=self.length() - pattern_len {
            if self.nucleotides[i..i + pattern_len] == pattern.nucleotides {
                positions.push(i);
            }
        }

        positions
    }

    /// è½¬æ¢ä¸ºå­—ç¬¦ä¸²
    fn to_string(&self) -> String {
        self.nucleotides.iter().map(|n| n.to_char()).collect()
    }
}
```

### 4.2 è›‹ç™½è´¨åºåˆ—å¤„ç†

```rust
/// æ°¨åŸºé…¸æšä¸¾
# [derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
enum AminoAcid {
    A, R, N, D, C, Q, E, G, H, I, L, K, M, F, P, S, T, W, Y, V,
}

impl AminoAcid {
    /// ä»å­—ç¬¦åˆ›å»ºæ°¨åŸºé…¸
    fn from_char(c: char) -> Option<AminoAcid> {
        match c.to_ascii_uppercase() {
            'A' => Some(AminoAcid::A),
            'R' => Some(AminoAcid::R),
            'N' => Some(AminoAcid::N),
            'D' => Some(AminoAcid::D),
            'C' => Some(AminoAcid::C),
            'Q' => Some(AminoAcid::Q),
            'E' => Some(AminoAcid::E),
            'G' => Some(AminoAcid::G),
            'H' => Some(AminoAcid::H),
            'I' => Some(AminoAcid::I),
            'L' => Some(AminoAcid::L),
            'K' => Some(AminoAcid::K),
            'M' => Some(AminoAcid::M),
            'F' => Some(AminoAcid::F),
            'P' => Some(AminoAcid::P),
            'S' => Some(AminoAcid::S),
            'T' => Some(AminoAcid::T),
            'W' => Some(AminoAcid::W),
            'Y' => Some(AminoAcid::Y),
            'V' => Some(AminoAcid::V),
            _ => None,
        }
    }

    /// è·å–ç–æ°´æ€§å€¼
    fn hydrophobicity(&self) -> f64 {
        match self {
            AminoAcid::A => 1.8,
            AminoAcid::R => -4.5,
            AminoAcid::N => -3.5,
            AminoAcid::D => -3.5,
            AminoAcid::C => 2.5,
            AminoAcid::Q => -3.5,
            AminoAcid::E => -3.5,
            AminoAcid::G => -0.4,
            AminoAcid::H => -3.2,
            AminoAcid::I => 4.5,
            AminoAcid::L => 3.8,
            AminoAcid::K => -3.9,
            AminoAcid::M => 1.9,
            AminoAcid::F => 2.8,
            AminoAcid::P => -1.6,
            AminoAcid::S => -0.8,
            AminoAcid::T => -0.7,
            AminoAcid::W => -0.9,
            AminoAcid::Y => -1.3,
            AminoAcid::V => 4.2,
        }
    }

    /// è·å–åˆ†å­é‡
    fn molecular_weight(&self) -> f64 {
        match self {
            AminoAcid::A => 89.1,
            AminoAcid::R => 174.2,
            AminoAcid::N => 132.1,
            AminoAcid::D => 133.1,
            AminoAcid::C => 121.2,
            AminoAcid::Q => 146.2,
            AminoAcid::E => 147.1,
            AminoAcid::G => 75.1,
            AminoAcid::H => 155.2,
            AminoAcid::I => 131.2,
            AminoAcid::L => 131.2,
            AminoAcid::K => 146.2,
            AminoAcid::M => 149.2,
            AminoAcid::F => 165.2,
            AminoAcid::P => 115.1,
            AminoAcid::S => 105.1,
            AminoAcid::T => 119.1,
            AminoAcid::W => 204.2,
            AminoAcid::Y => 181.2,
            AminoAcid::V => 117.1,
        }
    }
}

/// è›‹ç™½è´¨åºåˆ—
# [derive(Debug, Clone)]
struct ProteinSequence {
    amino_acids: Vec<AminoAcid>,
}

impl ProteinSequence {
    /// ä»å­—ç¬¦ä¸²åˆ›å»ºè›‹ç™½è´¨åºåˆ—
    fn from_string(s: &str) -> Result<Self, String> {
        let amino_acids: Result<Vec<AminoAcid>, _> = s
            .chars()
            .map(AminoAcid::from_char)
            .collect();

        match amino_acids {
            Ok(aas) => Ok(ProteinSequence { amino_acids: aas }),
            Err(_) => Err("Invalid protein sequence".to_string()),
        }
    }

    /// è·å–åºåˆ—é•¿åº¦
    fn length(&self) -> usize {
        self.amino_acids.len()
    }

    /// è®¡ç®—åˆ†å­é‡
    fn molecular_weight(&self) -> f64 {
        self.amino_acids.iter().map(|aa| aa.molecular_weight()).sum()
    }

    /// è®¡ç®—å¹³å‡ç–æ°´æ€§
    fn average_hydrophobicity(&self) -> f64 {
        let total: f64 = self.amino_acids.iter().map(|aa| aa.hydrophobicity()).sum();
        total / self.length() as f64
    }

    /// è®¡ç®—æ°¨åŸºé…¸ç»„æˆ
    fn amino_acid_composition(&self) -> HashMap<AminoAcid, f64> {
        let mut composition = HashMap::new();
        let total = self.length() as f64;

        for aa in &self.amino_acids {
            *composition.entry(*aa).or_insert(0.0) += 1.0;
        }

        for count in composition.values_mut() {
            *count /= total;
        }

        composition
    }
}
```

### 4.3 åºåˆ—æ¯”å¯¹ç®—æ³•

```rust
/// åºåˆ—æ¯”å¯¹ç»“æœ
# [derive(Debug)]
struct Alignment {
    sequence1: String,
    sequence2: String,
    score: i32,
}

/// åºåˆ—æ¯”å¯¹å™¨
struct SequenceAligner {
    match_score: i32,
    mismatch_penalty: i32,
    gap_penalty: i32,
}

impl SequenceAligner {
    fn new(match_score: i32, mismatch_penalty: i32, gap_penalty: i32) -> Self {
        SequenceAligner {
            match_score,
            mismatch_penalty,
            gap_penalty,
        }
    }

    /// å…¨å±€åºåˆ—æ¯”å¯¹
    fn global_align(&self, seq1: &str, seq2: &str) -> Alignment {
        let len1 = seq1.len();
        let len2 = seq2.len();

        // åˆ›å»ºåŠ¨æ€è§„åˆ’çŸ©é˜µ
        let mut dp = vec![vec![0; len2 + 1]; len1 + 1];

        // åˆå§‹åŒ–ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—
        for i in 0..=len1 {
            dp[i][0] = i as i32 * self.gap_penalty;
        }
        for j in 0..=len2 {
            dp[0][j] = j as i32 * self.gap_penalty;
        }

        // å¡«å……åŠ¨æ€è§„åˆ’çŸ©é˜µ
        for i in 1..=len1 {
            for j in 1..=len2 {
                let match_score = if seq1.chars().nth(i - 1) == seq2.chars().nth(j - 1) {
                    self.match_score
                } else {
                    self.mismatch_penalty
                };

                dp[i][j] = (dp[i-1][j-1] + match_score)
                    .max(dp[i-1][j] + self.gap_penalty)
                    .max(dp[i][j-1] + self.gap_penalty);
            }
        }

        // å›æº¯æ„å»ºæ¯”å¯¹ç»“æœ
        let (aligned_seq1, aligned_seq2) = self.backtrack(&dp, seq1, seq2);

        Alignment {
            sequence1: aligned_seq1,
            sequence2: aligned_seq2,
            score: dp[len1][len2],
        }
    }

    /// å›æº¯æ„å»ºæ¯”å¯¹åºåˆ—
    fn backtrack(&self, dp: &[Vec<i32>], seq1: &str, seq2: &str) -> (String, String) {
        let mut i = seq1.len();
        let mut j = seq2.len();
        let mut aligned_seq1 = String::new();
        let mut aligned_seq2 = String::new();

        while i > 0 || j > 0 {
            if i > 0 && j > 0 && dp[i][j] == dp[i-1][j-1] +
                if seq1.chars().nth(i-1) == seq2.chars().nth(j-1) { self.match_score } else { self.mismatch_penalty } {
                aligned_seq1.insert(0, seq1.chars().nth(i-1).unwrap());
                aligned_seq2.insert(0, seq2.chars().nth(j-1).unwrap());
                i -= 1;
                j -= 1;
            } else if i > 0 && dp[i][j] == dp[i-1][j] + self.gap_penalty {
                aligned_seq1.insert(0, seq1.chars().nth(i-1).unwrap());
                aligned_seq2.insert(0, '-');
                i -= 1;
            } else {
                aligned_seq1.insert(0, '-');
                aligned_seq2.insert(0, seq2.chars().nth(j-1).unwrap());
                j -= 1;
            }
        }

        (aligned_seq1, aligned_seq2)
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 DNAåºåˆ—åˆ†æ

```rust
// DNAåºåˆ—åˆ†æç¤ºä¾‹
fn dna_analysis_example() {
    // åˆ›å»ºDNAåºåˆ—
    let dna = DNASequence::from_string("ATCGATCGATCG").unwrap();

    println!("DNAåºåˆ—: {}", dna.to_string());
    println!("åºåˆ—é•¿åº¦: {}", dna.length());
    println!("GCå«é‡: {:.2}%", dna.gc_content() * 100.0);

    // è·å–äº’è¡¥åºåˆ—
    let complement = dna.complement();
    println!("äº’è¡¥åºåˆ—: {}", complement.to_string());

    // æ£€æŸ¥å›æ–‡
    let palindrome = DNASequence::from_string("ATCGAT").unwrap();
    println!("åºåˆ— {} æ˜¯å›æ–‡: {}", palindrome.to_string(), palindrome.is_palindrome());

    // æŸ¥æ‰¾å­åºåˆ—
    let pattern = DNASequence::from_string("ATC").unwrap();
    let positions = dna.find_subsequence(&pattern);
    println!("æ¨¡å¼ {} åœ¨ä½ç½®: {:?}", pattern.to_string(), positions);
}

// è›‹ç™½è´¨åºåˆ—åˆ†æç¤ºä¾‹
fn protein_analysis_example() {
    // åˆ›å»ºè›‹ç™½è´¨åºåˆ—
    let protein = ProteinSequence::from_string("MKTVRQERLKSIVRILERSKEPVSGAQLAEELSVSRQVIVQDIAYLRSLGYNIVATPRGYVLAGG").unwrap();

    println!("è›‹ç™½è´¨åºåˆ—é•¿åº¦: {}", protein.length());
    println!("åˆ†å­é‡: {:.2} Da", protein.molecular_weight());
    println!("å¹³å‡ç–æ°´æ€§: {:.2}", protein.average_hydrophobicity());

    // æ°¨åŸºé…¸ç»„æˆ
    let composition = protein.amino_acid_composition();
    println!("æ°¨åŸºé…¸ç»„æˆ:");
    for (aa, freq) in composition {
        println!("  {}: {:.3}", format!("{:?}", aa), freq);
    }
}

// åºåˆ—æ¯”å¯¹ç¤ºä¾‹
fn sequence_alignment_example() {
    let aligner = SequenceAligner::new(1, -1, -2);

    let seq1 = "ATCGATCG";
    let seq2 = "ATCGATCC";

    let alignment = aligner.global_align(seq1, seq2);

    println!("åºåˆ—æ¯”å¯¹ç»“æœ:");
    println!("åºåˆ—1: {}", alignment.sequence1);
    println!("åºåˆ—2: {}", alignment.sequence2);
    println!("æ¯”å¯¹å¾—åˆ†: {}", alignment.score);
}
```

### 5.2 ç”Ÿç‰©ä¿¡æ¯å¤„ç†

```rust
/// ç”Ÿç‰©åºåˆ—æ•°æ®åº“
struct SequenceDatabase {
    sequences: HashMap<String, DNASequence>,
}

impl SequenceDatabase {
    fn new() -> Self {
        SequenceDatabase {
            sequences: HashMap::new(),
        }
    }

    /// æ·»åŠ åºåˆ—
    fn add_sequence(&mut self, name: String, sequence: DNASequence) {
        self.sequences.insert(name, sequence);
    }

    /// æœç´¢ç›¸ä¼¼åºåˆ—
    fn search_similar(&self, query: &DNASequence, threshold: f64) -> Vec<(String, f64)> {
        let mut results = Vec::new();

        for (name, sequence) in &self.sequences {
            let similarity = self.calculate_similarity(query, sequence);
            if similarity >= threshold {
                results.push((name.clone(), similarity));
            }
        }

        results.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
        results
    }

    /// è®¡ç®—åºåˆ—ç›¸ä¼¼æ€§
    fn calculate_similarity(&self, seq1: &DNASequence, seq2: &DNASequence) -> f64 {
        let aligner = SequenceAligner::new(1, -1, -2);
        let alignment = aligner.global_align(&seq1.to_string(), &seq2.to_string());

        let max_len = seq1.length().max(seq2.length());
        alignment.score as f64 / max_len as f64
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn database_search_example() {
    let mut db = SequenceDatabase::new();

    // æ·»åŠ ä¸€äº›åºåˆ—
    db.add_sequence("seq1".to_string(), DNASequence::from_string("ATCGATCG").unwrap());
    db.add_sequence("seq2".to_string(), DNASequence::from_string("ATCGATCC").unwrap());
    db.add_sequence("seq3".to_string(), DNASequence::from_string("GCTAGCTA").unwrap());

    // æœç´¢ç›¸ä¼¼åºåˆ—
    let query = DNASequence::from_string("ATCGATCG").unwrap();
    let results = db.search_similar(&query, 0.8);

    println!("ç›¸ä¼¼åºåˆ—æœç´¢ç»“æœ:");
    for (name, similarity) in results {
        println!("  {}: {:.3}", name, similarity);
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å½¢å¼è¯­è¨€ç†è®ºçš„å…³ç³»

ç”Ÿç‰©è¯­è¨€ä¸ç»å…¸å½¢å¼è¯­è¨€ç†è®ºçš„å…³ç³»ï¼š

1. **å­—æ¯è¡¨æ‰©å±•**ï¼šç”Ÿç‰©è¯­è¨€ä½¿ç”¨ç‰¹æ®Šçš„å­—æ¯è¡¨ï¼ˆDNAã€è›‹ç™½è´¨ï¼‰
2. **ç”Ÿç‰©å­¦çº¦æŸ**ï¼šç”Ÿç‰©è¯­è¨€éµå¾ªç”Ÿç‰©å­¦è§„å¾‹å’Œè¿›åŒ–çº¦æŸ
3. **åºåˆ—æ¨¡å¼**ï¼šç”Ÿç‰©è¯­è¨€åŒ…å«ç‰¹å®šçš„åºåˆ—æ¨¡å¼å’Œç»“æ„
4. **åŠŸèƒ½è¯­ä¹‰**ï¼šç”Ÿç‰©è¯­è¨€å…·æœ‰ç”Ÿç‰©å­¦åŠŸèƒ½è¯­ä¹‰

### 6.2 ä¸è®¡ç®—ç†è®ºçš„å…³ç³»

ç”Ÿç‰©è¯­è¨€ä¸è®¡ç®—ç†è®ºçš„å…³ç³»ï¼š

1. **åºåˆ—åˆ†æç®—æ³•**ï¼šç”Ÿç‰©è¯­è¨€éœ€è¦é«˜æ•ˆçš„åºåˆ—åˆ†æç®—æ³•
2. **æ¨¡å¼åŒ¹é…**ï¼šç”Ÿç‰©è¯­è¨€ä¸­çš„æ¨¡å¼åŒ¹é…å’Œæœç´¢
3. **æœºå™¨å­¦ä¹ **ï¼šç”Ÿç‰©è¯­è¨€åœ¨æœºå™¨å­¦ä¹ ä¸­çš„åº”ç”¨
4. **æ•°æ®åº“ç†è®º**ï¼šç”Ÿç‰©åºåˆ—æ•°æ®åº“çš„è®¾è®¡å’ŒæŸ¥è¯¢

### 6.3 ä¸ä¿¡æ¯è®ºçš„å…³ç³»

ç”Ÿç‰©è¯­è¨€ä¸ä¿¡æ¯è®ºçš„å…³ç³»ï¼š

1. **ä¿¡æ¯ç¼–ç **ï¼šDNAä½œä¸ºä¿¡æ¯ç¼–ç ç³»ç»Ÿ
2. **ä¿¡æ¯å‹ç¼©**ï¼šç”Ÿç‰©åºåˆ—çš„å‹ç¼©å’Œå­˜å‚¨
3. **ä¿¡æ¯ä¼ è¾“**ï¼šç”Ÿç‰©ä¿¡æ¯çš„ä¼ é€’å’Œå¤åˆ¶
4. **ä¿¡æ¯ç†µ**ï¼šç”Ÿç‰©åºåˆ—çš„ä¿¡æ¯ç†µåˆ†æ

## 7. å‚è€ƒæ–‡çŒ®

1. Durbin, R., Eddy, S. R., Krogh, A., & Mitchison, G. (1998). Biological sequence analysis: probabilistic models of proteins and nucleic acids. Cambridge university press.
2. Gusfield, D. (1997). Algorithms on strings, trees, and sequences: computer science and computational biology. Cambridge university press.
3. Mount, D. W. (2004). Bioinformatics: sequence and genome analysis. Cold Spring Harbor Laboratory Press.
4. Pevzner, P. A. (2000). Computational molecular biology: an algorithmic approach. MIT press.
5. Waterman, M. S. (1995). Introduction to computational biology: maps, sequences and genomes. CRC press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [03.1.1 æœ‰é™è‡ªåŠ¨æœº](../03.1.1_æœ‰é™è‡ªåŠ¨æœº.md)
- [03.2.1 æ­£åˆ™æ–‡æ³•](../03.2.1_æ­£åˆ™æ–‡æ³•.md)
- [03.3.1 ä¹”å§†æ–¯åŸºè°±ç³»](../03.3.1_ä¹”å§†æ–¯åŸºè°±ç³».md)
- [03.6.3 ç®—æ³•åˆ†æ](./03.6.3_ç®—æ³•åˆ†æ.md)
