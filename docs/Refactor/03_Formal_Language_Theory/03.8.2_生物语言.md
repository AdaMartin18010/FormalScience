# 03.8.2 ÁîüÁâ©ËØ≠Ë®Ä

## üìã Ê¶ÇËø∞

ÁîüÁâ©ËØ≠Ë®ÄÊòØÂΩ¢ÂºèËØ≠Ë®ÄÁêÜËÆ∫Âú®ÁîüÁâ©Â≠¶È¢ÜÂüüÁöÑÂ∫îÁî®ÔºåÁ†îÁ©∂ÁîüÁâ©‰ø°ÊÅØÁöÑÂΩ¢ÂºèÂåñË°®ËææÂíåÂ§ÑÁêÜ„ÄÇÊú¨ÊñáÊ°£Âª∫Á´ã‰∏•Ê†ºÁöÑÁîüÁâ©ËØ≠Ë®ÄÁêÜËÆ∫Ê°ÜÊû∂ÔºåÂåÖÂê´DNAÂ∫èÂàóËØ≠Ë®Ä„ÄÅËõãÁôΩË¥®Â∫èÂàóËØ≠Ë®Ä„ÄÅÁîüÁâ©ËÆ°ÁÆóÊ®°ÂûãÁ≠âÂÜÖÂÆπ„ÄÇ

## üéØ Ê†∏ÂøÉÁõÆÊ†á

1. Âª∫Á´ãÁîüÁâ©ËØ≠Ë®ÄÁöÑÂü∫Êú¨Ê¶ÇÂøµÂíåÂΩ¢ÂºèÂåñÂÆö‰πâ
2. ÂàÜÊûêDNAÂíåËõãÁôΩË¥®Â∫èÂàóÁöÑÂΩ¢ÂºèËØ≠Ë®ÄÁâπÂæÅ
3. Á†îÁ©∂ÁîüÁâ©ËÆ°ÁÆóÊ®°Âûã‰∏éÂΩ¢ÂºèËØ≠Ë®ÄÁöÑÂÖ≥Á≥ª
4. Êèê‰æõÁîüÁâ©‰ø°ÊÅØÂ§ÑÁêÜÁöÑÂΩ¢ÂºèÂåñÊñπÊ≥ï

## üìö ÁõÆÂΩï

1. [Âü∫Êú¨Ê¶ÇÂøµ](#1-Âü∫Êú¨Ê¶ÇÂøµ)
2. [ÂΩ¢ÂºèÂåñÂÆö‰πâ](#2-ÂΩ¢ÂºèÂåñÂÆö‰πâ)
3. [ÂÆöÁêÜ‰∏éËØÅÊòé](#3-ÂÆöÁêÜ‰∏éËØÅÊòé)
4. [‰ª£Á†ÅÂÆûÁé∞](#4-‰ª£Á†ÅÂÆûÁé∞)
5. [Â∫îÁî®Á§∫‰æã](#5-Â∫îÁî®Á§∫‰æã)
6. [Áõ∏ÂÖ≥ÁêÜËÆ∫](#6-Áõ∏ÂÖ≥ÁêÜËÆ∫)
7. [ÂèÇËÄÉÊñáÁåÆ](#7-ÂèÇËÄÉÊñáÁåÆ)

## 1. Âü∫Êú¨Ê¶ÇÂøµ

### 1.1 ÁîüÁâ©‰ø°ÊÅØÂü∫Á°Ä

**ÂÆö‰πâ 1.1.1** (DNAÂ∫èÂàó)
DNAÂ∫èÂàóÊòØÁî±Âõõ‰∏™Ê†∏Ëã∑ÈÖ∏A„ÄÅT„ÄÅC„ÄÅGÁªÑÊàêÁöÑÂ≠óÁ¨¶‰∏≤ÔºåË°®Á§∫‰∏∫Ôºö
$$S = s_1s_2\cdots s_n$$
ÂÖ∂‰∏≠ $s_i \in \{A, T, C, G\}$„ÄÇ

**ÂÆö‰πâ 1.1.2** (ËõãÁôΩË¥®Â∫èÂàó)
ËõãÁôΩË¥®Â∫èÂàóÊòØÁî±20ÁßçÊ∞®Âü∫ÈÖ∏ÁªÑÊàêÁöÑÂ≠óÁ¨¶‰∏≤ÔºåË°®Á§∫‰∏∫Ôºö
$$P = p_1p_2\cdots p_m$$
ÂÖ∂‰∏≠ $p_i \in \{A, R, N, D, C, Q, E, G, H, I, L, K, M, F, P, S, T, W, Y, V\}$„ÄÇ

**ÂÆö‰πâ 1.1.3** (ÁîüÁâ©ËØ≠Ë®Ä)
ÁîüÁâ©ËØ≠Ë®ÄÊòØÁî®‰∫éÊèèËø∞ÁîüÁâ©‰ø°ÊÅØÁöÑÂΩ¢ÂºèËØ≠Ë®ÄÔºåÂåÖÊã¨DNAËØ≠Ë®Ä„ÄÅËõãÁôΩË¥®ËØ≠Ë®Ä„ÄÅRNAËØ≠Ë®ÄÁ≠â„ÄÇ

### 1.2 ÁîüÁâ©ËØ≠Ë®ÄÁöÑÂü∫Êú¨ÁâπÂæÅ

**ÂÆö‰πâ 1.2.1** (ÁîüÁâ©Â∫èÂàóËØ≠Ë®Ä)
ÁîüÁâ©Â∫èÂàóËØ≠Ë®Ä $L_B$ ÊòØÁîüÁâ©Â∫èÂàóÁöÑÈõÜÂêàÔºåÂÖ∑Êúâ‰ª•‰∏ãÁâπÂæÅÔºö

- ÊúâÈôêÂ≠óÊØçË°®ÔºöDNA‰∏∫$\{A, T, C, G\}$ÔºåËõãÁôΩË¥®‰∏∫20ÁßçÊ∞®Âü∫ÈÖ∏
- Â∫èÂàóÈïøÂ∫¶ÔºöÂèØ‰ª•ÊòØÂõ∫ÂÆöÈïøÂ∫¶ÊàñÂèØÂèòÈïøÂ∫¶
- ÁîüÁâ©Â≠¶Á∫¶ÊùüÔºöÈÅµÂæ™ÁîüÁâ©Â≠¶ËßÑÂæãÂíåËøõÂåñÁ∫¶Êùü

**ÂÆö‰πâ 1.2.2** (ÁîüÁâ©ËØ≠Ê≥ï)
ÁîüÁâ©ËØ≠Ê≥ïÊòØÊèèËø∞ÁîüÁâ©Â∫èÂàóÁªìÊûÑÁöÑËßÑÂàôÁ≥ªÁªüÔºåÂåÖÊã¨Ôºö

- ÂêØÂä®Â≠êÂ∫èÂàóÊ®°Âºè
- ÁºñÁ†ÅÂ∫èÂàóÁªìÊûÑ
- Ë∞ÉÊéßÂ∫èÂàóÊ®°Âºè
- ÈáçÂ§çÂ∫èÂàóÊ®°Âºè

**ÂÆö‰πâ 1.2.3** (ÁîüÁâ©ËØ≠‰πâ)
ÁîüÁâ©ËØ≠‰πâÂ∞ÜÁîüÁâ©Â∫èÂàóÊò†Â∞ÑÂà∞ÁîüÁâ©Â≠¶ÂäüËÉΩÔºö

- Âü∫Âõ†Ë°®ËææË∞ÉÊéß
- ËõãÁôΩË¥®ÂäüËÉΩ
- ËøõÂåñÂÖ≥Á≥ª
- ÁñæÁóÖÂÖ≥ËÅî

## 2. ÂΩ¢ÂºèÂåñÂÆö‰πâ

### 2.1 DNAËØ≠Ë®Ä

**ÂÆö‰πâ 2.1.1** (DNAÂ≠óÊØçË°®)
DNAÂ≠óÊØçË°® $\Sigma_{DNA} = \{A, T, C, G\}$ÔºåÂÖ∂‰∏≠Ôºö

- A (ËÖ∫ÂòåÂë§) ‰∏é T (ËÉ∏ËÖ∫ÂòßÂï∂) ÈÖçÂØπ
- C (ËÉûÂòßÂï∂) ‰∏é G (È∏üÂòåÂë§) ÈÖçÂØπ

**ÂÆö‰πâ 2.1.2** (DNA‰∫íË°•ÊÄß)
DNAÂ∫èÂàó $S = s_1s_2\cdots s_n$ ÁöÑ‰∫íË°•Â∫èÂàó‰∏∫Ôºö
$$S^c = c(s_1)c(s_2)\cdots c(s_n)$$
ÂÖ∂‰∏≠ $c(A) = T, c(T) = A, c(C) = G, c(G) = C$„ÄÇ

**ÂÆö‰πâ 2.1.3** (DNAÂõûÊñá)
DNAÂ∫èÂàó $S$ ÊòØÂõûÊñáÔºåÂΩì‰∏î‰ªÖÂΩì $S = S^c$„ÄÇ

### 2.2 ËõãÁôΩË¥®ËØ≠Ë®Ä

**ÂÆö‰πâ 2.2.1** (ËõãÁôΩË¥®Â≠óÊØçË°®)
ËõãÁôΩË¥®Â≠óÊØçË°® $\Sigma_{Protein}$ ÂåÖÂê´20ÁßçÊ†áÂáÜÊ∞®Âü∫ÈÖ∏Ôºö
$$\Sigma_{Protein} = \{A, R, N, D, C, Q, E, G, H, I, L, K, M, F, P, S, T, W, Y, V\}$$

**ÂÆö‰πâ 2.2.2** (Ê∞®Âü∫ÈÖ∏ÊÄßË¥®)
Ê∞®Âü∫ÈÖ∏ÂÖ∑ÊúâÂ§öÁßçÊÄßË¥®Ôºö

- ÁñèÊ∞¥ÊÄß/‰∫≤Ê∞¥ÊÄß
- ÁîµËç∑ÊÄßË¥®
- ÂàÜÂ≠êÈáè
- ‰æßÈìæÁªìÊûÑ

**ÂÆö‰πâ 2.2.3** (ËõãÁôΩË¥®ÁªìÊûÑ)
ËõãÁôΩË¥®ÁªìÊûÑÂàÜ‰∏∫Âõõ‰∏™Â±ÇÊ¨°Ôºö

- ‰∏ÄÁ∫ßÁªìÊûÑÔºöÊ∞®Âü∫ÈÖ∏Â∫èÂàó
- ‰∫åÁ∫ßÁªìÊûÑÔºöŒ±Ëû∫Êóã„ÄÅŒ≤ÊäòÂè†
- ‰∏âÁ∫ßÁªìÊûÑÔºöÁ©∫Èó¥ÊûÑË±°
- ÂõõÁ∫ßÁªìÊûÑÔºö‰∫öÂü∫ÁªÑË£Ö

### 2.3 ÁîüÁâ©ËØ≠Ê≥ï

**ÂÆö‰πâ 2.3.1** (ÁîüÁâ©Ê≠£ÂàôË°®ËææÂºè)
ÁîüÁâ©Ê≠£ÂàôË°®ËææÂºèÁî®‰∫éÊèèËø∞ÁîüÁâ©Â∫èÂàóÊ®°ÂºèÔºö

- $[ATCG]$Ôºö‰ªªÊÑèÊ†∏Ëã∑ÈÖ∏
- $[AT]^+$Ôºö‰∏Ä‰∏™ÊàñÂ§ö‰∏™AÊàñT
- $(ATCG){3}$ÔºöÊÅ∞Â•Ω3‰∏™Ê†∏Ëã∑ÈÖ∏
- $(ATCG)*$ÔºöÈõ∂‰∏™ÊàñÂ§ö‰∏™Ê†∏Ëã∑ÈÖ∏

**ÂÆö‰πâ 2.3.2** (ÁîüÁâ©‰∏ä‰∏ãÊñáÊó†ÂÖ≥ÊñáÊ≥ï)
ÁîüÁâ©‰∏ä‰∏ãÊñáÊó†ÂÖ≥ÊñáÊ≥ï $G_B = (V_B, \Sigma_B, R_B, S_B)$ ÂÖ∂‰∏≠Ôºö

- $V_B$ ÊòØÁîüÁâ©ÈùûÁªàÁªìÁ¨¶ÈõÜÂêà
- $\Sigma_B$ ÊòØÁîüÁâ©ÁªàÁªìÁ¨¶ÈõÜÂêà
- $R_B$ ÊòØÁîüÁâ©ÈáçÂÜôËßÑÂàôÈõÜÂêà
- $S_B$ ÊòØÁîüÁâ©ÂºÄÂßãÁ¨¶Âè∑

## 3. ÂÆöÁêÜ‰∏éËØÅÊòé

### 3.1 DNAËØ≠Ë®ÄÁöÑÂü∫Êú¨ÂÆöÁêÜ

**ÂÆöÁêÜ 3.1.1** (DNA‰∫íË°•ÊÄßÂÆöÁêÜ)
ÂØπ‰∫é‰ªªÊÑèDNAÂ∫èÂàó $S$ÔºåÊúâ $(S^c)^c = S$„ÄÇ

**ËØÅÊòé**Ôºö
ËÆæ $S = s_1s_2\cdots s_n$ÔºåÂàôÔºö
$$S^c = c(s_1)c(s_2)\cdots c(s_n)$$
$$(S^c)^c = c(c(s_1))c(c(s_2))\cdots c(c(s_n)) = s_1s_2\cdots s_n = S$$

**ÂÆöÁêÜ 3.1.2** (DNAÂõûÊñáËØÜÂà´)
DNAÂ∫èÂàó $S$ ÊòØÂõûÊñáÂΩì‰∏î‰ªÖÂΩì $S = S^R$ÔºåÂÖ∂‰∏≠ $S^R$ ÊòØ $S$ ÁöÑÂèçËΩ¨„ÄÇ

**ËØÅÊòé**Ôºö
Â¶ÇÊûú $S$ ÊòØÂõûÊñáÔºåÂàô $S = S^c$„ÄÇ
Áî±‰∫é $S^c = S^R$Ôºà‰∫íË°•Â∫èÂàóÁ≠â‰∫éÂèçËΩ¨Â∫èÂàóÔºâÔºåÊâÄ‰ª• $S = S^R$„ÄÇ
Âèç‰πãÔºåÂ¶ÇÊûú $S = S^R$ÔºåÂàô $S = S^c$ÔºåÊâÄ‰ª• $S$ ÊòØÂõûÊñá„ÄÇ

### 3.2 ÁîüÁâ©Â∫èÂàóÂàÜÊûêÂÆöÁêÜ

**ÂÆöÁêÜ 3.2.1** (ÊúÄÈïøÂÖ¨ÂÖ±Â≠êÂ∫èÂàó)
‰∏§‰∏™ÁîüÁâ©Â∫èÂàóÁöÑÊúÄÈïøÂÖ¨ÂÖ±Â≠êÂ∫èÂàóÂèØ‰ª•ÈÄöËøáÂä®ÊÄÅËßÑÂàíÁÆóÊ≥ïÂú® $O(mn)$ Êó∂Èó¥ÂÜÖËÆ°ÁÆó„ÄÇ

**ËØÅÊòé**Ôºö
ËÆæ $S_1$ Âíå $S_2$ ÊòØ‰∏§‰∏™Â∫èÂàóÔºåÈïøÂ∫¶ÂàÜÂà´‰∏∫ $m$ Âíå $n$„ÄÇ
ÂÆö‰πâ $LCS(i,j)$ ‰∏∫ $S_1[1..i]$ Âíå $S_2[1..j]$ ÁöÑÊúÄÈïøÂÖ¨ÂÖ±Â≠êÂ∫èÂàóÈïøÂ∫¶„ÄÇ
ÈÄíÊé®ÂÖ≥Á≥ªÔºö
$$LCS(i,j) = \begin{cases}
0 & \text{if } i=0 \text{ or } j=0 \\
LCS(i-1,j-1) + 1 & \text{if } S_1[i] = S_2[j] \\
\max(LCS(i-1,j), LCS(i,j-1)) & \text{otherwise}
\end{cases}$$

**ÂÆöÁêÜ 3.2.2** (Â∫èÂàóÁõ∏‰ººÊÄßÂ∫¶Èáè)
Â∫èÂàóÁõ∏‰ººÊÄßÂèØ‰ª•ÈÄöËøáÁºñËæëË∑ùÁ¶ª„ÄÅÂ∫èÂàóÊØîÂØπÂæóÂàÜÁ≠âÊñπÊ≥ïÂ∫¶Èáè„ÄÇ

## 4. ‰ª£Á†ÅÂÆûÁé∞

### 4.1 DNAÂ∫èÂàóÂ§ÑÁêÜ

```rust
use std::collections::HashMap;

/// DNAÊ†∏Ëã∑ÈÖ∏Êûö‰∏æ
# [derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
enum Nucleotide {
    A, T, C, G,
}

impl Nucleotide {
    /// Ëé∑Âèñ‰∫íË°•Ê†∏Ëã∑ÈÖ∏
    fn complement(&self) -> Nucleotide {
        match self {
            Nucleotide::A => Nucleotide::T,
            Nucleotide::T => Nucleotide::A,
            Nucleotide::C => Nucleotide::G,
            Nucleotide::G => Nucleotide::C,
        }
    }

    /// ‰ªéÂ≠óÁ¨¶ÂàõÂª∫Ê†∏Ëã∑ÈÖ∏
    fn from_char(c: char) -> Option<Nucleotide> {
        match c.to_ascii_uppercase() {
            'A' => Some(Nucleotide::A),
            'T' => Some(Nucleotide::T),
            'C' => Some(Nucleotide::C),
            'G' => Some(Nucleotide::G),
            _ => None,
        }
    }

    /// ËΩ¨Êç¢‰∏∫Â≠óÁ¨¶
    fn to_char(&self) -> char {
        match self {
            Nucleotide::A => 'A',
            Nucleotide::T => 'T',
            Nucleotide::C => 'C',
            Nucleotide::G => 'G',
        }
    }
}

/// DNAÂ∫èÂàó
# [derive(Debug, Clone)]
struct DNASequence {
    nucleotides: Vec<Nucleotide>,
}

impl DNASequence {
    /// ‰ªéÂ≠óÁ¨¶‰∏≤ÂàõÂª∫DNAÂ∫èÂàó
    fn from_string(s: &str) -> Result<Self, String> {
        let nucleotides: Result<Vec<Nucleotide>, _> = s
            .chars()
            .map(Nucleotide::from_char)
            .collect();

        match nucleotides {
            Ok(nucs) => Ok(DNASequence { nucleotides: nucs }),
            Err(_) => Err("Invalid DNA sequence".to_string()),
        }
    }

    /// Ëé∑ÂèñÂ∫èÂàóÈïøÂ∫¶
    fn length(&self) -> usize {
        self.nucleotides.len()
    }

    /// Ëé∑Âèñ‰∫íË°•Â∫èÂàó
    fn complement(&self) -> DNASequence {
        let comp_nucleotides: Vec<Nucleotide> = self.nucleotides
            .iter()
            .map(|n| n.complement())
            .collect();
        DNASequence { nucleotides: comp_nucleotides }
    }

    /// Ëé∑ÂèñÂèçÂêë‰∫íË°•Â∫èÂàó
    fn reverse_complement(&self) -> DNASequence {
        let mut comp = self.complement();
        comp.nucleotides.reverse();
        comp
    }

    /// Ê£ÄÊü•ÊòØÂê¶‰∏∫ÂõûÊñá
    fn is_palindrome(&self) -> bool {
        self.nucleotides == self.reverse_complement().nucleotides
    }

    /// ËÆ°ÁÆóGCÂê´Èáè
    fn gc_content(&self) -> f64 {
        let gc_count = self.nucleotides
            .iter()
            .filter(|&&n| n == Nucleotide::G || n == Nucleotide::C)
            .count();
        gc_count as f64 / self.length() as f64
    }

    /// Êü•ÊâæÂ≠êÂ∫èÂàó
    fn find_subsequence(&self, pattern: &DNASequence) -> Vec<usize> {
        let mut positions = Vec::new();
        let pattern_len = pattern.length();

        for i in 0..=self.length() - pattern_len {
            if self.nucleotides[i..i + pattern_len] == pattern.nucleotides {
                positions.push(i);
            }
        }

        positions
    }

    /// ËΩ¨Êç¢‰∏∫Â≠óÁ¨¶‰∏≤
    fn to_string(&self) -> String {
        self.nucleotides.iter().map(|n| n.to_char()).collect()
    }
}
```

### 4.2 ËõãÁôΩË¥®Â∫èÂàóÂ§ÑÁêÜ

```rust
/// Ê∞®Âü∫ÈÖ∏Êûö‰∏æ
# [derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
enum AminoAcid {
    A, R, N, D, C, Q, E, G, H, I, L, K, M, F, P, S, T, W, Y, V,
}

impl AminoAcid {
    /// ‰ªéÂ≠óÁ¨¶ÂàõÂª∫Ê∞®Âü∫ÈÖ∏
    fn from_char(c: char) -> Option<AminoAcid> {
        match c.to_ascii_uppercase() {
            'A' => Some(AminoAcid::A),
            'R' => Some(AminoAcid::R),
            'N' => Some(AminoAcid::N),
            'D' => Some(AminoAcid::D),
            'C' => Some(AminoAcid::C),
            'Q' => Some(AminoAcid::Q),
            'E' => Some(AminoAcid::E),
            'G' => Some(AminoAcid::G),
            'H' => Some(AminoAcid::H),
            'I' => Some(AminoAcid::I),
            'L' => Some(AminoAcid::L),
            'K' => Some(AminoAcid::K),
            'M' => Some(AminoAcid::M),
            'F' => Some(AminoAcid::F),
            'P' => Some(AminoAcid::P),
            'S' => Some(AminoAcid::S),
            'T' => Some(AminoAcid::T),
            'W' => Some(AminoAcid::W),
            'Y' => Some(AminoAcid::Y),
            'V' => Some(AminoAcid::V),
            _ => None,
        }
    }

    /// Ëé∑ÂèñÁñèÊ∞¥ÊÄßÂÄº
    fn hydrophobicity(&self) -> f64 {
        match self {
            AminoAcid::A => 1.8,
            AminoAcid::R => -4.5,
            AminoAcid::N => -3.5,
            AminoAcid::D => -3.5,
            AminoAcid::C => 2.5,
            AminoAcid::Q => -3.5,
            AminoAcid::E => -3.5,
            AminoAcid::G => -0.4,
            AminoAcid::H => -3.2,
            AminoAcid::I => 4.5,
            AminoAcid::L => 3.8,
            AminoAcid::K => -3.9,
            AminoAcid::M => 1.9,
            AminoAcid::F => 2.8,
            AminoAcid::P => -1.6,
            AminoAcid::S => -0.8,
            AminoAcid::T => -0.7,
            AminoAcid::W => -0.9,
            AminoAcid::Y => -1.3,
            AminoAcid::V => 4.2,
        }
    }

    /// Ëé∑ÂèñÂàÜÂ≠êÈáè
    fn molecular_weight(&self) -> f64 {
        match self {
            AminoAcid::A => 89.1,
            AminoAcid::R => 174.2,
            AminoAcid::N => 132.1,
            AminoAcid::D => 133.1,
            AminoAcid::C => 121.2,
            AminoAcid::Q => 146.2,
            AminoAcid::E => 147.1,
            AminoAcid::G => 75.1,
            AminoAcid::H => 155.2,
            AminoAcid::I => 131.2,
            AminoAcid::L => 131.2,
            AminoAcid::K => 146.2,
            AminoAcid::M => 149.2,
            AminoAcid::F => 165.2,
            AminoAcid::P => 115.1,
            AminoAcid::S => 105.1,
            AminoAcid::T => 119.1,
            AminoAcid::W => 204.2,
            AminoAcid::Y => 181.2,
            AminoAcid::V => 117.1,
        }
    }
}

/// ËõãÁôΩË¥®Â∫èÂàó
# [derive(Debug, Clone)]
struct ProteinSequence {
    amino_acids: Vec<AminoAcid>,
}

impl ProteinSequence {
    /// ‰ªéÂ≠óÁ¨¶‰∏≤ÂàõÂª∫ËõãÁôΩË¥®Â∫èÂàó
    fn from_string(s: &str) -> Result<Self, String> {
        let amino_acids: Result<Vec<AminoAcid>, _> = s
            .chars()
            .map(AminoAcid::from_char)
            .collect();

        match amino_acids {
            Ok(aas) => Ok(ProteinSequence { amino_acids: aas }),
            Err(_) => Err("Invalid protein sequence".to_string()),
        }
    }

    /// Ëé∑ÂèñÂ∫èÂàóÈïøÂ∫¶
    fn length(&self) -> usize {
        self.amino_acids.len()
    }

    /// ËÆ°ÁÆóÂàÜÂ≠êÈáè
    fn molecular_weight(&self) -> f64 {
        self.amino_acids.iter().map(|aa| aa.molecular_weight()).sum()
    }

    /// ËÆ°ÁÆóÂπ≥ÂùáÁñèÊ∞¥ÊÄß
    fn average_hydrophobicity(&self) -> f64 {
        let total: f64 = self.amino_acids.iter().map(|aa| aa.hydrophobicity()).sum();
        total / self.length() as f64
    }

    /// ËÆ°ÁÆóÊ∞®Âü∫ÈÖ∏ÁªÑÊàê
    fn amino_acid_composition(&self) -> HashMap<AminoAcid, f64> {
        let mut composition = HashMap::new();
        let total = self.length() as f64;

        for aa in &self.amino_acids {
            *composition.entry(*aa).or_insert(0.0) += 1.0;
        }

        for count in composition.values_mut() {
            *count /= total;
        }

        composition
    }
}
```

### 4.3 Â∫èÂàóÊØîÂØπÁÆóÊ≥ï

```rust
/// Â∫èÂàóÊØîÂØπÁªìÊûú
# [derive(Debug)]
struct Alignment {
    sequence1: String,
    sequence2: String,
    score: i32,
}

/// Â∫èÂàóÊØîÂØπÂô®
struct SequenceAligner {
    match_score: i32,
    mismatch_penalty: i32,
    gap_penalty: i32,
}

impl SequenceAligner {
    fn new(match_score: i32, mismatch_penalty: i32, gap_penalty: i32) -> Self {
        SequenceAligner {
            match_score,
            mismatch_penalty,
            gap_penalty,
        }
    }

    /// ÂÖ®Â±ÄÂ∫èÂàóÊØîÂØπ
    fn global_align(&self, seq1: &str, seq2: &str) -> Alignment {
        let len1 = seq1.len();
        let len2 = seq2.len();

        // ÂàõÂª∫Âä®ÊÄÅËßÑÂàíÁü©Èòµ
        let mut dp = vec![vec![0; len2 + 1]; len1 + 1];

        // ÂàùÂßãÂåñÁ¨¨‰∏ÄË°åÂíåÁ¨¨‰∏ÄÂàó
        for i in 0..=len1 {
            dp[i][0] = i as i32 * self.gap_penalty;
        }
        for j in 0..=len2 {
            dp[0][j] = j as i32 * self.gap_penalty;
        }

        // Â°´ÂÖÖÂä®ÊÄÅËßÑÂàíÁü©Èòµ
        for i in 1..=len1 {
            for j in 1..=len2 {
                let match_score = if seq1.chars().nth(i - 1) == seq2.chars().nth(j - 1) {
                    self.match_score
                } else {
                    self.mismatch_penalty
                };

                dp[i][j] = (dp[i-1][j-1] + match_score)
                    .max(dp[i-1][j] + self.gap_penalty)
                    .max(dp[i][j-1] + self.gap_penalty);
            }
        }

        // ÂõûÊ∫ØÊûÑÂª∫ÊØîÂØπÁªìÊûú
        let (aligned_seq1, aligned_seq2) = self.backtrack(&dp, seq1, seq2);

        Alignment {
            sequence1: aligned_seq1,
            sequence2: aligned_seq2,
            score: dp[len1][len2],
        }
    }

    /// ÂõûÊ∫ØÊûÑÂª∫ÊØîÂØπÂ∫èÂàó
    fn backtrack(&self, dp: &[Vec<i32>], seq1: &str, seq2: &str) -> (String, String) {
        let mut i = seq1.len();
        let mut j = seq2.len();
        let mut aligned_seq1 = String::new();
        let mut aligned_seq2 = String::new();

        while i > 0 || j > 0 {
            if i > 0 && j > 0 && dp[i][j] == dp[i-1][j-1] +
                if seq1.chars().nth(i-1) == seq2.chars().nth(j-1) { self.match_score } else { self.mismatch_penalty } {
                aligned_seq1.insert(0, seq1.chars().nth(i-1).unwrap());
                aligned_seq2.insert(0, seq2.chars().nth(j-1).unwrap());
                i -= 1;
                j -= 1;
            } else if i > 0 && dp[i][j] == dp[i-1][j] + self.gap_penalty {
                aligned_seq1.insert(0, seq1.chars().nth(i-1).unwrap());
                aligned_seq2.insert(0, '-');
                i -= 1;
            } else {
                aligned_seq1.insert(0, '-');
                aligned_seq2.insert(0, seq2.chars().nth(j-1).unwrap());
                j -= 1;
            }
        }

        (aligned_seq1, aligned_seq2)
    }
}
```

## 5. Â∫îÁî®Á§∫‰æã

### 5.1 DNAÂ∫èÂàóÂàÜÊûê

```rust
// DNAÂ∫èÂàóÂàÜÊûêÁ§∫‰æã
fn dna_analysis_example() {
    // ÂàõÂª∫DNAÂ∫èÂàó
    let dna = DNASequence::from_string("ATCGATCGATCG").unwrap();

    println!("DNAÂ∫èÂàó: {}", dna.to_string());
    println!("Â∫èÂàóÈïøÂ∫¶: {}", dna.length());
    println!("GCÂê´Èáè: {:.2}%", dna.gc_content() * 100.0);

    // Ëé∑Âèñ‰∫íË°•Â∫èÂàó
    let complement = dna.complement();
    println!("‰∫íË°•Â∫èÂàó: {}", complement.to_string());

    // Ê£ÄÊü•ÂõûÊñá
    let palindrome = DNASequence::from_string("ATCGAT").unwrap();
    println!("Â∫èÂàó {} ÊòØÂõûÊñá: {}", palindrome.to_string(), palindrome.is_palindrome());

    // Êü•ÊâæÂ≠êÂ∫èÂàó
    let pattern = DNASequence::from_string("ATC").unwrap();
    let positions = dna.find_subsequence(&pattern);
    println!("Ê®°Âºè {} Âú®‰ΩçÁΩÆ: {:?}", pattern.to_string(), positions);
}

// ËõãÁôΩË¥®Â∫èÂàóÂàÜÊûêÁ§∫‰æã
fn protein_analysis_example() {
    // ÂàõÂª∫ËõãÁôΩË¥®Â∫èÂàó
    let protein = ProteinSequence::from_string("MKTVRQERLKSIVRILERSKEPVSGAQLAEELSVSRQVIVQDIAYLRSLGYNIVATPRGYVLAGG").unwrap();

    println!("ËõãÁôΩË¥®Â∫èÂàóÈïøÂ∫¶: {}", protein.length());
    println!("ÂàÜÂ≠êÈáè: {:.2} Da", protein.molecular_weight());
    println!("Âπ≥ÂùáÁñèÊ∞¥ÊÄß: {:.2}", protein.average_hydrophobicity());

    // Ê∞®Âü∫ÈÖ∏ÁªÑÊàê
    let composition = protein.amino_acid_composition();
    println!("Ê∞®Âü∫ÈÖ∏ÁªÑÊàê:");
    for (aa, freq) in composition {
        println!("  {}: {:.3}", format!("{:?}", aa), freq);
    }
}

// Â∫èÂàóÊØîÂØπÁ§∫‰æã
fn sequence_alignment_example() {
    let aligner = SequenceAligner::new(1, -1, -2);

    let seq1 = "ATCGATCG";
    let seq2 = "ATCGATCC";

    let alignment = aligner.global_align(seq1, seq2);

    println!("Â∫èÂàóÊØîÂØπÁªìÊûú:");
    println!("Â∫èÂàó1: {}", alignment.sequence1);
    println!("Â∫èÂàó2: {}", alignment.sequence2);
    println!("ÊØîÂØπÂæóÂàÜ: {}", alignment.score);
}
```

### 5.2 ÁîüÁâ©‰ø°ÊÅØÂ§ÑÁêÜ

```rust
/// ÁîüÁâ©Â∫èÂàóÊï∞ÊçÆÂ∫ì
struct SequenceDatabase {
    sequences: HashMap<String, DNASequence>,
}

impl SequenceDatabase {
    fn new() -> Self {
        SequenceDatabase {
            sequences: HashMap::new(),
        }
    }

    /// Ê∑ªÂä†Â∫èÂàó
    fn add_sequence(&mut self, name: String, sequence: DNASequence) {
        self.sequences.insert(name, sequence);
    }

    /// ÊêúÁ¥¢Áõ∏‰ººÂ∫èÂàó
    fn search_similar(&self, query: &DNASequence, threshold: f64) -> Vec<(String, f64)> {
        let mut results = Vec::new();

        for (name, sequence) in &self.sequences {
            let similarity = self.calculate_similarity(query, sequence);
            if similarity >= threshold {
                results.push((name.clone(), similarity));
            }
        }

        results.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
        results
    }

    /// ËÆ°ÁÆóÂ∫èÂàóÁõ∏‰ººÊÄß
    fn calculate_similarity(&self, seq1: &DNASequence, seq2: &DNASequence) -> f64 {
        let aligner = SequenceAligner::new(1, -1, -2);
        let alignment = aligner.global_align(&seq1.to_string(), &seq2.to_string());

        let max_len = seq1.length().max(seq2.length());
        alignment.score as f64 / max_len as f64
    }
}

// ‰ΩøÁî®Á§∫‰æã
fn database_search_example() {
    let mut db = SequenceDatabase::new();

    // Ê∑ªÂä†‰∏Ä‰∫õÂ∫èÂàó
    db.add_sequence("seq1".to_string(), DNASequence::from_string("ATCGATCG").unwrap());
    db.add_sequence("seq2".to_string(), DNASequence::from_string("ATCGATCC").unwrap());
    db.add_sequence("seq3".to_string(), DNASequence::from_string("GCTAGCTA").unwrap());

    // ÊêúÁ¥¢Áõ∏‰ººÂ∫èÂàó
    let query = DNASequence::from_string("ATCGATCG").unwrap();
    let results = db.search_similar(&query, 0.8);

    println!("Áõ∏‰ººÂ∫èÂàóÊêúÁ¥¢ÁªìÊûú:");
    for (name, similarity) in results {
        println!("  {}: {:.3}", name, similarity);
    }
}
```

## 6. Áõ∏ÂÖ≥ÁêÜËÆ∫

### 6.1 ‰∏éÂΩ¢ÂºèËØ≠Ë®ÄÁêÜËÆ∫ÁöÑÂÖ≥Á≥ª

ÁîüÁâ©ËØ≠Ë®Ä‰∏éÁªèÂÖ∏ÂΩ¢ÂºèËØ≠Ë®ÄÁêÜËÆ∫ÁöÑÂÖ≥Á≥ªÔºö

1. **Â≠óÊØçË°®Êâ©Â±ï**ÔºöÁîüÁâ©ËØ≠Ë®Ä‰ΩøÁî®ÁâπÊÆäÁöÑÂ≠óÊØçË°®ÔºàDNA„ÄÅËõãÁôΩË¥®Ôºâ
2. **ÁîüÁâ©Â≠¶Á∫¶Êùü**ÔºöÁîüÁâ©ËØ≠Ë®ÄÈÅµÂæ™ÁîüÁâ©Â≠¶ËßÑÂæãÂíåËøõÂåñÁ∫¶Êùü
3. **Â∫èÂàóÊ®°Âºè**ÔºöÁîüÁâ©ËØ≠Ë®ÄÂåÖÂê´ÁâπÂÆöÁöÑÂ∫èÂàóÊ®°ÂºèÂíåÁªìÊûÑ
4. **ÂäüËÉΩËØ≠‰πâ**ÔºöÁîüÁâ©ËØ≠Ë®ÄÂÖ∑ÊúâÁîüÁâ©Â≠¶ÂäüËÉΩËØ≠‰πâ

### 6.2 ‰∏éËÆ°ÁÆóÁêÜËÆ∫ÁöÑÂÖ≥Á≥ª

ÁîüÁâ©ËØ≠Ë®Ä‰∏éËÆ°ÁÆóÁêÜËÆ∫ÁöÑÂÖ≥Á≥ªÔºö

1. **Â∫èÂàóÂàÜÊûêÁÆóÊ≥ï**ÔºöÁîüÁâ©ËØ≠Ë®ÄÈúÄË¶ÅÈ´òÊïàÁöÑÂ∫èÂàóÂàÜÊûêÁÆóÊ≥ï
2. **Ê®°ÂºèÂåπÈÖç**ÔºöÁîüÁâ©ËØ≠Ë®Ä‰∏≠ÁöÑÊ®°ÂºèÂåπÈÖçÂíåÊêúÁ¥¢
3. **Êú∫Âô®Â≠¶‰π†**ÔºöÁîüÁâ©ËØ≠Ë®ÄÂú®Êú∫Âô®Â≠¶‰π†‰∏≠ÁöÑÂ∫îÁî®
4. **Êï∞ÊçÆÂ∫ìÁêÜËÆ∫**ÔºöÁîüÁâ©Â∫èÂàóÊï∞ÊçÆÂ∫ìÁöÑËÆæËÆ°ÂíåÊü•ËØ¢

### 6.3 ‰∏é‰ø°ÊÅØËÆ∫ÁöÑÂÖ≥Á≥ª

ÁîüÁâ©ËØ≠Ë®Ä‰∏é‰ø°ÊÅØËÆ∫ÁöÑÂÖ≥Á≥ªÔºö

1. **‰ø°ÊÅØÁºñÁ†Å**ÔºöDNA‰Ωú‰∏∫‰ø°ÊÅØÁºñÁ†ÅÁ≥ªÁªü
2. **‰ø°ÊÅØÂéãÁº©**ÔºöÁîüÁâ©Â∫èÂàóÁöÑÂéãÁº©ÂíåÂ≠òÂÇ®
3. **‰ø°ÊÅØ‰º†Ëæì**ÔºöÁîüÁâ©‰ø°ÊÅØÁöÑ‰º†ÈÄíÂíåÂ§çÂà∂
4. **‰ø°ÊÅØÁÜµ**ÔºöÁîüÁâ©Â∫èÂàóÁöÑ‰ø°ÊÅØÁÜµÂàÜÊûê

## 7. ÂèÇËÄÉÊñáÁåÆ

1. Durbin, R., Eddy, S. R., Krogh, A., & Mitchison, G. (1998). Biological sequence analysis: probabilistic models of proteins and nucleic acids. Cambridge university press.
2. Gusfield, D. (1997). Algorithms on strings, trees, and sequences: computer science and computational biology. Cambridge university press.
3. Mount, D. W. (2004). Bioinformatics: sequence and genome analysis. Cold Spring Harbor Laboratory Press.
4. Pevzner, P. A. (2000). Computational molecular biology: an algorithmic approach. MIT press.
5. Waterman, M. S. (1995). Introduction to computational biology: maps, sequences and genomes. CRC press.

---

**Áõ∏ÂÖ≥ÊñáÊ°£**Ôºö
- [03.1.1 ÊúâÈôêËá™Âä®Êú∫](../03.1.1_ÊúâÈôêËá™Âä®Êú∫.md)
- [03.2.1 Ê≠£ÂàôÊñáÊ≥ï](../03.2.1_Ê≠£ÂàôÊñáÊ≥ï.md)
- [03.3.1 ‰πîÂßÜÊñØÂü∫Ë∞±Á≥ª](../03.3.1_‰πîÂßÜÊñØÂü∫Ë∞±Á≥ª.md)
- [03.6.3 ÁÆóÊ≥ïÂàÜÊûê](./03.6.3_ÁÆóÊ≥ïÂàÜÊûê.md)
