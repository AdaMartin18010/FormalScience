# 03.4.3 é€’å½’ä¸‹é™è§£æ

## ğŸ“‹ æ¦‚è¿°

é€’å½’ä¸‹é™è§£ææ˜¯ä¸€ç§è‡ªé¡¶å‘ä¸‹çš„è¯­æ³•åˆ†ææ–¹æ³•ï¼Œé€šè¿‡ä¸ºæ¯ä¸ªéç»ˆç»“ç¬¦ç¼–å†™ä¸€ä¸ªé€’å½’å‡½æ•°æ¥å®ç°è§£æã€‚è¿™ç§æ–¹æ³•ç›´è§‚æ˜“æ‡‚ï¼Œé€‚åˆæ‰‹å·¥å®ç°ï¼Œæ˜¯LL(1)è§£æçš„ä¸€ç§å…·ä½“å®ç°æ–¹å¼ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å½¢å¼åŒ–é€’å½’ä¸‹é™ç®—æ³•**ï¼šå»ºç«‹ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œç®—æ³•æè¿°
2. **LL(1)æ–‡æ³•åˆ†æ**ï¼šå®šä¹‰LL(1)æ–‡æ³•çš„æ€§è´¨å’Œæ„é€ æ–¹æ³•
3. **é¢„æµ‹è§£æè¡¨æ„é€ **ï¼šå»ºç«‹FIRSTé›†ã€FOLLOWé›†å’Œé¢„æµ‹è§£æè¡¨
4. **å®ç°éªŒè¯**ï¼šæä¾›å®Œæ•´çš„Rustå®ç°å’Œå½¢å¼åŒ–è¯æ˜

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 é€’å½’ä¸‹é™è§£æçš„åŸºæœ¬æ€æƒ³

é€’å½’ä¸‹é™è§£æçš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š

1. **è‡ªé¡¶å‘ä¸‹**ï¼šä»å¼€å§‹ç¬¦å·å¼€å§‹ï¼Œé€æ­¥æ¨å¯¼åˆ°è¾“å…¥ä¸²
2. **é€’å½’å‡½æ•°**ï¼šä¸ºæ¯ä¸ªéç»ˆç»“ç¬¦ç¼–å†™ä¸€ä¸ªé€’å½’å‡½æ•°
3. **é¢„æµ‹è§£æ**ï¼šæ ¹æ®å½“å‰è¾“å…¥ç¬¦å·é¢„æµ‹ä½¿ç”¨å“ªä¸ªäº§ç”Ÿå¼
4. **å›æº¯é¿å…**ï¼šé€šè¿‡LL(1)æ€§è´¨é¿å…å›æº¯

### 1.2 é€’å½’ä¸‹é™è§£æå™¨çš„ç»“æ„

**å®šä¹‰ 1.2.1 (é€’å½’ä¸‹é™è§£æå™¨ç»“æ„)**
é€’å½’ä¸‹é™è§£æå™¨æ˜¯ä¸€ä¸ªå››å…ƒç»„ $\mathcal{P} = (G, \mathcal{F}, \mathcal{T}, \text{parse})$ï¼Œå…¶ä¸­ï¼š

- $G$ æ˜¯LL(1)æ–‡æ³•
- $\mathcal{F}$ æ˜¯è§£æå‡½æ•°é›†åˆ
- $\mathcal{T}$ æ˜¯é¢„æµ‹è§£æè¡¨
- $\text{parse}$ æ˜¯ä¸»è§£æå‡½æ•°

### 1.3 è§£æè¿‡ç¨‹

**å®šä¹‰ 1.2.2 (è§£æé…ç½®)**
é€’å½’ä¸‹é™è§£æçš„é…ç½®æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(A, \alpha, \beta)$ï¼Œå…¶ä¸­ï¼š

- $A$ æ˜¯å½“å‰éç»ˆç»“ç¬¦
- $\alpha$ æ˜¯å·²åŒ¹é…çš„è¾“å…¥å‰ç¼€
- $\beta$ æ˜¯å‰©ä½™è¾“å…¥

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 LL(1)æ–‡æ³•

**å®šä¹‰ 2.1.1 (LL(1)æ–‡æ³•)**
æ–‡æ³• $G$ æ˜¯LL(1)æ–‡æ³•ï¼Œå½“ä¸”ä»…å½“å¯¹äºä»»æ„éç»ˆç»“ç¬¦ $A$ å’Œä»»æ„äº§ç”Ÿå¼ $A \rightarrow \alpha$ å’Œ $A \rightarrow \beta$ï¼Œæœ‰ï¼š
$$\text{FIRST}(\alpha) \cap \text{FIRST}(\beta) = \emptyset$$

**å®šä¹‰ 2.1.2 (FIRSTé›†)**
å¯¹äºç¬¦å·ä¸² $\alpha$ï¼ŒFIRSTé›†å®šä¹‰ä¸ºï¼š
$$\text{FIRST}(\alpha) = \{a \in \Sigma \mid \alpha \Rightarrow^* a\beta\} \cup \{\varepsilon \mid \alpha \Rightarrow^* \varepsilon\}$$

**å®šä¹‰ 2.1.3 (FOLLOWé›†)**
å¯¹äºéç»ˆç»“ç¬¦ $A$ï¼ŒFOLLOWé›†å®šä¹‰ä¸ºï¼š
$$\text{FOLLOW}(A) = \{a \in \Sigma \mid S \Rightarrow^* \alpha Aa\beta\} \cup \{\$ \mid S \Rightarrow^* \alpha A\}$$

### 2.2 é¢„æµ‹è§£æè¡¨

**å®šä¹‰ 2.2.1 (é¢„æµ‹è§£æè¡¨)**
é¢„æµ‹è§£æè¡¨ $M$ æ˜¯ä¸€ä¸ªäºŒç»´è¡¨ï¼Œå…¶ä¸­ $M[A, a]$ åŒ…å«äº§ç”Ÿå¼ $A \rightarrow \alpha$ï¼Œå½“ä¸”ä»…å½“ï¼š
$$a \in \text{FIRST}(\alpha) \text{ æˆ– } (a \in \text{FOLLOW}(A) \text{ ä¸” } \varepsilon \in \text{FIRST}(\alpha))$$

**ç®—æ³• 2.2.1 (é¢„æµ‹è§£æè¡¨æ„é€ )**

```rust
fn construct_predictive_table(grammar: &Grammar) -> PredictiveTable {
    let mut table = HashMap::new();
    
    for production in &grammar.productions {
        let first_set = grammar.first(&production.rhs);
        
        for terminal in first_set {
            if terminal != "Îµ" {
                table.insert((production.lhs.clone(), terminal), production.clone());
            }
        }
        
        if first_set.contains("Îµ") {
            let follow_set = grammar.follow(&production.lhs);
            for terminal in follow_set {
                table.insert((production.lhs.clone(), terminal), production.clone());
            }
        }
    }
    
    PredictiveTable { table }
}
```

### 2.3 é€’å½’ä¸‹é™è§£æç®—æ³•

**ç®—æ³• 2.3.1 (é€’å½’ä¸‹é™è§£æ)**

```rust
fn recursive_descent_parse(grammar: &Grammar, input: &[String]) -> Result<ParseTree, String> {
    let mut parser = RecursiveDescentParser::new(grammar);
    parser.parse(input)
}
```

## 3. å®šç†ä¸è¯æ˜

### 3.1 LL(1)æ–‡æ³•çš„æ€§è´¨

**å®šç† 3.1.1 (LL(1)æ–‡æ³•æ— æ­§ä¹‰æ€§)**
å¦‚æœæ–‡æ³• $G$ æ˜¯LL(1)æ–‡æ³•ï¼Œåˆ™ $G$ æ˜¯æ— æ­§ä¹‰çš„ã€‚

**è¯æ˜ï¼š**

1. **å‡è®¾**ï¼šå‡è®¾ $G$ æœ‰æ­§ä¹‰ï¼Œå­˜åœ¨ä¸¤ä¸ªä¸åŒçš„æœ€å·¦æ¨å¯¼
2. **çŸ›ç›¾**ï¼šLL(1)æ€§è´¨ç¡®ä¿åœ¨æ¯ä¸€æ­¥éƒ½æœ‰å”¯ä¸€çš„é€‰æ‹©
3. **ç»“è®º**ï¼šå› æ­¤ $G$ æ— æ­§ä¹‰

**å®šç† 3.1.2 (LL(1)è§£ææ­£ç¡®æ€§)**
å¦‚æœæ–‡æ³• $G$ æ˜¯LL(1)æ–‡æ³•ï¼Œåˆ™é€’å½’ä¸‹é™è§£æå™¨èƒ½å¤Ÿæ­£ç¡®è¯†åˆ« $L(G)$ ä¸­çš„æ‰€æœ‰å¥å­ã€‚

**è¯æ˜ï¼š**
é€šè¿‡å½’çº³æ³•è¯æ˜ï¼š

1. **åŸºç¡€æƒ…å†µ**ï¼šç©ºä¸²çš„è§£æ
2. **å½’çº³æ­¥éª¤**ï¼šå‡è®¾å¯¹äºé•¿åº¦å°äº $n$ çš„ä¸²æˆç«‹ï¼Œè¯æ˜å¯¹äºé•¿åº¦ä¸º $n$ çš„ä¸²ä¹Ÿæˆç«‹
3. **é¢„æµ‹æ­£ç¡®æ€§**ï¼šé¢„æµ‹è§£æè¡¨ç¡®ä¿é€‰æ‹©æ­£ç¡®çš„äº§ç”Ÿå¼
4. **é€’å½’æ­£ç¡®æ€§**ï¼šé€’å½’è°ƒç”¨ä¿æŒè§£æçš„æ­£ç¡®æ€§

### 3.2 FIRSTé›†å’ŒFOLLOWé›†çš„æ€§è´¨

**å®šç† 3.2.1 (FIRSTé›†æ€§è´¨)**
FIRSTé›†æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š

1. **å•è°ƒæ€§**ï¼šå¦‚æœ $\alpha \Rightarrow^* \beta$ï¼Œåˆ™ $\text{FIRST}(\beta) \subseteq \text{FIRST}(\alpha)$
2. **ä¼ é€’æ€§**ï¼šå¦‚æœ $A \Rightarrow^* B$ ä¸” $B \Rightarrow^* \gamma$ï¼Œåˆ™ $\text{FIRST}(\gamma) \subseteq \text{FIRST}(A)$
3. **ç»„åˆæ€§**ï¼š$\text{FIRST}(\alpha\beta) = \text{FIRST}(\alpha) \cup (\text{FIRST}(\beta) \cap \{\varepsilon\})$

**è¯æ˜ï¼š**

1. **å•è°ƒæ€§**ï¼šé€šè¿‡æ¨å¯¼çš„å®šä¹‰ç›´æ¥å¾—åˆ°
2. **ä¼ é€’æ€§**ï¼šé€šè¿‡æ¨å¯¼çš„ä¼ é€’æ€§å¾—åˆ°
3. **ç»„åˆæ€§**ï¼šé€šè¿‡FIRSTé›†çš„å®šä¹‰å’Œæ¨å¯¼è§„åˆ™å¾—åˆ°

**å®šç† 3.2.2 (FOLLOWé›†æ€§è´¨)**
FOLLOWé›†æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š

1. **å¼€å§‹ç¬¦å·**ï¼š$\$ \in \text{FOLLOW}(S)$
2. **äº§ç”Ÿå¼è§„åˆ™**ï¼šå¦‚æœ $A \rightarrow \alpha B\beta$ï¼Œåˆ™ $\text{FIRST}(\beta) \subseteq \text{FOLLOW}(B)$
3. **ä¼ é€’æ€§**ï¼šå¦‚æœ $A \rightarrow \alpha B$ ä¸” $\varepsilon \in \text{FIRST}(\beta)$ï¼Œåˆ™ $\text{FOLLOW}(A) \subseteq \text{FOLLOW}(B)$

### 3.3 å†²çªæ£€æµ‹

**å®šä¹‰ 3.3.1 (LL(1)å†²çª)**
åœ¨é¢„æµ‹è§£æè¡¨ä¸­å­˜åœ¨å†²çªï¼Œå¦‚æœå­˜åœ¨ï¼š
$$M[A, a] = \{A \rightarrow \alpha, A \rightarrow \beta\} \text{ ä¸” } \alpha \neq \beta$$

**å®šç† 3.3.1 (å†²çªæ£€æµ‹)**
LL(1)å†²çªå¯ä»¥é€šè¿‡æ£€æŸ¥é¢„æµ‹è§£æè¡¨æ¥æ£€æµ‹ã€‚

**è¯æ˜ï¼š**

1. **å†²çªå®šä¹‰**ï¼šå†²çªç­‰ä»·äºé¢„æµ‹è§£æè¡¨ä¸­åŒä¸€ä½ç½®æœ‰å¤šä¸ªäº§ç”Ÿå¼
2. **æ£€æµ‹æ–¹æ³•**ï¼šéå†é¢„æµ‹è§£æè¡¨ï¼Œæ£€æŸ¥æ¯ä¸ªä½ç½®æ˜¯å¦åªæœ‰ä¸€ä¸ªäº§ç”Ÿå¼
3. **å†²çªæŠ¥å‘Š**ï¼šæŠ¥å‘Šæ‰€æœ‰å†²çªä½ç½®å’Œæ¶‰åŠçš„äº§ç”Ÿå¼

## 4. ä»£ç å®ç°

### 4.1 é€’å½’ä¸‹é™è§£æå™¨æ ¸å¿ƒå®ç°

```rust
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone)]
pub struct ParseTree {
    pub node: String,
    pub children: Vec<ParseTree>,
}

impl ParseTree {
    pub fn new(node: String) -> Self {
        Self {
            node,
            children: Vec::new(),
        }
    }
    
    pub fn add_child(&mut self, child: ParseTree) {
        self.children.push(child);
    }
}

#[derive(Debug)]
pub struct RecursiveDescentParser {
    grammar: Grammar,
    predictive_table: PredictiveTable,
    input: Vec<String>,
    position: usize,
}

impl RecursiveDescentParser {
    pub fn new(grammar: Grammar) -> Self {
        let predictive_table = Self::construct_predictive_table(&grammar);
        Self {
            grammar,
            predictive_table,
            input: Vec::new(),
            position: 0,
        }
    }
    
    pub fn parse(&mut self, input: &[String]) -> Result<ParseTree, String> {
        self.input = input.to_vec();
        self.position = 0;
        
        let tree = self.parse_nonterminal(&self.grammar.start_symbol)?;
        
        if self.position < self.input.len() {
            return Err(format!("Unexpected input at position {}", self.position));
        }
        
        Ok(tree)
    }
    
    fn parse_nonterminal(&mut self, nonterminal: &str) -> Result<ParseTree, String> {
        let current_input = self.current_input();
        let production = self.predictive_table.get(nonterminal, &current_input)
            .ok_or_else(|| format!("No production for {} with input {}", nonterminal, current_input))?;
        
        let mut tree = ParseTree::new(nonterminal.to_string());
        
        for symbol in &production.rhs {
            match symbol {
                Symbol::Terminal(term) => {
                    if self.current_input() == term {
                        tree.add_child(ParseTree::new(term.clone()));
                        self.advance();
                    } else {
                        return Err(format!("Expected {}, got {}", term, self.current_input()));
                    }
                }
                Symbol::NonTerminal(nt) => {
                    let child_tree = self.parse_nonterminal(nt)?;
                    tree.add_child(child_tree);
                }
            }
        }
        
        Ok(tree)
    }
    
    fn current_input(&self) -> String {
        if self.position < self.input.len() {
            self.input[self.position].clone()
        } else {
            "$".to_string()
        }
    }
    
    fn advance(&mut self) {
        self.position += 1;
    }
    
    fn construct_predictive_table(grammar: &Grammar) -> PredictiveTable {
        let mut table = HashMap::new();
        
        for production in &grammar.productions {
            let first_set = grammar.first(&production.rhs);
            
            for terminal in first_set {
                if terminal != "Îµ" {
                    table.insert((production.lhs.clone(), terminal), production.clone());
                }
            }
            
            if first_set.contains("Îµ") {
                let follow_set = grammar.follow(&production.lhs);
                for terminal in follow_set {
                    table.insert((production.lhs.clone(), terminal), production.clone());
                }
            }
        }
        
        PredictiveTable { table }
    }
}

#[derive(Debug)]
pub struct PredictiveTable {
    table: HashMap<(String, String), Production>,
}

impl PredictiveTable {
    pub fn get(&self, nonterminal: &str, terminal: &str) -> Option<&Production> {
        self.table.get(&(nonterminal.to_string(), terminal.to_string()))
    }
}
```

### 4.2 æ–‡æ³•æ‰©å±•å®ç°

```rust
impl Grammar {
    pub fn first(&self, symbols: &[Symbol]) -> HashSet<String> {
        let mut first = HashSet::new();
        
        for symbol in symbols {
            match symbol {
                Symbol::Terminal(term) => {
                    first.insert(term.clone());
                    break; // é‡åˆ°ç»ˆç»“ç¬¦å°±åœæ­¢
                }
                Symbol::NonTerminal(nt) => {
                    let nt_first = self.first_nonterminal(nt);
                    first.extend(nt_first.iter().filter(|&s| s != "Îµ").cloned());
                    
                    if !nt_first.contains("Îµ") {
                        break; // å¦‚æœéç»ˆç»“ç¬¦ä¸èƒ½æ¨å¯¼å‡ºÎµï¼Œå°±åœæ­¢
                    }
                }
            }
        }
        
        // å¦‚æœæ‰€æœ‰ç¬¦å·éƒ½èƒ½æ¨å¯¼å‡ºÎµï¼Œåˆ™Îµä¹Ÿåœ¨FIRSTé›†ä¸­
        if symbols.iter().all(|s| {
            match s {
                Symbol::Terminal(_) => false,
                Symbol::NonTerminal(nt) => self.first_nonterminal(nt).contains("Îµ"),
            }
        }) {
            first.insert("Îµ".to_string());
        }
        
        first
    }
    
    fn first_nonterminal(&self, nonterminal: &str) -> HashSet<String> {
        let mut first = HashSet::new();
        let mut visited = HashSet::new();
        
        self.first_nonterminal_recursive(nonterminal, &mut first, &mut visited);
        
        first
    }
    
    fn first_nonterminal_recursive(&self, nonterminal: &str, first: &mut HashSet<String>, visited: &mut HashSet<String>) {
        if visited.contains(nonterminal) {
            return;
        }
        visited.insert(nonterminal.to_string());
        
        for production in &self.productions {
            if production.lhs == nonterminal {
                let rhs_first = self.first(&production.rhs);
                first.extend(rhs_first);
            }
        }
    }
    
    pub fn follow(&self, nonterminal: &str) -> HashSet<String> {
        let mut follow = HashSet::new();
        let mut visited = HashSet::new();
        
        if nonterminal == &self.start_symbol {
            follow.insert("$".to_string());
        }
        
        self.follow_recursive(nonterminal, &mut follow, &mut visited);
        
        follow
    }
    
    fn follow_recursive(&self, nonterminal: &str, follow: &mut HashSet<String>, visited: &mut HashSet<String>) {
        if visited.contains(nonterminal) {
            return;
        }
        visited.insert(nonterminal.to_string());
        
        for production in &self.productions {
            for (i, symbol) in production.rhs.iter().enumerate() {
                if let Symbol::NonTerminal(nt) = symbol {
                    if nt == nonterminal {
                        if i + 1 < production.rhs.len() {
                            // ä¸‹ä¸€ä¸ªç¬¦å·çš„FIRSTé›†
                            let next_symbols = &production.rhs[i + 1..];
                            let next_first = self.first(next_symbols);
                            
                            follow.extend(next_first.iter().filter(|&s| s != "Îµ").cloned());
                            
                            if next_first.contains("Îµ") {
                                // å¦‚æœä¸‹ä¸€ä¸ªç¬¦å·ä¸²èƒ½æ¨å¯¼å‡ºÎµï¼Œæ·»åŠ FOLLOW(å·¦éƒ¨)
                                self.follow_recursive(&production.lhs, follow, visited);
                            }
                        } else {
                            // äº§ç”Ÿå¼å³éƒ¨æœ«å°¾ï¼Œæ·»åŠ FOLLOW(å·¦éƒ¨)
                            self.follow_recursive(&production.lhs, follow, visited);
                        }
                    }
                }
            }
        }
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç®€å•ç®—æœ¯è¡¨è¾¾å¼æ–‡æ³•

```rust
fn create_arithmetic_grammar() -> Grammar {
    let mut grammar = Grammar::new("E".to_string());
    
    // E -> TE'
    grammar.add_production("E".to_string(), vec![
        Symbol::NonTerminal("T".to_string()),
        Symbol::NonTerminal("E'".to_string()),
    ]);
    
    // E' -> +TE' | Îµ
    grammar.add_production("E'".to_string(), vec![
        Symbol::Terminal("+".to_string()),
        Symbol::NonTerminal("T".to_string()),
        Symbol::NonTerminal("E'".to_string()),
    ]);
    grammar.add_production("E'".to_string(), vec![]); // Îµäº§ç”Ÿå¼
    
    // T -> FT'
    grammar.add_production("T".to_string(), vec![
        Symbol::NonTerminal("F".to_string()),
        Symbol::NonTerminal("T'".to_string()),
    ]);
    
    // T' -> *FT' | Îµ
    grammar.add_production("T'".to_string(), vec![
        Symbol::Terminal("*".to_string()),
        Symbol::NonTerminal("F".to_string()),
        Symbol::NonTerminal("T'".to_string()),
    ]);
    grammar.add_production("T'".to_string(), vec![]); // Îµäº§ç”Ÿå¼
    
    // F -> (E) | id
    grammar.add_production("F".to_string(), vec![
        Symbol::Terminal("(".to_string()),
        Symbol::NonTerminal("E".to_string()),
        Symbol::Terminal(")".to_string()),
    ]);
    grammar.add_production("F".to_string(), vec![
        Symbol::Terminal("id".to_string()),
    ]);
    
    grammar
}

#[test]
fn test_arithmetic_parsing() {
    let grammar = create_arithmetic_grammar();
    let mut parser = RecursiveDescentParser::new(grammar);
    
    let input = vec!["id".to_string(), "+".to_string(), "id".to_string(), "*".to_string(), "id".to_string()];
    let result = parser.parse(&input);
    
    assert!(result.is_ok());
    println!("Parse tree: {:?}", result.unwrap());
}
```

### 5.2 å†²çªæ£€æµ‹ç¤ºä¾‹

```rust
fn detect_ll1_conflicts(grammar: &Grammar) -> Vec<String> {
    let mut conflicts = Vec::new();
    let predictive_table = RecursiveDescentParser::construct_predictive_table(grammar);
    
    let mut conflict_map: HashMap<(String, String), Vec<Production>> = HashMap::new();
    
    for ((nonterminal, terminal), production) in &predictive_table.table {
        conflict_map
            .entry((nonterminal.clone(), terminal.clone()))
            .or_insert_with(Vec::new)
            .push(production.clone());
    }
    
    for ((nonterminal, terminal), productions) in conflict_map {
        if productions.len() > 1 {
            conflicts.push(format!(
                "LL(1) conflict for ({}, {}): {} productions",
                nonterminal, terminal, productions.len()
            ));
        }
    }
    
    conflicts
}

#[test]
fn test_conflict_detection() {
    let grammar = create_arithmetic_grammar();
    let conflicts = detect_ll1_conflicts(&grammar);
    
    if conflicts.is_empty() {
        println!("No LL(1) conflicts detected");
    } else {
        for conflict in conflicts {
            println!("Conflict: {}", conflict);
        }
    }
}
```

### 5.3 é”™è¯¯æ¢å¤ç¤ºä¾‹

```rust
impl RecursiveDescentParser {
    fn parse_with_error_recovery(&mut self, input: &[String]) -> Result<ParseTree, Vec<String>> {
        let mut errors = Vec::new();
        self.input = input.to_vec();
        self.position = 0;
        
        let tree = match self.parse_nonterminal_with_recovery(&self.grammar.start_symbol, &mut errors) {
            Ok(tree) => tree,
            Err(e) => {
                errors.push(e);
                ParseTree::new("ERROR".to_string())
            }
        };
        
        if errors.is_empty() {
            Ok(tree)
        } else {
            Err(errors)
        }
    }
    
    fn parse_nonterminal_with_recovery(&mut self, nonterminal: &str, errors: &mut Vec<String>) -> Result<ParseTree, String> {
        let current_input = self.current_input();
        
        match self.predictive_table.get(nonterminal, &current_input) {
            Some(production) => {
                let mut tree = ParseTree::new(nonterminal.to_string());
                
                for symbol in &production.rhs {
                    match symbol {
                        Symbol::Terminal(term) => {
                            if self.current_input() == term {
                                tree.add_child(ParseTree::new(term.clone()));
                                self.advance();
                            } else {
                                let error = format!("Expected {}, got {}", term, self.current_input());
                                errors.push(error);
                                // é”™è¯¯æ¢å¤ï¼šè·³è¿‡å½“å‰è¾“å…¥ç¬¦å·
                                self.advance();
                            }
                        }
                        Symbol::NonTerminal(nt) => {
                            match self.parse_nonterminal_with_recovery(nt, errors) {
                                Ok(child_tree) => tree.add_child(child_tree),
                                Err(e) => {
                                    errors.push(e);
                                    tree.add_child(ParseTree::new("ERROR".to_string()));
                                }
                            }
                        }
                    }
                }
                
                Ok(tree)
            }
            None => {
                let error = format!("No production for {} with input {}", nonterminal, current_input);
                Err(error)
            }
        }
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å…¶ä»–è§£ææ–¹æ³•çš„æ¯”è¾ƒ

| è§£ææ–¹æ³• | æ–¹å‘ | æ–‡æ³•ç±» | å®ç°å¤æ‚åº¦ | é”™è¯¯æ¢å¤ |
|---------|------|--------|-----------|---------|
| é€’å½’ä¸‹é™ | è‡ªé¡¶å‘ä¸‹ | LL(1) | ç®€å• | å›°éš¾ |
| LLè§£æ | è‡ªé¡¶å‘ä¸‹ | LL(k) | ä¸­ç­‰ | ä¸­ç­‰ |
| LRè§£æ | è‡ªåº•å‘ä¸Š | LR(k) | å¤æ‚ | ç®€å• |
| é€šç”¨è§£æ | ä»»æ„ | ä»»æ„ | æœ€å¤æ‚ | ä¸­ç­‰ |

### 6.2 é€’å½’ä¸‹é™è§£æçš„å±€é™æ€§

1. **æ–‡æ³•é™åˆ¶**ï¼šåªèƒ½å¤„ç†LL(1)æ–‡æ³•
2. **å·¦é€’å½’**ï¼šæ— æ³•ç›´æ¥å¤„ç†å·¦é€’å½’æ–‡æ³•
3. **é”™è¯¯æ¢å¤**ï¼šé”™è¯¯æ¢å¤æœºåˆ¶ç›¸å¯¹å¤æ‚
4. **æ•ˆç‡**ï¼šå¯¹äºå¤æ‚æ–‡æ³•ï¼Œæ•ˆç‡å¯èƒ½è¾ƒä½

### 6.3 ä¼˜åŒ–æŠ€æœ¯

1. **å·¦é€’å½’æ¶ˆé™¤**ï¼šå°†å·¦é€’å½’æ–‡æ³•è½¬æ¢ä¸ºå³é€’å½’
2. **å·¦å› å­æå–**ï¼šæå–å…¬å…±å‰ç¼€ï¼Œå‡å°‘å†²çª
3. **é”™è¯¯æ¢å¤**ï¼šå®ç°å„ç§é”™è¯¯æ¢å¤ç­–ç•¥
4. **ä»£ç ç”Ÿæˆ**ï¼šè‡ªåŠ¨ç”Ÿæˆé€’å½’ä¸‹é™è§£æå™¨ä»£ç 

## 7. å‚è€ƒæ–‡çŒ®

1. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). Compilers: Principles, Techniques, and Tools (2nd ed.). Pearson Education.
2. Grune, D., & Jacobs, C. J. (2008). Parsing Techniques: A Practical Guide (2nd ed.). Springer.
3. Wirth, N. (1976). Algorithms + Data Structures = Programs. Prentice-Hall.
4. é€’å½’ä¸‹é™è§£æå™¨çš„è®¾è®¡ä¸å®ç°
5. LL(1)æ–‡æ³•ç†è®ºä¸åº”ç”¨

- [03.3.1 ä¹”å§†æ–¯åŸºè°±ç³»](../03.3.1_ä¹”å§†æ–¯åŸºè°±ç³».md)
