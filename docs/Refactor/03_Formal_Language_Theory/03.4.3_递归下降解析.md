# 03.4.3 é€’å½’ä¸‹é™è§£æ

## ğŸ“‹ æ¦‚è¿°

é€’å½’ä¸‹é™è§£æï¼ˆRecursive Descent Parsingï¼‰æ˜¯ä¸€ç§è‡ªé¡¶å‘ä¸‹çš„è¯­æ³•åˆ†ææ–¹æ³•ï¼Œé€šè¿‡ä¸ºæ¯ä¸ªéç»ˆç»“ç¬¦ç¼–å†™é€’å½’å‡½æ•°æ¥å®ç°è¯­æ³•åˆ†æã€‚å®ƒæ˜¯LL(k)è§£æå™¨çš„ä¸€ç§ç›´æ¥å®ç°æ–¹å¼ï¼Œå…·æœ‰ç›´è§‚ã€æ˜“äºç†è§£å’Œè°ƒè¯•çš„ç‰¹ç‚¹ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å½¢å¼åŒ–å®šä¹‰**ï¼šå»ºç«‹é€’å½’ä¸‹é™è§£æçš„æ•°å­¦åŸºç¡€
2. **ç®—æ³•è®¾è®¡**ï¼šè®¾è®¡é«˜æ•ˆçš„é€’å½’ä¸‹é™è§£æç®—æ³•
3. **å®ç°éªŒè¯**ï¼šæä¾›å®Œæ•´çš„ä»£ç å®ç°å’Œæµ‹è¯•
4. **æ€§èƒ½åˆ†æ**ï¼šåˆ†ææ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦
5. **åº”ç”¨æ‰©å±•**ï¼šæ¢è®¨åœ¨å®é™…ç¼–è¯‘å™¨ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [ç®—æ³•è®¾è®¡](#3-ç®—æ³•è®¾è®¡)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [å¤æ‚åº¦åˆ†æ](#5-å¤æ‚åº¦åˆ†æ)
6. [é”™è¯¯å¤„ç†](#6-é”™è¯¯å¤„ç†)
7. [ä¼˜åŒ–æŠ€æœ¯](#7-ä¼˜åŒ–æŠ€æœ¯)
8. [åº”ç”¨ç¤ºä¾‹](#8-åº”ç”¨ç¤ºä¾‹)
9. [ç›¸å…³ç†è®º](#9-ç›¸å…³ç†è®º)
10. [å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 é€’å½’ä¸‹é™è§£æåŸç†

é€’å½’ä¸‹é™è§£æåŸºäºä»¥ä¸‹æ ¸å¿ƒæ€æƒ³ï¼š

**å®šä¹‰ 1.1** (é€’å½’ä¸‹é™è§£æå™¨)
é€’å½’ä¸‹é™è§£æå™¨æ˜¯ä¸€ä¸ªè¯­æ³•åˆ†æå™¨ï¼Œå…¶ä¸­ï¼š
- æ¯ä¸ªéç»ˆç»“ç¬¦å¯¹åº”ä¸€ä¸ªé€’å½’å‡½æ•°
- å‡½æ•°ä½“æ ¹æ®äº§ç”Ÿå¼å³éƒ¨å®ç°
- é€šè¿‡é€’å½’è°ƒç”¨å®ç°è¯­æ³•æ ‘çš„æ„å»º

**å®šç† 1.1** (é€’å½’ä¸‹é™è§£æçš„æ­£ç¡®æ€§)
å¯¹äºLL(k)æ–‡æ³•Gï¼Œå­˜åœ¨é€’å½’ä¸‹é™è§£æå™¨Pï¼Œä½¿å¾—ï¼š
- Pèƒ½å¤Ÿæ­£ç¡®è¯†åˆ«L(G)ä¸­çš„æ‰€æœ‰å¥å­
- Pçš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œå…¶ä¸­næ˜¯è¾“å…¥ä¸²çš„é•¿åº¦

### 1.2 LL(k)æ–‡æ³•ä¸é€’å½’ä¸‹é™

**å®šä¹‰ 1.2** (LL(k)æ–‡æ³•)
æ–‡æ³•Gæ˜¯LL(k)çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
- å¯¹äºä»»æ„ä¸¤ä¸ªä¸åŒçš„äº§ç”Ÿå¼A â†’ Î±å’ŒA â†’ Î²
- FIRST_k(Î±) âˆ© FIRST_k(Î²) = âˆ…

**å¼•ç† 1.1** (LL(k)æ–‡æ³•çš„é€’å½’ä¸‹é™å®ç°)
å¦‚æœæ–‡æ³•Gæ˜¯LL(k)çš„ï¼Œåˆ™å­˜åœ¨é€’å½’ä¸‹é™è§£æå™¨Pï¼Œä½¿å¾—ï¼š
- Pèƒ½å¤Ÿæ— å›æº¯åœ°è§£æL(G)
- Pçš„æ¯ä¸ªå‡½æ•°è°ƒç”¨éƒ½æ˜¯ç¡®å®šçš„

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 é€’å½’ä¸‹é™è§£æå™¨çš„å½¢å¼åŒ–æ¨¡å‹

**å®šä¹‰ 2.1** (é€’å½’ä¸‹é™è§£æå™¨)
é€’å½’ä¸‹é™è§£æå™¨æ˜¯ä¸€ä¸ªäº”å…ƒç»„P = (N, Î£, R, S, F)ï¼Œå…¶ä¸­ï¼š
- Næ˜¯éç»ˆç»“ç¬¦é›†åˆ
- Î£æ˜¯ç»ˆç»“ç¬¦é›†åˆ
- Ræ˜¯äº§ç”Ÿå¼é›†åˆ
- Sæ˜¯å¼€å§‹ç¬¦å·
- Fæ˜¯å‡½æ•°æ˜ å°„ï¼šN â†’ Function

**å®šä¹‰ 2.2** (è§£æå‡½æ•°)
å¯¹äºéç»ˆç»“ç¬¦A âˆˆ Nï¼Œå…¶å¯¹åº”çš„è§£æå‡½æ•°f_Aå®šä¹‰ä¸ºï¼š
```
f_A(input: TokenStream) -> ParseTree {
    match lookahead(input, k) {
        case FIRST_k(Î±â‚) => return parse_Î±â‚(input)
        case FIRST_k(Î±â‚‚) => return parse_Î±â‚‚(input)
        ...
        case FIRST_k(Î±â‚™) => return parse_Î±â‚™(input)
        default => throw ParseError
    }
}
```

### 2.2 è§£ææ ‘çš„æ„å»º

**å®šä¹‰ 2.3** (è§£ææ ‘èŠ‚ç‚¹)
è§£ææ ‘èŠ‚ç‚¹æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„Node = (label, children, value)ï¼Œå…¶ä¸­ï¼š
- labelæ˜¯èŠ‚ç‚¹æ ‡ç­¾ï¼ˆéç»ˆç»“ç¬¦æˆ–ç»ˆç»“ç¬¦ï¼‰
- childrenæ˜¯å­èŠ‚ç‚¹åˆ—è¡¨
- valueæ˜¯èŠ‚ç‚¹çš„è¯­ä¹‰å€¼

**å®šç† 2.1** (è§£ææ ‘çš„å”¯ä¸€æ€§)
å¯¹äºLL(k)æ–‡æ³•Gå’Œè¾“å…¥ä¸²w âˆˆ L(G)ï¼Œé€’å½’ä¸‹é™è§£æå™¨æ„å»ºçš„è§£ææ ‘æ˜¯å”¯ä¸€çš„ã€‚

## 3. ç®—æ³•è®¾è®¡

### 3.1 åŸºæœ¬é€’å½’ä¸‹é™ç®—æ³•

```rust
// é€’å½’ä¸‹é™è§£æå™¨çš„æ ¸å¿ƒç®—æ³•
trait RecursiveDescentParser {
    fn parse(&mut self, input: &str) -> Result<ParseTree, ParseError>;
    fn parse_nonterminal(&mut self, nt: &str) -> Result<ParseTree, ParseError>;
    fn match_token(&mut self, expected: &str) -> Result<Token, ParseError>;
    fn lookahead(&self, k: usize) -> Vec<Token>;
}

impl RecursiveDescentParser for Parser {
    fn parse(&mut self, input: &str) -> Result<ParseTree, ParseError> {
        self.tokens = self.lexer.tokenize(input)?;
        self.current = 0;
        self.parse_nonterminal("S")
    }
    
    fn parse_nonterminal(&mut self, nt: &str) -> Result<ParseTree, ParseError> {
        let lookahead = self.lookahead(1);
        let production = self.select_production(nt, &lookahead)?;
        
        let mut children = Vec::new();
        for symbol in production {
            let child = match symbol {
                Symbol::Terminal(t) => {
                    let token = self.match_token(t)?;
                    ParseTree::new_leaf(token)
                },
                Symbol::NonTerminal(nt) => {
                    self.parse_nonterminal(nt)?
                }
            };
            children.push(child);
        }
        
        Ok(ParseTree::new_node(nt, children))
    }
}
```

### 3.2 é¢„æµ‹è¡¨æ„å»ºç®—æ³•

```rust
// é¢„æµ‹è¡¨çš„æ„å»ºç®—æ³•
struct PredictionTable {
    table: HashMap<(String, Vec<Token>), Vec<Symbol>>,
}

impl PredictionTable {
    fn build(&mut self, grammar: &Grammar) {
        for production in &grammar.productions {
            let first_set = self.compute_first(&production.rhs);
            for token in first_set {
                self.table.insert(
                    (production.lhs.clone(), vec![token]),
                    production.rhs.clone()
                );
            }
        }
    }
    
    fn compute_first(&self, symbols: &[Symbol]) -> HashSet<Token> {
        let mut first = HashSet::new();
        for symbol in symbols {
            match symbol {
                Symbol::Terminal(t) => {
                    first.insert(t.clone());
                    break;
                },
                Symbol::NonTerminal(nt) => {
                    let nt_first = self.first_sets.get(nt).unwrap();
                    first.extend(nt_first.iter().cloned());
                    if !nt_first.contains(&Token::Epsilon) {
                        break;
                    }
                }
            }
        }
        first
    }
}
```

## 4. ä»£ç å®ç°

### 4.1 å®Œæ•´çš„é€’å½’ä¸‹é™è§£æå™¨å®ç°

```rust
use std::collections::HashMap;
use std::error::Error;

#[derive(Debug, Clone, PartialEq)]
pub enum Token {
    Number(i64),
    Plus,
    Minus,
    Multiply,
    Divide,
    LeftParen,
    RightParen,
    Eof,
}

#[derive(Debug)]
pub struct ParseTree {
    pub label: String,
    pub children: Vec<ParseTree>,
    pub value: Option<i64>,
}

impl ParseTree {
    pub fn new_leaf(token: Token) -> Self {
        let value = match token {
            Token::Number(n) => Some(n),
            _ => None,
        };
        ParseTree {
            label: format!("{:?}", token),
            children: vec![],
            value,
        }
    }
    
    pub fn new_node(label: &str, children: Vec<ParseTree>) -> Self {
        ParseTree {
            label: label.to_string(),
            children,
            value: None,
        }
    }
}

#[derive(Debug)]
pub struct ParseError {
    pub message: String,
    pub position: usize,
}

pub struct RecursiveDescentParser {
    tokens: Vec<Token>,
    current: usize,
}

impl RecursiveDescentParser {
    pub fn new() -> Self {
        RecursiveDescentParser {
            tokens: vec![],
            current: 0,
        }
    }
    
    pub fn parse(&mut self, input: &str) -> Result<ParseTree, ParseError> {
        self.tokens = self.tokenize(input)?;
        self.current = 0;
        self.parse_expression()
    }
    
    // E -> T E'
    fn parse_expression(&mut self) -> Result<ParseTree, ParseError> {
        let term = self.parse_term()?;
        let expr_prime = self.parse_expression_prime()?;
        
        if expr_prime.children.is_empty() {
            Ok(term)
        } else {
            Ok(ParseTree::new_node("E", vec![term, expr_prime]))
        }
    }
    
    // E' -> + T E' | - T E' | Îµ
    fn parse_expression_prime(&mut self) -> Result<ParseTree, ParseError> {
        if self.current >= self.tokens.len() {
            return Ok(ParseTree::new_node("E'", vec![]));
        }
        
        match self.tokens[self.current] {
            Token::Plus | Token::Minus => {
                let op = self.tokens[self.current].clone();
                self.current += 1;
                let term = self.parse_term()?;
                let expr_prime = self.parse_expression_prime()?;
                
                Ok(ParseTree::new_node("E'", vec![
                    ParseTree::new_leaf(op),
                    term,
                    expr_prime
                ]))
            },
            _ => Ok(ParseTree::new_node("E'", vec![]))
        }
    }
    
    // T -> F T'
    fn parse_term(&mut self) -> Result<ParseTree, ParseError> {
        let factor = self.parse_factor()?;
        let term_prime = self.parse_term_prime()?;
        
        if term_prime.children.is_empty() {
            Ok(factor)
        } else {
            Ok(ParseTree::new_node("T", vec![factor, term_prime]))
        }
    }
    
    // T' -> * F T' | / F T' | Îµ
    fn parse_term_prime(&mut self) -> Result<ParseTree, ParseError> {
        if self.current >= self.tokens.len() {
            return Ok(ParseTree::new_node("T'", vec![]));
        }
        
        match self.tokens[self.current] {
            Token::Multiply | Token::Divide => {
                let op = self.tokens[self.current].clone();
                self.current += 1;
                let factor = self.parse_factor()?;
                let term_prime = self.parse_term_prime()?;
                
                Ok(ParseTree::new_node("T'", vec![
                    ParseTree::new_leaf(op),
                    factor,
                    term_prime
                ]))
            },
            _ => Ok(ParseTree::new_node("T'", vec![]))
        }
    }
    
    // F -> ( E ) | number
    fn parse_factor(&mut self) -> Result<ParseTree, ParseError> {
        if self.current >= self.tokens.len() {
            return Err(ParseError {
                message: "Unexpected end of input".to_string(),
                position: self.current,
            });
        }
        
        match &self.tokens[self.current] {
            Token::LeftParen => {
                self.current += 1;
                let expr = self.parse_expression()?;
                
                if self.current >= self.tokens.len() || self.tokens[self.current] != Token::RightParen {
                    return Err(ParseError {
                        message: "Expected closing parenthesis".to_string(),
                        position: self.current,
                    });
                }
                self.current += 1;
                
                Ok(ParseTree::new_node("F", vec![
                    ParseTree::new_leaf(Token::LeftParen),
                    expr,
                    ParseTree::new_leaf(Token::RightParen)
                ]))
            },
            Token::Number(_) => {
                let token = self.tokens[self.current].clone();
                self.current += 1;
                Ok(ParseTree::new_node("F", vec![ParseTree::new_leaf(token)]))
            },
            _ => Err(ParseError {
                message: format!("Unexpected token: {:?}", self.tokens[self.current]),
                position: self.current,
            })
        }
    }
    
    fn tokenize(&self, input: &str) -> Result<Vec<Token>, ParseError> {
        let mut tokens = Vec::new();
        let mut chars = input.chars().peekable();
        
        while let Some(&ch) = chars.peek() {
            match ch {
                '0'..='9' => {
                    let mut num = 0;
                    while let Some(&digit) = chars.peek() {
                        if digit.is_ascii_digit() {
                            num = num * 10 + digit.to_digit(10).unwrap() as i64;
                            chars.next();
                        } else {
                            break;
                        }
                    }
                    tokens.push(Token::Number(num));
                },
                '+' => {
                    tokens.push(Token::Plus);
                    chars.next();
                },
                '-' => {
                    tokens.push(Token::Minus);
                    chars.next();
                },
                '*' => {
                    tokens.push(Token::Multiply);
                    chars.next();
                },
                '/' => {
                    tokens.push(Token::Divide);
                    chars.next();
                },
                '(' => {
                    tokens.push(Token::LeftParen);
                    chars.next();
                },
                ')' => {
                    tokens.push(Token::RightParen);
                    chars.next();
                },
                ' ' | '\t' | '\n' => {
                    chars.next();
                },
                _ => {
                    return Err(ParseError {
                        message: format!("Unexpected character: {}", ch),
                        position: tokens.len(),
                    });
                }
            }
        }
        
        tokens.push(Token::Eof);
        Ok(tokens)
    }
}

// æµ‹è¯•ä»£ç 
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_simple_expression() {
        let mut parser = RecursiveDescentParser::new();
        let result = parser.parse("2 + 3 * 4");
        assert!(result.is_ok());
        
        let tree = result.unwrap();
        assert_eq!(tree.label, "E");
    }
    
    #[test]
    fn test_parenthesized_expression() {
        let mut parser = RecursiveDescentParser::new();
        let result = parser.parse("(2 + 3) * 4");
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_invalid_expression() {
        let mut parser = RecursiveDescentParser::new();
        let result = parser.parse("2 + + 3");
        assert!(result.is_err());
    }
}
```

### 4.2 Haskellå®ç°ç‰ˆæœ¬

```haskell
-- é€’å½’ä¸‹é™è§£æå™¨çš„Haskellå®ç°
module RecursiveDescentParser where

import Data.Char (isDigit)
import Control.Monad (when)

-- æ•°æ®ç±»å‹å®šä¹‰
data Token = Number Int
           | Plus
           | Minus
           | Multiply
           | Divide
           | LeftParen
           | RightParen
           | Eof
           deriving (Show, Eq)

data ParseTree = Leaf Token
               | Node String [ParseTree]
               deriving (Show)

data ParseError = ParseError String Int deriving Show

-- è§£æå™¨çŠ¶æ€
data ParserState = ParserState {
    tokens :: [Token],
    position :: Int
} deriving Show

-- è§£æå™¨å•å­
newtype Parser a = Parser {
    runParser :: ParserState -> Either ParseError (a, ParserState)
}

instance Monad Parser where
    return x = Parser $ \s -> Right (x, s)
    p >>= f = Parser $ \s -> case runParser p s of
        Left err -> Left err
        Right (x, s') -> runParser (f x) s'

instance Applicative Parser where
    pure = return
    pf <*> px = do
        f <- pf
        x <- px
        return (f x)

instance Functor Parser where
    fmap f p = Parser $ \s -> case runParser p s of
        Left err -> Left err
        Right (x, s') -> Right (f x, s')

-- åŸºæœ¬è§£æå™¨æ“ä½œ
getToken :: Parser Token
getToken = Parser $ \s -> 
    if position s < length (tokens s)
    then Right (tokens s !! position s, s { position = position s + 1 })
    else Left (ParseError "Unexpected end of input" (position s))

peekToken :: Parser Token
peekToken = Parser $ \s ->
    if position s < length (tokens s)
    then Right (tokens s !! position s, s)
    else Left (ParseError "Unexpected end of input" (position s))

matchToken :: Token -> Parser Token
matchToken expected = do
    token <- getToken
    if token == expected
    then return token
    else Parser $ \s -> Left (ParseError 
        ("Expected " ++ show expected ++ ", got " ++ show token) 
        (position s))

-- è¯­æ³•è§„åˆ™å®ç°
-- E -> T E'
parseExpression :: Parser ParseTree
parseExpression = do
    term <- parseTerm
    exprPrime <- parseExpressionPrime
    case exprPrime of
        Node "E'" [] -> return term
        _ -> return (Node "E" [term, exprPrime])

-- E' -> + T E' | - T E' | Îµ
parseExpressionPrime :: Parser ParseTree
parseExpressionPrime = do
    token <- peekToken
    case token of
        Plus -> do
            _ <- getToken
            term <- parseTerm
            exprPrime <- parseExpressionPrime
            return (Node "E'" [Leaf Plus, term, exprPrime])
        Minus -> do
            _ <- getToken
            term <- parseTerm
            exprPrime <- parseExpressionPrime
            return (Node "E'" [Leaf Minus, term, exprPrime])
        _ -> return (Node "E'" [])

-- T -> F T'
parseTerm :: Parser ParseTree
parseTerm = do
    factor <- parseFactor
    termPrime <- parseTermPrime
    case termPrime of
        Node "T'" [] -> return factor
        _ -> return (Node "T" [factor, termPrime])

-- T' -> * F T' | / F T' | Îµ
parseTermPrime :: Parser ParseTree
parseTermPrime = do
    token <- peekToken
    case token of
        Multiply -> do
            _ <- getToken
            factor <- parseFactor
            termPrime <- parseTermPrime
            return (Node "T'" [Leaf Multiply, factor, termPrime])
        Divide -> do
            _ <- getToken
            factor <- parseFactor
            termPrime <- parseTermPrime
            return (Node "T'" [Leaf Divide, factor, termPrime])
        _ -> return (Node "T'" [])

-- F -> ( E ) | number
parseFactor :: Parser ParseTree
parseFactor = do
    token <- peekToken
    case token of
        LeftParen -> do
            _ <- getToken
            expr <- parseExpression
            _ <- matchToken RightParen
            return (Node "F" [Leaf LeftParen, expr, Leaf RightParen])
        Number n -> do
            _ <- getToken
            return (Node "F" [Leaf (Number n)])
        _ -> Parser $ \s -> Left (ParseError 
            ("Unexpected token: " ++ show token) 
            (position s))

-- è¯æ³•åˆ†æå™¨
tokenize :: String -> Either ParseError [Token]
tokenize input = tokenize' input []
  where
    tokenize' [] acc = Right (reverse acc ++ [Eof])
    tokenize' (c:cs) acc
        | isDigit c = let (num, rest) = span isDigit (c:cs)
                      in tokenize' rest (Number (read num) : acc)
        | c == '+' = tokenize' cs (Plus : acc)
        | c == '-' = tokenize' cs (Minus : acc)
        | c == '*' = tokenize' cs (Multiply : acc)
        | c == '/' = tokenize' cs (Divide : acc)
        | c == '(' = tokenize' cs (LeftParen : acc)
        | c == ')' = tokenize' cs (RightParen : acc)
        | c `elem` " \t\n" = tokenize' cs acc
        | otherwise = Left (ParseError ("Unexpected character: " ++ [c]) 0)

-- ä¸»è§£æå‡½æ•°
parse :: String -> Either ParseError ParseTree
parse input = do
    tokens <- tokenize input
    let state = ParserState tokens 0
    case runParser parseExpression state of
        Left err -> Left err
        Right (tree, _) -> Right tree

-- æµ‹è¯•å‡½æ•°
testParser :: IO ()
testParser = do
    putStrLn "Testing recursive descent parser..."
    
    let testCases = [
            ("2 + 3", "Simple addition"),
            ("2 * 3 + 4", "Multiplication and addition"),
            ("(2 + 3) * 4", "Parenthesized expression"),
            ("2 + 3 * 4", "Operator precedence")
        ]
    
    mapM_ (\(input, desc) -> do
        putStrLn $ "\n" ++ desc ++ ": " ++ input
        case parse input of
            Left err -> putStrLn $ "Error: " ++ show err
            Right tree -> putStrLn $ "Success: " ++ show tree
        ) testCases
```

## 5. å¤æ‚åº¦åˆ†æ

### 5.1 æ—¶é—´å¤æ‚åº¦åˆ†æ

**å®šç† 5.1** (é€’å½’ä¸‹é™è§£æçš„æ—¶é—´å¤æ‚åº¦)
å¯¹äºè¾“å…¥ä¸²é•¿åº¦ä¸ºnçš„LL(k)æ–‡æ³•ï¼Œé€’å½’ä¸‹é™è§£æå™¨çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ã€‚

**è¯æ˜**ï¼š
1. æ¯ä¸ªç»ˆç»“ç¬¦å’Œéç»ˆç»“ç¬¦æœ€å¤šè¢«è®¿é—®ä¸€æ¬¡
2. æ¯ä¸ªå‡½æ•°è°ƒç”¨çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(1)
3. æ€»çš„å‡½æ•°è°ƒç”¨æ¬¡æ•°ä¸è¾“å…¥ä¸²é•¿åº¦æˆæ­£æ¯”
4. å› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸ºO(n)

### 5.2 ç©ºé—´å¤æ‚åº¦åˆ†æ

**å®šç† 5.2** (é€’å½’ä¸‹é™è§£æçš„ç©ºé—´å¤æ‚åº¦)
é€’å½’ä¸‹é™è§£æå™¨çš„ç©ºé—´å¤æ‚åº¦ä¸ºO(h)ï¼Œå…¶ä¸­hæ˜¯è¯­æ³•æ ‘çš„é«˜åº¦ã€‚

**è¯æ˜**ï¼š
1. é€’å½’è°ƒç”¨æ ˆçš„æ·±åº¦ç­‰äºè¯­æ³•æ ‘çš„é«˜åº¦
2. æ¯ä¸ªå‡½æ•°è°ƒç”¨çš„å±€éƒ¨å˜é‡ç©ºé—´ä¸ºO(1)
3. å› æ­¤æ€»ç©ºé—´å¤æ‚åº¦ä¸ºO(h)

### 5.3 æœ€åæƒ…å†µåˆ†æ

**å¼•ç† 5.1** (å·¦é€’å½’é—®é¢˜)
å¦‚æœæ–‡æ³•åŒ…å«å·¦é€’å½’ï¼Œé€’å½’ä¸‹é™è§£æå™¨ä¼šé™·å…¥æ— é™é€’å½’ã€‚

**è¯æ˜**ï¼š
å¯¹äºå·¦é€’å½’äº§ç”Ÿå¼A â†’ AÎ±ï¼Œè§£æå‡½æ•°f_Aä¼šæ— é™è°ƒç”¨è‡ªèº«ï¼š
```
f_A() -> f_A() -> f_A() -> ...
```

## 6. é”™è¯¯å¤„ç†

### 6.1 é”™è¯¯æ¢å¤ç­–ç•¥

```rust
// é”™è¯¯æ¢å¤çš„é€’å½’ä¸‹é™è§£æå™¨
pub struct ErrorRecoveryParser {
    tokens: Vec<Token>,
    current: usize,
    errors: Vec<ParseError>,
}

impl ErrorRecoveryParser {
    pub fn new() -> Self {
        ErrorRecoveryParser {
            tokens: vec![],
            current: 0,
            errors: vec![],
        }
    }
    
    fn synchronize(&mut self) {
        // è·³è¿‡tokensç›´åˆ°æ‰¾åˆ°åŒæ­¥ç‚¹
        while self.current < self.tokens.len() {
            match self.tokens[self.current] {
                Token::Semicolon | Token::RightBrace | Token::RightParen => {
                    self.current += 1;
                    return;
                },
                _ => self.current += 1,
            }
        }
    }
    
    fn report_error(&mut self, message: String) {
        self.errors.push(ParseError {
            message,
            position: self.current,
        });
    }
}
```

### 6.2 é”™è¯¯è¯Šæ–­

**å®šä¹‰ 6.1** (é”™è¯¯è¯Šæ–­)
é”™è¯¯è¯Šæ–­æ˜¯è¯†åˆ«å’ŒæŠ¥å‘Šè¯­æ³•é”™è¯¯çš„è¿‡ç¨‹ï¼ŒåŒ…æ‹¬ï¼š
- é”™è¯¯ä½ç½®å®šä½
- é”™è¯¯ç±»å‹åˆ†ç±»
- é”™è¯¯æ¢å¤å»ºè®®

**ç®—æ³• 6.1** (é”™è¯¯è¯Šæ–­ç®—æ³•)
```
function diagnose_error(input, position):
    expected = compute_expected_tokens(position)
    actual = get_actual_token(position)
    suggestions = generate_suggestions(expected, actual)
    return ErrorReport(expected, actual, suggestions)
```

## 7. ä¼˜åŒ–æŠ€æœ¯

### 7.1 é¢„æµ‹è¡¨ä¼˜åŒ–

```rust
// ä¼˜åŒ–çš„é¢„æµ‹è¡¨å®ç°
pub struct OptimizedPredictionTable {
    table: HashMap<(String, Token), Vec<Symbol>>,
    epsilon_productions: HashSet<String>,
}

impl OptimizedPredictionTable {
    pub fn new() -> Self {
        OptimizedPredictionTable {
            table: HashMap::new(),
            epsilon_productions: HashSet::new(),
        }
    }
    
    pub fn add_production(&mut self, nonterminal: &str, tokens: &[Token], production: Vec<Symbol>) {
        for token in tokens {
            self.table.insert((nonterminal.to_string(), token.clone()), production.clone());
        }
    }
    
    pub fn get_production(&self, nonterminal: &str, token: &Token) -> Option<&Vec<Symbol>> {
        self.table.get(&(nonterminal.to_string(), token.clone()))
    }
}
```

### 7.2 è®°å¿†åŒ–ä¼˜åŒ–

```rust
// è®°å¿†åŒ–çš„é€’å½’ä¸‹é™è§£æå™¨
pub struct MemoizedParser {
    cache: HashMap<(String, usize), Option<ParseTree>>,
    tokens: Vec<Token>,
    current: usize,
}

impl MemoizedParser {
    pub fn new() -> Self {
        MemoizedParser {
            cache: HashMap::new(),
            tokens: vec![],
            current: 0,
        }
    }
    
    fn parse_with_memoization(&mut self, nonterminal: &str) -> Option<ParseTree> {
        let key = (nonterminal.to_string(), self.current);
        
        if let Some(result) = self.cache.get(&key) {
            return result.clone();
        }
        
        let result = self.parse_nonterminal(nonterminal);
        self.cache.insert(key, result.clone());
        result
    }
}
```

## 8. åº”ç”¨ç¤ºä¾‹

### 8.1 è¡¨è¾¾å¼è§£æå™¨

```rust
// å®Œæ•´çš„è¡¨è¾¾å¼è§£æå™¨ç¤ºä¾‹
pub struct ExpressionParser {
    parser: RecursiveDescentParser,
}

impl ExpressionParser {
    pub fn new() -> Self {
        ExpressionParser {
            parser: RecursiveDescentParser::new(),
        }
    }
    
    pub fn evaluate(&self, expression: &str) -> Result<i64, ParseError> {
        let tree = self.parser.parse(expression)?;
        self.evaluate_tree(&tree)
    }
    
    fn evaluate_tree(&self, tree: &ParseTree) -> Result<i64, ParseError> {
        match tree {
            ParseTree { label, children, value: Some(v) } if label.contains("Number") => {
                Ok(*v)
            },
            ParseTree { label, children, .. } if label == "E" => {
                if children.len() == 1 {
                    self.evaluate_tree(&children[0])
                } else {
                    let left = self.evaluate_tree(&children[0])?;
                    let right = self.evaluate_tree(&children[1])?;
                    Ok(left + right)
                }
            },
            ParseTree { label, children, .. } if label == "T" => {
                if children.len() == 1 {
                    self.evaluate_tree(&children[0])
                } else {
                    let left = self.evaluate_tree(&children[0])?;
                    let right = self.evaluate_tree(&children[1])?;
                    Ok(left * right)
                }
            },
            _ => Err(ParseError {
                message: "Invalid parse tree".to_string(),
                position: 0,
            })
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let parser = ExpressionParser::new();
    
    let expressions = vec![
        "2 + 3",
        "2 * 3 + 4",
        "(2 + 3) * 4",
        "10 / 2 + 3 * 4",
    ];
    
    for expr in expressions {
        match parser.evaluate(expr) {
            Ok(result) => println!("{} = {}", expr, result),
            Err(e) => println!("Error parsing {}: {}", expr, e.message),
        }
    }
}
```

### 8.2 é…ç½®è¯­è¨€è§£æå™¨

```rust
// é…ç½®è¯­è¨€è§£æå™¨ç¤ºä¾‹
pub struct ConfigParser {
    parser: RecursiveDescentParser,
}

impl ConfigParser {
    pub fn new() -> Self {
        ConfigParser {
            parser: RecursiveDescentParser::new(),
        }
    }
    
    pub fn parse_config(&self, config: &str) -> Result<HashMap<String, String>, ParseError> {
        let tree = self.parser.parse(config)?;
        self.extract_config(&tree)
    }
    
    fn extract_config(&self, tree: &ParseTree) -> Result<HashMap<String, String>, ParseError> {
        let mut config = HashMap::new();
        
        // éå†è§£ææ ‘ï¼Œæå–é”®å€¼å¯¹
        self.traverse_config_tree(tree, &mut config)?;
        
        Ok(config)
    }
    
    fn traverse_config_tree(&self, tree: &ParseTree, config: &mut HashMap<String, String>) -> Result<(), ParseError> {
        // å®ç°é…ç½®æ ‘éå†é€»è¾‘
        Ok(())
    }
}
```

## 9. ç›¸å…³ç†è®º

### 9.1 ä¸å…¶ä»–è§£ææ–¹æ³•çš„æ¯”è¾ƒ

| ç‰¹æ€§ | é€’å½’ä¸‹é™ | LLè§£æ | LRè§£æ | è‡ªåº•å‘ä¸Š |
|------|----------|--------|--------|----------|
| æ–¹å‘ | è‡ªé¡¶å‘ä¸‹ | è‡ªé¡¶å‘ä¸‹ | è‡ªåº•å‘ä¸Š | è‡ªåº•å‘ä¸Š |
| å›æº¯ | æ—  | æ—  | æ—  | æ—  |
| å®ç°å¤æ‚åº¦ | ç®€å• | ä¸­ç­‰ | å¤æ‚ | å¤æ‚ |
| é”™è¯¯å¤„ç† | å®¹æ˜“ | å®¹æ˜“ | å›°éš¾ | å›°éš¾ |
| æ€§èƒ½ | å¥½ | å¥½ | å¾ˆå¥½ | å¾ˆå¥½ |

### 9.2 ç†è®ºè”ç³»

**å®šç† 9.1** (é€’å½’ä¸‹é™ä¸LL(k)çš„å…³ç³»)
é€’å½’ä¸‹é™è§£æå™¨æ˜¯LL(k)è§£æå™¨çš„ä¸€ç§ç›´æ¥å®ç°æ–¹å¼ã€‚

**è¯æ˜**ï¼š
1. é€’å½’ä¸‹é™è§£æå™¨ä¸ºæ¯ä¸ªéç»ˆç»“ç¬¦ç¼–å†™é€’å½’å‡½æ•°
2. å‡½æ•°ä½“æ ¹æ®äº§ç”Ÿå¼å³éƒ¨å®ç°
3. è¿™ä¸LL(k)è§£æå™¨çš„é¢„æµ‹è¡¨æ–¹æ³•ç­‰ä»·

**å®šç† 9.2** (é€’å½’ä¸‹é™ä¸è¯­æ³•æ ‘çš„å…³ç³»)
é€’å½’ä¸‹é™è§£æå™¨ç›´æ¥æ„å»ºè¯­æ³•æ ‘ï¼Œæ— éœ€é¢å¤–çš„æ ‘æ„å»ºæ­¥éª¤ã€‚

**è¯æ˜**ï¼š
1. æ¯ä¸ªå‡½æ•°è°ƒç”¨è¿”å›ä¸€ä¸ªå­æ ‘
2. å­æ ‘ç»„åˆå½¢æˆå®Œæ•´çš„è¯­æ³•æ ‘
3. æ ‘çš„ç»“æ„ä¸é€’å½’è°ƒç”¨ç»“æ„ä¸€è‡´

## 10. å‚è€ƒæ–‡çŒ®

1. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). *Compilers: Principles, Techniques, and Tools* (2nd ed.). Pearson Education.

2. Grune, D., & Jacobs, C. J. (2008). *Parsing Techniques: A Practical Guide* (2nd ed.). Springer.

3. Appel, A. W. (1998). *Modern Compiler Implementation in ML*. Cambridge University Press.

4. Cooper, K. D., & Torczon, L. (2011). *Engineering a Compiler* (3rd ed.). Morgan Kaufmann.

5. Wirth, N. (1996). *Compiler Construction*. Addison-Wesley.

6. Fischer, C. N., & LeBlanc, R. J. (1991). *Crafting a Compiler*. Benjamin/Cummings.

7. Wilhelm, R., & Seidl, H. (2010). *Compiler Design: Virtual Machines*. Springer.

8. Muchnick, S. S. (1997). *Advanced Compiler Design and Implementation*. Morgan Kaufmann.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [03.4.1 LLè§£æ](../03.4.1_LLè§£æ.md)
- [03.4.2 LRè§£æ](../03.4.2_LRè§£æ.md)
- [03.4.4 è‡ªåº•å‘ä¸Šè§£æ](../03.4.4_è‡ªåº•å‘ä¸Šè§£æ.md)
- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03.2.2_ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•.md)
- [03.3.1 ä¹”å§†æ–¯åŸºè°±ç³»](../03.3.1_ä¹”å§†æ–¯åŸºè°±ç³».md) 