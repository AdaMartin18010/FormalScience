# 03.4.4 è‡ªåº•å‘ä¸Šè§£æ

## ğŸ“‹ æ¦‚è¿°

è‡ªåº•å‘ä¸Šè§£ææ˜¯ä¸€ç§ä»è¾“å…¥ä¸²å¼€å§‹ï¼Œé€æ­¥å½’çº¦åˆ°å¼€å§‹ç¬¦å·çš„è¯­æ³•åˆ†ææ–¹æ³•ã€‚è¿™ç§æ–¹æ³•èƒ½å¤Ÿå¤„ç†æ¯”è‡ªé¡¶å‘ä¸‹è§£ææ›´å¹¿æ³›çš„æ–‡æ³•ç±»ï¼ŒåŒ…æ‹¬LR(k)æ–‡æ³•å’ŒæŸäº›éLR(k)æ–‡æ³•ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å½¢å¼åŒ–è‡ªåº•å‘ä¸Šç®—æ³•**ï¼šå»ºç«‹ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œç®—æ³•æè¿°
2. **ç§»è¿›-å½’çº¦è§£æ**ï¼šå®šä¹‰ç§»è¿›-å½’çº¦è§£æå™¨çš„ç»“æ„å’Œæ“ä½œ
3. **å¥æŸ„è¯†åˆ«**ï¼šå»ºç«‹å¥æŸ„è¯†åˆ«ç®—æ³•å’Œå¥æŸ„æ€§è´¨
4. **å®ç°éªŒè¯**ï¼šæä¾›å®Œæ•´çš„Rustå®ç°å’Œå½¢å¼åŒ–è¯æ˜

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è‡ªåº•å‘ä¸Šè§£æçš„åŸºæœ¬æ€æƒ³

è‡ªåº•å‘ä¸Šè§£æçš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š

1. **ä»è¾“å…¥å¼€å§‹**ï¼šä»è¾“å…¥ä¸²çš„ç¬¦å·å¼€å§‹è§£æ
2. **é€æ­¥å½’çº¦**ï¼šä½¿ç”¨äº§ç”Ÿå¼è§„åˆ™å°†ç¬¦å·ä¸²å½’çº¦ä¸ºéç»ˆç»“ç¬¦
3. **å¥æŸ„è¯†åˆ«**ï¼šè¯†åˆ«å½“å‰å¯ä»¥å½’çº¦çš„å¥æŸ„
4. **ç›®æ ‡å¯¼å‘**ï¼šæœ€ç»ˆå½’çº¦åˆ°å¼€å§‹ç¬¦å·

### 1.2 è‡ªåº•å‘ä¸Šè§£æå™¨çš„ç»“æ„

**å®šä¹‰ 1.2.1 (è‡ªåº•å‘ä¸Šè§£æå™¨ç»“æ„)**
è‡ªåº•å‘ä¸Šè§£æå™¨æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $\mathcal{P} = (G, \mathcal{S}, \mathcal{I}, \mathcal{A}, \text{parse})$ï¼Œå…¶ä¸­ï¼š

- $G$ æ˜¯æ–‡æ³•
- $\mathcal{S}$ æ˜¯ç¬¦å·æ ˆ
- $\mathcal{I}$ æ˜¯è¾“å…¥æ ˆ
- $\mathcal{A}$ æ˜¯åŠ¨ä½œè¡¨
- $\text{parse}$ æ˜¯ä¸»è§£æå‡½æ•°

### 1.3 è§£æé…ç½®

**å®šä¹‰ 1.2.2 (è§£æé…ç½®)**
è‡ªåº•å‘ä¸Šè§£æçš„é…ç½®æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(s, i, a)$ï¼Œå…¶ä¸­ï¼š

- $s$ æ˜¯ç¬¦å·æ ˆå†…å®¹
- $i$ æ˜¯è¾“å…¥æ ˆå†…å®¹
- $a$ æ˜¯å½“å‰åŠ¨ä½œ

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å¥æŸ„

**å®šä¹‰ 2.1.1 (å¥æŸ„)**
å¯¹äºæ–‡æ³• $G$ å’Œå³å¥å‹ $\alpha\beta\gamma$ï¼Œå¦‚æœ $S \Rightarrow^* \alpha A\gamma \Rightarrow \alpha\beta\gamma$ï¼Œåˆ™ $\beta$ æ˜¯ $\alpha\beta\gamma$ ä¸­å…³äºäº§ç”Ÿå¼ $A \rightarrow \beta$ çš„å¥æŸ„ã€‚

**å®šä¹‰ 2.1.2 (å¥æŸ„æ€§è´¨)**
å¥æŸ„å…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼š

1. **å”¯ä¸€æ€§**ï¼šæ¯ä¸ªå³å¥å‹æœ‰å”¯ä¸€çš„å¥æŸ„
2. **ä½ç½®æ€§**ï¼šå¥æŸ„æ€»æ˜¯å‡ºç°åœ¨æœ€å³ç«¯
3. **å½’çº¦æ€§**ï¼šå¥æŸ„å¯ä»¥ç«‹å³å½’çº¦

**å®šç† 2.1.1 (å¥æŸ„è¯†åˆ«)**
å¦‚æœ $\beta$ æ˜¯ $\alpha\beta\gamma$ çš„å¥æŸ„ï¼Œåˆ™ $\beta$ æ˜¯ $\alpha\beta\gamma$ ä¸­æœ€å³ç«¯çš„å¯ä»¥å½’çº¦çš„å­ä¸²ã€‚

**è¯æ˜ï¼š**

1. **å¥æŸ„å®šä¹‰**ï¼šå¥æŸ„æ˜¯æŸä¸ªäº§ç”Ÿå¼å³éƒ¨
2. **æœ€å³æ€§**ï¼šå¥æŸ„æ€»æ˜¯å‡ºç°åœ¨æœ€å³ç«¯
3. **å½’çº¦æ€§**ï¼šå¥æŸ„å¯ä»¥ç«‹å³å½’çº¦

### 2.2 ç§»è¿›-å½’çº¦è§£æ

**å®šä¹‰ 2.2.1 (ç§»è¿›æ“ä½œ)**
ç§»è¿›æ“ä½œå°†å½“å‰è¾“å…¥ç¬¦å·å‹å…¥ç¬¦å·æ ˆï¼š
$$\text{SHIFT}: (s, ai, \text{shift}) \rightarrow (sa, i, \text{next})$$

**å®šä¹‰ 2.2.2 (å½’çº¦æ“ä½œ)**
å½’çº¦æ“ä½œå°†æ ˆé¡¶çš„å¥æŸ„å½’çº¦ä¸ºéç»ˆç»“ç¬¦ï¼š
$$\text{REDUCE}: (s\alpha, i, \text{reduce}(A \rightarrow \alpha)) \rightarrow (sA, i, \text{next})$$

**ç®—æ³• 2.2.1 (ç§»è¿›-å½’çº¦è§£æ)**

```rust
fn shift_reduce_parse(grammar: &Grammar, input: &[String]) -> Result<Vec<usize>, String> {
    let mut parser = ShiftReduceParser::new(grammar);
    parser.parse(input)
}
```

### 2.3 å¥æŸ„è¯†åˆ«ç®—æ³•

**ç®—æ³• 2.3.1 (å¥æŸ„è¯†åˆ«)**

```rust
fn find_handle(stack: &[String], grammar: &Grammar) -> Option<(usize, Production)> {
    for i in (0..stack.len()).rev() {
        for production in &grammar.productions {
            if stack[i..].len() >= production.rhs.len() {
                let suffix = &stack[i..i + production.rhs.len()];
                if suffix.iter().zip(&production.rhs).all(|(a, b)| a == b) {
                    return Some((i, production.clone()));
                }
            }
        }
    }
    None
}
```

## 3. å®šç†ä¸è¯æ˜

### 3.1 è‡ªåº•å‘ä¸Šè§£æçš„æ­£ç¡®æ€§

**å®šç† 3.1.1 (è‡ªåº•å‘ä¸Šè§£ææ­£ç¡®æ€§)**
å¦‚æœæ–‡æ³• $G$ æ˜¯æ— æ­§ä¹‰çš„ï¼Œåˆ™è‡ªåº•å‘ä¸Šè§£æå™¨èƒ½å¤Ÿæ­£ç¡®è¯†åˆ« $L(G)$ ä¸­çš„æ‰€æœ‰å¥å­ã€‚

**è¯æ˜ï¼š**
é€šè¿‡å½’çº³æ³•è¯æ˜ï¼š

1. **åŸºç¡€æƒ…å†µ**ï¼šç©ºä¸²çš„è§£æ
2. **å½’çº³æ­¥éª¤**ï¼šå‡è®¾å¯¹äºé•¿åº¦å°äº $n$ çš„ä¸²æˆç«‹ï¼Œè¯æ˜å¯¹äºé•¿åº¦ä¸º $n$ çš„ä¸²ä¹Ÿæˆç«‹
3. **å¥æŸ„è¯†åˆ«**ï¼šå¥æŸ„è¯†åˆ«ç®—æ³•ç¡®ä¿è¯†åˆ«æ­£ç¡®çš„å¥æŸ„
4. **å½’çº¦æ­£ç¡®æ€§**ï¼šå½’çº¦æ“ä½œä¿æŒè§£æçš„æ­£ç¡®æ€§

### 3.2 å¥æŸ„çš„æ€§è´¨

**å®šç† 3.2.1 (å¥æŸ„å”¯ä¸€æ€§)**
å¯¹äºæ— æ­§ä¹‰æ–‡æ³•ï¼Œæ¯ä¸ªå³å¥å‹æœ‰å”¯ä¸€çš„å¥æŸ„ã€‚

**è¯æ˜ï¼š**

1. **æ— æ­§ä¹‰æ€§**ï¼šæ— æ­§ä¹‰æ–‡æ³•ç¡®ä¿æ¯ä¸ªå¥å­æœ‰å”¯ä¸€çš„æ¨å¯¼
2. **å¥æŸ„å®šä¹‰**ï¼šå¥æŸ„å¯¹åº”æ¨å¯¼ä¸­çš„æŸä¸ªæ­¥éª¤
3. **å”¯ä¸€æ€§**ï¼šå› æ­¤å¥æŸ„æ˜¯å”¯ä¸€çš„

**å®šç† 3.2.2 (å¥æŸ„ä½ç½®æ€§)**
å¥æŸ„æ€»æ˜¯å‡ºç°åœ¨å³å¥å‹çš„æœ€å³ç«¯ã€‚

**è¯æ˜ï¼š**

1. **æœ€å³æ¨å¯¼**ï¼šè‡ªåº•å‘ä¸Šè§£æå¯¹åº”æœ€å³æ¨å¯¼
2. **å¥æŸ„ä½ç½®**ï¼šå¥æŸ„å¯¹åº”æœ€å³æ¨å¯¼ä¸­çš„æŸä¸ªæ­¥éª¤
3. **æœ€å³æ€§**ï¼šå› æ­¤å¥æŸ„åœ¨æœ€å³ç«¯

### 3.3 å†²çªåˆ†æ

**å®šä¹‰ 3.3.1 (ç§»è¿›-å½’çº¦å†²çª)**
åœ¨é…ç½® $(s, ai, \text{action})$ ä¸­å­˜åœ¨ç§»è¿›-å½’çº¦å†²çªï¼Œå¦‚æœï¼š

- å¯ä»¥æ‰§è¡Œç§»è¿›æ“ä½œï¼š$(s, ai, \text{shift})$
- å¯ä»¥æ‰§è¡Œå½’çº¦æ“ä½œï¼š$(s, ai, \text{reduce}(A \rightarrow \alpha))$

**å®šä¹‰ 3.3.2 (å½’çº¦-å½’çº¦å†²çª)**
åœ¨é…ç½® $(s, i, \text{action})$ ä¸­å­˜åœ¨å½’çº¦-å½’çº¦å†²çªï¼Œå¦‚æœå­˜åœ¨ä¸¤ä¸ªä¸åŒçš„å½’çº¦æ“ä½œï¼š

- $(s, i, \text{reduce}(A \rightarrow \alpha))$
- $(s, i, \text{reduce}(B \rightarrow \beta))$

**å®šç† 3.3.1 (å†²çªæ£€æµ‹)**
è‡ªåº•å‘ä¸Šè§£æä¸­çš„å†²çªå¯ä»¥é€šè¿‡æ£€æŸ¥æ¯ä¸ªé…ç½®æ¥æ£€æµ‹ã€‚

**è¯æ˜ï¼š**

1. **å†²çªå®šä¹‰**ï¼šå†²çªç­‰ä»·äºé…ç½®ä¸­æœ‰å¤šä¸ªå¯èƒ½çš„åŠ¨ä½œ
2. **æ£€æµ‹æ–¹æ³•**ï¼šéå†æ‰€æœ‰é…ç½®ï¼Œæ£€æŸ¥æ¯ä¸ªé…ç½®çš„åŠ¨ä½œ
3. **å†²çªæŠ¥å‘Š**ï¼šæŠ¥å‘Šæ‰€æœ‰å†²çªé…ç½®

## 4. ä»£ç å®ç°

### 4.1 è‡ªåº•å‘ä¸Šè§£æå™¨æ ¸å¿ƒå®ç°

```rust
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone)]
pub enum Action {
    Shift,
    Reduce(usize), // äº§ç”Ÿå¼ID
    Accept,
    Error,
}

#[derive(Debug)]
pub struct ShiftReduceParser {
    grammar: Grammar,
    action_table: HashMap<(usize, String), Action>,
    goto_table: HashMap<(usize, String), usize>,
    states: Vec<HashSet<Item>>,
}

impl ShiftReduceParser {
    pub fn new(grammar: Grammar) -> Self {
        let mut parser = Self {
            grammar,
            action_table: HashMap::new(),
            goto_table: HashMap::new(),
            states: Vec::new(),
        };
        
        parser.construct_tables();
        parser
    }
    
    pub fn parse(&self, input: &[String]) -> Result<Vec<usize>, String> {
        let mut stack = vec![0]; // çŠ¶æ€æ ˆ
        let mut input_pos = 0;
        let mut parse_tree = Vec::new();
        
        loop {
            let current_state = stack.last().unwrap();
            let current_input = if input_pos < input.len() {
                &input[input_pos]
            } else {
                "$"
            };
            
            match self.action_table.get(&(*current_state, current_input.to_string())) {
                Some(Action::Shift) => {
                    // ç§»è¿›æ“ä½œ
                    let next_state = self.goto_table.get(&(*current_state, current_input.to_string()))
                        .ok_or_else(|| format!("No goto for state {} and input {}", current_state, current_input))?;
                    stack.push(*next_state);
                    input_pos += 1;
                }
                Some(Action::Reduce(production_id)) => {
                    // å½’çº¦æ“ä½œ
                    let production = &self.grammar.productions[*production_id];
                    let rhs_len = production.rhs.len();
                    
                    // å¼¹å‡ºçŠ¶æ€æ ˆä¸­çš„çŠ¶æ€
                    for _ in 0..rhs_len {
                        stack.pop();
                    }
                    
                    // å‹å…¥å½’çº¦åçš„çŠ¶æ€
                    let current_state = stack.last().unwrap();
                    let next_state = self.goto_table.get(&(*current_state, production.lhs.clone()))
                        .ok_or_else(|| format!("No goto for state {} and nonterminal {}", current_state, production.lhs))?;
                    stack.push(*next_state);
                    
                    parse_tree.push(*production_id);
                }
                Some(Action::Accept) => {
                    return Ok(parse_tree);
                }
                Some(Action::Error) | None => {
                    return Err(format!("Parse error at position {}", input_pos));
                }
            }
        }
    }
    
    fn construct_tables(&mut self) {
        // æ„é€ LR(0)çŠ¶æ€æœº
        self.construct_lr0_automaton();
        
        // æ„é€ åŠ¨ä½œè¡¨å’ŒGOTOè¡¨
        self.construct_action_goto_tables();
    }
    
    fn construct_lr0_automaton(&mut self) {
        // åˆå§‹é¡¹ç›®é›†
        let initial_item = Item::new(0, 0); // å‡è®¾å¼€å§‹äº§ç”Ÿå¼IDä¸º0
        let initial_items = self.closure(&[initial_item]);
        self.states.push(initial_items);
        
        let mut unprocessed = vec![0];
        
        while let Some(state_id) = unprocessed.pop() {
            let current_state = &self.states[state_id];
            
            // å¯¹æ¯ä¸ªç¬¦å·è®¡ç®—GOTO
            for symbol in self.grammar.all_symbols() {
                let goto_items = self.goto(current_state, &symbol);
                
                if !goto_items.is_empty() {
                    let next_state_id = self.find_or_add_state(goto_items);
                    self.goto_table.insert((state_id, symbol), next_state_id);
                    
                    if next_state_id == self.states.len() - 1 {
                        unprocessed.push(next_state_id);
                    }
                }
            }
        }
    }
    
    fn closure(&self, items: &[Item]) -> HashSet<Item> {
        let mut closure = HashSet::new();
        let mut unprocessed: Vec<Item> = items.to_vec();
        
        while let Some(item) = unprocessed.pop() {
            if closure.insert(item.clone()) {
                // å¦‚æœé¡¹ç›®æ˜¯ A -> Î±Â·BÎ² å½¢å¼ï¼Œæ·»åŠ æ‰€æœ‰ B -> Â·Î³ é¡¹ç›®
                if let Some(next_symbol) = item.next_symbol(&self.grammar) {
                    if let Symbol::NonTerminal(nt) = next_symbol {
                        for (prod_id, production) in self.grammar.productions.iter().enumerate() {
                            if production.lhs == *nt {
                                let new_item = Item::new(prod_id, 0);
                                unprocessed.push(new_item);
                            }
                        }
                    }
                }
            }
        }
        
        closure
    }
    
    fn goto(&self, items: &HashSet<Item>, symbol: &Symbol) -> HashSet<Item> {
        let mut goto_items = HashSet::new();
        
        for item in items {
            if let Some(next_symbol) = item.next_symbol(&self.grammar) {
                if next_symbol == symbol {
                    let new_item = Item::new(item.production_id, item.dot_position + 1);
                    goto_items.insert(new_item);
                }
            }
        }
        
        self.closure(&goto_items.into_iter().collect::<Vec<_>>())
    }
    
    fn find_or_add_state(&mut self, items: HashSet<Item>) -> usize {
        for (state_id, state) in self.states.iter().enumerate() {
            if state == &items {
                return state_id;
            }
        }
        
        self.states.push(items);
        self.states.len() - 1
    }
    
    fn construct_action_goto_tables(&mut self) {
        for (state_id, state) in self.states.iter().enumerate() {
            for item in state {
                if item.is_reduce_item(&self.grammar) {
                    // å½’çº¦åŠ¨ä½œ
                    if item.production_id == 0 {
                        // æ¥å—åŠ¨ä½œ
                        self.action_table.insert((state_id, "$".to_string()), Action::Accept);
                    } else {
                        // å½’çº¦åŠ¨ä½œ
                        let production = &self.grammar.productions[item.production_id];
                        for symbol in self.grammar.follow(&production.lhs) {
                            self.action_table.insert((state_id, symbol), Action::Reduce(item.production_id));
                        }
                    }
                } else if item.is_shift_item(&self.grammar) {
                    // ç§»è¿›åŠ¨ä½œ
                    if let Some(next_symbol) = item.next_symbol(&self.grammar) {
                        if let Symbol::Terminal(term) = next_symbol {
                            if let Some(&next_state) = self.goto_table.get(&(state_id, next_symbol.clone())) {
                                self.action_table.insert((state_id, term.clone()), Action::Shift);
                            }
                        }
                    }
                }
            }
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Item {
    pub production_id: usize,
    pub dot_position: usize,
}

impl Item {
    pub fn new(production_id: usize, dot_position: usize) -> Self {
        Self {
            production_id,
            dot_position,
        }
    }
    
    pub fn is_reduce_item(&self, grammar: &Grammar) -> bool {
        let production = &grammar.productions[self.production_id];
        self.dot_position == production.rhs.len()
    }
    
    pub fn is_shift_item(&self, grammar: &Grammar) -> bool {
        !self.is_reduce_item(grammar)
    }
    
    pub fn next_symbol(&self, grammar: &Grammar) -> Option<&Symbol> {
        let production = &grammar.productions[self.production_id];
        production.rhs.get(self.dot_position)
    }
}
```

### 4.2 å¥æŸ„è¯†åˆ«å®ç°

```rust
impl ShiftReduceParser {
    fn find_handle(&self, stack: &[String]) -> Option<(usize, &Production)> {
        for i in (0..stack.len()).rev() {
            for production in &self.grammar.productions {
                if stack[i..].len() >= production.rhs.len() {
                    let suffix = &stack[i..i + production.rhs.len()];
                    if suffix.iter().zip(&production.rhs).all(|(a, b)| {
                        match b {
                            Symbol::Terminal(term) => a == term,
                            Symbol::NonTerminal(nt) => a == nt,
                        }
                    }) {
                        return Some((i, production));
                    }
                }
            }
        }
        None
    }
    
    fn can_reduce(&self, stack: &[String], production: &Production) -> bool {
        if stack.len() < production.rhs.len() {
            return false;
        }
        
        let suffix = &stack[stack.len() - production.rhs.len()..];
        suffix.iter().zip(&production.rhs).all(|(a, b)| {
            match b {
                Symbol::Terminal(term) => a == term,
                Symbol::NonTerminal(nt) => a == nt,
            }
        })
    }
    
    fn reduce(&self, stack: &mut Vec<String>, production: &Production) {
        let rhs_len = production.rhs.len();
        for _ in 0..rhs_len {
            stack.pop();
        }
        stack.push(production.lhs.clone());
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç®€å•ç®—æœ¯è¡¨è¾¾å¼æ–‡æ³•

```rust
fn create_arithmetic_grammar() -> Grammar {
    let mut grammar = Grammar::new("E".to_string());
    
    // E -> E + T | T
    grammar.add_production("E".to_string(), vec![
        Symbol::NonTerminal("E".to_string()),
        Symbol::Terminal("+".to_string()),
        Symbol::NonTerminal("T".to_string()),
    ]);
    grammar.add_production("E".to_string(), vec![
        Symbol::NonTerminal("T".to_string()),
    ]);
    
    // T -> T * F | F
    grammar.add_production("T".to_string(), vec![
        Symbol::NonTerminal("T".to_string()),
        Symbol::Terminal("*".to_string()),
        Symbol::NonTerminal("F".to_string()),
    ]);
    grammar.add_production("T".to_string(), vec![
        Symbol::NonTerminal("F".to_string()),
    ]);
    
    // F -> (E) | id
    grammar.add_production("F".to_string(), vec![
        Symbol::Terminal("(".to_string()),
        Symbol::NonTerminal("E".to_string()),
        Symbol::Terminal(")".to_string()),
    ]);
    grammar.add_production("F".to_string(), vec![
        Symbol::Terminal("id".to_string()),
    ]);
    
    grammar
}

#[test]
fn test_arithmetic_parsing() {
    let grammar = create_arithmetic_grammar();
    let parser = ShiftReduceParser::new(grammar);
    
    let input = vec!["id".to_string(), "+".to_string(), "id".to_string(), "*".to_string(), "id".to_string()];
    let result = parser.parse(&input);
    
    assert!(result.is_ok());
    println!("Parse tree: {:?}", result.unwrap());
}
```

### 5.2 å¥æŸ„è¯†åˆ«ç¤ºä¾‹

```rust
#[test]
fn test_handle_recognition() {
    let grammar = create_arithmetic_grammar();
    let parser = ShiftReduceParser::new(grammar);
    
    // æµ‹è¯•å¥æŸ„è¯†åˆ«
    let stack = vec!["id".to_string()];
    let handle = parser.find_handle(&stack);
    
    assert!(handle.is_some());
    let (pos, production) = handle.unwrap();
    assert_eq!(pos, 0);
    assert_eq!(production.lhs, "F");
    assert_eq!(production.rhs, vec![Symbol::Terminal("id".to_string())]);
}
```

### 5.3 å†²çªæ£€æµ‹ç¤ºä¾‹

```rust
fn detect_conflicts(parser: &ShiftReduceParser) -> Vec<String> {
    let mut conflicts = Vec::new();
    
    for ((state, input), action) in &parser.action_table {
        // æ£€æŸ¥ç§»è¿›-å½’çº¦å†²çª
        if let Action::Reduce(production_id) = action {
            if let Some(Action::Shift) = parser.action_table.get(&(*state, input.clone())) {
                conflicts.push(format!(
                    "Shift-Reduce conflict in state {} with input {}",
                    state, input
                ));
            }
        }
        
        // æ£€æŸ¥å½’çº¦-å½’çº¦å†²çª
        if let Action::Reduce(production_id1) = action {
            for ((state2, input2), action2) in &parser.action_table {
                if state == state2 && input == input2 {
                    if let Action::Reduce(production_id2) = action2 {
                        if production_id1 != production_id2 {
                            conflicts.push(format!(
                                "Reduce-Reduce conflict in state {} with input {}",
                                state, input
                            ));
                        }
                    }
                }
            }
        }
    }
    
    conflicts
}

#[test]
fn test_conflict_detection() {
    let grammar = create_arithmetic_grammar();
    let parser = ShiftReduceParser::new(grammar);
    let conflicts = detect_conflicts(&parser);
    
    if conflicts.is_empty() {
        println!("No conflicts detected");
    } else {
        for conflict in conflicts {
            println!("Conflict: {}", conflict);
        }
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å…¶ä»–è§£ææ–¹æ³•çš„æ¯”è¾ƒ

| è§£ææ–¹æ³• | æ–¹å‘ | æ–‡æ³•ç±» | å®ç°å¤æ‚åº¦ | é”™è¯¯æ¢å¤ |
|---------|------|--------|-----------|---------|
| è‡ªé¡¶å‘ä¸‹ | è‡ªé¡¶å‘ä¸‹ | LL(k) | ä¸­ç­‰ | å›°éš¾ |
| è‡ªåº•å‘ä¸Š | è‡ªåº•å‘ä¸Š | LR(k) | å¤æ‚ | ç®€å• |
| é€šç”¨è§£æ | ä»»æ„ | ä»»æ„ | æœ€å¤æ‚ | ä¸­ç­‰ |

### 6.2 è‡ªåº•å‘ä¸Šè§£æçš„å±€é™æ€§

1. **çŠ¶æ€çˆ†ç‚¸**ï¼šLR(1)è§£æå™¨çš„çŠ¶æ€æ•°å¯èƒ½æŒ‡æ•°çº§å¢é•¿
2. **å†²çªå¤„ç†**ï¼šæŸäº›æ–‡æ³•æ— æ³•é€šè¿‡ç®€å•çš„å‘å‰çœ‹è§£å†³å†²çª
3. **å®ç°å¤æ‚åº¦**ï¼šè‡ªåº•å‘ä¸Šè§£æå™¨çš„å®ç°ç›¸å¯¹å¤æ‚

### 6.3 ä¼˜åŒ–æŠ€æœ¯

1. **çŠ¶æ€åˆå¹¶**ï¼šLALR(1)é€šè¿‡åˆå¹¶ç›¸ä¼¼çŠ¶æ€å‡å°‘çŠ¶æ€æ•°
2. **è¡¨å‹ç¼©**ï¼šä½¿ç”¨å„ç§æŠ€æœ¯å‹ç¼©è§£æè¡¨å¤§å°
3. **å¢é‡è§£æ**ï¼šæ”¯æŒå¢é‡æ›´æ–°è§£æè¡¨
4. **é”™è¯¯æ¢å¤**ï¼šå®ç°å„ç§é”™è¯¯æ¢å¤ç­–ç•¥

## 7. å‚è€ƒæ–‡çŒ®

1. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). Compilers: Principles, Techniques, and Tools (2nd ed.). Pearson Education.
2. Knuth, D. E. (1965). On the translation of languages from left to right. Information and Control, 8(6), 607-639.
3. DeRemer, F. L. (1969). Practical translators for LR(k) languages. PhD thesis, MIT.
4. è‡ªåº•å‘ä¸Šè§£æç†è®ºä¸å®ç°
5. å¥æŸ„è¯†åˆ«ç®—æ³•ç ”ç©¶
