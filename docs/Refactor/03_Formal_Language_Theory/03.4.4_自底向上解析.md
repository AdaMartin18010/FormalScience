# 03.4.4 è‡ªåº•å‘ä¸Šè§£æ

## ğŸ“‹ æ¦‚è¿°

è‡ªåº•å‘ä¸Šè§£æï¼ˆBottom-Up Parsingï¼‰æ˜¯ä¸€ç§ä»è¾“å…¥ä¸²å¼€å§‹ï¼Œé€æ­¥å½’çº¦åˆ°å¼€å§‹ç¬¦å·çš„è¯­æ³•åˆ†ææ–¹æ³•ã€‚å®ƒé€šè¿‡è¯†åˆ«å¥æŸ„ï¼ˆhandleï¼‰å¹¶è¿›è¡Œå½’çº¦æ“ä½œæ¥æ„å»ºè¯­æ³•æ ‘ï¼Œæ˜¯LRè§£æå™¨å®¶æ—çš„æ ¸å¿ƒæŠ€æœ¯ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å½¢å¼åŒ–å®šä¹‰**ï¼šå»ºç«‹è‡ªåº•å‘ä¸Šè§£æçš„æ•°å­¦åŸºç¡€
2. **ç®—æ³•è®¾è®¡**ï¼šè®¾è®¡é«˜æ•ˆçš„å¥æŸ„è¯†åˆ«å’Œå½’çº¦ç®—æ³•
3. **å®ç°éªŒè¯**ï¼šæä¾›å®Œæ•´çš„ä»£ç å®ç°å’Œæµ‹è¯•
4. **æ€§èƒ½åˆ†æ**ï¼šåˆ†ææ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦
5. **åº”ç”¨æ‰©å±•**ï¼šæ¢è®¨åœ¨å®é™…ç¼–è¯‘å™¨ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [ç®—æ³•è®¾è®¡](#3-ç®—æ³•è®¾è®¡)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [å¤æ‚åº¦åˆ†æ](#5-å¤æ‚åº¦åˆ†æ)
6. [é”™è¯¯å¤„ç†](#6-é”™è¯¯å¤„ç†)
7. [ä¼˜åŒ–æŠ€æœ¯](#7-ä¼˜åŒ–æŠ€æœ¯)
8. [åº”ç”¨ç¤ºä¾‹](#8-åº”ç”¨ç¤ºä¾‹)
9. [ç›¸å…³ç†è®º](#9-ç›¸å…³ç†è®º)
10. [å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è‡ªåº•å‘ä¸Šè§£æåŸç†

è‡ªåº•å‘ä¸Šè§£æåŸºäºä»¥ä¸‹æ ¸å¿ƒæ€æƒ³ï¼š

**å®šä¹‰ 1.1** (è‡ªåº•å‘ä¸Šè§£æå™¨)
è‡ªåº•å‘ä¸Šè§£æå™¨æ˜¯ä¸€ä¸ªè¯­æ³•åˆ†æå™¨ï¼Œå…¶ä¸­ï¼š

- ä»è¾“å…¥ä¸²å¼€å§‹ï¼Œé€æ­¥å½’çº¦åˆ°å¼€å§‹ç¬¦å·
- é€šè¿‡è¯†åˆ«å¥æŸ„è¿›è¡Œå½’çº¦æ“ä½œ
- ä½¿ç”¨æ ˆæ¥ç»´æŠ¤è§£æçŠ¶æ€

**å®šç† 1.1** (è‡ªåº•å‘ä¸Šè§£æçš„æ­£ç¡®æ€§)
å¯¹äºLR(k)æ–‡æ³•Gï¼Œå­˜åœ¨è‡ªåº•å‘ä¸Šè§£æå™¨Pï¼Œä½¿å¾—ï¼š

- Pèƒ½å¤Ÿæ­£ç¡®è¯†åˆ«L(G)ä¸­çš„æ‰€æœ‰å¥å­
- Pçš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œå…¶ä¸­næ˜¯è¾“å…¥ä¸²çš„é•¿åº¦

### 1.2 å¥æŸ„è¯†åˆ«

**å®šä¹‰ 1.2** (å¥æŸ„)
å¯¹äºäº§ç”Ÿå¼A â†’ Î±ï¼Œå¦‚æœå­˜åœ¨æ¨å¯¼S â‡’* Î²AÎ³ â‡’ Î²Î±Î³ï¼Œå…¶ä¸­Î²Î±Î³æ˜¯å½“å‰æ ˆé¡¶çš„ç¬¦å·ä¸²ï¼Œåˆ™ç§°Î±æ˜¯å½“å‰æ ˆé¡¶çš„å¥æŸ„ã€‚

**å¼•ç† 1.1** (å¥æŸ„çš„å”¯ä¸€æ€§)
å¯¹äºLR(k)æ–‡æ³•Gå’Œè¾“å…¥ä¸²w âˆˆ L(G)ï¼Œåœ¨è§£æè¿‡ç¨‹ä¸­çš„æ¯ä¸ªæ—¶åˆ»ï¼Œå¥æŸ„æ˜¯å”¯ä¸€çš„ã€‚

### 1.3 å½’çº¦æ“ä½œ

**å®šä¹‰ 1.3** (å½’çº¦æ“ä½œ)
å½’çº¦æ“ä½œæ˜¯å°†æ ˆé¡¶çš„å¥æŸ„Î±æ›¿æ¢ä¸ºéç»ˆç»“ç¬¦Açš„è¿‡ç¨‹ï¼Œå…¶ä¸­A â†’ Î±æ˜¯ä¸€ä¸ªäº§ç”Ÿå¼ã€‚

**ç®—æ³• 1.1** (åŸºæœ¬å½’çº¦ç®—æ³•)

```
function reduce(stack, production):
    A -> Î± = production
    if stack.top() matches Î± then
        pop Î± from stack
        push A onto stack
        return true
    return false
```

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 è‡ªåº•å‘ä¸Šè§£æå™¨çš„å½¢å¼åŒ–æ¨¡å‹

**å®šä¹‰ 2.1** (è‡ªåº•å‘ä¸Šè§£æå™¨)
è‡ªåº•å‘ä¸Šè§£æå™¨æ˜¯ä¸€ä¸ªå…­å…ƒç»„P = (N, Î£, R, S, Î´, F)ï¼Œå…¶ä¸­ï¼š

- Næ˜¯éç»ˆç»“ç¬¦é›†åˆ
- Î£æ˜¯ç»ˆç»“ç¬¦é›†åˆ
- Ræ˜¯äº§ç”Ÿå¼é›†åˆ
- Sæ˜¯å¼€å§‹ç¬¦å·
- Î´æ˜¯è½¬ç§»å‡½æ•°ï¼šState Ã— Symbol â†’ Action
- Fæ˜¯æ¥å—çŠ¶æ€é›†åˆ

**å®šä¹‰ 2.2** (è§£æçŠ¶æ€)
è§£æçŠ¶æ€æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„(Stack, Input, Action)ï¼Œå…¶ä¸­ï¼š

- Stackæ˜¯ç¬¦å·æ ˆ
- Inputæ˜¯å‰©ä½™è¾“å…¥ä¸²
- Actionæ˜¯å½“å‰åŠ¨ä½œï¼ˆç§»è¿›/å½’çº¦/æ¥å—/é”™è¯¯ï¼‰

### 2.2 LR(k)æ–‡æ³•çš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.3** (LR(k)æ–‡æ³•)
æ–‡æ³•Gæ˜¯LR(k)çš„ï¼Œå½“ä¸”ä»…å½“ï¼š

- å¯¹äºä»»æ„ä¸¤ä¸ªä¸åŒçš„å³å¥å‹Î²Î±Î³å’ŒÎ²Î±'Î³'
- å¦‚æœFIRST_k(Î³) âˆ© FIRST_k(Î³') â‰  âˆ…
- åˆ™Î± = Î±'

**å®šç† 2.1** (LR(k)æ–‡æ³•çš„ç¡®å®šæ€§)
å¦‚æœæ–‡æ³•Gæ˜¯LR(k)çš„ï¼Œåˆ™å­˜åœ¨ç¡®å®šçš„è‡ªåº•å‘ä¸Šè§£æå™¨Pï¼Œä½¿å¾—ï¼š

- Pèƒ½å¤Ÿæ— æ­§ä¹‰åœ°è§£æL(G)
- Pçš„æ¯ä¸ªåŠ¨ä½œéƒ½æ˜¯ç¡®å®šçš„

## 3. ç®—æ³•è®¾è®¡

### 3.1 åŸºæœ¬è‡ªåº•å‘ä¸Šè§£æç®—æ³•

```rust
// è‡ªåº•å‘ä¸Šè§£æå™¨çš„æ ¸å¿ƒç®—æ³•
trait BottomUpParser {
    fn parse(&mut self, input: &str) -> Result<ParseTree, ParseError>;
    fn shift(&mut self, token: Token) -> Result<(), ParseError>;
    fn reduce(&mut self, production: &Production) -> Result<(), ParseError>;
    fn get_action(&self, state: State, token: &Token) -> Action;
}

impl BottomUpParser for Parser {
    fn parse(&mut self, input: &str) -> Result<ParseTree, ParseError> {
        self.tokens = self.lexer.tokenize(input)?;
        self.current = 0;
        self.stack.push(State::Initial);
        
        loop {
            let current_state = self.stack.top().unwrap();
            let lookahead = self.get_lookahead();
            let action = self.get_action(current_state, &lookahead);
            
            match action {
                Action::Shift(next_state) => {
                    self.shift(lookahead)?;
                    self.stack.push(next_state);
                },
                Action::Reduce(production) => {
                    self.reduce(&production)?;
                },
                Action::Accept => {
                    return Ok(self.build_tree());
                },
                Action::Error => {
                    return Err(ParseError::new("Parse error"));
                }
            }
        }
    }
    
    fn shift(&mut self, token: Token) -> Result<(), ParseError> {
        self.symbol_stack.push(Symbol::Terminal(token));
        Ok(())
    }
    
    fn reduce(&mut self, production: &Production) -> Result<(), ParseError> {
        // å¼¹å‡ºäº§ç”Ÿå¼å³éƒ¨çš„ç¬¦å·
        for _ in 0..production.rhs.len() {
            self.symbol_stack.pop();
            self.stack.pop();
        }
        
        // å‹å…¥äº§ç”Ÿå¼å·¦éƒ¨çš„éç»ˆç»“ç¬¦
        self.symbol_stack.push(Symbol::NonTerminal(production.lhs.clone()));
        
        // è®¡ç®—æ–°çš„çŠ¶æ€
        let current_state = self.stack.top().unwrap();
        let new_state = self.get_goto(current_state, &production.lhs)?;
        self.stack.push(new_state);
        
        Ok(())
    }
}
```

### 3.2 LR(0)è§£æè¡¨æ„å»ºç®—æ³•

```rust
// LR(0)è§£æè¡¨æ„å»ºç®—æ³•
struct LR0TableBuilder {
    grammar: Grammar,
    states: Vec<LR0State>,
    action_table: HashMap<(State, Token), Action>,
    goto_table: HashMap<(State, String), State>,
}

impl LR0TableBuilder {
    fn build(&mut self) -> Result<(), String> {
        // æ„å»ºè§„èŒƒLR(0)é¡¹é›†æ—
        self.build_canonical_collection()?;
        
        // æ„å»ºåŠ¨ä½œè¡¨å’Œè½¬ç§»è¡¨
        self.build_tables()?;
        
        Ok(())
    }
    
    fn build_canonical_collection(&mut self) -> Result<(), String> {
        // åˆå§‹é¡¹é›†
        let initial_item = LR0Item::new(
            self.grammar.start_symbol.clone(),
            vec![self.grammar.start_symbol.clone()],
            0
        );
        
        let initial_state = LR0State::new(vec![initial_item]);
        self.states.push(initial_state);
        
        // é—­åŒ…å’Œè½¬ç§»æ“ä½œ
        let mut unprocessed = vec![0];
        while let Some(state_idx) = unprocessed.pop() {
            let state = &self.states[state_idx];
            
            // è®¡ç®—é—­åŒ…
            let closure = self.compute_closure(state);
            
            // è®¡ç®—è½¬ç§»
            for symbol in self.grammar.all_symbols() {
                let goto = self.compute_goto(&closure, &symbol);
                if !goto.items.is_empty() {
                    let new_state_idx = self.add_state(goto);
                    if new_state_idx == self.states.len() - 1 {
                        unprocessed.push(new_state_idx);
                    }
                }
            }
        }
        
        Ok(())
    }
    
    fn compute_closure(&self, state: &LR0State) -> LR0State {
        let mut closure = state.clone();
        let mut changed = true;
        
        while changed {
            changed = false;
            for item in &closure.items {
                if let Some(next_symbol) = item.get_next_symbol() {
                    if let Symbol::NonTerminal(nt) = next_symbol {
                        for production in &self.grammar.productions {
                            if production.lhs == *nt {
                                let new_item = LR0Item::new(
                                    nt.clone(),
                                    production.rhs.clone(),
                                    0
                                );
                                if !closure.items.contains(&new_item) {
                                    closure.items.push(new_item);
                                    changed = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        closure
    }
    
    fn compute_goto(&self, state: &LR0State, symbol: &Symbol) -> LR0State {
        let mut goto_items = Vec::new();
        
        for item in &state.items {
            if let Some(next_symbol) = item.get_next_symbol() {
                if next_symbol == symbol {
                    let new_item = item.advance();
                    goto_items.push(new_item);
                }
            }
        }
        
        LR0State::new(goto_items)
    }
}
```

## 4. ä»£ç å®ç°

### 4.1 å®Œæ•´çš„è‡ªåº•å‘ä¸Šè§£æå™¨å®ç°

```rust
use std::collections::HashMap;
use std::error::Error;

#[derive(Debug, Clone, PartialEq)]
pub enum Token {
    Number(i64),
    Plus,
    Minus,
    Multiply,
    Divide,
    LeftParen,
    RightParen,
    Eof,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Symbol {
    Terminal(Token),
    NonTerminal(String),
}

#[derive(Debug)]
pub struct Production {
    pub lhs: String,
    pub rhs: Vec<Symbol>,
}

#[derive(Debug, Clone)]
pub enum Action {
    Shift(usize),
    Reduce(usize),
    Accept,
    Error,
}

#[derive(Debug)]
pub struct ParseTree {
    pub label: String,
    pub children: Vec<ParseTree>,
    pub value: Option<i64>,
}

impl ParseTree {
    pub fn new_leaf(token: Token) -> Self {
        let value = match token {
            Token::Number(n) => Some(n),
            _ => None,
        };
        ParseTree {
            label: format!("{:?}", token),
            children: vec![],
            value,
        }
    }
    
    pub fn new_node(label: &str, children: Vec<ParseTree>) -> Self {
        ParseTree {
            label: label.to_string(),
            children,
            value: None,
        }
    }
}

#[derive(Debug)]
pub struct ParseError {
    pub message: String,
    pub position: usize,
}

impl ParseError {
    pub fn new(message: &str) -> Self {
        ParseError {
            message: message.to_string(),
            position: 0,
        }
    }
}

pub struct BottomUpParser {
    tokens: Vec<Token>,
    current: usize,
    stack: Vec<usize>,
    symbol_stack: Vec<Symbol>,
    action_table: HashMap<(usize, Token), Action>,
    goto_table: HashMap<(usize, String), usize>,
    productions: Vec<Production>,
}

impl BottomUpParser {
    pub fn new() -> Self {
        let mut parser = BottomUpParser {
            tokens: vec![],
            current: 0,
            stack: vec![],
            symbol_stack: vec![],
            action_table: HashMap::new(),
            goto_table: HashMap::new(),
            productions: vec![],
        };
        
        // åˆå§‹åŒ–æ–‡æ³•
        parser.init_grammar();
        // æ„å»ºè§£æè¡¨
        parser.build_parse_table();
        
        parser
    }
    
    fn init_grammar(&mut self) {
        // å®šä¹‰è¡¨è¾¾å¼æ–‡æ³•
        // E -> E + T | E - T | T
        // T -> T * F | T / F | F
        // F -> ( E ) | number
        
        // æ¶ˆé™¤å·¦é€’å½’åçš„æ–‡æ³•
        // E -> T E'
        // E' -> + T E' | - T E' | Îµ
        // T -> F T'
        // T' -> * F T' | / F T' | Îµ
        // F -> ( E ) | number
        
        self.productions = vec![
            Production { lhs: "E".to_string(), rhs: vec![Symbol::NonTerminal("T".to_string()), Symbol::NonTerminal("E'".to_string())] },
            Production { lhs: "E'".to_string(), rhs: vec![Symbol::Terminal(Token::Plus), Symbol::NonTerminal("T".to_string()), Symbol::NonTerminal("E'".to_string())] },
            Production { lhs: "E'".to_string(), rhs: vec![Symbol::Terminal(Token::Minus), Symbol::NonTerminal("T".to_string()), Symbol::NonTerminal("E'".to_string())] },
            Production { lhs: "E'".to_string(), rhs: vec![] }, // Îµ
            Production { lhs: "T".to_string(), rhs: vec![Symbol::NonTerminal("F".to_string()), Symbol::NonTerminal("T'".to_string())] },
            Production { lhs: "T'".to_string(), rhs: vec![Symbol::Terminal(Token::Multiply), Symbol::NonTerminal("F".to_string()), Symbol::NonTerminal("T'".to_string())] },
            Production { lhs: "T'".to_string(), rhs: vec![Symbol::Terminal(Token::Divide), Symbol::NonTerminal("F".to_string()), Symbol::NonTerminal("T'".to_string())] },
            Production { lhs: "T'".to_string(), rhs: vec![] }, // Îµ
            Production { lhs: "F".to_string(), rhs: vec![Symbol::Terminal(Token::LeftParen), Symbol::NonTerminal("E".to_string()), Symbol::Terminal(Token::RightParen)] },
            Production { lhs: "F".to_string(), rhs: vec![Symbol::Terminal(Token::Number(0))] }, // å ä½ç¬¦
        ];
    }
    
    fn build_parse_table(&mut self) {
        // ç®€åŒ–çš„è§£æè¡¨æ„å»º
        // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œéœ€è¦æ„å»ºå®Œæ•´çš„LRè§£æè¡¨
        
        // ç¤ºä¾‹ï¼šçŠ¶æ€0çš„ç§»è¿›åŠ¨ä½œ
        self.action_table.insert((0, Token::Number(0)), Action::Shift(1));
        self.action_table.insert((0, Token::LeftParen), Action::Shift(2));
        
        // ç¤ºä¾‹ï¼šçŠ¶æ€1çš„å½’çº¦åŠ¨ä½œ
        self.action_table.insert((1, Token::Plus), Action::Reduce(9)); // F -> number
        self.action_table.insert((1, Token::Minus), Action::Reduce(9));
        self.action_table.insert((1, Token::Multiply), Action::Reduce(9));
        self.action_table.insert((1, Token::Divide), Action::Reduce(9));
        self.action_table.insert((1, Token::RightParen), Action::Reduce(9));
        self.action_table.insert((1, Token::Eof), Action::Reduce(9));
        
        // ç¤ºä¾‹ï¼šè½¬ç§»è¡¨
        self.goto_table.insert((0, "F".to_string()), 3);
        self.goto_table.insert((0, "T".to_string()), 4);
        self.goto_table.insert((0, "E".to_string()), 5);
    }
    
    pub fn parse(&mut self, input: &str) -> Result<ParseTree, ParseError> {
        self.tokens = self.tokenize(input)?;
        self.current = 0;
        self.stack.push(0);
        
        loop {
            let current_state = *self.stack.last().unwrap();
            let lookahead = self.get_lookahead();
            let action = self.get_action(current_state, &lookahead);
            
            match action {
                Action::Shift(next_state) => {
                    self.shift(lookahead)?;
                    self.stack.push(next_state);
                },
                Action::Reduce(production_idx) => {
                    self.reduce(production_idx)?;
                },
                Action::Accept => {
                    return Ok(self.build_tree());
                },
                Action::Error => {
                    return Err(ParseError::new("Parse error"));
                }
            }
        }
    }
    
    fn shift(&mut self, token: Token) -> Result<(), ParseError> {
        self.symbol_stack.push(Symbol::Terminal(token));
        self.current += 1;
        Ok(())
    }
    
    fn reduce(&mut self, production_idx: usize) -> Result<(), ParseError> {
        let production = &self.productions[production_idx];
        
        // å¼¹å‡ºäº§ç”Ÿå¼å³éƒ¨çš„ç¬¦å·
        for _ in 0..production.rhs.len() {
            self.symbol_stack.pop();
            self.stack.pop();
        }
        
        // å‹å…¥äº§ç”Ÿå¼å·¦éƒ¨çš„éç»ˆç»“ç¬¦
        self.symbol_stack.push(Symbol::NonTerminal(production.lhs.clone()));
        
        // è®¡ç®—æ–°çš„çŠ¶æ€
        let current_state = *self.stack.last().unwrap();
        if let Some(&new_state) = self.goto_table.get(&(current_state, production.lhs.clone())) {
            self.stack.push(new_state);
        } else {
            return Err(ParseError::new("Goto error"));
        }
        
        Ok(())
    }
    
    fn get_action(&self, state: usize, token: &Token) -> Action {
        self.action_table.get(&(state, token.clone())).cloned().unwrap_or(Action::Error)
    }
    
    fn get_lookahead(&self) -> Token {
        if self.current < self.tokens.len() {
            self.tokens[self.current].clone()
        } else {
            Token::Eof
        }
    }
    
    fn build_tree(&self) -> ParseTree {
        // ä»ç¬¦å·æ ˆæ„å»ºè¯­æ³•æ ‘
        // è¿™é‡Œç®€åŒ–å®ç°
        ParseTree::new_node("E", vec![])
    }
    
    fn tokenize(&self, input: &str) -> Result<Vec<Token>, ParseError> {
        let mut tokens = Vec::new();
        let mut chars = input.chars().peekable();
        
        while let Some(&ch) = chars.peek() {
            match ch {
                '0'..='9' => {
                    let mut num = 0;
                    while let Some(&digit) = chars.peek() {
                        if digit.is_ascii_digit() {
                            num = num * 10 + digit.to_digit(10).unwrap() as i64;
                            chars.next();
                        } else {
                            break;
                        }
                    }
                    tokens.push(Token::Number(num));
                },
                '+' => {
                    tokens.push(Token::Plus);
                    chars.next();
                },
                '-' => {
                    tokens.push(Token::Minus);
                    chars.next();
                },
                '*' => {
                    tokens.push(Token::Multiply);
                    chars.next();
                },
                '/' => {
                    tokens.push(Token::Divide);
                    chars.next();
                },
                '(' => {
                    tokens.push(Token::LeftParen);
                    chars.next();
                },
                ')' => {
                    tokens.push(Token::RightParen);
                    chars.next();
                },
                ' ' | '\t' | '\n' => {
                    chars.next();
                },
                _ => {
                    return Err(ParseError::new(&format!("Unexpected character: {}", ch)));
                }
            }
        }
        
        tokens.push(Token::Eof);
        Ok(tokens)
    }
}

// æµ‹è¯•ä»£ç 
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_simple_expression() {
        let mut parser = BottomUpParser::new();
        let result = parser.parse("2 + 3");
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_complex_expression() {
        let mut parser = BottomUpParser::new();
        let result = parser.parse("2 * 3 + 4");
        assert!(result.is_ok());
    }
}
```

### 4.2 Haskellå®ç°ç‰ˆæœ¬

```haskell
-- è‡ªåº•å‘ä¸Šè§£æå™¨çš„Haskellå®ç°
module BottomUpParser where

import Data.Char (isDigit)
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Maybe (fromMaybe)

-- æ•°æ®ç±»å‹å®šä¹‰
data Token = Number Int
           | Plus
           | Minus
           | Multiply
           | Divide
           | LeftParen
           | RightParen
           | Eof
           deriving (Show, Eq, Ord)

data Symbol = Terminal Token
            | NonTerminal String
            deriving (Show, Eq)

data Production = Production {
    lhs :: String,
    rhs :: [Symbol]
} deriving (Show)

data Action = Shift Int
            | Reduce Int
            | Accept
            | Error
            deriving (Show)

data ParseTree = Leaf Token
               | Node String [ParseTree]
               deriving (Show)

data ParseError = ParseError String deriving Show

-- è§£æå™¨çŠ¶æ€
data ParserState = ParserState {
    tokens :: [Token],
    position :: Int,
    stack :: [Int],
    symbolStack :: [Symbol]
} deriving Show

-- è§£æè¡¨
data ParseTable = ParseTable {
    actionTable :: Map (Int, Token) Action,
    gotoTable :: Map (Int, String) Int,
    productions :: [Production]
} deriving Show

-- åŸºæœ¬è§£æå™¨æ“ä½œ
class BottomUpParser a where
    parse :: a -> String -> Either ParseError ParseTree
    shift :: a -> ParserState -> Token -> Either ParseError ParserState
    reduce :: a -> ParserState -> Int -> Either ParseError ParserState
    getAction :: a -> Int -> Token -> Action

-- å…·ä½“å®ç°
data SimpleBottomUpParser = SimpleBottomUpParser {
    parseTable :: ParseTable
} deriving Show

instance BottomUpParser SimpleBottomUpParser where
    parse parser input = do
        tokens <- tokenize input
        let initialState = ParserState {
            tokens = tokens,
            position = 0,
            stack = [0],
            symbolStack = []
        }
        parseLoop parser initialState
    
    shift parser state token = Right state {
        tokens = tokens state,
        position = position state + 1,
        stack = stack state,
        symbolStack = Terminal token : symbolStack state
    }
    
    reduce parser state productionIdx = do
        let production = productions (parseTable parser) !! productionIdx
        let newSymbolStack = drop (length (rhs production)) (symbolStack state)
        let newStack = drop (length (rhs production)) (stack state)
        let newSymbolStack' = NonTerminal (lhs production) : newSymbolStack
        
        -- è®¡ç®—æ–°çš„çŠ¶æ€
        let currentState = head newStack
        let newState = fromMaybe 0 (Map.lookup (currentState, lhs production) (gotoTable (parseTable parser)))
        
        Right state {
            tokens = tokens state,
            position = position state,
            stack = newState : newStack,
            symbolStack = newSymbolStack'
        }
    
    getAction parser state token = fromMaybe Error (Map.lookup (state, token) (actionTable (parseTable parser)))

-- è§£æå¾ªç¯
parseLoop :: SimpleBottomUpParser -> ParserState -> Either ParseError ParseTree
parseLoop parser state = do
    let currentState = head (stack state)
    let lookahead = getLookahead state
    let action = getAction parser currentState lookahead
    
    case action of
        Shift nextState -> do
            newState <- shift parser state lookahead
            parseLoop parser newState { stack = nextState : stack newState }
        Reduce productionIdx -> do
            newState <- reduce parser state productionIdx
            parseLoop parser newState
        Accept -> Right (buildTree (symbolStack state))
        Error -> Left (ParseError "Parse error")

-- è¾…åŠ©å‡½æ•°
getLookahead :: ParserState -> Token
getLookahead state = 
    if position state < length (tokens state)
    then tokens state !! position state
    else Eof

buildTree :: [Symbol] -> ParseTree
buildTree symbols = Node "E" [] -- ç®€åŒ–å®ç°

-- è¯æ³•åˆ†æå™¨
tokenize :: String -> Either ParseError [Token]
tokenize input = tokenize' input []
  where
    tokenize' [] acc = Right (reverse acc ++ [Eof])
    tokenize' (c:cs) acc
        | isDigit c = let (num, rest) = span isDigit (c:cs)
                      in tokenize' rest (Number (read num) : acc)
        | c == '+' = tokenize' cs (Plus : acc)
        | c == '-' = tokenize' cs (Minus : acc)
        | c == '*' = tokenize' cs (Multiply : acc)
        | c == '/' = tokenize' cs (Divide : acc)
        | c == '(' = tokenize' cs (LeftParen : acc)
        | c == ')' = tokenize' cs (RightParen : acc)
        | c `elem` " \t\n" = tokenize' cs acc
        | otherwise = Left (ParseError ("Unexpected character: " ++ [c]))

-- åˆ›å»ºè§£æå™¨
createParser :: SimpleBottomUpParser
createParser = SimpleBottomUpParser {
    parseTable = ParseTable {
        actionTable = Map.fromList [
            ((0, Number 0), Shift 1),
            ((0, LeftParen), Shift 2),
            ((1, Plus), Reduce 9),
            ((1, Minus), Reduce 9),
            ((1, Multiply), Reduce 9),
            ((1, Divide), Reduce 9),
            ((1, RightParen), Reduce 9),
            ((1, Eof), Reduce 9)
        ],
        gotoTable = Map.fromList [
            ((0, "F"), 3),
            ((0, "T"), 4),
            ((0, "E"), 5)
        ],
        productions = [
            Production "E" [NonTerminal "T", NonTerminal "E'"],
            Production "E'" [Terminal Plus, NonTerminal "T", NonTerminal "E'"],
            Production "E'" [Terminal Minus, NonTerminal "T", NonTerminal "E'"],
            Production "E'" [],
            Production "T" [NonTerminal "F", NonTerminal "T'"],
            Production "T'" [Terminal Multiply, NonTerminal "F", NonTerminal "T'"],
            Production "T'" [Terminal Divide, NonTerminal "F", NonTerminal "T'"],
            Production "T'" [],
            Production "F" [Terminal LeftParen, NonTerminal "E", Terminal RightParen],
            Production "F" [Terminal (Number 0)]
        ]
    }
}

-- æµ‹è¯•å‡½æ•°
testParser :: IO ()
testParser = do
    putStrLn "Testing bottom-up parser..."
    
    let parser = createParser
    let testCases = [
            ("2 + 3", "Simple addition"),
            ("2 * 3 + 4", "Multiplication and addition"),
            ("(2 + 3) * 4", "Parenthesized expression")
        ]
    
    mapM_ (\(input, desc) -> do
        putStrLn $ "\n" ++ desc ++ ": " ++ input
        case parse parser input of
            Left err -> putStrLn $ "Error: " ++ show err
            Right tree -> putStrLn $ "Success: " ++ show tree
        ) testCases
```

## 5. å¤æ‚åº¦åˆ†æ

### 5.1 æ—¶é—´å¤æ‚åº¦åˆ†æ

**å®šç† 5.1** (è‡ªåº•å‘ä¸Šè§£æçš„æ—¶é—´å¤æ‚åº¦)
å¯¹äºè¾“å…¥ä¸²é•¿åº¦ä¸ºnçš„LR(k)æ–‡æ³•ï¼Œè‡ªåº•å‘ä¸Šè§£æå™¨çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ã€‚

**è¯æ˜**ï¼š

1. æ¯ä¸ªè¾“å…¥ç¬¦å·æœ€å¤šè¢«ç§»è¿›ä¸€æ¬¡
2. æ¯ä¸ªå½’çº¦æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸ºO(1)
3. æ€»çš„ç§»è¿›å’Œå½’çº¦æ“ä½œæ¬¡æ•°ä¸è¾“å…¥ä¸²é•¿åº¦æˆæ­£æ¯”
4. å› æ­¤æ€»æ—¶é—´å¤æ‚åº¦ä¸ºO(n)

### 5.2 ç©ºé—´å¤æ‚åº¦åˆ†æ

**å®šç† 5.2** (è‡ªåº•å‘ä¸Šè§£æçš„ç©ºé—´å¤æ‚åº¦)
è‡ªåº•å‘ä¸Šè§£æå™¨çš„ç©ºé—´å¤æ‚åº¦ä¸ºO(n)ï¼Œå…¶ä¸­næ˜¯è¾“å…¥ä¸²çš„é•¿åº¦ã€‚

**è¯æ˜**ï¼š

1. ç¬¦å·æ ˆçš„æœ€å¤§æ·±åº¦ä¸ºO(n)
2. çŠ¶æ€æ ˆçš„æœ€å¤§æ·±åº¦ä¸ºO(n)
3. æ¯ä¸ªæ ˆå…ƒç´ çš„ç©ºé—´ä¸ºO(1)
4. å› æ­¤æ€»ç©ºé—´å¤æ‚åº¦ä¸ºO(n)

### 5.3 è§£æè¡¨å¤§å°åˆ†æ

**å¼•ç† 5.1** (LRè§£æè¡¨çš„å¤§å°)
å¯¹äºæ–‡æ³•Gï¼ŒLRè§£æè¡¨çš„å¤§å°ä¸ºO(|N| Ã— |Î£| Ã— |States|)ï¼Œå…¶ä¸­ï¼š

- |N|æ˜¯éç»ˆç»“ç¬¦çš„æ•°é‡
- |Î£|æ˜¯ç»ˆç»“ç¬¦çš„æ•°é‡
- |States|æ˜¯çŠ¶æ€çš„æ•°é‡

**è¯æ˜**ï¼š

1. åŠ¨ä½œè¡¨çš„å¤§å°ä¸ºO(|States| Ã— |Î£|)
2. è½¬ç§»è¡¨çš„å¤§å°ä¸ºO(|States| Ã— |N|)
3. æ€»è¡¨å¤§å°ä¸ºO(|States| Ã— (|Î£| + |N|))

## 6. é”™è¯¯å¤„ç†

### 6.1 é”™è¯¯æ¢å¤ç­–ç•¥

```rust
// é”™è¯¯æ¢å¤çš„è‡ªåº•å‘ä¸Šè§£æå™¨
pub struct ErrorRecoveryBottomUpParser {
    tokens: Vec<Token>,
    current: usize,
    stack: Vec<usize>,
    symbol_stack: Vec<Symbol>,
    errors: Vec<ParseError>,
}

impl ErrorRecoveryBottomUpParser {
    pub fn new() -> Self {
        ErrorRecoveryBottomUpParser {
            tokens: vec![],
            current: 0,
            stack: vec![],
            symbol_stack: vec![],
            errors: vec![],
        }
    }
    
    fn panic_mode_recovery(&mut self) {
        // ææ…Œæ¨¡å¼é”™è¯¯æ¢å¤
        while self.current < self.tokens.len() {
            let token = &self.tokens[self.current];
            if self.is_synchronizing_token(token) {
                break;
            }
            self.current += 1;
        }
    }
    
    fn is_synchronizing_token(&self, token: &Token) -> bool {
        matches!(token, Token::Semicolon | Token::RightBrace | Token::RightParen)
    }
    
    fn report_error(&mut self, message: String) {
        self.errors.push(ParseError {
            message,
            position: self.current,
        });
    }
}
```

### 6.2 é”™è¯¯è¯Šæ–­

**å®šä¹‰ 6.1** (é”™è¯¯è¯Šæ–­)
é”™è¯¯è¯Šæ–­æ˜¯è¯†åˆ«å’ŒæŠ¥å‘Šè¯­æ³•é”™è¯¯çš„è¿‡ç¨‹ï¼ŒåŒ…æ‹¬ï¼š

- é”™è¯¯ä½ç½®å®šä½
- é”™è¯¯ç±»å‹åˆ†ç±»
- é”™è¯¯æ¢å¤å»ºè®®

**ç®—æ³• 6.1** (é”™è¯¯è¯Šæ–­ç®—æ³•)

```
function diagnose_error(state, token):
    expected = get_expected_tokens(state)
    suggestions = generate_suggestions(expected, token)
    return ErrorReport(expected, token, suggestions)
```

## 7. ä¼˜åŒ–æŠ€æœ¯

### 7.1 è§£æè¡¨å‹ç¼©

```rust
// è§£æè¡¨å‹ç¼©æŠ€æœ¯
pub struct CompressedParseTable {
    action_table: Vec<u32>, // å‹ç¼©çš„åŠ¨ä½œè¡¨
    goto_table: Vec<u32>,   // å‹ç¼©çš„è½¬ç§»è¡¨
    base_table: Vec<i32>,   // åŸºç¡€è¡¨
    check_table: Vec<i32>,  // æ£€æŸ¥è¡¨
}

impl CompressedParseTable {
    pub fn new() -> Self {
        CompressedParseTable {
            action_table: vec![],
            goto_table: vec![],
            base_table: vec![],
            check_table: vec![],
        }
    }
    
    pub fn compress(&mut self, original_table: &HashMap<(usize, Token), Action>) {
        // å®ç°è§£æè¡¨å‹ç¼©ç®—æ³•
        // ä½¿ç”¨ç¨€ç–çŸ©é˜µå‹ç¼©æŠ€æœ¯
    }
    
    pub fn get_action(&self, state: usize, token: &Token) -> Option<Action> {
        // ä»å‹ç¼©è¡¨ä¸­è·å–åŠ¨ä½œ
        None // ç®€åŒ–å®ç°
    }
}
```

### 7.2 å¹¶è¡Œè§£æ

```rust
// å¹¶è¡Œè‡ªåº•å‘ä¸Šè§£æå™¨
pub struct ParallelBottomUpParser {
    parsers: Vec<BottomUpParser>,
    chunk_size: usize,
}

impl ParallelBottomUpParser {
    pub fn new(num_threads: usize) -> Self {
        let mut parsers = Vec::new();
        for _ in 0..num_threads {
            parsers.push(BottomUpParser::new());
        }
        
        ParallelBottomUpParser {
            parsers,
            chunk_size: 1000,
        }
    }
    
    pub fn parse_parallel(&self, input: &str) -> Result<Vec<ParseTree>, ParseError> {
        // å°†è¾“å…¥åˆ†å‰²æˆå—
        let chunks = self.split_input(input);
        
        // å¹¶è¡Œè§£ææ¯ä¸ªå—
        let results: Result<Vec<_>, _> = chunks.into_par_iter()
            .enumerate()
            .map(|(i, chunk)| {
                self.parsers[i % self.parsers.len()].parse(chunk)
            })
            .collect();
        
        results
    }
    
    fn split_input(&self, input: &str) -> Vec<&str> {
        // å®ç°è¾“å…¥åˆ†å‰²é€»è¾‘
        vec![input]
    }
}
```

## 8. åº”ç”¨ç¤ºä¾‹

### 8.1 è¡¨è¾¾å¼è®¡ç®—å™¨

```rust
// åŸºäºè‡ªåº•å‘ä¸Šè§£æçš„è¡¨è¾¾å¼è®¡ç®—å™¨
pub struct ExpressionCalculator {
    parser: BottomUpParser,
}

impl ExpressionCalculator {
    pub fn new() -> Self {
        ExpressionCalculator {
            parser: BottomUpParser::new(),
        }
    }
    
    pub fn evaluate(&self, expression: &str) -> Result<i64, ParseError> {
        let tree = self.parser.parse(expression)?;
        self.evaluate_tree(&tree)
    }
    
    fn evaluate_tree(&self, tree: &ParseTree) -> Result<i64, ParseError> {
        match tree {
            ParseTree { label, children, value: Some(v) } if label.contains("Number") => {
                Ok(*v)
            },
            ParseTree { label, children, .. } if label == "E" => {
                if children.len() == 1 {
                    self.evaluate_tree(&children[0])
                } else {
                    let left = self.evaluate_tree(&children[0])?;
                    let right = self.evaluate_tree(&children[1])?;
                    Ok(left + right)
                }
            },
            ParseTree { label, children, .. } if label == "T" => {
                if children.len() == 1 {
                    self.evaluate_tree(&children[0])
                } else {
                    let left = self.evaluate_tree(&children[0])?;
                    let right = self.evaluate_tree(&children[1])?;
                    Ok(left * right)
                }
            },
            _ => Err(ParseError::new("Invalid parse tree"))
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let calculator = ExpressionCalculator::new();
    
    let expressions = vec![
        "2 + 3 * 4",
        "(2 + 3) * 4",
        "10 / 2 + 3 * 4",
        "1 + 2 + 3 + 4 + 5",
    ];
    
    for expr in expressions {
        match calculator.evaluate(expr) {
            Ok(result) => println!("{} = {}", expr, result),
            Err(e) => println!("Error evaluating {}: {}", expr, e.message),
        }
    }
}
```

### 8.2 é…ç½®è§£æå™¨

```rust
// åŸºäºè‡ªåº•å‘ä¸Šè§£æçš„é…ç½®è§£æå™¨
pub struct ConfigParser {
    parser: BottomUpParser,
}

impl ConfigParser {
    pub fn new() -> Self {
        ConfigParser {
            parser: BottomUpParser::new(),
        }
    }
    
    pub fn parse_config(&self, config: &str) -> Result<HashMap<String, String>, ParseError> {
        let tree = self.parser.parse(config)?;
        self.extract_config(&tree)
    }
    
    fn extract_config(&self, tree: &ParseTree) -> Result<HashMap<String, String>, ParseError> {
        let mut config = HashMap::new();
        
        // éå†è§£ææ ‘ï¼Œæå–é”®å€¼å¯¹
        self.traverse_config_tree(tree, &mut config)?;
        
        Ok(config)
    }
    
    fn traverse_config_tree(&self, tree: &ParseTree, config: &mut HashMap<String, String>) -> Result<(), ParseError> {
        // å®ç°é…ç½®æ ‘éå†é€»è¾‘
        Ok(())
    }
}
```

## 9. ç›¸å…³ç†è®º

### 9.1 ä¸å…¶ä»–è§£ææ–¹æ³•çš„æ¯”è¾ƒ

| ç‰¹æ€§ | è‡ªåº•å‘ä¸Š | è‡ªé¡¶å‘ä¸‹ | LLè§£æ | LRè§£æ |
|------|----------|----------|--------|--------|
| æ–¹å‘ | è‡ªåº•å‘ä¸Š | è‡ªé¡¶å‘ä¸‹ | è‡ªé¡¶å‘ä¸‹ | è‡ªåº•å‘ä¸Š |
| å›æº¯ | æ—  | å¯èƒ½æœ‰ | æ—  | æ—  |
| å®ç°å¤æ‚åº¦ | å¤æ‚ | ç®€å• | ä¸­ç­‰ | å¤æ‚ |
| é”™è¯¯å¤„ç† | å›°éš¾ | å®¹æ˜“ | å®¹æ˜“ | å›°éš¾ |
| æ€§èƒ½ | å¾ˆå¥½ | å¥½ | å¥½ | å¾ˆå¥½ |
| æ–‡æ³•é™åˆ¶ | è¾ƒå°‘ | è¾ƒå¤š | è¾ƒå¤š | è¾ƒå°‘ |

### 9.2 ç†è®ºè”ç³»

**å®šç† 9.1** (è‡ªåº•å‘ä¸Šä¸LRè§£æçš„å…³ç³»)
è‡ªåº•å‘ä¸Šè§£æå™¨æ˜¯LRè§£æå™¨çš„ä¸€ç§å®ç°æ–¹å¼ã€‚

**è¯æ˜**ï¼š

1. è‡ªåº•å‘ä¸Šè§£æå™¨ä½¿ç”¨æ ˆæ¥ç»´æŠ¤è§£æçŠ¶æ€
2. é€šè¿‡ç§»è¿›å’Œå½’çº¦æ“ä½œè¿›è¡Œè§£æ
3. è¿™ä¸LRè§£æå™¨çš„æ ¸å¿ƒæ€æƒ³ä¸€è‡´

**å®šç† 9.2** (è‡ªåº•å‘ä¸Šä¸è¯­æ³•æ ‘çš„å…³ç³»)
è‡ªåº•å‘ä¸Šè§£æå™¨é€šè¿‡å½’çº¦æ“ä½œæ„å»ºè¯­æ³•æ ‘ã€‚

**è¯æ˜**ï¼š

1. æ¯æ¬¡å½’çº¦æ“ä½œå°†å¥æŸ„æ›¿æ¢ä¸ºéç»ˆç»“ç¬¦
2. å½’çº¦è¿‡ç¨‹å¯¹åº”è¯­æ³•æ ‘çš„æ„å»ºè¿‡ç¨‹
3. æœ€ç»ˆçš„ç¬¦å·æ ˆå¯¹åº”å®Œæ•´çš„è¯­æ³•æ ‘

## 10. å‚è€ƒæ–‡çŒ®

1. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). *Compilers: Principles, Techniques, and Tools* (2nd ed.). Pearson Education.

2. Grune, D., & Jacobs, C. J. (2008). *Parsing Techniques: A Practical Guide* (2nd ed.). Springer.

3. Appel, A. W. (1998). *Modern Compiler Implementation in ML*. Cambridge University Press.

4. Cooper, K. D., & Torczon, L. (2011). *Engineering a Compiler* (3rd ed.). Morgan Kaufmann.

5. Wirth, N. (1996). *Compiler Construction*. Addison-Wesley.

6. Fischer, C. N., & LeBlanc, R. J. (1991). *Crafting a Compiler*. Benjamin/Cummings.

7. Wilhelm, R., & Seidl, H. (2010). *Compiler Design: Virtual Machines*. Springer.

8. Muchnick, S. S. (1997). *Advanced Compiler Design and Implementation*. Morgan Kaufmann.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [03.4.1 LLè§£æ](../03.4.1_LLè§£æ.md)
- [03.4.2 LRè§£æ](../03.4.2_LRè§£æ.md)
- [03.4.3 é€’å½’ä¸‹é™è§£æ](../03.4.3_é€’å½’ä¸‹é™è§£æ.md)
- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03.2.2_ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•.md)
- [03.3.1 ä¹”å§†æ–¯åŸºè°±ç³»](../03.3.1_ä¹”å§†æ–¯åŸºè°±ç³».md)
