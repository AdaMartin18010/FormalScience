# 03.1.4 å›¾çµæœº

## ğŸ“‹ æ¦‚è¿°

å›¾çµæœºæ˜¯è®¡ç®—ç†è®ºä¸­æœ€é‡è¦å’Œæœ€åŸºç¡€çš„æ¨¡å‹ï¼Œå®ƒç”±è‰¾ä¼¦Â·å›¾çµåœ¨1936å¹´æå‡ºï¼Œè¢«è®¤ä¸ºæ˜¯ç°ä»£è®¡ç®—æœºçš„ç†è®ºåŸºç¡€ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦æ„å»ºå›¾çµæœºçš„ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬å›¾çµæœºçš„å®šä¹‰ã€æ€§è´¨å’Œè®¡ç®—èƒ½åŠ›ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹å›¾çµæœºçš„å½¢å¼åŒ–åŸºç¡€**
2. **åˆ†æå›¾çµæœºçš„è®¡ç®—æ¨¡å‹**
3. **æ¢è®¨å›¾çµæœºçš„è®¡ç®—èƒ½åŠ›**
4. **ç ”ç©¶å›¾çµæœºçš„å˜ä½“**
5. **æ„å»ºå›¾çµæœºçš„åº”ç”¨æ¡†æ¶**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å›¾çµæœºçš„å®šä¹‰

å›¾çµæœºæ˜¯ä¸€ä¸ªæŠ½è±¡çš„è®¡ç®—æ¨¡å‹ï¼ŒåŒ…å«ï¼š

- **æœ‰é™çŠ¶æ€æ§åˆ¶å™¨**ï¼šæ§åˆ¶è®¡ç®—è¿‡ç¨‹
- **æ— é™é•¿çš„ç£å¸¦**ï¼šå­˜å‚¨è¾“å…¥ã€è¾“å‡ºå’Œä¸­é—´ç»“æœ
- **è¯»å†™å¤´**ï¼šåœ¨ç£å¸¦ä¸Šç§»åŠ¨å¹¶è¯»å†™ç¬¦å·
- **è½¬ç§»å‡½æ•°**ï¼šå®šä¹‰çŠ¶æ€è½¬ç§»è§„åˆ™

### 1.2 å›¾çµæœºçš„åŸºæœ¬ç»„æˆ

1. **çŠ¶æ€é›†åˆ**ï¼šæœ‰é™çš„çŠ¶æ€é›†åˆ
2. **å­—æ¯è¡¨**ï¼šè¾“å…¥å­—æ¯è¡¨å’Œç£å¸¦å­—æ¯è¡¨
3. **è½¬ç§»å‡½æ•°**ï¼šçŠ¶æ€è½¬ç§»è§„åˆ™
4. **åˆå§‹çŠ¶æ€**ï¼šè®¡ç®—çš„èµ·å§‹çŠ¶æ€
5. **æ¥å—çŠ¶æ€**ï¼šè®¡ç®—æˆåŠŸç»“æŸçš„çŠ¶æ€
6. **æ‹’ç»çŠ¶æ€**ï¼šè®¡ç®—å¤±è´¥ç»“æŸçš„çŠ¶æ€

### 1.3 å›¾çµæœºçš„è®¡ç®—è¿‡ç¨‹

1. **åˆå§‹åŒ–**ï¼šå°†è¾“å…¥å†™åœ¨ç£å¸¦ä¸Šï¼Œè¯»å†™å¤´æŒ‡å‘æœ€å·¦ç«¯
2. **è®¡ç®—æ­¥éª¤**ï¼šæ ¹æ®å½“å‰çŠ¶æ€å’Œè¯»åˆ°çš„ç¬¦å·æ‰§è¡Œè½¬ç§»
3. **ç»ˆæ­¢æ¡ä»¶**ï¼šè¾¾åˆ°æ¥å—æˆ–æ‹’ç»çŠ¶æ€
4. **è¾“å‡º**ï¼šæ ¹æ®ç»ˆæ­¢çŠ¶æ€åˆ¤æ–­æ˜¯å¦æ¥å—è¾“å…¥

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å›¾çµæœºçš„åŸºæœ¬å®šä¹‰

**å®šä¹‰ 2.1.1** (å›¾çµæœº)
ä¸€ä¸ªå›¾çµæœºæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $M = (Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})$ï¼Œå…¶ä¸­ï¼š

- $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\Gamma$ æ˜¯ç£å¸¦å­—æ¯è¡¨ï¼Œæ»¡è¶³ $\Sigma \subseteq \Gamma$
- $\delta: Q \times \Gamma \to Q \times \Gamma \times \{L, R\}$ æ˜¯è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $q_{accept} \in Q$ æ˜¯æ¥å—çŠ¶æ€
- $q_{reject} \in Q$ æ˜¯æ‹’ç»çŠ¶æ€

### 2.2 é…ç½®

**å®šä¹‰ 2.2.1** (é…ç½®)
å›¾çµæœºçš„ä¸€ä¸ªé…ç½®æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(q, w, i)$ï¼Œå…¶ä¸­ï¼š

- $q \in Q$ æ˜¯å½“å‰çŠ¶æ€
- $w \in \Gamma^*$ æ˜¯ç£å¸¦å†…å®¹
- $i \in \mathbb{N}$ æ˜¯è¯»å†™å¤´ä½ç½®

### 2.3 è½¬ç§»å…³ç³»

**å®šä¹‰ 2.3.1** (è½¬ç§»å…³ç³»)
é…ç½®ä¹‹é—´çš„è½¬ç§»å…³ç³» $\vdash_M$ å®šä¹‰ä¸ºï¼š

$$(q, w, i) \vdash_M (q', w', i')$$

å½“ä¸”ä»…å½“ $\delta(q, w_i) = (q', \sigma, D)$ï¼Œå…¶ä¸­ï¼š

- $w'_i = \sigma$
- $w'_j = w_j$ å¯¹äº $j \neq i$
- $i' = i + 1$ å¦‚æœ $D = R$
- $i' = i - 1$ å¦‚æœ $D = L$

### 2.4 è®¡ç®—

**å®šä¹‰ 2.4.1** (è®¡ç®—)
å›¾çµæœº $M$ å¯¹è¾“å…¥ $w$ çš„è®¡ç®—æ˜¯ä¸€ä¸ªé…ç½®åºåˆ—ï¼š

$$C_0 \vdash_M C_1 \vdash_M \cdots \vdash_M C_k$$

å…¶ä¸­ $C_0 = (q_0, w, 0)$ æ˜¯åˆå§‹é…ç½®ã€‚

### 2.5 è¯­è¨€æ¥å—

**å®šä¹‰ 2.5.1** (è¯­è¨€æ¥å—)
å›¾çµæœº $M$ æ¥å—çš„è¯­è¨€æ˜¯ï¼š

$$L(M) = \{w \in \Sigma^* : M \text{ æ¥å— } w\}$$

å…¶ä¸­ $M$ æ¥å— $w$ å½“ä¸”ä»…å½“å­˜åœ¨è®¡ç®—åºåˆ—ä»¥æ¥å—çŠ¶æ€ç»“æŸã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 å›¾çµæœºçš„è®¡ç®—èƒ½åŠ›

**å®šç† 3.1.1** (å›¾çµæœºçš„é€šç”¨æ€§)
å›¾çµæœºå¯ä»¥è®¡ç®—ä»»ä½•å¯è®¡ç®—çš„å‡½æ•°ã€‚

**è¯æ˜**ï¼š

1. å›¾çµæœºå¯ä»¥æ¨¡æ‹Ÿä»»ä½•æœ‰é™çŠ¶æ€è‡ªåŠ¨æœº
2. å›¾çµæœºå¯ä»¥æ¨¡æ‹Ÿä¸‹æ¨è‡ªåŠ¨æœº
3. å›¾çµæœºå¯ä»¥æ¨¡æ‹Ÿçº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº
4. å›¾çµæœºå…·æœ‰æ— é™å­˜å‚¨èƒ½åŠ›
5. å› æ­¤å›¾çµæœºå…·æœ‰é€šç”¨è®¡ç®—èƒ½åŠ›

### 3.2 åœæœºé—®é¢˜

**å®šç† 3.2.1** (åœæœºé—®é¢˜ä¸å¯åˆ¤å®šæ€§)
åœæœºé—®é¢˜æ˜¯ä¸å¯åˆ¤å®šçš„ï¼Œå³ä¸å­˜åœ¨å›¾çµæœºå¯ä»¥åˆ¤å®šä»»æ„å›¾çµæœºæ˜¯å¦åœæœºã€‚

**è¯æ˜**ï¼š

1. å‡è®¾å­˜åœ¨å›¾çµæœº $H$ å¯ä»¥åˆ¤å®šåœæœºé—®é¢˜
2. æ„é€ å›¾çµæœº $D$ï¼Œå®ƒæ¥å—è¾“å…¥ $M$ å½“ä¸”ä»…å½“ $M$ ä¸æ¥å— $M$
3. è€ƒè™‘ $D$ å¯¹è¾“å…¥ $D$ çš„è¡Œä¸º
4. å¦‚æœ $D$ æ¥å— $D$ï¼Œåˆ™ $D$ ä¸æ¥å— $D$ï¼ŒçŸ›ç›¾
5. å¦‚æœ $D$ ä¸æ¥å— $D$ï¼Œåˆ™ $D$ æ¥å— $D$ï¼ŒçŸ›ç›¾
6. å› æ­¤ $H$ ä¸å­˜åœ¨

### 3.3 ä¸˜å¥‡-å›¾çµè®ºé¢˜

**å®šç† 3.3.1** (ä¸˜å¥‡-å›¾çµè®ºé¢˜)
ä»»ä½•å¯è®¡ç®—çš„å‡½æ•°éƒ½å¯ä»¥ç”±å›¾çµæœºè®¡ç®—ã€‚

**è¯æ˜**ï¼š

1. æ‰€æœ‰å·²çŸ¥çš„è®¡ç®—æ¨¡å‹éƒ½å¯ä»¥ç”±å›¾çµæœºæ¨¡æ‹Ÿ
2. å›¾çµæœºå¯ä»¥æ¨¡æ‹Ÿé€’å½’å‡½æ•°
3. å›¾çµæœºå¯ä»¥æ¨¡æ‹ŸÎ»æ¼”ç®—
4. å›¾çµæœºå¯ä»¥æ¨¡æ‹Ÿå¯„å­˜å™¨æœº
5. å› æ­¤å›¾çµæœºå…·æœ‰é€šç”¨è®¡ç®—èƒ½åŠ›

### 3.4 å›¾çµæœºçš„ç­‰ä»·æ€§

**å®šç† 3.4.1** (å›¾çµæœºç­‰ä»·æ€§)
æ‰€æœ‰å›¾çµæœºå˜ä½“åœ¨è®¡ç®—èƒ½åŠ›ä¸Šæ˜¯ç­‰ä»·çš„ã€‚

**è¯æ˜**ï¼š

1. å¤šå¸¦å›¾çµæœºå¯ä»¥ç”±å›¾çµæœºæ¨¡æ‹Ÿ
2. éç¡®å®šæ€§å›¾çµæœºå¯ä»¥ç”±å›¾çµæœºæ¨¡æ‹Ÿ
3. éšæœºè®¿é—®å›¾çµæœºå¯ä»¥ç”±å›¾çµæœºæ¨¡æ‹Ÿ
4. å› æ­¤æ‰€æœ‰å˜ä½“ç­‰ä»·

## 4. ä»£ç å®ç°

### 4.1 å›¾çµæœºå®ç°

```rust
use std::collections::HashMap;

/// å›¾çµæœºæ–¹å‘
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Direction {
    Left,
    Right,
}

/// å›¾çµæœºçŠ¶æ€
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct State(String);

/// å›¾çµæœºç¬¦å·
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Symbol(char);

/// å›¾çµæœºè½¬ç§»
#[derive(Debug, Clone)]
pub struct Transition {
    next_state: State,
    write_symbol: Symbol,
    direction: Direction,
}

/// å›¾çµæœºé…ç½®
#[derive(Debug, Clone)]
pub struct Configuration {
    state: State,
    tape: Vec<Symbol>,
    head_position: usize,
}

/// å›¾çµæœº
#[derive(Debug, Clone)]
pub struct TuringMachine {
    states: Vec<State>,
    input_alphabet: Vec<Symbol>,
    tape_alphabet: Vec<Symbol>,
    transition_function: HashMap<(State, Symbol), Transition>,
    initial_state: State,
    accept_state: State,
    reject_state: State,
    blank_symbol: Symbol,
}

impl TuringMachine {
    /// åˆ›å»ºæ–°çš„å›¾çµæœº
    pub fn new(
        states: Vec<State>,
        input_alphabet: Vec<Symbol>,
        tape_alphabet: Vec<Symbol>,
        initial_state: State,
        accept_state: State,
        reject_state: State,
        blank_symbol: Symbol,
    ) -> Self {
        Self {
            states,
            input_alphabet,
            tape_alphabet,
            transition_function: HashMap::new(),
            initial_state,
            accept_state,
            reject_state,
            blank_symbol,
        }
    }
    
    /// æ·»åŠ è½¬ç§»è§„åˆ™
    pub fn add_transition(
        &mut self,
        current_state: State,
        read_symbol: Symbol,
        next_state: State,
        write_symbol: Symbol,
        direction: Direction,
    ) -> Result<(), String> {
        // éªŒè¯çŠ¶æ€å’Œç¬¦å·çš„æœ‰æ•ˆæ€§
        if !self.states.contains(&current_state) {
            return Err("æ— æ•ˆçš„å½“å‰çŠ¶æ€".to_string());
        }
        if !self.states.contains(&next_state) {
            return Err("æ— æ•ˆçš„ä¸‹ä¸€ä¸ªçŠ¶æ€".to_string());
        }
        if !self.tape_alphabet.contains(&read_symbol) {
            return Err("æ— æ•ˆçš„è¯»å–ç¬¦å·".to_string());
        }
        if !self.tape_alphabet.contains(&write_symbol) {
            return Err("æ— æ•ˆçš„å†™å…¥ç¬¦å·".to_string());
        }
        
        let transition = Transition {
            next_state,
            write_symbol,
            direction,
        };
        
        self.transition_function.insert((current_state, read_symbol), transition);
        Ok(())
    }
    
    /// è¿è¡Œå›¾çµæœº
    pub fn run(&self, input: &str) -> TuringMachineResult {
        // åˆå§‹åŒ–é…ç½®
        let mut config = Configuration {
            state: self.initial_state.clone(),
            tape: input.chars().map(Symbol).collect(),
            head_position: 0,
        };
        
        // ç¡®ä¿ç£å¸¦è¶³å¤Ÿé•¿
        if config.tape.is_empty() {
            config.tape.push(self.blank_symbol.clone());
        }
        
        let mut step_count = 0;
        let max_steps = 10000; // é˜²æ­¢æ— é™å¾ªç¯
        
        while step_count < max_steps {
            // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°ç»ˆæ­¢çŠ¶æ€
            if config.state == self.accept_state {
                return TuringMachineResult::Accept(config.tape);
            }
            if config.state == self.reject_state {
                return TuringMachineResult::Reject(config.tape);
            }
            
            // è·å–å½“å‰ç¬¦å·
            let current_symbol = if config.head_position < config.tape.len() {
                config.tape[config.head_position].clone()
            } else {
                self.blank_symbol.clone()
            };
            
            // æŸ¥æ‰¾è½¬ç§»è§„åˆ™
            let key = (config.state.clone(), current_symbol);
            if let Some(transition) = self.transition_function.get(&key) {
                // æ‰§è¡Œè½¬ç§»
                config.state = transition.next_state.clone();
                
                // å†™å…¥ç¬¦å·
                if config.head_position < config.tape.len() {
                    config.tape[config.head_position] = transition.write_symbol.clone();
                } else {
                    config.tape.push(transition.write_symbol.clone());
                }
                
                // ç§»åŠ¨è¯»å†™å¤´
                match transition.direction {
                    Direction::Left => {
                        if config.head_position > 0 {
                            config.head_position -= 1;
                        }
                    }
                    Direction::Right => {
                        config.head_position += 1;
                        if config.head_position >= config.tape.len() {
                            config.tape.push(self.blank_symbol.clone());
                        }
                    }
                }
            } else {
                // æ²¡æœ‰è½¬ç§»è§„åˆ™ï¼Œæ‹’ç»
                return TuringMachineResult::Reject(config.tape);
            }
            
            step_count += 1;
        }
        
        TuringMachineResult::Timeout(config.tape)
    }
    
    /// æ£€æŸ¥è¾“å…¥æ˜¯å¦è¢«æ¥å—
    pub fn accepts(&self, input: &str) -> bool {
        matches!(self.run(input), TuringMachineResult::Accept(_))
    }
    
    /// è·å–å›¾çµæœºçš„è¯­è¨€
    pub fn get_language(&self) -> Vec<String> {
        // ç®€åŒ–å®ç°ï¼šè¿”å›ä¸€äº›æµ‹è¯•å­—ç¬¦ä¸²
        vec![
            "0".to_string(),
            "00".to_string(),
            "000".to_string(),
        ]
    }
}

/// å›¾çµæœºè¿è¡Œç»“æœ
#[derive(Debug, Clone)]
pub enum TuringMachineResult {
    Accept(Vec<Symbol>),
    Reject(Vec<Symbol>),
    Timeout(Vec<Symbol>),
}

/// å›¾çµæœºåˆ†æå™¨
pub struct TuringMachineAnalyzer;

impl TuringMachineAnalyzer {
    /// åˆ†æå›¾çµæœºçš„æ€§è´¨
    pub fn analyze(&self, tm: &TuringMachine) -> TuringMachineAnalysis {
        let is_deterministic = self.is_deterministic(tm);
        let is_complete = self.is_complete(tm);
        let state_count = tm.states.len();
        let transition_count = tm.transition_function.len();
        
        TuringMachineAnalysis {
            is_deterministic,
            is_complete,
            state_count,
            transition_count,
            complexity: self.estimate_complexity(tm),
        }
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºç¡®å®šæ€§å›¾çµæœº
    fn is_deterministic(&self, tm: &TuringMachine) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥è½¬ç§»å‡½æ•°æ˜¯å¦å”¯ä¸€
        let mut seen = std::collections::HashSet::new();
        for key in tm.transition_function.keys() {
            if !seen.insert(key) {
                return false;
            }
        }
        true
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºå®Œæ•´å›¾çµæœº
    fn is_complete(&self, tm: &TuringMachine) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„è½¬ç§»è§„åˆ™
        tm.transition_function.len() >= tm.states.len() * tm.tape_alphabet.len() / 2
    }
    
    /// ä¼°è®¡å›¾çµæœºçš„å¤æ‚åº¦
    fn estimate_complexity(&self, tm: &TuringMachine) -> Complexity {
        let state_complexity = tm.states.len();
        let transition_complexity = tm.transition_function.len();
        
        if state_complexity <= 5 && transition_complexity <= 10 {
            Complexity::Simple
        } else if state_complexity <= 20 && transition_complexity <= 50 {
            Complexity::Moderate
        } else {
            Complexity::Complex
        }
    }
    
    /// æ¨¡æ‹Ÿå›¾çµæœº
    pub fn simulate(&self, tm: &TuringMachine, input: &str, max_steps: usize) -> SimulationResult {
        let mut config = Configuration {
            state: tm.initial_state.clone(),
            tape: input.chars().map(Symbol).collect(),
            head_position: 0,
        };
        
        let mut history = Vec::new();
        let mut step_count = 0;
        
        while step_count < max_steps {
            history.push(config.clone());
            
            if config.state == tm.accept_state {
                return SimulationResult::Accept(history);
            }
            if config.state == tm.reject_state {
                return SimulationResult::Reject(history);
            }
            
            // æ‰§è¡Œä¸€æ­¥è®¡ç®—
            let current_symbol = if config.head_position < config.tape.len() {
                config.tape[config.head_position].clone()
            } else {
                tm.blank_symbol.clone()
            };
            
            let key = (config.state.clone(), current_symbol);
            if let Some(transition) = tm.transition_function.get(&key) {
                config.state = transition.next_state.clone();
                
                if config.head_position < config.tape.len() {
                    config.tape[config.head_position] = transition.write_symbol.clone();
                } else {
                    config.tape.push(transition.write_symbol.clone());
                }
                
                match transition.direction {
                    Direction::Left => {
                        if config.head_position > 0 {
                            config.head_position -= 1;
                        }
                    }
                    Direction::Right => {
                        config.head_position += 1;
                        if config.head_position >= config.tape.len() {
                            config.tape.push(tm.blank_symbol.clone());
                        }
                    }
                }
            } else {
                return SimulationResult::Reject(history);
            }
            
            step_count += 1;
        }
        
        SimulationResult::Timeout(history)
    }
}

/// å›¾çµæœºåˆ†æç»“æœ
#[derive(Debug, Clone)]
pub struct TuringMachineAnalysis {
    is_deterministic: bool,
    is_complete: bool,
    state_count: usize,
    transition_count: usize,
    complexity: Complexity,
}

/// å¤æ‚åº¦çº§åˆ«
#[derive(Debug, Clone)]
pub enum Complexity {
    Simple,
    Moderate,
    Complex,
}

/// æ¨¡æ‹Ÿç»“æœ
#[derive(Debug, Clone)]
pub enum SimulationResult {
    Accept(Vec<Configuration>),
    Reject(Vec<Configuration>),
    Timeout(Vec<Configuration>),
}

/// é€šç”¨å›¾çµæœº
pub struct UniversalTuringMachine {
    description_tape: Vec<Symbol>,
    data_tape: Vec<Symbol>,
    program_tape: Vec<Symbol>,
}

impl UniversalTuringMachine {
    /// åˆ›å»ºé€šç”¨å›¾çµæœº
    pub fn new() -> Self {
        Self {
            description_tape: Vec::new(),
            data_tape: Vec::new(),
            program_tape: Vec::new(),
        }
    }
    
    /// ç¼–ç å›¾çµæœº
    pub fn encode_turing_machine(&mut self, tm: &TuringMachine) -> String {
        // ç®€åŒ–å®ç°ï¼šå°†å›¾çµæœºç¼–ç ä¸ºå­—ç¬¦ä¸²
        let mut encoding = String::new();
        
        // ç¼–ç çŠ¶æ€
        for state in &tm.states {
            encoding.push_str(&format!("S:{};", state.0));
        }
        
        // ç¼–ç è½¬ç§»å‡½æ•°
        for ((state, symbol), transition) in &tm.transition_function {
            encoding.push_str(&format!("T:{}:{}:{}:{}:{};", 
                state.0, symbol.0, transition.next_state.0, 
                transition.write_symbol.0, 
                if transition.direction == Direction::Left { "L" } else { "R" }));
        }
        
        encoding
    }
    
    /// è¿è¡Œç¼–ç çš„å›¾çµæœº
    pub fn run_encoded(&self, encoding: &str, input: &str) -> TuringMachineResult {
        // ç®€åŒ–å®ç°ï¼šè§£æç¼–ç å¹¶è¿è¡Œ
        let tm = self.decode_turing_machine(encoding);
        tm.run(input)
    }
    
    /// è§£ç å›¾çµæœº
    fn decode_turing_machine(&self, encoding: &str) -> TuringMachine {
        // ç®€åŒ–å®ç°ï¼šä»ç¼–ç é‡å»ºå›¾çµæœº
        let states = vec![State("q0".to_string()), State("q1".to_string())];
        let input_alphabet = vec![Symbol('0'), Symbol('1')];
        let tape_alphabet = vec![Symbol('0'), Symbol('1'), Symbol('B')];
        let initial_state = State("q0".to_string());
        let accept_state = State("q1".to_string());
        let reject_state = State("q2".to_string());
        let blank_symbol = Symbol('B');
        
        let mut tm = TuringMachine::new(
            states, input_alphabet, tape_alphabet,
            initial_state, accept_state, reject_state, blank_symbol,
        );
        
        tm
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_turing_machine_creation() {
        let states = vec![
            State("q0".to_string()),
            State("q1".to_string()),
            State("q2".to_string()),
        ];
        let input_alphabet = vec![Symbol('0'), Symbol('1')];
        let tape_alphabet = vec![Symbol('0'), Symbol('1'), Symbol('B')];
        let initial_state = State("q0".to_string());
        let accept_state = State("q1".to_string());
        let reject_state = State("q2".to_string());
        let blank_symbol = Symbol('B');
        
        let mut tm = TuringMachine::new(
            states, input_alphabet, tape_alphabet,
            initial_state, accept_state, reject_state, blank_symbol,
        );
        
        // æ·»åŠ è½¬ç§»è§„åˆ™
        tm.add_transition(
            State("q0".to_string()),
            Symbol('0'),
            State("q1".to_string()),
            Symbol('1'),
            Direction::Right,
        ).unwrap();
        
        assert_eq!(tm.transition_function.len(), 1);
    }

    #[test]
    fn test_turing_machine_run() {
        let states = vec![
            State("q0".to_string()),
            State("q1".to_string()),
            State("q2".to_string()),
        ];
        let input_alphabet = vec![Symbol('0'), Symbol('1')];
        let tape_alphabet = vec![Symbol('0'), Symbol('1'), Symbol('B')];
        let initial_state = State("q0".to_string());
        let accept_state = State("q1".to_string());
        let reject_state = State("q2".to_string());
        let blank_symbol = Symbol('B');
        
        let mut tm = TuringMachine::new(
            states, input_alphabet, tape_alphabet,
            initial_state, accept_state, reject_state, blank_symbol,
        );
        
        // ç®€å•çš„æ¥å—æ‰€æœ‰è¾“å…¥çš„å›¾çµæœº
        tm.add_transition(
            State("q0".to_string()),
            Symbol('0'),
            State("q1".to_string()),
            Symbol('0'),
            Direction::Right,
        ).unwrap();
        
        tm.add_transition(
            State("q0".to_string()),
            Symbol('1'),
            State("q1".to_string()),
            Symbol('1'),
            Direction::Right,
        ).unwrap();
        
        let result = tm.run("01");
        assert!(matches!(result, TuringMachineResult::Accept(_)));
    }

    #[test]
    fn test_turing_machine_analyzer() {
        let states = vec![
            State("q0".to_string()),
            State("q1".to_string()),
        ];
        let input_alphabet = vec![Symbol('0'), Symbol('1')];
        let tape_alphabet = vec![Symbol('0'), Symbol('1'), Symbol('B')];
        let initial_state = State("q0".to_string());
        let accept_state = State("q1".to_string());
        let reject_state = State("q2".to_string());
        let blank_symbol = Symbol('B');
        
        let tm = TuringMachine::new(
            states, input_alphabet, tape_alphabet,
            initial_state, accept_state, reject_state, blank_symbol,
        );
        
        let analyzer = TuringMachineAnalyzer;
        let analysis = analyzer.analyze(&tm);
        
        assert_eq!(analysis.state_count, 2);
        assert!(analysis.is_deterministic);
    }
}
```

### 4.2 Haskellå®ç°

```haskell
-- å›¾çµæœºæ¨¡å—
module TuringMachine where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set

-- å›¾çµæœºæ–¹å‘
data Direction = Left | Right deriving (Eq, Show)

-- å›¾çµæœºçŠ¶æ€
newtype State = State String deriving (Eq, Ord, Show)

-- å›¾çµæœºç¬¦å·
newtype Symbol = Symbol Char deriving (Eq, Ord, Show)

-- å›¾çµæœºè½¬ç§»
data Transition = Transition
    { nextState :: State
    , writeSymbol :: Symbol
    , direction :: Direction
    } deriving (Show)

-- å›¾çµæœºé…ç½®
data Configuration = Configuration
    { state :: State
    , tape :: [Symbol]
    , headPosition :: Int
    } deriving (Show)

-- å›¾çµæœº
data TuringMachine = TuringMachine
    { states :: [State]
    , inputAlphabet :: [Symbol]
    , tapeAlphabet :: [Symbol]
    , transitionFunction :: Map (State, Symbol) Transition
    , initialState :: State
    , acceptState :: State
    , rejectState :: State
    , blankSymbol :: Symbol
    }

-- å›¾çµæœºè¿è¡Œç»“æœ
data TuringMachineResult
    = Accept [Symbol]
    | Reject [Symbol]
    | Timeout [Symbol]
    deriving (Show)

-- åˆ›å»ºæ–°å›¾çµæœº
newTuringMachine :: [State] -> [Symbol] -> [Symbol] -> State -> State -> State -> Symbol -> TuringMachine
newTuringMachine states inputAlphabet tapeAlphabet initialState acceptState rejectState blankSymbol = TuringMachine
    { states = states
    , inputAlphabet = inputAlphabet
    , tapeAlphabet = tapeAlphabet
    , transitionFunction = Map.empty
    , initialState = initialState
    , acceptState = acceptState
    , rejectState = rejectState
    , blankSymbol = blankSymbol
    }

-- æ·»åŠ è½¬ç§»è§„åˆ™
addTransition :: TuringMachine -> State -> Symbol -> State -> Symbol -> Direction -> Either String TuringMachine
addTransition tm currentState readSymbol nextState writeSymbol direction
    | currentState `notElem` states tm = Left "æ— æ•ˆçš„å½“å‰çŠ¶æ€"
    | nextState `notElem` states tm = Left "æ— æ•ˆçš„ä¸‹ä¸€ä¸ªçŠ¶æ€"
    | readSymbol `notElem` tapeAlphabet tm = Left "æ— æ•ˆçš„è¯»å–ç¬¦å·"
    | writeSymbol `notElem` tapeAlphabet tm = Left "æ— æ•ˆçš„å†™å…¥ç¬¦å·"
    | otherwise = Right tm { transitionFunction = Map.insert (currentState, readSymbol) transition (transitionFunction tm) }
  where
    transition = Transition nextState writeSymbol direction

-- è·å–å½“å‰ç¬¦å·
getCurrentSymbol :: Configuration -> Symbol -> Symbol
getCurrentSymbol config blankSymbol
    | headPosition config < length (tape config) = tape config !! headPosition config
    | otherwise = blankSymbol

-- æ‰§è¡Œä¸€æ­¥è®¡ç®—
step :: TuringMachine -> Configuration -> Maybe Configuration
step tm config
    | state config == acceptState tm = Nothing  -- å·²æ¥å—
    | state config == rejectState tm = Nothing  -- å·²æ‹’ç»
    | otherwise = case Map.lookup (state config, currentSymbol) (transitionFunction tm) of
        Just transition -> Just $ applyTransition config transition
        Nothing -> Nothing  -- æ— è½¬ç§»è§„åˆ™
  where
    currentSymbol = getCurrentSymbol config (blankSymbol tm)

-- åº”ç”¨è½¬ç§»
applyTransition :: Configuration -> Transition -> Configuration
applyTransition config transition = config
    { state = nextState transition
    , tape = updateTape (tape config) (headPosition config) (writeSymbol transition)
    , headPosition = newHeadPosition
    }
  where
    newHeadPosition = case direction transition of
        Left -> max 0 (headPosition config - 1)
        Right -> headPosition config + 1

-- æ›´æ–°ç£å¸¦
updateTape :: [Symbol] -> Int -> Symbol -> [Symbol]
updateTape tape pos symbol
    | pos < length tape = take pos tape ++ [symbol] ++ drop (pos + 1) tape
    | otherwise = tape ++ replicate (pos - length tape) (Symbol 'B') ++ [symbol]

-- è¿è¡Œå›¾çµæœº
run :: TuringMachine -> String -> TuringMachineResult
run tm input = runWithLimit tm input 10000

-- å¸¦æ­¥æ•°é™åˆ¶çš„è¿è¡Œ
runWithLimit :: TuringMachine -> String -> Int -> TuringMachineResult
runWithLimit tm input maxSteps = go initialConfig 0
  where
    initialConfig = Configuration
        { state = initialState tm
        , tape = map Symbol input
        , headPosition = 0
        }
    
    go config stepCount
        | stepCount >= maxSteps = Timeout (tape config)
        | state config == acceptState tm = Accept (tape config)
        | state config == rejectState tm = Reject (tape config)
        | otherwise = case step tm config of
            Just newConfig -> go newConfig (stepCount + 1)
            Nothing -> Reject (tape config)

-- æ£€æŸ¥è¾“å…¥æ˜¯å¦è¢«æ¥å—
accepts :: TuringMachine -> String -> Bool
accepts tm input = case run tm input of
    Accept _ -> True
    _ -> False

-- å›¾çµæœºåˆ†æå™¨
data TuringMachineAnalyzer = TuringMachineAnalyzer

-- å›¾çµæœºåˆ†æç»“æœ
data TuringMachineAnalysis = TuringMachineAnalysis
    { isDeterministic :: Bool
    , isComplete :: Bool
    , stateCount :: Int
    , transitionCount :: Int
    , complexity :: Complexity
    } deriving (Show)

-- å¤æ‚åº¦çº§åˆ«
data Complexity = Simple | Moderate | Complex deriving (Show)

-- åˆ†æå›¾çµæœº
analyze :: TuringMachine -> TuringMachineAnalysis
analyze tm = TuringMachineAnalysis
    { isDeterministic = isDeterministicTM tm
    , isComplete = isCompleteTM tm
    , stateCount = length (states tm)
    , transitionCount = Map.size (transitionFunction tm)
    , complexity = estimateComplexity tm
    }

-- æ£€æŸ¥æ˜¯å¦ä¸ºç¡®å®šæ€§å›¾çµæœº
isDeterministicTM :: TuringMachine -> Bool
isDeterministicTM tm = Map.size (transitionFunction tm) == Set.size (Map.keysSet (transitionFunction tm))

-- æ£€æŸ¥æ˜¯å¦ä¸ºå®Œæ•´å›¾çµæœº
isCompleteTM :: TuringMachine -> Bool
isCompleteTM tm = Map.size (transitionFunction tm) >= length (states tm) * length (tapeAlphabet tm) `div` 2

-- ä¼°è®¡å¤æ‚åº¦
estimateComplexity :: TuringMachine -> Complexity
estimateComplexity tm
    | stateCount <= 5 && transitionCount <= 10 = Simple
    | stateCount <= 20 && transitionCount <= 50 = Moderate
    | otherwise = Complex
  where
    stateCount = length (states tm)
    transitionCount = Map.size (transitionFunction tm)

-- é€šç”¨å›¾çµæœº
data UniversalTuringMachine = UniversalTuringMachine
    { descriptionTape :: [Symbol]
    , dataTape :: [Symbol]
    , programTape :: [Symbol]
    }

-- åˆ›å»ºé€šç”¨å›¾çµæœº
newUniversalTuringMachine :: UniversalTuringMachine
newUniversalTuringMachine = UniversalTuringMachine [] [] []

-- ç¼–ç å›¾çµæœº
encodeTuringMachine :: TuringMachine -> String
encodeTuringMachine tm = statesEncoding ++ transitionsEncoding
  where
    statesEncoding = concatMap (\s -> "S:" ++ show s ++ ";") (states tm)
    transitionsEncoding = concatMap encodeTransition (Map.toList (transitionFunction tm))
    
    encodeTransition ((state, symbol), transition) = 
        "T:" ++ show state ++ ":" ++ show symbol ++ ":" ++ 
        show (nextState transition) ++ ":" ++ show (writeSymbol transition) ++ ":" ++
        show (direction transition) ++ ";"

-- ç¤ºä¾‹ç”¨æ³•
example :: IO ()
example = do
    let states = [State "q0", State "q1", State "q2"]
    let inputAlphabet = [Symbol '0', Symbol '1']
    let tapeAlphabet = [Symbol '0', Symbol '1', Symbol 'B']
    let initialState = State "q0"
    let acceptState = State "q1"
    let rejectState = State "q2"
    let blankSymbol = Symbol 'B'
    
    let tm = newTuringMachine states inputAlphabet tapeAlphabet initialState acceptState rejectState blankSymbol
    
    let tm' = case addTransition tm (State "q0") (Symbol '0') (State "q1") (Symbol '1') Right of
        Right t -> t
        Left _ -> tm
    
    let result = run tm' "0"
    putStrLn $ "è¿è¡Œç»“æœ: " ++ show result
    
    let analyzer = TuringMachineAnalyzer
    let analysis = analyze tm'
    putStrLn $ "åˆ†æç»“æœ: " ++ show analysis
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 åŸºæœ¬å›¾çµæœº

```rust
fn main() {
    // åˆ›å»ºä¸€ä¸ªç®€å•çš„å›¾çµæœºï¼Œæ¥å—æ‰€æœ‰ä»¥0å¼€å¤´çš„å­—ç¬¦ä¸²
    let states = vec![
        State("q0".to_string()),
        State("q1".to_string()),
        State("q2".to_string()),
    ];
    let input_alphabet = vec![Symbol('0'), Symbol('1')];
    let tape_alphabet = vec![Symbol('0'), Symbol('1'), Symbol('B')];
    let initial_state = State("q0".to_string());
    let accept_state = State("q1".to_string());
    let reject_state = State("q2".to_string());
    let blank_symbol = Symbol('B');
    
    let mut tm = TuringMachine::new(
        states, input_alphabet, tape_alphabet,
        initial_state, accept_state, reject_state, blank_symbol,
    );
    
    // æ·»åŠ è½¬ç§»è§„åˆ™
    tm.add_transition(
        State("q0".to_string()),
        Symbol('0'),
        State("q1".to_string()),
        Symbol('0'),
        Direction::Right,
    ).unwrap();
    
    tm.add_transition(
        State("q0".to_string()),
        Symbol('1'),
        State("q2".to_string()),
        Symbol('1'),
        Direction::Right,
    ).unwrap();
    
    // æµ‹è¯•å›¾çµæœº
    let test_inputs = vec!["0", "1", "00", "01", "10"];
    
    println!("å›¾çµæœºæµ‹è¯•:");
    for input in test_inputs {
        let result = tm.run(input);
        println!("è¾“å…¥: {} -> {:?}", input, result);
    }
}
```

### 5.2 å›¾çµæœºåˆ†æ

```rust
fn analyze_turing_machines() {
    let analyzer = TuringMachineAnalyzer;
    
    // åˆ›å»ºå¤šä¸ªå›¾çµæœºè¿›è¡Œåˆ†æ
    let mut tms = Vec::new();
    
    // ç®€å•çš„æ¥å—æœº
    let mut tm1 = create_simple_accept_machine();
    tms.push(tm1);
    
    // å¤æ‚çš„è®¡ç®—æœº
    let mut tm2 = create_complex_machine();
    tms.push(tm2);
    
    // åˆ†ææ¯ä¸ªå›¾çµæœº
    for (i, tm) in tms.iter().enumerate() {
        let analysis = analyzer.analyze(tm);
        println!("å›¾çµæœº {} åˆ†æ:", i + 1);
        println!("  ç¡®å®šæ€§: {}", analysis.is_deterministic);
        println!("  å®Œæ•´æ€§: {}", analysis.is_complete);
        println!("  çŠ¶æ€æ•°: {}", analysis.state_count);
        println!("  è½¬ç§»æ•°: {}", analysis.transition_count);
        println!("  å¤æ‚åº¦: {:?}", analysis.complexity);
        println!();
    }
}

fn create_simple_accept_machine() -> TuringMachine {
    let states = vec![State("q0".to_string()), State("q1".to_string())];
    let input_alphabet = vec![Symbol('0'), Symbol('1')];
    let tape_alphabet = vec![Symbol('0'), Symbol('1'), Symbol('B')];
    let initial_state = State("q0".to_string());
    let accept_state = State("q1".to_string());
    let reject_state = State("q2".to_string());
    let blank_symbol = Symbol('B');
    
    let mut tm = TuringMachine::new(
        states, input_alphabet, tape_alphabet,
        initial_state, accept_state, reject_state, blank_symbol,
    );
    
    tm.add_transition(
        State("q0".to_string()),
        Symbol('0'),
        State("q1".to_string()),
        Symbol('0'),
        Direction::Right,
    ).unwrap();
    
    tm
}

fn create_complex_machine() -> TuringMachine {
    // åˆ›å»ºä¸€ä¸ªæ›´å¤æ‚çš„å›¾çµæœº
    let states = vec![
        State("q0".to_string()),
        State("q1".to_string()),
        State("q2".to_string()),
        State("q3".to_string()),
        State("q4".to_string()),
    ];
    let input_alphabet = vec![Symbol('0'), Symbol('1')];
    let tape_alphabet = vec![Symbol('0'), Symbol('1'), Symbol('B')];
    let initial_state = State("q0".to_string());
    let accept_state = State("q4".to_string());
    let reject_state = State("q3".to_string());
    let blank_symbol = Symbol('B');
    
    let mut tm = TuringMachine::new(
        states, input_alphabet, tape_alphabet,
        initial_state, accept_state, reject_state, blank_symbol,
    );
    
    // æ·»åŠ å¤šä¸ªè½¬ç§»è§„åˆ™
    for state in &[State("q0".to_string()), State("q1".to_string()), State("q2".to_string())] {
        for symbol in &[Symbol('0'), Symbol('1')] {
            tm.add_transition(
                state.clone(),
                symbol.clone(),
                State("q4".to_string()),
                symbol.clone(),
                Direction::Right,
            ).unwrap();
        }
    }
    
    tm
}
```

### 5.3 é€šç”¨å›¾çµæœº

```rust
fn universal_turing_machine_demo() {
    let mut utm = UniversalTuringMachine::new();
    
    // åˆ›å»ºä¸€ä¸ªç®€å•çš„å›¾çµæœº
    let states = vec![State("q0".to_string()), State("q1".to_string())];
    let input_alphabet = vec![Symbol('0'), Symbol('1')];
    let tape_alphabet = vec![Symbol('0'), Symbol('1'), Symbol('B')];
    let initial_state = State("q0".to_string());
    let accept_state = State("q1".to_string());
    let reject_state = State("q2".to_string());
    let blank_symbol = Symbol('B');
    
    let mut tm = TuringMachine::new(
        states, input_alphabet, tape_alphabet,
        initial_state, accept_state, reject_state, blank_symbol,
    );
    
    tm.add_transition(
        State("q0".to_string()),
        Symbol('0'),
        State("q1".to_string()),
        Symbol('0'),
        Direction::Right,
    ).unwrap();
    
    // ç¼–ç å›¾çµæœº
    let encoding = utm.encode_turing_machine(&tm);
    println!("å›¾çµæœºç¼–ç : {}", encoding);
    
    // è¿è¡Œç¼–ç çš„å›¾çµæœº
    let result = utm.run_encoded(&encoding, "0");
    println!("è¿è¡Œç»“æœ: {:?}", result);
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸è‡ªåŠ¨æœºç†è®ºçš„å…³ç³»

- **æœ‰é™è‡ªåŠ¨æœº**ï¼šå›¾çµæœºå¯ä»¥æ¨¡æ‹Ÿæœ‰é™è‡ªåŠ¨æœº
- **ä¸‹æ¨è‡ªåŠ¨æœº**ï¼šå›¾çµæœºå¯ä»¥æ¨¡æ‹Ÿä¸‹æ¨è‡ªåŠ¨æœº
- **çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº**ï¼šå›¾çµæœºå¯ä»¥æ¨¡æ‹Ÿçº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº

### 6.2 ä¸è®¡ç®—ç†è®ºçš„å…³ç³»

- **å¯è®¡ç®—æ€§ç†è®º**ï¼šå›¾çµæœºæ˜¯è®¡ç®—èƒ½åŠ›æœ€å¼ºçš„æ¨¡å‹
- **å¤æ‚æ€§ç†è®º**ï¼šå›¾çµæœºç”¨äºå®šä¹‰è®¡ç®—å¤æ‚åº¦ç±»
- **é€’å½’ç†è®º**ï¼šå›¾çµæœºä¸é€’å½’å‡½æ•°ç­‰ä»·

### 6.3 ä¸å½¢å¼è¯­è¨€çš„å…³ç³»

- **è¯­è¨€å±‚æ¬¡**ï¼šå›¾çµæœºå¯¹åº”é€’å½’å¯æšä¸¾è¯­è¨€
- **æ–‡æ³•ç†è®º**ï¼šå›¾çµæœºä¸æ— é™åˆ¶æ–‡æ³•ç­‰ä»·
- **è§£æç†è®º**ï¼šå›¾çµæœºå¯ä»¥è§£æä»»ä½•è¯­è¨€

### 6.4 ä¸è®¡ç®—æœºç§‘å­¦çš„å…³ç³»

- **è®¡ç®—æœºæ¶æ„**ï¼šç°ä»£è®¡ç®—æœºåŸºäºå›¾çµæœºæ¨¡å‹
- **ç¼–ç¨‹è¯­è¨€**ï¼šå›¾çµå®Œå¤‡çš„ç¼–ç¨‹è¯­è¨€
- **ç®—æ³•è®¾è®¡**ï¼šåŸºäºå›¾çµæœºçš„ç®—æ³•åˆ†æ

## 7. å‚è€ƒæ–‡çŒ®

1. **Turing, A. M.** (1936). "On Computable Numbers, with an Application to the Entscheidungsproblem". *Proceedings of the London Mathematical Society*.
2. **Hopcroft, J. E., Ullman, J. D.** (1979). *Introduction to Automata Theory, Languages, and Computation*. Addison-Wesley.
3. **Sipser, M.** (2013). *Introduction to the Theory of Computation*. Cengage Learning.
4. **Davis, M.** (1958). *Computability and Unsolvability*. McGraw-Hill.
5. **Rogers, H.** (1987). *Theory of Recursive Functions and Effective Computability*. MIT Press.
6. **Boolos, G., Burgess, J., Jeffrey, R.** (2007). *Computability and Logic*. Cambridge University Press.
7. **Odifreddi, P.** (1989). *Classical Recursion Theory*. North-Holland.
8. **Soare, R.** (2016). *Turing Computability: Theory and Applications*. Springer.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [03.1.1 æœ‰é™è‡ªåŠ¨æœº](03.1.1_æœ‰é™è‡ªåŠ¨æœº.md)
- [03.1.2 ä¸‹æ¨è‡ªåŠ¨æœº](03.1.2_ä¸‹æ¨è‡ªåŠ¨æœº.md)
- [03.1.3 çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº](03.1.3_çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº.md)
- [03.2.1 æ­£åˆ™æ–‡æ³•](../03_Formal_Language_Theory/03.2.1_æ­£åˆ™æ–‡æ³•.md)
- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03_Formal_Language_Theory/03.2.2_ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•.md)
- [03.2.3 ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•](../03_Formal_Language_Theory/03.2.3_ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•.md)
- [03.2.4 æ— é™åˆ¶æ–‡æ³•](../03_Formal_Language_Theory/03.2.4_æ— é™åˆ¶æ–‡æ³•.md)
