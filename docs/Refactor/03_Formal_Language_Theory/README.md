# 03. å½¢å¼è¯­è¨€ç†è®º (Formal Language Theory)

## ğŸ“‹ æ¦‚è¿°

å½¢å¼è¯­è¨€ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦å’Œè¯­è¨€å­¦çš„åŸºç¡€ç†è®ºï¼Œç ”ç©¶è¯­è¨€çš„æ•°å­¦ç»“æ„å’Œè®¡ç®—æ€§è´¨ã€‚æœ¬æ¨¡å—å»ºç«‹äº†å®Œæ•´çš„å½¢å¼è¯­è¨€ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬è‡ªåŠ¨æœºç†è®ºã€æ–‡æ³•ç†è®ºã€è¯­è¨€å±‚æ¬¡ç­‰æ ¸å¿ƒé¢†åŸŸã€‚

**æ„å»ºæ—¶é—´**: 2024å¹´12æœˆ20æ—¥  
**ç‰ˆæœ¬**: v2.0  
**çŠ¶æ€**: æŒç»­æ„å»ºä¸­

## ğŸ—ï¸ ç†è®ºç»“æ„

### 03.01 è‡ªåŠ¨æœºç†è®º (Automata Theory)

- **03.01.01** æœ‰é™è‡ªåŠ¨æœºåŸºç¡€ (Finite Automata Basics)
- **03.01.02** ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (Deterministic Finite Automata)
- **03.01.03** éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (Nondeterministic Finite Automata)
- **03.01.04** Îµ-éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (Îµ-Nondeterministic Finite Automata)
- **03.01.05** ä¸‹æ¨è‡ªåŠ¨æœº (Pushdown Automata)
- **03.01.06** å›¾çµæœº (Turing Machines)
- **03.01.07** çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº (Linear Bounded Automata)
- **03.01.08** è‡ªåŠ¨æœºç­‰ä»·æ€§ (Automata Equivalence)

### 03.02 æ–‡æ³•ç†è®º (Grammar Theory)

- **03.02.01** æ–‡æ³•åŸºç¡€ (Grammar Basics)
- **03.02.02** æ­£åˆ™æ–‡æ³• (Regular Grammars)
- **03.02.03** ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³• (Context-Free Grammars)
- **03.02.04** ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³• (Context-Sensitive Grammars)
- **03.02.05** æ— é™åˆ¶æ–‡æ³• (Unrestricted Grammars)
- **03.02.06** æ–‡æ³•èŒƒå¼ (Grammar Normal Forms)
- **03.02.07** æ–‡æ³•ç­‰ä»·æ€§ (Grammar Equivalence)

### 03.03 è¯­è¨€å±‚æ¬¡ç†è®º (Language Hierarchy)

- **03.03.01** ä¹”å§†æ–¯åŸºå±‚æ¬¡ (Chomsky Hierarchy)
- **03.03.02** æ­£åˆ™è¯­è¨€ (Regular Languages)
- **03.03.03** ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ (Context-Free Languages)
- **03.03.04** ä¸Šä¸‹æ–‡æœ‰å…³è¯­è¨€ (Context-Sensitive Languages)
- **03.03.05** é€’å½’å¯æšä¸¾è¯­è¨€ (Recursively Enumerable Languages)
- **03.03.06** è¯­è¨€åŒ…å«å…³ç³» (Language Inclusion)
- **03.03.07** è¯­è¨€è¿ç®— (Language Operations)

### 03.04 è§£æç†è®º (Parsing Theory)

- **03.04.01** è§£æåŸºç¡€ (Parsing Basics)
- **03.04.02** LLè§£æ (LL Parsing)
- **03.04.03** LRè§£æ (LR Parsing)
- **03.04.04** é€’å½’ä¸‹é™è§£æ (Recursive Descent Parsing)
- **03.04.05** é¢„æµ‹è§£æ (Predictive Parsing)
- **03.04.06** è‡ªåº•å‘ä¸Šè§£æ (Bottom-Up Parsing)
- **03.04.07** è§£æè¡¨æ„é€  (Parse Table Construction)

### 03.05 è¯­ä¹‰ç†è®º (Semantics Theory)

- **03.05.01** è¯­ä¹‰åŸºç¡€ (Semantics Basics)
- **03.05.02** æ“ä½œè¯­ä¹‰ (Operational Semantics)
- **03.05.03** æŒ‡ç§°è¯­ä¹‰ (Denotational Semantics)
- **03.05.04** å…¬ç†è¯­ä¹‰ (Axiomatic Semantics)
- **03.05.05** è‡ªç„¶è¯­ä¹‰ (Natural Semantics)
- **03.05.06** è¯­ä¹‰ç­‰ä»·æ€§ (Semantic Equivalence)
- **03.05.07** è¯­ä¹‰éªŒè¯ (Semantic Verification)

## ğŸ“Š æ„å»ºè¿›åº¦

### æ€»ä½“è¿›åº¦

- **è®¡åˆ’æ–‡æ¡£æ•°**: 20ä¸ª
- **å·²å®Œæˆæ–‡æ¡£æ•°**: 0ä¸ª
- **å®Œæˆåº¦**: 0%
- **å½“å‰çŠ¶æ€**: å¼€å§‹æ„å»º

### å„å­é¢†åŸŸè¿›åº¦

| å­é¢†åŸŸ | è®¡åˆ’æ–‡æ¡£æ•° | å·²å®Œæˆ | å®Œæˆåº¦ | çŠ¶æ€ |
|--------|------------|--------|--------|------|
| 03.01 è‡ªåŠ¨æœºç†è®º | 8 | 0 | 0% | ğŸ”´ æœªå¼€å§‹ |
| 03.02 æ–‡æ³•ç†è®º | 7 | 0 | 0% | ğŸ”´ æœªå¼€å§‹ |
| 03.03 è¯­è¨€å±‚æ¬¡ç†è®º | 7 | 0 | 0% | ğŸ”´ æœªå¼€å§‹ |
| 03.04 è§£æç†è®º | 7 | 0 | 0% | ğŸ”´ æœªå¼€å§‹ |
| 03.05 è¯­ä¹‰ç†è®º | 7 | 0 | 0% | ğŸ”´ æœªå¼€å§‹ |

## ğŸ”— ç†è®ºå…³è”

### å†…éƒ¨å…³è”

```
è‡ªåŠ¨æœºç†è®º
    â†“
æ–‡æ³•ç†è®º â† è¯­è¨€å±‚æ¬¡ç†è®º
    â†“
è§£æç†è®º â† è¯­ä¹‰ç†è®º
```

### å¤–éƒ¨å…³è”

```
å“²å­¦åŸºç¡€ç†è®º
    â†“
æ•°å­¦åŸºç¡€ç†è®º
    â†“
å½¢å¼è¯­è¨€ç†è®º
    â†“
ç±»å‹ç†è®º
```

## ğŸ“ æ ¸å¿ƒæ¦‚å¿µ

### 1. è¯­è¨€ (Language)

- **å®šä¹‰**: è¯­è¨€æ˜¯å­—ç¬¦ä¸²çš„é›†åˆ
- **å½¢å¼åŒ–**: $L \subseteq \Sigma^*$ å…¶ä¸­Î£æ˜¯å­—æ¯è¡¨
- **åº”ç”¨**: åœ¨ç¼–ç¨‹è¯­è¨€ä¸­ç”¨äºå®šä¹‰è¯­æ³•

### 2. è‡ªåŠ¨æœº (Automaton)

- **å®šä¹‰**: è‡ªåŠ¨æœºæ˜¯å¤„ç†å­—ç¬¦ä¸²çš„æŠ½è±¡æœºå™¨
- **å½¢å¼åŒ–**: $M = (Q, \Sigma, \delta, q_0, F)$
- **åº”ç”¨**: åœ¨ç¼–è¯‘å™¨ä¸­ç”¨äºè¯æ³•åˆ†æ

### 3. æ–‡æ³• (Grammar)

- **å®šä¹‰**: æ–‡æ³•æ˜¯ç”Ÿæˆè¯­è¨€çš„è§„åˆ™ç³»ç»Ÿ
- **å½¢å¼åŒ–**: $G = (V, T, P, S)$
- **åº”ç”¨**: åœ¨ç¼–ç¨‹è¯­è¨€ä¸­ç”¨äºå®šä¹‰è¯­æ³•è§„åˆ™

### 4. è§£æ (Parsing)

- **å®šä¹‰**: è§£ææ˜¯å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºè¯­æ³•æ ‘çš„è¿‡ç¨‹
- **å½¢å¼åŒ–**: $\text{Parse}: \Sigma^* \rightarrow \text{ParseTree}$
- **åº”ç”¨**: åœ¨ç¼–è¯‘å™¨ä¸­ç”¨äºè¯­æ³•åˆ†æ

### 5. è¯­ä¹‰ (Semantics)

- **å®šä¹‰**: è¯­ä¹‰æ˜¯è¯­è¨€è¡¨è¾¾å¼çš„å«ä¹‰
- **å½¢å¼åŒ–**: $\llbracket \cdot \rrbracket: \text{Expression} \rightarrow \text{Meaning}$
- **åº”ç”¨**: åœ¨ç¼–ç¨‹è¯­è¨€ä¸­ç”¨äºå®šä¹‰ç¨‹åºå«ä¹‰

## ğŸ› ï¸ å½¢å¼åŒ–æ–¹æ³•

### 1. è‡ªåŠ¨æœºæ–¹æ³•

- ä½¿ç”¨çŠ¶æ€è½¬æ¢å›¾è¡¨ç¤ºè®¡ç®—è¿‡ç¨‹
- é€šè¿‡è½¬ç§»å‡½æ•°å®šä¹‰è¡Œä¸º
- å»ºç«‹è¯­è¨€è¯†åˆ«æœºåˆ¶

### 2. æ–‡æ³•æ–¹æ³•

- ä½¿ç”¨äº§ç”Ÿå¼è§„åˆ™å®šä¹‰è¯­è¨€ç»“æ„
- é€šè¿‡æ¨å¯¼è¿‡ç¨‹ç”Ÿæˆå­—ç¬¦ä¸²
- å»ºç«‹è¯­è¨€ç”Ÿæˆæœºåˆ¶

### 3. ä»£æ•°æ–¹æ³•

- ä½¿ç”¨ä»£æ•°ç»“æ„è¡¨ç¤ºè¯­è¨€æ€§è´¨
- é€šè¿‡è¿ç®—å®šä¹‰è¯­è¨€æ“ä½œ
- å»ºç«‹è¯­è¨€ä»£æ•°ç†è®º

## ğŸ“š æ ¸å¿ƒå®šç†

### å®šç† 03.01.01 (DFAä¸NFAç­‰ä»·æ€§)

**é™ˆè¿°**: å¯¹äºä»»æ„éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºï¼Œå­˜åœ¨ç­‰ä»·çš„ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºã€‚

**å½¢å¼åŒ–**:
$$\forall \text{NFA} N \exists \text{DFA} D (L(N) = L(D))$$

**è¯æ˜**: ç•¥

### å®šç† 03.02.01 (æ³µå¼•ç†)

**é™ˆè¿°**: å¦‚æœLæ˜¯æ­£åˆ™è¯­è¨€ï¼Œåˆ™å­˜åœ¨æ³µé•¿åº¦pï¼Œä½¿å¾—å¯¹äºä»»æ„é•¿åº¦è‡³å°‘ä¸ºpçš„å­—ç¬¦ä¸²wâˆˆLï¼Œå¯ä»¥åˆ†è§£ä¸ºw=xyzï¼Œæ»¡è¶³æ³µå¼•ç†æ¡ä»¶ã€‚

**å½¢å¼åŒ–**:
$$L \in \text{REG} \rightarrow \exists p \forall w \in L (|w| \geq p \rightarrow \exists x,y,z (w=xyz \land \text{PumpConditions}(x,y,z)))$$

**è¯æ˜**: ç•¥

### å®šç† 03.03.01 (ä¹”å§†æ–¯åŸºå±‚æ¬¡)

**é™ˆè¿°**: è¯­è¨€ç±»å½¢æˆä¸¥æ ¼çš„å±‚æ¬¡ç»“æ„ï¼šREG âŠ‚ CFL âŠ‚ CSL âŠ‚ RELã€‚

**å½¢å¼åŒ–**:
$$\text{REG} \subsetneq \text{CFL} \subsetneq \text{CSL} \subsetneq \text{REL}$$

**è¯æ˜**: ç•¥

## ğŸ’» ä»£ç å®ç°

### Rustå®ç°ç¤ºä¾‹

```rust
use std::collections::{HashMap, HashSet};
use std::fmt;

// è‡ªåŠ¨æœºçŠ¶æ€ç±»å‹
type State = String;

// è½¬ç§»å‡½æ•°ç±»å‹
type TransitionFunction = HashMap<(State, char), State>;

// æœ‰é™è‡ªåŠ¨æœº
#[derive(Debug, Clone)]
pub struct FiniteAutomaton {
    states: HashSet<State>,
    alphabet: HashSet<char>,
    transitions: TransitionFunction,
    initial_state: State,
    final_states: HashSet<State>,
}

impl FiniteAutomaton {
    pub fn new(
        states: HashSet<State>,
        alphabet: HashSet<char>,
        transitions: TransitionFunction,
        initial_state: State,
        final_states: HashSet<State>,
    ) -> Self {
        Self {
            states,
            alphabet,
            transitions,
            initial_state,
            final_states,
        }
    }
    
    pub fn accepts(&self, input: &str) -> bool {
        let mut current_state = self.initial_state.clone();
        
        for c in input.chars() {
            if let Some(next_state) = self.transitions.get(&(current_state.clone(), c)) {
                current_state = next_state.clone();
            } else {
                return false;
            }
        }
        
        self.final_states.contains(&current_state)
    }
}

// æ–‡æ³•ç±»å‹
#[derive(Debug, Clone)]
pub struct Grammar {
    variables: HashSet<String>,
    terminals: HashSet<String>,
    productions: Vec<Production>,
    start_symbol: String,
}

#[derive(Debug, Clone)]
pub struct Production {
    left: String,
    right: Vec<String>,
}

impl Grammar {
    pub fn new(
        variables: HashSet<String>,
        terminals: HashSet<String>,
        productions: Vec<Production>,
        start_symbol: String,
    ) -> Self {
        Self {
            variables,
            terminals,
            productions,
            start_symbol,
        }
    }
    
    pub fn derive(&self, steps: usize) -> Vec<String> {
        let mut current = vec![self.start_symbol.clone()];
        let mut result = vec![current.join("")];
        
        for _ in 0..steps {
            let mut next = Vec::new();
            for sentential_form in &current {
                for production in &self.productions {
                    if sentential_form.contains(&production.left) {
                        let new_form = sentential_form.replace(&production.left, &production.right.join(""));
                        next.push(new_form);
                    }
                }
            }
            current = next;
            if !current.is_empty() {
                result.push(current[0].clone());
            }
        }
        
        result
    }
}
```

### Haskellå®ç°ç¤ºä¾‹

```haskell
-- è‡ªåŠ¨æœºçŠ¶æ€ç±»å‹
type State = String

-- è½¬ç§»å‡½æ•°ç±»å‹
type TransitionFunction = [(State, Char, State)]

-- æœ‰é™è‡ªåŠ¨æœº
data FiniteAutomaton = FiniteAutomaton
    { states :: [State]
    , alphabet :: [Char]
    , transitions :: TransitionFunction
    , initialState :: State
    , finalStates :: [State]
    }

-- æ£€æŸ¥è‡ªåŠ¨æœºæ˜¯å¦æ¥å—è¾“å…¥
accepts :: FiniteAutomaton -> String -> Bool
accepts automaton input = 
    let finalState = foldl (step automaton) (initialState automaton) input
    in finalState `elem` finalStates automaton

-- å•æ­¥è½¬ç§»
step :: FiniteAutomaton -> State -> Char -> State
step automaton currentState symbol = 
    case lookup (currentState, symbol) (transitions automaton) of
        Just nextState -> nextState
        Nothing -> currentState

-- æ–‡æ³•ç±»å‹
data Grammar = Grammar
    { variables :: [String]
    , terminals :: [String]
    , productions :: [Production]
    , startSymbol :: String
    }

data Production = Production
    { left :: String
    , right :: [String]
    }

-- æ¨å¯¼
derive :: Grammar -> Int -> [String]
derive grammar steps = 
    let initial = [startSymbol grammar]
        result = iterate (applyProductions grammar) initial
    in take (steps + 1) $ map concat result

-- åº”ç”¨äº§ç”Ÿå¼
applyProductions :: Grammar -> [String] -> [String]
applyProductions grammar sententialForms = 
    concatMap (applyAllProductions grammar) sententialForms

applyAllProductions :: Grammar -> String -> [String]
applyAllProductions grammar sententialForm = 
    concatMap (applyProduction sententialForm) (productions grammar)

applyProduction :: String -> Production -> [String]
applyProduction sententialForm production = 
    let parts = splitOn (left production) sententialForm
    in if length parts > 1 
       then [concat $ zipWith (++) parts (replicate (length parts - 1) (concat $ right production) ++ [""])]
       else []
```

## ğŸ¯ åº”ç”¨é¢†åŸŸ

### 1. ç¼–è¯‘å™¨è®¾è®¡

- è¯æ³•åˆ†æå™¨ä½¿ç”¨æœ‰é™è‡ªåŠ¨æœº
- è¯­æ³•åˆ†æå™¨ä½¿ç”¨ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•
- è¯­ä¹‰åˆ†æå™¨ä½¿ç”¨è¯­ä¹‰ç†è®º

### 2. è‡ªç„¶è¯­è¨€å¤„ç†

- å¥æ³•åˆ†æä½¿ç”¨æ–‡æ³•ç†è®º
- è¯­ä¹‰ç†è§£ä½¿ç”¨è¯­ä¹‰ç†è®º
- è¯­è¨€ç”Ÿæˆä½¿ç”¨è‡ªåŠ¨æœºç†è®º

### 3. è½¯ä»¶å·¥ç¨‹

- å½¢å¼åŒ–è§„èŒƒä½¿ç”¨è¯­è¨€ç†è®º
- ç¨‹åºéªŒè¯ä½¿ç”¨è¯­ä¹‰ç†è®º
- ä»£ç ç”Ÿæˆä½¿ç”¨æ–‡æ³•ç†è®º

### 4. äººå·¥æ™ºèƒ½

- çŸ¥è¯†è¡¨ç¤ºä½¿ç”¨è¯­è¨€ç†è®º
- æ¨ç†ç³»ç»Ÿä½¿ç”¨è¯­ä¹‰ç†è®º
- å­¦ä¹ ç®—æ³•ä½¿ç”¨è‡ªåŠ¨æœºç†è®º

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. **Chomsky, N.** (1956). "Three Models for the Description of Language". *IRE Transactions on Information Theory*.
2. **Hopcroft, J.E.** (1979). *Introduction to Automata Theory, Languages, and Computation*. Addison-Wesley.
3. **Sipser, M.** (2012). *Introduction to the Theory of Computation*. Cengage Learning.
4. **Aho, A.V.** (2006). *Compilers: Principles, Techniques, and Tools*. Pearson.
5. **Winskel, G.** (1993). *The Formal Semantics of Programming Languages*. MIT Press.
6. **Plotkin, G.D.** (1981). *A Structural Approach to Operational Semantics*. Aarhus University.
7. **Scott, D.** (1970). "Outline of a Mathematical Theory of Computation". *Oxford University Computing Laboratory*.

## ğŸš€ ä¸‹ä¸€æ­¥è®¡åˆ’

### ç«‹å³å¼€å§‹ (ä»Šå¤©)

1. åˆ›å»ºæœ‰é™è‡ªåŠ¨æœºåŸºç¡€æ–‡æ¡£
2. åˆ›å»ºæ–‡æ³•åŸºç¡€æ–‡æ¡£
3. å»ºç«‹è¯­è¨€ç†è®ºå…³è”ç³»ç»Ÿ

### çŸ­æœŸç›®æ ‡ (æœ¬å‘¨å†…)

1. å®Œæˆè‡ªåŠ¨æœºç†è®ºå­é¢†åŸŸ
2. å®Œæˆæ–‡æ³•ç†è®ºå­é¢†åŸŸ
3. å¼€å§‹è¯­è¨€å±‚æ¬¡ç†è®ºå­é¢†åŸŸ

### ä¸­æœŸç›®æ ‡ (æœ¬æœˆå†…)

1. å®ŒæˆåŸºç¡€è¯­è¨€ç†è®º
2. å¼€å§‹é«˜çº§è¯­è¨€ç†è®º
3. å®Œå–„è¯­è¨€ç†è®ºå…³è”

---

**æ„å»ºè€…**: AI Assistant  
**æœ€åæ›´æ–°**: 2024å¹´12æœˆ20æ—¥  
**ç‰ˆæœ¬**: v2.0
