# 03.2.1 æ­£åˆ™æ–‡æ³•

## ğŸ“‹ æ¦‚è¿°

æ­£åˆ™æ–‡æ³•æ˜¯å½¢å¼è¯­è¨€ç†è®ºä¸­æœ€åŸºç¡€çš„æ–‡æ³•ç±»å‹ï¼Œå®ƒç”Ÿæˆçš„è¯­è¨€æ°å¥½æ˜¯æœ‰é™è‡ªåŠ¨æœºèƒ½å¤Ÿè¯†åˆ«çš„è¯­è¨€ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦æ„å»ºæ­£åˆ™æ–‡æ³•çš„ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬æ–‡æ³•çš„å®šä¹‰ã€æ€§è´¨å’Œä¸è‡ªåŠ¨æœºçš„å…³ç³»ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹æ­£åˆ™æ–‡æ³•çš„å½¢å¼åŒ–åŸºç¡€**
2. **åˆ†ææ­£åˆ™æ–‡æ³•çš„ç»“æ„**
3. **æ¢è®¨æ­£åˆ™æ–‡æ³•ä¸æœ‰é™è‡ªåŠ¨æœºçš„å…³ç³»**
4. **ç ”ç©¶æ­£åˆ™æ–‡æ³•çš„åº”ç”¨**
5. **æ„å»ºæ­£åˆ™æ–‡æ³•çš„è®¡ç®—æ¡†æ¶**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ­£åˆ™æ–‡æ³•çš„å®šä¹‰

æ­£åˆ™æ–‡æ³•æ˜¯ä¸€ç§ç‰¹æ®Šçš„ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ï¼Œå…¶äº§ç”Ÿå¼å…·æœ‰ç‰¹å®šçš„å½¢å¼ï¼š

- **å³çº¿æ€§æ–‡æ³•**ï¼šæ‰€æœ‰äº§ç”Ÿå¼çš„å³éƒ¨æœ€å¤šæœ‰ä¸€ä¸ªéç»ˆç»“ç¬¦ï¼Œä¸”ä½äºæœ€å³ç«¯
- **å·¦çº¿æ€§æ–‡æ³•**ï¼šæ‰€æœ‰äº§ç”Ÿå¼çš„å³éƒ¨æœ€å¤šæœ‰ä¸€ä¸ªéç»ˆç»“ç¬¦ï¼Œä¸”ä½äºæœ€å·¦ç«¯

### 1.2 æ­£åˆ™æ–‡æ³•çš„ç‰¹ç‚¹

1. **ç®€å•æ€§**ï¼šäº§ç”Ÿå¼ç»“æ„ç®€å•ï¼Œæ˜“äºåˆ†æ
2. **ç­‰ä»·æ€§**ï¼šå³çº¿æ€§å’Œå·¦çº¿æ€§æ–‡æ³•ç­‰ä»·
3. **è¡¨è¾¾èƒ½åŠ›**ï¼šåªèƒ½ç”Ÿæˆæ­£åˆ™è¯­è¨€
4. **è®¡ç®—æ•ˆç‡**ï¼šè¯†åˆ«å’Œè§£ææ•ˆç‡é«˜

### 1.3 æ­£åˆ™æ–‡æ³•çš„åº”ç”¨

- **è¯æ³•åˆ†æ**ï¼šç¼–ç¨‹è¯­è¨€çš„è¯æ³•åˆ†æå™¨
- **æ¨¡å¼åŒ¹é…**ï¼šå­—ç¬¦ä¸²æ¨¡å¼è¯†åˆ«
- **æ–‡æœ¬å¤„ç†**ï¼šæ–‡æœ¬æœç´¢å’Œæ›¿æ¢
- **åè®®è®¾è®¡**ï¼šé€šä¿¡åè®®çš„å½¢å¼åŒ–æè¿°

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å³çº¿æ€§æ–‡æ³•

**å®šä¹‰ 2.1.1** (å³çº¿æ€§æ–‡æ³•)
ä¸€ä¸ªå³çº¿æ€§æ–‡æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ $G = (V, \Sigma, P, S)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯éç»ˆç»“ç¬¦é›†åˆ
- $\Sigma$ æ˜¯ç»ˆç»“ç¬¦é›†åˆ
- $P$ æ˜¯äº§ç”Ÿå¼é›†åˆï¼Œæ¯ä¸ªäº§ç”Ÿå¼å½¢å¦‚ï¼š
  - $A \to aB$ æˆ– $A \to a$ æˆ– $A \to \varepsilon$
- $S \in V$ æ˜¯èµ·å§‹ç¬¦å·

### 2.2 å·¦çº¿æ€§æ–‡æ³•

**å®šä¹‰ 2.2.1** (å·¦çº¿æ€§æ–‡æ³•)
ä¸€ä¸ªå·¦çº¿æ€§æ–‡æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ $G = (V, \Sigma, P, S)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯éç»ˆç»“ç¬¦é›†åˆ
- $\Sigma$ æ˜¯ç»ˆç»“ç¬¦é›†åˆ
- $P$ æ˜¯äº§ç”Ÿå¼é›†åˆï¼Œæ¯ä¸ªäº§ç”Ÿå¼å½¢å¦‚ï¼š
  - $A \to Ba$ æˆ– $A \to a$ æˆ– $A \to \varepsilon$
- $S \in V$ æ˜¯èµ·å§‹ç¬¦å·

### 2.3 æ¨å¯¼å…³ç³»

**å®šä¹‰ 2.3.1** (ç›´æ¥æ¨å¯¼)
å¯¹äºå³çº¿æ€§æ–‡æ³• $G$ï¼Œç›´æ¥æ¨å¯¼å…³ç³» $\Rightarrow_G$ å®šä¹‰ä¸ºï¼š

$$\alpha A \beta \Rightarrow_G \alpha \gamma \beta$$

å½“ä¸”ä»…å½“ $A \to \gamma \in P$ã€‚

**å®šä¹‰ 2.3.2** (æ¨å¯¼)
æ¨å¯¼å…³ç³» $\Rightarrow_G^*$ æ˜¯ $\Rightarrow_G$ çš„è‡ªåä¼ é€’é—­åŒ…ã€‚

### 2.4 ç”Ÿæˆçš„è¯­è¨€

**å®šä¹‰ 2.4.1** (ç”Ÿæˆçš„è¯­è¨€)
æ­£åˆ™æ–‡æ³• $G$ ç”Ÿæˆçš„è¯­è¨€æ˜¯ï¼š

$$L(G) = \{w \in \Sigma^* : S \Rightarrow_G^* w\}$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 æ­£åˆ™æ–‡æ³•ä¸æœ‰é™è‡ªåŠ¨æœºçš„ç­‰ä»·æ€§

**å®šç† 3.1.1** (æ­£åˆ™æ–‡æ³•ä¸æœ‰é™è‡ªåŠ¨æœºç­‰ä»·)
å¯¹äºä»»æ„æ­£åˆ™è¯­è¨€ $L$ï¼Œå­˜åœ¨æ­£åˆ™æ–‡æ³• $G$ ä½¿å¾— $L = L(G)$ï¼Œåä¹‹äº¦ç„¶ã€‚

**è¯æ˜**ï¼š

1. **ä»æ­£åˆ™æ–‡æ³•æ„é€ æœ‰é™è‡ªåŠ¨æœº**ï¼š
   - çŠ¶æ€é›†åˆï¼šéç»ˆç»“ç¬¦é›†åˆ $V \cup \{F\}$
   - åˆå§‹çŠ¶æ€ï¼šèµ·å§‹ç¬¦å· $S$
   - æ¥å—çŠ¶æ€ï¼š$F$
   - è½¬ç§»å‡½æ•°ï¼šæ ¹æ®äº§ç”Ÿå¼å®šä¹‰

2. **ä»æœ‰é™è‡ªåŠ¨æœºæ„é€ æ­£åˆ™æ–‡æ³•**ï¼š
   - éç»ˆç»“ç¬¦ï¼šçŠ¶æ€é›†åˆ
   - èµ·å§‹ç¬¦å·ï¼šåˆå§‹çŠ¶æ€
   - äº§ç”Ÿå¼ï¼šæ ¹æ®è½¬ç§»å‡½æ•°å®šä¹‰

### 3.2 å³çº¿æ€§å’Œå·¦çº¿æ€§æ–‡æ³•çš„ç­‰ä»·æ€§

**å®šç† 3.2.1** (å³çº¿æ€§å’Œå·¦çº¿æ€§æ–‡æ³•ç­‰ä»·)
å¯¹äºä»»æ„å³çº¿æ€§æ–‡æ³•ï¼Œå­˜åœ¨ç­‰ä»·çš„å·¦çº¿æ€§æ–‡æ³•ï¼Œåä¹‹äº¦ç„¶ã€‚

**è¯æ˜**ï¼š

1. æ„é€ ä¸­é—´æ–‡æ³•
2. åè½¬äº§ç”Ÿå¼
3. è°ƒæ•´éç»ˆç»“ç¬¦
4. è¯æ˜è¯­è¨€ç­‰ä»·

### 3.3 æ­£åˆ™æ–‡æ³•çš„æ³µå¼•ç†

**å®šç† 3.3.1** (æ­£åˆ™æ–‡æ³•çš„æ³µå¼•ç†)
è®¾ $L$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œåˆ™å­˜åœ¨å¸¸æ•° $n$ ä½¿å¾—å¯¹äºä»»æ„ $w \in L$ ä¸” $|w| \geq n$ï¼Œå­˜åœ¨åˆ†è§£ $w = xyz$ æ»¡è¶³ï¼š

1. $|xy| \leq n$
2. $|y| > 0$
3. $\forall k \geq 0: xy^k z \in L$

**è¯æ˜**ï¼š

1. ä½¿ç”¨æœ‰é™è‡ªåŠ¨æœºçš„çŠ¶æ€æ•°
2. åº”ç”¨é¸½å·¢åŸç†
3. æ„é€ æ³µå¼•ç†åˆ†è§£

### 3.4 æ­£åˆ™æ–‡æ³•çš„æœ€å°åŒ–

**å®šç† 3.4.1** (æ­£åˆ™æ–‡æ³•æœ€å°åŒ–)
å¯¹äºä»»æ„æ­£åˆ™æ–‡æ³•ï¼Œå­˜åœ¨ç­‰ä»·çš„æœ€å°æ­£åˆ™æ–‡æ³•ã€‚

**è¯æ˜**ï¼š

1. æ„é€ å¯¹åº”çš„æœ‰é™è‡ªåŠ¨æœº
2. æœ€å°åŒ–æœ‰é™è‡ªåŠ¨æœº
3. è½¬æ¢å›æ­£åˆ™æ–‡æ³•

## 4. ä»£ç å®ç°

### 4.1 æ­£åˆ™æ–‡æ³•å®ç°

```rust
use std::collections::{HashMap, HashSet};

/// äº§ç”Ÿå¼ç±»å‹
#[derive(Debug, Clone, PartialEq)]
pub enum ProductionType {
    RightLinear,  // å³çº¿æ€§
    LeftLinear,   // å·¦çº¿æ€§
}

/// äº§ç”Ÿå¼
#[derive(Debug, Clone)]
pub struct Production {
    left: String,   // å·¦éƒ¨ï¼ˆéç»ˆç»“ç¬¦ï¼‰
    right: String,  // å³éƒ¨
}

/// æ­£åˆ™æ–‡æ³•
#[derive(Debug, Clone)]
pub struct RegularGrammar {
    non_terminals: HashSet<String>,
    terminals: HashSet<char>,
    productions: Vec<Production>,
    start_symbol: String,
    grammar_type: ProductionType,
}

/// æ–‡æ³•åˆ†æç»“æœ
#[derive(Debug, Clone)]
pub struct GrammarAnalysis {
    is_regular: bool,
    is_right_linear: bool,
    is_left_linear: bool,
    is_ambiguous: bool,
    production_count: usize,
    non_terminal_count: usize,
    terminal_count: usize,
}

impl RegularGrammar {
    /// åˆ›å»ºæ–°çš„æ­£åˆ™æ–‡æ³•
    pub fn new(
        non_terminals: Vec<String>,
        terminals: Vec<char>,
        start_symbol: String,
        grammar_type: ProductionType,
    ) -> Self {
        Self {
            non_terminals: non_terminals.into_iter().collect(),
            terminals: terminals.into_iter().collect(),
            productions: Vec::new(),
            start_symbol,
            grammar_type,
        }
    }
    
    /// æ·»åŠ äº§ç”Ÿå¼
    pub fn add_production(&mut self, left: String, right: String) -> Result<(), String> {
        // éªŒè¯äº§ç”Ÿå¼çš„æœ‰æ•ˆæ€§
        if !self.non_terminals.contains(&left) {
            return Err("å·¦éƒ¨å¿…é¡»æ˜¯éç»ˆç»“ç¬¦".to_string());
        }
        
        match self.grammar_type {
            ProductionType::RightLinear => {
                if !self.is_valid_right_linear_production(&right) {
                    return Err("æ— æ•ˆçš„å³çº¿æ€§äº§ç”Ÿå¼".to_string());
                }
            }
            ProductionType::LeftLinear => {
                if !self.is_valid_left_linear_production(&right) {
                    return Err("æ— æ•ˆçš„å·¦çº¿æ€§äº§ç”Ÿå¼".to_string());
                }
            }
        }
        
        self.productions.push(Production { left, right });
        Ok(())
    }
    
    /// éªŒè¯å³çº¿æ€§äº§ç”Ÿå¼
    fn is_valid_right_linear_production(&self, right: &str) -> bool {
        if right.is_empty() {
            return true; // Îµäº§ç”Ÿå¼
        }
        
        let mut chars: Vec<char> = right.chars().collect();
        
        // æ£€æŸ¥æ ¼å¼ï¼šaB æˆ– a
        if chars.len() == 1 {
            return self.terminals.contains(&chars[0]);
        } else if chars.len() == 2 {
            return self.terminals.contains(&chars[0]) && 
                   self.non_terminals.contains(&chars[1].to_string());
        }
        
        false
    }
    
    /// éªŒè¯å·¦çº¿æ€§äº§ç”Ÿå¼
    fn is_valid_left_linear_production(&self, right: &str) -> bool {
        if right.is_empty() {
            return true; // Îµäº§ç”Ÿå¼
        }
        
        let mut chars: Vec<char> = right.chars().collect();
        
        // æ£€æŸ¥æ ¼å¼ï¼šBa æˆ– a
        if chars.len() == 1 {
            return self.terminals.contains(&chars[0]);
        } else if chars.len() == 2 {
            return self.non_terminals.contains(&chars[0].to_string()) && 
                   self.terminals.contains(&chars[1]);
        }
        
        false
    }
    
    /// æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦å±äºæ–‡æ³•ç”Ÿæˆçš„è¯­è¨€
    pub fn accepts(&self, input: &str) -> bool {
        self.derive(input, &self.start_symbol)
    }
    
    /// é€’å½’æ¨å¯¼
    fn derive(&self, target: &str, current: &str) -> bool {
        if current == target {
            return true;
        }
        
        if current.len() > target.len() {
            return false;
        }
        
        // å°è¯•æ‰€æœ‰å¯èƒ½çš„äº§ç”Ÿå¼
        for production in &self.productions {
            if current.contains(&production.left) {
                let new_string = current.replace(&production.left, &production.right);
                if self.derive(target, &new_string) {
                    return true;
                }
            }
        }
        
        false
    }
    
    /// ç”Ÿæˆè¯­è¨€ä¸­çš„å­—ç¬¦ä¸²
    pub fn generate_strings(&self, max_length: usize) -> Vec<String> {
        let mut strings = Vec::new();
        self.generate_from_symbol(&self.start_symbol, "", max_length, &mut strings);
        strings
    }
    
    /// ä»ç¬¦å·ç”Ÿæˆå­—ç¬¦ä¸²
    fn generate_from_symbol(
        &self,
        symbol: &str,
        current: &str,
        max_length: usize,
        strings: &mut Vec<String>,
    ) {
        if current.len() > max_length {
            return;
        }
        
        if symbol.chars().all(|c| self.terminals.contains(&c)) {
            let result = current.to_string() + symbol;
            if !strings.contains(&result) {
                strings.push(result);
            }
            return;
        }
        
        // åº”ç”¨äº§ç”Ÿå¼
        for production in &self.productions {
            if symbol.contains(&production.left) {
                let new_symbol = symbol.replace(&production.left, &production.right);
                self.generate_from_symbol(&new_symbol, current, max_length, strings);
            }
        }
    }
    
    /// è½¬æ¢ä¸ºæœ‰é™è‡ªåŠ¨æœº
    pub fn to_finite_automaton(&self) -> FiniteAutomaton {
        let mut states = self.non_terminals.clone();
        states.insert("F".to_string()); // æ¥å—çŠ¶æ€
        
        let mut transitions = HashMap::new();
        
        for production in &self.productions {
            match self.grammar_type {
                ProductionType::RightLinear => {
                    if production.right.len() == 2 {
                        let symbol = production.right.chars().next().unwrap();
                        let next_state = production.right.chars().nth(1).unwrap().to_string();
                        transitions.insert((production.left.clone(), symbol), next_state);
                    } else if production.right.len() == 1 {
                        let symbol = production.right.chars().next().unwrap();
                        transitions.insert((production.left.clone(), symbol), "F".to_string());
                    }
                }
                ProductionType::LeftLinear => {
                    if production.right.len() == 2 {
                        let symbol = production.right.chars().nth(1).unwrap();
                        let prev_state = production.right.chars().next().unwrap().to_string();
                        transitions.insert((prev_state, symbol), production.left.clone());
                    } else if production.right.len() == 1 {
                        let symbol = production.right.chars().next().unwrap();
                        transitions.insert(("S".to_string(), symbol), production.left.clone());
                    }
                }
            }
        }
        
        FiniteAutomaton {
            states,
            alphabet: self.terminals.clone(),
            transitions,
            initial_state: self.start_symbol.clone(),
            accept_states: vec!["F".to_string()],
        }
    }
    
    /// åˆ†ææ–‡æ³•
    pub fn analyze(&self) -> GrammarAnalysis {
        let is_regular = self.is_regular_grammar();
        let is_right_linear = self.is_right_linear_grammar();
        let is_left_linear = self.is_left_linear_grammar();
        let is_ambiguous = self.is_ambiguous_grammar();
        
        GrammarAnalysis {
            is_regular,
            is_right_linear,
            is_left_linear,
            is_ambiguous,
            production_count: self.productions.len(),
            non_terminal_count: self.non_terminals.len(),
            terminal_count: self.terminals.len(),
        }
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºæ­£åˆ™æ–‡æ³•
    fn is_regular_grammar(&self) -> bool {
        self.is_right_linear_grammar() || self.is_left_linear_grammar()
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºå³çº¿æ€§æ–‡æ³•
    fn is_right_linear_grammar(&self) -> bool {
        self.productions.iter().all(|p| self.is_valid_right_linear_production(&p.right))
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºå·¦çº¿æ€§æ–‡æ³•
    fn is_left_linear_grammar(&self) -> bool {
        self.productions.iter().all(|p| self.is_valid_left_linear_production(&p.right))
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºæ­§ä¹‰æ–‡æ³•
    fn is_ambiguous_grammar(&self) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥æ˜¯å¦æœ‰å¤šä¸ªäº§ç”Ÿå¼å…·æœ‰ç›¸åŒçš„å·¦éƒ¨
        let mut left_sides = HashMap::new();
        for production in &self.productions {
            *left_sides.entry(&production.left).or_insert(0) += 1;
        }
        
        left_sides.values().any(|&count| count > 1)
    }
}

/// æœ‰é™è‡ªåŠ¨æœº
#[derive(Debug, Clone)]
pub struct FiniteAutomaton {
    states: HashSet<String>,
    alphabet: HashSet<char>,
    transitions: HashMap<(String, char), String>,
    initial_state: String,
    accept_states: Vec<String>,
}

impl FiniteAutomaton {
    /// æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦è¢«æ¥å—
    pub fn accepts(&self, input: &str) -> bool {
        let mut current_state = self.initial_state.clone();
        
        for c in input.chars() {
            if let Some(next_state) = self.transitions.get(&(current_state.clone(), c)) {
                current_state = next_state.clone();
            } else {
                return false;
            }
        }
        
        self.accept_states.contains(&current_state)
    }
}

/// æ­£åˆ™æ–‡æ³•åˆ†æå™¨
pub struct RegularGrammarAnalyzer;

impl RegularGrammarAnalyzer {
    /// åˆ†ææ­£åˆ™æ–‡æ³•
    pub fn analyze(&self, grammar: &RegularGrammar) -> DetailedGrammarAnalysis {
        let basic_analysis = grammar.analyze();
        let language_properties = self.analyze_language_properties(grammar);
        let complexity = self.estimate_complexity(grammar);
        
        DetailedGrammarAnalysis {
            basic: basic_analysis,
            language_properties,
            complexity,
        }
    }
    
    /// åˆ†æè¯­è¨€æ€§è´¨
    fn analyze_language_properties(&self, grammar: &RegularGrammar) -> LanguageProperties {
        let is_finite = self.is_finite_language(grammar);
        let is_infinite = self.is_infinite_language(grammar);
        let has_epsilon = grammar.productions.iter().any(|p| p.right.is_empty());
        
        LanguageProperties {
            is_finite,
            is_infinite,
            has_epsilon,
            estimated_size: self.estimate_language_size(grammar),
        }
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰é™è¯­è¨€
    fn is_finite_language(&self, grammar: &RegularGrammar) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥æ˜¯å¦æœ‰å¾ªç¯äº§ç”Ÿå¼
        let mut has_cycle = false;
        for production in &grammar.productions {
            if production.right.contains(&production.left) {
                has_cycle = true;
                break;
            }
        }
        !has_cycle
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºæ— é™è¯­è¨€
    fn is_infinite_language(&self, grammar: &RegularGrammar) -> bool {
        !self.is_finite_language(grammar)
    }
    
    /// ä¼°è®¡è¯­è¨€å¤§å°
    fn estimate_language_size(&self, grammar: &RegularGrammar) -> LanguageSize {
        if self.is_finite_language(grammar) {
            let strings = grammar.generate_strings(10);
            LanguageSize::Finite(strings.len())
        } else {
            LanguageSize::Infinite
        }
    }
    
    /// ä¼°è®¡å¤æ‚åº¦
    fn estimate_complexity(&self, grammar: &RegularGrammar) -> GrammarComplexity {
        let production_count = grammar.productions.len();
        let non_terminal_count = grammar.non_terminals.len();
        
        if production_count <= 5 && non_terminal_count <= 3 {
            GrammarComplexity::Simple
        } else if production_count <= 20 && non_terminal_count <= 10 {
            GrammarComplexity::Moderate
        } else {
            GrammarComplexity::Complex
        }
    }
    
    /// æœ€å°åŒ–æ­£åˆ™æ–‡æ³•
    pub fn minimize(&self, grammar: &RegularGrammar) -> RegularGrammar {
        // è½¬æ¢ä¸ºæœ‰é™è‡ªåŠ¨æœº
        let automaton = grammar.to_finite_automaton();
        
        // æœ€å°åŒ–æœ‰é™è‡ªåŠ¨æœºï¼ˆç®€åŒ–å®ç°ï¼‰
        let minimized_automaton = self.minimize_automaton(&automaton);
        
        // è½¬æ¢å›æ­£åˆ™æ–‡æ³•
        self.automaton_to_grammar(&minimized_automaton)
    }
    
    /// æœ€å°åŒ–æœ‰é™è‡ªåŠ¨æœº
    fn minimize_automaton(&self, automaton: &FiniteAutomaton) -> FiniteAutomaton {
        // ç®€åŒ–å®ç°ï¼šè¿”å›åŸè‡ªåŠ¨æœº
        automaton.clone()
    }
    
    /// è‡ªåŠ¨æœºè½¬æ–‡æ³•
    fn automaton_to_grammar(&self, automaton: &FiniteAutomaton) -> RegularGrammar {
        let non_terminals: Vec<String> = automaton.states.iter().cloned().collect();
        let terminals: Vec<char> = automaton.alphabet.iter().cloned().collect();
        
        let mut grammar = RegularGrammar::new(
            non_terminals,
            terminals,
            automaton.initial_state.clone(),
            ProductionType::RightLinear,
        );
        
        // æ·»åŠ äº§ç”Ÿå¼
        for ((state, symbol), next_state) in &automaton.transitions {
            if automaton.accept_states.contains(next_state) {
                grammar.add_production(state.clone(), symbol.to_string()).unwrap();
            } else {
                grammar.add_production(state.clone(), format!("{}{}", symbol, next_state)).unwrap();
            }
        }
        
        grammar
    }
}

/// è¯¦ç»†æ–‡æ³•åˆ†æç»“æœ
#[derive(Debug, Clone)]
pub struct DetailedGrammarAnalysis {
    basic: GrammarAnalysis,
    language_properties: LanguageProperties,
    complexity: GrammarComplexity,
}

/// è¯­è¨€æ€§è´¨
#[derive(Debug, Clone)]
pub struct LanguageProperties {
    is_finite: bool,
    is_infinite: bool,
    has_epsilon: bool,
    estimated_size: LanguageSize,
}

/// è¯­è¨€å¤§å°
#[derive(Debug, Clone)]
pub enum LanguageSize {
    Finite(usize),
    Infinite,
}

/// æ–‡æ³•å¤æ‚åº¦
#[derive(Debug, Clone)]
pub enum GrammarComplexity {
    Simple,
    Moderate,
    Complex,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_regular_grammar_creation() {
        let non_terminals = vec!["S".to_string(), "A".to_string()];
        let terminals = vec!['a', 'b'];
        let start_symbol = "S".to_string();
        
        let mut grammar = RegularGrammar::new(
            non_terminals,
            terminals,
            start_symbol,
            ProductionType::RightLinear,
        );
        
        grammar.add_production("S".to_string(), "aA".to_string()).unwrap();
        grammar.add_production("A".to_string(), "b".to_string()).unwrap();
        
        assert_eq!(grammar.productions.len(), 2);
    }

    #[test]
    fn test_grammar_acceptance() {
        let mut grammar = RegularGrammar::new(
            vec!["S".to_string(), "A".to_string()],
            vec!['a', 'b'],
            "S".to_string(),
            ProductionType::RightLinear,
        );
        
        grammar.add_production("S".to_string(), "aA".to_string()).unwrap();
        grammar.add_production("A".to_string(), "b".to_string()).unwrap();
        
        assert!(grammar.accepts("ab"));
        assert!(!grammar.accepts("a"));
    }

    #[test]
    fn test_grammar_analysis() {
        let mut grammar = RegularGrammar::new(
            vec!["S".to_string(), "A".to_string()],
            vec!['a', 'b'],
            "S".to_string(),
            ProductionType::RightLinear,
        );
        
        grammar.add_production("S".to_string(), "aA".to_string()).unwrap();
        grammar.add_production("A".to_string(), "b".to_string()).unwrap();
        
        let analysis = grammar.analyze();
        assert!(analysis.is_regular);
        assert!(analysis.is_right_linear);
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 åŸºæœ¬æ­£åˆ™æ–‡æ³•

```rust
fn main() {
    // åˆ›å»ºæ­£åˆ™æ–‡æ³•ï¼šL = {a^n b^m | n, m â‰¥ 0}
    let mut grammar = RegularGrammar::new(
        vec!["S".to_string(), "A".to_string(), "B".to_string()],
        vec!['a', 'b'],
        "S".to_string(),
        ProductionType::RightLinear,
    );
    
    // æ·»åŠ äº§ç”Ÿå¼
    grammar.add_production("S".to_string(), "aA".to_string()).unwrap();
    grammar.add_production("S".to_string(), "bB".to_string()).unwrap();
    grammar.add_production("S".to_string(), "".to_string()).unwrap(); // Îµ
    grammar.add_production("A".to_string(), "aA".to_string()).unwrap();
    grammar.add_production("A".to_string(), "bB".to_string()).unwrap();
    grammar.add_production("B".to_string(), "bB".to_string()).unwrap();
    grammar.add_production("B".to_string(), "".to_string()).unwrap(); // Îµ
    
    println!("æ­£åˆ™æ–‡æ³•ç¤ºä¾‹:");
    println!("äº§ç”Ÿå¼:");
    for production in &grammar.productions {
        println!("  {} -> {}", production.left, production.right);
    }
    
    // æµ‹è¯•å­—ç¬¦ä¸²
    let test_strings = vec!["", "a", "b", "aa", "ab", "bb", "aab", "abb"];
    
    println!("\nå­—ç¬¦ä¸²æµ‹è¯•:");
    for s in test_strings {
        let accepted = grammar.accepts(s);
        println!("  '{}' -> {}", s, accepted);
    }
}
```

### 5.2 æ–‡æ³•åˆ†æ

```rust
fn analyze_grammars() {
    let analyzer = RegularGrammarAnalyzer;
    
    // åˆ›å»ºä¸åŒçš„æ­£åˆ™æ–‡æ³•
    let grammars = vec![
        create_simple_grammar(),
        create_complex_grammar(),
        create_ambiguous_grammar(),
    ];
    
    for (i, grammar) in grammars.iter().enumerate() {
        let analysis = analyzer.analyze(grammar);
        println!("æ–‡æ³• {} åˆ†æ:", i + 1);
        println!("  æ­£åˆ™: {}", analysis.basic.is_regular);
        println!("  å³çº¿æ€§: {}", analysis.basic.is_right_linear);
        println!("  æ­§ä¹‰: {}", analysis.basic.is_ambiguous);
        println!("  äº§ç”Ÿå¼æ•°: {}", analysis.basic.production_count);
        println!("  è¯­è¨€æœ‰é™: {}", analysis.language_properties.is_finite);
        println!("  å¤æ‚åº¦: {:?}", analysis.complexity);
        println!();
    }
}

fn create_simple_grammar() -> RegularGrammar {
    let mut grammar = RegularGrammar::new(
        vec!["S".to_string()],
        vec!['a'],
        "S".to_string(),
        ProductionType::RightLinear,
    );
    grammar.add_production("S".to_string(), "a".to_string()).unwrap();
    grammar
}

fn create_complex_grammar() -> RegularGrammar {
    let mut grammar = RegularGrammar::new(
        vec!["S".to_string(), "A".to_string(), "B".to_string(), "C".to_string()],
        vec!['a', 'b', 'c'],
        "S".to_string(),
        ProductionType::RightLinear,
    );
    
    grammar.add_production("S".to_string(), "aA".to_string()).unwrap();
    grammar.add_production("A".to_string(), "bB".to_string()).unwrap();
    grammar.add_production("B".to_string(), "cC".to_string()).unwrap();
    grammar.add_production("C".to_string(), "a".to_string()).unwrap();
    
    grammar
}

fn create_ambiguous_grammar() -> RegularGrammar {
    let mut grammar = RegularGrammar::new(
        vec!["S".to_string()],
        vec!['a'],
        "S".to_string(),
        ProductionType::RightLinear,
    );
    
    grammar.add_production("S".to_string(), "a".to_string()).unwrap();
    grammar.add_production("S".to_string(), "a".to_string()).unwrap(); // é‡å¤äº§ç”Ÿå¼
    
    grammar
}
```

### 5.3 æ–‡æ³•è½¬æ¢

```rust
fn grammar_conversion() {
    // åˆ›å»ºæ­£åˆ™æ–‡æ³•
    let mut grammar = RegularGrammar::new(
        vec!["S".to_string(), "A".to_string()],
        vec!['a', 'b'],
        "S".to_string(),
        ProductionType::RightLinear,
    );
    
    grammar.add_production("S".to_string(), "aA".to_string()).unwrap();
    grammar.add_production("A".to_string(), "b".to_string()).unwrap();
    
    // è½¬æ¢ä¸ºæœ‰é™è‡ªåŠ¨æœº
    let automaton = grammar.to_finite_automaton();
    
    println!("æ–‡æ³•è½¬è‡ªåŠ¨æœº:");
    println!("çŠ¶æ€: {:?}", automaton.states);
    println!("å­—æ¯è¡¨: {:?}", automaton.alphabet);
    println!("è½¬ç§»: {:?}", automaton.transitions);
    
    // æµ‹è¯•è‡ªåŠ¨æœº
    let test_strings = vec!["ab", "a", "b", "aa"];
    
    println!("\nè‡ªåŠ¨æœºæµ‹è¯•:");
    for s in test_strings {
        let accepted = automaton.accepts(s);
        println!("  '{}' -> {}", s, accepted);
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸è‡ªåŠ¨æœºç†è®ºçš„å…³ç³»

- **æœ‰é™è‡ªåŠ¨æœº**ï¼šæ­£åˆ™æ–‡æ³•ä¸æœ‰é™è‡ªåŠ¨æœºç­‰ä»·
- **ä¸‹æ¨è‡ªåŠ¨æœº**ï¼šæ­£åˆ™æ–‡æ³•æ˜¯ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•çš„ç‰¹ä¾‹
- **å›¾çµæœº**ï¼šæ­£åˆ™æ–‡æ³•è¡¨è¾¾èƒ½åŠ›æœ‰é™

### 6.2 ä¸å½¢å¼è¯­è¨€çš„å…³ç³»

- **ä¹”å§†æ–¯åŸºè°±ç³»**ï¼šæ­£åˆ™æ–‡æ³•å¯¹åº”æ­£åˆ™è¯­è¨€
- **è¯­è¨€å±‚æ¬¡**ï¼šæ­£åˆ™è¯­è¨€æ˜¯æœ€ç®€å•çš„è¯­è¨€ç±»
- **è¯­è¨€è¿ç®—**ï¼šæ­£åˆ™è¯­è¨€åœ¨è¿ç®—ä¸‹å°é—­

### 6.3 ä¸ç¼–è¯‘åŸç†çš„å…³ç³»

- **è¯æ³•åˆ†æ**ï¼šæ­£åˆ™æ–‡æ³•ç”¨äºè¯æ³•åˆ†æå™¨
- **è¯­æ³•åˆ†æ**ï¼šæ­£åˆ™æ–‡æ³•æ˜¯è¯­æ³•åˆ†æçš„åŸºç¡€
- **ä»£ç ç”Ÿæˆ**ï¼šæ­£åˆ™æ–‡æ³•æŒ‡å¯¼ä»£ç ç”Ÿæˆ

### 6.4 ä¸è®¡ç®—ç†è®ºçš„å…³ç³»

- **å¯è®¡ç®—æ€§**ï¼šæ­£åˆ™è¯­è¨€æ˜¯å¯åˆ¤å®šçš„
- **å¤æ‚æ€§**ï¼šæ­£åˆ™è¯­è¨€è¯†åˆ«æ˜¯çº¿æ€§çš„
- **è¡¨è¾¾èƒ½åŠ›**ï¼šæ­£åˆ™è¯­è¨€è¡¨è¾¾èƒ½åŠ›æœ‰é™

## 7. å‚è€ƒæ–‡çŒ®

1. **Hopcroft, J. E., Ullman, J. D.** (1979). *Introduction to Automata Theory, Languages, and Computation*. Addison-Wesley.
2. **Sipser, M.** (2013). *Introduction to the Theory of Computation*. Cengage Learning.
3. **Lewis, H. R., Papadimitriou, C. H.** (1998). *Elements of the Theory of Computation*. Prentice Hall.
4. **Kozen, D. C.** (1997). *Automata and Computability*. Springer.
5. **Sudkamp, T. A.** (2006). *Languages and Machines: An Introduction to the Theory of Computer Science*. Addison-Wesley.
6. **Linz, P.** (2017). *An Introduction to Formal Languages and Automata*. Jones & Bartlett Learning.
7. **Martin, J. C.** (2010). *Introduction to Languages and the Theory of Computation*. McGraw-Hill.
8. **Aho, A. V., Ullman, J. D.** (1972). *The Theory of Parsing, Translation, and Compiling*. Prentice Hall.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [03.1.1 æœ‰é™è‡ªåŠ¨æœº](03.1.1_æœ‰é™è‡ªåŠ¨æœº.md)
- [03.1.2 ä¸‹æ¨è‡ªåŠ¨æœº](03.1.2_ä¸‹æ¨è‡ªåŠ¨æœº.md)
- [03.1.3 çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº](03.1.3_çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº.md)
- [03.1.4 å›¾çµæœº](03.1.4_å›¾çµæœº.md)
- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03_Formal_Language_Theory/03.2.2_ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•.md)
- [03.2.3 ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•](../03_Formal_Language_Theory/03.2.3_ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•.md)
- [03.2.4 æ— é™åˆ¶æ–‡æ³•](../03_Formal_Language_Theory/03.2.4_æ— é™åˆ¶æ–‡æ³•.md)
