# 03.4 è§£æç†è®º

## ğŸ“‹ æ¦‚è¿°

è§£æç†è®ºæ˜¯å½¢å¼è¯­è¨€ç†è®ºçš„é‡è¦åˆ†æ”¯ï¼Œç ”ç©¶å¦‚ä½•å°†ç¬¦åˆç‰¹å®šè¯­æ³•è§„åˆ™çš„å­—ç¬¦ä¸²è½¬æ¢ä¸ºç»“æ„åŒ–çš„è¡¨ç¤ºå½¢å¼ï¼ˆé€šå¸¸æ˜¯è¯­æ³•æ ‘æˆ–æŠ½è±¡è¯­æ³•æ ‘ï¼‰ã€‚
è§£æè¿‡ç¨‹æ˜¯ç¼–è¯‘å™¨ã€è§£é‡Šå™¨å’Œå„ç§è¯­è¨€å¤„ç†å·¥å…·çš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œå®ƒå°†çº¿æ€§çš„æ–‡æœ¬è¾“å…¥è½¬æ¢ä¸ºå±‚æ¬¡åŒ–çš„ç»“æ„ï¼Œä¸ºåç»­çš„è¯­ä¹‰åˆ†æå’Œä»£ç ç”Ÿæˆæä¾›åŸºç¡€ã€‚
è§£æç†è®ºä¸ä»…æœ‰æ·±åšçš„ç†è®ºåŸºç¡€ï¼Œä¹Ÿæœ‰å¹¿æ³›çš„å®é™…åº”ç”¨ï¼Œæ˜¯è¿æ¥å½¢å¼è¯­è¨€ç†è®ºä¸å®é™…ç¼–ç¨‹è¯­è¨€å®ç°çš„é‡è¦æ¡¥æ¢ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **ç†è®ºåŸºç¡€**ï¼šå»ºç«‹è§£æçš„æ•°å­¦åŸºç¡€å’Œå½¢å¼åŒ–å®šä¹‰
2. **ç®—æ³•åˆ†ç±»**ï¼šç³»ç»Ÿä»‹ç»ä¸»è¦çš„è§£æç®—æ³•åŠå…¶ç‰¹æ€§
3. **æ•ˆç‡åˆ†æ**ï¼šåˆ†æä¸åŒè§£ææ–¹æ³•çš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦
4. **å®ç°æŠ€æœ¯**ï¼šæ¢è®¨è§£æå™¨çš„å®ç°æ–¹æ³•å’Œä¼˜åŒ–ç­–ç•¥
5. **åº”ç”¨åœºæ™¯**ï¼šå±•ç¤ºè§£æç†è®ºåœ¨ç¼–ç¨‹è¯­è¨€å’Œå…¶ä»–é¢†åŸŸçš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [è‡ªé¡¶å‘ä¸‹è§£æ](#2-è‡ªé¡¶å‘ä¸‹è§£æ)
3. [è‡ªåº•å‘ä¸Šè§£æ](#3-è‡ªåº•å‘ä¸Šè§£æ)
4. [è§£æå™¨ç”Ÿæˆ](#4-è§£æå™¨ç”Ÿæˆ)
5. [ä»£ç å®ç°](#5-ä»£ç å®ç°)
6. [åº”ç”¨ç¤ºä¾‹](#6-åº”ç”¨ç¤ºä¾‹)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è§£æçš„å®šä¹‰

**å®šä¹‰ 1.1.1** (è§£æ)
è§£ææ˜¯å°†ç¬¦åˆç‰¹å®šè¯­æ³•è§„åˆ™çš„å­—ç¬¦ä¸²è½¬æ¢ä¸ºç»“æ„åŒ–è¡¨ç¤ºï¼ˆé€šå¸¸æ˜¯è¯­æ³•æ ‘æˆ–æŠ½è±¡è¯­æ³•æ ‘ï¼‰çš„è¿‡ç¨‹ã€‚

**å®šä¹‰ 1.1.2** (è¯­æ³•æ ‘)
è¯­æ³•æ ‘æ˜¯ä¸€ç§æ ‘çŠ¶ç»“æ„ï¼Œè¡¨ç¤ºè¾“å…¥å­—ç¬¦ä¸²çš„è¯­æ³•ç»“æ„ã€‚å¶èŠ‚ç‚¹å¯¹åº”ç»ˆç»“ç¬¦ï¼Œéå¶èŠ‚ç‚¹å¯¹åº”éç»ˆç»“ç¬¦ï¼Œæ ‘çš„ç»“æ„åæ˜ äº†æ¨å¯¼è¿‡ç¨‹ã€‚

**å®šä¹‰ 1.1.3** (æŠ½è±¡è¯­æ³•æ ‘)
æŠ½è±¡è¯­æ³•æ ‘æ˜¯è¯­æ³•æ ‘çš„ç®€åŒ–å½¢å¼ï¼Œçœç•¥äº†ä¸€äº›è¯­æ³•ç»†èŠ‚ï¼Œæ›´å…³æ³¨è¯­è¨€çš„è¯­ä¹‰ç»“æ„ã€‚

### 1.2 è§£æä¸æ–‡æ³•

**å®šä¹‰ 1.2.1** (å¯è§£ææ€§)
å¦‚æœå­˜åœ¨ä¸€ä¸ªç®—æ³•èƒ½å¤Ÿä¸ºæ–‡æ³• $G$ ä¸­çš„æ¯ä¸ªå¥å­æ„å»ºè¯­æ³•æ ‘ï¼Œåˆ™ç§°æ–‡æ³• $G$ æ˜¯å¯è§£æçš„ã€‚

**å®šç† 1.2.1** (ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•çš„å¯è§£ææ€§)
æ‰€æœ‰ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•éƒ½æ˜¯å¯è§£æçš„ï¼Œä½†è§£æç®—æ³•çš„æ•ˆç‡å¯èƒ½å› æ–‡æ³•çš„ç‰¹æ€§è€Œå¼‚ã€‚

**å®šä¹‰ 1.2.2** (æ­§ä¹‰æ€§)
å¦‚æœæ–‡æ³• $G$ ä¸­å­˜åœ¨æŸä¸ªå¥å­æœ‰å¤šä¸ªä¸åŒçš„è¯­æ³•æ ‘ï¼Œåˆ™ç§°æ–‡æ³• $G$ æ˜¯æ­§ä¹‰çš„ã€‚

**ç¤ºä¾‹ 1.2.1** (æ­§ä¹‰æ–‡æ³•)
è€ƒè™‘è¡¨è¾¾å¼æ–‡æ³•ï¼š$E \rightarrow E + E \mid E * E \mid (E) \mid id$
å¯¹äºè¾“å…¥ "$id + id * id$"ï¼Œæœ‰ä¸¤ç§ä¸åŒçš„è§£ææ ‘ï¼Œå¯¹åº”äº "$(id + id) * id$" å’Œ "$id + (id * id)$"ã€‚

### 1.3 è§£ææ–¹æ³•åˆ†ç±»

**åˆ†ç±» 1.3.1** (æŒ‰æ–¹å‘)

- **è‡ªé¡¶å‘ä¸‹è§£æ**ï¼šä»èµ·å§‹ç¬¦å·å¼€å§‹ï¼Œå°è¯•æ„å»ºè¯­æ³•æ ‘ç›´åˆ°åŒ¹é…è¾“å…¥å­—ç¬¦ä¸²
- **è‡ªåº•å‘ä¸Šè§£æ**ï¼šä»è¾“å…¥å­—ç¬¦ä¸²å¼€å§‹ï¼Œé€æ­¥è§„çº¦ç›´åˆ°å¾—åˆ°èµ·å§‹ç¬¦å·

**åˆ†ç±» 1.3.2** (æŒ‰å›æº¯)

- **ç¡®å®šæ€§è§£æ**ï¼šåœ¨è§£æè¿‡ç¨‹ä¸­çš„æ¯ä¸€æ­¥éƒ½èƒ½ç¡®å®šåœ°é€‰æ‹©ä¸€ä¸ªåŠ¨ä½œï¼Œä¸éœ€è¦å›æº¯
- **éç¡®å®šæ€§è§£æ**ï¼šåœ¨è§£æè¿‡ç¨‹ä¸­å¯èƒ½éœ€è¦å°è¯•å¤šä¸ªé€‰æ‹©ï¼Œå¯èƒ½éœ€è¦å›æº¯

**åˆ†ç±» 1.3.3** (æŒ‰é¢„æµ‹)

- **é¢„æµ‹è§£æ**ï¼šä½¿ç”¨å‘å‰çœ‹ç¬¦å·æ¥æŒ‡å¯¼è§£æå†³ç­–
- **éé¢„æµ‹è§£æ**ï¼šä¸ä½¿ç”¨å‘å‰çœ‹ç¬¦å·ï¼Œå¯èƒ½éœ€è¦æ›´å¤šçš„å›æº¯

## 2. è‡ªé¡¶å‘ä¸‹è§£æ

### 2.1 é€’å½’ä¸‹é™è§£æ

**å®šä¹‰ 2.1.1** (é€’å½’ä¸‹é™è§£æ)
é€’å½’ä¸‹é™è§£ææ˜¯ä¸€ç§è‡ªé¡¶å‘ä¸‹è§£ææ–¹æ³•ï¼Œä¸ºæ¯ä¸ªéç»ˆç»“ç¬¦åˆ›å»ºä¸€ä¸ªè§£æå‡½æ•°ï¼Œè¿™äº›å‡½æ•°ç›¸äº’é€’å½’è°ƒç”¨ä»¥è§£æè¾“å…¥ã€‚

**ç®—æ³• 2.1.1** (é€’å½’ä¸‹é™è§£æå™¨)

```text
function parse(input):
    pos = 0
    function parseE():  // å¯¹åº”éç»ˆç»“ç¬¦ E
        if lookahead() == 'id':
            match('id')
        else if lookahead() == '(':
            match('(')
            parseE()
            match(')')
        else:
            error()
    
    function match(terminal):
        if lookahead() == terminal:
            pos += 1
        else:
            error()
    
    function lookahead():
        return input[pos]
    
    parseE()  // ä»èµ·å§‹ç¬¦å·å¼€å§‹è§£æ
    if pos == len(input):
        return "Accept"
    else:
        return "Reject"
```

**å®šç† 2.1.1** (é€’å½’ä¸‹é™è§£æçš„é™åˆ¶)
é€’å½’ä¸‹é™è§£æä¸èƒ½ç›´æ¥å¤„ç†å·¦é€’å½’æ–‡æ³•ï¼Œéœ€è¦å…ˆè¿›è¡Œå·¦é€’å½’æ¶ˆé™¤ã€‚

### 2.2 LL(k)è§£æ

**å®šä¹‰ 2.2.1** (LL(k)æ–‡æ³•)
å¦‚æœä¸€ä¸ªæ–‡æ³•å¯ä»¥é€šè¿‡å‘å‰çœ‹ k ä¸ªç¬¦å·çš„è‡ªé¡¶å‘ä¸‹è§£ææ–¹æ³•æ— æ­§ä¹‰åœ°è§£æï¼Œåˆ™ç§°å…¶ä¸º LL(k) æ–‡æ³•ã€‚LL è¡¨ç¤ºä»å·¦åˆ°å³æ‰«æè¾“å…¥ï¼Œæ„å»ºæœ€å·¦æ¨å¯¼ã€‚

**å®šä¹‰ 2.2.2** (FIRSTé›†åˆ)
å¯¹äºæ–‡æ³•ç¬¦å· $X$ï¼Œ$\text{FIRST}_k(X)$ æ˜¯ $X$ å¯ä»¥æ¨å¯¼å‡ºçš„æ‰€æœ‰å­—ç¬¦ä¸²çš„å‰ k ä¸ªç¬¦å·çš„é›†åˆã€‚

**å®šä¹‰ 2.2.3** (FOLLOWé›†åˆ)
å¯¹äºéç»ˆç»“ç¬¦ $A$ï¼Œ$\text{FOLLOW}_k(A)$ æ˜¯å¯èƒ½ç´§è·Ÿåœ¨ $A$ ä¹‹åå‡ºç°çš„ k ä¸ªç¬¦å·çš„é›†åˆã€‚

**ç®—æ³• 2.2.1** (è®¡ç®—FIRSTé›†åˆ)

```text
function computeFirst(grammar):
    for each terminal t:
        FIRST(t) = {t}
    
    for each non-terminal A:
        FIRST(A) = {}
    
    repeat until no changes:
        for each production A â†’ Xâ‚Xâ‚‚...Xâ‚™:
            add FIRST(Xâ‚) - {Îµ} to FIRST(A)
            for i = 1 to n-1:
                if Îµ âˆˆ FIRST(Xáµ¢):
                    add FIRST(Xáµ¢â‚Šâ‚) - {Îµ} to FIRST(A)
            if Îµ âˆˆ FIRST(Xáµ¢) for all i = 1 to n:
                add Îµ to FIRST(A)
    
    return FIRST
```

**ç®—æ³• 2.2.2** (è®¡ç®—FOLLOWé›†åˆ)

```text
function computeFollow(grammar, FIRST):
    for each non-terminal A:
        FOLLOW(A) = {}
    
    add $ to FOLLOW(S)  // S is the start symbol
    
    repeat until no changes:
        for each production A â†’ Î±BÎ²:
            add FIRST(Î²) - {Îµ} to FOLLOW(B)
            if Îµ âˆˆ FIRST(Î²):
                add FOLLOW(A) to FOLLOW(B)
    
    return FOLLOW
```

**ç®—æ³• 2.2.3** (LL(1)è§£æè¡¨æ„å»º)

```pseudocode
function buildLL1Table(grammar, FIRST, FOLLOW):
    initialize table M with error entries
    
    for each production A â†’ Î±:
        for each terminal t âˆˆ FIRST(Î±):
            M[A, t] = A â†’ Î±
        
        if Îµ âˆˆ FIRST(Î±):
            for each terminal t âˆˆ FOLLOW(A):
                M[A, t] = A â†’ Î±
    
    return M
```

**å®šç† 2.2.1** (LL(1)è§£æçš„æ¡ä»¶)
æ–‡æ³• $G$ æ˜¯ LL(1) çš„å½“ä¸”ä»…å½“å¯¹äºä»»ä½•éç»ˆç»“ç¬¦ $A$ å’Œä¸¤ä¸ªä¸åŒçš„äº§ç”Ÿå¼ $A \rightarrow \alpha \mid \beta$ï¼š

1. $\text{FIRST}(\alpha) \cap \text{FIRST}(\beta) = \emptyset$
2. å¦‚æœ $\beta \Rightarrow^* \epsilon$ï¼Œåˆ™ $\text{FIRST}(\alpha) \cap \text{FOLLOW}(A) = \emptyset$

### 2.3 é¢„æµ‹æ€§è§£æ

**å®šä¹‰ 2.3.1** (é¢„æµ‹æ€§è§£æ)
é¢„æµ‹æ€§è§£ææ˜¯ä¸€ç§ç¡®å®šæ€§çš„è‡ªé¡¶å‘ä¸‹è§£ææ–¹æ³•ï¼Œä½¿ç”¨å‘å‰çœ‹ç¬¦å·æ¥æŒ‡å¯¼äº§ç”Ÿå¼çš„é€‰æ‹©ï¼Œæ— éœ€å›æº¯ã€‚

**ç®—æ³• 2.3.1** (é¢„æµ‹æ€§è§£æå™¨)

```pseudocode
function predictiveParse(input, table):
    stack = [EOF, S]  // S is the start symbol
    pos = 0
    
    while stack is not empty:
        X = top of stack
        a = lookahead()
        
        if X is a terminal or EOF:
            if X == a:
                pop stack
                pos += 1
            else:
                error()
        else:  // X is a non-terminal
            if table[X, a] exists:
                pop stack
                push right side of table[X, a] onto stack in reverse order
            else:
                error()
    
    return "Accept"
```

**å®šç† 2.3.1** (é¢„æµ‹æ€§è§£æçš„æ•ˆç‡)
é¢„æµ‹æ€§è§£æçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯è¾“å…¥å­—ç¬¦ä¸²çš„é•¿åº¦ã€‚

## 3. è‡ªåº•å‘ä¸Šè§£æ

### 3.1 ç§»ä½-è§„çº¦è§£æ

**å®šä¹‰ 3.1.1** (ç§»ä½-è§„çº¦è§£æ)
ç§»ä½-è§„çº¦è§£ææ˜¯ä¸€ç§è‡ªåº•å‘ä¸Šè§£ææ–¹æ³•ï¼Œé€šè¿‡ç§»ä½ï¼ˆå°†è¾“å…¥ç¬¦å·å‹å…¥æ ˆï¼‰å’Œè§„çº¦ï¼ˆå°†æ ˆé¡¶çš„ç¬¦å·åºåˆ—æ›¿æ¢ä¸ºéç»ˆç»“ç¬¦ï¼‰æ“ä½œæ„å»ºè¯­æ³•æ ‘ã€‚

**å®šä¹‰ 3.1.2** (å¥æŸ„)
å¥æŸ„æ˜¯æœ€å³æ¨å¯¼ä¸­æœ€å·¦å‡ºç°çš„äº§ç”Ÿå¼å®ä¾‹ï¼Œæ˜¯ä¸‹ä¸€æ­¥è§„çº¦æ“ä½œçš„ç›®æ ‡ã€‚

**ç®—æ³• 3.1.1** (åŸºæœ¬ç§»ä½-è§„çº¦è§£æå™¨)

```pseudocode
function shiftReduceParse(input, grammar):
    stack = []
    pos = 0
    
    while true:
        if stack contains a handle:
            reduce stack using appropriate production
        else if pos < len(input):
            shift input[pos] onto stack
            pos += 1
        else if stack contains only the start symbol:
            return "Accept"
        else:
            return "Reject"
```

### 3.2 LR(k)è§£æ

**å®šä¹‰ 3.2.1** (LR(k)æ–‡æ³•)
å¦‚æœä¸€ä¸ªæ–‡æ³•å¯ä»¥é€šè¿‡å‘å‰çœ‹ k ä¸ªç¬¦å·çš„è‡ªåº•å‘ä¸Šè§£ææ–¹æ³•æ— æ­§ä¹‰åœ°è§£æï¼Œåˆ™ç§°å…¶ä¸º LR(k) æ–‡æ³•ã€‚LR è¡¨ç¤ºä»å·¦åˆ°å³æ‰«æè¾“å…¥ï¼Œæ„å»ºæœ€å³æ¨å¯¼çš„é€†è¿‡ç¨‹ã€‚

**å®šä¹‰ 3.2.2** (é¡¹ç›®)
LR(0) é¡¹ç›®æ˜¯å½¢å¦‚ $A \rightarrow \alpha \cdot \beta$ çš„è¡¨è¾¾å¼ï¼Œå…¶ä¸­ $A \rightarrow \alpha\beta$ æ˜¯ä¸€ä¸ªäº§ç”Ÿå¼ï¼Œç‚¹è¡¨ç¤ºè§£æçš„å½“å‰ä½ç½®ã€‚

**å®šä¹‰ 3.2.3** (LR(1)é¡¹ç›®)
LR(1) é¡¹ç›®æ˜¯å½¢å¦‚ $[A \rightarrow \alpha \cdot \beta, a]$ çš„è¡¨è¾¾å¼ï¼Œå…¶ä¸­ $a$ æ˜¯å‘å‰çœ‹ç¬¦å·ã€‚

**ç®—æ³• 3.2.1** (æ„å»ºLR(0)é¡¹ç›®é›†è§„èŒƒæ—)

```pseudocode
function buildLR0ItemSets(grammar):
    initialize C with the closure of {S' â†’ Â·S}
    
    repeat until no changes:
        for each set I in C:
            for each grammar symbol X:
                if there is an item A â†’ Î±Â·XÎ² in I:
                    J = goto(I, X)
                    if J is not empty and J is not in C:
                        add J to C
    
    return C
```

**ç®—æ³• 3.2.2** (æ„å»ºLRè§£æè¡¨)

```pseudocode
function buildLRTable(grammar, itemSets):
    initialize table with error entries
    
    for each item set I:
        for each item [A â†’ Î±Â·aÎ²] in I:  // a is a terminal
            action[I, a] = shift goto(I, a)
        
        for each item [A â†’ Î±Â·] in I:  // A â†’ Î± is a production
            for each terminal a:
                action[I, a] = reduce A â†’ Î±
        
        for each item [S' â†’ SÂ·] in I:
            action[I, $] = accept
        
        for each non-terminal A:
            goto[I, A] = goto(I, A)
    
    return table
```

**å®šç† 3.2.1** (LRè§£æçš„èƒ½åŠ›)
LR(1) è§£æå™¨å¯ä»¥è§£ææ‰€æœ‰ç¡®å®šæ€§ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼Œä¸”æ¯” LL(1) è§£æå™¨èƒ½åŠ›æ›´å¼ºã€‚

### 3.3 LALRè§£æ

**å®šä¹‰ 3.3.1** (LALRæ–‡æ³•)
LALRï¼ˆLook-Ahead LRï¼‰æ–‡æ³•æ˜¯é€šè¿‡åˆå¹¶å…·æœ‰ç›¸åŒæ ¸å¿ƒé¡¹ç›®çš„LR(1)é¡¹ç›®é›†å¾—åˆ°çš„ç®€åŒ–å½¢å¼ã€‚

**ç®—æ³• 3.3.1** (æ„å»ºLALRè§£æè¡¨)

```pseudocode
function buildLALRTable(grammar):
    build LR(1) item sets
    merge item sets with the same core
    construct parsing table from merged item sets
    return table
```

**å®šç† 3.3.1** (LALRä¸LRçš„å…³ç³»)
LALR(1) æ–‡æ³•æ˜¯ LR(1) æ–‡æ³•çš„çœŸå­é›†ï¼Œä½†æ¯” SLR(1) æ–‡æ³•æ›´å¼ºå¤§ã€‚

## 4. è§£æå™¨ç”Ÿæˆ

### 4.1 è§£æå™¨ç”Ÿæˆå·¥å…·

**å®šä¹‰ 4.1.1** (è§£æå™¨ç”Ÿæˆå™¨)
è§£æå™¨ç”Ÿæˆå™¨æ˜¯ä¸€ç§å·¥å…·ï¼Œæ ¹æ®å½¢å¼åŒ–çš„è¯­æ³•è§„èŒƒè‡ªåŠ¨ç”Ÿæˆè§£æå™¨ä»£ç ã€‚

**ç¤ºä¾‹ 4.1.1** (å¸¸è§è§£æå™¨ç”Ÿæˆå™¨)

- **Yacc/Bison**ï¼šç”ŸæˆLALR(1)è§£æå™¨
- **ANTLR**ï¼šç”ŸæˆLL(*)è§£æå™¨
- **JavaCC**ï¼šç”ŸæˆLL(k)è§£æå™¨
- **Parsec**ï¼šå‡½æ•°å¼è§£æå™¨ç»„åˆå­åº“

### 4.2 è¯­æ³•è½¬æ¢

**å®šä¹‰ 4.2.1** (å·¦é€’å½’æ¶ˆé™¤)
å·¦é€’å½’æ¶ˆé™¤æ˜¯å°†å·¦é€’å½’æ–‡æ³•è½¬æ¢ä¸ºç­‰ä»·çš„éå·¦é€’å½’æ–‡æ³•çš„è¿‡ç¨‹ã€‚

**ç®—æ³• 4.2.1** (ç›´æ¥å·¦é€’å½’æ¶ˆé™¤)

```pseudocode
function eliminateDirectLeftRecursion(grammar):
    for each non-terminal A:
        partition productions A â†’ AÎ±â‚ | ... | AÎ±â‚™ | Î²â‚ | ... | Î²â‚˜
        where Î²áµ¢ does not start with A
        
        replace with:
        A â†’ Î²â‚A' | ... | Î²â‚˜A'
        A' â†’ Î±â‚A' | ... | Î±â‚™A' | Îµ
    
    return transformed grammar
```

**å®šä¹‰ 4.2.2** (å·¦å› å­åŒ–)
å·¦å› å­åŒ–æ˜¯æ¶ˆé™¤å…·æœ‰å…±åŒå‰ç¼€çš„äº§ç”Ÿå¼ï¼Œä»¥å‡å°‘è§£ææ—¶çš„é¢„æµ‹å†²çªã€‚

**ç®—æ³• 4.2.2** (å·¦å› å­åŒ–)

```pseudocode
function leftFactoring(grammar):
    for each non-terminal A:
        group productions by common prefix
        for each group with common prefix Î±:
            replace A â†’ Î±Î²â‚ | Î±Î²â‚‚ | ... | Î±Î²â‚™
            with:
            A â†’ Î±A'
            A' â†’ Î²â‚ | Î²â‚‚ | ... | Î²â‚™
    
    return transformed grammar
```

### 4.3 é”™è¯¯å¤„ç†

**å®šä¹‰ 4.3.1** (è¯­æ³•é”™è¯¯æ¢å¤)
è¯­æ³•é”™è¯¯æ¢å¤æ˜¯åœ¨å‘ç°è¯­æ³•é”™è¯¯åï¼Œå°è¯•ç»§ç»­è§£æå‰©ä½™è¾“å…¥çš„æŠ€æœ¯ã€‚

**æ–¹æ³• 4.3.1** (ææ…Œæ¨¡å¼æ¢å¤)
åœ¨å‘ç°é”™è¯¯æ—¶ï¼Œè·³è¿‡è¾“å…¥ç¬¦å·ç›´åˆ°é‡åˆ°åŒæ­¥æ ‡è®°ï¼ˆå¦‚åˆ†å·ã€å³æ‹¬å·ç­‰ï¼‰ã€‚

**æ–¹æ³• 4.3.2** (çŸ­è¯­çº§æ¢å¤)
å°è¯•æ’å…¥æˆ–åˆ é™¤å°‘é‡ç¬¦å·ä»¥ä¿®å¤é”™è¯¯ï¼Œç„¶åç»§ç»­è§£æã€‚

**æ–¹æ³• 4.3.3** (é”™è¯¯äº§ç”Ÿå¼)
åœ¨æ–‡æ³•ä¸­æ·»åŠ ç‰¹æ®Šçš„é”™è¯¯å¤„ç†äº§ç”Ÿå¼ï¼Œç”¨äºè¯†åˆ«å’Œå¤„ç†å¸¸è§é”™è¯¯æ¨¡å¼ã€‚

## 5. ä»£ç å®ç°

### 5.1 é€’å½’ä¸‹é™è§£æå™¨çš„Rustå®ç°

```rust
use std::iter::Peekable;
use std::str::Chars;

enum Token {
    Number(i32),
    Plus,
    Minus,
    Times,
    Divide,
    LParen,
    RParen,
    EOF,
}

struct Lexer<'a> {
    input: Peekable<Chars<'a>>,
}

impl<'a> Lexer<'a> {
    fn new(input: &'a str) -> Self {
        Lexer {
            input: input.chars().peekable(),
        }
    }
    
    fn next_token(&mut self) -> Token {
        // è·³è¿‡ç©ºç™½å­—ç¬¦
        while let Some(&c) = self.input.peek() {
            if !c.is_whitespace() {
                break;
            }
            self.input.next();
        }
        
        // è¯»å–ä¸‹ä¸€ä¸ªå­—ç¬¦
        match self.input.next() {
            Some('0'..='9') => {
                let mut num = c.to_digit(10).unwrap() as i32;
                while let Some(&c) = self.input.peek() {
                    if !c.is_digit(10) {
                        break;
                    }
                    num = num * 10 + self.input.next().unwrap().to_digit(10).unwrap() as i32;
                }
                Token::Number(num)
            },
            Some('+') => Token::Plus,
            Some('-') => Token::Minus,
            Some('*') => Token::Times,
            Some('/') => Token::Divide,
            Some('(') => Token::LParen,
            Some(')') => Token::RParen,
            None => Token::EOF,
            _ => panic!("Unexpected character"),
        }
    }
}

struct Parser<'a> {
    lexer: Lexer<'a>,
    current_token: Token,
}

impl<'a> Parser<'a> {
    fn new(input: &'a str) -> Self {
        let mut lexer = Lexer::new(input);
        let current_token = lexer.next_token();
        Parser {
            lexer,
            current_token,
        }
    }
    
    fn match_token(&mut self, expected: Token) {
        if self.current_token == expected {
            self.current_token = self.lexer.next_token();
        } else {
            panic!("Unexpected token");
        }
    }
    
    // è¯­æ³•è§„åˆ™: E -> T E'
    fn parse_expression(&mut self) -> i32 {
        let mut value = self.parse_term();
        
        loop {
            match self.current_token {
                Token::Plus => {
                    self.match_token(Token::Plus);
                    value += self.parse_term();
                },
                Token::Minus => {
                    self.match_token(Token::Minus);
                    value -= self.parse_term();
                },
                _ => break,
            }
        }
        
        value
    }
    
    // è¯­æ³•è§„åˆ™: T -> F T'
    fn parse_term(&mut self) -> i32 {
        let mut value = self.parse_factor();
        
        loop {
            match self.current_token {
                Token::Times => {
                    self.match_token(Token::Times);
                    value *= self.parse_factor();
                },
                Token::Divide => {
                    self.match_token(Token::Divide);
                    value /= self.parse_factor();
                },
                _ => break,
            }
        }
        
        value
    }
    
    // è¯­æ³•è§„åˆ™: F -> number | ( E )
    fn parse_factor(&mut self) -> i32 {
        match self.current_token {
            Token::Number(n) => {
                let value = n;
                self.match_token(Token::Number(n));
                value
            },
            Token::LParen => {
                self.match_token(Token::LParen);
                let value = self.parse_expression();
                self.match_token(Token::RParen);
                value
            },
            _ => panic!("Unexpected token"),
        }
    }
    
    fn parse(&mut self) -> i32 {
        let result = self.parse_expression();
        if self.current_token != Token::EOF {
            panic!("Unexpected token at end of input");
        }
        result
    }
}
```

### 5.2 LL(1)è§£æè¡¨çš„Leanå½¢å¼åŒ–

```lean
import data.set
import data.finset
import data.list
import data.string

open set

-- æ–‡æ³•ç¬¦å·
inductive symbol (Î± : Type) (Î² : Type)
| terminal : Î± â†’ symbol
| non_terminal : Î² â†’ symbol

-- äº§ç”Ÿå¼
structure production (Î± : Type) (Î² : Type) :=
(lhs : Î²)
(rhs : list (symbol Î± Î²))

-- ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•
structure cfg (Î± : Type) (Î² : Type) :=
(terminals : finset Î±)
(non_terminals : finset Î²)
(productions : list (production Î± Î²))
(start_symbol : Î²)

-- FIRSTé›†åˆ
def first {Î± : Type} {Î² : Type} (g : cfg Î± Î²) : Î² â†’ finset Î± :=
Î» A, sorry  -- å®é™…å®ç°éœ€è¦è®¡ç®—FIRSTé›†åˆ

-- FOLLOWé›†åˆ
def follow {Î± : Type} {Î² : Type} (g : cfg Î± Î²) : Î² â†’ finset Î± :=
Î» A, sorry  -- å®é™…å®ç°éœ€è¦è®¡ç®—FOLLOWé›†åˆ

-- LL(1)è§£æè¡¨
def ll1_table {Î± : Type} {Î² : Type} (g : cfg Î± Î²) : 
  Î² â†’ Î± â†’ option (production Î± Î²) :=
Î» A a, sorry  -- å®é™…å®ç°éœ€è¦æ„å»ºLL(1)è§£æè¡¨

-- LL(1)è§£æå™¨
def ll1_parse {Î± : Type} {Î² : Type} (g : cfg Î± Î²) (table : Î² â†’ Î± â†’ option (production Î± Î²)) 
  (input : list Î±) : bool :=
let init_stack := [symbol.non_terminal g.start_symbol] in
sorry  -- å®é™…å®ç°éœ€è¦æ¨¡æ‹ŸLL(1)è§£æè¿‡ç¨‹

-- LL(1)æ–‡æ³•åˆ¤å®š
def is_ll1 {Î± : Type} {Î² : Type} (g : cfg Î± Î²) : Prop :=
âˆ€ (A : Î²) (pâ‚ pâ‚‚ : production Î± Î²),
  pâ‚ âˆˆ g.productions â†’ pâ‚‚ âˆˆ g.productions â†’
  pâ‚.lhs = A â†’ pâ‚‚.lhs = A â†’ pâ‚ â‰  pâ‚‚ â†’
  (first g pâ‚.rhs âˆ© first g pâ‚‚.rhs = âˆ…) âˆ§
  (if has_epsilon g pâ‚.rhs then first g pâ‚‚.rhs âˆ© follow g A = âˆ… else true)
```

## 6. åº”ç”¨ç¤ºä¾‹

### 6.1 è¡¨è¾¾å¼è§£æå™¨

**ç¤ºä¾‹ 6.1.1** (ç®—æœ¯è¡¨è¾¾å¼è§£æå™¨)

```pseudocode
// æ–‡æ³•è§„åˆ™
expr   â†’ term   ("+" term   | "-" term)*
term   â†’ factor ("*" factor | "/" factor)*
factor â†’ NUMBER | "(" expr ")"

// é€’å½’ä¸‹é™è§£æå™¨å®ç°
function parseExpr():
    let left = parseTerm()
    while current is "+" or "-":
        let op = current
        advance()
        let right = parseTerm()
        left = createBinaryExpr(left, op, right)
    return left

function parseTerm():
    let left = parseFactor()
    while current is "*" or "/":
        let op = current
        advance()
        let right = parseFactor()
        left = createBinaryExpr(left, op, right)
    return left

function parseFactor():
    if current is NUMBER:
        let value = current
        advance()
        return createNumberExpr(value)
    else if current is "(":
        advance()
        let expr = parseExpr()
        expect(")")
        return expr
    else:
        error("Expected number or '('")
```

### 6.2 ç¼–ç¨‹è¯­è¨€è§£æ

**ç¤ºä¾‹ 6.2.1** (ç®€å•è¯­è¨€è§£æå™¨)

```pseudocode
// æ–‡æ³•è§„åˆ™
program â†’ statement*
statement â†’ varDecl | ifStmt | whileStmt | block | exprStmt
varDecl â†’ "var" IDENTIFIER "=" expr ";"
ifStmt â†’ "if" "(" expr ")" statement ("else" statement)?
whileStmt â†’ "while" "(" expr ")" statement
block â†’ "{" statement* "}"
exprStmt â†’ expr ";"

// è§£æå™¨å®ç°
function parseProgram():
    let statements = []
    while not atEnd():
        statements.push(parseStatement())
    return createProgram(statements)

function parseStatement():
    if match("var"):
        return parseVarDecl()
    if match("if"):
        return parseIfStmt()
    if match("while"):
        return parseWhileStmt()
    if match("{"):
        return parseBlock()
    return parseExprStmt()
```

### 6.3 é¢†åŸŸç‰¹å®šè¯­è¨€è§£æ

**ç¤ºä¾‹ 6.3.1** (JSONè§£æå™¨)

```pseudocode
// JSONæ–‡æ³•
json     â†’ object | array | string | number | "true" | "false" | "null"
object   â†’ "{" (pair ("," pair)*)? "}"
pair     â†’ string ":" json
array    â†’ "[" (json ("," json)*)? "]"
string   â†’ "\"" char* "\""
number   â†’ digit+ ("." digit+)?

// JSONè§£æå™¨å®ç°
function parseJSON():
    return parseValue()

function parseValue():
    if match("{"):
        return parseObject()
    if match("["):
        return parseArray()
    if match("\""):
        return parseString()
    if isDigit(current):
        return parseNumber()
    if match("true"):
        return createBooleanValue(true)
    if match("false"):
        return createBooleanValue(false)
    if match("null"):
        return createNullValue()
    error("Expected JSON value")
```

## 7. å‚è€ƒæ–‡çŒ®

1. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). Compilers: Principles, techniques, and tools. Addison-Wesley.
2. Grune, D., & Jacobs, C. J. (2008). Parsing techniques: a practical guide. Springer Science & Business Media.
3. Knuth, D. E. (1965). On the translation of languages from left to right. Information and Control, 8(6), 607-639.
4. Parr, T. (2010). Language implementation patterns: create your own domain-specific and general programming languages. Pragmatic Bookshelf.
5. Scott, E., & Johnstone, A. (2010). GLL parsing. Electronic Notes in Theoretical Computer Science, 253(7), 177-189.
