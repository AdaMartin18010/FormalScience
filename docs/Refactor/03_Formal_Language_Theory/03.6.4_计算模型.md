# 03.6.4 è®¡ç®—æ¨¡å‹ (Computational Models)

## ğŸ“‹ æ¦‚è¿°

è®¡ç®—æ¨¡å‹æ˜¯å½¢å¼è¯­è¨€ç†è®ºçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œæä¾›äº†æè¿°å’Œåˆ†ç±»è®¡ç®—èƒ½åŠ›çš„å½¢å¼åŒ–æ¡†æ¶ã€‚æœ¬æ–‡æ¡£æ·±å…¥æ¢è®¨å„ç§è®¡ç®—æ¨¡å‹çš„ç†è®ºåŸºç¡€ã€å½¢å¼åŒ–å®šä¹‰ã€ç­‰ä»·æ€§å…³ç³»ä»¥åŠåœ¨è®¡ç®—æœºç§‘å­¦ä¸­çš„åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹è®¡ç®—æ¨¡å‹çš„å½¢å¼åŒ–ç†è®ºæ¡†æ¶**
2. **åˆ†æä¸åŒè®¡ç®—æ¨¡å‹çš„è¡¨è¾¾èƒ½åŠ›**
3. **è¯æ˜è®¡ç®—æ¨¡å‹ä¹‹é—´çš„ç­‰ä»·æ€§**
4. **æ¢è®¨è®¡ç®—æ¨¡å‹çš„å±€é™æ€§**
5. **å±•ç¤ºè®¡ç®—æ¨¡å‹åœ¨å®è·µä¸­çš„åº”ç”¨**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å›¾çµæœºæ¨¡å‹](#2-å›¾çµæœºæ¨¡å‹)
3. [Î»æ¼”ç®—æ¨¡å‹](#3-Î»æ¼”ç®—æ¨¡å‹)
4. [é€’å½’å‡½æ•°æ¨¡å‹](#4-é€’å½’å‡½æ•°æ¨¡å‹)
5. [å…¶ä»–è®¡ç®—æ¨¡å‹](#5-å…¶ä»–è®¡ç®—æ¨¡å‹)
6. [è®¡ç®—æ¨¡å‹ç­‰ä»·æ€§](#6-è®¡ç®—æ¨¡å‹ç­‰ä»·æ€§)
7. [ä»£ç å®ç°](#7-ä»£ç å®ç°)
8. [åº”ç”¨ç¤ºä¾‹](#8-åº”ç”¨ç¤ºä¾‹)
9. [ç›¸å…³ç†è®º](#9-ç›¸å…³ç†è®º)
10. [å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è®¡ç®—æ¨¡å‹çš„å®šä¹‰

**å®šä¹‰ 1.1.1 (è®¡ç®—æ¨¡å‹)**
è®¡ç®—æ¨¡å‹æ˜¯ä¸€ä¸ªå››å…ƒç»„ $\mathcal{M} = (S, I, O, \delta)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯çŠ¶æ€é›†åˆ
- $I$ æ˜¯è¾“å…¥é›†åˆ
- $O$ æ˜¯è¾“å‡ºé›†åˆ
- $\delta$ æ˜¯è½¬ç§»å‡½æ•°

**å®šä¹‰ 1.1.2 (è®¡ç®—èƒ½åŠ›)**
è®¡ç®—æ¨¡å‹çš„è®¡ç®—èƒ½åŠ›ç”±å…¶èƒ½å¤Ÿè§£å†³çš„é—®é¢˜é›†åˆå†³å®šã€‚

**å®šä¹‰ 1.1.3 (å›¾çµç­‰ä»·)**
ä¸¤ä¸ªè®¡ç®—æ¨¡å‹æ˜¯å›¾çµç­‰ä»·çš„ï¼Œå½“ä¸”ä»…å½“å®ƒä»¬èƒ½å¤Ÿè§£å†³ç›¸åŒçš„è®¡ç®—é—®é¢˜ã€‚

### 1.2 è®¡ç®—æ¨¡å‹çš„åˆ†ç±»

è®¡ç®—æ¨¡å‹å¯ä»¥æŒ‰ç…§ä»¥ä¸‹ç»´åº¦åˆ†ç±»ï¼š

1. **ç¡®å®šæ€§ vs éç¡®å®šæ€§**
2. **æœ‰é™ vs æ— é™å­˜å‚¨**
3. **åŒæ­¥ vs å¼‚æ­¥**
4. **é›†ä¸­å¼ vs åˆ†å¸ƒå¼**

## 2. å›¾çµæœºæ¨¡å‹

### 2.1 æ ‡å‡†å›¾çµæœº

**å®šä¹‰ 2.1.1 (å›¾çµæœº)**
æ ‡å‡†å›¾çµæœºæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $M = (Q, \Sigma, \Gamma, \delta, q_0, B, F)$ï¼Œå…¶ä¸­ï¼š

- $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\Gamma$ æ˜¯ç£å¸¦å­—æ¯è¡¨ï¼Œ$\Sigma \subseteq \Gamma$
- $\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\}$ æ˜¯è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $B \in \Gamma \setminus \Sigma$ æ˜¯ç©ºç™½ç¬¦å·
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†åˆ

**å®šç† 2.1.1 (å›¾çµæœºé€šç”¨æ€§)**
å¯¹äºä»»ä½•å¯è®¡ç®—å‡½æ•° $f$ï¼Œå­˜åœ¨å›¾çµæœº $M$ è®¡ç®— $f$ã€‚

**è¯æ˜ï¼š** é€šè¿‡æ„é€ æ€§è¯æ˜ï¼Œå±•ç¤ºå¦‚ä½•æ„é€ è®¡ç®—ç»™å®šå‡½æ•°çš„å›¾çµæœºã€‚

### 2.2 å›¾çµæœºå˜ç§

#### 2.2.1 å¤šå¸¦å›¾çµæœº

**å®šä¹‰ 2.2.1 (å¤šå¸¦å›¾çµæœº)**
$k$ å¸¦å›¾çµæœºæœ‰ $k$ ä¸ªç£å¸¦ï¼Œæ¯ä¸ªç£å¸¦éƒ½æœ‰è‡ªå·±çš„è¯»å†™å¤´ã€‚

**å®šç† 2.2.1 (å¤šå¸¦å›¾çµæœºç­‰ä»·æ€§)**
å¤šå¸¦å›¾çµæœºä¸æ ‡å‡†å›¾çµæœºåœ¨è®¡ç®—èƒ½åŠ›ä¸Šç­‰ä»·ã€‚

**è¯æ˜ï¼š** é€šè¿‡æ¨¡æ‹Ÿï¼Œå±•ç¤ºå¦‚ä½•ç”¨æ ‡å‡†å›¾çµæœºæ¨¡æ‹Ÿå¤šå¸¦å›¾çµæœºã€‚

#### 2.2.2 éç¡®å®šæ€§å›¾çµæœº

**å®šä¹‰ 2.2.2 (éç¡®å®šæ€§å›¾çµæœº)**
éç¡®å®šæ€§å›¾çµæœºçš„è½¬ç§»å‡½æ•°ä¸ºï¼š
$$\delta: Q \times \Gamma \rightarrow \mathcal{P}(Q \times \Gamma \times \{L, R\})$$

**å®šç† 2.2.2 (éç¡®å®šæ€§å›¾çµæœºç­‰ä»·æ€§)**
éç¡®å®šæ€§å›¾çµæœºä¸ç¡®å®šæ€§å›¾çµæœºåœ¨è®¡ç®—èƒ½åŠ›ä¸Šç­‰ä»·ã€‚

**è¯æ˜ï¼š** é€šè¿‡çŠ¶æ€ç©ºé—´æœç´¢ï¼Œå±•ç¤ºå¦‚ä½•ç”¨ç¡®å®šæ€§å›¾çµæœºæ¨¡æ‹Ÿéç¡®å®šæ€§å›¾çµæœºã€‚

## 3. Î»æ¼”ç®—æ¨¡å‹

### 3.1 Î»æ¼”ç®—è¯­æ³•

**å®šä¹‰ 3.1.1 (Î»é¡¹)**
Î»é¡¹ç”±ä»¥ä¸‹è¯­æ³•å®šä¹‰ï¼š
$$M ::= x \mid \lambda x.M \mid M M$$

å…¶ä¸­ï¼š

- $x$ æ˜¯å˜é‡
- $\lambda x.M$ æ˜¯æŠ½è±¡
- $M M$ æ˜¯åº”ç”¨

**å®šä¹‰ 3.1.2 (è‡ªç”±å˜é‡)**
å˜é‡ $x$ åœ¨é¡¹ $M$ ä¸­çš„è‡ªç”±å‡ºç°ï¼š
$$\text{FV}(x) = \{x\}$$
$$\text{FV}(\lambda x.M) = \text{FV}(M) \setminus \{x\}$$
$$\text{FV}(M N) = \text{FV}(M) \cup \text{FV}(N)$$

### 3.2 Î»æ¼”ç®—å½’çº¦

**å®šä¹‰ 3.2.1 (Î²å½’çº¦)**
Î²å½’çº¦è§„åˆ™ï¼š
$$(\lambda x.M) N \rightarrow_\beta M[x := N]$$

å…¶ä¸­ $M[x := N]$ è¡¨ç¤ºå°† $M$ ä¸­æ‰€æœ‰è‡ªç”±å‡ºç°çš„ $x$ æ›¿æ¢ä¸º $N$ã€‚

**å®šä¹‰ 3.2.2 (Î±ç­‰ä»·)**
Î±ç­‰ä»·é€šè¿‡å˜é‡é‡å‘½åå®šä¹‰ï¼š
$$\lambda x.M =_\alpha \lambda y.M[x := y]$$

**å®šç† 3.2.1 (Church-Rosserå®šç†)**
å¦‚æœ $M \rightarrow^* N_1$ ä¸” $M \rightarrow^* N_2$ï¼Œåˆ™å­˜åœ¨ $N$ ä½¿å¾— $N_1 \rightarrow^* N$ ä¸” $N_2 \rightarrow^* N$ã€‚

**è¯æ˜ï¼š** é€šè¿‡å¹¶è¡Œå½’çº¦å’Œæ ‡å‡†åŒ–å½’çº¦ã€‚

### 3.3 Î»æ¼”ç®—ç¼–ç 

**å®šä¹‰ 3.3.1 (Churchæ•°)**
Churchæ•°ç¼–ç ï¼š
$$\overline{n} = \lambda f.\lambda x.f^n(x)$$

**å®šä¹‰ 3.3.2 (å¸ƒå°”å€¼)**
å¸ƒå°”å€¼ç¼–ç ï¼š
$$\text{true} = \lambda x.\lambda y.x$$
$$\text{false} = \lambda x.\lambda y.y$$

**å®šç† 3.3.1 (Î»æ¼”ç®—å›¾çµç­‰ä»·)**
Î»æ¼”ç®—ä¸å›¾çµæœºåœ¨è®¡ç®—èƒ½åŠ›ä¸Šç­‰ä»·ã€‚

**è¯æ˜ï¼š** é€šè¿‡ç›¸äº’æ¨¡æ‹Ÿï¼š

1. ç”¨Î»æ¼”ç®—æ¨¡æ‹Ÿå›¾çµæœº
2. ç”¨å›¾çµæœºæ¨¡æ‹ŸÎ»æ¼”ç®—

## 4. é€’å½’å‡½æ•°æ¨¡å‹

### 4.1 åŸå§‹é€’å½’å‡½æ•°

**å®šä¹‰ 4.1.1 (åŸºæœ¬å‡½æ•°)**
åŸºæœ¬å‡½æ•°åŒ…æ‹¬ï¼š

1. **é›¶å‡½æ•°**ï¼š$Z(x) = 0$
2. **åç»§å‡½æ•°**ï¼š$S(x) = x + 1$
3. **æŠ•å½±å‡½æ•°**ï¼š$P_i^n(x_1, \ldots, x_n) = x_i$

**å®šä¹‰ 4.1.2 (å¤åˆ)**
å¦‚æœ $f$ æ˜¯ $k$ å…ƒå‡½æ•°ï¼Œ$g_1, \ldots, g_k$ æ˜¯ $n$ å…ƒå‡½æ•°ï¼Œåˆ™ï¼š
$$h(x_1, \ldots, x_n) = f(g_1(x_1, \ldots, x_n), \ldots, g_k(x_1, \ldots, x_n))$$

**å®šä¹‰ 4.1.3 (åŸå§‹é€’å½’)**
å¦‚æœ $f$ æ˜¯ $n$ å…ƒå‡½æ•°ï¼Œ$g$ æ˜¯ $n+2$ å…ƒå‡½æ•°ï¼Œåˆ™ï¼š
$$h(x_1, \ldots, x_n, 0) = f(x_1, \ldots, x_n)$$
$$h(x_1, \ldots, x_n, y+1) = g(x_1, \ldots, x_n, y, h(x_1, \ldots, x_n, y))$$

### 4.2 ä¸€èˆ¬é€’å½’å‡½æ•°

**å®šä¹‰ 4.2.1 (Î¼ç®—å­)**
å¦‚æœ $f$ æ˜¯ $n+1$ å…ƒå‡½æ•°ï¼Œåˆ™ï¼š
$$\mu y[f(x_1, \ldots, x_n, y) = 0] = \text{æœ€å°çš„ } y \text{ ä½¿å¾— } f(x_1, \ldots, x_n, y) = 0$$

**å®šä¹‰ 4.2.2 (ä¸€èˆ¬é€’å½’å‡½æ•°)**
ä¸€èˆ¬é€’å½’å‡½æ•°æ˜¯åŒ…å«åŸºæœ¬å‡½æ•°ã€å¤åˆã€åŸå§‹é€’å½’å’ŒÎ¼ç®—å­çš„æœ€å°å‡½æ•°ç±»ã€‚

**å®šç† 4.2.1 (é€’å½’å‡½æ•°å›¾çµç­‰ä»·)**
ä¸€èˆ¬é€’å½’å‡½æ•°ä¸å›¾çµæœºåœ¨è®¡ç®—èƒ½åŠ›ä¸Šç­‰ä»·ã€‚

**è¯æ˜ï¼š** é€šè¿‡ç›¸äº’æ¨¡æ‹Ÿï¼š

1. ç”¨é€’å½’å‡½æ•°æ¨¡æ‹Ÿå›¾çµæœº
2. ç”¨å›¾çµæœºæ¨¡æ‹Ÿé€’å½’å‡½æ•°

## 5. å…¶ä»–è®¡ç®—æ¨¡å‹

### 5.1 å¯„å­˜å™¨æœº

**å®šä¹‰ 5.1.1 (å¯„å­˜å™¨æœº)**
å¯„å­˜å™¨æœºåŒ…å«ï¼š

- æ— é™å¤šä¸ªå¯„å­˜å™¨ $R_0, R_1, R_2, \ldots$
- ç¨‹åºè®¡æ•°å™¨
- æŒ‡ä»¤é›†ï¼šæ¸…é›¶ã€é€’å¢ã€é€’å‡ã€è·³è½¬

**å®šç† 5.1.1 (å¯„å­˜å™¨æœºå›¾çµç­‰ä»·)**
å¯„å­˜å™¨æœºä¸å›¾çµæœºåœ¨è®¡ç®—èƒ½åŠ›ä¸Šç­‰ä»·ã€‚

### 5.2 ç»†èƒè‡ªåŠ¨æœº

**å®šä¹‰ 5.2.1 (ç»†èƒè‡ªåŠ¨æœº)**
ç»†èƒè‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(\Sigma, N, f)$ï¼Œå…¶ä¸­ï¼š

- $\Sigma$ æ˜¯çŠ¶æ€é›†åˆ
- $N$ æ˜¯é‚»åŸŸå‡½æ•°
- $f: \Sigma^{|N|} \rightarrow \Sigma$ æ˜¯å±€éƒ¨è§„åˆ™

**å®šç† 5.2.1 (ç»†èƒè‡ªåŠ¨æœºè®¡ç®—èƒ½åŠ›)**
æŸäº›ç»†èƒè‡ªåŠ¨æœºï¼ˆå¦‚Conwayçš„ç”Ÿå‘½æ¸¸æˆï¼‰æ˜¯å›¾çµç­‰ä»·çš„ã€‚

### 5.3 é‡å­è®¡ç®—æ¨¡å‹

**å®šä¹‰ 5.3.1 (é‡å­å›¾çµæœº)**
é‡å­å›¾çµæœºçš„è½¬ç§»å‡½æ•°æ˜¯é…‰ç®—å­ï¼š
$$\delta: Q \times \Gamma \rightarrow \mathbb{C}^{Q \times \Gamma \times \{L, R\}}$$

**å®šç† 5.3.1 (é‡å­è®¡ç®—èƒ½åŠ›)**
é‡å­å›¾çµæœºåœ¨è®¡ç®—èƒ½åŠ›ä¸Šç­‰ä»·äºç»å…¸å›¾çµæœºï¼Œä½†åœ¨æŸäº›é—®é¢˜ä¸Šå¯èƒ½æ›´é«˜æ•ˆã€‚

## 6. è®¡ç®—æ¨¡å‹ç­‰ä»·æ€§

### 6.1 ç­‰ä»·æ€§è¯æ˜æ–¹æ³•

**æ–¹æ³• 6.1.1 (æ¨¡æ‹Ÿæ–¹æ³•)**
é€šè¿‡æ„é€ æ¨¡æ‹Ÿå™¨è¯æ˜ä¸¤ä¸ªè®¡ç®—æ¨¡å‹ç­‰ä»·ã€‚

**æ–¹æ³• 6.1.2 (ç¼–ç æ–¹æ³•)**
é€šè¿‡ç¼–ç å°†ä¸€ä¸ªé—®é¢˜è½¬æ¢ä¸ºå¦ä¸€ä¸ªé—®é¢˜ã€‚

**æ–¹æ³• 6.1.3 (å½’çº¦æ–¹æ³•)**
é€šè¿‡å½’çº¦è¯æ˜è®¡ç®—èƒ½åŠ›çš„å…³ç³»ã€‚

### 6.2 ç­‰ä»·æ€§å®šç†

**å®šç† 6.2.1 (Church-Turingè®ºé¢˜)**
ä»»ä½•å¯è®¡ç®—å‡½æ•°éƒ½å¯ä»¥ç”±å›¾çµæœºè®¡ç®—ã€‚

**å®šç† 6.2.2 (è®¡ç®—æ¨¡å‹ç­‰ä»·æ€§)**
ä»¥ä¸‹è®¡ç®—æ¨¡å‹åœ¨è®¡ç®—èƒ½åŠ›ä¸Šç­‰ä»·ï¼š

1. å›¾çµæœº
2. Î»æ¼”ç®—
3. ä¸€èˆ¬é€’å½’å‡½æ•°
4. å¯„å­˜å™¨æœº
5. Postç³»ç»Ÿ

## 7. ä»£ç å®ç°

### 7.1 å›¾çµæœºå®ç°

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum Direction {
    Left,
    Right,
}

#[derive(Debug, Clone)]
pub struct Transition {
    pub next_state: String,
    pub write_symbol: char,
    pub direction: Direction,
}

#[derive(Debug)]
pub struct TuringMachine {
    pub states: Vec<String>,
    pub input_alphabet: Vec<char>,
    pub tape_alphabet: Vec<char>,
    pub transitions: std::collections::HashMap<(String, char), Transition>,
    pub initial_state: String,
    pub blank_symbol: char,
    pub accept_states: Vec<String>,
}

impl TuringMachine {
    pub fn new(
        states: Vec<String>,
        input_alphabet: Vec<char>,
        tape_alphabet: Vec<char>,
        initial_state: String,
        blank_symbol: char,
        accept_states: Vec<String>,
    ) -> Self {
        Self {
            states,
            input_alphabet,
            tape_alphabet,
            transitions: std::collections::HashMap::new(),
            initial_state,
            blank_symbol,
            accept_states,
        }
    }

    pub fn add_transition(
        &mut self,
        current_state: String,
        read_symbol: char,
        next_state: String,
        write_symbol: char,
        direction: Direction,
    ) {
        self.transitions.insert(
            (current_state, read_symbol),
            Transition {
                next_state,
                write_symbol,
                direction,
            },
        );
    }

    pub fn run(&self, input: &str) -> bool {
        let mut tape: Vec<char> = input.chars().collect();
        let mut head = 0;
        let mut current_state = self.initial_state.clone();

        loop {
            // æ‰©å±•ç£å¸¦å¦‚æœéœ€è¦
            while head >= tape.len() {
                tape.push(self.blank_symbol);
            }
            while head < 0 {
                tape.insert(0, self.blank_symbol);
                head += 1;
            }

            let current_symbol = tape[head];
            
            // æ£€æŸ¥æ˜¯å¦åœ¨æ¥å—çŠ¶æ€
            if self.accept_states.contains(&current_state) {
                return true;
            }

            // æŸ¥æ‰¾è½¬ç§»
            if let Some(transition) = self.transitions.get(&(current_state.clone(), current_symbol)) {
                // å†™å…¥ç¬¦å·
                tape[head] = transition.write_symbol;
                
                // ç§»åŠ¨è¯»å†™å¤´
                match transition.direction {
                    Direction::Left => head -= 1,
                    Direction::Right => head += 1,
                }
                
                // æ›´æ–°çŠ¶æ€
                current_state = transition.next_state.clone();
            } else {
                // æ²¡æœ‰è½¬ç§»ï¼Œæ‹’ç»
                return false;
            }
        }
    }
}

// ç¤ºä¾‹ï¼šæ„é€ ä¸€ä¸ªè¯†åˆ« {0^n1^n | n â‰¥ 0} çš„å›¾çµæœº
pub fn create_an_bn_turing_machine() -> TuringMachine {
    let mut tm = TuringMachine::new(
        vec!["q0".to_string(), "q1".to_string(), "q2".to_string(), "q3".to_string(), "q4".to_string()],
        vec!['0', '1'],
        vec!['0', '1', 'X', 'Y', 'B'],
        "q0".to_string(),
        'B',
        vec!["q4".to_string()],
    );

    // çŠ¶æ€ q0: å¯»æ‰¾ç¬¬ä¸€ä¸ª 0
    tm.add_transition("q0".to_string(), '0', "q1".to_string(), 'X', Direction::Right);
    tm.add_transition("q0".to_string(), 'Y', "q3".to_string(), 'Y', Direction::Right);
    tm.add_transition("q0".to_string(), 'B', "q4".to_string(), 'B', Direction::Right);

    // çŠ¶æ€ q1: å¯»æ‰¾ç¬¬ä¸€ä¸ª 1
    tm.add_transition("q1".to_string(), '0', "q1".to_string(), '0', Direction::Right);
    tm.add_transition("q1".to_string(), '1', "q2".to_string(), 'Y', Direction::Left);
    tm.add_transition("q1".to_string(), 'Y', "q1".to_string(), 'Y', Direction::Right);

    // çŠ¶æ€ q2: å›åˆ°å¼€å§‹
    tm.add_transition("q2".to_string(), '0', "q2".to_string(), '0', Direction::Left);
    tm.add_transition("q2".to_string(), 'X', "q0".to_string(), 'X', Direction::Right);
    tm.add_transition("q2".to_string(), 'Y', "q2".to_string(), 'Y', Direction::Left);

    // çŠ¶æ€ q3: æ£€æŸ¥æ˜¯å¦éƒ½æ˜¯ Y
    tm.add_transition("q3".to_string(), 'Y', "q3".to_string(), 'Y', Direction::Right);
    tm.add_transition("q3".to_string(), 'B', "q4".to_string(), 'B', Direction::Right);

    tm
}
```

### 7.2 Î»æ¼”ç®—å®ç°

```rust
#[derive(Debug, Clone, PartialEq)]
pub enum LambdaTerm {
    Variable(String),
    Abstraction(String, Box<LambdaTerm>),
    Application(Box<LambdaTerm>, Box<LambdaTerm>),
}

impl LambdaTerm {
    pub fn variable(name: &str) -> Self {
        LambdaTerm::Variable(name.to_string())
    }

    pub fn abstraction(var: &str, body: LambdaTerm) -> Self {
        LambdaTerm::Abstraction(var.to_string(), Box::new(body))
    }

    pub fn application(func: LambdaTerm, arg: LambdaTerm) -> Self {
        LambdaTerm::Application(Box::new(func), Box::new(arg))
    }

    pub fn free_variables(&self) -> std::collections::HashSet<String> {
        match self {
            LambdaTerm::Variable(name) => {
                let mut set = std::collections::HashSet::new();
                set.insert(name.clone());
                set
            }
            LambdaTerm::Abstraction(var, body) => {
                let mut set = body.free_variables();
                set.remove(var);
                set
            }
            LambdaTerm::Application(func, arg) => {
                let mut set = func.free_variables();
                set.extend(arg.free_variables());
                set
            }
        }
    }

    pub fn substitute(&self, var: &str, replacement: &LambdaTerm) -> LambdaTerm {
        match self {
            LambdaTerm::Variable(name) => {
                if name == var {
                    replacement.clone()
                } else {
                    self.clone()
                }
            }
            LambdaTerm::Abstraction(param, body) => {
                if param == var {
                    self.clone()
                } else {
                    let free_vars = replacement.free_variables();
                    if free_vars.contains(param) {
                        // éœ€è¦Î±é‡å‘½å
                        let new_param = format!("{}'", param);
                        let renamed_body = body.substitute(param, &LambdaTerm::variable(&new_param));
                        LambdaTerm::abstraction(&new_param, renamed_body.substitute(var, replacement))
                    } else {
                        LambdaTerm::abstraction(param, body.substitute(var, replacement))
                    }
                }
            }
            LambdaTerm::Application(func, arg) => {
                LambdaTerm::application(
                    func.substitute(var, replacement),
                    arg.substitute(var, replacement),
                )
            }
        }
    }

    pub fn beta_reduce(&self) -> Option<LambdaTerm> {
        match self {
            LambdaTerm::Application(func, arg) => {
                if let LambdaTerm::Abstraction(var, body) = func.as_ref() {
                    // Î²å½’çº¦
                    Some(body.substitute(var, arg))
                } else {
                    // å°è¯•å½’çº¦å‡½æ•°éƒ¨åˆ†
                    if let Some(reduced_func) = func.beta_reduce() {
                        Some(LambdaTerm::application(reduced_func, arg.clone()))
                    } else {
                        // å°è¯•å½’çº¦å‚æ•°éƒ¨åˆ†
                        if let Some(reduced_arg) = arg.beta_reduce() {
                            Some(LambdaTerm::application(func.clone(), reduced_arg))
                        } else {
                            None
                        }
                    }
                }
            }
            LambdaTerm::Abstraction(var, body) => {
                if let Some(reduced_body) = body.beta_reduce() {
                    Some(LambdaTerm::abstraction(var, reduced_body))
                } else {
                    None
                }
            }
            LambdaTerm::Variable(_) => None,
        }
    }

    pub fn normalize(&self) -> LambdaTerm {
        let mut current = self.clone();
        while let Some(reduced) = current.beta_reduce() {
            current = reduced;
        }
        current
    }
}

// Churchæ•°ç¼–ç 
pub fn church_numeral(n: usize) -> LambdaTerm {
    let mut result = LambdaTerm::abstraction("f", LambdaTerm::abstraction("x", LambdaTerm::variable("x")));
    for _ in 0..n {
        result = LambdaTerm::abstraction(
            "f",
            LambdaTerm::abstraction(
                "x",
                LambdaTerm::application(
                    LambdaTerm::variable("f"),
                    LambdaTerm::application(
                        LambdaTerm::application(result, LambdaTerm::variable("f")),
                        LambdaTerm::variable("x"),
                    ),
                ),
            ),
        );
    }
    result
}

// å¸ƒå°”å€¼ç¼–ç 
pub fn church_true() -> LambdaTerm {
    LambdaTerm::abstraction("x", LambdaTerm::abstraction("y", LambdaTerm::variable("x")))
}

pub fn church_false() -> LambdaTerm {
    LambdaTerm::abstraction("x", LambdaTerm::abstraction("y", LambdaTerm::variable("y")))
}
```

### 7.3 é€’å½’å‡½æ•°å®ç°

```rust
#[derive(Debug, Clone)]
pub enum RecursiveFunction {
    Zero,
    Successor,
    Projection(usize, usize), // Projection(i, n) = P_i^n
    Composition(Box<RecursiveFunction>, Vec<RecursiveFunction>),
    PrimitiveRecursion(Box<RecursiveFunction>, Box<RecursiveFunction>),
    Minimization(Box<RecursiveFunction>),
}

impl RecursiveFunction {
    pub fn evaluate(&self, args: &[u64]) -> Option<u64> {
        match self {
            RecursiveFunction::Zero => Some(0),
            RecursiveFunction::Successor => {
                if args.len() == 1 {
                    Some(args[0] + 1)
                } else {
                    None
                }
            }
            RecursiveFunction::Projection(i, n) => {
                if args.len() == *n && *i < *n {
                    Some(args[*i])
                } else {
                    None
                }
            }
            RecursiveFunction::Composition(f, gs) => {
                // è®¡ç®— g_1(args), ..., g_k(args)
                let mut g_results = Vec::new();
                for g in gs {
                    if let Some(result) = g.evaluate(args) {
                        g_results.push(result);
                    } else {
                        return None;
                    }
                }
                // è®¡ç®— f(g_results)
                f.evaluate(&g_results)
            }
            RecursiveFunction::PrimitiveRecursion(f, g) => {
                if args.is_empty() {
                    return None;
                }
                let n = args.len() - 1;
                let y = args[n];
                let x_args = &args[..n];

                if y == 0 {
                    // h(x, 0) = f(x)
                    f.evaluate(x_args)
                } else {
                    // h(x, y+1) = g(x, y, h(x, y))
                    let mut recursive_args = x_args.to_vec();
                    recursive_args.push(y - 1);
                    if let Some(prev_result) = self.evaluate(&recursive_args) {
                        let mut g_args = x_args.to_vec();
                        g_args.push(y - 1);
                        g_args.push(prev_result);
                        g.evaluate(&g_args)
                    } else {
                        None
                    }
                }
            }
            RecursiveFunction::Minimization(f) => {
                if args.is_empty() {
                    return None;
                }
                let n = args.len() - 1;
                let y = args[n];
                let x_args = &args[..n];

                // å¯»æ‰¾æœ€å°çš„ z ä½¿å¾— f(x, z) = 0
                let mut z = 0;
                loop {
                    let mut f_args = x_args.to_vec();
                    f_args.push(z);
                    match f.evaluate(&f_args) {
                        Some(0) => return Some(z),
                        Some(_) => z += 1,
                        None => return None, // å‡½æ•°æœªå®šä¹‰
                    }
                }
            }
        }
    }
}

// ç¤ºä¾‹ï¼šåŠ æ³•å‡½æ•°
pub fn addition_function() -> RecursiveFunction {
    // add(x, y) = x + y
    // ä½¿ç”¨åŸå§‹é€’å½’ï¼šadd(x, 0) = x, add(x, y+1) = S(add(x, y))
    RecursiveFunction::PrimitiveRecursion(
        Box::new(RecursiveFunction::Projection(0, 1)), // f(x) = x
        Box::new(RecursiveFunction::Composition(
            Box::new(RecursiveFunction::Successor),
            vec![RecursiveFunction::Projection(2, 3)], // g(x, y, z) = S(z)
        )),
    )
}

// ç¤ºä¾‹ï¼šä¹˜æ³•å‡½æ•°
pub fn multiplication_function() -> RecursiveFunction {
    // mult(x, y) = x * y
    // ä½¿ç”¨åŸå§‹é€’å½’ï¼šmult(x, 0) = 0, mult(x, y+1) = add(x, mult(x, y))
    RecursiveFunction::PrimitiveRecursion(
        Box::new(RecursiveFunction::Zero), // f(x) = 0
        Box::new(RecursiveFunction::Composition(
            Box::new(addition_function()),
            vec![
                RecursiveFunction::Projection(0, 3), // x
                RecursiveFunction::Projection(2, 3), // mult(x, y)
            ],
        )),
    )
}
```

## 8. åº”ç”¨ç¤ºä¾‹

### 8.1 å›¾çµæœºåº”ç”¨

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_an_bn_turing_machine() {
        let tm = create_an_bn_turing_machine();
        
        // æµ‹è¯•æœ‰æ•ˆè¾“å…¥
        assert!(tm.run(""));
        assert!(tm.run("01"));
        assert!(tm.run("0011"));
        assert!(tm.run("000111"));
        
        // æµ‹è¯•æ— æ•ˆè¾“å…¥
        assert!(!tm.run("0"));
        assert!(!tm.run("1"));
        assert!(!tm.run("10"));
        assert!(!tm.run("001"));
        assert!(!tm.run("011"));
    }
}
```

### 8.2 Î»æ¼”ç®—åº”ç”¨

```rust
#[cfg(test)]
mod lambda_tests {
    use super::*;

    #[test]
    fn test_church_numerals() {
        let zero = church_numeral(0);
        let one = church_numeral(1);
        let two = church_numeral(2);
        
        // æµ‹è¯• Church æ•° 0
        let result = zero.normalize();
        println!("Church 0: {:?}", result);
        
        // æµ‹è¯• Church æ•° 1
        let result = one.normalize();
        println!("Church 1: {:?}", result);
        
        // æµ‹è¯• Church æ•° 2
        let result = two.normalize();
        println!("Church 2: {:?}", result);
    }

    #[test]
    fn test_boolean_encoding() {
        let true_val = church_true();
        let false_val = church_false();
        
        // æµ‹è¯•å¸ƒå°”å€¼ç¼–ç 
        println!("Church true: {:?}", true_val);
        println!("Church false: {:?}", false_val);
    }
}
```

### 8.3 é€’å½’å‡½æ•°åº”ç”¨

```rust
#[cfg(test)]
mod recursive_tests {
    use super::*;

    #[test]
    fn test_addition_function() {
        let add = addition_function();
        
        // æµ‹è¯•åŠ æ³•
        assert_eq!(add.evaluate(&[3, 4]), Some(7));
        assert_eq!(add.evaluate(&[0, 5]), Some(5));
        assert_eq!(add.evaluate(&[7, 0]), Some(7));
    }

    #[test]
    fn test_multiplication_function() {
        let mult = multiplication_function();
        
        // æµ‹è¯•ä¹˜æ³•
        assert_eq!(mult.evaluate(&[3, 4]), Some(12));
        assert_eq!(mult.evaluate(&[0, 5]), Some(0));
        assert_eq!(mult.evaluate(&[7, 0]), Some(0));
    }
}
```

## 9. ç›¸å…³ç†è®º

### 9.1 å¯è®¡ç®—æ€§ç†è®º

- **åœæœºé—®é¢˜**ï¼šå›¾çµæœºåœæœºé—®é¢˜çš„ä¸å¯åˆ¤å®šæ€§
- **é€’å½’å®šç†**ï¼šè‡ªå¼•ç”¨å’Œé€’å½’æ„é€ çš„ç†è®ºåŸºç¡€
- **å½’çº¦ç†è®º**ï¼šé—®é¢˜é—´å¤æ‚æ€§çš„æ¯”è¾ƒæ–¹æ³•

### 9.2 å¤æ‚æ€§ç†è®º

- **æ—¶é—´å¤æ‚æ€§**ï¼šè®¡ç®—æ‰€éœ€çš„æ—¶é—´èµ„æº
- **ç©ºé—´å¤æ‚æ€§**ï¼šè®¡ç®—æ‰€éœ€çš„å­˜å‚¨èµ„æº
- **å¤æ‚æ€§ç±»**ï¼šPã€NPã€PSPACEç­‰å¤æ‚æ€§ç±»

### 9.3 å½¢å¼è¯­è¨€ç†è®º

- **ä¹”å§†æ–¯åŸºè°±ç³»**ï¼šå½¢å¼è¯­è¨€çš„å±‚æ¬¡åˆ†ç±»
- **è‡ªåŠ¨æœºç†è®º**ï¼šè¯­è¨€è¯†åˆ«çš„è®¡ç®—æ¨¡å‹
- **è¯­æ³•ç†è®º**ï¼šè¯­è¨€ç”Ÿæˆçš„å½¢å¼åŒ–æ–¹æ³•

## 10. å‚è€ƒæ–‡çŒ®

1. Turing, A. M. (1936). On computable numbers, with an application to the Entscheidungsproblem. *Proceedings of the London Mathematical Society*, 2(42), 230-265.

2. Church, A. (1936). An unsolvable problem of elementary number theory. *American Journal of Mathematics*, 58(2), 345-363.

3. Kleene, S. C. (1936). General recursive functions of natural numbers. *Mathematische Annalen*, 112(1), 727-742.

4. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation* (3rd ed.). Pearson.

5. Barendregt, H. P. (1984). *The Lambda Calculus: Its Syntax and Semantics* (2nd ed.). North-Holland.

6. Rogers, H. (1987). *Theory of Recursive Functions and Effective Computability*. MIT Press.

7. Sipser, M. (2012). *Introduction to the Theory of Computation* (3rd ed.). Cengage Learning.

8. Papadimitriou, C. H. (1994). *Computational Complexity*. Addison-Wesley.

---

**å…³é”®è¯**: è®¡ç®—æ¨¡å‹ã€å›¾çµæœºã€Î»æ¼”ç®—ã€é€’å½’å‡½æ•°ã€å¯è®¡ç®—æ€§ã€ç­‰ä»·æ€§ã€å½¢å¼åŒ–æ–¹æ³•
