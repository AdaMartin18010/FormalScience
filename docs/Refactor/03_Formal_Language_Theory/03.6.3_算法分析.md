# 03.6.3 ç®—æ³•åˆ†æ

## ğŸ“‹ æ¦‚è¿°

ç®—æ³•åˆ†ææ˜¯å½¢å¼è¯­è¨€ç†è®ºä¸­çš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶ç®—æ³•çš„æ•ˆç‡ã€å¤æ‚æ€§å’Œæ€§èƒ½ç‰¹å¾ã€‚å®ƒæä¾›äº†è¯„ä¼°å’Œæ¯”è¾ƒä¸åŒç®—æ³•æ€§èƒ½çš„æ•°å­¦å·¥å…·å’Œæ–¹æ³•è®ºï¼Œæ˜¯è®¡ç®—æœºç§‘å­¦å’Œè½¯ä»¶å·¥ç¨‹çš„åŸºç¡€ç†è®ºã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹ç®—æ³•æ€§èƒ½è¯„ä¼°çš„æ•°å­¦æ¡†æ¶**
2. **æä¾›æ—¶é—´å’Œç©ºé—´å¤æ‚æ€§çš„åˆ†ææ–¹æ³•**
3. **å»ºç«‹ç®—æ³•ä¼˜åŒ–çš„ç†è®ºåŸºç¡€**
4. **ä¸ºç®—æ³•è®¾è®¡æä¾›å½¢å¼åŒ–æŒ‡å¯¼**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç®—æ³•å¤æ‚åº¦

ç®—æ³•å¤æ‚åº¦æ˜¯è¡¡é‡ç®—æ³•æ€§èƒ½çš„æ ¸å¿ƒæŒ‡æ ‡ï¼ŒåŒ…æ‹¬ï¼š

**å®šä¹‰ 1.1.1 (æ—¶é—´å¤æ‚åº¦)**
ç»™å®šç®—æ³• $A$ å’Œè¾“å…¥è§„æ¨¡ $n$ï¼Œæ—¶é—´å¤æ‚åº¦ $T_A(n)$ å®šä¹‰ä¸ºç®—æ³•åœ¨æœ€åæƒ…å†µä¸‹æ‰§è¡ŒåŸºæœ¬æ“ä½œçš„æœ€å¤§æ¬¡æ•°ã€‚

**å®šä¹‰ 1.1.2 (ç©ºé—´å¤æ‚åº¦)**
ç»™å®šç®—æ³• $A$ å’Œè¾“å…¥è§„æ¨¡ $n$ï¼Œç©ºé—´å¤æ‚åº¦ $S_A(n)$ å®šä¹‰ä¸ºç®—æ³•åœ¨æœ€åæƒ…å†µä¸‹ä½¿ç”¨çš„é¢å¤–å­˜å‚¨ç©ºé—´çš„æœ€å¤§é‡ã€‚

### 1.2 æ¸è¿›åˆ†æ

æ¸è¿›åˆ†ææ˜¯ç®—æ³•åˆ†æçš„æ ¸å¿ƒæ–¹æ³•ï¼š

**å®šä¹‰ 1.2.1 (å¤§Oè®°å·)**
å¯¹äºå‡½æ•° $f(n)$ å’Œ $g(n)$ï¼Œå¦‚æœå­˜åœ¨å¸¸æ•° $c > 0$ å’Œ $n_0 \in \mathbb{N}$ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰ $n \geq n_0$ï¼Œéƒ½æœ‰ $|f(n)| \leq c \cdot |g(n)|$ï¼Œåˆ™è®°ä½œ $f(n) = O(g(n))$ã€‚

**å®šä¹‰ 1.2.2 (å¤§Î©è®°å·)**
å¯¹äºå‡½æ•° $f(n)$ å’Œ $g(n)$ï¼Œå¦‚æœå­˜åœ¨å¸¸æ•° $c > 0$ å’Œ $n_0 \in \mathbb{N}$ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰ $n \geq n_0$ï¼Œéƒ½æœ‰ $|f(n)| \geq c \cdot |g(n)|$ï¼Œåˆ™è®°ä½œ $f(n) = \Omega(g(n))$ã€‚

**å®šä¹‰ 1.2.3 (å¤§Î˜è®°å·)**
å¦‚æœ $f(n) = O(g(n))$ ä¸” $f(n) = \Omega(g(n))$ï¼Œåˆ™è®°ä½œ $f(n) = \Theta(g(n))$ã€‚

### 1.3 å¤æ‚åº¦ç±»åˆ«

å¸¸è§çš„å¤æ‚åº¦ç±»åˆ«åŒ…æ‹¬ï¼š

- **å¸¸æ•°æ—¶é—´**: $O(1)$
- **å¯¹æ•°æ—¶é—´**: $O(\log n)$
- **çº¿æ€§æ—¶é—´**: $O(n)$
- **çº¿æ€§å¯¹æ•°æ—¶é—´**: $O(n \log n)$
- **å¹³æ–¹æ—¶é—´**: $O(n^2)$
- **æŒ‡æ•°æ—¶é—´**: $O(2^n)$
- **é˜¶ä¹˜æ—¶é—´**: $O(n!)$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ç®—æ³•æ¨¡å‹

**å®šä¹‰ 2.1.1 (ç®—æ³•)**
ç®—æ³•æ˜¯ä¸€ä¸ªæœ‰é™çš„è®¡ç®—è¿‡ç¨‹ï¼Œç”±ä»¥ä¸‹äº”å…ƒç»„å®šä¹‰ï¼š
$$A = (Q, \Sigma, \delta, q_0, F)$$

å…¶ä¸­ï¼š
- $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times \Sigma \rightarrow Q$ æ˜¯è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†

### 2.2 å¤æ‚åº¦å‡½æ•°

**å®šä¹‰ 2.2.1 (æ—¶é—´å¤æ‚åº¦å‡½æ•°)**
ç»™å®šç®—æ³• $A$ï¼Œå…¶æ—¶é—´å¤æ‚åº¦å‡½æ•° $T_A: \mathbb{N} \rightarrow \mathbb{N}$ å®šä¹‰ä¸ºï¼š
$$T_A(n) = \max\{t_A(x) : |x| = n\}$$

å…¶ä¸­ $t_A(x)$ æ˜¯ç®—æ³• $A$ å¤„ç†è¾“å…¥ $x$ æ‰€éœ€çš„æ­¥æ•°ã€‚

**å®šä¹‰ 2.2.2 (ç©ºé—´å¤æ‚åº¦å‡½æ•°)**
ç»™å®šç®—æ³• $A$ï¼Œå…¶ç©ºé—´å¤æ‚åº¦å‡½æ•° $S_A: \mathbb{N} \rightarrow \mathbb{N}$ å®šä¹‰ä¸ºï¼š
$$S_A(n) = \max\{s_A(x) : |x| = n\}$$

å…¶ä¸­ $s_A(x)$ æ˜¯ç®—æ³• $A$ å¤„ç†è¾“å…¥ $x$ æ‰€éœ€çš„å­˜å‚¨ç©ºé—´ã€‚

### 2.3 æ¸è¿›å…³ç³»

**å®šä¹‰ 2.3.1 (æ¸è¿›ä¸Šç•Œ)**
å¯¹äºå‡½æ•° $f, g: \mathbb{N} \rightarrow \mathbb{R}^+$ï¼Œ$f(n) = O(g(n))$ å½“ä¸”ä»…å½“ï¼š
$$\exists c > 0, n_0 \in \mathbb{N}: \forall n \geq n_0, f(n) \leq c \cdot g(n)$$

**å®šä¹‰ 2.3.2 (æ¸è¿›ä¸‹ç•Œ)**
å¯¹äºå‡½æ•° $f, g: \mathbb{N} \rightarrow \mathbb{R}^+$ï¼Œ$f(n) = \Omega(g(n))$ å½“ä¸”ä»…å½“ï¼š
$$\exists c > 0, n_0 \in \mathbb{N}: \forall n \geq n_0, f(n) \geq c \cdot g(n)$$

**å®šä¹‰ 2.3.3 (æ¸è¿›ç´§ç•Œ)**
å¯¹äºå‡½æ•° $f, g: \mathbb{N} \rightarrow \mathbb{R}^+$ï¼Œ$f(n) = \Theta(g(n))$ å½“ä¸”ä»…å½“ï¼š
$$f(n) = O(g(n)) \land f(n) = \Omega(g(n))$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬æ€§è´¨

**å®šç† 3.1.1 (æ¸è¿›å…³ç³»çš„ä¼ é€’æ€§)**
å¦‚æœ $f(n) = O(g(n))$ ä¸” $g(n) = O(h(n))$ï¼Œåˆ™ $f(n) = O(h(n))$ã€‚

**è¯æ˜**ï¼š
æ ¹æ®å®šä¹‰ï¼Œå­˜åœ¨å¸¸æ•° $c_1, c_2 > 0$ å’Œ $n_1, n_2 \in \mathbb{N}$ï¼Œä½¿å¾—ï¼š
- å¯¹äºæ‰€æœ‰ $n \geq n_1$ï¼Œ$f(n) \leq c_1 \cdot g(n)$
- å¯¹äºæ‰€æœ‰ $n \geq n_2$ï¼Œ$g(n) \leq c_2 \cdot h(n)$

å– $n_0 = \max(n_1, n_2)$ å’Œ $c = c_1 \cdot c_2$ï¼Œåˆ™å¯¹äºæ‰€æœ‰ $n \geq n_0$ï¼š
$$f(n) \leq c_1 \cdot g(n) \leq c_1 \cdot c_2 \cdot h(n) = c \cdot h(n)$$

å› æ­¤ $f(n) = O(h(n))$ã€‚â–¡

**å®šç† 3.1.2 (å¤šé¡¹å¼æ—¶é—´å°é—­æ€§)**
å¦‚æœ $f(n) = O(n^k)$ ä¸” $g(n) = O(n^m)$ï¼Œåˆ™ $f(n) \cdot g(n) = O(n^{k+m})$ã€‚

**è¯æ˜**ï¼š
æ ¹æ®å®šä¹‰ï¼Œå­˜åœ¨å¸¸æ•° $c_1, c_2 > 0$ å’Œ $n_1, n_2 \in \mathbb{N}$ï¼Œä½¿å¾—ï¼š
- å¯¹äºæ‰€æœ‰ $n \geq n_1$ï¼Œ$f(n) \leq c_1 \cdot n^k$
- å¯¹äºæ‰€æœ‰ $n \geq n_2$ï¼Œ$g(n) \leq c_2 \cdot n^m$

å– $n_0 = \max(n_1, n_2)$ å’Œ $c = c_1 \cdot c_2$ï¼Œåˆ™å¯¹äºæ‰€æœ‰ $n \geq n_0$ï¼š
$$f(n) \cdot g(n) \leq c_1 \cdot n^k \cdot c_2 \cdot n^m = c \cdot n^{k+m}$$

å› æ­¤ $f(n) \cdot g(n) = O(n^{k+m})$ã€‚â–¡

### 3.2 é€’å½’å…³ç³»

**å®šç† 3.2.1 (ä¸»å®šç†)**
å¯¹äºé€’å½’å…³ç³» $T(n) = aT(n/b) + f(n)$ï¼Œå…¶ä¸­ $a \geq 1, b > 1$ï¼Œåˆ™ï¼š

1. å¦‚æœ $f(n) = O(n^{\log_b a - \epsilon})$ å¯¹äºæŸä¸ª $\epsilon > 0$ï¼Œåˆ™ $T(n) = \Theta(n^{\log_b a})$
2. å¦‚æœ $f(n) = \Theta(n^{\log_b a})$ï¼Œåˆ™ $T(n) = \Theta(n^{\log_b a} \log n)$
3. å¦‚æœ $f(n) = \Omega(n^{\log_b a + \epsilon})$ å¯¹äºæŸä¸ª $\epsilon > 0$ï¼Œä¸” $af(n/b) \leq cf(n)$ å¯¹äºæŸä¸ª $c < 1$ å’Œå……åˆ†å¤§çš„ $n$ï¼Œåˆ™ $T(n) = \Theta(f(n))$

**è¯æ˜**ï¼š
é€šè¿‡é€’å½’æ ‘æ–¹æ³•å’Œæ•°å­¦å½’çº³æ³•å¯ä»¥è¯æ˜ã€‚è¯¦ç»†è¯æ˜è§ç›¸å…³ç†è®ºéƒ¨åˆ†ã€‚â–¡

### 3.3 æ’åºç®—æ³•åˆ†æ

**å®šç† 3.3.1 (æ¯”è¾ƒæ’åºä¸‹ç•Œ)**
ä»»ä½•åŸºäºæ¯”è¾ƒçš„æ’åºç®—æ³•åœ¨æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¸º $\Omega(n \log n)$ã€‚

**è¯æ˜**ï¼š
åŸºäºæ¯”è¾ƒçš„æ’åºç®—æ³•å¯ä»¥å»ºæ¨¡ä¸ºå†³ç­–æ ‘ã€‚å¯¹äº $n$ ä¸ªå…ƒç´ çš„æ’åºï¼Œæœ‰ $n!$ ç§å¯èƒ½çš„æ’åˆ—ã€‚å†³ç­–æ ‘çš„é«˜åº¦è‡³å°‘ä¸º $\log_2(n!)$ã€‚

æ ¹æ®æ–¯ç‰¹æ—å…¬å¼ï¼š
$$\log_2(n!) = \log_2(\sqrt{2\pi n}(\frac{n}{e})^n) + O(\frac{1}{n})$$

å› æ­¤ï¼š
$$\log_2(n!) = n \log_2 n - n \log_2 e + \frac{1}{2} \log_2(2\pi n) + O(\frac{1}{n}) = \Omega(n \log n)$$

å› æ­¤ä»»ä½•æ¯”è¾ƒæ’åºç®—æ³•çš„æœ€åæƒ…å†µæ—¶é—´å¤æ‚åº¦ä¸º $\Omega(n \log n)$ã€‚â–¡

## 4. ä»£ç å®ç°

### 4.1 å¤æ‚åº¦åˆ†æå·¥å…·

```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};

/// ç®—æ³•å¤æ‚åº¦åˆ†æå™¨
pub struct ComplexityAnalyzer {
    measurements: HashMap<usize, Duration>,
}

impl ComplexityAnalyzer {
    pub fn new() -> Self {
        Self {
            measurements: HashMap::new(),
        }
    }

    /// æµ‹é‡ç®—æ³•æ‰§è¡Œæ—¶é—´
    pub fn measure<F>(&mut self, input_size: usize, algorithm: F) -> Duration
    where
        F: FnOnce() -> (),
    {
        let start = Instant::now();
        algorithm();
        let duration = start.elapsed();
        self.measurements.insert(input_size, duration);
        duration
    }

    /// åˆ†ææ—¶é—´å¤æ‚åº¦
    pub fn analyze_time_complexity(&self) -> ComplexityClass {
        if self.measurements.len() < 2 {
            return ComplexityClass::Unknown;
        }

        let mut sizes: Vec<usize> = self.measurements.keys().cloned().collect();
        sizes.sort();

        // è®¡ç®—ç›¸é‚»è§„æ¨¡é—´çš„å¢é•¿ç‡
        let mut growth_rates = Vec::new();
        for i in 1..sizes.len() {
            let prev_size = sizes[i - 1];
            let curr_size = sizes[i];
            let prev_time = self.measurements[&prev_size];
            let curr_time = self.measurements[&curr_size];

            let growth_rate = curr_time.as_nanos() as f64 / prev_time.as_nanos() as f64;
            let size_ratio = curr_size as f64 / prev_size as f64;
            let complexity_ratio = growth_rate / size_ratio.ln();

            growth_rates.push(complexity_ratio);
        }

        // æ ¹æ®å¢é•¿ç‡åˆ¤æ–­å¤æ‚åº¦ç±»åˆ«
        let avg_growth = growth_rates.iter().sum::<f64>() / growth_rates.len() as f64;

        if avg_growth < 1.5 {
            ComplexityClass::Constant
        } else if avg_growth < 2.5 {
            ComplexityClass::Logarithmic
        } else if avg_growth < 3.5 {
            ComplexityClass::Linear
        } else if avg_growth < 4.5 {
            ComplexityClass::Linearithmic
        } else if avg_growth < 5.5 {
            ComplexityClass::Quadratic
        } else {
            ComplexityClass::Exponential
        }
    }
}

/// å¤æ‚åº¦ç±»åˆ«
#[derive(Debug, Clone, PartialEq)]
pub enum ComplexityClass {
    Constant,
    Logarithmic,
    Linear,
    Linearithmic,
    Quadratic,
    Exponential,
    Unknown,
}

impl std::fmt::Display for ComplexityClass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ComplexityClass::Constant => write!(f, "O(1)"),
            ComplexityClass::Logarithmic => write!(f, "O(log n)"),
            ComplexityClass::Linear => write!(f, "O(n)"),
            ComplexityClass::Linearithmic => write!(f, "O(n log n)"),
            ComplexityClass::Quadratic => write!(f, "O(nÂ²)"),
            ComplexityClass::Exponential => write!(f, "O(2â¿)"),
            ComplexityClass::Unknown => write!(f, "Unknown"),
        }
    }
}
```

### 4.2 æ’åºç®—æ³•å®ç°

```rust
/// æ’åºç®—æ³•é›†åˆ
pub struct SortingAlgorithms;

impl SortingAlgorithms {
    /// å†’æ³¡æ’åº - O(nÂ²)
    pub fn bubble_sort<T: Ord>(arr: &mut [T]) {
        let n = arr.len();
        for i in 0..n {
            for j in 0..n - i - 1 {
                if arr[j] > arr[j + 1] {
                    arr.swap(j, j + 1);
                }
            }
        }
    }

    /// å¿«é€Ÿæ’åº - O(n log n) å¹³å‡æƒ…å†µ
    pub fn quick_sort<T: Ord>(arr: &mut [T]) {
        if arr.len() <= 1 {
            return;
        }

        let pivot_index = Self::partition(arr);
        Self::quick_sort(&mut arr[..pivot_index]);
        Self::quick_sort(&mut arr[pivot_index + 1..]);
    }

    /// åˆ†åŒºå‡½æ•°
    fn partition<T: Ord>(arr: &mut [T]) -> usize {
        let len = arr.len();
        let pivot_index = len - 1;
        let mut i = 0;

        for j in 0..len - 1 {
            if arr[j] <= arr[pivot_index] {
                arr.swap(i, j);
                i += 1;
            }
        }

        arr.swap(i, pivot_index);
        i
    }

    /// å½’å¹¶æ’åº - O(n log n)
    pub fn merge_sort<T: Ord + Clone>(arr: &mut [T]) {
        if arr.len() <= 1 {
            return;
        }

        let mid = arr.len() / 2;
        let mut left = arr[..mid].to_vec();
        let mut right = arr[mid..].to_vec();

        Self::merge_sort(&mut left);
        Self::merge_sort(&mut right);

        Self::merge(arr, &left, &right);
    }

    /// å½’å¹¶å‡½æ•°
    fn merge<T: Ord + Clone>(arr: &mut [T], left: &[T], right: &[T]) {
        let mut i = 0;
        let mut j = 0;
        let mut k = 0;

        while i < left.len() && j < right.len() {
            if left[i] <= right[j] {
                arr[k] = left[i].clone();
                i += 1;
            } else {
                arr[k] = right[j].clone();
                j += 1;
            }
            k += 1;
        }

        while i < left.len() {
            arr[k] = left[i].clone();
            i += 1;
            k += 1;
        }

        while j < right.len() {
            arr[k] = right[j].clone();
            j += 1;
            k += 1;
        }
    }

    /// å †æ’åº - O(n log n)
    pub fn heap_sort<T: Ord>(arr: &mut [T]) {
        let n = arr.len();

        // æ„å»ºæœ€å¤§å †
        for i in (0..n / 2).rev() {
            Self::heapify(arr, n, i);
        }

        // é€ä¸ªæå–æœ€å¤§å…ƒç´ 
        for i in (1..n).rev() {
            arr.swap(0, i);
            Self::heapify(arr, i, 0);
        }
    }

    /// å †åŒ–å‡½æ•°
    fn heapify<T: Ord>(arr: &mut [T], n: usize, i: usize) {
        let mut largest = i;
        let left = 2 * i + 1;
        let right = 2 * i + 2;

        if left < n && arr[left] > arr[largest] {
            largest = left;
        }

        if right < n && arr[right] > arr[largest] {
            largest = right;
        }

        if largest != i {
            arr.swap(i, largest);
            Self::heapify(arr, n, largest);
        }
    }
}
```

### 4.3 æœç´¢ç®—æ³•å®ç°

```rust
/// æœç´¢ç®—æ³•é›†åˆ
pub struct SearchAlgorithms;

impl SearchAlgorithms {
    /// çº¿æ€§æœç´¢ - O(n)
    pub fn linear_search<T: PartialEq>(arr: &[T], target: &T) -> Option<usize> {
        for (i, item) in arr.iter().enumerate() {
            if item == target {
                return Some(i);
            }
        }
        None
    }

    /// äºŒåˆ†æœç´¢ - O(log n)
    pub fn binary_search<T: Ord>(arr: &[T], target: &T) -> Option<usize> {
        let mut left = 0;
        let mut right = arr.len();

        while left < right {
            let mid = left + (right - left) / 2;
            match arr[mid].cmp(target) {
                std::cmp::Ordering::Equal => return Some(mid),
                std::cmp::Ordering::Less => left = mid + 1,
                std::cmp::Ordering::Greater => right = mid,
            }
        }
        None
    }

    /// æ·±åº¦ä¼˜å…ˆæœç´¢
    pub fn dfs<F>(graph: &Vec<Vec<usize>>, start: usize, mut visit: F)
    where
        F: FnMut(usize),
    {
        let mut visited = vec![false; graph.len()];
        let mut stack = vec![start];

        while let Some(node) = stack.pop() {
            if !visited[node] {
                visited[node] = true;
                visit(node);

                for &neighbor in &graph[node] {
                    if !visited[neighbor] {
                        stack.push(neighbor);
                    }
                }
            }
        }
    }

    /// å¹¿åº¦ä¼˜å…ˆæœç´¢
    pub fn bfs<F>(graph: &Vec<Vec<usize>>, start: usize, mut visit: F)
    where
        F: FnMut(usize),
    {
        let mut visited = vec![false; graph.len()];
        let mut queue = std::collections::VecDeque::new();
        queue.push_back(start);
        visited[start] = true;

        while let Some(node) = queue.pop_front() {
            visit(node);

            for &neighbor in &graph[node] {
                if !visited[neighbor] {
                    visited[neighbor] = true;
                    queue.push_back(neighbor);
                }
            }
        }
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç®—æ³•æ€§èƒ½æ¯”è¾ƒ

```rust
use crate::complexity_analysis::{ComplexityAnalyzer, ComplexityClass};
use crate::sorting_algorithms::SortingAlgorithms;

fn main() {
    let mut analyzer = ComplexityAnalyzer::new();

    // æµ‹è¯•ä¸åŒè§„æ¨¡çš„æ’åºç®—æ³•
    let sizes = vec![100, 1000, 10000];
    
    for &size in &sizes {
        let mut arr: Vec<i32> = (0..size).rev().collect();
        
        analyzer.measure(size, || {
            SortingAlgorithms::bubble_sort(&mut arr);
        });
    }

    let complexity = analyzer.analyze_time_complexity();
    println!("Bubble Sort Complexity: {}", complexity);
}
```

### 5.2 é€’å½’ç®—æ³•åˆ†æ

```rust
/// æ–æ³¢é‚£å¥‘æ•°åˆ—è®¡ç®—
pub struct Fibonacci;

impl Fibonacci {
    /// é€’å½’å®ç° - O(2â¿)
    pub fn recursive(n: u64) -> u64 {
        match n {
            0 | 1 => n,
            _ => Self::recursive(n - 1) + Self::recursive(n - 2),
        }
    }

    /// åŠ¨æ€è§„åˆ’å®ç° - O(n)
    pub fn dynamic_programming(n: u64) -> u64 {
        if n <= 1 {
            return n;
        }

        let mut dp = vec![0; (n + 1) as usize];
        dp[1] = 1;

        for i in 2..=n as usize {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        dp[n as usize]
    }

    /// çŸ©é˜µå¿«é€Ÿå¹‚å®ç° - O(log n)
    pub fn matrix_power(n: u64) -> u64 {
        if n <= 1 {
            return n;
        }

        let mut matrix = [[1, 1], [1, 0]];
        let mut result = [[1, 0], [0, 1]];

        let mut power = n;
        while power > 0 {
            if power % 2 == 1 {
                result = Self::matrix_multiply(result, matrix);
            }
            matrix = Self::matrix_multiply(matrix, matrix);
            power /= 2;
        }

        result[0][1]
    }

    fn matrix_multiply(a: [[u64; 2]; 2], b: [[u64; 2]; 2]) -> [[u64; 2]; 2] {
        [
            [
                a[0][0] * b[0][0] + a[0][1] * b[1][0],
                a[0][0] * b[0][1] + a[0][1] * b[1][1],
            ],
            [
                a[1][0] * b[0][0] + a[1][1] * b[1][0],
                a[1][0] * b[0][1] + a[1][1] * b[1][1],
            ],
        ]
    }
}
```

### 5.3 å›¾ç®—æ³•åˆ†æ

```rust
use std::collections::{BinaryHeap, HashMap};
use std::cmp::Ordering;

/// å›¾ç»“æ„
#[derive(Debug)]
pub struct Graph {
    vertices: usize,
    edges: Vec<Vec<(usize, u32)>>, // (ç›®æ ‡é¡¶ç‚¹, æƒé‡)
}

impl Graph {
    pub fn new(vertices: usize) -> Self {
        Self {
            vertices,
            edges: vec![Vec::new(); vertices],
        }
    }

    pub fn add_edge(&mut self, from: usize, to: usize, weight: u32) {
        self.edges[from].push((to, weight));
    }

    /// Dijkstraæœ€çŸ­è·¯å¾„ç®—æ³• - O((V + E) log V)
    pub fn dijkstra(&self, start: usize) -> Vec<u32> {
        let mut distances = vec![u32::MAX; self.vertices];
        distances[start] = 0;

        let mut heap = BinaryHeap::new();
        heap.push(State {
            cost: 0,
            vertex: start,
        });

        while let Some(State { cost, vertex }) = heap.pop() {
            if cost > distances[vertex] {
                continue;
            }

            for &(next_vertex, weight) in &self.edges[vertex] {
                let next_cost = cost + weight;
                if next_cost < distances[next_vertex] {
                    distances[next_vertex] = next_cost;
                    heap.push(State {
                        cost: next_cost,
                        vertex: next_vertex,
                    });
                }
            }
        }

        distances
    }

    /// Floyd-Warshallå…¨æºæœ€çŸ­è·¯å¾„ç®—æ³• - O(VÂ³)
    pub fn floyd_warshall(&self) -> Vec<Vec<u32>> {
        let mut distances = vec![vec![u32::MAX; self.vertices]; self.vertices];

        // åˆå§‹åŒ–å¯¹è§’çº¿
        for i in 0..self.vertices {
            distances[i][i] = 0;
        }

        // åˆå§‹åŒ–ç›´æ¥è¾¹
        for (i, edges) in self.edges.iter().enumerate() {
            for &(j, weight) in edges {
                distances[i][j] = weight;
            }
        }

        // Floyd-Warshallæ ¸å¿ƒç®—æ³•
        for k in 0..self.vertices {
            for i in 0..self.vertices {
                for j in 0..self.vertices {
                    if distances[i][k] != u32::MAX && distances[k][j] != u32::MAX {
                        let new_distance = distances[i][k] + distances[k][j];
                        if new_distance < distances[i][j] {
                            distances[i][j] = new_distance;
                        }
                    }
                }
            }
        }

        distances
    }
}

#[derive(Copy, Clone, Eq, PartialEq)]
struct State {
    cost: u32,
    vertex: usize,
}

impl Ord for State {
    fn cmp(&self, other: &Self) -> Ordering {
        other.cost.cmp(&self.cost)
    }
}

impl PartialOrd for State {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å¯è®¡ç®—æ€§ç†è®ºçš„å…³ç³»

ç®—æ³•åˆ†æç†è®ºç›´æ¥ä¾èµ–äº[å¯è®¡ç®—æ€§ç†è®º](03.6.1_å¯è®¡ç®—æ€§ç†è®º.md)çš„åŸºç¡€æ¦‚å¿µã€‚å¯è®¡ç®—æ€§ç†è®ºç¡®å®šäº†å“ªäº›é—®é¢˜æ˜¯å¯è®¡ç®—çš„ï¼Œè€Œç®—æ³•åˆ†æåˆ™è¿›ä¸€æ­¥ç ”ç©¶è¿™äº›å¯è®¡ç®—é—®é¢˜çš„æ•ˆç‡ç‰¹å¾ã€‚

**å…³ç³» 6.1.1**
å¦‚æœé—®é¢˜ $P$ åœ¨å¯è®¡ç®—æ€§ç†è®ºä¸­è¢«è¯æ˜æ˜¯ä¸å¯è®¡ç®—çš„ï¼Œåˆ™ç®—æ³•åˆ†æä¸­ä¸å­˜åœ¨è§£å†³ $P$ çš„æœ‰æ•ˆç®—æ³•ã€‚

### 6.2 ä¸å¤æ‚æ€§ç†è®ºçš„å…³ç³»

ç®—æ³•åˆ†ææ˜¯[å¤æ‚æ€§ç†è®º](03.6.2_å¤æ‚æ€§ç†è®º.md)çš„åŸºç¡€ã€‚å¤æ‚æ€§ç†è®ºåœ¨ç®—æ³•åˆ†æçš„åŸºç¡€ä¸Šï¼Œè¿›ä¸€æ­¥ç ”ç©¶é—®é¢˜çš„å›ºæœ‰å¤æ‚æ€§ï¼Œå»ºç«‹äº†Pã€NPã€NPå®Œå…¨ç­‰é‡è¦æ¦‚å¿µã€‚

**å…³ç³» 6.2.1**
ç®—æ³•åˆ†ææä¾›äº†åˆ†æå…·ä½“ç®—æ³•æ€§èƒ½çš„å·¥å…·ï¼Œè€Œå¤æ‚æ€§ç†è®ºåˆ™ç ”ç©¶é—®é¢˜ç±»åˆ«çš„å›ºæœ‰å¤æ‚æ€§ä¸‹ç•Œã€‚

### 6.3 ä¸å½¢å¼è¯­è¨€ç†è®ºçš„å…³ç³»

ç®—æ³•åˆ†æåœ¨[å½¢å¼è¯­è¨€ç†è®º](03.3.1_ä¹”å§†æ–¯åŸºè°±ç³».md)ä¸­å…·æœ‰é‡è¦åº”ç”¨ï¼Œç‰¹åˆ«æ˜¯åœ¨ï¼š

1. **è¯­æ³•åˆ†æç®—æ³•**: åˆ†æä¸åŒè§£æç®—æ³•çš„å¤æ‚åº¦
2. **è¯­è¨€è¯†åˆ«**: ç ”ç©¶è‡ªåŠ¨æœºè¯†åˆ«è¯­è¨€çš„æ•ˆç‡
3. **ç¼–è¯‘å™¨ä¼˜åŒ–**: ä¼˜åŒ–ç¼–è¯‘è¿‡ç¨‹ä¸­çš„å„ç§ç®—æ³•

### 6.4 ä¸æ•°å­¦åŸºç¡€çš„å…³ç³»

ç®—æ³•åˆ†æå¤§é‡ä½¿ç”¨[æ•°å­¦åŸºç¡€ç†è®º](02_Mathematical_Foundation/)ä¸­çš„æ¦‚å¿µï¼š

- **å‡½æ•°è®º**: ç”¨äºå®šä¹‰å¤æ‚åº¦å‡½æ•°
- **å…³ç³»è®º**: ç”¨äºåˆ†æç®—æ³•é—´çš„æ€§èƒ½å…³ç³»
- **ç»„åˆæ•°å­¦**: ç”¨äºåˆ†æç®—æ³•çš„æœ€åæƒ…å†µ

## 7. å‚è€ƒæ–‡çŒ®

1. Cormen, T. H., Leiserson, C. E., Rivest, R. L., & Stein, C. (2009). *Introduction to Algorithms* (3rd ed.). MIT Press.

2. Knuth, D. E. (1997). *The Art of Computer Programming, Volume 1: Fundamental Algorithms* (3rd ed.). Addison-Wesley.

3. Sedgewick, R., & Wayne, K. (2011). *Algorithms* (4th ed.). Addison-Wesley.

4. Aho, A. V., Hopcroft, J. E., & Ullman, J. D. (1974). *The Design and Analysis of Computer Algorithms*. Addison-Wesley.

5. Papadimitriou, C. H. (1994). *Computational Complexity*. Addison-Wesley.

---

**ç›¸å…³æ–‡æ¡£**:
- [03.6.1 å¯è®¡ç®—æ€§ç†è®º](03.6.1_å¯è®¡ç®—æ€§ç†è®º.md)
- [03.6.2 å¤æ‚æ€§ç†è®º](03.6.2_å¤æ‚æ€§ç†è®º.md)
- [03.6.4 è®¡ç®—æ¨¡å‹](03.6.4_è®¡ç®—æ¨¡å‹.md)
- [02.4.1 å‡½æ•°æ¦‚å¿µ](02_Mathematical_Foundation/02.4.1_å‡½æ•°æ¦‚å¿µ.md)
- [02.5.1 å…³ç³»æ¦‚å¿µ](02_Mathematical_Foundation/02.5.1_å…³ç³»æ¦‚å¿µ.md) 