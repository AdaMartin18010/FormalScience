# 03.1.1 æœ‰é™è‡ªåŠ¨æœº

## ğŸ“‹ æ¦‚è¿°

æœ‰é™è‡ªåŠ¨æœºæ˜¯å½¢å¼è¯­è¨€ç†è®ºä¸­ç ”ç©¶è®¡ç®—æ¨¡å‹çš„åŸºç¡€ç†è®ºã€‚å®ƒæè¿°äº†ä¸€ç§å…·æœ‰æœ‰é™çŠ¶æ€ã€æœ‰é™è¾“å…¥å­—æ¯è¡¨çš„æŠ½è±¡æœºå™¨ï¼Œèƒ½å¤Ÿæ ¹æ®å½“å‰çŠ¶æ€å’Œè¾“å…¥ç¬¦å·è¿›è¡ŒçŠ¶æ€è½¬ç§»ï¼Œä¸ºç†è§£è®¡ç®—èƒ½åŠ›å’Œè¯­è¨€è¯†åˆ«æä¾›ç†è®ºåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹æœ‰é™è‡ªåŠ¨æœºçš„å½¢å¼åŒ–æ¨¡å‹**
2. **åˆ†æè‡ªåŠ¨æœºçš„è®¡ç®—èƒ½åŠ›**
3. **ç ”ç©¶æ­£åˆ™è¯­è¨€çš„æ€§è´¨**
4. **æ„å»ºè‡ªåŠ¨æœºç­‰ä»·æ€§ç†è®º**
5. **æ¢è®¨è‡ªåŠ¨æœºçš„æœ€å°åŒ–ç®—æ³•**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è‡ªåŠ¨æœºæ¦‚å¿µ

**å®šä¹‰ 1.1.1** (æœ‰é™è‡ªåŠ¨æœº)
æœ‰é™è‡ªåŠ¨æœºæ˜¯ä¸€ç§æŠ½è±¡çš„è®¡ç®—æ¨¡å‹ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š
- **æœ‰é™çŠ¶æ€é›†**: æœºå™¨å¯ä»¥å¤„äºæœ‰é™ä¸ªä¸åŒçš„çŠ¶æ€
- **æœ‰é™è¾“å…¥å­—æ¯è¡¨**: æœºå™¨å¯ä»¥æ¥å—æœ‰é™ç§ä¸åŒçš„è¾“å…¥ç¬¦å·
- **çŠ¶æ€è½¬ç§»å‡½æ•°**: æ ¹æ®å½“å‰çŠ¶æ€å’Œè¾“å…¥ç¬¦å·ç¡®å®šä¸‹ä¸€ä¸ªçŠ¶æ€
- **åˆå§‹çŠ¶æ€**: æœºå™¨å¼€å§‹è¿è¡Œæ—¶çš„çŠ¶æ€
- **æ¥å—çŠ¶æ€é›†**: æœºå™¨å¯ä»¥æ¥å—çš„æœ€ç»ˆçŠ¶æ€

### 1.2 è‡ªåŠ¨æœºç±»å‹

**å®šä¹‰ 1.1.2** (è‡ªåŠ¨æœºç±»å‹åˆ†ç±»)
æœ‰é™è‡ªåŠ¨æœºå¯ä»¥åˆ†ä¸ºä»¥ä¸‹ç±»å‹ï¼š

1. **ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (DFA)**: æ¯ä¸ªçŠ¶æ€-è¾“å…¥å¯¹éƒ½æœ‰å”¯ä¸€çš„ä¸‹ä¸€ä¸ªçŠ¶æ€
2. **éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (NFA)**: ä¸€ä¸ªçŠ¶æ€-è¾“å…¥å¯¹å¯èƒ½æœ‰å¤šä¸ªä¸‹ä¸€ä¸ªçŠ¶æ€
3. **Îµ-éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº (Îµ-NFA)**: å…è®¸ä¸æ¶ˆè€—è¾“å…¥ç¬¦å·çš„çŠ¶æ€è½¬ç§»

### 1.3 è¯­è¨€è¯†åˆ«

**å®šä¹‰ 1.1.3** (è¯­è¨€è¯†åˆ«)
è‡ªåŠ¨æœºè¯†åˆ«è¯­è¨€çš„è¿‡ç¨‹ï¼š
- **è¾“å…¥å­—ç¬¦ä¸²**: ç”±è¾“å…¥å­—æ¯è¡¨ä¸­çš„ç¬¦å·ç»„æˆçš„åºåˆ—
- **è®¡ç®—è·¯å¾„**: è‡ªåŠ¨æœºå¤„ç†è¾“å…¥å­—ç¬¦ä¸²çš„çŠ¶æ€è½¬ç§»åºåˆ—
- **æ¥å—æ¡ä»¶**: å¦‚æœè®¡ç®—è·¯å¾„ä»¥æ¥å—çŠ¶æ€ç»“æŸï¼Œåˆ™æ¥å—è¯¥å­—ç¬¦ä¸²
- **è¯†åˆ«è¯­è¨€**: è‡ªåŠ¨æœºæ¥å—çš„æ‰€æœ‰å­—ç¬¦ä¸²çš„é›†åˆ

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº

**å®šä¹‰ 1.2.1** (DFA)
ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š
- $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†
- $\Sigma$ æ˜¯æœ‰é™è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times \Sigma \rightarrow Q$ æ˜¯çŠ¶æ€è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†

**å®šä¹‰ 1.2.2** (DFAçš„æ‰©å±•è½¬ç§»å‡½æ•°)
DFAçš„æ‰©å±•è½¬ç§»å‡½æ•° $\hat{\delta}: Q \times \Sigma^* \rightarrow Q$ é€’å½’å®šä¹‰å¦‚ä¸‹ï¼š

1. $\hat{\delta}(q, \varepsilon) = q$ (ç©ºå­—ç¬¦ä¸²ä¸æ”¹å˜çŠ¶æ€)
2. $\hat{\delta}(q, wa) = \delta(\hat{\delta}(q, w), a)$ (é€’å½’å®šä¹‰)

å…¶ä¸­ $w \in \Sigma^*$ï¼Œ$a \in \Sigma$ï¼Œ$\varepsilon$ æ˜¯ç©ºå­—ç¬¦ä¸²ã€‚

**å®šä¹‰ 1.2.3** (DFAæ¥å—çš„è¯­è¨€)
DFA $M$ æ¥å—çš„è¯­è¨€å®šä¹‰ä¸ºï¼š
$$L(M) = \{w \in \Sigma^* : \hat{\delta}(q_0, w) \in F\}$$

### 2.2 éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº

**å®šä¹‰ 1.2.4** (NFA)
éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š
- $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†
- $\Sigma$ æ˜¯æœ‰é™è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times \Sigma \rightarrow 2^Q$ æ˜¯çŠ¶æ€è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†

**å®šä¹‰ 1.2.5** (NFAçš„æ‰©å±•è½¬ç§»å‡½æ•°)
NFAçš„æ‰©å±•è½¬ç§»å‡½æ•° $\hat{\delta}: Q \times \Sigma^* \rightarrow 2^Q$ é€’å½’å®šä¹‰å¦‚ä¸‹ï¼š

1. $\hat{\delta}(q, \varepsilon) = \{q\}$
2. $\hat{\delta}(q, wa) = \bigcup_{p \in \hat{\delta}(q, w)} \delta(p, a)$

**å®šä¹‰ 1.2.6** (NFAæ¥å—çš„è¯­è¨€)
NFA $M$ æ¥å—çš„è¯­è¨€å®šä¹‰ä¸ºï¼š
$$L(M) = \{w \in \Sigma^* : \hat{\delta}(q_0, w) \cap F \neq \emptyset\}$$

### 2.3 Îµ-éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº

**å®šä¹‰ 1.2.7** (Îµ-NFA)
Îµ-éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š
- $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†
- $\Sigma$ æ˜¯æœ‰é™è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times (\Sigma \cup \{\varepsilon\}) \rightarrow 2^Q$ æ˜¯çŠ¶æ€è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†

**å®šä¹‰ 1.2.8** (Îµé—­åŒ…)
çŠ¶æ€ $q$ çš„Îµé—­åŒ… $E(q)$ å®šä¹‰ä¸ºï¼š
$$E(q) = \{p \in Q : \text{å­˜åœ¨ä»} q \text{åˆ°} p \text{çš„Îµè·¯å¾„}\}$$

**å®šä¹‰ 1.2.9** (Îµ-NFAçš„æ‰©å±•è½¬ç§»å‡½æ•°)
Îµ-NFAçš„æ‰©å±•è½¬ç§»å‡½æ•° $\hat{\delta}: Q \times \Sigma^* \rightarrow 2^Q$ é€’å½’å®šä¹‰å¦‚ä¸‹ï¼š

1. $\hat{\delta}(q, \varepsilon) = E(q)$
2. $\hat{\delta}(q, wa) = E\left(\bigcup_{p \in \hat{\delta}(q, w)} \delta(p, a)\right)$

## 3. å®šç†ä¸è¯æ˜

### 3.1 è‡ªåŠ¨æœºç­‰ä»·æ€§

**å®šç† 1.3.1** (DFAä¸NFAç­‰ä»·æ€§)
å¯¹äºæ¯ä¸ªNFAï¼Œéƒ½å­˜åœ¨ä¸€ä¸ªç­‰ä»·çš„DFAï¼Œå³å®ƒä»¬è¯†åˆ«ç›¸åŒçš„è¯­è¨€ã€‚

**è¯æ˜**:
è®¾ $M = (Q, \Sigma, \delta, q_0, F)$ æ˜¯ä¸€ä¸ªNFAã€‚

æ„é€ ç­‰ä»·çš„DFA $M' = (Q', \Sigma, \delta', q_0', F')$ï¼š

1. $Q' = 2^Q$ (å¹‚é›†æ„é€ )
2. $q_0' = \{q_0\}$
3. $F' = \{S \subseteq Q : S \cap F \neq \emptyset\}$
4. $\delta'(S, a) = \bigcup_{q \in S} \delta(q, a)$

å¯¹äºä»»æ„å­—ç¬¦ä¸² $w$ï¼Œæœ‰ï¼š
$$\hat{\delta'}(\{q_0\}, w) = \hat{\delta}(q_0, w)$$

å› æ­¤ $L(M') = L(M)$ã€‚

**å®šç† 1.3.2** (Îµ-NFAä¸NFAç­‰ä»·æ€§)
å¯¹äºæ¯ä¸ªÎµ-NFAï¼Œéƒ½å­˜åœ¨ä¸€ä¸ªç­‰ä»·çš„NFAã€‚

**è¯æ˜**:
è®¾ $M = (Q, \Sigma, \delta, q_0, F)$ æ˜¯ä¸€ä¸ªÎµ-NFAã€‚

æ„é€ ç­‰ä»·çš„NFA $M' = (Q, \Sigma, \delta', q_0', F')$ï¼š

1. $q_0' = q_0$
2. $F' = \{q \in Q : E(q) \cap F \neq \emptyset\}$
3. $\delta'(q, a) = \bigcup_{p \in E(q)} \delta(p, a)$

å¯¹äºä»»æ„å­—ç¬¦ä¸² $w$ï¼Œæœ‰ï¼š
$$\hat{\delta'}(q_0, w) = \hat{\delta}(q_0, w)$$

å› æ­¤ $L(M') = L(M)$ã€‚

### 3.2 æ­£åˆ™è¯­è¨€æ€§è´¨

**å®šç† 1.3.3** (æ­£åˆ™è¯­è¨€çš„å°é—­æ€§)
æ­£åˆ™è¯­è¨€åœ¨ä»¥ä¸‹è¿ç®—ä¸‹å°é—­ï¼š
1. å¹¶é›†
2. äº¤é›†
3. è¡¥é›†
4. è¿æ¥
5. å…‹æ—é—­åŒ…

**è¯æ˜**:
1. **å¹¶é›†**: æ„é€ ä¸¤ä¸ªè‡ªåŠ¨æœºçš„å¹¶é›†è‡ªåŠ¨æœº
2. **äº¤é›†**: æ„é€ ä¸¤ä¸ªè‡ªåŠ¨æœºçš„ä¹˜ç§¯è‡ªåŠ¨æœº
3. **è¡¥é›†**: å°†DFAçš„æ¥å—çŠ¶æ€å’Œéæ¥å—çŠ¶æ€äº’æ¢
4. **è¿æ¥**: æ„é€ ä¸¤ä¸ªè‡ªåŠ¨æœºçš„è¿æ¥è‡ªåŠ¨æœº
5. **å…‹æ—é—­åŒ…**: æ·»åŠ Îµè½¬ç§»å’Œè‡ªç¯

**å®šç† 1.3.4** (æ³µå¼•ç†)
è®¾ $L$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œåˆ™å­˜åœ¨å¸¸æ•° $n$ï¼Œä½¿å¾—å¯¹äºä»»æ„ $w \in L$ ä¸” $|w| \geq n$ï¼Œå­˜åœ¨åˆ†è§£ $w = xyz$ï¼Œæ»¡è¶³ï¼š
1. $|xy| \leq n$
2. $|y| > 0$
3. å¯¹äºä»»æ„ $k \geq 0$ï¼Œ$xy^k z \in L$

**è¯æ˜**:
è®¾ $M$ æ˜¯è¯†åˆ« $L$ çš„DFAï¼Œæœ‰ $n$ ä¸ªçŠ¶æ€ã€‚

å¯¹äºä»»æ„ $w \in L$ ä¸” $|w| \geq n$ï¼Œè€ƒè™‘ $M$ å¤„ç† $w$ çš„çŠ¶æ€åºåˆ—ã€‚

ç”±äº $M$ åªæœ‰ $n$ ä¸ªçŠ¶æ€ï¼Œæ ¹æ®é¸½å·¢åŸç†ï¼ŒçŠ¶æ€åºåˆ—ä¸­å¿…ç„¶æœ‰é‡å¤çš„çŠ¶æ€ã€‚

è®¾ $q_i = q_j$ ä¸” $i < j$ï¼Œåˆ™å¯ä»¥å°† $w$ åˆ†è§£ä¸º $w = xyz$ï¼Œå…¶ä¸­ï¼š
- $x$ å¯¹åº”ä»åˆå§‹çŠ¶æ€åˆ° $q_i$ çš„è·¯å¾„
- $y$ å¯¹åº”ä» $q_i$ åˆ° $q_j$ çš„è·¯å¾„
- $z$ å¯¹åº”ä» $q_j$ åˆ°æ¥å—çŠ¶æ€çš„è·¯å¾„

ç”±äº $q_i = q_j$ï¼Œå¯¹äºä»»æ„ $k \geq 0$ï¼Œ$xy^k z$ éƒ½ä¼šè¢« $M$ æ¥å—ã€‚

### 3.3 è‡ªåŠ¨æœºæœ€å°åŒ–

**å®šç† 1.3.5** (è‡ªåŠ¨æœºæœ€å°åŒ–)
å¯¹äºæ¯ä¸ªDFAï¼Œéƒ½å­˜åœ¨ä¸€ä¸ªå”¯ä¸€çš„æœ€å°ç­‰ä»·DFAã€‚

**è¯æ˜**:
ä½¿ç”¨ç­‰ä»·ç±»æ„é€ æœ€å°åŒ–ç®—æ³•ï¼š

1. åˆå§‹åˆ’åˆ†ï¼šå°†çŠ¶æ€åˆ†ä¸ºæ¥å—çŠ¶æ€å’Œéæ¥å—çŠ¶æ€
2. è¿­ä»£ç»†åŒ–ï¼šæ ¹æ®è½¬ç§»å‡½æ•°ç»†åŒ–ç­‰ä»·ç±»
3. æ„é€ æœ€å°DFAï¼šæ¯ä¸ªç­‰ä»·ç±»å¯¹åº”ä¸€ä¸ªçŠ¶æ€

æœ€å°DFAçš„çŠ¶æ€æ•°ç­‰äºç­‰ä»·ç±»çš„æ•°é‡ï¼Œä¸”æ˜¯å”¯ä¸€çš„ã€‚

## 4. ä»£ç å®ç°

### 4.1 ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºå®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::fmt;

/// çŠ¶æ€æ ‡è¯†ç¬¦
pub type State = usize;

/// è¾“å…¥ç¬¦å·
pub type Symbol = char;

/// ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº
#[derive(Debug, Clone)]
pub struct DFA {
    pub states: HashSet<State>,
    pub alphabet: HashSet<Symbol>,
    pub transitions: HashMap<(State, Symbol), State>,
    pub initial_state: State,
    pub accepting_states: HashSet<State>,
}

impl DFA {
    /// åˆ›å»ºæ–°çš„DFA
    pub fn new(initial_state: State) -> Self {
        DFA {
            states: HashSet::new(),
            alphabet: HashSet::new(),
            transitions: HashMap::new(),
            initial_state,
            accepting_states: HashSet::new(),
        }
    }
    
    /// æ·»åŠ çŠ¶æ€
    pub fn add_state(&mut self, state: State) {
        self.states.insert(state);
    }
    
    /// æ·»åŠ è¾“å…¥ç¬¦å·
    pub fn add_symbol(&mut self, symbol: Symbol) {
        self.alphabet.insert(symbol);
    }
    
    /// æ·»åŠ è½¬ç§»
    pub fn add_transition(&mut self, from: State, symbol: Symbol, to: State) {
        self.transitions.insert((from, symbol), to);
    }
    
    /// è®¾ç½®æ¥å—çŠ¶æ€
    pub fn set_accepting(&mut self, state: State) {
        self.accepting_states.insert(state);
    }
    
    /// æ‰§è¡Œè½¬ç§»
    pub fn transition(&self, state: State, symbol: Symbol) -> Option<State> {
        self.transitions.get(&(state, symbol)).cloned()
    }
    
    /// æ‰©å±•è½¬ç§»å‡½æ•°
    pub fn extended_transition(&self, state: State, input: &str) -> Option<State> {
        let mut current_state = state;
        
        for symbol in input.chars() {
            if let Some(next_state) = self.transition(current_state, symbol) {
                current_state = next_state;
            } else {
                return None; // æ— å®šä¹‰è½¬ç§»
            }
        }
        
        Some(current_state)
    }
    
    /// æ£€æŸ¥æ˜¯å¦æ¥å—å­—ç¬¦ä¸²
    pub fn accepts(&self, input: &str) -> bool {
        if let Some(final_state) = self.extended_transition(self.initial_state, input) {
            self.accepting_states.contains(&final_state)
        } else {
            false
        }
    }
    
    /// è·å–æ¥å—çš„è¯­è¨€
    pub fn get_language(&self, max_length: usize) -> HashSet<String> {
        let mut language = HashSet::new();
        self.generate_strings(self.initial_state, "", max_length, &mut language);
        language
    }
    
    /// ç”Ÿæˆå­—ç¬¦ä¸²
    fn generate_strings(&self, state: State, current: &str, max_length: usize, language: &mut HashSet<String>) {
        if current.len() > max_length {
            return;
        }
        
        if self.accepting_states.contains(&state) {
            language.insert(current.to_string());
        }
        
        for &symbol in &self.alphabet {
            if let Some(next_state) = self.transition(state, symbol) {
                let new_current = format!("{}{}", current, symbol);
                self.generate_strings(next_state, &new_current, max_length, language);
            }
        }
    }
}

/// éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº
#[derive(Debug, Clone)]
pub struct NFA {
    pub states: HashSet<State>,
    pub alphabet: HashSet<Symbol>,
    pub transitions: HashMap<(State, Symbol), HashSet<State>>,
    pub initial_state: State,
    pub accepting_states: HashSet<State>,
}

impl NFA {
    /// åˆ›å»ºæ–°çš„NFA
    pub fn new(initial_state: State) -> Self {
        NFA {
            states: HashSet::new(),
            alphabet: HashSet::new(),
            transitions: HashMap::new(),
            initial_state,
            accepting_states: HashSet::new(),
        }
    }
    
    /// æ·»åŠ çŠ¶æ€
    pub fn add_state(&mut self, state: State) {
        self.states.insert(state);
    }
    
    /// æ·»åŠ è¾“å…¥ç¬¦å·
    pub fn add_symbol(&mut self, symbol: Symbol) {
        self.alphabet.insert(symbol);
    }
    
    /// æ·»åŠ è½¬ç§»
    pub fn add_transition(&mut self, from: State, symbol: Symbol, to: State) {
        self.transitions.entry((from, symbol))
            .or_insert_with(HashSet::new)
            .insert(to);
    }
    
    /// è®¾ç½®æ¥å—çŠ¶æ€
    pub fn set_accepting(&mut self, state: State) {
        self.accepting_states.insert(state);
    }
    
    /// æ‰§è¡Œè½¬ç§»
    pub fn transition(&self, state: State, symbol: Symbol) -> HashSet<State> {
        self.transitions.get(&(state, symbol))
            .cloned()
            .unwrap_or_default()
    }
    
    /// æ‰©å±•è½¬ç§»å‡½æ•°
    pub fn extended_transition(&self, states: &HashSet<State>, input: &str) -> HashSet<State> {
        let mut current_states = states.clone();
        
        for symbol in input.chars() {
            let mut next_states = HashSet::new();
            for &state in &current_states {
                next_states.extend(self.transition(state, symbol));
            }
            current_states = next_states;
        }
        
        current_states
    }
    
    /// æ£€æŸ¥æ˜¯å¦æ¥å—å­—ç¬¦ä¸²
    pub fn accepts(&self, input: &str) -> bool {
        let mut initial_states = HashSet::new();
        initial_states.insert(self.initial_state);
        
        let final_states = self.extended_transition(&initial_states, input);
        !final_states.is_disjoint(&self.accepting_states)
    }
    
    /// è½¬æ¢ä¸ºDFA
    pub fn to_dfa(&self) -> DFA {
        let mut dfa = DFA::new(0);
        
        // ä½¿ç”¨å¹‚é›†æ„é€ 
        let mut state_mapping = HashMap::new();
        let mut dfa_states = Vec::new();
        
        // åˆå§‹çŠ¶æ€
        let initial_dfa_state = 0;
        let mut initial_nfa_states = HashSet::new();
        initial_nfa_states.insert(self.initial_state);
        state_mapping.insert(initial_nfa_states.clone(), initial_dfa_state);
        dfa_states.push(initial_nfa_states);
        dfa.add_state(initial_dfa_state);
        
        // å¤„ç†æ‰€æœ‰DFAçŠ¶æ€
        let mut i = 0;
        while i < dfa_states.len() {
            let current_nfa_states = &dfa_states[i];
            let current_dfa_state = state_mapping[current_nfa_states];
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºæ¥å—çŠ¶æ€
            if !current_nfa_states.is_disjoint(&self.accepting_states) {
                dfa.set_accepting(current_dfa_state);
            }
            
            // ä¸ºæ¯ä¸ªè¾“å…¥ç¬¦å·è®¡ç®—è½¬ç§»
            for &symbol in &self.alphabet {
                let mut next_nfa_states = HashSet::new();
                for &nfa_state in current_nfa_states {
                    next_nfa_states.extend(self.transition(nfa_state, symbol));
                }
                
                if !next_nfa_states.is_empty() {
                    let next_dfa_state = if let Some(&existing_state) = state_mapping.get(&next_nfa_states) {
                        existing_state
                    } else {
                        let new_dfa_state = dfa_states.len();
                        state_mapping.insert(next_nfa_states.clone(), new_dfa_state);
                        dfa_states.push(next_nfa_states);
                        dfa.add_state(new_dfa_state);
                        new_dfa_state
                    };
                    
                    dfa.add_transition(current_dfa_state, symbol, next_dfa_state);
                }
            }
            
            i += 1;
        }
        
        // è®¾ç½®å­—æ¯è¡¨
        for &symbol in &self.alphabet {
            dfa.add_symbol(symbol);
        }
        
        dfa
    }
}

/// è‡ªåŠ¨æœºæœ€å°åŒ–
pub struct AutomatonMinimizer;

impl AutomatonMinimizer {
    /// æœ€å°åŒ–DFA
    pub fn minimize_dfa(dfa: &DFA) -> DFA {
        // è®¡ç®—ç­‰ä»·ç±»
        let equivalence_classes = Self::compute_equivalence_classes(dfa);
        
        // æ„é€ æœ€å°DFA
        let mut minimal_dfa = DFA::new(0);
        
        // åˆ›å»ºçŠ¶æ€æ˜ å°„
        let mut state_mapping = HashMap::new();
        let mut new_state_id = 0;
        
        for class in &equivalence_classes {
            state_mapping.insert(class.clone(), new_state_id);
            minimal_dfa.add_state(new_state_id);
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºæ¥å—çŠ¶æ€
            if class.iter().any(|&state| dfa.accepting_states.contains(&state)) {
                minimal_dfa.set_accepting(new_state_id);
            }
            
            new_state_id += 1;
        }
        
        // æ·»åŠ è½¬ç§»
        for class in &equivalence_classes {
            let new_state = state_mapping[class];
            let representative = class.iter().next().unwrap();
            
            for &symbol in &dfa.alphabet {
                if let Some(next_state) = dfa.transition(*representative, symbol) {
                    // æ‰¾åˆ°åŒ…å«next_stateçš„ç­‰ä»·ç±»
                    for other_class in &equivalence_classes {
                        if other_class.contains(&next_state) {
                            let new_next_state = state_mapping[other_class];
                            minimal_dfa.add_transition(new_state, symbol, new_next_state);
                            break;
                        }
                    }
                }
            }
        }
        
        // è®¾ç½®å­—æ¯è¡¨
        for &symbol in &dfa.alphabet {
            minimal_dfa.add_symbol(symbol);
        }
        
        minimal_dfa
    }
    
    /// è®¡ç®—ç­‰ä»·ç±»
    fn compute_equivalence_classes(dfa: &DFA) -> Vec<HashSet<State>> {
        // åˆå§‹åˆ’åˆ†ï¼šæ¥å—çŠ¶æ€å’Œéæ¥å—çŠ¶æ€
        let mut partition = vec![
            dfa.accepting_states.clone(),
            dfa.states.difference(&dfa.accepting_states).cloned().collect()
        ];
        
        // è¿­ä»£ç»†åŒ–
        loop {
            let mut new_partition = Vec::new();
            let mut changed = false;
            
            for class in &partition {
                if class.len() <= 1 {
                    new_partition.push(class.clone());
                    continue;
                }
                
                // å°è¯•åˆ†å‰²ç­‰ä»·ç±»
                let mut subclasses = Vec::new();
                let mut remaining = class.clone();
                
                while !remaining.is_empty() {
                    let representative = *remaining.iter().next().unwrap();
                    let mut subclass = HashSet::new();
                    subclass.insert(representative);
                    remaining.remove(&representative);
                    
                    let mut to_remove = Vec::new();
                    for &state in &remaining {
                        if Self::are_equivalent(dfa, representative, state, &partition) {
                            subclass.insert(state);
                            to_remove.push(state);
                        }
                    }
                    
                    for state in to_remove {
                        remaining.remove(&state);
                    }
                    
                    subclasses.push(subclass);
                }
                
                if subclasses.len() > 1 {
                    changed = true;
                }
                new_partition.extend(subclasses);
            }
            
            if !changed {
                break;
            }
            
            partition = new_partition;
        }
        
        partition
    }
    
    /// æ£€æŸ¥ä¸¤ä¸ªçŠ¶æ€æ˜¯å¦ç­‰ä»·
    fn are_equivalent(dfa: &DFA, state1: State, state2: State, partition: &[HashSet<State>]) -> bool {
        for &symbol in &dfa.alphabet {
            let next1 = dfa.transition(state1, symbol);
            let next2 = dfa.transition(state2, symbol);
            
            if next1 != next2 {
                // æ£€æŸ¥next1å’Œnext2æ˜¯å¦åœ¨åŒä¸€ä¸ªç­‰ä»·ç±»ä¸­
                let mut found = false;
                for class in partition {
                    if class.contains(&next1) && class.contains(&next2) {
                        found = true;
                        break;
                    }
                }
                if !found {
                    return false;
                }
            }
        }
        true
    }
}

/// æ­£åˆ™è¡¨è¾¾å¼åˆ°NFAçš„è½¬æ¢
pub struct RegexToNFA;

impl RegexToNFA {
    /// å°†æ­£åˆ™è¡¨è¾¾å¼è½¬æ¢ä¸ºNFA
    pub fn convert(regex: &str) -> NFA {
        // ç®€åŒ–å®ç°ï¼šåªå¤„ç†åŸºæœ¬çš„æ­£åˆ™è¡¨è¾¾å¼
        let mut nfa = NFA::new(0);
        nfa.add_state(0);
        nfa.add_state(1);
        nfa.set_accepting(1);
        
        // è§£ææ­£åˆ™è¡¨è¾¾å¼å¹¶æ„é€ NFA
        // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„è§£æå™¨
        for c in regex.chars() {
            if c.is_alphanumeric() {
                nfa.add_symbol(c);
                nfa.add_transition(0, c, 1);
            }
        }
        
        nfa
    }
}

/// è‡ªåŠ¨æœºæµ‹è¯•
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_dfa() {
        // æ„é€ è¯†åˆ«å¶æ•°ä¸ªaçš„DFA
        let mut dfa = DFA::new(0);
        
        dfa.add_state(0);
        dfa.add_state(1);
        dfa.add_symbol('a');
        dfa.add_symbol('b');
        
        dfa.add_transition(0, 'a', 1);
        dfa.add_transition(0, 'b', 0);
        dfa.add_transition(1, 'a', 0);
        dfa.add_transition(1, 'b', 1);
        
        dfa.set_accepting(0);
        
        // æµ‹è¯•
        assert!(dfa.accepts(""));
        assert!(dfa.accepts("aa"));
        assert!(dfa.accepts("aabb"));
        assert!(!dfa.accepts("a"));
        assert!(!dfa.accepts("aaa"));
    }
    
    #[test]
    fn test_nfa_to_dfa() {
        // æ„é€ NFA
        let mut nfa = NFA::new(0);
        
        nfa.add_state(0);
        nfa.add_state(1);
        nfa.add_state(2);
        nfa.add_symbol('a');
        nfa.add_symbol('b');
        
        nfa.add_transition(0, 'a', 1);
        nfa.add_transition(0, 'a', 2);
        nfa.add_transition(1, 'b', 2);
        nfa.add_transition(2, 'a', 2);
        
        nfa.set_accepting(2);
        
        // è½¬æ¢ä¸ºDFA
        let dfa = nfa.to_dfa();
        
        // æµ‹è¯•ç­‰ä»·æ€§
        let test_strings = vec!["", "a", "ab", "aba", "abaa"];
        for s in test_strings {
            assert_eq!(nfa.accepts(s), dfa.accepts(s));
        }
    }
    
    #[test]
    fn test_minimization() {
        // æ„é€ å¯æœ€å°åŒ–çš„DFA
        let mut dfa = DFA::new(0);
        
        dfa.add_state(0);
        dfa.add_state(1);
        dfa.add_state(2);
        dfa.add_state(3);
        dfa.add_symbol('a');
        dfa.add_symbol('b');
        
        dfa.add_transition(0, 'a', 1);
        dfa.add_transition(0, 'b', 2);
        dfa.add_transition(1, 'a', 1);
        dfa.add_transition(1, 'b', 3);
        dfa.add_transition(2, 'a', 1);
        dfa.add_transition(2, 'b', 2);
        dfa.add_transition(3, 'a', 1);
        dfa.add_transition(3, 'b', 2);
        
        dfa.set_accepting(1);
        dfa.set_accepting(3);
        
        // æœ€å°åŒ–
        let minimal_dfa = AutomatonMinimizer::minimize_dfa(&dfa);
        
        // éªŒè¯ç­‰ä»·æ€§
        let test_strings = vec!["", "a", "b", "aa", "ab", "ba", "bb"];
        for s in test_strings {
            assert_eq!(dfa.accepts(s), minimal_dfa.accepts(s));
        }
        
        // éªŒè¯æœ€å°åŒ–
        assert!(minimal_dfa.states.len() < dfa.states.len());
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 è¯æ³•åˆ†æå™¨

**ç¤ºä¾‹ 1**: ç®€å•è¯æ³•åˆ†æå™¨
```rust
// è¯æ³•åˆ†æå™¨
fn create_lexical_analyzer() -> DFA {
    let mut dfa = DFA::new(0);
    
    // çŠ¶æ€ï¼š0-åˆå§‹ï¼Œ1-æ ‡è¯†ç¬¦ï¼Œ2-æ•°å­—ï¼Œ3-å­—ç¬¦ä¸²ï¼Œ4-æ³¨é‡Š
    for i in 0..5 {
        dfa.add_state(i);
    }
    
    // å­—æ¯è¡¨
    dfa.add_symbol('a');
    dfa.add_symbol('0');
    dfa.add_symbol('"');
    dfa.add_symbol('/');
    dfa.add_symbol(' ');
    
    // è½¬ç§»å‡½æ•°
    // æ ‡è¯†ç¬¦ï¼šå­—æ¯å¼€å¤´ï¼Œåè·Ÿå­—æ¯æˆ–æ•°å­—
    dfa.add_transition(0, 'a', 1);
    dfa.add_transition(1, 'a', 1);
    dfa.add_transition(1, '0', 1);
    
    // æ•°å­—ï¼šæ•°å­—åºåˆ—
    dfa.add_transition(0, '0', 2);
    dfa.add_transition(2, '0', 2);
    
    // å­—ç¬¦ä¸²ï¼šåŒå¼•å·åŒ…å›´
    dfa.add_transition(0, '"', 3);
    dfa.add_transition(3, 'a', 3);
    dfa.add_transition(3, '0', 3);
    dfa.add_transition(3, '"', 4);
    
    // æ³¨é‡Šï¼šåŒæ–œæ 
    dfa.add_transition(0, '/', 4);
    dfa.add_transition(4, '/', 4);
    
    // æ¥å—çŠ¶æ€
    dfa.set_accepting(1); // æ ‡è¯†ç¬¦
    dfa.set_accepting(2); // æ•°å­—
    dfa.set_accepting(4); // å­—ç¬¦ä¸²ç»“æŸ
    
    dfa
}

// ä½¿ç”¨ç¤ºä¾‹
let lexer = create_lexical_analyzer();
println!("'abc' æ˜¯æ ‡è¯†ç¬¦: {}", lexer.accepts("abc"));
println!("'123' æ˜¯æ•°å­—: {}", lexer.accepts("123"));
println!("'\"hello\"' æ˜¯å­—ç¬¦ä¸²: {}", lexer.accepts("\"hello\""));
```

### 5.2 æ¨¡å¼åŒ¹é…

**ç¤ºä¾‹ 2**: æ¨¡å¼åŒ¹é…è‡ªåŠ¨æœº
```rust
// æ¨¡å¼åŒ¹é…è‡ªåŠ¨æœº
fn create_pattern_matcher(pattern: &str) -> DFA {
    let mut dfa = DFA::new(0);
    
    // ä¸ºæ¨¡å¼çš„æ¯ä¸ªä½ç½®åˆ›å»ºçŠ¶æ€
    for i in 0..=pattern.len() {
        dfa.add_state(i);
    }
    
    // è®¾ç½®å­—æ¯è¡¨
    for c in pattern.chars() {
        dfa.add_symbol(c);
    }
    
    // æ„é€ è½¬ç§»å‡½æ•°
    for (i, c) in pattern.chars().enumerate() {
        dfa.add_transition(i, c, i + 1);
    }
    
    // è®¾ç½®æ¥å—çŠ¶æ€
    dfa.set_accepting(pattern.len());
    
    dfa
}

// ä½¿ç”¨ç¤ºä¾‹
let pattern = "abc";
let matcher = create_pattern_matcher(pattern);
println!("'abc' åŒ¹é…æ¨¡å¼: {}", matcher.accepts("abc"));
println!("'ab' åŒ¹é…æ¨¡å¼: {}", matcher.accepts("ab"));
println!("'abcd' åŒ¹é…æ¨¡å¼: {}", matcher.accepts("abcd"));
```

### 5.3 çŠ¶æ€æœºéªŒè¯

**ç¤ºä¾‹ 3**: åè®®çŠ¶æ€æœºéªŒè¯
```rust
// åè®®çŠ¶æ€æœº
fn create_protocol_machine() -> DFA {
    let mut dfa = DFA::new(0);
    
    // çŠ¶æ€ï¼š0-åˆå§‹ï¼Œ1-è¿æ¥ï¼Œ2-è®¤è¯ï¼Œ3-ä¼ è¾“ï¼Œ4-æ–­å¼€
    for i in 0..5 {
        dfa.add_state(i);
    }
    
    // äº‹ä»¶ï¼šc-è¿æ¥ï¼Œa-è®¤è¯ï¼Œt-ä¼ è¾“ï¼Œd-æ–­å¼€
    dfa.add_symbol('c');
    dfa.add_symbol('a');
    dfa.add_symbol('t');
    dfa.add_symbol('d');
    
    // åè®®è½¬ç§»
    dfa.add_transition(0, 'c', 1); // åˆå§‹->è¿æ¥
    dfa.add_transition(1, 'a', 2); // è¿æ¥->è®¤è¯
    dfa.add_transition(2, 't', 3); // è®¤è¯->ä¼ è¾“
    dfa.add_transition(3, 't', 3); // ä¼ è¾“->ä¼ è¾“
    dfa.add_transition(3, 'd', 4); // ä¼ è¾“->æ–­å¼€
    dfa.add_transition(4, 'c', 1); // æ–­å¼€->è¿æ¥
    
    // æ¥å—çŠ¶æ€ï¼šä¼ è¾“çŠ¶æ€
    dfa.set_accepting(3);
    
    dfa
}

// éªŒè¯åè®®åºåˆ—
let protocol = create_protocol_machine();
let valid_sequence = "cat";
let invalid_sequence = "cta";

println!("æœ‰æ•ˆåºåˆ— '{}': {}", valid_sequence, protocol.accepts(valid_sequence));
println!("æ— æ•ˆåºåˆ— '{}': {}", invalid_sequence, protocol.accepts(invalid_sequence));
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸æ–‡æ³•ç†è®ºçš„å…³ç³»

æœ‰é™è‡ªåŠ¨æœºä¸æ–‡æ³•ç†è®ºå¯†åˆ‡ç›¸å…³ï¼š
- **æ­£åˆ™æ–‡æ³•**: æœ‰é™è‡ªåŠ¨æœºè¯†åˆ«æ­£åˆ™è¯­è¨€
- **ä¹”å§†æ–¯åŸºè°±ç³»**: æœ‰é™è‡ªåŠ¨æœºå¯¹åº”3å‹æ–‡æ³•
- **æ–‡æ³•è½¬æ¢**: æ­£åˆ™æ–‡æ³•ä¸æœ‰é™è‡ªåŠ¨æœºå¯ä»¥ç›¸äº’è½¬æ¢

### 6.2 ä¸è®¡ç®—ç†è®ºçš„å…³ç³»

æœ‰é™è‡ªåŠ¨æœºæ˜¯è®¡ç®—ç†è®ºçš„åŸºç¡€ï¼š
- **è®¡ç®—èƒ½åŠ›**: æœ‰é™è‡ªåŠ¨æœºçš„è®¡ç®—èƒ½åŠ›é™åˆ¶
- **å¤æ‚æ€§**: æœ‰é™è‡ªåŠ¨æœºçš„çŠ¶æ€å¤æ‚æ€§
- **ç­‰ä»·æ€§**: ä¸åŒè‡ªåŠ¨æœºæ¨¡å‹çš„ç­‰ä»·æ€§

### 6.3 ä¸è¯­è¨€ç†è®ºçš„å…³ç³»

æœ‰é™è‡ªåŠ¨æœºä¸ºè¯­è¨€ç†è®ºæä¾›å·¥å…·ï¼š
- **è¯­è¨€è¯†åˆ«**: è‡ªåŠ¨æœºè¯†åˆ«ç‰¹å®šè¯­è¨€
- **è¯­è¨€æ€§è´¨**: é€šè¿‡è‡ªåŠ¨æœºåˆ†æè¯­è¨€æ€§è´¨
- **è¯­è¨€æ“ä½œ**: è‡ªåŠ¨æœºä¸Šçš„è¯­è¨€æ“ä½œ

## 7. å‚è€ƒæ–‡çŒ®

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to automata theory, languages, and computation*. Pearson Education.

2. Sipser, M. (2012). *Introduction to the theory of computation*. Cengage Learning.

3. Kozen, D. C. (1997). *Automata and computability*. Springer Science & Business Media.

4. Lewis, H. R., & Papadimitriou, C. H. (1998). *Elements of the theory of computation*. Pearson Education.

5. Myhill, J. (1957). Finite automata and the representation of events. *WADD TR-57-624*, 112-137.

---

**ç›¸å…³æ–‡æ¡£**:
- [03.1.2 ä¸‹æ¨è‡ªåŠ¨æœº](03.1.2_ä¸‹æ¨è‡ªåŠ¨æœº.md)
- [03.1.3 çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº](03.1.3_çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº.md)
- [03.2.1 æ­£åˆ™æ–‡æ³•](03.2.1_æ­£åˆ™æ–‡æ³•.md)
- [03.3.1 ä¹”å§†æ–¯åŸºè°±ç³»](03.3.1_ä¹”å§†æ–¯åŸºè°±ç³».md)

**è¿”å›**: [å½¢å¼è¯­è¨€ç†è®º](../README.md) | [ä¸»ç´¢å¼•](../../00_Master_Index/README.md) 