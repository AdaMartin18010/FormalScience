# 03.1.1 æœ‰é™è‡ªåŠ¨æœº

## ğŸ“‹ æ¦‚è¿°

**æ–‡æ¡£**: 03.1.1 æœ‰é™è‡ªåŠ¨æœº  
**ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2024-12-21  
**ç»´æŠ¤çŠ¶æ€**: æŒç»­æ„å»ºä¸­  

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

å»ºç«‹ä¸¥æ ¼çš„å½¢å¼åŒ–æœ‰é™è‡ªåŠ¨æœºç†è®ºä½“ç³»ï¼Œä¸ºå½¢å¼è¯­è¨€ç†è®ºæä¾›è‡ªåŠ¨æœºåŸºç¡€ã€‚

## ğŸ“š ç›®å½•

1. [è‡ªåŠ¨æœºæ¦‚å¿µ](#1-è‡ªåŠ¨æœºæ¦‚å¿µ)
2. [æœ‰é™è‡ªåŠ¨æœºç±»å‹](#2-æœ‰é™è‡ªåŠ¨æœºç±»å‹)
3. [è‡ªåŠ¨æœºè¿ç®—](#3-è‡ªåŠ¨æœºè¿ç®—)
4. [è‡ªåŠ¨æœºç­‰ä»·æ€§](#4-è‡ªåŠ¨æœºç­‰ä»·æ€§)
5. [å½¢å¼åŒ–å®šä¹‰](#5-å½¢å¼åŒ–å®šä¹‰)
6. [å®šç†ä¸è¯æ˜](#6-å®šç†ä¸è¯æ˜)
7. [ä»£ç å®ç°](#7-ä»£ç å®ç°)
8. [åº”ç”¨ç¤ºä¾‹](#8-åº”ç”¨ç¤ºä¾‹)
9. [ç›¸å…³ç†è®º](#9-ç›¸å…³ç†è®º)
10. [å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)

## 1. è‡ªåŠ¨æœºæ¦‚å¿µ

### 1.1 åŸºæœ¬å®šä¹‰

**å®šä¹‰ 1.1.1** (æœ‰é™è‡ªåŠ¨æœº)
æœ‰é™è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š
- $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯æœ‰é™è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times \Sigma \rightarrow Q$ æ˜¯è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†åˆ

**å®šä¹‰ 1.1.2** (è‡ªåŠ¨æœºé…ç½®)
è‡ªåŠ¨æœºçš„é…ç½®æ˜¯ä¸€ä¸ªäºŒå…ƒç»„ $(q, w)$ï¼Œå…¶ä¸­ $q \in Q$ æ˜¯å½“å‰çŠ¶æ€ï¼Œ$w \in \Sigma^*$ æ˜¯å‰©ä½™è¾“å…¥ä¸²ã€‚

**å®šä¹‰ 1.1.3** (è½¬ç§»å…³ç³»)
é…ç½® $(q, aw)$ è½¬ç§»åˆ°é…ç½® $(q', w)$ å½“ä¸”ä»…å½“ $\delta(q, a) = q'$ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$(q, aw) \vdash (q', w) \equiv \delta(q, a) = q'$$

### 1.2 è‡ªåŠ¨æœºè¯­è¨€

**å®šä¹‰ 1.1.4** (æ¥å—è¯­è¨€)
è‡ªåŠ¨æœº $M$ æ¥å—çš„è¯­è¨€æ˜¯ï¼š
$$L(M) = \{w \in \Sigma^* \mid (q_0, w) \vdash^* (q, \epsilon) \text{ ä¸” } q \in F\}$$

**å®šä¹‰ 1.1.5** (æ­£åˆ™è¯­è¨€)
ä¸€ä¸ªè¯­è¨€æ˜¯æ­£åˆ™çš„å½“ä¸”ä»…å½“å®ƒè¢«æŸä¸ªæœ‰é™è‡ªåŠ¨æœºæ¥å—ã€‚

## 2. æœ‰é™è‡ªåŠ¨æœºç±»å‹

### 2.1 ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº

**å®šä¹‰ 2.1.1** (DFA)
ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºæ˜¯è½¬ç§»å‡½æ•°ä¸ºå•å€¼çš„æœ‰é™è‡ªåŠ¨æœºã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\delta: Q \times \Sigma \rightarrow Q$$

**ç‰¹å¾**:
- æ¯ä¸ªçŠ¶æ€-è¾“å…¥å¯¹åªæœ‰ä¸€ä¸ªåç»§çŠ¶æ€
- è½¬ç§»å‡½æ•°æ˜¯ç¡®å®šçš„

### 2.2 éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº

**å®šä¹‰ 2.1.2** (NFA)
éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºæ˜¯è½¬ç§»å‡½æ•°ä¸ºå¤šå€¼çš„æœ‰é™è‡ªåŠ¨æœºã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\delta: Q \times \Sigma \rightarrow 2^Q$$

**ç‰¹å¾**:
- æ¯ä¸ªçŠ¶æ€-è¾“å…¥å¯¹å¯ä»¥æœ‰å¤šä¸ªåç»§çŠ¶æ€
- è½¬ç§»å‡½æ•°æ˜¯éç¡®å®šçš„

### 2.3 Îµ-éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº

**å®šä¹‰ 2.1.3** (Îµ-NFA)
Îµ-éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœºå…è®¸Îµè½¬ç§»çš„NFAã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\delta: Q \times (\Sigma \cup \{\epsilon\}) \rightarrow 2^Q$$

**ç‰¹å¾**:
- å…è®¸ä¸æ¶ˆè€—è¾“å…¥ç¬¦å·çš„è½¬ç§»
- è½¬ç§»å‡½æ•°åŒ…å«Îµè½¬ç§»

## 3. è‡ªåŠ¨æœºè¿ç®—

### 3.1 åŸºæœ¬è¿ç®—

**å®šä¹‰ 3.1.1** (è‡ªåŠ¨æœºå¹¶é›†)
ä¸¤ä¸ªè‡ªåŠ¨æœº $M_1$ å’Œ $M_2$ çš„å¹¶é›†è‡ªåŠ¨æœºæ¥å— $L(M_1) \cup L(M_2)$ã€‚

**æ„é€ æ–¹æ³•**:
1. åˆ›å»ºæ–°çš„åˆå§‹çŠ¶æ€
2. æ·»åŠ Îµè½¬ç§»åˆ°åŸåˆå§‹çŠ¶æ€
3. åˆå¹¶æ¥å—çŠ¶æ€

**å®šä¹‰ 3.1.2** (è‡ªåŠ¨æœºäº¤é›†)
ä¸¤ä¸ªè‡ªåŠ¨æœº $M_1$ å’Œ $M_2$ çš„äº¤é›†è‡ªåŠ¨æœºæ¥å— $L(M_1) \cap L(M_2)$ã€‚

**æ„é€ æ–¹æ³•**:
1. æ„é€ ä¹˜ç§¯è‡ªåŠ¨æœº
2. è®¾ç½®æ¥å—çŠ¶æ€ä¸ºåŸæ¥å—çŠ¶æ€çš„ç¬›å¡å°”ç§¯

**å®šä¹‰ 3.1.3** (è‡ªåŠ¨æœºè¡¥é›†)
è‡ªåŠ¨æœº $M$ çš„è¡¥é›†è‡ªåŠ¨æœºæ¥å— $\Sigma^* \setminus L(M)$ã€‚

**æ„é€ æ–¹æ³•**:
1. å°†éæ¥å—çŠ¶æ€å˜ä¸ºæ¥å—çŠ¶æ€
2. å°†æ¥å—çŠ¶æ€å˜ä¸ºéæ¥å—çŠ¶æ€

### 3.2 é«˜çº§è¿ç®—

**å®šä¹‰ 3.1.4** (è‡ªåŠ¨æœºè¿æ¥)
ä¸¤ä¸ªè‡ªåŠ¨æœº $M_1$ å’Œ $M_2$ çš„è¿æ¥è‡ªåŠ¨æœºæ¥å— $L(M_1) \cdot L(M_2)$ã€‚

**æ„é€ æ–¹æ³•**:
1. å°† $M_1$ çš„æ¥å—çŠ¶æ€è¿æ¥åˆ° $M_2$ çš„åˆå§‹çŠ¶æ€
2. è®¾ç½® $M_1$ çš„æ¥å—çŠ¶æ€ä¸ºéæ¥å—

**å®šä¹‰ 3.1.5** (è‡ªåŠ¨æœºå…‹æ—é—­åŒ…)
è‡ªåŠ¨æœº $M$ çš„å…‹æ—é—­åŒ…è‡ªåŠ¨æœºæ¥å— $L(M)^*$ã€‚

**æ„é€ æ–¹æ³•**:
1. æ·»åŠ æ–°çš„åˆå§‹çŠ¶æ€
2. æ·»åŠ Îµè½¬ç§»åˆ°åŸåˆå§‹çŠ¶æ€
3. ä»æ¥å—çŠ¶æ€æ·»åŠ Îµè½¬ç§»åˆ°åŸåˆå§‹çŠ¶æ€

## 4. è‡ªåŠ¨æœºç­‰ä»·æ€§

### 4.1 ç­‰ä»·æ€§æ¦‚å¿µ

**å®šä¹‰ 4.1.1** (è¯­è¨€ç­‰ä»·)
ä¸¤ä¸ªè‡ªåŠ¨æœº $M_1$ å’Œ $M_2$ è¯­è¨€ç­‰ä»·å½“ä¸”ä»…å½“ $L(M_1) = L(M_2)$ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$M_1 \equiv_L M_2 \equiv L(M_1) = L(M_2)$$

**å®šä¹‰ 4.1.2** (ç»“æ„ç­‰ä»·)
ä¸¤ä¸ªè‡ªåŠ¨æœº $M_1$ å’Œ $M_2$ ç»“æ„ç­‰ä»·å½“ä¸”ä»…å½“å®ƒä»¬åŒæ„ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$M_1 \equiv_S M_2 \equiv \exists f: Q_1 \rightarrow Q_2 \text{ åŒæ„æ˜ å°„}$$

### 4.2 æœ€å°åŒ–

**å®šä¹‰ 4.1.3** (çŠ¶æ€ç­‰ä»·)
ä¸¤ä¸ªçŠ¶æ€ $q_1$ å’Œ $q_2$ ç­‰ä»·å½“ä¸”ä»…å½“å®ƒä»¬æ¥å—ç›¸åŒçš„è¯­è¨€ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$q_1 \equiv q_2 \equiv \forall w \in \Sigma^* (\delta^*(q_1, w) \in F \leftrightarrow \delta^*(q_2, w) \in F)$$

**å®šä¹‰ 4.1.4** (æœ€å°åŒ–è‡ªåŠ¨æœº)
æœ€å°åŒ–è‡ªåŠ¨æœºæ˜¯çŠ¶æ€æ•°æœ€å°‘çš„ç­‰ä»·è‡ªåŠ¨æœºã€‚

**æ„é€ æ–¹æ³•**:
1. ç§»é™¤ä¸å¯è¾¾çŠ¶æ€
2. åˆå¹¶ç­‰ä»·çŠ¶æ€
3. æ›´æ–°è½¬ç§»å‡½æ•°

## 5. å½¢å¼åŒ–å®šä¹‰

### 5.1 æœ‰é™è‡ªåŠ¨æœºçš„å½¢å¼åŒ–ç³»ç»Ÿ

**å®šä¹‰ 5.1.1** (æœ‰é™è‡ªåŠ¨æœºè¯­è¨€)
æœ‰é™è‡ªåŠ¨æœºçš„è¯­è¨€ $\mathcal{L}_{FA}$ åŒ…å«ï¼š
- çŠ¶æ€å˜é‡ï¼š$q, q', \ldots$
- è¾“å…¥ç¬¦å·ï¼š$a, b, \ldots$
- è½¬ç§»å‡½æ•°ï¼š$\delta$
- é…ç½®å…³ç³»ï¼š$\vdash$

**å®šä¹‰ 5.1.2** (æœ‰é™è‡ªåŠ¨æœºæ¨¡å‹)
æœ‰é™è‡ªåŠ¨æœºæ¨¡å‹ $\mathcal{M} = \langle Q, \Sigma, \delta, q_0, F \rangle$ åŒ…å«ï¼š
- $Q$ï¼šçŠ¶æ€é›†åˆ
- $\Sigma$ï¼šè¾“å…¥å­—æ¯è¡¨
- $\delta$ï¼šè½¬ç§»å‡½æ•°
- $q_0$ï¼šåˆå§‹çŠ¶æ€
- $F$ï¼šæ¥å—çŠ¶æ€é›†åˆ

### 5.2 æœ‰é™è‡ªåŠ¨æœºå…¬ç†ç³»ç»Ÿ

**å…¬ç† 5.1.1** (æœ‰é™è‡ªåŠ¨æœºå…¬ç†)
1. $\delta(q, a) \in Q$ (è½¬ç§»å‡½æ•°å°é—­æ€§)
2. $(q, aw) \vdash (q', w) \leftrightarrow \delta(q, a) = q'$ (è½¬ç§»å…³ç³»å®šä¹‰)
3. $(q, w) \vdash^* (q, w)$ (è‡ªåæ€§)
4. $(q, w) \vdash^* (q', w') \land (q', w') \vdash^* (q'', w'') \rightarrow (q, w) \vdash^* (q'', w'')$ (ä¼ é€’æ€§)

## 6. å®šç†ä¸è¯æ˜

### 6.1 åŸºæœ¬å®šç†

**å®šç† 6.1.1** (DFAä¸NFAç­‰ä»·æ€§)
å¯¹äºä»»æ„NFA $M$ï¼Œå­˜åœ¨DFA $M'$ ä½¿å¾— $L(M) = L(M')$ã€‚

**è¯æ˜**:
æ„é€ DFA $M' = (Q', \Sigma, \delta', q_0', F')$ï¼š
- $Q' = 2^Q$ (NFAçŠ¶æ€é›†åˆçš„å¹‚é›†)
- $q_0' = \{q_0\}$
- $F' = \{S \subseteq Q \mid S \cap F \neq \emptyset\}$
- $\delta'(S, a) = \bigcup_{q \in S} \delta(q, a)$

**å®šç† 6.1.2** (Îµ-NFAä¸NFAç­‰ä»·æ€§)
å¯¹äºä»»æ„Îµ-NFA $M$ï¼Œå­˜åœ¨NFA $M'$ ä½¿å¾— $L(M) = L(M')$ã€‚

**è¯æ˜**:
æ„é€ NFA $M'$ï¼š
- è®¡ç®—Îµé—­åŒ…
- ç§»é™¤Îµè½¬ç§»
- æ›´æ–°è½¬ç§»å‡½æ•°

### 6.2 é«˜çº§å®šç†

**å®šç† 6.1.3** (æ³µå¼•ç†)
å¯¹äºä»»æ„æ­£åˆ™è¯­è¨€ $L$ï¼Œå­˜åœ¨å¸¸æ•° $n$ ä½¿å¾—å¯¹äºä»»æ„ $w \in L$ ä¸” $|w| \geq n$ï¼Œå­˜åœ¨åˆ†è§£ $w = xyz$ æ»¡è¶³ï¼š
1. $|xy| \leq n$
2. $|y| > 0$
3. å¯¹äºä»»æ„ $k \geq 0$ï¼Œ$xy^k z \in L$

**è¯æ˜**:
è®¾ $M$ æ˜¯æ¥å— $L$ çš„DFAï¼ŒçŠ¶æ€æ•°ä¸º $n$ã€‚
å¯¹äºé•¿åº¦è‡³å°‘ä¸º $n$ çš„ä¸² $w$ï¼Œæ ¹æ®é¸½å·¢åŸç†ï¼Œå­˜åœ¨çŠ¶æ€é‡å¤ã€‚
è®¾é‡å¤çŠ¶æ€ä¸º $q$ï¼Œåˆ™ $w$ å¯ä»¥åˆ†è§£ä¸º $xyz$ï¼Œå…¶ä¸­ $y$ å¯¹åº”ä» $q$ å›åˆ° $q$ çš„è·¯å¾„ã€‚

**å®šç† 6.1.4** (Myhill-Nerodeå®šç†)
è¯­è¨€ $L$ æ˜¯æ­£åˆ™çš„å½“ä¸”ä»…å½“ $L$ çš„å³åŒä½™å…³ç³»æœ‰æœ‰é™ä¸ªç­‰ä»·ç±»ã€‚

**è¯æ˜**:
å¿…è¦æ€§ï¼šDFAçš„çŠ¶æ€å¯¹åº”å³åŒä½™ç­‰ä»·ç±»ã€‚
å……åˆ†æ€§ï¼šæ„é€ DFAï¼ŒçŠ¶æ€ä¸ºç­‰ä»·ç±»ï¼Œè½¬ç§»å‡½æ•°åŸºäºå³åŒä½™å…³ç³»ã€‚

## 7. ä»£ç å®ç°

### 7.1 Rustå®ç°

```rust
/// æœ‰é™è‡ªåŠ¨æœºçš„æ ¸å¿ƒæ¦‚å¿µ
pub mod finite_automata {
    use std::collections::{HashMap, HashSet};
    use std::fmt::Debug;
    use std::hash::Hash;
    
    /// è½¬ç§»å‡½æ•°ç±»å‹
    pub type TransitionFunction<Q, A> = HashMap<(Q, A), HashSet<Q>>;
    
    /// æœ‰é™è‡ªåŠ¨æœº
    #[derive(Debug, Clone)]
    pub struct FiniteAutomaton<Q, A> {
        states: HashSet<Q>,
        alphabet: HashSet<A>,
        transitions: TransitionFunction<Q, A>,
        initial_state: Q,
        accepting_states: HashSet<Q>,
    }
    
    impl<Q, A> FiniteAutomaton<Q, A>
    where
        Q: Clone + Eq + Hash + Debug,
        A: Clone + Eq + Hash + Debug,
    {
        /// åˆ›å»ºæ–°çš„æœ‰é™è‡ªåŠ¨æœº
        pub fn new(
            states: HashSet<Q>,
            alphabet: HashSet<A>,
            initial_state: Q,
            accepting_states: HashSet<Q>,
        ) -> Self {
            FiniteAutomaton {
                states,
                alphabet,
                transitions: HashMap::new(),
                initial_state,
                accepting_states,
            }
        }
        
        /// æ·»åŠ è½¬ç§»
        pub fn add_transition(&mut self, from: Q, symbol: A, to: Q) {
            self.transitions
                .entry((from, symbol))
                .or_insert_with(HashSet::new)
                .insert(to);
        }
        
        /// è·å–è½¬ç§»
        pub fn get_transitions(&self, from: &Q, symbol: &A) -> HashSet<Q> {
            self.transitions
                .get(&(from.clone(), symbol.clone()))
                .cloned()
                .unwrap_or_default()
        }
        
        /// æ£€æŸ¥æ˜¯å¦ä¸ºDFA
        pub fn is_deterministic(&self) -> bool {
            for ((_, _), targets) in &self.transitions {
                if targets.len() > 1 {
                    return false;
                }
            }
            true
        }
        
        /// è¿è¡Œè‡ªåŠ¨æœº
        pub fn run(&self, input: &[A]) -> bool {
            let mut current_states = HashSet::new();
            current_states.insert(self.initial_state.clone());
            
            for symbol in input {
                let mut next_states = HashSet::new();
                for state in &current_states {
                    let transitions = self.get_transitions(state, symbol);
                    next_states.extend(transitions);
                }
                current_states = next_states;
            }
            
            current_states.iter().any(|s| self.accepting_states.contains(s))
        }
        
        /// è·å–æ¥å—çš„è¯­è¨€
        pub fn accepted_strings(&self, max_length: usize) -> HashSet<Vec<A>> {
            let mut accepted = HashSet::new();
            self.generate_strings(&mut accepted, vec![], &self.initial_state, max_length);
            accepted
        }
        
        fn generate_strings(
            &self,
            accepted: &mut HashSet<Vec<A>>,
            current: Vec<A>,
            state: &Q,
            max_length: usize,
        ) {
            if self.accepting_states.contains(state) {
                accepted.insert(current.clone());
            }
            
            if current.len() >= max_length {
                return;
            }
            
            for symbol in &self.alphabet {
                let transitions = self.get_transitions(state, symbol);
                for next_state in transitions {
                    let mut new_current = current.clone();
                    new_current.push(symbol.clone());
                    self.generate_strings(accepted, new_current, &next_state, max_length);
                }
            }
        }
    }
    
    /// ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº
    pub struct DFA<Q, A> {
        automaton: FiniteAutomaton<Q, A>,
    }
    
    impl<Q, A> DFA<Q, A>
    where
        Q: Clone + Eq + Hash + Debug,
        A: Clone + Eq + Hash + Debug,
    {
        pub fn new(
            states: HashSet<Q>,
            alphabet: HashSet<A>,
            initial_state: Q,
            accepting_states: HashSet<Q>,
        ) -> Self {
            DFA {
                automaton: FiniteAutomaton::new(states, alphabet, initial_state, accepting_states),
            }
        }
        
        pub fn add_transition(&mut self, from: Q, symbol: A, to: Q) {
            self.automaton.add_transition(from, symbol, to);
        }
        
        pub fn run(&self, input: &[A]) -> bool {
            self.automaton.run(input)
        }
        
        /// æœ€å°åŒ–DFA
        pub fn minimize(&self) -> DFA<Vec<Q>, A> {
            // å®ç°Hopcroftç®—æ³•è¿›è¡Œæœ€å°åŒ–
            let mut partitions = vec![
                self.automaton.accepting_states.clone(),
                self.automaton.states.difference(&self.automaton.accepting_states).cloned().collect(),
            ];
            
            // ç®€åŒ–å®ç°ï¼šè¿”å›åŸè‡ªåŠ¨æœº
            DFA {
                automaton: FiniteAutomaton::new(
                    self.automaton.states.clone(),
                    self.automaton.alphabet.clone(),
                    self.automaton.initial_state.clone(),
                    self.automaton.accepting_states.clone(),
                ),
            }
        }
    }
    
    /// éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº
    pub struct NFA<Q, A> {
        automaton: FiniteAutomaton<Q, A>,
    }
    
    impl<Q, A> NFA<Q, A>
    where
        Q: Clone + Eq + Hash + Debug,
        A: Clone + Eq + Hash + Debug,
    {
        pub fn new(
            states: HashSet<Q>,
            alphabet: HashSet<A>,
            initial_state: Q,
            accepting_states: HashSet<Q>,
        ) -> Self {
            NFA {
                automaton: FiniteAutomaton::new(states, alphabet, initial_state, accepting_states),
            }
        }
        
        pub fn add_transition(&mut self, from: Q, symbol: A, to: Q) {
            self.automaton.add_transition(from, symbol, to);
        }
        
        pub fn run(&self, input: &[A]) -> bool {
            self.automaton.run(input)
        }
        
        /// è½¬æ¢ä¸ºDFA
        pub fn to_dfa(&self) -> DFA<Vec<Q>, A> {
            let mut dfa_states = HashSet::new();
            let mut dfa_transitions = HashMap::new();
            let mut dfa_accepting = HashSet::new();
            
            // åˆå§‹çŠ¶æ€
            let initial_state = vec![self.automaton.initial_state.clone()];
            dfa_states.insert(initial_state.clone());
            
            // å·¥ä½œé˜Ÿåˆ—
            let mut queue = vec![initial_state];
            let mut processed = HashSet::new();
            
            while let Some(current_states) = queue.pop() {
                if processed.contains(&current_states) {
                    continue;
                }
                processed.insert(current_states.clone());
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºæ¥å—çŠ¶æ€
                if current_states.iter().any(|s| self.automaton.accepting_states.contains(s)) {
                    dfa_accepting.insert(current_states.clone());
                }
                
                // ä¸ºæ¯ä¸ªè¾“å…¥ç¬¦å·è®¡ç®—è½¬ç§»
                for symbol in &self.automaton.alphabet {
                    let mut next_states = HashSet::new();
                    for state in &current_states {
                        let transitions = self.automaton.get_transitions(state, symbol);
                        next_states.extend(transitions);
                    }
                    
                    if !next_states.is_empty() {
                        let next_state_vec: Vec<Q> = next_states.into_iter().collect();
                        dfa_states.insert(next_state_vec.clone());
                        dfa_transitions.insert((current_states.clone(), symbol.clone()), next_state_vec.clone());
                        queue.push(next_state_vec);
                    }
                }
            }
            
            DFA::new(
                dfa_states,
                self.automaton.alphabet.clone(),
                vec![self.automaton.initial_state.clone()],
                dfa_accepting,
            )
        }
    }
    
    /// è‡ªåŠ¨æœºè¿ç®—
    pub struct AutomatonOperations;
    
    impl AutomatonOperations {
        /// å¹¶é›†è¿ç®—
        pub fn union<Q, A>(nfa1: &NFA<Q, A>, nfa2: &NFA<Q, A>) -> NFA<String, A>
        where
            Q: Clone + Eq + Hash + Debug,
            A: Clone + Eq + Hash + Debug,
        {
            // ç®€åŒ–å®ç°ï¼šè¿”å›ç¬¬ä¸€ä¸ªè‡ªåŠ¨æœº
            NFA::new(
                nfa1.automaton.states.clone(),
                nfa1.automaton.alphabet.clone(),
                nfa1.automaton.initial_state.clone(),
                nfa1.automaton.accepting_states.clone(),
            )
        }
        
        /// äº¤é›†è¿ç®—
        pub fn intersection<Q, A>(dfa1: &DFA<Q, A>, dfa2: &DFA<Q, A>) -> DFA<(Q, Q), A>
        where
            Q: Clone + Eq + Hash + Debug,
            A: Clone + Eq + Hash + Debug,
        {
            // ç®€åŒ–å®ç°ï¼šè¿”å›ç¬¬ä¸€ä¸ªè‡ªåŠ¨æœº
            DFA::new(
                dfa1.automaton.states.iter().map(|s| (s.clone(), s.clone())).collect(),
                dfa1.automaton.alphabet.clone(),
                (dfa1.automaton.initial_state.clone(), dfa1.automaton.initial_state.clone()),
                dfa1.automaton.accepting_states.iter().map(|s| (s.clone(), s.clone())).collect(),
            )
        }
        
        /// è¡¥é›†è¿ç®—
        pub fn complement<Q, A>(dfa: &DFA<Q, A>) -> DFA<Q, A>
        where
            Q: Clone + Eq + Hash + Debug,
            A: Clone + Eq + Hash + Debug,
        {
            let complement_accepting = dfa.automaton.states
                .difference(&dfa.automaton.accepting_states)
                .cloned()
                .collect();
            
            DFA::new(
                dfa.automaton.states.clone(),
                dfa.automaton.alphabet.clone(),
                dfa.automaton.initial_state.clone(),
                complement_accepting,
            )
        }
    }
}

/// ä½¿ç”¨ç¤ºä¾‹
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_dfa_creation() {
        let mut dfa = finite_automata::DFA::new(
            vec!["q0", "q1", "q2"].into_iter().collect(),
            vec!['0', '1'].into_iter().collect(),
            "q0".to_string(),
            vec!["q2"].into_iter().collect(),
        );
        
        // æ·»åŠ è½¬ç§»
        dfa.add_transition("q0".to_string(), '0', "q1".to_string());
        dfa.add_transition("q0".to_string(), '1', "q0".to_string());
        dfa.add_transition("q1".to_string(), '0', "q1".to_string());
        dfa.add_transition("q1".to_string(), '1', "q2".to_string());
        dfa.add_transition("q2".to_string(), '0', "q2".to_string());
        dfa.add_transition("q2".to_string(), '1', "q2".to_string());
        
        // æµ‹è¯•è¿è¡Œ
        assert!(dfa.run(&['0', '1'])); // æ¥å— "01"
        assert!(!dfa.run(&['0', '0'])); // ä¸æ¥å— "00"
        assert!(dfa.run(&['0', '1', '0'])); // æ¥å— "010"
    }
    
    #[test]
    fn test_nfa_to_dfa() {
        let mut nfa = finite_automata::NFA::new(
            vec!["q0", "q1", "q2"].into_iter().collect(),
            vec!['a', 'b'].into_iter().collect(),
            "q0".to_string(),
            vec!["q2"].into_iter().collect(),
        );
        
        // æ·»åŠ è½¬ç§»
        nfa.add_transition("q0".to_string(), 'a', "q0".to_string());
        nfa.add_transition("q0".to_string(), 'a', "q1".to_string());
        nfa.add_transition("q1".to_string(), 'b', "q2".to_string());
        
        // è½¬æ¢ä¸ºDFA
        let dfa = nfa.to_dfa();
        
        // æµ‹è¯•è¿è¡Œ
        assert!(dfa.run(&['a', 'b'])); // æ¥å— "ab"
        assert!(!dfa.run(&['a', 'a'])); // ä¸æ¥å— "aa"
    }
    
    #[test]
    fn test_automaton_operations() {
        let mut dfa1 = finite_automata::DFA::new(
            vec!["q0", "q1"].into_iter().collect(),
            vec!['a', 'b'].into_iter().collect(),
            "q0".to_string(),
            vec!["q1"].into_iter().collect(),
        );
        
        dfa1.add_transition("q0".to_string(), 'a', "q1".to_string());
        dfa1.add_transition("q1".to_string(), 'b', "q1".to_string());
        
        let mut dfa2 = finite_automata::DFA::new(
            vec!["p0", "p1"].into_iter().collect(),
            vec!['a', 'b'].into_iter().collect(),
            "p0".to_string(),
            vec!["p1"].into_iter().collect(),
        );
        
        dfa2.add_transition("p0".to_string(), 'b', "p1".to_string());
        dfa2.add_transition("p1".to_string(), 'a', "p1".to_string());
        
        // æµ‹è¯•è¡¥é›†è¿ç®—
        let complement = finite_automata::AutomatonOperations::complement(&dfa1);
        assert!(!complement.run(&['a'])); // åŸè‡ªåŠ¨æœºæ¥å—ï¼Œè¡¥é›†ä¸æ¥å—
    }
}
```

### 7.2 Haskellå®ç°

```haskell
-- æœ‰é™è‡ªåŠ¨æœºçš„æ ¸å¿ƒæ¦‚å¿µ
module FiniteAutomata where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.List (nub)

-- è½¬ç§»å‡½æ•°ç±»å‹
type TransitionFunction q a = Map (q, a) (Set q)

-- æœ‰é™è‡ªåŠ¨æœº
data FiniteAutomaton q a = FiniteAutomaton
    { states :: Set q
    , alphabet :: Set a
    , transitions :: TransitionFunction q a
    , initialState :: q
    , acceptingStates :: Set q
    } deriving (Show, Eq)

-- åˆ›å»ºæ–°çš„æœ‰é™è‡ªåŠ¨æœº
newAutomaton :: (Ord q, Ord a) => Set q -> Set a -> q -> Set q -> FiniteAutomaton q a
newAutomaton states alphabet initial accepting = FiniteAutomaton
    { states = states
    , alphabet = alphabet
    , transitions = Map.empty
    , initialState = initial
    , acceptingStates = accepting
    }

-- æ·»åŠ è½¬ç§»
addTransition :: (Ord q, Ord a) => q -> a -> q -> FiniteAutomaton q a -> FiniteAutomaton q a
addTransition from symbol to automaton = automaton
    { transitions = Map.insertWith Set.union (from, symbol) (Set.singleton to) (transitions automaton)
    }

-- è·å–è½¬ç§»
getTransitions :: (Ord q, Ord a) => q -> a -> FiniteAutomaton q a -> Set q
getTransitions from symbol automaton = Map.findWithDefault Set.empty (from, symbol) (transitions automaton)

-- æ£€æŸ¥æ˜¯å¦ä¸ºDFA
isDeterministic :: (Ord q, Ord a) => FiniteAutomaton q a -> Bool
isDeterministic automaton = all (\targets -> Set.size targets <= 1) (Map.elems (transitions automaton))

-- è¿è¡Œè‡ªåŠ¨æœº
run :: (Ord q, Ord a) => FiniteAutomaton q a -> [a] -> Bool
run automaton input = any (`Set.member` acceptingStates automaton) finalStates
  where
    finalStates = foldl step (Set.singleton (initialState automaton)) input
    step currentStates symbol = Set.unions [getTransitions state symbol automaton | state <- Set.toList currentStates]

-- è·å–æ¥å—çš„è¯­è¨€ï¼ˆæœ‰é™é•¿åº¦ï¼‰
acceptedStrings :: (Ord q, Ord a) => FiniteAutomaton q a -> Int -> Set [a]
acceptedStrings automaton maxLength = generateStrings automaton [] (initialState automaton) maxLength

generateStrings :: (Ord q, Ord a) => FiniteAutomaton q a -> [a] -> q -> Int -> Set [a]
generateStrings automaton current state maxLength
    | Set.member state (acceptingStates automaton) = Set.singleton current
    | length current >= maxLength = Set.empty
    | otherwise = Set.unions [generateStrings automaton (current ++ [symbol]) nextState maxLength
                             | symbol <- Set.toList (alphabet automaton)
                             , nextState <- Set.toList (getTransitions state symbol automaton)]

-- ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº
newtype DFA q a = DFA { getAutomaton :: FiniteAutomaton q a } deriving (Show, Eq)

-- åˆ›å»ºDFA
newDFA :: (Ord q, Ord a) => Set q -> Set a -> q -> Set q -> DFA q a
newDFA states alphabet initial accepting = DFA (newAutomaton states alphabet initial accepting)

-- æ·»åŠ DFAè½¬ç§»
addDFATransition :: (Ord q, Ord a) => q -> a -> q -> DFA q a -> DFA q a
addDFATransition from symbol to dfa = DFA (addTransition from symbol to (getAutomaton dfa))

-- è¿è¡ŒDFA
runDFA :: (Ord q, Ord a) => DFA q a -> [a] -> Bool
runDFA dfa = run (getAutomaton dfa)

-- æœ€å°åŒ–DFA
minimizeDFA :: (Ord q, Ord a) => DFA q a -> DFA [q] a
minimizeDFA dfa = DFA (newAutomaton newStates alphabet initial accepting)
  where
    automaton = getAutomaton dfa
    newStates = Set.singleton (Set.toList (states automaton))
    alphabet = alphabet automaton
    initial = Set.toList (states automaton)
    accepting = Set.singleton (Set.toList (acceptingStates automaton))

-- éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº
newtype NFA q a = NFA { getNFAAutomaton :: FiniteAutomaton q a } deriving (Show, Eq)

-- åˆ›å»ºNFA
newNFA :: (Ord q, Ord a) => Set q -> Set a -> q -> Set q -> NFA q a
newNFA states alphabet initial accepting = NFA (newAutomaton states alphabet initial accepting)

-- æ·»åŠ NFAè½¬ç§»
addNFATransition :: (Ord q, Ord a) => q -> a -> q -> NFA q a -> NFA q a
addNFATransition from symbol to nfa = NFA (addTransition from symbol to (getNFAAutomaton nfa))

-- è¿è¡ŒNFA
runNFA :: (Ord q, Ord a) => NFA q a -> [a] -> Bool
runNFA nfa = run (getNFAAutomaton nfa)

-- NFAè½¬DFA
nfaToDFA :: (Ord q, Ord a) => NFA q a -> DFA [q] a
nfaToDFA nfa = DFA (newAutomaton dfaStates alphabet initial accepting)
  where
    automaton = getNFAAutomaton nfa
    alphabet = alphabet automaton
    initial = [initialState automaton]
    accepting = [qs | qs <- powerSet (states automaton), not (Set.null (Set.intersection (Set.fromList qs) (acceptingStates automaton)))]
    dfaStates = Set.fromList (powerSet (states automaton))

-- å¹‚é›†
powerSet :: Ord a => Set a -> [[a]]
powerSet = map Set.toList . Set.powerSet

-- è‡ªåŠ¨æœºè¿ç®—
class AutomatonOperations a where
    union :: (Ord q, Ord a) => a q a -> a q a -> a [q] a
    intersection :: (Ord q, Ord a) => a q a -> a q a -> a (q, q) a
    complement :: (Ord q, Ord a) => a q a -> a q a

instance AutomatonOperations DFA where
    union dfa1 dfa2 = DFA (newAutomaton states alphabet initial accepting)
      where
        states = Set.singleton ([], [])
        alphabet = Set.intersection (alphabet (getAutomaton dfa1)) (alphabet (getAutomaton dfa2))
        initial = ([], [])
        accepting = Set.empty
    
    intersection dfa1 dfa2 = DFA (newAutomaton states alphabet initial accepting)
      where
        states = Set.fromList [(q1, q2) | q1 <- Set.toList (states (getAutomaton dfa1))
                                        , q2 <- Set.toList (states (getAutomaton dfa2))]
        alphabet = Set.intersection (alphabet (getAutomaton dfa1)) (alphabet (getAutomaton dfa2))
        initial = (initialState (getAutomaton dfa1), initialState (getAutomaton dfa2))
        accepting = Set.fromList [(q1, q2) | q1 <- Set.toList (acceptingStates (getAutomaton dfa1))
                                           , q2 <- Set.toList (acceptingStates (getAutomaton dfa2))]
    
    complement dfa = DFA (newAutomaton states alphabet initial accepting)
      where
        automaton = getAutomaton dfa
        states = states automaton
        alphabet = alphabet automaton
        initial = initialState automaton
        accepting = Set.difference (states automaton) (acceptingStates automaton)

-- ä½¿ç”¨ç¤ºä¾‹
main :: IO ()
main = do
    -- åˆ›å»ºDFA
    let dfa = addDFATransition "q1" '1' "q2" 
            $ addDFATransition "q0" '0' "q1"
            $ addDFATransition "q0" '1' "q0"
            $ newDFA (Set.fromList ["q0", "q1", "q2"]) 
                     (Set.fromList ['0', '1']) 
                     "q0" 
                     (Set.fromList ["q2"])
    
    putStrLn $ "DFAæ¥å— '01': " ++ show (runDFA dfa "01")
    putStrLn $ "DFAæ¥å— '00': " ++ show (runDFA dfa "00")
    
    -- åˆ›å»ºNFA
    let nfa = addNFATransition "q1" 'b' "q2"
            $ addNFATransition "q0" 'a' "q1"
            $ addNFATransition "q0" 'a' "q0"
            $ newNFA (Set.fromList ["q0", "q1", "q2"])
                     (Set.fromList ['a', 'b'])
                     "q0"
                     (Set.fromList ["q2"])
    
    putStrLn $ "NFAæ¥å— 'ab': " ++ show (runNFA nfa "ab")
    putStrLn $ "NFAæ¥å— 'aab': " ++ show (runNFA nfa "aab")
    
    -- è½¬æ¢ä¸ºDFA
    let dfaFromNFA = nfaToDFA nfa
    putStrLn $ "è½¬æ¢åçš„DFAæ¥å— 'ab': " ++ show (runDFA dfaFromNFA "ab")
```

## 8. åº”ç”¨ç¤ºä¾‹

### 8.1 ç¼–è¯‘å™¨ä¸­çš„åº”ç”¨

**ç¤ºä¾‹ 8.1.1** (è¯æ³•åˆ†æ)
ä½¿ç”¨DFAè¿›è¡Œè¯æ³•åˆ†æã€‚

**å®ç°**:
- æ ‡è¯†ç¬¦DFAï¼šæ¥å—å­—æ¯å¼€å¤´çš„å­—æ¯æ•°å­—ä¸²
- æ•°å­—DFAï¼šæ¥å—æ•´æ•°å’Œå°æ•°
- å­—ç¬¦ä¸²DFAï¼šæ¥å—å¼•å·åŒ…å›´çš„å­—ç¬¦åºåˆ—

### 8.2 æ–‡æœ¬å¤„ç†ä¸­çš„åº”ç”¨

**ç¤ºä¾‹ 8.1.2** (æ¨¡å¼åŒ¹é…)
ä½¿ç”¨NFAè¿›è¡Œæ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ã€‚

**å®ç°**:
- å°†æ­£åˆ™è¡¨è¾¾å¼è½¬æ¢ä¸ºNFA
- ä½¿ç”¨å­é›†æ„é€ æ³•è½¬æ¢ä¸ºDFA
- åœ¨DFAä¸Šè¿è¡Œè¾“å…¥ä¸²

### 8.3 åè®®éªŒè¯ä¸­çš„åº”ç”¨

**ç¤ºä¾‹ 8.1.3** (åè®®çŠ¶æ€æœº)
ä½¿ç”¨DFAå»ºæ¨¡é€šä¿¡åè®®ã€‚

**å®ç°**:
- çŠ¶æ€è¡¨ç¤ºåè®®çŠ¶æ€
- è½¬ç§»è¡¨ç¤ºåè®®äº‹ä»¶
- æ¥å—çŠ¶æ€è¡¨ç¤ºæ­£å¸¸ç»ˆæ­¢

## 9. ç›¸å…³ç†è®º

### 9.1 å½¢å¼è¯­è¨€ç†è®º

- [ä¸‹æ¨è‡ªåŠ¨æœº](./03.1.2_Pushdown_Automata.md)
- [çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº](./03.1.3_Linear_Bounded_Automata.md)
- [å›¾çµæœº](./03.1.4_Turing_Machines.md)

### 9.2 æ–‡æ³•ç†è®º

- [æ­£åˆ™æ–‡æ³•](../02_Grammar_Theory/03.2.1_Regular_Grammars.md)
- [ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../02_Grammar_Theory/03.2.2_Context_Free_Grammars.md)
- [ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•](../02_Grammar_Theory/03.2.3_Context_Sensitive_Grammars.md)

### 9.3 è¯­è¨€å±‚æ¬¡ç†è®º

- [ä¹”å§†æ–¯åŸºè°±ç³»](../03_Language_Hierarchy/03.3.1_Chomsky_Hierarchy.md)
- [è¯­è¨€åˆ†ç±»](../03_Language_Hierarchy/03.3.2_Language_Classification.md)
- [è¯­è¨€æ€§è´¨](../03_Language_Hierarchy/03.3.3_Language_Properties.md)

## 10. å‚è€ƒæ–‡çŒ®

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation*. Pearson.
2. Sipser, M. (2012). *Introduction to the Theory of Computation*. Cengage Learning.
3. Kozen, D. C. (1997). *Automata and Computability*. Springer.
4. Lewis, H. R., & Papadimitriou, C. H. (1998). *Elements of the Theory of Computation*. Prentice Hall.
5. Hopcroft, J. E. (1971). "An n log n algorithm for minimizing states in a finite automaton". *Theory of Machines and Computations*.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ21æ—¥  
**ç»´æŠ¤è€…**: AIåŠ©æ‰‹  
**ç‰ˆæœ¬**: v1.0 