# è‡ªåŠ¨æœºç†è®º (Automata Theory)

## ğŸ“š **ç›®å½•ç»“æ„**

```
01_Automata_Theory/
â”œâ”€â”€ README.md                           # å½“å‰æ–‡ä»¶ - è‡ªåŠ¨æœºç†è®ºæ€»è§ˆ
â”œâ”€â”€ 01_Finite_Automata/                 # æœ‰é™è‡ªåŠ¨æœº
â”‚   â”œâ”€â”€ 01_DFA.md                       # ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº
â”‚   â”œâ”€â”€ 02_NFA.md                       # éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº
â”‚   â””â”€â”€ 03_Automata_Equivalence.md      # è‡ªåŠ¨æœºç­‰ä»·æ€§
â”œâ”€â”€ 02_Pushdown_Automata/               # ä¸‹æ¨è‡ªåŠ¨æœº
â”‚   â”œâ”€â”€ 01_PDA.md                       # ä¸‹æ¨è‡ªåŠ¨æœºåŸºç¡€
â”‚   â”œâ”€â”€ 02_DPDA.md                      # ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº
â”‚   â””â”€â”€ 03_CFG_Equivalence.md           # ä¸ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ç­‰ä»·æ€§
â””â”€â”€ 03_Turing_Machines/                 # å›¾çµæœº
    â”œâ”€â”€ 01_Turing_Machine.md            # å›¾çµæœºåŸºç¡€
    â”œâ”€â”€ 02_Universal_TM.md              # é€šç”¨å›¾çµæœº
    â””â”€â”€ 03_Computability.md             # å¯è®¡ç®—æ€§ç†è®º
```

## ğŸ¯ **æ ¸å¿ƒä¸»é¢˜**

### 1. æœ‰é™è‡ªåŠ¨æœº (Finite Automata)
- [01_Finite_Automata/](01_Finite_Automata/) - æœ‰é™è‡ªåŠ¨æœºæ€»è§ˆ
  - [ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº](01_Finite_Automata/01_DFA.md) - DFAçš„å®šä¹‰ã€æ€§è´¨å’Œæ„é€ 
  - [éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº](01_Finite_Automata/02_NFA.md) - NFAçš„å®šä¹‰ã€æ€§è´¨å’Œæ„é€ 
  - [è‡ªåŠ¨æœºç­‰ä»·æ€§](01_Finite_Automata/03_Automata_Equivalence.md) - DFAä¸NFAçš„ç­‰ä»·æ€§è¯æ˜

### 2. ä¸‹æ¨è‡ªåŠ¨æœº (Pushdown Automata)
- [02_Pushdown_Automata/](02_Pushdown_Automata/) - ä¸‹æ¨è‡ªåŠ¨æœºæ€»è§ˆ
  - [ä¸‹æ¨è‡ªåŠ¨æœºåŸºç¡€](02_Pushdown_Automata/01_PDA.md) - PDAçš„å®šä¹‰ã€æ€§è´¨å’Œæ„é€ 
  - [ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº](02_Pushdown_Automata/02_DPDA.md) - DPDAçš„å®šä¹‰ã€æ€§è´¨å’Œé™åˆ¶
  - [ä¸ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ç­‰ä»·æ€§](02_Pushdown_Automata/03_CFG_Equivalence.md) - PDAä¸CFGçš„ç­‰ä»·æ€§

### 3. å›¾çµæœº (Turing Machines)
- [03_Turing_Machines/](03_Turing_Machines/) - å›¾çµæœºæ€»è§ˆ
  - [å›¾çµæœºåŸºç¡€](03_Turing_Machines/01_Turing_Machine.md) - å›¾çµæœºçš„å®šä¹‰ã€æ€§è´¨å’Œæ„é€ 
  - [é€šç”¨å›¾çµæœº](03_Turing_Machines/02_Universal_TM.md) - é€šç”¨å›¾çµæœºçš„æ„é€ å’Œæ„ä¹‰
  - [å¯è®¡ç®—æ€§ç†è®º](03_Turing_Machines/03_Computability.md) - å¯è®¡ç®—æ€§ã€ä¸å¯åˆ¤å®šæ€§ã€åœæœºé—®é¢˜

## ğŸ“Š **ç†è®ºæ¡†æ¶**

### è‡ªåŠ¨æœºçš„åŸºæœ¬é—®é¢˜

1. **è®¡ç®—èƒ½åŠ›é—®é¢˜**
   - ä»€ä¹ˆè¯­è¨€å¯ä»¥è¢«è¯†åˆ«ï¼Ÿ
   - è®¡ç®—èƒ½åŠ›çš„å±‚æ¬¡ç»“æ„ï¼Ÿ
   - ä¸åŒè‡ªåŠ¨æœºçš„ç­‰ä»·æ€§ï¼Ÿ

2. **æ„é€ é—®é¢˜**
   - å¦‚ä½•æ„é€ è‡ªåŠ¨æœºï¼Ÿ
   - è‡ªåŠ¨æœºçš„ä¼˜åŒ–å’Œæœ€å°åŒ–ï¼Ÿ
   - è‡ªåŠ¨æœºçš„ç»„åˆå’Œå˜æ¢ï¼Ÿ

3. **åˆ¤å®šé—®é¢˜**
   - è¯­è¨€çš„å¯åˆ¤å®šæ€§ï¼Ÿ
   - è‡ªåŠ¨æœºçš„ç­‰ä»·æ€§åˆ¤å®šï¼Ÿ
   - åœæœºé—®é¢˜ï¼Ÿ

## ğŸ”— **å½¢å¼åŒ–è¡¨ç¤º**

### è‡ªåŠ¨æœºç±»å‹ç³»ç»Ÿ

```rust
// çŠ¶æ€ç±»å‹
type State = String;

// ç¬¦å·ç±»å‹
type Symbol = char;

// è½¬ç§»å‡½æ•°ç±»å‹
type Transition = (State, Symbol, State);

// æœ‰é™è‡ªåŠ¨æœºç‰¹å¾
trait FiniteAutomaton {
    /// è·å–æ‰€æœ‰çŠ¶æ€
    fn states(&self) -> Set<State>;
    
    /// è·å–å­—æ¯è¡¨
    fn alphabet(&self) -> Set<Symbol>;
    
    /// è·å–è½¬ç§»å‡½æ•°
    fn transitions(&self) -> Set<Transition>;
    
    /// è·å–åˆå§‹çŠ¶æ€
    fn initial_state(&self) -> State;
    
    /// è·å–æ¥å—çŠ¶æ€
    fn accepting_states(&self) -> Set<State>;
    
    /// åˆ¤æ–­æ˜¯å¦æ¥å—è¾“å…¥
    fn accepts(&self, input: &str) -> bool;
}

// ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº
struct DFA {
    states: Set<State>,
    alphabet: Set<Symbol>,
    transitions: Map<(State, Symbol), State>,
    initial_state: State,
    accepting_states: Set<State>,
}

impl FiniteAutomaton for DFA {
    fn states(&self) -> Set<State> {
        self.states.clone()
    }
    
    fn alphabet(&self) -> Set<Symbol> {
        self.alphabet.clone()
    }
    
    fn transitions(&self) -> Set<Transition> {
        self.transitions.iter()
            .map(|((from, symbol), to)| (*from, *symbol, *to))
            .collect()
    }
    
    fn initial_state(&self) -> State {
        self.initial_state.clone()
    }
    
    fn accepting_states(&self) -> Set<State> {
        self.accepting_states.clone()
    }
    
    fn accepts(&self, input: &str) -> bool {
        let mut current_state = self.initial_state.clone();
        
        for symbol in input.chars() {
            if let Some(next_state) = self.transitions.get(&(current_state.clone(), symbol)) {
                current_state = next_state.clone();
            } else {
                return false; // æ— è½¬ç§»
            }
        }
        
        self.accepting_states.contains(&current_state)
    }
}

// éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº
struct NFA {
    states: Set<State>,
    alphabet: Set<Symbol>,
    transitions: Map<(State, Symbol), Set<State>>,
    initial_state: State,
    accepting_states: Set<State>,
}

impl FiniteAutomaton for NFA {
    fn states(&self) -> Set<State> {
        self.states.clone()
    }
    
    fn alphabet(&self) -> Set<Symbol> {
        self.alphabet.clone()
    }
    
    fn transitions(&self) -> Set<Transition> {
        self.transitions.iter()
            .flat_map(|((from, symbol), to_states)| {
                to_states.iter().map(|to| (*from, *symbol, to.clone()))
            })
            .collect()
    }
    
    fn initial_state(&self) -> State {
        self.initial_state.clone()
    }
    
    fn accepting_states(&self) -> Set<State> {
        self.accepting_states.clone()
    }
    
    fn accepts(&self, input: &str) -> bool {
        let mut current_states = Set::new();
        current_states.insert(self.initial_state.clone());
        
        for symbol in input.chars() {
            let mut next_states = Set::new();
            for state in &current_states {
                if let Some(transitions) = self.transitions.get(&(state.clone(), symbol)) {
                    next_states.extend(transitions.clone());
                }
            }
            current_states = next_states;
            if current_states.is_empty() {
                return false;
            }
        }
        
        current_states.iter().any(|state| self.accepting_states.contains(state))
    }
}
```

### è‡ªåŠ¨æœºå…¬ç†ç³»ç»Ÿ

```haskell
-- è‡ªåŠ¨æœºç±»å‹ç±»
class Automaton a where
    states :: a -> Set State
    alphabet :: a -> Set Symbol
    initialState :: a -> State
    acceptingStates :: a -> Set State
    accepts :: a -> String -> Bool

-- ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº
data DFA = DFA
    { dfaStates :: Set State
    , dfaAlphabet :: Set Symbol
    , dfaTransitions :: Map (State, Symbol) State
    , dfaInitialState :: State
    , dfaAcceptingStates :: Set State
    }

-- éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº
data NFA = NFA
    { nfaStates :: Set State
    , nfaAlphabet :: Set Symbol
    , nfaTransitions :: Map (State, Symbol) (Set State)
    , nfaInitialState :: State
    , nfaAcceptingStates :: Set State
    }

-- è‡ªåŠ¨æœºå®ä¾‹
instance Automaton DFA where
    states = dfaStates
    alphabet = dfaAlphabet
    initialState = dfaInitialState
    acceptingStates = dfaAcceptingStates
    accepts dfa input = 
        let finalState = foldl (step dfa) (dfaInitialState dfa) input
        in finalState `member` (dfaAcceptingStates dfa)
      where
        step dfa state symbol = 
            case lookup (state, symbol) (dfaTransitions dfa) of
                Just nextState -> nextState
                Nothing -> state -- æ­»çŠ¶æ€
```

## ğŸ“ **æ ¸å¿ƒå®šç†**

### DFAä¸NFAç­‰ä»·æ€§å®šç†

**å®šç† 1.1** (DFA-NFAç­‰ä»·æ€§)
å¯¹äºä»»ä½•NFAï¼Œéƒ½å­˜åœ¨ä¸€ä¸ªç­‰ä»·çš„DFAã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š
$$\forall N \in \text{NFA} \exists D \in \text{DFA}(L(N) = L(D))$$

**è¯æ˜**ï¼š

1. **æ„é€ æ–¹æ³•**ï¼šå­é›†æ„é€ æ³•
2. **è¯æ˜æ­¥éª¤**ï¼š
   
   a) è®¾ $N = (Q_N, \Sigma, \delta_N, q_0, F_N)$ æ˜¯NFA
   
   b) æ„é€ DFA $D = (Q_D, \Sigma, \delta_D, q_0', F_D)$ å…¶ä¸­ï¼š
      - $Q_D = 2^{Q_N}$ (å¹‚é›†)
      - $q_0' = \{q_0\}$
      - $F_D = \{S \subseteq Q_N : S \cap F_N \neq \emptyset\}$
      - $\delta_D(S, a) = \bigcup_{q \in S} \delta_N(q, a)$
   
   c) è¯æ˜ $L(N) = L(D)$ï¼š
      - å¯¹äºä»»æ„è¾“å…¥ $w$ï¼Œ$D$ çš„çŠ¶æ€å¯¹åº” $N$ åœ¨ $w$ ä¸Šå¯èƒ½åˆ°è¾¾çš„çŠ¶æ€é›†åˆ
      - $D$ æ¥å— $w$ å½“ä¸”ä»…å½“ $N$ æ¥å— $w$

3. **ç»“è®º**ï¼šDFAä¸NFAç­‰ä»·

### è‡ªåŠ¨æœºæœ€å°åŒ–å®šç†

**å®šç† 1.2** (è‡ªåŠ¨æœºæœ€å°åŒ–)
å¯¹äºä»»ä½•DFAï¼Œéƒ½å­˜åœ¨ä¸€ä¸ªç­‰ä»·çš„æœ€å°DFAã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š
$$\forall D \in \text{DFA} \exists M \in \text{DFA}(L(D) = L(M) \land |M| \text{ is minimal})$$

**è¯æ˜**ï¼š

1. **æ„é€ æ–¹æ³•**ï¼šç­‰ä»·ç±»åˆ’åˆ†
2. **è¯æ˜æ­¥éª¤**ï¼š
   
   a) å®šä¹‰çŠ¶æ€ç­‰ä»·å…³ç³»ï¼š$p \equiv q$ å½“ä¸”ä»…å½“ $\forall w \in \Sigma^*(\delta^*(p, w) \in F \leftrightarrow \delta^*(q, w) \in F)$
   
   b) æ„é€ ç­‰ä»·ç±»ï¼š$[q] = \{p : p \equiv q\}$
   
   c) æ„é€ æœ€å°DFAï¼šçŠ¶æ€ä¸ºç­‰ä»·ç±»ï¼Œè½¬ç§»ä¸º $\delta([q], a) = [\delta(q, a)]$
   
   d) è¯æ˜æœ€å°æ€§ï¼šä»»ä½•æ›´å°çš„DFAéƒ½æ— æ³•è¯†åˆ«ç›¸åŒè¯­è¨€

3. **ç»“è®º**ï¼šæœ€å°DFAå­˜åœ¨ä¸”å”¯ä¸€

### æ³µå¼•ç†

**å®šç† 1.3** (æ­£åˆ™è¯­è¨€æ³µå¼•ç†)
å¦‚æœ $L$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œåˆ™å­˜åœ¨å¸¸æ•° $p$ ä½¿å¾—å¯¹äºä»»æ„ $w \in L$ ä¸” $|w| \geq p$ï¼Œå­˜åœ¨åˆ†è§£ $w = xyz$ æ»¡è¶³ï¼š
1. $|xy| \leq p$
2. $|y| > 0$
3. $\forall i \geq 0(xy^i z \in L)$

**è¯æ˜**ï¼š

1. **æ„é€ **ï¼šè®¾ $D$ æ˜¯è¯†åˆ« $L$ çš„DFAï¼Œ$p = |Q|$
2. **è¯æ˜æ­¥éª¤**ï¼š
   
   a) å¯¹äº $w \in L$ ä¸” $|w| \geq p$ï¼Œè€ƒè™‘ $D$ åœ¨ $w$ ä¸Šçš„è®¡ç®—è·¯å¾„
   
   b) æ ¹æ®é¸½å·¢åŸç†ï¼Œè·¯å¾„ä¸­å¿…æœ‰é‡å¤çŠ¶æ€
   
   c) è®¾é‡å¤çŠ¶æ€ä¸º $q$ï¼Œå¯¹åº”å­ä¸² $y$
   
   d) åˆ™ $xy^i z$ å¯¹åº”ç»•è¿‡ $y$ çš„è·¯å¾„ï¼Œä»åœ¨ $L$ ä¸­

3. **åº”ç”¨**ï¼šç”¨äºè¯æ˜è¯­è¨€éæ­£åˆ™æ€§

## ğŸ”§ **è¯æ˜ç³»ç»Ÿ**

### è‡ªåŠ¨æœºè¯æ˜è§„åˆ™

**è§„åˆ™ 1.1** (æ„é€ è§„åˆ™)
é€šè¿‡æ„é€ è¯æ˜å­˜åœ¨æ€§ã€‚

$$\frac{\text{æ„é€ æ–¹æ³•}}{\exists A \in \text{Automaton}(P(A))} \quad \text{(æ„é€ )}$$

**è§„åˆ™ 1.2** (ç­‰ä»·æ€§è§„åˆ™)
é€šè¿‡åŒå‘åŒ…å«è¯æ˜ç­‰ä»·æ€§ã€‚

$$\frac{L(A) \subseteq L(B) \quad L(B) \subseteq L(A)}{L(A) = L(B)} \quad \text{(ç­‰ä»·æ€§)}$$

**è§„åˆ™ 1.3** (æ³µå¼•ç†è§„åˆ™)
ä½¿ç”¨æ³µå¼•ç†è¯æ˜éæ­£åˆ™æ€§ã€‚

$$\frac{\text{æ³µå¼•ç†çŸ›ç›¾}}{L \notin \text{REG}} \quad \text{(æ³µå¼•ç†)}$$

### è¯æ˜ç¤ºä¾‹

**ç¤ºä¾‹ 1.1**ï¼šè¯æ˜ $L = \{a^n b^n : n \geq 0\}$ ä¸æ˜¯æ­£åˆ™è¯­è¨€ã€‚

**è¯æ˜**ï¼š

1. **å‡è®¾**ï¼š$L$ æ˜¯æ­£åˆ™è¯­è¨€
2. **åº”ç”¨æ³µå¼•ç†**ï¼šè®¾æ³µå¼•ç†å¸¸æ•°ä¸º $p$
3. **é€‰æ‹©å­—ç¬¦ä¸²**ï¼š$w = a^p b^p \in L$
4. **åˆ†è§£**ï¼š$w = xyz$ æ»¡è¶³æ³µå¼•ç†æ¡ä»¶
5. **åˆ†æ**ï¼š
   - ç”±äº $|xy| \leq p$ï¼Œ$y$ åªåŒ…å« $a$
   - è®¾ $y = a^k$ï¼Œ$k > 0$
   - åˆ™ $xy^2 z = a^{p+k} b^p \notin L$
6. **çŸ›ç›¾**ï¼šä¸æ³µå¼•ç†çŸ›ç›¾
7. **ç»“è®º**ï¼š$L$ ä¸æ˜¯æ­£åˆ™è¯­è¨€

## ğŸ’» **åº”ç”¨ç¤ºä¾‹**

### ç¼–è¯‘å™¨ä¸­çš„åº”ç”¨

```rust
// è¯æ³•åˆ†æå™¨ä¸­çš„DFA
struct LexicalAnalyzer {
    dfa: DFA,
    keywords: Set<String>,
}

impl LexicalAnalyzer {
    fn new() -> Self {
        // æ„é€ è¯†åˆ«æ ‡è¯†ç¬¦ã€æ•°å­—ã€è¿ç®—ç¬¦ç­‰çš„DFA
        let dfa = Self::build_lexical_dfa();
        let keywords = Self::load_keywords();
        Self { dfa, keywords }
    }
    
    fn tokenize(&self, input: &str) -> Vec<Token> {
        let mut tokens = Vec::new();
        let mut current = String::new();
        
        for ch in input.chars() {
            if self.dfa.accepts(&format!("{}{}", current, ch)) {
                current.push(ch);
            } else {
                if !current.is_empty() {
                    tokens.push(self.create_token(&current));
                    current.clear();
                }
                current.push(ch);
            }
        }
        
        if !current.is_empty() {
            tokens.push(self.create_token(&current));
        }
        
        tokens
    }
    
    fn create_token(&self, lexeme: &str) -> Token {
        if self.keywords.contains(lexeme) {
            Token::Keyword(lexeme.to_string())
        } else if self.dfa.accepts(lexeme) {
            Token::Identifier(lexeme.to_string())
        } else {
            Token::Error(lexeme.to_string())
        }
    }
}
```

### ç½‘ç»œåè®®ä¸­çš„åº”ç”¨

```rust
// åè®®çŠ¶æ€æœº
struct ProtocolStateMachine {
    current_state: ProtocolState,
    transitions: Map<(ProtocolState, Event), ProtocolState>,
}

impl ProtocolStateMachine {
    fn new() -> Self {
        let transitions = Self::build_protocol_transitions();
        Self {
            current_state: ProtocolState::Idle,
            transitions,
        }
    }
    
    fn process_event(&mut self, event: Event) -> Result<(), ProtocolError> {
        let key = (self.current_state.clone(), event.clone());
        
        if let Some(next_state) = self.transitions.get(&key) {
            self.current_state = next_state.clone();
            Ok(())
        } else {
            Err(ProtocolError::InvalidTransition {
                from: self.current_state.clone(),
                event,
            })
        }
    }
    
    fn is_accepting(&self) -> bool {
        matches!(self.current_state, ProtocolState::Completed)
    }
}
```

## ğŸ”„ **ä¸å…¶ä»–ç†è®ºçš„å…³è”**

### ä¸æ–‡æ³•ç†è®ºçš„å…³è”

- **DFA â†” æ­£åˆ™æ–‡æ³•**ï¼šDFAè¯†åˆ«çš„è¯­è¨€ç­‰ä»·äºæ­£åˆ™æ–‡æ³•ç”Ÿæˆçš„è¯­è¨€
- **PDA â†” ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•**ï¼šPDAè¯†åˆ«çš„è¯­è¨€ç­‰ä»·äºCFGç”Ÿæˆçš„è¯­è¨€
- **å›¾çµæœº â†” æ— é™åˆ¶æ–‡æ³•**ï¼šå›¾çµæœºè¯†åˆ«çš„è¯­è¨€ç­‰ä»·äº0å‹æ–‡æ³•ç”Ÿæˆçš„è¯­è¨€

### ä¸è®¡ç®—ç†è®ºçš„å…³è”

- **è‡ªåŠ¨æœº â†” è®¡ç®—æ¨¡å‹**ï¼šè‡ªåŠ¨æœºæ˜¯æŠ½è±¡çš„è®¡ç®—æ¨¡å‹
- **å¯è®¡ç®—æ€§ â†” å›¾çµæœº**ï¼šå›¾çµæœºå®šä¹‰äº†å¯è®¡ç®—æ€§çš„æ ‡å‡†
- **å¤æ‚æ€§ â†” è‡ªåŠ¨æœº**ï¼šä¸åŒè‡ªåŠ¨æœºå¯¹åº”ä¸åŒçš„è®¡ç®—å¤æ‚æ€§

### ä¸å½¢å¼ç§‘å­¦çš„å…³è”

- **è‡ªåŠ¨æœº â†” ç±»å‹ç³»ç»Ÿ**ï¼šè‡ªåŠ¨æœºå¯ä»¥ç”¨äºç±»å‹æ£€æŸ¥
- **è‡ªåŠ¨æœº â†” æ¨¡å‹æ£€æŸ¥**ï¼šè‡ªåŠ¨æœºç”¨äºç³»ç»ŸéªŒè¯
- **è‡ªåŠ¨æœº â†” è¯­è¨€å¤„ç†**ï¼šè‡ªåŠ¨æœºæ˜¯è¯­è¨€å¤„ç†çš„åŸºç¡€

## ğŸš€ **å¿«é€Ÿå¯¼èˆª**

### æ ¸å¿ƒæ¦‚å¿µ
- [DFAåŸºç¡€](01_Finite_Automata/01_DFA.md)
- [NFAåŸºç¡€](01_Finite_Automata/02_NFA.md)
- [å›¾çµæœºåŸºç¡€](03_Turing_Machines/01_Turing_Machine.md)

### åº”ç”¨é¢†åŸŸ
- [ç¼–è¯‘å™¨è®¾è®¡](../06_Applications/01_Compiler_Design/)
- [ç¼–ç¨‹è¯­è¨€](../06_Applications/02_Programming_Languages/)
- [è‡ªç„¶è¯­è¨€å¤„ç†](../06_Applications/03_Natural_Language_Processing/)

---

**æœ€åæ›´æ–°**: 2024-12-20  
**ç‰ˆæœ¬**: v1.0.0  
**ç»´æŠ¤è€…**: è‡ªåŠ¨æœºç†è®ºå›¢é˜Ÿ
