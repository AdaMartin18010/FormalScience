# 03.1.2 ä¸‹æ¨è‡ªåŠ¨æœºç†è®º

## ğŸ“‹ æ¦‚è¿°

ä¸‹æ¨è‡ªåŠ¨æœºç†è®ºæ˜¯å½¢å¼è¯­è¨€ç†è®ºçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œç ”ç©¶å…·æœ‰æ ˆå­˜å‚¨èƒ½åŠ›çš„æœ‰é™çŠ¶æ€è‡ªåŠ¨æœºã€‚æœ¬ç†è®ºä¸ºä¸Šä¸‹æ–‡æ— å…³è¯­è¨€æä¾›äº†å®Œæ•´çš„è®¡ç®—æ¨¡å‹ï¼Œæ˜¯ç¼–è¯‘å™¨è®¾è®¡å’Œè¯­è¨€å¤„ç†çš„é‡è¦ç†è®ºåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹ä¸‹æ¨è‡ªåŠ¨æœºçš„å½¢å¼åŒ–ç†è®º**
2. **åˆ†æä¸‹æ¨è‡ªåŠ¨æœºçš„è®¡ç®—èƒ½åŠ›**
3. **æ„å»ºä¸‹æ¨è‡ªåŠ¨æœºçš„è®¾è®¡æ–¹æ³•**
4. **æä¾›å½¢å¼åŒ–è¯æ˜å’Œç®—æ³•å®ç°**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [è‡ªåŠ¨æœºç±»å‹](#3-è‡ªåŠ¨æœºç±»å‹)
4. [è®¡ç®—è¿‡ç¨‹](#4-è®¡ç®—è¿‡ç¨‹)
5. [å½¢å¼åŒ–è¯æ˜](#5-å½¢å¼åŒ–è¯æ˜)
6. [ä»£ç å®ç°](#6-ä»£ç å®ç°)
7. [åº”ç”¨ç¤ºä¾‹](#7-åº”ç”¨ç¤ºä¾‹)
8. [ç›¸å…³ç†è®º](#8-ç›¸å…³ç†è®º)
9. [å‚è€ƒæ–‡çŒ®](#9-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ä¸‹æ¨è‡ªåŠ¨æœºçš„å®šä¹‰

**å®šä¹‰ 1.1** (ä¸‹æ¨è‡ªåŠ¨æœº)
ä¸‹æ¨è‡ªåŠ¨æœº (Pushdown Automaton, PDA) æ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ï¼š
$$M = \langle Q, \Sigma, \Gamma, \delta, q_0, Z_0, F \rangle$$
å…¶ä¸­ï¼š
- $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\Gamma$ æ˜¯æ ˆå­—æ¯è¡¨
- $\delta$ æ˜¯è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $Z_0 \in \Gamma$ æ˜¯åˆå§‹æ ˆç¬¦å·
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†åˆ

### 1.2 è½¬ç§»å‡½æ•°

**å®šä¹‰ 1.2** (è½¬ç§»å‡½æ•°)
è½¬ç§»å‡½æ•° $\delta$ å®šä¹‰ä¸ºï¼š
$$\delta: Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \rightarrow \mathcal{P}(Q \times \Gamma^*)$$

è½¬ç§»å‡½æ•°è¡¨ç¤ºï¼šåœ¨çŠ¶æ€ $q$ï¼Œè¯»å…¥ç¬¦å· $a$ï¼ˆæˆ– $\epsilon$ï¼‰ï¼Œæ ˆé¡¶ç¬¦å·ä¸º $Z$ æ—¶ï¼Œå¯ä»¥è½¬ç§»åˆ°çŠ¶æ€ $q'$ å¹¶å°†æ ˆé¡¶ç¬¦å·æ›¿æ¢ä¸ºå­—ç¬¦ä¸² $\gamma$ã€‚

### 1.3 ç¬æ—¶æè¿°

**å®šä¹‰ 1.3** (ç¬æ—¶æè¿°)
ç¬æ—¶æè¿° (Instantaneous Description, ID) æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(q, w, \alpha)$ï¼Œå…¶ä¸­ï¼š
- $q \in Q$ æ˜¯å½“å‰çŠ¶æ€
- $w \in \Sigma^*$ æ˜¯å‰©ä½™è¾“å…¥å­—ç¬¦ä¸²
- $\alpha \in \Gamma^*$ æ˜¯æ ˆå†…å®¹ï¼ˆæ ˆé¡¶åœ¨å³ï¼‰

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 è½¬ç§»å…³ç³»

**å®šä¹‰ 2.1** (è½¬ç§»å…³ç³»)
è½¬ç§»å…³ç³» $\vdash$ å®šä¹‰ä¸ºï¼š
$$(q, aw, Z\alpha) \vdash (q', w, \gamma\alpha)$$
å½“ä¸”ä»…å½“ $(q', \gamma) \in \delta(q, a, Z)$

**$\epsilon$-è½¬ç§»**ï¼š
$$(q, w, Z\alpha) \vdash (q', w, \gamma\alpha)$$
å½“ä¸”ä»…å½“ $(q', \gamma) \in \delta(q, \epsilon, Z)$

### 2.2 å¤šæ­¥è½¬ç§»

**å®šä¹‰ 2.2** (å¤šæ­¥è½¬ç§»)
å¤šæ­¥è½¬ç§»å…³ç³» $\vdash^*$ æ˜¯ $\vdash$ çš„è‡ªåä¼ é€’é—­åŒ…ï¼š
1. $(q, w, \alpha) \vdash^* (q, w, \alpha)$
2. å¦‚æœ $(q, w, \alpha) \vdash (q', w', \alpha')$ ä¸” $(q', w', \alpha') \vdash^* (q'', w'', \alpha'')$ï¼Œåˆ™ $(q, w, \alpha) \vdash^* (q'', w'', \alpha'')$

### 2.3 è¯­è¨€æ¥å—

**å®šä¹‰ 2.3** (è¯­è¨€æ¥å—)
ä¸‹æ¨è‡ªåŠ¨æœº $M$ æ¥å—çš„è¯­è¨€å®šä¹‰ä¸ºï¼š
$$L(M) = \{w \in \Sigma^* \mid (q_0, w, Z_0) \vdash^* (q, \epsilon, \alpha), q \in F, \alpha \in \Gamma^*\}$$

## 3. è‡ªåŠ¨æœºç±»å‹

### 3.1 ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº

**å®šä¹‰ 3.1** (ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº)
ä¸‹æ¨è‡ªåŠ¨æœº $M$ æ˜¯ç¡®å®šæ€§çš„ï¼Œå¦‚æœï¼š
1. å¯¹äºæ‰€æœ‰ $q \in Q, a \in \Sigma, Z \in \Gamma$ï¼Œ$|\delta(q, a, Z)| \leq 1$
2. å¯¹äºæ‰€æœ‰ $q \in Q, Z \in \Gamma$ï¼Œå¦‚æœ $\delta(q, \epsilon, Z) \neq \emptyset$ï¼Œåˆ™å¯¹äºæ‰€æœ‰ $a \in \Sigma$ï¼Œ$\delta(q, a, Z) = \emptyset$

### 3.2 éç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº

**å®šä¹‰ 3.2** (éç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº)
éç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœºå…è®¸ï¼š
1. å¤šä¸ªè½¬ç§»é€‰æ‹©
2. $\epsilon$-è½¬ç§»
3. æ ˆæ“ä½œçš„ä¸ç¡®å®šæ€§

### 3.3 æ¥å—æ–¹å¼

**å®šä¹‰ 3.3** (æ¥å—æ–¹å¼)
ä¸‹æ¨è‡ªåŠ¨æœºæœ‰ä¸¤ç§æ¥å—æ–¹å¼ï¼š
1. **ç»ˆæ€æ¥å—**ï¼šè¾“å…¥ç»“æŸæ—¶å¤„äºæ¥å—çŠ¶æ€
2. **ç©ºæ ˆæ¥å—**ï¼šè¾“å…¥ç»“æŸæ—¶æ ˆä¸ºç©º

## 4. è®¡ç®—è¿‡ç¨‹

### 4.1 è®¡ç®—æ­¥éª¤

**å®šä¹‰ 4.1** (è®¡ç®—æ­¥éª¤)
ä¸‹æ¨è‡ªåŠ¨æœºçš„è®¡ç®—æ­¥éª¤ï¼š
1. è¯»å–è¾“å…¥ç¬¦å·ï¼ˆæˆ–æ‰§è¡Œ $\epsilon$-è½¬ç§»ï¼‰
2. æ£€æŸ¥å½“å‰çŠ¶æ€å’Œæ ˆé¡¶ç¬¦å·
3. æ ¹æ®è½¬ç§»å‡½æ•°é€‰æ‹©è½¬ç§»
4. æ›´æ–°çŠ¶æ€å’Œæ ˆå†…å®¹
5. é‡å¤ç›´åˆ°è¾“å…¥ç»“æŸ

### 4.2 æ ˆæ“ä½œ

**å®šä¹‰ 4.2** (æ ˆæ“ä½œ)
æ ˆæ“ä½œåŒ…æ‹¬ï¼š
- **å‹æ ˆ**ï¼šå°†ç¬¦å·æ¨å…¥æ ˆé¡¶
- **å¼¹æ ˆ**ï¼šç§»é™¤æ ˆé¡¶ç¬¦å·
- **æ›¿æ¢**ï¼šç”¨å­—ç¬¦ä¸²æ›¿æ¢æ ˆé¡¶ç¬¦å·
- **ä¿æŒ**ï¼šä¿æŒæ ˆé¡¶ç¬¦å·ä¸å˜

### 4.3 è®¡ç®—ç¤ºä¾‹

**ç¤ºä¾‹ 4.1** (å›æ–‡ä¸²è¯†åˆ«)
è€ƒè™‘è¯†åˆ«å›æ–‡ä¸²çš„ä¸‹æ¨è‡ªåŠ¨æœºï¼š
- çŠ¶æ€ï¼š$Q = \{q_0, q_1, q_2\}$
- è¾“å…¥å­—æ¯è¡¨ï¼š$\Sigma = \{a, b\}$
- æ ˆå­—æ¯è¡¨ï¼š$\Gamma = \{Z_0, A, B\}$
- è½¬ç§»å‡½æ•°ï¼š
  - $\delta(q_0, a, Z_0) = \{(q_1, AZ_0)\}$
  - $\delta(q_0, b, Z_0) = \{(q_1, BZ_0)\}$
  - $\delta(q_1, a, A) = \{(q_1, AA)\}$
  - $\delta(q_1, b, A) = \{(q_1, BA)\}$
  - $\delta(q_1, a, B) = \{(q_1, AB)\}$
  - $\delta(q_1, b, B) = \{(q_1, BB)\}$
  - $\delta(q_1, \epsilon, A) = \{(q_2, A)\}$
  - $\delta(q_1, \epsilon, B) = \{(q_2, B)\}$
  - $\delta(q_2, a, A) = \{(q_2, \epsilon)\}$
  - $\delta(q_2, b, B) = \{(q_2, \epsilon)\}$

## 5. å½¢å¼åŒ–è¯æ˜

### 5.1 ç­‰ä»·æ€§å®šç†

**å®šç† 5.1** (ä¸‹æ¨è‡ªåŠ¨æœºä¸ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ç­‰ä»·)
è¯­è¨€ $L$ è¢«ä¸‹æ¨è‡ªåŠ¨æœºæ¥å—å½“ä¸”ä»…å½“ $L$ æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ã€‚

**è¯æ˜**ï¼š
1. **ä»æ–‡æ³•åˆ°è‡ªåŠ¨æœº**ï¼š
   - æ„é€ ä¸‹æ¨è‡ªåŠ¨æœºæ¨¡æ‹Ÿæ–‡æ³•æ¨å¯¼
   - ä½¿ç”¨æ ˆå­˜å‚¨éç»ˆç»“ç¬¦
   - æ ¹æ®äº§ç”Ÿå¼è¿›è¡Œè½¬ç§»

2. **ä»è‡ªåŠ¨æœºåˆ°æ–‡æ³•**ï¼š
   - æ„é€ æ–‡æ³•æ¨¡æ‹Ÿè‡ªåŠ¨æœºè®¡ç®—
   - ä½¿ç”¨éç»ˆç»“ç¬¦è¡¨ç¤ºçŠ¶æ€å’Œæ ˆå†…å®¹
   - æ ¹æ®è½¬ç§»å‡½æ•°æ„é€ äº§ç”Ÿå¼

### 5.2 ç¡®å®šæ€§é™åˆ¶å®šç†

**å®šç† 5.2** (ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœºçš„é™åˆ¶)
ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœºä¸èƒ½è¯†åˆ«æ‰€æœ‰ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ã€‚

**è¯æ˜**ï¼š
æ„é€ è¯­è¨€ $L = \{ww^R \mid w \in \{a, b\}^*\}$ï¼Œè¯æ˜ï¼š
1. $L$ æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€
2. ä»»ä½•ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœºéƒ½æ— æ³•è¯†åˆ« $L$
3. éç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœºå¯ä»¥è¯†åˆ« $L$

### 5.3 æ³µå¼•ç†

**å®šç† 5.3** (ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€çš„æ³µå¼•ç†)
å¦‚æœ $L$ æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼Œåˆ™å­˜åœ¨å¸¸æ•° $p$ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰ $s \in L$ ä¸” $|s| \geq p$ï¼Œå­˜åœ¨åˆ†è§£ $s = uvxyz$ æ»¡è¶³ï¼š
1. $|vxy| \leq p$
2. $|vy| \geq 1$
3. å¯¹äºæ‰€æœ‰ $i \geq 0$ï¼Œ$uv^ixy^iz \in L$

**è¯æ˜**ï¼š
1. åˆ©ç”¨ä¸‹æ¨è‡ªåŠ¨æœºçš„çŠ¶æ€é‡å¤
2. æ„é€ æ³µåˆ†è§£
3. è¯æ˜æ³µæ€§è´¨

## 6. ä»£ç å®ç°

### 6.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::fmt;

/// æ ˆ
#[derive(Debug, Clone)]
pub struct Stack<T> {
    elements: Vec<T>,
}

impl<T> Stack<T> {
    pub fn new() -> Self {
        Self { elements: Vec::new() }
    }

    pub fn push(&mut self, element: T) {
        self.elements.push(element);
    }

    pub fn pop(&mut self) -> Option<T> {
        self.elements.pop()
    }

    pub fn peek(&self) -> Option<&T> {
        self.elements.last()
    }

    pub fn is_empty(&self) -> bool {
        self.elements.is_empty()
    }

    pub fn len(&self) -> usize {
        self.elements.len()
    }

    pub fn to_vec(&self) -> Vec<T> {
        self.elements.clone()
    }
}

/// è½¬ç§»
#[derive(Debug, Clone)]
pub struct Transition<Q, A, G> {
    next_state: Q,
    stack_push: Vec<G>,
}

impl<Q, A, G> Transition<Q, A, G> {
    pub fn new(next_state: Q, stack_push: Vec<G>) -> Self {
        Self { next_state, stack_push }
    }
}

/// ä¸‹æ¨è‡ªåŠ¨æœº
#[derive(Debug, Clone)]
pub struct PushdownAutomaton<Q, A, G> {
    states: HashSet<Q>,
    input_alphabet: HashSet<A>,
    stack_alphabet: HashSet<G>,
    transitions: HashMap<(Q, Option<A>, G), Vec<Transition<Q, A, G>>>,
    initial_state: Q,
    initial_stack_symbol: G,
    accepting_states: HashSet<Q>,
}

impl<Q, A, G> PushdownAutomaton<Q, A, G>
where
    Q: Clone + Eq + std::hash::Hash,
    A: Clone + Eq + std::hash::Hash,
    G: Clone + Eq + std::hash::Hash,
{
    pub fn new(initial_state: Q, initial_stack_symbol: G) -> Self {
        Self {
            states: HashSet::new(),
            input_alphabet: HashSet::new(),
            stack_alphabet: HashSet::new(),
            transitions: HashMap::new(),
            initial_state,
            initial_stack_symbol,
            accepting_states: HashSet::new(),
        }
    }

    /// æ·»åŠ çŠ¶æ€
    pub fn add_state(&mut self, state: Q) {
        self.states.insert(state);
    }

    /// æ·»åŠ è¾“å…¥ç¬¦å·
    pub fn add_input_symbol(&mut self, symbol: A) {
        self.input_alphabet.insert(symbol);
    }

    /// æ·»åŠ æ ˆç¬¦å·
    pub fn add_stack_symbol(&mut self, symbol: G) {
        self.stack_alphabet.insert(symbol);
    }

    /// æ·»åŠ è½¬ç§»
    pub fn add_transition(&mut self, from_state: Q, input_symbol: Option<A>, 
                         stack_symbol: G, to_state: Q, stack_push: Vec<G>) {
        let key = (from_state, input_symbol, stack_symbol);
        let transition = Transition::new(to_state, stack_push);
        
        self.transitions.entry(key)
            .or_insert_with(Vec::new)
            .push(transition);
    }

    /// æ·»åŠ æ¥å—çŠ¶æ€
    pub fn add_accepting_state(&mut self, state: Q) {
        self.accepting_states.insert(state);
    }

    /// è·å–è½¬ç§»
    pub fn get_transitions(&self, state: &Q, input_symbol: Option<&A>, 
                          stack_symbol: &G) -> Vec<&Transition<Q, A, G>> {
        let key = (state.clone(), input_symbol.cloned(), stack_symbol.clone());
        self.transitions.get(&key).map(|v| v.iter().collect()).unwrap_or_default()
    }

    /// æ‰§è¡Œä¸€æ­¥è½¬ç§»
    pub fn step(&self, current_state: &Q, input_symbol: Option<&A>, 
                stack: &mut Stack<G>) -> Vec<(Q, Stack<G>)> {
        let mut results = Vec::new();
        
        if let Some(top_symbol) = stack.peek() {
            let transitions = self.get_transitions(current_state, input_symbol, top_symbol);
            
            for transition in transitions {
                let mut new_stack = stack.clone();
                new_stack.pop(); // ç§»é™¤æ ˆé¡¶ç¬¦å·
                
                // å‹å…¥æ–°ç¬¦å·ï¼ˆä»å³åˆ°å·¦ï¼‰
                for symbol in transition.stack_push.iter().rev() {
                    new_stack.push(symbol.clone());
                }
                
                results.push((transition.next_state.clone(), new_stack));
            }
        }
        
        results
    }

    /// æ£€æŸ¥æ˜¯å¦æ¥å—è¾“å…¥
    pub fn accepts(&self, input: &[A]) -> bool {
        let mut configurations = vec![(
            self.initial_state.clone(),
            input.to_vec(),
            {
                let mut stack = Stack::new();
                stack.push(self.initial_stack_symbol.clone());
                stack
            }
        )];
        
        while !configurations.is_empty() {
            let mut new_configurations = Vec::new();
            
            for (state, remaining_input, stack) in configurations {
                // æ£€æŸ¥æ˜¯å¦æ¥å—
                if remaining_input.is_empty() && self.accepting_states.contains(&state) {
                    return true;
                }
                
                // å°è¯•è¯»å–è¾“å…¥ç¬¦å·
                if !remaining_input.is_empty() {
                    let input_symbol = &remaining_input[0];
                    let next_input = &remaining_input[1..];
                    
                    let transitions = self.step(&state, Some(input_symbol), &mut stack.clone());
                    for (next_state, next_stack) in transitions {
                        new_configurations.push((next_state, next_input.to_vec(), next_stack));
                    }
                }
                
                // å°è¯•Îµè½¬ç§»
                let epsilon_transitions = self.step(&state, None, &mut stack.clone());
                for (next_state, next_stack) in epsilon_transitions {
                    new_configurations.push((next_state, remaining_input.clone(), next_stack));
                }
            }
            
            configurations = new_configurations;
        }
        
        false
    }

    /// è½¬æ¢ä¸ºç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœºï¼ˆå¦‚æœå¯èƒ½ï¼‰
    pub fn to_deterministic(&self) -> Option<PushdownAutomaton<Q, A, G>> {
        // ç®€åŒ–ç‰ˆæœ¬ï¼šæ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯ç¡®å®šæ€§çš„
        for transitions in self.transitions.values() {
            if transitions.len() > 1 {
                return None; // éç¡®å®šæ€§
            }
        }
        
        Some(self.clone())
    }
}

/// ä¸‹æ¨è‡ªåŠ¨æœºæ„é€ å™¨
#[derive(Debug, Clone)]
pub struct PushdownAutomatonBuilder<Q, A, G> {
    automaton: PushdownAutomaton<Q, A, G>,
}

impl<Q, A, G> PushdownAutomatonBuilder<Q, A, G>
where
    Q: Clone + Eq + std::hash::Hash,
    A: Clone + Eq + std::hash::Hash,
    G: Clone + Eq + std::hash::Hash,
{
    pub fn new(initial_state: Q, initial_stack_symbol: G) -> Self {
        Self {
            automaton: PushdownAutomaton::new(initial_state, initial_stack_symbol),
        }
    }

    pub fn add_state(mut self, state: Q) -> Self {
        self.automaton.add_state(state);
        self
    }

    pub fn add_input_symbol(mut self, symbol: A) -> Self {
        self.automaton.add_input_symbol(symbol);
        self
    }

    pub fn add_stack_symbol(mut self, symbol: G) -> Self {
        self.automaton.add_stack_symbol(symbol);
        self
    }

    pub fn add_transition(mut self, from_state: Q, input_symbol: Option<A>, 
                         stack_symbol: G, to_state: Q, stack_push: Vec<G>) -> Self {
        self.automaton.add_transition(from_state, input_symbol, stack_symbol, to_state, stack_push);
        self
    }

    pub fn add_accepting_state(mut self, state: Q) -> Self {
        self.automaton.add_accepting_state(state);
        self
    }

    pub fn build(self) -> PushdownAutomaton<Q, A, G> {
        self.automaton
    }
}

/// å›æ–‡ä¸²è¯†åˆ«å™¨
pub fn create_palindrome_recognizer() -> PushdownAutomaton<String, char, char> {
    PushdownAutomatonBuilder::new("q0".to_string(), 'Z')
        .add_state("q0".to_string())
        .add_state("q1".to_string())
        .add_state("q2".to_string())
        .add_input_symbol('a')
        .add_input_symbol('b')
        .add_stack_symbol('Z')
        .add_stack_symbol('A')
        .add_stack_symbol('B')
        .add_transition("q0".to_string(), Some('a'), 'Z', "q1".to_string(), vec!['A', 'Z'])
        .add_transition("q0".to_string(), Some('b'), 'Z', "q1".to_string(), vec!['B', 'Z'])
        .add_transition("q1".to_string(), Some('a'), 'A', "q1".to_string(), vec!['A', 'A'])
        .add_transition("q1".to_string(), Some('b'), 'A', "q1".to_string(), vec!['B', 'A'])
        .add_transition("q1".to_string(), Some('a'), 'B', "q1".to_string(), vec!['A', 'B'])
        .add_transition("q1".to_string(), Some('b'), 'B', "q1".to_string(), vec!['B', 'B'])
        .add_transition("q1".to_string(), None, 'A', "q2".to_string(), vec!['A'])
        .add_transition("q1".to_string(), None, 'B', "q2".to_string(), vec!['B'])
        .add_transition("q2".to_string(), Some('a'), 'A', "q2".to_string(), vec![])
        .add_transition("q2".to_string(), Some('b'), 'B', "q2".to_string(), vec![])
        .add_accepting_state("q2".to_string())
        .build()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_palindrome_recognizer() {
        let pda = create_palindrome_recognizer();
        
        // æµ‹è¯•å›æ–‡ä¸²
        assert!(pda.accepts(&['a', 'b', 'a']));
        assert!(pda.accepts(&['a', 'a']));
        assert!(pda.accepts(&['b', 'a', 'b']));
        
        // æµ‹è¯•éå›æ–‡ä¸²
        assert!(!pda.accepts(&['a', 'b']));
        assert!(!pda.accepts(&['a', 'b', 'b']));
    }

    #[test]
    fn test_stack_operations() {
        let mut stack = Stack::new();
        stack.push('A');
        stack.push('B');
        
        assert_eq!(stack.peek(), Some(&'B'));
        assert_eq!(stack.pop(), Some('B'));
        assert_eq!(stack.peek(), Some(&'A'));
    }
}
```

### 6.2 Haskell å®ç°

```haskell
module PushdownAutomaton where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Maybe (fromMaybe)

-- æ ˆ
data Stack a = Stack [a] deriving (Show, Eq)

emptyStack :: Stack a
emptyStack = Stack []

push :: a -> Stack a -> Stack a
push x (Stack xs) = Stack (x:xs)

pop :: Stack a -> Maybe (a, Stack a)
pop (Stack []) = Nothing
pop (Stack (x:xs)) = Just (x, Stack xs)

peek :: Stack a -> Maybe a
peek (Stack []) = Nothing
peek (Stack (x:_)) = Just x

isEmpty :: Stack a -> Bool
isEmpty (Stack []) = True
isEmpty _ = False

stackToList :: Stack a -> [a]
stackToList (Stack xs) = xs

-- è½¬ç§»
data Transition q a g = Transition
    { nextState :: q
    , stackPush :: [g]
    } deriving (Show, Eq)

-- ä¸‹æ¨è‡ªåŠ¨æœº
data PushdownAutomaton q a g = PushdownAutomaton
    { states :: Set q
    , inputAlphabet :: Set a
    , stackAlphabet :: Set g
    , transitions :: Map (q, Maybe a, g) [Transition q a g]
    , initialState :: q
    , initialStackSymbol :: g
    , acceptingStates :: Set q
    } deriving (Show, Eq)

-- åˆ›å»ºç©ºä¸‹æ¨è‡ªåŠ¨æœº
emptyPushdownAutomaton :: (Ord q, Ord a, Ord g) => q -> g -> PushdownAutomaton q a g
emptyPushdownAutomaton initState initStack = PushdownAutomaton
    { states = Set.singleton initState
    , inputAlphabet = Set.empty
    , stackAlphabet = Set.singleton initStack
    , transitions = Map.empty
    , initialState = initState
    , initialStackSymbol = initStack
    , acceptingStates = Set.empty
    }

-- æ·»åŠ çŠ¶æ€
addState :: (Ord q, Ord a, Ord g) => q -> PushdownAutomaton q a g -> PushdownAutomaton q a g
addState state pda = pda { states = Set.insert state (states pda) }

-- æ·»åŠ è¾“å…¥ç¬¦å·
addInputSymbol :: (Ord q, Ord a, Ord g) => a -> PushdownAutomaton q a g -> PushdownAutomaton q a g
addInputSymbol symbol pda = pda { inputAlphabet = Set.insert symbol (inputAlphabet pda) }

-- æ·»åŠ æ ˆç¬¦å·
addStackSymbol :: (Ord q, Ord a, Ord g) => g -> PushdownAutomaton q a g -> PushdownAutomaton q a g
addStackSymbol symbol pda = pda { stackAlphabet = Set.insert symbol (stackAlphabet pda) }

-- æ·»åŠ è½¬ç§»
addTransition :: (Ord q, Ord a, Ord g) => q -> Maybe a -> g -> q -> [g] -> PushdownAutomaton q a g -> PushdownAutomaton q a g
addTransition fromState inputSymbol stackSymbol toState stackPush pda = pda
    { transitions = Map.insertWith (++) (fromState, inputSymbol, stackSymbol) 
        [Transition toState stackPush] (transitions pda)
    }

-- æ·»åŠ æ¥å—çŠ¶æ€
addAcceptingState :: (Ord q, Ord a, Ord g) => q -> PushdownAutomaton q a g -> PushdownAutomaton q a g
addAcceptingState state pda = pda { acceptingStates = Set.insert state (acceptingStates pda) }

-- è·å–è½¬ç§»
getTransitions :: (Ord q, Ord a, Ord g) => q -> Maybe a -> g -> PushdownAutomaton q a g -> [Transition q a g]
getTransitions state inputSymbol stackSymbol pda = 
    fromMaybe [] (Map.lookup (state, inputSymbol, stackSymbol) (transitions pda))

-- æ‰§è¡Œä¸€æ­¥è½¬ç§»
step :: (Ord q, Ord a, Ord g) => q -> Maybe a -> Stack g -> PushdownAutomaton q a g -> [(q, Stack g)]
step state inputSymbol stack pda = 
    case peek stack of
        Nothing -> []
        Just topSymbol -> 
            let transitions = getTransitions state inputSymbol topSymbol pda
                (_, newStack) = fromMaybe (undefined, stack) (pop stack)
            in [(nextState t, foldr push newStack (stackPush t)) | t <- transitions]

-- æ£€æŸ¥æ˜¯å¦æ¥å—è¾“å…¥
accepts :: (Ord q, Ord a, Ord g) => [a] -> PushdownAutomaton q a g -> Bool
accepts input pda = 
    let initialConfig = (initialState pda, input, push (initialStackSymbol pda) emptyStack)
        configs = [initialConfig]
    in acceptsHelper configs pda
  where
    acceptsHelper [] _ = False
    acceptsHelper configs pda = 
        let newConfigs = concatMap (processConfig pda) configs
        in any isAccepting newConfigs || acceptsHelper newConfigs pda
    
    processConfig pda (state, remainingInput, stack) = 
        let inputTransitions = if null remainingInput then [] else
                step state (Just (head remainingInput)) stack pda
            epsilonTransitions = step state Nothing stack pda
            inputConfigs = [(nextState, tail remainingInput, nextStack) | (nextState, nextStack) <- inputTransitions]
            epsilonConfigs = [(nextState, remainingInput, nextStack) | (nextState, nextStack) <- epsilonTransitions]
        in inputConfigs ++ epsilonConfigs
    
    isAccepting (state, remainingInput, _) = 
        null remainingInput && Set.member state (acceptingStates pda)

-- ä¸‹æ¨è‡ªåŠ¨æœºæ„é€ å™¨
data PushdownAutomatonBuilder q a g = PushdownAutomatonBuilder
    { automaton :: PushdownAutomaton q a g
    } deriving (Show, Eq)

-- åˆ›å»ºæ„é€ å™¨
newBuilder :: (Ord q, Ord a, Ord g) => q -> g -> PushdownAutomatonBuilder q a g
newBuilder initState initStack = PushdownAutomatonBuilder (emptyPushdownAutomaton initState initStack)

-- æ·»åŠ çŠ¶æ€
withState :: (Ord q, Ord a, Ord g) => q -> PushdownAutomatonBuilder q a g -> PushdownAutomatonBuilder q a g
withState state builder = builder { automaton = addState state (automaton builder) }

-- æ·»åŠ è¾“å…¥ç¬¦å·
withInputSymbol :: (Ord q, Ord a, Ord g) => a -> PushdownAutomatonBuilder q a g -> PushdownAutomatonBuilder q a g
withInputSymbol symbol builder = builder { automaton = addInputSymbol symbol (automaton builder) }

-- æ·»åŠ æ ˆç¬¦å·
withStackSymbol :: (Ord q, Ord a, Ord g) => g -> PushdownAutomatonBuilder q a g -> PushdownAutomatonBuilder q a g
withStackSymbol symbol builder = builder { automaton = addStackSymbol symbol (automaton builder) }

-- æ·»åŠ è½¬ç§»
withTransition :: (Ord q, Ord a, Ord g) => q -> Maybe a -> g -> q -> [g] -> PushdownAutomatonBuilder q a g -> PushdownAutomatonBuilder q a g
withTransition fromState inputSymbol stackSymbol toState stackPush builder = 
    builder { automaton = addTransition fromState inputSymbol stackSymbol toState stackPush (automaton builder) }

-- æ·»åŠ æ¥å—çŠ¶æ€
withAcceptingState :: (Ord q, Ord a, Ord g) => q -> PushdownAutomatonBuilder q a g -> PushdownAutomatonBuilder q a g
withAcceptingState state builder = builder { automaton = addAcceptingState state (automaton builder) }

-- æ„å»ºè‡ªåŠ¨æœº
build :: PushdownAutomatonBuilder q a g -> PushdownAutomaton q a g
build builder = automaton builder

-- å›æ–‡ä¸²è¯†åˆ«å™¨
createPalindromeRecognizer :: PushdownAutomaton String Char Char
createPalindromeRecognizer = build $
    newBuilder "q0" 'Z'
    `withState` "q1"
    `withState` "q2"
    `withInputSymbol` 'a'
    `withInputSymbol` 'b'
    `withStackSymbol` 'A'
    `withStackSymbol` 'B'
    `withTransition` "q0" (Just 'a') 'Z' "q1" ['A', 'Z']
    `withTransition` "q0" (Just 'b') 'Z' "q1" ['B', 'Z']
    `withTransition` "q1" (Just 'a') 'A' "q1" ['A', 'A']
    `withTransition` "q1" (Just 'b') 'A' "q1" ['B', 'A']
    `withTransition` "q1" (Just 'a') 'B' "q1" ['A', 'B']
    `withTransition` "q1" (Just 'b') 'B' "q1" ['B', 'B']
    `withTransition` "q1" Nothing 'A' "q2" ['A']
    `withTransition` "q1" Nothing 'B' "q2" ['B']
    `withTransition` "q2" (Just 'a') 'A' "q2" []
    `withTransition` "q2" (Just 'b') 'B' "q2" []
    `withAcceptingState` "q2"

-- ç¤ºä¾‹ä½¿ç”¨
example :: IO ()
example = do
    let pda = createPalindromeRecognizer
    
    putStrLn "Pushdown Automaton Example:"
    putStrLn $ "Accepts 'aba': " ++ show (accepts "aba" pda)
    putStrLn $ "Accepts 'aa': " ++ show (accepts "aa" pda)
    putStrLn $ "Accepts 'bab': " ++ show (accepts "bab" pda)
    putStrLn $ "Accepts 'ab': " ++ show (accepts "ab" pda)
    putStrLn $ "Accepts 'abb': " ++ show (accepts "abb" pda)

main :: IO ()
main = example
```

## 7. åº”ç”¨ç¤ºä¾‹

### 7.1 è¯­è¨€è¯†åˆ«

**ç¤ºä¾‹ 7.1** (æ‹¬å·åŒ¹é…)
```rust
// æ‹¬å·åŒ¹é…è¯†åˆ«å™¨
let mut bracket_matcher = PushdownAutomatonBuilder::new("q0".to_string(), 'Z')
    .add_state("q0".to_string())
    .add_state("q1".to_string())
    .add_input_symbol('(')
    .add_input_symbol(')')
    .add_stack_symbol('Z')
    .add_stack_symbol('X')
    .add_transition("q0".to_string(), Some('('), 'Z', "q1".to_string(), vec!['X', 'Z'])
    .add_transition("q0".to_string(), Some('('), 'X', "q1".to_string(), vec!['X', 'X'])
    .add_transition("q1".to_string(), Some('('), 'X', "q1".to_string(), vec!['X', 'X'])
    .add_transition("q1".to_string(), Some(')'), 'X', "q1".to_string(), vec![])
    .add_transition("q1".to_string(), None, 'Z', "q0".to_string(), vec!['Z'])
    .add_accepting_state("q0".to_string())
    .build();

// æµ‹è¯•æ‹¬å·åŒ¹é…
assert!(bracket_matcher.accepts(&['(', ')']));
assert!(bracket_matcher.accepts(&['(', '(', ')', ')']));
assert!(!bracket_matcher.accepts(&['(', ')', ')']));
```

### 7.2 ç¼–è¯‘å™¨è®¾è®¡

**ç¤ºä¾‹ 7.2** (ç®€å•è¡¨è¾¾å¼è§£æ)
```rust
// ç®€å•ç®—æœ¯è¡¨è¾¾å¼è§£æå™¨
let mut expression_parser = PushdownAutomatonBuilder::new("q0".to_string(), 'Z')
    .add_state("q0".to_string())
    .add_state("q1".to_string())
    .add_state("q2".to_string())
    .add_input_symbol('n') // æ•°å­—
    .add_input_symbol('+') // åŠ å·
    .add_input_symbol('*') // ä¹˜å·
    .add_stack_symbol('Z')
    .add_stack_symbol('E') // è¡¨è¾¾å¼
    .add_stack_symbol('T') // é¡¹
    .add_stack_symbol('F') // å› å­
    .add_transition("q0".to_string(), None, 'Z', "q1".to_string(), vec!['E', 'Z'])
    .add_transition("q1".to_string(), Some('n'), 'F', "q2".to_string(), vec![])
    .add_transition("q2".to_string(), Some('*'), 'T', "q1".to_string(), vec!['*', 'F', 'T'])
    .add_transition("q2".to_string(), Some('+'), 'E', "q1".to_string(), vec!['+', 'T', 'E'])
    .add_accepting_state("q2".to_string())
    .build();
```

## 8. ç›¸å…³ç†è®º

### 8.1 ä¸æœ‰é™è‡ªåŠ¨æœºçš„å…³ç³»

ä¸‹æ¨è‡ªåŠ¨æœºæ˜¯æœ‰é™è‡ªåŠ¨æœºçš„æ‰©å±•ï¼Œé€šè¿‡æ·»åŠ æ ˆå­˜å‚¨èƒ½åŠ›å¢å¼ºäº†è®¡ç®—èƒ½åŠ›ã€‚

### 8.2 ä¸ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•çš„å…³ç³»

ä¸‹æ¨è‡ªåŠ¨æœºä¸ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ç­‰ä»·ï¼Œä¸ºä¸Šä¸‹æ–‡æ— å…³è¯­è¨€æä¾›äº†è®¡ç®—æ¨¡å‹ã€‚

### 8.3 ä¸ç¼–è¯‘å™¨ç†è®ºçš„å…³ç³»

ä¸‹æ¨è‡ªåŠ¨æœºæ˜¯ç¼–è¯‘å™¨è®¾è®¡ä¸­è¯­æ³•åˆ†æçš„é‡è¦å·¥å…·ï¼Œç”¨äºå®ç°è‡ªé¡¶å‘ä¸‹å’Œè‡ªåº•å‘ä¸Šçš„è§£æã€‚

## 9. å‚è€ƒæ–‡çŒ®

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. *Introduction to Automata Theory, Languages, and Computation*. Pearson, 2006.
2. Sipser, M. *Introduction to the Theory of Computation*. Cengage Learning, 2012.
3. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. *Compilers: Principles, Techniques, and Tools*. Pearson, 2006.
4. Kozen, D. C. *Automata and Computability*. Springer, 1997.
5. Lewis, H. R., & Papadimitriou, C. H. *Elements of the Theory of Computation*. Prentice Hall, 1998.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [03.1.1 æœ‰é™è‡ªåŠ¨æœº](../03.1.1_æœ‰é™è‡ªåŠ¨æœº.md)
- [03.1.3 çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº](../03.1.3_çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº.md)
- [03.1.4 å›¾çµæœº](../03.1.4_å›¾çµæœº.md)
- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03.2.2_ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•.md)
- [03.3.1 ä¹”å§†æ–¯åŸºè°±ç³»](../03.3.1_ä¹”å§†æ–¯åŸºè°±ç³».md) 