# 03.1.2 ä¸‹æ¨è‡ªåŠ¨æœº (Pushdown Automata)

## ğŸ“š æ¦‚è¿°

ä¸‹æ¨è‡ªåŠ¨æœºæ˜¯æ¯”æœ‰é™è‡ªåŠ¨æœºæ›´å¼ºå¤§çš„è®¡ç®—æ¨¡å‹ï¼Œé€šè¿‡å¼•å…¥ä¸€ä¸ªæ ˆç»“æ„æ¥å¢å¼ºå…¶è®°å¿†èƒ½åŠ›ã€‚ä¸‹æ¨è‡ªåŠ¨æœºèƒ½å¤Ÿè¯†åˆ«ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼Œæ˜¯ç¼–è¯‘å™¨è®¾è®¡ä¸­è¯­æ³•åˆ†æçš„ç†è®ºåŸºç¡€ã€‚

## ğŸ” ä¸»è¦ç±»å‹

### éç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº (NPDA)

**å®šä¹‰ 3.1.10** (éç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº)
éç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$ï¼Œå…¶ä¸­ï¼š

1. $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†
2. $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
3. $\Gamma$ æ˜¯æ ˆå­—æ¯è¡¨
4. $\delta: Q \times (\Sigma \cup \{\varepsilon\}) \times \Gamma \to 2^{Q \times \Gamma^*}$ æ˜¯è½¬ç§»å‡½æ•°
5. $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
6. $Z_0 \in \Gamma$ æ˜¯åˆå§‹æ ˆç¬¦å·
7. $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†

**ç‰¹ç‚¹**ï¼š

- éç¡®å®šæ€§ï¼šä¸€ä¸ªé…ç½®å¯èƒ½æœ‰å¤šä¸ªåç»§é…ç½®
- æ ˆè®°å¿†ï¼šå¯ä»¥å­˜å‚¨æ— é™é•¿åº¦çš„ä¿¡æ¯
- è®¡ç®—èƒ½åŠ›ï¼šå¯ä»¥è¯†åˆ«æ‰€æœ‰ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€

### ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº (DPDA)

**å®šä¹‰ 3.1.9** (ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº)
ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœºæ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$ï¼Œå…¶ä¸­ï¼š

1. $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†
2. $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
3. $\Gamma$ æ˜¯æ ˆå­—æ¯è¡¨
4. $\delta: Q \times (\Sigma \cup \{\varepsilon\}) \times \Gamma \to Q \times \Gamma^*$ æ˜¯è½¬ç§»å‡½æ•°
5. $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
6. $Z_0 \in \Gamma$ æ˜¯åˆå§‹æ ˆç¬¦å·
7. $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†

**çº¦æŸæ¡ä»¶**ï¼šå¯¹äºä»»æ„ $q \in Q$, $a \in \Sigma$, $Z \in \Gamma$ï¼Œå¦‚æœ $\delta(q, \varepsilon, Z)$ å·²å®šä¹‰ï¼Œåˆ™å¯¹æ‰€æœ‰ $b \in \Sigma$ï¼Œ$\delta(q, b, Z)$ æœªå®šä¹‰ã€‚

**ç‰¹ç‚¹**ï¼š

- ç¡®å®šæ€§ï¼šæ¯ä¸ªé…ç½®æœ€å¤šæœ‰ä¸€ä¸ªåç»§é…ç½®
- è®¡ç®—èƒ½åŠ›ï¼šè¯†åˆ«ç¡®å®šæ€§ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼Œæ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€çš„çœŸå­é›†

## ğŸ”„ é…ç½®ä¸è®¡ç®—

### é…ç½®

**å®šä¹‰ 3.1.11** (é…ç½®)
ä¸‹æ¨è‡ªåŠ¨æœºçš„é…ç½®æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(q, w, \gamma)$ï¼Œå…¶ä¸­ï¼š

- $q \in Q$ æ˜¯å½“å‰çŠ¶æ€
- $w \in \Sigma^*$ æ˜¯å‰©ä½™è¾“å…¥ä¸²
- $\gamma \in \Gamma^*$ æ˜¯æ ˆå†…å®¹

### è½¬ç§»å…³ç³»

**å®šä¹‰ 3.1.12** (è½¬ç§»å…³ç³»)
é…ç½®è½¬ç§»å…³ç³» $\vdash$ å®šä¹‰ä¸ºï¼š
$(q, aw, Z\gamma) \vdash (p, w, \alpha\gamma)$ å½“ä¸”ä»…å½“ $(p, \alpha) \in \delta(q, a, Z)$

å…¶ä¸­ $a \in \Sigma \cup \{\varepsilon\}$ï¼Œ$Z$ æ˜¯æ ˆé¡¶ç¬¦å·ï¼Œ$\alpha$ æ˜¯æ›¿æ¢æ ˆé¡¶çš„ç¬¦å·ä¸²ã€‚

### æ¥å—æ–¹å¼

**å®šä¹‰ 3.1.13** (ç»ˆæ€æ¥å—)
ä¸‹æ¨è‡ªåŠ¨æœº $M$ ç»ˆæ€æ¥å—çš„è¯­è¨€å®šä¹‰ä¸ºï¼š
$$L(M) = \{w \in \Sigma^* \mid (q_0, w, Z_0) \vdash^* (q, \varepsilon, \gamma), q \in F\}$$

**å®šä¹‰ 3.1.14** (ç©ºæ ˆæ¥å—)
ä¸‹æ¨è‡ªåŠ¨æœº $M$ ç©ºæ ˆæ¥å—çš„è¯­è¨€å®šä¹‰ä¸ºï¼š
$$N(M) = \{w \in \Sigma^* \mid (q_0, w, Z_0) \vdash^* (q, \varepsilon, \varepsilon)\}$$

## ğŸ“Š ç†è®ºæ€§è´¨

### ä¸ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€çš„ç­‰ä»·æ€§

**å®šç† 3.1.5** (NPDAä¸ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€çš„ç­‰ä»·æ€§)
NPDAæ¥å—çš„è¯­è¨€ç±»æ°å¥½æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ç±»ã€‚

**è¯æ˜æ¦‚è¦**ï¼š

1. ä»ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•åˆ°NPDAï¼šå¯ä»¥æ„é€ ä¸€ä¸ªNPDAæ¥æ¨¡æ‹Ÿæ–‡æ³•çš„æ¨å¯¼è¿‡ç¨‹
2. ä»NPDAåˆ°ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ï¼šå¯ä»¥æ„é€ ä¸€ä¸ªæ–‡æ³•æ¥æ¨¡æ‹ŸNPDAçš„è®¡ç®—è¿‡ç¨‹

### DPDAä¸NPDAçš„ä¸ç­‰ä»·æ€§

**å®šç† 3.1.6** (DPDAä¸NPDAçš„ä¸ç­‰ä»·æ€§)
å­˜åœ¨è¢«NPDAæ¥å—ä½†ä¸è¢«ä»»ä½•DPDAæ¥å—çš„è¯­è¨€ã€‚

**è¯æ˜**ï¼š
è€ƒè™‘è¯­è¨€ $L = \{ww^R \mid w \in \{a,b\}^*\}$ï¼Œå…¶ä¸­ $w^R$ æ˜¯ $w$ çš„åè½¬ã€‚å¯ä»¥æ„é€ NPDAæ¥å—Lï¼Œä½†å¯ä»¥è¯æ˜ä¸å­˜åœ¨DPDAæ¥å—Lã€‚

### ç»ˆæ€æ¥å—ä¸ç©ºæ ˆæ¥å—çš„ç­‰ä»·æ€§

**å®šç† 3.1.7** (æ¥å—æ–¹å¼çš„ç­‰ä»·æ€§)
å¯¹äºæ¯ä¸ªç»ˆæ€æ¥å—çš„NPDAï¼Œå­˜åœ¨ä¸€ä¸ªç©ºæ ˆæ¥å—çš„NPDAæ¥å—ç›¸åŒçš„è¯­è¨€ï¼Œåä¹‹äº¦ç„¶ã€‚

**è¯æ˜æ¦‚è¦**ï¼š

1. ä»ç»ˆæ€æ¥å—åˆ°ç©ºæ ˆæ¥å—ï¼šåœ¨æ¥å—çŠ¶æ€æ—¶æ¸…ç©ºæ ˆ
2. ä»ç©ºæ ˆæ¥å—åˆ°ç»ˆæ€æ¥å—ï¼šåœ¨æ ˆç©ºæ—¶è¿›å…¥æ¥å—çŠ¶æ€

### ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€æ³µå¼•ç†

**å®šç† 3.1.8** (ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€æ³µå¼•ç†)
å¦‚æœ $L$ æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼Œé‚£ä¹ˆå­˜åœ¨å¸¸æ•° $n$ï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰ $w \in L$ ä¸” $|w| \geq n$ï¼Œå­˜åœ¨åˆ†è§£ $w = uvxyz$ï¼Œæ»¡è¶³ï¼š

1. $|vxy| \leq n$
2. $|vy| > 0$
3. å¯¹äºæ‰€æœ‰ $i \geq 0$ï¼Œ$uv^ixy^iz \in L$

**è¯æ˜**ï¼š
è®¾ $G = (V, T, P, S)$ æ˜¯ä¹”å§†æ–¯åŸºèŒƒå¼æ–‡æ³•ï¼Œç”Ÿæˆ $L$ã€‚ä»¤ $n = 2^{|V|}$ã€‚

å¯¹äºä»»æ„ $w \in L$ ä¸” $|w| \geq n$ï¼Œè€ƒè™‘ $w$ çš„æ´¾ç”Ÿæ ‘ã€‚ç”±äºæ ‘çš„é«˜åº¦è‡³å°‘ä¸º $|V| + 1$ï¼Œæ ¹æ®é¸½å·¢åŸç†ï¼Œå­˜åœ¨ä¸€æ¡è·¯å¾„ä¸Šå‡ºç°ç›¸åŒçš„éç»ˆç»“ç¬¦ $A$ã€‚

è®¾ $A$ åœ¨è·¯å¾„ä¸Šçš„ä¸¤ä¸ªä½ç½®åˆ†åˆ«ä¸º $p_1$ å’Œ $p_2$ï¼ˆ$p_1$ æ›´æ¥è¿‘æ ¹ï¼‰ï¼Œåˆ™ï¼š

- $S \stackrel{*}{\Rightarrow} uAz$ ï¼ˆä»æ ¹åˆ° $p_1$ï¼‰
- $A \stackrel{*}{\Rightarrow} vAy$ ï¼ˆä» $p_1$ åˆ° $p_2$ï¼‰
- $A \stackrel{*}{\Rightarrow} x$ ï¼ˆä» $p_2$ åˆ°å¶å­ï¼‰

å› æ­¤ $S \stackrel{*}{\Rightarrow} uv^ixy^iz$ å¯¹æ‰€æœ‰ $i \geq 0$ æˆç«‹ã€‚

**åº”ç”¨**ï¼šæ³µå¼•ç†å¸¸ç”¨äºè¯æ˜æŸä¸ªè¯­è¨€ä¸æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ã€‚

**ä¾‹ 3.1.2**ï¼šè¯æ˜ $L = \{a^nb^nc^n \mid n \geq 0\}$ ä¸æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ã€‚

**è¯æ˜**ï¼šå‡è®¾ $L$ æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼Œè®¾æ³µå¼•ç†å¸¸æ•°ä¸º $n$ã€‚è€ƒè™‘å­—ç¬¦ä¸² $w = a^nb^nc^n$ã€‚

æ ¹æ®æ³µå¼•ç†ï¼Œå­˜åœ¨åˆ†è§£ $w = uvxyz$ï¼Œå…¶ä¸­ $|vxy| \leq n$ï¼Œ$|vy| > 0$ï¼Œä¸” $uv^ixy^iz \in L$ å¯¹æ‰€æœ‰ $i \geq 0$ æˆç«‹ã€‚

ç”±äº $|vxy| \leq n$ï¼Œ$v$ å’Œ $y$ ä¸èƒ½åŒæ—¶åŒ…å« $a$ã€$b$ã€$c$ ä¸‰ç§ç¬¦å·ã€‚å› æ­¤ï¼Œ$uv^2xy^2z$ ä¸­æŸç§ç¬¦å·çš„æ•°é‡ä¼šå¢åŠ ï¼Œè€Œå…¶ä»–ç¬¦å·çš„æ•°é‡ä¸å˜ï¼Œå¯¼è‡´ $uv^2xy^2z \notin L$ï¼ŒçŸ›ç›¾ã€‚

å› æ­¤ $L$ ä¸æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ã€‚

## ğŸ’» Rustå®ç°

### NPDAå®ç°

```rust
use std::collections::{HashMap, HashSet, VecDeque};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct State(String);

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Symbol(char);

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StackSymbol(char);

pub struct NPDA {
    states: HashSet<State>,
    input_alphabet: HashSet<Symbol>,
    stack_alphabet: HashSet<StackSymbol>,
    transitions: HashMap<(State, Option<Symbol>, StackSymbol), HashSet<(State, Vec<StackSymbol>)>>,
    initial_state: State,
    initial_stack_symbol: StackSymbol,
    accepting_states: HashSet<State>,
}

impl NPDA {
    pub fn new(
        states: HashSet<State>,
        input_alphabet: HashSet<Symbol>,
        stack_alphabet: HashSet<StackSymbol>,
        transitions: HashMap<(State, Option<Symbol>, StackSymbol), HashSet<(State, Vec<StackSymbol>)>>,
        initial_state: State,
        initial_stack_symbol: StackSymbol,
        accepting_states: HashSet<State>,
    ) -> Self {
        NPDA {
            states,
            input_alphabet,
            stack_alphabet,
            transitions,
            initial_state,
            initial_stack_symbol,
            accepting_states,
        }
    }

    pub fn accepts(&self, input: &str) -> bool {
        let mut configurations = VecDeque::new();
        let mut visited = HashSet::new();
        
        // åˆå§‹é…ç½®
        let initial_config = Configuration {
            state: self.initial_state.clone(),
            remaining_input: input.to_string(),
            stack: vec![self.initial_stack_symbol.clone()],
        };
        
        configurations.push_back(initial_config);
        
        while let Some(config) = configurations.pop_front() {
            if !visited.insert(config.clone()) {
                continue; // é¿å…å¾ªç¯
            }
            
            // æ£€æŸ¥æ˜¯å¦æ¥å—ï¼ˆç»ˆæ€æ¥å—ï¼‰
            if config.remaining_input.is_empty() && self.accepting_states.contains(&config.state) {
                return true;
            }
            
            // æ£€æŸ¥æ˜¯å¦æ¥å—ï¼ˆç©ºæ ˆæ¥å—ï¼‰
            if config.remaining_input.is_empty() && config.stack.is_empty() {
                return true;
            }
            
            // è·å–å½“å‰æ ˆé¡¶
            if let Some(&stack_top) = config.stack.last() {
                // å°è¯•Îµè½¬ç§»
                if let Some(targets) = self.transitions.get(&(config.state.clone(), None, stack_top.clone())) {
                    for (next_state, new_stack_top) in targets {
                        let mut new_stack = config.stack.clone();
                        new_stack.pop(); // ç§»é™¤æ ˆé¡¶
                        new_stack.extend(new_stack_top.iter().rev()); // å‹å…¥æ–°ç¬¦å·
                        
                        let new_config = Configuration {
                            state: next_state.clone(),
                            remaining_input: config.remaining_input.clone(),
                            stack: new_stack,
                        };
                        configurations.push_back(new_config);
                    }
                }
                
                // å°è¯•å¸¸è§„è½¬ç§»
                if let Some(first_char) = config.remaining_input.chars().next() {
                    let symbol = Symbol(first_char);
                    if let Some(targets) = self.transitions.get(&(config.state.clone(), Some(symbol), stack_top.clone())) {
                        for (next_state, new_stack_top) in targets {
                            let mut new_stack = config.stack.clone();
                            new_stack.pop(); // ç§»é™¤æ ˆé¡¶
                            new_stack.extend(new_stack_top.iter().rev()); // å‹å…¥æ–°ç¬¦å·
                            
                            let new_config = Configuration {
                                state: next_state.clone(),
                                remaining_input: config.remaining_input[1..].to_string(),
                                stack: new_stack,
                            };
                            configurations.push_back(new_config);
                        }
                    }
                }
            }
        }
        
        false
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct Configuration {
    state: State,
    remaining_input: String,
    stack: Vec<StackSymbol>,
}
```

### DPDAå®ç°

```rust
pub struct DPDA {
    states: HashSet<State>,
    input_alphabet: HashSet<Symbol>,
    stack_alphabet: HashSet<StackSymbol>,
    transitions: HashMap<(State, Option<Symbol>, StackSymbol), (State, Vec<StackSymbol>)>,
    initial_state: State,
    initial_stack_symbol: StackSymbol,
    accepting_states: HashSet<State>,
}

impl DPDA {
    pub fn new(
        states: HashSet<State>,
        input_alphabet: HashSet<Symbol>,
        stack_alphabet: HashSet<StackSymbol>,
        transitions: HashMap<(State, Option<Symbol>, StackSymbol), (State, Vec<StackSymbol>)>,
        initial_state: State,
        initial_stack_symbol: StackSymbol,
        accepting_states: HashSet<State>,
    ) -> Self {
        DPDA {
            states,
            input_alphabet,
            stack_alphabet,
            transitions,
            initial_state,
            initial_stack_symbol,
            accepting_states,
        }
    }

    pub fn accepts(&self, input: &str) -> bool {
        let mut current_state = self.initial_state.clone();
        let mut stack = vec![self.initial_stack_symbol.clone()];
        let mut input_pos = 0;
        
        while input_pos <= input.len() {
            let current_symbol = if input_pos < input.len() {
                Some(Symbol(input.chars().nth(input_pos).unwrap()))
            } else {
                None
            };
            
            if let Some(&stack_top) = stack.last() {
                // å°è¯•Îµè½¬ç§»
                if let Some((next_state, new_stack_top)) = self.transitions.get(&(current_state.clone(), None, stack_top.clone())) {
                    current_state = next_state.clone();
                    stack.pop();
                    stack.extend(new_stack_top.iter().rev());
                    continue;
                }
                
                // å°è¯•å¸¸è§„è½¬ç§»
                if let Some(symbol) = current_symbol {
                    if let Some((next_state, new_stack_top)) = self.transitions.get(&(current_state.clone(), Some(symbol), stack_top.clone())) {
                        current_state = next_state.clone();
                        stack.pop();
                        stack.extend(new_stack_top.iter().rev());
                        input_pos += 1;
                        continue;
                    }
                }
            }
            
            // æ— è½¬ç§»ï¼Œæ£€æŸ¥æ˜¯å¦æ¥å—
            break;
        }
        
        // ç»ˆæ€æ¥å—
        if input_pos == input.len() && self.accepting_states.contains(&current_state) {
            return true;
        }
        
        // ç©ºæ ˆæ¥å—
        if input_pos == input.len() && stack.is_empty() {
            return true;
        }
        
        false
    }
}
```

### è¯­æ³•åˆ†æå™¨å®ç°

```rust
pub struct Parser {
    pda: NPDA,
    tokens: Vec<Token>,
    position: usize,
}

impl Parser {
    pub fn new(pda: NPDA, tokens: Vec<Token>) -> Self {
        Parser {
            pda,
            tokens,
            position: 0,
        }
    }

    pub fn parse(&mut self) -> Result<ParseTree, ParseError> {
        let mut stack = vec![self.pda.initial_stack_symbol.clone()];
        let mut parse_stack = Vec::new();
        
        while self.position < self.tokens.len() || !stack.is_empty() {
            let current_token = self.tokens.get(self.position);
            let top_stack = stack.last().unwrap();
            
            if let Some(production) = self.get_production(current_token, top_stack) {
                // åº”ç”¨äº§ç”Ÿå¼
                stack.pop();
                for symbol in production.iter().rev() {
                    stack.push(symbol.clone());
                }
                
                // æ„å»ºè¯­æ³•æ ‘èŠ‚ç‚¹
                let node = ParseNode::new(production.clone());
                parse_stack.push(node);
                
                if current_token.is_some() {
                    self.position += 1;
                }
            } else {
                return Err(ParseError::UnexpectedToken);
            }
        }
        
        Ok(ParseTree::new(parse_stack))
    }
    
    fn get_production(&self, token: Option<&Token>, stack_top: &StackSymbol) -> Option<Vec<StackSymbol>> {
        // æ ¹æ®å½“å‰tokenå’Œæ ˆé¡¶ç¬¦å·ç¡®å®šä½¿ç”¨çš„äº§ç”Ÿå¼
        match (token, stack_top.0) {
            (Some(t), 'E') if t.token_type == TokenType::Number => {
                Some(vec![StackSymbol('N')])
            },
            (Some(t), 'E') if t.token_type == TokenType::Plus => {
                Some(vec![StackSymbol('E'), StackSymbol('+'), StackSymbol('E')])
            },
            _ => None,
        }
    }
}

#[derive(Debug)]
pub struct ParseTree {
    root: ParseNode,
}

#[derive(Debug)]
pub struct ParseNode {
    symbol: StackSymbol,
    children: Vec<ParseNode>,
}

impl ParseNode {
    pub fn new(symbol: Vec<StackSymbol>) -> Self {
        ParseNode {
            symbol: symbol[0].clone(),
            children: Vec::new(),
        }
    }
}

#[derive(Debug)]
pub enum ParseError {
    UnexpectedToken,
    IncompleteParse,
}
```

## ğŸ› ï¸ åº”ç”¨

### 1. è¯­æ³•åˆ†æ

ä¸‹æ¨è‡ªåŠ¨æœºåœ¨ç¼–è¯‘å™¨ä¸­ç”¨äºè¯­æ³•åˆ†æï¼š

```rust
pub struct SyntaxAnalyzer {
    pda: NPDA,
}

impl SyntaxAnalyzer {
    pub fn new(grammar: &str) -> Result<Self, GrammarError> {
        // ä»æ–‡æ³•æ„é€ PDA
        let pda = grammar_to_pda(grammar)?;
        Ok(SyntaxAnalyzer { pda })
    }
    
    pub fn analyze(&self, tokens: &[Token]) -> Result<SyntaxTree, AnalysisError> {
        let mut parser = Parser::new(self.pda.clone(), tokens.to_vec());
        let parse_tree = parser.parse()?;
        
        // å°†è§£ææ ‘è½¬æ¢ä¸ºè¯­æ³•æ ‘
        let syntax_tree = self.build_syntax_tree(parse_tree)?;
        
        Ok(syntax_tree)
    }
    
    fn build_syntax_tree(&self, parse_tree: ParseTree) -> Result<SyntaxTree, AnalysisError> {
        // æ„å»ºè¯­æ³•æ ‘çš„å…·ä½“å®ç°
        unimplemented!("è¯­æ³•æ ‘æ„å»º")
    }
}

#[derive(Debug)]
pub struct SyntaxTree {
    root: SyntaxNode,
}

#[derive(Debug)]
pub struct SyntaxNode {
    node_type: NodeType,
    value: String,
    children: Vec<SyntaxNode>,
}

#[derive(Debug)]
pub enum NodeType {
    Expression,
    Statement,
    Declaration,
    Function,
    Variable,
}
```

### 2. æ‹¬å·åŒ¹é…

æ£€æŸ¥æ‹¬å·æ˜¯å¦åŒ¹é…ï¼š

```rust
pub struct BracketMatcher {
    pda: DPDA,
}

impl BracketMatcher {
    pub fn new() -> Self {
        let states = HashSet::from([
            State("q0".to_string()),
            State("q1".to_string()),
        ]);
        
        let input_alphabet = HashSet::from([
            Symbol('('),
            Symbol(')'),
            Symbol('['),
            Symbol(']'),
            Symbol('{'),
            Symbol('}'),
        ]);
        
        let stack_alphabet = HashSet::from([
            StackSymbol('('),
            StackSymbol('['),
            StackSymbol('{'),
            StackSymbol('Z'),
        ]);
        
        let mut transitions = HashMap::new();
        
        // å‹å…¥å·¦æ‹¬å·
        transitions.insert(
            (State("q0".to_string()), Some(Symbol('(')), StackSymbol('Z')),
            (State("q0".to_string()), vec![StackSymbol('('), StackSymbol('Z')])
        );
        transitions.insert(
            (State("q0".to_string()), Some(Symbol('[')), StackSymbol('Z')),
            (State("q0".to_string()), vec![StackSymbol('['), StackSymbol('Z')])
        );
        transitions.insert(
            (State("q0".to_string()), Some(Symbol('{')), StackSymbol('Z')),
            (State("q0".to_string()), vec![StackSymbol('{'), StackSymbol('Z')])
        );
        
        // åŒ¹é…å³æ‹¬å·
        transitions.insert(
            (State("q0".to_string()), Some(Symbol(')')), StackSymbol('(')),
            (State("q0".to_string()), vec![])
        );
        transitions.insert(
            (State("q0".to_string()), Some(Symbol(']')), StackSymbol('[')),
            (State("q0".to_string()), vec![])
        );
        transitions.insert(
            (State("q0".to_string()), Some(Symbol('}')), StackSymbol('{')),
            (State("q0".to_string()), vec![])
        );
        
        let pda = DPDA::new(
            states,
            input_alphabet,
            stack_alphabet,
            transitions,
            State("q0".to_string()),
            StackSymbol('Z'),
            HashSet::from([State("q0".to_string())]),
        );
        
        BracketMatcher { pda }
    }
    
    pub fn is_balanced(&self, text: &str) -> bool {
        self.pda.accepts(text)
    }
    
    pub fn find_unmatched(&self, text: &str) -> Vec<UnmatchedBracket> {
        let mut unmatched = Vec::new();
        let mut stack = Vec::new();
        
        for (i, c) in text.chars().enumerate() {
            match c {
                '(' | '[' | '{' => {
                    stack.push((i, c));
                },
                ')' | ']' | '}' => {
                    if let Some((pos, open)) = stack.pop() {
                        if !self.matches(open, c) {
                            unmatched.push(UnmatchedBracket {
                                position: i,
                                bracket: c,
                                message: format!("ä¸åŒ¹é…çš„å³æ‹¬å· '{}'", c),
                            });
                        }
                    } else {
                        unmatched.push(UnmatchedBracket {
                            position: i,
                            bracket: c,
                            message: format!("å¤šä½™çš„å³æ‹¬å· '{}'", c),
                        });
                    }
                },
                _ => {}
            }
        }
        
        // æ£€æŸ¥æœªåŒ¹é…çš„å·¦æ‹¬å·
        for (pos, open) in stack {
            unmatched.push(UnmatchedBracket {
                position: pos,
                bracket: open,
                message: format!("æœªåŒ¹é…çš„å·¦æ‹¬å· '{}'", open),
            });
        }
        
        unmatched
    }
    
    fn matches(&self, open: char, close: char) -> bool {
        matches!((open, close), 
            ('(', ')') | ('[', ']') | ('{', '}')
        )
    }
}

#[derive(Debug)]
pub struct UnmatchedBracket {
    pub position: usize,
    pub bracket: char,
    pub message: String,
}
```

### 3. å›æ–‡è¯†åˆ«

è¯†åˆ«å½¢å¦‚ $ww^R$ çš„å›æ–‡ï¼š

```rust
pub struct PalindromeRecognizer {
    pda: NPDA,
}

impl PalindromeRecognizer {
    pub fn new() -> Self {
        let states = HashSet::from([
            State("q0".to_string()),
            State("q1".to_string()),
            State("q2".to_string()),
        ]);
        
        let input_alphabet = HashSet::from([
            Symbol('a'),
            Symbol('b'),
        ]);
        
        let stack_alphabet = HashSet::from([
            StackSymbol('a'),
            StackSymbol('b'),
            StackSymbol('Z'),
        ]);
        
        let mut transitions = HashMap::new();
        
        // å‹å…¥å‰åŠéƒ¨åˆ†
        transitions.insert(
            (State("q0".to_string()), Some(Symbol('a')), StackSymbol('Z')),
            HashSet::from([(State("q0".to_string()), vec![StackSymbol('a'), StackSymbol('Z')])])
        );
        transitions.insert(
            (State("q0".to_string()), Some(Symbol('b')), StackSymbol('Z')),
            HashSet::from([(State("q0".to_string()), vec![StackSymbol('b'), StackSymbol('Z')])])
        );
        transitions.insert(
            (State("q0".to_string()), Some(Symbol('a')), StackSymbol('a')),
            HashSet::from([(State("q0".to_string()), vec![StackSymbol('a'), StackSymbol('a')])])
        );
        transitions.insert(
            (State("q0".to_string()), Some(Symbol('b')), StackSymbol('a')),
            HashSet::from([(State("q0".to_string()), vec![StackSymbol('b'), StackSymbol('a')])])
        );
        transitions.insert(
            (State("q0".to_string()), Some(Symbol('a')), StackSymbol('b')),
            HashSet::from([(State("q0".to_string()), vec![StackSymbol('a'), StackSymbol('b')])])
        );
        transitions.insert(
            (State("q0".to_string()), Some(Symbol('b')), StackSymbol('b')),
            HashSet::from([(State("q0".to_string()), vec![StackSymbol('b'), StackSymbol('b')])])
        );
        
        // çŒœæµ‹ä¸­ç‚¹ï¼ˆÎµè½¬ç§»ï¼‰
        transitions.insert(
            (State("q0".to_string()), None, StackSymbol('a')),
            HashSet::from([(State("q1".to_string()), vec![StackSymbol('a')])])
        );
        transitions.insert(
            (State("q0".to_string()), None, StackSymbol('b')),
            HashSet::from([(State("q1".to_string()), vec![StackSymbol('b')])])
        );
        
        // åŒ¹é…ååŠéƒ¨åˆ†
        transitions.insert(
            (State("q1".to_string()), Some(Symbol('a')), StackSymbol('a')),
            HashSet::from([(State("q1".to_string()), vec![])])
        );
        transitions.insert(
            (State("q1".to_string()), Some(Symbol('b')), StackSymbol('b')),
            HashSet::from([(State("q1".to_string()), vec![])])
        );
        
        // æ¥å—
        transitions.insert(
            (State("q1".to_string()), None, StackSymbol('Z')),
            HashSet::from([(State("q2".to_string()), vec![])])
        );
        
        let pda = NPDA::new(
            states,
            input_alphabet,
            stack_alphabet,
            transitions,
            State("q0".to_string()),
            StackSymbol('Z'),
            HashSet::from([State("q2".to_string())]),
        );
        
        PalindromeRecognizer { pda }
    }
    
    pub fn is_palindrome(&self, text: &str) -> bool {
        self.pda.accepts(text)
    }
    
    pub fn find_palindromes(&self, text: &str) -> Vec<Palindrome> {
        let mut palindromes = Vec::new();
        
        for start in 0..text.len() {
            for end in start + 1..=text.len() {
                let substring = &text[start..end];
                if self.is_palindrome(substring) {
                    palindromes.push(Palindrome {
                        start,
                        end,
                        text: substring.to_string(),
                    });
                }
            }
        }
        
        palindromes
    }
}

#[derive(Debug)]
pub struct Palindrome {
    pub start: usize,
    pub end: usize,
    pub text: String,
}
```

### 4. è¡¨è¾¾å¼æ±‚å€¼

è®¡ç®—ç®—æœ¯è¡¨è¾¾å¼çš„å€¼ï¼š

```rust
pub struct ExpressionEvaluator {
    pda: DPDA,
}

impl ExpressionEvaluator {
    pub fn new() -> Self {
        // æ„é€ ç”¨äºè¡¨è¾¾å¼æ±‚å€¼çš„PDA
        // è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…ä¸­éœ€è¦æ›´å¤æ‚çš„è½¬ç§»å‡½æ•°
        let states = HashSet::from([
            State("q0".to_string()),
            State("q1".to_string()),
        ]);
        
        let input_alphabet = HashSet::from([
            Symbol('0'), Symbol('1'), Symbol('2'), Symbol('3'), Symbol('4'),
            Symbol('5'), Symbol('6'), Symbol('7'), Symbol('8'), Symbol('9'),
            Symbol('+'), Symbol('-'), Symbol('*'), Symbol('/'),
            Symbol('('), Symbol(')'),
        ]);
        
        let stack_alphabet = HashSet::from([
            StackSymbol('N'), // æ•°å­—
            StackSymbol('O'), // æ“ä½œç¬¦
            StackSymbol('P'), // æ‹¬å·
            StackSymbol('Z'), // æ ˆåº•
        ]);
        
        let mut transitions = HashMap::new();
        
        // æ•°å­—å¤„ç†
        for c in '0'..='9' {
            transitions.insert(
                (State("q0".to_string()), Some(Symbol(c)), StackSymbol('Z')),
                (State("q0".to_string()), vec![StackSymbol('N'), StackSymbol('Z')])
            );
        }
        
        // æ“ä½œç¬¦å¤„ç†
        for op in ['+', '-', '*', '/'] {
            transitions.insert(
                (State("q0".to_string()), Some(Symbol(op)), StackSymbol('N')),
                (State("q0".to_string()), vec![StackSymbol('O'), StackSymbol('N')])
            );
        }
        
        let pda = DPDA::new(
            states,
            input_alphabet,
            stack_alphabet,
            transitions,
            State("q0".to_string()),
            StackSymbol('Z'),
            HashSet::from([State("q0".to_string())]),
        );
        
        ExpressionEvaluator { pda }
    }
    
    pub fn evaluate(&self, expression: &str) -> Result<f64, EvaluationError> {
        // ä½¿ç”¨PDAè¿›è¡Œè¡¨è¾¾å¼æ±‚å€¼
        // è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…ä¸­éœ€è¦æ›´å¤æ‚çš„ç®—æ³•
        if self.pda.accepts(expression) {
            // è§£æå¹¶è®¡ç®—è¡¨è¾¾å¼
            self.parse_and_evaluate(expression)
        } else {
            Err(EvaluationError::InvalidExpression)
        }
    }
    
    fn parse_and_evaluate(&self, expression: &str) -> Result<f64, EvaluationError> {
        // è¡¨è¾¾å¼è§£æå’Œæ±‚å€¼çš„å…·ä½“å®ç°
        // è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…ä¸­éœ€è¦å®Œæ•´çš„è¡¨è¾¾å¼è§£æå™¨
        unimplemented!("è¡¨è¾¾å¼è§£æå’Œæ±‚å€¼")
    }
}

#[derive(Debug)]
pub enum EvaluationError {
    InvalidExpression,
    DivisionByZero,
    InvalidOperator,
}
```

## ğŸ”— ç›¸å…³å†…å®¹

- [03.1.1 æœ‰é™è‡ªåŠ¨æœº](03.1.1_Finite_Automata.md) - æ¯”ä¸‹æ¨è‡ªåŠ¨æœºæ›´ç®€å•çš„è®¡ç®—æ¨¡å‹
- [03.1.3 çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº](03.1.3_Linear_Bounded_Automata.md) - æ¯”ä¸‹æ¨è‡ªåŠ¨æœºæ›´å¼ºå¤§çš„è®¡ç®—æ¨¡å‹
- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03.2_Formal_Grammars/03.2.2_Context_Free_Grammar.md) - ä¸ä¸‹æ¨è‡ªåŠ¨æœºç­‰ä»·çš„æ–‡æ³•
- [03.4 è§£æç†è®º](../03.4_Parsing_Theory.md) - åŸºäºä¸‹æ¨è‡ªåŠ¨æœºçš„è¯­æ³•åˆ†ææ–¹æ³•

---

**æ›´æ–°æ—¶é—´**: 2025-01-16  
**ç‰ˆæœ¬**: 3.0  
**çŠ¶æ€**: å·²å®Œæˆï¼ˆåŒ…å«æ³µå¼•ç†ã€Rustå®ç°ã€åº”ç”¨æ¡ˆä¾‹ï¼‰

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
