# 03.4.1 LLè§£æ

## ğŸ“‹ æ¦‚è¿°

LLè§£ææ˜¯ä¸€ç§è‡ªé¡¶å‘ä¸‹çš„è¯­æ³•åˆ†ææ–¹æ³•ï¼Œç”¨äºè§£æä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ã€‚LLè§£æå™¨ä»å·¦åˆ°å³æ‰«æè¾“å…¥ï¼Œé‡‡ç”¨æœ€å·¦æ¨å¯¼ï¼Œèƒ½å¤Ÿé«˜æ•ˆåœ°æ„å»ºè¯­æ³•åˆ†ææ ‘ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. ç†è§£LLè§£æçš„åŸºæœ¬åŸç†å’Œç®—æ³•
2. æŒæ¡LL(k)æ–‡æ³•çš„å®šä¹‰å’Œæ€§è´¨
3. å­¦ä¼šæ„å»ºLLè§£æè¡¨å’Œé€’å½’ä¸‹é™è§£æå™¨
4. ç†è§£LLè§£æçš„å±€é™æ€§å’Œåº”ç”¨åœºæ™¯
5. æŒæ¡é”™è¯¯æ¢å¤å’Œä¼˜åŒ–æŠ€æœ¯

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 LLè§£æçš„å®šä¹‰

**å®šä¹‰ 1.1** (LLè§£æ)
LLè§£ææ˜¯ä¸€ç§**è‡ªé¡¶å‘ä¸‹**çš„è¯­æ³•åˆ†ææ–¹æ³•ï¼Œå…¶ä¸­ï¼š
- ç¬¬ä¸€ä¸ªLè¡¨ç¤º**ä»å·¦åˆ°å³**æ‰«æè¾“å…¥
- ç¬¬äºŒä¸ªLè¡¨ç¤º**æœ€å·¦æ¨å¯¼**

**å®šä¹‰ 1.2** (LL(k)æ–‡æ³•)
ä¸€ä¸ªä¸Šä¸‹æ–‡æ— å…³æ–‡æ³• $G$ æ˜¯**LL(k)æ–‡æ³•**ï¼Œå¦‚æœå¯¹äºä»»æ„ä¸¤ä¸ªä¸åŒçš„äº§ç”Ÿå¼ $A \to \alpha$ å’Œ $A \to \beta$ï¼Œä»¥åŠä»»æ„æ¨å¯¼ï¼š
$$S \Rightarrow^* wA\gamma \Rightarrow w\alpha\gamma \Rightarrow^* wx$$
$$S \Rightarrow^* wA\gamma \Rightarrow w\beta\gamma \Rightarrow^* wy$$

å…¶ä¸­ $x, y \in \Sigma^*$ï¼Œéƒ½æœ‰ï¼š
$$\text{FIRST}_k(\alpha \text{FOLLOW}_k(A)) \cap \text{FIRST}_k(\beta \text{FOLLOW}_k(A)) = \emptyset$$

### 1.2 åŸºæœ¬æ¦‚å¿µ

**å®šä¹‰ 1.3** (FIRSTé›†åˆ)
å¯¹äºæ–‡æ³•ç¬¦å·ä¸² $\alpha$ï¼Œ$\text{FIRST}(\alpha)$ å®šä¹‰ä¸ºï¼š
$$\text{FIRST}(\alpha) = \{a \in \Sigma : \alpha \Rightarrow^* a\beta \text{ for some } \beta \in (V \cup \Sigma)^*\} \cup \{\varepsilon : \alpha \Rightarrow^* \varepsilon\}$$

**å®šä¹‰ 1.4** (FOLLOWé›†åˆ)
å¯¹äºéç»ˆç»“ç¬¦ $A$ï¼Œ$\text{FOLLOW}(A)$ å®šä¹‰ä¸ºï¼š
$$\text{FOLLOW}(A) = \{a \in \Sigma : S \Rightarrow^* \alpha Aa\beta \text{ for some } \alpha, \beta \in (V \cup \Sigma)^*\} \cup \{\$ : S \Rightarrow^* \alpha A\}$$

**å®šä¹‰ 1.5** (é¢„æµ‹åˆ†æè¡¨)
LL(1)æ–‡æ³•çš„**é¢„æµ‹åˆ†æè¡¨** $M$ æ˜¯ä¸€ä¸ªäºŒç»´è¡¨ï¼Œå…¶ä¸­ï¼š
$$M[A, a] = \begin{cases}
A \to \alpha & \text{if } a \in \text{FIRST}(\alpha) \\
A \to \alpha & \text{if } \varepsilon \in \text{FIRST}(\alpha) \text{ and } a \in \text{FOLLOW}(A) \\
\text{error} & \text{otherwise}
\end{cases}$$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 LLè§£æçš„å½¢å¼åŒ–æ¨¡å‹

**å®šä¹‰ 2.1** (LLè§£æå™¨çŠ¶æ€)
LLè§£æå™¨çš„çŠ¶æ€æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(S, w, \alpha)$ï¼Œå…¶ä¸­ï¼š
- $S$ æ˜¯æ ˆçš„å†…å®¹
- $w$ æ˜¯å‰©ä½™çš„è¾“å…¥ä¸²
- $\alpha$ æ˜¯å½“å‰çš„åˆ†æé…ç½®

**å®šä¹‰ 2.2** (LLè§£æçš„è½¬ç§»å…³ç³»)
LLè§£æçš„è½¬ç§»å…³ç³» $\vdash$ å®šä¹‰ä¸ºï¼š
1. **åŒ¹é…**ï¼š$(S, aw, \alpha) \vdash (S, w, \alpha)$ å¦‚æœæ ˆé¡¶æ˜¯ç»ˆç»“ç¬¦ $a$
2. **å±•å¼€**ï¼š$(S, w, A\alpha) \vdash (S\beta, w, \alpha)$ å¦‚æœ $A \to \beta$ æ˜¯äº§ç”Ÿå¼
3. **æ¥å—**ï¼š$(\varepsilon, \varepsilon, \varepsilon)$ æ˜¯æ¥å—çŠ¶æ€

### 2.2 LL(k)æ–‡æ³•çš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.3** (LL(k)æ¡ä»¶)
æ–‡æ³• $G$ æ»¡è¶³**LL(k)æ¡ä»¶**ï¼Œå¦‚æœå¯¹äºä»»æ„éç»ˆç»“ç¬¦ $A$ å’Œäº§ç”Ÿå¼ $A \to \alpha_i$ï¼Œ$i = 1, 2, \ldots, n$ï¼Œéƒ½æœ‰ï¼š
$$\text{FIRST}_k(\alpha_i \text{FOLLOW}_k(A)) \cap \text{FIRST}_k(\alpha_j \text{FOLLOW}_k(A)) = \emptyset$$
å¯¹äºæ‰€æœ‰ $i \neq j$ã€‚

**å®šä¹‰ 2.4** (å¼ºLL(k)æ–‡æ³•)
å¦‚æœæ–‡æ³• $G$ æ»¡è¶³ï¼š
$$\text{FIRST}_k(\alpha_i) \cap \text{FIRST}_k(\alpha_j) = \emptyset$$
å¯¹äºæ‰€æœ‰ $A \to \alpha_i$ å’Œ $A \to \alpha_j$ï¼Œ$i \neq j$ï¼Œåˆ™ç§° $G$ æ˜¯**å¼ºLL(k)æ–‡æ³•**ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬å®šç†

**å®šç† 3.1** (LL(1)æ–‡æ³•çš„å……åˆ†å¿…è¦æ¡ä»¶)
ä¸€ä¸ªä¸Šä¸‹æ–‡æ— å…³æ–‡æ³• $G$ æ˜¯LL(1)æ–‡æ³•å½“ä¸”ä»…å½“å¯¹äºä»»æ„éç»ˆç»“ç¬¦ $A$ å’Œäº§ç”Ÿå¼ $A \to \alpha_i$ï¼Œ$i = 1, 2, \ldots, n$ï¼Œéƒ½æœ‰ï¼š
$$\text{FIRST}(\alpha_i) \cap \text{FIRST}(\alpha_j) = \emptyset$$
å¯¹äºæ‰€æœ‰ $i \neq j$ï¼Œä¸”å¦‚æœ $\varepsilon \in \text{FIRST}(\alpha_i)$ï¼Œåˆ™ï¼š
$$\text{FIRST}(\alpha_j) \cap \text{FOLLOW}(A) = \emptyset$$
å¯¹äºæ‰€æœ‰ $j \neq i$ã€‚

**è¯æ˜**ï¼š
å¿…è¦æ€§ï¼šå¦‚æœ $G$ æ˜¯LL(1)æ–‡æ³•ï¼Œé‚£ä¹ˆå¯¹äºä»»æ„ä¸¤ä¸ªäº§ç”Ÿå¼ $A \to \alpha$ å’Œ $A \to \beta$ï¼Œå¿…é¡»èƒ½å¤Ÿé€šè¿‡æŸ¥çœ‹ä¸‹ä¸€ä¸ªè¾“å…¥ç¬¦å·æ¥åŒºåˆ†é€‰æ‹©å“ªä¸ªäº§ç”Ÿå¼ã€‚

å……åˆ†æ€§ï¼šå¦‚æœæ¡ä»¶æ»¡è¶³ï¼Œé‚£ä¹ˆå¯ä»¥æ„å»ºä¸€ä¸ªç¡®å®šæ€§çš„LL(1)è§£æå™¨ã€‚

**å®šç† 3.2** (LL(k)æ–‡æ³•çš„å±‚æ¬¡æ€§)
å¦‚æœæ–‡æ³• $G$ æ˜¯LL(k)æ–‡æ³•ï¼Œé‚£ä¹ˆ $G$ ä¹Ÿæ˜¯LL(k+1)æ–‡æ³•ã€‚

**è¯æ˜**ï¼š
å¦‚æœ $\text{FIRST}_k(\alpha_i \text{FOLLOW}_k(A)) \cap \text{FIRST}_k(\alpha_j \text{FOLLOW}_k(A)) = \emptyset$ï¼Œé‚£ä¹ˆï¼š
$$\text{FIRST}_{k+1}(\alpha_i \text{FOLLOW}_{k+1}(A)) \cap \text{FIRST}_{k+1}(\alpha_j \text{FOLLOW}_{k+1}(A)) = \emptyset$$

### 3.2 ç®—æ³•å®šç†

**å®šç† 3.3** (FIRSTé›†åˆçš„è®¡ç®—)
FIRSTé›†åˆå¯ä»¥é€šè¿‡ä»¥ä¸‹é€’å½’è§„åˆ™è®¡ç®—ï¼š
1. å¦‚æœ $a \in \Sigma$ï¼Œåˆ™ $\text{FIRST}(a) = \{a\}$
2. å¦‚æœ $A \to \varepsilon$ï¼Œåˆ™ $\varepsilon \in \text{FIRST}(A)$
3. å¦‚æœ $A \to \alpha_1\alpha_2\cdots\alpha_n$ï¼Œåˆ™ï¼š
   - $\text{FIRST}(\alpha_1) \setminus \{\varepsilon\} \subseteq \text{FIRST}(A)$
   - å¦‚æœ $\varepsilon \in \text{FIRST}(\alpha_1\alpha_2\cdots\alpha_{i-1})$ï¼Œåˆ™ $\text{FIRST}(\alpha_i) \setminus \{\varepsilon\} \subseteq \text{FIRST}(A)$
   - å¦‚æœ $\varepsilon \in \text{FIRST}(\alpha_1\alpha_2\cdots\alpha_n)$ï¼Œåˆ™ $\varepsilon \in \text{FIRST}(A)$

**å®šç† 3.4** (FOLLOWé›†åˆçš„è®¡ç®—)
FOLLOWé›†åˆå¯ä»¥é€šè¿‡ä»¥ä¸‹è§„åˆ™è®¡ç®—ï¼š
1. $\$ \in \text{FOLLOW}(S)$
2. å¦‚æœ $A \to \alpha B\beta$ï¼Œåˆ™ $\text{FIRST}(\beta) \setminus \{\varepsilon\} \subseteq \text{FOLLOW}(B)$
3. å¦‚æœ $A \to \alpha B$ æˆ– $A \to \alpha B\beta$ ä¸” $\varepsilon \in \text{FIRST}(\beta)$ï¼Œåˆ™ $\text{FOLLOW}(A) \subseteq \text{FOLLOW}(B)$

## 4. ä»£ç å®ç°

### 4.1 Rustå®ç°

```rust
use std::collections::{HashMap, HashSet};

/// æ–‡æ³•ç¬¦å·
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Symbol {
    Terminal(String),
    NonTerminal(String),
    Epsilon,
    EndMarker,
}

/// äº§ç”Ÿå¼
#[derive(Debug, Clone)]
pub struct Production {
    pub left: String,
    pub right: Vec<Symbol>,
}

/// LLè§£æå™¨
#[derive(Debug)]
pub struct LLParser {
    grammar: Vec<Production>,
    first_sets: HashMap<String, HashSet<String>>,
    follow_sets: HashMap<String, HashSet<String>>,
    parse_table: HashMap<(String, String), Vec<Symbol>>,
}

impl LLParser {
    /// åˆ›å»ºæ–°çš„LLè§£æå™¨
    pub fn new(grammar: Vec<Production>) -> Self {
        let mut parser = Self {
            grammar,
            first_sets: HashMap::new(),
            follow_sets: HashMap::new(),
            parse_table: HashMap::new(),
        };
        parser.compute_first_sets();
        parser.compute_follow_sets();
        parser.build_parse_table();
        parser
    }
    
    /// è®¡ç®—FIRSTé›†åˆ
    fn compute_first_sets(&mut self) {
        // åˆå§‹åŒ–
        for production in &self.grammar {
            self.first_sets.insert(production.left.clone(), HashSet::new());
        }
        
        let mut changed = true;
        while changed {
            changed = false;
            
            for production in &self.grammar {
                let first = self.first_sets.get_mut(&production.left).unwrap();
                let original_size = first.len();
                
                // è®¡ç®—äº§ç”Ÿå¼å³éƒ¨çš„FIRSTé›†åˆ
                let right_first = self.first_of_sequence(&production.right);
                first.extend(right_first);
                
                if first.len() > original_size {
                    changed = true;
                }
            }
        }
    }
    
    /// è®¡ç®—ç¬¦å·åºåˆ—çš„FIRSTé›†åˆ
    fn first_of_sequence(&self, symbols: &[Symbol]) -> HashSet<String> {
        let mut first = HashSet::new();
        let mut all_nullable = true;
        
        for symbol in symbols {
            match symbol {
                Symbol::Terminal(t) => {
                    first.insert(t.clone());
                    all_nullable = false;
                    break;
                }
                Symbol::NonTerminal(nt) => {
                    if let Some(nt_first) = self.first_sets.get(nt) {
                        for item in nt_first {
                            if item != "Îµ" {
                                first.insert(item.clone());
                            }
                        }
                        
                        if !nt_first.contains("Îµ") {
                            all_nullable = false;
                            break;
                        }
                    }
                }
                Symbol::Epsilon => {
                    first.insert("Îµ".to_string());
                }
                Symbol::EndMarker => {
                    first.insert("$".to_string());
                    all_nullable = false;
                    break;
                }
            }
        }
        
        if all_nullable {
            first.insert("Îµ".to_string());
        }
        
        first
    }
    
    /// è®¡ç®—FOLLOWé›†åˆ
    fn compute_follow_sets(&mut self) {
        // åˆå§‹åŒ–
        for production in &self.grammar {
            self.follow_sets.insert(production.left.clone(), HashSet::new());
        }
        
        // å¼€å§‹ç¬¦å·çš„FOLLOWé›†åˆåŒ…å«$
        if let Some(start_follow) = self.follow_sets.get_mut(&self.grammar[0].left) {
            start_follow.insert("$".to_string());
        }
        
        let mut changed = true;
        while changed {
            changed = false;
            
            for production in &self.grammar {
                let right = &production.right;
                
                for i in 0..right.len() {
                    if let Symbol::NonTerminal(nt) = &right[i] {
                        let follow = self.follow_sets.get_mut(nt).unwrap();
                        let original_size = follow.len();
                        
                        // è®¡ç®—Î²çš„FIRSTé›†åˆ
                        if i + 1 < right.len() {
                            let beta = &right[i + 1..];
                            let beta_first = self.first_of_sequence(beta);
                            
                            for item in beta_first {
                                if item != "Îµ" {
                                    follow.insert(item);
                                }
                            }
                            
                            // å¦‚æœÎ²å¯ä»¥æ¨å¯¼å‡ºÎµï¼Œåˆ™æ·»åŠ FOLLOW(A)
                            if beta_first.contains("Îµ") {
                                if let Some(a_follow) = self.follow_sets.get(&production.left) {
                                    follow.extend(a_follow.clone());
                                }
                            }
                        } else {
                            // A -> Î±Bï¼Œåˆ™FOLLOW(A) âŠ† FOLLOW(B)
                            if let Some(a_follow) = self.follow_sets.get(&production.left) {
                                follow.extend(a_follow.clone());
                            }
                        }
                        
                        if follow.len() > original_size {
                            changed = true;
                        }
                    }
                }
            }
        }
    }
    
    /// æ„å»ºè§£æè¡¨
    fn build_parse_table(&mut self) {
        for production in &self.grammar {
            let first = self.first_of_sequence(&production.right);
            
            for terminal in first {
                if terminal != "Îµ" {
                    self.parse_table.insert(
                        (production.left.clone(), terminal),
                        production.right.clone(),
                    );
                }
            }
            
            // å¦‚æœÎµåœ¨FIRSTé›†åˆä¸­ï¼Œåˆ™è€ƒè™‘FOLLOWé›†åˆ
            if first.contains("Îµ") {
                if let Some(follow) = self.follow_sets.get(&production.left) {
                    for terminal in follow {
                        self.parse_table.insert(
                            (production.left.clone(), terminal.clone()),
                            production.right.clone(),
                        );
                    }
                }
            }
        }
    }
    
    /// è§£æè¾“å…¥ä¸²
    pub fn parse(&self, input: &str) -> Result<Vec<String>, String> {
        let mut stack = vec![Symbol::EndMarker, Symbol::NonTerminal(self.grammar[0].left.clone())];
        let mut input_tokens: Vec<String> = input
            .split_whitespace()
            .map(|s| s.to_string())
            .collect();
        input_tokens.push("$".to_string());
        
        let mut input_index = 0;
        let mut derivation = Vec::new();
        
        while let Some(top) = stack.last() {
            match top {
                Symbol::Terminal(t) => {
                    if input_index < input_tokens.len() && &input_tokens[input_index] == t {
                        stack.pop();
                        input_index += 1;
                    } else {
                        return Err(format!("Expected '{}', found '{}'", t, input_tokens[input_index]));
                    }
                }
                Symbol::NonTerminal(nt) => {
                    if input_index < input_tokens.len() {
                        let terminal = &input_tokens[input_index];
                        if let Some(production) = self.parse_table.get(&(nt.clone(), terminal.clone())) {
                            stack.pop();
                            for symbol in production.iter().rev() {
                                if let Symbol::Epsilon = symbol {
                                    continue;
                                }
                                stack.push(symbol.clone());
                            }
                            derivation.push(format!("{} -> {}", nt, self.symbols_to_string(production)));
                        } else {
                            return Err(format!("No production for {} with input '{}'", nt, terminal));
                        }
                    } else {
                        return Err("Unexpected end of input".to_string());
                    }
                }
                Symbol::EndMarker => {
                    if input_index < input_tokens.len() && input_tokens[input_index] == "$" {
                        break;
                    } else {
                        return Err("Input not fully consumed".to_string());
                    }
                }
                Symbol::Epsilon => {
                    stack.pop();
                }
            }
        }
        
        Ok(derivation)
    }
    
    /// å°†ç¬¦å·åºåˆ—è½¬æ¢ä¸ºå­—ç¬¦ä¸²
    fn symbols_to_string(&self, symbols: &[Symbol]) -> String {
        symbols
            .iter()
            .map(|s| match s {
                Symbol::Terminal(t) => t.clone(),
                Symbol::NonTerminal(nt) => nt.clone(),
                Symbol::Epsilon => "Îµ".to_string(),
                Symbol::EndMarker => "$".to_string(),
            })
            .collect::<Vec<_>>()
            .join(" ")
    }
    
    /// æ£€æŸ¥æ–‡æ³•æ˜¯å¦ä¸ºLL(1)
    pub fn is_ll1(&self) -> bool {
        let mut conflicts = Vec::new();
        
        for production in &self.grammar {
            let first = self.first_of_sequence(&production.right);
            
            for other_production in &self.grammar {
                if production.left == other_production.left && production.right != other_production.right {
                    let other_first = self.first_of_sequence(&other_production.right);
                    
                    let intersection: HashSet<_> = first.intersection(&other_first).collect();
                    if !intersection.is_empty() {
                        conflicts.push(format!(
                            "Conflict in {}: {} vs {}",
                            production.left,
                            self.symbols_to_string(&production.right),
                            self.symbols_to_string(&other_production.right)
                        ));
                    }
                }
            }
        }
        
        if conflicts.is_empty() {
            true
        } else {
            println!("LL(1) conflicts found:");
            for conflict in conflicts {
                println!("  {}", conflict);
            }
            false
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_simple_ll1_grammar() {
        let grammar = vec![
            Production {
                left: "E".to_string(),
                right: vec![
                    Symbol::NonTerminal("T".to_string()),
                    Symbol::NonTerminal("E'".to_string()),
                ],
            },
            Production {
                left: "E'".to_string(),
                right: vec![
                    Symbol::Terminal("+".to_string()),
                    Symbol::NonTerminal("T".to_string()),
                    Symbol::NonTerminal("E'".to_string()),
                ],
            },
            Production {
                left: "E'".to_string(),
                right: vec![Symbol::Epsilon],
            },
            Production {
                left: "T".to_string(),
                right: vec![
                    Symbol::Terminal("id".to_string()),
                ],
            },
        ];
        
        let parser = LLParser::new(grammar);
        assert!(parser.is_ll1());
        
        let result = parser.parse("id + id");
        assert!(result.is_ok());
    }
}
```

### 4.2 Haskellå®ç°

```haskell
import Data.List (nub, (\\), intersect)
import qualified Data.Map as Map
import qualified Data.Set as Set

-- æ–‡æ³•ç¬¦å·
data Symbol = Terminal String | NonTerminal String | Epsilon | EndMarker
    deriving (Show, Eq, Ord)

-- äº§ç”Ÿå¼
data Production = Production {
    left :: String,
    right :: [Symbol]
} deriving (Show, Eq)

-- LLè§£æå™¨
data LLParser = LLParser {
    grammar :: [Production],
    firstSets :: Map.Map String (Set.Set String),
    followSets :: Map.Map String (Set.Set String),
    parseTable :: Map.Map (String, String) [Symbol]
} deriving (Show)

-- åˆ›å»ºæ–°çš„LLè§£æå™¨
newLLParser :: [Production] -> LLParser
newLLParser g = 
    let first = computeFirstSets g
        follow = computeFollowSets g first
        table = buildParseTable g first follow
    in LLParser g first follow table

-- è®¡ç®—FIRSTé›†åˆ
computeFirstSets :: [Production] -> Map.Map String (Set.Set String)
computeFirstSets grammar = 
    let initial = Map.fromList [(left p, Set.empty) | p <- grammar]
    in fixPoint (updateFirstSets grammar) initial
  where
    fixPoint f x = 
        let x' = f x
        in if x' == x then x else fixPoint f x'
    
    updateFirstSets g firstMap = 
        Map.fromList [(nt, newFirst) | p <- g, let nt = left p, 
                     let newFirst = Set.union (Map.findWithDefault Set.empty nt firstMap) 
                                             (firstOfSequence (right p) firstMap)]
    
    firstOfSequence [] _ = Set.singleton "Îµ"
    firstOfSequence (s:ss) firstMap = case s of
        Terminal t -> Set.singleton t
        NonTerminal nt -> 
            let ntFirst = Map.findWithDefault Set.empty nt firstMap
                restFirst = firstOfSequence ss firstMap
            in if Set.member "Îµ" ntFirst
               then Set.union (Set.delete "Îµ" ntFirst) restFirst
               else Set.delete "Îµ" ntFirst
        Epsilon -> Set.singleton "Îµ"
        EndMarker -> Set.singleton "$"

-- è®¡ç®—FOLLOWé›†åˆ
computeFollowSets :: [Production] -> Map.Map String (Set.Set String) -> Map.Map String (Set.Set String)
computeFollowSets grammar firstSets = 
    let initial = Map.insert (left (head grammar)) (Set.singleton "$") 
                            (Map.fromList [(left p, Set.empty) | p <- grammar])
    in fixPoint (updateFollowSets grammar firstSets) initial
  where
    fixPoint f x = 
        let x' = f x
        in if x' == x then x else fixPoint f x'
    
    updateFollowSets g firstMap followMap = 
        foldl (\acc p -> updateFollowForProduction p firstMap acc) followMap g
    
    updateFollowForProduction p firstMap followMap = 
        let right = right p
            leftNT = left p
        in foldl (\acc (i, symbol) -> 
                    case symbol of
                        NonTerminal nt -> updateFollowForNonTerminal nt i right leftNT firstMap acc
                        _ -> acc) followMap (zip [0..] right)
    
    updateFollowForNonTerminal nt pos right leftNT firstMap followMap = 
        let beta = drop (pos + 1) right
            betaFirst = firstOfSequence beta firstMap
            currentFollow = Map.findWithDefault Set.empty nt followMap
            newFollow = if null beta
                       then Set.union currentFollow (Map.findWithDefault Set.empty leftNT followMap)
                       else let betaFirstNoEpsilon = Set.delete "Îµ" betaFirst
                                leftFollow = Map.findWithDefault Set.empty leftNT followMap
                            in if Set.member "Îµ" betaFirst
                               then Set.union currentFollow (Set.union betaFirstNoEpsilon leftFollow)
                               else Set.union currentFollow betaFirstNoEpsilon
        in Map.insert nt newFollow followMap

-- æ„å»ºè§£æè¡¨
buildParseTable :: [Production] -> Map.Map String (Set.Set String) -> Map.Map String (Set.Set String) -> Map.Map (String, String) [Symbol]
buildParseTable grammar firstSets followSets = 
    foldl (\acc p -> 
        let first = firstOfSequence (right p) firstSets
            leftNT = left p
        in foldl (\acc' terminal -> 
                    if terminal /= "Îµ"
                    then Map.insert (leftNT, terminal) (right p) acc'
                    else acc') 
                (foldl (\acc' terminal -> 
                         Map.insert (leftNT, terminal) (right p) acc') acc 
                       (Map.findWithDefault Set.empty leftNT followSets))
                (Set.delete "Îµ" first)) Map.empty grammar

-- è§£æè¾“å…¥
parse :: LLParser -> [String] -> Either String [String]
parse parser input = 
    let tokens = input ++ ["$"]
        initialStack = [EndMarker, NonTerminal (left (head (grammar parser)))]
    in parseHelper parser tokens initialStack []
  where
    parseHelper _ [] _ _ = Left "Unexpected end of input"
    parseHelper _ _ [] _ = Left "Stack empty"
    parseHelper p (t:ts) (s:ss) derivation = case s of
        Terminal term -> 
            if t == term
            then parseHelper p ts ss derivation
            else Left $ "Expected '" ++ term ++ "', found '" ++ t ++ "'"
        NonTerminal nt -> 
            case Map.lookup (nt, t) (parseTable p) of
                Just production -> 
                    let newStack = reverse production ++ ss
                        newDerivation = derivation ++ [nt ++ " -> " ++ symbolsToString production]
                    in parseHelper p (t:ts) newStack newDerivation
                Nothing -> Left $ "No production for " ++ nt ++ " with input '" ++ t ++ "'"
        EndMarker -> 
            if t == "$"
            then Right derivation
            else Left "Input not fully consumed"
        Epsilon -> parseHelper p (t:ts) ss derivation

-- è¾…åŠ©å‡½æ•°
symbolsToString :: [Symbol] -> String
symbolsToString = unwords . map symbolToString
  where
    symbolToString (Terminal t) = t
    symbolToString (NonTerminal nt) = nt
    symbolToString Epsilon = "Îµ"
    symbolToString EndMarker = "$"

-- æ£€æŸ¥æ˜¯å¦ä¸ºLL(1)æ–‡æ³•
isLL1 :: LLParser -> Bool
isLL1 parser = 
    let conflicts = findConflicts (grammar parser) (firstSets parser)
    in null conflicts
  where
    findConflicts g firstMap = 
        concatMap (\p1 -> 
            concatMap (\p2 -> 
                if left p1 == left p2 && right p1 /= right p2
                then let first1 = firstOfSequence (right p1) firstMap
                         first2 = firstOfSequence (right p2) firstMap
                         intersection = Set.intersection first1 first2
                     in if Set.null intersection
                        then []
                        else ["Conflict in " ++ left p1 ++ ": " ++ symbolsToString (right p1) ++ " vs " ++ symbolsToString (right p2)]
                else []) g) g

-- ç¤ºä¾‹ä½¿ç”¨
main :: IO ()
main = do
    putStrLn "LLè§£æç¤ºä¾‹ï¼š"
    
    -- ç®€å•çš„ç®—æœ¯è¡¨è¾¾å¼æ–‡æ³•
    let grammar = [
            Production "E" [NonTerminal "T", NonTerminal "E'"],
            Production "E'" [Terminal "+", NonTerminal "T", NonTerminal "E'"],
            Production "E'" [Epsilon],
            Production "T" [Terminal "id"]
        ]
    
    let parser = newLLParser grammar
    
    putStrLn $ "Is LL(1): " ++ show (isLL1 parser)
    
    let result = parse parser ["id", "+", "id"]
    case result of
        Right derivation -> do
            putStrLn "è§£ææˆåŠŸï¼š"
            mapM_ putStrLn derivation
        Left error -> putStrLn $ "è§£æé”™è¯¯: " ++ error
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç®€å•ç®—æœ¯è¡¨è¾¾å¼è§£æ

**é—®é¢˜**ï¼šè§£æç®€å•çš„ç®—æœ¯è¡¨è¾¾å¼ï¼Œå¦‚ `id + id * id`ã€‚

**è§£**ï¼š
ä½¿ç”¨LL(1)æ–‡æ³•ï¼š
```
E -> T E'
E' -> + T E' | Îµ
T -> F T'
T' -> * F T' | Îµ
F -> id | (E)
```

### 5.2 ç¼–ç¨‹è¯­è¨€è¯­æ³•åˆ†æ

**é—®é¢˜**ï¼šä¸ºç®€å•çš„ç¼–ç¨‹è¯­è¨€æ„å»ºè¯­æ³•åˆ†æå™¨ã€‚

**è§£**ï¼š
```rust
pub fn parse_program(input: &str) -> Result<AST, String> {
    let grammar = vec![
        // ç¨‹åº -> è¯­å¥åˆ—è¡¨
        Production {
            left: "Program".to_string(),
            right: vec![Symbol::NonTerminal("StmtList".to_string())],
        },
        // è¯­å¥åˆ—è¡¨ -> è¯­å¥ è¯­å¥åˆ—è¡¨ | Îµ
        Production {
            left: "StmtList".to_string(),
            right: vec![
                Symbol::NonTerminal("Statement".to_string()),
                Symbol::NonTerminal("StmtList".to_string()),
            ],
        },
        Production {
            left: "StmtList".to_string(),
            right: vec![Symbol::Epsilon],
        },
        // è¯­å¥ -> èµ‹å€¼ | æ¡ä»¶ | å¾ªç¯
        Production {
            left: "Statement".to_string(),
            right: vec![Symbol::NonTerminal("Assignment".to_string())],
        },
        // èµ‹å€¼ -> id = è¡¨è¾¾å¼
        Production {
            left: "Assignment".to_string(),
            right: vec![
                Symbol::Terminal("id".to_string()),
                Symbol::Terminal("=".to_string()),
                Symbol::NonTerminal("Expression".to_string()),
            ],
        },
    ];
    
    let parser = LLParser::new(grammar);
    parser.parse(input)
}
```

### 5.3 é…ç½®æ–‡ä»¶è§£æ

**é—®é¢˜**ï¼šè§£æé…ç½®æ–‡ä»¶æ ¼å¼ï¼Œå¦‚INIæ–‡ä»¶ã€‚

**è§£**ï¼š
```rust
pub fn parse_ini_file(content: &str) -> Result<HashMap<String, HashMap<String, String>>, String> {
    let grammar = vec![
        // æ–‡ä»¶ -> èŠ‚åˆ—è¡¨
        Production {
            left: "File".to_string(),
            right: vec![Symbol::NonTerminal("SectionList".to_string())],
        },
        // èŠ‚åˆ—è¡¨ -> èŠ‚ èŠ‚åˆ—è¡¨ | Îµ
        Production {
            left: "SectionList".to_string(),
            right: vec![
                Symbol::NonTerminal("Section".to_string()),
                Symbol::NonTerminal("SectionList".to_string()),
            ],
        },
        Production {
            left: "SectionList".to_string(),
            right: vec![Symbol::Epsilon],
        },
        // èŠ‚ -> [èŠ‚å] é”®å€¼å¯¹åˆ—è¡¨
        Production {
            left: "Section".to_string(),
            right: vec![
                Symbol::Terminal("[".to_string()),
                Symbol::NonTerminal("SectionName".to_string()),
                Symbol::Terminal("]".to_string()),
                Symbol::NonTerminal("KeyValueList".to_string()),
            ],
        },
        // é”®å€¼å¯¹åˆ—è¡¨ -> é”®å€¼å¯¹ é”®å€¼å¯¹åˆ—è¡¨ | Îµ
        Production {
            left: "KeyValueList".to_string(),
            right: vec![
                Symbol::NonTerminal("KeyValue".to_string()),
                Symbol::NonTerminal("KeyValueList".to_string()),
            ],
        },
        Production {
            left: "KeyValueList".to_string(),
            right: vec![Symbol::Epsilon],
        },
        // é”®å€¼å¯¹ -> é”® = å€¼
        Production {
            left: "KeyValue".to_string(),
            right: vec![
                Symbol::NonTerminal("Key".to_string()),
                Symbol::Terminal("=".to_string()),
                Symbol::NonTerminal("Value".to_string()),
            ],
        },
    ];
    
    let parser = LLParser::new(grammar);
    parser.parse(content)
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å½¢å¼è¯­è¨€ç†è®ºçš„å…³ç³»

- **ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•**ï¼šLLè§£æçš„åŸºç¡€
- **ä¹”å§†æ–¯åŸºè°±ç³»**ï¼šLL(k)æ–‡æ³•çš„å±‚æ¬¡
- **è‡ªåŠ¨æœºç†è®º**ï¼šä¸‹æ¨è‡ªåŠ¨æœºçš„å®ç°

### 6.2 ä¸ç¼–è¯‘åŸç†çš„å…³ç³»

- **è¯­æ³•åˆ†æ**ï¼šç¼–è¯‘å™¨å‰ç«¯çš„é‡è¦ç»„æˆéƒ¨åˆ†
- **é”™è¯¯æ¢å¤**ï¼šè¯­æ³•é”™è¯¯çš„æ£€æµ‹å’Œæ¢å¤
- **ä»£ç ç”Ÿæˆ**ï¼šè¯­æ³•æ ‘åˆ°ç›®æ ‡ä»£ç çš„è½¬æ¢

### 6.3 ä¸å…¶ä»–è§£ææ–¹æ³•çš„å…³ç³»

- **LRè§£æ**ï¼šè‡ªåº•å‘ä¸Šçš„è§£ææ–¹æ³•
- **é€’å½’ä¸‹é™**ï¼šLLè§£æçš„æ‰‹å·¥å®ç°
- **é¢„æµ‹è§£æ**ï¼šLLè§£æçš„å¦ä¸€ç§ç§°å‘¼

### 6.4 ä¸è½¯ä»¶å·¥ç¨‹çš„å…³ç³»

- **è§£æå™¨ç”Ÿæˆå™¨**ï¼šå¦‚ANTLRã€Yaccç­‰å·¥å…·
- **é¢†åŸŸç‰¹å®šè¯­è¨€**ï¼šDSLçš„è¯­æ³•è®¾è®¡
- **é…ç½®æ–‡ä»¶è§£æ**ï¼šå„ç§æ ¼å¼çš„è§£æ

## 7. å‚è€ƒæ–‡çŒ®

1. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). *Compilers: Principles, Techniques, and Tools*. Pearson.
2. Grune, D., & Jacobs, C. J. (2008). *Parsing Techniques: A Practical Guide*. Springer.
3. Sippu, S., & Soisalon-Soininen, E. (1990). *Parsing Theory*. Springer.
4. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation*. Pearson.
5. Appel, A. W. (2002). *Modern Compiler Implementation*. Cambridge University Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [03.1.1 æœ‰é™è‡ªåŠ¨æœº](../03_Formal_Language_Theory/03.1.1_æœ‰é™è‡ªåŠ¨æœº.md)
- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03_Formal_Language_Theory/03.2.2_ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•.md)
- [03.4.2 LRè§£æ](../03_Formal_Language_Theory/03.4.2_LRè§£æ.md)
- [03.4.3 é€’å½’ä¸‹é™è§£æ](../03_Formal_Language_Theory/03.4.3_é€’å½’ä¸‹é™è§£æ.md)
- [04.1.1 ç®€å•ç±»å‹Î»æ¼”ç®—](../04_Type_Theory/04.1.1_ç®€å•ç±»å‹Î»æ¼”ç®—.md) 