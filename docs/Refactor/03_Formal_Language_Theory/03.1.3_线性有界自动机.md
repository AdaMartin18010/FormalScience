# 03.1.3 çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº

## ğŸ“‹ æ¦‚è¿°

çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº(LBA)æ˜¯å›¾çµæœºçš„ä¸€ç§å—é™å½¢å¼ï¼Œå…¶è¯»å†™å¤´åªèƒ½åœ¨è¾“å…¥å­—ç¬¦ä¸²çš„èŒƒå›´å†…ç§»åŠ¨ã€‚æœ¬æ–‡æ¡£å»ºç«‹LBAçš„å®Œæ•´ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬å½¢å¼åŒ–å®šä¹‰ã€è®¡ç®—èƒ½åŠ›ã€å¤æ‚åº¦åˆ†æå’Œåº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹LBAçš„å½¢å¼åŒ–å®šä¹‰
2. åˆ†æLBAçš„è®¡ç®—èƒ½åŠ›
3. æ„å»ºLBAçš„å¤æ‚åº¦ç†è®º
4. æä¾›LBAçš„ç®—æ³•å®ç°
5. å®ç°LBAçš„éªŒè¯ç³»ç»Ÿ

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 LBAçš„æœ¬è´¨

çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºæ˜¯å›¾çµæœºçš„å—é™ç‰ˆæœ¬ï¼Œå…¶ç£å¸¦é•¿åº¦ä¸è¾“å…¥é•¿åº¦æˆæ­£æ¯”ã€‚

**å®šä¹‰ 1.1.1** (çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº)
çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºæ˜¯ä¸€ç§å›¾çµæœºï¼Œå…¶ç£å¸¦é•¿åº¦é™åˆ¶ä¸ºè¾“å…¥é•¿åº¦çš„çº¿æ€§å‡½æ•°ã€‚

**å®šä¹‰ 1.1.2** (LBAçš„ç‰¹ç‚¹)
LBAå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š
1. ç£å¸¦é•¿åº¦ä¸è¾“å…¥é•¿åº¦æˆæ­£æ¯”
2. è¯»å†™å¤´ä¸èƒ½è¶…å‡ºç£å¸¦è¾¹ç•Œ
3. è®¡ç®—èƒ½åŠ›ä»‹äºä¸‹æ¨è‡ªåŠ¨æœºå’Œå›¾çµæœºä¹‹é—´

### 1.2 LBAçš„åˆ†ç±»

**å®šä¹‰ 1.1.3** (ç¡®å®šæ€§LBA)
ç¡®å®šæ€§LBAåœ¨æ¯ä¸ªé…ç½®ä¸‹æœ€å¤šæœ‰ä¸€ä¸ªå¯èƒ½çš„è½¬ç§»ã€‚

**å®šä¹‰ 1.1.4** (éç¡®å®šæ€§LBA)
éç¡®å®šæ€§LBAåœ¨æ¯ä¸ªé…ç½®ä¸‹å¯èƒ½æœ‰å¤šä¸ªå¯èƒ½çš„è½¬ç§»ã€‚

**å®šä¹‰ 1.1.5** (åŒå‘LBA)
åŒå‘LBAçš„è¯»å†™å¤´å¯ä»¥å‘å·¦å’Œå‘å³ç§»åŠ¨ã€‚

### 1.3 LBAçš„è®¡ç®—èƒ½åŠ›

**å®šä¹‰ 1.1.6** (LBAå¯è¯†åˆ«è¯­è¨€)
LBAå¯è¯†åˆ«çš„è¯­è¨€ç±»ç§°ä¸ºä¸Šä¸‹æ–‡æœ‰å…³è¯­è¨€(CSL)ã€‚

**å®šä¹‰ 1.1.7** (LBAçš„è®¡ç®—å¤æ‚åº¦)
LBAçš„è®¡ç®—å¤æ‚åº¦é€šå¸¸ä¸ºå¤šé¡¹å¼æ—¶é—´ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 LBAçš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1.1** (çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº)
çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºæ˜¯ä¸ƒå…ƒç»„ $M = (Q, \Sigma, \Gamma, \delta, q_0, q_{accept}, q_{reject})$ï¼Œå…¶ä¸­ï¼š

1. $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†
2. $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
3. $\Gamma$ æ˜¯ç£å¸¦å­—æ¯è¡¨ï¼Œ$\Sigma \subseteq \Gamma$
4. $\delta: Q \times \Gamma \rightarrow \mathcal{P}(Q \times \Gamma \times \{L, R\})$ æ˜¯è½¬ç§»å‡½æ•°
5. $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
6. $q_{accept} \in Q$ æ˜¯æ¥å—çŠ¶æ€
7. $q_{reject} \in Q$ æ˜¯æ‹’ç»çŠ¶æ€

**å®šä¹‰ 2.1.2** (LBAé…ç½®)
LBAçš„é…ç½®æ˜¯ä¸‰å…ƒç»„ $(q, i, w)$ï¼Œå…¶ä¸­ï¼š
- $q \in Q$ æ˜¯å½“å‰çŠ¶æ€
- $i \in \{0, 1, \ldots, |w|\}$ æ˜¯è¯»å†™å¤´ä½ç½®
- $w \in \Gamma^*$ æ˜¯ç£å¸¦å†…å®¹

**å®šä¹‰ 2.1.3** (LBAè½¬ç§»å…³ç³»)
é…ç½® $(q, i, w)$ è½¬ç§»åˆ° $(q', i', w')$ï¼Œè®°ä½œ $(q, i, w) \vdash (q', i', w')$ï¼Œå½“ä¸”ä»…å½“ï¼š

1. $\delta(q, w_i) = (q', \sigma, D)$
2. $w' = w_0 \cdots w_{i-1} \sigma w_{i+1} \cdots w_{|w|-1}$
3. $i' = \begin{cases} i-1 & \text{if } D = L \\ i+1 & \text{if } D = R \end{cases}$
4. $0 \leq i' \leq |w'|$

### 2.2 LBAçš„è¯­è¨€è¯†åˆ«

**å®šä¹‰ 2.2.1** (LBAæ¥å—çš„è¯­è¨€)
LBA $M$ æ¥å—çš„è¯­è¨€å®šä¹‰ä¸ºï¼š
$$L(M) = \{w \in \Sigma^* : (q_0, 0, w) \vdash^* (q_{accept}, i, w')\}$$

**å®šä¹‰ 2.2.2** (LBAæ‹’ç»çš„è¯­è¨€)
LBA $M$ æ‹’ç»çš„è¯­è¨€å®šä¹‰ä¸ºï¼š
$$\overline{L(M)} = \{w \in \Sigma^* : (q_0, 0, w) \vdash^* (q_{reject}, i, w')\}$$

**å®šä¹‰ 2.2.3** (LBAçš„åœæœºæ€§)
LBAæ€»æ˜¯åœæœºï¼Œå› ä¸ºç£å¸¦é•¿åº¦æœ‰é™ä¸”è½¬ç§»å‡½æ•°æ˜¯ç¡®å®šçš„ã€‚

### 2.3 LBAçš„å¤æ‚åº¦

**å®šä¹‰ 2.3.1** (LBAçš„æ—¶é—´å¤æ‚åº¦)
LBAçš„æ—¶é—´å¤æ‚åº¦æ˜¯æ¥å—è¾“å…¥æ‰€éœ€çš„æœ€å¤§æ­¥æ•°ã€‚

**å®šä¹‰ 2.3.2** (LBAçš„ç©ºé—´å¤æ‚åº¦)
LBAçš„ç©ºé—´å¤æ‚åº¦æ˜¯ç£å¸¦é•¿åº¦çš„å‡½æ•°ã€‚

**å®šä¹‰ 2.3.3** (LBAçš„çº¿æ€§æœ‰ç•Œæ€§)
LBAçš„ç£å¸¦é•¿åº¦é™åˆ¶ä¸º $c \cdot |w|$ï¼Œå…¶ä¸­ $c$ æ˜¯å¸¸æ•°ï¼Œ$w$ æ˜¯è¾“å…¥ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬æ€§è´¨å®šç†

**å®šç† 3.1.1** (LBAçš„åœæœºæ€§)
æ¯ä¸ªLBAéƒ½ä¿è¯åœæœºã€‚

**è¯æ˜**ï¼š
ç”±äºç£å¸¦é•¿åº¦æœ‰é™ï¼ˆä¸è¾“å…¥é•¿åº¦æˆæ­£æ¯”ï¼‰ï¼Œä¸”æ¯ä¸ªè½¬ç§»éƒ½æ¶ˆè€—è‡³å°‘ä¸€ä¸ªæ—¶é—´æ­¥ï¼ŒLBAæœ€å¤šæ‰§è¡Œ $O(|w|^2)$ æ­¥åå¿…é¡»åœæœºã€‚

**å®šç† 3.1.2** (LBAçš„ç¡®å®šæ€§)
ç¡®å®šæ€§LBAå’Œéç¡®å®šæ€§LBAè¯†åˆ«ç›¸åŒçš„è¯­è¨€ç±»ã€‚

**è¯æ˜**ï¼š
é€šè¿‡æ¨¡æ‹ŸæŠ€æœ¯ï¼Œéç¡®å®šæ€§LBAå¯ä»¥è¢«ç¡®å®šæ€§LBAæ¨¡æ‹Ÿï¼Œè™½ç„¶æ—¶é—´å¤æ‚åº¦å¯èƒ½å¢åŠ ã€‚

**å®šç† 3.1.3** (LBAä¸ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•)
LBAè¯†åˆ«çš„è¯­è¨€ç±»ç­‰ä»·äºä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•ç”Ÿæˆçš„è¯­è¨€ç±»ã€‚

**è¯æ˜**ï¼š
é€šè¿‡æ„é€ æ€§è¯æ˜ï¼Œå¯ä»¥å»ºç«‹LBAå’Œä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•ä¹‹é—´çš„å¯¹åº”å…³ç³»ã€‚

### 3.2 è®¡ç®—èƒ½åŠ›å®šç†

**å®šç† 3.2.1** (LBAçš„è®¡ç®—èƒ½åŠ›)
LBAçš„è®¡ç®—èƒ½åŠ›ä¸¥æ ¼å¼ºäºä¸‹æ¨è‡ªåŠ¨æœºï¼Œä¸¥æ ¼å¼±äºå›¾çµæœºã€‚

**è¯æ˜**ï¼š
1. LBAå¯ä»¥æ¨¡æ‹Ÿä¸‹æ¨è‡ªåŠ¨æœº
2. LBAä¸èƒ½æ¨¡æ‹Ÿé€šç”¨å›¾çµæœºï¼ˆå› ä¸ºç£å¸¦é•¿åº¦é™åˆ¶ï¼‰
3. å­˜åœ¨LBAæ— æ³•è¯†åˆ«çš„é€’å½’å¯æšä¸¾è¯­è¨€

**å®šç† 3.2.2** (LBAçš„å°é—­æ€§)
LBAè¯†åˆ«çš„è¯­è¨€ç±»åœ¨ä»¥ä¸‹è¿ç®—ä¸‹å°é—­ï¼š

1. **å¹¶è¿ç®—**ï¼š$L_1 \cup L_2$
2. **äº¤è¿ç®—**ï¼š$L_1 \cap L_2$
3. **è¡¥è¿ç®—**ï¼š$\overline{L}$
4. **è¿æ¥è¿ç®—**ï¼š$L_1 \cdot L_2$
5. **æ˜Ÿè¿ç®—**ï¼š$L^*$

**è¯æ˜**ï¼š
é€šè¿‡æ„é€ æ–°çš„LBAæ¥è¯æ˜æ¯ç§è¿ç®—çš„å°é—­æ€§ã€‚

### 3.3 å¤æ‚åº¦å®šç†

**å®šç† 3.3.1** (LBAçš„æ—¶é—´å¤æ‚åº¦)
LBAçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ï¼Œå…¶ä¸­ $n$ æ˜¯è¾“å…¥é•¿åº¦ã€‚

**å®šç† 3.3.2** (LBAçš„ç©ºé—´å¤æ‚åº¦)
LBAçš„ç©ºé—´å¤æ‚åº¦ä¸º $O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯è¾“å…¥é•¿åº¦ã€‚

**å®šç† 3.3.3** (LBAçš„ç­‰ä»·æ€§)
ä¸¤ä¸ªLBAæ˜¯å¦ç­‰ä»·æ˜¯å¯åˆ¤å®šçš„ã€‚

**è¯æ˜**ï¼š
ç”±äºLBAæ€»æ˜¯åœæœºï¼Œå¯ä»¥é€šè¿‡æšä¸¾æ‰€æœ‰å¯èƒ½çš„è¾“å…¥æ¥åˆ¤å®šç­‰ä»·æ€§ã€‚

## 4. ä»£ç å®ç°

### 4.1 LBAæ•°æ®ç»“æ„

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Direction {
    Left,
    Right,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Transition {
    next_state: String,
    write_symbol: char,
    direction: Direction,
}

#[derive(Debug, Clone)]
pub struct LBA {
    states: Vec<String>,
    input_alphabet: Vec<char>,
    tape_alphabet: Vec<char>,
    transitions: HashMap<(String, char), Vec<Transition>>,
    initial_state: String,
    accept_state: String,
    reject_state: String,
    tape_bound: usize, // ç£å¸¦é•¿åº¦é™åˆ¶çš„å€æ•°
}

#[derive(Debug, Clone)]
pub struct LBAConfiguration {
    state: String,
    head_position: usize,
    tape_content: Vec<char>,
}

impl LBA {
    pub fn new(
        states: Vec<String>,
        input_alphabet: Vec<char>,
        tape_alphabet: Vec<char>,
        initial_state: String,
        accept_state: String,
        reject_state: String,
        tape_bound: usize,
    ) -> Self {
        Self {
            states,
            input_alphabet,
            tape_alphabet,
            transitions: HashMap::new(),
            initial_state,
            accept_state,
            reject_state,
            tape_bound,
        }
    }
    
    pub fn add_transition(
        &mut self,
        current_state: &str,
        read_symbol: char,
        next_state: &str,
        write_symbol: char,
        direction: Direction,
    ) {
        let transition = Transition {
            next_state: next_state.to_string(),
            write_symbol,
            direction,
        };
        
        self.transitions
            .entry((current_state.to_string(), read_symbol))
            .or_insert_with(Vec::new)
            .push(transition);
    }
    
    pub fn get_transitions(&self, state: &str, symbol: char) -> Option<&Vec<Transition>> {
        self.transitions.get(&(state.to_string(), symbol))
    }
    
    pub fn is_deterministic(&self) -> bool {
        for transitions in self.transitions.values() {
            if transitions.len() > 1 {
                return false;
            }
        }
        true
    }
}
```

### 4.2 LBAæ‰§è¡Œå¼•æ“

```rust
impl LBA {
    /// åˆ›å»ºåˆå§‹é…ç½®
    pub fn create_initial_config(&self, input: &str) -> LBAConfiguration {
        let tape_length = input.len() * self.tape_bound;
        let mut tape_content = vec!['B'; tape_length]; // Bè¡¨ç¤ºç©ºç™½ç¬¦å·
        
        // å°†è¾“å…¥å†™å…¥ç£å¸¦
        for (i, ch) in input.chars().enumerate() {
            if i < tape_content.len() {
                tape_content[i] = ch;
            }
        }
        
        LBAConfiguration {
            state: self.initial_state.clone(),
            head_position: 0,
            tape_content,
        }
    }
    
    /// æ‰§è¡Œä¸€æ­¥è½¬ç§»
    pub fn step(&self, config: &LBAConfiguration) -> Vec<LBAConfiguration> {
        let current_symbol = config.tape_content[config.head_position];
        
        if let Some(transitions) = self.get_transitions(&config.state, current_symbol) {
            let mut next_configs = Vec::new();
            
            for transition in transitions {
                let mut new_config = config.clone();
                new_config.state = transition.next_state.clone();
                new_config.tape_content[config.head_position] = transition.write_symbol;
                
                match transition.direction {
                    Direction::Left => {
                        if new_config.head_position > 0 {
                            new_config.head_position -= 1;
                        }
                    }
                    Direction::Right => {
                        if new_config.head_position < new_config.tape_content.len() - 1 {
                            new_config.head_position += 1;
                        }
                    }
                }
                
                next_configs.push(new_config);
            }
            
            next_configs
        } else {
            Vec::new() // æ²¡æœ‰è½¬ç§»ï¼Œåœæœº
        }
    }
    
    /// æ‰§è¡ŒLBAç›´åˆ°åœæœº
    pub fn run(&self, input: &str) -> LBAExecutionResult {
        let mut current_configs = vec![self.create_initial_config(input)];
        let mut step_count = 0;
        let max_steps = input.len() * input.len() * self.tape_bound; // é˜²æ­¢æ— é™å¾ªç¯
        
        while step_count < max_steps {
            let mut next_configs = Vec::new();
            
            for config in &current_configs {
                if config.state == self.accept_state {
                    return LBAExecutionResult::Accept {
                        steps: step_count,
                        final_config: config.clone(),
                    };
                }
                
                if config.state == self.reject_state {
                    return LBAExecutionResult::Reject {
                        steps: step_count,
                        final_config: config.clone(),
                    };
                }
                
                let new_configs = self.step(config);
                next_configs.extend(new_configs);
            }
            
            if next_configs.is_empty() {
                return LBAExecutionResult::Reject {
                    steps: step_count,
                    final_config: current_configs[0].clone(),
                };
            }
            
            current_configs = next_configs;
            step_count += 1;
        }
        
        LBAExecutionResult::Timeout {
            steps: step_count,
            final_configs: current_configs,
        }
    }
    
    /// æ£€æŸ¥æ˜¯å¦æ¥å—è¾“å…¥
    pub fn accepts(&self, input: &str) -> bool {
        match self.run(input) {
            LBAExecutionResult::Accept { .. } => true,
            _ => false,
        }
    }
}

#[derive(Debug)]
pub enum LBAExecutionResult {
    Accept {
        steps: usize,
        final_config: LBAConfiguration,
    },
    Reject {
        steps: usize,
        final_config: LBAConfiguration,
    },
    Timeout {
        steps: usize,
        final_configs: Vec<LBAConfiguration>,
    },
}
```

### 4.3 LBAæ„é€ å™¨

```rust
pub struct LBABuilder;

impl LBABuilder {
    /// æ„é€ è¯†åˆ«å›æ–‡çš„LBA
    pub fn build_palindrome_lba() -> LBA {
        let mut lba = LBA::new(
            vec![
                "q0".to_string(), "q1".to_string(), "q2".to_string(),
                "q3".to_string(), "qaccept".to_string(), "qreject".to_string(),
            ],
            vec!['0', '1'],
            vec!['0', '1', 'B', 'X'],
            "q0".to_string(),
            "qaccept".to_string(),
            "qreject".to_string(),
            2,
        );
        
        // åˆå§‹çŠ¶æ€ï¼šæ£€æŸ¥ç¬¬ä¸€ä¸ªç¬¦å·
        lba.add_transition("q0", '0', "q1", 'X', Direction::Right);
        lba.add_transition("q0", '1', "q2", 'X', Direction::Right);
        lba.add_transition("q0", 'B', "qaccept", 'B', Direction::Left);
        
        // çŠ¶æ€q1ï¼šå¯»æ‰¾åŒ¹é…çš„0
        lba.add_transition("q1", '0', "q1", '0', Direction::Right);
        lba.add_transition("q1", '1', "q1", '1', Direction::Right);
        lba.add_transition("q1", 'B', "q3", 'B', Direction::Left);
        
        // çŠ¶æ€q2ï¼šå¯»æ‰¾åŒ¹é…çš„1
        lba.add_transition("q2", '0', "q2", '0', Direction::Right);
        lba.add_transition("q2", '1', "q2", '1', Direction::Right);
        lba.add_transition("q2", 'B', "q3", 'B', Direction::Left);
        
        // çŠ¶æ€q3ï¼šå‘å·¦ç§»åŠ¨å¹¶æ£€æŸ¥
        lba.add_transition("q3", '0', "q3", '0', Direction::Left);
        lba.add_transition("q3", '1', "q3", '1', Direction::Left);
        lba.add_transition("q3", 'X', "q0", 'X', Direction::Right);
        
        lba
    }
    
    /// æ„é€ è¯†åˆ«a^n b^n c^nçš„LBA
    pub fn build_anbncn_lba() -> LBA {
        let mut lba = LBA::new(
            vec![
                "q0".to_string(), "q1".to_string(), "q2".to_string(),
                "q3".to_string(), "q4".to_string(), "q5".to_string(),
                "qaccept".to_string(), "qreject".to_string(),
            ],
            vec!['a', 'b', 'c'],
            vec!['a', 'b', 'c', 'X', 'Y', 'Z', 'B'],
            "q0".to_string(),
            "qaccept".to_string(),
            "qreject".to_string(),
            3,
        );
        
        // åˆå§‹çŠ¶æ€ï¼šæ ‡è®°ç¬¬ä¸€ä¸ªa
        lba.add_transition("q0", 'a', "q1", 'X', Direction::Right);
        lba.add_transition("q0", 'B', "qaccept", 'B', Direction::Left);
        
        // çŠ¶æ€q1ï¼šå¯»æ‰¾ç¬¬ä¸€ä¸ªb
        lba.add_transition("q1", 'a', "q1", 'a', Direction::Right);
        lba.add_transition("q1", 'b', "q2", 'Y', Direction::Right);
        
        // çŠ¶æ€q2ï¼šå¯»æ‰¾ç¬¬ä¸€ä¸ªc
        lba.add_transition("q2", 'b', "q2", 'b', Direction::Right);
        lba.add_transition("q2", 'c', "q3", 'Z', Direction::Left);
        
        // çŠ¶æ€q3ï¼šå‘å·¦ç§»åŠ¨
        lba.add_transition("q3", 'a', "q3", 'a', Direction::Left);
        lba.add_transition("q3", 'b', "q3", 'b', Direction::Left);
        lba.add_transition("q3", 'X', "q4", 'X', Direction::Right);
        lba.add_transition("q3", 'Y', "q4", 'Y', Direction::Right);
        lba.add_transition("q3", 'Z", "q4", 'Z', Direction::Right);
        
        // çŠ¶æ€q4ï¼šæ£€æŸ¥æ˜¯å¦è¿˜æœ‰æœªæ ‡è®°çš„ç¬¦å·
        lba.add_transition("q4", 'a', "q1", 'X', Direction::Right);
        lba.add_transition("q4", 'b', "q5", 'Y', Direction::Right);
        lba.add_transition("q4", 'c', "qreject", 'c', Direction::Right);
        lba.add_transition("q4", 'B', "qaccept", 'B', Direction::Left);
        
        // çŠ¶æ€q5ï¼šæ£€æŸ¥å‰©ä½™çš„bå’Œc
        lba.add_transition("q5", 'b', "q5", 'b', Direction::Right);
        lba.add_transition("q5", 'c', "q3", 'Z', Direction::Left);
        
        lba
    }
}
```

### 4.4 LBAåˆ†æå™¨

```rust
pub struct LBAAnalyzer;

impl LBAAnalyzer {
    /// åˆ†æLBAçš„æ—¶é—´å¤æ‚åº¦
    pub fn analyze_time_complexity(lba: &LBA, test_inputs: &[&str]) -> TimeComplexityAnalysis {
        let mut results = Vec::new();
        
        for input in test_inputs {
            match lba.run(input) {
                LBAExecutionResult::Accept { steps, .. } |
                LBAExecutionResult::Reject { steps, .. } => {
                    results.push((input.len(), steps));
                }
                LBAExecutionResult::Timeout { steps, .. } => {
                    results.push((input.len(), steps));
                }
            }
        }
        
        // è®¡ç®—å¤æ‚åº¦
        let max_steps = results.iter().map(|(_, steps)| *steps).max().unwrap_or(0);
        let max_length = results.iter().map(|(len, _)| *len).max().unwrap_or(0);
        
        TimeComplexityAnalysis {
            max_steps,
            max_input_length: max_length,
            complexity_class: Self::classify_complexity(max_steps, max_length),
            results,
        }
    }
    
    /// åˆ†æLBAçš„ç©ºé—´å¤æ‚åº¦
    pub fn analyze_space_complexity(lba: &LBA, test_inputs: &[&str]) -> SpaceComplexityAnalysis {
        let mut results = Vec::new();
        
        for input in test_inputs {
            let tape_length = input.len() * lba.tape_bound;
            results.push((input.len(), tape_length));
        }
        
        let max_tape_length = results.iter().map(|(_, tape_len)| *tape_len).max().unwrap_or(0);
        let max_input_length = results.iter().map(|(len, _)| *len).max().unwrap_or(0);
        
        SpaceComplexityAnalysis {
            max_tape_length,
            max_input_length,
            space_bound: lba.tape_bound,
            results,
        }
    }
    
    /// æ£€æŸ¥LBAçš„è¯­è¨€ç±»
    pub fn check_language_class(lba: &LBA, test_cases: &[(&str, bool)]) -> LanguageClassAnalysis {
        let mut correct = 0;
        let mut total = test_cases.len();
        
        for (input, expected) in test_cases {
            let actual = lba.accepts(input);
            if actual == *expected {
                correct += 1;
            }
        }
        
        let accuracy = correct as f64 / total as f64;
        
        LanguageClassAnalysis {
            accuracy,
            correct_count: correct,
            total_count: total,
            is_deterministic: lba.is_deterministic(),
        }
    }
    
    fn classify_complexity(max_steps: usize, max_length: usize) -> String {
        if max_steps <= max_length {
            "O(n)".to_string()
        } else if max_steps <= max_length * max_length {
            "O(nÂ²)".to_string()
        } else if max_steps <= max_length * max_length * max_length {
            "O(nÂ³)".to_string()
        } else {
            "O(n^k)".to_string()
        }
    }
}

#[derive(Debug)]
pub struct TimeComplexityAnalysis {
    pub max_steps: usize,
    pub max_input_length: usize,
    pub complexity_class: String,
    pub results: Vec<(usize, usize)>,
}

#[derive(Debug)]
pub struct SpaceComplexityAnalysis {
    pub max_tape_length: usize,
    pub max_input_length: usize,
    pub space_bound: usize,
    pub results: Vec<(usize, usize)>,
}

#[derive(Debug)]
pub struct LanguageClassAnalysis {
    pub accuracy: f64,
    pub correct_count: usize,
    pub total_count: usize,
    pub is_deterministic: bool,
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 åŸºæœ¬LBAç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_palindrome_lba() {
        let lba = LBABuilder::build_palindrome_lba();
        
        // æµ‹è¯•å›æ–‡
        assert!(lba.accepts(""));
        assert!(lba.accepts("0"));
        assert!(lba.accepts("1"));
        assert!(lba.accepts("00"));
        assert!(lba.accepts("11"));
        assert!(lba.accepts("010"));
        assert!(lba.accepts("101"));
        assert!(lba.accepts("0000"));
        assert!(lba.accepts("1111"));
        
        // æµ‹è¯•éå›æ–‡
        assert!(!lba.accepts("01"));
        assert!(!lba.accepts("10"));
        assert!(!lba.accepts("001"));
        assert!(!lba.accepts("110"));
    }
    
    #[test]
    fn test_anbncn_lba() {
        let lba = LBABuilder::build_anbncn_lba();
        
        // æµ‹è¯•a^n b^n c^n
        assert!(lba.accepts(""));
        assert!(lba.accepts("abc"));
        assert!(lba.accepts("aabbcc"));
        assert!(lba.accepts("aaabbbccc"));
        
        // æµ‹è¯•ä¸ç¬¦åˆçš„è¯­è¨€
        assert!(!lba.accepts("a"));
        assert!(!lba.accepts("ab"));
        assert!(!lba.accepts("abbc"));
        assert!(!lba.accepts("aabcc"));
    }
    
    #[test]
    fn test_lba_determinism() {
        let lba = LBABuilder::build_palindrome_lba();
        assert!(lba.is_deterministic());
    }
    
    #[test]
    fn test_lba_execution() {
        let lba = LBABuilder::build_palindrome_lba();
        
        match lba.run("00") {
            LBAExecutionResult::Accept { steps, .. } => {
                println!("Accepted in {} steps", steps);
            }
            LBAExecutionResult::Reject { steps, .. } => {
                println!("Rejected in {} steps", steps);
            }
            LBAExecutionResult::Timeout { steps, .. } => {
                println!("Timeout after {} steps", steps);
            }
        }
    }
}
```

### 5.2 LBAåˆ†æç¤ºä¾‹

```rust
#[test]
fn test_lba_analysis() {
    let lba = LBABuilder::build_palindrome_lba();
    
    let test_inputs = vec!["", "0", "1", "00", "11", "010", "101", "0000", "1111"];
    
    // æ—¶é—´å¤æ‚åº¦åˆ†æ
    let time_analysis = LBAAnalyzer::analyze_time_complexity(&lba, &test_inputs);
    println!("Time complexity: {}", time_analysis.complexity_class);
    println!("Max steps: {}", time_analysis.max_steps);
    
    // ç©ºé—´å¤æ‚åº¦åˆ†æ
    let space_analysis = LBAAnalyzer::analyze_space_complexity(&lba, &test_inputs);
    println!("Space bound: {}", space_analysis.space_bound);
    println!("Max tape length: {}", space_analysis.max_tape_length);
    
    // è¯­è¨€ç±»åˆ†æ
    let test_cases = vec![
        ("", true), ("0", true), ("1", true), ("00", true),
        ("01", false), ("10", false), ("001", false),
    ];
    
    let language_analysis = LBAAnalyzer::check_language_class(&lba, &test_cases);
    println!("Accuracy: {:.2}%", language_analysis.accuracy * 100.0);
    println!("Deterministic: {}", language_analysis.is_deterministic);
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸è‡ªåŠ¨æœºç†è®ºçš„å…³ç³»

LBAæ˜¯è‡ªåŠ¨æœºå±‚æ¬¡ç»“æ„ä¸­çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œä½äºä¸‹æ¨è‡ªåŠ¨æœºå’Œå›¾çµæœºä¹‹é—´ã€‚

### 6.2 ä¸å¤æ‚åº¦ç†è®ºçš„å…³ç³»

LBAä¸å¤šé¡¹å¼æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦ç†è®ºå¯†åˆ‡ç›¸å…³ã€‚

### 6.3 ä¸å½¢å¼è¯­è¨€ç†è®ºçš„å…³ç³»

LBAè¯†åˆ«çš„è¯­è¨€ç±»ç­‰ä»·äºä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•ç”Ÿæˆçš„è¯­è¨€ç±»ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to Automata Theory, Languages, and Computation. Pearson.
2. Sipser, M. (2012). Introduction to the Theory of Computation. Cengage Learning.
3. Kozen, D. C. (2006). Automata and Computability. Springer.
4. ç‹å®ªé’§. (1998). æ•°ç†é€»è¾‘å¼•è®º. åŒ—äº¬å¤§å­¦å‡ºç‰ˆç¤¾.
5. å¼ æ¸…å®‡. (2006). é€»è¾‘å“²å­¦ä¹ç« . æ±Ÿè‹äººæ°‘å‡ºç‰ˆç¤¾.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [03.1.1 æœ‰é™è‡ªåŠ¨æœº](../03.1.1_æœ‰é™è‡ªåŠ¨æœº.md)
- [03.1.2 ä¸‹æ¨è‡ªåŠ¨æœº](../03.1.2_ä¸‹æ¨è‡ªåŠ¨æœº.md)
- [03.1.4 å›¾çµæœº](../03.1.4_å›¾çµæœº.md)
- [03.2.1 æ­£åˆ™æ–‡æ³•](../03.2.1_æ­£åˆ™æ–‡æ³•.md)
- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03.2.2_ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•.md) 