# 03.8.1 é‡å­è¯­è¨€

## ğŸ“‹ æ¦‚è¿°

é‡å­è¯­è¨€æ˜¯å½¢å¼è¯­è¨€ç†è®ºçš„å‰æ²¿åˆ†æ”¯ï¼Œç ”ç©¶é‡å­è®¡ç®—çš„å½¢å¼åŒ–è¡¨è¾¾å’Œé‡å­ç¼–ç¨‹è¯­è¨€çš„ç†è®ºåŸºç¡€ã€‚æœ¬æ–‡æ¡£å»ºç«‹ä¸¥æ ¼çš„é‡å­è¯­è¨€ç†è®ºæ¡†æ¶ï¼ŒåŒ…å«é‡å­è®¡ç®—æ¨¡å‹ã€é‡å­ç¼–ç¨‹è¯­è¨€ã€é‡å­ç®—æ³•æè¿°è¯­è¨€ç­‰å†…å®¹ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹é‡å­è¯­è¨€çš„åŸºæœ¬æ¦‚å¿µå’Œå½¢å¼åŒ–å®šä¹‰
2. åˆ†æé‡å­è®¡ç®—æ¨¡å‹ä¸å½¢å¼è¯­è¨€çš„å…³ç³»
3. ç ”ç©¶é‡å­ç¼–ç¨‹è¯­è¨€çš„è®¾è®¡åŸç†
4. æä¾›é‡å­ç®—æ³•çš„å½¢å¼åŒ–æè¿°æ–¹æ³•

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 é‡å­è®¡ç®—åŸºç¡€

**å®šä¹‰ 1.1.1** (é‡å­æ¯”ç‰¹)
é‡å­æ¯”ç‰¹æ˜¯é‡å­è®¡ç®—çš„åŸºæœ¬å•ä½ï¼Œç”¨äºŒç»´å¤å‘é‡ç©ºé—´ $\mathbb{C}^2$ ä¸­çš„å•ä½å‘é‡è¡¨ç¤ºï¼š
$$|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$$
å…¶ä¸­ $\alpha, \beta \in \mathbb{C}$ ä¸” $|\alpha|^2 + |\beta|^2 = 1$ã€‚

**å®šä¹‰ 1.1.2** (é‡å­æ€)
nä¸ªé‡å­æ¯”ç‰¹çš„é‡å­æ€æ˜¯ $2^n$ ç»´å¤å‘é‡ç©ºé—´ $\mathbb{C}^{2^n}$ ä¸­çš„å•ä½å‘é‡ï¼š
$$|\psi\rangle = \sum_{x \in \{0,1\}^n} \alpha_x |x\rangle$$
å…¶ä¸­ $\sum_{x} |\alpha_x|^2 = 1$ã€‚

**å®šä¹‰ 1.1.3** (é‡å­é—¨)
é‡å­é—¨æ˜¯ä½œç”¨åœ¨é‡å­æ¯”ç‰¹ä¸Šçš„é…‰ç®—å­ï¼Œä¿æŒé‡å­æ€çš„å½’ä¸€åŒ–æ€§è´¨ã€‚

### 1.2 é‡å­è¯­è¨€çš„åŸºæœ¬ç‰¹å¾

**å®šä¹‰ 1.2.1** (é‡å­è¯­è¨€)
é‡å­è¯­è¨€æ˜¯ç”¨äºæè¿°é‡å­è®¡ç®—è¿‡ç¨‹çš„å½¢å¼è¯­è¨€ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š

- æ”¯æŒé‡å­æ€çš„è¡¨ç¤ºå’Œæ“ä½œ
- åŒ…å«é‡å­é—¨çš„æè¿°
- æ”¯æŒé‡å­æµ‹é‡æ“ä½œ
- å¤„ç†é‡å­çº ç¼ å’Œå åŠ 

**å®šä¹‰ 1.2.2** (é‡å­çº¿æ€§æ€§)
é‡å­è¯­è¨€å¿…é¡»ä¿æŒé‡å­æ€çš„çº¿æ€§æ€§ï¼Œå³ï¼š
$$U(\alpha|\psi_1\rangle + \beta|\psi_2\rangle) = \alpha U|\psi_1\rangle + \beta U|\psi_2\rangle$$

**å®šä¹‰ 1.2.3** (ä¸å¯å…‹éš†æ€§)
é‡å­è¯­è¨€å¿…é¡»ä½“ç°é‡å­ä¿¡æ¯çš„ä¸å¯å…‹éš†æ€§ï¼Œä¸èƒ½ç›´æ¥å¤åˆ¶æœªçŸ¥é‡å­æ€ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 é‡å­è¯­æ³•

**å®šä¹‰ 2.1.1** (é‡å­è¯­æ³•)
é‡å­è¯­æ³• $G_Q = (V_Q, \Sigma_Q, R_Q, S_Q)$ å…¶ä¸­ï¼š

- $V_Q$ æ˜¯é‡å­éç»ˆç»“ç¬¦é›†åˆ
- $\Sigma_Q$ æ˜¯é‡å­ç»ˆç»“ç¬¦é›†åˆ
- $R_Q$ æ˜¯é‡å­é‡å†™è§„åˆ™é›†åˆ
- $S_Q$ æ˜¯é‡å­å¼€å§‹ç¬¦å·

**å®šä¹‰ 2.1.2** (é‡å­è¡¨è¾¾å¼)
é‡å­è¡¨è¾¾å¼æ˜¯é‡å­è¯­è¨€ä¸­çš„åŸºæœ¬æ„é€ ï¼ŒåŒ…æ‹¬ï¼š

- é‡å­æ€è¡¨è¾¾å¼ï¼š$|\psi\rangle$
- é‡å­é—¨è¡¨è¾¾å¼ï¼š$U|\psi\rangle$
- é‡å­æµ‹é‡è¡¨è¾¾å¼ï¼š$\langle\psi|M|\psi\rangle$

### 2.2 é‡å­è¯­ä¹‰

**å®šä¹‰ 2.2.1** (é‡å­è¯­ä¹‰å‡½æ•°)
é‡å­è¯­ä¹‰å‡½æ•° $\llbracket \cdot \rrbracket$ å°†é‡å­è¡¨è¾¾å¼æ˜ å°„åˆ°é‡å­æ€ï¼š
$$\llbracket |\psi\rangle \rrbracket = |\psi\rangle$$
$$\llbracket U|\psi\rangle \rrbracket = U\llbracket |\psi\rangle \rrbracket$$

**å®šä¹‰ 2.2.2** (é‡å­æ“ä½œè¯­ä¹‰)
é‡å­æ“ä½œè¯­ä¹‰å®šä¹‰é‡å­ç¨‹åºçš„æ‰§è¡Œè¿‡ç¨‹ï¼š
$$\frac{|\psi\rangle \rightarrow |\psi'\rangle}{U|\psi\rangle \rightarrow U|\psi'\rangle}$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 é‡å­è¯­è¨€çš„åŸºæœ¬å®šç†

**å®šç† 3.1.1** (é‡å­çº¿æ€§æ€§ä¿æŒ)
é‡å­è¯­è¨€ä¸­çš„ä»»ä½•æ“ä½œéƒ½ä¿æŒé‡å­æ€çš„çº¿æ€§æ€§ã€‚

**è¯æ˜**ï¼š
è®¾ $|\psi_1\rangle$ å’Œ $|\psi_2\rangle$ æ˜¯ä»»æ„é‡å­æ€ï¼Œ$\alpha, \beta \in \mathbb{C}$ã€‚
å¯¹äºä»»æ„é‡å­é—¨ $U$ï¼Œæœ‰ï¼š
$$U(\alpha|\psi_1\rangle + \beta|\psi_2\rangle) = \alpha U|\psi_1\rangle + \beta U|\psi_2\rangle$$
è¿™ç”±é‡å­é—¨çš„çº¿æ€§æ€§ç›´æ¥å¾—å‡ºã€‚

**å®šç† 3.1.2** (é‡å­ä¸å¯å…‹éš†å®šç†)
åœ¨é‡å­è¯­è¨€ä¸­ï¼Œä¸å­˜åœ¨é€šç”¨çš„é‡å­æ€å¤åˆ¶æ“ä½œã€‚

**è¯æ˜**ï¼š
å‡è®¾å­˜åœ¨é€šç”¨å¤åˆ¶æ“ä½œ $U_{copy}$ï¼Œä½¿å¾—ï¼š
$$U_{copy}(|\psi\rangle|0\rangle) = |\psi\rangle|\psi\rangle$$
å¯¹äºä»»æ„ $|\psi\rangle$ã€‚

è€ƒè™‘ä¸¤ä¸ªæ­£äº¤æ€ $|0\rangle$ å’Œ $|1\rangle$ï¼š
$$U_{copy}(|0\rangle|0\rangle) = |0\rangle|0\rangle$$
$$U_{copy}(|1\rangle|0\rangle) = |1\rangle|1\rangle$$

å¯¹äºå åŠ æ€ $|\psi\rangle = \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)$ï¼š
$$U_{copy}(|\psi\rangle|0\rangle) = \frac{1}{\sqrt{2}}(|0\rangle|0\rangle + |1\rangle|1\rangle) \neq |\psi\rangle|\psi\rangle$$
è¿™ä¸å‡è®¾çŸ›ç›¾ã€‚

### 3.2 é‡å­å¤æ‚æ€§ç†è®º

**å®šç† 3.2.1** (é‡å­å¤æ‚æ€§ç±»åŒ…å«å…³ç³»)
$$P \subseteq BPP \subseteq BQP \subseteq PSPACE$$

**è¯æ˜**ï¼š

1. $P \subseteq BPP$ï¼šç¡®å®šæ€§ç®—æ³•æ˜¯æ¦‚ç‡ç®—æ³•çš„ç‰¹ä¾‹
2. $BPP \subseteq BQP$ï¼šç»å…¸æ¦‚ç‡è®¡ç®—å¯ä»¥æ¨¡æ‹Ÿä¸ºé‡å­è®¡ç®—
3. $BQP \subseteq PSPACE$ï¼šé‡å­è®¡ç®—å¯ä»¥åœ¨å¤šé¡¹å¼ç©ºé—´å†…æ¨¡æ‹Ÿ

## 4. ä»£ç å®ç°

### 4.1 é‡å­è¯­è¨€åŸºç¡€å®ç°

```rust
use std::collections::HashMap;
use num_complex::Complex64;

/// é‡å­æ¯”ç‰¹è¡¨ç¤º
#[derive(Clone, Debug)]
struct Qubit {
    alpha: Complex64,  // |0âŸ© çš„ç³»æ•°
    beta: Complex64,   // |1âŸ© çš„ç³»æ•°
}

impl Qubit {
    /// åˆ›å»ºæ–°çš„é‡å­æ¯”ç‰¹
    fn new(alpha: Complex64, beta: Complex64) -> Self {
        let norm = (alpha.norm_sqr() + beta.norm_sqr()).sqrt();
        Qubit {
            alpha: alpha / norm,
            beta: beta / norm,
        }
    }
    
    /// æµ‹é‡é‡å­æ¯”ç‰¹
    fn measure(&self) -> bool {
        let prob_1 = self.beta.norm_sqr();
        rand::random::<f64>() < prob_1
    }
}

/// é‡å­é—¨æ“ä½œ
trait QuantumGate {
    fn apply(&self, qubit: &Qubit) -> Qubit;
}

/// Hadamardé—¨
struct HadamardGate;

impl QuantumGate for HadamardGate {
    fn apply(&self, qubit: &Qubit) -> Qubit {
        let new_alpha = (qubit.alpha + qubit.beta) / 2.0_f64.sqrt();
        let new_beta = (qubit.alpha - qubit.beta) / 2.0_f64.sqrt();
        Qubit::new(new_alpha, new_beta)
    }
}

/// é‡å­å¯„å­˜å™¨
#[derive(Clone, Debug)]
struct QuantumRegister {
    qubits: Vec<Qubit>,
}

impl QuantumRegister {
    /// åˆ›å»ºnä¸ªé‡å­æ¯”ç‰¹çš„å¯„å­˜å™¨
    fn new(n: usize) -> Self {
        let qubits = vec![Qubit::new(Complex64::new(1.0, 0.0), Complex64::new(0.0, 0.0)); n];
        QuantumRegister { qubits }
    }
    
    /// åº”ç”¨é‡å­é—¨åˆ°æŒ‡å®šé‡å­æ¯”ç‰¹
    fn apply_gate<G: QuantumGate>(&mut self, gate: &G, qubit_index: usize) {
        if qubit_index < self.qubits.len() {
            self.qubits[qubit_index] = gate.apply(&self.qubits[qubit_index]);
        }
    }
    
    /// æµ‹é‡æ•´ä¸ªå¯„å­˜å™¨
    fn measure_all(&self) -> Vec<bool> {
        self.qubits.iter().map(|q| q.measure()).collect()
    }
}
```

### 4.2 é‡å­ç®—æ³•å®ç°

```rust
/// é‡å­å‚…é‡Œå¶å˜æ¢
struct QuantumFourierTransform;

impl QuantumFourierTransform {
    /// åœ¨nä¸ªé‡å­æ¯”ç‰¹ä¸Šæ‰§è¡ŒQFT
    fn apply(&self, register: &mut QuantumRegister) {
        let n = register.qubits.len();
        
        for i in 0..n {
            // åº”ç”¨Hadamardé—¨
            register.apply_gate(&HadamardGate, i);
            
            // åº”ç”¨å—æ§ç›¸ä½é—¨
            for j in (i + 1)..n {
                let phase = std::f64::consts::PI / (1 << (j - i)) as f64;
                // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…éœ€è¦å®ç°å—æ§ç›¸ä½é—¨
            }
        }
        
        // åè½¬é‡å­æ¯”ç‰¹é¡ºåº
        register.qubits.reverse();
    }
}

/// Groverç®—æ³•
struct GroverAlgorithm {
    oracle: Box<dyn Fn(&[bool]) -> bool>,
    iterations: usize,
}

impl GroverAlgorithm {
    fn new<F>(oracle: F, iterations: usize) -> Self 
    where F: Fn(&[bool]) -> bool + 'static 
    {
        GroverAlgorithm {
            oracle: Box::new(oracle),
            iterations,
        }
    }
    
    /// æ‰§è¡ŒGroveræœç´¢
    fn search(&self, n_qubits: usize) -> Vec<bool> {
        let mut register = QuantumRegister::new(n_qubits);
        
        // åˆå§‹åŒ–å åŠ æ€
        for i in 0..n_qubits {
            register.apply_gate(&HadamardGate, i);
        }
        
        // Groverè¿­ä»£
        for _ in 0..self.iterations {
            // Oracleæ“ä½œ
            self.apply_oracle(&mut register);
            
            // æ‰©æ•£æ“ä½œ
            self.apply_diffusion(&mut register);
        }
        
        // æµ‹é‡ç»“æœ
        register.measure_all()
    }
    
    fn apply_oracle(&self, register: &mut QuantumRegister) {
        // å®ç°oracleæ“ä½œ
        // è¿™é‡Œç®€åŒ–å¤„ç†
    }
    
    fn apply_diffusion(&self, register: &mut QuantumRegister) {
        // å®ç°æ‰©æ•£æ“ä½œ
        // è¿™é‡Œç®€åŒ–å¤„ç†
    }
}
```

### 4.3 é‡å­ç¼–ç¨‹è¯­è¨€ç¤ºä¾‹

```rust
/// é‡å­ç¼–ç¨‹è¯­è¨€çš„æ ¸å¿ƒç»“æ„
#[derive(Debug)]
enum QuantumExpression {
    Qubit(Qubit),
    Gate(Box<dyn QuantumGate>),
    Apply(Box<QuantumExpression>, Box<QuantumExpression>),
    Measure(Box<QuantumExpression>),
    Sequence(Vec<QuantumExpression>),
}

/// é‡å­ç¨‹åºè§£é‡Šå™¨
struct QuantumInterpreter {
    register: QuantumRegister,
}

impl QuantumInterpreter {
    fn new(n_qubits: usize) -> Self {
        QuantumInterpreter {
            register: QuantumRegister::new(n_qubits),
        }
    }
    
    /// è§£é‡Šé‡å­è¡¨è¾¾å¼
    fn interpret(&mut self, expr: &QuantumExpression) -> Result<(), String> {
        match expr {
            QuantumExpression::Qubit(_) => Ok(()),
            QuantumExpression::Gate(_) => Ok(()),
            QuantumExpression::Apply(gate, target) => {
                self.interpret(target)?;
                self.interpret(gate)?;
                Ok(())
            },
            QuantumExpression::Measure(expr) => {
                self.interpret(expr)?;
                // æ‰§è¡Œæµ‹é‡
                Ok(())
            },
            QuantumExpression::Sequence(exprs) => {
                for expr in exprs {
                    self.interpret(expr)?;
                }
                Ok(())
            },
        }
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 é‡å­éšæœºæ•°ç”Ÿæˆ

```rust
/// é‡å­éšæœºæ•°ç”Ÿæˆå™¨
struct QuantumRandomGenerator;

impl QuantumRandomGenerator {
    /// ç”Ÿæˆé‡å­éšæœºæ¯”ç‰¹
    fn generate_random_bit() -> bool {
        let qubit = Qubit::new(
            Complex64::new(1.0, 0.0), 
            Complex64::new(0.0, 0.0)
        );
        let hadamard = HadamardGate;
        let superposed = hadamard.apply(&qubit);
        superposed.measure()
    }
    
    /// ç”Ÿæˆnä½é‡å­éšæœºæ•°
    fn generate_random_bits(n: usize) -> Vec<bool> {
        (0..n).map(|_| Self::generate_random_bit()).collect()
    }
    
    /// ç”Ÿæˆé‡å­éšæœºæ•´æ•°
    fn generate_random_int(max: u32) -> u32 {
        let bits_needed = (max as f64).log2().ceil() as usize;
        let bits = Self::generate_random_bits(bits_needed);
        
        let mut result = 0u32;
        for (i, &bit) in bits.iter().enumerate() {
            if bit {
                result |= 1 << i;
            }
        }
        
        result % max
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn quantum_random_example() {
    println!("ç”Ÿæˆ10ä¸ªé‡å­éšæœºæ¯”ç‰¹:");
    for _ in 0..10 {
        let bit = QuantumRandomGenerator::generate_random_bit();
        print!("{} ", if bit { 1 } else { 0 });
    }
    println!();
    
    println!("ç”Ÿæˆ5ä¸ª0-99çš„é‡å­éšæœºæ•°:");
    for _ in 0..5 {
        let num = QuantumRandomGenerator::generate_random_int(100);
        print!("{} ", num);
    }
    println!();
}
```

### 5.2 é‡å­å¯†é’¥åˆ†å‘

```rust
/// é‡å­å¯†é’¥åˆ†å‘åè®®
struct QuantumKeyDistribution {
    alice_qubits: Vec<Qubit>,
    bob_measurements: Vec<bool>,
    alice_bases: Vec<bool>,  // true = +, false = Ã—
    bob_bases: Vec<bool>,
}

impl QuantumKeyDistribution {
    fn new() -> Self {
        QuantumKeyDistribution {
            alice_qubits: Vec::new(),
            bob_measurements: Vec::new(),
            alice_bases: Vec::new(),
            bob_bases: Vec::new(),
        }
    }
    
    /// Aliceå‡†å¤‡é‡å­æ¯”ç‰¹
    fn alice_prepare(&mut self, n: usize) {
        for _ in 0..n {
            // éšæœºé€‰æ‹©æ¯”ç‰¹å€¼
            let bit = rand::random::<bool>();
            // éšæœºé€‰æ‹©æµ‹é‡åŸº
            let basis = rand::random::<bool>();
            
            let qubit = if bit {
                if basis {
                    // +åŸºçš„|1âŸ©æ€
                    Qubit::new(Complex64::new(0.0, 0.0), Complex64::new(1.0, 0.0))
                } else {
                    // Ã—åŸºçš„|1âŸ©æ€
                    Qubit::new(Complex64::new(1.0/2.0_f64.sqrt(), 0.0), 
                               Complex64::new(-1.0/2.0_f64.sqrt(), 0.0))
                }
            } else {
                if basis {
                    // +åŸºçš„|0âŸ©æ€
                    Qubit::new(Complex64::new(1.0, 0.0), Complex64::new(0.0, 0.0))
                } else {
                    // Ã—åŸºçš„|0âŸ©æ€
                    Qubit::new(Complex64::new(1.0/2.0_f64.sqrt(), 0.0), 
                               Complex64::new(1.0/2.0_f64.sqrt(), 0.0))
                }
            };
            
            self.alice_qubits.push(qubit);
            self.alice_bases.push(basis);
        }
    }
    
    /// Bobæµ‹é‡é‡å­æ¯”ç‰¹
    fn bob_measure(&mut self) {
        for qubit in &self.alice_qubits {
            // Bobéšæœºé€‰æ‹©æµ‹é‡åŸº
            let basis = rand::random::<bool>();
            self.bob_bases.push(basis);
            
            // æ ¹æ®é€‰æ‹©çš„åŸºè¿›è¡Œæµ‹é‡
            let measurement = qubit.measure();
            self.bob_measurements.push(measurement);
        }
    }
    
    /// ç”Ÿæˆå…±äº«å¯†é’¥
    fn generate_shared_key(&self) -> Vec<bool> {
        let mut shared_key = Vec::new();
        
        for i in 0..self.alice_bases.len() {
            // åªæœ‰å½“Aliceå’ŒBobé€‰æ‹©ç›¸åŒæµ‹é‡åŸºæ—¶æ‰ä¿ç•™ç»“æœ
            if self.alice_bases[i] == self.bob_bases[i] {
                shared_key.push(self.bob_measurements[i]);
            }
        }
        
        shared_key
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn qkd_example() {
    let mut qkd = QuantumKeyDistribution::new();
    
    // Aliceå‡†å¤‡100ä¸ªé‡å­æ¯”ç‰¹
    qkd.alice_prepare(100);
    
    // Bobæµ‹é‡é‡å­æ¯”ç‰¹
    qkd.bob_measure();
    
    // ç”Ÿæˆå…±äº«å¯†é’¥
    let shared_key = qkd.generate_shared_key();
    
    println!("ç”Ÿæˆçš„å…±äº«å¯†é’¥é•¿åº¦: {}", shared_key.len());
    println!("å¯†é’¥å‰20ä½: {:?}", &shared_key[..shared_key.len().min(20)]);
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å½¢å¼è¯­è¨€ç†è®ºçš„å…³ç³»

é‡å­è¯­è¨€ä¸ç»å…¸å½¢å¼è¯­è¨€ç†è®ºçš„å…³ç³»ï¼š

1. **æ‰©å±•æ€§**ï¼šé‡å­è¯­è¨€æ‰©å±•äº†ç»å…¸å½¢å¼è¯­è¨€ï¼Œå¢åŠ äº†é‡å­æ€å’Œé‡å­æ“ä½œ
2. **çº¿æ€§æ€§çº¦æŸ**ï¼šé‡å­è¯­è¨€å¿…é¡»ä¿æŒé‡å­æ€çš„çº¿æ€§æ€§
3. **ä¸å¯å…‹éš†æ€§**ï¼šé‡å­è¯­è¨€ä½“ç°äº†é‡å­ä¿¡æ¯çš„ä¸å¯å…‹éš†ç‰¹æ€§
4. **æµ‹é‡è¯­ä¹‰**ï¼šé‡å­è¯­è¨€åŒ…å«æµ‹é‡æ“ä½œçš„ç‰¹æ®Šè¯­ä¹‰

### 6.2 ä¸è®¡ç®—ç†è®ºçš„å…³ç³»

é‡å­è¯­è¨€ä¸è®¡ç®—ç†è®ºçš„å…³ç³»ï¼š

1. **å¤æ‚æ€§ç±»**ï¼šé‡å­è¯­è¨€å¯¹åº”æ–°çš„å¤æ‚æ€§ç±»å¦‚BQP
2. **è®¡ç®—æ¨¡å‹**ï¼šé‡å­è¯­è¨€åŸºäºé‡å­å›¾çµæœºç­‰è®¡ç®—æ¨¡å‹
3. **ç®—æ³•è®¾è®¡**ï¼šé‡å­è¯­è¨€æ”¯æŒé‡å­ç®—æ³•çš„å½¢å¼åŒ–æè¿°

### 6.3 ä¸ç¼–ç¨‹è¯­è¨€ç†è®ºçš„å…³ç³»

é‡å­è¯­è¨€ä¸ç¼–ç¨‹è¯­è¨€ç†è®ºçš„å…³ç³»ï¼š

1. **ç±»å‹ç³»ç»Ÿ**ï¼šé‡å­è¯­è¨€éœ€è¦ç‰¹æ®Šçš„ç±»å‹ç³»ç»Ÿå¤„ç†é‡å­æ€
2. **å†…å­˜ç®¡ç†**ï¼šé‡å­è¯­è¨€éœ€è¦å¤„ç†é‡å­æ€çš„ä¸å¯å…‹éš†æ€§
3. **å¹¶å‘æ¨¡å‹**ï¼šé‡å­è¯­è¨€éœ€è¦è€ƒè™‘é‡å­çº ç¼ çš„å¹¶å‘è¯­ä¹‰

## 7. å‚è€ƒæ–‡çŒ®

1. Nielsen, M. A., & Chuang, I. L. (2010). Quantum computation and quantum information. Cambridge university press.
2. Kaye, P., Laflamme, R., & Mosca, M. (2007). An introduction to quantum computing. Oxford University Press.
3. Preskill, J. (1998). Lecture notes for physics 229: Quantum information and computation. California Institute of Technology.
4. Rieffel, E. G., & Polak, W. H. (2011). Quantum computing: A gentle introduction. MIT Press.
5. Mermin, N. D. (2007). Quantum computer science: an introduction. Cambridge University Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [03.1.4 å›¾çµæœº](../03.1.4_å›¾çµæœº.md)
- [03.6.1 å¯è®¡ç®—æ€§ç†è®º](./03.6.1_Computability_Theory.md)
- [03.6.2 å¤æ‚æ€§ç†è®º](./03.6.2_Complexity_Theory.md)
- [04.6.1 é‡å­ç±»å‹åŸºç¡€](../04_Type_Theory/04.6.1_é‡å­ç±»å‹åŸºç¡€.md)
