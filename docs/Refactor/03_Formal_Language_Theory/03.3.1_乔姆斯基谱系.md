# 03.3.1 ä¹”å§†æ–¯åŸºè°±ç³»

## ğŸ“‹ æ¦‚è¿°

ä¹”å§†æ–¯åŸºè°±ç³»ï¼ˆChomsky Hierarchyï¼‰æ˜¯å½¢å¼è¯­è¨€ç†è®ºä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå®ƒå°†å½¢å¼è¯­è¨€æŒ‰ç…§ç”Ÿæˆå®ƒä»¬çš„æ–‡æ³•ç±»å‹åˆ†ä¸ºå››ä¸ªå±‚æ¬¡ã€‚è¿™ä¸ªè°±ç³»ä¸ä»…æ­ç¤ºäº†ä¸åŒè¯­è¨€ç±»çš„è®¡ç®—èƒ½åŠ›ï¼Œä¹Ÿä¸ºè®¡ç®—æœºç§‘å­¦å’Œè¯­è¨€å­¦æä¾›äº†é‡è¦çš„ç†è®ºåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å±‚æ¬¡ç»“æ„**ï¼šå±•ç¤ºä¹”å§†æ–¯åŸºè°±ç³»çš„å››ä¸ªå±‚æ¬¡
2. **è®¡ç®—èƒ½åŠ›**ï¼šåˆ†ææ¯ä¸ªå±‚æ¬¡çš„è®¡ç®—èƒ½åŠ›
3. **ç­‰ä»·æ€§**ï¼šå»ºç«‹æ–‡æ³•ä¸è‡ªåŠ¨æœºçš„ç­‰ä»·æ€§
4. **åº”ç”¨ä»·å€¼**ï¼šå±•ç¤ºè°±ç³»åœ¨ç†è®ºå’Œå®è·µä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å››ä¸ªå±‚æ¬¡](#2-å››ä¸ªå±‚æ¬¡)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ä¹”å§†æ–¯åŸºè°±ç³»çš„ç›´è§‚ç†è§£

ä¹”å§†æ–¯åŸºè°±ç³»å°†å½¢å¼è¯­è¨€æŒ‰ç…§ç”Ÿæˆå®ƒä»¬çš„æ–‡æ³•ç±»å‹åˆ†ä¸ºå››ä¸ªå±‚æ¬¡ï¼Œä»æœ€å—é™çš„æ­£åˆ™è¯­è¨€åˆ°æœ€ä¸€èˆ¬çš„é€’å½’å¯æšä¸¾è¯­è¨€ã€‚æ¯ä¸ªå±‚æ¬¡éƒ½æœ‰å¯¹åº”çš„è‡ªåŠ¨æœºæ¨¡å‹å’Œç‰¹å®šçš„è®¡ç®—èƒ½åŠ›ã€‚

### 1.2 è°±ç³»ç»“æ„

**å®šä¹‰ 1.2.1** (ä¹”å§†æ–¯åŸºè°±ç³»)
ä¹”å§†æ–¯åŸºè°±ç³»åŒ…å«å››ä¸ªå±‚æ¬¡ï¼š

- **3å‹æ–‡æ³•**ï¼šæ­£åˆ™æ–‡æ³•ï¼Œç”Ÿæˆæ­£åˆ™è¯­è¨€
- **2å‹æ–‡æ³•**ï¼šä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ï¼Œç”Ÿæˆä¸Šä¸‹æ–‡æ— å…³è¯­è¨€
- **1å‹æ–‡æ³•**ï¼šä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•ï¼Œç”Ÿæˆä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€
- **0å‹æ–‡æ³•**ï¼šæ— é™åˆ¶æ–‡æ³•ï¼Œç”Ÿæˆé€’å½’å¯æšä¸¾è¯­è¨€

### 1.3 åŒ…å«å…³ç³»

**å®šç† 1.3.1** (è°±ç³»åŒ…å«å…³ç³»)
è®¾ $\mathcal{L}_3, \mathcal{L}_2, \mathcal{L}_1, \mathcal{L}_0$ åˆ†åˆ«è¡¨ç¤ºæ­£åˆ™ã€ä¸Šä¸‹æ–‡æ— å…³ã€ä¸Šä¸‹æ–‡ç›¸å…³ã€é€’å½’å¯æšä¸¾è¯­è¨€ç±»ï¼Œåˆ™ï¼š
$$\mathcal{L}_3 \subset \mathcal{L}_2 \subset \mathcal{L}_1 \subset \mathcal{L}_0$$

## 2. å››ä¸ªå±‚æ¬¡

### 2.1 3å‹æ–‡æ³•ï¼ˆæ­£åˆ™æ–‡æ³•ï¼‰

**å®šä¹‰ 2.1.1** (æ­£åˆ™æ–‡æ³•)
ä¸€ä¸ªæ­£åˆ™æ–‡æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ $G = (V, \Sigma, P, S)$ï¼Œå…¶ä¸­äº§ç”Ÿå¼å…·æœ‰ä»¥ä¸‹å½¢å¼ä¹‹ä¸€ï¼š

- $A \to aB$ï¼ˆå³çº¿æ€§ï¼‰
- $A \to a$ï¼ˆå³çº¿æ€§ï¼‰
- $A \to Ba$ï¼ˆå·¦çº¿æ€§ï¼‰
- $A \to a$ï¼ˆå·¦çº¿æ€§ï¼‰

å…¶ä¸­ $A, B \in V$ï¼Œ$a \in \Sigma$ã€‚

**å®šç† 2.1.1** (æ­£åˆ™è¯­è¨€çš„æ€§è´¨)

- æ­£åˆ™è¯­è¨€åœ¨å¹¶ã€äº¤ã€è¡¥ã€è¿æ¥ã€æ˜Ÿå·è¿ç®—ä¸‹å°é—­
- æ­£åˆ™è¯­è¨€å¯ä»¥è¢«æœ‰é™è‡ªåŠ¨æœºè¯†åˆ«
- æ­£åˆ™è¯­è¨€æœ‰æ³µå¼•ç†

### 2.2 2å‹æ–‡æ³•ï¼ˆä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ï¼‰

**å®šä¹‰ 2.2.1** (ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•)
ä¸€ä¸ªä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ $G = (V, \Sigma, P, S)$ï¼Œå…¶ä¸­æ¯ä¸ªäº§ç”Ÿå¼å½¢å¦‚ï¼š
$$A \to \alpha$$
å…¶ä¸­ $A \in V$ï¼Œ$\alpha \in (V \cup \Sigma)^*$ã€‚

**å®šç† 2.2.1** (ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€çš„æ€§è´¨)

- ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€åœ¨å¹¶ã€è¿æ¥ã€æ˜Ÿå·è¿ç®—ä¸‹å°é—­
- ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€å¯ä»¥è¢«ä¸‹æ¨è‡ªåŠ¨æœºè¯†åˆ«
- ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€æœ‰æ³µå¼•ç†

### 2.3 1å‹æ–‡æ³•ï¼ˆä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•ï¼‰

**å®šä¹‰ 2.3.1** (ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•)
ä¸€ä¸ªä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ $G = (V, \Sigma, P, S)$ï¼Œå…¶ä¸­æ¯ä¸ªäº§ç”Ÿå¼å½¢å¦‚ï¼š
$$\alpha A \beta \to \alpha \gamma \beta$$
å…¶ä¸­ $A \in V$ï¼Œ$\alpha, \beta, \gamma \in (V \cup \Sigma)^*$ï¼Œä¸” $\gamma \neq \varepsilon$ã€‚

**å®šç† 2.3.1** (ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€çš„æ€§è´¨)

- ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€åœ¨å¹¶ã€äº¤ã€è¡¥ã€è¿æ¥è¿ç®—ä¸‹å°é—­
- ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€å¯ä»¥è¢«çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºè¯†åˆ«

### 2.4 0å‹æ–‡æ³•ï¼ˆæ— é™åˆ¶æ–‡æ³•ï¼‰

**å®šä¹‰ 2.4.1** (æ— é™åˆ¶æ–‡æ³•)
ä¸€ä¸ªæ— é™åˆ¶æ–‡æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ $G = (V, \Sigma, P, S)$ï¼Œå…¶ä¸­äº§ç”Ÿå¼å½¢å¦‚ï¼š
$$\alpha \to \beta$$
å…¶ä¸­ $\alpha, \beta \in (V \cup \Sigma)^*$ï¼Œä¸” $\alpha \neq \varepsilon$ã€‚

**å®šç† 2.4.1** (é€’å½’å¯æšä¸¾è¯­è¨€çš„æ€§è´¨)

- é€’å½’å¯æšä¸¾è¯­è¨€åœ¨å¹¶ã€äº¤ã€è¿æ¥è¿ç®—ä¸‹å°é—­
- é€’å½’å¯æšä¸¾è¯­è¨€å¯ä»¥è¢«å›¾çµæœºè¯†åˆ«
- é€’å½’å¯æšä¸¾è¯­è¨€çš„æˆå‘˜é—®é¢˜æ˜¯ä¸å¯åˆ¤å®šçš„

## 3. å®šç†ä¸è¯æ˜

### 3.1 è‡ªåŠ¨æœºç­‰ä»·æ€§

**å®šç† 3.1.1** (è‡ªåŠ¨æœºç­‰ä»·æ€§)

1. æ­£åˆ™è¯­è¨€ $\Leftrightarrow$ æœ‰é™è‡ªåŠ¨æœº
2. ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ $\Leftrightarrow$ ä¸‹æ¨è‡ªåŠ¨æœº
3. ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ $\Leftrightarrow$ çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº
4. é€’å½’å¯æšä¸¾è¯­è¨€ $\Leftrightarrow$ å›¾çµæœº

### 3.2 æ³µå¼•ç†

**å®šç† 3.2.1** (æ­£åˆ™è¯­è¨€æ³µå¼•ç†)
è®¾ $L$ æ˜¯æ­£åˆ™è¯­è¨€ï¼Œåˆ™å­˜åœ¨å¸¸æ•° $p$ï¼Œä½¿å¾—å¯¹ä»»æ„ $w \in L$ï¼Œ$|w| \geq p$ï¼Œå­˜åœ¨åˆ†è§£ $w = xyz$ï¼Œæ»¡è¶³ï¼š

1. $|xy| \leq p$
2. $|y| \geq 1$
3. å¯¹ä»»æ„ $i \geq 0$ï¼Œ$xy^iz \in L$

**å®šç† 3.2.2** (ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€æ³µå¼•ç†)
è®¾ $L$ æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼Œåˆ™å­˜åœ¨å¸¸æ•° $p$ï¼Œä½¿å¾—å¯¹ä»»æ„ $w \in L$ï¼Œ$|w| \geq p$ï¼Œå­˜åœ¨åˆ†è§£ $w = uvxyz$ï¼Œæ»¡è¶³ï¼š

1. $|vxy| \leq p$
2. $|vy| \geq 1$
3. å¯¹ä»»æ„ $i \geq 0$ï¼Œ$uv^ixy^iz \in L$

### 3.3 åˆ¤å®šæ€§é—®é¢˜

**å®šç† 3.3.1** (åˆ¤å®šæ€§é—®é¢˜)

1. **æ­£åˆ™è¯­è¨€**ï¼šæˆå‘˜é—®é¢˜ã€ç©ºæ€§é—®é¢˜ã€ç­‰ä»·æ€§é—®é¢˜éƒ½æ˜¯å¯åˆ¤å®šçš„
2. **ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€**ï¼šæˆå‘˜é—®é¢˜ã€ç©ºæ€§é—®é¢˜æ˜¯å¯åˆ¤å®šçš„ï¼Œç­‰ä»·æ€§é—®é¢˜æ˜¯ä¸å¯åˆ¤å®šçš„
3. **ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€**ï¼šæˆå‘˜é—®é¢˜æ˜¯å¯åˆ¤å®šçš„ï¼Œç©ºæ€§é—®é¢˜æ˜¯ä¸å¯åˆ¤å®šçš„
4. **é€’å½’å¯æšä¸¾è¯­è¨€**ï¼šæˆå‘˜é—®é¢˜ã€ç©ºæ€§é—®é¢˜éƒ½æ˜¯ä¸å¯åˆ¤å®šçš„

## 4. ä»£ç å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::fmt;

/// è¡¨ç¤ºæ–‡æ³•ç±»å‹
#[derive(Debug, Clone, PartialEq)]
pub enum GrammarType {
    Regular,           // 3å‹æ–‡æ³•
    ContextFree,       // 2å‹æ–‡æ³•
    ContextSensitive,  // 1å‹æ–‡æ³•
    Unrestricted,      // 0å‹æ–‡æ³•
}

/// è¡¨ç¤ºä¸€ä¸ªäº§ç”Ÿå¼
#[derive(Debug, Clone)]
pub struct Production {
    pub left: String,
    pub right: String,
}

impl Production {
    pub fn new(left: String, right: String) -> Self {
        Production { left, right }
    }
}

/// è¡¨ç¤ºä¸€ä¸ªæ–‡æ³•
#[derive(Debug)]
pub struct Grammar {
    pub grammar_type: GrammarType,
    pub variables: HashSet<char>,
    pub terminals: HashSet<char>,
    pub productions: Vec<Production>,
    pub start_symbol: char,
}

impl Grammar {
    pub fn new(
        grammar_type: GrammarType,
        variables: HashSet<char>,
        terminals: HashSet<char>,
        productions: Vec<Production>,
        start_symbol: char,
    ) -> Result<Self, String> {
        // éªŒè¯æ–‡æ³•ç±»å‹ä¸äº§ç”Ÿå¼çš„ä¸€è‡´æ€§
        if !Self::validate_grammar_type(&grammar_type, &productions) {
            return Err("Productions do not match grammar type".to_string());
        }
        
        Ok(Grammar {
            grammar_type,
            variables,
            terminals,
            productions,
            start_symbol,
        })
    }
    
    /// éªŒè¯æ–‡æ³•ç±»å‹ä¸äº§ç”Ÿå¼çš„ä¸€è‡´æ€§
    fn validate_grammar_type(grammar_type: &GrammarType, productions: &[Production]) -> bool {
        match grammar_type {
            GrammarType::Regular => Self::validate_regular_productions(productions),
            GrammarType::ContextFree => Self::validate_context_free_productions(productions),
            GrammarType::ContextSensitive => Self::validate_context_sensitive_productions(productions),
            GrammarType::Unrestricted => true, // æ— é™åˆ¶æ–‡æ³•æ²¡æœ‰ç‰¹æ®Šé™åˆ¶
        }
    }
    
    /// éªŒè¯æ­£åˆ™æ–‡æ³•çš„äº§ç”Ÿå¼
    fn validate_regular_productions(productions: &[Production]) -> bool {
        for production in productions {
            let left = &production.left;
            let right = &production.right;
            
            // å·¦éƒ¨å¿…é¡»æ˜¯å•ä¸ªå˜å…ƒ
            if left.len() != 1 {
                return false;
            }
            
            // å³éƒ¨å¿…é¡»æ˜¯ aB æˆ– a çš„å½¢å¼ï¼ˆå³çº¿æ€§ï¼‰
            if right.len() == 1 {
                // å•ä¸ªç»ˆç»“ç¬¦
                continue;
            } else if right.len() == 2 {
                // ç»ˆç»“ç¬¦ + å˜å…ƒ
                let first = right.chars().next().unwrap();
                let second = right.chars().nth(1).unwrap();
                if !first.is_lowercase() || !second.is_uppercase() {
                    return false;
                }
            } else {
                return false;
            }
        }
        true
    }
    
    /// éªŒè¯ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•çš„äº§ç”Ÿå¼
    fn validate_context_free_productions(productions: &[Production]) -> bool {
        for production in productions {
            let left = &production.left;
            
            // å·¦éƒ¨å¿…é¡»æ˜¯å•ä¸ªå˜å…ƒ
            if left.len() != 1 {
                return false;
            }
            
            let first_char = left.chars().next().unwrap();
            if !first_char.is_uppercase() {
                return false;
            }
        }
        true
    }
    
    /// éªŒè¯ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•çš„äº§ç”Ÿå¼
    fn validate_context_sensitive_productions(productions: &[Production]) -> bool {
        for production in productions {
            let left = &production.left;
            let right = &production.right;
            
            // å·¦éƒ¨é•¿åº¦å¿…é¡»å°äºç­‰äºå³éƒ¨é•¿åº¦
            if left.len() > right.len() {
                return false;
            }
            
            // å·¦éƒ¨å¿…é¡»åŒ…å«è‡³å°‘ä¸€ä¸ªå˜å…ƒ
            let has_variable = left.chars().any(|c| c.is_uppercase());
            if !has_variable {
                return false;
            }
        }
        true
    }
    
    /// åˆ¤æ–­æ–‡æ³•ç±»å‹
    pub fn determine_grammar_type(&self) -> GrammarType {
        if Self::validate_regular_productions(&self.productions) {
            GrammarType::Regular
        } else if Self::validate_context_free_productions(&self.productions) {
            GrammarType::ContextFree
        } else if Self::validate_context_sensitive_productions(&self.productions) {
            GrammarType::ContextSensitive
        } else {
            GrammarType::Unrestricted
        }
    }
    
    /// æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦å¯ä»¥ç”±æ–‡æ³•ç”Ÿæˆ
    pub fn generates(&self, input: &str) -> bool {
        // ç®€åŒ–çš„å®ç°ï¼Œå®é™…ä¸­éœ€è¦æ›´å¤æ‚çš„è§£æç®—æ³•
        let mut current = self.start_symbol.to_string();
        
        // ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢
        let mut queue = vec![current.clone()];
        let mut visited = HashSet::new();
        visited.insert(current);
        
        while let Some(current_str) = queue.pop() {
            if current_str == input {
                return true;
            }
            
            // å°è¯•æ‰€æœ‰å¯èƒ½çš„äº§ç”Ÿå¼
            for production in &self.productions {
                let mut pos = 0;
                while let Some(start) = current_str[pos..].find(&production.left) {
                    let actual_start = pos + start;
                    let mut new_str = current_str.clone();
                    new_str.replace_range(actual_start..actual_start + production.left.len(), &production.right);
                    
                    if !visited.contains(&new_str) {
                        visited.insert(new_str.clone());
                        queue.push(new_str);
                    }
                    
                    pos = actual_start + 1;
                }
            }
        }
        
        false
    }
}

/// åˆ›å»ºç¤ºä¾‹æ–‡æ³•
pub fn create_regular_grammar() -> Grammar {
    let variables: HashSet<char> = vec!['S', 'A'].into_iter().collect();
    let terminals: HashSet<char> = vec!['a', 'b'].into_iter().collect();
    
    let productions = vec![
        Production::new("S".to_string(), "aA".to_string()),
        Production::new("A".to_string(), "bA".to_string()),
        Production::new("A".to_string(), "b".to_string()),
    ];
    
    Grammar::new(
        GrammarType::Regular,
        variables,
        terminals,
        productions,
        'S',
    ).unwrap()
}

pub fn create_context_free_grammar() -> Grammar {
    let variables: HashSet<char> = vec!['S'].into_iter().collect();
    let terminals: HashSet<char> = vec!['a', 'b'].into_iter().collect();
    
    let productions = vec![
        Production::new("S".to_string(), "aSb".to_string()),
        Production::new("S".to_string(), "ab".to_string()),
    ];
    
    Grammar::new(
        GrammarType::ContextFree,
        variables,
        terminals,
        productions,
        'S',
    ).unwrap()
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_grammar_type_detection() {
        let regular_grammar = create_regular_grammar();
        assert_eq!(regular_grammar.determine_grammar_type(), GrammarType::Regular);
        
        let cf_grammar = create_context_free_grammar();
        assert_eq!(cf_grammar.determine_grammar_type(), GrammarType::ContextFree);
    }
    
    #[test]
    fn test_regular_grammar() {
        let grammar = create_regular_grammar();
        
        assert!(grammar.generates("ab"));
        assert!(grammar.generates("abb"));
        assert!(grammar.generates("abbb"));
        assert!(!grammar.generates("ba"));
    }
    
    #[test]
    fn test_context_free_grammar() {
        let grammar = create_context_free_grammar();
        
        assert!(grammar.generates("ab"));
        assert!(grammar.generates("aabb"));
        assert!(grammar.generates("aaabbb"));
        assert!(!grammar.generates("aab"));
    }
}
```

### 4.2 Haskell å®ç°

```haskell
import Data.Set (Set)
import qualified Data.Set as Set
import Data.List (find, nub)

-- è¡¨ç¤ºæ–‡æ³•ç±»å‹
data GrammarType = Regular | ContextFree | ContextSensitive | Unrestricted
    deriving (Show, Eq, Ord)

-- è¡¨ç¤ºä¸€ä¸ªäº§ç”Ÿå¼
data Production = Production
    { left :: String
    , right :: String
    } deriving (Show, Eq, Ord)

-- è¡¨ç¤ºä¸€ä¸ªæ–‡æ³•
data Grammar = Grammar
    { grammarType :: GrammarType
    , variables :: Set Char
    , terminals :: Set Char
    , productions :: [Production]
    , startSymbol :: Char
    } deriving (Show)

-- éªŒè¯æ­£åˆ™æ–‡æ³•çš„äº§ç”Ÿå¼
validateRegularProductions :: [Production] -> Bool
validateRegularProductions prods = 
    all validateRegularProduction prods
  where
    validateRegularProduction (Production left right) =
        length left == 1 && 
        (length right == 1 || 
         (length right == 2 && 
          isLower (head right) && 
          isUpper (right !! 1)))

-- éªŒè¯ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•çš„äº§ç”Ÿå¼
validateContextFreeProductions :: [Production] -> Bool
validateContextFreeProductions prods = 
    all validateContextFreeProduction prods
  where
    validateContextFreeProduction (Production left _) =
        length left == 1 && isUpper (head left)

-- éªŒè¯ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•çš„äº§ç”Ÿå¼
validateContextSensitiveProductions :: [Production] -> Bool
validateContextSensitiveProductions prods = 
    all validateContextSensitiveProduction prods
  where
    validateContextSensitiveProduction (Production left right) =
        length left <= length right && 
        any isUpper left

-- åˆ¤æ–­æ–‡æ³•ç±»å‹
determineGrammarType :: [Production] -> GrammarType
determineGrammarType prods
    | validateRegularProductions prods = Regular
    | validateContextFreeProductions prods = ContextFree
    | validateContextSensitiveProductions prods = ContextSensitive
    | otherwise = Unrestricted

-- åˆ›å»ºæ­£åˆ™æ–‡æ³•
createRegularGrammar :: Grammar
createRegularGrammar = Grammar
    { grammarType = Regular
    , variables = Set.fromList "SA"
    , terminals = Set.fromList "ab"
    , productions = 
        [ Production "S" "aA"
        , Production "A" "bA"
        , Production "A" "b"
        ]
    , startSymbol = 'S'
    }

-- åˆ›å»ºä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•
createContextFreeGrammar :: Grammar
createContextFreeGrammar = Grammar
    { grammarType = ContextFree
    , variables = Set.fromList "S"
    , terminals = Set.fromList "ab"
    , productions = 
        [ Production "S" "aSb"
        , Production "S" "ab"
        ]
    , startSymbol = 'S'
    }

-- æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦å¯ä»¥ç”±æ–‡æ³•ç”Ÿæˆ
generates :: Grammar -> String -> Bool
generates grammar input = 
    let derivations = derive grammar 20
    in  any (\d -> d == input && all (\c -> Set.member c (terminals grammar)) d) derivations

-- ç”Ÿæˆæ¨å¯¼
derive :: Grammar -> Int -> [String]
derive grammar maxSteps = 
    let initial = [startSymbol grammar]
        derivations = iterate (step grammar) initial
    in  concat $ take maxSteps derivations

-- å•æ­¥æ¨å¯¼
step :: Grammar -> [String] -> [String]
step grammar currentStrings = 
    nub $ concatMap (applyProductions grammar) currentStrings

-- åº”ç”¨äº§ç”Ÿå¼
applyProductions :: Grammar -> String -> [String]
applyProductions grammar str = 
    concatMap (applyProduction str) (productions grammar)

-- åº”ç”¨å•ä¸ªäº§ç”Ÿå¼
applyProduction :: String -> Production -> [String]
applyProduction str (Production left right) = 
    let positions = findSubstringPositions left str
    in  map (\pos -> replaceAt str pos left right) positions

-- æŸ¥æ‰¾å­ä¸²ä½ç½®
findSubstringPositions :: String -> String -> [Int]
findSubstringPositions sub str = 
    [i | i <- [0..length str - length sub], 
     take (length sub) (drop i str) == sub]

-- åœ¨æŒ‡å®šä½ç½®æ›¿æ¢
replaceAt :: String -> Int -> String -> String -> String
replaceAt str pos old new = 
    take pos str ++ new ++ drop (pos + length old) str

-- æµ‹è¯•å‡½æ•°
testChomskyHierarchy :: IO ()
testChomskyHierarchy = do
    let regularGrammar = createRegularGrammar
        cfGrammar = createContextFreeGrammar
    
    putStrLn "Testing Chomsky Hierarchy:"
    
    putStrLn "\nRegular Grammar (Type 3):"
    putStrLn $ "Type: " ++ show (grammarType regularGrammar)
    putStrLn $ "Generates 'ab': " ++ show (generates regularGrammar "ab")
    putStrLn $ "Generates 'abb': " ++ show (generates regularGrammar "abb")
    putStrLn $ "Generates 'ba': " ++ show (generates regularGrammar "ba")
    
    putStrLn "\nContext-Free Grammar (Type 2):"
    putStrLn $ "Type: " ++ show (grammarType cfGrammar)
    putStrLn $ "Generates 'ab': " ++ show (generates cfGrammar "ab")
    putStrLn $ "Generates 'aabb': " ++ show (generates cfGrammar "aabb")
    putStrLn $ "Generates 'aab': " ++ show (generates cfGrammar "aab")
    
    putStrLn "\nGrammar Type Detection:"
    putStrLn $ "Regular grammar detected as: " ++ show (determineGrammarType (productions regularGrammar))
    putStrLn $ "CF grammar detected as: " ++ show (determineGrammarType (productions cfGrammar))

main :: IO ()
main = testChomskyHierarchy
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç¼–ç¨‹è¯­è¨€

**ç¤ºä¾‹ 5.1.1** (æ­£åˆ™è¡¨è¾¾å¼)
æ­£åˆ™è¡¨è¾¾å¼å¯¹åº”æ­£åˆ™è¯­è¨€ï¼Œç”¨äºæ¨¡å¼åŒ¹é…å’Œæ–‡æœ¬å¤„ç†ã€‚

**ç¤ºä¾‹ 5.1.2** (ç¼–ç¨‹è¯­è¨€è¯­æ³•)
å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€çš„è¯­æ³•å¯ä»¥ç”¨ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•æè¿°ã€‚

### 5.2 è‡ªç„¶è¯­è¨€å¤„ç†

**ç¤ºä¾‹ 5.2.1** (å¥æ³•åˆ†æ)
è‡ªç„¶è¯­è¨€çš„å¥æ³•ç»“æ„å¯ä»¥ç”¨ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•æˆ–æ›´å¤æ‚çš„æ–‡æ³•æè¿°ã€‚

### 5.3 ç¼–è¯‘å™¨è®¾è®¡

**ç¤ºä¾‹ 5.2.2** (è¯æ³•åˆ†æ)
è¯æ³•åˆ†æå™¨é€šå¸¸ä½¿ç”¨æ­£åˆ™æ–‡æ³•æ¥è¯†åˆ«è¯æ³•å•å…ƒã€‚

## 6. ç›¸å…³ç†è®º

### 6.1 è‡ªåŠ¨æœºç†è®º

- **æœ‰é™è‡ªåŠ¨æœº**ï¼šè¯†åˆ«æ­£åˆ™è¯­è¨€
- **ä¸‹æ¨è‡ªåŠ¨æœº**ï¼šè¯†åˆ«ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€
- **çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº**ï¼šè¯†åˆ«ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€
- **å›¾çµæœº**ï¼šè¯†åˆ«é€’å½’å¯æšä¸¾è¯­è¨€

### 6.2 è®¡ç®—å¤æ‚æ€§

æ¯ä¸ªå±‚æ¬¡éƒ½æœ‰å¯¹åº”çš„è®¡ç®—å¤æ‚æ€§å’Œåˆ¤å®šæ€§é—®é¢˜ã€‚

### 6.3 è¯­è¨€ç±»çš„æ€§è´¨

ä¸åŒå±‚æ¬¡çš„è¯­è¨€ç±»åœ¨è¿ç®—å°é—­æ€§ã€åˆ¤å®šæ€§ç­‰æ–¹é¢æœ‰ä¸åŒçš„æ€§è´¨ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to Automata Theory, Languages, and Computation. Pearson.
2. Sipser, M. (2012). Introduction to the Theory of Computation. Cengage Learning.
3. Chomsky, N. (1956). Three models for the description of language. IRE Transactions on Information Theory, 2(3), 113-124.
4. Davis, M., Sigal, R., & Weyuker, E. J. (1994). Computability, Complexity, and Languages. Academic Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [03.2.1 æ­£åˆ™æ–‡æ³•](../03_Formal_Language_Theory/03.2.1_æ­£åˆ™æ–‡æ³•.md)
- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03_Formal_Language_Theory/03.2.2_ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•.md)
- [03.2.3 ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•](../03_Formal_Language_Theory/03.2.3_ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•.md)
- [03.2.4 æ— é™åˆ¶æ–‡æ³•](../03_Formal_Language_Theory/03.2.4_æ— é™åˆ¶æ–‡æ³•.md)
