# 03.3 è¯­è¨€å±‚æ¬¡ç†è®º

> **é‡è¦æç¤º**: æœ¬æ–‡ä»¶çš„å†…å®¹å·²è¢«é‡æ„åˆ° [03.3_Language_Hierarchy](./03.3_Language_Hierarchy/) ç›®å½•ä¸­ã€‚è¯·è®¿é—®è¯¥ç›®å½•è·å–æœ€æ–°çš„ã€ç»“æ„åŒ–çš„è¯­è¨€å±‚æ¬¡ç†è®ºå†…å®¹ã€‚
>
> æ–°çš„ç›®å½•ç»“æ„åŒ…æ‹¬:
>
> - [03.3.1_ä¹”å§†æ–¯åŸºè°±ç³»](./03.3_Language_Hierarchy/03.3.1_ä¹”å§†æ–¯åŸºè°±ç³»/03.3.1_ä¹”å§†æ–¯åŸºè°±ç³».md)
> - [03.3.2_è¯­è¨€åˆ†ç±»](./03.3_Language_Hierarchy/03.3.2_è¯­è¨€åˆ†ç±»/03.3.2_è¯­è¨€åˆ†ç±».md)
> - [03.3.3_è¯­è¨€æ€§è´¨](./03.3_Language_Hierarchy/03.3.3_è¯­è¨€æ€§è´¨/03.3.3_è¯­è¨€æ€§è´¨.md)
> - [03.3.4_è¯­è¨€å…³ç³»](./03.3_Language_Hierarchy/03.3.4_è¯­è¨€å…³ç³»/03.3.4_è¯­è¨€å…³ç³».md)
>
> æ­¤æ–‡ä»¶ä¿ç•™ä½œä¸ºå†å²å‚è€ƒã€‚
>
> **æ›´æ–°æ—¶é—´**: 2024-12-22

## ğŸ“‹ æ¦‚è¿°

è¯­è¨€å±‚æ¬¡ç†è®ºæ˜¯å½¢å¼è¯­è¨€ç†è®ºçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œå®ƒç ”ç©¶ä¸åŒç±»å‹å½¢å¼è¯­è¨€ä¹‹é—´çš„å±‚æ¬¡å…³ç³»ã€è¡¨è¾¾èƒ½åŠ›å’Œè®¡ç®—å¤æ‚æ€§ã€‚
ä¹”å§†æ–¯åŸºè°±ç³»ï¼ˆChomsky Hierarchyï¼‰ä½œä¸ºè¿™ä¸€ç†è®ºçš„åŸºç¡€ï¼Œå°†å½¢å¼è¯­è¨€æŒ‰ç…§å…¶ç”Ÿæˆæ–‡æ³•çš„å¤æ‚æ€§å’Œè¯†åˆ«è‡ªåŠ¨æœºçš„èƒ½åŠ›åˆ†ä¸ºå››ä¸ªå±‚æ¬¡ã€‚
è¿™ç§åˆ†ç±»ä¸ä»…æ­ç¤ºäº†è¯­è¨€è¡¨è¾¾èƒ½åŠ›çš„é€’è¿›å…³ç³»ï¼Œä¹Ÿä¸ºç†è§£è®¡ç®—æ¨¡å‹çš„èƒ½åŠ›è¾¹ç•Œæä¾›äº†ç†è®ºæ¡†æ¶ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å±‚æ¬¡ç»“æ„**ï¼šå»ºç«‹å½¢å¼è¯­è¨€çš„ä¸¥æ ¼å±‚æ¬¡åˆ†ç±»
2. **ç­‰ä»·å…³ç³»**ï¼šé˜æ˜è¯­è¨€ç±»åˆ«ä¸è‡ªåŠ¨æœºæ¨¡å‹çš„å¯¹åº”å…³ç³»
3. **åˆ†ç•Œç‰¹æ€§**ï¼šè¯†åˆ«åŒºåˆ†ä¸åŒè¯­è¨€ç±»åˆ«çš„å…³é”®ç‰¹æ€§
4. **è¡¨è¾¾èƒ½åŠ›**ï¼šåˆ†æå„å±‚æ¬¡è¯­è¨€çš„è¡¨è¾¾èƒ½åŠ›å’Œå±€é™æ€§
5. **åº”ç”¨ä»·å€¼**ï¼šå±•ç¤ºè¯­è¨€å±‚æ¬¡ç†è®ºåœ¨è®¡ç®—æœºç§‘å­¦ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [ä¹”å§†æ–¯åŸºè°±ç³»](#2-ä¹”å§†æ–¯åŸºè°±ç³»)
3. [è¯­è¨€ç‰¹æ€§ä¸åˆ†ç•Œ](#3-è¯­è¨€ç‰¹æ€§ä¸åˆ†ç•Œ)
4. [å±‚æ¬¡æ‰©å±•](#4-å±‚æ¬¡æ‰©å±•)
5. [ä»£ç å®ç°](#5-ä»£ç å®ç°)
6. [åº”ç”¨ç¤ºä¾‹](#6-åº”ç”¨ç¤ºä¾‹)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å½¢å¼è¯­è¨€åŸºç¡€

**å®šä¹‰ 1.1.1** (å­—æ¯è¡¨)
å­—æ¯è¡¨ $\Sigma$ æ˜¯ä¸€ä¸ªæœ‰é™çš„éç©ºç¬¦å·é›†åˆã€‚

**å®šä¹‰ 1.1.2** (å­—ç¬¦ä¸²)
å­—ç¬¦ä¸²æ˜¯å­—æ¯è¡¨ä¸­ç¬¦å·çš„æœ‰é™åºåˆ—ã€‚ç©ºå­—ç¬¦ä¸²è®°ä¸º $\epsilon$ã€‚

**å®šä¹‰ 1.1.3** (è¯­è¨€)
è¯­è¨€ $L$ æ˜¯å®šä¹‰åœ¨å­—æ¯è¡¨ $\Sigma$ ä¸Šçš„å­—ç¬¦ä¸²é›†åˆï¼Œå³ $L \subseteq \Sigma^*$ã€‚

### 1.2 è¯­è¨€ç±»åˆ«

**å®šä¹‰ 1.2.1** (é€’å½’å¯æšä¸¾è¯­è¨€)
å¦‚æœå­˜åœ¨å›¾çµæœºèƒ½å¤Ÿæ¥å—è¯¥è¯­è¨€ä¸­çš„æ‰€æœ‰å­—ç¬¦ä¸²ï¼Œåˆ™ç§°è¯¥è¯­è¨€ä¸ºé€’å½’å¯æšä¸¾è¯­è¨€ã€‚

**å®šä¹‰ 1.2.2** (é€’å½’è¯­è¨€)
å¦‚æœå­˜åœ¨å›¾çµæœºèƒ½å¤Ÿåˆ¤å®šä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦å±äºè¯¥è¯­è¨€ï¼ˆå³å›¾çµæœºå¯¹äºä»»ä½•è¾“å…¥éƒ½ä¼šåœæœºï¼‰ï¼Œåˆ™ç§°è¯¥è¯­è¨€ä¸ºé€’å½’è¯­è¨€ã€‚

**å®šä¹‰ 1.2.3** (ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€)
å¦‚æœå­˜åœ¨çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºèƒ½å¤Ÿæ¥å—è¯¥è¯­è¨€ï¼Œåˆ™ç§°è¯¥è¯­è¨€ä¸ºä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ã€‚

**å®šä¹‰ 1.2.4** (ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€)
å¦‚æœå­˜åœ¨ä¸‹æ¨è‡ªåŠ¨æœºèƒ½å¤Ÿæ¥å—è¯¥è¯­è¨€ï¼Œåˆ™ç§°è¯¥è¯­è¨€ä¸ºä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ã€‚

**å®šä¹‰ 1.2.5** (æ­£åˆ™è¯­è¨€)
å¦‚æœå­˜åœ¨æœ‰é™è‡ªåŠ¨æœºèƒ½å¤Ÿæ¥å—è¯¥è¯­è¨€ï¼Œåˆ™ç§°è¯¥è¯­è¨€ä¸ºæ­£åˆ™è¯­è¨€ã€‚

## 2. ä¹”å§†æ–¯åŸºè°±ç³»

### 2.1 è°±ç³»ç»“æ„

**å®šä¹‰ 2.1.1** (ä¹”å§†æ–¯åŸºè°±ç³»)
ä¹”å§†æ–¯åŸºè°±ç³»å°†å½¢å¼è¯­è¨€åˆ†ä¸ºå››ä¸ªå±‚æ¬¡ï¼š

1. **0å‹è¯­è¨€**ï¼ˆé€’å½’å¯æšä¸¾è¯­è¨€ï¼‰ï¼šç”±æ— é™åˆ¶æ–‡æ³•ç”Ÿæˆï¼Œå›¾çµæœºè¯†åˆ«
2. **1å‹è¯­è¨€**ï¼ˆä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼‰ï¼šç”±ä¸Šä¸‹æ–‡ç›¸å…³æ–‡æ³•ç”Ÿæˆï¼Œçº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºè¯†åˆ«
3. **2å‹è¯­è¨€**ï¼ˆä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼‰ï¼šç”±ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ç”Ÿæˆï¼Œä¸‹æ¨è‡ªåŠ¨æœºè¯†åˆ«
4. **3å‹è¯­è¨€**ï¼ˆæ­£åˆ™è¯­è¨€ï¼‰ï¼šç”±æ­£åˆ™æ–‡æ³•ç”Ÿæˆï¼Œæœ‰é™è‡ªåŠ¨æœºè¯†åˆ«

**å®šç† 2.1.1** (è°±ç³»åŒ…å«å…³ç³»)
ä¹”å§†æ–¯åŸºè°±ç³»å½¢æˆä¸¥æ ¼åŒ…å«å…³ç³»ï¼š
$$\mathcal{L}_3 \subset \mathcal{L}_2 \subset \mathcal{L}_1 \subset \mathcal{L}_0$$
å…¶ä¸­ $\mathcal{L}_i$ è¡¨ç¤º $i$ å‹è¯­è¨€çš„é›†åˆã€‚

**è¯æ˜**:

1. $\mathcal{L}_3 \subset \mathcal{L}_2$ï¼šæ¯ä¸ªæ­£åˆ™è¯­è¨€éƒ½æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼Œä½† $L = \{a^n b^n \mid n \geq 1\}$ æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€è€Œéæ­£åˆ™è¯­è¨€ï¼ˆé€šè¿‡æ³µå¼•ç†è¯æ˜ï¼‰ã€‚
2. $\mathcal{L}_2 \subset \mathcal{L}_1$ï¼šæ¯ä¸ªä¸Šä¸‹æ–‡æ— å…³è¯­è¨€éƒ½æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼Œä½† $L = \{a^n b^n c^n \mid n \geq 1\}$ æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€è€Œéä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼ˆé€šè¿‡æ³µå¼•ç†è¯æ˜ï¼‰ã€‚
3. $\mathcal{L}_1 \subset \mathcal{L}_0$ï¼šæ¯ä¸ªä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€éƒ½æ˜¯é€’å½’å¯æšä¸¾è¯­è¨€ï¼Œä½†å›¾çµæœºçš„åœæœºé—®é¢˜å¯¹åº”çš„è¯­è¨€æ˜¯é€’å½’å¯æšä¸¾è¯­è¨€è€Œéä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ã€‚

### 2.2 è‡ªåŠ¨æœºå¯¹åº”å…³ç³»

**å®šç† 2.2.1** (è¯­è¨€ä¸è‡ªåŠ¨æœºçš„å¯¹åº”)
ä¹”å§†æ–¯åŸºè°±ç³»ä¸­çš„è¯­è¨€ç±»åˆ«ä¸è‡ªåŠ¨æœºæ¨¡å‹å­˜åœ¨ä¸¥æ ¼å¯¹åº”å…³ç³»ï¼š

1. æ­£åˆ™è¯­è¨€ $\Leftrightarrow$ æœ‰é™è‡ªåŠ¨æœº
2. ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ $\Leftrightarrow$ ä¸‹æ¨è‡ªåŠ¨æœº
3. ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ $\Leftrightarrow$ çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº
4. é€’å½’å¯æšä¸¾è¯­è¨€ $\Leftrightarrow$ å›¾çµæœº

**å®šç† 2.2.2** (è®¡ç®—èƒ½åŠ›å±‚æ¬¡)
è‡ªåŠ¨æœºæ¨¡å‹çš„è®¡ç®—èƒ½åŠ›å½¢æˆä¸¥æ ¼é€’å¢å…³ç³»ï¼š
$$\text{FSA} \subset \text{PDA} \subset \text{LBA} \subset \text{TM}$$
å…¶ä¸­ FSA è¡¨ç¤ºæœ‰é™çŠ¶æ€è‡ªåŠ¨æœºï¼ŒPDA è¡¨ç¤ºä¸‹æ¨è‡ªåŠ¨æœºï¼ŒLBA è¡¨ç¤ºçº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºï¼ŒTM è¡¨ç¤ºå›¾çµæœºã€‚

### 2.3 åˆ†ç•Œè¯­è¨€

**å®šä¹‰ 2.3.1** (åˆ†ç•Œè¯­è¨€)
åˆ†ç•Œè¯­è¨€æ˜¯æŒ‡æ°å¥½å±äºæŸä¸€è¯­è¨€ç±»åˆ«ä½†ä¸å±äºæ›´ä½å±‚æ¬¡ç±»åˆ«çš„è¯­è¨€ã€‚

**ç¤ºä¾‹ 2.3.1** (æ­£åˆ™ä¸ä¸Šä¸‹æ–‡æ— å…³çš„åˆ†ç•Œ)
è¯­è¨€ $L = \{a^n b^n \mid n \geq 1\}$ æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ä½†ä¸æ˜¯æ­£åˆ™è¯­è¨€ï¼Œå› æ­¤æ˜¯æ­£åˆ™è¯­è¨€ä¸ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€çš„åˆ†ç•Œè¯­è¨€ã€‚

**ç¤ºä¾‹ 2.3.2** (ä¸Šä¸‹æ–‡æ— å…³ä¸ä¸Šä¸‹æ–‡ç›¸å…³çš„åˆ†ç•Œ)
è¯­è¨€ $L = \{a^n b^n c^n \mid n \geq 1\}$ æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ä½†ä¸æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼Œå› æ­¤æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ä¸ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€çš„åˆ†ç•Œè¯­è¨€ã€‚

**ç¤ºä¾‹ 2.3.3** (ä¸Šä¸‹æ–‡ç›¸å…³ä¸é€’å½’å¯æšä¸¾çš„åˆ†ç•Œ)
åœæœºé—®é¢˜å¯¹åº”çš„è¯­è¨€ $L_{halt} = \{\langle M, w \rangle \mid \text{å›¾çµæœº } M \text{ åœ¨è¾“å…¥ } w \text{ ä¸Šåœæœº}\}$ æ˜¯é€’å½’å¯æšä¸¾è¯­è¨€ä½†ä¸æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼Œå› æ­¤æ˜¯ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ä¸é€’å½’å¯æšä¸¾è¯­è¨€çš„åˆ†ç•Œè¯­è¨€ã€‚

## 3. è¯­è¨€ç‰¹æ€§ä¸åˆ†ç•Œ

### 3.1 æ³µå¼•ç†

**å®šç† 3.1.1** (æ­£åˆ™è¯­è¨€çš„æ³µå¼•ç†)
å¯¹äºä»»ä½•æ­£åˆ™è¯­è¨€ $L$ï¼Œå­˜åœ¨ä¸€ä¸ªå¸¸æ•° $p \geq 1$ï¼Œä½¿å¾—å¯¹äºä»»ä½• $z \in L$ï¼Œå¦‚æœ $|z| \geq p$ï¼Œåˆ™ $z$ å¯ä»¥å†™æˆ $z = uvw$ï¼Œå…¶ä¸­ï¼š

1. $|uv| \leq p$
2. $|v| \geq 1$
3. å¯¹äºä»»ä½• $i \geq 0$ï¼Œ$uv^iw \in L$

**å®šç† 3.1.2** (ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€çš„æ³µå¼•ç†)
å¯¹äºä»»ä½•ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ $L$ï¼Œå­˜åœ¨ä¸€ä¸ªå¸¸æ•° $p \geq 1$ï¼Œä½¿å¾—å¯¹äºä»»ä½• $z \in L$ï¼Œå¦‚æœ $|z| \geq p$ï¼Œåˆ™ $z$ å¯ä»¥å†™æˆ $z = uvwxy$ï¼Œå…¶ä¸­ï¼š

1. $|vwx| \leq p$
2. $|vx| \geq 1$
3. å¯¹äºä»»ä½• $i \geq 0$ï¼Œ$uv^iwx^iy \in L$

**åº”ç”¨ 3.1.1** (è¯æ˜è¯­è¨€ä¸æ˜¯æ­£åˆ™çš„)
åˆ©ç”¨æ³µå¼•ç†å¯ä»¥è¯æ˜ $L = \{a^n b^n \mid n \geq 1\}$ ä¸æ˜¯æ­£åˆ™è¯­è¨€ã€‚

**åº”ç”¨ 3.1.2** (è¯æ˜è¯­è¨€ä¸æ˜¯ä¸Šä¸‹æ–‡æ— å…³çš„)
åˆ©ç”¨æ³µå¼•ç†å¯ä»¥è¯æ˜ $L = \{a^n b^n c^n \mid n \geq 1\}$ ä¸æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ã€‚

### 3.2 é—­åŒ…æ€§è´¨

**å®šç† 3.2.1** (æ­£åˆ™è¯­è¨€çš„é—­åŒ…æ€§è´¨)
æ­£åˆ™è¯­è¨€ç±»å¯¹ä»¥ä¸‹è¿ç®—å°é—­ï¼š

- å¹¶è¿ç®—
- äº¤è¿ç®—
- è¡¥è¿ç®—
- è¿æ¥è¿ç®—
- å…‹æ—é—­åŒ…
- åŒæ€æ˜ å°„
- åŒæ€é€†æ˜ å°„

**å®šç† 3.2.2** (ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€çš„é—­åŒ…æ€§è´¨)
ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ç±»å¯¹ä»¥ä¸‹è¿ç®—å°é—­ï¼š

- å¹¶è¿ç®—
- è¿æ¥è¿ç®—
- å…‹æ—é—­åŒ…
- åŒæ€æ˜ å°„
ä½†å¯¹ä»¥ä¸‹è¿ç®—ä¸å°é—­ï¼š
- äº¤è¿ç®—
- è¡¥è¿ç®—

**å®šç† 3.2.3** (ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€çš„é—­åŒ…æ€§è´¨)
ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ç±»å¯¹ä»¥ä¸‹è¿ç®—å°é—­ï¼š

- å¹¶è¿ç®—
- äº¤è¿ç®—
- è¿æ¥è¿ç®—
- å…‹æ—é—­åŒ…
ä½†å¯¹è¡¥è¿ç®—ä¸å°é—­ã€‚

### 3.3 åˆ¤å®šæ€§è´¨

**å®šç† 3.3.1** (è¯­è¨€åˆ¤å®šé—®é¢˜)
å„è¯­è¨€ç±»åˆ«çš„åˆ¤å®šé—®é¢˜å…·æœ‰ä¸åŒçš„å¤æ‚æ€§ï¼š

1. æ­£åˆ™è¯­è¨€ï¼šæˆå‘˜èµ„æ ¼é—®é¢˜å¯åˆ¤å®šï¼Œç­‰ä»·æ€§é—®é¢˜å¯åˆ¤å®š
2. ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼šæˆå‘˜èµ„æ ¼é—®é¢˜å¯åˆ¤å®šï¼Œç­‰ä»·æ€§é—®é¢˜ä¸å¯åˆ¤å®š
3. ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼šæˆå‘˜èµ„æ ¼é—®é¢˜å¯åˆ¤å®šï¼Œç­‰ä»·æ€§é—®é¢˜ä¸å¯åˆ¤å®š
4. é€’å½’å¯æšä¸¾è¯­è¨€ï¼šæˆå‘˜èµ„æ ¼é—®é¢˜åŠå¯åˆ¤å®šï¼Œç­‰ä»·æ€§é—®é¢˜ä¸å¯åˆ¤å®š

**å®šç† 3.3.2** (ç©ºè¯­è¨€é—®é¢˜)
åˆ¤æ–­ä¸€ä¸ªè¯­è¨€æ˜¯å¦ä¸ºç©ºè¯­è¨€çš„å¤æ‚æ€§ï¼š

1. æ­£åˆ™è¯­è¨€ï¼šå¯åˆ¤å®š
2. ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼šå¯åˆ¤å®š
3. ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ï¼šä¸å¯åˆ¤å®š
4. é€’å½’å¯æšä¸¾è¯­è¨€ï¼šä¸å¯åˆ¤å®š

## 4. å±‚æ¬¡æ‰©å±•

### 4.1 é€’å½’è¯­è¨€

**å®šä¹‰ 4.1.1** (é€’å½’è¯­è¨€)
å¦‚æœè¯­è¨€ $L$ åŠå…¶è¡¥è¯­ $\overline{L}$ éƒ½æ˜¯é€’å½’å¯æšä¸¾çš„ï¼Œåˆ™ $L$ æ˜¯é€’å½’è¯­è¨€ã€‚

**å®šç† 4.1.1** (é€’å½’è¯­è¨€çš„ä½ç½®)
é€’å½’è¯­è¨€ç±»ä¸¥æ ¼åŒ…å«äºé€’å½’å¯æšä¸¾è¯­è¨€ç±»ï¼Œä¸”ä¸¥æ ¼åŒ…å«ä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€ç±»ï¼š
$$\mathcal{L}_1 \subset \mathcal{L}_{rec} \subset \mathcal{L}_0$$
å…¶ä¸­ $\mathcal{L}_{rec}$ è¡¨ç¤ºé€’å½’è¯­è¨€çš„é›†åˆã€‚

### 4.2 ç¡®å®šæ€§ä¸éç¡®å®šæ€§

**å®šç† 4.2.1** (ç¡®å®šæ€§ä¸éç¡®å®šæ€§)
ä¸åŒè‡ªåŠ¨æœºæ¨¡å‹çš„ç¡®å®šæ€§ä¸éç¡®å®šæ€§å…³ç³»ï¼š

1. ç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº = éç¡®å®šæ€§æœ‰é™è‡ªåŠ¨æœº
2. ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº $\subset$ éç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœº
3. ç¡®å®šæ€§çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº = éç¡®å®šæ€§çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœºï¼ˆçŒœæƒ³ï¼‰
4. ç¡®å®šæ€§å›¾çµæœº = éç¡®å®šæ€§å›¾çµæœº

**ç¤ºä¾‹ 4.2.1** (ç¡®å®šæ€§ä¸éç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœºçš„å·®å¼‚)
è¯­è¨€ $L = \{ww^R \mid w \in \{a,b\}^*\} \cup \{ww \mid w \in \{a,b\}^*\}$ å¯ä»¥è¢«éç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœºè¯†åˆ«ï¼Œä½†ä¸èƒ½è¢«ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœºè¯†åˆ«ã€‚

### 4.3 ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€çš„å­ç±»

**å®šä¹‰ 4.3.1** (ç¡®å®šæ€§ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€)
å¦‚æœä¸€ä¸ªä¸Šä¸‹æ–‡æ— å…³è¯­è¨€å¯ä»¥è¢«ç¡®å®šæ€§ä¸‹æ¨è‡ªåŠ¨æœºè¯†åˆ«ï¼Œåˆ™ç§°å…¶ä¸ºç¡®å®šæ€§ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ã€‚

**å®šä¹‰ 4.3.2** (LL(k)è¯­è¨€)
å¦‚æœä¸€ä¸ªä¸Šä¸‹æ–‡æ— å…³è¯­è¨€å¯ä»¥é€šè¿‡å‘å‰çœ‹ k ä¸ªç¬¦å·çš„è‡ªé¡¶å‘ä¸‹åˆ†ææ–¹æ³•è¯†åˆ«ï¼Œåˆ™ç§°å…¶ä¸º LL(k) è¯­è¨€ã€‚

**å®šä¹‰ 4.3.3** (LR(k)è¯­è¨€)
å¦‚æœä¸€ä¸ªä¸Šä¸‹æ–‡æ— å…³è¯­è¨€å¯ä»¥é€šè¿‡å‘å‰çœ‹ k ä¸ªç¬¦å·çš„è‡ªåº•å‘ä¸Šåˆ†ææ–¹æ³•è¯†åˆ«ï¼Œåˆ™ç§°å…¶ä¸º LR(k) è¯­è¨€ã€‚

**å®šç† 4.3.1** (ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€çš„å­ç±»å…³ç³»)
$$\text{LL}(1) \subset \text{LL}(k) \subset \text{DCFL} \subset \text{LR}(1) \subset \text{LR}(k) \subset \text{CFL}$$
å…¶ä¸­ DCFL è¡¨ç¤ºç¡®å®šæ€§ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼ŒCFL è¡¨ç¤ºä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ã€‚

## 5. ä»£ç å®ç°

### 5.1 è¯­è¨€å±‚æ¬¡çš„Rustå®ç°

```rust
use std::collections::{HashSet, VecDeque};
use std::fmt;
use std::hash::Hash;

// è¯­è¨€ç±»åˆ«æšä¸¾
#[derive(Debug, Clone, PartialEq, Eq)]
enum LanguageClass {
    Regular,
    ContextFree,
    ContextSensitive,
    Recursive,
    RecursivelyEnumerable,
}

// æŠ½è±¡è¯­è¨€æ¥å£
trait Language {
    type Symbol;
    
    // åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦å±äºè¯¥è¯­è¨€
    fn contains(&self, input: &[Self::Symbol]) -> bool;
    
    // è·å–è¯­è¨€ç±»åˆ«
    fn language_class(&self) -> LanguageClass;
    
    // ç”Ÿæˆå±äºè¯¥è¯­è¨€çš„å­—ç¬¦ä¸²ï¼ˆæœ‰é™é›†åˆï¼‰
    fn generate_examples(&self, max_length: usize) -> HashSet<Vec<Self::Symbol>>;
}

// æ­£åˆ™è¯­è¨€å®ç°ï¼ˆé€šè¿‡æœ‰é™è‡ªåŠ¨æœºï¼‰
struct RegularLanguage<S> {
    states: HashSet<usize>,
    alphabet: HashSet<S>,
    transitions: Vec<Vec<HashSet<usize>>>,
    start_state: usize,
    accept_states: HashSet<usize>,
}

impl<S: Clone + Eq + Hash> Language for RegularLanguage<S> {
    type Symbol = S;
    
    fn contains(&self, input: &[S]) -> bool {
        let mut current_states = HashSet::new();
        current_states.insert(self.start_state);
        
        for symbol in input {
            let mut next_states = HashSet::new();
            for &state in &current_states {
                if let Some(symbol_index) = self.alphabet.iter().position(|s| s == symbol) {
                    for &next_state in &self.transitions[state][symbol_index] {
                        next_states.insert(next_state);
                    }
                }
            }
            current_states = next_states;
        }
        
        current_states.iter().any(|&state| self.accept_states.contains(&state))
    }
    
    fn language_class(&self) -> LanguageClass {
        LanguageClass::Regular
    }
    
    fn generate_examples(&self, max_length: usize) -> HashSet<Vec<S>> {
        let mut result = HashSet::new();
        let mut queue = VecDeque::new();
        queue.push_back((self.start_state, Vec::new()));
        
        while let Some((state, string)) = queue.pop_front() {
            if self.accept_states.contains(&state) {
                result.insert(string.clone());
            }
            
            if string.len() < max_length {
                for (i, symbol) in self.alphabet.iter().enumerate() {
                    for &next_state in &self.transitions[state][i] {
                        let mut new_string = string.clone();
                        new_string.push(symbol.clone());
                        queue.push_back((next_state, new_string));
                    }
                }
            }
        }
        
        result
    }
}

// ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€å®ç°ï¼ˆé€šè¿‡ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ï¼‰
struct ContextFreeLanguage<T, N> {
    terminals: HashSet<T>,
    non_terminals: HashSet<N>,
    productions: Vec<(N, Vec<Either<T, N>>)>,
    start_symbol: N,
}

enum Either<A, B> {
    Left(A),
    Right(B),
}

impl<T: Clone + Eq + Hash, N: Clone + Eq + Hash> Language for ContextFreeLanguage<T, N> {
    type Symbol = T;
    
    fn contains(&self, input: &[T]) -> bool {
        // ä½¿ç”¨CYKç®—æ³•åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦å±äºè¯¥è¯­è¨€
        // è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…ä¸Šéœ€è¦å…ˆå°†æ–‡æ³•è½¬æ¢ä¸ºä¹”å§†æ–¯åŸºèŒƒå¼
        unimplemented!("CYK algorithm implementation required")
    }
    
    fn language_class(&self) -> LanguageClass {
        LanguageClass::ContextFree
    }
    
    fn generate_examples(&self, max_length: usize) -> HashSet<Vec<T>> {
        let mut result = HashSet::new();
        // ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢ç”Ÿæˆå­—ç¬¦ä¸²
        // è¿™é‡Œç®€åŒ–å®ç°
        unimplemented!("BFS generation implementation required")
    }
}

// è¯­è¨€å±‚æ¬¡å…³ç³»æ£€æŸ¥
fn check_hierarchy_inclusion<S: Clone + Eq + Hash>(
    language: &dyn Language<Symbol = S>,
    examples: &[Vec<S>],
    counter_examples: &[Vec<S>]
) -> bool {
    // æ£€æŸ¥æ‰€æœ‰æ­£ä¾‹æ˜¯å¦éƒ½è¢«æ¥å—
    let all_examples_accepted = examples.iter()
        .all(|example| language.contains(example));
    
    // æ£€æŸ¥æ‰€æœ‰åä¾‹æ˜¯å¦éƒ½è¢«æ‹’ç»
    let all_counter_examples_rejected = counter_examples.iter()
        .all(|counter_example| !language.contains(counter_example));
    
    all_examples_accepted && all_counter_examples_rejected
}

// æ³µå¼•ç†æµ‹è¯•
fn test_pumping_lemma_regular<S: Clone + Eq + Hash>(
    language: &dyn Language<Symbol = S>,
    pumping_length: usize,
    test_string: &[S]
) -> bool {
    if test_string.len() < pumping_length {
        return true; // å­—ç¬¦ä¸²é•¿åº¦å°äºæ³µé•¿åº¦ï¼Œæ³µå¼•ç†ä¸é€‚ç”¨
    }
    
    // å°è¯•æ‰€æœ‰å¯èƒ½çš„åˆ†è§£ z = uvw
    for i in 0..=pumping_length {
        for j in 1..=pumping_length - i {
            let u = &test_string[0..i];
            let v = &test_string[i..i+j];
            let w = &test_string[i+j..];
            
            // æ£€æŸ¥æ˜¯å¦å­˜åœ¨æŸä¸ªiä½¿å¾—uv^iwä¸åœ¨è¯­è¨€ä¸­
            for pump_count in 0..=2 {
                let mut pumped_string = u.to_vec();
                for _ in 0..pump_count {
                    pumped_string.extend_from_slice(v);
                }
                pumped_string.extend_from_slice(w);
                
                if !language.contains(&pumped_string) {
                    return false; // æ‰¾åˆ°åä¾‹ï¼Œè¯­è¨€ä¸æ˜¯æ­£åˆ™çš„
                }
            }
        }
    }
    
    true // æœªæ‰¾åˆ°åä¾‹ï¼Œæ³µå¼•ç†æˆç«‹
}
```

### 5.2 è¯­è¨€å±‚æ¬¡çš„Leanå½¢å¼åŒ–

```lean
import data.set
import data.finset
import data.list
import computability.turing

open set

-- è¯­è¨€ç±»åˆ«
inductive language_class
| regular
| context_free
| context_sensitive
| recursive
| recursively_enumerable

-- å½¢å¼è¯­è¨€å®šä¹‰
def formal_language (Î± : Type) := set (list Î±)

-- æ­£åˆ™è¯­è¨€å®šä¹‰
structure finite_automaton (Î± : Type) :=
(states : finset nat)
(alphabet : finset Î±)
(transitions : list (list (finset nat)))
(start_state : nat)
(accept_states : finset nat)

-- åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦è¢«æœ‰é™è‡ªåŠ¨æœºæ¥å—
def accepts {Î± : Type} (fa : finite_automaton Î±) (input : list Î±) : Prop :=
âˆƒ (states : list nat),
  states.length = input.length + 1 âˆ§
  states.head = some fa.start_state âˆ§
  (âˆ€ (i : nat), i < input.length â†’ 
    âˆƒ (s t : nat) (a : Î±),
      states.nth i = some s âˆ§
      states.nth (i+1) = some t âˆ§
      input.nth i = some a âˆ§
      t âˆˆ fa.transitions.nth s >>= Î» row, row.nth (finset.index_of a fa.alphabet)) âˆ§
  states.last âˆˆ fa.accept_states

-- æ­£åˆ™è¯­è¨€
def regular_language {Î± : Type} (L : formal_language Î±) : Prop :=
âˆƒ (fa : finite_automaton Î±), âˆ€ w, w âˆˆ L â†” accepts fa w

-- ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€å®šä¹‰
structure context_free_grammar (Î± : Type) (Î² : Type) :=
(terminals : finset Î±)
(non_terminals : finset Î²)
(productions : list (Î² Ã— list (sum Î± Î²)))
(start_symbol : Î²)

-- æ¨å¯¼å…³ç³»
inductive derives {Î± : Type} {Î² : Type} (cfg : context_free_grammar Î± Î²) : 
  list (sum Î± Î²) â†’ list (sum Î± Î²) â†’ Prop
| base (u v w : list (sum Î± Î²)) (A : Î²) (Î³ : list (sum Î± Î²)) :
    (A, Î³) âˆˆ cfg.productions â†’ derives (u ++ [sum.inr A] ++ v) (u ++ Î³ ++ v)
| trans (u v w : list (sum Î± Î²)) : derives u v â†’ derives v w â†’ derives u w

-- ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€
def context_free_language {Î± : Type} (L : formal_language Î±) : Prop :=
âˆƒ (Î² : Type) (cfg : context_free_grammar Î± Î²), 
  âˆ€ w, w âˆˆ L â†” derives cfg [sum.inr cfg.start_symbol] (map sum.inl w)

-- è¯­è¨€å±‚æ¬¡åŒ…å«å…³ç³»
theorem regular_subset_context_free {Î± : Type} :
  {L : formal_language Î± | regular_language L} âŠ† {L | context_free_language L} :=
begin
  -- è¯æ˜ï¼šæ¯ä¸ªæ­£åˆ™è¯­è¨€éƒ½æ˜¯ä¸Šä¸‹æ–‡æ— å…³çš„
  sorry
end

theorem strict_inclusion {Î± : Type} :
  {L : formal_language Î± | regular_language L} âŠ‚ {L | context_free_language L} :=
begin
  -- è¯æ˜ï¼šå­˜åœ¨ä¸Šä¸‹æ–‡æ— å…³ä½†ä¸æ˜¯æ­£åˆ™çš„è¯­è¨€
  sorry
end

-- æ³µå¼•ç†
theorem pumping_lemma_regular {Î± : Type} (L : formal_language Î±) (h : regular_language L) :
  âˆƒ (p : nat), âˆ€ (w : list Î±), w âˆˆ L â†’ length w â‰¥ p â†’ 
    âˆƒ (x y z : list Î±), w = x ++ y ++ z âˆ§ length (x ++ y) â‰¤ p âˆ§ length y > 0 âˆ§
      âˆ€ (i : nat), x ++ (list.repeat y i).join ++ z âˆˆ L :=
begin
  -- è¯æ˜ï¼šæ­£åˆ™è¯­è¨€çš„æ³µå¼•ç†
  sorry
end
```

## 6. åº”ç”¨ç¤ºä¾‹

### 6.1 ç¼–è¯‘å™¨è®¾è®¡

**ç¤ºä¾‹ 6.1.1** (è¯æ³•åˆ†æä¸è¯­æ³•åˆ†æ)
ç¼–è¯‘å™¨çš„ä¸åŒé˜¶æ®µåˆ©ç”¨ä¸åŒè¯­è¨€ç±»åˆ«ï¼š

- è¯æ³•åˆ†æï¼šä½¿ç”¨æ­£åˆ™è¯­è¨€æè¿°è¯æ³•å•å…ƒ
- è¯­æ³•åˆ†æï¼šä½¿ç”¨ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€æè¿°ç¨‹åºè¯­æ³•
- è¯­ä¹‰åˆ†æï¼šéœ€è¦ä¸Šä¸‹æ–‡ç›¸å…³ä¿¡æ¯ï¼ˆå¦‚ç±»å‹æ£€æŸ¥ï¼‰

```text
// è¯æ³•åˆ†æï¼ˆæ­£åˆ™è¯­è¨€ï¼‰
<identifier> ::= [a-zA-Z_][a-zA-Z0-9_]*
<number> ::= [0-9]+(\.[0-9]+)?

// è¯­æ³•åˆ†æï¼ˆä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼‰
<expr> ::= <expr> "+" <term> | <term>
<term> ::= <term> "*" <factor> | <factor>
<factor> ::= "(" <expr> ")" | <identifier> | <number>

// è¯­ä¹‰åˆ†æï¼ˆä¸Šä¸‹æ–‡ç›¸å…³ï¼‰
// å˜é‡å¿…é¡»å…ˆå£°æ˜åä½¿ç”¨
// å‡½æ•°è°ƒç”¨å‚æ•°ç±»å‹å¿…é¡»åŒ¹é…å®šä¹‰
```

### 6.2 å½¢å¼éªŒè¯

**ç¤ºä¾‹ 6.2.1** (åè®®éªŒè¯)
ä¸åŒå¤æ‚åº¦çš„åè®®éœ€è¦ä¸åŒè¯­è¨€ç±»åˆ«æè¿°ï¼š

- ç®€å•çŠ¶æ€åè®®ï¼šæ­£åˆ™è¯­è¨€
- å¸¦æ ˆçš„åè®®ï¼šä¸Šä¸‹æ–‡æ— å…³è¯­è¨€
- å¤æ‚äº¤äº’åè®®ï¼šä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€

**ç¤ºä¾‹ 6.2.2** (æ¨¡å‹æ£€æµ‹)
æ¨¡å‹æ£€æµ‹ä½¿ç”¨æ—¶æ€é€»è¾‘æè¿°ç³»ç»Ÿæ€§è´¨ï¼Œä¸åŒå¤æ‚åº¦çš„æ€§è´¨å¯¹åº”ä¸åŒè¯­è¨€ç±»åˆ«ã€‚

### 6.3 è‡ªç„¶è¯­è¨€å¤„ç†

**ç¤ºä¾‹ 6.3.1** (è‡ªç„¶è¯­è¨€çš„å½¢å¼åŒ–)
è‡ªç„¶è¯­è¨€çš„ä¸åŒå±‚é¢å¯¹åº”ä¸åŒè¯­è¨€ç±»åˆ«ï¼š

- è¯æ³•ï¼šæ­£åˆ™è¯­è¨€ï¼ˆå•è¯å½¢æ€ï¼‰
- å¥æ³•ï¼šä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼ˆçŸ­è¯­ç»“æ„ï¼‰
- è¯­ä¹‰ï¼šä¸Šä¸‹æ–‡ç›¸å…³è¯­è¨€æˆ–æ›´é«˜ï¼ˆè¯­ä¹‰ä¾èµ–ï¼‰

## 7. å‚è€ƒæ–‡çŒ®

1. Chomsky, N. (1956). Three models for the description of language. IRE Transactions on Information Theory, 2(3), 113-124.
2. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to automata theory, languages, and computation. Pearson Education.
3. Sipser, M. (2012). Introduction to the theory of computation. Cengage Learning.
4. Bar-Hillel, Y., Perles, M., & Shamir, E. (1961). On formal properties of simple phrase structure grammars. Zeitschrift fÃ¼r Phonetik, Sprachwissenschaft und Kommunikationsforschung, 14, 143-172.
5. Kuroda, S. Y. (1964). Classes of languages and linear-bounded automata. Information and Control, 7(2), 207-223.
