# 03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•

## ğŸ“‹ æ¦‚è¿°

ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ï¼ˆContext-Free Grammar, CFGï¼‰æ˜¯å½¢å¼è¯­è¨€ç†è®ºä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå®ƒå®šä¹‰äº†ä¹”å§†æ–¯åŸºè°±ç³»ä¸­çš„2å‹è¯­è¨€ã€‚CFGåœ¨ç¼–è¯‘å™¨è®¾è®¡ã€è‡ªç„¶è¯­è¨€å¤„ç†ã€åè®®è®¾è®¡ç­‰é¢†åŸŸæœ‰å¹¿æ³›åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•çš„ä¸¥æ ¼å½¢å¼åŒ–å®šä¹‰
2. ç ”ç©¶CFGçš„åŸºæœ¬æ€§è´¨å’Œç»“æ„
3. æ¢è®¨CFGçš„è§£æç®—æ³•
4. åˆ†æCFGçš„ç­‰ä»·å˜æ¢
5. æä¾›å®Œæ•´çš„ä»£ç å®ç°

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [è§£æç®—æ³•](#4-è§£æç®—æ³•)
5. [ä»£ç å®ç°](#5-ä»£ç å®ç°)
6. [åº”ç”¨ç¤ºä¾‹](#6-åº”ç”¨ç¤ºä¾‹)
7. [ç›¸å…³ç†è®º](#7-ç›¸å…³ç†è®º)
8. [å‚è€ƒæ–‡çŒ®](#8-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•çš„ç›´è§‚ç†è§£

ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•æ˜¯ä¸€ç§å½¢å¼æ–‡æ³•ï¼Œå…¶ä¸­æ¯ä¸ªäº§ç”Ÿå¼è§„åˆ™çš„å½¢å¼ä¸º $A \to \alpha$ï¼Œå…¶ä¸­ $A$ æ˜¯éç»ˆç»“ç¬¦ï¼Œ$\alpha$ æ˜¯ç»ˆç»“ç¬¦å’Œéç»ˆç»“ç¬¦çš„ä¸²ã€‚CFGçš„ç‰¹ç‚¹æ˜¯æ›¿æ¢éç»ˆç»“ç¬¦æ—¶ä¸ä¾èµ–äºå…¶ä¸Šä¸‹æ–‡ã€‚

**ç»å…¸ä¾‹å­**ï¼š
- ç®—æœ¯è¡¨è¾¾å¼æ–‡æ³•
- ç¼–ç¨‹è¯­è¨€è¯­æ³•
- è‡ªç„¶è¯­è¨€å¥æ³•ç»“æ„

### 1.2 CFGçš„åŸºæœ¬ç»„æˆ

1. **éç»ˆç»“ç¬¦é›†åˆ**ï¼šè¡¨ç¤ºè¯­æ³•èŒƒç•´
2. **ç»ˆç»“ç¬¦é›†åˆ**ï¼šè¡¨ç¤ºè¯­è¨€çš„åŸºæœ¬ç¬¦å·
3. **äº§ç”Ÿå¼è§„åˆ™**ï¼šå®šä¹‰è¯­æ³•ç»“æ„
4. **å¼€å§‹ç¬¦å·**ï¼šæ–‡æ³•çš„èµ·å§‹ç‚¹

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•çš„å®šä¹‰

**å®šä¹‰ 2.1.1** (ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•)
ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•æ˜¯ä¸€ä¸ªå››å…ƒç»„ $G = (V, \Sigma, P, S)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯éç»ˆç»“ç¬¦é›†åˆï¼ˆæœ‰é™é›†ï¼‰
- $\Sigma$ æ˜¯ç»ˆç»“ç¬¦é›†åˆï¼ˆæœ‰é™é›†ï¼‰ï¼Œä¸” $V \cap \Sigma = \emptyset$
- $P$ æ˜¯äº§ç”Ÿå¼é›†åˆï¼Œæ¯ä¸ªäº§ç”Ÿå¼å½¢å¦‚ $A \to \alpha$ï¼Œå…¶ä¸­ $A \in V$ï¼Œ$\alpha \in (V \cup \Sigma)^*$
- $S \in V$ æ˜¯å¼€å§‹ç¬¦å·

### 2.2 æ¨å¯¼çš„å®šä¹‰

**å®šä¹‰ 2.1.2** (ç›´æ¥æ¨å¯¼)
è®¾ $G = (V, \Sigma, P, S)$ æ˜¯CFGï¼Œå¯¹äº $\alpha, \beta \in (V \cup \Sigma)^*$ï¼Œå¦‚æœå­˜åœ¨äº§ç”Ÿå¼ $A \to \gamma \in P$ï¼Œä½¿å¾— $\alpha = \alpha_1 A \alpha_2$ ä¸” $\beta = \alpha_1 \gamma \alpha_2$ï¼Œåˆ™ç§° $\alpha$ ç›´æ¥æ¨å¯¼å‡º $\beta$ï¼Œè®°ä½œ $\alpha \Rightarrow \beta$ã€‚

**å®šä¹‰ 2.1.3** (æ¨å¯¼)
æ¨å¯¼å…³ç³» $\Rightarrow^*$ æ˜¯ $\Rightarrow$ çš„è‡ªåä¼ é€’é—­åŒ…ï¼Œå³ï¼š
- $\alpha \Rightarrow^* \alpha$ï¼ˆè‡ªåæ€§ï¼‰
- å¦‚æœ $\alpha \Rightarrow \beta$ ä¸” $\beta \Rightarrow^* \gamma$ï¼Œåˆ™ $\alpha \Rightarrow^* \gamma$ï¼ˆä¼ é€’æ€§ï¼‰

### 2.3 è¯­è¨€çš„å®šä¹‰

**å®šä¹‰ 2.1.4** (CFGç”Ÿæˆçš„è¯­è¨€)
CFG $G = (V, \Sigma, P, S)$ ç”Ÿæˆçš„è¯­è¨€å®šä¹‰ä¸ºï¼š
$$L(G) = \{w \in \Sigma^* \mid S \Rightarrow^* w\}$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 CFGçš„åŸºæœ¬æ€§è´¨

**å®šç† 3.1.1** (CFGçš„å•è°ƒæ€§)
è®¾ $G$ æ˜¯CFGï¼Œå¦‚æœ $S \Rightarrow^* \alpha$ï¼Œåˆ™ $|\alpha| \geq 1$ æˆ– $\alpha = \varepsilon$ã€‚

**è¯æ˜**ï¼š
å¯¹æ¨å¯¼æ­¥æ•°è¿›è¡Œå½’çº³ï¼š
- åŸºç¡€æƒ…å†µï¼š$S \Rightarrow S$ï¼Œ$|S| = 1$
- å½’çº³æ­¥éª¤ï¼šå‡è®¾ $S \Rightarrow^* \alpha$ ä¸” $|\alpha| \geq 1$ï¼Œå¦‚æœ $\alpha \Rightarrow \beta$ï¼Œåˆ™ $|\beta| \geq |\alpha| - 1 \geq 0$

**å®šç† 3.1.2** (CFGçš„ä¸Šä¸‹æ–‡æ— å…³æ€§)
CFGçš„æ›¿æ¢æ“ä½œä¸ä¾èµ–äºä¸Šä¸‹æ–‡ï¼Œå³å¦‚æœ $A \to \alpha$ æ˜¯äº§ç”Ÿå¼ï¼Œåˆ™å¯ä»¥åœ¨ä»»ä½•åŒ…å« $A$ çš„ä¸²ä¸­åº”ç”¨æ­¤äº§ç”Ÿå¼ã€‚

### 3.2 CFGçš„ç­‰ä»·æ€§

**å®šä¹‰ 3.2.1** (CFGç­‰ä»·)
ä¸¤ä¸ªCFG $G_1$ å’Œ $G_2$ ç§°ä¸ºç­‰ä»·çš„ï¼Œå¦‚æœ $L(G_1) = L(G_2)$ã€‚

**å®šç† 3.2.1** (CFGçš„ç­‰ä»·å˜æ¢)
ä»»ä½•CFGéƒ½å¯ä»¥è½¬æ¢ä¸ºç­‰ä»·çš„ä¹”å§†æ–¯åŸºèŒƒå¼ï¼ˆCNFï¼‰æˆ–æ ¼é›·å·´èµ«èŒƒå¼ï¼ˆGNFï¼‰ã€‚

### 3.3 ä¹”å§†æ–¯åŸºèŒƒå¼

**å®šä¹‰ 3.3.1** (ä¹”å§†æ–¯åŸºèŒƒå¼)
CFG $G$ ç§°ä¸ºä¹”å§†æ–¯åŸºèŒƒå¼ï¼Œå¦‚æœæ‰€æœ‰äº§ç”Ÿå¼éƒ½æ˜¯ä»¥ä¸‹å½¢å¼ä¹‹ä¸€ï¼š
1. $A \to BC$ï¼Œå…¶ä¸­ $A, B, C \in V$
2. $A \to a$ï¼Œå…¶ä¸­ $A \in V$ï¼Œ$a \in \Sigma$
3. $S \to \varepsilon$ï¼ˆä»…å½“ $\varepsilon \in L(G)$ æ—¶ï¼‰

**å®šç† 3.3.1** (CNFè½¬æ¢å®šç†)
ä»»ä½•CFGéƒ½å¯ä»¥è½¬æ¢ä¸ºç­‰ä»·çš„CNFã€‚

**è¯æ˜**ï¼š
1. æ¶ˆé™¤ $\varepsilon$ äº§ç”Ÿå¼ï¼ˆé™¤äº† $S \to \varepsilon$ï¼‰
2. æ¶ˆé™¤å•ä½äº§ç”Ÿå¼ï¼ˆ$A \to B$ï¼‰
3. å°†é•¿äº§ç”Ÿå¼åˆ†è§£ä¸ºäºŒå…ƒäº§ç”Ÿå¼
4. å°†ç»ˆç»“ç¬¦æ›¿æ¢ä¸ºéç»ˆç»“ç¬¦

## 4. è§£æç®—æ³•

### 4.1 CYKç®—æ³•

**ç®—æ³• 4.1.1** (CYKç®—æ³•)
CYKç®—æ³•æ˜¯ç”¨äºåˆ¤æ–­ä¸²æ˜¯å¦å±äºCFGç”Ÿæˆè¯­è¨€çš„åŠ¨æ€è§„åˆ’ç®—æ³•ã€‚

**è¾“å…¥**ï¼šCFG $G$ï¼ˆCNFå½¢å¼ï¼‰å’Œä¸² $w = a_1 a_2 ... a_n$
**è¾“å‡º**ï¼š$w \in L(G)$ çš„çœŸå‡å€¼

**ç®—æ³•æ­¥éª¤**ï¼š
1. åˆå§‹åŒ–ï¼š$V[i,i] = \{A \mid A \to a_i \in P\}$
2. é€’æ¨ï¼š$V[i,j] = \{A \mid A \to BC \in P, B \in V[i,k], C \in V[k+1,j]\}$
3. åˆ¤æ–­ï¼š$S \in V[1,n]$

### 4.2 é€’å½’ä¸‹é™è§£æ

**ç®—æ³• 4.1.2** (é€’å½’ä¸‹é™è§£æ)
é€’å½’ä¸‹é™è§£ææ˜¯è‡ªé¡¶å‘ä¸‹çš„è§£ææ–¹æ³•ï¼Œé€‚ç”¨äºLL(1)æ–‡æ³•ã€‚

**åŸºæœ¬æ€æƒ³**ï¼š
- ä¸ºæ¯ä¸ªéç»ˆç»“ç¬¦ç¼–å†™ä¸€ä¸ªè§£æå‡½æ•°
- æ ¹æ®å½“å‰è¾“å…¥ç¬¦å·é€‰æ‹©äº§ç”Ÿå¼
- é€’å½’è°ƒç”¨ç›¸åº”çš„è§£æå‡½æ•°

## 5. ä»£ç å®ç°

### 5.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::fmt;

/// ç¬¦å·ç±»å‹
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Symbol {
    Terminal(String),
    NonTerminal(String),
}

impl Symbol {
    pub fn is_terminal(&self) -> bool {
        matches!(self, Symbol::Terminal(_))
    }
    
    pub fn is_non_terminal(&self) -> bool {
        matches!(self, Symbol::NonTerminal(_))
    }
    
    pub fn to_string(&self) -> String {
        match self {
            Symbol::Terminal(s) => s.clone(),
            Symbol::NonTerminal(s) => s.clone(),
        }
    }
}

/// äº§ç”Ÿå¼
#[derive(Debug, Clone)]
pub struct Production {
    pub left: Symbol,
    pub right: Vec<Symbol>,
}

impl Production {
    pub fn new(left: Symbol, right: Vec<Symbol>) -> Self {
        Self { left, right }
    }
    
    pub fn is_cnf(&self) -> bool {
        match &self.right.len() {
            1 => {
                if let Symbol::Terminal(_) = &self.right[0] {
                    true
                } else {
                    false
                }
            }
            2 => {
                if let (Symbol::NonTerminal(_), Symbol::NonTerminal(_)) = 
                    (&self.right[0], &self.right[1]) {
                    true
                } else {
                    false
                }
            }
            _ => false
        }
    }
}

/// ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•
#[derive(Debug)]
pub struct ContextFreeGrammar {
    pub non_terminals: HashSet<Symbol>,
    pub terminals: HashSet<Symbol>,
    pub productions: Vec<Production>,
    pub start_symbol: Symbol,
}

impl ContextFreeGrammar {
    pub fn new(start_symbol: Symbol) -> Self {
        let mut non_terminals = HashSet::new();
        non_terminals.insert(start_symbol.clone());
        
        Self {
            non_terminals,
            terminals: HashSet::new(),
            productions: Vec::new(),
            start_symbol,
        }
    }
    
    pub fn add_production(&mut self, production: Production) {
        // æ·»åŠ éç»ˆç»“ç¬¦
        self.non_terminals.insert(production.left.clone());
        
        // æ·»åŠ ç»ˆç»“ç¬¦å’Œéç»ˆç»“ç¬¦
        for symbol in &production.right {
            match symbol {
                Symbol::Terminal(_) => {
                    self.terminals.insert(symbol.clone());
                }
                Symbol::NonTerminal(_) => {
                    self.non_terminals.insert(symbol.clone());
                }
            }
        }
        
        self.productions.push(production);
    }
    
    /// æ£€æŸ¥æ–‡æ³•æ˜¯å¦ä¸ºCNF
    pub fn is_cnf(&self) -> bool {
        self.productions.iter().all(|p| p.is_cnf())
    }
    
    /// è½¬æ¢ä¸ºCNF
    pub fn to_cnf(&self) -> ContextFreeGrammar {
        let mut cnf = ContextFreeGrammar::new(self.start_symbol.clone());
        
        // ç®€åŒ–å®ç°ï¼šå‡è®¾æ–‡æ³•å·²ç»æ˜¯CNFå½¢å¼
        for production in &self.productions {
            cnf.add_production(production.clone());
        }
        
        cnf
    }
    
    /// CYKç®—æ³•å®ç°
    pub fn cyk_parse(&self, input: &str) -> bool {
        if !self.is_cnf() {
            panic!("CYKç®—æ³•è¦æ±‚æ–‡æ³•ä¸ºCNFå½¢å¼");
        }
        
        let tokens: Vec<char> = input.chars().collect();
        let n = tokens.len();
        
        if n == 0 {
            return self.has_epsilon_production();
        }
        
        // åˆå§‹åŒ–Vè¡¨
        let mut v = vec![vec![HashSet::new(); n]; n];
        
        // å¡«å……å¯¹è§’çº¿
        for i in 0..n {
            for production in &self.productions {
                if production.right.len() == 1 {
                    if let Symbol::Terminal(term) = &production.right[0] {
                        if term == &tokens[i].to_string() {
                            v[i][i].insert(production.left.clone());
                        }
                    }
                }
            }
        }
        
        // å¡«å……å…¶ä½™éƒ¨åˆ†
        for len in 2..=n {
            for i in 0..=n-len {
                let j = i + len - 1;
                for k in i..j {
                    for production in &self.productions {
                        if production.right.len() == 2 {
                            if let (Symbol::NonTerminal(b), Symbol::NonTerminal(c)) = 
                                (&production.right[0], &production.right[1]) {
                                if v[i][k].contains(b) && v[k+1][j].contains(c) {
                                    v[i][j].insert(production.left.clone());
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // æ£€æŸ¥å¼€å§‹ç¬¦å·æ˜¯å¦åœ¨V[0][n-1]ä¸­
        v[0][n-1].contains(&self.start_symbol)
    }
    
    fn has_epsilon_production(&self) -> bool {
        self.productions.iter().any(|p| p.right.is_empty())
    }
}

/// é€’å½’ä¸‹é™è§£æå™¨
pub struct RecursiveDescentParser {
    grammar: ContextFreeGrammar,
    input: Vec<char>,
    position: usize,
}

impl RecursiveDescentParser {
    pub fn new(grammar: ContextFreeGrammar) -> Self {
        Self {
            grammar,
            input: Vec::new(),
            position: 0,
        }
    }
    
    pub fn parse(&mut self, input: &str) -> bool {
        self.input = input.chars().collect();
        self.position = 0;
        self.parse_non_terminal(&self.grammar.start_symbol)
    }
    
    fn parse_non_terminal(&mut self, non_terminal: &Symbol) -> bool {
        // ç®€åŒ–å®ç°ï¼šå°è¯•æ‰€æœ‰äº§ç”Ÿå¼
        for production in &self.grammar.productions {
            if &production.left == non_terminal {
                let start_pos = self.position;
                if self.parse_sequence(&production.right) {
                    return true;
                }
                self.position = start_pos; // å›æº¯
            }
        }
        false
    }
    
    fn parse_sequence(&mut self, symbols: &[Symbol]) -> bool {
        for symbol in symbols {
            match symbol {
                Symbol::Terminal(term) => {
                    if self.position < self.input.len() && 
                       self.input[self.position].to_string() == *term {
                        self.position += 1;
                    } else {
                        return false;
                    }
                }
                Symbol::NonTerminal(non_term) => {
                    if !self.parse_non_terminal(non_term) {
                        return false;
                    }
                }
            }
        }
        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_simple_cfg() {
        let mut grammar = ContextFreeGrammar::new(
            Symbol::NonTerminal("S".to_string())
        );
        
        // S -> aSb | ab
        grammar.add_production(Production::new(
            Symbol::NonTerminal("S".to_string()),
            vec![
                Symbol::Terminal("a".to_string()),
                Symbol::NonTerminal("S".to_string()),
                Symbol::Terminal("b".to_string())
            ]
        ));
        
        grammar.add_production(Production::new(
            Symbol::NonTerminal("S".to_string()),
            vec![
                Symbol::Terminal("a".to_string()),
                Symbol::Terminal("b".to_string())
            ]
        ));
        
        assert!(!grammar.is_cnf());
    }
    
    #[test]
    fn test_cnf_grammar() {
        let mut grammar = ContextFreeGrammar::new(
            Symbol::NonTerminal("S".to_string())
        );
        
        // S -> AB | a
        // A -> a
        // B -> b
        grammar.add_production(Production::new(
            Symbol::NonTerminal("S".to_string()),
            vec![
                Symbol::NonTerminal("A".to_string()),
                Symbol::NonTerminal("B".to_string())
            ]
        ));
        
        grammar.add_production(Production::new(
            Symbol::NonTerminal("S".to_string()),
            vec![Symbol::Terminal("a".to_string())]
        ));
        
        grammar.add_production(Production::new(
            Symbol::NonTerminal("A".to_string()),
            vec![Symbol::Terminal("a".to_string())]
        ));
        
        grammar.add_production(Production::new(
            Symbol::NonTerminal("B".to_string()),
            vec![Symbol::Terminal("b".to_string())]
        ));
        
        assert!(grammar.is_cnf());
        assert!(grammar.cyk_parse("ab"));
        assert!(grammar.cyk_parse("a"));
    }
}
```

### 5.2 Haskell å®ç°

```haskell
module ContextFreeGrammar where

import Data.Set (Set)
import qualified Data.Set as Set
import Data.Map (Map)
import qualified Data.Map as Map
import Data.List (nub)

-- ç¬¦å·ç±»å‹
data Symbol = Terminal String | NonTerminal String
    deriving (Eq, Ord, Show)

-- äº§ç”Ÿå¼
data Production = Production {
    left :: Symbol,
    right :: [Symbol]
} deriving (Eq, Show)

-- ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•
data ContextFreeGrammar = ContextFreeGrammar {
    nonTerminals :: Set Symbol,
    terminals :: Set Symbol,
    productions :: [Production],
    startSymbol :: Symbol
} deriving (Eq, Show)

-- åˆ›å»ºç©ºæ–‡æ³•
emptyGrammar :: Symbol -> ContextFreeGrammar
emptyGrammar start = ContextFreeGrammar {
    nonTerminals = Set.singleton start,
    terminals = Set.empty,
    productions = [],
    startSymbol = start
}

-- æ·»åŠ äº§ç”Ÿå¼
addProduction :: Production -> ContextFreeGrammar -> ContextFreeGrammar
addProduction prod grammar = grammar {
    nonTerminals = Set.insert (left prod) $ 
                   foldr (\s acc -> case s of
                       NonTerminal _ -> Set.insert s acc
                       _ -> acc) (nonTerminals grammar) (right prod),
    terminals = foldr (\s acc -> case s of
        Terminal _ -> Set.insert s acc
        _ -> acc) (terminals grammar) (right prod),
    productions = prod : productions grammar
}

-- æ£€æŸ¥æ˜¯å¦ä¸ºCNF
isCNF :: ContextFreeGrammar -> Bool
isCNF grammar = all isCNFProduction (productions grammar)
  where
    isCNFProduction prod = case right prod of
        [Terminal _] -> True
        [NonTerminal _, NonTerminal _] -> True
        _ -> False

-- CYKç®—æ³•
cykParse :: ContextFreeGrammar -> String -> Bool
cykParse grammar input = 
    if not (isCNF grammar)
    then error "CYKç®—æ³•è¦æ±‚æ–‡æ³•ä¸ºCNFå½¢å¼"
    else cykParse' grammar input

cykParse' :: ContextFreeGrammar -> String -> Bool
cykParse' grammar input = 
    let tokens = input
        n = length tokens
        v = buildVTable grammar tokens
    in Set.member (startSymbol grammar) (v !! 0 !! (n-1))

-- æ„å»ºVè¡¨
buildVTable :: ContextFreeGrammar -> String -> [[Set Symbol]]
buildVTable grammar tokens = 
    let n = length tokens
        v = replicate n (replicate n Set.empty)
        v1 = fillDiagonal grammar tokens v
    in fillTable grammar v1

-- å¡«å……å¯¹è§’çº¿
fillDiagonal :: ContextFreeGrammar -> String -> [[Set Symbol]] -> [[Set Symbol]]
fillDiagonal grammar tokens v = 
    foldr (\(i, token) acc -> 
        let symbols = [left prod | prod <- productions grammar,
                                  right prod == [Terminal [token]]]
            newV = updateV acc i i (Set.fromList symbols)
        in newV) v (zip [0..] tokens)

-- å¡«å……å…¶ä½™éƒ¨åˆ†
fillTable :: ContextFreeGrammar -> [[Set Symbol]] -> [[Set Symbol]]
fillTable grammar v = 
    let n = length v
        ranges = [(len, i) | len <- [2..n], i <- [0..n-len]]
    in foldr (\(len, i) acc -> 
        let j = i + len - 1
            symbols = generateSymbols grammar acc i j
            newV = updateV acc i j symbols
        in newV) v ranges

-- ç”Ÿæˆç¬¦å·
generateSymbols :: ContextFreeGrammar -> [[Set Symbol]] -> Int -> Int -> Set Symbol
generateSymbols grammar v i j = 
    let kRange = [i..j-1]
        symbols = concat [generateSymbolsForK grammar v i j k | k <- kRange]
    in Set.fromList symbols

-- ä¸ºç‰¹å®škç”Ÿæˆç¬¦å·
generateSymbolsForK :: ContextFreeGrammar -> [[Set Symbol]] -> Int -> Int -> Int -> [Symbol]
generateSymbolsForK grammar v i j k = 
    [left prod | prod <- productions grammar,
                right prod == [NonTerminal "B", NonTerminal "C"],
                let b = NonTerminal "B"
                    c = NonTerminal "C"
                in Set.member b (v !! i !! k) && Set.member c (v !! (k+1) !! j)]

-- æ›´æ–°Vè¡¨
updateV :: [[Set Symbol]] -> Int -> Int -> Set Symbol -> [[Set Symbol]]
updateV v i j symbols = 
    let row = v !! i
        newRow = take j row ++ [symbols] ++ drop (j+1) row
    in take i v ++ [newRow] ++ drop (i+1) v

-- é€’å½’ä¸‹é™è§£æå™¨
data RecursiveDescentParser = RecursiveDescentParser {
    grammar :: ContextFreeGrammar,
    input :: String,
    position :: Int
}

-- åˆ›å»ºè§£æå™¨
createParser :: ContextFreeGrammar -> RecursiveDescentParser
createParser g = RecursiveDescentParser g "" 0

-- è§£æè¾“å…¥
parse :: RecursiveDescentParser -> String -> Bool
parse parser input = 
    let newParser = parser { input = input, position = 0 }
    in parseNonTerminal newParser (startSymbol (grammar parser))

-- è§£æéç»ˆç»“ç¬¦
parseNonTerminal :: RecursiveDescentParser -> Symbol -> Bool
parseNonTerminal parser nonTerminal = 
    let relevantProductions = [p | p <- productions (grammar parser), 
                                  left p == nonTerminal]
    in any (\prod -> parseSequence parser (right prod)) relevantProductions

-- è§£æç¬¦å·åºåˆ—
parseSequence :: RecursiveDescentParser -> [Symbol] -> Bool
parseSequence parser [] = True
parseSequence parser (s:ss) = 
    case s of
        Terminal t -> 
            if position parser < length (input parser) && 
               [input parser !! position parser] == t
            then parseSequence (parser { position = position parser + 1 }) ss
            else False
        NonTerminal nt -> 
            let startPos = position parser
                success = parseNonTerminal parser s
            in if success 
               then parseSequence parser ss
               else False

-- ç¤ºä¾‹æ–‡æ³•
exampleGrammar :: ContextFreeGrammar
exampleGrammar = 
    let g = emptyGrammar (NonTerminal "S")
        g1 = addProduction (Production (NonTerminal "S") 
                                    [NonTerminal "A", NonTerminal "B"]) g
        g2 = addProduction (Production (NonTerminal "S") 
                                    [Terminal "a"]) g1
        g3 = addProduction (Production (NonTerminal "A") 
                                    [Terminal "a"]) g2
        g4 = addProduction (Production (NonTerminal "B") 
                                    [Terminal "b"]) g3
    in g4

-- æµ‹è¯•å‡½æ•°
testCYK :: Bool
testCYK = cykParse exampleGrammar "ab"

testRecursiveDescent :: Bool
testRecursiveDescent = parse (createParser exampleGrammar) "ab"
```

## 6. åº”ç”¨ç¤ºä¾‹

### 6.1 ç®—æœ¯è¡¨è¾¾å¼æ–‡æ³•

**ç¤ºä¾‹ 6.1.1** (ç®—æœ¯è¡¨è¾¾å¼CFG)
```
E -> E + T | T
T -> T * F | F
F -> (E) | id
```

è¿™ä¸ªCFGå®šä¹‰äº†ç®€å•çš„ç®—æœ¯è¡¨è¾¾å¼ï¼Œæ”¯æŒåŠ æ³•ã€ä¹˜æ³•å’Œæ‹¬å·ã€‚

### 6.2 å¹³è¡¡æ‹¬å·æ–‡æ³•

**ç¤ºä¾‹ 6.1.2** (å¹³è¡¡æ‹¬å·CFG)
```
S -> (S) | SS | Îµ
```

è¿™ä¸ªCFGç”Ÿæˆæ‰€æœ‰å¹³è¡¡çš„æ‹¬å·ä¸²ã€‚

### 6.3 å›æ–‡æ–‡æ³•

**ç¤ºä¾‹ 6.1.3** (å›æ–‡CFG)
```
S -> aSa | bSb | a | b | Îµ
```

è¿™ä¸ªCFGç”Ÿæˆæ‰€æœ‰å›æ–‡ä¸²ã€‚

## 7. ç›¸å…³ç†è®º

### 7.1 ä¸è‡ªåŠ¨æœºçš„å…³ç³»

CFGä¸ä¸‹æ¨è‡ªåŠ¨æœºï¼ˆPDAï¼‰ç­‰ä»·ï¼Œè¿™æ˜¯ä¹”å§†æ–¯åŸºè°±ç³»çš„é‡è¦ç»“æœã€‚

### 7.2 ä¸è§£æçš„å…³ç³»

CFGæ˜¯å„ç§è§£æç®—æ³•çš„åŸºç¡€ï¼ŒåŒ…æ‹¬LLã€LRã€é€’å½’ä¸‹é™ç­‰ã€‚

### 7.3 ä¸è¯­è¨€å±‚æ¬¡çš„å…³ç³»

CFGå®šä¹‰çš„è¯­è¨€æ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­è¨€ï¼Œæ˜¯ä¹”å§†æ–¯åŸºè°±ç³»ä¸­çš„2å‹è¯­è¨€ã€‚

## 8. å‚è€ƒæ–‡çŒ®

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation*. Pearson.
2. Sipser, M. (2012). *Introduction to the Theory of Computation*. Cengage Learning.
3. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). *Compilers: Principles, Techniques, and Tools*. Pearson.
4. Grune, D., & Jacobs, C. J. (2008). *Parsing Techniques: A Practical Guide*. Springer.
5. Chomsky, N. (1956). Three models for the description of language. *IRE Transactions on Information Theory*, 2(3), 113-124.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [03.1.2 ä¸‹æ¨è‡ªåŠ¨æœº](../03_Formal_Language_Theory/03.1.2_ä¸‹æ¨è‡ªåŠ¨æœº.md)
- [03.2.1 æ­£åˆ™æ–‡æ³•](../03_Formal_Language_Theory/03.2.1_æ­£åˆ™æ–‡æ³•.md)
- [03.2.3 ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•](../03_Formal_Language_Theory/03.2.3_ä¸Šä¸‹æ–‡æœ‰å…³æ–‡æ³•.md)
- [03.3.1 ä¹”å§†æ–¯åŸºè°±ç³»](../03_Formal_Language_Theory/03.3.1_ä¹”å§†æ–¯åŸºè°±ç³».md)
- [03.4.1 LLè§£æ](../03_Formal_Language_Theory/03.4.1_LLè§£æ.md) 