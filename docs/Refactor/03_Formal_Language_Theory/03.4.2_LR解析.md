# 03.4.2 LR解析

## 📋 概述

LR解析是一种自底向上的语法分析方法，能够处理比LL解析更广泛的上下文无关文法。LR解析器使用状态机来跟踪解析过程，通过移进-归约操作构建语法分析树。

## 🎯 核心目标

1. 理解LR解析的基本原理和算法
2. 掌握LR(k)文法的定义和性质
3. 学会构建LR解析表和状态机
4. 理解不同LR变体的特点和适用场景
5. 掌握LR解析的错误处理和优化技术

## 📚 目录

1. [基本概念](#1-基本概念)
2. [形式化定义](#2-形式化定义)
3. [定理与证明](#3-定理与证明)
4. [代码实现](#4-代码实现)
5. [应用示例](#5-应用示例)
6. [相关理论](#6-相关理论)
7. [参考文献](#7-参考文献)

## 1. 基本概念

### 1.1 LR解析的定义

**定义 1.1** (LR解析)
LR解析是一种**自底向上**的语法分析方法，其中：

- L表示**从左到右**扫描输入
- R表示**最右推导**的逆过程

**定义 1.2** (LR(k)文法)
一个上下文无关文法 $G$ 是**LR(k)文法**，如果对于任意两个不同的最右推导：
$$S \Rightarrow^* \alpha A w \Rightarrow \alpha \beta w$$
$$S \Rightarrow^* \gamma B x \Rightarrow \gamma \delta x$$

其中 $w, x \in \Sigma^*$，$|w| = |x| = k$，都有：
$$\text{FOLLOW}_k(A) \cap \text{FOLLOW}_k(B) = \emptyset$$

### 1.2 基本概念

**定义 1.3** (项目)
一个**项目**（Item）是一个产生式加上一个位置标记，表示解析的进度。形式为：
$$A \to \alpha \cdot \beta$$
其中 $\cdot$ 表示当前解析位置。

**定义 1.4** (规范项目集)
一个**规范项目集**（Canonical Item Set）是LR解析器的一个状态，包含所有在某个配置下可能有效的项目。

**定义 1.5** (移进-归约冲突)
当解析器状态中同时存在移进项目和归约项目时，称为**移进-归约冲突**。

**定义 1.6** (归约-归约冲突)
当解析器状态中存在多个归约项目时，称为**归约-归约冲突**。

### 1.3 LR解析的变体

**定义 1.7** (SLR(1))
**SLR(1)**（Simple LR(1)）使用FOLLOW集合来解决冲突。

**定义 1.8** (LALR(1))
**LALR(1)**（Look-Ahead LR(1)）通过合并相似状态来减少状态数量。

**定义 1.9** (LR(1))
**LR(1)**使用精确的向前看信息来构建解析表。

## 2. 形式化定义

### 2.1 LR解析的形式化模型

**定义 2.1** (LR解析器配置)
LR解析器的配置是一个三元组 $(S, w, \alpha)$，其中：

- $S$ 是状态栈
- $w$ 是剩余的输入串
- $\alpha$ 是符号栈

**定义 2.2** (LR解析的转移关系)
LR解析的转移关系 $\vdash$ 定义为：

1. **移进**：$(S, aw, \alpha) \vdash (S \cdot s, w, \alpha a)$ 如果 $\text{ACTION}[s, a] = \text{shift } s'$
2. **归约**：$(S \cdot s, w, \alpha \beta) \vdash (S', w, \alpha A)$ 如果 $\text{ACTION}[s, a] = \text{reduce } A \to \beta$
3. **接受**：$(s_0, \varepsilon, S)$ 是接受状态

### 2.2 项目集闭包

**定义 2.3** (项目集闭包)
项目集 $I$ 的**闭包** $\text{CLOSURE}(I)$ 定义为：
$$\text{CLOSURE}(I) = I \cup \{B \to \cdot \gamma : A \to \alpha \cdot B\beta \in \text{CLOSURE}(I), B \to \gamma \in P\}$$

**定义 2.4** (GOTO函数)
对于项目集 $I$ 和符号 $X$，**GOTO函数**定义为：
$$\text{GOTO}(I, X) = \text{CLOSURE}(\{A \to \alpha X \cdot \beta : A \to \alpha \cdot X\beta \in I\})$$

### 2.3 LR解析表的构造

**定义 2.5** (ACTION表)
**ACTION表** $[\text{state}, \text{terminal}]$ 定义为：
$$\text{ACTION}[i, a] = \begin{cases}
\text{shift } j & \text{if } \text{GOTO}(I_i, a) = I_j \\
\text{reduce } A \to \beta & \text{if } A \to \beta \cdot \in I_i \text{ and } a \in \text{FOLLOW}(A) \\
\text{accept} & \text{if } S' \to S \cdot \in I_i \text{ and } a = \$ \\
\text{error} & \text{otherwise}
\end{cases}$$

**定义 2.6** (GOTO表)
**GOTO表** $[\text{state}, \text{nonterminal}]$ 定义为：
$$\text{GOTO}[i, A] = j \text{ if } \text{GOTO}(I_i, A) = I_j$$

## 3. 定理与证明

### 3.1 基本定理

**定理 3.1** (LR(k)文法的充分必要条件)
一个上下文无关文法 $G$ 是LR(k)文法当且仅当在构造LR(k)解析表时没有冲突。

**证明**：
必要性：如果 $G$ 是LR(k)文法，那么对于任意两个不同的最右推导，其向前看集合不相交，因此不会产生冲突。

充分性：如果没有冲突，那么解析器能够唯一确定下一步操作，因此 $G$ 是LR(k)文法。

**定理 3.2** (项目集闭包的性质)
对于任意项目集 $I$，$\text{CLOSURE}(I)$ 是唯一的，且满足：
$$\text{CLOSURE}(\text{CLOSURE}(I)) = \text{CLOSURE}(I)$$

**证明**：
唯一性：闭包操作是确定性的，每次添加的项目都是基于已有的项目。
幂等性：一旦项目在闭包中，再次应用闭包操作不会添加新项目。

### 3.2 算法定理

**定理 3.3** (LR(0)项目集构造)
LR(0)项目集可以通过以下算法构造：
1. 初始化：$I_0 = \text{CLOSURE}(\{S' \to \cdot S\})$
2. 对于每个项目集 $I_i$ 和符号 $X$，计算 $\text{GOTO}(I_i, X)$
3. 如果 $\text{GOTO}(I_i, X)$ 不在已构造的项目集中，则添加为新状态

**定理 3.4** (SLR(1)冲突解决)
在SLR(1)解析中，如果状态 $I_i$ 中存在移进-归约冲突：
- 移进项目：$A \to \alpha \cdot a\beta$
- 归约项目：$B \to \gamma \cdot$

则当 $a \in \text{FOLLOW}(B)$ 时存在冲突，否则选择移进。

### 3.3 复杂度定理

**定理 3.5** (LR解析的复杂度)
对于文法 $G$，LR解析的时间和空间复杂度为：
- 时间复杂度：$O(n)$，其中 $n$ 是输入串的长度
- 空间复杂度：$O(n)$，用于存储状态栈和符号栈

**证明**：
每次移进或归约操作都是常数时间，且每个输入符号最多被处理一次。

## 4. 代码实现

### 4.1 Rust实现

```rust
use std::collections::{HashMap, HashSet};

/// LR项目
# [derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LRItem {
    pub production: usize,
    pub dot_position: usize,
    pub lookahead: String,
}

/// LR状态
# [derive(Debug, Clone)]
pub struct LRState {
    pub items: HashSet<LRItem>,
    pub state_id: usize,
}

/// LR解析器
# [derive(Debug)]
pub struct LRParser {
    grammar: Vec<Production>,
    states: Vec<LRState>,
    action_table: HashMap<(usize, String), Action>,
    goto_table: HashMap<(usize, String), usize>,
    first_sets: HashMap<String, HashSet<String>>,
    follow_sets: HashMap<String, HashSet<String>>,
}

/// 解析动作
# [derive(Debug, Clone)]
pub enum Action {
    Shift(usize),
    Reduce(usize),
    Accept,
    Error,
}

impl LRParser {
    /// 创建新的LR解析器
    pub fn new(grammar: Vec<Production>) -> Self {
        let mut parser = Self {
            grammar,
            states: Vec::new(),
            action_table: HashMap::new(),
            goto_table: HashMap::new(),
            first_sets: HashMap::new(),
            follow_sets: HashMap::new(),
        };
        parser.compute_first_sets();
        parser.compute_follow_sets();
        parser.build_lr_states();
        parser.build_parse_tables();
        parser
    }

    /// 计算FIRST集合
    fn compute_first_sets(&mut self) {
        // 初始化
        for production in &self.grammar {
            self.first_sets.insert(production.left.clone(), HashSet::new());
        }

        let mut changed = true;
        while changed {
            changed = false;

            for production in &self.grammar {
                let first = self.first_sets.get_mut(&production.left).unwrap();
                let original_size = first.len();

                let right_first = self.first_of_sequence(&production.right);
                first.extend(right_first);

                if first.len() > original_size {
                    changed = true;
                }
            }
        }
    }

    /// 计算符号序列的FIRST集合
    fn first_of_sequence(&self, symbols: &[Symbol]) -> HashSet<String> {
        let mut first = HashSet::new();
        let mut all_nullable = true;

        for symbol in symbols {
            match symbol {
                Symbol::Terminal(t) => {
                    first.insert(t.clone());
                    all_nullable = false;
                    break;
                }
                Symbol::NonTerminal(nt) => {
                    if let Some(nt_first) = self.first_sets.get(nt) {
                        for item in nt_first {
                            if item != "ε" {
                                first.insert(item.clone());
                            }
                        }

                        if !nt_first.contains("ε") {
                            all_nullable = false;
                            break;
                        }
                    }
                }
                Symbol::Epsilon => {
                    first.insert("ε".to_string());
                }
                Symbol::EndMarker => {
                    first.insert("$".to_string());
                    all_nullable = false;
                    break;
                }
            }
        }

        if all_nullable {
            first.insert("ε".to_string());
        }

        first
    }

    /// 计算FOLLOW集合
    fn compute_follow_sets(&mut self) {
        // 初始化
        for production in &self.grammar {
            self.follow_sets.insert(production.left.clone(), HashSet::new());
        }

        // 开始符号的FOLLOW集合包含$
        if let Some(start_follow) = self.follow_sets.get_mut(&self.grammar[0].left) {
            start_follow.insert("$".to_string());
        }

        let mut changed = true;
        while changed {
            changed = false;

            for production in &self.grammar {
                let right = &production.right;

                for i in 0..right.len() {
                    if let Symbol::NonTerminal(nt) = &right[i] {
                        let follow = self.follow_sets.get_mut(nt).unwrap();
                        let original_size = follow.len();

                        // 计算β的FIRST集合
                        if i + 1 < right.len() {
                            let beta = &right[i + 1..];
                            let beta_first = self.first_of_sequence(beta);

                            for item in beta_first {
                                if item != "ε" {
                                    follow.insert(item);
                                }
                            }

                            // 如果β可以推导出ε，则添加FOLLOW(A)
                            if beta_first.contains("ε") {
                                if let Some(a_follow) = self.follow_sets.get(&production.left) {
                                    follow.extend(a_follow.clone());
                                }
                            }
                        } else {
                            // A -> αB，则FOLLOW(A) ⊆ FOLLOW(B)
                            if let Some(a_follow) = self.follow_sets.get(&production.left) {
                                follow.extend(a_follow.clone());
                            }
                        }

                        if follow.len() > original_size {
                            changed = true;
                        }
                    }
                }
            }
        }
    }

    /// 计算项目集闭包
    fn closure(&self, items: &HashSet<LRItem>) -> HashSet<LRItem> {
        let mut closure = items.clone();
        let mut changed = true;

        while changed {
            changed = false;

            for item in closure.clone() {
                let production = &self.grammar[item.production];
                let right = &production.right;

                if item.dot_position < right.len() {
                    if let Symbol::NonTerminal(nt) = &right[item.dot_position] {
                        // 计算β的FIRST集合
                        let beta = &right[item.dot_position + 1..];
                        let beta_first = self.first_of_sequence(beta);

                        // 计算向前看符号
                        let mut lookahead = beta_first.clone();
                        if beta_first.contains("ε") {
                            lookahead.remove("ε");
                            if let Some(follow) = self.follow_sets.get(&production.left) {
                                lookahead.extend(follow.clone());
                            }
                        }

                        // 添加新项目
                        for prod_idx in 0..self.grammar.len() {
                            let prod = &self.grammar[prod_idx];
                            if prod.left == *nt {
                                for la in &lookahead {
                                    let new_item = LRItem {
                                        production: prod_idx,
                                        dot_position: 0,
                                        lookahead: la.clone(),
                                    };
                                    if !closure.contains(&new_item) {
                                        closure.insert(new_item);
                                        changed = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        closure
    }

    /// 计算GOTO函数
    fn goto(&self, items: &HashSet<LRItem>, symbol: &Symbol) -> HashSet<LRItem> {
        let mut goto_items = HashSet::new();

        for item in items {
            let production = &self.grammar[item.production];
            let right = &production.right;

            if item.dot_position < right.len() && right[item.dot_position] == *symbol {
                let new_item = LRItem {
                    production: item.production,
                    dot_position: item.dot_position + 1,
                    lookahead: item.lookahead.clone(),
                };
                goto_items.insert(new_item);
            }
        }

        self.closure(&goto_items)
    }

    /// 构建LR状态
    fn build_lr_states(&mut self) {
        // 添加增广产生式
        let augmented_production = Production {
            left: "S'".to_string(),
            right: vec![Symbol::NonTerminal(self.grammar[0].left.clone())],
        };
        self.grammar.insert(0, augmented_production);

        // 初始项目集
        let initial_item = LRItem {
            production: 0,
            dot_position: 0,
            lookahead: "$".to_string(),
        };
        let initial_items = HashSet::from([initial_item]);
        let initial_closure = self.closure(&initial_items);

        let mut states = vec![LRState {
            items: initial_closure,
            state_id: 0,
        }];
        let mut unprocessed = vec![0];
        let mut processed = HashSet::new();

        while let Some(state_id) = unprocessed.pop() {
            if processed.contains(&state_id) {
                continue;
            }
            processed.insert(state_id);

            let state = &states[state_id];

            // 计算所有可能的GOTO
            let mut symbols = HashSet::new();
            for item in &state.items {
                let production = &self.grammar[item.production];
                let right = &production.right;

                if item.dot_position < right.len() {
                    symbols.insert(right[item.dot_position].clone());
                }
            }

            for symbol in symbols {
                let goto_items = self.goto(&state.items, &symbol);

                if !goto_items.is_empty() {
                    // 检查是否已存在相同状态
                    let mut found = false;
                    for (idx, existing_state) in states.iter().enumerate() {
                        if existing_state.items == goto_items {
                            self.goto_table.insert((state_id, self.symbol_to_string(&symbol)), idx);
                            found = true;
                            break;
                        }
                    }

                    if !found {
                        let new_state_id = states.len();
                        states.push(LRState {
                            items: goto_items,
                            state_id: new_state_id,
                        });
                        self.goto_table.insert((state_id, self.symbol_to_string(&symbol)), new_state_id);
                        unprocessed.push(new_state_id);
                    }
                }
            }
        }

        self.states = states;
    }

    /// 构建解析表
    fn build_parse_tables(&mut self) {
        for (state_id, state) in self.states.iter().enumerate() {
            for item in &state.items {
                let production = &self.grammar[item.production];
                let right = &production.right;

                if item.dot_position < right.len() {
                    // 移进项目
                    if let Symbol::Terminal(term) = &right[item.dot_position] {
                        if let Some(&goto_state) = self.goto_table.get(&(state_id, term.clone())) {
                            self.action_table.insert((state_id, term.clone()), Action::Shift(goto_state));
                        }
                    }
                } else {
                    // 归约项目
                    if production.left == "S'" {
                        self.action_table.insert((state_id, "$".to_string()), Action::Accept);
                    } else {
                        if let Some(follow) = self.follow_sets.get(&production.left) {
                            for terminal in follow {
                                self.action_table.insert((state_id, terminal.clone()), Action::Reduce(item.production));
                            }
                        }
                    }
                }
            }
        }
    }

    /// 解析输入
    pub fn parse(&self, input: &str) -> Result<Vec<String>, String> {
        let mut state_stack = vec![0];
        let mut symbol_stack = vec![Symbol::EndMarker];
        let mut input_tokens: Vec<String> = input
            .split_whitespace()
            .map(|s| s.to_string())
            .collect();
        input_tokens.push("$".to_string());

        let mut input_index = 0;
        let mut derivation = Vec::new();

        loop {
            let current_state = *state_stack.last().unwrap();
            let current_token = &input_tokens[input_index];

            match self.action_table.get(&(current_state, current_token.clone())) {
                Some(Action::Shift(next_state)) => {
                    state_stack.push(*next_state);
                    symbol_stack.push(Symbol::Terminal(current_token.clone()));
                    input_index += 1;
                }
                Some(Action::Reduce(production_idx)) => {
                    let production = &self.grammar[*production_idx];
                    let right_len = production.right.len();

                    // 弹出栈顶的符号
                    for _ in 0..right_len {
                        state_stack.pop();
                        symbol_stack.pop();
                    }

                    // 压入左部符号
                    symbol_stack.push(Symbol::NonTerminal(production.left.clone()));

                    // 查找GOTO状态
                    let current_state = *state_stack.last().unwrap();
                    if let Some(&goto_state) = self.goto_table.get(&(current_state, production.left.clone())) {
                        state_stack.push(goto_state);
                    } else {
                        return Err("GOTO table error".to_string());
                    }

                    derivation.push(format!("{} -> {}", production.left, self.symbols_to_string(&production.right)));
                }
                Some(Action::Accept) => {
                    break;
                }
                Some(Action::Error) | None => {
                    return Err(format!("Parse error at token '{}' in state {}", current_token, current_state));
                }
            }
        }

        Ok(derivation)
    }

    /// 将符号转换为字符串
    fn symbol_to_string(&self, symbol: &Symbol) -> String {
        match symbol {
            Symbol::Terminal(t) => t.clone(),
            Symbol::NonTerminal(nt) => nt.clone(),
            Symbol::Epsilon => "ε".to_string(),
            Symbol::EndMarker => "$".to_string(),
        }
    }

    /// 将符号序列转换为字符串
    fn symbols_to_string(&self, symbols: &[Symbol]) -> String {
        symbols
            .iter()
            .map(|s| self.symbol_to_string(s))
            .collect::<Vec<_>>()
            .join(" ")
    }

    /// 检查是否有冲突
    pub fn has_conflicts(&self) -> bool {
        for (state_id, state) in self.states.iter().enumerate() {
            let mut shift_terminals = HashSet::new();
            let mut reduce_productions = HashSet::new();

            for item in &state.items {
                let production = &self.grammar[item.production];
                let right = &production.right;

                if item.dot_position < right.len() {
                    if let Symbol::Terminal(term) = &right[item.dot_position] {
                        shift_terminals.insert(term.clone());
                    }
                } else {
                    if production.left != "S'" {
                        if let Some(follow) = self.follow_sets.get(&production.left) {
                            for terminal in follow {
                                if shift_terminals.contains(terminal) {
                                    return true; // 移进-归约冲突
                                }
                                reduce_productions.insert((production.left.clone(), terminal.clone()));
                            }
                        }
                    }
                }
            }

            // 检查归约-归约冲突
            if reduce_productions.len() > 1 {
                return true;
            }
        }

        false
    }
}

# [cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_lr_grammar() {
        let grammar = vec![
            Production {
                left: "E".to_string(),
                right: vec![
                    Symbol::NonTerminal("E".to_string()),
                    Symbol::Terminal("+".to_string()),
                    Symbol::NonTerminal("T".to_string()),
                ],
            },
            Production {
                left: "E".to_string(),
                right: vec![Symbol::NonTerminal("T".to_string())],
            },
            Production {
                left: "T".to_string(),
                right: vec![
                    Symbol::NonTerminal("T".to_string()),
                    Symbol::Terminal("*".to_string()),
                    Symbol::NonTerminal("F".to_string()),
                ],
            },
            Production {
                left: "T".to_string(),
                right: vec![Symbol::NonTerminal("F".to_string())],
            },
            Production {
                left: "F".to_string(),
                right: vec![Symbol::Terminal("id".to_string())],
            },
        ];

        let parser = LRParser::new(grammar);
        assert!(!parser.has_conflicts());

        let result = parser.parse("id + id * id");
        assert!(result.is_ok());
    }
}
```

### 4.2 Haskell实现

```haskell
import Data.List (nub, (\\), intersect)
import qualified Data.Map as Map
import qualified Data.Set as Set

-- LR项目
data LRItem = LRItem {
    production :: Int,
    dotPosition :: Int,
    lookahead :: String
} deriving (Show, Eq, Ord)

-- LR状态
data LRState = LRState {
    items :: Set.Set LRItem,
    stateId :: Int
} deriving (Show, Eq)

-- 解析动作
data Action = Shift Int | Reduce Int | Accept | Error
    deriving (Show, Eq)

-- LR解析器
data LRParser = LRParser {
    grammar :: [Production],
    states :: [LRState],
    actionTable :: Map.Map (Int, String) Action,
    gotoTable :: Map.Map (Int, String) Int,
    firstSets :: Map.Map String (Set.Set String),
    followSets :: Map.Map String (Set.Set String)
} deriving (Show)

-- 创建新的LR解析器
newLRParser :: [Production] -> LRParser
newLRParser g =
    let augmentedGrammar = addAugmentedProduction g
        first = computeFirstSets augmentedGrammar
        follow = computeFollowSets augmentedGrammar first
        states = buildLRStates augmentedGrammar first follow
        (action, goto) = buildParseTables states augmentedGrammar follow
    in LRParser augmentedGrammar states action goto first follow

-- 添加增广产生式
addAugmentedProduction :: [Production] -> [Production]
addAugmentedProduction g =
    let startSymbol = left (head g)
    in Production "S'" [NonTerminal startSymbol] : g

-- 计算项目集闭包
closure :: [Production] -> Map.Map String (Set.Set String) -> Set.Set LRItem -> Set.Set LRItem
closure grammar firstSets items =
    let initialItems = items
    in fixPoint (closureStep grammar firstSets) initialItems
  where
    fixPoint f x =
        let x' = f x
        in if x' == x then x else fixPoint f x'

    closureStep g first items =
        foldl (\acc item ->
            let production = g !! production item
                right = right production
                dotPos = dotPosition item
            in if dotPos < length right
               then case right !! dotPos of
                    NonTerminal nt ->
                        let beta = drop (dotPos + 1) right
                            betaFirst = firstOfSequence beta first
                            lookahead = if Set.member "ε" betaFirst
                                       then Set.union (Set.delete "ε" betaFirst)
                                                    (Map.findWithDefault Set.empty (left production) first)
                                       else Set.delete "ε" betaFirst
                        in foldl (\acc' la ->
                                    foldl (\acc'' (idx, p) ->
                                            if left p == nt
                                            then Set.insert (LRItem idx 0 la) acc''
                                            else acc'') acc' (zip [0..] g)) acc lookahead
                    _ -> acc
               else acc) items items

-- 计算GOTO函数
goto :: [Production] -> Map.Map String (Set.Set String) -> Set.Set LRItem -> Symbol -> Set.Set LRItem
goto grammar firstSets items symbol =
    let gotoItems = Set.fromList [LRItem (production item) (dotPosition item + 1) (lookahead item) |
                                 item <- Set.toList items,
                                 let prod = grammar !! production item,
                                 let right = right prod,
                                 dotPosition item < length right && right !! dotPosition item == symbol]
    in closure grammar firstSets gotoItems

-- 构建LR状态
buildLRStates :: [Production] -> Map.Map String (Set.Set String) -> Map.Map String (Set.Set String) -> [LRState]
buildLRStates grammar firstSets followSets =
    let initialItem = LRItem 0 0 "$"
        initialItems = Set.singleton initialItem
        initialClosure = closure grammar firstSets initialItems
        initialState = LRState initialClosure 0
    in buildStates [initialState] [0] Set.empty
  where
    buildStates states unprocessed processed =
        if null unprocessed
        then states
        else let currentStateId = head unprocessed
                 currentState = states !! currentStateId
                 newStates = processState currentState states
                 newUnprocessed = [s | s <- unprocessed, s /= currentStateId] ++
                                 [stateId s | s <- newStates, stateId s `notElem` map stateId states]
             in buildStates (states ++ newStates) newUnprocessed (Set.insert currentStateId processed)

    processState state states =
        let symbols = Set.fromList [right (grammar !! production item) !! dotPosition item |
                                   item <- Set.toList (items state),
                                   let prod = grammar !! production item,
                                   dotPosition item < length (right prod)]
        in concatMap (\symbol ->
                        let gotoItems = goto grammar firstSets (items state) symbol
                        in if Set.null gotoItems
                           then []
                           else [LRState gotoItems (length states + length (concatMap (processState state) states))])
                    (Set.toList symbols)

-- 构建解析表
buildParseTables :: [LRState] -> [Production] -> Map.Map String (Set.Set String) -> (Map.Map (Int, String) Action, Map.Map (Int, String) Int)
buildParseTables states grammar followSets =
    let actionTable = Map.fromList (concatMap (\state -> buildActionEntries state grammar followSets) states)
        gotoTable = Map.fromList (concatMap (\state -> buildGotoEntries state grammar) states)
    in (actionTable, gotoTable)
  where
    buildActionEntries state grammar followSets =
        concatMap (\item ->
            let production = grammar !! production item
                right = right production
            in if dotPosition item < length right
               then case right !! dotPosition item of
                    Terminal term -> [(stateId state, term, Shift (findGotoState state term))]
                    _ -> []
               else if left production == "S'"
                    then [(stateId state, "$", Accept)]
                    else let follow = Map.findWithDefault Set.empty (left production) followSets
                         in [(stateId state, terminal, Reduce (production item)) | terminal <- Set.toList follow])
            (Set.toList (items state))

    buildGotoEntries state grammar =
        concatMap (\item ->
            let production = grammar !! production item
                right = right production
            in if dotPosition item < length right
               then case right !! dotPosition item of
                    NonTerminal nt -> [(stateId state, nt, findGotoState state nt)]
                    _ -> []
               else [])
            (Set.toList (items state))

    findGotoState state symbol =
        -- 简化实现，实际需要查找对应的GOTO状态
        0

-- 解析输入
parse :: LRParser -> [String] -> Either String [String]
parse parser input =
    let tokens = input ++ ["$"]
        initialStack = [0]
        initialSymbols = [EndMarker]
    in parseHelper parser tokens initialStack initialSymbols []
  where
    parseHelper _ [] _ _ _ = Left "Unexpected end of input"
    parseHelper _ _ [] _ _ = Left "Stack empty"
    parseHelper p (t:ts) (s:ss) symbols derivation =
        case Map.lookup (s, t) (actionTable p) of
            Just (Shift nextState) ->
                parseHelper p ts (nextState:s:ss) (Terminal t:symbols) derivation
            Just (Reduce productionIdx) ->
                let production = grammar p !! productionIdx
                    rightLen = length (right production)
                    newStack = drop rightLen (s:ss)
                    newSymbols = drop rightLen symbols
                    newSymbols' = NonTerminal (left production) : newSymbols
                    newDerivation = derivation ++ [left production ++ " -> " ++ symbolsToString (right production)]
                in parseHelper p (t:ts) newStack newSymbols' newDerivation
            Just Accept -> Right derivation
            Just Error -> Left $ "Parse error at token '" ++ t ++ "' in state " ++ show s
            Nothing -> Left $ "No action for token '" ++ t ++ "' in state " ++ show s

-- 辅助函数
symbolsToString :: [Symbol] -> String
symbolsToString = unwords . map symbolToString
  where
    symbolToString (Terminal t) = t
    symbolToString (NonTerminal nt) = nt
    symbolToString Epsilon = "ε"
    symbolToString EndMarker = "$"

-- 示例使用
main :: IO ()
main = do
    putStrLn "LR解析示例："

    -- 简单的算术表达式文法
    let grammar = [
            Production "E" [NonTerminal "E", Terminal "+", NonTerminal "T"],
            Production "E" [NonTerminal "T"],
            Production "T" [NonTerminal "T", Terminal "*", NonTerminal "F"],
            Production "T" [NonTerminal "F"],
            Production "F" [Terminal "id"]
        ]

    let parser = newLRParser grammar

    let result = parse parser ["id", "+", "id", "*", "id"]
    case result of
        Right derivation -> do
            putStrLn "解析成功："
            mapM_ putStrLn derivation
        Left error -> putStrLn $ "解析错误: " ++ error
```

## 5. 应用示例

### 5.1 算术表达式解析

**问题**：解析包含运算符优先级的算术表达式。

**解**：
使用LR(1)文法：
```
E -> E + T | T
T -> T * F | F
F -> id | (E)
```

### 5.2 编程语言语法分析

**问题**：为复杂的编程语言构建语法分析器。

**解**：
```rust
pub fn parse_program(input: &str) -> Result<AST, String> {
    let grammar = vec![
        // 程序 -> 语句列表
        Production {
            left: "Program".to_string(),
            right: vec![Symbol::NonTerminal("StmtList".to_string())],
        },
        // 语句列表 -> 语句 语句列表 | ε
        Production {
            left: "StmtList".to_string(),
            right: vec![
                Symbol::NonTerminal("Statement".to_string()),
                Symbol::NonTerminal("StmtList".to_string()),
            ],
        },
        Production {
            left: "StmtList".to_string(),
            right: vec![Symbol::Epsilon],
        },
        // 语句 -> 赋值 | 条件 | 循环
        Production {
            left: "Statement".to_string(),
            right: vec![Symbol::NonTerminal("Assignment".to_string())],
        },
        // 赋值 -> id = 表达式 ;
        Production {
            left: "Assignment".to_string(),
            right: vec![
                Symbol::Terminal("id".to_string()),
                Symbol::Terminal("=".to_string()),
                Symbol::NonTerminal("Expression".to_string()),
                Symbol::Terminal(";".to_string()),
            ],
        },
    ];

    let parser = LRParser::new(grammar);
    parser.parse(input)
}
```

### 5.3 配置文件解析

**问题**：解析复杂的配置文件格式。

**解**：
```rust
pub fn parse_config_file(content: &str) -> Result<Config, String> {
    let grammar = vec![
        // 配置 -> 节列表
        Production {
            left: "Config".to_string(),
            right: vec![Symbol::NonTerminal("SectionList".to_string())],
        },
        // 节列表 -> 节 节列表 | ε
        Production {
            left: "SectionList".to_string(),
            right: vec![
                Symbol::NonTerminal("Section".to_string()),
                Symbol::NonTerminal("SectionList".to_string()),
            ],
        },
        Production {
            left: "SectionList".to_string(),
            right: vec![Symbol::Epsilon],
        },
        // 节 -> [节名] 键值对列表
        Production {
            left: "Section".to_string(),
            right: vec![
                Symbol::Terminal("[".to_string()),
                Symbol::NonTerminal("SectionName".to_string()),
                Symbol::Terminal("]".to_string()),
                Symbol::NonTerminal("KeyValueList".to_string()),
            ],
        },
        // 键值对列表 -> 键值对 键值对列表 | ε
        Production {
            left: "KeyValueList".to_string(),
            right: vec![
                Symbol::NonTerminal("KeyValue".to_string()),
                Symbol::NonTerminal("KeyValueList".to_string()),
            ],
        },
        Production {
            left: "KeyValueList".to_string(),
            right: vec![Symbol::Epsilon],
        },
        // 键值对 -> 键 = 值
        Production {
            left: "KeyValue".to_string(),
            right: vec![
                Symbol::NonTerminal("Key".to_string()),
                Symbol::Terminal("=".to_string()),
                Symbol::NonTerminal("Value".to_string()),
            ],
        },
    ];

    let parser = LRParser::new(grammar);
    parser.parse(content)
}
```

## 6. 相关理论

### 6.1 与形式语言理论的关系

- **上下文无关文法**：LR解析的基础
- **下推自动机**：LR解析器的实现模型
- **乔姆斯基谱系**：LR(k)文法的层次

### 6.2 与编译原理的关系

- **语法分析**：编译器前端的重要组成部分
- **错误恢复**：语法错误的检测和恢复
- **代码生成**：语法树到目标代码的转换

### 6.3 与其他解析方法的关系

- **LL解析**：自顶向下的解析方法
- **递归下降**：LL解析的手工实现
- **预测解析**：LL解析的另一种称呼

### 6.4 与软件工程的关系

- **解析器生成器**：如Yacc、Bison等工具
- **领域特定语言**：DSL的语法设计
- **配置文件解析**：各种格式的解析

## 7. 参考文献

1. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). *Compilers: Principles, Techniques, and Tools*. Pearson.
2. Grune, D., & Jacobs, C. J. (2008). *Parsing Techniques: A Practical Guide*. Springer.
3. Sippu, S., & Soisalon-Soininen, E. (1990). *Parsing Theory*. Springer.
4. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation*. Pearson.
5. Appel, A. W. (2002). *Modern Compiler Implementation*. Cambridge University Press.

---

**相关文档**：
- [03.1.2 下推自动机](../03_Formal_Language_Theory/03.1.2_下推自动机.md)
- [03.2.2 上下文无关文法](../03_Formal_Language_Theory/03.2.2_上下文无关文法.md)
- [03.4.1 LL解析](../03_Formal_Language_Theory/03.4.1_LL解析.md)
- [03.4.3 递归下降解析](../03_Formal_Language_Theory/03.4.3_递归下降解析.md)
- [04.1.1 简单类型λ演算](../04_Type_Theory/04.1.1_简单类型λ演算.md)
