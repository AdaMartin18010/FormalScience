# 03.4.2 LRè§£æ

## ğŸ“‹ æ¦‚è¿°

LRè§£ææ˜¯ä¸€ç§è‡ªåº•å‘ä¸Šçš„è¯­æ³•åˆ†ææ–¹æ³•ï¼Œèƒ½å¤Ÿå¤„ç†æ¯”LLè§£ææ›´å¹¿æ³›çš„ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ã€‚LRè§£æå™¨ä½¿ç”¨çŠ¶æ€æœºæ¥è·Ÿè¸ªè§£æè¿‡ç¨‹ï¼Œé€šè¿‡ç§»è¿›-å½’çº¦æ“ä½œæ„å»ºè¯­æ³•åˆ†ææ ‘ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. ç†è§£LRè§£æçš„åŸºæœ¬åŸç†å’Œç®—æ³•
2. æŒæ¡LR(k)æ–‡æ³•çš„å®šä¹‰å’Œæ€§è´¨
3. å­¦ä¼šæ„å»ºLRè§£æè¡¨å’ŒçŠ¶æ€æœº
4. ç†è§£ä¸åŒLRå˜ä½“çš„ç‰¹ç‚¹å’Œé€‚ç”¨åœºæ™¯
5. æŒæ¡LRè§£æçš„é”™è¯¯å¤„ç†å’Œä¼˜åŒ–æŠ€æœ¯

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 LRè§£æçš„å®šä¹‰

**å®šä¹‰ 1.1** (LRè§£æ)
LRè§£ææ˜¯ä¸€ç§**è‡ªåº•å‘ä¸Š**çš„è¯­æ³•åˆ†ææ–¹æ³•ï¼Œå…¶ä¸­ï¼š

- Lè¡¨ç¤º**ä»å·¦åˆ°å³**æ‰«æè¾“å…¥
- Rè¡¨ç¤º**æœ€å³æ¨å¯¼**çš„é€†è¿‡ç¨‹

**å®šä¹‰ 1.2** (LR(k)æ–‡æ³•)
ä¸€ä¸ªä¸Šä¸‹æ–‡æ— å…³æ–‡æ³• $G$ æ˜¯**LR(k)æ–‡æ³•**ï¼Œå¦‚æœå¯¹äºä»»æ„ä¸¤ä¸ªä¸åŒçš„æœ€å³æ¨å¯¼ï¼š
$$S \Rightarrow^* \alpha A w \Rightarrow \alpha \beta w$$
$$S \Rightarrow^* \gamma B x \Rightarrow \gamma \delta x$$

å…¶ä¸­ $w, x \in \Sigma^*$ï¼Œ$|w| = |x| = k$ï¼Œéƒ½æœ‰ï¼š
$$\text{FOLLOW}_k(A) \cap \text{FOLLOW}_k(B) = \emptyset$$

### 1.2 åŸºæœ¬æ¦‚å¿µ

**å®šä¹‰ 1.3** (é¡¹ç›®)
ä¸€ä¸ª**é¡¹ç›®**ï¼ˆItemï¼‰æ˜¯ä¸€ä¸ªäº§ç”Ÿå¼åŠ ä¸Šä¸€ä¸ªä½ç½®æ ‡è®°ï¼Œè¡¨ç¤ºè§£æçš„è¿›åº¦ã€‚å½¢å¼ä¸ºï¼š
$$A \to \alpha \cdot \beta$$
å…¶ä¸­ $\cdot$ è¡¨ç¤ºå½“å‰è§£æä½ç½®ã€‚

**å®šä¹‰ 1.4** (è§„èŒƒé¡¹ç›®é›†)
ä¸€ä¸ª**è§„èŒƒé¡¹ç›®é›†**ï¼ˆCanonical Item Setï¼‰æ˜¯LRè§£æå™¨çš„ä¸€ä¸ªçŠ¶æ€ï¼ŒåŒ…å«æ‰€æœ‰åœ¨æŸä¸ªé…ç½®ä¸‹å¯èƒ½æœ‰æ•ˆçš„é¡¹ç›®ã€‚

**å®šä¹‰ 1.5** (ç§»è¿›-å½’çº¦å†²çª)
å½“è§£æå™¨çŠ¶æ€ä¸­åŒæ—¶å­˜åœ¨ç§»è¿›é¡¹ç›®å’Œå½’çº¦é¡¹ç›®æ—¶ï¼Œç§°ä¸º**ç§»è¿›-å½’çº¦å†²çª**ã€‚

**å®šä¹‰ 1.6** (å½’çº¦-å½’çº¦å†²çª)
å½“è§£æå™¨çŠ¶æ€ä¸­å­˜åœ¨å¤šä¸ªå½’çº¦é¡¹ç›®æ—¶ï¼Œç§°ä¸º**å½’çº¦-å½’çº¦å†²çª**ã€‚

### 1.3 LRè§£æçš„å˜ä½“

**å®šä¹‰ 1.7** (SLR(1))
**SLR(1)**ï¼ˆSimple LR(1)ï¼‰ä½¿ç”¨FOLLOWé›†åˆæ¥è§£å†³å†²çªã€‚

**å®šä¹‰ 1.8** (LALR(1))
**LALR(1)**ï¼ˆLook-Ahead LR(1)ï¼‰é€šè¿‡åˆå¹¶ç›¸ä¼¼çŠ¶æ€æ¥å‡å°‘çŠ¶æ€æ•°é‡ã€‚

**å®šä¹‰ 1.9** (LR(1))
**LR(1)**ä½¿ç”¨ç²¾ç¡®çš„å‘å‰çœ‹ä¿¡æ¯æ¥æ„å»ºè§£æè¡¨ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 LRè§£æçš„å½¢å¼åŒ–æ¨¡å‹

**å®šä¹‰ 2.1** (LRè§£æå™¨é…ç½®)
LRè§£æå™¨çš„é…ç½®æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(S, w, \alpha)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯çŠ¶æ€æ ˆ
- $w$ æ˜¯å‰©ä½™çš„è¾“å…¥ä¸²
- $\alpha$ æ˜¯ç¬¦å·æ ˆ

**å®šä¹‰ 2.2** (LRè§£æçš„è½¬ç§»å…³ç³»)
LRè§£æçš„è½¬ç§»å…³ç³» $\vdash$ å®šä¹‰ä¸ºï¼š

1. **ç§»è¿›**ï¼š$(S, aw, \alpha) \vdash (S \cdot s, w, \alpha a)$ å¦‚æœ $\text{ACTION}[s, a] = \text{shift } s'$
2. **å½’çº¦**ï¼š$(S \cdot s, w, \alpha \beta) \vdash (S', w, \alpha A)$ å¦‚æœ $\text{ACTION}[s, a] = \text{reduce } A \to \beta$
3. **æ¥å—**ï¼š$(s_0, \varepsilon, S)$ æ˜¯æ¥å—çŠ¶æ€

### 2.2 é¡¹ç›®é›†é—­åŒ…

**å®šä¹‰ 2.3** (é¡¹ç›®é›†é—­åŒ…)
é¡¹ç›®é›† $I$ çš„**é—­åŒ…** $\text{CLOSURE}(I)$ å®šä¹‰ä¸ºï¼š
$$\text{CLOSURE}(I) = I \cup \{B \to \cdot \gamma : A \to \alpha \cdot B\beta \in \text{CLOSURE}(I), B \to \gamma \in P\}$$

**å®šä¹‰ 2.4** (GOTOå‡½æ•°)
å¯¹äºé¡¹ç›®é›† $I$ å’Œç¬¦å· $X$ï¼Œ**GOTOå‡½æ•°**å®šä¹‰ä¸ºï¼š
$$\text{GOTO}(I, X) = \text{CLOSURE}(\{A \to \alpha X \cdot \beta : A \to \alpha \cdot X\beta \in I\})$$

### 2.3 LRè§£æè¡¨çš„æ„é€ 

**å®šä¹‰ 2.5** (ACTIONè¡¨)
**ACTIONè¡¨** $[\text{state}, \text{terminal}]$ å®šä¹‰ä¸ºï¼š
$$\text{ACTION}[i, a] = \begin{cases}
\text{shift } j & \text{if } \text{GOTO}(I_i, a) = I_j \\
\text{reduce } A \to \beta & \text{if } A \to \beta \cdot \in I_i \text{ and } a \in \text{FOLLOW}(A) \\
\text{accept} & \text{if } S' \to S \cdot \in I_i \text{ and } a = \$ \\
\text{error} & \text{otherwise}
\end{cases}$$

**å®šä¹‰ 2.6** (GOTOè¡¨)
**GOTOè¡¨** $[\text{state}, \text{nonterminal}]$ å®šä¹‰ä¸ºï¼š
$$\text{GOTO}[i, A] = j \text{ if } \text{GOTO}(I_i, A) = I_j$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬å®šç†

**å®šç† 3.1** (LR(k)æ–‡æ³•çš„å……åˆ†å¿…è¦æ¡ä»¶)
ä¸€ä¸ªä¸Šä¸‹æ–‡æ— å…³æ–‡æ³• $G$ æ˜¯LR(k)æ–‡æ³•å½“ä¸”ä»…å½“åœ¨æ„é€ LR(k)è§£æè¡¨æ—¶æ²¡æœ‰å†²çªã€‚

**è¯æ˜**ï¼š
å¿…è¦æ€§ï¼šå¦‚æœ $G$ æ˜¯LR(k)æ–‡æ³•ï¼Œé‚£ä¹ˆå¯¹äºä»»æ„ä¸¤ä¸ªä¸åŒçš„æœ€å³æ¨å¯¼ï¼Œå…¶å‘å‰çœ‹é›†åˆä¸ç›¸äº¤ï¼Œå› æ­¤ä¸ä¼šäº§ç”Ÿå†²çªã€‚

å……åˆ†æ€§ï¼šå¦‚æœæ²¡æœ‰å†²çªï¼Œé‚£ä¹ˆè§£æå™¨èƒ½å¤Ÿå”¯ä¸€ç¡®å®šä¸‹ä¸€æ­¥æ“ä½œï¼Œå› æ­¤ $G$ æ˜¯LR(k)æ–‡æ³•ã€‚

**å®šç† 3.2** (é¡¹ç›®é›†é—­åŒ…çš„æ€§è´¨)
å¯¹äºä»»æ„é¡¹ç›®é›† $I$ï¼Œ$\text{CLOSURE}(I)$ æ˜¯å”¯ä¸€çš„ï¼Œä¸”æ»¡è¶³ï¼š
$$\text{CLOSURE}(\text{CLOSURE}(I)) = \text{CLOSURE}(I)$$

**è¯æ˜**ï¼š
å”¯ä¸€æ€§ï¼šé—­åŒ…æ“ä½œæ˜¯ç¡®å®šæ€§çš„ï¼Œæ¯æ¬¡æ·»åŠ çš„é¡¹ç›®éƒ½æ˜¯åŸºäºå·²æœ‰çš„é¡¹ç›®ã€‚
å¹‚ç­‰æ€§ï¼šä¸€æ—¦é¡¹ç›®åœ¨é—­åŒ…ä¸­ï¼Œå†æ¬¡åº”ç”¨é—­åŒ…æ“ä½œä¸ä¼šæ·»åŠ æ–°é¡¹ç›®ã€‚

### 3.2 ç®—æ³•å®šç†

**å®šç† 3.3** (LR(0)é¡¹ç›®é›†æ„é€ )
LR(0)é¡¹ç›®é›†å¯ä»¥é€šè¿‡ä»¥ä¸‹ç®—æ³•æ„é€ ï¼š
1. åˆå§‹åŒ–ï¼š$I_0 = \text{CLOSURE}(\{S' \to \cdot S\})$
2. å¯¹äºæ¯ä¸ªé¡¹ç›®é›† $I_i$ å’Œç¬¦å· $X$ï¼Œè®¡ç®— $\text{GOTO}(I_i, X)$
3. å¦‚æœ $\text{GOTO}(I_i, X)$ ä¸åœ¨å·²æ„é€ çš„é¡¹ç›®é›†ä¸­ï¼Œåˆ™æ·»åŠ ä¸ºæ–°çŠ¶æ€

**å®šç† 3.4** (SLR(1)å†²çªè§£å†³)
åœ¨SLR(1)è§£æä¸­ï¼Œå¦‚æœçŠ¶æ€ $I_i$ ä¸­å­˜åœ¨ç§»è¿›-å½’çº¦å†²çªï¼š
- ç§»è¿›é¡¹ç›®ï¼š$A \to \alpha \cdot a\beta$
- å½’çº¦é¡¹ç›®ï¼š$B \to \gamma \cdot$

åˆ™å½“ $a \in \text{FOLLOW}(B)$ æ—¶å­˜åœ¨å†²çªï¼Œå¦åˆ™é€‰æ‹©ç§»è¿›ã€‚

### 3.3 å¤æ‚åº¦å®šç†

**å®šç† 3.5** (LRè§£æçš„å¤æ‚åº¦)
å¯¹äºæ–‡æ³• $G$ï¼ŒLRè§£æçš„æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦ä¸ºï¼š
- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œå…¶ä¸­ $n$ æ˜¯è¾“å…¥ä¸²çš„é•¿åº¦
- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œç”¨äºå­˜å‚¨çŠ¶æ€æ ˆå’Œç¬¦å·æ ˆ

**è¯æ˜**ï¼š
æ¯æ¬¡ç§»è¿›æˆ–å½’çº¦æ“ä½œéƒ½æ˜¯å¸¸æ•°æ—¶é—´ï¼Œä¸”æ¯ä¸ªè¾“å…¥ç¬¦å·æœ€å¤šè¢«å¤„ç†ä¸€æ¬¡ã€‚

## 4. ä»£ç å®ç°

### 4.1 Rustå®ç°

```rust
use std::collections::{HashMap, HashSet};

/// LRé¡¹ç›®
# [derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LRItem {
    pub production: usize,
    pub dot_position: usize,
    pub lookahead: String,
}

/// LRçŠ¶æ€
# [derive(Debug, Clone)]
pub struct LRState {
    pub items: HashSet<LRItem>,
    pub state_id: usize,
}

/// LRè§£æå™¨
# [derive(Debug)]
pub struct LRParser {
    grammar: Vec<Production>,
    states: Vec<LRState>,
    action_table: HashMap<(usize, String), Action>,
    goto_table: HashMap<(usize, String), usize>,
    first_sets: HashMap<String, HashSet<String>>,
    follow_sets: HashMap<String, HashSet<String>>,
}

/// è§£æåŠ¨ä½œ
# [derive(Debug, Clone)]
pub enum Action {
    Shift(usize),
    Reduce(usize),
    Accept,
    Error,
}

impl LRParser {
    /// åˆ›å»ºæ–°çš„LRè§£æå™¨
    pub fn new(grammar: Vec<Production>) -> Self {
        let mut parser = Self {
            grammar,
            states: Vec::new(),
            action_table: HashMap::new(),
            goto_table: HashMap::new(),
            first_sets: HashMap::new(),
            follow_sets: HashMap::new(),
        };
        parser.compute_first_sets();
        parser.compute_follow_sets();
        parser.build_lr_states();
        parser.build_parse_tables();
        parser
    }

    /// è®¡ç®—FIRSTé›†åˆ
    fn compute_first_sets(&mut self) {
        // åˆå§‹åŒ–
        for production in &self.grammar {
            self.first_sets.insert(production.left.clone(), HashSet::new());
        }

        let mut changed = true;
        while changed {
            changed = false;

            for production in &self.grammar {
                let first = self.first_sets.get_mut(&production.left).unwrap();
                let original_size = first.len();

                let right_first = self.first_of_sequence(&production.right);
                first.extend(right_first);

                if first.len() > original_size {
                    changed = true;
                }
            }
        }
    }

    /// è®¡ç®—ç¬¦å·åºåˆ—çš„FIRSTé›†åˆ
    fn first_of_sequence(&self, symbols: &[Symbol]) -> HashSet<String> {
        let mut first = HashSet::new();
        let mut all_nullable = true;

        for symbol in symbols {
            match symbol {
                Symbol::Terminal(t) => {
                    first.insert(t.clone());
                    all_nullable = false;
                    break;
                }
                Symbol::NonTerminal(nt) => {
                    if let Some(nt_first) = self.first_sets.get(nt) {
                        for item in nt_first {
                            if item != "Îµ" {
                                first.insert(item.clone());
                            }
                        }

                        if !nt_first.contains("Îµ") {
                            all_nullable = false;
                            break;
                        }
                    }
                }
                Symbol::Epsilon => {
                    first.insert("Îµ".to_string());
                }
                Symbol::EndMarker => {
                    first.insert("$".to_string());
                    all_nullable = false;
                    break;
                }
            }
        }

        if all_nullable {
            first.insert("Îµ".to_string());
        }

        first
    }

    /// è®¡ç®—FOLLOWé›†åˆ
    fn compute_follow_sets(&mut self) {
        // åˆå§‹åŒ–
        for production in &self.grammar {
            self.follow_sets.insert(production.left.clone(), HashSet::new());
        }

        // å¼€å§‹ç¬¦å·çš„FOLLOWé›†åˆåŒ…å«$
        if let Some(start_follow) = self.follow_sets.get_mut(&self.grammar[0].left) {
            start_follow.insert("$".to_string());
        }

        let mut changed = true;
        while changed {
            changed = false;

            for production in &self.grammar {
                let right = &production.right;

                for i in 0..right.len() {
                    if let Symbol::NonTerminal(nt) = &right[i] {
                        let follow = self.follow_sets.get_mut(nt).unwrap();
                        let original_size = follow.len();

                        // è®¡ç®—Î²çš„FIRSTé›†åˆ
                        if i + 1 < right.len() {
                            let beta = &right[i + 1..];
                            let beta_first = self.first_of_sequence(beta);

                            for item in beta_first {
                                if item != "Îµ" {
                                    follow.insert(item);
                                }
                            }

                            // å¦‚æœÎ²å¯ä»¥æ¨å¯¼å‡ºÎµï¼Œåˆ™æ·»åŠ FOLLOW(A)
                            if beta_first.contains("Îµ") {
                                if let Some(a_follow) = self.follow_sets.get(&production.left) {
                                    follow.extend(a_follow.clone());
                                }
                            }
                        } else {
                            // A -> Î±Bï¼Œåˆ™FOLLOW(A) âŠ† FOLLOW(B)
                            if let Some(a_follow) = self.follow_sets.get(&production.left) {
                                follow.extend(a_follow.clone());
                            }
                        }

                        if follow.len() > original_size {
                            changed = true;
                        }
                    }
                }
            }
        }
    }

    /// è®¡ç®—é¡¹ç›®é›†é—­åŒ…
    fn closure(&self, items: &HashSet<LRItem>) -> HashSet<LRItem> {
        let mut closure = items.clone();
        let mut changed = true;

        while changed {
            changed = false;

            for item in closure.clone() {
                let production = &self.grammar[item.production];
                let right = &production.right;

                if item.dot_position < right.len() {
                    if let Symbol::NonTerminal(nt) = &right[item.dot_position] {
                        // è®¡ç®—Î²çš„FIRSTé›†åˆ
                        let beta = &right[item.dot_position + 1..];
                        let beta_first = self.first_of_sequence(beta);

                        // è®¡ç®—å‘å‰çœ‹ç¬¦å·
                        let mut lookahead = beta_first.clone();
                        if beta_first.contains("Îµ") {
                            lookahead.remove("Îµ");
                            if let Some(follow) = self.follow_sets.get(&production.left) {
                                lookahead.extend(follow.clone());
                            }
                        }

                        // æ·»åŠ æ–°é¡¹ç›®
                        for prod_idx in 0..self.grammar.len() {
                            let prod = &self.grammar[prod_idx];
                            if prod.left == *nt {
                                for la in &lookahead {
                                    let new_item = LRItem {
                                        production: prod_idx,
                                        dot_position: 0,
                                        lookahead: la.clone(),
                                    };
                                    if !closure.contains(&new_item) {
                                        closure.insert(new_item);
                                        changed = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        closure
    }

    /// è®¡ç®—GOTOå‡½æ•°
    fn goto(&self, items: &HashSet<LRItem>, symbol: &Symbol) -> HashSet<LRItem> {
        let mut goto_items = HashSet::new();

        for item in items {
            let production = &self.grammar[item.production];
            let right = &production.right;

            if item.dot_position < right.len() && right[item.dot_position] == *symbol {
                let new_item = LRItem {
                    production: item.production,
                    dot_position: item.dot_position + 1,
                    lookahead: item.lookahead.clone(),
                };
                goto_items.insert(new_item);
            }
        }

        self.closure(&goto_items)
    }

    /// æ„å»ºLRçŠ¶æ€
    fn build_lr_states(&mut self) {
        // æ·»åŠ å¢å¹¿äº§ç”Ÿå¼
        let augmented_production = Production {
            left: "S'".to_string(),
            right: vec![Symbol::NonTerminal(self.grammar[0].left.clone())],
        };
        self.grammar.insert(0, augmented_production);

        // åˆå§‹é¡¹ç›®é›†
        let initial_item = LRItem {
            production: 0,
            dot_position: 0,
            lookahead: "$".to_string(),
        };
        let initial_items = HashSet::from([initial_item]);
        let initial_closure = self.closure(&initial_items);

        let mut states = vec![LRState {
            items: initial_closure,
            state_id: 0,
        }];
        let mut unprocessed = vec![0];
        let mut processed = HashSet::new();

        while let Some(state_id) = unprocessed.pop() {
            if processed.contains(&state_id) {
                continue;
            }
            processed.insert(state_id);

            let state = &states[state_id];

            // è®¡ç®—æ‰€æœ‰å¯èƒ½çš„GOTO
            let mut symbols = HashSet::new();
            for item in &state.items {
                let production = &self.grammar[item.production];
                let right = &production.right;

                if item.dot_position < right.len() {
                    symbols.insert(right[item.dot_position].clone());
                }
            }

            for symbol in symbols {
                let goto_items = self.goto(&state.items, &symbol);

                if !goto_items.is_empty() {
                    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒçŠ¶æ€
                    let mut found = false;
                    for (idx, existing_state) in states.iter().enumerate() {
                        if existing_state.items == goto_items {
                            self.goto_table.insert((state_id, self.symbol_to_string(&symbol)), idx);
                            found = true;
                            break;
                        }
                    }

                    if !found {
                        let new_state_id = states.len();
                        states.push(LRState {
                            items: goto_items,
                            state_id: new_state_id,
                        });
                        self.goto_table.insert((state_id, self.symbol_to_string(&symbol)), new_state_id);
                        unprocessed.push(new_state_id);
                    }
                }
            }
        }

        self.states = states;
    }

    /// æ„å»ºè§£æè¡¨
    fn build_parse_tables(&mut self) {
        for (state_id, state) in self.states.iter().enumerate() {
            for item in &state.items {
                let production = &self.grammar[item.production];
                let right = &production.right;

                if item.dot_position < right.len() {
                    // ç§»è¿›é¡¹ç›®
                    if let Symbol::Terminal(term) = &right[item.dot_position] {
                        if let Some(&goto_state) = self.goto_table.get(&(state_id, term.clone())) {
                            self.action_table.insert((state_id, term.clone()), Action::Shift(goto_state));
                        }
                    }
                } else {
                    // å½’çº¦é¡¹ç›®
                    if production.left == "S'" {
                        self.action_table.insert((state_id, "$".to_string()), Action::Accept);
                    } else {
                        if let Some(follow) = self.follow_sets.get(&production.left) {
                            for terminal in follow {
                                self.action_table.insert((state_id, terminal.clone()), Action::Reduce(item.production));
                            }
                        }
                    }
                }
            }
        }
    }

    /// è§£æè¾“å…¥
    pub fn parse(&self, input: &str) -> Result<Vec<String>, String> {
        let mut state_stack = vec![0];
        let mut symbol_stack = vec![Symbol::EndMarker];
        let mut input_tokens: Vec<String> = input
            .split_whitespace()
            .map(|s| s.to_string())
            .collect();
        input_tokens.push("$".to_string());

        let mut input_index = 0;
        let mut derivation = Vec::new();

        loop {
            let current_state = *state_stack.last().unwrap();
            let current_token = &input_tokens[input_index];

            match self.action_table.get(&(current_state, current_token.clone())) {
                Some(Action::Shift(next_state)) => {
                    state_stack.push(*next_state);
                    symbol_stack.push(Symbol::Terminal(current_token.clone()));
                    input_index += 1;
                }
                Some(Action::Reduce(production_idx)) => {
                    let production = &self.grammar[*production_idx];
                    let right_len = production.right.len();

                    // å¼¹å‡ºæ ˆé¡¶çš„ç¬¦å·
                    for _ in 0..right_len {
                        state_stack.pop();
                        symbol_stack.pop();
                    }

                    // å‹å…¥å·¦éƒ¨ç¬¦å·
                    symbol_stack.push(Symbol::NonTerminal(production.left.clone()));

                    // æŸ¥æ‰¾GOTOçŠ¶æ€
                    let current_state = *state_stack.last().unwrap();
                    if let Some(&goto_state) = self.goto_table.get(&(current_state, production.left.clone())) {
                        state_stack.push(goto_state);
                    } else {
                        return Err("GOTO table error".to_string());
                    }

                    derivation.push(format!("{} -> {}", production.left, self.symbols_to_string(&production.right)));
                }
                Some(Action::Accept) => {
                    break;
                }
                Some(Action::Error) | None => {
                    return Err(format!("Parse error at token '{}' in state {}", current_token, current_state));
                }
            }
        }

        Ok(derivation)
    }

    /// å°†ç¬¦å·è½¬æ¢ä¸ºå­—ç¬¦ä¸²
    fn symbol_to_string(&self, symbol: &Symbol) -> String {
        match symbol {
            Symbol::Terminal(t) => t.clone(),
            Symbol::NonTerminal(nt) => nt.clone(),
            Symbol::Epsilon => "Îµ".to_string(),
            Symbol::EndMarker => "$".to_string(),
        }
    }

    /// å°†ç¬¦å·åºåˆ—è½¬æ¢ä¸ºå­—ç¬¦ä¸²
    fn symbols_to_string(&self, symbols: &[Symbol]) -> String {
        symbols
            .iter()
            .map(|s| self.symbol_to_string(s))
            .collect::<Vec<_>>()
            .join(" ")
    }

    /// æ£€æŸ¥æ˜¯å¦æœ‰å†²çª
    pub fn has_conflicts(&self) -> bool {
        for (state_id, state) in self.states.iter().enumerate() {
            let mut shift_terminals = HashSet::new();
            let mut reduce_productions = HashSet::new();

            for item in &state.items {
                let production = &self.grammar[item.production];
                let right = &production.right;

                if item.dot_position < right.len() {
                    if let Symbol::Terminal(term) = &right[item.dot_position] {
                        shift_terminals.insert(term.clone());
                    }
                } else {
                    if production.left != "S'" {
                        if let Some(follow) = self.follow_sets.get(&production.left) {
                            for terminal in follow {
                                if shift_terminals.contains(terminal) {
                                    return true; // ç§»è¿›-å½’çº¦å†²çª
                                }
                                reduce_productions.insert((production.left.clone(), terminal.clone()));
                            }
                        }
                    }
                }
            }

            // æ£€æŸ¥å½’çº¦-å½’çº¦å†²çª
            if reduce_productions.len() > 1 {
                return true;
            }
        }

        false
    }
}

# [cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_lr_grammar() {
        let grammar = vec![
            Production {
                left: "E".to_string(),
                right: vec![
                    Symbol::NonTerminal("E".to_string()),
                    Symbol::Terminal("+".to_string()),
                    Symbol::NonTerminal("T".to_string()),
                ],
            },
            Production {
                left: "E".to_string(),
                right: vec![Symbol::NonTerminal("T".to_string())],
            },
            Production {
                left: "T".to_string(),
                right: vec![
                    Symbol::NonTerminal("T".to_string()),
                    Symbol::Terminal("*".to_string()),
                    Symbol::NonTerminal("F".to_string()),
                ],
            },
            Production {
                left: "T".to_string(),
                right: vec![Symbol::NonTerminal("F".to_string())],
            },
            Production {
                left: "F".to_string(),
                right: vec![Symbol::Terminal("id".to_string())],
            },
        ];

        let parser = LRParser::new(grammar);
        assert!(!parser.has_conflicts());

        let result = parser.parse("id + id * id");
        assert!(result.is_ok());
    }
}
```

### 4.2 Haskellå®ç°

```haskell
import Data.List (nub, (\\), intersect)
import qualified Data.Map as Map
import qualified Data.Set as Set

-- LRé¡¹ç›®
data LRItem = LRItem {
    production :: Int,
    dotPosition :: Int,
    lookahead :: String
} deriving (Show, Eq, Ord)

-- LRçŠ¶æ€
data LRState = LRState {
    items :: Set.Set LRItem,
    stateId :: Int
} deriving (Show, Eq)

-- è§£æåŠ¨ä½œ
data Action = Shift Int | Reduce Int | Accept | Error
    deriving (Show, Eq)

-- LRè§£æå™¨
data LRParser = LRParser {
    grammar :: [Production],
    states :: [LRState],
    actionTable :: Map.Map (Int, String) Action,
    gotoTable :: Map.Map (Int, String) Int,
    firstSets :: Map.Map String (Set.Set String),
    followSets :: Map.Map String (Set.Set String)
} deriving (Show)

-- åˆ›å»ºæ–°çš„LRè§£æå™¨
newLRParser :: [Production] -> LRParser
newLRParser g =
    let augmentedGrammar = addAugmentedProduction g
        first = computeFirstSets augmentedGrammar
        follow = computeFollowSets augmentedGrammar first
        states = buildLRStates augmentedGrammar first follow
        (action, goto) = buildParseTables states augmentedGrammar follow
    in LRParser augmentedGrammar states action goto first follow

-- æ·»åŠ å¢å¹¿äº§ç”Ÿå¼
addAugmentedProduction :: [Production] -> [Production]
addAugmentedProduction g =
    let startSymbol = left (head g)
    in Production "S'" [NonTerminal startSymbol] : g

-- è®¡ç®—é¡¹ç›®é›†é—­åŒ…
closure :: [Production] -> Map.Map String (Set.Set String) -> Set.Set LRItem -> Set.Set LRItem
closure grammar firstSets items =
    let initialItems = items
    in fixPoint (closureStep grammar firstSets) initialItems
  where
    fixPoint f x =
        let x' = f x
        in if x' == x then x else fixPoint f x'

    closureStep g first items =
        foldl (\acc item ->
            let production = g !! production item
                right = right production
                dotPos = dotPosition item
            in if dotPos < length right
               then case right !! dotPos of
                    NonTerminal nt ->
                        let beta = drop (dotPos + 1) right
                            betaFirst = firstOfSequence beta first
                            lookahead = if Set.member "Îµ" betaFirst
                                       then Set.union (Set.delete "Îµ" betaFirst)
                                                    (Map.findWithDefault Set.empty (left production) first)
                                       else Set.delete "Îµ" betaFirst
                        in foldl (\acc' la ->
                                    foldl (\acc'' (idx, p) ->
                                            if left p == nt
                                            then Set.insert (LRItem idx 0 la) acc''
                                            else acc'') acc' (zip [0..] g)) acc lookahead
                    _ -> acc
               else acc) items items

-- è®¡ç®—GOTOå‡½æ•°
goto :: [Production] -> Map.Map String (Set.Set String) -> Set.Set LRItem -> Symbol -> Set.Set LRItem
goto grammar firstSets items symbol =
    let gotoItems = Set.fromList [LRItem (production item) (dotPosition item + 1) (lookahead item) |
                                 item <- Set.toList items,
                                 let prod = grammar !! production item,
                                 let right = right prod,
                                 dotPosition item < length right && right !! dotPosition item == symbol]
    in closure grammar firstSets gotoItems

-- æ„å»ºLRçŠ¶æ€
buildLRStates :: [Production] -> Map.Map String (Set.Set String) -> Map.Map String (Set.Set String) -> [LRState]
buildLRStates grammar firstSets followSets =
    let initialItem = LRItem 0 0 "$"
        initialItems = Set.singleton initialItem
        initialClosure = closure grammar firstSets initialItems
        initialState = LRState initialClosure 0
    in buildStates [initialState] [0] Set.empty
  where
    buildStates states unprocessed processed =
        if null unprocessed
        then states
        else let currentStateId = head unprocessed
                 currentState = states !! currentStateId
                 newStates = processState currentState states
                 newUnprocessed = [s | s <- unprocessed, s /= currentStateId] ++
                                 [stateId s | s <- newStates, stateId s `notElem` map stateId states]
             in buildStates (states ++ newStates) newUnprocessed (Set.insert currentStateId processed)

    processState state states =
        let symbols = Set.fromList [right (grammar !! production item) !! dotPosition item |
                                   item <- Set.toList (items state),
                                   let prod = grammar !! production item,
                                   dotPosition item < length (right prod)]
        in concatMap (\symbol ->
                        let gotoItems = goto grammar firstSets (items state) symbol
                        in if Set.null gotoItems
                           then []
                           else [LRState gotoItems (length states + length (concatMap (processState state) states))])
                    (Set.toList symbols)

-- æ„å»ºè§£æè¡¨
buildParseTables :: [LRState] -> [Production] -> Map.Map String (Set.Set String) -> (Map.Map (Int, String) Action, Map.Map (Int, String) Int)
buildParseTables states grammar followSets =
    let actionTable = Map.fromList (concatMap (\state -> buildActionEntries state grammar followSets) states)
        gotoTable = Map.fromList (concatMap (\state -> buildGotoEntries state grammar) states)
    in (actionTable, gotoTable)
  where
    buildActionEntries state grammar followSets =
        concatMap (\item ->
            let production = grammar !! production item
                right = right production
            in if dotPosition item < length right
               then case right !! dotPosition item of
                    Terminal term -> [(stateId state, term, Shift (findGotoState state term))]
                    _ -> []
               else if left production == "S'"
                    then [(stateId state, "$", Accept)]
                    else let follow = Map.findWithDefault Set.empty (left production) followSets
                         in [(stateId state, terminal, Reduce (production item)) | terminal <- Set.toList follow])
            (Set.toList (items state))

    buildGotoEntries state grammar =
        concatMap (\item ->
            let production = grammar !! production item
                right = right production
            in if dotPosition item < length right
               then case right !! dotPosition item of
                    NonTerminal nt -> [(stateId state, nt, findGotoState state nt)]
                    _ -> []
               else [])
            (Set.toList (items state))

    findGotoState state symbol =
        -- ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æŸ¥æ‰¾å¯¹åº”çš„GOTOçŠ¶æ€
        0

-- è§£æè¾“å…¥
parse :: LRParser -> [String] -> Either String [String]
parse parser input =
    let tokens = input ++ ["$"]
        initialStack = [0]
        initialSymbols = [EndMarker]
    in parseHelper parser tokens initialStack initialSymbols []
  where
    parseHelper _ [] _ _ _ = Left "Unexpected end of input"
    parseHelper _ _ [] _ _ = Left "Stack empty"
    parseHelper p (t:ts) (s:ss) symbols derivation =
        case Map.lookup (s, t) (actionTable p) of
            Just (Shift nextState) ->
                parseHelper p ts (nextState:s:ss) (Terminal t:symbols) derivation
            Just (Reduce productionIdx) ->
                let production = grammar p !! productionIdx
                    rightLen = length (right production)
                    newStack = drop rightLen (s:ss)
                    newSymbols = drop rightLen symbols
                    newSymbols' = NonTerminal (left production) : newSymbols
                    newDerivation = derivation ++ [left production ++ " -> " ++ symbolsToString (right production)]
                in parseHelper p (t:ts) newStack newSymbols' newDerivation
            Just Accept -> Right derivation
            Just Error -> Left $ "Parse error at token '" ++ t ++ "' in state " ++ show s
            Nothing -> Left $ "No action for token '" ++ t ++ "' in state " ++ show s

-- è¾…åŠ©å‡½æ•°
symbolsToString :: [Symbol] -> String
symbolsToString = unwords . map symbolToString
  where
    symbolToString (Terminal t) = t
    symbolToString (NonTerminal nt) = nt
    symbolToString Epsilon = "Îµ"
    symbolToString EndMarker = "$"

-- ç¤ºä¾‹ä½¿ç”¨
main :: IO ()
main = do
    putStrLn "LRè§£æç¤ºä¾‹ï¼š"

    -- ç®€å•çš„ç®—æœ¯è¡¨è¾¾å¼æ–‡æ³•
    let grammar = [
            Production "E" [NonTerminal "E", Terminal "+", NonTerminal "T"],
            Production "E" [NonTerminal "T"],
            Production "T" [NonTerminal "T", Terminal "*", NonTerminal "F"],
            Production "T" [NonTerminal "F"],
            Production "F" [Terminal "id"]
        ]

    let parser = newLRParser grammar

    let result = parse parser ["id", "+", "id", "*", "id"]
    case result of
        Right derivation -> do
            putStrLn "è§£ææˆåŠŸï¼š"
            mapM_ putStrLn derivation
        Left error -> putStrLn $ "è§£æé”™è¯¯: " ++ error
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç®—æœ¯è¡¨è¾¾å¼è§£æ

**é—®é¢˜**ï¼šè§£æåŒ…å«è¿ç®—ç¬¦ä¼˜å…ˆçº§çš„ç®—æœ¯è¡¨è¾¾å¼ã€‚

**è§£**ï¼š
ä½¿ç”¨LR(1)æ–‡æ³•ï¼š
```
E -> E + T | T
T -> T * F | F
F -> id | (E)
```

### 5.2 ç¼–ç¨‹è¯­è¨€è¯­æ³•åˆ†æ

**é—®é¢˜**ï¼šä¸ºå¤æ‚çš„ç¼–ç¨‹è¯­è¨€æ„å»ºè¯­æ³•åˆ†æå™¨ã€‚

**è§£**ï¼š
```rust
pub fn parse_program(input: &str) -> Result<AST, String> {
    let grammar = vec![
        // ç¨‹åº -> è¯­å¥åˆ—è¡¨
        Production {
            left: "Program".to_string(),
            right: vec![Symbol::NonTerminal("StmtList".to_string())],
        },
        // è¯­å¥åˆ—è¡¨ -> è¯­å¥ è¯­å¥åˆ—è¡¨ | Îµ
        Production {
            left: "StmtList".to_string(),
            right: vec![
                Symbol::NonTerminal("Statement".to_string()),
                Symbol::NonTerminal("StmtList".to_string()),
            ],
        },
        Production {
            left: "StmtList".to_string(),
            right: vec![Symbol::Epsilon],
        },
        // è¯­å¥ -> èµ‹å€¼ | æ¡ä»¶ | å¾ªç¯
        Production {
            left: "Statement".to_string(),
            right: vec![Symbol::NonTerminal("Assignment".to_string())],
        },
        // èµ‹å€¼ -> id = è¡¨è¾¾å¼ ;
        Production {
            left: "Assignment".to_string(),
            right: vec![
                Symbol::Terminal("id".to_string()),
                Symbol::Terminal("=".to_string()),
                Symbol::NonTerminal("Expression".to_string()),
                Symbol::Terminal(";".to_string()),
            ],
        },
    ];

    let parser = LRParser::new(grammar);
    parser.parse(input)
}
```

### 5.3 é…ç½®æ–‡ä»¶è§£æ

**é—®é¢˜**ï¼šè§£æå¤æ‚çš„é…ç½®æ–‡ä»¶æ ¼å¼ã€‚

**è§£**ï¼š
```rust
pub fn parse_config_file(content: &str) -> Result<Config, String> {
    let grammar = vec![
        // é…ç½® -> èŠ‚åˆ—è¡¨
        Production {
            left: "Config".to_string(),
            right: vec![Symbol::NonTerminal("SectionList".to_string())],
        },
        // èŠ‚åˆ—è¡¨ -> èŠ‚ èŠ‚åˆ—è¡¨ | Îµ
        Production {
            left: "SectionList".to_string(),
            right: vec![
                Symbol::NonTerminal("Section".to_string()),
                Symbol::NonTerminal("SectionList".to_string()),
            ],
        },
        Production {
            left: "SectionList".to_string(),
            right: vec![Symbol::Epsilon],
        },
        // èŠ‚ -> [èŠ‚å] é”®å€¼å¯¹åˆ—è¡¨
        Production {
            left: "Section".to_string(),
            right: vec![
                Symbol::Terminal("[".to_string()),
                Symbol::NonTerminal("SectionName".to_string()),
                Symbol::Terminal("]".to_string()),
                Symbol::NonTerminal("KeyValueList".to_string()),
            ],
        },
        // é”®å€¼å¯¹åˆ—è¡¨ -> é”®å€¼å¯¹ é”®å€¼å¯¹åˆ—è¡¨ | Îµ
        Production {
            left: "KeyValueList".to_string(),
            right: vec![
                Symbol::NonTerminal("KeyValue".to_string()),
                Symbol::NonTerminal("KeyValueList".to_string()),
            ],
        },
        Production {
            left: "KeyValueList".to_string(),
            right: vec![Symbol::Epsilon],
        },
        // é”®å€¼å¯¹ -> é”® = å€¼
        Production {
            left: "KeyValue".to_string(),
            right: vec![
                Symbol::NonTerminal("Key".to_string()),
                Symbol::Terminal("=".to_string()),
                Symbol::NonTerminal("Value".to_string()),
            ],
        },
    ];

    let parser = LRParser::new(grammar);
    parser.parse(content)
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å½¢å¼è¯­è¨€ç†è®ºçš„å…³ç³»

- **ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•**ï¼šLRè§£æçš„åŸºç¡€
- **ä¸‹æ¨è‡ªåŠ¨æœº**ï¼šLRè§£æå™¨çš„å®ç°æ¨¡å‹
- **ä¹”å§†æ–¯åŸºè°±ç³»**ï¼šLR(k)æ–‡æ³•çš„å±‚æ¬¡

### 6.2 ä¸ç¼–è¯‘åŸç†çš„å…³ç³»

- **è¯­æ³•åˆ†æ**ï¼šç¼–è¯‘å™¨å‰ç«¯çš„é‡è¦ç»„æˆéƒ¨åˆ†
- **é”™è¯¯æ¢å¤**ï¼šè¯­æ³•é”™è¯¯çš„æ£€æµ‹å’Œæ¢å¤
- **ä»£ç ç”Ÿæˆ**ï¼šè¯­æ³•æ ‘åˆ°ç›®æ ‡ä»£ç çš„è½¬æ¢

### 6.3 ä¸å…¶ä»–è§£ææ–¹æ³•çš„å…³ç³»

- **LLè§£æ**ï¼šè‡ªé¡¶å‘ä¸‹çš„è§£ææ–¹æ³•
- **é€’å½’ä¸‹é™**ï¼šLLè§£æçš„æ‰‹å·¥å®ç°
- **é¢„æµ‹è§£æ**ï¼šLLè§£æçš„å¦ä¸€ç§ç§°å‘¼

### 6.4 ä¸è½¯ä»¶å·¥ç¨‹çš„å…³ç³»

- **è§£æå™¨ç”Ÿæˆå™¨**ï¼šå¦‚Yaccã€Bisonç­‰å·¥å…·
- **é¢†åŸŸç‰¹å®šè¯­è¨€**ï¼šDSLçš„è¯­æ³•è®¾è®¡
- **é…ç½®æ–‡ä»¶è§£æ**ï¼šå„ç§æ ¼å¼çš„è§£æ

## 7. å‚è€ƒæ–‡çŒ®

1. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). *Compilers: Principles, Techniques, and Tools*. Pearson.
2. Grune, D., & Jacobs, C. J. (2008). *Parsing Techniques: A Practical Guide*. Springer.
3. Sippu, S., & Soisalon-Soininen, E. (1990). *Parsing Theory*. Springer.
4. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation*. Pearson.
5. Appel, A. W. (2002). *Modern Compiler Implementation*. Cambridge University Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [03.1.2 ä¸‹æ¨è‡ªåŠ¨æœº](../03_Formal_Language_Theory/03.1.2_ä¸‹æ¨è‡ªåŠ¨æœº.md)
- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03_Formal_Language_Theory/03.2.2_ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•.md)
- [03.4.1 LLè§£æ](../03_Formal_Language_Theory/03.4.1_LLè§£æ.md)
- [03.4.3 é€’å½’ä¸‹é™è§£æ](../03_Formal_Language_Theory/03.4.3_é€’å½’ä¸‹é™è§£æ.md)
- [04.1.1 ç®€å•ç±»å‹Î»æ¼”ç®—](../04_Type_Theory/04.1.1_ç®€å•ç±»å‹Î»æ¼”ç®—.md)
