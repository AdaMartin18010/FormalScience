# 03.4.2 LRè§£æç†è®º

## ğŸ“‹ æ¦‚è¿°

LRè§£ææ˜¯ä¸€ç§è‡ªåº•å‘ä¸Šçš„è¯­æ³•åˆ†ææ–¹æ³•ï¼Œèƒ½å¤Ÿå¤„ç†æ¯”LLè§£ææ›´å¹¿æ³›çš„ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•ã€‚LRè§£æå™¨é€šè¿‡ç»´æŠ¤ä¸€ä¸ªçŠ¶æ€æ ˆå’Œè¾“å…¥æ ˆï¼Œä½¿ç”¨çŠ¶æ€è½¬æ¢è¡¨æ¥å†³å®šä½•æ—¶è¿›è¡Œç§»è¿›ï¼ˆshiftï¼‰æˆ–å½’çº¦ï¼ˆreduceï¼‰æ“ä½œã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å½¢å¼åŒ–LRè§£æç®—æ³•**ï¼šå»ºç«‹ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œç®—æ³•æè¿°
2. **LRçŠ¶æ€æœºæ„é€ **ï¼šå®šä¹‰LR(0)ã€SLR(1)ã€LALR(1)ã€LR(1)ç­‰çŠ¶æ€æœº
3. **å†²çªå¤„ç†**ï¼šåˆ†æç§»è¿›-å½’çº¦å’Œå½’çº¦-å½’çº¦å†²çªçš„è§£å†³æ–¹æ³•
4. **å®ç°éªŒè¯**ï¼šæä¾›å®Œæ•´çš„Rustå®ç°å’Œå½¢å¼åŒ–è¯æ˜

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 LRè§£æçš„åŸºæœ¬æ€æƒ³

LRè§£ææ˜¯ä¸€ç§è‡ªåº•å‘ä¸Šçš„è¯­æ³•åˆ†ææ–¹æ³•ï¼Œå…¶æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š

1. **ç§»è¿›æ“ä½œ**ï¼šå°†è¾“å…¥ç¬¦å·å‹å…¥æ ˆä¸­
2. **å½’çº¦æ“ä½œ**ï¼šæ ¹æ®äº§ç”Ÿå¼è§„åˆ™å°†æ ˆé¡¶çš„ç¬¦å·åºåˆ—å½’çº¦ä¸ºéç»ˆç»“ç¬¦
3. **çŠ¶æ€ç®¡ç†**ï¼šä½¿ç”¨çŠ¶æ€æœºæ¥è·Ÿè¸ªè§£æè¿‡ç¨‹ä¸­çš„çŠ¶æ€ä¿¡æ¯

### 1.2 LRè§£æå™¨çš„ç»„æˆéƒ¨åˆ†

**å®šä¹‰ 1.2.1 (LRè§£æå™¨ç»“æ„)**
LRè§£æå™¨æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $\mathcal{P} = (Q, \Sigma, \Gamma, \delta, q_0)$ï¼Œå…¶ä¸­ï¼š

- $Q$ æ˜¯çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\Gamma$ æ˜¯æ ˆå­—æ¯è¡¨
- $\delta: Q \times \Sigma \times \Gamma^* \rightarrow Q \times \Gamma^*$ æ˜¯è½¬ç§»å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€

### 1.3 LRè§£æçš„é…ç½®

**å®šä¹‰ 1.2.2 (LRé…ç½®)**
LRè§£æçš„é…ç½®æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(q, \alpha, \beta)$ï¼Œå…¶ä¸­ï¼š

- $q \in Q$ æ˜¯å½“å‰çŠ¶æ€
- $\alpha \in \Gamma^*$ æ˜¯æ ˆå†…å®¹
- $\beta \in \Sigma^*$ æ˜¯å‰©ä½™è¾“å…¥

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 LR(0)é¡¹ç›®

**å®šä¹‰ 2.1.1 (LR(0)é¡¹ç›®)**
LR(0)é¡¹ç›®æ˜¯å½¢å¦‚ $A \rightarrow \alpha \cdot \beta$ çš„è¡¨è¾¾å¼ï¼Œå…¶ä¸­ï¼š

- $A \rightarrow \alpha\beta$ æ˜¯æ–‡æ³•äº§ç”Ÿå¼
- $\cdot$ æ˜¯é¡¹ç›®æ ‡è®°ï¼Œè¡¨ç¤ºè§£æä½ç½®

**å®šä¹‰ 2.1.2 (é¡¹ç›®é—­åŒ…)**
é¡¹ç›® $I$ çš„é—­åŒ… $\text{CLOSURE}(I)$ æ˜¯æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„æœ€å°é¡¹ç›®é›†ï¼š

1. $I \subseteq \text{CLOSURE}(I)$
2. å¦‚æœ $A \rightarrow \alpha \cdot B\beta \in \text{CLOSURE}(I)$ ä¸” $B \rightarrow \gamma$ æ˜¯äº§ç”Ÿå¼ï¼Œåˆ™ $B \rightarrow \cdot\gamma \in \text{CLOSURE}(I)$

**å®šç† 2.1.1 (é—­åŒ…æ€§è´¨)**
é¡¹ç›®é—­åŒ…è¿ç®—æ»¡è¶³ï¼š

1. **å•è°ƒæ€§**ï¼š$I \subseteq \text{CLOSURE}(I)$
2. **å¹‚ç­‰æ€§**ï¼š$\text{CLOSURE}(\text{CLOSURE}(I)) = \text{CLOSURE}(I)$
3. **å•è°ƒæ€§**ï¼š$I \subseteq J \Rightarrow \text{CLOSURE}(I) \subseteq \text{CLOSURE}(J)$

**è¯æ˜ï¼š**

1. **å•è°ƒæ€§**ï¼šç”±å®šä¹‰ç›´æ¥å¾—åˆ°
2. **å¹‚ç­‰æ€§**ï¼šé€šè¿‡å½’çº³æ³•è¯æ˜ï¼Œæ‰€æœ‰æ–°åŠ å…¥çš„é¡¹ç›®éƒ½å·²åœ¨é—­åŒ…ä¸­
3. **å•è°ƒæ€§**ï¼šé€šè¿‡å½’çº³æ³•è¯æ˜ï¼Œ$J$ çš„é—­åŒ…åŒ…å« $I$ çš„é—­åŒ…

### 2.2 GOTOå‡½æ•°

**å®šä¹‰ 2.2.1 (GOTOå‡½æ•°)**
å¯¹äºé¡¹ç›®é›† $I$ å’Œç¬¦å· $X$ï¼ŒGOTOå‡½æ•°å®šä¹‰ä¸ºï¼š
$$\text{GOTO}(I, X) = \text{CLOSURE}(\{A \rightarrow \alpha X \cdot \beta \mid A \rightarrow \alpha \cdot X\beta \in I\})$$

**å®šç† 2.2.1 (GOTOæ€§è´¨)**
GOTOå‡½æ•°æ»¡è¶³ï¼š

1. **ç¡®å®šæ€§**ï¼šå¯¹äºç»™å®šçš„ $I$ å’Œ $X$ï¼Œ$\text{GOTO}(I, X)$ æ˜¯å”¯ä¸€çš„
2. **å•è°ƒæ€§**ï¼š$I \subseteq J \Rightarrow \text{GOTO}(I, X) \subseteq \text{GOTO}(J, X)$

### 2.3 LR(0)çŠ¶æ€æœºæ„é€ 

**ç®—æ³• 2.3.1 (LR(0)çŠ¶æ€æœºæ„é€ )**:

```rust
fn construct_lr0_automaton(grammar: &Grammar) -> LR0Automaton {
    let mut states = Vec::new();
    let mut transitions = HashMap::new();
    
    // åˆå§‹é¡¹ç›®é›†
    let initial_items = closure(&[Item::new(grammar.start_symbol(), 0, 0)]);
    states.push(initial_items.clone());
    
    let mut unprocessed = vec![0];
    
    while let Some(state_id) = unprocessed.pop() {
        let current_state = &states[state_id];
        
        // å¯¹æ¯ä¸ªç¬¦å·è®¡ç®—GOTO
        for symbol in grammar.all_symbols() {
            let goto_items = goto(current_state, symbol);
            
            if !goto_items.is_empty() {
                let next_state_id = find_or_add_state(&mut states, goto_items);
                transitions.insert((state_id, symbol), next_state_id);
                
                if next_state_id == states.len() - 1 {
                    unprocessed.push(next_state_id);
                }
            }
        }
    }
    
    LR0Automaton { states, transitions }
}
```

## 3. å®šç†ä¸è¯æ˜

### 3.1 LR(0)è§£æçš„æ­£ç¡®æ€§

**å®šç† 3.1.1 (LR(0)è§£ææ­£ç¡®æ€§)**
å¦‚æœæ–‡æ³• $G$ æ˜¯LR(0)æ–‡æ³•ï¼Œåˆ™LR(0)è§£æå™¨èƒ½å¤Ÿæ­£ç¡®è¯†åˆ« $L(G)$ ä¸­çš„æ‰€æœ‰å¥å­ã€‚

**è¯æ˜ï¼š**
é€šè¿‡å½’çº³æ³•è¯æ˜ï¼š

1. **åŸºç¡€æƒ…å†µ**ï¼šç©ºä¸²çš„è§£æ
2. **å½’çº³æ­¥éª¤**ï¼šå‡è®¾å¯¹äºé•¿åº¦å°äº $n$ çš„ä¸²æˆç«‹ï¼Œè¯æ˜å¯¹äºé•¿åº¦ä¸º $n$ çš„ä¸²ä¹Ÿæˆç«‹
3. **ç§»è¿›æ“ä½œ**ï¼šä¿æŒè§£æçŠ¶æ€çš„ä¸€è‡´æ€§
4. **å½’çº¦æ“ä½œ**ï¼šä½¿ç”¨æ­£ç¡®çš„äº§ç”Ÿå¼è¿›è¡Œå½’çº¦

### 3.2 å†²çªåˆ†æ

**å®šä¹‰ 3.2.1 (ç§»è¿›-å½’çº¦å†²çª)**
åœ¨çŠ¶æ€ $q$ ä¸­å­˜åœ¨ç§»è¿›-å½’çº¦å†²çªï¼Œå¦‚æœå­˜åœ¨ï¼š

- ç§»è¿›é¡¹ç›®ï¼š$A \rightarrow \alpha \cdot a\beta$
- å½’çº¦é¡¹ç›®ï¼š$B \rightarrow \gamma \cdot$

**å®šä¹‰ 3.2.2 (å½’çº¦-å½’çº¦å†²çª)**
åœ¨çŠ¶æ€ $q$ ä¸­å­˜åœ¨å½’çº¦-å½’çº¦å†²çªï¼Œå¦‚æœå­˜åœ¨ä¸¤ä¸ªä¸åŒçš„å½’çº¦é¡¹ç›®ï¼š

- $A \rightarrow \alpha \cdot$
- $B \rightarrow \beta \cdot$

**å®šç† 3.2.1 (å†²çªæ£€æµ‹)**
LR(0)çŠ¶æ€æœºä¸­çš„å†²çªå¯ä»¥é€šè¿‡æ£€æŸ¥æ¯ä¸ªçŠ¶æ€çš„é¡¹ç›®é›†æ¥æ£€æµ‹ã€‚

**è¯æ˜ï¼š**

1. **ç§»è¿›-å½’çº¦å†²çª**ï¼šæ£€æŸ¥æ˜¯å¦å­˜åœ¨åŒæ—¶åŒ…å«ç§»è¿›å’Œå½’çº¦é¡¹ç›®çš„çŠ¶æ€
2. **å½’çº¦-å½’çº¦å†²çª**ï¼šæ£€æŸ¥æ˜¯å¦å­˜åœ¨åŒ…å«å¤šä¸ªå½’çº¦é¡¹ç›®çš„çŠ¶æ€
3. **å†²çªæ£€æµ‹**ï¼šé€šè¿‡é¡¹ç›®é›†åˆ†æå¯ä»¥æ£€æµ‹æ‰€æœ‰å†²çª

### 3.3 SLR(1)è§£æ

**å®šä¹‰ 3.3.1 (SLR(1)è§£æ)**
SLR(1)è§£æé€šè¿‡ä½¿ç”¨FOLLOWé›†æ¥è§£å†³LR(0)å†²çªï¼š

- å¯¹äºå½’çº¦é¡¹ç›® $A \rightarrow \alpha \cdot$ï¼Œåªæœ‰å½“ä¸‹ä¸€ä¸ªè¾“å…¥ç¬¦å·åœ¨ $\text{FOLLOW}(A)$ ä¸­æ—¶æ‰è¿›è¡Œå½’çº¦
- å¯¹äºç§»è¿›é¡¹ç›® $A \rightarrow \alpha \cdot a\beta$ï¼Œå½“è¾“å…¥ç¬¦å·ä¸º $a$ æ—¶è¿›è¡Œç§»è¿›

**å®šç† 3.3.1 (SLR(1)å†²çªè§£å†³)**
å¦‚æœæ–‡æ³• $G$ æ˜¯SLR(1)æ–‡æ³•ï¼Œåˆ™SLR(1)è§£æå™¨èƒ½å¤Ÿè§£å†³æ‰€æœ‰LR(0)å†²çªã€‚

**è¯æ˜ï¼š**

1. **FOLLOWé›†æ€§è´¨**ï¼šFOLLOWé›†æä¾›äº†è¶³å¤Ÿçš„å‘å‰çœ‹ä¿¡æ¯
2. **å†²çªè§£å†³**ï¼šé€šè¿‡FOLLOWé›†å¯ä»¥åŒºåˆ†ç§»è¿›å’Œå½’çº¦æ“ä½œ
3. **æ­£ç¡®æ€§**ï¼šSLR(1)è§£æå™¨ä¿æŒäº†è§£æçš„æ­£ç¡®æ€§

## 4. ä»£ç å®ç°

### 4.1 LRè§£æå™¨æ ¸å¿ƒå®ç°

```rust
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Item {
    pub production_id: usize,
    pub dot_position: usize,
    pub lookahead: Option<String>,
}

impl Item {
    pub fn new(production_id: usize, dot_position: usize) -> Self {
        Self {
            production_id,
            dot_position,
            lookahead: None,
        }
    }
    
    pub fn with_lookahead(mut self, lookahead: String) -> Self {
        self.lookahead = Some(lookahead);
        self
    }
    
    pub fn is_reduce_item(&self, grammar: &Grammar) -> bool {
        let production = &grammar.productions[self.production_id];
        self.dot_position == production.rhs.len()
    }
    
    pub fn is_shift_item(&self, grammar: &Grammar) -> bool {
        !self.is_reduce_item(grammar)
    }
    
    pub fn next_symbol(&self, grammar: &Grammar) -> Option<&Symbol> {
        let production = &grammar.productions[self.production_id];
        production.rhs.get(self.dot_position)
    }
}

#[derive(Debug)]
pub struct LR0Automaton {
    pub states: Vec<HashSet<Item>>,
    pub transitions: HashMap<(usize, Symbol), usize>,
    pub actions: HashMap<(usize, String), Action>,
}

#[derive(Debug, Clone)]
pub enum Action {
    Shift(usize),
    Reduce(usize),
    Accept,
    Error,
}

impl LR0Automaton {
    pub fn new(grammar: &Grammar) -> Self {
        let mut automaton = Self {
            states: Vec::new(),
            transitions: HashMap::new(),
            actions: HashMap::new(),
        };
        
        automaton.construct_states(grammar);
        automaton.construct_actions(grammar);
        
        automaton
    }
    
    fn construct_states(&mut self, grammar: &Grammar) {
        // åˆå§‹é¡¹ç›®é›†
        let initial_item = Item::new(0, 0); // å‡è®¾å¼€å§‹äº§ç”Ÿå¼IDä¸º0
        let initial_items = self.closure(&[initial_item], grammar);
        self.states.push(initial_items);
        
        let mut unprocessed = vec![0];
        
        while let Some(state_id) = unprocessed.pop() {
            let current_state = &self.states[state_id];
            
            // å¯¹æ¯ä¸ªç¬¦å·è®¡ç®—GOTO
            for symbol in grammar.all_symbols() {
                let goto_items = self.goto(current_state, &symbol, grammar);
                
                if !goto_items.is_empty() {
                    let next_state_id = self.find_or_add_state(goto_items);
                    self.transitions.insert((state_id, symbol.clone()), next_state_id);
                    
                    if next_state_id == self.states.len() - 1 {
                        unprocessed.push(next_state_id);
                    }
                }
            }
        }
    }
    
    fn closure(&self, items: &[Item], grammar: &Grammar) -> HashSet<Item> {
        let mut closure = HashSet::new();
        let mut unprocessed: Vec<Item> = items.to_vec();
        
        while let Some(item) = unprocessed.pop() {
            if closure.insert(item.clone()) {
                // å¦‚æœé¡¹ç›®æ˜¯ A -> Î±Â·BÎ² å½¢å¼ï¼Œæ·»åŠ æ‰€æœ‰ B -> Â·Î³ é¡¹ç›®
                if let Some(next_symbol) = item.next_symbol(grammar) {
                    if let Symbol::NonTerminal(nt) = next_symbol {
                        for (prod_id, production) in grammar.productions.iter().enumerate() {
                            if production.lhs == *nt {
                                let new_item = Item::new(prod_id, 0);
                                unprocessed.push(new_item);
                            }
                        }
                    }
                }
            }
        }
        
        closure
    }
    
    fn goto(&self, items: &HashSet<Item>, symbol: &Symbol, grammar: &Grammar) -> HashSet<Item> {
        let mut goto_items = HashSet::new();
        
        for item in items {
            if let Some(next_symbol) = item.next_symbol(grammar) {
                if next_symbol == symbol {
                    let new_item = Item::new(item.production_id, item.dot_position + 1);
                    goto_items.insert(new_item);
                }
            }
        }
        
        self.closure(&goto_items.into_iter().collect::<Vec<_>>(), grammar)
    }
    
    fn find_or_add_state(&mut self, items: HashSet<Item>) -> usize {
        for (state_id, state) in self.states.iter().enumerate() {
            if state == &items {
                return state_id;
            }
        }
        
        self.states.push(items);
        self.states.len() - 1
    }
    
    fn construct_actions(&mut self, grammar: &Grammar) {
        for (state_id, state) in self.states.iter().enumerate() {
            for item in state {
                if item.is_reduce_item(grammar) {
                    // å½’çº¦åŠ¨ä½œ
                    if item.production_id == 0 {
                        // æ¥å—åŠ¨ä½œ
                        self.actions.insert((state_id, "$".to_string()), Action::Accept);
                    } else {
                        // å½’çº¦åŠ¨ä½œ
                        let production = &grammar.productions[item.production_id];
                        for symbol in grammar.follow(&production.lhs) {
                            self.actions.insert((state_id, symbol), Action::Reduce(item.production_id));
                        }
                    }
                } else if item.is_shift_item(grammar) {
                    // ç§»è¿›åŠ¨ä½œ
                    if let Some(next_symbol) = item.next_symbol(grammar) {
                        if let Symbol::Terminal(term) = next_symbol {
                            if let Some(&next_state) = self.transitions.get(&(state_id, next_symbol.clone())) {
                                self.actions.insert((state_id, term.clone()), Action::Shift(next_state));
                            }
                        }
                    }
                }
            }
        }
    }
    
    pub fn parse(&self, input: &[String]) -> Result<Vec<usize>, String> {
        let mut stack = vec![0]; // çŠ¶æ€æ ˆ
        let mut input_pos = 0;
        let mut parse_tree = Vec::new();
        
        loop {
            let current_state = stack.last().unwrap();
            let current_input = if input_pos < input.len() {
                &input[input_pos]
            } else {
                "$"
            };
            
            match self.actions.get(&(*current_state, current_input.to_string())) {
                Some(Action::Shift(next_state)) => {
                    stack.push(*next_state);
                    input_pos += 1;
                }
                Some(Action::Reduce(production_id)) => {
                    let production = &grammar.productions[*production_id];
                    let rhs_len = production.rhs.len();
                    
                    // å¼¹å‡ºçŠ¶æ€æ ˆä¸­çš„çŠ¶æ€
                    for _ in 0..rhs_len {
                        stack.pop();
                    }
                    
                    // å‹å…¥å½’çº¦åçš„çŠ¶æ€
                    let current_state = stack.last().unwrap();
                    if let Some(&next_state) = self.transitions.get(&(*current_state, Symbol::NonTerminal(production.lhs.clone()))) {
                        stack.push(next_state);
                    }
                    
                    parse_tree.push(*production_id);
                }
                Some(Action::Accept) => {
                    return Ok(parse_tree);
                }
                Some(Action::Error) | None => {
                    return Err(format!("Parse error at position {}", input_pos));
                }
            }
        }
    }
}
```

### 4.2 æ–‡æ³•å®šä¹‰

```rust
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Symbol {
    Terminal(String),
    NonTerminal(String),
}

#[derive(Debug)]
pub struct Production {
    pub lhs: String,
    pub rhs: Vec<Symbol>,
}

#[derive(Debug)]
pub struct Grammar {
    pub start_symbol: String,
    pub productions: Vec<Production>,
}

impl Grammar {
    pub fn new(start_symbol: String) -> Self {
        Self {
            start_symbol,
            productions: Vec::new(),
        }
    }
    
    pub fn add_production(&mut self, lhs: String, rhs: Vec<Symbol>) {
        self.productions.push(Production { lhs, rhs });
    }
    
    pub fn all_symbols(&self) -> HashSet<Symbol> {
        let mut symbols = HashSet::new();
        
        for production in &self.productions {
            symbols.insert(Symbol::NonTerminal(production.lhs.clone()));
            for symbol in &production.rhs {
                symbols.insert(symbol.clone());
            }
        }
        
        symbols
    }
    
    pub fn first(&self, symbol: &str) -> HashSet<String> {
        let mut first = HashSet::new();
        
        if let Some(production) = self.productions.iter().find(|p| p.lhs == symbol) {
            if let Some(first_symbol) = production.rhs.first() {
                match first_symbol {
                    Symbol::Terminal(term) => {
                        first.insert(term.clone());
                    }
                    Symbol::NonTerminal(nt) => {
                        first.extend(self.first(nt));
                    }
                }
            }
        }
        
        first
    }
    
    pub fn follow(&self, symbol: &str) -> HashSet<String> {
        let mut follow = HashSet::new();
        
        if symbol == &self.start_symbol {
            follow.insert("$".to_string());
        }
        
        for production in &self.productions {
            for (i, rhs_symbol) in production.rhs.iter().enumerate() {
                if let Symbol::NonTerminal(nt) = rhs_symbol {
                    if nt == symbol {
                        if i + 1 < production.rhs.len() {
                            // ä¸‹ä¸€ä¸ªç¬¦å·çš„FIRSTé›†
                            let next_symbol = &production.rhs[i + 1];
                            match next_symbol {
                                Symbol::Terminal(term) => {
                                    follow.insert(term.clone());
                                }
                                Symbol::NonTerminal(nt2) => {
                                    follow.extend(self.first(nt2));
                                }
                            }
                        } else {
                            // äº§ç”Ÿå¼å³éƒ¨æœ«å°¾ï¼Œæ·»åŠ FOLLOW(å·¦éƒ¨)
                            follow.extend(self.follow(&production.lhs));
                        }
                    }
                }
            }
        }
        
        follow
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç®€å•ç®—æœ¯è¡¨è¾¾å¼æ–‡æ³•

```rust
fn create_arithmetic_grammar() -> Grammar {
    let mut grammar = Grammar::new("E".to_string());
    
    // E -> E + T | T
    grammar.add_production("E".to_string(), vec![
        Symbol::NonTerminal("E".to_string()),
        Symbol::Terminal("+".to_string()),
        Symbol::NonTerminal("T".to_string()),
    ]);
    grammar.add_production("E".to_string(), vec![
        Symbol::NonTerminal("T".to_string()),
    ]);
    
    // T -> T * F | F
    grammar.add_production("T".to_string(), vec![
        Symbol::NonTerminal("T".to_string()),
        Symbol::Terminal("*".to_string()),
        Symbol::NonTerminal("F".to_string()),
    ]);
    grammar.add_production("T".to_string(), vec![
        Symbol::NonTerminal("F".to_string()),
    ]);
    
    // F -> (E) | id
    grammar.add_production("F".to_string(), vec![
        Symbol::Terminal("(".to_string()),
        Symbol::NonTerminal("E".to_string()),
        Symbol::Terminal(")".to_string()),
    ]);
    grammar.add_production("F".to_string(), vec![
        Symbol::Terminal("id".to_string()),
    ]);
    
    grammar
}

#[test]
fn test_arithmetic_parsing() {
    let grammar = create_arithmetic_grammar();
    let automaton = LR0Automaton::new(&grammar);
    
    let input = vec!["id".to_string(), "+".to_string(), "id".to_string(), "*".to_string(), "id".to_string()];
    let result = automaton.parse(&input);
    
    assert!(result.is_ok());
    println!("Parse tree: {:?}", result.unwrap());
}
```

### 5.2 å†²çªæ£€æµ‹ç¤ºä¾‹

```rust
fn detect_conflicts(automaton: &LR0Automaton, grammar: &Grammar) -> Vec<String> {
    let mut conflicts = Vec::new();
    
    for (state_id, state) in automaton.states.iter().enumerate() {
        let mut shift_items = Vec::new();
        let mut reduce_items = Vec::new();
        
        for item in state {
            if item.is_shift_item(grammar) {
                if let Some(symbol) = item.next_symbol(grammar) {
                    if let Symbol::Terminal(term) = symbol {
                        shift_items.push(term.clone());
                    }
                }
            } else if item.is_reduce_item(grammar) {
                let production = &grammar.productions[item.production_id];
                reduce_items.push(production.lhs.clone());
            }
        }
        
        // æ£€æµ‹ç§»è¿›-å½’çº¦å†²çª
        for shift_term in &shift_items {
            for reduce_nt in &reduce_items {
                let follow_set = grammar.follow(reduce_nt);
                if follow_set.contains(shift_term) {
                    conflicts.push(format!(
                        "Shift-Reduce conflict in state {}: shift '{}' vs reduce '{}'",
                        state_id, shift_term, reduce_nt
                    ));
                }
            }
        }
        
        // æ£€æµ‹å½’çº¦-å½’çº¦å†²çª
        if reduce_items.len() > 1 {
            conflicts.push(format!(
                "Reduce-Reduce conflict in state {}: multiple reduce items",
                state_id
            ));
        }
    }
    
    conflicts
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å…¶ä»–è§£ææ–¹æ³•çš„æ¯”è¾ƒ

| è§£ææ–¹æ³• | å‘å‰çœ‹ç¬¦å·æ•° | æ–‡æ³•ç±» | çŠ¶æ€æ•° | å®ç°å¤æ‚åº¦ |
|---------|-------------|--------|--------|-----------|
| LR(0) | 0 | æœ‰é™ | æœ€å°‘ | ç®€å• |
| SLR(1) | 1 | è¾ƒå¹¿ | è¾ƒå°‘ | ä¸­ç­‰ |
| LALR(1) | 1 | æ›´å¹¿ | ä¸­ç­‰ | å¤æ‚ |
| LR(1) | 1 | æœ€å¹¿ | æœ€å¤š | æœ€å¤æ‚ |

### 6.2 LRè§£æçš„å±€é™æ€§

1. **çŠ¶æ€çˆ†ç‚¸**ï¼šLR(1)è§£æå™¨çš„çŠ¶æ€æ•°å¯èƒ½æŒ‡æ•°çº§å¢é•¿
2. **å†²çªå¤„ç†**ï¼šæŸäº›æ–‡æ³•æ— æ³•é€šè¿‡ç®€å•çš„å‘å‰çœ‹è§£å†³å†²çª
3. **é”™è¯¯æ¢å¤**ï¼šLRè§£æå™¨çš„é”™è¯¯æ¢å¤æœºåˆ¶ç›¸å¯¹å¤æ‚

### 6.3 ä¼˜åŒ–æŠ€æœ¯

1. **çŠ¶æ€åˆå¹¶**ï¼šLALR(1)é€šè¿‡åˆå¹¶ç›¸ä¼¼çŠ¶æ€å‡å°‘çŠ¶æ€æ•°
2. **è¡¨å‹ç¼©**ï¼šä½¿ç”¨å„ç§æŠ€æœ¯å‹ç¼©è§£æè¡¨å¤§å°
3. **å¢é‡è§£æ**ï¼šæ”¯æŒå¢é‡æ›´æ–°è§£æè¡¨

## 7. å‚è€ƒæ–‡çŒ®

1. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). Compilers: Principles, Techniques, and Tools (2nd ed.). Pearson Education.
2. Knuth, D. E. (1965). On the translation of languages from left to right. Information and Control, 8(6), 607-639.
3. DeRemer, F. L. (1969). Practical translators for LR(k) languages. PhD thesis, MIT.
4. Pager, D. (1977). A practical general method for constructing LR(k) parsers. Acta Informatica, 7(3), 249-268.
5. é¾™ä¹¦ (Dragon Book) - ç¼–è¯‘å™¨è®¾è®¡åŸç†ä¸å®è·µ
