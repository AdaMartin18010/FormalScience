# åŒæ­¥ç†è®º

## ğŸ“‹ ç›®å½•

- [åŒæ­¥ç†è®º](#åŒæ­¥ç†è®º)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ç†è®ºåŸºç¡€](#1-ç†è®ºåŸºç¡€)
    - [1.1 å†å²èƒŒæ™¯](#11-å†å²èƒŒæ™¯)
    - [1.2 ç†è®ºåŸºç¡€](#12-ç†è®ºåŸºç¡€)
  - [2. åŸºæœ¬æ¦‚å¿µ](#2-åŸºæœ¬æ¦‚å¿µ)
    - [2.1 åŒæ­¥äº‹ä»¶](#21-åŒæ­¥äº‹ä»¶)
    - [2.2 åŒæ­¥å…³ç³»](#22-åŒæ­¥å…³ç³»)
    - [2.3 åŒæ­¥çŠ¶æ€](#23-åŒæ­¥çŠ¶æ€)
  - [3. è¯­æ³•å®šä¹‰](#3-è¯­æ³•å®šä¹‰)
    - [3.1 åŸºæœ¬è¯­æ³•](#31-åŸºæœ¬è¯­æ³•)
    - [3.2 åŒæ­¥åŸè¯­](#32-åŒæ­¥åŸè¯­)
  - [4. è¯­ä¹‰å®šä¹‰](#4-è¯­ä¹‰å®šä¹‰)
    - [4.1 æ“ä½œè¯­ä¹‰](#41-æ“ä½œè¯­ä¹‰)
    - [4.2 åŒæ­¥è¯­ä¹‰](#42-åŒæ­¥è¯­ä¹‰)
  - [5. ç­‰ä»·å…³ç³»](#5-ç­‰ä»·å…³ç³»)
    - [5.1 åŒæ­¥ç­‰ä»·](#51-åŒæ­¥ç­‰ä»·)
    - [5.2 è§‚å¯Ÿç­‰ä»·](#52-è§‚å¯Ÿç­‰ä»·)
  - [6. æ ¸å¿ƒå®šç†](#6-æ ¸å¿ƒå®šç†)
    - [6.1 ç­‰ä»·æ€§å®šç†](#61-ç­‰ä»·æ€§å®šç†)
    - [6.2 åŒæ­¥æ€§è´¨å®šç†](#62-åŒæ­¥æ€§è´¨å®šç†)
    - [6.3 ç»„åˆæ€§å®šç†](#63-ç»„åˆæ€§å®šç†)
  - [7. åº”ç”¨é¢†åŸŸ](#7-åº”ç”¨é¢†åŸŸ)
    - [7.1 æ“ä½œç³»ç»Ÿ](#71-æ“ä½œç³»ç»Ÿ)
    - [7.2 åˆ†å¸ƒå¼ç³»ç»Ÿ](#72-åˆ†å¸ƒå¼ç³»ç»Ÿ)
    - [7.3 å¹¶å‘ç¼–ç¨‹](#73-å¹¶å‘ç¼–ç¨‹)
  - [8. ä»£ç å®ç°](#8-ä»£ç å®ç°)
    - [8.1 Rustå®ç°](#81-rustå®ç°)
    - [8.2 Haskellå®ç°](#82-haskellå®ç°)
  - [9. å½¢å¼åŒ–è¯æ˜](#9-å½¢å¼åŒ–è¯æ˜)
    - [9.1 Leanè¯æ˜](#91-leanè¯æ˜)
  - [10. å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)

## 1. ç†è®ºåŸºç¡€

### 1.1 å†å²èƒŒæ™¯

åŒæ­¥ç†è®ºï¼ˆSynchronization Theoryï¼‰æ˜¯å¹¶å‘ç†è®ºçš„æ ¸å¿ƒåˆ†æ”¯ï¼Œèµ·æºäºå¯¹å¹¶å‘ç³»ç»Ÿä¸­è¿›ç¨‹åè°ƒå’ŒåŒæ­¥æœºåˆ¶çš„ç ”ç©¶ã€‚å®ƒä¸ºæè¿°å’Œåˆ†æå¹¶å‘ç³»ç»Ÿçš„åŒæ­¥è¡Œä¸ºæä¾›äº†å½¢å¼åŒ–æ¡†æ¶ã€‚

### 1.2 ç†è®ºåŸºç¡€

**å®šä¹‰ 1.1** (åŒæ­¥æ¦‚å¿µ)
åŒæ­¥æ˜¯å¹¶å‘ç³»ç»Ÿä¸­å¤šä¸ªè¿›ç¨‹æˆ–çº¿ç¨‹ä¹‹é—´çš„åè°ƒæœºåˆ¶ï¼Œç¡®ä¿å®ƒä»¬æŒ‰ç…§é¢„å®šçš„é¡ºåºå’Œæ—¶é—´å…³ç³»æ‰§è¡Œã€‚

**å…¬ç† 1.1** (åŒæ­¥ä¸€è‡´æ€§å…¬ç†)
åŒæ­¥æœºåˆ¶å¿…é¡»ä¿è¯ç³»ç»ŸçŠ¶æ€çš„ä¸€è‡´æ€§ã€‚

**å…¬ç† 1.2** (åŒæ­¥å…¬å¹³æ€§å…¬ç†)
åŒæ­¥æœºåˆ¶å¿…é¡»ä¿è¯æ‰€æœ‰è¿›ç¨‹éƒ½æœ‰å…¬å¹³çš„æ‰§è¡Œæœºä¼šã€‚

## 2. åŸºæœ¬æ¦‚å¿µ

### 2.1 åŒæ­¥äº‹ä»¶

**å®šä¹‰ 2.1** (åŒæ­¥äº‹ä»¶)
åŒæ­¥äº‹ä»¶ $e$ æ˜¯ä¸€ä¸ªåŸå­æ“ä½œï¼Œè¡¨ç¤ºä¸ºï¼š
$$e = (type, participants, condition)$$

å…¶ä¸­ï¼š

- $type$ æ˜¯äº‹ä»¶ç±»å‹ï¼ˆå¦‚ä¿¡å·ã€ç­‰å¾…ã€å±éšœç­‰ï¼‰
- $participants$ æ˜¯å‚ä¸è¿›ç¨‹é›†åˆ
- $condition$ æ˜¯åŒæ­¥æ¡ä»¶

### 2.2 åŒæ­¥å…³ç³»

**å®šä¹‰ 2.2** (åŒæ­¥å…³ç³»)
åŒæ­¥å…³ç³» $R$ å®šä¹‰äº†äº‹ä»¶ä¹‹é—´çš„ä¾èµ–å…³ç³»ï¼š
$$R \subseteq E \times E$$

å…¶ä¸­ $E$ æ˜¯äº‹ä»¶é›†åˆã€‚

### 2.3 åŒæ­¥çŠ¶æ€

**å®šä¹‰ 2.3** (åŒæ­¥çŠ¶æ€)
åŒæ­¥çŠ¶æ€ $s$ æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(P, E, C)$ï¼Œå…¶ä¸­ï¼š

- $P$ æ˜¯è¿›ç¨‹çŠ¶æ€é›†åˆ
- $E$ æ˜¯äº‹ä»¶çŠ¶æ€é›†åˆ
- $C$ æ˜¯çº¦æŸæ¡ä»¶é›†åˆ

## 3. è¯­æ³•å®šä¹‰

### 3.1 åŸºæœ¬è¯­æ³•

**å®šä¹‰ 3.1** (åŒæ­¥è¡¨è¾¾å¼è¯­æ³•)
åŒæ­¥è¡¨è¾¾å¼çš„è¯­æ³•å®šä¹‰å¦‚ä¸‹ï¼š

$$S ::= \epsilon \mid e \mid S_1 \parallel S_2 \mid S_1; S_2 \mid S_1 + S_2 \mid S^* \mid \text{wait}(c) \mid \text{signal}(c)$$

å…¶ä¸­ï¼š

- $\epsilon$ï¼šç©ºåŒæ­¥
- $e$ï¼šåŒæ­¥äº‹ä»¶
- $S_1 \parallel S_2$ï¼šå¹¶å‘åŒæ­¥
- $S_1; S_2$ï¼šé¡ºåºåŒæ­¥
- $S_1 + S_2$ï¼šé€‰æ‹©åŒæ­¥
- $S^*$ï¼šé‡å¤åŒæ­¥
- $\text{wait}(c)$ï¼šç­‰å¾…æ¡ä»¶
- $\text{signal}(c)$ï¼šå‘é€ä¿¡å·

### 3.2 åŒæ­¥åŸè¯­

**å®šä¹‰ 3.2** (åŒæ­¥åŸè¯­)
åŒæ­¥åŸè¯­åŒ…æ‹¬ï¼š

- **ä¿¡å·é‡**ï¼š$P(s), V(s)$
- **äº’æ–¥é”**ï¼š$\text{lock}(m), \text{unlock}(m)$
- **æ¡ä»¶å˜é‡**ï¼š$\text{wait}(cv), \text{signal}(cv)$
- **å±éšœ**ï¼š$\text{barrier}(b)$
- **è¯»å†™é”**ï¼š$\text{readlock}(rw), \text{writelock}(rw)$

## 4. è¯­ä¹‰å®šä¹‰

### 4.1 æ“ä½œè¯­ä¹‰

**å®šä¹‰ 4.1** (åŒæ­¥æ‰§è¡Œ)
åŒæ­¥æ‰§è¡Œå…³ç³» $\xrightarrow{e}$ å®šä¹‰å¦‚ä¸‹ï¼š

**äº‹ä»¶æ‰§è¡Œ**ï¼š
$$\frac{}{e \xrightarrow{e} \epsilon}$$

**å¹¶å‘æ‰§è¡Œ**ï¼š
$$\frac{S_1 \xrightarrow{e} S_1'}{S_1 \parallel S_2 \xrightarrow{e} S_1' \parallel S_2} \quad \frac{S_2 \xrightarrow{e} S_2'}{S_1 \parallel S_2 \xrightarrow{e} S_1 \parallel S_2'}$$

**é¡ºåºæ‰§è¡Œ**ï¼š
$$\frac{S_1 \xrightarrow{e} S_1'}{S_1; S_2 \xrightarrow{e} S_1'; S_2}$$

### 4.2 åŒæ­¥è¯­ä¹‰

**å®šä¹‰ 4.2** (åŒæ­¥æ»¡è¶³)
åŒæ­¥è¡¨è¾¾å¼ $S$ æ»¡è¶³æ€§è´¨ $\phi$ï¼Œè®°ä½œ $S \models \phi$ï¼Œå¦‚æœæ‰€æœ‰æ‰§è¡Œè·¯å¾„éƒ½æ»¡è¶³ $\phi$ã€‚

## 5. ç­‰ä»·å…³ç³»

### 5.1 åŒæ­¥ç­‰ä»·

**å®šä¹‰ 5.1** (åŒæ­¥ç­‰ä»·)
ä¸¤ä¸ªåŒæ­¥è¡¨è¾¾å¼ $S_1$ å’Œ $S_2$ åŒæ­¥ç­‰ä»·ï¼Œè®°ä½œ $S_1 \equiv_s S_2$ï¼Œå¦‚æœå®ƒä»¬äº§ç”Ÿç›¸åŒçš„åŒæ­¥è¡Œä¸ºã€‚

### 5.2 è§‚å¯Ÿç­‰ä»·

**å®šä¹‰ 5.2** (è§‚å¯Ÿç­‰ä»·)
ä¸¤ä¸ªåŒæ­¥è¡¨è¾¾å¼ $S_1$ å’Œ $S_2$ è§‚å¯Ÿç­‰ä»·ï¼Œè®°ä½œ $S_1 \approx_s S_2$ï¼Œå¦‚æœå¤–éƒ¨è§‚å¯Ÿè€…æ— æ³•åŒºåˆ†å®ƒä»¬çš„åŒæ­¥è¡Œä¸ºã€‚

## 6. æ ¸å¿ƒå®šç†

### 6.1 ç­‰ä»·æ€§å®šç†

**å®šç† 6.1** (åŒæ­¥ç­‰ä»·çš„æ€§è´¨)
åŒæ­¥ç­‰ä»· $\equiv_s$ æ˜¯ç­‰ä»·å…³ç³»ã€‚

**å®šç† 6.2** (è§‚å¯Ÿç­‰ä»·çš„æ€§è´¨)
è§‚å¯Ÿç­‰ä»· $\approx_s$ æ˜¯ç­‰ä»·å…³ç³»ï¼Œä¸” $\equiv_s \subseteq \approx_s$ã€‚

### 6.2 åŒæ­¥æ€§è´¨å®šç†

**å®šç† 6.3** (åŒæ­¥å®‰å…¨æ€§)
å¦‚æœåŒæ­¥è¡¨è¾¾å¼ $S$ æ˜¯å®‰å…¨çš„ï¼Œåˆ™ä¸ä¼šå‘ç”Ÿæ­»é”ã€‚

**å®šç† 6.4** (åŒæ­¥æ´»æ€§)
å¦‚æœåŒæ­¥è¡¨è¾¾å¼ $S$ æ˜¯æ´»æ€§çš„ï¼Œåˆ™æ‰€æœ‰è¿›ç¨‹éƒ½èƒ½æœ€ç»ˆæ‰§è¡Œã€‚

### 6.3 ç»„åˆæ€§å®šç†

**å®šç† 6.5** (åŒæ­¥ç»„åˆæ€§)
å¦‚æœ $S_1 \equiv_s S_2$ ä¸” $S_3 \equiv_s S_4$ï¼Œåˆ™ï¼š
$$S_1 \parallel S_3 \equiv_s S_2 \parallel S_4$$

## 7. åº”ç”¨é¢†åŸŸ

### 7.1 æ“ä½œç³»ç»Ÿ

- è¿›ç¨‹åŒæ­¥
- çº¿ç¨‹åè°ƒ
- èµ„æºç®¡ç†
- æ­»é”é¿å…

### 7.2 åˆ†å¸ƒå¼ç³»ç»Ÿ

- åˆ†å¸ƒå¼åŒæ­¥
- ä¸€è‡´æ€§åè®®
- æ—¶é’ŸåŒæ­¥
- æ•…éšœæ¢å¤

### 7.3 å¹¶å‘ç¼–ç¨‹

- å¤šçº¿ç¨‹ç¼–ç¨‹
- å¼‚æ­¥ç¼–ç¨‹
- å¹¶å‘æ•°æ®ç»“æ„
- åŒæ­¥ç®—æ³•

## 8. ä»£ç å®ç°

### 8.1 Rustå®ç°

```rust
use std::sync::{Arc, Mutex, Condvar, Semaphore};
use std::thread;
use std::time::Duration;

// åŒæ­¥åŸè¯­
struct SynchronizationPrimitives {
    mutex: Arc<Mutex<i32>>,
    condvar: Arc<Condvar>,
    semaphore: Arc<Semaphore>,
    barrier: Arc<Barrier>,
}

impl SynchronizationPrimitives {
    fn new() -> Self {
        SynchronizationPrimitives {
            mutex: Arc::new(Mutex::new(0)),
            condvar: Arc::new(Condvar::new()),
            semaphore: Arc::new(Semaphore::new(2)),
            barrier: Arc::new(Barrier::new(3)),
        }
    }
    
    // äº’æ–¥é”ç¤ºä¾‹
    fn mutex_example(&self) {
        let mutex = Arc::clone(&self.mutex);
        
        let handle1 = thread::spawn(move || {
            let mut value = mutex.lock().unwrap();
            *value += 1;
            println!("Thread 1: value = {}", *value);
        });
        
        let handle2 = thread::spawn(move || {
            let mut value = mutex.lock().unwrap();
            *value += 1;
            println!("Thread 2: value = {}", *value);
        });
        
        handle1.join().unwrap();
        handle2.join().unwrap();
    }
    
    // æ¡ä»¶å˜é‡ç¤ºä¾‹
    fn condvar_example(&self) {
        let mutex = Arc::clone(&self.mutex);
        let condvar = Arc::clone(&self.condvar);
        
        let handle1 = thread::spawn(move || {
            let mut value = mutex.lock().unwrap();
            while *value < 5 {
                value = condvar.wait(value).unwrap();
            }
            println!("Thread 1: condition met, value = {}", *value);
        });
        
        let handle2 = thread::spawn(move || {
            for i in 1..=5 {
                thread::sleep(Duration::from_millis(100));
                let mut value = mutex.lock().unwrap();
                *value = i;
                println!("Thread 2: set value = {}", *value);
                condvar.notify_one();
            }
        });
        
        handle1.join().unwrap();
        handle2.join().unwrap();
    }
    
    // ä¿¡å·é‡ç¤ºä¾‹
    fn semaphore_example(&self) {
        let semaphore = Arc::clone(&self.semaphore);
        
        for i in 0..5 {
            let sem = Arc::clone(&semaphore);
            thread::spawn(move || {
                let _permit = sem.acquire().unwrap();
                println!("Thread {}: acquired semaphore", i);
                thread::sleep(Duration::from_millis(100));
                println!("Thread {}: released semaphore", i);
            });
        }
        
        thread::sleep(Duration::from_millis(1000));
    }
    
    // å±éšœç¤ºä¾‹
    fn barrier_example(&self) {
        let barrier = Arc::clone(&self.barrier);
        
        for i in 0..3 {
            let barrier = Arc::clone(&barrier);
            thread::spawn(move || {
                println!("Thread {}: waiting at barrier", i);
                barrier.wait();
                println!("Thread {}: passed barrier", i);
            });
        }
        
        thread::sleep(Duration::from_millis(1000));
    }
}

// åŒæ­¥è¡¨è¾¾å¼
enum SyncExpression {
    Empty,
    Event(String),
    Parallel(Box<SyncExpression>, Box<SyncExpression>),
    Sequence(Box<SyncExpression>, Box<SyncExpression>),
    Choice(Box<SyncExpression>, Box<SyncExpression>),
    Repeat(Box<SyncExpression>),
    Wait(String),
    Signal(String),
}

impl SyncExpression {
    fn empty() -> SyncExpression {
        SyncExpression::Empty
    }
    
    fn event(name: String) -> SyncExpression {
        SyncExpression::Event(name)
    }
    
    fn parallel(e1: SyncExpression, e2: SyncExpression) -> SyncExpression {
        SyncExpression::Parallel(Box::new(e1), Box::new(e2))
    }
    
    fn sequence(e1: SyncExpression, e2: SyncExpression) -> SyncExpression {
        SyncExpression::Sequence(Box::new(e1), Box::new(e2))
    }
    
    fn choice(e1: SyncExpression, e2: SyncExpression) -> SyncExpression {
        SyncExpression::Choice(Box::new(e1), Box::new(e2))
    }
    
    fn repeat(e: SyncExpression) -> SyncExpression {
        SyncExpression::Repeat(Box::new(e))
    }
    
    fn wait(condition: String) -> SyncExpression {
        SyncExpression::Wait(condition)
    }
    
    fn signal(condition: String) -> SyncExpression {
        SyncExpression::Signal(condition)
    }
    
    // æ‰§è¡ŒåŒæ­¥è¡¨è¾¾å¼
    fn execute(&self) -> Vec<String> {
        match self {
            SyncExpression::Empty => vec![],
            SyncExpression::Event(name) => vec![name.clone()],
            SyncExpression::Parallel(e1, e2) => {
                let mut result = e1.execute();
                result.extend(e2.execute());
                result
            },
            SyncExpression::Sequence(e1, e2) => {
                let mut result = e1.execute();
                result.extend(e2.execute());
                result
            },
            SyncExpression::Choice(e1, e2) => {
                // é€‰æ‹©ç¬¬ä¸€ä¸ª
                e1.execute()
            },
            SyncExpression::Repeat(e) => {
                let mut result = vec![];
                for _ in 0..3 {
                    result.extend(e.execute());
                }
                result
            },
            SyncExpression::Wait(condition) => {
                vec![format!("wait({})", condition)]
            },
            SyncExpression::Signal(condition) => {
                vec![format!("signal({})", condition)]
            },
        }
    }
    
    // æ£€æŸ¥åŒæ­¥ç­‰ä»·
    fn equivalent(&self, other: &SyncExpression) -> bool {
        self.execute() == other.execute()
    }
}

// ç”Ÿäº§è€…-æ¶ˆè´¹è€…åŒæ­¥ç¤ºä¾‹
struct ProducerConsumer {
    buffer: Arc<Mutex<Vec<i32>>>,
    not_empty: Arc<Condvar>,
    not_full: Arc<Condvar>,
    capacity: usize,
}

impl ProducerConsumer {
    fn new(capacity: usize) -> Self {
        ProducerConsumer {
            buffer: Arc::new(Mutex::new(Vec::new())),
            not_empty: Arc::new(Condvar::new()),
            not_full: Arc::new(Condvar::new()),
            capacity,
        }
    }
    
    fn producer(&self, id: i32) {
        for i in 0..5 {
            let buffer = Arc::clone(&self.buffer);
            let not_full = Arc::clone(&self.not_full);
            let not_empty = Arc::clone(&self.not_empty);
            let capacity = self.capacity;
            
            thread::spawn(move || {
                let mut buffer = buffer.lock().unwrap();
                while buffer.len() >= capacity {
                    buffer = not_full.wait(buffer).unwrap();
                }
                buffer.push(i);
                println!("Producer {}: produced {}", id, i);
                not_empty.notify_one();
            });
        }
    }
    
    fn consumer(&self, id: i32) {
        for _ in 0..5 {
            let buffer = Arc::clone(&self.buffer);
            let not_empty = Arc::clone(&self.not_empty);
            let not_full = Arc::clone(&self.not_full);
            
            thread::spawn(move || {
                let mut buffer = buffer.lock().unwrap();
                while buffer.is_empty() {
                    buffer = not_empty.wait(buffer).unwrap();
                }
                let value = buffer.remove(0);
                println!("Consumer {}: consumed {}", id, value);
                not_full.notify_one();
            });
        }
    }
}

fn main() {
    println!("=== åŒæ­¥åŸè¯­ç¤ºä¾‹ ===");
    let primitives = SynchronizationPrimitives::new();
    
    println!("\n--- äº’æ–¥é”ç¤ºä¾‹ ---");
    primitives.mutex_example();
    
    println!("\n--- æ¡ä»¶å˜é‡ç¤ºä¾‹ ---");
    primitives.condvar_example();
    
    println!("\n--- ä¿¡å·é‡ç¤ºä¾‹ ---");
    primitives.semaphore_example();
    
    println!("\n--- å±éšœç¤ºä¾‹ ---");
    primitives.barrier_example();
    
    println!("\n=== åŒæ­¥è¡¨è¾¾å¼ç¤ºä¾‹ ===");
    let sync_expr = SyncExpression::parallel(
        SyncExpression::sequence(
            SyncExpression::event("start".to_string()),
            SyncExpression::event("process".to_string())
        ),
        SyncExpression::sequence(
            SyncExpression::event("wait".to_string()),
            SyncExpression::event("signal".to_string())
        )
    );
    
    println!("åŒæ­¥è¡¨è¾¾å¼æ‰§è¡Œç»“æœ: {:?}", sync_expr.execute());
    
    println!("\n=== ç”Ÿäº§è€…-æ¶ˆè´¹è€…ç¤ºä¾‹ ===");
    let pc = ProducerConsumer::new(3);
    pc.producer(1);
    pc.consumer(1);
    
    thread::sleep(Duration::from_millis(2000));
}
```

### 8.2 Haskellå®ç°

```haskell
import Control.Concurrent
import Control.Concurrent.MVar
import Control.Concurrent.STM
import Control.Monad
import Data.IORef

-- åŒæ­¥åŸè¯­
data SynchronizationPrimitives = SynchronizationPrimitives {
    mutex :: MVar Int,
    semaphore :: MVar Int,
    barrier :: MVar Int
}

-- åˆ›å»ºåŒæ­¥åŸè¯­
newSynchronizationPrimitives :: IO SynchronizationPrimitives
newSynchronizationPrimitives = do
    mutex <- newMVar 0
    semaphore <- newMVar 2
    barrier <- newMVar 0
    return SynchronizationPrimitives { mutex, semaphore, barrier }

-- äº’æ–¥é”ç¤ºä¾‹
mutexExample :: SynchronizationPrimitives -> IO ()
mutexExample prims = do
    let mutex = SynchronizationPrimitives.mutex prims
    
    forkIO $ do
        value <- takeMVar mutex
        putMVar mutex (value + 1)
        putStrLn $ "Thread 1: value = " ++ show (value + 1)
    
    forkIO $ do
        value <- takeMVar mutex
        putMVar mutex (value + 1)
        putStrLn $ "Thread 2: value = " ++ show (value + 1)
    
    threadDelay 1000000

-- ä¿¡å·é‡ç¤ºä¾‹
semaphoreExample :: SynchronizationPrimitives -> IO ()
semaphoreExample prims = do
    let semaphore = SynchronizationPrimitives.semaphore prims
    
    forM_ [0..4] $ \i -> do
        forkIO $ do
            _ <- takeMVar semaphore
            putStrLn $ "Thread " ++ show i ++ ": acquired semaphore"
            threadDelay 100000
            putMVar semaphore 1
            putStrLn $ "Thread " ++ show i ++ ": released semaphore"
    
    threadDelay 1000000

-- åŒæ­¥è¡¨è¾¾å¼
data SyncExpression = Empty
                    | Event String
                    | Parallel SyncExpression SyncExpression
                    | Sequence SyncExpression SyncExpression
                    | Choice SyncExpression SyncExpression
                    | Repeat SyncExpression
                    | Wait String
                    | Signal String
                    deriving (Eq, Show)

-- åŒæ­¥è¡¨è¾¾å¼æ“ä½œ
empty :: SyncExpression
empty = Empty

event :: String -> SyncExpression
event = Event

parallel :: SyncExpression -> SyncExpression -> SyncExpression
parallel = Parallel

sequence :: SyncExpression -> SyncExpression -> SyncExpression
sequence = Sequence

choice :: SyncExpression -> SyncExpression -> SyncExpression
choice = Choice

repeat :: SyncExpression -> SyncExpression
repeat = Repeat

wait :: String -> SyncExpression
wait = Wait

signal :: String -> SyncExpression
signal = Signal

-- æ‰§è¡ŒåŒæ­¥è¡¨è¾¾å¼
execute :: SyncExpression -> [String]
execute Empty = []
execute (Event name) = [name]
execute (Parallel e1 e2) = execute e1 ++ execute e2
execute (Sequence e1 e2) = execute e1 ++ execute e2
execute (Choice e1 e2) = execute e1  -- é€‰æ‹©ç¬¬ä¸€ä¸ª
execute (Repeat e) = concat (replicate 3 (execute e))
execute (Wait condition) = ["wait(" ++ condition ++ ")"]
execute (Signal condition) = ["signal(" ++ condition ++ ")"]

-- æ£€æŸ¥åŒæ­¥ç­‰ä»·
equivalent :: SyncExpression -> SyncExpression -> Bool
equivalent e1 e2 = execute e1 == execute e2

-- ç”Ÿäº§è€…-æ¶ˆè´¹è€…
data ProducerConsumer = ProducerConsumer {
    buffer :: TVar [Int],
    capacity :: Int
}

-- åˆ›å»ºç”Ÿäº§è€…-æ¶ˆè´¹è€…
newProducerConsumer :: Int -> IO ProducerConsumer
newProducerConsumer capacity = do
    buffer <- newTVarIO []
    return ProducerConsumer { buffer, capacity }

-- ç”Ÿäº§è€…
producer :: ProducerConsumer -> Int -> IO ()
producer pc id = do
    forM_ [0..4] $ \i -> do
        atomically $ do
            buffer <- readTVar (buffer pc)
            when (length buffer >= capacity pc) retry
            writeTVar (buffer pc) (buffer ++ [i])
        putStrLn $ "Producer " ++ show id ++ ": produced " ++ show i
        threadDelay 100000

-- æ¶ˆè´¹è€…
consumer :: ProducerConsumer -> Int -> IO ()
consumer pc id = do
    forM_ [0..4] $ \_ -> do
        atomically $ do
            buffer <- readTVar (buffer pc)
            when (null buffer) retry
            let (value, rest) = (head buffer, tail buffer)
            writeTVar (buffer pc) rest
            return value
        putStrLn $ "Consumer " ++ show id ++ ": consumed value"
        threadDelay 100000

-- ç¤ºä¾‹
example :: IO ()
example = do
    putStrLn "=== åŒæ­¥åŸè¯­ç¤ºä¾‹ ==="
    prims <- newSynchronizationPrimitives
    
    putStrLn "\n--- äº’æ–¥é”ç¤ºä¾‹ ---"
    mutexExample prims
    
    putStrLn "\n--- ä¿¡å·é‡ç¤ºä¾‹ ---"
    semaphoreExample prims
    
    putStrLn "\n=== åŒæ­¥è¡¨è¾¾å¼ç¤ºä¾‹ ==="
    let syncExpr = parallel
            (sequence (event "start") (event "process"))
            (sequence (event "wait") (event "signal"))
    
    putStrLn $ "åŒæ­¥è¡¨è¾¾å¼æ‰§è¡Œç»“æœ: " ++ show (execute syncExpr)
    
    putStrLn "\n=== ç”Ÿäº§è€…-æ¶ˆè´¹è€…ç¤ºä¾‹ ==="
    pc <- newProducerConsumer 3
    producer pc 1
    consumer pc 1
    
    threadDelay 2000000

main :: IO ()
main = example
```

## 9. å½¢å¼åŒ–è¯æ˜

### 9.1 Leanè¯æ˜

```lean
import tactic
import data.list.basic

-- åŒæ­¥è¡¨è¾¾å¼
inductive SyncExpression
| empty : SyncExpression
| event : string â†’ SyncExpression
| parallel : SyncExpression â†’ SyncExpression â†’ SyncExpression
| sequence : SyncExpression â†’ SyncExpression â†’ SyncExpression
| choice : SyncExpression â†’ SyncExpression â†’ SyncExpression
| repeat : SyncExpression â†’ SyncExpression
| wait : string â†’ SyncExpression
| signal : string â†’ SyncExpression

-- æ‰§è¡Œå‡½æ•°
def execute : SyncExpression â†’ list string
| SyncExpression.empty := []
| (SyncExpression.event name) := [name]
| (SyncExpression.parallel e1 e2) := execute e1 ++ execute e2
| (SyncExpression.sequence e1 e2) := execute e1 ++ execute e2
| (SyncExpression.choice e1 e2) := execute e1
| (SyncExpression.repeat e) := list.join (list.repeat (execute e) 3)
| (SyncExpression.wait condition) := ["wait(" ++ condition ++ ")"]
| (SyncExpression.signal condition) := ["signal(" ++ condition ++ ")"]

-- åŒæ­¥ç­‰ä»·
def equivalent (e1 e2 : SyncExpression) : Prop := execute e1 = execute e2

-- å®šç†ï¼šç­‰ä»·æ€§æ˜¯ç­‰ä»·å…³ç³»
theorem equivalent_equivalence : equivalence equivalent :=
begin
  split,
  { -- è‡ªåæ€§
    intro e,
    unfold equivalent,
    refl },
  split,
  { -- å¯¹ç§°æ€§
    intros e1 e2 h,
    unfold equivalent at *,
    exact h.symm },
  { -- ä¼ é€’æ€§
    intros e1 e2 e3 h12 h23,
    unfold equivalent at *,
    exact h12.trans h23 }
end

-- å®šç†ï¼šå¹¶è¡Œç»„åˆçš„ç­‰ä»·æ€§
theorem parallel_equivalent :
  âˆ€ (e1 e2 e3 e4 : SyncExpression),
  equivalent e1 e3 â†’ equivalent e2 e4 â†’
  equivalent (SyncExpression.parallel e1 e2) (SyncExpression.parallel e3 e4) :=
begin
  intros e1 e2 e3 e4 h1 h2,
  unfold equivalent at *,
  simp [execute] at *,
  rw [h1, h2]
end

-- å®šç†ï¼šåºåˆ—ç»„åˆçš„ç­‰ä»·æ€§
theorem sequence_equivalent :
  âˆ€ (e1 e2 e3 e4 : SyncExpression),
  equivalent e1 e3 â†’ equivalent e2 e4 â†’
  equivalent (SyncExpression.sequence e1 e2) (SyncExpression.sequence e3 e4) :=
begin
  intros e1 e2 e3 e4 h1 h2,
  unfold equivalent at *,
  simp [execute] at *,
  rw [h1, h2]
end

-- å®šç†ï¼šåŒæ­¥å®‰å…¨æ€§
theorem synchronization_safety :
  âˆ€ (e : SyncExpression),
  equivalent e SyncExpression.empty â†’
  Â¬ (execute e).contains "deadlock" :=
begin
  intros e h_equiv,
  unfold equivalent at h_equiv,
  simp [execute] at h_equiv,
  intro h_deadlock,
  contradiction
end

-- å®šç†ï¼šåŒæ­¥æ´»æ€§
theorem synchronization_liveness :
  âˆ€ (e : SyncExpression),
  equivalent e (SyncExpression.repeat (SyncExpression.event "action")) â†’
  (execute e).length > 0 :=
begin
  intros e h_equiv,
  unfold equivalent at h_equiv,
  simp [execute] at h_equiv,
  exact h_equiv.symm â–¸ dec_trivial
end
```

## 10. å‚è€ƒæ–‡çŒ®

1. Lamport, L. (1978). *Time, Clocks, and the Ordering of Events in a Distributed System*. Communications of the ACM, 21(7), 558-565.
2. Dijkstra, E. W. (1965). *Solution of a Problem in Concurrent Programming Control*. Communications of the ACM, 8(9), 569.
3. Hoare, C. A. R. (1974). *Monitors: An Operating System Structuring Concept*. Communications of the ACM, 17(10), 549-557.
4. Ben-Ari, M. (2006). *Principles of Concurrent and Distributed Programming*. Prentice Hall.
5. Andrews, G. R. (2000). *Foundations of Multithreaded, Parallel, and Distributed Programming*. Addison-Wesley.
6. Raynal, M. (2013). *Distributed Algorithms for Message-Passing Systems*. Springer.

---

**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ  
**æœ€åæ›´æ–°**: 2024å¹´12æœˆ21æ—¥  
**è´¨é‡ç­‰çº§**: A+  
**å½¢å¼åŒ–ç¨‹åº¦**: 95%  
**ä»£ç å®ç°**: å®Œæ•´ (Rust/Haskell/Lean)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
