# 07.5.4 å®‰å…¨å·¥ç¨‹ç†è®º

## ğŸ“‹ æ¦‚è¿°

å®‰å…¨å·¥ç¨‹ç†è®ºæ˜¯è½¯ä»¶å·¥ç¨‹ä¸­ä¿éšœè½¯ä»¶å®‰å…¨æ€§çš„æ ¸å¿ƒç†è®ºä½“ç³»ï¼Œé€šè¿‡å»ºç«‹å½¢å¼åŒ–çš„å®‰å…¨æ¨¡å‹å’Œé˜²æŠ¤æœºåˆ¶ï¼Œä¸ºè½¯ä»¶å®‰å…¨å¼€å‘æä¾›ç§‘å­¦ä¾æ®ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹è½¯ä»¶å®‰å…¨çš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°Rustå®‰å…¨ç¼–ç¨‹ç¤ºä¾‹
4. åˆ†æå®‰å…¨å¨èƒä¸é˜²æŠ¤ç­–ç•¥

## ğŸ“š ç›®å½•

1. åŸºæœ¬æ¦‚å¿µ
2. å½¢å¼åŒ–å®šä¹‰
3. å®šç†ä¸è¯æ˜
4. ä»£ç å®ç°
5. åº”ç”¨ç¤ºä¾‹
6. ç›¸å…³ç†è®º
7. å‚è€ƒæ–‡çŒ®

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è½¯ä»¶å®‰å…¨å®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆè½¯ä»¶å®‰å…¨ï¼‰
è½¯ä»¶å®‰å…¨æ˜¯è½¯ä»¶åœ¨æ¶æ„æ”»å‡»å’Œæ„å¤–æ•…éšœä¸‹ä¿æŒæœºå¯†æ€§ã€å®Œæ•´æ€§å’Œå¯ç”¨æ€§çš„èƒ½åŠ›ã€‚

### 1.2 å®‰å…¨å±æ€§

- æœºå¯†æ€§ï¼ˆConfidentialityï¼‰
- å®Œæ•´æ€§ï¼ˆIntegrityï¼‰
- å¯ç”¨æ€§ï¼ˆAvailabilityï¼‰
- è®¤è¯æ€§ï¼ˆAuthenticationï¼‰
- æˆæƒæ€§ï¼ˆAuthorizationï¼‰
- ä¸å¯å¦è®¤æ€§ï¼ˆNon-repudiationï¼‰

## 2. å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1**ï¼ˆå®‰å…¨æ¨¡å‹ï¼‰
å®‰å…¨æ¨¡å‹æ˜¯ä¸€ä¸ªå…­å…ƒç»„ $SM = (S, O, A, P, R, V)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯ä¸»ä½“é›†åˆ
- $O$ æ˜¯å®¢ä½“é›†åˆ
- $A$ æ˜¯è®¿é—®æƒé™é›†åˆ
- $P$ æ˜¯ç­–ç•¥é›†åˆ
- $R$ æ˜¯è§„åˆ™é›†åˆ
- $V$ æ˜¯éªŒè¯å‡½æ•°

**å®šä¹‰ 2.2**ï¼ˆå®‰å…¨ç­–ç•¥ï¼‰
å®‰å…¨ç­–ç•¥ $P$ æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$P: S \times O \times A \rightarrow \{allow, deny\}$
è¡¨ç¤ºä¸»ä½“å¯¹å®¢ä½“çš„è®¿é—®æƒé™ã€‚

**å®šç† 2.1**ï¼ˆæœ€å°æƒé™åŸåˆ™ï¼‰
æ¯ä¸ªä¸»ä½“åº”è¯¥åªæ‹¥æœ‰å®Œæˆå…¶ä»»åŠ¡æ‰€éœ€çš„æœ€å°æƒé™ã€‚

**è¯æ˜**ï¼š
é™åˆ¶æƒé™å¯ä»¥å‡å°‘æ½œåœ¨çš„å®‰å…¨é£é™©ï¼Œç¬¦åˆçºµæ·±é˜²å¾¡åŸåˆ™ã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

**å®šç† 3.1**ï¼ˆå®‰å…¨è¾¹ç•Œå®šç†ï¼‰
ç³»ç»Ÿå®‰å…¨ç”±æœ€å¼±çš„å®‰å…¨è¾¹ç•Œå†³å®šã€‚

**è¯æ˜**ï¼š
æ”»å‡»è€…æ€»æ˜¯å¯»æ‰¾æœ€è–„å¼±çš„ç¯èŠ‚ï¼Œå› æ­¤ç³»ç»Ÿæ•´ä½“å®‰å…¨æ€§å—é™äºæœ€å¼±çš„å®‰å…¨è¾¹ç•Œã€‚$\square$

**å®šç† 3.2**ï¼ˆå®‰å…¨ä¸å¯ç”¨æ€§æƒè¡¡ï¼‰
å®‰å…¨æ€§ä¸å¯ç”¨æ€§ä¹‹é—´å­˜åœ¨æƒè¡¡å…³ç³»ã€‚

**è¯æ˜**ï¼š
å¢åŠ å®‰å…¨æªæ–½é€šå¸¸ä¼šå½±å“ç³»ç»Ÿæ€§èƒ½å’Œä½¿ç”¨ä¾¿åˆ©æ€§ã€‚$\square$

## 4. ä»£ç å®ç°

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

/// å®‰å…¨çº§åˆ«æšä¸¾
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SecurityLevel {
    Public,
    Internal,
    Confidential,
    Secret,
    TopSecret,
}

/// ç”¨æˆ·è§’è‰²
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum UserRole {
    Guest,
    User,
    Admin,
    SuperAdmin,
}

/// å®‰å…¨ä¸»ä½“
pub struct SecuritySubject {
    pub id: String,
    pub role: UserRole,
    pub security_level: SecurityLevel,
    pub permissions: Vec<String>,
}

/// å®‰å…¨å®¢ä½“
pub struct SecurityObject {
    pub id: String,
    pub security_level: SecurityLevel,
    pub owner: String,
    pub access_control_list: HashMap<String, Vec<String>>,
}

/// è®¿é—®æ§åˆ¶çŸ©é˜µ
pub struct AccessControlMatrix {
    matrix: HashMap<(String, String), Vec<String>>, // (subject, object) -> permissions
}

impl AccessControlMatrix {
    pub fn new() -> Self {
        Self {
            matrix: HashMap::new(),
        }
    }
    
    pub fn grant_permission(&mut self, subject: &str, object: &str, permission: &str) {
        let key = (subject.to_string(), object.to_string());
        self.matrix.entry(key)
            .or_insert_with(Vec::new)
            .push(permission.to_string());
    }
    
    pub fn revoke_permission(&mut self, subject: &str, object: &str, permission: &str) {
        let key = (subject.to_string(), object.to_string());
        if let Some(permissions) = self.matrix.get_mut(&key) {
            permissions.retain(|p| p != permission);
        }
    }
    
    pub fn check_permission(&self, subject: &str, object: &str, permission: &str) -> bool {
        let key = (subject.to_string(), object.to_string());
        self.matrix.get(&key)
            .map(|permissions| permissions.contains(&permission.to_string()))
            .unwrap_or(false)
    }
}

/// å®‰å…¨è®¤è¯å™¨
pub struct SecurityAuthenticator {
    users: HashMap<String, String>, // username -> hashed_password
    sessions: HashMap<String, (String, Instant)>, // session_id -> (username, timestamp)
    session_timeout: Duration,
}

impl SecurityAuthenticator {
    pub fn new(session_timeout: Duration) -> Self {
        Self {
            users: HashMap::new(),
            sessions: HashMap::new(),
            session_timeout,
        }
    }
    
    pub fn register_user(&mut self, username: &str, password: &str) -> Result<(), String> {
        if self.users.contains_key(username) {
            return Err("User already exists".to_string());
        }
        
        let hashed_password = Self::hash_password(password);
        self.users.insert(username.to_string(), hashed_password);
        Ok(())
    }
    
    pub fn authenticate(&mut self, username: &str, password: &str) -> Result<String, String> {
        let hashed_password = self.users.get(username)
            .ok_or("User not found")?;
        
        if Self::verify_password(password, hashed_password) {
            let session_id = Self::generate_session_id();
            self.sessions.insert(session_id.clone(), (username.to_string(), Instant::now()));
            Ok(session_id)
        } else {
            Err("Invalid password".to_string())
        }
    }
    
    pub fn validate_session(&mut self, session_id: &str) -> Result<String, String> {
        let (username, timestamp) = self.sessions.get(session_id)
            .ok_or("Invalid session")?;
        
        if timestamp.elapsed() > self.session_timeout {
            self.sessions.remove(session_id);
            return Err("Session expired".to_string());
        }
        
        Ok(username.clone())
    }
    
    fn hash_password(password: &str) -> String {
        // ç®€åŒ–çš„å¯†ç å“ˆå¸Œï¼Œå®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨bcryptç­‰å®‰å…¨ç®—æ³•
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        password.hash(&mut hasher);
        format!("{:x}", hasher.finish())
    }
    
    fn verify_password(password: &str, hashed: &str) -> bool {
        Self::hash_password(password) == hashed
    }
    
    fn generate_session_id() -> String {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        use std::time::SystemTime;
        
        let mut hasher = DefaultHasher::new();
        SystemTime::now().hash(&mut hasher);
        format!("{:x}", hasher.finish())
    }
}

/// å®‰å…¨åŠ å¯†å™¨
pub struct SecurityEncryptor;

impl SecurityEncryptor {
    /// å¯¹ç§°åŠ å¯†
    pub fn encrypt_symmetric(data: &[u8], key: &[u8]) -> Vec<u8> {
        // ç®€åŒ–çš„XORåŠ å¯†ï¼Œå®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨AESç­‰æ ‡å‡†ç®—æ³•
        data.iter()
            .zip(key.iter().cycle())
            .map(|(d, k)| d ^ k)
            .collect()
    }
    
    /// å¯¹ç§°è§£å¯†
    pub fn decrypt_symmetric(encrypted_data: &[u8], key: &[u8]) -> Vec<u8> {
        Self::encrypt_symmetric(encrypted_data, key) // XORæ˜¯å¯¹ç§°çš„
    }
    
    /// ç”Ÿæˆéšæœºå¯†é’¥
    pub fn generate_key(length: usize) -> Vec<u8> {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        use std::time::SystemTime;
        
        let mut hasher = DefaultHasher::new();
        SystemTime::now().hash(&mut hasher);
        let hash = hasher.finish();
        
        (0..length)
            .map(|i| ((hash >> (i * 8)) & 0xFF) as u8)
            .collect()
    }
}

/// å®‰å…¨å®¡è®¡å™¨
pub struct SecurityAuditor {
    logs: Arc<Mutex<Vec<AuditLog>>>,
}

#[derive(Debug, Clone)]
pub struct AuditLog {
    pub timestamp: Instant,
    pub subject: String,
    pub action: String,
    pub object: String,
    pub result: bool,
    pub details: String,
}

impl SecurityAuditor {
    pub fn new() -> Self {
        Self {
            logs: Arc::new(Mutex::new(Vec::new())),
        }
    }
    
    pub fn log_access(&self, subject: &str, action: &str, object: &str, result: bool, details: &str) {
        let log = AuditLog {
            timestamp: Instant::now(),
            subject: subject.to_string(),
            action: action.to_string(),
            object: object.to_string(),
            result,
            details: details.to_string(),
        };
        
        if let Ok(mut logs) = self.logs.lock() {
            logs.push(log);
        }
    }
    
    pub fn get_logs(&self) -> Vec<AuditLog> {
        self.logs.lock().unwrap().clone()
    }
    
    pub fn analyze_security_events(&self) -> SecurityAnalysis {
        let logs = self.get_logs();
        let total_events = logs.len();
        let failed_attempts = logs.iter().filter(|log| !log.result).count();
        let success_rate = if total_events > 0 {
            (total_events - failed_attempts) as f64 / total_events as f64
        } else {
            0.0
        };
        
        SecurityAnalysis {
            total_events,
            failed_attempts,
            success_rate,
            recent_events: logs.into_iter().rev().take(10).collect(),
        }
    }
}

#[derive(Debug)]
pub struct SecurityAnalysis {
    pub total_events: usize,
    pub failed_attempts: usize,
    pub success_rate: f64,
    pub recent_events: Vec<AuditLog>,
}

/// å®‰å…¨ç®¡ç†å™¨
pub struct SecurityManager {
    access_control: AccessControlMatrix,
    authenticator: SecurityAuthenticator,
    encryptor: SecurityEncryptor,
    auditor: SecurityAuditor,
}

impl SecurityManager {
    pub fn new() -> Self {
        Self {
            access_control: AccessControlMatrix::new(),
            authenticator: SecurityAuthenticator::new(Duration::from_secs(3600)),
            encryptor: SecurityEncryptor,
            auditor: SecurityAuditor::new(),
        }
    }
    
    pub fn secure_access(&mut self, session_id: &str, object: &str, action: &str) -> Result<(), String> {
        // éªŒè¯ä¼šè¯
        let username = self.authenticator.validate_session(session_id)?;
        
        // æ£€æŸ¥æƒé™
        if !self.access_control.check_permission(&username, object, action) {
            self.auditor.log_access(&username, action, object, false, "Permission denied");
            return Err("Permission denied".to_string());
        }
        
        // è®°å½•æˆåŠŸè®¿é—®
        self.auditor.log_access(&username, action, object, true, "Access granted");
        Ok(())
    }
    
    pub fn encrypt_data(&self, data: &[u8]) -> Vec<u8> {
        let key = SecurityEncryptor::generate_key(32);
        SecurityEncryptor::encrypt_symmetric(data, &key)
    }
    
    pub fn decrypt_data(&self, encrypted_data: &[u8], key: &[u8]) -> Vec<u8> {
        SecurityEncryptor::decrypt_symmetric(encrypted_data, key)
    }
    
    pub fn get_security_report(&self) -> SecurityAnalysis {
        self.auditor.analyze_security_events()
    }
}

/// å®‰å…¨æ¼æ´æ£€æµ‹å™¨
pub struct VulnerabilityDetector;

impl VulnerabilityDetector {
    /// æ£€æµ‹SQLæ³¨å…¥æ¼æ´
    pub fn detect_sql_injection(input: &str) -> bool {
        let sql_keywords = ["SELECT", "INSERT", "UPDATE", "DELETE", "DROP", "CREATE"];
        let upper_input = input.to_uppercase();
        
        sql_keywords.iter().any(|keyword| upper_input.contains(keyword))
    }
    
    /// æ£€æµ‹XSSæ¼æ´
    pub fn detect_xss(input: &str) -> bool {
        let xss_patterns = ["<script>", "javascript:", "onerror=", "onload="];
        let lower_input = input.to_lowercase();
        
        xss_patterns.iter().any(|pattern| lower_input.contains(pattern))
    }
    
    /// æ£€æµ‹ç¼“å†²åŒºæº¢å‡º
    pub fn detect_buffer_overflow(data: &[u8], buffer_size: usize) -> bool {
        data.len() > buffer_size
    }
    
    /// æ£€æµ‹è¾“å…¥éªŒè¯
    pub fn validate_input(input: &str, max_length: usize) -> Result<(), String> {
        if input.len() > max_length {
            return Err("Input too long".to_string());
        }
        
        if Self::detect_sql_injection(input) {
            return Err("Potential SQL injection detected".to_string());
        }
        
        if Self::detect_xss(input) {
            return Err("Potential XSS attack detected".to_string());
        }
        
        Ok(())
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_security_authentication() {
        let mut authenticator = SecurityAuthenticator::new(Duration::from_secs(3600));
        
        // æ³¨å†Œç”¨æˆ·
        assert!(authenticator.register_user("alice", "password123").is_ok());
        
        // è®¤è¯ç”¨æˆ·
        let session_id = authenticator.authenticate("alice", "password123").unwrap();
        
        // éªŒè¯ä¼šè¯
        let username = authenticator.validate_session(&session_id).unwrap();
        assert_eq!(username, "alice");
    }
    
    #[test]
    fn test_access_control() {
        let mut matrix = AccessControlMatrix::new();
        
        // æˆäºˆæƒé™
        matrix.grant_permission("alice", "file1.txt", "read");
        matrix.grant_permission("alice", "file1.txt", "write");
        
        // æ£€æŸ¥æƒé™
        assert!(matrix.check_permission("alice", "file1.txt", "read"));
        assert!(matrix.check_permission("alice", "file1.txt", "write"));
        assert!(!matrix.check_permission("alice", "file1.txt", "execute"));
        
        // æ’¤é”€æƒé™
        matrix.revoke_permission("alice", "file1.txt", "write");
        assert!(!matrix.check_permission("alice", "file1.txt", "write"));
    }
    
    #[test]
    fn test_encryption() {
        let data = b"Hello, World!";
        let key = SecurityEncryptor::generate_key(32);
        
        // åŠ å¯†
        let encrypted = SecurityEncryptor::encrypt_symmetric(data, &key);
        assert_ne!(data, encrypted.as_slice());
        
        // è§£å¯†
        let decrypted = SecurityEncryptor::decrypt_symmetric(&encrypted, &key);
        assert_eq!(data, decrypted.as_slice());
    }
    
    #[test]
    fn test_vulnerability_detection() {
        // æµ‹è¯•SQLæ³¨å…¥æ£€æµ‹
        assert!(VulnerabilityDetector::detect_sql_injection("'; DROP TABLE users; --"));
        assert!(!VulnerabilityDetector::detect_sql_injection("normal input"));
        
        // æµ‹è¯•XSSæ£€æµ‹
        assert!(VulnerabilityDetector::detect_xss("<script>alert('xss')</script>"));
        assert!(!VulnerabilityDetector::detect_xss("normal text"));
        
        // æµ‹è¯•ç¼“å†²åŒºæº¢å‡ºæ£€æµ‹
        let large_data = vec![0u8; 1000];
        assert!(VulnerabilityDetector::detect_buffer_overflow(&large_data, 100));
        
        // æµ‹è¯•è¾“å…¥éªŒè¯
        assert!(VulnerabilityDetector::validate_input("normal input", 100).is_ok());
        assert!(VulnerabilityDetector::validate_input("'; DROP TABLE users; --", 100).is_err());
    }
    
    #[test]
    fn test_security_manager() {
        let mut manager = SecurityManager::new();
        
        // æ³¨å†Œç”¨æˆ·å¹¶è®¾ç½®æƒé™
        manager.authenticator.register_user("bob", "password").unwrap();
        let session_id = manager.authenticator.authenticate("bob", "password").unwrap();
        manager.access_control.grant_permission("bob", "document.txt", "read");
        
        // æµ‹è¯•å®‰å…¨è®¿é—®
        assert!(manager.secure_access(&session_id, "document.txt", "read").is_ok());
        assert!(manager.secure_access(&session_id, "document.txt", "write").is_err());
        
        // è·å–å®‰å…¨æŠ¥å‘Š
        let report = manager.get_security_report();
        assert!(report.total_events > 0);
    }
}
```

## 6. ç›¸å…³ç†è®º

- å¯†ç å­¦ç†è®º
- è®¿é—®æ§åˆ¶ç†è®º
- ç½‘ç»œå®‰å…¨ç†è®º
- è½¯ä»¶æ¼æ´ç†è®º

## 7. å‚è€ƒæ–‡çŒ®

1. Anderson, R. "Security Engineering: A Guide to Building Dependable Distributed Systems"
2. Schneier, B. "Applied Cryptography: Protocols, Algorithms, and Source Code in C"
3. Bishop, M. "Computer Security: Art and Science"
4. Pfleeger, C. P., Pfleeger, S. L. "Security in Computing"

---

**ç›¸å…³é“¾æ¥**ï¼š

- [07.5.1 è´¨é‡æ¨¡å‹ç†è®º](../07.5.1_è´¨é‡æ¨¡å‹ç†è®º.md)
- [07.5.2 ä»£ç è´¨é‡ç†è®º](../07.5.2_ä»£ç è´¨é‡ç†è®º.md)
- [07.5.3 æ€§èƒ½ä¼˜åŒ–ç†è®º](../07.5.3_æ€§èƒ½ä¼˜åŒ–ç†è®º.md)
