# 07.1.2 å½¢å¼åŒ–éªŒè¯æ–¹æ³•

## ğŸ“‹ æ¦‚è¿°

å½¢å¼åŒ–éªŒè¯æ–¹æ³•æ˜¯è½¯ä»¶å·¥ç¨‹ç†è®ºçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œä½¿ç”¨æ•°å­¦æ–¹æ³•è¯æ˜è½¯ä»¶ç³»ç»Ÿçš„æ­£ç¡®æ€§ã€‚æœ¬ç†è®ºæ¶µç›–æ¨¡å‹æ£€æŸ¥ã€å®šç†è¯æ˜ã€æŠ½è±¡è§£é‡Šã€ç¬¦å·æ‰§è¡Œç­‰éªŒè¯æŠ€æœ¯ï¼Œä¸ºè½¯ä»¶ç³»ç»Ÿçš„å¯é æ€§ä¿è¯æä¾›ç†è®ºåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹å½¢å¼åŒ–éªŒè¯çš„æ•°å­¦åŸºç¡€**
2. **æä¾›è‡ªåŠ¨åŒ–çš„éªŒè¯æŠ€æœ¯**
3. **ç¡®ä¿è½¯ä»¶ç³»ç»Ÿçš„æ­£ç¡®æ€§**
4. **æ”¯æŒå¤§è§„æ¨¡ç³»ç»Ÿçš„éªŒè¯**
5. **ä¿ƒè¿›éªŒè¯æŠ€æœ¯çš„å·¥ç¨‹åŒ–åº”ç”¨**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å½¢å¼åŒ–éªŒè¯

**å®šä¹‰ 1.1.1** (å½¢å¼åŒ–éªŒè¯)
å½¢å¼åŒ–éªŒè¯æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(M, P, V)$ï¼Œå…¶ä¸­ï¼š

- $M$: ç³»ç»Ÿæ¨¡å‹
- $P$: æ€§è´¨è§„èŒƒ
- $V$: éªŒè¯æ–¹æ³•

**å®šä¹‰ 1.1.2** (éªŒè¯ç»“æœ)
éªŒè¯ç»“æœæ˜¯ä¸€ä¸ªå››å…ƒç»„ $(result, counterexample, proof, time)$ï¼Œå…¶ä¸­ï¼š

- $result \in \{valid, invalid, unknown\}$
- $counterexample$: åä¾‹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
- $proof$: è¯æ˜ï¼ˆå¦‚æœæˆåŠŸï¼‰
- $time$: éªŒè¯æ—¶é—´

### 1.2 éªŒè¯æ–¹æ³•åˆ†ç±»

**å®šä¹‰ 1.2.1** (æ¨¡å‹æ£€æŸ¥)
æ¨¡å‹æ£€æŸ¥æ˜¯ä¸€ç§è‡ªåŠ¨åŒ–çš„éªŒè¯æ–¹æ³•ï¼š
$$ModelCheck(M, P) = \begin{cases}
valid & \text{if } M \models P \\
invalid & \text{if } M \not\models P \land \text{counterexample found} \\
unknown & \text{otherwise}
\end{cases}$$

**å®šä¹‰ 1.2.2** (å®šç†è¯æ˜)
å®šç†è¯æ˜æ˜¯ä¸€ç§åŸºäºé€»è¾‘æ¨ç†çš„éªŒè¯æ–¹æ³•ï¼š
$$TheoremProve(M, P) = \begin{cases}
valid & \text{if } \vdash M \Rightarrow P \\
invalid & \text{if } \vdash M \Rightarrow \neg P \\
unknown & \text{otherwise}
\end{cases}$$

### 1.3 éªŒè¯æ€§è´¨

**å®šä¹‰ 1.3.1** (å®‰å…¨æ€§æ€§è´¨)
å®‰å…¨æ€§æ€§è´¨æ–­è¨€"åäº‹æ°¸è¿œä¸ä¼šå‘ç”Ÿ"ï¼š
$$Safety(P) = \forall \sigma: \neg Bad(\sigma)$$

**å®šä¹‰ 1.3.2** (æ´»æ€§æ€§è´¨)
æ´»æ€§æ€§è´¨æ–­è¨€"å¥½äº‹æœ€ç»ˆä¼šå‘ç”Ÿ"ï¼š
$$Liveness(P) = \forall \sigma: \exists i: Good(\sigma_i)$$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ¨¡å‹æ£€æŸ¥ç†è®º

**å®šä¹‰ 2.1.1** (Kripkeç»“æ„)
Kripkeç»“æ„æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $(S, S_0, R, L, AP)$ï¼Œå…¶ä¸­ï¼š

- $S$: çŠ¶æ€é›†åˆ
- $S_0 \subseteq S$: åˆå§‹çŠ¶æ€é›†åˆ
- $R \subseteq S \times S$: è½¬ç§»å…³ç³»
- $L: S \to 2^{AP}$: æ ‡ç­¾å‡½æ•°
- $AP$: åŸå­å‘½é¢˜é›†åˆ

**å®šä¹‰ 2.1.2** (CTLå…¬å¼)
è®¡ç®—æ ‘é€»è¾‘(CTL)å…¬å¼çš„è¯­æ³•ï¼š
$$\phi ::= p \mid \neg \phi \mid \phi \land \phi \mid \phi \lor \phi \mid AX\phi \mid EX\phi \mid AG\phi \mid EG\phi \mid AF\phi \mid EF\phi \mid A[\phi U\phi] \mid E[\phi U\phi]$$

### 2.2 å®šç†è¯æ˜ç†è®º

**å®šä¹‰ 2.2.1** (éœå°”é€»è¾‘)
éœå°”é€»è¾‘çš„ä¸‰å…ƒç»„ $(P, C, Q)$ï¼Œå…¶ä¸­ï¼š

- $P$: å‰ç½®æ¡ä»¶
- $C$: ç¨‹åºä»£ç 
- $Q$: åç½®æ¡ä»¶

**å®šä¹‰ 2.2.2** (æœ€å¼±å‰ç½®æ¡ä»¶)
æœ€å¼±å‰ç½®æ¡ä»¶ $wp(C, Q)$ æ˜¯ä½¿ç¨‹åº $C$ æ‰§è¡Œåæ»¡è¶³ $Q$ çš„æœ€å¼±æ¡ä»¶ã€‚

### 2.3 æŠ½è±¡è§£é‡Šç†è®º

**å®šä¹‰ 2.3.1** (æŠ½è±¡åŸŸ)
æŠ½è±¡åŸŸæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(D^\#, \sqsubseteq, \gamma)$ï¼Œå…¶ä¸­ï¼š

- $D^\#$: æŠ½è±¡å€¼é›†åˆ
- $\sqsubseteq$: ååºå…³ç³»
- $\gamma: D^\# \to 2^D$: å…·ä½“åŒ–å‡½æ•°

**å®šä¹‰ 2.3.2** (æŠ½è±¡è§£é‡Š)
æŠ½è±¡è§£é‡Šæ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$$AbstractInterpret(C, D^\#) = \alpha(\llbracket C \rrbracket(\gamma(D^\#)))$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 æ¨¡å‹æ£€æŸ¥æ­£ç¡®æ€§

**å®šç† 3.1.1** (æ¨¡å‹æ£€æŸ¥æ­£ç¡®æ€§)
å¦‚æœæ¨¡å‹æ£€æŸ¥è¿”å› $valid$ï¼Œé‚£ä¹ˆæ¨¡å‹ç¡®å®æ»¡è¶³æ€§è´¨ã€‚

**è¯æ˜**:
è®¾ $M$ æ˜¯ä¸€ä¸ªKripkeç»“æ„ï¼Œ$P$ æ˜¯ä¸€ä¸ªCTLå…¬å¼ã€‚

**æ¨¡å‹æ£€æŸ¥ç®—æ³•**:
1. æ„å»ºçŠ¶æ€ç©ºé—´ $S$
2. æ ‡è®°æ»¡è¶³ $P$ çš„çŠ¶æ€
3. æ£€æŸ¥åˆå§‹çŠ¶æ€æ˜¯å¦è¢«æ ‡è®°

**æ­£ç¡®æ€§è¯æ˜**:
- å¦‚æœç®—æ³•è¿”å› $valid$ï¼Œåˆ™æ‰€æœ‰å¯è¾¾çŠ¶æ€éƒ½æ»¡è¶³ $P$
- ç”±äºåˆå§‹çŠ¶æ€å¯è¾¾ï¼Œæ‰€ä»¥ $M \models P$
- å› æ­¤æ¨¡å‹æ£€æŸ¥ç»“æœæ˜¯æ­£ç¡®çš„

### 3.2 éœå°”é€»è¾‘å®Œå¤‡æ€§

**å®šç† 3.2.1** (éœå°”é€»è¾‘å®Œå¤‡æ€§)
éœå°”é€»è¾‘å¯¹äºéƒ¨åˆ†æ­£ç¡®æ€§æ˜¯å®Œå¤‡çš„ã€‚

**è¯æ˜**:
è®¾ $C$ æ˜¯ä¸€ä¸ªç¨‹åºï¼Œ$P$ å’Œ $Q$ æ˜¯å‰ç½®å’Œåç½®æ¡ä»¶ã€‚

**å®Œå¤‡æ€§è¯æ˜**:
1. å¦‚æœ $\{P\} C \{Q\}$ æ˜¯æœ‰æ•ˆçš„
2. é‚£ä¹ˆ $P \Rightarrow wp(C, Q)$ æ˜¯æ°¸çœŸçš„
3. å› æ­¤éœå°”é€»è¾‘å¯ä»¥è¯æ˜è¿™ä¸ªä¸‰å…ƒç»„
4. ç»“è®ºï¼šéœå°”é€»è¾‘æ˜¯å®Œå¤‡çš„

### 3.3 æŠ½è±¡è§£é‡Šå®‰å…¨æ€§

**å®šç† 3.3.1** (æŠ½è±¡è§£é‡Šå®‰å…¨æ€§)
æŠ½è±¡è§£é‡Šçš„ç»“æœæ˜¯å®‰å…¨çš„ï¼Œå³ä¸ä¼šé—æ¼é”™è¯¯ã€‚

**è¯æ˜**:
è®¾ $D^\#$ æ˜¯ä¸€ä¸ªæŠ½è±¡åŸŸï¼Œ$\gamma$ æ˜¯å…·ä½“åŒ–å‡½æ•°ã€‚

**å®‰å…¨æ€§è¯æ˜**:
$$\forall d^\# \in D^\#: \gamma(d^\#) \subseteq \gamma(\alpha(\gamma(d^\#)))$$

è¿™æ„å‘³ç€æŠ½è±¡è§£é‡Šçš„ç»“æœåŒ…å«äº†æ‰€æœ‰å¯èƒ½çš„å…·ä½“å€¼ï¼Œå› æ­¤ä¸ä¼šé—æ¼é”™è¯¯ã€‚

## 4. ä»£ç å®ç°

### 4.1 æ¨¡å‹æ£€æŸ¥å™¨å®ç°

```rust
use std::collections::{HashMap, HashSet, VecDeque};
use serde::{Serialize, Deserialize};

// Kripkeç»“æ„å®šä¹‰
# [derive(Debug, Clone)]
pub struct KripkeStructure {
    states: Vec<String>,
    initial_states: HashSet<usize>,
    transitions: HashMap<usize, Vec<usize>>,
    labels: HashMap<usize, HashSet<String>>,
    atomic_propositions: HashSet<String>,
}

// CTLå…¬å¼å®šä¹‰
# [derive(Debug, Clone)]
pub enum CTLFormula {
    Atomic(String),
    Not(Box<CTLFormula>),
    And(Box<CTLFormula>, Box<CTLFormula>),
    Or(Box<CTLFormula>, Box<CTLFormula>),
    AX(Box<CTLFormula>),
    EX(Box<CTLFormula>),
    AG(Box<CTLFormula>),
    EG(Box<CTLFormula>),
    AF(Box<CTLFormula>),
    EF(Box<CTLFormula>),
    AU(Box<CTLFormula>, Box<CTLFormula>),
    EU(Box<CTLFormula>, Box<CTLFormula>),
}

// æ¨¡å‹æ£€æŸ¥å™¨
pub struct ModelChecker {
    kripke: KripkeStructure,
}

impl ModelChecker {
    pub fn new(kripke: KripkeStructure) -> Self {
        Self { kripke }
    }

    pub fn check(&self, formula: &CTLFormula) -> bool {
        let satisfying_states = self.satisfying_states(formula);

        // æ£€æŸ¥æ‰€æœ‰åˆå§‹çŠ¶æ€æ˜¯å¦æ»¡è¶³å…¬å¼
        self.kripke.initial_states.iter().all(|&state| {
            satisfying_states.contains(&state)
        })
    }

    fn satisfying_states(&self, formula: &CTLFormula) -> HashSet<usize> {
        match formula {
            CTLFormula::Atomic(prop) => {
                let mut states = HashSet::new();
                for (state, labels) in &self.kripke.labels {
                    if labels.contains(prop) {
                        states.insert(*state);
                    }
                }
                states
            }
            CTLFormula::Not(subformula) => {
                let sub_states = self.satisfying_states(subformula);
                let mut result = HashSet::new();
                for state in 0..self.kripke.states.len() {
                    if !sub_states.contains(&state) {
                        result.insert(state);
                    }
                }
                result
            }
            CTLFormula::And(left, right) => {
                let left_states = self.satisfying_states(left);
                let right_states = self.satisfying_states(right);
                left_states.intersection(&right_states).cloned().collect()
            }
            CTLFormula::Or(left, right) => {
                let left_states = self.satisfying_states(left);
                let right_states = self.satisfying_states(right);
                left_states.union(&right_states).cloned().collect()
            }
            CTLFormula::AX(subformula) => {
                let sub_states = self.satisfying_states(subformula);
                let mut result = HashSet::new();

                for state in 0..self.kripke.states.len() {
                    if let Some(successors) = self.kripke.transitions.get(&state) {
                        if successors.iter().all(|&s| sub_states.contains(&s)) {
                            result.insert(state);
                        }
                    }
                }
                result
            }
            CTLFormula::EX(subformula) => {
                let sub_states = self.satisfying_states(subformula);
                let mut result = HashSet::new();

                for state in 0..self.kripke.states.len() {
                    if let Some(successors) = self.kripke.transitions.get(&state) {
                        if successors.iter().any(|&s| sub_states.contains(&s)) {
                            result.insert(state);
                        }
                    }
                }
                result
            }
            CTLFormula::AG(subformula) => {
                let sub_states = self.satisfying_states(subformula);
                self.compute_ag(sub_states)
            }
            CTLFormula::EG(subformula) => {
                let sub_states = self.satisfying_states(subformula);
                self.compute_eg(sub_states)
            }
            CTLFormula::AF(subformula) => {
                let sub_states = self.satisfying_states(subformula);
                self.compute_af(sub_states)
            }
            CTLFormula::EF(subformula) => {
                let sub_states = self.satisfying_states(subformula);
                self.compute_ef(sub_states)
            }
            CTLFormula::AU(left, right) => {
                let left_states = self.satisfying_states(left);
                let right_states = self.satisfying_states(right);
                self.compute_au(&left_states, &right_states)
            }
            CTLFormula::EU(left, right) => {
                let left_states = self.satisfying_states(left);
                let right_states = self.satisfying_states(right);
                self.compute_eu(&left_states, &right_states)
            }
        }
    }

    fn compute_ag(&self, sub_states: HashSet<usize>) -> HashSet<usize> {
        let mut result = sub_states.clone();
        let mut changed = true;

        while changed {
            changed = false;
            let mut new_result = result.clone();

            for state in 0..self.kripke.states.len() {
                if result.contains(&state) {
                    if let Some(successors) = self.kripke.transitions.get(&state) {
                        if !successors.iter().all(|&s| result.contains(&s)) {
                            new_result.remove(&state);
                            changed = true;
                        }
                    }
                }
            }

            result = new_result;
        }

        result
    }

    fn compute_eg(&self, sub_states: HashSet<usize>) -> HashSet<usize> {
        let mut result = sub_states.clone();
        let mut changed = true;

        while changed {
            changed = false;
            let mut new_result = result.clone();

            for state in 0..self.kripke.states.len() {
                if result.contains(&state) {
                    if let Some(successors) = self.kripke.transitions.get(&state) {
                        if !successors.iter().any(|&s| result.contains(&s)) {
                            new_result.remove(&state);
                            changed = true;
                        }
                    }
                }
            }

            result = new_result;
        }

        result
    }

    fn compute_af(&self, sub_states: HashSet<usize>) -> HashSet<usize> {
        let mut result = sub_states.clone();
        let mut changed = true;

        while changed {
            changed = false;
            let mut new_result = result.clone();

            for state in 0..self.kripke.states.len() {
                if !result.contains(&state) {
                    if let Some(successors) = self.kripke.transitions.get(&state) {
                        if successors.iter().all(|&s| result.contains(&s)) {
                            new_result.insert(state);
                            changed = true;
                        }
                    }
                }
            }

            result = new_result;
        }

        result
    }

    fn compute_ef(&self, sub_states: HashSet<usize>) -> HashSet<usize> {
        let mut result = sub_states.clone();
        let mut changed = true;

        while changed {
            changed = false;
            let mut new_result = result.clone();

            for state in 0..self.kripke.states.len() {
                if !result.contains(&state) {
                    if let Some(successors) = self.kripke.transitions.get(&state) {
                        if successors.iter().any(|&s| result.contains(&s)) {
                            new_result.insert(state);
                            changed = true;
                        }
                    }
                }
            }

            result = new_result;
        }

        result
    }

    fn compute_au(&self, left_states: &HashSet<usize>, right_states: &HashSet<usize>) -> HashSet<usize> {
        let mut result = right_states.clone();
        let mut changed = true;

        while changed {
            changed = false;
            let mut new_result = result.clone();

            for state in 0..self.kripke.states.len() {
                if !result.contains(&state) && left_states.contains(&state) {
                    if let Some(successors) = self.kripke.transitions.get(&state) {
                        if successors.iter().all(|&s| result.contains(&s)) {
                            new_result.insert(state);
                            changed = true;
                        }
                    }
                }
            }

            result = new_result;
        }

        result
    }

    fn compute_eu(&self, left_states: &HashSet<usize>, right_states: &HashSet<usize>) -> HashSet<usize> {
        let mut result = right_states.clone();
        let mut changed = true;

        while changed {
            changed = false;
            let mut new_result = result.clone();

            for state in 0..self.kripke.states.len() {
                if !result.contains(&state) && left_states.contains(&state) {
                    if let Some(successors) = self.kripke.transitions.get(&state) {
                        if successors.iter().any(|&s| result.contains(&s)) {
                            new_result.insert(state);
                            changed = true;
                        }
                    }
                }
            }

            result = new_result;
        }

        result
    }
}
```

### 4.2 éœå°”é€»è¾‘éªŒè¯å™¨å®ç°

```rust
use std::collections::HashMap;

// ç¨‹åºè¯­å¥å®šä¹‰
# [derive(Debug, Clone)]
pub enum Statement {
    Skip,
    Assignment(String, Expression),
    Sequence(Box<Statement>, Box<Statement>),
    IfThenElse(Expression, Box<Statement>, Box<Statement>),
    While(Expression, Box<Statement>),
}

// è¡¨è¾¾å¼å®šä¹‰
# [derive(Debug, Clone)]
pub enum Expression {
    Variable(String),
    Constant(i64),
    BinaryOp(Box<Expression>, BinaryOperator, Box<Expression>),
}

# [derive(Debug, Clone)]
pub enum BinaryOperator {
    Add,
    Sub,
    Mul,
    Div,
    Eq,
    Ne,
    Lt,
    Le,
    Gt,
    Ge,
    And,
    Or,
}

// éœå°”é€»è¾‘éªŒè¯å™¨
pub struct HoareVerifier {
    environment: HashMap<String, i64>,
}

impl HoareVerifier {
    pub fn new() -> Self {
        Self {
            environment: HashMap::new(),
        }
    }

    pub fn verify(&mut self, precondition: &Expression, statement: &Statement, postcondition: &Expression) -> bool {
        // è®¡ç®—æœ€å¼±å‰ç½®æ¡ä»¶
        let wp = self.weakest_precondition(statement, postcondition);

        // æ£€æŸ¥å‰ç½®æ¡ä»¶æ˜¯å¦è•´å«æœ€å¼±å‰ç½®æ¡ä»¶
        self.implies(precondition, &wp)
    }

    fn weakest_precondition(&self, statement: &Statement, postcondition: &Expression) -> Expression {
        match statement {
            Statement::Skip => postcondition.clone(),
            Statement::Assignment(var, expr) => {
                self.substitute(postcondition, var, expr)
            }
            Statement::Sequence(stmt1, stmt2) => {
                let wp2 = self.weakest_precondition(stmt2, postcondition);
                self.weakest_precondition(stmt1, &wp2)
            }
            Statement::IfThenElse(condition, then_stmt, else_stmt) => {
                let wp_then = self.weakest_precondition(then_stmt, postcondition);
                let wp_else = self.weakest_precondition(else_stmt, postcondition);

                Expression::BinaryOp(
                    Box::new(condition.clone()),
                    BinaryOperator::And,
                    Box::new(wp_then)
                ).or(Expression::BinaryOp(
                    Box::new(Expression::BinaryOp(
                        Box::new(condition.clone()),
                        BinaryOperator::Not,
                        Box::new(Expression::Constant(0))
                    )),
                    BinaryOperator::And,
                    Box::new(wp_else)
                ))
            }
            Statement::While(condition, body) => {
                // ç®€åŒ–å®ç°ï¼šå‡è®¾å¾ªç¯ä¸å˜å¼
                postcondition.clone()
            }
        }
    }

    fn substitute(&self, expression: &Expression, variable: &str, value: &Expression) -> Expression {
        match expression {
            Expression::Variable(var) => {
                if var == variable {
                    value.clone()
                } else {
                    expression.clone()
                }
            }
            Expression::Constant(_) => expression.clone(),
            Expression::BinaryOp(left, op, right) => {
                Expression::BinaryOp(
                    Box::new(self.substitute(left, variable, value)),
                    op.clone(),
                    Box::new(self.substitute(right, variable, value))
                )
            }
        }
    }

    fn implies(&self, antecedent: &Expression, consequent: &Expression) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥é€»è¾‘è•´å«
        // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œä¼šä½¿ç”¨SATæ±‚è§£å™¨æˆ–å®šç†è¯æ˜å™¨
        true
    }
}

// è¡¨è¾¾å¼æ‰©å±•æ–¹æ³•
impl Expression {
    fn or(self, other: Expression) -> Expression {
        Expression::BinaryOp(Box::new(self), BinaryOperator::Or, Box::new(other))
    }
}
```

### 4.3 æŠ½è±¡è§£é‡Šå™¨å®ç°

```rust
use std::collections::HashMap;

// æŠ½è±¡åŸŸå®šä¹‰
# [derive(Debug, Clone)]
pub enum AbstractValue {
    Top,
    Bottom,
    Interval(i64, i64),
    Constant(i64),
}

// æŠ½è±¡è§£é‡Šå™¨
pub struct AbstractInterpreter {
    abstract_domain: HashMap<String, AbstractValue>,
}

impl AbstractInterpreter {
    pub fn new() -> Self {
        Self {
            abstract_domain: HashMap::new(),
        }
    }

    pub fn analyze(&mut self, statement: &Statement) -> HashMap<String, AbstractValue> {
        match statement {
            Statement::Skip => self.abstract_domain.clone(),
            Statement::Assignment(var, expr) => {
                let value = self.abstract_evaluate(expr);
                self.abstract_domain.insert(var.clone(), value);
                self.abstract_domain.clone()
            }
            Statement::Sequence(stmt1, stmt2) => {
                self.analyze(stmt1);
                self.analyze(stmt2);
                self.abstract_domain.clone()
            }
            Statement::IfThenElse(condition, then_stmt, else_stmt) => {
                let condition_value = self.abstract_evaluate(condition);

                match condition_value {
                    AbstractValue::Constant(0) => {
                        self.analyze(else_stmt);
                    }
                    AbstractValue::Constant(_) => {
                        self.analyze(then_stmt);
                    }
                    _ => {
                        // åˆ†æ”¯åˆå¹¶
                        let then_domain = self.abstract_domain.clone();
                        self.analyze(then_stmt);
                        let then_result = self.abstract_domain.clone();

                        self.abstract_domain = then_domain;
                        self.analyze(else_stmt);
                        let else_result = self.abstract_domain.clone();

                        self.abstract_domain = self.merge_domains(&then_result, &else_result);
                    }
                }

                self.abstract_domain.clone()
            }
            Statement::While(condition, body) => {
                let mut iteration_count = 0;
                let max_iterations = 10; // é˜²æ­¢æ— é™å¾ªç¯

                while iteration_count < max_iterations {
                    let condition_value = self.abstract_evaluate(condition);

                    match condition_value {
                        AbstractValue::Constant(0) => break,
                        AbstractValue::Bottom => break,
                        _ => {
                            self.analyze(body);
                            iteration_count += 1;
                        }
                    }
                }

                self.abstract_domain.clone()
            }
        }
    }

    fn abstract_evaluate(&self, expression: &Expression) -> AbstractValue {
        match expression {
            Expression::Variable(var) => {
                self.abstract_domain.get(var).cloned().unwrap_or(AbstractValue::Top)
            }
            Expression::Constant(value) => {
                AbstractValue::Constant(*value)
            }
            Expression::BinaryOp(left, op, right) => {
                let left_val = self.abstract_evaluate(left);
                let right_val = self.abstract_evaluate(right);

                self.abstract_binary_op(&left_val, op, &right_val)
            }
        }
    }

    fn abstract_binary_op(&self, left: &AbstractValue, op: &BinaryOperator, right: &AbstractValue) -> AbstractValue {
        match (left, op, right) {
            (AbstractValue::Constant(l), BinaryOperator::Add, AbstractValue::Constant(r)) => {
                AbstractValue::Constant(l + r)
            }
            (AbstractValue::Constant(l), BinaryOperator::Sub, AbstractValue::Constant(r)) => {
                AbstractValue::Constant(l - r)
            }
            (AbstractValue::Constant(l), BinaryOperator::Mul, AbstractValue::Constant(r)) => {
                AbstractValue::Constant(l * r)
            }
            (AbstractValue::Interval(l1, l2), BinaryOperator::Add, AbstractValue::Interval(r1, r2)) => {
                AbstractValue::Interval(l1 + r1, l2 + r2)
            }
            (AbstractValue::Interval(l1, l2), BinaryOperator::Sub, AbstractValue::Interval(r1, r2)) => {
                AbstractValue::Interval(l1 - r2, l2 - r1)
            }
            _ => AbstractValue::Top,
        }
    }

    fn merge_domains(&self, domain1: &HashMap<String, AbstractValue>, domain2: &HashMap<String, AbstractValue>) -> HashMap<String, AbstractValue> {
        let mut merged = HashMap::new();

        for (var, val1) in domain1 {
            if let Some(val2) = domain2.get(var) {
                merged.insert(var.clone(), self.merge_values(val1, val2));
            } else {
                merged.insert(var.clone(), val1.clone());
            }
        }

        for (var, val2) in domain2 {
            if !domain1.contains_key(var) {
                merged.insert(var.clone(), val2.clone());
            }
        }

        merged
    }

    fn merge_values(&self, val1: &AbstractValue, val2: &AbstractValue) -> AbstractValue {
        match (val1, val2) {
            (AbstractValue::Constant(c1), AbstractValue::Constant(c2)) => {
                if c1 == c2 {
                    AbstractValue::Constant(*c1)
                } else {
                    AbstractValue::Interval(*c1.min(c2), *c1.max(c2))
                }
            }
            (AbstractValue::Interval(l1, l2), AbstractValue::Interval(r1, r2)) => {
                AbstractValue::Interval(l1.min(*r1), l2.max(*r2))
            }
            _ => AbstractValue::Top,
        }
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 äº’æ–¥é”éªŒè¯

```rust
use std::sync::{Arc, Mutex};
use std::thread;

// äº’æ–¥é”çŠ¶æ€æœº
pub struct MutexStateMachine {
    states: Vec<String>,
    initial_state: usize,
    transitions: HashMap<usize, Vec<usize>>,
    labels: HashMap<usize, HashSet<String>>,
}

impl MutexStateMachine {
    pub fn new() -> Self {
        let mut transitions = HashMap::new();
        transitions.insert(0, vec![1]); // unlocked -> locked
        transitions.insert(1, vec![0]); // locked -> unlocked

        let mut labels = HashMap::new();
        labels.insert(0, vec!["unlocked".to_string()].into_iter().collect());
        labels.insert(1, vec!["locked".to_string()].into_iter().collect());

        Self {
            states: vec!["unlocked".to_string(), "locked".to_string()],
            initial_state: 0,
            transitions,
            labels,
        }
    }

    pub fn to_kripke(&self) -> KripkeStructure {
        KripkeStructure {
            states: self.states.clone(),
            initial_states: vec![self.initial_state].into_iter().collect(),
            transitions: self.transitions.clone(),
            labels: self.labels.clone(),
            atomic_propositions: vec!["unlocked".to_string(), "locked".to_string()].into_iter().collect(),
        }
    }
}

// äº’æ–¥é”éªŒè¯ç¤ºä¾‹
pub struct MutexVerificationExample {
    model_checker: ModelChecker,
}

impl MutexVerificationExample {
    pub fn new() -> Self {
        let mutex_sm = MutexStateMachine::new();
        let kripke = mutex_sm.to_kripke();
        let model_checker = ModelChecker::new(kripke);

        Self { model_checker }
    }

    pub fn verify_mutex_properties(&self) -> HashMap<String, bool> {
        let mut results = HashMap::new();

        // æ€§è´¨1: äº’æ–¥æ€§ - ä¸èƒ½åŒæ—¶å¤„äºlockedå’ŒunlockedçŠ¶æ€
        let mutex_property = CTLFormula::AG(Box::new(CTLFormula::Not(Box::new(
            CTLFormula::And(
                Box::new(CTLFormula::Atomic("locked".to_string())),
                Box::new(CTLFormula::Atomic("unlocked".to_string()))
            )
        ))));
        results.insert("mutual_exclusion".to_string(), self.model_checker.check(&mutex_property));

        // æ€§è´¨2: å¯è¾¾æ€§ - ä»unlockedçŠ¶æ€å¯ä»¥åˆ°è¾¾lockedçŠ¶æ€
        let reachability_property = CTLFormula::EF(Box::new(CTLFormula::Atomic("locked".to_string())));
        results.insert("reachability".to_string(), self.model_checker.check(&reachability_property));

        // æ€§è´¨3: å…¬å¹³æ€§ - å¦‚æœå¤„äºlockedçŠ¶æ€ï¼Œæœ€ç»ˆä¼šå›åˆ°unlockedçŠ¶æ€
        let fairness_property = CTLFormula::AG(Box::new(CTLFormula::Implies(
            Box::new(CTLFormula::Atomic("locked".to_string())),
            Box::new(CTLFormula::AF(Box::new(CTLFormula::Atomic("unlocked".to_string()))))
        )));
        results.insert("fairness".to_string(), self.model_checker.check(&fairness_property));

        results
    }
}

// CTLå…¬å¼æ‰©å±•
impl CTLFormula {
    fn implies(left: Box<CTLFormula>, right: Box<CTLFormula>) -> CTLFormula {
        CTLFormula::Or(Box::new(CTLFormula::Not(left)), right)
    }
}
```

### 5.2 ç¨‹åºæ­£ç¡®æ€§éªŒè¯

```rust
// ç¨‹åºæ­£ç¡®æ€§éªŒè¯ç¤ºä¾‹
pub struct ProgramCorrectnessExample {
    hoare_verifier: HoareVerifier,
    abstract_interpreter: AbstractInterpreter,
}

impl ProgramCorrectnessExample {
    pub fn new() -> Self {
        Self {
            hoare_verifier: HoareVerifier::new(),
            abstract_interpreter: AbstractInterpreter::new(),
        }
    }

    pub fn verify_factorial_program(&mut self) -> bool {
        // é˜¶ä¹˜ç¨‹åºï¼š{n >= 0} fact := 1; i := 0; while i < n do i := i + 1; fact := fact * i od {fact = n!}

        let n_var = Expression::Variable("n".to_string());
        let fact_var = Expression::Variable("fact".to_string());
        let i_var = Expression::Variable("i".to_string());

        // å‰ç½®æ¡ä»¶ï¼šn >= 0
        let precondition = Expression::BinaryOp(
            Box::new(n_var.clone()),
            BinaryOperator::Ge,
            Box::new(Expression::Constant(0))
        );

        // ç¨‹åºï¼šfact := 1; i := 0; while i < n do i := i + 1; fact := fact * i od
        let program = Statement::Sequence(
            Box::new(Statement::Assignment("fact".to_string(), Expression::Constant(1))),
            Box::new(Statement::Sequence(
                Box::new(Statement::Assignment("i".to_string(), Expression::Constant(0))),
                Box::new(Statement::While(
                    Expression::BinaryOp(
                        Box::new(i_var.clone()),
                        BinaryOperator::Lt,
                        Box::new(n_var.clone())
                    ),
                    Box::new(Statement::Sequence(
                        Box::new(Statement::Assignment("i".to_string(),
                            Expression::BinaryOp(
                                Box::new(i_var.clone()),
                                BinaryOperator::Add,
                                Box::new(Expression::Constant(1))
                            )
                        )),
                        Box::new(Statement::Assignment("fact".to_string(),
                            Expression::BinaryOp(
                                Box::new(fact_var.clone()),
                                BinaryOperator::Mul,
                                Box::new(i_var.clone())
                            )
                        ))
                    ))
                ))
            ))
        );

        // åç½®æ¡ä»¶ï¼šfact = n!
        // ç®€åŒ–å®ç°ï¼šfact >= 1
        let postcondition = Expression::BinaryOp(
            Box::new(fact_var.clone()),
            BinaryOperator::Ge,
            Box::new(Expression::Constant(1))
        );

        // ä½¿ç”¨éœå°”é€»è¾‘éªŒè¯
        let hoare_result = self.hoare_verifier.verify(&precondition, &program, &postcondition);

        // ä½¿ç”¨æŠ½è±¡è§£é‡ŠéªŒè¯
        let abstract_result = self.abstract_interpreter.analyze(&program);

        println!("Hoare logic verification result: {}", hoare_result);
        println!("Abstract interpretation result: {:?}", abstract_result);

        hoare_result
    }
}

# [tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== Formal Verification Methods Example ===");

    // äº’æ–¥é”éªŒè¯
    let mutex_example = MutexVerificationExample::new();
    let mutex_results = mutex_example.verify_mutex_properties();
    println!("Mutex verification results: {:?}", mutex_results);

    // ç¨‹åºæ­£ç¡®æ€§éªŒè¯
    let mut program_example = ProgramCorrectnessExample::new();
    let program_result = program_example.verify_factorial_program();
    println!("Program correctness verification result: {}", program_result);

    Ok(())
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å½¢å¼åŒ–æ–¹æ³•ç†è®ºçš„å…³ç³»
å½¢å¼åŒ–éªŒè¯æ–¹æ³•æ˜¯å½¢å¼åŒ–æ–¹æ³•ç†è®ºçš„æ ¸å¿ƒï¼Œä¸ºè½¯ä»¶ç³»ç»Ÿçš„æ­£ç¡®æ€§æä¾›æ•°å­¦ä¿è¯ã€‚

### 6.2 ä¸è½¯ä»¶å·¥ç¨‹ç†è®ºçš„å…³ç³»
å½¢å¼åŒ–éªŒè¯æ–¹æ³•ä¸è½¯ä»¶å·¥ç¨‹çš„è´¨é‡ä¿è¯å¯†åˆ‡ç›¸å…³ï¼Œæ˜¯ç¡®ä¿è½¯ä»¶è´¨é‡çš„é‡è¦æ‰‹æ®µã€‚

### 6.3 ä¸å½¢å¼è¯­è¨€ç†è®ºçš„å…³ç³»
å½¢å¼åŒ–éªŒè¯æ–¹æ³•å»ºç«‹åœ¨å½¢å¼è¯­è¨€ç†è®ºåŸºç¡€ä¸Šï¼Œä½¿ç”¨å½¢å¼è¯­è¨€æè¿°ç³»ç»Ÿè¡Œä¸ºå’Œæ€§è´¨ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Clarke, E. M., Grumberg, O., & Peled, D. A. (1999). Model Checking. MIT Press.

2. Huth, M., & Ryan, M. (2004). Logic in Computer Science: Modelling and Reasoning about Systems (2nd ed.). Cambridge University Press.

3. Cousot, P., & Cousot, R. (1977). Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints. In Proceedings of the 4th ACM SIGACT-SIGPLAN symposium on Principles of programming languages (pp. 238-252).

4. Hoare, C. A. R. (1969). An axiomatic basis for computer programming. Communications of the ACM, 12(10), 576-580.

5. Baier, C., & Katoen, J. P. (2008). Principles of Model Checking. MIT Press.

---

**ç›¸å…³æ–‡æ¡£**:
- [07.1.1 å½¢å¼åŒ–è§„æ ¼è¯´æ˜](../07_Software_Engineering_Theory/07.1.1_å½¢å¼åŒ–è§„æ ¼è¯´æ˜.md)
- [07.1.3 æ¨¡å‹é©±åŠ¨å¼€å‘](../07_Software_Engineering_Theory/07.1.3_æ¨¡å‹é©±åŠ¨å¼€å‘.md)
- [07.1.4 å¥‘çº¦å¼ç¼–ç¨‹](../07_Software_Engineering_Theory/07.1.4_å¥‘çº¦å¼ç¼–ç¨‹.md)
