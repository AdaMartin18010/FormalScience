# 07.2.1 æ¶æ„è®¾è®¡åŸåˆ™

## ğŸ“‹ æ¦‚è¿°

æ¶æ„è®¾è®¡åŸåˆ™æ˜¯è½¯ä»¶å·¥ç¨‹ç†è®ºçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œç ”ç©¶è½¯ä»¶ç³»ç»Ÿæ¶æ„è®¾è®¡çš„åŸºæœ¬åŸç†ã€æ¨¡å¼å’Œæœ€ä½³å®è·µã€‚æœ¬ç†è®ºä¸ºæ„å»ºé«˜è´¨é‡ã€å¯ç»´æŠ¤ã€å¯æ‰©å±•çš„è½¯ä»¶ç³»ç»Ÿæä¾›ç†è®ºåŸºç¡€å’Œæ–¹æ³•è®ºæŒ‡å¯¼ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹æ¶æ„è®¾è®¡çš„å½¢å¼åŒ–ç†è®ºåŸºç¡€**
2. **æä¾›æ¶æ„è®¾è®¡çš„åŸºæœ¬åŸåˆ™**
3. **ç¡®ä¿æ¶æ„çš„è´¨é‡å±æ€§**
4. **æ”¯æŒæ¶æ„çš„æ¼”è¿›å’Œç»´æŠ¤**
5. **ä¿ƒè¿›æ¶æ„è®¾è®¡çš„ç§‘å­¦åŒ–**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è½¯ä»¶æ¶æ„

**å®šä¹‰ 1.1.1** (è½¯ä»¶æ¶æ„)
è½¯ä»¶æ¶æ„æ˜¯ä¸€ä¸ªå››å…ƒç»„ $(C, L, P, Q)$ï¼Œå…¶ä¸­ï¼š

- $C$: ç»„ä»¶é›†åˆ
- $L$: è¿æ¥å™¨é›†åˆ
- $P$: ç«¯å£é›†åˆ
- $Q$: è´¨é‡å±æ€§é›†åˆ

### 1.2 æ¶æ„è®¾è®¡åŸåˆ™

**å®šä¹‰ 1.2.1** (å•ä¸€èŒè´£åŸåˆ™)
æ¯ä¸ªç»„ä»¶åº”è¯¥åªæœ‰ä¸€ä¸ªæ”¹å˜çš„ç†ç”±ï¼š
$$\forall c \in C: |Responsibilities(c)| = 1$$

**å®šä¹‰ 1.2.2** (å¼€é—­åŸåˆ™)
è½¯ä»¶å®ä½“åº”è¯¥å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­ï¼š
$$\forall c \in C: Extensible(c) \land \neg Modifiable(c)$$

**å®šä¹‰ 1.2.3** (é‡Œæ°æ›¿æ¢åŸåˆ™)
å­ç±»å‹å¿…é¡»èƒ½å¤Ÿæ›¿æ¢å…¶åŸºç±»å‹ï¼š
$$\forall s \in Subtypes, b \in BaseTypes: s \preceq b \Rightarrow Replaceable(s, b)$$

### 1.3 æ¶æ„è´¨é‡å±æ€§

**å®šä¹‰ 1.3.1** (å¯ç»´æŠ¤æ€§)
è½¯ä»¶ç³»ç»Ÿæ˜“äºä¿®æ”¹å’Œç»´æŠ¤çš„ç¨‹åº¦ï¼š
$$Maintainability(S) = \frac{1}{Complexity(S)}$$

**å®šä¹‰ 1.3.2** (å¯æ‰©å±•æ€§)
è½¯ä»¶ç³»ç»Ÿæ˜“äºæ‰©å±•æ–°åŠŸèƒ½çš„èƒ½åŠ›ï¼š
$$Extensibility(S) = \frac{NewFeatures(S)}{Effort(S)}$$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ç»„ä»¶æ¨¡å‹

**å®šä¹‰ 2.1.1** (ç»„ä»¶)
ç»„ä»¶æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $(id, interface, implementation, state, behavior)$ï¼Œå…¶ä¸­ï¼š

- $id$: ç»„ä»¶æ ‡è¯†ç¬¦
- $interface$: æ¥å£å®šä¹‰
- $implementation$: å®ç°ç»†èŠ‚
- $state$: å†…éƒ¨çŠ¶æ€
- $behavior$: è¡Œä¸ºè§„èŒƒ

**å®šä¹‰ 2.1.2** (æ¥å£)
æ¥å£æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(inputs, outputs, contracts)$ï¼Œå…¶ä¸­ï¼š

- $inputs$: è¾“å…¥å‚æ•°é›†åˆ
- $outputs$: è¾“å‡ºå‚æ•°é›†åˆ
- $contracts$: å¥‘çº¦é›†åˆ

### 2.2 è¿æ¥å™¨æ¨¡å‹

**å®šä¹‰ 2.2.1** (è¿æ¥å™¨)
è¿æ¥å™¨æ˜¯ä¸€ä¸ªå››å…ƒç»„ $(id, type, endpoints, protocol)$ï¼Œå…¶ä¸­ï¼š

- $id$: è¿æ¥å™¨æ ‡è¯†ç¬¦
- $type$: è¿æ¥å™¨ç±»å‹
- $endpoints$: ç«¯ç‚¹é›†åˆ
- $protocol$: é€šä¿¡åè®®

**å®šä¹‰ 2.2.2** (è¿æ¥å™¨ç±»å‹)
è¿æ¥å™¨ç±»å‹åŒ…æ‹¬ï¼š

- $Synchronous$: åŒæ­¥è¿æ¥å™¨
- $Asynchronous$: å¼‚æ­¥è¿æ¥å™¨
- $EventBased$: äº‹ä»¶é©±åŠ¨è¿æ¥å™¨
- $MessageBased$: æ¶ˆæ¯ä¼ é€’è¿æ¥å™¨

### 2.3 æ¶æ„æ¨¡å¼

**å®šä¹‰ 2.3.1** (åˆ†å±‚æ¶æ„)
åˆ†å±‚æ¶æ„æ˜¯ä¸€ä¸ªæœ‰åºçš„ç»„ä»¶åºåˆ—ï¼š
$$LayeredArch = [L_1, L_2, ..., L_n]$$
å…¶ä¸­ $\forall i < j: L_i \prec L_j$ï¼ˆä¸Šå±‚ä¾èµ–ä¸‹å±‚ï¼‰

**å®šä¹‰ 2.3.2** (å¾®æœåŠ¡æ¶æ„)
å¾®æœåŠ¡æ¶æ„æ˜¯ç‹¬ç«‹æœåŠ¡çš„é›†åˆï¼š
$$MicroservicesArch = \{S_1, S_2, ..., S_n\}$$
å…¶ä¸­ $\forall i \neq j: Independent(S_i, S_j)$

## 3. å®šç†ä¸è¯æ˜

### 3.1 å•ä¸€èŒè´£åŸåˆ™çš„æ­£ç¡®æ€§

**å®šç† 3.1.1** (å•ä¸€èŒè´£åŸåˆ™)
éµå¾ªå•ä¸€èŒè´£åŸåˆ™çš„ç»„ä»¶å…·æœ‰æ›´é«˜çš„å†…èšæ€§å’Œæ›´ä½çš„è€¦åˆæ€§ã€‚

**è¯æ˜**:
è®¾ $C$ æ˜¯ä¸€ä¸ªéµå¾ªå•ä¸€èŒè´£åŸåˆ™çš„ç»„ä»¶ã€‚

**å†…èšæ€§è¯æ˜**:

- å•ä¸€èŒè´£æ„å‘³ç€ç»„ä»¶å†…éƒ¨å…ƒç´ é«˜åº¦ç›¸å…³
- å†…èšæ€§ $Cohesion(C) = \frac{InternalRelations(C)}{TotalElements(C)} \to 1$

**è€¦åˆæ€§è¯æ˜**:

- å•ä¸€èŒè´£å‡å°‘äº†ä¸å…¶ä»–ç»„ä»¶çš„äº¤äº’ç‚¹
- è€¦åˆæ€§ $Coupling(C) = \frac{ExternalDependencies(C)}{TotalDependencies(C)} \to 0$

### 3.2 å¼€é—­åŸåˆ™çš„å¯æ‰©å±•æ€§

**å®šç† 3.2.1** (å¼€é—­åŸåˆ™)
éµå¾ªå¼€é—­åŸåˆ™çš„ç³»ç»Ÿå…·æœ‰æ›´å¥½çš„å¯æ‰©å±•æ€§ã€‚

**è¯æ˜**:
è®¾ $S$ æ˜¯ä¸€ä¸ªéµå¾ªå¼€é—­åŸåˆ™çš„ç³»ç»Ÿã€‚

**æ‰©å±•æ€§è¯æ˜**:

- æ–°åŠŸèƒ½é€šè¿‡æ‰©å±•å®ç°ï¼Œä¸ä¿®æ”¹ç°æœ‰ä»£ç 
- æ‰©å±•æˆæœ¬ $Cost_{extend} < Cost_{modify}$
- å¯æ‰©å±•æ€§ $Extensibility(S) = \frac{NewFeatures(S)}{Cost_{extend}} \to \infty$

### 3.3 åˆ†å±‚æ¶æ„çš„ä¾èµ–å…³ç³»

**å®šç† 3.3.1** (åˆ†å±‚æ¶æ„ä¾èµ–)
åˆ†å±‚æ¶æ„ä¸­çš„ä¾èµ–å…³ç³»æ˜¯ä¼ é€’çš„ä¸”æ— ç¯çš„ã€‚

**è¯æ˜**:
è®¾ $LayeredArch = [L_1, L_2, ..., L_n]$ æ˜¯ä¸€ä¸ªåˆ†å±‚æ¶æ„ã€‚

**ä¼ é€’æ€§è¯æ˜**:

- $\forall i < j < k: L_i \prec L_j \land L_j \prec L_k \Rightarrow L_i \prec L_k$

**æ— ç¯æ€§è¯æ˜**:

- å‡è®¾å­˜åœ¨ç¯ï¼š$L_i \prec L_j \prec ... \prec L_i$
- è¿™ä¸å±‚çš„é¡ºåºå…³ç³»çŸ›ç›¾
- å› æ­¤ä¸å­˜åœ¨ç¯

## 4. ä»£ç å®ç°

### 4.1 åˆ†å±‚æ¶æ„å®ç°

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc;
use serde::{Serialize, Deserialize};

// åˆ†å±‚æ¶æ„çš„åŸºç¡€ç»„ä»¶
pub trait Layer {
    fn process(&self, input: &str) -> Result<String, Box<dyn std::error::Error>>;
    fn get_name(&self) -> &str;
}

// è¡¨ç¤ºå±‚
pub struct PresentationLayer {
    name: String,
    next_layer: Option<Arc<dyn Layer>>,
}

impl PresentationLayer {
    pub fn new(name: String, next_layer: Option<Arc<dyn Layer>>) -> Self {
        Self { name, next_layer }
    }
}

impl Layer for PresentationLayer {
    fn process(&self, input: &str) -> Result<String, Box<dyn std::error::Error>> {
        println!("Presentation layer processing: {}", input);
        
        // è¡¨ç¤ºå±‚å¤„ç†ï¼šæ ¼å¼åŒ–è¾“å…¥
        let formatted_input = format!("[FORMATTED] {}", input);
        
        // ä¼ é€’ç»™ä¸‹ä¸€å±‚
        if let Some(next) = &self.next_layer {
            let result = next.process(&formatted_input)?;
            Ok(format!("[PRESENTATION] {}", result))
        } else {
            Ok(formatted_input)
        }
    }

    fn get_name(&self) -> &str {
        &self.name
    }
}

// ä¸šåŠ¡é€»è¾‘å±‚
pub struct BusinessLogicLayer {
    name: String,
    next_layer: Option<Arc<dyn Layer>>,
    business_rules: HashMap<String, String>,
}

impl BusinessLogicLayer {
    pub fn new(name: String, next_layer: Option<Arc<dyn Layer>>) -> Self {
        let mut business_rules = HashMap::new();
        business_rules.insert("validate".to_string(), "Business validation rule".to_string());
        business_rules.insert("calculate".to_string(), "Business calculation rule".to_string());
        
        Self {
            name,
            next_layer,
            business_rules,
        }
    }
}

impl Layer for BusinessLogicLayer {
    fn process(&self, input: &str) -> Result<String, Box<dyn std::error::Error>> {
        println!("Business logic layer processing: {}", input);
        
        // ä¸šåŠ¡é€»è¾‘å¤„ç†ï¼šåº”ç”¨ä¸šåŠ¡è§„åˆ™
        let mut processed_input = input.to_string();
        for (rule, _) in &self.business_rules {
            processed_input = format!("[RULE: {}] {}", rule, processed_input);
        }
        
        // ä¼ é€’ç»™ä¸‹ä¸€å±‚
        if let Some(next) = &self.next_layer {
            let result = next.process(&processed_input)?;
            Ok(format!("[BUSINESS] {}", result))
        } else {
            Ok(processed_input)
        }
    }

    fn get_name(&self) -> &str {
        &self.name
    }
}

// æ•°æ®è®¿é—®å±‚
pub struct DataAccessLayer {
    name: String,
    database: Arc<Mutex<HashMap<String, String>>>,
}

impl DataAccessLayer {
    pub fn new(name: String) -> Self {
        let mut database = HashMap::new();
        database.insert("user:1".to_string(), "Alice".to_string());
        database.insert("user:2".to_string(), "Bob".to_string());
        
        Self {
            name,
            database: Arc::new(Mutex::new(database)),
        }
    }
}

impl Layer for DataAccessLayer {
    fn process(&self, input: &str) -> Result<String, Box<dyn std::error::Error>> {
        println!("Data access layer processing: {}", input);
        
        // æ•°æ®è®¿é—®å¤„ç†ï¼šæŸ¥è¯¢æ•°æ®åº“
        let database = self.database.lock().unwrap();
        let result = if input.contains("user:1") {
            database.get("user:1").cloned().unwrap_or_default()
        } else if input.contains("user:2") {
            database.get("user:2").cloned().unwrap_or_default()
        } else {
            "Unknown user".to_string()
        };
        
        Ok(format!("[DATA] {}", result))
    }

    fn get_name(&self) -> &str {
        &self.name
    }
}

// åˆ†å±‚æ¶æ„ç®¡ç†å™¨
pub struct LayeredArchitecture {
    layers: Vec<Arc<dyn Layer>>,
}

impl LayeredArchitecture {
    pub fn new() -> Self {
        Self { layers: Vec::new() }
    }

    pub fn add_layer(&mut self, layer: Arc<dyn Layer>) {
        self.layers.push(layer);
    }

    pub fn build_layered_system() -> Self {
        let mut architecture = LayeredArchitecture::new();
        
        // åˆ›å»ºæ•°æ®è®¿é—®å±‚
        let data_layer = Arc::new(DataAccessLayer::new("DataAccess".to_string()));
        
        // åˆ›å»ºä¸šåŠ¡é€»è¾‘å±‚
        let business_layer = Arc::new(BusinessLogicLayer::new(
            "BusinessLogic".to_string(),
            Some(data_layer),
        ));
        
        // åˆ›å»ºè¡¨ç¤ºå±‚
        let presentation_layer = Arc::new(PresentationLayer::new(
            "Presentation".to_string(),
            Some(business_layer),
        ));
        
        architecture.add_layer(presentation_layer);
        architecture
    }

    pub fn process_request(&self, input: &str) -> Result<String, Box<dyn std::error::Error>> {
        if let Some(top_layer) = self.layers.first() {
            top_layer.process(input)
        } else {
            Err("No layers available".into())
        }
    }
}
```

### 4.2 å¾®æœåŠ¡æ¶æ„å®ç°

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc;
use serde::{Serialize, Deserialize};

// å¾®æœåŠ¡æ¥å£
pub trait Microservice {
    fn get_name(&self) -> &str;
    fn get_version(&self) -> &str;
    fn process_request(&self, request: ServiceRequest) -> Result<ServiceResponse, Box<dyn std::error::Error>>;
    fn health_check(&self) -> bool;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceRequest {
    service_name: String,
    method: String,
    parameters: HashMap<String, String>,
    request_id: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceResponse {
    service_name: String,
    result: String,
    status: String,
    request_id: String,
}

// ç”¨æˆ·æœåŠ¡
pub struct UserService {
    name: String,
    version: String,
    users: Arc<Mutex<HashMap<String, User>>>,
}

#[derive(Debug, Clone)]
pub struct User {
    id: String,
    name: String,
    email: String,
}

impl UserService {
    pub fn new() -> Self {
        let mut users = HashMap::new();
        users.insert("1".to_string(), User {
            id: "1".to_string(),
            name: "Alice".to_string(),
            email: "alice@example.com".to_string(),
        });
        users.insert("2".to_string(), User {
            id: "2".to_string(),
            name: "Bob".to_string(),
            email: "bob@example.com".to_string(),
        });
        
        Self {
            name: "UserService".to_string(),
            version: "1.0.0".to_string(),
            users: Arc::new(Mutex::new(users)),
        }
    }
}

impl Microservice for UserService {
    fn get_name(&self) -> &str {
        &self.name
    }

    fn get_version(&self) -> &str {
        &self.version
    }

    fn process_request(&self, request: ServiceRequest) -> Result<ServiceResponse, Box<dyn std::error::Error>> {
        println!("UserService processing request: {:?}", request);
        
        let users = self.users.lock().unwrap();
        let result = match request.method.as_str() {
            "get_user" => {
                if let Some(user_id) = request.parameters.get("user_id") {
                    if let Some(user) = users.get(user_id) {
                        format!("User: {} ({})", user.name, user.email)
                    } else {
                        "User not found".to_string()
                    }
                } else {
                    "Missing user_id parameter".to_string()
                }
            }
            "list_users" => {
                let user_list: Vec<String> = users.values()
                    .map(|u| format!("{}: {}", u.id, u.name))
                    .collect();
                user_list.join(", ")
            }
            _ => "Unknown method".to_string(),
        };
        
        Ok(ServiceResponse {
            service_name: self.name.clone(),
            result,
            status: "success".to_string(),
            request_id: request.request_id,
        })
    }

    fn health_check(&self) -> bool {
        true
    }
}

// è®¢å•æœåŠ¡
pub struct OrderService {
    name: String,
    version: String,
    orders: Arc<Mutex<HashMap<String, Order>>>,
}

#[derive(Debug, Clone)]
pub struct Order {
    id: String,
    user_id: String,
    items: Vec<String>,
    total: f64,
}

impl OrderService {
    pub fn new() -> Self {
        let mut orders = HashMap::new();
        orders.insert("1".to_string(), Order {
            id: "1".to_string(),
            user_id: "1".to_string(),
            items: vec!["Book".to_string(), "Pen".to_string()],
            total: 25.50,
        });
        
        Self {
            name: "OrderService".to_string(),
            version: "1.0.0".to_string(),
            orders: Arc::new(Mutex::new(orders)),
        }
    }
}

impl Microservice for OrderService {
    fn get_name(&self) -> &str {
        &self.name
    }

    fn get_version(&self) -> &str {
        &self.version
    }

    fn process_request(&self, request: ServiceRequest) -> Result<ServiceResponse, Box<dyn std::error::Error>> {
        println!("OrderService processing request: {:?}", request);
        
        let orders = self.orders.lock().unwrap();
        let result = match request.method.as_str() {
            "get_order" => {
                if let Some(order_id) = request.parameters.get("order_id") {
                    if let Some(order) = orders.get(order_id) {
                        format!("Order {}: {} items, total ${:.2}", 
                                order.id, order.items.len(), order.total)
                    } else {
                        "Order not found".to_string()
                    }
                } else {
                    "Missing order_id parameter".to_string()
                }
            }
            "list_orders" => {
                let order_list: Vec<String> = orders.values()
                    .map(|o| format!("Order {}: ${:.2}", o.id, o.total))
                    .collect();
                order_list.join(", ")
            }
            _ => "Unknown method".to_string(),
        };
        
        Ok(ServiceResponse {
            service_name: self.name.clone(),
            result,
            status: "success".to_string(),
            request_id: request.request_id,
        })
    }

    fn health_check(&self) -> bool {
        true
    }
}

// å¾®æœåŠ¡ç¼–æ’å™¨
pub struct ServiceOrchestrator {
    services: HashMap<String, Arc<dyn Microservice>>,
}

impl ServiceOrchestrator {
    pub fn new() -> Self {
        Self {
            services: HashMap::new(),
        }
    }

    pub fn register_service(&mut self, service: Arc<dyn Microservice>) {
        self.services.insert(service.get_name().to_string(), service);
    }

    pub fn call_service(&self, service_name: &str, request: ServiceRequest) -> Result<ServiceResponse, Box<dyn std::error::Error>> {
        if let Some(service) = self.services.get(service_name) {
            if service.health_check() {
                service.process_request(request)
            } else {
                Err("Service health check failed".into())
            }
        } else {
            Err(format!("Service {} not found", service_name).into())
        }
    }

    pub fn get_service_status(&self) -> HashMap<String, bool> {
        self.services.iter()
            .map(|(name, service)| (name.clone(), service.health_check()))
            .collect()
    }
}
```

### 4.3 äº‹ä»¶é©±åŠ¨æ¶æ„å®ç°

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc;
use serde::{Serialize, Deserialize};

// äº‹ä»¶å®šä¹‰
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Event {
    id: String,
    event_type: String,
    source: String,
    timestamp: u64,
    data: HashMap<String, String>,
}

// äº‹ä»¶å¤„ç†å™¨
pub trait EventHandler {
    fn get_name(&self) -> &str;
    fn can_handle(&self, event_type: &str) -> bool;
    fn handle_event(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>>;
}

// ç”¨æˆ·æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
pub struct UserRegistrationHandler {
    name: String,
    user_service: Arc<Mutex<HashMap<String, String>>>,
}

impl UserRegistrationHandler {
    pub fn new() -> Self {
        Self {
            name: "UserRegistrationHandler".to_string(),
            user_service: Arc::new(Mutex::new(HashMap::new())),
        }
    }
}

impl EventHandler for UserRegistrationHandler {
    fn get_name(&self) -> &str {
        &self.name
    }

    fn can_handle(&self, event_type: &str) -> bool {
        event_type == "user_registered"
    }

    fn handle_event(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>> {
        println!("UserRegistrationHandler processing event: {:?}", event);
        
        if let Some(user_id) = event.data.get("user_id") {
            if let Some(user_name) = event.data.get("user_name") {
                let mut users = self.user_service.lock().unwrap();
                users.insert(user_id.clone(), user_name.clone());
                println!("User {} registered successfully", user_name);
            }
        }
        
        Ok(())
    }
}

// è®¢å•åˆ›å»ºäº‹ä»¶å¤„ç†å™¨
pub struct OrderCreatedHandler {
    name: String,
    order_service: Arc<Mutex<HashMap<String, f64>>>,
}

impl OrderCreatedHandler {
    pub fn new() -> Self {
        Self {
            name: "OrderCreatedHandler".to_string(),
            order_service: Arc::new(Mutex::new(HashMap::new())),
        }
    }
}

impl EventHandler for OrderCreatedHandler {
    fn get_name(&self) -> &str {
        &self.name
    }

    fn can_handle(&self, event_type: &str) -> bool {
        event_type == "order_created"
    }

    fn handle_event(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>> {
        println!("OrderCreatedHandler processing event: {:?}", event);
        
        if let Some(order_id) = event.data.get("order_id") {
            if let Some(amount) = event.data.get("amount") {
                if let Ok(amount_value) = amount.parse::<f64>() {
                    let mut orders = self.order_service.lock().unwrap();
                    orders.insert(order_id.clone(), amount_value);
                    println!("Order {} created with amount ${:.2}", order_id, amount_value);
                }
            }
        }
        
        Ok(())
    }
}

// äº‹ä»¶æ€»çº¿
pub struct EventBus {
    handlers: Vec<Arc<dyn EventHandler>>,
    event_queue: mpsc::Sender<Event>,
}

impl EventBus {
    pub fn new() -> Self {
        let (tx, mut rx) = mpsc::channel(1000);
        
        // å¯åŠ¨äº‹ä»¶å¤„ç†å¾ªç¯
        tokio::spawn(async move {
            while let Some(event) = rx.recv().await {
                println!("EventBus processing event: {:?}", event);
            }
        });
        
        Self {
            handlers: Vec::new(),
            event_queue: tx,
        }
    }

    pub fn register_handler(&mut self, handler: Arc<dyn EventHandler>) {
        self.handlers.push(handler);
    }

    pub async fn publish_event(&self, event: Event) -> Result<(), Box<dyn std::error::Error>> {
        // å‘é€äº‹ä»¶åˆ°é˜Ÿåˆ—
        self.event_queue.send(event.clone()).await?;
        
        // åŒæ­¥å¤„ç†äº‹ä»¶
        for handler in &self.handlers {
            if handler.can_handle(&event.event_type) {
                handler.handle_event(&event)?;
            }
        }
        
        Ok(())
    }

    pub fn get_handler_count(&self) -> usize {
        self.handlers.len()
    }
}

// äº‹ä»¶é©±åŠ¨æ¶æ„ç®¡ç†å™¨
pub struct EventDrivenArchitecture {
    event_bus: EventBus,
    event_history: Arc<Mutex<Vec<Event>>>,
}

impl EventDrivenArchitecture {
    pub fn new() -> Self {
        Self {
            event_bus: EventBus::new(),
            event_history: Arc::new(Mutex::new(Vec::new())),
        }
    }

    pub fn register_handler(&mut self, handler: Arc<dyn EventHandler>) {
        self.event_bus.register_handler(handler);
    }

    pub async fn publish_event(&mut self, event: Event) -> Result<(), Box<dyn std::error::Error>> {
        // è®°å½•äº‹ä»¶å†å²
        {
            let mut history = self.event_history.lock().unwrap();
            history.push(event.clone());
        }
        
        // å‘å¸ƒäº‹ä»¶
        self.event_bus.publish_event(event).await
    }

    pub fn get_event_history(&self) -> Vec<Event> {
        self.event_history.lock().unwrap().clone()
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç”µå•†ç³»ç»Ÿæ¶æ„

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

// ç”µå•†ç³»ç»Ÿçš„åˆ†å±‚æ¶æ„
pub struct ECommerceSystem {
    presentation_layer: Arc<PresentationLayer>,
    business_layer: Arc<BusinessLogicLayer>,
    data_layer: Arc<DataAccessLayer>,
}

impl ECommerceSystem {
    pub fn new() -> Self {
        // åˆ›å»ºæ•°æ®è®¿é—®å±‚
        let data_layer = Arc::new(DataAccessLayer::new("ECommerceData".to_string()));
        
        // åˆ›å»ºä¸šåŠ¡é€»è¾‘å±‚
        let business_layer = Arc::new(BusinessLogicLayer::new(
            "ECommerceBusiness".to_string(),
            Some(data_layer.clone()),
        ));
        
        // åˆ›å»ºè¡¨ç¤ºå±‚
        let presentation_layer = Arc::new(PresentationLayer::new(
            "ECommercePresentation".to_string(),
            Some(business_layer.clone()),
        ));
        
        Self {
            presentation_layer,
            business_layer,
            data_layer,
        }
    }

    pub fn process_order(&self, order_request: &str) -> Result<String, Box<dyn std::error::Error>> {
        self.presentation_layer.process(order_request)
    }
}

// ç”µå•†ç³»ç»Ÿçš„å¾®æœåŠ¡æ¶æ„
pub struct ECommerceMicroservices {
    orchestrator: ServiceOrchestrator,
}

impl ECommerceMicroservices {
    pub fn new() -> Self {
        let mut orchestrator = ServiceOrchestrator::new();
        
        // æ³¨å†Œç”¨æˆ·æœåŠ¡
        let user_service = Arc::new(UserService::new());
        orchestrator.register_service(user_service);
        
        // æ³¨å†Œè®¢å•æœåŠ¡
        let order_service = Arc::new(OrderService::new());
        orchestrator.register_service(order_service);
        
        Self { orchestrator }
    }

    pub fn get_user_info(&self, user_id: &str) -> Result<String, Box<dyn std::error::Error>> {
        let mut parameters = HashMap::new();
        parameters.insert("user_id".to_string(), user_id.to_string());
        
        let request = ServiceRequest {
            service_name: "UserService".to_string(),
            method: "get_user".to_string(),
            parameters,
            request_id: uuid::Uuid::new_v4().to_string(),
        };
        
        let response = self.orchestrator.call_service("UserService", request)?;
        Ok(response.result)
    }

    pub fn get_order_info(&self, order_id: &str) -> Result<String, Box<dyn std::error::Error>> {
        let mut parameters = HashMap::new();
        parameters.insert("order_id".to_string(), order_id.to_string());
        
        let request = ServiceRequest {
            service_name: "OrderService".to_string(),
            method: "get_order".to_string(),
            parameters,
            request_id: uuid::Uuid::new_v4().to_string(),
        };
        
        let response = self.orchestrator.call_service("OrderService", request)?;
        Ok(response.result)
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // æµ‹è¯•åˆ†å±‚æ¶æ„
    println!("=== Testing Layered Architecture ===");
    let mut layered_system = LayeredArchitecture::build_layered_system();
    let result = layered_system.process_request("user:1")?;
    println!("Layered result: {}", result);
    
    // æµ‹è¯•å¾®æœåŠ¡æ¶æ„
    println!("\n=== Testing Microservices Architecture ===");
    let microservices = ECommerceMicroservices::new();
    let user_info = microservices.get_user_info("1")?;
    println!("User info: {}", user_info);
    
    let order_info = microservices.get_order_info("1")?;
    println!("Order info: {}", order_info);
    
    // æµ‹è¯•äº‹ä»¶é©±åŠ¨æ¶æ„
    println!("\n=== Testing Event-Driven Architecture ===");
    let mut event_arch = EventDrivenArchitecture::new();
    
    // æ³¨å†Œäº‹ä»¶å¤„ç†å™¨
    let user_handler = Arc::new(UserRegistrationHandler::new());
    let order_handler = Arc::new(OrderCreatedHandler::new());
    event_arch.register_handler(user_handler);
    event_arch.register_handler(order_handler);
    
    // å‘å¸ƒç”¨æˆ·æ³¨å†Œäº‹ä»¶
    let mut user_data = HashMap::new();
    user_data.insert("user_id".to_string(), "3".to_string());
    user_data.insert("user_name".to_string(), "Charlie".to_string());
    
    let user_event = Event {
        id: uuid::Uuid::new_v4().to_string(),
        event_type: "user_registered".to_string(),
        source: "web".to_string(),
        timestamp: std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs(),
        data: user_data,
    };
    
    event_arch.publish_event(user_event).await?;
    
    // å‘å¸ƒè®¢å•åˆ›å»ºäº‹ä»¶
    let mut order_data = HashMap::new();
    order_data.insert("order_id".to_string(), "2".to_string());
    order_data.insert("amount".to_string(), "99.99".to_string());
    
    let order_event = Event {
        id: uuid::Uuid::new_v4().to_string(),
        event_type: "order_created".to_string(),
        source: "api".to_string(),
        timestamp: std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs(),
        data: order_data,
    };
    
    event_arch.publish_event(order_event).await?;
    
    println!("Event history: {} events", event_arch.get_event_history().len());
    
    Ok(())
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸è½¯ä»¶å·¥ç¨‹ç†è®ºçš„å…³ç³»

æ¶æ„è®¾è®¡åŸåˆ™æ˜¯è½¯ä»¶å·¥ç¨‹ç†è®ºçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œä¸ºè½¯ä»¶ç³»ç»Ÿçš„è®¾è®¡å’Œå®ç°æä¾›æŒ‡å¯¼ã€‚

### 6.2 ä¸è®¾è®¡æ¨¡å¼ç†è®ºçš„å…³ç³»

æ¶æ„è®¾è®¡åŸåˆ™ä¸è®¾è®¡æ¨¡å¼ç†è®ºå¯†åˆ‡ç›¸å…³ï¼Œè®¾è®¡æ¨¡å¼æ˜¯æ¶æ„åŸåˆ™çš„å…·ä½“å®ç°ã€‚

### 6.3 ä¸å½¢å¼åŒ–æ–¹æ³•ç†è®ºçš„å…³ç³»

æ¶æ„è®¾è®¡åŸåˆ™å¯ä»¥å½¢å¼åŒ–è¡¨ç¤ºï¼Œä¸ºæ¶æ„çš„æ­£ç¡®æ€§éªŒè¯æä¾›ç†è®ºåŸºç¡€ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Bass, L., Clements, P., & Kazman, R. (2012). Software Architecture in Practice (3rd ed.). Addison-Wesley.

2. Martin, R. C. (2017). Clean Architecture: A Craftsman's Guide to Software Structure and Design. Prentice Hall.

3. Fowler, M. (2018). Patterns of Enterprise Application Architecture. Addison-Wesley.

4. Hohpe, G., & Woolf, B. (2003). Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions. Addison-Wesley.

5. Newman, S. (2021). Building Microservices: Designing Fine-Grained Systems (2nd ed.). O'Reilly Media.

---

**ç›¸å…³æ–‡æ¡£**:

- [07.2.2 æ¶æ„æ¨¡å¼ç†è®º](../07_Software_Engineering_Theory/07.2.2_æ¶æ„æ¨¡å¼ç†è®º.md)
- [07.2.3 å¾®æœåŠ¡æ¶æ„](../07_Software_Engineering_Theory/07.2.3_å¾®æœåŠ¡æ¶æ„.md)
- [07.2.4 äº‹ä»¶é©±åŠ¨æ¶æ„](../07_Software_Engineering_Theory/07.2.4_äº‹ä»¶é©±åŠ¨æ¶æ„.md)
