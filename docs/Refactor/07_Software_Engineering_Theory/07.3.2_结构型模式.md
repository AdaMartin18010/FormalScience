# 07.3.2 ç»“æ„å‹æ¨¡å¼ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç»“æ„å‹æ¨¡å¼å…³æ³¨ç±»å’Œå¯¹è±¡çš„ç»„åˆï¼Œé€šè¿‡ç»„åˆå’Œç»§æ‰¿æ¥æ„å»ºæ›´å¤æ‚çš„ç»“æ„ï¼ŒåŒæ—¶ä¿æŒç³»ç»Ÿçš„çµæ´»æ€§å’Œå¯æ‰©å±•æ€§ã€‚æœ¬ç†è®ºä»å½¢å¼åŒ–è§’åº¦æ·±å…¥åˆ†æç»“æ„å‹æ¨¡å¼çš„æ ¸å¿ƒæ¦‚å¿µã€æ•°å­¦åŸºç¡€å’Œå®ç°åŸç†ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **ç»“æ„å»ºæ¨¡**ï¼šå»ºç«‹ç»“æ„å‹æ¨¡å¼çš„æ•°å­¦å½¢å¼åŒ–æ¨¡å‹
2. **ç»„åˆç†è®º**ï¼šç³»ç»ŸåŒ–åˆ†æå¯¹è±¡ç»„åˆçš„æ•°å­¦åŸç†
3. **é€‚é…æœºåˆ¶**ï¼šæ·±å…¥åˆ†ææ¥å£é€‚é…å’Œè½¬æ¢æœºåˆ¶
4. **è£…é¥°ç†è®º**ï¼šç ”ç©¶åŠ¨æ€æ‰©å±•å¯¹è±¡åŠŸèƒ½çš„ç†è®ºåŸºç¡€

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [æ¨¡å¼åˆ†ç±»ç†è®º](#3-æ¨¡å¼åˆ†ç±»ç†è®º)
4. [æ ¸å¿ƒæ¨¡å¼åˆ†æ](#4-æ ¸å¿ƒæ¨¡å¼åˆ†æ)
5. [å®ç°åŸç†](#5-å®ç°åŸç†)
6. [ä»£ç å®ç°](#6-ä»£ç å®ç°)
7. [åº”ç”¨ç¤ºä¾‹](#7-åº”ç”¨ç¤ºä¾‹)
8. [ç›¸å…³ç†è®º](#8-ç›¸å…³ç†è®º)
9. [å‚è€ƒæ–‡çŒ®](#9-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç»“æ„å‹æ¨¡å¼å®šä¹‰

**å®šä¹‰ 1.1** (ç»“æ„å‹æ¨¡å¼)
ç»“æ„å‹æ¨¡å¼æ˜¯ä¸€ç±»è®¾è®¡æ¨¡å¼ï¼Œå…¶æ ¸å¿ƒç›®æ ‡æ˜¯ï¼š

- å¤„ç†ç±»å’Œå¯¹è±¡çš„ç»„åˆå…³ç³»
- æä¾›çµæ´»çš„æ¥å£é€‚é…æœºåˆ¶
- å®ç°åŠŸèƒ½çš„åŠ¨æ€æ‰©å±•
- ä¼˜åŒ–å¯¹è±¡é—´çš„é€šä¿¡ç»“æ„

### 1.2 æ ¸å¿ƒé—®é¢˜

ç»“æ„å‹æ¨¡å¼è§£å†³çš„æ ¸å¿ƒé—®é¢˜åŒ…æ‹¬ï¼š

1. **æ¥å£ä¸å…¼å®¹**ï¼šä¸åŒç³»ç»Ÿé—´çš„æ¥å£å·®å¼‚
2. **åŠŸèƒ½æ‰©å±•**ï¼šåœ¨ä¸ä¿®æ”¹åŸæœ‰ä»£ç çš„æƒ…å†µä¸‹æ‰©å±•åŠŸèƒ½
3. **ç»“æ„å¤æ‚**ï¼šå¤æ‚å¯¹è±¡ç»“æ„çš„ç®€åŒ–å’Œç®¡ç†
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šé€šè¿‡ç»“æ„ä¼˜åŒ–æå‡ç³»ç»Ÿæ€§èƒ½

### 1.3 è®¾è®¡åŸåˆ™

ç»“æ„å‹æ¨¡å¼éµå¾ªä»¥ä¸‹è®¾è®¡åŸåˆ™ï¼š

- **ç»„åˆä¼˜äºç»§æ‰¿**ï¼šä¼˜å…ˆä½¿ç”¨ç»„åˆè€Œéç»§æ‰¿
- **æ¥å£éš”ç¦»**ï¼šæä¾›ç²¾ç¡®çš„æ¥å£å®šä¹‰
- **å¼€é—­åŸåˆ™**ï¼šå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­
- **å•ä¸€èŒè´£**ï¼šæ¯ä¸ªç±»åªè´Ÿè´£ä¸€ä¸ªèŒè´£

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ¨¡å¼ç»“æ„å½¢å¼åŒ–

**å®šä¹‰ 2.1** (ç»“æ„å‹æ¨¡å¼ç»“æ„)
ç»“æ„å‹æ¨¡å¼å¯ä»¥å½¢å¼åŒ–ä¸ºå…­å…ƒç»„ï¼š

$$\text{StructuralPattern} = (C, I, R, \mathcal{C}, \mathcal{D}, \mathcal{A})$$

å…¶ä¸­ï¼š

- $C$ æ˜¯ç»„ä»¶é›†åˆ (Component Set)
- $I$ æ˜¯æ¥å£é›†åˆ (Interface Set)
- $R$ æ˜¯å…³ç³»é›†åˆ (Relation Set)
- $\mathcal{C}$ æ˜¯ç»„åˆå‡½æ•°é›†åˆ (Composition Function Set)
- $\mathcal{D}$ æ˜¯è£…é¥°å‡½æ•°é›†åˆ (Decoration Function Set)
- $\mathcal{A}$ æ˜¯é€‚é…å‡½æ•°é›†åˆ (Adaptation Function Set)

### 2.2 ç»„åˆå…³ç³»å½¢å¼åŒ–

**å®šä¹‰ 2.2** (ç»„åˆå…³ç³»)
ç»„åˆå…³ç³»æ˜¯ä¸€ä¸ªäºŒå…ƒå…³ç³»ï¼š

$$R_c \subseteq C \times C$$

æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š

1. **è‡ªåæ€§**ï¼š$\forall c \in C: (c, c) \in R_c$
2. **ä¼ é€’æ€§**ï¼š$\forall a, b, c \in C: (a, b) \in R_c \land (b, c) \in R_c \Rightarrow (a, c) \in R_c$
3. **åå¯¹ç§°æ€§**ï¼š$\forall a, b \in C: (a, b) \in R_c \land (b, a) \in R_c \Rightarrow a = b$

### 2.3 æ¥å£é€‚é…å½¢å¼åŒ–

**å®šä¹‰ 2.3** (æ¥å£é€‚é…)
æ¥å£é€‚é…æ˜¯ä¸€ä¸ªæ˜ å°„å‡½æ•°ï¼š

$$\text{Adapt}: I_1 \rightarrow I_2$$

å…¶ä¸­ $I_1$ æ˜¯æºæ¥å£ï¼Œ$I_2$ æ˜¯ç›®æ ‡æ¥å£ã€‚

**å®šç† 2.1** (é€‚é…çš„ä¿æŒæ€§)
é€‚é…å‡½æ•°ä¿æŒæ¥å£çš„è¯­ä¹‰ï¼š
$$\forall i \in I_1: \text{Semantics}(i) = \text{Semantics}(\text{Adapt}(i))$$

## 3. æ¨¡å¼åˆ†ç±»ç†è®º

### 3.1 åˆ†ç±»ç»´åº¦

ç»“æ„å‹æ¨¡å¼å¯ä»¥æŒ‰ä»¥ä¸‹ç»´åº¦åˆ†ç±»ï¼š

1. **ç»„åˆæ–¹å¼ç»´åº¦**
   - é™æ€ç»„åˆï¼šComposite, Bridge
   - åŠ¨æ€ç»„åˆï¼šDecorator, Proxy
   - æ¥å£ç»„åˆï¼šAdapter, Facade

2. **åŠŸèƒ½ç»´åº¦**
   - é€‚é…åŠŸèƒ½ï¼šAdapter, Bridge
   - æ‰©å±•åŠŸèƒ½ï¼šDecorator, Proxy
   - ç®€åŒ–åŠŸèƒ½ï¼šFacade, Flyweight

3. **ç»“æ„ç»´åº¦**
   - æ ‘å½¢ç»“æ„ï¼šComposite
   - çº¿æ€§ç»“æ„ï¼šChain of Responsibility
   - ç½‘çŠ¶ç»“æ„ï¼šBridge

### 3.2 åˆ†ç±»æ ‘ç»“æ„

```text
ç»“æ„å‹æ¨¡å¼
â”œâ”€â”€ é€‚é…ç±»
â”‚   â”œâ”€â”€ Adapter
â”‚   â”œâ”€â”€ Bridge
â”‚   â””â”€â”€ Facade
â”œâ”€â”€ ç»„åˆç±»
â”‚   â”œâ”€â”€ Composite
â”‚   â”œâ”€â”€ Decorator
â”‚   â””â”€â”€ Proxy
â””â”€â”€ ä¼˜åŒ–ç±»
    â”œâ”€â”€ Flyweight
    â””â”€â”€ Chain of Responsibility
```

## 4. æ ¸å¿ƒæ¨¡å¼åˆ†æ

### 4.1 é€‚é…å™¨æ¨¡å¼

**å®šä¹‰ 4.1** (é€‚é…å™¨)
é€‚é…å™¨æ¨¡å¼å°†ä¸€ä¸ªç±»çš„æ¥å£è½¬æ¢æˆå®¢æˆ·å¸Œæœ›çš„å¦å¤–ä¸€ä¸ªæ¥å£ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{Adapter} = (T, A, \text{Adapt}, \text{Target})$$

å…¶ä¸­ï¼š

- $T$ æ˜¯ç›®æ ‡æ¥å£é›†åˆ
- $A$ æ˜¯é€‚é…å™¨é›†åˆ
- $\text{Adapt}$ æ˜¯é€‚é…å‡½æ•°
- $\text{Target}$ æ˜¯ç›®æ ‡æ¥å£

**å®šç† 4.1** (é€‚é…å™¨çš„å…¼å®¹æ€§)
é€‚é…å™¨ç¡®ä¿æ¥å£å…¼å®¹ï¼š
$$\forall t \in T, \exists a \in A: \text{Adapt}(a) = t$$

### 4.2 æ¡¥æ¥æ¨¡å¼

**å®šä¹‰ 4.2** (æ¡¥æ¥)
æ¡¥æ¥æ¨¡å¼å°†æŠ½è±¡éƒ¨åˆ†ä¸å®ç°éƒ¨åˆ†åˆ†ç¦»ï¼Œä½¿å®ƒä»¬éƒ½å¯ä»¥ç‹¬ç«‹åœ°å˜åŒ–ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{Bridge} = (A, I, \text{Implement}, \text{Abstraction})$$

å…¶ä¸­ï¼š

- $A$ æ˜¯æŠ½è±¡é›†åˆ
- $I$ æ˜¯å®ç°é›†åˆ
- $\text{Implement}$ æ˜¯å®ç°å…³ç³»
- $\text{Abstraction}$ æ˜¯æŠ½è±¡å…³ç³»

**å®šç† 4.2** (æ¡¥æ¥çš„ç‹¬ç«‹æ€§)
æ¡¥æ¥æ¨¡å¼æ”¯æŒç‹¬ç«‹å˜åŒ–ï¼š
$$\forall a \in A, \forall i \in I: \text{Implement}(a, i) \text{ is independent}$$

### 4.3 ç»„åˆæ¨¡å¼

**å®šä¹‰ 4.3** (ç»„åˆ)
ç»„åˆæ¨¡å¼å°†å¯¹è±¡ç»„åˆæˆæ ‘å½¢ç»“æ„ä»¥è¡¨ç¤º"éƒ¨åˆ†-æ•´ä½“"çš„å±‚æ¬¡ç»“æ„ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{Composite} = (C, \text{Children}, \text{Parent}, \text{Operation})$$

å…¶ä¸­ï¼š

- $C$ æ˜¯ç»„ä»¶é›†åˆ
- $\text{Children}$ æ˜¯å­ç»„ä»¶å…³ç³»
- $\text{Parent}$ æ˜¯çˆ¶ç»„ä»¶å…³ç³»
- $\text{Operation}$ æ˜¯æ“ä½œå‡½æ•°

**å®šç† 4.3** (ç»„åˆçš„é€’å½’æ€§)
ç»„åˆæ¨¡å¼æ”¯æŒé€’å½’æ“ä½œï¼š
$$\forall c \in C: \text{Operation}(c) = \text{Operation}(\text{Children}(c))$$

### 4.4 è£…é¥°å™¨æ¨¡å¼

**å®šä¹‰ 4.4** (è£…é¥°å™¨)
è£…é¥°å™¨æ¨¡å¼åŠ¨æ€åœ°ç»™å¯¹è±¡æ·»åŠ é¢å¤–çš„èŒè´£ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{Decorator} = (C, D, \text{Decorate}, \text{Behavior})$$

å…¶ä¸­ï¼š

- $C$ æ˜¯ç»„ä»¶é›†åˆ
- $D$ æ˜¯è£…é¥°å™¨é›†åˆ
- $\text{Decorate}$ æ˜¯è£…é¥°å‡½æ•°
- $\text{Behavior}$ æ˜¯è¡Œä¸ºå‡½æ•°

**å®šç† 4.4** (è£…é¥°å™¨çš„å¯ç»„åˆæ€§)
è£…é¥°å™¨æ”¯æŒç»„åˆï¼š
$$\forall d_1, d_2 \in D: \text{Decorate}(d_1, \text{Decorate}(d_2, c)) = \text{Decorate}(d_2, \text{Decorate}(d_1, c))$$

### 4.5 å¤–è§‚æ¨¡å¼

**å®šä¹‰ 4.5** (å¤–è§‚)
å¤–è§‚æ¨¡å¼ä¸ºå­ç³»ç»Ÿä¸­çš„ä¸€ç»„æ¥å£æä¾›ä¸€ä¸ªä¸€è‡´çš„ç•Œé¢ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{Facade} = (S, F, \text{Simplify}, \text{Interface})$$

å…¶ä¸­ï¼š

- $S$ æ˜¯å­ç³»ç»Ÿé›†åˆ
- $F$ æ˜¯å¤–è§‚é›†åˆ
- $\text{Simplify}$ æ˜¯ç®€åŒ–å‡½æ•°
- $\text{Interface}$ æ˜¯æ¥å£å‡½æ•°

**å®šç† 4.5** (å¤–è§‚çš„ç®€åŒ–æ€§)
å¤–è§‚æ¨¡å¼ç®€åŒ–æ¥å£ï¼š
$$\forall s \in S: \text{Complexity}(\text{Simplify}(s)) < \text{Complexity}(s)$$

## 5. å®ç°åŸç†

### 5.1 ç»„åˆåŸç†

**å®šä¹‰ 5.1** (ç»„åˆ)
ç»„åˆæ˜¯é€šè¿‡åŒ…å«å…¶ä»–å¯¹è±¡æ¥å®ç°åŠŸèƒ½ï¼š

$$\text{Composition} = (O, \text{Contains}, \text{Delegates})$$

å…¶ä¸­ï¼š

- $O$ æ˜¯å¯¹è±¡é›†åˆ
- $\text{Contains}$ æ˜¯åŒ…å«å…³ç³»
- $\text{Delegates}$ æ˜¯å§”æ‰˜å…³ç³»

### 5.2 å§”æ‰˜æœºåˆ¶

**å®šä¹‰ 5.2** (å§”æ‰˜)
å§”æ‰˜æ˜¯å°†è¯·æ±‚è½¬å‘ç»™å…¶ä»–å¯¹è±¡ï¼š

$$\text{Delegation}: \text{Request} \times \text{Object} \rightarrow \text{Response}$$

### 5.3 åŠ¨æ€ä»£ç†

**å®šä¹‰ 5.3** (åŠ¨æ€ä»£ç†)
åŠ¨æ€ä»£ç†åœ¨è¿è¡Œæ—¶åˆ›å»ºä»£ç†å¯¹è±¡ï¼š

$$\text{DynamicProxy}: \text{Interface} \times \text{Handler} \rightarrow \text{Proxy}$$

## 6. ä»£ç å®ç°

### 6.1 Rust å®ç°

```rust
// é€‚é…å™¨æ¨¡å¼å®ç°
pub trait Target {
    fn request(&self) -> String;
}

pub struct Adaptee;

impl Adaptee {
    pub fn specific_request(&self) -> String {
        "Specific request".to_string()
    }
}

pub struct Adapter {
    adaptee: Adaptee,
}

impl Adapter {
    pub fn new(adaptee: Adaptee) -> Self {
        Self { adaptee }
    }
}

impl Target for Adapter {
    fn request(&self) -> String {
        format!("Adapter: {}", self.adaptee.specific_request())
    }
}

// æ¡¥æ¥æ¨¡å¼å®ç°
pub trait Implementor {
    fn operation_impl(&self) -> String;
}

pub struct ConcreteImplementorA;
pub struct ConcreteImplementorB;

impl Implementor for ConcreteImplementorA {
    fn operation_impl(&self) -> String {
        "ConcreteImplementorA operation".to_string()
    }
}

impl Implementor for ConcreteImplementorB {
    fn operation_impl(&self) -> String {
        "ConcreteImplementorB operation".to_string()
    }
}

pub struct Abstraction {
    implementor: Box<dyn Implementor>,
}

impl Abstraction {
    pub fn new(implementor: Box<dyn Implementor>) -> Self {
        Self { implementor }
    }
    
    pub fn operation(&self) -> String {
        format!("Abstraction: {}", self.implementor.operation_impl())
    }
}

// ç»„åˆæ¨¡å¼å®ç°
pub trait Component {
    fn operation(&self) -> String;
    fn add(&mut self, component: Box<dyn Component>);
    fn remove(&mut self, component: &dyn Component);
    fn get_child(&self, index: usize) -> Option<&dyn Component>;
}

pub struct Leaf {
    name: String,
}

impl Leaf {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

impl Component for Leaf {
    fn operation(&self) -> String {
        format!("Leaf: {}", self.name)
    }
    
    fn add(&mut self, _component: Box<dyn Component>) {
        // Leaf cannot add children
    }
    
    fn remove(&mut self, _component: &dyn Component) {
        // Leaf cannot remove children
    }
    
    fn get_child(&self, _index: usize) -> Option<&dyn Component> {
        None
    }
}

pub struct Composite {
    name: String,
    children: Vec<Box<dyn Component>>,
}

impl Composite {
    pub fn new(name: String) -> Self {
        Self {
            name,
            children: Vec::new(),
        }
    }
}

impl Component for Composite {
    fn operation(&self) -> String {
        let mut result = format!("Composite: {}", self.name);
        for child in &self.children {
            result.push_str(&format!("\n  {}", child.operation()));
        }
        result
    }
    
    fn add(&mut self, component: Box<dyn Component>) {
        self.children.push(component);
    }
    
    fn remove(&mut self, component: &dyn Component) {
        self.children.retain(|c| !std::ptr::eq(c.as_ref(), component));
    }
    
    fn get_child(&self, index: usize) -> Option<&dyn Component> {
        self.children.get(index).map(|c| c.as_ref())
    }
}

// è£…é¥°å™¨æ¨¡å¼å®ç°
pub trait Component {
    fn operation(&self) -> String;
}

pub struct ConcreteComponent;

impl Component for ConcreteComponent {
    fn operation(&self) -> String {
        "ConcreteComponent".to_string()
    }
}

pub struct Decorator {
    component: Box<dyn Component>,
}

impl Decorator {
    pub fn new(component: Box<dyn Component>) -> Self {
        Self { component }
    }
}

impl Component for Decorator {
    fn operation(&self) -> String {
        format!("Decorator({})", self.component.operation())
    }
}

pub struct ConcreteDecoratorA {
    component: Box<dyn Component>,
}

impl ConcreteDecoratorA {
    pub fn new(component: Box<dyn Component>) -> Self {
        Self { component }
    }
}

impl Component for ConcreteDecoratorA {
    fn operation(&self) -> String {
        format!("ConcreteDecoratorA({})", self.component.operation())
    }
}

pub struct ConcreteDecoratorB {
    component: Box<dyn Component>,
}

impl ConcreteDecoratorB {
    pub fn new(component: Box<dyn Component>) -> Self {
        Self { component }
    }
}

impl Component for ConcreteDecoratorB {
    fn operation(&self) -> String {
        format!("ConcreteDecoratorB({})", self.component.operation())
    }
}

// å¤–è§‚æ¨¡å¼å®ç°
pub struct SubsystemA;

impl SubsystemA {
    pub fn operation_a(&self) -> String {
        "SubsystemA operation".to_string()
    }
}

pub struct SubsystemB;

impl SubsystemB {
    pub fn operation_b(&self) -> String {
        "SubsystemB operation".to_string()
    }
}

pub struct SubsystemC;

impl SubsystemC {
    pub fn operation_c(&self) -> String {
        "SubsystemC operation".to_string()
    }
}

pub struct Facade {
    subsystem_a: SubsystemA,
    subsystem_b: SubsystemB,
    subsystem_c: SubsystemC,
}

impl Facade {
    pub fn new() -> Self {
        Self {
            subsystem_a: SubsystemA,
            subsystem_b: SubsystemB,
            subsystem_c: SubsystemC,
        }
    }
    
    pub fn operation(&self) -> String {
        format!(
            "Facade: {} + {} + {}",
            self.subsystem_a.operation_a(),
            self.subsystem_b.operation_b(),
            self.subsystem_c.operation_c()
        )
    }
}
```

### 6.2 Haskell å®ç°

```haskell
-- é€‚é…å™¨æ¨¡å¼
class Target a where
    request :: a -> String

data Adaptee = Adaptee

specificRequest :: Adaptee -> String
specificRequest _ = "Specific request"

data Adapter = Adapter Adaptee

instance Target Adapter where
    request (Adapter adaptee) = "Adapter: " ++ specificRequest adaptee

-- æ¡¥æ¥æ¨¡å¼
class Implementor a where
    operationImpl :: a -> String

data ConcreteImplementorA = ConcreteImplementorA
data ConcreteImplementorB = ConcreteImplementorB

instance Implementor ConcreteImplementorA where
    operationImpl _ = "ConcreteImplementorA operation"

instance Implementor ConcreteImplementorB where
    operationImpl _ = "ConcreteImplementorB operation"

data Abstraction a = Abstraction a

operation :: Implementor a => Abstraction a -> String
operation (Abstraction impl) = "Abstraction: " ++ operationImpl impl

-- ç»„åˆæ¨¡å¼
class Component a where
    operation :: a -> String
    add :: a -> a -> a
    remove :: a -> a -> a
    getChild :: a -> Int -> Maybe a

data Leaf = Leaf String

instance Component Leaf where
    operation (Leaf name) = "Leaf: " ++ name
    add leaf _ = leaf
    remove leaf _ = leaf
    getChild _ _ = Nothing

data Composite = Composite String [Composite]

instance Component Composite where
    operation (Composite name children) = 
        "Composite: " ++ name ++ concatMap (\c -> "\n  " ++ operation c) children
    add (Composite name children) child = 
        Composite name (children ++ [child])
    remove (Composite name children) child = 
        Composite name (filter (/= child) children)
    getChild (Composite _ children) index = 
        if index >= 0 && index < length children 
        then Just (children !! index) 
        else Nothing

-- è£…é¥°å™¨æ¨¡å¼
class Component a where
    operation :: a -> String

data ConcreteComponent = ConcreteComponent

instance Component ConcreteComponent where
    operation _ = "ConcreteComponent"

data Decorator a = Decorator a

instance Component a => Component (Decorator a) where
    operation (Decorator component) = "Decorator(" ++ operation component ++ ")"

data ConcreteDecoratorA a = ConcreteDecoratorA a

instance Component a => Component (ConcreteDecoratorA a) where
    operation (ConcreteDecoratorA component) = "ConcreteDecoratorA(" ++ operation component ++ ")"

data ConcreteDecoratorB a = ConcreteDecoratorB a

instance Component a => Component (ConcreteDecoratorB a) where
    operation (ConcreteDecoratorB component) = "ConcreteDecoratorB(" ++ operation component ++ ")"

-- å¤–è§‚æ¨¡å¼
data SubsystemA = SubsystemA
data SubsystemB = SubsystemB
data SubsystemC = SubsystemC

operationA :: SubsystemA -> String
operationA _ = "SubsystemA operation"

operationB :: SubsystemB -> String
operationB _ = "SubsystemB operation"

operationC :: SubsystemC -> String
operationC _ = "SubsystemC operation"

data Facade = Facade SubsystemA SubsystemB SubsystemC

operation :: Facade -> String
operation (Facade a b c) = 
    "Facade: " ++ operationA a ++ " + " ++ operationB b ++ " + " ++ operationC c
```

## 7. åº”ç”¨ç¤ºä¾‹

### 7.1 å›¾å½¢ç¼–è¾‘å™¨ç»„åˆæ¨¡å¼

```rust
// å›¾å½¢ç¼–è¾‘å™¨ç»„åˆæ¨¡å¼ç¤ºä¾‹
pub trait Graphic {
    fn draw(&self);
    fn add(&mut self, graphic: Box<dyn Graphic>);
    fn remove(&mut self, graphic: &dyn Graphic);
    fn get_child(&self, index: usize) -> Option<&dyn Graphic>;
}

pub struct Line {
    start: (i32, i32),
    end: (i32, i32),
}

impl Line {
    pub fn new(start: (i32, i32), end: (i32, i32)) -> Self {
        Self { start, end }
    }
}

impl Graphic for Line {
    fn draw(&self) {
        println!("Drawing line from {:?} to {:?}", self.start, self.end);
    }
    
    fn add(&mut self, _graphic: Box<dyn Graphic>) {
        // Line cannot contain other graphics
    }
    
    fn remove(&mut self, _graphic: &dyn Graphic) {
        // Line cannot remove graphics
    }
    
    fn get_child(&self, _index: usize) -> Option<&dyn Graphic> {
        None
    }
}

pub struct Rectangle {
    x: i32,
    y: i32,
    width: i32,
    height: i32,
}

impl Rectangle {
    pub fn new(x: i32, y: i32, width: i32, height: i32) -> Self {
        Self { x, y, width, height }
    }
}

impl Graphic for Rectangle {
    fn draw(&self) {
        println!("Drawing rectangle at ({}, {}) with size {}x{}", 
                 self.x, self.y, self.width, self.height);
    }
    
    fn add(&mut self, _graphic: Box<dyn Graphic>) {
        // Rectangle cannot contain other graphics
    }
    
    fn remove(&mut self, _graphic: &dyn Graphic) {
        // Rectangle cannot remove graphics
    }
    
    fn get_child(&self, _index: usize) -> Option<&dyn Graphic> {
        None
    }
}

pub struct Picture {
    graphics: Vec<Box<dyn Graphic>>,
}

impl Picture {
    pub fn new() -> Self {
        Self {
            graphics: Vec::new(),
        }
    }
}

impl Graphic for Picture {
    fn draw(&self) {
        println!("Drawing picture:");
        for graphic in &self.graphics {
            graphic.draw();
        }
    }
    
    fn add(&mut self, graphic: Box<dyn Graphic>) {
        self.graphics.push(graphic);
    }
    
    fn remove(&mut self, graphic: &dyn Graphic) {
        self.graphics.retain(|g| !std::ptr::eq(g.as_ref(), graphic));
    }
    
    fn get_child(&self, index: usize) -> Option<&dyn Graphic> {
        self.graphics.get(index).map(|g| g.as_ref())
    }
}

// ä½¿ç”¨ç¤ºä¾‹
pub fn graphics_editor_example() {
    let mut picture = Picture::new();
    
    let line = Line::new((0, 0), (100, 100));
    let rectangle = Rectangle::new(10, 10, 50, 30);
    
    picture.add(Box::new(line));
    picture.add(Box::new(rectangle));
    
    picture.draw();
}
```

### 7.2 å’–å•¡åº—è£…é¥°å™¨æ¨¡å¼

```rust
// å’–å•¡åº—è£…é¥°å™¨æ¨¡å¼ç¤ºä¾‹
pub trait Beverage {
    fn cost(&self) -> f64;
    fn description(&self) -> String;
}

pub struct Espresso;

impl Beverage for Espresso {
    fn cost(&self) -> f64 {
        1.99
    }
    
    fn description(&self) -> String {
        "Espresso".to_string()
    }
}

pub struct HouseBlend;

impl Beverage for HouseBlend {
    fn cost(&self) -> f64 {
        0.89
    }
    
    fn description(&self) -> String {
        "House Blend Coffee".to_string()
    }
}

pub struct CondimentDecorator {
    beverage: Box<dyn Beverage>,
}

impl CondimentDecorator {
    pub fn new(beverage: Box<dyn Beverage>) -> Self {
        Self { beverage }
    }
}

impl Beverage for CondimentDecorator {
    fn cost(&self) -> f64 {
        self.beverage.cost()
    }
    
    fn description(&self) -> String {
        self.beverage.description()
    }
}

pub struct Mocha {
    beverage: Box<dyn Beverage>,
}

impl Mocha {
    pub fn new(beverage: Box<dyn Beverage>) -> Self {
        Self { beverage }
    }
}

impl Beverage for Mocha {
    fn cost(&self) -> f64 {
        self.beverage.cost() + 0.20
    }
    
    fn description(&self) -> String {
        format!("{}, Mocha", self.beverage.description())
    }
}

pub struct Whip {
    beverage: Box<dyn Beverage>,
}

impl Whip {
    pub fn new(beverage: Box<dyn Beverage>) -> Self {
        Self { beverage }
    }
}

impl Beverage for Whip {
    fn cost(&self) -> f64 {
        self.beverage.cost() + 0.10
    }
    
    fn description(&self) -> String {
        format!("{}, Whip", self.beverage.description())
    }
}

// ä½¿ç”¨ç¤ºä¾‹
pub fn coffee_shop_example() {
    let beverage = Box::new(Espresso);
    println!("{}: ${:.2}", beverage.description(), beverage.cost());
    
    let beverage2 = Box::new(HouseBlend);
    let beverage2 = Box::new(Mocha::new(beverage2));
    let beverage2 = Box::new(Mocha::new(beverage2));
    let beverage2 = Box::new(Whip::new(beverage2));
    println!("{}: ${:.2}", beverage2.description(), beverage2.cost());
}
```

## 8. ç›¸å…³ç†è®º

### 8.1 è®¾è®¡æ¨¡å¼ç†è®º

ç»“æ„å‹æ¨¡å¼æ˜¯è®¾è®¡æ¨¡å¼ç†è®ºçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œä¸å…¶ä»–æ¨¡å¼ç±»å‹å¯†åˆ‡ç›¸å…³ï¼š

- **åˆ›å»ºå‹æ¨¡å¼**ï¼šå…³æ³¨å¯¹è±¡åˆ›å»ºæœºåˆ¶
- **è¡Œä¸ºå‹æ¨¡å¼**ï¼šå…³æ³¨å¯¹è±¡é—´é€šä¿¡å’ŒèŒè´£åˆ†é…
- **æ¶æ„æ¨¡å¼**ï¼šå…³æ³¨ç³»ç»Ÿçº§çš„è®¾è®¡å†³ç­–

### 8.2 é¢å‘å¯¹è±¡ç†è®º

ç»“æ„å‹æ¨¡å¼åŸºäºé¢å‘å¯¹è±¡çš„æ ¸å¿ƒæ¦‚å¿µï¼š

- **ç»„åˆ**ï¼šé€šè¿‡å¯¹è±¡ç»„åˆå®ç°åŠŸèƒ½
- **å§”æ‰˜**ï¼šå°†è¯·æ±‚è½¬å‘ç»™å…¶ä»–å¯¹è±¡
- **å¤šæ€**ï¼šæ”¯æŒè¿è¡Œæ—¶ç±»å‹ç»‘å®š
- **å°è£…**ï¼šéšè—å®ç°ç»†èŠ‚

### 8.3 è½¯ä»¶å·¥ç¨‹ç†è®º

ç»“æ„å‹æ¨¡å¼ä½“ç°äº†è½¯ä»¶å·¥ç¨‹çš„é‡è¦åŸåˆ™ï¼š

- **æ¨¡å—åŒ–**ï¼šå°†åŠŸèƒ½æ¨¡å—åŒ–
- **å¯ç»´æŠ¤æ€§**ï¼šé™ä½ç³»ç»Ÿè€¦åˆåº¦
- **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒåŠŸèƒ½æ‰©å±•
- **å¯é‡ç”¨æ€§**ï¼šæé«˜ä»£ç é‡ç”¨æ€§

## 9. å‚è€ƒæ–‡çŒ®

1. Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.

2. Freeman, E., Robson, E., Sierra, K., & Bates, B. (2004). Head First Design Patterns. O'Reilly Media.

3. Martin, R. C. (2000). Design Principles and Design Patterns. Object Mentor.

4. Liskov, B. (1987). Data Abstraction and Hierarchy. SIGPLAN Notices, 23(5), 17-34.

5. Meyer, B. (1988). Object-Oriented Software Construction. Prentice Hall.

---

**ç›¸å…³é“¾æ¥**ï¼š

- [07.3.1 åˆ›å»ºå‹æ¨¡å¼](../07.3.1_åˆ›å»ºå‹æ¨¡å¼.md)
- [07.3.3 è¡Œä¸ºå‹æ¨¡å¼](../07.3.3_è¡Œä¸ºå‹æ¨¡å¼.md)
- [07.3.4 æ¶æ„æ¨¡å¼](../07.3.4_æ¶æ„æ¨¡å¼.md)
- [08.1.1 è¯­è¨€è®¾è®¡åŸåˆ™](../../08_Programming_Language_Theory/08.1.1_è¯­è¨€è®¾è®¡åŸåˆ™.md)
