# 07.3.2 ç»“æ„å‹æ¨¡å¼

## ğŸ“‹ æ¦‚è¿°

ç»“æ„å‹æ¨¡å¼å…³æ³¨ç±»å’Œå¯¹è±¡çš„ç»„åˆï¼Œå®ƒä»¬æä¾›äº†ä¸€ç§å°†ç±»å’Œå¯¹è±¡ç»„åˆæˆæ›´å¤§ç»“æ„çš„æ–¹æ³•ï¼ŒåŒæ—¶ä¿æŒè¿™äº›ç»“æ„çš„çµæ´»æ€§å’Œæ•ˆç‡ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦åˆ†æç»“æ„å‹æ¨¡å¼çš„ç†è®ºåŸºç¡€ã€æ•°å­¦å®šä¹‰ã€å®ç°åŸç†å’Œåº”ç”¨åœºæ™¯ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ç»“æ„å‹æ¨¡å¼çš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°å®Œæ•´çš„Rustä»£ç ç¤ºä¾‹
4. åˆ†ææ¨¡å¼é—´çš„å…³è”æ€§å’Œåº”ç”¨åœºæ™¯

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç»“æ„å‹æ¨¡å¼çš„å®šä¹‰

**å®šä¹‰ 1.1** (ç»“æ„å‹æ¨¡å¼)
ç»“æ„å‹æ¨¡å¼æ˜¯ä¸€ç±»è®¾è®¡æ¨¡å¼ï¼Œå®ƒä»¬å¤„ç†ç±»å’Œå¯¹è±¡çš„ç»„åˆï¼Œé€šè¿‡ç»„åˆæœºåˆ¶åˆ›å»ºæ›´å¤§çš„ç»“æ„ï¼ŒåŒæ—¶ä¿æŒç³»ç»Ÿçš„çµæ´»æ€§å’Œå¯æ‰©å±•æ€§ã€‚

**å®šä¹‰ 1.2** (å¯¹è±¡ç»„åˆé—®é¢˜)
ç»™å®šå¯¹è±¡é›†åˆ $O = \{o_1, o_2, \ldots, o_n\}$ å’Œå…³ç³»é›†åˆ $R = \{r_1, r_2, \ldots, r_m\}$ï¼Œå¯¹è±¡ç»„åˆé—®é¢˜æ˜¯åœ¨æ»¡è¶³æ‰€æœ‰å…³ç³»çº¦æŸçš„æƒ…å†µä¸‹ï¼Œå°†å¯¹è±¡ç»„åˆæˆæ›´å¤§çš„ç»“æ„ã€‚

### 1.2 ç»“æ„å‹æ¨¡å¼çš„åˆ†ç±»

ç»“æ„å‹æ¨¡å¼å¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ç±»ï¼š

1. **é€‚é…å™¨æ¨¡å¼ (Adapter Pattern)**
2. **æ¡¥æ¥æ¨¡å¼ (Bridge Pattern)**
3. **ç»„åˆæ¨¡å¼ (Composite Pattern)**
4. **è£…é¥°å™¨æ¨¡å¼ (Decorator Pattern)**
5. **å¤–è§‚æ¨¡å¼ (Facade Pattern)**
6. **äº«å…ƒæ¨¡å¼ (Flyweight Pattern)**
7. **ä»£ç†æ¨¡å¼ (Proxy Pattern)**

### 1.3 å½¢å¼åŒ–è¡¨ç¤º

**å®šä¹‰ 1.3** (ç»“æ„å‹æ¨¡å¼çš„å½¢å¼åŒ–è¡¨ç¤º)
ç»“æ„å‹æ¨¡å¼å¯ä»¥è¡¨ç¤ºä¸ºå…­å…ƒç»„ $S = (O, R, C, I, T, P)$ï¼Œå…¶ä¸­ï¼š
- $O$ æ˜¯å¯¹è±¡é›†åˆ
- $R$ æ˜¯å…³ç³»é›†åˆ
- $C$ æ˜¯ç»„åˆè§„åˆ™é›†åˆ
- $I$ æ˜¯æ¥å£é›†åˆ
- $T$ æ˜¯è½¬æ¢å‡½æ•°é›†åˆ
- $P$ æ˜¯å±æ€§é›†åˆ

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 é€‚é…å™¨æ¨¡å¼

**å®šä¹‰ 2.1** (é€‚é…å™¨æ¨¡å¼)
é€‚é…å™¨æ¨¡å¼å°†ä¸€ä¸ªç±»çš„æ¥å£è½¬æ¢æˆå®¢æˆ·å¸Œæœ›çš„å¦å¤–ä¸€ä¸ªæ¥å£ï¼Œä½¿å¾—åŸæœ¬ç”±äºæ¥å£ä¸å…¼å®¹è€Œä¸èƒ½ä¸€èµ·å·¥ä½œçš„ç±»å¯ä»¥ä¸€èµ·å·¥ä½œã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Adapter}(T, T') = \{(f, g) \mid f : T \rightarrow T' \land g : T' \rightarrow T \land f \circ g = \text{id}_{T'}\}$$

**å®šç† 2.1** (é€‚é…å™¨çš„åŒå‘æ€§)
é€‚é…å™¨æ¨¡å¼æä¾›äº†åŒå‘è½¬æ¢èƒ½åŠ›ã€‚

**è¯æ˜**ï¼š
æ ¹æ®é€‚é…å™¨çš„å®šä¹‰ï¼Œå­˜åœ¨å‡½æ•° $f : T \rightarrow T'$ å’Œ $g : T' \rightarrow T$ï¼Œä½¿å¾— $f \circ g = \text{id}_{T'}$ï¼Œå› æ­¤å¯ä»¥å®ç°åŒå‘è½¬æ¢ã€‚$\square$

### 2.2 æ¡¥æ¥æ¨¡å¼

**å®šä¹‰ 2.2** (æ¡¥æ¥æ¨¡å¼)
æ¡¥æ¥æ¨¡å¼å°†æŠ½è±¡éƒ¨åˆ†ä¸å®ç°éƒ¨åˆ†åˆ†ç¦»ï¼Œä½¿å®ƒä»¬éƒ½å¯ä»¥ç‹¬ç«‹åœ°å˜åŒ–ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Bridge}(A, I) = \{(a, i) \mid a \in A \land i \in I \land \text{implement}(a, i)\}$$

**å®šç† 2.2** (æ¡¥æ¥çš„ç‹¬ç«‹æ€§)
æ¡¥æ¥æ¨¡å¼ä½¿å¾—æŠ½è±¡å’Œå®ç°å¯ä»¥ç‹¬ç«‹å˜åŒ–ã€‚

**è¯æ˜**ï¼š
æ ¹æ®æ¡¥æ¥çš„å®šä¹‰ï¼ŒæŠ½è±¡ $A$ å’Œå®ç° $I$ é€šè¿‡æ¥å£è¿æ¥ï¼Œå› æ­¤å¯ä»¥ç‹¬ç«‹å˜åŒ–è€Œä¸å½±å“å¯¹æ–¹ã€‚$\square$

### 2.3 ç»„åˆæ¨¡å¼

**å®šä¹‰ 2.3** (ç»„åˆæ¨¡å¼)
ç»„åˆæ¨¡å¼å°†å¯¹è±¡ç»„åˆæˆæ ‘å½¢ç»“æ„ä»¥è¡¨ç¤º"éƒ¨åˆ†-æ•´ä½“"çš„å±‚æ¬¡ç»“æ„ï¼Œä½¿å¾—ç”¨æˆ·å¯¹å•ä¸ªå¯¹è±¡å’Œç»„åˆå¯¹è±¡çš„ä½¿ç”¨å…·æœ‰ä¸€è‡´æ€§ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Composite}(N, L) = \{(n, l) \mid n \in N \land l \in L \land \text{isLeaf}(l) \lor \text{hasChildren}(n)\}$$

**å®šç† 2.3** (ç»„åˆçš„ä¸€è‡´æ€§)
ç»„åˆæ¨¡å¼æä¾›äº†ç»Ÿä¸€çš„æ¥å£ã€‚

**è¯æ˜**ï¼š
æ ¹æ®ç»„åˆçš„å®šä¹‰ï¼Œå¶å­èŠ‚ç‚¹å’Œå¤åˆèŠ‚ç‚¹éƒ½å®ç°äº†ç›¸åŒçš„æ¥å£ï¼Œå› æ­¤æä¾›äº†ç»Ÿä¸€çš„ä½¿ç”¨æ–¹å¼ã€‚$\square$

### 2.4 è£…é¥°å™¨æ¨¡å¼

**å®šä¹‰ 2.4** (è£…é¥°å™¨æ¨¡å¼)
è£…é¥°å™¨æ¨¡å¼åŠ¨æ€åœ°ç»™å¯¹è±¡æ·»åŠ é¢å¤–çš„èŒè´£ï¼Œè€Œä¸æ”¹å˜å…¶æ¥å£ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Decorator}(O, D) = \{(o, d) \mid o \in O \land d \in D \land \text{decorate}(d, o) \in O\}$$

**å®šç† 2.4** (è£…é¥°å™¨çš„å¯ç»„åˆæ€§)
è£…é¥°å™¨æ¨¡å¼æ”¯æŒå¤šå±‚è£…é¥°ã€‚

**è¯æ˜**ï¼š
è£…é¥°å™¨æœ¬èº«ä¹Ÿæ˜¯å¯¹è±¡ï¼Œå› æ­¤å¯ä»¥ç»§ç»­è¢«è£…é¥°ï¼Œå½¢æˆå¤šå±‚è£…é¥°ç»“æ„ã€‚$\square$

### 2.5 å¤–è§‚æ¨¡å¼

**å®šä¹‰ 2.5** (å¤–è§‚æ¨¡å¼)
å¤–è§‚æ¨¡å¼ä¸ºå­ç³»ç»Ÿä¸­çš„ä¸€ç»„æ¥å£æä¾›ä¸€ä¸ªä¸€è‡´çš„ç•Œé¢ï¼Œå®šä¹‰äº†ä¸€ä¸ªé«˜å±‚æ¥å£ï¼Œä½¿å¾—å­ç³»ç»Ÿæ›´åŠ å®¹æ˜“ä½¿ç”¨ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Facade}(S, F) = \{f \mid f : \prod_{i=1}^n S_i \rightarrow F \land \text{simplify}(f)\}$$

**å®šç† 2.5** (å¤–è§‚çš„ç®€åŒ–æ€§)
å¤–è§‚æ¨¡å¼ç®€åŒ–äº†å¤æ‚ç³»ç»Ÿçš„ä½¿ç”¨ã€‚

**è¯æ˜**ï¼š
å¤–è§‚æä¾›äº†ä¸€ä¸ªç»Ÿä¸€çš„æ¥å£ï¼Œéšè—äº†å­ç³»ç»Ÿçš„å¤æ‚æ€§ï¼Œå› æ­¤ç®€åŒ–äº†ä½¿ç”¨ã€‚$\square$

### 2.6 äº«å…ƒæ¨¡å¼

**å®šä¹‰ 2.6** (äº«å…ƒæ¨¡å¼)
äº«å…ƒæ¨¡å¼è¿ç”¨å…±äº«æŠ€æœ¯æœ‰æ•ˆåœ°æ”¯æŒå¤§é‡ç»†ç²’åº¦å¯¹è±¡çš„å¤ç”¨ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Flyweight}(O, S) = \{(o, s) \mid o \in O \land s \in S \land \text{share}(o, s)\}$$

**å®šç† 2.6** (äº«å…ƒçš„å…±äº«æ€§)
äº«å…ƒæ¨¡å¼é€šè¿‡å…±äº«å‡å°‘å†…å­˜ä½¿ç”¨ã€‚

**è¯æ˜**ï¼š
å¤šä¸ªå¯¹è±¡å…±äº«åŒä¸€ä¸ªäº«å…ƒå®ä¾‹ï¼Œå› æ­¤å‡å°‘äº†å†…å­˜å ç”¨ã€‚$\square$

### 2.7 ä»£ç†æ¨¡å¼

**å®šä¹‰ 2.7** (ä»£ç†æ¨¡å¼)
ä»£ç†æ¨¡å¼ä¸ºå…¶ä»–å¯¹è±¡æä¾›ä¸€ç§ä»£ç†ä»¥æ§åˆ¶å¯¹è¿™ä¸ªå¯¹è±¡çš„è®¿é—®ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Proxy}(T, P) = \{(t, p) \mid t \in T \land p \in P \land \text{control}(p, t)\}$$

**å®šç† 2.7** (ä»£ç†çš„æ§åˆ¶æ€§)
ä»£ç†æ¨¡å¼æä¾›äº†è®¿é—®æ§åˆ¶èƒ½åŠ›ã€‚

**è¯æ˜**ï¼š
ä»£ç†å¯ä»¥æ§åˆ¶å¯¹ç›®æ ‡å¯¹è±¡çš„è®¿é—®ï¼ŒåŒ…æ‹¬æƒé™æ£€æŸ¥ã€ç¼“å­˜ã€å»¶è¿ŸåŠ è½½ç­‰ã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

### 3.1 ç»“æ„å‹æ¨¡å¼çš„åŸºæœ¬æ€§è´¨

**å®šç† 3.1** (ç»“æ„å‹æ¨¡å¼çš„ç»„åˆæ€§)
ç»“æ„å‹æ¨¡å¼æ”¯æŒå¯¹è±¡çš„ç»„åˆæ“ä½œã€‚

**è¯æ˜**ï¼š
è®¾ $S_1, S_2$ æ˜¯ä¸¤ä¸ªç»“æ„å‹æ¨¡å¼ï¼Œåˆ™å®ƒä»¬çš„ç»„åˆ $S_1 \circ S_2$ ä»ç„¶æ˜¯ä¸€ä¸ªç»“æ„å‹æ¨¡å¼ï¼Œå› ä¸ºï¼š
1. å¯¹è±¡é›†åˆçš„å¹¶é›†ä»ç„¶æ˜¯å¯¹è±¡é›†åˆ
2. å…³ç³»é›†åˆçš„å¹¶é›†ä»ç„¶æ˜¯å…³ç³»é›†åˆ
3. ç»„åˆè§„åˆ™å¯ä»¥é€’å½’åº”ç”¨
$\square$

**å®šç† 3.2** (ç»“æ„å‹æ¨¡å¼çš„ä¼ é€’æ€§)
ç»“æ„å‹æ¨¡å¼æ»¡è¶³ä¼ é€’æ€§ï¼šå¦‚æœ $A$ ä¸ $B$ æœ‰ç»“æ„å…³ç³»ï¼Œ$B$ ä¸ $C$ æœ‰ç»“æ„å…³ç³»ï¼Œåˆ™ $A$ ä¸ $C$ æœ‰ç»“æ„å…³ç³»ã€‚

**è¯æ˜**ï¼š
æ ¹æ®ç»“æ„å…³ç³»çš„å®šä¹‰ï¼Œå¯ä»¥é€šè¿‡ç»„åˆæ“ä½œå°† $A$ å’Œ $C$ è¿æ¥èµ·æ¥ã€‚$\square$

### 3.2 æ¨¡å¼é—´çš„å…³è”æ€§

**å®šç† 3.3** (é€‚é…å™¨ä¸ä»£ç†çš„å…³ç³»)
ä»£ç†æ¨¡å¼å¯ä»¥æ¨¡æ‹Ÿé€‚é…å™¨æ¨¡å¼ã€‚

**è¯æ˜**ï¼š
è®¾ $P$ æ˜¯ä»£ç†ï¼Œ$A$ æ˜¯é€‚é…å™¨ï¼Œåˆ™å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼æ¨¡æ‹Ÿï¼š
$$A(t) = P(\text{adapt}(t))$$
$\square$

**å®šç† 3.4** (è£…é¥°å™¨ä¸ç»„åˆçš„å…³ç³»)
è£…é¥°å™¨æ¨¡å¼æ˜¯ç»„åˆæ¨¡å¼çš„ç‰¹ä¾‹ã€‚

**è¯æ˜**ï¼š
è£…é¥°å™¨å¯ä»¥çœ‹ä½œæ˜¯ä¸€ç§ç‰¹æ®Šçš„ç»„åˆï¼Œå…¶ä¸­è£…é¥°å™¨å¯¹è±¡åŒ…è£…äº†è¢«è£…é¥°å¯¹è±¡ã€‚$\square$

## 4. ä»£ç å®ç°

### 4.1 é€‚é…å™¨æ¨¡å¼å®ç°

```rust
/// ç›®æ ‡æ¥å£
pub trait Target {
    fn request(&self) -> String;
}

/// è¢«é€‚é…çš„ç±»
pub struct Adaptee {
    specific_request: String,
}

impl Adaptee {
    pub fn new(request: String) -> Self {
        Self {
            specific_request: request,
        }
    }
    
    pub fn specific_request(&self) -> String {
        format!("Adaptee: {}", self.specific_request)
    }
}

/// é€‚é…å™¨
pub struct Adapter {
    adaptee: Adaptee,
}

impl Adapter {
    pub fn new(adaptee: Adaptee) -> Self {
        Self { adaptee }
    }
}

impl Target for Adapter {
    fn request(&self) -> String {
        // å°†é€‚é…å™¨çš„æ¥å£è½¬æ¢ä¸ºç›®æ ‡æ¥å£
        self.adaptee.specific_request()
    }
}

/// é€‚é…å™¨çš„æ•°å­¦éªŒè¯
pub struct AdapterValidator;

impl AdapterValidator {
    /// éªŒè¯é€‚é…å™¨çš„åŒå‘æ€§
    pub fn validate_bidirectional<T: Target>(target: &T) -> bool {
        let result = target.request();
        // éªŒè¯é€‚é…åçš„æ¥å£å¯ä»¥æ­£å¸¸å·¥ä½œ
        !result.is_empty()
    }
}
```

### 4.2 æ¡¥æ¥æ¨¡å¼å®ç°

```rust
/// å®ç°æ¥å£
pub trait Implementor {
    fn operation_impl(&self) -> String;
}

/// å…·ä½“å®ç°A
pub struct ConcreteImplementorA;

impl Implementor for ConcreteImplementorA {
    fn operation_impl(&self) -> String {
        String::from("ConcreteImplementorA operation")
    }
}

/// å…·ä½“å®ç°B
pub struct ConcreteImplementorB;

impl Implementor for ConcreteImplementorB {
    fn operation_impl(&self) -> String {
        String::from("ConcreteImplementorB operation")
    }
}

/// æŠ½è±¡ç±»
pub trait Abstraction {
    type Impl: Implementor;
    
    fn operation(&self) -> String;
    fn set_implementor(&mut self, implementor: Self::Impl);
}

/// å…·ä½“æŠ½è±¡ç±»
pub struct ConcreteAbstraction<I: Implementor> {
    implementor: I,
}

impl<I: Implementor> ConcreteAbstraction<I> {
    pub fn new(implementor: I) -> Self {
        Self { implementor }
    }
}

impl<I: Implementor> Abstraction for ConcreteAbstraction<I> {
    type Impl = I;
    
    fn operation(&self) -> String {
        format!("Abstraction: {}", self.implementor.operation_impl())
    }
    
    fn set_implementor(&mut self, implementor: Self::Impl) {
        self.implementor = implementor;
    }
}

/// æ¡¥æ¥çš„æ•°å­¦éªŒè¯
pub struct BridgeValidator;

impl BridgeValidator {
    /// éªŒè¯æ¡¥æ¥çš„ç‹¬ç«‹æ€§
    pub fn validate_independence<I: Implementor>(abstraction: &ConcreteAbstraction<I>) -> bool {
        let result = abstraction.operation();
        // éªŒè¯æŠ½è±¡å’Œå®ç°å¯ä»¥ç‹¬ç«‹å·¥ä½œ
        result.contains("Abstraction") && result.contains("operation")
    }
}
```

### 4.3 ç»„åˆæ¨¡å¼å®ç°

```rust
use std::collections::HashMap;

/// ç»„ä»¶ç‰¹å¾
pub trait Component {
    fn operation(&self) -> String;
    fn add(&mut self, component: Box<dyn Component>);
    fn remove(&mut self, component: &dyn Component);
    fn get_child(&self, index: usize) -> Option<&dyn Component>;
}

/// å¶å­ç»„ä»¶
pub struct Leaf {
    name: String,
}

impl Leaf {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

impl Component for Leaf {
    fn operation(&self) -> String {
        format!("Leaf: {}", self.name)
    }
    
    fn add(&mut self, _component: Box<dyn Component>) {
        // å¶å­èŠ‚ç‚¹ä¸æ”¯æŒæ·»åŠ å­ç»„ä»¶
    }
    
    fn remove(&mut self, _component: &dyn Component) {
        // å¶å­èŠ‚ç‚¹ä¸æ”¯æŒç§»é™¤å­ç»„ä»¶
    }
    
    fn get_child(&self, _index: usize) -> Option<&dyn Component> {
        None
    }
}

/// å¤åˆç»„ä»¶
pub struct Composite {
    name: String,
    children: Vec<Box<dyn Component>>,
}

impl Composite {
    pub fn new(name: String) -> Self {
        Self {
            name,
            children: Vec::new(),
        }
    }
}

impl Component for Composite {
    fn operation(&self) -> String {
        let mut result = format!("Composite: {}", self.name);
        for child in &self.children {
            result.push_str(&format!("\n  {}", child.operation()));
        }
        result
    }
    
    fn add(&mut self, component: Box<dyn Component>) {
        self.children.push(component);
    }
    
    fn remove(&mut self, component: &dyn Component) {
        self.children.retain(|c| !std::ptr::eq(c.as_ref(), component));
    }
    
    fn get_child(&self, index: usize) -> Option<&dyn Component> {
        self.children.get(index).map(|c| c.as_ref())
    }
}

/// ç»„åˆçš„æ•°å­¦éªŒè¯
pub struct CompositeValidator;

impl CompositeValidator {
    /// éªŒè¯ç»„åˆçš„ä¸€è‡´æ€§
    pub fn validate_consistency(component: &dyn Component) -> bool {
        let result = component.operation();
        // éªŒè¯å¶å­èŠ‚ç‚¹å’Œå¤åˆèŠ‚ç‚¹éƒ½å®ç°äº†ç›¸åŒçš„æ¥å£
        !result.is_empty()
    }
}
```

### 4.4 è£…é¥°å™¨æ¨¡å¼å®ç°

```rust
/// ç»„ä»¶æ¥å£
pub trait Component {
    fn operation(&self) -> String;
}

/// å…·ä½“ç»„ä»¶
pub struct ConcreteComponent;

impl Component for ConcreteComponent {
    fn operation(&self) -> String {
        String::from("ConcreteComponent")
    }
}

/// è£…é¥°å™¨åŸºç±»
pub struct Decorator<C: Component> {
    component: C,
}

impl<C: Component> Decorator<C> {
    pub fn new(component: C) -> Self {
        Self { component }
    }
}

impl<C: Component> Component for Decorator<C> {
    fn operation(&self) -> String {
        self.component.operation()
    }
}

/// å…·ä½“è£…é¥°å™¨A
pub struct ConcreteDecoratorA<C: Component> {
    decorator: Decorator<C>,
}

impl<C: Component> ConcreteDecoratorA<C> {
    pub fn new(component: C) -> Self {
        Self {
            decorator: Decorator::new(component),
        }
    }
}

impl<C: Component> Component for ConcreteDecoratorA<C> {
    fn operation(&self) -> String {
        format!("ConcreteDecoratorA({})", self.decorator.operation())
    }
}

/// å…·ä½“è£…é¥°å™¨B
pub struct ConcreteDecoratorB<C: Component> {
    decorator: Decorator<C>,
}

impl<C: Component> ConcreteDecoratorB<C> {
    pub fn new(component: C) -> Self {
        Self {
            decorator: Decorator::new(component),
        }
    }
}

impl<C: Component> Component for ConcreteDecoratorB<C> {
    fn operation(&self) -> String {
        format!("ConcreteDecoratorB({})", self.decorator.operation())
    }
}

/// è£…é¥°å™¨çš„æ•°å­¦éªŒè¯
pub struct DecoratorValidator;

impl DecoratorValidator {
    /// éªŒè¯è£…é¥°å™¨çš„å¯ç»„åˆæ€§
    pub fn validate_composability<C: Component>(component: C) -> bool {
        let decorated_a = ConcreteDecoratorA::new(component);
        let decorated_b = ConcreteDecoratorB::new(decorated_a);
        let result = decorated_b.operation();
        // éªŒè¯å¤šå±‚è£…é¥°å¯ä»¥æ­£å¸¸å·¥ä½œ
        result.contains("ConcreteDecoratorB") && result.contains("ConcreteDecoratorA")
    }
}
```

### 4.5 å¤–è§‚æ¨¡å¼å®ç°

```rust
/// å­ç³»ç»ŸA
pub struct SubsystemA;

impl SubsystemA {
    pub fn operation_a(&self) -> String {
        String::from("SubsystemA operation")
    }
}

/// å­ç³»ç»ŸB
pub struct SubsystemB;

impl SubsystemB {
    pub fn operation_b(&self) -> String {
        String::from("SubsystemB operation")
    }
}

/// å­ç³»ç»ŸC
pub struct SubsystemC;

impl SubsystemC {
    pub fn operation_c(&self) -> String {
        String::from("SubsystemC operation")
    }
}

/// å¤–è§‚ç±»
pub struct Facade {
    subsystem_a: SubsystemA,
    subsystem_b: SubsystemB,
    subsystem_c: SubsystemC,
}

impl Facade {
    pub fn new() -> Self {
        Self {
            subsystem_a: SubsystemA,
            subsystem_b: SubsystemB,
            subsystem_c: SubsystemC,
        }
    }
    
    pub fn operation(&self) -> String {
        let mut result = String::new();
        result.push_str(&self.subsystem_a.operation_a());
        result.push_str("\n");
        result.push_str(&self.subsystem_b.operation_b());
        result.push_str("\n");
        result.push_str(&self.subsystem_c.operation_c());
        result
    }
}

/// å¤–è§‚çš„æ•°å­¦éªŒè¯
pub struct FacadeValidator;

impl FacadeValidator {
    /// éªŒè¯å¤–è§‚çš„ç®€åŒ–æ€§
    pub fn validate_simplification(facade: &Facade) -> bool {
        let result = facade.operation();
        // éªŒè¯å¤–è§‚ç®€åŒ–äº†å¤æ‚ç³»ç»Ÿçš„ä½¿ç”¨
        result.contains("SubsystemA") && result.contains("SubsystemB") && result.contains("SubsystemC")
    }
}
```

### 4.6 äº«å…ƒæ¨¡å¼å®ç°

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

/// äº«å…ƒæ¥å£
pub trait Flyweight {
    fn operation(&self, extrinsic_state: &str) -> String;
}

/// å…·ä½“äº«å…ƒ
pub struct ConcreteFlyweight {
    intrinsic_state: String,
}

impl ConcreteFlyweight {
    pub fn new(intrinsic_state: String) -> Self {
        Self { intrinsic_state }
    }
}

impl Flyweight for ConcreteFlyweight {
    fn operation(&self, extrinsic_state: &str) -> String {
        format!("ConcreteFlyweight: {} + {}", self.intrinsic_state, extrinsic_state)
    }
}

/// äº«å…ƒå·¥å‚
pub struct FlyweightFactory {
    flyweights: HashMap<String, Arc<dyn Flyweight>>,
}

impl FlyweightFactory {
    pub fn new() -> Self {
        Self {
            flyweights: HashMap::new(),
        }
    }
    
    pub fn get_flyweight(&mut self, key: String) -> Arc<dyn Flyweight> {
        if let Some(flyweight) = self.flyweights.get(&key) {
            flyweight.clone()
        } else {
            let flyweight = Arc::new(ConcreteFlyweight::new(key.clone()));
            self.flyweights.insert(key, flyweight.clone());
            flyweight
        }
    }
    
    pub fn count(&self) -> usize {
        self.flyweights.len()
    }
}

/// äº«å…ƒçš„æ•°å­¦éªŒè¯
pub struct FlyweightValidator;

impl FlyweightValidator {
    /// éªŒè¯äº«å…ƒçš„å…±äº«æ€§
    pub fn validate_sharing(factory: &mut FlyweightFactory) -> bool {
        let initial_count = factory.count();
        let flyweight1 = factory.get_flyweight("shared".to_string());
        let flyweight2 = factory.get_flyweight("shared".to_string());
        let final_count = factory.count();
        
        // éªŒè¯ç›¸åŒkeyçš„äº«å…ƒè¢«å…±äº«
        initial_count + 1 == final_count
    }
}
```

### 4.7 ä»£ç†æ¨¡å¼å®ç°

```rust
/// æœåŠ¡æ¥å£
pub trait Service {
    fn operation(&self) -> String;
}

/// çœŸå®æœåŠ¡
pub struct RealService;

impl Service for RealService {
    fn operation(&self) -> String {
        String::from("RealService operation")
    }
}

/// ä»£ç†æœåŠ¡
pub struct ProxyService {
    real_service: Option<RealService>,
}

impl ProxyService {
    pub fn new() -> Self {
        Self {
            real_service: None,
        }
    }
    
    fn lazy_init(&mut self) {
        if self.real_service.is_none() {
            self.real_service = Some(RealService);
        }
    }
}

impl Service for ProxyService {
    fn operation(&self) -> String {
        // ä»£ç†å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„é€»è¾‘ï¼Œå¦‚è®¿é—®æ§åˆ¶ã€ç¼“å­˜ç­‰
        if let Some(ref service) = self.real_service {
            format!("Proxy: {}", service.operation())
        } else {
            String::from("Proxy: Service not initialized")
        }
    }
}

/// ä»£ç†çš„æ•°å­¦éªŒè¯
pub struct ProxyValidator;

impl ProxyValidator {
    /// éªŒè¯ä»£ç†çš„æ§åˆ¶æ€§
    pub fn validate_control(mut proxy: ProxyService) -> bool {
        let result = proxy.operation();
        // éªŒè¯ä»£ç†å¯ä»¥æ§åˆ¶å¯¹çœŸå®æœåŠ¡çš„è®¿é—®
        result.contains("Proxy")
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å›¾å½¢ç¼–è¾‘å™¨çš„ç»„åˆæ¨¡å¼

```rust
use std::collections::HashMap;

/// å›¾å½¢ç»„ä»¶
pub trait Graphic {
    fn draw(&self) -> String;
    fn add(&mut self, graphic: Box<dyn Graphic>);
    fn remove(&mut self, graphic: &dyn Graphic);
    fn get_child(&self, index: usize) -> Option<&dyn Graphic>;
}

/// ç®€å•å›¾å½¢
pub struct SimpleGraphic {
    name: String,
}

impl SimpleGraphic {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

impl Graphic for SimpleGraphic {
    fn draw(&self) -> String {
        format!("Drawing {}", self.name)
    }
    
    fn add(&mut self, _graphic: Box<dyn Graphic>) {
        // ç®€å•å›¾å½¢ä¸æ”¯æŒæ·»åŠ å­å›¾å½¢
    }
    
    fn remove(&mut self, _graphic: &dyn Graphic) {
        // ç®€å•å›¾å½¢ä¸æ”¯æŒç§»é™¤å­å›¾å½¢
    }
    
    fn get_child(&self, _index: usize) -> Option<&dyn Graphic> {
        None
    }
}

/// å¤åˆå›¾å½¢
pub struct CompositeGraphic {
    name: String,
    children: Vec<Box<dyn Graphic>>,
}

impl CompositeGraphic {
    pub fn new(name: String) -> Self {
        Self {
            name,
            children: Vec::new(),
        }
    }
}

impl Graphic for CompositeGraphic {
    fn draw(&self) -> String {
        let mut result = format!("Drawing composite: {}", self.name);
        for child in &self.children {
            result.push_str(&format!("\n  {}", child.draw()));
        }
        result
    }
    
    fn add(&mut self, graphic: Box<dyn Graphic>) {
        self.children.push(graphic);
    }
    
    fn remove(&mut self, graphic: &dyn Graphic) {
        self.children.retain(|g| !std::ptr::eq(g.as_ref(), graphic));
    }
    
    fn get_child(&self, index: usize) -> Option<&dyn Graphic> {
        self.children.get(index).map(|g| g.as_ref())
    }
}
```

### 5.2 å’–å•¡åº—çš„è£…é¥°å™¨æ¨¡å¼

```rust
/// å’–å•¡æ¥å£
pub trait Coffee {
    fn cost(&self) -> f64;
    fn description(&self) -> String;
}

/// åŸºç¡€å’–å•¡
pub struct SimpleCoffee;

impl Coffee for SimpleCoffee {
    fn cost(&self) -> f64 {
        2.0
    }
    
    fn description(&self) -> String {
        String::from("Simple coffee")
    }
}

/// å’–å•¡è£…é¥°å™¨
pub struct CoffeeDecorator<C: Coffee> {
    coffee: C,
}

impl<C: Coffee> CoffeeDecorator<C> {
    pub fn new(coffee: C) -> Self {
        Self { coffee }
    }
}

impl<C: Coffee> Coffee for CoffeeDecorator<C> {
    fn cost(&self) -> f64 {
        self.coffee.cost()
    }
    
    fn description(&self) -> String {
        self.coffee.description()
    }
}

/// ç‰›å¥¶è£…é¥°å™¨
pub struct MilkDecorator<C: Coffee> {
    decorator: CoffeeDecorator<C>,
}

impl<C: Coffee> MilkDecorator<C> {
    pub fn new(coffee: C) -> Self {
        Self {
            decorator: CoffeeDecorator::new(coffee),
        }
    }
}

impl<C: Coffee> Coffee for MilkDecorator<C> {
    fn cost(&self) -> f64 {
        self.decorator.cost() + 0.5
    }
    
    fn description(&self) -> String {
        format!("{} with milk", self.decorator.description())
    }
}

/// ç³–è£…é¥°å™¨
pub struct SugarDecorator<C: Coffee> {
    decorator: CoffeeDecorator<C>,
}

impl<C: Coffee> SugarDecorator<C> {
    pub fn new(coffee: C) -> Self {
        Self {
            decorator: CoffeeDecorator::new(coffee),
        }
    }
}

impl<C: Coffee> Coffee for SugarDecorator<C> {
    fn cost(&self) -> f64 {
        self.decorator.cost() + 0.2
    }
    
    fn description(&self) -> String {
        format!("{} with sugar", self.decorator.description())
    }
}
```

### 5.3 æ–‡ä»¶ç³»ç»Ÿçš„å¤–è§‚æ¨¡å¼

```rust
use std::collections::HashMap;

/// æ–‡ä»¶ç³»ç»Ÿç»„ä»¶
pub trait FileSystemComponent {
    fn display(&self, indent: usize) -> String;
}

/// æ–‡ä»¶
pub struct File {
    name: String,
    size: usize,
}

impl File {
    pub fn new(name: String, size: usize) -> Self {
        Self { name, size }
    }
}

impl FileSystemComponent for File {
    fn display(&self, indent: usize) -> String {
        let indent_str = "  ".repeat(indent);
        format!("{}File: {} ({} bytes)", indent_str, self.name, self.size)
    }
}

/// ç›®å½•
pub struct Directory {
    name: String,
    children: Vec<Box<dyn FileSystemComponent>>,
}

impl Directory {
    pub fn new(name: String) -> Self {
        Self {
            name,
            children: Vec::new(),
        }
    }
    
    pub fn add(&mut self, component: Box<dyn FileSystemComponent>) {
        self.children.push(component);
    }
}

impl FileSystemComponent for Directory {
    fn display(&self, indent: usize) -> String {
        let indent_str = "  ".repeat(indent);
        let mut result = format!("{}Directory: {}", indent_str, self.name);
        for child in &self.children {
            result.push_str(&format!("\n{}", child.display(indent + 1)));
        }
        result
    }
}

/// æ–‡ä»¶ç³»ç»Ÿå¤–è§‚
pub struct FileSystemFacade {
    root: Directory,
}

impl FileSystemFacade {
    pub fn new() -> Self {
        let mut root = Directory::new("root".to_string());
        
        // åˆ›å»ºæ–‡ä»¶ç»“æ„
        let mut documents = Directory::new("documents".to_string());
        documents.add(Box::new(File::new("report.txt".to_string(), 1024)));
        documents.add(Box::new(File::new("presentation.pdf".to_string(), 2048)));
        
        let mut pictures = Directory::new("pictures".to_string());
        pictures.add(Box::new(File::new("photo1.jpg".to_string(), 512)));
        pictures.add(Box::new(File::new("photo2.jpg".to_string(), 768)));
        
        root.add(Box::new(documents));
        root.add(Box::new(pictures));
        
        Self { root }
    }
    
    pub fn display_structure(&self) -> String {
        self.root.display(0)
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸è®¾è®¡æ¨¡å¼ç†è®ºçš„å…³ç³»

ç»“æ„å‹æ¨¡å¼æ˜¯è®¾è®¡æ¨¡å¼ç†è®ºçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œä¸åˆ›å»ºå‹æ¨¡å¼å’Œè¡Œä¸ºå‹æ¨¡å¼å½¢æˆå®Œæ•´çš„æ¨¡å¼ä½“ç³»ã€‚

**å®šç† 6.1** (ç»“æ„å‹æ¨¡å¼çš„ç‹¬ç«‹æ€§)
ç»“æ„å‹æ¨¡å¼å¯ä»¥ç‹¬ç«‹äºåˆ›å»ºå‹æ¨¡å¼å’Œè¡Œä¸ºå‹æ¨¡å¼ä½¿ç”¨ã€‚

**è¯æ˜**ï¼š
ç»“æ„å‹æ¨¡å¼å…³æ³¨å¯¹è±¡ç»„åˆï¼Œä¸ä¾èµ–äºå¯¹è±¡çš„åˆ›å»ºæ–¹å¼æˆ–è¡Œä¸ºæ–¹å¼ï¼Œå› æ­¤å¯ä»¥ç‹¬ç«‹ä½¿ç”¨ã€‚$\square$

### 6.2 ä¸é¢å‘å¯¹è±¡ç†è®ºçš„å…³ç³»

ç»“æ„å‹æ¨¡å¼ä½“ç°äº†é¢å‘å¯¹è±¡ç†è®ºä¸­çš„ç»„åˆä¼˜äºç»§æ‰¿åŸåˆ™ã€‚

**å®šç† 6.2** (ç»„åˆä¼˜äºç»§æ‰¿)
ç»“æ„å‹æ¨¡å¼é€šè¿‡ç»„åˆå®ç°äº†æ¯”ç»§æ‰¿æ›´çµæ´»çš„è®¾è®¡ã€‚

**è¯æ˜**ï¼š
ç»„åˆæ¨¡å¼å…è®¸åœ¨è¿è¡Œæ—¶åŠ¨æ€æ”¹å˜å¯¹è±¡çš„ç»“æ„ï¼Œè€Œç»§æ‰¿æ˜¯é™æ€çš„ï¼Œå› æ­¤ç»„åˆæ›´åŠ çµæ´»ã€‚$\square$

### 6.3 ä¸è½¯ä»¶å·¥ç¨‹ç†è®ºçš„å…³ç³»

ç»“æ„å‹æ¨¡å¼æ˜¯è½¯ä»¶å·¥ç¨‹ä¸­é‡è¦çš„è®¾è®¡åŸåˆ™ï¼Œä½“ç°äº†å¼€é—­åŸåˆ™å’Œé‡Œæ°æ›¿æ¢åŸåˆ™ã€‚

**å®šç† 6.3** (å¼€é—­åŸåˆ™çš„ä½“ç°)
ç»“æ„å‹æ¨¡å¼æ”¯æŒå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­ã€‚

**è¯æ˜**ï¼š
é€šè¿‡ç»„åˆå’Œæ¥å£ï¼Œå¯ä»¥åœ¨ä¸ä¿®æ”¹ç°æœ‰ä»£ç çš„æƒ…å†µä¸‹æ·»åŠ æ–°çš„åŠŸèƒ½ã€‚$\square$

## 7. å‚è€ƒæ–‡çŒ®

1. Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.
2. Freeman, E., Robson, E., Sierra, K., & Bates, B. (2004). Head First Design Patterns. O'Reilly Media.
3. Martin, R. C. (2000). Design Principles and Design Patterns. Object Mentor.
4. Liskov, B. (1987). Data Abstraction and Hierarchy. SIGPLAN Notices, 23(5), 17-34.
5. Meyer, B. (1988). Object-Oriented Software Construction. Prentice Hall.

---

**ç›¸å…³é“¾æ¥**ï¼š
- [07.3.1 åˆ›å»ºå‹æ¨¡å¼](../07.3.1_åˆ›å»ºå‹æ¨¡å¼.md)
- [07.3.3 è¡Œä¸ºå‹æ¨¡å¼](../07.3.3_è¡Œä¸ºå‹æ¨¡å¼.md)
- [07.3.4 æ¶æ„æ¨¡å¼](../07.3.4_æ¶æ„æ¨¡å¼.md)
- [07.2.1 æ¶æ„è®¾è®¡åŸåˆ™](../07.2.1_æ¶æ„è®¾è®¡åŸåˆ™.md)
- [07.2.2 æ¶æ„æ¨¡å¼ç†è®º](../07.2.2_æ¶æ„æ¨¡å¼ç†è®º.md) 