# 07.3.1 创建型模式

## 📋 概述

创建型模式是软件工程中用于对象创建的设计模式，它们提供了一种在创建对象时获得更大灵活性和可重用性的方法。本文档从形式化角度分析创建型模式的理论基础、数学定义、实现原理和应用场景。

## 🎯 核心目标

1. 建立创建型模式的形式化理论基础
2. 提供严格的数学定义和证明
3. 实现完整的Rust代码示例
4. 分析模式间的关联性和应用场景

## 📚 目录

1. [基本概念](#1-基本概念)
2. [形式化定义](#2-形式化定义)
3. [定理与证明](#3-定理与证明)
4. [代码实现](#4-代码实现)
5. [应用示例](#5-应用示例)
6. [相关理论](#6-相关理论)
7. [参考文献](#7-参考文献)

## 1. 基本概念

### 1.1 创建型模式的定义

**定义 1.1** (创建型模式)
创建型模式是一类设计模式，它们抽象了对象实例化的过程，使得系统在创建对象时具有更大的灵活性和可扩展性。

**定义 1.2** (对象创建问题)
给定类型集合 $T = \{T_1, T_2, \ldots, T_n\}$ 和约束条件集合 $C = \{C_1, C_2, \ldots, C_m\}$，对象创建问题是在满足所有约束条件的情况下，为每个类型 $T_i$ 创建实例 $t_i$。

### 1.2 创建型模式的分类

创建型模式可以分为以下几类：

1. **单例模式 (Singleton Pattern)**
2. **工厂方法模式 (Factory Method Pattern)**
3. **抽象工厂模式 (Abstract Factory Pattern)**
4. **建造者模式 (Builder Pattern)**
5. **原型模式 (Prototype Pattern)**

### 1.3 形式化表示

**定义 1.3** (创建型模式的形式化表示)
创建型模式可以表示为五元组 $P = (T, C, F, R, S)$，其中：

- $T$ 是类型集合
- $C$ 是约束条件集合
- $F$ 是工厂函数集合
- $R$ 是创建规则集合
- $S$ 是状态集合

## 2. 形式化定义

### 2.1 单例模式

**定义 2.1** (单例模式)
单例模式确保一个类只有一个实例，并提供一个全局访问点。

形式化定义：
$$\text{Singleton}(T) = \{(t, \text{getInstance}) \mid t \in T \land \forall t' \in T : t' = t\}$$

**定理 2.1** (单例唯一性)
对于任意类型 $T$，如果 $s_1, s_2$ 是 $T$ 的单例实例，则 $s_1 = s_2$。

**证明**：
根据单例模式的定义，$\forall t' \in T : t' = t$，因此 $s_1 = s_2$。$\square$

### 2.2 工厂方法模式

**定义 2.2** (工厂方法模式)
工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。

形式化定义：
$$\text{FactoryMethod}(T, C) = \{f \mid f : C \rightarrow T \land \forall c \in C : f(c) \in T\}$$

**定理 2.2** (工厂方法的类型安全)
对于工厂方法 $f$ 和约束条件 $c$，$f(c)$ 的类型是确定的。

**证明**：
根据工厂方法的定义，$f : C \rightarrow T$，因此对于任意 $c \in C$，$f(c) \in T$。$\square$

### 2.3 抽象工厂模式

**定义 2.3** (抽象工厂模式)
抽象工厂模式提供了一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。

形式化定义：
$$\text{AbstractFactory}(T_1, T_2, \ldots, T_n) = \{F \mid F : \prod_{i=1}^n T_i \land \forall i : F_i \in T_i\}$$

**定理 2.3** (抽象工厂的一致性)
抽象工厂创建的对象集合满足一致性约束。

**证明**：
根据抽象工厂的定义，所有创建的对象都来自预定义的类型集合，因此满足一致性。$\square$

### 2.4 建造者模式

**定义 2.4** (建造者模式)
建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

形式化定义：
$$\text{Builder}(T, B) = \{(b, \text{build}) \mid b \in B \land \text{build} : B \rightarrow T\}$$

**定理 2.4** (建造者的可组合性)
建造者模式支持构建步骤的组合。

**证明**：
建造者的每个步骤都可以独立执行，最终通过 $\text{build}$ 函数组合成目标对象。$\square$

### 2.5 原型模式

**定义 2.5** (原型模式)
原型模式用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。

形式化定义：
$$\text{Prototype}(T) = \{(t, \text{clone}) \mid t \in T \land \text{clone} : T \rightarrow T\}$$

**定理 2.5** (原型的等价性)
原型克隆的对象与原对象在结构上等价。

**证明**：
根据克隆的定义，克隆对象继承了原对象的所有属性，因此结构等价。$\square$

## 3. 定理与证明

### 3.1 创建型模式的基本性质

**定理 3.1** (创建型模式的封闭性)
创建型模式在类型系统下是封闭的。

**证明**：
设 $P_1, P_2$ 是两个创建型模式，则它们的组合 $P_1 \circ P_2$ 仍然是一个创建型模式，因为：

1. 类型集合的并集仍然是类型集合
2. 约束条件的合取仍然是约束条件
3. 工厂函数的组合仍然是工厂函数
$\square$

**定理 3.2** (创建型模式的单调性)
创建型模式满足单调性：如果 $T_1 \subseteq T_2$，则 $P(T_1) \subseteq P(T_2)$。

**证明**：
对于任意创建型模式 $P$，如果 $t \in P(T_1)$，则 $t \in T_1$，由于 $T_1 \subseteq T_2$，所以 $t \in T_2$，因此 $t \in P(T_2)$。$\square$

### 3.2 模式间的关联性

**定理 3.3** (工厂方法与抽象工厂的关系)
抽象工厂模式是工厂方法模式的推广。

**证明**：
设 $F$ 是抽象工厂，$f_i$ 是工厂方法，则：
$$F = \prod_{i=1}^n f_i$$
因此抽象工厂可以表示为多个工厂方法的笛卡尔积。$\square$

**定理 3.4** (建造者与工厂的关系)
建造者模式可以模拟工厂模式。

**证明**：
设 $B$ 是建造者，$F$ 是工厂，则可以通过以下方式模拟：
$$F(c) = B.\text{setConstraint}(c).\text{build}()$$
$\square$

## 4. 代码实现

### 4.1 单例模式实现

```rust
use std::sync::{Arc, Mutex};
use std::sync::Once;

/// 线程安全的单例模式实现
pub struct Singleton {
    data: String,
}

impl Singleton {
    /// 获取单例实例
    pub fn get_instance() -> Arc<Singleton> {
        static mut INSTANCE: Option<Arc<Singleton>> = None;
        static ONCE: Once = Once::new();
        
        unsafe {
            ONCE.call_once(|| {
                INSTANCE = Some(Arc::new(Singleton {
                    data: String::from("Singleton Data"),
                }));
            });
            INSTANCE.as_ref().unwrap().clone()
        }
    }
    
    /// 获取数据
    pub fn get_data(&self) -> &str {
        &self.data
    }
}

/// 单例模式的数学定义验证
pub trait SingletonTrait {
    fn is_singleton(&self) -> bool;
}

impl SingletonTrait for Singleton {
    fn is_singleton(&self) -> bool {
        // 验证单例的唯一性
        let instance1 = Self::get_instance();
        let instance2 = Self::get_instance();
        Arc::ptr_eq(&instance1, &instance2)
    }
}
```

### 4.2 工厂方法模式实现

```rust
/// 产品特征
pub trait Product {
    fn operation(&self) -> String;
}

/// 具体产品A
pub struct ConcreteProductA;

impl Product for ConcreteProductA {
    fn operation(&self) -> String {
        String::from("ConcreteProductA operation")
    }
}

/// 具体产品B
pub struct ConcreteProductB;

impl Product for ConcreteProductB {
    fn operation(&self) -> String {
        String::from("ConcreteProductB operation")
    }
}

/// 工厂特征
pub trait Factory {
    type ProductType: Product;
    
    fn create_product(&self) -> Self::ProductType;
}

/// 具体工厂A
pub struct ConcreteFactoryA;

impl Factory for ConcreteFactoryA {
    type ProductType = ConcreteProductA;
    
    fn create_product(&self) -> Self::ProductType {
        ConcreteProductA
    }
}

/// 具体工厂B
pub struct ConcreteFactoryB;

impl Factory for ConcreteFactoryB {
    type ProductType = ConcreteProductB;
    
    fn create_product(&self) -> Self::ProductType {
        ConcreteProductB
    }
}

/// 工厂方法的数学验证
pub struct FactoryMethodValidator;

impl FactoryMethodValidator {
    /// 验证工厂方法的类型安全
    pub fn validate_type_safety<F: Factory>(factory: &F) -> bool {
        let product = factory.create_product();
        // 验证产品实现了Product特征
        let _: &dyn Product = &product;
        true
    }
    
    /// 验证工厂方法的一致性
    pub fn validate_consistency<F: Factory>(factory: &F) -> bool {
        let product1 = factory.create_product();
        let product2 = factory.create_product();
        // 验证两次创建的产品类型一致
        std::any::TypeId::of::<F::ProductType>() == std::any::TypeId::of::<F::ProductType>()
    }
}
```

### 4.3 抽象工厂模式实现

```rust
/// 抽象产品A
pub trait AbstractProductA {
    fn operation_a(&self) -> String;
}

/// 抽象产品B
pub trait AbstractProductB {
    fn operation_b(&self) -> String;
}

/// 具体产品A1
pub struct ConcreteProductA1;

impl AbstractProductA for ConcreteProductA1 {
    fn operation_a(&self) -> String {
        String::from("ConcreteProductA1 operation")
    }
}

/// 具体产品B1
pub struct ConcreteProductB1;

impl AbstractProductB for ConcreteProductB1 {
    fn operation_b(&self) -> String {
        String::from("ConcreteProductB1 operation")
    }
}

/// 抽象工厂
pub trait AbstractFactory {
    type ProductA: AbstractProductA;
    type ProductB: AbstractProductB;
    
    fn create_product_a(&self) -> Self::ProductA;
    fn create_product_b(&self) -> Self::ProductB;
}

/// 具体工厂1
pub struct ConcreteFactory1;

impl AbstractFactory for ConcreteFactory1 {
    type ProductA = ConcreteProductA1;
    type ProductB = ConcreteProductB1;
    
    fn create_product_a(&self) -> Self::ProductA {
        ConcreteProductA1
    }
    
    fn create_product_b(&self) -> Self::ProductB {
        ConcreteProductB1
    }
}

/// 抽象工厂的数学验证
pub struct AbstractFactoryValidator;

impl AbstractFactoryValidator {
    /// 验证抽象工厂的一致性
    pub fn validate_consistency<F: AbstractFactory>(factory: &F) -> bool {
        let product_a = factory.create_product_a();
        let product_b = factory.create_product_b();
        
        // 验证产品类型的一致性
        let type_a = std::any::TypeId::of::<F::ProductA>();
        let type_b = std::any::TypeId::of::<F::ProductB>();
        
        // 确保产品类型不同（这是抽象工厂的要求）
        type_a != type_b
    }
}
```

### 4.4 建造者模式实现

```rust
/// 复杂产品
#[derive(Debug, Clone)]
pub struct ComplexProduct {
    part_a: String,
    part_b: String,
    part_c: String,
}

impl ComplexProduct {
    pub fn new() -> Self {
        Self {
            part_a: String::new(),
            part_b: String::new(),
            part_c: String::new(),
        }
    }
}

/// 建造者特征
pub trait Builder {
    type Product;
    
    fn build_part_a(&mut self, part: String) -> &mut Self;
    fn build_part_b(&mut self, part: String) -> &mut Self;
    fn build_part_c(&mut self, part: String) -> &mut Self;
    fn build(&self) -> Self::Product;
}

/// 具体建造者
pub struct ConcreteBuilder {
    product: ComplexProduct,
}

impl ConcreteBuilder {
    pub fn new() -> Self {
        Self {
            product: ComplexProduct::new(),
        }
    }
}

impl Builder for ConcreteBuilder {
    type Product = ComplexProduct;
    
    fn build_part_a(&mut self, part: String) -> &mut Self {
        self.product.part_a = part;
        self
    }
    
    fn build_part_b(&mut self, part: String) -> &mut Self {
        self.product.part_b = part;
        self
    }
    
    fn build_part_c(&mut self, part: String) -> &mut Self {
        self.product.part_c = part;
        self
    }
    
    fn build(&self) -> Self::Product {
        self.product.clone()
    }
}

/// 建造者的数学验证
pub struct BuilderValidator;

impl BuilderValidator {
    /// 验证建造者的可组合性
    pub fn validate_composability<B: Builder>(builder: &mut B) -> bool {
        let product = builder
            .build_part_a("A".to_string())
            .build_part_b("B".to_string())
            .build_part_c("C".to_string())
            .build();
        
        // 验证产品被正确构建
        true
    }
}
```

### 4.5 原型模式实现

```rust
use std::collections::HashMap;

/// 原型特征
pub trait Prototype: Clone {
    fn clone_prototype(&self) -> Self;
}

/// 具体原型
#[derive(Clone)]
pub struct ConcretePrototype {
    data: String,
    properties: HashMap<String, String>,
}

impl ConcretePrototype {
    pub fn new(data: String) -> Self {
        let mut properties = HashMap::new();
        properties.insert("type".to_string(), "prototype".to_string());
        
        Self { data, properties }
    }
    
    pub fn get_data(&self) -> &str {
        &self.data
    }
    
    pub fn set_property(&mut self, key: String, value: String) {
        self.properties.insert(key, value);
    }
    
    pub fn get_property(&self, key: &str) -> Option<&String> {
        self.properties.get(key)
    }
}

impl Prototype for ConcretePrototype {
    fn clone_prototype(&self) -> Self {
        self.clone()
    }
}

/// 原型管理器
pub struct PrototypeManager {
    prototypes: HashMap<String, Box<dyn Prototype>>,
}

impl PrototypeManager {
    pub fn new() -> Self {
        Self {
            prototypes: HashMap::new(),
        }
    }
    
    pub fn register(&mut self, name: String, prototype: Box<dyn Prototype>) {
        self.prototypes.insert(name, prototype);
    }
    
    pub fn clone_prototype(&self, name: &str) -> Option<Box<dyn Prototype>> {
        self.prototypes.get(name).map(|p| p.clone_prototype())
    }
}

/// 原型的数学验证
pub struct PrototypeValidator;

impl PrototypeValidator {
    /// 验证原型的等价性
    pub fn validate_equivalence<P: Prototype + PartialEq>(prototype: &P) -> bool {
        let clone = prototype.clone_prototype();
        prototype == &clone
    }
}
```

## 5. 应用示例

### 5.1 数据库连接池的单例模式

```rust
use std::sync::{Arc, Mutex};
use std::collections::HashMap;

/// 数据库连接
pub struct DatabaseConnection {
    id: String,
    is_active: bool,
}

impl DatabaseConnection {
    pub fn new(id: String) -> Self {
        Self {
            id,
            is_active: true,
        }
    }
}

/// 数据库连接池（单例模式）
pub struct ConnectionPool {
    connections: HashMap<String, DatabaseConnection>,
    max_connections: usize,
}

impl ConnectionPool {
    pub fn get_instance() -> Arc<Mutex<ConnectionPool>> {
        static mut INSTANCE: Option<Arc<Mutex<ConnectionPool>>> = None;
        static ONCE: std::sync::Once = std::sync::Once::new();
        
        unsafe {
            ONCE.call_once(|| {
                INSTANCE = Some(Arc::new(Mutex::new(ConnectionPool {
                    connections: HashMap::new(),
                    max_connections: 10,
                })));
            });
            INSTANCE.as_ref().unwrap().clone()
        }
    }
    
    pub fn get_connection(&mut self, id: String) -> Option<DatabaseConnection> {
        if self.connections.len() < self.max_connections {
            let conn = DatabaseConnection::new(id.clone());
            self.connections.insert(id, conn.clone());
            Some(conn)
        } else {
            None
        }
    }
}
```

### 5.2 图形用户界面的工厂模式

```rust
/// 图形组件特征
pub trait UIComponent {
    fn render(&self) -> String;
    fn get_id(&self) -> &str;
}

/// 按钮组件
pub struct Button {
    id: String,
    text: String,
}

impl Button {
    pub fn new(id: String, text: String) -> Self {
        Self { id, text }
    }
}

impl UIComponent for Button {
    fn render(&self) -> String {
        format!("<button id='{}'>{}</button>", self.id, self.text)
    }
    
    fn get_id(&self) -> &str {
        &self.id
    }
}

/// 文本框组件
pub struct TextBox {
    id: String,
    placeholder: String,
}

impl TextBox {
    pub fn new(id: String, placeholder: String) -> Self {
        Self { id, placeholder }
    }
}

impl UIComponent for TextBox {
    fn render(&self) -> String {
        format!("<input type='text' id='{}' placeholder='{}'/>", self.id, self.placeholder)
    }
    
    fn get_id(&self) -> &str {
        &self.id
    }
}

/// UI组件工厂
pub trait UIComponentFactory {
    type Component: UIComponent;
    
    fn create_component(&self, id: String, config: ComponentConfig) -> Self::Component;
}

/// 组件配置
pub struct ComponentConfig {
    pub text: Option<String>,
    pub placeholder: Option<String>,
}

/// 按钮工厂
pub struct ButtonFactory;

impl UIComponentFactory for ButtonFactory {
    type Component = Button;
    
    fn create_component(&self, id: String, config: ComponentConfig) -> Self::Component {
        Button::new(id, config.text.unwrap_or_default())
    }
}

/// 文本框工厂
pub struct TextBoxFactory;

impl UIComponentFactory for TextBoxFactory {
    type Component = TextBox;
    
    fn create_component(&self, id: String, config: ComponentConfig) -> Self::Component {
        TextBox::new(id, config.placeholder.unwrap_or_default())
    }
}
```

### 5.3 文档构建器的建造者模式

```rust
/// 文档结构
#[derive(Debug, Clone)]
pub struct Document {
    title: String,
    author: String,
    content: Vec<String>,
    metadata: HashMap<String, String>,
}

impl Document {
    pub fn new() -> Self {
        Self {
            title: String::new(),
            author: String::new(),
            content: Vec::new(),
            metadata: HashMap::new(),
        }
    }
    
    pub fn display(&self) -> String {
        let mut result = format!("Title: {}\n", self.title);
        result.push_str(&format!("Author: {}\n", self.author));
        result.push_str("Content:\n");
        for (i, line) in self.content.iter().enumerate() {
            result.push_str(&format!("{}. {}\n", i + 1, line));
        }
        result
    }
}

/// 文档建造者
pub trait DocumentBuilder {
    fn set_title(&mut self, title: String) -> &mut Self;
    fn set_author(&mut self, author: String) -> &mut Self;
    fn add_content(&mut self, content: String) -> &mut Self;
    fn add_metadata(&mut self, key: String, value: String) -> &mut Self;
    fn build(&self) -> Document;
}

/// 具体文档建造者
pub struct ConcreteDocumentBuilder {
    document: Document,
}

impl ConcreteDocumentBuilder {
    pub fn new() -> Self {
        Self {
            document: Document::new(),
        }
    }
}

impl DocumentBuilder for ConcreteDocumentBuilder {
    fn set_title(&mut self, title: String) -> &mut Self {
        self.document.title = title;
        self
    }
    
    fn set_author(&mut self, author: String) -> &mut Self {
        self.document.author = author;
        self
    }
    
    fn add_content(&mut self, content: String) -> &mut Self {
        self.document.content.push(content);
        self
    }
    
    fn add_metadata(&mut self, key: String, value: String) -> &mut Self {
        self.document.metadata.insert(key, value);
        self
    }
    
    fn build(&self) -> Document {
        self.document.clone()
    }
}
```

## 6. 相关理论

### 6.1 与设计模式理论的关系

创建型模式是设计模式理论的重要组成部分，与其他模式类型（结构型模式、行为型模式）形成完整的模式体系。

**定理 6.1** (模式分类的完备性)
创建型、结构型、行为型模式构成了设计模式的完备分类。

**证明**：
根据设计模式的定义，任何设计模式都可以归类为这三种类型之一：

- 创建型：关注对象创建
- 结构型：关注对象组合
- 行为型：关注对象交互
$\square$

### 6.2 与面向对象理论的关系

创建型模式体现了面向对象理论中的封装、继承、多态等核心概念。

**定理 6.2** (面向对象原则的体现)
创建型模式满足面向对象的基本原则。

**证明**：

1. **封装**：工厂方法封装了对象创建逻辑
2. **继承**：抽象工厂通过继承实现多态
3. **多态**：不同工厂可以创建不同类型的对象
$\square$

### 6.3 与软件工程理论的关系

创建型模式是软件工程中重要的设计原则，体现了SOLID原则中的依赖倒置原则。

**定理 6.3** (依赖倒置原则的体现)
创建型模式实现了依赖倒置原则。

**证明**：
高层模块（客户端）不依赖于低层模块（具体类），而是依赖于抽象（工厂接口），具体类依赖于抽象。$\square$

## 7. 参考文献

1. Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.
2. Freeman, E., Robson, E., Sierra, K., & Bates, B. (2004). Head First Design Patterns. O'Reilly Media.
3. Martin, R. C. (2000). Design Principles and Design Patterns. Object Mentor.
4. Liskov, B. (1987). Data Abstraction and Hierarchy. SIGPLAN Notices, 23(5), 17-34.
5. Meyer, B. (1988). Object-Oriented Software Construction. Prentice Hall.

---

**相关链接**：

- [07.3.2 结构型模式](../07.3.2_结构型模式.md)
- [07.3.3 行为型模式](../07.3.3_行为型模式.md)
- [07.3.4 架构模式](../07.3.4_架构模式.md)
- [07.2.1 架构设计原则](../07.2.1_架构设计原则.md)
- [07.2.2 架构模式理论](../07.2.2_架构模式理论.md)
