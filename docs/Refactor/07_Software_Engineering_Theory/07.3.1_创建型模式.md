# 07.3.1 åˆ›å»ºå‹æ¨¡å¼ç†è®º

## ğŸ“‹ æ¦‚è¿°

åˆ›å»ºå‹æ¨¡å¼æ˜¯è½¯ä»¶è®¾è®¡æ¨¡å¼çš„ä¸€ä¸ªé‡è¦åˆ†ç±»ï¼Œä¸“æ³¨äºå¯¹è±¡çš„åˆ›å»ºæœºåˆ¶ï¼Œé€šè¿‡å°†å¯¹è±¡çš„åˆ›å»ºä¸ä½¿ç”¨åˆ†ç¦»ï¼Œæé«˜ç³»ç»Ÿçš„çµæ´»æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚æœ¬ç†è®ºä»å½¢å¼åŒ–è§’åº¦æ·±å…¥åˆ†æåˆ›å»ºå‹æ¨¡å¼çš„æ ¸å¿ƒæ¦‚å¿µã€æ•°å­¦åŸºç¡€å’Œå®ç°åŸç†ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å½¢å¼åŒ–å»ºæ¨¡**ï¼šå»ºç«‹åˆ›å»ºå‹æ¨¡å¼çš„æ•°å­¦å½¢å¼åŒ–æ¨¡å‹
2. **æ¨¡å¼åˆ†ç±»**ï¼šç³»ç»ŸåŒ–åˆ†ç±»å„ç§åˆ›å»ºå‹æ¨¡å¼
3. **å®ç°åŸç†**ï¼šæ·±å…¥åˆ†ææ¨¡å¼å®ç°çš„åº•å±‚æœºåˆ¶
4. **åº”ç”¨æŒ‡å¯¼**ï¼šæä¾›æ¨¡å¼é€‰æ‹©å’Œåº”ç”¨çš„å†³ç­–æ¡†æ¶

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [æ¨¡å¼åˆ†ç±»ç†è®º](#3-æ¨¡å¼åˆ†ç±»ç†è®º)
4. [æ ¸å¿ƒæ¨¡å¼åˆ†æ](#4-æ ¸å¿ƒæ¨¡å¼åˆ†æ)
5. [å®ç°åŸç†](#5-å®ç°åŸç†)
6. [ä»£ç å®ç°](#6-ä»£ç å®ç°)
7. [åº”ç”¨ç¤ºä¾‹](#7-åº”ç”¨ç¤ºä¾‹)
8. [ç›¸å…³ç†è®º](#8-ç›¸å…³ç†è®º)
9. [å‚è€ƒæ–‡çŒ®](#9-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 åˆ›å»ºå‹æ¨¡å¼å®šä¹‰

**å®šä¹‰ 1.1** (åˆ›å»ºå‹æ¨¡å¼)
åˆ›å»ºå‹æ¨¡å¼æ˜¯ä¸€ç±»è®¾è®¡æ¨¡å¼ï¼Œå…¶æ ¸å¿ƒç›®æ ‡æ˜¯ï¼š
- å°è£…å¯¹è±¡çš„åˆ›å»ºè¿‡ç¨‹
- æ§åˆ¶å¯¹è±¡çš„å®ä¾‹åŒ–æ–¹å¼
- æä¾›çµæ´»çš„å¯¹è±¡åˆ›å»ºæ¥å£
- é™ä½ç³»ç»Ÿå¯¹å…·ä½“ç±»çš„ä¾èµ–

### 1.2 æ ¸å¿ƒé—®é¢˜

åˆ›å»ºå‹æ¨¡å¼è§£å†³çš„æ ¸å¿ƒé—®é¢˜åŒ…æ‹¬ï¼š

1. **å¯¹è±¡åˆ›å»ºå¤æ‚æ€§**ï¼šå¤æ‚å¯¹è±¡çš„åˆ›å»ºè¿‡ç¨‹éœ€è¦å¤šæ­¥éª¤
2. **ç±»å‹ä¾èµ–è€¦åˆ**ï¼šå®¢æˆ·ç«¯ç›´æ¥ä¾èµ–å…·ä½“ç±»å‹
3. **èµ„æºç®¡ç†**ï¼šå¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸå’Œèµ„æºåˆ†é…
4. **é…ç½®çµæ´»æ€§**ï¼šä¸åŒé…ç½®ä¸‹çš„å¯¹è±¡åˆ›å»ºéœ€æ±‚

### 1.3 è®¾è®¡åŸåˆ™

åˆ›å»ºå‹æ¨¡å¼éµå¾ªä»¥ä¸‹è®¾è®¡åŸåˆ™ï¼š

- **å•ä¸€èŒè´£åŸåˆ™**ï¼šåˆ›å»ºé€»è¾‘ä¸ä¸šåŠ¡é€»è¾‘åˆ†ç¦»
- **å¼€é—­åŸåˆ™**ï¼šå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­
- **ä¾èµ–å€’ç½®åŸåˆ™**ï¼šä¾èµ–æŠ½è±¡è€Œéå…·ä½“å®ç°
- **æ¥å£éš”ç¦»åŸåˆ™**ï¼šå®¢æˆ·ç«¯ä¸åº”ä¾èµ–ä¸éœ€è¦çš„æ¥å£

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ¨¡å¼ç»“æ„å½¢å¼åŒ–

**å®šä¹‰ 2.1** (åˆ›å»ºå‹æ¨¡å¼ç»“æ„)
åˆ›å»ºå‹æ¨¡å¼å¯ä»¥å½¢å¼åŒ–ä¸ºäº”å…ƒç»„ï¼š

$$\text{Pattern} = (C, P, I, R, \mathcal{F})$$

å…¶ä¸­ï¼š
- $C$ æ˜¯åˆ›å»ºè€…é›†åˆ (Creator Set)
- $P$ æ˜¯äº§å“é›†åˆ (Product Set)  
- $I$ æ˜¯æ¥å£é›†åˆ (Interface Set)
- $R$ æ˜¯å…³ç³»é›†åˆ (Relation Set)
- $\mathcal{F}$ æ˜¯å·¥å‚å‡½æ•°é›†åˆ (Factory Function Set)

### 2.2 å·¥å‚å‡½æ•°å½¢å¼åŒ–

**å®šä¹‰ 2.2** (å·¥å‚å‡½æ•°)
å·¥å‚å‡½æ•°æ˜¯ä¸€ä¸ªæ˜ å°„ï¼š

$$f: \text{Config} \times \text{Params} \rightarrow \text{Product}$$

å…¶ä¸­ï¼š
- $\text{Config}$ æ˜¯é…ç½®ç©ºé—´
- $\text{Params}$ æ˜¯å‚æ•°ç©ºé—´
- $\text{Product}$ æ˜¯äº§å“ç©ºé—´

### 2.3 æ¨¡å¼å…³ç³»å½¢å¼åŒ–

**å®šä¹‰ 2.3** (æ¨¡å¼å…³ç³»)
æ¨¡å¼å…³ç³» $R$ åŒ…å«ä»¥ä¸‹å…³ç³»ï¼š

1. **åˆ›å»ºå…³ç³»**ï¼š$R_c \subseteq C \times P$
2. **ä¾èµ–å…³ç³»**ï¼š$R_d \subseteq I \times C$
3. **ç»„åˆå…³ç³»**ï¼š$R_o \subseteq P \times P$
4. **ç»§æ‰¿å…³ç³»**ï¼š$R_i \subseteq P \times P$

## 3. æ¨¡å¼åˆ†ç±»ç†è®º

### 3.1 åˆ†ç±»ç»´åº¦

åˆ›å»ºå‹æ¨¡å¼å¯ä»¥æŒ‰ä»¥ä¸‹ç»´åº¦åˆ†ç±»ï¼š

1. **åˆ›å»ºæ–¹å¼ç»´åº¦**
   - ç›´æ¥åˆ›å»ºï¼šSimple Factory
   - å»¶è¿Ÿåˆ›å»ºï¼šLazy Initialization
   - ç¼“å­˜åˆ›å»ºï¼šObject Pool

2. **å¤æ‚åº¦ç»´åº¦**
   - ç®€å•æ¨¡å¼ï¼šFactory Method
   - å¤æ‚æ¨¡å¼ï¼šAbstract Factory
   - æ„å»ºæ¨¡å¼ï¼šBuilder

3. **å®ä¾‹åŒ–ç»´åº¦**
   - å•ä¾‹æ¨¡å¼ï¼šSingleton
   - åŸå‹æ¨¡å¼ï¼šPrototype
   - å¤šä¾‹æ¨¡å¼ï¼šMultiton

### 3.2 åˆ†ç±»æ ‘ç»“æ„

```
åˆ›å»ºå‹æ¨¡å¼
â”œâ”€â”€ ç®€å•åˆ›å»º
â”‚   â”œâ”€â”€ Simple Factory
â”‚   â”œâ”€â”€ Factory Method
â”‚   â””â”€â”€ Lazy Initialization
â”œâ”€â”€ å¤æ‚åˆ›å»º
â”‚   â”œâ”€â”€ Abstract Factory
â”‚   â”œâ”€â”€ Builder
â”‚   â””â”€â”€ Object Pool
â””â”€â”€ ç‰¹æ®Šåˆ›å»º
    â”œâ”€â”€ Singleton
    â”œâ”€â”€ Prototype
    â””â”€â”€ Multiton
```

## 4. æ ¸å¿ƒæ¨¡å¼åˆ†æ

### 4.1 ç®€å•å·¥å‚æ¨¡å¼

**å®šä¹‰ 4.1** (ç®€å•å·¥å‚)
ç®€å•å·¥å‚æ¨¡å¼å®šä¹‰äº†ä¸€ä¸ªåˆ›å»ºå¯¹è±¡çš„æ¥å£ï¼Œä½†ç”±å­ç±»å†³å®šè¦å®ä¾‹åŒ–çš„ç±»æ˜¯å“ªä¸€ä¸ªã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{SimpleFactory} = (C, P, f)$$

å…¶ä¸­ $f: \text{Type} \rightarrow P$ æ˜¯ç±»å‹åˆ°äº§å“çš„æ˜ å°„å‡½æ•°ã€‚

**å®šç† 4.1** (ç®€å•å·¥å‚çš„å°è£…æ€§)
ç®€å•å·¥å‚æ¨¡å¼å®ç°äº†å¯¹è±¡åˆ›å»ºçš„å°è£…ï¼Œæ»¡è¶³ï¼š
$$\forall t \in \text{Type}, \exists p \in P: f(t) = p$$

### 4.2 å·¥å‚æ–¹æ³•æ¨¡å¼

**å®šä¹‰ 4.2** (å·¥å‚æ–¹æ³•)
å·¥å‚æ–¹æ³•æ¨¡å¼å®šä¹‰äº†ä¸€ä¸ªåˆ›å»ºå¯¹è±¡çš„æ¥å£ï¼Œä½†ç”±å­ç±»å†³å®šè¦å®ä¾‹åŒ–çš„ç±»æ˜¯å“ªä¸€ä¸ªã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{FactoryMethod} = (C, P, \mathcal{F}, R)$$

å…¶ä¸­ $\mathcal{F}$ æ˜¯å·¥å‚æ–¹æ³•é›†åˆï¼Œ$R$ æ˜¯åˆ›å»ºè€…ä¸äº§å“çš„å¯¹åº”å…³ç³»ã€‚

**å®šç† 4.2** (å·¥å‚æ–¹æ³•çš„æ‰©å±•æ€§)
å·¥å‚æ–¹æ³•æ¨¡å¼æ”¯æŒå¼€é—­åŸåˆ™ï¼š
$$\forall c \in C, \exists f \in \mathcal{F}: f \text{ creates } p \in P$$

### 4.3 æŠ½è±¡å·¥å‚æ¨¡å¼

**å®šä¹‰ 4.3** (æŠ½è±¡å·¥å‚)
æŠ½è±¡å·¥å‚æ¨¡å¼æä¾›äº†ä¸€ä¸ªåˆ›å»ºä¸€ç³»åˆ—ç›¸å…³æˆ–ç›¸äº’ä¾èµ–å¯¹è±¡çš„æ¥å£ï¼Œè€Œæ— éœ€æŒ‡å®šå®ƒä»¬çš„å…·ä½“ç±»ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{AbstractFactory} = (C, P_1, P_2, \ldots, P_n, \mathcal{F})$$

å…¶ä¸­ $P_i$ æ˜¯ç¬¬ $i$ ä¸ªäº§å“æ—ï¼Œ$\mathcal{F}$ æ˜¯å·¥å‚æ–¹æ³•é›†åˆã€‚

**å®šç† 4.3** (æŠ½è±¡å·¥å‚çš„ä¸€è‡´æ€§)
æŠ½è±¡å·¥å‚ç¡®ä¿äº§å“æ—çš„ä¸€è‡´æ€§ï¼š
$$\forall f \in \mathcal{F}, \forall i: f \text{ creates consistent } P_i$$

### 4.4 å»ºé€ è€…æ¨¡å¼

**å®šä¹‰ 4.4** (å»ºé€ è€…)
å»ºé€ è€…æ¨¡å¼å°†ä¸€ä¸ªå¤æ‚å¯¹è±¡çš„æ„å»ºä¸å®ƒçš„è¡¨ç¤ºåˆ†ç¦»ï¼Œä½¿å¾—åŒæ ·çš„æ„å»ºè¿‡ç¨‹å¯ä»¥åˆ›å»ºä¸åŒçš„è¡¨ç¤ºã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{Builder} = (B, P, \text{Steps}, \text{Build})$$

å…¶ä¸­ï¼š
- $B$ æ˜¯å»ºé€ è€…é›†åˆ
- $P$ æ˜¯äº§å“é›†åˆ
- $\text{Steps}$ æ˜¯æ„å»ºæ­¥éª¤é›†åˆ
- $\text{Build}$ æ˜¯æ„å»ºå‡½æ•°

**å®šç† 4.4** (å»ºé€ è€…çš„åˆ†æ­¥æ€§)
å»ºé€ è€…æ¨¡å¼æ”¯æŒåˆ†æ­¥æ„å»ºï¼š
$$\text{Build}: \text{Steps}^* \rightarrow P$$

### 4.5 å•ä¾‹æ¨¡å¼

**å®šä¹‰ 4.5** (å•ä¾‹)
å•ä¾‹æ¨¡å¼ç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›ä¸€ä¸ªå…¨å±€è®¿é—®ç‚¹ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{Singleton} = (C, \text{instance}, \text{getInstance})$$

å…¶ä¸­ï¼š
- $C$ æ˜¯å•ä¾‹ç±»
- $\text{instance}$ æ˜¯å”¯ä¸€å®ä¾‹
- $\text{getInstance}$ æ˜¯è·å–å®ä¾‹çš„æ–¹æ³•

**å®šç† 4.5** (å•ä¾‹çš„å”¯ä¸€æ€§)
å•ä¾‹æ¨¡å¼ä¿è¯å®ä¾‹çš„å”¯ä¸€æ€§ï¼š
$$\forall c_1, c_2 \in C: \text{getInstance}() = \text{getInstance}()$$

## 5. å®ç°åŸç†

### 5.1 å¤šæ€æœºåˆ¶

åˆ›å»ºå‹æ¨¡å¼çš„æ ¸å¿ƒå®ç°åŸç†æ˜¯å¤šæ€æœºåˆ¶ï¼š

**å®šä¹‰ 5.1** (å¤šæ€)
å¤šæ€æ˜¯æŒ‡åŒä¸€ä¸ªæ¥å£å¯ä»¥æœ‰ä¸åŒçš„å®ç°ï¼š

$$\text{Polymorphism} = (I, \text{Impl}_1, \text{Impl}_2, \ldots, \text{Impl}_n)$$

å…¶ä¸­ $I$ æ˜¯æ¥å£ï¼Œ$\text{Impl}_i$ æ˜¯ç¬¬ $i$ ä¸ªå®ç°ã€‚

### 5.2 å»¶è¿Ÿç»‘å®š

**å®šä¹‰ 5.2** (å»¶è¿Ÿç»‘å®š)
å»¶è¿Ÿç»‘å®šåœ¨è¿è¡Œæ—¶ç¡®å®šå…·ä½“ç±»å‹ï¼š

$$\text{LateBinding}: \text{Type} \times \text{Runtime} \rightarrow \text{Implementation}$$

### 5.3 åå°„æœºåˆ¶

**å®šä¹‰ 5.3** (åå°„)
åå°„å…è®¸ç¨‹åºåœ¨è¿è¡Œæ—¶æ£€æŸ¥å’Œæ“ä½œç±»å‹ä¿¡æ¯ï¼š

$$\text{Reflection}: \text{Type} \rightarrow \text{Metadata}$$

## 6. ä»£ç å®ç°

### 6.1 Rust å®ç°

```rust
// ç®€å•å·¥å‚æ¨¡å¼å®ç°
pub trait Product {
    fn operation(&self) -> String;
}

pub struct ConcreteProductA;
pub struct ConcreteProductB;

impl Product for ConcreteProductA {
    fn operation(&self) -> String {
        "ConcreteProductA operation".to_string()
    }
}

impl Product for ConcreteProductB {
    fn operation(&self) -> String {
        "ConcreteProductB operation".to_string()
    }
}

pub enum ProductType {
    A,
    B,
}

pub struct SimpleFactory;

impl SimpleFactory {
    pub fn create_product(product_type: ProductType) -> Box<dyn Product> {
        match product_type {
            ProductType::A => Box::new(ConcreteProductA),
            ProductType::B => Box::new(ConcreteProductB),
        }
    }
}

// å·¥å‚æ–¹æ³•æ¨¡å¼å®ç°
pub trait Creator {
    fn factory_method(&self) -> Box<dyn Product>;
    fn some_operation(&self) -> String {
        let product = self.factory_method();
        format!("Creator: {}", product.operation())
    }
}

pub struct ConcreteCreatorA;
pub struct ConcreteCreatorB;

impl Creator for ConcreteCreatorA {
    fn factory_method(&self) -> Box<dyn Product> {
        Box::new(ConcreteProductA)
    }
}

impl Creator for ConcreteCreatorB {
    fn factory_method(&self) -> Box<dyn Product> {
        Box::new(ConcreteProductB)
    }
}

// æŠ½è±¡å·¥å‚æ¨¡å¼å®ç°
pub trait AbstractProductA {
    fn operation_a(&self) -> String;
}

pub trait AbstractProductB {
    fn operation_b(&self) -> String;
}

pub trait AbstractFactory {
    fn create_product_a(&self) -> Box<dyn AbstractProductA>;
    fn create_product_b(&self) -> Box<dyn AbstractProductB>;
}

pub struct ConcreteProductA1;
pub struct ConcreteProductA2;
pub struct ConcreteProductB1;
pub struct ConcreteProductB2;

impl AbstractProductA for ConcreteProductA1 {
    fn operation_a(&self) -> String {
        "ConcreteProductA1 operation".to_string()
    }
}

impl AbstractProductA for ConcreteProductA2 {
    fn operation_a(&self) -> String {
        "ConcreteProductA2 operation".to_string()
    }
}

impl AbstractProductB for ConcreteProductB1 {
    fn operation_b(&self) -> String {
        "ConcreteProductB1 operation".to_string()
    }
}

impl AbstractProductB for ConcreteProductB2 {
    fn operation_b(&self) -> String {
        "ConcreteProductB2 operation".to_string()
    }
}

pub struct ConcreteFactory1;
pub struct ConcreteFactory2;

impl AbstractFactory for ConcreteFactory1 {
    fn create_product_a(&self) -> Box<dyn AbstractProductA> {
        Box::new(ConcreteProductA1)
    }
    
    fn create_product_b(&self) -> Box<dyn AbstractProductB> {
        Box::new(ConcreteProductB1)
    }
}

impl AbstractFactory for ConcreteFactory2 {
    fn create_product_a(&self) -> Box<dyn AbstractProductA> {
        Box::new(ConcreteProductA2)
    }
    
    fn create_product_b(&self) -> Box<dyn AbstractProductB> {
        Box::new(ConcreteProductB2)
    }
}

// å»ºé€ è€…æ¨¡å¼å®ç°
#[derive(Debug, Clone)]
pub struct ComplexObject {
    pub part_a: String,
    pub part_b: String,
    pub part_c: String,
}

pub trait Builder {
    fn build_part_a(&mut self, part: String);
    fn build_part_b(&mut self, part: String);
    fn build_part_c(&mut self, part: String);
    fn get_result(&self) -> ComplexObject;
}

pub struct ConcreteBuilder {
    object: ComplexObject,
}

impl ConcreteBuilder {
    pub fn new() -> Self {
        Self {
            object: ComplexObject {
                part_a: String::new(),
                part_b: String::new(),
                part_c: String::new(),
            }
        }
    }
}

impl Builder for ConcreteBuilder {
    fn build_part_a(&mut self, part: String) {
        self.object.part_a = part;
    }
    
    fn build_part_b(&mut self, part: String) {
        self.object.part_b = part;
    }
    
    fn build_part_c(&mut self, part: String) {
        self.object.part_c = part;
    }
    
    fn get_result(&self) -> ComplexObject {
        self.object.clone()
    }
}

pub struct Director;

impl Director {
    pub fn construct(builder: &mut dyn Builder) -> ComplexObject {
        builder.build_part_a("Part A".to_string());
        builder.build_part_b("Part B".to_string());
        builder.build_part_c("Part C".to_string());
        builder.get_result()
    }
}

// å•ä¾‹æ¨¡å¼å®ç°
use std::sync::{Arc, Mutex};
use std::sync::Once;

pub struct Singleton {
    data: String,
}

impl Singleton {
    fn new() -> Self {
        Self {
            data: "Singleton instance".to_string(),
        }
    }
    
    pub fn get_instance() -> Arc<Mutex<Singleton>> {
        static mut INSTANCE: Option<Arc<Mutex<Singleton>>> = None;
        static ONCE: Once = Once::new();
        
        unsafe {
            ONCE.call_once(|| {
                INSTANCE = Some(Arc::new(Mutex::new(Singleton::new())));
            });
            INSTANCE.as_ref().unwrap().clone()
        }
    }
    
    pub fn get_data(&self) -> &str {
        &self.data
    }
}
```

### 6.2 Haskell å®ç°

```haskell
-- ç®€å•å·¥å‚æ¨¡å¼
class Product a where
    operation :: a -> String

data ConcreteProductA = ConcreteProductA
data ConcreteProductB = ConcreteProductB

instance Product ConcreteProductA where
    operation _ = "ConcreteProductA operation"

instance Product ConcreteProductB where
    operation _ = "ConcreteProductB operation"

data ProductType = A | B

createProduct :: ProductType -> String
createProduct A = operation ConcreteProductA
createProduct B = operation ConcreteProductB

-- å·¥å‚æ–¹æ³•æ¨¡å¼
class Creator c where
    factoryMethod :: c -> String
    someOperation :: c -> String
    someOperation c = "Creator: " ++ factoryMethod c

data ConcreteCreatorA = ConcreteCreatorA
data ConcreteCreatorB = ConcreteCreatorB

instance Creator ConcreteCreatorA where
    factoryMethod _ = operation ConcreteProductA

instance Creator ConcreteCreatorB where
    factoryMethod _ = operation ConcreteProductB

-- æŠ½è±¡å·¥å‚æ¨¡å¼
class AbstractProductA a where
    operationA :: a -> String

class AbstractProductB b where
    operationB :: b -> String

class AbstractFactory f where
    createProductA :: f -> String
    createProductB :: f -> String

data ConcreteProductA1 = ConcreteProductA1
data ConcreteProductA2 = ConcreteProductA2
data ConcreteProductB1 = ConcreteProductB1
data ConcreteProductB2 = ConcreteProductB2

instance AbstractProductA ConcreteProductA1 where
    operationA _ = "ConcreteProductA1 operation"

instance AbstractProductA ConcreteProductA2 where
    operationA _ = "ConcreteProductA2 operation"

instance AbstractProductB ConcreteProductB1 where
    operationB _ = "ConcreteProductB1 operation"

instance AbstractProductB ConcreteProductB2 where
    operationB _ = "ConcreteProductB2 operation"

data ConcreteFactory1 = ConcreteFactory1
data ConcreteFactory2 = ConcreteFactory2

instance AbstractFactory ConcreteFactory1 where
    createProductA _ = operationA ConcreteProductA1
    createProductB _ = operationB ConcreteProductB1

instance AbstractFactory ConcreteFactory2 where
    createProductA _ = operationA ConcreteProductA2
    createProductB _ = operationB ConcreteProductB2

-- å»ºé€ è€…æ¨¡å¼
data ComplexObject = ComplexObject
    { partA :: String
    , partB :: String
    , partC :: String
    } deriving (Show, Eq)

class Builder b where
    buildPartA :: String -> b -> b
    buildPartB :: String -> b -> b
    buildPartC :: String -> b -> b
    getResult :: b -> ComplexObject

data ConcreteBuilder = ConcreteBuilder
    { object :: ComplexObject
    } deriving (Show)

instance Builder ConcreteBuilder where
    buildPartA part builder = builder { object = (object builder) { partA = part } }
    buildPartB part builder = builder { object = (object builder) { partB = part } }
    buildPartC part builder = builder { object = (object builder) { partC = part } }
    getResult = object

newBuilder :: ConcreteBuilder
newBuilder = ConcreteBuilder (ComplexObject "" "" "")

construct :: ConcreteBuilder -> ComplexObject
construct builder = getResult $ buildPartC "Part C" $ buildPartB "Part B" $ buildPartA "Part A" builder

-- å•ä¾‹æ¨¡å¼ (ä½¿ç”¨ IORef)
import Data.IORef
import System.IO.Unsafe

{-# NOINLINE singletonInstance #-}
singletonInstance :: IORef String
singletonInstance = unsafePerformIO $ newIORef "Singleton instance"

getInstance :: IO String
getInstance = readIORef singletonInstance
```

## 7. åº”ç”¨ç¤ºä¾‹

### 7.1 æ•°æ®åº“è¿æ¥å·¥å‚

```rust
// æ•°æ®åº“è¿æ¥å·¥å‚ç¤ºä¾‹
pub trait DatabaseConnection {
    fn connect(&self) -> Result<(), String>;
    fn disconnect(&self) -> Result<(), String>;
    fn execute_query(&self, query: &str) -> Result<String, String>;
}

pub struct MySQLConnection;
pub struct PostgreSQLConnection;
pub struct SQLiteConnection;

impl DatabaseConnection for MySQLConnection {
    fn connect(&self) -> Result<(), String> {
        println!("Connecting to MySQL database...");
        Ok(())
    }
    
    fn disconnect(&self) -> Result<(), String> {
        println!("Disconnecting from MySQL database...");
        Ok(())
    }
    
    fn execute_query(&self, query: &str) -> Result<String, String> {
        println!("Executing MySQL query: {}", query);
        Ok("MySQL result".to_string())
    }
}

impl DatabaseConnection for PostgreSQLConnection {
    fn connect(&self) -> Result<(), String> {
        println!("Connecting to PostgreSQL database...");
        Ok(())
    }
    
    fn disconnect(&self) -> Result<(), String> {
        println!("Disconnecting from PostgreSQL database...");
        Ok(())
    }
    
    fn execute_query(&self, query: &str) -> Result<String, String> {
        println!("Executing PostgreSQL query: {}", query);
        Ok("PostgreSQL result".to_string())
    }
}

impl DatabaseConnection for SQLiteConnection {
    fn connect(&self) -> Result<(), String> {
        println!("Connecting to SQLite database...");
        Ok(())
    }
    
    fn disconnect(&self) -> Result<(), String> {
        println!("Disconnecting from SQLite database...");
        Ok(())
    }
    
    fn execute_query(&self, query: &str) -> Result<String, String> {
        println!("Executing SQLite query: {}", query);
        Ok("SQLite result".to_string())
    }
}

pub enum DatabaseType {
    MySQL,
    PostgreSQL,
    SQLite,
}

pub struct DatabaseFactory;

impl DatabaseFactory {
    pub fn create_connection(db_type: DatabaseType) -> Box<dyn DatabaseConnection> {
        match db_type {
            DatabaseType::MySQL => Box::new(MySQLConnection),
            DatabaseType::PostgreSQL => Box::new(PostgreSQLConnection),
            DatabaseType::SQLite => Box::new(SQLiteConnection),
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
pub fn database_example() {
    let mysql_conn = DatabaseFactory::create_connection(DatabaseType::MySQL);
    let postgres_conn = DatabaseFactory::create_connection(DatabaseType::PostgreSQL);
    
    mysql_conn.connect().unwrap();
    let result = mysql_conn.execute_query("SELECT * FROM users").unwrap();
    println!("Result: {}", result);
    mysql_conn.disconnect().unwrap();
    
    postgres_conn.connect().unwrap();
    let result = postgres_conn.execute_query("SELECT * FROM products").unwrap();
    println!("Result: {}", result);
    postgres_conn.disconnect().unwrap();
}
```

### 7.2 é…ç½®ç®¡ç†å™¨å•ä¾‹

```rust
// é…ç½®ç®¡ç†å™¨å•ä¾‹ç¤ºä¾‹
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::sync::Once;

pub struct ConfigManager {
    config: HashMap<String, String>,
}

impl ConfigManager {
    fn new() -> Self {
        let mut config = HashMap::new();
        config.insert("database_url".to_string(), "localhost:5432".to_string());
        config.insert("api_key".to_string(), "secret_key".to_string());
        config.insert("max_connections".to_string(), "100".to_string());
        
        Self { config }
    }
    
    pub fn get_instance() -> Arc<Mutex<ConfigManager>> {
        static mut INSTANCE: Option<Arc<Mutex<ConfigManager>>> = None;
        static ONCE: Once = Once::new();
        
        unsafe {
            ONCE.call_once(|| {
                INSTANCE = Some(Arc::new(Mutex::new(ConfigManager::new())));
            });
            INSTANCE.as_ref().unwrap().clone()
        }
    }
    
    pub fn get_config(&self, key: &str) -> Option<&String> {
        self.config.get(key)
    }
    
    pub fn set_config(&mut self, key: String, value: String) {
        self.config.insert(key, value);
    }
    
    pub fn get_all_config(&self) -> &HashMap<String, String> {
        &self.config
    }
}

// ä½¿ç”¨ç¤ºä¾‹
pub fn config_manager_example() {
    let config_manager = ConfigManager::get_instance();
    
    {
        let config = config_manager.lock().unwrap();
        println!("Database URL: {}", config.get_config("database_url").unwrap());
        println!("API Key: {}", config.get_config("api_key").unwrap());
        println!("Max Connections: {}", config.get_config("max_connections").unwrap());
    }
    
    {
        let mut config = config_manager.lock().unwrap();
        config.set_config("new_setting".to_string(), "new_value".to_string());
        println!("New setting: {}", config.get_config("new_setting").unwrap());
    }
}
```

## 8. ç›¸å…³ç†è®º

### 8.1 è®¾è®¡æ¨¡å¼ç†è®º

åˆ›å»ºå‹æ¨¡å¼æ˜¯è®¾è®¡æ¨¡å¼ç†è®ºçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œä¸å…¶ä»–æ¨¡å¼ç±»å‹å¯†åˆ‡ç›¸å…³ï¼š

- **ç»“æ„å‹æ¨¡å¼**ï¼šå…³æ³¨å¯¹è±¡ç»„åˆå’Œç±»ç»“æ„
- **è¡Œä¸ºå‹æ¨¡å¼**ï¼šå…³æ³¨å¯¹è±¡é—´é€šä¿¡å’ŒèŒè´£åˆ†é…
- **æ¶æ„æ¨¡å¼**ï¼šå…³æ³¨ç³»ç»Ÿçº§çš„è®¾è®¡å†³ç­–

### 8.2 é¢å‘å¯¹è±¡ç†è®º

åˆ›å»ºå‹æ¨¡å¼åŸºäºé¢å‘å¯¹è±¡çš„æ ¸å¿ƒæ¦‚å¿µï¼š

- **å°è£…**ï¼šéšè—å¯¹è±¡åˆ›å»ºç»†èŠ‚
- **ç»§æ‰¿**ï¼šé€šè¿‡ç»§æ‰¿å®ç°å¤šæ€
- **å¤šæ€**ï¼šæ”¯æŒè¿è¡Œæ—¶ç±»å‹ç»‘å®š
- **æŠ½è±¡**ï¼šæä¾›ç»Ÿä¸€çš„åˆ›å»ºæ¥å£

### 8.3 è½¯ä»¶å·¥ç¨‹ç†è®º

åˆ›å»ºå‹æ¨¡å¼ä½“ç°äº†è½¯ä»¶å·¥ç¨‹çš„é‡è¦åŸåˆ™ï¼š

- **æ¨¡å—åŒ–**ï¼šå°†åˆ›å»ºé€»è¾‘æ¨¡å—åŒ–
- **å¯ç»´æŠ¤æ€§**ï¼šé™ä½ç³»ç»Ÿè€¦åˆåº¦
- **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒæ–°ç±»å‹çš„æ·»åŠ 
- **å¯æµ‹è¯•æ€§**ï¼šä¾¿äºå•å…ƒæµ‹è¯•

## 9. å‚è€ƒæ–‡çŒ®

1. Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.

2. Freeman, E., Robson, E., Sierra, K., & Bates, B. (2004). Head First Design Patterns. O'Reilly Media.

3. Martin, R. C. (2000). Design Principles and Design Patterns. Object Mentor.

4. Liskov, B. (1987). Data Abstraction and Hierarchy. SIGPLAN Notices, 23(5), 17-34.

5. Meyer, B. (1988). Object-Oriented Software Construction. Prentice Hall.

---

**ç›¸å…³é“¾æ¥**ï¼š
- [07.3.2 ç»“æ„å‹æ¨¡å¼](../07.3.2_ç»“æ„å‹æ¨¡å¼.md)
- [07.3.3 è¡Œä¸ºå‹æ¨¡å¼](../07.3.3_è¡Œä¸ºå‹æ¨¡å¼.md)
- [07.3.4 æ¶æ„æ¨¡å¼](../07.3.4_æ¶æ„æ¨¡å¼.md)
- [08.1.1 è¯­è¨€è®¾è®¡åŸåˆ™](../../08_Programming_Language_Theory/08.1.1_è¯­è¨€è®¾è®¡åŸåˆ™.md)

- [07.2.2 æ¶æ„æ¨¡å¼ç†è®º](../07.2.2_æ¶æ„æ¨¡å¼ç†è®º.md)

