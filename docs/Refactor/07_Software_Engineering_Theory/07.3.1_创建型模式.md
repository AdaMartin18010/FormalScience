# 07.3.1 åˆ›å»ºå‹æ¨¡å¼

## ğŸ“‹ æ¦‚è¿°

åˆ›å»ºå‹æ¨¡å¼æ˜¯è½¯ä»¶å·¥ç¨‹ä¸­ç”¨äºå¯¹è±¡åˆ›å»ºçš„è®¾è®¡æ¨¡å¼ï¼Œå®ƒä»¬æä¾›äº†ä¸€ç§åœ¨åˆ›å»ºå¯¹è±¡æ—¶è·å¾—æ›´å¤§çµæ´»æ€§å’Œå¯é‡ç”¨æ€§çš„æ–¹æ³•ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦åˆ†æåˆ›å»ºå‹æ¨¡å¼çš„ç†è®ºåŸºç¡€ã€æ•°å­¦å®šä¹‰ã€å®ç°åŸç†å’Œåº”ç”¨åœºæ™¯ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹åˆ›å»ºå‹æ¨¡å¼çš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°å®Œæ•´çš„Rustä»£ç ç¤ºä¾‹
4. åˆ†ææ¨¡å¼é—´çš„å…³è”æ€§å’Œåº”ç”¨åœºæ™¯

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 åˆ›å»ºå‹æ¨¡å¼çš„å®šä¹‰

**å®šä¹‰ 1.1** (åˆ›å»ºå‹æ¨¡å¼)
åˆ›å»ºå‹æ¨¡å¼æ˜¯ä¸€ç±»è®¾è®¡æ¨¡å¼ï¼Œå®ƒä»¬æŠ½è±¡äº†å¯¹è±¡å®ä¾‹åŒ–çš„è¿‡ç¨‹ï¼Œä½¿å¾—ç³»ç»Ÿåœ¨åˆ›å»ºå¯¹è±¡æ—¶å…·æœ‰æ›´å¤§çš„çµæ´»æ€§å’Œå¯æ‰©å±•æ€§ã€‚

**å®šä¹‰ 1.2** (å¯¹è±¡åˆ›å»ºé—®é¢˜)
ç»™å®šç±»å‹é›†åˆ $T = \{T_1, T_2, \ldots, T_n\}$ å’Œçº¦æŸæ¡ä»¶é›†åˆ $C = \{C_1, C_2, \ldots, C_m\}$ï¼Œå¯¹è±¡åˆ›å»ºé—®é¢˜æ˜¯åœ¨æ»¡è¶³æ‰€æœ‰çº¦æŸæ¡ä»¶çš„æƒ…å†µä¸‹ï¼Œä¸ºæ¯ä¸ªç±»å‹ $T_i$ åˆ›å»ºå®ä¾‹ $t_i$ã€‚

### 1.2 åˆ›å»ºå‹æ¨¡å¼çš„åˆ†ç±»

åˆ›å»ºå‹æ¨¡å¼å¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ç±»ï¼š

1. **å•ä¾‹æ¨¡å¼ (Singleton Pattern)**
2. **å·¥å‚æ–¹æ³•æ¨¡å¼ (Factory Method Pattern)**
3. **æŠ½è±¡å·¥å‚æ¨¡å¼ (Abstract Factory Pattern)**
4. **å»ºé€ è€…æ¨¡å¼ (Builder Pattern)**
5. **åŸå‹æ¨¡å¼ (Prototype Pattern)**

### 1.3 å½¢å¼åŒ–è¡¨ç¤º

**å®šä¹‰ 1.3** (åˆ›å»ºå‹æ¨¡å¼çš„å½¢å¼åŒ–è¡¨ç¤º)
åˆ›å»ºå‹æ¨¡å¼å¯ä»¥è¡¨ç¤ºä¸ºäº”å…ƒç»„ $P = (T, C, F, R, S)$ï¼Œå…¶ä¸­ï¼š

- $T$ æ˜¯ç±»å‹é›†åˆ
- $C$ æ˜¯çº¦æŸæ¡ä»¶é›†åˆ
- $F$ æ˜¯å·¥å‚å‡½æ•°é›†åˆ
- $R$ æ˜¯åˆ›å»ºè§„åˆ™é›†åˆ
- $S$ æ˜¯çŠ¶æ€é›†åˆ

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å•ä¾‹æ¨¡å¼

**å®šä¹‰ 2.1** (å•ä¾‹æ¨¡å¼)
å•ä¾‹æ¨¡å¼ç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶æä¾›ä¸€ä¸ªå…¨å±€è®¿é—®ç‚¹ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Singleton}(T) = \{(t, \text{getInstance}) \mid t \in T \land \forall t' \in T : t' = t\}$$

**å®šç† 2.1** (å•ä¾‹å”¯ä¸€æ€§)
å¯¹äºä»»æ„ç±»å‹ $T$ï¼Œå¦‚æœ $s_1, s_2$ æ˜¯ $T$ çš„å•ä¾‹å®ä¾‹ï¼Œåˆ™ $s_1 = s_2$ã€‚

**è¯æ˜**ï¼š
æ ¹æ®å•ä¾‹æ¨¡å¼çš„å®šä¹‰ï¼Œ$\forall t' \in T : t' = t$ï¼Œå› æ­¤ $s_1 = s_2$ã€‚$\square$

### 2.2 å·¥å‚æ–¹æ³•æ¨¡å¼

**å®šä¹‰ 2.2** (å·¥å‚æ–¹æ³•æ¨¡å¼)
å·¥å‚æ–¹æ³•æ¨¡å¼å®šä¹‰äº†ä¸€ä¸ªåˆ›å»ºå¯¹è±¡çš„æ¥å£ï¼Œä½†ç”±å­ç±»å†³å®šè¦å®ä¾‹åŒ–çš„ç±»æ˜¯å“ªä¸€ä¸ªã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{FactoryMethod}(T, C) = \{f \mid f : C \rightarrow T \land \forall c \in C : f(c) \in T\}$$

**å®šç† 2.2** (å·¥å‚æ–¹æ³•çš„ç±»å‹å®‰å…¨)
å¯¹äºå·¥å‚æ–¹æ³• $f$ å’Œçº¦æŸæ¡ä»¶ $c$ï¼Œ$f(c)$ çš„ç±»å‹æ˜¯ç¡®å®šçš„ã€‚

**è¯æ˜**ï¼š
æ ¹æ®å·¥å‚æ–¹æ³•çš„å®šä¹‰ï¼Œ$f : C \rightarrow T$ï¼Œå› æ­¤å¯¹äºä»»æ„ $c \in C$ï¼Œ$f(c) \in T$ã€‚$\square$

### 2.3 æŠ½è±¡å·¥å‚æ¨¡å¼

**å®šä¹‰ 2.3** (æŠ½è±¡å·¥å‚æ¨¡å¼)
æŠ½è±¡å·¥å‚æ¨¡å¼æä¾›äº†ä¸€ä¸ªåˆ›å»ºä¸€ç³»åˆ—ç›¸å…³æˆ–ç›¸äº’ä¾èµ–å¯¹è±¡çš„æ¥å£ï¼Œè€Œæ— éœ€æŒ‡å®šå®ƒä»¬çš„å…·ä½“ç±»ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{AbstractFactory}(T_1, T_2, \ldots, T_n) = \{F \mid F : \prod_{i=1}^n T_i \land \forall i : F_i \in T_i\}$$

**å®šç† 2.3** (æŠ½è±¡å·¥å‚çš„ä¸€è‡´æ€§)
æŠ½è±¡å·¥å‚åˆ›å»ºçš„å¯¹è±¡é›†åˆæ»¡è¶³ä¸€è‡´æ€§çº¦æŸã€‚

**è¯æ˜**ï¼š
æ ¹æ®æŠ½è±¡å·¥å‚çš„å®šä¹‰ï¼Œæ‰€æœ‰åˆ›å»ºçš„å¯¹è±¡éƒ½æ¥è‡ªé¢„å®šä¹‰çš„ç±»å‹é›†åˆï¼Œå› æ­¤æ»¡è¶³ä¸€è‡´æ€§ã€‚$\square$

### 2.4 å»ºé€ è€…æ¨¡å¼

**å®šä¹‰ 2.4** (å»ºé€ è€…æ¨¡å¼)
å»ºé€ è€…æ¨¡å¼å°†ä¸€ä¸ªå¤æ‚å¯¹è±¡çš„æ„å»ºä¸å®ƒçš„è¡¨ç¤ºåˆ†ç¦»ï¼Œä½¿å¾—åŒæ ·çš„æ„å»ºè¿‡ç¨‹å¯ä»¥åˆ›å»ºä¸åŒçš„è¡¨ç¤ºã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Builder}(T, B) = \{(b, \text{build}) \mid b \in B \land \text{build} : B \rightarrow T\}$$

**å®šç† 2.4** (å»ºé€ è€…çš„å¯ç»„åˆæ€§)
å»ºé€ è€…æ¨¡å¼æ”¯æŒæ„å»ºæ­¥éª¤çš„ç»„åˆã€‚

**è¯æ˜**ï¼š
å»ºé€ è€…çš„æ¯ä¸ªæ­¥éª¤éƒ½å¯ä»¥ç‹¬ç«‹æ‰§è¡Œï¼Œæœ€ç»ˆé€šè¿‡ $\text{build}$ å‡½æ•°ç»„åˆæˆç›®æ ‡å¯¹è±¡ã€‚$\square$

### 2.5 åŸå‹æ¨¡å¼

**å®šä¹‰ 2.5** (åŸå‹æ¨¡å¼)
åŸå‹æ¨¡å¼ç”¨åŸå‹å®ä¾‹æŒ‡å®šåˆ›å»ºå¯¹è±¡çš„ç§ç±»ï¼Œå¹¶ä¸”é€šè¿‡å¤åˆ¶è¿™äº›åŸå‹åˆ›å»ºæ–°çš„å¯¹è±¡ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Prototype}(T) = \{(t, \text{clone}) \mid t \in T \land \text{clone} : T \rightarrow T\}$$

**å®šç† 2.5** (åŸå‹çš„ç­‰ä»·æ€§)
åŸå‹å…‹éš†çš„å¯¹è±¡ä¸åŸå¯¹è±¡åœ¨ç»“æ„ä¸Šç­‰ä»·ã€‚

**è¯æ˜**ï¼š
æ ¹æ®å…‹éš†çš„å®šä¹‰ï¼Œå…‹éš†å¯¹è±¡ç»§æ‰¿äº†åŸå¯¹è±¡çš„æ‰€æœ‰å±æ€§ï¼Œå› æ­¤ç»“æ„ç­‰ä»·ã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åˆ›å»ºå‹æ¨¡å¼çš„åŸºæœ¬æ€§è´¨

**å®šç† 3.1** (åˆ›å»ºå‹æ¨¡å¼çš„å°é—­æ€§)
åˆ›å»ºå‹æ¨¡å¼åœ¨ç±»å‹ç³»ç»Ÿä¸‹æ˜¯å°é—­çš„ã€‚

**è¯æ˜**ï¼š
è®¾ $P_1, P_2$ æ˜¯ä¸¤ä¸ªåˆ›å»ºå‹æ¨¡å¼ï¼Œåˆ™å®ƒä»¬çš„ç»„åˆ $P_1 \circ P_2$ ä»ç„¶æ˜¯ä¸€ä¸ªåˆ›å»ºå‹æ¨¡å¼ï¼Œå› ä¸ºï¼š

1. ç±»å‹é›†åˆçš„å¹¶é›†ä»ç„¶æ˜¯ç±»å‹é›†åˆ
2. çº¦æŸæ¡ä»¶çš„åˆå–ä»ç„¶æ˜¯çº¦æŸæ¡ä»¶
3. å·¥å‚å‡½æ•°çš„ç»„åˆä»ç„¶æ˜¯å·¥å‚å‡½æ•°
$\square$

**å®šç† 3.2** (åˆ›å»ºå‹æ¨¡å¼çš„å•è°ƒæ€§)
åˆ›å»ºå‹æ¨¡å¼æ»¡è¶³å•è°ƒæ€§ï¼šå¦‚æœ $T_1 \subseteq T_2$ï¼Œåˆ™ $P(T_1) \subseteq P(T_2)$ã€‚

**è¯æ˜**ï¼š
å¯¹äºä»»æ„åˆ›å»ºå‹æ¨¡å¼ $P$ï¼Œå¦‚æœ $t \in P(T_1)$ï¼Œåˆ™ $t \in T_1$ï¼Œç”±äº $T_1 \subseteq T_2$ï¼Œæ‰€ä»¥ $t \in T_2$ï¼Œå› æ­¤ $t \in P(T_2)$ã€‚$\square$

### 3.2 æ¨¡å¼é—´çš„å…³è”æ€§

**å®šç† 3.3** (å·¥å‚æ–¹æ³•ä¸æŠ½è±¡å·¥å‚çš„å…³ç³»)
æŠ½è±¡å·¥å‚æ¨¡å¼æ˜¯å·¥å‚æ–¹æ³•æ¨¡å¼çš„æ¨å¹¿ã€‚

**è¯æ˜**ï¼š
è®¾ $F$ æ˜¯æŠ½è±¡å·¥å‚ï¼Œ$f_i$ æ˜¯å·¥å‚æ–¹æ³•ï¼Œåˆ™ï¼š
$$F = \prod_{i=1}^n f_i$$
å› æ­¤æŠ½è±¡å·¥å‚å¯ä»¥è¡¨ç¤ºä¸ºå¤šä¸ªå·¥å‚æ–¹æ³•çš„ç¬›å¡å°”ç§¯ã€‚$\square$

**å®šç† 3.4** (å»ºé€ è€…ä¸å·¥å‚çš„å…³ç³»)
å»ºé€ è€…æ¨¡å¼å¯ä»¥æ¨¡æ‹Ÿå·¥å‚æ¨¡å¼ã€‚

**è¯æ˜**ï¼š
è®¾ $B$ æ˜¯å»ºé€ è€…ï¼Œ$F$ æ˜¯å·¥å‚ï¼Œåˆ™å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼æ¨¡æ‹Ÿï¼š
$$F(c) = B.\text{setConstraint}(c).\text{build}()$$
$\square$

## 4. ä»£ç å®ç°

### 4.1 å•ä¾‹æ¨¡å¼å®ç°

```rust
use std::sync::{Arc, Mutex};
use std::sync::Once;

/// çº¿ç¨‹å®‰å…¨çš„å•ä¾‹æ¨¡å¼å®ç°
pub struct Singleton {
    data: String,
}

impl Singleton {
    /// è·å–å•ä¾‹å®ä¾‹
    pub fn get_instance() -> Arc<Singleton> {
        static mut INSTANCE: Option<Arc<Singleton>> = None;
        static ONCE: Once = Once::new();
        
        unsafe {
            ONCE.call_once(|| {
                INSTANCE = Some(Arc::new(Singleton {
                    data: String::from("Singleton Data"),
                }));
            });
            INSTANCE.as_ref().unwrap().clone()
        }
    }
    
    /// è·å–æ•°æ®
    pub fn get_data(&self) -> &str {
        &self.data
    }
}

/// å•ä¾‹æ¨¡å¼çš„æ•°å­¦å®šä¹‰éªŒè¯
pub trait SingletonTrait {
    fn is_singleton(&self) -> bool;
}

impl SingletonTrait for Singleton {
    fn is_singleton(&self) -> bool {
        // éªŒè¯å•ä¾‹çš„å”¯ä¸€æ€§
        let instance1 = Self::get_instance();
        let instance2 = Self::get_instance();
        Arc::ptr_eq(&instance1, &instance2)
    }
}
```

### 4.2 å·¥å‚æ–¹æ³•æ¨¡å¼å®ç°

```rust
/// äº§å“ç‰¹å¾
pub trait Product {
    fn operation(&self) -> String;
}

/// å…·ä½“äº§å“A
pub struct ConcreteProductA;

impl Product for ConcreteProductA {
    fn operation(&self) -> String {
        String::from("ConcreteProductA operation")
    }
}

/// å…·ä½“äº§å“B
pub struct ConcreteProductB;

impl Product for ConcreteProductB {
    fn operation(&self) -> String {
        String::from("ConcreteProductB operation")
    }
}

/// å·¥å‚ç‰¹å¾
pub trait Factory {
    type ProductType: Product;
    
    fn create_product(&self) -> Self::ProductType;
}

/// å…·ä½“å·¥å‚A
pub struct ConcreteFactoryA;

impl Factory for ConcreteFactoryA {
    type ProductType = ConcreteProductA;
    
    fn create_product(&self) -> Self::ProductType {
        ConcreteProductA
    }
}

/// å…·ä½“å·¥å‚B
pub struct ConcreteFactoryB;

impl Factory for ConcreteFactoryB {
    type ProductType = ConcreteProductB;
    
    fn create_product(&self) -> Self::ProductType {
        ConcreteProductB
    }
}

/// å·¥å‚æ–¹æ³•çš„æ•°å­¦éªŒè¯
pub struct FactoryMethodValidator;

impl FactoryMethodValidator {
    /// éªŒè¯å·¥å‚æ–¹æ³•çš„ç±»å‹å®‰å…¨
    pub fn validate_type_safety<F: Factory>(factory: &F) -> bool {
        let product = factory.create_product();
        // éªŒè¯äº§å“å®ç°äº†Productç‰¹å¾
        let _: &dyn Product = &product;
        true
    }
    
    /// éªŒè¯å·¥å‚æ–¹æ³•çš„ä¸€è‡´æ€§
    pub fn validate_consistency<F: Factory>(factory: &F) -> bool {
        let product1 = factory.create_product();
        let product2 = factory.create_product();
        // éªŒè¯ä¸¤æ¬¡åˆ›å»ºçš„äº§å“ç±»å‹ä¸€è‡´
        std::any::TypeId::of::<F::ProductType>() == std::any::TypeId::of::<F::ProductType>()
    }
}
```

### 4.3 æŠ½è±¡å·¥å‚æ¨¡å¼å®ç°

```rust
/// æŠ½è±¡äº§å“A
pub trait AbstractProductA {
    fn operation_a(&self) -> String;
}

/// æŠ½è±¡äº§å“B
pub trait AbstractProductB {
    fn operation_b(&self) -> String;
}

/// å…·ä½“äº§å“A1
pub struct ConcreteProductA1;

impl AbstractProductA for ConcreteProductA1 {
    fn operation_a(&self) -> String {
        String::from("ConcreteProductA1 operation")
    }
}

/// å…·ä½“äº§å“B1
pub struct ConcreteProductB1;

impl AbstractProductB for ConcreteProductB1 {
    fn operation_b(&self) -> String {
        String::from("ConcreteProductB1 operation")
    }
}

/// æŠ½è±¡å·¥å‚
pub trait AbstractFactory {
    type ProductA: AbstractProductA;
    type ProductB: AbstractProductB;
    
    fn create_product_a(&self) -> Self::ProductA;
    fn create_product_b(&self) -> Self::ProductB;
}

/// å…·ä½“å·¥å‚1
pub struct ConcreteFactory1;

impl AbstractFactory for ConcreteFactory1 {
    type ProductA = ConcreteProductA1;
    type ProductB = ConcreteProductB1;
    
    fn create_product_a(&self) -> Self::ProductA {
        ConcreteProductA1
    }
    
    fn create_product_b(&self) -> Self::ProductB {
        ConcreteProductB1
    }
}

/// æŠ½è±¡å·¥å‚çš„æ•°å­¦éªŒè¯
pub struct AbstractFactoryValidator;

impl AbstractFactoryValidator {
    /// éªŒè¯æŠ½è±¡å·¥å‚çš„ä¸€è‡´æ€§
    pub fn validate_consistency<F: AbstractFactory>(factory: &F) -> bool {
        let product_a = factory.create_product_a();
        let product_b = factory.create_product_b();
        
        // éªŒè¯äº§å“ç±»å‹çš„ä¸€è‡´æ€§
        let type_a = std::any::TypeId::of::<F::ProductA>();
        let type_b = std::any::TypeId::of::<F::ProductB>();
        
        // ç¡®ä¿äº§å“ç±»å‹ä¸åŒï¼ˆè¿™æ˜¯æŠ½è±¡å·¥å‚çš„è¦æ±‚ï¼‰
        type_a != type_b
    }
}
```

### 4.4 å»ºé€ è€…æ¨¡å¼å®ç°

```rust
/// å¤æ‚äº§å“
#[derive(Debug, Clone)]
pub struct ComplexProduct {
    part_a: String,
    part_b: String,
    part_c: String,
}

impl ComplexProduct {
    pub fn new() -> Self {
        Self {
            part_a: String::new(),
            part_b: String::new(),
            part_c: String::new(),
        }
    }
}

/// å»ºé€ è€…ç‰¹å¾
pub trait Builder {
    type Product;
    
    fn build_part_a(&mut self, part: String) -> &mut Self;
    fn build_part_b(&mut self, part: String) -> &mut Self;
    fn build_part_c(&mut self, part: String) -> &mut Self;
    fn build(&self) -> Self::Product;
}

/// å…·ä½“å»ºé€ è€…
pub struct ConcreteBuilder {
    product: ComplexProduct,
}

impl ConcreteBuilder {
    pub fn new() -> Self {
        Self {
            product: ComplexProduct::new(),
        }
    }
}

impl Builder for ConcreteBuilder {
    type Product = ComplexProduct;
    
    fn build_part_a(&mut self, part: String) -> &mut Self {
        self.product.part_a = part;
        self
    }
    
    fn build_part_b(&mut self, part: String) -> &mut Self {
        self.product.part_b = part;
        self
    }
    
    fn build_part_c(&mut self, part: String) -> &mut Self {
        self.product.part_c = part;
        self
    }
    
    fn build(&self) -> Self::Product {
        self.product.clone()
    }
}

/// å»ºé€ è€…çš„æ•°å­¦éªŒè¯
pub struct BuilderValidator;

impl BuilderValidator {
    /// éªŒè¯å»ºé€ è€…çš„å¯ç»„åˆæ€§
    pub fn validate_composability<B: Builder>(builder: &mut B) -> bool {
        let product = builder
            .build_part_a("A".to_string())
            .build_part_b("B".to_string())
            .build_part_c("C".to_string())
            .build();
        
        // éªŒè¯äº§å“è¢«æ­£ç¡®æ„å»º
        true
    }
}
```

### 4.5 åŸå‹æ¨¡å¼å®ç°

```rust
use std::collections::HashMap;

/// åŸå‹ç‰¹å¾
pub trait Prototype: Clone {
    fn clone_prototype(&self) -> Self;
}

/// å…·ä½“åŸå‹
#[derive(Clone)]
pub struct ConcretePrototype {
    data: String,
    properties: HashMap<String, String>,
}

impl ConcretePrototype {
    pub fn new(data: String) -> Self {
        let mut properties = HashMap::new();
        properties.insert("type".to_string(), "prototype".to_string());
        
        Self { data, properties }
    }
    
    pub fn get_data(&self) -> &str {
        &self.data
    }
    
    pub fn set_property(&mut self, key: String, value: String) {
        self.properties.insert(key, value);
    }
    
    pub fn get_property(&self, key: &str) -> Option<&String> {
        self.properties.get(key)
    }
}

impl Prototype for ConcretePrototype {
    fn clone_prototype(&self) -> Self {
        self.clone()
    }
}

/// åŸå‹ç®¡ç†å™¨
pub struct PrototypeManager {
    prototypes: HashMap<String, Box<dyn Prototype>>,
}

impl PrototypeManager {
    pub fn new() -> Self {
        Self {
            prototypes: HashMap::new(),
        }
    }
    
    pub fn register(&mut self, name: String, prototype: Box<dyn Prototype>) {
        self.prototypes.insert(name, prototype);
    }
    
    pub fn clone_prototype(&self, name: &str) -> Option<Box<dyn Prototype>> {
        self.prototypes.get(name).map(|p| p.clone_prototype())
    }
}

/// åŸå‹çš„æ•°å­¦éªŒè¯
pub struct PrototypeValidator;

impl PrototypeValidator {
    /// éªŒè¯åŸå‹çš„ç­‰ä»·æ€§
    pub fn validate_equivalence<P: Prototype + PartialEq>(prototype: &P) -> bool {
        let clone = prototype.clone_prototype();
        prototype == &clone
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 æ•°æ®åº“è¿æ¥æ± çš„å•ä¾‹æ¨¡å¼

```rust
use std::sync::{Arc, Mutex};
use std::collections::HashMap;

/// æ•°æ®åº“è¿æ¥
pub struct DatabaseConnection {
    id: String,
    is_active: bool,
}

impl DatabaseConnection {
    pub fn new(id: String) -> Self {
        Self {
            id,
            is_active: true,
        }
    }
}

/// æ•°æ®åº“è¿æ¥æ± ï¼ˆå•ä¾‹æ¨¡å¼ï¼‰
pub struct ConnectionPool {
    connections: HashMap<String, DatabaseConnection>,
    max_connections: usize,
}

impl ConnectionPool {
    pub fn get_instance() -> Arc<Mutex<ConnectionPool>> {
        static mut INSTANCE: Option<Arc<Mutex<ConnectionPool>>> = None;
        static ONCE: std::sync::Once = std::sync::Once::new();
        
        unsafe {
            ONCE.call_once(|| {
                INSTANCE = Some(Arc::new(Mutex::new(ConnectionPool {
                    connections: HashMap::new(),
                    max_connections: 10,
                })));
            });
            INSTANCE.as_ref().unwrap().clone()
        }
    }
    
    pub fn get_connection(&mut self, id: String) -> Option<DatabaseConnection> {
        if self.connections.len() < self.max_connections {
            let conn = DatabaseConnection::new(id.clone());
            self.connections.insert(id, conn.clone());
            Some(conn)
        } else {
            None
        }
    }
}
```

### 5.2 å›¾å½¢ç”¨æˆ·ç•Œé¢çš„å·¥å‚æ¨¡å¼

```rust
/// å›¾å½¢ç»„ä»¶ç‰¹å¾
pub trait UIComponent {
    fn render(&self) -> String;
    fn get_id(&self) -> &str;
}

/// æŒ‰é’®ç»„ä»¶
pub struct Button {
    id: String,
    text: String,
}

impl Button {
    pub fn new(id: String, text: String) -> Self {
        Self { id, text }
    }
}

impl UIComponent for Button {
    fn render(&self) -> String {
        format!("<button id='{}'>{}</button>", self.id, self.text)
    }
    
    fn get_id(&self) -> &str {
        &self.id
    }
}

/// æ–‡æœ¬æ¡†ç»„ä»¶
pub struct TextBox {
    id: String,
    placeholder: String,
}

impl TextBox {
    pub fn new(id: String, placeholder: String) -> Self {
        Self { id, placeholder }
    }
}

impl UIComponent for TextBox {
    fn render(&self) -> String {
        format!("<input type='text' id='{}' placeholder='{}'/>", self.id, self.placeholder)
    }
    
    fn get_id(&self) -> &str {
        &self.id
    }
}

/// UIç»„ä»¶å·¥å‚
pub trait UIComponentFactory {
    type Component: UIComponent;
    
    fn create_component(&self, id: String, config: ComponentConfig) -> Self::Component;
}

/// ç»„ä»¶é…ç½®
pub struct ComponentConfig {
    pub text: Option<String>,
    pub placeholder: Option<String>,
}

/// æŒ‰é’®å·¥å‚
pub struct ButtonFactory;

impl UIComponentFactory for ButtonFactory {
    type Component = Button;
    
    fn create_component(&self, id: String, config: ComponentConfig) -> Self::Component {
        Button::new(id, config.text.unwrap_or_default())
    }
}

/// æ–‡æœ¬æ¡†å·¥å‚
pub struct TextBoxFactory;

impl UIComponentFactory for TextBoxFactory {
    type Component = TextBox;
    
    fn create_component(&self, id: String, config: ComponentConfig) -> Self::Component {
        TextBox::new(id, config.placeholder.unwrap_or_default())
    }
}
```

### 5.3 æ–‡æ¡£æ„å»ºå™¨çš„å»ºé€ è€…æ¨¡å¼

```rust
/// æ–‡æ¡£ç»“æ„
#[derive(Debug, Clone)]
pub struct Document {
    title: String,
    author: String,
    content: Vec<String>,
    metadata: HashMap<String, String>,
}

impl Document {
    pub fn new() -> Self {
        Self {
            title: String::new(),
            author: String::new(),
            content: Vec::new(),
            metadata: HashMap::new(),
        }
    }
    
    pub fn display(&self) -> String {
        let mut result = format!("Title: {}\n", self.title);
        result.push_str(&format!("Author: {}\n", self.author));
        result.push_str("Content:\n");
        for (i, line) in self.content.iter().enumerate() {
            result.push_str(&format!("{}. {}\n", i + 1, line));
        }
        result
    }
}

/// æ–‡æ¡£å»ºé€ è€…
pub trait DocumentBuilder {
    fn set_title(&mut self, title: String) -> &mut Self;
    fn set_author(&mut self, author: String) -> &mut Self;
    fn add_content(&mut self, content: String) -> &mut Self;
    fn add_metadata(&mut self, key: String, value: String) -> &mut Self;
    fn build(&self) -> Document;
}

/// å…·ä½“æ–‡æ¡£å»ºé€ è€…
pub struct ConcreteDocumentBuilder {
    document: Document,
}

impl ConcreteDocumentBuilder {
    pub fn new() -> Self {
        Self {
            document: Document::new(),
        }
    }
}

impl DocumentBuilder for ConcreteDocumentBuilder {
    fn set_title(&mut self, title: String) -> &mut Self {
        self.document.title = title;
        self
    }
    
    fn set_author(&mut self, author: String) -> &mut Self {
        self.document.author = author;
        self
    }
    
    fn add_content(&mut self, content: String) -> &mut Self {
        self.document.content.push(content);
        self
    }
    
    fn add_metadata(&mut self, key: String, value: String) -> &mut Self {
        self.document.metadata.insert(key, value);
        self
    }
    
    fn build(&self) -> Document {
        self.document.clone()
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸è®¾è®¡æ¨¡å¼ç†è®ºçš„å…³ç³»

åˆ›å»ºå‹æ¨¡å¼æ˜¯è®¾è®¡æ¨¡å¼ç†è®ºçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œä¸å…¶ä»–æ¨¡å¼ç±»å‹ï¼ˆç»“æ„å‹æ¨¡å¼ã€è¡Œä¸ºå‹æ¨¡å¼ï¼‰å½¢æˆå®Œæ•´çš„æ¨¡å¼ä½“ç³»ã€‚

**å®šç† 6.1** (æ¨¡å¼åˆ†ç±»çš„å®Œå¤‡æ€§)
åˆ›å»ºå‹ã€ç»“æ„å‹ã€è¡Œä¸ºå‹æ¨¡å¼æ„æˆäº†è®¾è®¡æ¨¡å¼çš„å®Œå¤‡åˆ†ç±»ã€‚

**è¯æ˜**ï¼š
æ ¹æ®è®¾è®¡æ¨¡å¼çš„å®šä¹‰ï¼Œä»»ä½•è®¾è®¡æ¨¡å¼éƒ½å¯ä»¥å½’ç±»ä¸ºè¿™ä¸‰ç§ç±»å‹ä¹‹ä¸€ï¼š

- åˆ›å»ºå‹ï¼šå…³æ³¨å¯¹è±¡åˆ›å»º
- ç»“æ„å‹ï¼šå…³æ³¨å¯¹è±¡ç»„åˆ
- è¡Œä¸ºå‹ï¼šå…³æ³¨å¯¹è±¡äº¤äº’
$\square$

### 6.2 ä¸é¢å‘å¯¹è±¡ç†è®ºçš„å…³ç³»

åˆ›å»ºå‹æ¨¡å¼ä½“ç°äº†é¢å‘å¯¹è±¡ç†è®ºä¸­çš„å°è£…ã€ç»§æ‰¿ã€å¤šæ€ç­‰æ ¸å¿ƒæ¦‚å¿µã€‚

**å®šç† 6.2** (é¢å‘å¯¹è±¡åŸåˆ™çš„ä½“ç°)
åˆ›å»ºå‹æ¨¡å¼æ»¡è¶³é¢å‘å¯¹è±¡çš„åŸºæœ¬åŸåˆ™ã€‚

**è¯æ˜**ï¼š

1. **å°è£…**ï¼šå·¥å‚æ–¹æ³•å°è£…äº†å¯¹è±¡åˆ›å»ºé€»è¾‘
2. **ç»§æ‰¿**ï¼šæŠ½è±¡å·¥å‚é€šè¿‡ç»§æ‰¿å®ç°å¤šæ€
3. **å¤šæ€**ï¼šä¸åŒå·¥å‚å¯ä»¥åˆ›å»ºä¸åŒç±»å‹çš„å¯¹è±¡
$\square$

### 6.3 ä¸è½¯ä»¶å·¥ç¨‹ç†è®ºçš„å…³ç³»

åˆ›å»ºå‹æ¨¡å¼æ˜¯è½¯ä»¶å·¥ç¨‹ä¸­é‡è¦çš„è®¾è®¡åŸåˆ™ï¼Œä½“ç°äº†SOLIDåŸåˆ™ä¸­çš„ä¾èµ–å€’ç½®åŸåˆ™ã€‚

**å®šç† 6.3** (ä¾èµ–å€’ç½®åŸåˆ™çš„ä½“ç°)
åˆ›å»ºå‹æ¨¡å¼å®ç°äº†ä¾èµ–å€’ç½®åŸåˆ™ã€‚

**è¯æ˜**ï¼š
é«˜å±‚æ¨¡å—ï¼ˆå®¢æˆ·ç«¯ï¼‰ä¸ä¾èµ–äºä½å±‚æ¨¡å—ï¼ˆå…·ä½“ç±»ï¼‰ï¼Œè€Œæ˜¯ä¾èµ–äºæŠ½è±¡ï¼ˆå·¥å‚æ¥å£ï¼‰ï¼Œå…·ä½“ç±»ä¾èµ–äºæŠ½è±¡ã€‚$\square$

## 7. å‚è€ƒæ–‡çŒ®

1. Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.
2. Freeman, E., Robson, E., Sierra, K., & Bates, B. (2004). Head First Design Patterns. O'Reilly Media.
3. Martin, R. C. (2000). Design Principles and Design Patterns. Object Mentor.
4. Liskov, B. (1987). Data Abstraction and Hierarchy. SIGPLAN Notices, 23(5), 17-34.
5. Meyer, B. (1988). Object-Oriented Software Construction. Prentice Hall.

---

**ç›¸å…³é“¾æ¥**ï¼š

- [07.3.2 ç»“æ„å‹æ¨¡å¼](../07.3.2_ç»“æ„å‹æ¨¡å¼.md)
- [07.3.3 è¡Œä¸ºå‹æ¨¡å¼](../07.3.3_è¡Œä¸ºå‹æ¨¡å¼.md)
- [07.3.4 æ¶æ„æ¨¡å¼](../07.3.4_æ¶æ„æ¨¡å¼.md)
- [07.2.1 æ¶æ„è®¾è®¡åŸåˆ™](../07.2.1_æ¶æ„è®¾è®¡åŸåˆ™.md)
- [07.2.2 æ¶æ„æ¨¡å¼ç†è®º](../07.2.2_æ¶æ„æ¨¡å¼ç†è®º.md)
