# 07.3.3 行为型模式

## 📋 概述

行为型模式关注对象之间的通信，它们描述对象之间如何相互协作以及如何分配职责。本文档从形式化角度分析行为型模式的理论基础、数学定义、实现原理和应用场景。

## 🎯 核心目标

1. 建立行为型模式的形式化理论基础
2. 提供严格的数学定义和证明
3. 实现完整的Rust代码示例
4. 分析模式间的关联性和应用场景

## 📚 目录

1. [基本概念](#1-基本概念)
2. [形式化定义](#2-形式化定义)
3. [定理与证明](#3-定理与证明)
4. [代码实现](#4-代码实现)
5. [应用示例](#5-应用示例)
6. [相关理论](#6-相关理论)
7. [参考文献](#7-参考文献)

## 1. 基本概念

### 1.1 行为型模式的定义

**定义 1.1** (行为型模式)
行为型模式是一类设计模式，它们关注对象之间的通信机制，定义对象间如何相互协作以及如何分配职责。

**定义 1.2** (对象交互问题)
给定对象集合 $O = \{o_1, o_2, \ldots, o_n\}$ 和交互规则集合 $I = \{i_1, i_2, \ldots, i_m\}$，对象交互问题是在满足所有交互规则的情况下，实现对象间的有效通信。

### 1.2 行为型模式的分类

行为型模式可以分为以下几类：

1. **责任链模式 (Chain of Responsibility Pattern)**
2. **命令模式 (Command Pattern)**
3. **解释器模式 (Interpreter Pattern)**
4. **迭代器模式 (Iterator Pattern)**
5. **中介者模式 (Mediator Pattern)**
6. **备忘录模式 (Memento Pattern)**
7. **观察者模式 (Observer Pattern)**
8. **状态模式 (State Pattern)**
9. **策略模式 (Strategy Pattern)**
10. **模板方法模式 (Template Method Pattern)**
11. **访问者模式 (Visitor Pattern)**

### 1.3 形式化表示

**定义 1.3** (行为型模式的形式化表示)
行为型模式可以表示为七元组 $B = (O, I, C, M, S, T, P)$，其中：
- $O$ 是对象集合
- $I$ 是交互规则集合
- $C$ 是通信协议集合
- $M$ 是消息集合
- $S$ 是状态集合
- $T$ 是转换函数集合
- $P$ 是优先级集合

## 2. 形式化定义

### 2.1 责任链模式

**定义 2.1** (责任链模式)
责任链模式为请求创建一个接收者对象的链，沿着这条链传递请求直到被处理。

形式化定义：
$$\text{ChainOfResponsibility}(H, R) = \{(h, r) \mid h \in H \land r \in R \land \text{canHandle}(h, r) \lor \text{hasNext}(h)\}$$

**定理 2.1** (责任链的传递性)
责任链模式支持请求的传递处理。

**证明**：
根据责任链的定义，每个处理器要么处理请求，要么传递给下一个处理器，因此支持传递处理。$\square$

### 2.2 命令模式

**定义 2.2** (命令模式)
命令模式将请求封装成对象，从而可以用不同的请求对客户进行参数化。

形式化定义：
$$\text{Command}(R, E) = \{(r, e) \mid r \in R \land e \in E \land \text{execute}(e, r)\}$$

**定理 2.2** (命令的可撤销性)
命令模式支持操作的撤销和重做。

**证明**：
命令对象封装了操作信息，因此可以实现撤销和重做功能。$\square$

### 2.3 解释器模式

**定义 2.3** (解释器模式)
解释器模式为语言创建解释器，定义语言的语法表示以及解释该语法的方法。

形式化定义：
$$\text{Interpreter}(G, E) = \{(g, e) \mid g \in G \land e \in E \land \text{interpret}(e, g)\}$$

**定理 2.3** (解释器的递归性)
解释器模式支持递归的语法解析。

**证明**：
解释器可以递归地解析复合表达式，因此支持复杂的语法结构。$\square$

### 2.4 迭代器模式

**定义 2.4** (迭代器模式)
迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

形式化定义：
$$\text{Iterator}(A, I) = \{(a, i) \mid a \in A \land i \in I \land \text{hasNext}(i) \land \text{next}(i) \in A\}$$

**定理 2.4** (迭代器的遍历性)
迭代器模式支持聚合对象的完整遍历。

**证明**：
迭代器提供了遍历聚合对象的标准接口，确保能够访问所有元素。$\square$

### 2.5 中介者模式

**定义 2.5** (中介者模式)
中介者模式用一个中介对象来封装一系列对象交互，中介者使各对象不需要显式地相互引用。

形式化定义：
$$\text{Mediator}(C, M) = \{(c, m) \mid c \in C \land m \in M \land \text{mediate}(m, c)\}$$

**定理 2.5** (中介者的解耦性)
中介者模式降低了对象间的耦合度。

**证明**：
对象通过中介者进行通信，而不是直接相互引用，因此降低了耦合度。$\square$

### 2.6 备忘录模式

**定义 2.6** (备忘录模式)
备忘录模式在不破坏封装的前提下，捕获并外部化对象的内部状态。

形式化定义：
$$\text{Memento}(O, S) = \{(o, s) \mid o \in O \land s \in S \land \text{save}(o, s) \land \text{restore}(o, s)\}$$

**定理 2.6** (备忘录的封装性)
备忘录模式保持了对象的封装性。

**证明**：
备忘录只保存状态信息，不暴露对象的内部结构，因此保持了封装性。$\square$

### 2.7 观察者模式

**定义 2.7** (观察者模式)
观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知。

形式化定义：
$$\text{Observer}(S, O) = \{(s, o) \mid s \in S \land o \in O \land \text{notify}(s, o)\}$$

**定理 2.7** (观察者的通知性)
观察者模式支持状态变化的自动通知。

**证明**：
当主题状态改变时，所有观察者都会收到通知，因此支持自动通知。$\square$

### 2.8 状态模式

**定义 2.8** (状态模式)
状态模式允许对象在内部状态改变时改变它的行为。

形式化定义：
$$\text{State}(C, S) = \{(c, s) \mid c \in C \land s \in S \land \text{changeState}(c, s)\}$$

**定理 2.8** (状态的可变性)
状态模式支持对象行为的动态变化。

**证明**：
对象的行为取决于当前状态，状态改变时行为也会改变。$\square$

### 2.9 策略模式

**定义 2.9** (策略模式)
策略模式定义一系列的算法，把它们封装起来，并且使它们可以互相替换。

形式化定义：
$$\text{Strategy}(C, A) = \{(c, a) \mid c \in C \land a \in A \land \text{execute}(c, a)\}$$

**定理 2.9** (策略的可替换性)
策略模式支持算法的动态替换。

**证明**：
不同的策略实现了相同的接口，因此可以在运行时动态替换。$\square$

### 2.10 模板方法模式

**定义 2.10** (模板方法模式)
模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。

形式化定义：
$$\text{TemplateMethod}(A, S) = \{(a, s) \mid a \in A \land s \in S \land \text{template}(a, s)\}$$

**定理 2.10** (模板的继承性)
模板方法模式通过继承实现代码复用。

**证明**：
子类继承模板方法，并实现特定的步骤，因此实现了代码复用。$\square$

### 2.11 访问者模式

**定义 2.11** (访问者模式)
访问者模式表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

形式化定义：
$$\text{Visitor}(E, V) = \{(e, v) \mid e \in E \land v \in V \land \text{visit}(v, e)\}$$

**定理 2.11** (访问者的扩展性)
访问者模式支持在不修改元素类的情况下添加新操作。

**证明**：
新的访问者可以实现新的操作，而不需要修改元素类的结构。$\square$

## 3. 定理与证明

### 3.1 行为型模式的基本性质

**定理 3.1** (行为型模式的组合性)
行为型模式支持行为的组合操作。

**证明**：
设 $B_1, B_2$ 是两个行为型模式，则它们的组合 $B_1 \circ B_2$ 仍然是一个行为型模式，因为：
1. 对象集合的并集仍然是对象集合
2. 交互规则的并集仍然是交互规则
3. 通信协议可以组合使用
$\square$

**定理 3.2** (行为型模式的传递性)
行为型模式满足传递性：如果对象 $A$ 与 $B$ 有交互，$B$ 与 $C$ 有交互，则 $A$ 与 $C$ 可以通过 $B$ 进行间接交互。

**证明**：
根据交互的定义，可以通过中介者或责任链实现间接交互。$\square$

### 3.2 模式间的关联性

**定理 3.3** (命令与策略的关系)
命令模式可以模拟策略模式。

**证明**：
设 $C$ 是命令，$S$ 是策略，则可以通过以下方式模拟：
$$S(a) = C(\text{execute}, a)$$
$\square$

**定理 3.4** (观察者与中介者的关系)
中介者模式可以模拟观察者模式。

**证明**：
中介者可以作为观察者和主题之间的桥梁，实现通知机制。$\square$

## 4. 代码实现

### 4.1 责任链模式实现

```rust
/// 请求
pub struct Request {
    pub level: u32,
    pub description: String,
}

impl Request {
    pub fn new(level: u32, description: String) -> Self {
        Self { level, description }
    }
}

/// 处理器特征
pub trait Handler {
    fn set_next(&mut self, handler: Box<dyn Handler>);
    fn handle(&self, request: &Request) -> Option<String>;
}

/// 抽象处理器
pub struct AbstractHandler {
    next: Option<Box<dyn Handler>>,
}

impl AbstractHandler {
    pub fn new() -> Self {
        Self { next: None }
    }
}

impl Handler for AbstractHandler {
    fn set_next(&mut self, handler: Box<dyn Handler>) {
        self.next = Some(handler);
    }
    
    fn handle(&self, request: &Request) -> Option<String> {
        if let Some(ref next) = self.next {
            next.handle(request)
        } else {
            None
        }
    }
}

/// 具体处理器A
pub struct ConcreteHandlerA {
    handler: AbstractHandler,
    level: u32,
}

impl ConcreteHandlerA {
    pub fn new(level: u32) -> Self {
        Self {
            handler: AbstractHandler::new(),
            level,
        }
    }
}

impl Handler for ConcreteHandlerA {
    fn set_next(&mut self, handler: Box<dyn Handler>) {
        self.handler.set_next(handler);
    }
    
    fn handle(&self, request: &Request) -> Option<String> {
        if request.level <= self.level {
            Some(format!("ConcreteHandlerA handled: {}", request.description))
        } else {
            self.handler.handle(request)
        }
    }
}

/// 责任链的数学验证
pub struct ChainOfResponsibilityValidator;

impl ChainOfResponsibilityValidator {
    /// 验证责任链的传递性
    pub fn validate_transitivity(handler: &dyn Handler) -> bool {
        let request = Request::new(1, "test request".to_string());
        let result = handler.handle(&request);
        result.is_some()
    }
}
```

### 4.2 命令模式实现

```rust
/// 命令特征
pub trait Command {
    fn execute(&self) -> String;
    fn undo(&self) -> String;
}

/// 接收者
pub struct Receiver {
    name: String,
}

impl Receiver {
    pub fn new(name: String) -> Self {
        Self { name }
    }
    
    pub fn action(&self) -> String {
        format!("Receiver {} performed action", self.name)
    }
    
    pub fn undo_action(&self) -> String {
        format!("Receiver {} undid action", self.name)
    }
}

/// 具体命令
pub struct ConcreteCommand {
    receiver: Receiver,
}

impl ConcreteCommand {
    pub fn new(receiver: Receiver) -> Self {
        Self { receiver }
    }
}

impl Command for ConcreteCommand {
    fn execute(&self) -> String {
        self.receiver.action()
    }
    
    fn undo(&self) -> String {
        self.receiver.undo_action()
    }
}

/// 调用者
pub struct Invoker {
    commands: Vec<Box<dyn Command>>,
}

impl Invoker {
    pub fn new() -> Self {
        Self {
            commands: Vec::new(),
        }
    }
    
    pub fn add_command(&mut self, command: Box<dyn Command>) {
        self.commands.push(command);
    }
    
    pub fn execute_all(&self) -> Vec<String> {
        self.commands.iter().map(|cmd| cmd.execute()).collect()
    }
    
    pub fn undo_all(&self) -> Vec<String> {
        self.commands.iter().map(|cmd| cmd.undo()).collect()
    }
}

/// 命令的数学验证
pub struct CommandValidator;

impl CommandValidator {
    /// 验证命令的可撤销性
    pub fn validate_undo(command: &dyn Command) -> bool {
        let execute_result = command.execute();
        let undo_result = command.undo();
        !execute_result.is_empty() && !undo_result.is_empty()
    }
}
```

### 4.3 观察者模式实现

```rust
use std::collections::HashMap;

/// 观察者特征
pub trait Observer {
    fn update(&self, subject: &Subject) -> String;
}

/// 具体观察者A
pub struct ConcreteObserverA {
    name: String,
}

impl ConcreteObserverA {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

impl Observer for ConcreteObserverA {
    fn update(&self, subject: &Subject) -> String {
        format!("ObserverA {} received update: {}", self.name, subject.get_state())
    }
}

/// 具体观察者B
pub struct ConcreteObserverB {
    name: String,
}

impl ConcreteObserverB {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

impl Observer for ConcreteObserverB {
    fn update(&self, subject: &Subject) -> String {
        format!("ObserverB {} received update: {}", self.name, subject.get_state())
    }
}

/// 主题
pub struct Subject {
    observers: Vec<Box<dyn Observer>>,
    state: String,
}

impl Subject {
    pub fn new() -> Self {
        Self {
            observers: Vec::new(),
            state: String::new(),
        }
    }
    
    pub fn attach(&mut self, observer: Box<dyn Observer>) {
        self.observers.push(observer);
    }
    
    pub fn detach(&mut self, observer: &dyn Observer) {
        self.observers.retain(|o| !std::ptr::eq(o.as_ref(), observer));
    }
    
    pub fn notify(&self) -> Vec<String> {
        self.observers.iter().map(|o| o.update(self)).collect()
    }
    
    pub fn set_state(&mut self, state: String) {
        self.state = state;
    }
    
    pub fn get_state(&self) -> &str {
        &self.state
    }
}

/// 观察者的数学验证
pub struct ObserverValidator;

impl ObserverValidator {
    /// 验证观察者的通知性
    pub fn validate_notification(subject: &mut Subject) -> bool {
        let observer_a = ConcreteObserverA::new("A".to_string());
        let observer_b = ConcreteObserverB::new("B".to_string());
        
        subject.attach(Box::new(observer_a));
        subject.attach(Box::new(observer_b));
        
        subject.set_state("new state".to_string());
        let notifications = subject.notify();
        
        notifications.len() == 2
    }
}
```

### 4.4 策略模式实现

```rust
/// 策略特征
pub trait Strategy {
    fn execute(&self, data: &str) -> String;
}

/// 具体策略A
pub struct ConcreteStrategyA;

impl Strategy for ConcreteStrategyA {
    fn execute(&self, data: &str) -> String {
        format!("StrategyA: {}", data.to_uppercase())
    }
}

/// 具体策略B
pub struct ConcreteStrategyB;

impl Strategy for ConcreteStrategyB {
    fn execute(&self, data: &str) -> String {
        format!("StrategyB: {}", data.to_lowercase())
    }
}

/// 上下文
pub struct Context<S: Strategy> {
    strategy: S,
}

impl<S: Strategy> Context<S> {
    pub fn new(strategy: S) -> Self {
        Self { strategy }
    }
    
    pub fn execute_strategy(&self, data: &str) -> String {
        self.strategy.execute(data)
    }
}

/// 策略的数学验证
pub struct StrategyValidator;

impl StrategyValidator {
    /// 验证策略的可替换性
    pub fn validate_replaceability() -> bool {
        let strategy_a = ConcreteStrategyA;
        let strategy_b = ConcreteStrategyB;
        
        let context_a = Context::new(strategy_a);
        let context_b = Context::new(strategy_b);
        
        let result_a = context_a.execute_strategy("Hello");
        let result_b = context_b.execute_strategy("Hello");
        
        result_a != result_b
    }
}
```

### 4.5 状态模式实现

```rust
/// 状态特征
pub trait State {
    fn handle(&self, context: &mut Context) -> String;
}

/// 具体状态A
pub struct ConcreteStateA;

impl State for ConcreteStateA {
    fn handle(&self, context: &mut Context) -> String {
        context.set_state(Box::new(ConcreteStateB));
        String::from("StateA handled, transitioning to StateB")
    }
}

/// 具体状态B
pub struct ConcreteStateB;

impl State for ConcreteStateB {
    fn handle(&self, context: &mut Context) -> String {
        context.set_state(Box::new(ConcreteStateA));
        String::from("StateB handled, transitioning to StateA")
    }
}

/// 上下文
pub struct Context {
    state: Box<dyn State>,
}

impl Context {
    pub fn new() -> Self {
        Self {
            state: Box::new(ConcreteStateA),
        }
    }
    
    pub fn set_state(&mut self, state: Box<dyn State>) {
        self.state = state;
    }
    
    pub fn request(&mut self) -> String {
        self.state.handle(self)
    }
}

/// 状态的数学验证
pub struct StateValidator;

impl StateValidator {
    /// 验证状态的可变性
    pub fn validate_mutability() -> bool {
        let mut context = Context::new();
        
        let result1 = context.request();
        let result2 = context.request();
        
        result1 != result2
    }
}
```

### 4.6 访问者模式实现

```rust
/// 元素特征
pub trait Element {
    fn accept(&self, visitor: &dyn Visitor) -> String;
}

/// 具体元素A
pub struct ConcreteElementA {
    name: String,
}

impl ConcreteElementA {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

impl Element for ConcreteElementA {
    fn accept(&self, visitor: &dyn Visitor) -> String {
        visitor.visit_element_a(self)
    }
}

/// 具体元素B
pub struct ConcreteElementB {
    value: i32,
}

impl ConcreteElementB {
    pub fn new(value: i32) -> Self {
        Self { value }
    }
}

impl Element for ConcreteElementB {
    fn accept(&self, visitor: &dyn Visitor) -> String {
        visitor.visit_element_b(self)
    }
}

/// 访问者特征
pub trait Visitor {
    fn visit_element_a(&self, element: &ConcreteElementA) -> String;
    fn visit_element_b(&self, element: &ConcreteElementB) -> String;
}

/// 具体访问者A
pub struct ConcreteVisitorA;

impl Visitor for ConcreteVisitorA {
    fn visit_element_a(&self, element: &ConcreteElementA) -> String {
        format!("VisitorA visited ElementA: {}", element.name)
    }
    
    fn visit_element_b(&self, element: &ConcreteElementB) -> String {
        format!("VisitorA visited ElementB: {}", element.value)
    }
}

/// 具体访问者B
pub struct ConcreteVisitorB;

impl Visitor for ConcreteVisitorB {
    fn visit_element_a(&self, element: &ConcreteElementA) -> String {
        format!("VisitorB processed ElementA: {}", element.name.to_uppercase())
    }
    
    fn visit_element_b(&self, element: &ConcreteElementB) -> String {
        format!("VisitorB processed ElementB: {}", element.value * 2)
    }
}

/// 访问者的数学验证
pub struct VisitorValidator;

impl VisitorValidator {
    /// 验证访问者的扩展性
    pub fn validate_extensibility() -> bool {
        let element_a = ConcreteElementA::new("test".to_string());
        let element_b = ConcreteElementB::new(5);
        
        let visitor_a = ConcreteVisitorA;
        let visitor_b = ConcreteVisitorB;
        
        let result_a1 = element_a.accept(&visitor_a);
        let result_a2 = element_a.accept(&visitor_b);
        let result_b1 = element_b.accept(&visitor_a);
        let result_b2 = element_b.accept(&visitor_b);
        
        result_a1 != result_a2 && result_b1 != result_b2
    }
}
```

## 5. 应用示例

### 5.1 日志处理系统的责任链模式

```rust
/// 日志级别
#[derive(Debug, Clone, PartialEq)]
pub enum LogLevel {
    Info,
    Warning,
    Error,
    Critical,
}

/// 日志消息
pub struct LogMessage {
    pub level: LogLevel,
    pub message: String,
    pub timestamp: String,
}

impl LogMessage {
    pub fn new(level: LogLevel, message: String) -> Self {
        Self {
            level,
            message,
            timestamp: chrono::Utc::now().to_rfc3339(),
        }
    }
}

/// 日志处理器特征
pub trait LogHandler {
    fn set_next(&mut self, handler: Box<dyn LogHandler>);
    fn handle(&self, message: &LogMessage) -> Option<String>;
}

/// 信息日志处理器
pub struct InfoLogHandler {
    next: Option<Box<dyn LogHandler>>,
}

impl InfoLogHandler {
    pub fn new() -> Self {
        Self { next: None }
    }
}

impl LogHandler for InfoLogHandler {
    fn set_next(&mut self, handler: Box<dyn LogHandler>) {
        self.next = Some(handler);
    }
    
    fn handle(&self, message: &LogMessage) -> Option<String> {
        if message.level == LogLevel::Info {
            Some(format!("[INFO] {}: {}", message.timestamp, message.message))
        } else {
            self.next.as_ref().and_then(|h| h.handle(message))
        }
    }
}

/// 错误日志处理器
pub struct ErrorLogHandler {
    next: Option<Box<dyn LogHandler>>,
}

impl ErrorLogHandler {
    pub fn new() -> Self {
        Self { next: None }
    }
}

impl LogHandler for ErrorLogHandler {
    fn set_next(&mut self, handler: Box<dyn LogHandler>) {
        self.next = Some(handler);
    }
    
    fn handle(&self, message: &LogMessage) -> Option<String> {
        if message.level == LogLevel::Error || message.level == LogLevel::Critical {
            Some(format!("[ERROR] {}: {}", message.timestamp, message.message))
        } else {
            self.next.as_ref().and_then(|h| h.handle(message))
        }
    }
}
```

### 5.2 文本编辑器的命令模式

```rust
use std::collections::VecDeque;

/// 文档
pub struct Document {
    content: String,
}

impl Document {
    pub fn new() -> Self {
        Self {
            content: String::new(),
        }
    }
    
    pub fn insert_text(&mut self, text: String, position: usize) {
        self.content.insert_str(position, &text);
    }
    
    pub fn delete_text(&mut self, start: usize, end: usize) -> String {
        let deleted = self.content[start..end].to_string();
        self.content.replace_range(start..end, "");
        deleted
    }
    
    pub fn get_content(&self) -> &str {
        &self.content
    }
}

/// 命令特征
pub trait EditorCommand {
    fn execute(&mut self) -> String;
    fn undo(&mut self) -> String;
}

/// 插入文本命令
pub struct InsertCommand {
    document: Document,
    text: String,
    position: usize,
}

impl InsertCommand {
    pub fn new(document: Document, text: String, position: usize) -> Self {
        Self {
            document,
            text,
            position,
        }
    }
}

impl EditorCommand for InsertCommand {
    fn execute(&mut self) -> String {
        self.document.insert_text(self.text.clone(), self.position);
        format!("Inserted '{}' at position {}", self.text, self.position)
    }
    
    fn undo(&mut self) -> String {
        let end = self.position + self.text.len();
        self.document.delete_text(self.position, end);
        format!("Undid insertion of '{}'", self.text)
    }
}

/// 删除文本命令
pub struct DeleteCommand {
    document: Document,
    start: usize,
    end: usize,
    deleted_text: Option<String>,
}

impl DeleteCommand {
    pub fn new(document: Document, start: usize, end: usize) -> Self {
        Self {
            document,
            start,
            end,
            deleted_text: None,
        }
    }
}

impl EditorCommand for DeleteCommand {
    fn execute(&mut self) -> String {
        let deleted = self.document.delete_text(self.start, self.end);
        self.deleted_text = Some(deleted.clone());
        format!("Deleted '{}'", deleted)
    }
    
    fn undo(&mut self) -> String {
        if let Some(ref text) = self.deleted_text {
            self.document.insert_text(text.clone(), self.start);
            format!("Undid deletion of '{}'", text)
        } else {
            String::from("Nothing to undo")
        }
    }
}

/// 编辑器
pub struct Editor {
    document: Document,
    command_history: VecDeque<Box<dyn EditorCommand>>,
}

impl Editor {
    pub fn new() -> Self {
        Self {
            document: Document::new(),
            command_history: VecDeque::new(),
        }
    }
    
    pub fn execute_command(&mut self, command: Box<dyn EditorCommand>) -> String {
        let result = command.execute();
        self.command_history.push_back(command);
        result
    }
    
    pub fn undo_last_command(&mut self) -> Option<String> {
        self.command_history.pop_back().map(|mut cmd| cmd.undo())
    }
    
    pub fn get_content(&self) -> &str {
        self.document.get_content()
    }
}
```

### 5.3 股票交易系统的观察者模式

```rust
use std::collections::HashMap;

/// 股票价格
pub struct StockPrice {
    pub symbol: String,
    pub price: f64,
    pub change: f64,
}

impl StockPrice {
    pub fn new(symbol: String, price: f64, change: f64) -> Self {
        Self {
            symbol,
            price,
            change,
        }
    }
}

/// 股票观察者特征
pub trait StockObserver {
    fn update(&self, stock: &StockPrice) -> String;
}

/// 价格提醒观察者
pub struct PriceAlertObserver {
    symbol: String,
    threshold: f64,
}

impl PriceAlertObserver {
    pub fn new(symbol: String, threshold: f64) -> Self {
        Self { symbol, threshold }
    }
}

impl StockObserver for PriceAlertObserver {
    fn update(&self, stock: &StockPrice) -> String {
        if stock.symbol == self.symbol && stock.price > self.threshold {
            format!("ALERT: {} price {} exceeds threshold {}", 
                   stock.symbol, stock.price, self.threshold)
        } else {
            format!("Price update: {} = ${:.2}", stock.symbol, stock.price)
        }
    }
}

/// 投资组合观察者
pub struct PortfolioObserver {
    holdings: HashMap<String, i32>,
}

impl PortfolioObserver {
    pub fn new() -> Self {
        Self {
            holdings: HashMap::new(),
        }
    }
    
    pub fn add_holding(&mut self, symbol: String, shares: i32) {
        *self.holdings.entry(symbol).or_insert(0) += shares;
    }
}

impl StockObserver for PortfolioObserver {
    fn update(&self, stock: &StockPrice) -> String {
        if let Some(&shares) = self.holdings.get(&stock.symbol) {
            let value = shares as f64 * stock.price;
            format!("Portfolio: {} shares of {} worth ${:.2}", 
                   shares, stock.symbol, value)
        } else {
            format!("Portfolio: No holdings in {}", stock.symbol)
        }
    }
}

/// 股票主题
pub struct StockSubject {
    observers: Vec<Box<dyn StockObserver>>,
    stocks: HashMap<String, StockPrice>,
}

impl StockSubject {
    pub fn new() -> Self {
        Self {
            observers: Vec::new(),
            stocks: HashMap::new(),
        }
    }
    
    pub fn attach(&mut self, observer: Box<dyn StockObserver>) {
        self.observers.push(observer);
    }
    
    pub fn update_stock_price(&mut self, stock: StockPrice) -> Vec<String> {
        self.stocks.insert(stock.symbol.clone(), stock.clone());
        self.observers.iter().map(|o| o.update(&stock)).collect()
    }
    
    pub fn get_stock(&self, symbol: &str) -> Option<&StockPrice> {
        self.stocks.get(symbol)
    }
}
```

## 6. 相关理论

### 6.1 与设计模式理论的关系

行为型模式是设计模式理论的重要组成部分，与创建型模式和结构型模式形成完整的模式体系。

**定理 6.1** (行为型模式的独立性)
行为型模式可以独立于创建型模式和结构型模式使用。

**证明**：
行为型模式关注对象交互，不依赖于对象的创建方式或结构方式，因此可以独立使用。$\square$

### 6.2 与面向对象理论的关系

行为型模式体现了面向对象理论中的多态和封装原则。

**定理 6.2** (多态的应用)
行为型模式通过多态实现了灵活的对象交互。

**证明**：
不同的策略、状态、观察者等都可以通过多态接口进行统一处理。$\square$

### 6.3 与软件工程理论的关系

行为型模式是软件工程中重要的设计原则，体现了开闭原则和依赖倒置原则。

**定理 6.3** (开闭原则的体现)
行为型模式支持对扩展开放，对修改封闭。

**证明**：
通过接口和抽象类，可以在不修改现有代码的情况下添加新的行为。$\square$

## 7. 参考文献

1. Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.
2. Freeman, E., Robson, E., Sierra, K., & Bates, B. (2004). Head First Design Patterns. O'Reilly Media.
3. Martin, R. C. (2000). Design Principles and Design Patterns. Object Mentor.
4. Liskov, B. (1987). Data Abstraction and Hierarchy. SIGPLAN Notices, 23(5), 17-34.
5. Meyer, B. (1988). Object-Oriented Software Construction. Prentice Hall.

---

**相关链接**：
- [07.3.1 创建型模式](../07.3.1_创建型模式.md)
- [07.3.2 结构型模式](../07.3.2_结构型模式.md)
- [07.3.4 架构模式](../07.3.4_架构模式.md)
- [07.2.1 架构设计原则](../07.2.1_架构设计原则.md)
- [07.2.2 架构模式理论](../07.2.2_架构模式理论.md) 