# 07.3.3 è¡Œä¸ºå‹æ¨¡å¼ç†è®º

## ğŸ“‹ æ¦‚è¿°

è¡Œä¸ºå‹æ¨¡å¼å…³æ³¨å¯¹è±¡é—´çš„é€šä¿¡æœºåˆ¶ï¼Œå®šä¹‰å¯¹è±¡é—´çš„äº¤äº’æ–¹å¼å’ŒèŒè´£åˆ†é…ï¼Œä½¿ç³»ç»Ÿæ›´åŠ çµæ´»å’Œå¯ç»´æŠ¤ã€‚æœ¬ç†è®ºä»å½¢å¼åŒ–è§’åº¦æ·±å…¥åˆ†æè¡Œä¸ºå‹æ¨¡å¼çš„æ ¸å¿ƒæ¦‚å¿µã€æ•°å­¦åŸºç¡€å’Œå®ç°åŸç†ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **äº¤äº’å»ºæ¨¡**ï¼šå»ºç«‹è¡Œä¸ºå‹æ¨¡å¼çš„æ•°å­¦å½¢å¼åŒ–æ¨¡å‹
2. **é€šä¿¡ç†è®º**ï¼šç³»ç»ŸåŒ–åˆ†æå¯¹è±¡é—´é€šä¿¡çš„æ•°å­¦åŸç†
3. **èŒè´£åˆ†é…**ï¼šç ”ç©¶å¯¹è±¡èŒè´£åˆ†é…çš„ç†è®ºåŸºç¡€
4. **çŠ¶æ€ç®¡ç†**ï¼šæ·±å…¥åˆ†æçŠ¶æ€è½¬æ¢å’ŒçŠ¶æ€ç®¡ç†æœºåˆ¶

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [æ¨¡å¼åˆ†ç±»ç†è®º](#3-æ¨¡å¼åˆ†ç±»ç†è®º)
4. [æ ¸å¿ƒæ¨¡å¼åˆ†æ](#4-æ ¸å¿ƒæ¨¡å¼åˆ†æ)
5. [å®ç°åŸç†](#5-å®ç°åŸç†)
6. [ä»£ç å®ç°](#6-ä»£ç å®ç°)
7. [åº”ç”¨ç¤ºä¾‹](#7-åº”ç”¨ç¤ºä¾‹)
8. [ç›¸å…³ç†è®º](#8-ç›¸å…³ç†è®º)
9. [å‚è€ƒæ–‡çŒ®](#9-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è¡Œä¸ºå‹æ¨¡å¼å®šä¹‰

**å®šä¹‰ 1.1** (è¡Œä¸ºå‹æ¨¡å¼)
è¡Œä¸ºå‹æ¨¡å¼æ˜¯ä¸€ç±»è®¾è®¡æ¨¡å¼ï¼Œå…¶æ ¸å¿ƒç›®æ ‡æ˜¯ï¼š
- å®šä¹‰å¯¹è±¡é—´çš„äº¤äº’æ–¹å¼
- åˆ†é…å¯¹è±¡èŒè´£å’Œç®—æ³•
- ç®¡ç†å¯¹è±¡çŠ¶æ€å’Œè½¬æ¢
- å®ç°æ¾è€¦åˆçš„é€šä¿¡æœºåˆ¶

### 1.2 æ ¸å¿ƒé—®é¢˜

è¡Œä¸ºå‹æ¨¡å¼è§£å†³çš„æ ¸å¿ƒé—®é¢˜åŒ…æ‹¬ï¼š

1. **å¯¹è±¡è€¦åˆ**ï¼šå¯¹è±¡é—´ç´§å¯†è€¦åˆå¯¼è‡´ç³»ç»ŸåƒµåŒ–
2. **èŒè´£åˆ†é…**ï¼šå¯¹è±¡èŒè´£ä¸æ¸…æ™°æˆ–åˆ†é…ä¸å½“
3. **çŠ¶æ€ç®¡ç†**ï¼šå¤æ‚çŠ¶æ€è½¬æ¢éš¾ä»¥ç®¡ç†
4. **ç®—æ³•é€‰æ‹©**ï¼šè¿è¡Œæ—¶ç®—æ³•é€‰æ‹©æœºåˆ¶

### 1.3 è®¾è®¡åŸåˆ™

è¡Œä¸ºå‹æ¨¡å¼éµå¾ªä»¥ä¸‹è®¾è®¡åŸåˆ™ï¼š

- **æ¾è€¦åˆ**ï¼šå‡å°‘å¯¹è±¡é—´çš„ä¾èµ–å…³ç³»
- **å•ä¸€èŒè´£**ï¼šæ¯ä¸ªå¯¹è±¡åªè´Ÿè´£ä¸€ä¸ªèŒè´£
- **å¼€é—­åŸåˆ™**ï¼šå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­
- **ä¾èµ–å€’ç½®**ï¼šä¾èµ–æŠ½è±¡è€Œéå…·ä½“å®ç°

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ¨¡å¼ç»“æ„å½¢å¼åŒ–

**å®šä¹‰ 2.1** (è¡Œä¸ºå‹æ¨¡å¼ç»“æ„)
è¡Œä¸ºå‹æ¨¡å¼å¯ä»¥å½¢å¼åŒ–ä¸ºä¸ƒå…ƒç»„ï¼š

$$\text{BehavioralPattern} = (O, M, S, R, \mathcal{H}, \mathcal{S}, \mathcal{C})$$

å…¶ä¸­ï¼š
- $O$ æ˜¯å¯¹è±¡é›†åˆ (Object Set)
- $M$ æ˜¯æ¶ˆæ¯é›†åˆ (Message Set)
- $S$ æ˜¯çŠ¶æ€é›†åˆ (State Set)
- $R$ æ˜¯å…³ç³»é›†åˆ (Relation Set)
- $\mathcal{H}$ æ˜¯å¤„ç†å™¨é›†åˆ (Handler Set)
- $\mathcal{S}$ æ˜¯ç­–ç•¥é›†åˆ (Strategy Set)
- $\mathcal{C}$ æ˜¯å‘½ä»¤é›†åˆ (Command Set)

### 2.2 æ¶ˆæ¯ä¼ é€’å½¢å¼åŒ–

**å®šä¹‰ 2.2** (æ¶ˆæ¯ä¼ é€’)
æ¶ˆæ¯ä¼ é€’æ˜¯ä¸€ä¸ªä¸‰å…ƒå…³ç³»ï¼š

$$R_m \subseteq O \times M \times O$$

è¡¨ç¤ºä»æºå¯¹è±¡åˆ°ç›®æ ‡å¯¹è±¡çš„æ¶ˆæ¯ä¼ é€’ã€‚

**å®šç† 2.1** (æ¶ˆæ¯ä¼ é€’çš„ä¼ é€’æ€§)
æ¶ˆæ¯ä¼ é€’æ»¡è¶³ä¼ é€’æ€§ï¼š
$$\forall o_1, o_2, o_3 \in O, \forall m_1, m_2 \in M: (o_1, m_1, o_2) \in R_m \land (o_2, m_2, o_3) \in R_m \Rightarrow \exists m_3 \in M: (o_1, m_3, o_3) \in R_m$$

### 2.3 çŠ¶æ€è½¬æ¢å½¢å¼åŒ–

**å®šä¹‰ 2.3** (çŠ¶æ€è½¬æ¢)
çŠ¶æ€è½¬æ¢æ˜¯ä¸€ä¸ªæ˜ å°„ï¼š

$$\text{Transition}: S \times M \rightarrow S$$

è¡¨ç¤ºåœ¨æ¶ˆæ¯è§¦å‘ä¸‹çš„çŠ¶æ€è½¬æ¢ã€‚

**å®šç† 2.2** (çŠ¶æ€è½¬æ¢çš„ç¡®å®šæ€§)
çŠ¶æ€è½¬æ¢æ˜¯ç¡®å®šæ€§çš„ï¼š
$$\forall s \in S, \forall m \in M: \exists! s' \in S: \text{Transition}(s, m) = s'$$

## 3. æ¨¡å¼åˆ†ç±»ç†è®º

### 3.1 åˆ†ç±»ç»´åº¦

è¡Œä¸ºå‹æ¨¡å¼å¯ä»¥æŒ‰ä»¥ä¸‹ç»´åº¦åˆ†ç±»ï¼š

1. **äº¤äº’æ–¹å¼ç»´åº¦**
   - ç›´æ¥äº¤äº’ï¼šObserver, Command
   - é—´æ¥äº¤äº’ï¼šMediator, Chain of Responsibility
   - çŠ¶æ€äº¤äº’ï¼šState, Strategy

2. **èŒè´£ç»´åº¦**
   - ç®—æ³•èŒè´£ï¼šStrategy, Template Method
   - çŠ¶æ€èŒè´£ï¼šState, Memento
   - é€šä¿¡èŒè´£ï¼šObserver, Mediator

3. **æ§åˆ¶ç»´åº¦**
   - é›†ä¸­æ§åˆ¶ï¼šMediator, Command
   - åˆ†æ•£æ§åˆ¶ï¼šChain of Responsibility, Observer
   - çŠ¶æ€æ§åˆ¶ï¼šState, Strategy

### 3.2 åˆ†ç±»æ ‘ç»“æ„

```
è¡Œä¸ºå‹æ¨¡å¼
â”œâ”€â”€ é€šä¿¡ç±»
â”‚   â”œâ”€â”€ Observer
â”‚   â”œâ”€â”€ Mediator
â”‚   â””â”€â”€ Chain of Responsibility
â”œâ”€â”€ ç®—æ³•ç±»
â”‚   â”œâ”€â”€ Strategy
â”‚   â”œâ”€â”€ Template Method
â”‚   â””â”€â”€ Command
â””â”€â”€ çŠ¶æ€ç±»
    â”œâ”€â”€ State
    â”œâ”€â”€ Memento
    â””â”€â”€ Iterator
```

## 4. æ ¸å¿ƒæ¨¡å¼åˆ†æ

### 4.1 è§‚å¯Ÿè€…æ¨¡å¼

**å®šä¹‰ 4.1** (è§‚å¯Ÿè€…)
è§‚å¯Ÿè€…æ¨¡å¼å®šä¹‰å¯¹è±¡é—´çš„ä¸€å¯¹å¤šä¾èµ–å…³ç³»ï¼Œå½“ä¸€ä¸ªå¯¹è±¡çŠ¶æ€æ”¹å˜æ—¶ï¼Œæ‰€æœ‰ä¾èµ–è€…éƒ½å¾—åˆ°é€šçŸ¥ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{Observer} = (S, O, \text{Notify}, \text{Update})$$

å…¶ä¸­ï¼š
- $S$ æ˜¯ä¸»é¢˜é›†åˆ (Subject Set)
- $O$ æ˜¯è§‚å¯Ÿè€…é›†åˆ (Observer Set)
- $\text{Notify}$ æ˜¯é€šçŸ¥å‡½æ•°
- $\text{Update}$ æ˜¯æ›´æ–°å‡½æ•°

**å®šç† 4.1** (è§‚å¯Ÿè€…çš„é€šçŸ¥æ€§)
è§‚å¯Ÿè€…æ¨¡å¼ç¡®ä¿é€šçŸ¥ä¼ é€’ï¼š
$$\forall s \in S, \forall o \in O: \text{Notify}(s, o) \Rightarrow \text{Update}(o, s)$$

### 4.2 ç­–ç•¥æ¨¡å¼

**å®šä¹‰ 4.2** (ç­–ç•¥)
ç­–ç•¥æ¨¡å¼å®šä¹‰ä¸€ç³»åˆ—ç®—æ³•ï¼Œå°†æ¯ä¸€ä¸ªç®—æ³•å°è£…èµ·æ¥ï¼Œå¹¶ä½¿å®ƒä»¬å¯ä»¥äº’æ¢ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{Strategy} = (C, \mathcal{S}, \text{Execute}, \text{Select})$$

å…¶ä¸­ï¼š
- $C$ æ˜¯ä¸Šä¸‹æ–‡é›†åˆ (Context Set)
- $\mathcal{S}$ æ˜¯ç­–ç•¥é›†åˆ (Strategy Set)
- $\text{Execute}$ æ˜¯æ‰§è¡Œå‡½æ•°
- $\text{Select}$ æ˜¯é€‰æ‹©å‡½æ•°

**å®šç† 4.2** (ç­–ç•¥çš„å¯äº’æ¢æ€§)
ç­–ç•¥æ¨¡å¼æ”¯æŒç­–ç•¥äº’æ¢ï¼š
$$\forall c \in C, \forall s_1, s_2 \in \mathcal{S}: \text{Execute}(c, s_1) \equiv \text{Execute}(c, s_2)$$

### 4.3 å‘½ä»¤æ¨¡å¼

**å®šä¹‰ 4.3** (å‘½ä»¤)
å‘½ä»¤æ¨¡å¼å°†è¯·æ±‚å°è£…æˆå¯¹è±¡ï¼Œä»è€Œå¯ä»¥ç”¨ä¸åŒçš„è¯·æ±‚å¯¹å®¢æˆ·è¿›è¡Œå‚æ•°åŒ–ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{Command} = (I, R, \text{Execute}, \text{Undo})$$

å…¶ä¸­ï¼š
- $I$ æ˜¯è°ƒç”¨è€…é›†åˆ (Invoker Set)
- $R$ æ˜¯æ¥æ”¶è€…é›†åˆ (Receiver Set)
- $\text{Execute}$ æ˜¯æ‰§è¡Œå‡½æ•°
- $\text{Undo}$ æ˜¯æ’¤é”€å‡½æ•°

**å®šç† 4.3** (å‘½ä»¤çš„å¯æ’¤é”€æ€§)
å‘½ä»¤æ¨¡å¼æ”¯æŒæ“ä½œæ’¤é”€ï¼š
$$\forall c \in \text{Command}: \text{Execute}(c) \land \text{Undo}(c) \Rightarrow \text{OriginalState}$$

### 4.4 çŠ¶æ€æ¨¡å¼

**å®šä¹‰ 4.4** (çŠ¶æ€)
çŠ¶æ€æ¨¡å¼å…è®¸å¯¹è±¡åœ¨å…¶å†…éƒ¨çŠ¶æ€æ”¹å˜æ—¶æ”¹å˜å…¶è¡Œä¸ºã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{State} = (C, S, \text{Transition}, \text{Behavior})$$

å…¶ä¸­ï¼š
- $C$ æ˜¯ä¸Šä¸‹æ–‡é›†åˆ (Context Set)
- $S$ æ˜¯çŠ¶æ€é›†åˆ (State Set)
- $\text{Transition}$ æ˜¯çŠ¶æ€è½¬æ¢å‡½æ•°
- $\text{Behavior}$ æ˜¯è¡Œä¸ºå‡½æ•°

**å®šç† 4.4** (çŠ¶æ€çš„è¡Œä¸ºä¸€è‡´æ€§)
çŠ¶æ€æ¨¡å¼ç¡®ä¿è¡Œä¸ºä¸€è‡´æ€§ï¼š
$$\forall c \in C, \forall s \in S: \text{Behavior}(c, s) = \text{Behavior}(c, s)$$

### 4.5 ä¸­ä»‹è€…æ¨¡å¼

**å®šä¹‰ 4.5** (ä¸­ä»‹è€…)
ä¸­ä»‹è€…æ¨¡å¼ç”¨ä¸€ä¸ªä¸­ä»‹å¯¹è±¡æ¥å°è£…ä¸€ç³»åˆ—å¯¹è±¡äº¤äº’ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
$$\text{Mediator} = (C, M, \text{Coordinate}, \text{Communicate})$$

å…¶ä¸­ï¼š
- $C$ æ˜¯åŒäº‹é›†åˆ (Colleague Set)
- $M$ æ˜¯ä¸­ä»‹è€…é›†åˆ (Mediator Set)
- $\text{Coordinate}$ æ˜¯åè°ƒå‡½æ•°
- $\text{Communicate}$ æ˜¯é€šä¿¡å‡½æ•°

**å®šç† 4.5** (ä¸­ä»‹è€…çš„åè°ƒæ€§)
ä¸­ä»‹è€…æ¨¡å¼å®ç°åè°ƒé€šä¿¡ï¼š
$$\forall c_1, c_2 \in C, \forall m \in M: \text{Communicate}(c_1, c_2) = \text{Coordinate}(m, c_1, c_2)$$

## 5. å®ç°åŸç†

### 5.1 äº‹ä»¶é©±åŠ¨æœºåˆ¶

**å®šä¹‰ 5.1** (äº‹ä»¶é©±åŠ¨)
äº‹ä»¶é©±åŠ¨æ˜¯åŸºäºäº‹ä»¶å’Œäº‹ä»¶å¤„ç†å™¨çš„é€šä¿¡æœºåˆ¶ï¼š

$$\text{EventDriven} = (E, H, \text{Trigger}, \text{Handle})$$

å…¶ä¸­ï¼š
- $E$ æ˜¯äº‹ä»¶é›†åˆ
- $H$ æ˜¯å¤„ç†å™¨é›†åˆ
- $\text{Trigger}$ æ˜¯è§¦å‘å‡½æ•°
- $\text{Handle}$ æ˜¯å¤„ç†å‡½æ•°

### 5.2 å›è°ƒæœºåˆ¶

**å®šä¹‰ 5.2** (å›è°ƒ)
å›è°ƒæ˜¯å°†å‡½æ•°ä½œä¸ºå‚æ•°ä¼ é€’ç»™å…¶ä»–å‡½æ•°ï¼š

$$\text{Callback}: \text{Function} \times \text{Context} \rightarrow \text{Result}$$

### 5.3 çŠ¶æ€æœº

**å®šä¹‰ 5.3** (çŠ¶æ€æœº)
çŠ¶æ€æœºæ˜¯æè¿°çŠ¶æ€è½¬æ¢çš„æ•°å­¦æ¨¡å‹ï¼š

$$\text{StateMachine} = (S, \Sigma, \delta, s_0, F)$$

å…¶ä¸­ï¼š
- $S$ æ˜¯çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\delta$ æ˜¯è½¬æ¢å‡½æ•°
- $s_0$ æ˜¯åˆå§‹çŠ¶æ€
- $F$ æ˜¯æ¥å—çŠ¶æ€é›†åˆ

## 6. ä»£ç å®ç°

### 6.1 Rust å®ç°

```rust
// è§‚å¯Ÿè€…æ¨¡å¼å®ç°
pub trait Observer {
    fn update(&self, subject: &dyn Subject);
}

pub trait Subject {
    fn attach(&mut self, observer: Box<dyn Observer>);
    fn detach(&mut self, observer: &dyn Observer);
    fn notify(&self);
    fn get_state(&self) -> i32;
}

pub struct ConcreteSubject {
    observers: Vec<Box<dyn Observer>>,
    state: i32,
}

impl ConcreteSubject {
    pub fn new() -> Self {
        Self {
            observers: Vec::new(),
            state: 0,
        }
    }
    
    pub fn set_state(&mut self, state: i32) {
        self.state = state;
        self.notify();
    }
}

impl Subject for ConcreteSubject {
    fn attach(&mut self, observer: Box<dyn Observer>) {
        self.observers.push(observer);
    }
    
    fn detach(&mut self, observer: &dyn Observer) {
        self.observers.retain(|o| !std::ptr::eq(o.as_ref(), observer));
    }
    
    fn notify(&self) {
        for observer in &self.observers {
            observer.update(self);
        }
    }
    
    fn get_state(&self) -> i32 {
        self.state
    }
}

pub struct ConcreteObserverA {
    name: String,
}

impl ConcreteObserverA {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

impl Observer for ConcreteObserverA {
    fn update(&self, subject: &dyn Subject) {
        println!("Observer {}: Subject state changed to {}", 
                 self.name, subject.get_state());
    }
}

// ç­–ç•¥æ¨¡å¼å®ç°
pub trait Strategy {
    fn algorithm(&self) -> String;
}

pub struct ConcreteStrategyA;
pub struct ConcreteStrategyB;
pub struct ConcreteStrategyC;

impl Strategy for ConcreteStrategyA {
    fn algorithm(&self) -> String {
        "Strategy A".to_string()
    }
}

impl Strategy for ConcreteStrategyB {
    fn algorithm(&self) -> String {
        "Strategy B".to_string()
    }
}

impl Strategy for ConcreteStrategyC {
    fn algorithm(&self) -> String {
        "Strategy C".to_string()
    }
}

pub struct Context {
    strategy: Box<dyn Strategy>,
}

impl Context {
    pub fn new(strategy: Box<dyn Strategy>) -> Self {
        Self { strategy }
    }
    
    pub fn set_strategy(&mut self, strategy: Box<dyn Strategy>) {
        self.strategy = strategy;
    }
    
    pub fn execute_strategy(&self) -> String {
        self.strategy.algorithm()
    }
}

// å‘½ä»¤æ¨¡å¼å®ç°
pub trait Command {
    fn execute(&self);
    fn undo(&self);
}

pub struct Receiver;

impl Receiver {
    pub fn action(&self) {
        println!("Receiver: Performing action");
    }
    
    pub fn undo_action(&self) {
        println!("Receiver: Undoing action");
    }
}

pub struct ConcreteCommand {
    receiver: Receiver,
}

impl ConcreteCommand {
    pub fn new(receiver: Receiver) -> Self {
        Self { receiver }
    }
}

impl Command for ConcreteCommand {
    fn execute(&self) {
        self.receiver.action();
    }
    
    fn undo(&self) {
        self.receiver.undo_action();
    }
}

pub struct Invoker {
    commands: Vec<Box<dyn Command>>,
}

impl Invoker {
    pub fn new() -> Self {
        Self {
            commands: Vec::new(),
        }
    }
    
    pub fn add_command(&mut self, command: Box<dyn Command>) {
        self.commands.push(command);
    }
    
    pub fn execute_commands(&self) {
        for command in &self.commands {
            command.execute();
        }
    }
    
    pub fn undo_commands(&self) {
        for command in &self.commands {
            command.undo();
        }
    }
}

// çŠ¶æ€æ¨¡å¼å®ç°
pub trait State {
    fn handle(&self, context: &mut Context);
}

pub struct ConcreteStateA;
pub struct ConcreteStateB;

impl State for ConcreteStateA {
    fn handle(&self, context: &mut Context) {
        println!("State A: Handling request");
        context.set_state(Box::new(ConcreteStateB));
    }
}

impl State for ConcreteStateB {
    fn handle(&self, context: &mut Context) {
        println!("State B: Handling request");
        context.set_state(Box::new(ConcreteStateA));
    }
}

pub struct Context {
    state: Box<dyn State>,
}

impl Context {
    pub fn new() -> Self {
        Self {
            state: Box::new(ConcreteStateA),
        }
    }
    
    pub fn set_state(&mut self, state: Box<dyn State>) {
        self.state = state;
    }
    
    pub fn request(&mut self) {
        self.state.handle(self);
    }
}

// ä¸­ä»‹è€…æ¨¡å¼å®ç°
pub trait Colleague {
    fn set_mediator(&mut self, mediator: &dyn Mediator);
    fn send(&self, message: &str);
    fn receive(&self, message: &str);
}

pub trait Mediator {
    fn send(&self, message: &str, colleague: &dyn Colleague);
}

pub struct ConcreteMediator {
    colleagues: Vec<Box<dyn Colleague>>,
}

impl ConcreteMediator {
    pub fn new() -> Self {
        Self {
            colleagues: Vec::new(),
        }
    }
    
    pub fn add_colleague(&mut self, colleague: Box<dyn Colleague>) {
        self.colleagues.push(colleague);
    }
}

impl Mediator for ConcreteMediator {
    fn send(&self, message: &str, sender: &dyn Colleague) {
        for colleague in &self.colleagues {
            if !std::ptr::eq(colleague.as_ref(), sender) {
                colleague.receive(message);
            }
        }
    }
}

pub struct ConcreteColleagueA {
    mediator: Option<&'static dyn Mediator>,
    name: String,
}

impl ConcreteColleagueA {
    pub fn new(name: String) -> Self {
        Self {
            mediator: None,
            name,
        }
    }
}

impl Colleague for ConcreteColleagueA {
    fn set_mediator(&mut self, mediator: &dyn Mediator) {
        // In a real implementation, this would store the mediator reference
    }
    
    fn send(&self, message: &str) {
        if let Some(mediator) = self.mediator {
            mediator.send(message, self);
        }
    }
    
    fn receive(&self, message: &str) {
        println!("Colleague {} received: {}", self.name, message);
    }
}
```

### 6.2 Haskell å®ç°

```haskell
-- è§‚å¯Ÿè€…æ¨¡å¼
class Observer o where
    update :: o -> Subject -> IO ()

class Subject s where
    attach :: s -> Observer -> IO s
    detach :: s -> Observer -> IO s
    notify :: s -> IO ()
    getState :: s -> Int

data ConcreteSubject = ConcreteSubject [Observer] Int

instance Subject ConcreteSubject where
    attach (ConcreteSubject obs state) observer = 
        return $ ConcreteSubject (observer : obs) state
    detach (ConcreteSubject obs state) observer = 
        return $ ConcreteSubject (filter (/= observer) obs) state
    notify (ConcreteSubject obs _) = 
        mapM_ (\o -> update o (ConcreteSubject obs 0)) obs
    getState (ConcreteSubject _ state) = state

data ConcreteObserverA = ConcreteObserverA String

instance Observer ConcreteObserverA where
    update (ConcreteObserverA name) subject = 
        putStrLn $ "Observer " ++ name ++ ": Subject state changed to " ++ show (getState subject)

-- ç­–ç•¥æ¨¡å¼
class Strategy s where
    algorithm :: s -> String

data ConcreteStrategyA = ConcreteStrategyA
data ConcreteStrategyB = ConcreteStrategyB
data ConcreteStrategyC = ConcreteStrategyC

instance Strategy ConcreteStrategyA where
    algorithm _ = "Strategy A"

instance Strategy ConcreteStrategyB where
    algorithm _ = "Strategy B"

instance Strategy ConcreteStrategyC where
    algorithm _ = "Strategy C"

data Context s = Context s

executeStrategy :: Strategy s => Context s -> String
executeStrategy (Context strategy) = algorithm strategy

-- å‘½ä»¤æ¨¡å¼
class Command c where
    execute :: c -> IO ()
    undo :: c -> IO ()

data Receiver = Receiver

action :: Receiver -> IO ()
action _ = putStrLn "Receiver: Performing action"

undoAction :: Receiver -> IO ()
undoAction _ = putStrLn "Receiver: Undoing action"

data ConcreteCommand = ConcreteCommand Receiver

instance Command ConcreteCommand where
    execute (ConcreteCommand receiver) = action receiver
    undo (ConcreteCommand receiver) = undoAction receiver

data Invoker = Invoker [ConcreteCommand]

executeCommands :: Invoker -> IO ()
executeCommands (Invoker commands) = mapM_ execute commands

undoCommands :: Invoker -> IO ()
undoCommands (Invoker commands) = mapM_ undo commands

-- çŠ¶æ€æ¨¡å¼
class State s where
    handle :: s -> Context -> Context

data ConcreteStateA = ConcreteStateA
data ConcreteStateB = ConcreteStateB

instance State ConcreteStateA where
    handle _ context = context -- In real implementation, would change state

instance State ConcreteStateB where
    handle _ context = context -- In real implementation, would change state

data Context = Context String -- Simplified for Haskell

request :: Context -> Context
request context = context -- In real implementation, would call state.handle
```

## 7. åº”ç”¨ç¤ºä¾‹

### 7.1 è‚¡ç¥¨å¸‚åœºè§‚å¯Ÿè€…æ¨¡å¼

```rust
// è‚¡ç¥¨å¸‚åœºè§‚å¯Ÿè€…æ¨¡å¼ç¤ºä¾‹
pub trait Observer {
    fn update(&self, stock_name: &str, price: f64);
}

pub trait Subject {
    fn attach(&mut self, observer: Box<dyn Observer>);
    fn detach(&mut self, observer: &dyn Observer);
    fn notify(&self);
    fn set_price(&mut self, price: f64);
}

pub struct Stock {
    name: String,
    price: f64,
    observers: Vec<Box<dyn Observer>>,
}

impl Stock {
    pub fn new(name: String, initial_price: f64) -> Self {
        Self {
            name,
            price: initial_price,
            observers: Vec::new(),
        }
    }
}

impl Subject for Stock {
    fn attach(&mut self, observer: Box<dyn Observer>) {
        self.observers.push(observer);
    }
    
    fn detach(&mut self, observer: &dyn Observer) {
        self.observers.retain(|o| !std::ptr::eq(o.as_ref(), observer));
    }
    
    fn notify(&self) {
        for observer in &self.observers {
            observer.update(&self.name, self.price);
        }
    }
    
    fn set_price(&mut self, price: f64) {
        self.price = price;
        self.notify();
    }
}

pub struct Investor {
    name: String,
}

impl Investor {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

impl Observer for Investor {
    fn update(&self, stock_name: &str, price: f64) {
        println!("Investor {}: {} stock price is now ${:.2}", 
                 self.name, stock_name, price);
    }
}

pub struct StockBroker {
    name: String,
}

impl StockBroker {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

impl Observer for StockBroker {
    fn update(&self, stock_name: &str, price: f64) {
        println!("Broker {}: {} stock price changed to ${:.2}", 
                 self.name, stock_name, price);
    }
}

// ä½¿ç”¨ç¤ºä¾‹
pub fn stock_market_example() {
    let mut apple_stock = Stock::new("Apple".to_string(), 150.0);
    
    let investor1 = Box::new(Investor::new("John".to_string()));
    let investor2 = Box::new(Investor::new("Jane".to_string()));
    let broker = Box::new(StockBroker::new("Smith".to_string()));
    
    apple_stock.attach(investor1);
    apple_stock.attach(investor2);
    apple_stock.attach(broker);
    
    apple_stock.set_price(155.0);
    apple_stock.set_price(160.0);
}
```

### 7.2 æ”¯ä»˜ç­–ç•¥æ¨¡å¼

```rust
// æ”¯ä»˜ç­–ç•¥æ¨¡å¼ç¤ºä¾‹
pub trait PaymentStrategy {
    fn pay(&self, amount: f64) -> String;
}

pub struct CreditCardPayment {
    card_number: String,
    cvv: String,
}

impl CreditCardPayment {
    pub fn new(card_number: String, cvv: String) -> Self {
        Self { card_number, cvv }
    }
}

impl PaymentStrategy for CreditCardPayment {
    fn pay(&self, amount: f64) -> String {
        format!("Paid ${:.2} using Credit Card ending in {}", 
                amount, &self.card_number[self.card_number.len()-4..])
    }
}

pub struct PayPalPayment {
    email: String,
}

impl PayPalPayment {
    pub fn new(email: String) -> Self {
        Self { email }
    }
}

impl PaymentStrategy for PayPalPayment {
    fn pay(&self, amount: f64) -> String {
        format!("Paid ${:.2} using PayPal account {}", amount, self.email)
    }
}

pub struct BitcoinPayment {
    wallet_address: String,
}

impl BitcoinPayment {
    pub fn new(wallet_address: String) -> Self {
        Self { wallet_address }
    }
}

impl PaymentStrategy for BitcoinPayment {
    fn pay(&self, amount: f64) -> String {
        format!("Paid ${:.2} using Bitcoin wallet {}", amount, self.wallet_address)
    }
}

pub struct ShoppingCart {
    items: Vec<(String, f64)>,
    payment_strategy: Option<Box<dyn PaymentStrategy>>,
}

impl ShoppingCart {
    pub fn new() -> Self {
        Self {
            items: Vec::new(),
            payment_strategy: None,
        }
    }
    
    pub fn add_item(&mut self, name: String, price: f64) {
        self.items.push((name, price));
    }
    
    pub fn set_payment_strategy(&mut self, strategy: Box<dyn PaymentStrategy>) {
        self.payment_strategy = Some(strategy);
    }
    
    pub fn checkout(&self) -> String {
        let total: f64 = self.items.iter().map(|(_, price)| price).sum();
        
        if let Some(strategy) = &self.payment_strategy {
            strategy.pay(total)
        } else {
            "No payment strategy set".to_string()
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
pub fn payment_example() {
    let mut cart = ShoppingCart::new();
    cart.add_item("Laptop".to_string(), 999.99);
    cart.add_item("Mouse".to_string(), 29.99);
    
    // ä½¿ç”¨ä¿¡ç”¨å¡æ”¯ä»˜
    let credit_card = Box::new(CreditCardPayment::new(
        "1234567890123456".to_string(), 
        "123".to_string()
    ));
    cart.set_payment_strategy(credit_card);
    println!("{}", cart.checkout());
    
    // ä½¿ç”¨PayPalæ”¯ä»˜
    let paypal = Box::new(PayPalPayment::new(
        "user@example.com".to_string()
    ));
    cart.set_payment_strategy(paypal);
    println!("{}", cart.checkout());
    
    // ä½¿ç”¨æ¯”ç‰¹å¸æ”¯ä»˜
    let bitcoin = Box::new(BitcoinPayment::new(
        "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa".to_string()
    ));
    cart.set_payment_strategy(bitcoin);
    println!("{}", cart.checkout());
}
```

## 8. ç›¸å…³ç†è®º

### 8.1 è®¾è®¡æ¨¡å¼ç†è®º

è¡Œä¸ºå‹æ¨¡å¼æ˜¯è®¾è®¡æ¨¡å¼ç†è®ºçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œä¸å…¶ä»–æ¨¡å¼ç±»å‹å¯†åˆ‡ç›¸å…³ï¼š

- **åˆ›å»ºå‹æ¨¡å¼**ï¼šå…³æ³¨å¯¹è±¡åˆ›å»ºæœºåˆ¶
- **ç»“æ„å‹æ¨¡å¼**ï¼šå…³æ³¨å¯¹è±¡ç»„åˆå’Œç±»ç»“æ„
- **æ¶æ„æ¨¡å¼**ï¼šå…³æ³¨ç³»ç»Ÿçº§çš„è®¾è®¡å†³ç­–

### 8.2 é¢å‘å¯¹è±¡ç†è®º

è¡Œä¸ºå‹æ¨¡å¼åŸºäºé¢å‘å¯¹è±¡çš„æ ¸å¿ƒæ¦‚å¿µï¼š

- **å¤šæ€**ï¼šæ”¯æŒè¿è¡Œæ—¶ç±»å‹ç»‘å®š
- **å°è£…**ï¼šéšè—å®ç°ç»†èŠ‚
- **ç»§æ‰¿**ï¼šé€šè¿‡ç»§æ‰¿å®ç°ä»£ç é‡ç”¨
- **ç»„åˆ**ï¼šé€šè¿‡å¯¹è±¡ç»„åˆå®ç°åŠŸèƒ½

### 8.3 è½¯ä»¶å·¥ç¨‹ç†è®º

è¡Œä¸ºå‹æ¨¡å¼ä½“ç°äº†è½¯ä»¶å·¥ç¨‹çš„é‡è¦åŸåˆ™ï¼š

- **æ¾è€¦åˆ**ï¼šå‡å°‘å¯¹è±¡é—´çš„ä¾èµ–å…³ç³»
- **é«˜å†…èš**ï¼šç›¸å…³åŠŸèƒ½èšé›†åœ¨ä¸€èµ·
- **å¯ç»´æŠ¤æ€§**ï¼šä¾¿äºä¿®æ”¹å’Œæ‰©å±•
- **å¯æµ‹è¯•æ€§**ï¼šä¾¿äºå•å…ƒæµ‹è¯•

## 9. å‚è€ƒæ–‡çŒ®

1. Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.

2. Freeman, E., Robson, E., Sierra, K., & Bates, B. (2004). Head First Design Patterns. O'Reilly Media.

3. Martin, R. C. (2000). Design Principles and Design Patterns. Object Mentor.

4. Liskov, B. (1987). Data Abstraction and Hierarchy. SIGPLAN Notices, 23(5), 17-34.

5. Meyer, B. (1988). Object-Oriented Software Construction. Prentice Hall.

---

**ç›¸å…³é“¾æ¥**ï¼š
- [07.3.1 åˆ›å»ºå‹æ¨¡å¼](../07.3.1_åˆ›å»ºå‹æ¨¡å¼.md)
- [07.3.2 ç»“æ„å‹æ¨¡å¼](../07.3.2_ç»“æ„å‹æ¨¡å¼.md)
- [07.3.4 æ¶æ„æ¨¡å¼](../07.3.4_æ¶æ„æ¨¡å¼.md)
- [08.1.1 è¯­è¨€è®¾è®¡åŸåˆ™](../../08_Programming_Language_Theory/08.1.1_è¯­è¨€è®¾è®¡åŸåˆ™.md)

- [07.3.4 æ¶æ„æ¨¡å¼](../07.3.4_æ¶æ„æ¨¡å¼.md)
- [08.1.1 è¯­è¨€è®¾è®¡åŸåˆ™](../../08_Programming_Language_Theory/08.1.1_è¯­è¨€è®¾è®¡åŸåˆ™.md)
