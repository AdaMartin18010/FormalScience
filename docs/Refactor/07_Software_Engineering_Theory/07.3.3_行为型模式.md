# 07.3.3 è¡Œä¸ºå‹æ¨¡å¼

## ğŸ“‹ æ¦‚è¿°

è¡Œä¸ºå‹æ¨¡å¼å…³æ³¨å¯¹è±¡ä¹‹é—´çš„é€šä¿¡ï¼Œå®ƒä»¬æè¿°å¯¹è±¡ä¹‹é—´å¦‚ä½•ç›¸äº’åä½œä»¥åŠå¦‚ä½•åˆ†é…èŒè´£ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦åˆ†æè¡Œä¸ºå‹æ¨¡å¼çš„ç†è®ºåŸºç¡€ã€æ•°å­¦å®šä¹‰ã€å®ç°åŸç†å’Œåº”ç”¨åœºæ™¯ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹è¡Œä¸ºå‹æ¨¡å¼çš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°å®Œæ•´çš„Rustä»£ç ç¤ºä¾‹
4. åˆ†ææ¨¡å¼é—´çš„å…³è”æ€§å’Œåº”ç”¨åœºæ™¯

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è¡Œä¸ºå‹æ¨¡å¼çš„å®šä¹‰

**å®šä¹‰ 1.1** (è¡Œä¸ºå‹æ¨¡å¼)
è¡Œä¸ºå‹æ¨¡å¼æ˜¯ä¸€ç±»è®¾è®¡æ¨¡å¼ï¼Œå®ƒä»¬å…³æ³¨å¯¹è±¡ä¹‹é—´çš„é€šä¿¡æœºåˆ¶ï¼Œå®šä¹‰å¯¹è±¡é—´å¦‚ä½•ç›¸äº’åä½œä»¥åŠå¦‚ä½•åˆ†é…èŒè´£ã€‚

**å®šä¹‰ 1.2** (å¯¹è±¡äº¤äº’é—®é¢˜)
ç»™å®šå¯¹è±¡é›†åˆ $O = \{o_1, o_2, \ldots, o_n\}$ å’Œäº¤äº’è§„åˆ™é›†åˆ $I = \{i_1, i_2, \ldots, i_m\}$ï¼Œå¯¹è±¡äº¤äº’é—®é¢˜æ˜¯åœ¨æ»¡è¶³æ‰€æœ‰äº¤äº’è§„åˆ™çš„æƒ…å†µä¸‹ï¼Œå®ç°å¯¹è±¡é—´çš„æœ‰æ•ˆé€šä¿¡ã€‚

### 1.2 è¡Œä¸ºå‹æ¨¡å¼çš„åˆ†ç±»

è¡Œä¸ºå‹æ¨¡å¼å¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ç±»ï¼š

1. **è´£ä»»é“¾æ¨¡å¼ (Chain of Responsibility Pattern)**
2. **å‘½ä»¤æ¨¡å¼ (Command Pattern)**
3. **è§£é‡Šå™¨æ¨¡å¼ (Interpreter Pattern)**
4. **è¿­ä»£å™¨æ¨¡å¼ (Iterator Pattern)**
5. **ä¸­ä»‹è€…æ¨¡å¼ (Mediator Pattern)**
6. **å¤‡å¿˜å½•æ¨¡å¼ (Memento Pattern)**
7. **è§‚å¯Ÿè€…æ¨¡å¼ (Observer Pattern)**
8. **çŠ¶æ€æ¨¡å¼ (State Pattern)**
9. **ç­–ç•¥æ¨¡å¼ (Strategy Pattern)**
10. **æ¨¡æ¿æ–¹æ³•æ¨¡å¼ (Template Method Pattern)**
11. **è®¿é—®è€…æ¨¡å¼ (Visitor Pattern)**

### 1.3 å½¢å¼åŒ–è¡¨ç¤º

**å®šä¹‰ 1.3** (è¡Œä¸ºå‹æ¨¡å¼çš„å½¢å¼åŒ–è¡¨ç¤º)
è¡Œä¸ºå‹æ¨¡å¼å¯ä»¥è¡¨ç¤ºä¸ºä¸ƒå…ƒç»„ $B = (O, I, C, M, S, T, P)$ï¼Œå…¶ä¸­ï¼š
- $O$ æ˜¯å¯¹è±¡é›†åˆ
- $I$ æ˜¯äº¤äº’è§„åˆ™é›†åˆ
- $C$ æ˜¯é€šä¿¡åè®®é›†åˆ
- $M$ æ˜¯æ¶ˆæ¯é›†åˆ
- $S$ æ˜¯çŠ¶æ€é›†åˆ
- $T$ æ˜¯è½¬æ¢å‡½æ•°é›†åˆ
- $P$ æ˜¯ä¼˜å…ˆçº§é›†åˆ

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 è´£ä»»é“¾æ¨¡å¼

**å®šä¹‰ 2.1** (è´£ä»»é“¾æ¨¡å¼)
è´£ä»»é“¾æ¨¡å¼ä¸ºè¯·æ±‚åˆ›å»ºä¸€ä¸ªæ¥æ”¶è€…å¯¹è±¡çš„é“¾ï¼Œæ²¿ç€è¿™æ¡é“¾ä¼ é€’è¯·æ±‚ç›´åˆ°è¢«å¤„ç†ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{ChainOfResponsibility}(H, R) = \{(h, r) \mid h \in H \land r \in R \land \text{canHandle}(h, r) \lor \text{hasNext}(h)\}$$

**å®šç† 2.1** (è´£ä»»é“¾çš„ä¼ é€’æ€§)
è´£ä»»é“¾æ¨¡å¼æ”¯æŒè¯·æ±‚çš„ä¼ é€’å¤„ç†ã€‚

**è¯æ˜**ï¼š
æ ¹æ®è´£ä»»é“¾çš„å®šä¹‰ï¼Œæ¯ä¸ªå¤„ç†å™¨è¦ä¹ˆå¤„ç†è¯·æ±‚ï¼Œè¦ä¹ˆä¼ é€’ç»™ä¸‹ä¸€ä¸ªå¤„ç†å™¨ï¼Œå› æ­¤æ”¯æŒä¼ é€’å¤„ç†ã€‚$\square$

### 2.2 å‘½ä»¤æ¨¡å¼

**å®šä¹‰ 2.2** (å‘½ä»¤æ¨¡å¼)
å‘½ä»¤æ¨¡å¼å°†è¯·æ±‚å°è£…æˆå¯¹è±¡ï¼Œä»è€Œå¯ä»¥ç”¨ä¸åŒçš„è¯·æ±‚å¯¹å®¢æˆ·è¿›è¡Œå‚æ•°åŒ–ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Command}(R, E) = \{(r, e) \mid r \in R \land e \in E \land \text{execute}(e, r)\}$$

**å®šç† 2.2** (å‘½ä»¤çš„å¯æ’¤é”€æ€§)
å‘½ä»¤æ¨¡å¼æ”¯æŒæ“ä½œçš„æ’¤é”€å’Œé‡åšã€‚

**è¯æ˜**ï¼š
å‘½ä»¤å¯¹è±¡å°è£…äº†æ“ä½œä¿¡æ¯ï¼Œå› æ­¤å¯ä»¥å®ç°æ’¤é”€å’Œé‡åšåŠŸèƒ½ã€‚$\square$

### 2.3 è§£é‡Šå™¨æ¨¡å¼

**å®šä¹‰ 2.3** (è§£é‡Šå™¨æ¨¡å¼)
è§£é‡Šå™¨æ¨¡å¼ä¸ºè¯­è¨€åˆ›å»ºè§£é‡Šå™¨ï¼Œå®šä¹‰è¯­è¨€çš„è¯­æ³•è¡¨ç¤ºä»¥åŠè§£é‡Šè¯¥è¯­æ³•çš„æ–¹æ³•ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Interpreter}(G, E) = \{(g, e) \mid g \in G \land e \in E \land \text{interpret}(e, g)\}$$

**å®šç† 2.3** (è§£é‡Šå™¨çš„é€’å½’æ€§)
è§£é‡Šå™¨æ¨¡å¼æ”¯æŒé€’å½’çš„è¯­æ³•è§£æã€‚

**è¯æ˜**ï¼š
è§£é‡Šå™¨å¯ä»¥é€’å½’åœ°è§£æå¤åˆè¡¨è¾¾å¼ï¼Œå› æ­¤æ”¯æŒå¤æ‚çš„è¯­æ³•ç»“æ„ã€‚$\square$

### 2.4 è¿­ä»£å™¨æ¨¡å¼

**å®šä¹‰ 2.4** (è¿­ä»£å™¨æ¨¡å¼)
è¿­ä»£å™¨æ¨¡å¼æä¾›ä¸€ç§æ–¹æ³•é¡ºåºè®¿é—®ä¸€ä¸ªèšåˆå¯¹è±¡ä¸­çš„å„ä¸ªå…ƒç´ ï¼Œè€Œåˆä¸æš´éœ²å…¶å†…éƒ¨çš„è¡¨ç¤ºã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Iterator}(A, I) = \{(a, i) \mid a \in A \land i \in I \land \text{hasNext}(i) \land \text{next}(i) \in A\}$$

**å®šç† 2.4** (è¿­ä»£å™¨çš„éå†æ€§)
è¿­ä»£å™¨æ¨¡å¼æ”¯æŒèšåˆå¯¹è±¡çš„å®Œæ•´éå†ã€‚

**è¯æ˜**ï¼š
è¿­ä»£å™¨æä¾›äº†éå†èšåˆå¯¹è±¡çš„æ ‡å‡†æ¥å£ï¼Œç¡®ä¿èƒ½å¤Ÿè®¿é—®æ‰€æœ‰å…ƒç´ ã€‚$\square$

### 2.5 ä¸­ä»‹è€…æ¨¡å¼

**å®šä¹‰ 2.5** (ä¸­ä»‹è€…æ¨¡å¼)
ä¸­ä»‹è€…æ¨¡å¼ç”¨ä¸€ä¸ªä¸­ä»‹å¯¹è±¡æ¥å°è£…ä¸€ç³»åˆ—å¯¹è±¡äº¤äº’ï¼Œä¸­ä»‹è€…ä½¿å„å¯¹è±¡ä¸éœ€è¦æ˜¾å¼åœ°ç›¸äº’å¼•ç”¨ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Mediator}(C, M) = \{(c, m) \mid c \in C \land m \in M \land \text{mediate}(m, c)\}$$

**å®šç† 2.5** (ä¸­ä»‹è€…çš„è§£è€¦æ€§)
ä¸­ä»‹è€…æ¨¡å¼é™ä½äº†å¯¹è±¡é—´çš„è€¦åˆåº¦ã€‚

**è¯æ˜**ï¼š
å¯¹è±¡é€šè¿‡ä¸­ä»‹è€…è¿›è¡Œé€šä¿¡ï¼Œè€Œä¸æ˜¯ç›´æ¥ç›¸äº’å¼•ç”¨ï¼Œå› æ­¤é™ä½äº†è€¦åˆåº¦ã€‚$\square$

### 2.6 å¤‡å¿˜å½•æ¨¡å¼

**å®šä¹‰ 2.6** (å¤‡å¿˜å½•æ¨¡å¼)
å¤‡å¿˜å½•æ¨¡å¼åœ¨ä¸ç ´åå°è£…çš„å‰æä¸‹ï¼Œæ•è·å¹¶å¤–éƒ¨åŒ–å¯¹è±¡çš„å†…éƒ¨çŠ¶æ€ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Memento}(O, S) = \{(o, s) \mid o \in O \land s \in S \land \text{save}(o, s) \land \text{restore}(o, s)\}$$

**å®šç† 2.6** (å¤‡å¿˜å½•çš„å°è£…æ€§)
å¤‡å¿˜å½•æ¨¡å¼ä¿æŒäº†å¯¹è±¡çš„å°è£…æ€§ã€‚

**è¯æ˜**ï¼š
å¤‡å¿˜å½•åªä¿å­˜çŠ¶æ€ä¿¡æ¯ï¼Œä¸æš´éœ²å¯¹è±¡çš„å†…éƒ¨ç»“æ„ï¼Œå› æ­¤ä¿æŒäº†å°è£…æ€§ã€‚$\square$

### 2.7 è§‚å¯Ÿè€…æ¨¡å¼

**å®šä¹‰ 2.7** (è§‚å¯Ÿè€…æ¨¡å¼)
è§‚å¯Ÿè€…æ¨¡å¼å®šä¹‰å¯¹è±¡é—´çš„ä¸€ç§ä¸€å¯¹å¤šçš„ä¾èµ–å…³ç³»ï¼Œå½“ä¸€ä¸ªå¯¹è±¡çš„çŠ¶æ€å‘ç”Ÿæ”¹å˜æ—¶ï¼Œæ‰€æœ‰ä¾èµ–äºå®ƒçš„å¯¹è±¡éƒ½å¾—åˆ°é€šçŸ¥ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Observer}(S, O) = \{(s, o) \mid s \in S \land o \in O \land \text{notify}(s, o)\}$$

**å®šç† 2.7** (è§‚å¯Ÿè€…çš„é€šçŸ¥æ€§)
è§‚å¯Ÿè€…æ¨¡å¼æ”¯æŒçŠ¶æ€å˜åŒ–çš„è‡ªåŠ¨é€šçŸ¥ã€‚

**è¯æ˜**ï¼š
å½“ä¸»é¢˜çŠ¶æ€æ”¹å˜æ—¶ï¼Œæ‰€æœ‰è§‚å¯Ÿè€…éƒ½ä¼šæ”¶åˆ°é€šçŸ¥ï¼Œå› æ­¤æ”¯æŒè‡ªåŠ¨é€šçŸ¥ã€‚$\square$

### 2.8 çŠ¶æ€æ¨¡å¼

**å®šä¹‰ 2.8** (çŠ¶æ€æ¨¡å¼)
çŠ¶æ€æ¨¡å¼å…è®¸å¯¹è±¡åœ¨å†…éƒ¨çŠ¶æ€æ”¹å˜æ—¶æ”¹å˜å®ƒçš„è¡Œä¸ºã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{State}(C, S) = \{(c, s) \mid c \in C \land s \in S \land \text{changeState}(c, s)\}$$

**å®šç† 2.8** (çŠ¶æ€çš„å¯å˜æ€§)
çŠ¶æ€æ¨¡å¼æ”¯æŒå¯¹è±¡è¡Œä¸ºçš„åŠ¨æ€å˜åŒ–ã€‚

**è¯æ˜**ï¼š
å¯¹è±¡çš„è¡Œä¸ºå–å†³äºå½“å‰çŠ¶æ€ï¼ŒçŠ¶æ€æ”¹å˜æ—¶è¡Œä¸ºä¹Ÿä¼šæ”¹å˜ã€‚$\square$

### 2.9 ç­–ç•¥æ¨¡å¼

**å®šä¹‰ 2.9** (ç­–ç•¥æ¨¡å¼)
ç­–ç•¥æ¨¡å¼å®šä¹‰ä¸€ç³»åˆ—çš„ç®—æ³•ï¼ŒæŠŠå®ƒä»¬å°è£…èµ·æ¥ï¼Œå¹¶ä¸”ä½¿å®ƒä»¬å¯ä»¥äº’ç›¸æ›¿æ¢ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Strategy}(C, A) = \{(c, a) \mid c \in C \land a \in A \land \text{execute}(c, a)\}$$

**å®šç† 2.9** (ç­–ç•¥çš„å¯æ›¿æ¢æ€§)
ç­–ç•¥æ¨¡å¼æ”¯æŒç®—æ³•çš„åŠ¨æ€æ›¿æ¢ã€‚

**è¯æ˜**ï¼š
ä¸åŒçš„ç­–ç•¥å®ç°äº†ç›¸åŒçš„æ¥å£ï¼Œå› æ­¤å¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€æ›¿æ¢ã€‚$\square$

### 2.10 æ¨¡æ¿æ–¹æ³•æ¨¡å¼

**å®šä¹‰ 2.10** (æ¨¡æ¿æ–¹æ³•æ¨¡å¼)
æ¨¡æ¿æ–¹æ³•æ¨¡å¼å®šä¹‰ä¸€ä¸ªæ“ä½œä¸­çš„ç®—æ³•çš„éª¨æ¶ï¼Œè€Œå°†ä¸€äº›æ­¥éª¤å»¶è¿Ÿåˆ°å­ç±»ä¸­ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{TemplateMethod}(A, S) = \{(a, s) \mid a \in A \land s \in S \land \text{template}(a, s)\}$$

**å®šç† 2.10** (æ¨¡æ¿çš„ç»§æ‰¿æ€§)
æ¨¡æ¿æ–¹æ³•æ¨¡å¼é€šè¿‡ç»§æ‰¿å®ç°ä»£ç å¤ç”¨ã€‚

**è¯æ˜**ï¼š
å­ç±»ç»§æ‰¿æ¨¡æ¿æ–¹æ³•ï¼Œå¹¶å®ç°ç‰¹å®šçš„æ­¥éª¤ï¼Œå› æ­¤å®ç°äº†ä»£ç å¤ç”¨ã€‚$\square$

### 2.11 è®¿é—®è€…æ¨¡å¼

**å®šä¹‰ 2.11** (è®¿é—®è€…æ¨¡å¼)
è®¿é—®è€…æ¨¡å¼è¡¨ç¤ºä¸€ä¸ªä½œç”¨äºæŸå¯¹è±¡ç»“æ„ä¸­çš„å„å…ƒç´ çš„æ“ä½œï¼Œå®ƒä½¿ä½ å¯ä»¥åœ¨ä¸æ”¹å˜å„å…ƒç´ çš„ç±»çš„å‰æä¸‹å®šä¹‰ä½œç”¨äºè¿™äº›å…ƒç´ çš„æ–°æ“ä½œã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Visitor}(E, V) = \{(e, v) \mid e \in E \land v \in V \land \text{visit}(v, e)\}$$

**å®šç† 2.11** (è®¿é—®è€…çš„æ‰©å±•æ€§)
è®¿é—®è€…æ¨¡å¼æ”¯æŒåœ¨ä¸ä¿®æ”¹å…ƒç´ ç±»çš„æƒ…å†µä¸‹æ·»åŠ æ–°æ“ä½œã€‚

**è¯æ˜**ï¼š
æ–°çš„è®¿é—®è€…å¯ä»¥å®ç°æ–°çš„æ“ä½œï¼Œè€Œä¸éœ€è¦ä¿®æ”¹å…ƒç´ ç±»çš„ç»“æ„ã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

### 3.1 è¡Œä¸ºå‹æ¨¡å¼çš„åŸºæœ¬æ€§è´¨

**å®šç† 3.1** (è¡Œä¸ºå‹æ¨¡å¼çš„ç»„åˆæ€§)
è¡Œä¸ºå‹æ¨¡å¼æ”¯æŒè¡Œä¸ºçš„ç»„åˆæ“ä½œã€‚

**è¯æ˜**ï¼š
è®¾ $B_1, B_2$ æ˜¯ä¸¤ä¸ªè¡Œä¸ºå‹æ¨¡å¼ï¼Œåˆ™å®ƒä»¬çš„ç»„åˆ $B_1 \circ B_2$ ä»ç„¶æ˜¯ä¸€ä¸ªè¡Œä¸ºå‹æ¨¡å¼ï¼Œå› ä¸ºï¼š
1. å¯¹è±¡é›†åˆçš„å¹¶é›†ä»ç„¶æ˜¯å¯¹è±¡é›†åˆ
2. äº¤äº’è§„åˆ™çš„å¹¶é›†ä»ç„¶æ˜¯äº¤äº’è§„åˆ™
3. é€šä¿¡åè®®å¯ä»¥ç»„åˆä½¿ç”¨
$\square$

**å®šç† 3.2** (è¡Œä¸ºå‹æ¨¡å¼çš„ä¼ é€’æ€§)
è¡Œä¸ºå‹æ¨¡å¼æ»¡è¶³ä¼ é€’æ€§ï¼šå¦‚æœå¯¹è±¡ $A$ ä¸ $B$ æœ‰äº¤äº’ï¼Œ$B$ ä¸ $C$ æœ‰äº¤äº’ï¼Œåˆ™ $A$ ä¸ $C$ å¯ä»¥é€šè¿‡ $B$ è¿›è¡Œé—´æ¥äº¤äº’ã€‚

**è¯æ˜**ï¼š
æ ¹æ®äº¤äº’çš„å®šä¹‰ï¼Œå¯ä»¥é€šè¿‡ä¸­ä»‹è€…æˆ–è´£ä»»é“¾å®ç°é—´æ¥äº¤äº’ã€‚$\square$

### 3.2 æ¨¡å¼é—´çš„å…³è”æ€§

**å®šç† 3.3** (å‘½ä»¤ä¸ç­–ç•¥çš„å…³ç³»)
å‘½ä»¤æ¨¡å¼å¯ä»¥æ¨¡æ‹Ÿç­–ç•¥æ¨¡å¼ã€‚

**è¯æ˜**ï¼š
è®¾ $C$ æ˜¯å‘½ä»¤ï¼Œ$S$ æ˜¯ç­–ç•¥ï¼Œåˆ™å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼æ¨¡æ‹Ÿï¼š
$$S(a) = C(\text{execute}, a)$$
$\square$

**å®šç† 3.4** (è§‚å¯Ÿè€…ä¸ä¸­ä»‹è€…çš„å…³ç³»)
ä¸­ä»‹è€…æ¨¡å¼å¯ä»¥æ¨¡æ‹Ÿè§‚å¯Ÿè€…æ¨¡å¼ã€‚

**è¯æ˜**ï¼š
ä¸­ä»‹è€…å¯ä»¥ä½œä¸ºè§‚å¯Ÿè€…å’Œä¸»é¢˜ä¹‹é—´çš„æ¡¥æ¢ï¼Œå®ç°é€šçŸ¥æœºåˆ¶ã€‚$\square$

## 4. ä»£ç å®ç°

### 4.1 è´£ä»»é“¾æ¨¡å¼å®ç°

```rust
/// è¯·æ±‚
pub struct Request {
    pub level: u32,
    pub description: String,
}

impl Request {
    pub fn new(level: u32, description: String) -> Self {
        Self { level, description }
    }
}

/// å¤„ç†å™¨ç‰¹å¾
pub trait Handler {
    fn set_next(&mut self, handler: Box<dyn Handler>);
    fn handle(&self, request: &Request) -> Option<String>;
}

/// æŠ½è±¡å¤„ç†å™¨
pub struct AbstractHandler {
    next: Option<Box<dyn Handler>>,
}

impl AbstractHandler {
    pub fn new() -> Self {
        Self { next: None }
    }
}

impl Handler for AbstractHandler {
    fn set_next(&mut self, handler: Box<dyn Handler>) {
        self.next = Some(handler);
    }
    
    fn handle(&self, request: &Request) -> Option<String> {
        if let Some(ref next) = self.next {
            next.handle(request)
        } else {
            None
        }
    }
}

/// å…·ä½“å¤„ç†å™¨A
pub struct ConcreteHandlerA {
    handler: AbstractHandler,
    level: u32,
}

impl ConcreteHandlerA {
    pub fn new(level: u32) -> Self {
        Self {
            handler: AbstractHandler::new(),
            level,
        }
    }
}

impl Handler for ConcreteHandlerA {
    fn set_next(&mut self, handler: Box<dyn Handler>) {
        self.handler.set_next(handler);
    }
    
    fn handle(&self, request: &Request) -> Option<String> {
        if request.level <= self.level {
            Some(format!("ConcreteHandlerA handled: {}", request.description))
        } else {
            self.handler.handle(request)
        }
    }
}

/// è´£ä»»é“¾çš„æ•°å­¦éªŒè¯
pub struct ChainOfResponsibilityValidator;

impl ChainOfResponsibilityValidator {
    /// éªŒè¯è´£ä»»é“¾çš„ä¼ é€’æ€§
    pub fn validate_transitivity(handler: &dyn Handler) -> bool {
        let request = Request::new(1, "test request".to_string());
        let result = handler.handle(&request);
        result.is_some()
    }
}
```

### 4.2 å‘½ä»¤æ¨¡å¼å®ç°

```rust
/// å‘½ä»¤ç‰¹å¾
pub trait Command {
    fn execute(&self) -> String;
    fn undo(&self) -> String;
}

/// æ¥æ”¶è€…
pub struct Receiver {
    name: String,
}

impl Receiver {
    pub fn new(name: String) -> Self {
        Self { name }
    }
    
    pub fn action(&self) -> String {
        format!("Receiver {} performed action", self.name)
    }
    
    pub fn undo_action(&self) -> String {
        format!("Receiver {} undid action", self.name)
    }
}

/// å…·ä½“å‘½ä»¤
pub struct ConcreteCommand {
    receiver: Receiver,
}

impl ConcreteCommand {
    pub fn new(receiver: Receiver) -> Self {
        Self { receiver }
    }
}

impl Command for ConcreteCommand {
    fn execute(&self) -> String {
        self.receiver.action()
    }
    
    fn undo(&self) -> String {
        self.receiver.undo_action()
    }
}

/// è°ƒç”¨è€…
pub struct Invoker {
    commands: Vec<Box<dyn Command>>,
}

impl Invoker {
    pub fn new() -> Self {
        Self {
            commands: Vec::new(),
        }
    }
    
    pub fn add_command(&mut self, command: Box<dyn Command>) {
        self.commands.push(command);
    }
    
    pub fn execute_all(&self) -> Vec<String> {
        self.commands.iter().map(|cmd| cmd.execute()).collect()
    }
    
    pub fn undo_all(&self) -> Vec<String> {
        self.commands.iter().map(|cmd| cmd.undo()).collect()
    }
}

/// å‘½ä»¤çš„æ•°å­¦éªŒè¯
pub struct CommandValidator;

impl CommandValidator {
    /// éªŒè¯å‘½ä»¤çš„å¯æ’¤é”€æ€§
    pub fn validate_undo(command: &dyn Command) -> bool {
        let execute_result = command.execute();
        let undo_result = command.undo();
        !execute_result.is_empty() && !undo_result.is_empty()
    }
}
```

### 4.3 è§‚å¯Ÿè€…æ¨¡å¼å®ç°

```rust
use std::collections::HashMap;

/// è§‚å¯Ÿè€…ç‰¹å¾
pub trait Observer {
    fn update(&self, subject: &Subject) -> String;
}

/// å…·ä½“è§‚å¯Ÿè€…A
pub struct ConcreteObserverA {
    name: String,
}

impl ConcreteObserverA {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

impl Observer for ConcreteObserverA {
    fn update(&self, subject: &Subject) -> String {
        format!("ObserverA {} received update: {}", self.name, subject.get_state())
    }
}

/// å…·ä½“è§‚å¯Ÿè€…B
pub struct ConcreteObserverB {
    name: String,
}

impl ConcreteObserverB {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

impl Observer for ConcreteObserverB {
    fn update(&self, subject: &Subject) -> String {
        format!("ObserverB {} received update: {}", self.name, subject.get_state())
    }
}

/// ä¸»é¢˜
pub struct Subject {
    observers: Vec<Box<dyn Observer>>,
    state: String,
}

impl Subject {
    pub fn new() -> Self {
        Self {
            observers: Vec::new(),
            state: String::new(),
        }
    }
    
    pub fn attach(&mut self, observer: Box<dyn Observer>) {
        self.observers.push(observer);
    }
    
    pub fn detach(&mut self, observer: &dyn Observer) {
        self.observers.retain(|o| !std::ptr::eq(o.as_ref(), observer));
    }
    
    pub fn notify(&self) -> Vec<String> {
        self.observers.iter().map(|o| o.update(self)).collect()
    }
    
    pub fn set_state(&mut self, state: String) {
        self.state = state;
    }
    
    pub fn get_state(&self) -> &str {
        &self.state
    }
}

/// è§‚å¯Ÿè€…çš„æ•°å­¦éªŒè¯
pub struct ObserverValidator;

impl ObserverValidator {
    /// éªŒè¯è§‚å¯Ÿè€…çš„é€šçŸ¥æ€§
    pub fn validate_notification(subject: &mut Subject) -> bool {
        let observer_a = ConcreteObserverA::new("A".to_string());
        let observer_b = ConcreteObserverB::new("B".to_string());
        
        subject.attach(Box::new(observer_a));
        subject.attach(Box::new(observer_b));
        
        subject.set_state("new state".to_string());
        let notifications = subject.notify();
        
        notifications.len() == 2
    }
}
```

### 4.4 ç­–ç•¥æ¨¡å¼å®ç°

```rust
/// ç­–ç•¥ç‰¹å¾
pub trait Strategy {
    fn execute(&self, data: &str) -> String;
}

/// å…·ä½“ç­–ç•¥A
pub struct ConcreteStrategyA;

impl Strategy for ConcreteStrategyA {
    fn execute(&self, data: &str) -> String {
        format!("StrategyA: {}", data.to_uppercase())
    }
}

/// å…·ä½“ç­–ç•¥B
pub struct ConcreteStrategyB;

impl Strategy for ConcreteStrategyB {
    fn execute(&self, data: &str) -> String {
        format!("StrategyB: {}", data.to_lowercase())
    }
}

/// ä¸Šä¸‹æ–‡
pub struct Context<S: Strategy> {
    strategy: S,
}

impl<S: Strategy> Context<S> {
    pub fn new(strategy: S) -> Self {
        Self { strategy }
    }
    
    pub fn execute_strategy(&self, data: &str) -> String {
        self.strategy.execute(data)
    }
}

/// ç­–ç•¥çš„æ•°å­¦éªŒè¯
pub struct StrategyValidator;

impl StrategyValidator {
    /// éªŒè¯ç­–ç•¥çš„å¯æ›¿æ¢æ€§
    pub fn validate_replaceability() -> bool {
        let strategy_a = ConcreteStrategyA;
        let strategy_b = ConcreteStrategyB;
        
        let context_a = Context::new(strategy_a);
        let context_b = Context::new(strategy_b);
        
        let result_a = context_a.execute_strategy("Hello");
        let result_b = context_b.execute_strategy("Hello");
        
        result_a != result_b
    }
}
```

### 4.5 çŠ¶æ€æ¨¡å¼å®ç°

```rust
/// çŠ¶æ€ç‰¹å¾
pub trait State {
    fn handle(&self, context: &mut Context) -> String;
}

/// å…·ä½“çŠ¶æ€A
pub struct ConcreteStateA;

impl State for ConcreteStateA {
    fn handle(&self, context: &mut Context) -> String {
        context.set_state(Box::new(ConcreteStateB));
        String::from("StateA handled, transitioning to StateB")
    }
}

/// å…·ä½“çŠ¶æ€B
pub struct ConcreteStateB;

impl State for ConcreteStateB {
    fn handle(&self, context: &mut Context) -> String {
        context.set_state(Box::new(ConcreteStateA));
        String::from("StateB handled, transitioning to StateA")
    }
}

/// ä¸Šä¸‹æ–‡
pub struct Context {
    state: Box<dyn State>,
}

impl Context {
    pub fn new() -> Self {
        Self {
            state: Box::new(ConcreteStateA),
        }
    }
    
    pub fn set_state(&mut self, state: Box<dyn State>) {
        self.state = state;
    }
    
    pub fn request(&mut self) -> String {
        self.state.handle(self)
    }
}

/// çŠ¶æ€çš„æ•°å­¦éªŒè¯
pub struct StateValidator;

impl StateValidator {
    /// éªŒè¯çŠ¶æ€çš„å¯å˜æ€§
    pub fn validate_mutability() -> bool {
        let mut context = Context::new();
        
        let result1 = context.request();
        let result2 = context.request();
        
        result1 != result2
    }
}
```

### 4.6 è®¿é—®è€…æ¨¡å¼å®ç°

```rust
/// å…ƒç´ ç‰¹å¾
pub trait Element {
    fn accept(&self, visitor: &dyn Visitor) -> String;
}

/// å…·ä½“å…ƒç´ A
pub struct ConcreteElementA {
    name: String,
}

impl ConcreteElementA {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

impl Element for ConcreteElementA {
    fn accept(&self, visitor: &dyn Visitor) -> String {
        visitor.visit_element_a(self)
    }
}

/// å…·ä½“å…ƒç´ B
pub struct ConcreteElementB {
    value: i32,
}

impl ConcreteElementB {
    pub fn new(value: i32) -> Self {
        Self { value }
    }
}

impl Element for ConcreteElementB {
    fn accept(&self, visitor: &dyn Visitor) -> String {
        visitor.visit_element_b(self)
    }
}

/// è®¿é—®è€…ç‰¹å¾
pub trait Visitor {
    fn visit_element_a(&self, element: &ConcreteElementA) -> String;
    fn visit_element_b(&self, element: &ConcreteElementB) -> String;
}

/// å…·ä½“è®¿é—®è€…A
pub struct ConcreteVisitorA;

impl Visitor for ConcreteVisitorA {
    fn visit_element_a(&self, element: &ConcreteElementA) -> String {
        format!("VisitorA visited ElementA: {}", element.name)
    }
    
    fn visit_element_b(&self, element: &ConcreteElementB) -> String {
        format!("VisitorA visited ElementB: {}", element.value)
    }
}

/// å…·ä½“è®¿é—®è€…B
pub struct ConcreteVisitorB;

impl Visitor for ConcreteVisitorB {
    fn visit_element_a(&self, element: &ConcreteElementA) -> String {
        format!("VisitorB processed ElementA: {}", element.name.to_uppercase())
    }
    
    fn visit_element_b(&self, element: &ConcreteElementB) -> String {
        format!("VisitorB processed ElementB: {}", element.value * 2)
    }
}

/// è®¿é—®è€…çš„æ•°å­¦éªŒè¯
pub struct VisitorValidator;

impl VisitorValidator {
    /// éªŒè¯è®¿é—®è€…çš„æ‰©å±•æ€§
    pub fn validate_extensibility() -> bool {
        let element_a = ConcreteElementA::new("test".to_string());
        let element_b = ConcreteElementB::new(5);
        
        let visitor_a = ConcreteVisitorA;
        let visitor_b = ConcreteVisitorB;
        
        let result_a1 = element_a.accept(&visitor_a);
        let result_a2 = element_a.accept(&visitor_b);
        let result_b1 = element_b.accept(&visitor_a);
        let result_b2 = element_b.accept(&visitor_b);
        
        result_a1 != result_a2 && result_b1 != result_b2
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 æ—¥å¿—å¤„ç†ç³»ç»Ÿçš„è´£ä»»é“¾æ¨¡å¼

```rust
/// æ—¥å¿—çº§åˆ«
#[derive(Debug, Clone, PartialEq)]
pub enum LogLevel {
    Info,
    Warning,
    Error,
    Critical,
}

/// æ—¥å¿—æ¶ˆæ¯
pub struct LogMessage {
    pub level: LogLevel,
    pub message: String,
    pub timestamp: String,
}

impl LogMessage {
    pub fn new(level: LogLevel, message: String) -> Self {
        Self {
            level,
            message,
            timestamp: chrono::Utc::now().to_rfc3339(),
        }
    }
}

/// æ—¥å¿—å¤„ç†å™¨ç‰¹å¾
pub trait LogHandler {
    fn set_next(&mut self, handler: Box<dyn LogHandler>);
    fn handle(&self, message: &LogMessage) -> Option<String>;
}

/// ä¿¡æ¯æ—¥å¿—å¤„ç†å™¨
pub struct InfoLogHandler {
    next: Option<Box<dyn LogHandler>>,
}

impl InfoLogHandler {
    pub fn new() -> Self {
        Self { next: None }
    }
}

impl LogHandler for InfoLogHandler {
    fn set_next(&mut self, handler: Box<dyn LogHandler>) {
        self.next = Some(handler);
    }
    
    fn handle(&self, message: &LogMessage) -> Option<String> {
        if message.level == LogLevel::Info {
            Some(format!("[INFO] {}: {}", message.timestamp, message.message))
        } else {
            self.next.as_ref().and_then(|h| h.handle(message))
        }
    }
}

/// é”™è¯¯æ—¥å¿—å¤„ç†å™¨
pub struct ErrorLogHandler {
    next: Option<Box<dyn LogHandler>>,
}

impl ErrorLogHandler {
    pub fn new() -> Self {
        Self { next: None }
    }
}

impl LogHandler for ErrorLogHandler {
    fn set_next(&mut self, handler: Box<dyn LogHandler>) {
        self.next = Some(handler);
    }
    
    fn handle(&self, message: &LogMessage) -> Option<String> {
        if message.level == LogLevel::Error || message.level == LogLevel::Critical {
            Some(format!("[ERROR] {}: {}", message.timestamp, message.message))
        } else {
            self.next.as_ref().and_then(|h| h.handle(message))
        }
    }
}
```

### 5.2 æ–‡æœ¬ç¼–è¾‘å™¨çš„å‘½ä»¤æ¨¡å¼

```rust
use std::collections::VecDeque;

/// æ–‡æ¡£
pub struct Document {
    content: String,
}

impl Document {
    pub fn new() -> Self {
        Self {
            content: String::new(),
        }
    }
    
    pub fn insert_text(&mut self, text: String, position: usize) {
        self.content.insert_str(position, &text);
    }
    
    pub fn delete_text(&mut self, start: usize, end: usize) -> String {
        let deleted = self.content[start..end].to_string();
        self.content.replace_range(start..end, "");
        deleted
    }
    
    pub fn get_content(&self) -> &str {
        &self.content
    }
}

/// å‘½ä»¤ç‰¹å¾
pub trait EditorCommand {
    fn execute(&mut self) -> String;
    fn undo(&mut self) -> String;
}

/// æ’å…¥æ–‡æœ¬å‘½ä»¤
pub struct InsertCommand {
    document: Document,
    text: String,
    position: usize,
}

impl InsertCommand {
    pub fn new(document: Document, text: String, position: usize) -> Self {
        Self {
            document,
            text,
            position,
        }
    }
}

impl EditorCommand for InsertCommand {
    fn execute(&mut self) -> String {
        self.document.insert_text(self.text.clone(), self.position);
        format!("Inserted '{}' at position {}", self.text, self.position)
    }
    
    fn undo(&mut self) -> String {
        let end = self.position + self.text.len();
        self.document.delete_text(self.position, end);
        format!("Undid insertion of '{}'", self.text)
    }
}

/// åˆ é™¤æ–‡æœ¬å‘½ä»¤
pub struct DeleteCommand {
    document: Document,
    start: usize,
    end: usize,
    deleted_text: Option<String>,
}

impl DeleteCommand {
    pub fn new(document: Document, start: usize, end: usize) -> Self {
        Self {
            document,
            start,
            end,
            deleted_text: None,
        }
    }
}

impl EditorCommand for DeleteCommand {
    fn execute(&mut self) -> String {
        let deleted = self.document.delete_text(self.start, self.end);
        self.deleted_text = Some(deleted.clone());
        format!("Deleted '{}'", deleted)
    }
    
    fn undo(&mut self) -> String {
        if let Some(ref text) = self.deleted_text {
            self.document.insert_text(text.clone(), self.start);
            format!("Undid deletion of '{}'", text)
        } else {
            String::from("Nothing to undo")
        }
    }
}

/// ç¼–è¾‘å™¨
pub struct Editor {
    document: Document,
    command_history: VecDeque<Box<dyn EditorCommand>>,
}

impl Editor {
    pub fn new() -> Self {
        Self {
            document: Document::new(),
            command_history: VecDeque::new(),
        }
    }
    
    pub fn execute_command(&mut self, command: Box<dyn EditorCommand>) -> String {
        let result = command.execute();
        self.command_history.push_back(command);
        result
    }
    
    pub fn undo_last_command(&mut self) -> Option<String> {
        self.command_history.pop_back().map(|mut cmd| cmd.undo())
    }
    
    pub fn get_content(&self) -> &str {
        self.document.get_content()
    }
}
```

### 5.3 è‚¡ç¥¨äº¤æ˜“ç³»ç»Ÿçš„è§‚å¯Ÿè€…æ¨¡å¼

```rust
use std::collections::HashMap;

/// è‚¡ç¥¨ä»·æ ¼
pub struct StockPrice {
    pub symbol: String,
    pub price: f64,
    pub change: f64,
}

impl StockPrice {
    pub fn new(symbol: String, price: f64, change: f64) -> Self {
        Self {
            symbol,
            price,
            change,
        }
    }
}

/// è‚¡ç¥¨è§‚å¯Ÿè€…ç‰¹å¾
pub trait StockObserver {
    fn update(&self, stock: &StockPrice) -> String;
}

/// ä»·æ ¼æé†’è§‚å¯Ÿè€…
pub struct PriceAlertObserver {
    symbol: String,
    threshold: f64,
}

impl PriceAlertObserver {
    pub fn new(symbol: String, threshold: f64) -> Self {
        Self { symbol, threshold }
    }
}

impl StockObserver for PriceAlertObserver {
    fn update(&self, stock: &StockPrice) -> String {
        if stock.symbol == self.symbol && stock.price > self.threshold {
            format!("ALERT: {} price {} exceeds threshold {}", 
                   stock.symbol, stock.price, self.threshold)
        } else {
            format!("Price update: {} = ${:.2}", stock.symbol, stock.price)
        }
    }
}

/// æŠ•èµ„ç»„åˆè§‚å¯Ÿè€…
pub struct PortfolioObserver {
    holdings: HashMap<String, i32>,
}

impl PortfolioObserver {
    pub fn new() -> Self {
        Self {
            holdings: HashMap::new(),
        }
    }
    
    pub fn add_holding(&mut self, symbol: String, shares: i32) {
        *self.holdings.entry(symbol).or_insert(0) += shares;
    }
}

impl StockObserver for PortfolioObserver {
    fn update(&self, stock: &StockPrice) -> String {
        if let Some(&shares) = self.holdings.get(&stock.symbol) {
            let value = shares as f64 * stock.price;
            format!("Portfolio: {} shares of {} worth ${:.2}", 
                   shares, stock.symbol, value)
        } else {
            format!("Portfolio: No holdings in {}", stock.symbol)
        }
    }
}

/// è‚¡ç¥¨ä¸»é¢˜
pub struct StockSubject {
    observers: Vec<Box<dyn StockObserver>>,
    stocks: HashMap<String, StockPrice>,
}

impl StockSubject {
    pub fn new() -> Self {
        Self {
            observers: Vec::new(),
            stocks: HashMap::new(),
        }
    }
    
    pub fn attach(&mut self, observer: Box<dyn StockObserver>) {
        self.observers.push(observer);
    }
    
    pub fn update_stock_price(&mut self, stock: StockPrice) -> Vec<String> {
        self.stocks.insert(stock.symbol.clone(), stock.clone());
        self.observers.iter().map(|o| o.update(&stock)).collect()
    }
    
    pub fn get_stock(&self, symbol: &str) -> Option<&StockPrice> {
        self.stocks.get(symbol)
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸è®¾è®¡æ¨¡å¼ç†è®ºçš„å…³ç³»

è¡Œä¸ºå‹æ¨¡å¼æ˜¯è®¾è®¡æ¨¡å¼ç†è®ºçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œä¸åˆ›å»ºå‹æ¨¡å¼å’Œç»“æ„å‹æ¨¡å¼å½¢æˆå®Œæ•´çš„æ¨¡å¼ä½“ç³»ã€‚

**å®šç† 6.1** (è¡Œä¸ºå‹æ¨¡å¼çš„ç‹¬ç«‹æ€§)
è¡Œä¸ºå‹æ¨¡å¼å¯ä»¥ç‹¬ç«‹äºåˆ›å»ºå‹æ¨¡å¼å’Œç»“æ„å‹æ¨¡å¼ä½¿ç”¨ã€‚

**è¯æ˜**ï¼š
è¡Œä¸ºå‹æ¨¡å¼å…³æ³¨å¯¹è±¡äº¤äº’ï¼Œä¸ä¾èµ–äºå¯¹è±¡çš„åˆ›å»ºæ–¹å¼æˆ–ç»“æ„æ–¹å¼ï¼Œå› æ­¤å¯ä»¥ç‹¬ç«‹ä½¿ç”¨ã€‚$\square$

### 6.2 ä¸é¢å‘å¯¹è±¡ç†è®ºçš„å…³ç³»

è¡Œä¸ºå‹æ¨¡å¼ä½“ç°äº†é¢å‘å¯¹è±¡ç†è®ºä¸­çš„å¤šæ€å’Œå°è£…åŸåˆ™ã€‚

**å®šç† 6.2** (å¤šæ€çš„åº”ç”¨)
è¡Œä¸ºå‹æ¨¡å¼é€šè¿‡å¤šæ€å®ç°äº†çµæ´»çš„å¯¹è±¡äº¤äº’ã€‚

**è¯æ˜**ï¼š
ä¸åŒçš„ç­–ç•¥ã€çŠ¶æ€ã€è§‚å¯Ÿè€…ç­‰éƒ½å¯ä»¥é€šè¿‡å¤šæ€æ¥å£è¿›è¡Œç»Ÿä¸€å¤„ç†ã€‚$\square$

### 6.3 ä¸è½¯ä»¶å·¥ç¨‹ç†è®ºçš„å…³ç³»

è¡Œä¸ºå‹æ¨¡å¼æ˜¯è½¯ä»¶å·¥ç¨‹ä¸­é‡è¦çš„è®¾è®¡åŸåˆ™ï¼Œä½“ç°äº†å¼€é—­åŸåˆ™å’Œä¾èµ–å€’ç½®åŸåˆ™ã€‚

**å®šç† 6.3** (å¼€é—­åŸåˆ™çš„ä½“ç°)
è¡Œä¸ºå‹æ¨¡å¼æ”¯æŒå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­ã€‚

**è¯æ˜**ï¼š
é€šè¿‡æ¥å£å’ŒæŠ½è±¡ç±»ï¼Œå¯ä»¥åœ¨ä¸ä¿®æ”¹ç°æœ‰ä»£ç çš„æƒ…å†µä¸‹æ·»åŠ æ–°çš„è¡Œä¸ºã€‚$\square$

## 7. å‚è€ƒæ–‡çŒ®

1. Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.
2. Freeman, E., Robson, E., Sierra, K., & Bates, B. (2004). Head First Design Patterns. O'Reilly Media.
3. Martin, R. C. (2000). Design Principles and Design Patterns. Object Mentor.
4. Liskov, B. (1987). Data Abstraction and Hierarchy. SIGPLAN Notices, 23(5), 17-34.
5. Meyer, B. (1988). Object-Oriented Software Construction. Prentice Hall.

---

**ç›¸å…³é“¾æ¥**ï¼š
- [07.3.1 åˆ›å»ºå‹æ¨¡å¼](../07.3.1_åˆ›å»ºå‹æ¨¡å¼.md)
- [07.3.2 ç»“æ„å‹æ¨¡å¼](../07.3.2_ç»“æ„å‹æ¨¡å¼.md)
- [07.3.4 æ¶æ„æ¨¡å¼](../07.3.4_æ¶æ„æ¨¡å¼.md)
- [07.2.1 æ¶æ„è®¾è®¡åŸåˆ™](../07.2.1_æ¶æ„è®¾è®¡åŸåˆ™.md)
- [07.2.2 æ¶æ„æ¨¡å¼ç†è®º](../07.2.2_æ¶æ„æ¨¡å¼ç†è®º.md) 