# å¾®æœåŠ¡æ¶æ„

## ğŸ“‹ æ¦‚è¿°

å¾®æœåŠ¡æ¶æ„æ˜¯ä¸€ç§å°†åº”ç”¨ç¨‹åºæ„å»ºä¸ºä¸€ç»„å°å‹ã€ç‹¬ç«‹æœåŠ¡çš„æ¶æ„é£æ ¼ï¼Œæ¯ä¸ªæœåŠ¡è¿è¡Œåœ¨è‡ªå·±çš„è¿›ç¨‹ä¸­ï¼Œé€šè¿‡è½»é‡çº§æœºåˆ¶è¿›è¡Œé€šä¿¡ã€‚æœ¬æ–‡æ¡£ç³»ç»Ÿæ€§åœ°ä»‹ç»å¾®æœåŠ¡æ¶æ„çš„ç†è®ºåŸºç¡€ã€è®¾è®¡åŸåˆ™ã€å®ç°æŠ€æœ¯å’Œå®é™…åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹å¾®æœåŠ¡æ¶æ„çš„ç†è®ºæ¡†æ¶**
2. **ç³»ç»ŸåŒ–æœåŠ¡æ‹†åˆ†å’Œè®¾è®¡åŸåˆ™**
3. **æä¾›é€šä¿¡å’Œæ•°æ®ç®¡ç†è§£å†³æ–¹æ¡ˆ**
4. **å±•ç¤ºå®é™…åº”ç”¨æ¡ˆä¾‹**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å¾®æœåŠ¡æ¶æ„çš„å®šä¹‰

å¾®æœåŠ¡æ¶æ„æ˜¯ä¸€ç§è½¯ä»¶æ¶æ„é£æ ¼ï¼Œå…¶æ ¸å¿ƒç‰¹å¾åŒ…æ‹¬ï¼š

- **æœåŠ¡æ‹†åˆ†**ï¼šå°†åº”ç”¨æ‹†åˆ†ä¸ºå°å‹ã€ç‹¬ç«‹çš„æœåŠ¡
- **ç‹¬ç«‹éƒ¨ç½²**ï¼šæ¯ä¸ªæœåŠ¡å¯ä»¥ç‹¬ç«‹éƒ¨ç½²å’Œæ‰©å±•
- **æŠ€æœ¯å¤šæ ·æ€§**ï¼šä¸åŒæœåŠ¡å¯ä»¥ä½¿ç”¨ä¸åŒæŠ€æœ¯æ ˆ
- **å»ä¸­å¿ƒåŒ–**ï¼šæ²¡æœ‰ç»Ÿä¸€çš„æ•°æ®å­˜å‚¨æˆ–æŠ€æœ¯æ ‡å‡†

### 1.2 å¾®æœåŠ¡è®¾è®¡åŸåˆ™

#### 1.2.1 å•ä¸€èŒè´£åŸåˆ™

```latex
å•ä¸€èŒè´£ = {
    ä¸šåŠ¡è¾¹ç•Œ: {é¢†åŸŸé©±åŠ¨è®¾è®¡, ä¸šåŠ¡èƒ½åŠ›, ä¸šåŠ¡åŠŸèƒ½},
    æŠ€æœ¯è¾¹ç•Œ: {æŠ€æœ¯æ ˆ, æ•°æ®å­˜å‚¨, éƒ¨ç½²ç¯å¢ƒ},
    å›¢é˜Ÿè¾¹ç•Œ: {å›¢é˜Ÿç»“æ„, æ‰€æœ‰æƒ, è´£ä»»åˆ’åˆ†}
}
```

#### 1.2.2 æœåŠ¡è‡ªæ²»åŸåˆ™

```latex
æœåŠ¡è‡ªæ²» = {
    ç‹¬ç«‹éƒ¨ç½²: {éƒ¨ç½²å•å…ƒ, ç‰ˆæœ¬ç®¡ç†, å›æ»šç­–ç•¥},
    ç‹¬ç«‹æ‰©å±•: {æ°´å¹³æ‰©å±•, å‚ç›´æ‰©å±•, èµ„æºåˆ†é…},
    ç‹¬ç«‹æ•…éšœ: {æ•…éšœéš”ç¦», å®¹é”™æœºåˆ¶, é™çº§ç­–ç•¥}
}
```

#### 1.2.3 æ•°æ®éš”ç¦»åŸåˆ™

```latex
æ•°æ®éš”ç¦» = {
    æ•°æ®åº“åˆ†ç¦»: {ç‹¬ç«‹æ•°æ®åº“, æ•°æ®æ‰€æœ‰æƒ, æ•°æ®ä¸€è‡´æ€§},
    æ•°æ®åŒæ­¥: {äº‹ä»¶é©±åŠ¨, æ¶ˆæ¯é˜Ÿåˆ—, æ•°æ®å¤åˆ¶},
    æ•°æ®æ²»ç†: {æ•°æ®è´¨é‡, æ•°æ®å®‰å…¨, æ•°æ®åˆè§„}
}
```

### 1.3 æœåŠ¡é€šä¿¡æ¨¡å¼

#### 1.3.1 åŒæ­¥é€šä¿¡

- **REST API**ï¼šåŸºäºHTTPçš„RESTfulæ¥å£
- **gRPC**ï¼šé«˜æ€§èƒ½çš„RPCæ¡†æ¶
- **GraphQL**ï¼šçµæ´»çš„æŸ¥è¯¢è¯­è¨€

#### 1.3.2 å¼‚æ­¥é€šä¿¡

- **æ¶ˆæ¯é˜Ÿåˆ—**ï¼šå¯é çš„æ¶ˆæ¯ä¼ é€’
- **äº‹ä»¶é©±åŠ¨**ï¼šåŸºäºäº‹ä»¶çš„æ¾è€¦åˆé€šä¿¡
- **å‘å¸ƒè®¢é˜…**ï¼šä¸€å¯¹å¤šçš„æ¶ˆæ¯å¹¿æ’­

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å¾®æœåŠ¡å®šä¹‰

**å®šä¹‰ 2.1** (å¾®æœåŠ¡):
å¾®æœåŠ¡æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $S = (I, P, D, C, E)$ï¼Œå…¶ä¸­ï¼š

```latex
S = (I, P, D, C, E)

å…¶ä¸­:
- I: æ¥å£é›†åˆ
- P: è¿›ç¨‹æ ‡è¯†
- D: æ•°æ®å­˜å‚¨
- C: é…ç½®ä¿¡æ¯
- E: ç¯å¢ƒä¾èµ–
```

### 2.2 æœåŠ¡ç»„åˆå®šä¹‰

**å®šä¹‰ 2.2** (æœåŠ¡ç»„åˆ):
å¾®æœåŠ¡ç³»ç»Ÿæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $MS = (S, R, T)$ï¼Œå…¶ä¸­ï¼š

```latex
MS = (S, R, T)

å…¶ä¸­:
- S: æœåŠ¡é›†åˆ
- R: æœåŠ¡å…³ç³»é›†åˆ
- T: æ‹“æ‰‘ç»“æ„
```

### 2.3 æœåŠ¡é€šä¿¡å®šä¹‰

**å®šä¹‰ 2.3** (æœåŠ¡é€šä¿¡):
æœåŠ¡é€šä¿¡æ˜¯ä¸€ä¸ªå››å…ƒç»„ $C = (S_1, S_2, P, M)$ï¼Œå…¶ä¸­ï¼š

```latex
C = (Sâ‚, Sâ‚‚, P, M)

å…¶ä¸­:
- Sâ‚: æºæœåŠ¡
- Sâ‚‚: ç›®æ ‡æœåŠ¡
- P: åè®®
- M: æ¶ˆæ¯æ ¼å¼
```

## 3. å®šç†ä¸è¯æ˜

### 3.1 æœåŠ¡ç‹¬ç«‹æ€§å®šç†

**å®šç† 3.1** (æœåŠ¡ç‹¬ç«‹æ€§):
å¦‚æœå¾®æœåŠ¡ $S_1$ å’Œ $S_2$ æ˜¯ç‹¬ç«‹çš„ï¼Œåˆ™ $S_1$ çš„æ•…éšœä¸ä¼šå½±å“ $S_2$ çš„æ­£å¸¸è¿è¡Œã€‚

**è¯æ˜**:
```latex
1. æœåŠ¡ç‹¬ç«‹æ€§å®šä¹‰: Independent(Sâ‚, Sâ‚‚) âŸº Â¬Depend(Sâ‚, Sâ‚‚)
2. æ•…éšœéš”ç¦»: Fault(Sâ‚) âŸ¹ Â¬Fault(Sâ‚‚)
3. å› æ­¤: Independent(Sâ‚, Sâ‚‚) âŸ¹ Fault(Sâ‚) âŸ¹ Â¬Fault(Sâ‚‚)
```

### 3.2 æœåŠ¡å¯æ‰©å±•æ€§å®šç†

**å®šç† 3.2** (æœåŠ¡å¯æ‰©å±•æ€§):
å¦‚æœå¾®æœåŠ¡ $S$ æ˜¯æ— çŠ¶æ€çš„ï¼Œåˆ™ $S$ å¯ä»¥æ°´å¹³æ‰©å±•ã€‚

**è¯æ˜**:
```latex
1. æ— çŠ¶æ€å®šä¹‰: Stateless(S) âŸº âˆ€Ïƒâ‚, Ïƒâ‚‚: State(S, Ïƒâ‚) = State(S, Ïƒâ‚‚)
2. æ°´å¹³æ‰©å±•: Scalable(S) âŸº âˆ€n: âˆƒSâ‚, ..., Sâ‚™: S = Sâ‚ âˆª ... âˆª Sâ‚™
3. å› æ­¤: Stateless(S) âŸ¹ Scalable(S)
```

### 3.3 æ•°æ®ä¸€è‡´æ€§å®šç†

**å®šç† 3.3** (æ•°æ®ä¸€è‡´æ€§):
åœ¨å¾®æœåŠ¡æ¶æ„ä¸­ï¼Œå¼ºä¸€è‡´æ€§éœ€è¦åˆ†å¸ƒå¼äº‹åŠ¡ï¼Œè€Œæœ€ç»ˆä¸€è‡´æ€§å¯ä»¥é€šè¿‡äº‹ä»¶é©±åŠ¨å®ç°ã€‚

**è¯æ˜**:
```latex
1. å¼ºä¸€è‡´æ€§: StrongConsistency âŸº âˆ€t: State(t) = State(t-1)
2. æœ€ç»ˆä¸€è‡´æ€§: EventualConsistency âŸº âˆƒt: State(t) = State(t-1)
3. åˆ†å¸ƒå¼äº‹åŠ¡: DistributedTransaction âŸ¹ StrongConsistency
4. äº‹ä»¶é©±åŠ¨: EventDriven âŸ¹ EventualConsistency
```

## 4. ä»£ç å®ç°

### 4.1 å¾®æœåŠ¡æ¡†æ¶ (Rust)

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc;
use serde::{Deserialize, Serialize};

/// å¾®æœåŠ¡å®šä¹‰
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Microservice {
    id: String,
    name: String,
    version: String,
    endpoints: Vec<Endpoint>,
    dependencies: Vec<String>,
    health_check: HealthCheck,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Endpoint {
    path: String,
    method: String,
    handler: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct HealthCheck {
    path: String,
    interval: u64,
    timeout: u64,
}

/// æœåŠ¡æ³¨å†Œè¡¨
struct ServiceRegistry {
    services: Arc<Mutex<HashMap<String, Vec<ServiceInstance>>>>,
}

impl ServiceRegistry {
    fn new() -> Self {
        Self {
            services: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    async fn register(&self, service: ServiceInstance) -> Result<(), String> {
        let mut services = self.services.lock().unwrap();
        let service_list = services.entry(service.service_name.clone()).or_insert_with(Vec::new);
        service_list.push(service);
        Ok(())
    }

    async fn discover(&self, service_name: &str) -> Result<Vec<ServiceInstance>, String> {
        let services = self.services.lock().unwrap();
        services.get(service_name)
            .cloned()
            .ok_or_else(|| "Service not found".to_string())
    }

    async fn deregister(&self, service_id: &str) -> Result<(), String> {
        let mut services = self.services.lock().unwrap();
        for service_list in services.values_mut() {
            service_list.retain(|s| s.id != service_id);
        }
        Ok(())
    }
}

/// æœåŠ¡å®ä¾‹
#[derive(Debug, Clone, Serialize, Deserialize)]
struct ServiceInstance {
    id: String,
    service_name: String,
    url: String,
    port: u16,
    health_status: HealthStatus,
    metadata: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}

/// è´Ÿè½½å‡è¡¡å™¨
trait LoadBalancer {
    fn select(&self, instances: &[ServiceInstance]) -> Result<ServiceInstance, String>;
}

/// è½®è¯¢è´Ÿè½½å‡è¡¡å™¨
struct RoundRobinBalancer {
    current_index: Arc<Mutex<usize>>,
}

impl RoundRobinBalancer {
    fn new() -> Self {
        Self {
            current_index: Arc::new(Mutex::new(0)),
        }
    }
}

impl LoadBalancer for RoundRobinBalancer {
    fn select(&self, instances: &[ServiceInstance]) -> Result<ServiceInstance, String> {
        if instances.is_empty() {
            return Err("No instances available".to_string());
        }

        let mut index = self.current_index.lock().unwrap();
        let selected = instances[*index % instances.len()].clone();
        *index += 1;
        Ok(selected)
    }
}

/// ç†”æ–­å™¨
struct CircuitBreaker {
    failure_threshold: usize,
    failure_count: Arc<Mutex<usize>>,
    state: Arc<Mutex<CircuitState>>,
    last_failure_time: Arc<Mutex<Option<std::time::Instant>>>,
}

#[derive(Debug, Clone)]
enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

impl CircuitBreaker {
    fn new(failure_threshold: usize) -> Self {
        Self {
            failure_threshold,
            failure_count: Arc::new(Mutex::new(0)),
            state: Arc::new(Mutex::new(CircuitState::Closed)),
            last_failure_time: Arc::new(Mutex::new(None)),
        }
    }

    async fn execute<F, T>(&self, operation: F) -> Result<T, String>
    where
        F: FnOnce() -> Result<T, String>,
    {
        let state = *self.state.lock().unwrap();
        
        match state {
            CircuitState::Open => {
                let last_failure = *self.last_failure_time.lock().unwrap();
                if let Some(failure_time) = last_failure {
                    if failure_time.elapsed().as_secs() > 60 {
                        // å°è¯•åŠå¼€çŠ¶æ€
                        *self.state.lock().unwrap() = CircuitState::HalfOpen;
                        self.execute(operation).await
                    } else {
                        Err("Circuit breaker is open".to_string())
                    }
                } else {
                    Err("Circuit breaker is open".to_string())
                }
            }
            CircuitState::HalfOpen => {
                match operation() {
                    Ok(result) => {
                        *self.state.lock().unwrap() = CircuitState::Closed;
                        *self.failure_count.lock().unwrap() = 0;
                        Ok(result)
                    }
                    Err(e) => {
                        *self.state.lock().unwrap() = CircuitState::Open;
                        *self.last_failure_time.lock().unwrap() = Some(std::time::Instant::now());
                        Err(e)
                    }
                }
            }
            CircuitState::Closed => {
                match operation() {
                    Ok(result) => Ok(result),
                    Err(e) => {
                        let mut count = self.failure_count.lock().unwrap();
                        *count += 1;
                        
                        if *count >= self.failure_threshold {
                            *self.state.lock().unwrap() = CircuitState::Open;
                            *self.last_failure_time.lock().unwrap() = Some(std::time::Instant::now());
                        }
                        Err(e)
                    }
                }
            }
        }
    }
}

/// æœåŠ¡å®¢æˆ·ç«¯
struct ServiceClient {
    registry: Arc<ServiceRegistry>,
    load_balancer: Arc<dyn LoadBalancer + Send + Sync>,
    circuit_breaker: Arc<CircuitBreaker>,
}

impl ServiceClient {
    fn new(registry: Arc<ServiceRegistry>, load_balancer: Arc<dyn LoadBalancer + Send + Sync>) -> Self {
        Self {
            registry,
            load_balancer,
            circuit_breaker: Arc::new(CircuitBreaker::new(5)),
        }
    }

    async fn call_service(&self, service_name: &str, request: &str) -> Result<String, String> {
        // æœåŠ¡å‘ç°
        let instances = self.registry.discover(service_name).await?;
        
        // è´Ÿè½½å‡è¡¡
        let instance = self.load_balancer.select(&instances)?;
        
        // ç†”æ–­å™¨ä¿æŠ¤
        self.circuit_breaker.execute(|| {
            // ç®€åŒ–çš„HTTPè°ƒç”¨
            Ok(format!("Response from {}: {}", instance.service_name, request))
        }).await
    }
}

/// æ¶ˆæ¯é˜Ÿåˆ—
struct MessageQueue {
    channels: Arc<Mutex<HashMap<String, mpsc::Sender<Message>>>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Message {
    id: String,
    topic: String,
    data: String,
    timestamp: std::time::SystemTime,
}

impl MessageQueue {
    fn new() -> Self {
        Self {
            channels: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    async fn publish(&self, topic: &str, message: Message) -> Result<(), String> {
        let channels = self.channels.lock().unwrap();
        if let Some(sender) = channels.get(topic) {
            sender.send(message).await.map_err(|e| e.to_string())?;
            Ok(())
        } else {
            Err("Topic not found".to_string())
        }
    }

    async fn subscribe(&self, topic: &str) -> Result<mpsc::Receiver<Message>, String> {
        let (sender, receiver) = mpsc::channel(100);
        let mut channels = self.channels.lock().unwrap();
        channels.insert(topic.to_string(), sender);
        Ok(receiver)
    }
}

/// å¾®æœåŠ¡ç³»ç»Ÿ
struct MicroserviceSystem {
    registry: Arc<ServiceRegistry>,
    client: Arc<ServiceClient>,
    message_queue: Arc<MessageQueue>,
}

impl MicroserviceSystem {
    fn new() -> Self {
        let registry = Arc::new(ServiceRegistry::new());
        let load_balancer = Arc::new(RoundRobinBalancer::new());
        let client = Arc::new(ServiceClient::new(Arc::clone(&registry), load_balancer));
        let message_queue = Arc::new(MessageQueue::new());

        Self {
            registry,
            client,
            message_queue,
        }
    }

    async fn start_service(&self, service: Microservice) -> Result<(), String> {
        let instance = ServiceInstance {
            id: format!("{}-{}", service.id, uuid::Uuid::new_v4()),
            service_name: service.name,
            url: "localhost".to_string(),
            port: 8080,
            health_status: HealthStatus::Healthy,
            metadata: HashMap::new(),
        };

        self.registry.register(instance).await
    }

    async fn call_service(&self, service_name: &str, request: &str) -> Result<String, String> {
        self.client.call_service(service_name, request).await
    }

    async fn publish_message(&self, topic: &str, data: &str) -> Result<(), String> {
        let message = Message {
            id: uuid::Uuid::new_v4().to_string(),
            topic: topic.to_string(),
            data: data.to_string(),
            timestamp: std::time::SystemTime::now(),
        };

        self.message_queue.publish(topic, message).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_service_registration() {
        let registry = ServiceRegistry::new();
        
        let instance = ServiceInstance {
            id: "test-1".to_string(),
            service_name: "user-service".to_string(),
            url: "localhost".to_string(),
            port: 8080,
            health_status: HealthStatus::Healthy,
            metadata: HashMap::new(),
        };

        registry.register(instance).await.unwrap();
        
        let instances = registry.discover("user-service").await.unwrap();
        assert_eq!(instances.len(), 1);
        assert_eq!(instances[0].service_name, "user-service");
    }

    #[tokio::test]
    async fn test_load_balancing() {
        let balancer = RoundRobinBalancer::new();
        
        let instances = vec![
            ServiceInstance {
                id: "1".to_string(),
                service_name: "service".to_string(),
                url: "localhost".to_string(),
                port: 8081,
                health_status: HealthStatus::Healthy,
                metadata: HashMap::new(),
            },
            ServiceInstance {
                id: "2".to_string(),
                service_name: "service".to_string(),
                url: "localhost".to_string(),
                port: 8082,
                health_status: HealthStatus::Healthy,
                metadata: HashMap::new(),
            },
        ];

        let selected1 = balancer.select(&instances).unwrap();
        let selected2 = balancer.select(&instances).unwrap();
        
        assert_ne!(selected1.id, selected2.id);
    }

    #[tokio::test]
    async fn test_circuit_breaker() {
        let breaker = CircuitBreaker::new(3);
        
        // æµ‹è¯•æˆåŠŸæ“ä½œ
        let result = breaker.execute(|| Ok("success")).await;
        assert!(result.is_ok());
        
        // æµ‹è¯•å¤±è´¥æ“ä½œ
        let result = breaker.execute(|| Err("failure".to_string())).await;
        assert!(result.is_err());
    }
}
```

### 4.2 äº‹ä»¶é©±åŠ¨å¾®æœåŠ¡ (Haskell)

```haskell
-- å¾®æœåŠ¡å®šä¹‰
data Microservice = Microservice {
    serviceId :: String,
    serviceName :: String,
    serviceVersion :: String,
    serviceEndpoints :: [Endpoint],
    serviceDependencies :: [String],
    serviceHealthCheck :: HealthCheck
} deriving (Show, Eq)

data Endpoint = Endpoint {
    endpointPath :: String,
    endpointMethod :: String,
    endpointHandler :: String -> IO String
} deriving (Show)

data HealthCheck = HealthCheck {
    healthPath :: String,
    healthInterval :: Int,
    healthTimeout :: Int
} deriving (Show, Eq)

-- æœåŠ¡å®ä¾‹
data ServiceInstance = ServiceInstance {
    instanceId :: String,
    instanceServiceName :: String,
    instanceUrl :: String,
    instancePort :: Int,
    instanceHealthStatus :: HealthStatus,
    instanceMetadata :: [(String, String)]
} deriving (Show, Eq)

data HealthStatus = 
    Healthy
  | Unhealthy
  | Unknown
  deriving (Show, Eq)

-- äº‹ä»¶å®šä¹‰
data Event = Event {
    eventId :: String,
    eventType :: String,
    eventData :: String,
    eventTimestamp :: UTCTime,
    eventSource :: String
} deriving (Show, Eq)

-- äº‹ä»¶æ€»çº¿
class EventBus a where
    publish :: a -> Event -> IO ()
    subscribe :: a -> String -> (Event -> IO ()) -> IO ()
    unsubscribe :: a -> String -> IO ()

-- ç®€å•äº‹ä»¶æ€»çº¿å®ç°
data SimpleEventBus = SimpleEventBus {
    subscribers :: IORef [(String, Event -> IO ())],
    eventQueue :: IORef [Event]
} deriving (Show)

instance EventBus SimpleEventBus where
    publish bus event = do
        queue <- readIORef (eventQueue bus)
        writeIORef (eventQueue bus) (event : queue)
        
        subs <- readIORef (subscribers bus)
        mapM_ (\(eventType, handler) -> 
            when (eventType == eventType event) $ handler event) subs
    
    subscribe bus eventType handler = do
        subs <- readIORef (subscribers bus)
        writeIORef (subscribers bus) ((eventType, handler) : subs)
    
    unsubscribe bus eventType = do
        subs <- readIORef (subscribers bus)
        writeIORef (subscribers bus) (filter (\(et, _) -> et /= eventType) subs)

-- æœåŠ¡æ³¨å†Œè¡¨
class ServiceRegistry a where
    register :: a -> ServiceInstance -> IO ()
    discover :: a -> String -> IO [ServiceInstance]
    deregister :: a -> String -> IO ()

data SimpleRegistry = SimpleRegistry {
    services :: IORef [(String, [ServiceInstance])]
} deriving (Show)

instance ServiceRegistry SimpleRegistry where
    register registry instance_ = do
        services_map <- readIORef (services registry)
        let service_name = instanceServiceName instance_
        let updated_map = updateServiceList services_map service_name instance_
        writeIORef (services registry) updated_map
    
    discover registry service_name = do
        services_map <- readIORef (services registry)
        return $ maybe [] id (lookup service_name services_map)
    
    deregister registry instance_id = do
        services_map <- readIORef (services registry)
        let updated_map = map (\(name, instances) -> 
            (name, filter (\i -> instanceId i /= instance_id) instances)) services_map
        writeIORef (services registry) updated_map

updateServiceList :: [(String, [ServiceInstance])] -> String -> ServiceInstance -> [(String, [ServiceInstance])]
updateServiceList services_map service_name instance_ =
    case lookup service_name services_map of
        Just instances -> (service_name, instance_ : instances) : filter (\(name, _) -> name /= service_name) services_map
        Nothing -> (service_name, [instance_]) : services_map

-- è´Ÿè½½å‡è¡¡å™¨
class LoadBalancer a where
    select :: a -> [ServiceInstance] -> IO ServiceInstance

data RoundRobinBalancer = RoundRobinBalancer {
    currentIndex :: IORef Int
} deriving (Show)

instance LoadBalancer RoundRobinBalancer where
    select balancer instances = do
        if null instances
        then error "No instances available"
        else do
            index <- readIORef (currentIndex balancer)
            let selected = instances !! (index `mod` length instances)
            writeIORef (currentIndex balancer) (index + 1)
            return selected

-- ç†”æ–­å™¨
data CircuitBreaker = CircuitBreaker {
    failureThreshold :: Int,
    failureCount :: IORef Int,
    state :: IORef CircuitState,
    lastFailureTime :: IORef (Maybe UTCTime)
} deriving (Show)

data CircuitState = 
    Closed
  | Open
  | HalfOpen
  deriving (Show, Eq)

executeWithCircuitBreaker :: CircuitBreaker -> IO a -> IO (Either String a)
executeWithCircuitBreaker breaker operation = do
    currentState <- readIORef (state breaker)
    
    case currentState of
        Open -> do
            lastFailure <- readIORef (lastFailureTime breaker)
            currentTime <- getCurrentTime
            
            case lastFailure of
                Just failureTime -> do
                    let timeDiff = diffUTCTime currentTime failureTime
                    if timeDiff > 60 -- 60ç§’åå°è¯•åŠå¼€
                    then do
                        writeIORef (state breaker) HalfOpen
                        executeWithCircuitBreaker breaker operation
                    else
                        return $ Left "Circuit breaker is open"
                Nothing ->
                    return $ Left "Circuit breaker is open"
        
        HalfOpen -> do
            result <- try operation
            case result of
                Left _ -> do
                    writeIORef (state breaker) Open
                    writeIORef (lastFailureTime breaker) (Just =<< getCurrentTime)
                    return $ Left "Circuit breaker opened"
                Right value -> do
                    writeIORef (state breaker) Closed
                    writeIORef (failureCount breaker) 0
                    return $ Right value
        
        Closed -> do
            result <- try operation
            case result of
                Left _ -> do
                    count <- readIORef (failureCount breaker)
                    writeIORef (failureCount breaker) (count + 1)
                    
                    if count + 1 >= failureThreshold breaker
                    then do
                        writeIORef (state breaker) Open
                        writeIORef (lastFailureTime breaker) (Just =<< getCurrentTime)
                        return $ Left "Circuit breaker opened"
                    else
                        return $ Left "Operation failed"
                Right value ->
                    return $ Right value

-- å¾®æœåŠ¡å®¢æˆ·ç«¯
data ServiceClient = ServiceClient {
    clientRegistry :: SimpleRegistry,
    clientLoadBalancer :: RoundRobinBalancer,
    clientCircuitBreaker :: CircuitBreaker
} deriving (Show)

callService :: ServiceClient -> String -> String -> IO (Either String String)
callService client service_name request = do
    -- æœåŠ¡å‘ç°
    instances <- discover (clientRegistry client) service_name
    
    if null instances
    then return $ Left "Service not found"
    else do
        -- è´Ÿè½½å‡è¡¡
        selected_instance <- select (clientLoadBalancer client) instances
        
        -- ç†”æ–­å™¨ä¿æŠ¤
        executeWithCircuitBreaker (clientCircuitBreaker client) $ do
            -- ç®€åŒ–çš„æœåŠ¡è°ƒç”¨
            return $ "Response from " ++ instanceServiceName selected_instance ++ ": " ++ request

-- å¾®æœåŠ¡ç³»ç»Ÿ
data MicroserviceSystem = MicroserviceSystem {
    systemRegistry :: SimpleRegistry,
    systemClient :: ServiceClient,
    systemEventBus :: SimpleEventBus
} deriving (Show)

createMicroserviceSystem :: IO MicroserviceSystem
createMicroserviceSystem = do
    registry <- SimpleRegistry <$> newIORef []
    balancer <- RoundRobinBalancer <$> newIORef 0
    breaker <- CircuitBreaker 5 <$> newIORef 0 <*> newIORef Closed <*> newIORef Nothing
    client <- return $ ServiceClient registry balancer breaker
    event_bus <- SimpleEventBus <$> newIORef [] <*> newIORef []
    
    return $ MicroserviceSystem registry client event_bus

-- ç¤ºä¾‹æœåŠ¡
createUserService :: IO Microservice
createUserService = do
    let endpoints = [
            Endpoint {
                endpointPath = "/users",
                endpointMethod = "GET",
                endpointHandler = \request -> return $ "User data: " ++ request
            }
        ]
    
    return $ Microservice {
        serviceId = "user-service-1",
        serviceName = "user-service",
        serviceVersion = "1.0.0",
        serviceEndpoints = endpoints,
        serviceDependencies = [],
        serviceHealthCheck = HealthCheck "/health" 30 5
    }

-- æµ‹è¯•
testMicroserviceSystem :: IO ()
testMicroserviceSystem = do
    system <- createMicroserviceSystem
    
    -- åˆ›å»ºæœåŠ¡å®ä¾‹
    let instance = ServiceInstance {
        instanceId = "user-1",
        instanceServiceName = "user-service",
        instanceUrl = "localhost",
        instancePort = 8080,
        instanceHealthStatus = Healthy,
        instanceMetadata = []
    }
    
    -- æ³¨å†ŒæœåŠ¡
    register (systemRegistry system) instance
    
    -- è°ƒç”¨æœåŠ¡
    result <- callService (systemClient system) "user-service" "get_user_123"
    print result
    
    -- å‘å¸ƒäº‹ä»¶
    current_time <- getCurrentTime
    let event = Event {
        eventId = "event-1",
        eventType = "user_created",
        eventData = "user_123",
        eventTimestamp = current_time,
        eventSource = "user-service"
    }
    
    publish (systemEventBus system) event
    putStrLn "Event published"
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç”µå•†å¾®æœåŠ¡ç³»ç»Ÿ

```rust
/// ç”µå•†å¾®æœåŠ¡ç³»ç»Ÿ
#[derive(Debug, Clone)]
struct ECommerceMicroservices {
    user_service: Arc<UserService>,
    product_service: Arc<ProductService>,
    order_service: Arc<OrderService>,
    payment_service: Arc<PaymentService>,
    inventory_service: Arc<InventoryService>,
}

impl ECommerceMicroservices {
    fn new() -> Self {
        let user_service = Arc::new(UserService::new());
        let product_service = Arc::new(ProductService::new());
        let order_service = Arc::new(OrderService::new());
        let payment_service = Arc::new(PaymentService::new());
        let inventory_service = Arc::new(InventoryService::new());

        Self {
            user_service,
            product_service,
            order_service,
            payment_service,
            inventory_service,
        }
    }

    async fn create_order(&self, user_id: &str, product_id: &str, quantity: i32) -> Result<String, String> {
        // 1. éªŒè¯ç”¨æˆ·
        let user = self.user_service.get_user(user_id).await?;
        
        // 2. è·å–äº§å“ä¿¡æ¯
        let product = self.product_service.get_product(product_id).await?;
        
        // 3. æ£€æŸ¥åº“å­˜
        let available = self.inventory_service.check_stock(product_id, quantity).await?;
        if !available {
            return Err("Insufficient stock".to_string());
        }
        
        // 4. åˆ›å»ºè®¢å•
        let order = self.order_service.create_order(user_id, product_id, quantity).await?;
        
        // 5. å¤„ç†æ”¯ä»˜
        let payment = self.payment_service.process_payment(&order).await?;
        
        // 6. æ›´æ–°åº“å­˜
        self.inventory_service.update_stock(product_id, quantity).await?;
        
        Ok(format!("Order created: {}", order))
    }
}

/// ç”¨æˆ·æœåŠ¡
struct UserService {
    users: Arc<Mutex<HashMap<String, User>>>,
}

#[derive(Debug, Clone)]
struct User {
    id: String,
    name: String,
    email: String,
    status: UserStatus,
}

#[derive(Debug, Clone)]
enum UserStatus {
    Active,
    Inactive,
    Suspended,
}

impl UserService {
    fn new() -> Self {
        Self {
            users: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    async fn get_user(&self, user_id: &str) -> Result<User, String> {
        let users = self.users.lock().unwrap();
        users.get(user_id)
            .cloned()
            .ok_or_else(|| "User not found".to_string())
    }

    async fn create_user(&self, name: &str, email: &str) -> Result<User, String> {
        let user = User {
            id: uuid::Uuid::new_v4().to_string(),
            name: name.to_string(),
            email: email.to_string(),
            status: UserStatus::Active,
        };

        let mut users = self.users.lock().unwrap();
        users.insert(user.id.clone(), user.clone());
        Ok(user)
    }
}

/// äº§å“æœåŠ¡
struct ProductService {
    products: Arc<Mutex<HashMap<String, Product>>>,
}

#[derive(Debug, Clone)]
struct Product {
    id: String,
    name: String,
    price: f64,
    category: String,
}

impl ProductService {
    fn new() -> Self {
        Self {
            products: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    async fn get_product(&self, product_id: &str) -> Result<Product, String> {
        let products = self.products.lock().unwrap();
        products.get(product_id)
            .cloned()
            .ok_or_else(|| "Product not found".to_string())
    }

    async fn create_product(&self, name: &str, price: f64, category: &str) -> Result<Product, String> {
        let product = Product {
            id: uuid::Uuid::new_v4().to_string(),
            name: name.to_string(),
            price,
            category: category.to_string(),
        };

        let mut products = self.products.lock().unwrap();
        products.insert(product.id.clone(), product.clone());
        Ok(product)
    }
}

/// è®¢å•æœåŠ¡
struct OrderService {
    orders: Arc<Mutex<HashMap<String, Order>>>,
}

#[derive(Debug, Clone)]
struct Order {
    id: String,
    user_id: String,
    product_id: String,
    quantity: i32,
    status: OrderStatus,
    created_at: std::time::SystemTime,
}

#[derive(Debug, Clone)]
enum OrderStatus {
    Pending,
    Confirmed,
    Shipped,
    Delivered,
    Cancelled,
}

impl OrderService {
    fn new() -> Self {
        Self {
            orders: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    async fn create_order(&self, user_id: &str, product_id: &str, quantity: i32) -> Result<Order, String> {
        let order = Order {
            id: uuid::Uuid::new_v4().to_string(),
            user_id: user_id.to_string(),
            product_id: product_id.to_string(),
            quantity,
            status: OrderStatus::Pending,
            created_at: std::time::SystemTime::now(),
        };

        let mut orders = self.orders.lock().unwrap();
        orders.insert(order.id.clone(), order.clone());
        Ok(order)
    }
}

/// æ”¯ä»˜æœåŠ¡
struct PaymentService {
    payments: Arc<Mutex<HashMap<String, Payment>>>,
}

#[derive(Debug, Clone)]
struct Payment {
    id: String,
    order_id: String,
    amount: f64,
    status: PaymentStatus,
}

#[derive(Debug, Clone)]
enum PaymentStatus {
    Pending,
    Completed,
    Failed,
    Refunded,
}

impl PaymentService {
    fn new() -> Self {
        Self {
            payments: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    async fn process_payment(&self, order: &Order) -> Result<Payment, String> {
        let payment = Payment {
            id: uuid::Uuid::new_v4().to_string(),
            order_id: order.id.clone(),
            amount: 100.0, // ç®€åŒ–è®¡ç®—
            status: PaymentStatus::Completed,
        };

        let mut payments = self.payments.lock().unwrap();
        payments.insert(payment.id.clone(), payment.clone());
        Ok(payment)
    }
}

/// åº“å­˜æœåŠ¡
struct InventoryService {
    inventory: Arc<Mutex<HashMap<String, i32>>>,
}

impl InventoryService {
    fn new() -> Self {
        Self {
            inventory: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    async fn check_stock(&self, product_id: &str, quantity: i32) -> Result<bool, String> {
        let inventory = self.inventory.lock().unwrap();
        let available = inventory.get(product_id).unwrap_or(&0);
        Ok(*available >= quantity)
    }

    async fn update_stock(&self, product_id: &str, quantity: i32) -> Result<(), String> {
        let mut inventory = self.inventory.lock().unwrap();
        let current = inventory.get(product_id).unwrap_or(&0);
        inventory.insert(product_id.to_string(), current - quantity);
        Ok(())
    }
}

#[cfg(test)]
mod ecommerce_tests {
    use super::*;

    #[tokio::test]
    async fn test_order_creation() {
        let system = ECommerceMicroservices::new();
        
        // åˆ›å»ºç”¨æˆ·
        let user = system.user_service.create_user("John Doe", "john@example.com").await.unwrap();
        
        // åˆ›å»ºäº§å“
        let product = system.product_service.create_product("Laptop", 999.99, "Electronics").await.unwrap();
        
        // åˆ›å»ºè®¢å•
        let result = system.create_order(&user.id, &product.id, 1).await;
        assert!(result.is_ok());
    }
}
```

### 5.2 äº‹ä»¶é©±åŠ¨è®¢å•å¤„ç†

```rust
/// äº‹ä»¶é©±åŠ¨è®¢å•å¤„ç†ç³»ç»Ÿ
#[derive(Debug, Clone)]
struct EventDrivenOrderSystem {
    event_bus: Arc<EventBus>,
    order_service: Arc<OrderService>,
    inventory_service: Arc<InventoryService>,
    payment_service: Arc<PaymentService>,
    notification_service: Arc<NotificationService>,
}

impl EventDrivenOrderSystem {
    fn new() -> Self {
        let event_bus = Arc::new(EventBus::new());
        let order_service = Arc::new(OrderService::new());
        let inventory_service = Arc::new(InventoryService::new());
        let payment_service = Arc::new(PaymentService::new());
        let notification_service = Arc::new(NotificationService::new());

        let system = Self {
            event_bus: Arc::clone(&event_bus),
            order_service: Arc::clone(&order_service),
            inventory_service: Arc::clone(&inventory_service),
            payment_service: Arc::clone(&payment_service),
            notification_service: Arc::clone(&notification_service),
        };

        // è®¾ç½®äº‹ä»¶å¤„ç†å™¨
        system.setup_event_handlers();
        system
    }

    fn setup_event_handlers(&self) {
        let event_bus = Arc::clone(&self.event_bus);
        let order_service = Arc::clone(&self.order_service);
        let inventory_service = Arc::clone(&self.inventory_service);
        let payment_service = Arc::clone(&self.payment_service);
        let notification_service = Arc::clone(&self.notification_service);

        // è®¢å•åˆ›å»ºäº‹ä»¶å¤„ç†å™¨
        event_bus.subscribe("order_created", move |event| {
            let order_id = event.data.clone();
            
            // æ£€æŸ¥åº“å­˜
            if let Ok(available) = inventory_service.check_stock_async(&order_id).await {
                if available {
                    event_bus.publish(Event {
                        event_type: "inventory_reserved".to_string(),
                        data: order_id,
                        timestamp: std::time::SystemTime::now(),
                    });
                } else {
                    event_bus.publish(Event {
                        event_type: "order_cancelled".to_string(),
                        data: order_id,
                        timestamp: std::time::SystemTime::now(),
                    });
                }
            }
        });

        // åº“å­˜é¢„ç•™äº‹ä»¶å¤„ç†å™¨
        event_bus.subscribe("inventory_reserved", move |event| {
            let order_id = event.data.clone();
            
            // å¤„ç†æ”¯ä»˜
            if let Ok(payment) = payment_service.process_payment_async(&order_id).await {
                if payment.status == PaymentStatus::Completed {
                    event_bus.publish(Event {
                        event_type: "payment_completed".to_string(),
                        data: order_id,
                        timestamp: std::time::SystemTime::now(),
                    });
                } else {
                    event_bus.publish(Event {
                        event_type: "payment_failed".to_string(),
                        data: order_id,
                        timestamp: std::time::SystemTime::now(),
                    });
                }
            }
        });

        // æ”¯ä»˜å®Œæˆäº‹ä»¶å¤„ç†å™¨
        event_bus.subscribe("payment_completed", move |event| {
            let order_id = event.data.clone();
            
            // å‘é€é€šçŸ¥
            notification_service.send_order_confirmation(&order_id);
            
            // æ›´æ–°è®¢å•çŠ¶æ€
            order_service.update_order_status(&order_id, OrderStatus::Confirmed);
        });
    }

    async fn create_order(&self, user_id: &str, product_id: &str, quantity: i32) -> Result<String, String> {
        // åˆ›å»ºè®¢å•
        let order = self.order_service.create_order(user_id, product_id, quantity).await?;
        
        // å‘å¸ƒè®¢å•åˆ›å»ºäº‹ä»¶
        self.event_bus.publish(Event {
            event_type: "order_created".to_string(),
            data: order.id.clone(),
            timestamp: std::time::SystemTime::now(),
        });

        Ok(order.id)
    }
}

/// äº‹ä»¶æ€»çº¿
struct EventBus {
    handlers: Arc<Mutex<HashMap<String, Vec<Box<dyn Fn(Event) + Send + Sync>>>>>,
}

#[derive(Debug, Clone)]
struct Event {
    event_type: String,
    data: String,
    timestamp: std::time::SystemTime,
}

impl EventBus {
    fn new() -> Self {
        Self {
            handlers: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    fn subscribe<F>(&self, event_type: &str, handler: F)
    where
        F: Fn(Event) + Send + Sync + 'static,
    {
        let mut handlers = self.handlers.lock().unwrap();
        let event_handlers = handlers.entry(event_type.to_string()).or_insert_with(Vec::new);
        event_handlers.push(Box::new(handler));
    }

    fn publish(&self, event: Event) {
        let handlers = self.handlers.lock().unwrap();
        if let Some(event_handlers) = handlers.get(&event.event_type) {
            for handler in event_handlers {
                handler(event.clone());
            }
        }
    }
}

/// é€šçŸ¥æœåŠ¡
struct NotificationService;

impl NotificationService {
    fn new() -> Self {
        Self
    }

    fn send_order_confirmation(&self, order_id: &str) {
        println!("Sending order confirmation for order: {}", order_id);
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸åˆ†å¸ƒå¼ç³»ç»Ÿçš„å…³ç³»

- **åˆ†å¸ƒå¼æ¶æ„**ï¼šå¾®æœåŠ¡æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿçš„ä¸€ç§å®ç°
- **ä¸€è‡´æ€§æ¨¡å‹**ï¼šå¾®æœåŠ¡éœ€è¦å¤„ç†åˆ†å¸ƒå¼ä¸€è‡´æ€§
- **æ•…éšœå¤„ç†**ï¼šå¾®æœåŠ¡éœ€è¦å®¹é”™å’Œæ•…éšœæ¢å¤æœºåˆ¶

### 6.2 ä¸äº‹ä»¶é©±åŠ¨æ¶æ„çš„å…³ç³»

- **äº‹ä»¶é€šä¿¡**ï¼šå¾®æœåŠ¡å¯ä»¥é€šè¿‡äº‹ä»¶è¿›è¡Œé€šä¿¡
- **æ¾è€¦åˆ**ï¼šäº‹ä»¶é©±åŠ¨å®ç°æœåŠ¡é—´çš„æ¾è€¦åˆ
- **å¼‚æ­¥å¤„ç†**ï¼šäº‹ä»¶æ”¯æŒå¼‚æ­¥å¤„ç†æ¨¡å¼

### 6.3 ä¸å®¹å™¨æŠ€æœ¯çš„å…³ç³»

- **å®¹å™¨åŒ–éƒ¨ç½²**ï¼šå¾®æœåŠ¡é€šå¸¸éƒ¨ç½²åœ¨å®¹å™¨ä¸­
- **ç¼–æ’ç®¡ç†**ï¼šéœ€è¦å®¹å™¨ç¼–æ’å·¥å…·ç®¡ç†æœåŠ¡
- **èµ„æºéš”ç¦»**ï¼šå®¹å™¨æä¾›èµ„æºéš”ç¦»

### 6.4 ä¸APIç½‘å…³çš„å…³ç³»

- **ç»Ÿä¸€å…¥å£**ï¼šAPIç½‘å…³ä½œä¸ºå¾®æœåŠ¡çš„ç»Ÿä¸€å…¥å£
- **è·¯ç”±è½¬å‘**ï¼šç½‘å…³è´Ÿè´£è¯·æ±‚è·¯ç”±å’Œè½¬å‘
- **å®‰å…¨æ§åˆ¶**ï¼šç½‘å…³æä¾›è®¤è¯å’Œæˆæƒ

## 7. å‚è€ƒæ–‡çŒ®

1. Newman, S. (2021). Building microservices: Designing fine-grained systems. O'Reilly Media.
2. Richardson, C. (2018). Microservices patterns: With examples in Java. Manning Publications.
3. Fowler, M. (2014). Microservices. Martin Fowler's Blog.
4. Evans, E. (2003). Domain-driven design: Tackling complexity in the heart of software. Addison-Wesley.
5. Hohpe, G., & Woolf, B. (2003). Enterprise integration patterns: Designing, building, and deploying messaging solutions. Addison-Wesley.

---

**ç›¸å…³æ–‡æ¡£**:
- [è½¯ä»¶æ¶æ„è®¾è®¡åŸåˆ™](../02_Software_Architecture/01_Architecture_Design_Principles.md)
- [æ¶æ„æ¨¡å¼ç†è®º](../02_Software_Architecture/02_Architecture_Pattern_Theory.md)
- [äº‹ä»¶é©±åŠ¨æ¶æ„](../02_Software_Architecture/04_Event_Driven_Architecture.md)
- [åˆ†å¸ƒå¼ç³»ç»Ÿç†è®º](../06_Distributed_Systems_Theory/01_Distributed_Systems_Foundation.md) 