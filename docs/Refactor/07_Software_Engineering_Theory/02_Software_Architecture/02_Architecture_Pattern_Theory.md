# æ¶æ„æ¨¡å¼ç†è®º

## ğŸ“‹ æ¦‚è¿°

æ¶æ„æ¨¡å¼ç†è®ºæ˜¯è½¯ä»¶æ¶æ„è®¾è®¡çš„æ ¸å¿ƒç†è®ºï¼Œé€šè¿‡ç³»ç»ŸåŒ–çš„æ¨¡å¼åˆ†ç±»ã€è®¾è®¡åŸåˆ™å’Œç»„åˆæ–¹æ³•ï¼Œä¸ºå¤æ‚è½¯ä»¶ç³»ç»Ÿæä¾›å¯é‡ç”¨ã€å¯ç»´æŠ¤çš„æ¶æ„è§£å†³æ–¹æ¡ˆã€‚æœ¬æ–‡æ¡£ç³»ç»Ÿæ€§åœ°ä»‹ç»æ¶æ„æ¨¡å¼çš„ç†è®ºåŸºç¡€ã€åˆ†ç±»ä½“ç³»ã€è®¾è®¡åŸåˆ™å’Œå®é™…åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹æ¶æ„æ¨¡å¼çš„ç†è®ºæ¡†æ¶**
2. **ç³»ç»ŸåŒ–æ¨¡å¼åˆ†ç±»å’Œè®¾è®¡åŸåˆ™**
3. **æä¾›æ¨¡å¼ç»„åˆå’Œæ¼”åŒ–æ–¹æ³•**
4. **å±•ç¤ºå®é™…åº”ç”¨æ¡ˆä¾‹**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ¶æ„æ¨¡å¼çš„å®šä¹‰

æ¶æ„æ¨¡å¼æ˜¯ä¸€ç§åœ¨è½¯ä»¶æ¶æ„å±‚é¢è§£å†³ç‰¹å®šé—®é¢˜çš„å¯é‡ç”¨è§£å†³æ–¹æ¡ˆï¼Œå…¶æ ¸å¿ƒç‰¹å¾åŒ…æ‹¬ï¼š

- **é—®é¢˜å¯¼å‘**ï¼šé’ˆå¯¹ç‰¹å®šæ¶æ„é—®é¢˜
- **è§£å†³æ–¹æ¡ˆ**ï¼šæä¾›å®Œæ•´çš„è§£å†³æ¡†æ¶
- **å¯é‡ç”¨æ€§**ï¼šå¯åœ¨ä¸åŒç³»ç»Ÿä¸­åº”ç”¨
- **æŠ½è±¡å±‚æ¬¡**ï¼šå…³æ³¨ç³»ç»Ÿçº§ç»“æ„

### 1.2 æ¶æ„æ¨¡å¼åˆ†ç±»

#### 1.2.1 åˆ†å±‚æ¶æ„æ¨¡å¼

```latex
åˆ†å±‚æ¶æ„ = {
    è¡¨ç°å±‚: {ç”¨æˆ·ç•Œé¢, æ§åˆ¶å™¨, è§†å›¾},
    ä¸šåŠ¡å±‚: {ä¸šåŠ¡é€»è¾‘, æœåŠ¡, é¢†åŸŸæ¨¡å‹},
    æ•°æ®å±‚: {æ•°æ®è®¿é—®, æŒä¹…åŒ–, å­˜å‚¨},
    åŸºç¡€è®¾æ–½å±‚: {é€šä¿¡, å®‰å…¨, ç›‘æ§}
}
```

#### 1.2.2 å¾®æœåŠ¡æ¶æ„æ¨¡å¼

```latex
å¾®æœåŠ¡æ¶æ„ = {
    æœåŠ¡æ‹†åˆ†: {ä¸šåŠ¡è¾¹ç•Œ, æ•°æ®è¾¹ç•Œ, å›¢é˜Ÿè¾¹ç•Œ},
    æœåŠ¡é€šä¿¡: {åŒæ­¥é€šä¿¡, å¼‚æ­¥é€šä¿¡, äº‹ä»¶é©±åŠ¨},
    æœåŠ¡æ²»ç†: {æœåŠ¡å‘ç°, è´Ÿè½½å‡è¡¡, ç†”æ–­å™¨},
    æ•°æ®ç®¡ç†: {æ•°æ®ä¸€è‡´æ€§, åˆ†å¸ƒå¼äº‹åŠ¡, æ•°æ®åŒæ­¥}
}
```

#### 1.2.3 äº‹ä»¶é©±åŠ¨æ¶æ„æ¨¡å¼

```latex
äº‹ä»¶é©±åŠ¨æ¶æ„ = {
    äº‹ä»¶æº: {äº‹ä»¶ç”Ÿæˆ, äº‹ä»¶å­˜å‚¨, äº‹ä»¶æµ},
    äº‹ä»¶å¤„ç†: {äº‹ä»¶å¤„ç†å™¨, äº‹ä»¶è·¯ç”±, äº‹ä»¶èšåˆ},
    äº‹ä»¶å­˜å‚¨: {äº‹ä»¶æ—¥å¿—, äº‹ä»¶æ•°æ®åº“, æµå¤„ç†},
    äº‹ä»¶æ¶ˆè´¹: {æ¶ˆè´¹è€…, è®¢é˜…è€…, ååº”å™¨}
}
```

### 1.3 æ¶æ„è®¾è®¡åŸåˆ™

#### 1.3.1 å•ä¸€èŒè´£åŸåˆ™

- **ç»„ä»¶èŒè´£**ï¼šæ¯ä¸ªç»„ä»¶åªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½é¢†åŸŸ
- **æ¥å£åˆ†ç¦»**ï¼šæ¥å£åº”è¯¥å°è€Œä¸“æ³¨
- **æ¨¡å—åŒ–**ï¼šç³»ç»Ÿç”±ç‹¬ç«‹æ¨¡å—ç»„æˆ

#### 1.3.2 å¼€é—­åŸåˆ™

- **æ‰©å±•å¼€æ”¾**ï¼šå¯¹æ‰©å±•å¼€æ”¾
- **ä¿®æ”¹å°é—­**ï¼šå¯¹ä¿®æ”¹å°é—­
- **æŠ½è±¡è®¾è®¡**ï¼šä¾èµ–æŠ½è±¡è€Œéå…·ä½“å®ç°

#### 1.3.3 ä¾èµ–å€’ç½®åŸåˆ™

- **é«˜å±‚æ¨¡å—**ï¼šä¸ä¾èµ–ä½å±‚æ¨¡å—
- **æŠ½è±¡ä¾èµ–**ï¼šä¾èµ–æŠ½è±¡æ¥å£
- **ç»†èŠ‚æŠ½è±¡**ï¼šç»†èŠ‚ä¾èµ–æŠ½è±¡

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ¶æ„æ¨¡å¼å®šä¹‰

**å®šä¹‰ 2.1** (æ¶æ„æ¨¡å¼):
æ¶æ„æ¨¡å¼æ˜¯ä¸€ä¸ªå››å…ƒç»„ $P = (C, R, I, S)$ï¼Œå…¶ä¸­ï¼š

```latex
P = (C, R, I, S)

å…¶ä¸­:
- C: ç»„ä»¶é›†åˆ
- R: å…³ç³»é›†åˆ
- I: æ¥å£é›†åˆ
- S: çº¦æŸé›†åˆ
```

### 2.2 æ¨¡å¼å®ä¾‹åŒ–å®šä¹‰

**å®šä¹‰ 2.2** (æ¨¡å¼å®ä¾‹åŒ–):
æ¨¡å¼ $P$ çš„å®ä¾‹åŒ–æ˜¯ä¸€ä¸ªå‡½æ•° $I: P \to A$ï¼Œå…¶ä¸­ï¼š

```latex
I: P â†’ A

å…¶ä¸­:
- P: æ¶æ„æ¨¡å¼
- A: å…·ä½“æ¶æ„
- I: å®ä¾‹åŒ–å‡½æ•°
- ä¿æŒæ¨¡å¼è¯­ä¹‰
```

### 2.3 æ¨¡å¼ç»„åˆå®šä¹‰

**å®šä¹‰ 2.3** (æ¨¡å¼ç»„åˆ):
å¯¹äºæ¨¡å¼ $P_1$ å’Œ $P_2$ï¼Œå…¶ç»„åˆä¸ºï¼š

```latex
Pâ‚ âŠ• Pâ‚‚ = (Câ‚ âˆª Câ‚‚, Râ‚ âˆª Râ‚‚ âˆª Râ‚â‚‚, Iâ‚ âˆª Iâ‚‚, Sâ‚ âˆ§ Sâ‚‚)

å…¶ä¸­:
- Râ‚â‚‚: æ¨¡å¼é—´å…³ç³»
- Sâ‚ âˆ§ Sâ‚‚: çº¦æŸåˆå–
```

## 3. å®šç†ä¸è¯æ˜

### 3.1 æ¨¡å¼æ­£ç¡®æ€§å®šç†

**å®šç† 3.1** (æ¨¡å¼æ­£ç¡®æ€§):
å¦‚æœæ¶æ„æ¨¡å¼ $P$ æ˜¯æ­£ç¡®çš„ï¼Œåˆ™å…¶å®ä¾‹åŒ– $I(P)$ æ»¡è¶³è®¾è®¡ç›®æ ‡ã€‚

**è¯æ˜**:
```latex
1. æ¨¡å¼æ­£ç¡®æ€§: âˆ€P: Correct(P) âŸº âˆ€I: I(P) âŠ¨ Goals(P)
2. å®ä¾‹åŒ–ä¿æŒè¯­ä¹‰: I(P) â‰¡ P
3. å› æ­¤: I(P) âŠ¨ Goals(P)
4. å³å®ä¾‹åŒ–æ»¡è¶³è®¾è®¡ç›®æ ‡
```

### 3.2 æ¨¡å¼ç»„åˆå®šç†

**å®šç† 3.2** (æ¨¡å¼ç»„åˆ):
å¦‚æœæ¨¡å¼ $P_1$ å’Œ $P_2$ å…¼å®¹ï¼Œåˆ™ç»„åˆæ¨¡å¼ $P_1 \oplus P_2$ ä¿æŒå„è‡ªæ€§è´¨ã€‚

**è¯æ˜**:
```latex
1. æ¨¡å¼å…¼å®¹æ€§: Compatible(Pâ‚, Pâ‚‚) âŸº Â¬Conflict(Pâ‚, Pâ‚‚)
2. ç»„åˆä¿æŒæ€§è´¨: Properties(Pâ‚ âŠ• Pâ‚‚) = Properties(Pâ‚) âˆ© Properties(Pâ‚‚)
3. å› æ­¤: Pâ‚ âŠ• Pâ‚‚ ä¿æŒå„è‡ªæ€§è´¨
```

### 3.3 æ¨¡å¼æ¼”åŒ–å®šç†

**å®šç† 3.3** (æ¨¡å¼æ¼”åŒ–):
å¦‚æœæ¨¡å¼ $P_1$ æ¼”åŒ–åˆ° $P_2$ï¼Œåˆ™ $P_2$ ä¿æŒ $P_1$ çš„æ ¸å¿ƒæ€§è´¨ã€‚

**è¯æ˜**:
```latex
1. æ¼”åŒ–å…³ç³»: Evolve(Pâ‚, Pâ‚‚) âŸº Core(Pâ‚) âŠ† Core(Pâ‚‚)
2. æ ¸å¿ƒæ€§è´¨ä¿æŒ: Core(Pâ‚) = Core(Pâ‚‚)
3. å› æ­¤: Pâ‚‚ ä¿æŒ Pâ‚ çš„æ ¸å¿ƒæ€§è´¨
```

## 4. ä»£ç å®ç°

### 4.1 åˆ†å±‚æ¶æ„å®ç° (Rust)

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

/// åˆ†å±‚æ¶æ„ç»„ä»¶
trait Layer {
    fn process(&self, data: &str) -> Result<String, String>;
    fn get_name(&self) -> &str;
}

/// è¡¨ç°å±‚
struct PresentationLayer {
    name: String,
    controllers: HashMap<String, Box<dyn Controller>>,
}

impl PresentationLayer {
    fn new() -> Self {
        Self {
            name: "Presentation".to_string(),
            controllers: HashMap::new(),
        }
    }

    fn add_controller(&mut self, name: String, controller: Box<dyn Controller>) {
        self.controllers.insert(name, controller);
    }
}

impl Layer for PresentationLayer {
    fn process(&self, data: &str) -> Result<String, String> {
        // è§£æè¯·æ±‚ï¼Œè·¯ç”±åˆ°ç›¸åº”æ§åˆ¶å™¨
        let parts: Vec<&str> = data.split(':').collect();
        if parts.len() < 2 {
            return Err("Invalid request format".to_string());
        }

        let controller_name = parts[0];
        let request_data = parts[1];

        if let Some(controller) = self.controllers.get(controller_name) {
            controller.handle(request_data)
        } else {
            Err("Controller not found".to_string())
        }
    }

    fn get_name(&self) -> &str {
        &self.name
    }
}

/// æ§åˆ¶å™¨æ¥å£
trait Controller {
    fn handle(&self, data: &str) -> Result<String, String>;
}

/// ç”¨æˆ·æ§åˆ¶å™¨
struct UserController {
    business_service: Arc<BusinessLayer>,
}

impl UserController {
    fn new(business_service: Arc<BusinessLayer>) -> Self {
        Self { business_service }
    }
}

impl Controller for UserController {
    fn handle(&self, data: &str) -> Result<String, String> {
        // éªŒè¯è¾“å…¥
        if data.is_empty() {
            return Err("Empty request data".to_string());
        }

        // è°ƒç”¨ä¸šåŠ¡å±‚
        let result = self.business_service.process(data)?;
        
        // æ ¼å¼åŒ–å“åº”
        Ok(format!("UserController: {}", result))
    }
}

/// ä¸šåŠ¡å±‚
struct BusinessLayer {
    name: String,
    data_layer: Arc<DataLayer>,
    business_rules: HashMap<String, Box<dyn BusinessRule>>,
}

impl BusinessLayer {
    fn new(data_layer: Arc<DataLayer>) -> Self {
        Self {
            name: "Business".to_string(),
            data_layer,
            business_rules: HashMap::new(),
        }
    }

    fn add_business_rule(&mut self, name: String, rule: Box<dyn BusinessRule>) {
        self.business_rules.insert(name, rule);
    }
}

impl Layer for BusinessLayer {
    fn process(&self, data: &str) -> Result<String, String> {
        // åº”ç”¨ä¸šåŠ¡è§„åˆ™
        for (_, rule) in &self.business_rules {
            if let Err(e) = rule.validate(data) {
                return Err(format!("Business rule violation: {}", e));
            }
        }

        // è°ƒç”¨æ•°æ®å±‚
        let raw_data = self.data_layer.process(data)?;
        
        // åº”ç”¨ä¸šåŠ¡é€»è¾‘
        Ok(format!("Business processed: {}", raw_data))
    }

    fn get_name(&self) -> &str {
        &self.name
    }
}

/// ä¸šåŠ¡è§„åˆ™æ¥å£
trait BusinessRule {
    fn validate(&self, data: &str) -> Result<(), String>;
}

/// ç”¨æˆ·éªŒè¯è§„åˆ™
struct UserValidationRule;

impl BusinessRule for UserValidationRule {
    fn validate(&self, data: &str) -> Result<(), String> {
        if data.len() < 3 {
            return Err("Data too short".to_string());
        }
        Ok(())
    }
}

/// æ•°æ®å±‚
struct DataLayer {
    name: String,
    repositories: HashMap<String, Box<dyn Repository>>,
}

impl DataLayer {
    fn new() -> Self {
        Self {
            name: "Data".to_string(),
            repositories: HashMap::new(),
        }
    }

    fn add_repository(&mut self, name: String, repository: Box<dyn Repository>) {
        self.repositories.insert(name, repository);
    }
}

impl Layer for DataLayer {
    fn process(&self, data: &str) -> Result<String, String> {
        // ç¡®å®šæ•°æ®æº
        let parts: Vec<&str> = data.split('/').collect();
        let repository_name = if parts.len() > 1 { parts[0] } else { "default" };
        let query_data = if parts.len() > 1 { parts[1] } else { data };

        if let Some(repository) = self.repositories.get(repository_name) {
            repository.query(query_data)
        } else {
            Err("Repository not found".to_string())
        }
    }

    fn get_name(&self) -> &str {
        &self.name
    }
}

/// ä»“å‚¨æ¥å£
trait Repository {
    fn query(&self, data: &str) -> Result<String, String>;
    fn save(&self, data: &str) -> Result<(), String>;
}

/// ç”¨æˆ·ä»“å‚¨
struct UserRepository {
    data: Arc<Mutex<HashMap<String, String>>>,
}

impl UserRepository {
    fn new() -> Self {
        Self {
            data: Arc::new(Mutex::new(HashMap::new())),
        }
    }
}

impl Repository for UserRepository {
    fn query(&self, data: &str) -> Result<String, String> {
        if let Ok(data_map) = self.data.lock() {
            if let Some(value) = data_map.get(data) {
                Ok(value.clone())
            } else {
                Ok("User not found".to_string())
            }
        } else {
            Err("Failed to access data".to_string())
        }
    }

    fn save(&self, data: &str) -> Result<(), String> {
        let parts: Vec<&str> = data.split('=').collect();
        if parts.len() != 2 {
            return Err("Invalid data format".to_string());
        }

        if let Ok(mut data_map) = self.data.lock() {
            data_map.insert(parts[0].to_string(), parts[1].to_string());
            Ok(())
        } else {
            Err("Failed to access data".to_string())
        }
    }
}

/// åˆ†å±‚æ¶æ„ç³»ç»Ÿ
struct LayeredArchitecture {
    layers: Vec<Box<dyn Layer>>,
}

impl LayeredArchitecture {
    fn new() -> Self {
        Self { layers: Vec::new() }
    }

    fn add_layer(&mut self, layer: Box<dyn Layer>) {
        self.layers.push(layer);
    }

    fn process_request(&self, request: &str) -> Result<String, String> {
        let mut current_data = request.to_string();

        // ä»è¡¨ç°å±‚å¼€å§‹ï¼Œé€å±‚å¤„ç†
        for layer in &self.layers {
            current_data = layer.process(&current_data)?;
        }

        Ok(current_data)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_layered_architecture() {
        // åˆ›å»ºæ•°æ®å±‚
        let data_layer = Arc::new(DataLayer::new());
        let mut data_layer_mut = Arc::get_mut(&mut Arc::clone(&data_layer)).unwrap();
        data_layer_mut.add_repository(
            "user".to_string(),
            Box::new(UserRepository::new()),
        );

        // åˆ›å»ºä¸šåŠ¡å±‚
        let business_layer = Arc::new(BusinessLayer::new(Arc::clone(&data_layer)));
        let mut business_layer_mut = Arc::get_mut(&mut Arc::clone(&business_layer)).unwrap();
        business_layer_mut.add_business_rule(
            "validation".to_string(),
            Box::new(UserValidationRule),
        );

        // åˆ›å»ºè¡¨ç°å±‚
        let mut presentation_layer = PresentationLayer::new();
        presentation_layer.add_controller(
            "user".to_string(),
            Box::new(UserController::new(Arc::clone(&business_layer))),
        );

        // åˆ›å»ºåˆ†å±‚æ¶æ„
        let mut architecture = LayeredArchitecture::new();
        architecture.add_layer(Box::new(presentation_layer));

        // æµ‹è¯•è¯·æ±‚å¤„ç†
        let result = architecture.process_request("user:test_data");
        assert!(result.is_ok());
    }
}
```

### 4.2 å¾®æœåŠ¡æ¶æ„å®ç° (Haskell)

```haskell
-- å¾®æœåŠ¡å®šä¹‰
data Microservice = Microservice {
    serviceName :: String,
    serviceEndpoints :: [Endpoint],
    serviceDependencies :: [String],
    serviceData :: ServiceData
} deriving (Show, Eq)

data Endpoint = Endpoint {
    endpointPath :: String,
    endpointMethod :: String,
    endpointHandler :: String -> IO String
} deriving (Show)

data ServiceData = ServiceData {
    dataStore :: [(String, String)],
    dataSchema :: [(String, String)]
} deriving (Show, Eq)

-- æœåŠ¡æ³¨å†Œè¡¨
type ServiceRegistry = [(String, Microservice)]

-- æœåŠ¡å‘ç°
class ServiceDiscovery a where
    registerService :: a -> String -> Microservice -> IO ()
    discoverService :: a -> String -> IO (Maybe Microservice)
    listServices :: a -> IO [String]

-- ç®€å•æœåŠ¡æ³¨å†Œè¡¨
data SimpleRegistry = SimpleRegistry {
    registry :: IORef ServiceRegistry
} deriving (Show)

instance ServiceDiscovery SimpleRegistry where
    registerService registry name service = do
        services <- readIORef (registry registry)
        writeIORef (registry registry) ((name, service) : services)
    
    discoverService registry name = do
        services <- readIORef (registry registry)
        return $ lookup name services
    
    listServices registry = do
        services <- readIORef (registry registry)
        return $ map fst services

-- è´Ÿè½½å‡è¡¡å™¨
class LoadBalancer a where
    selectService :: a -> [Microservice] -> IO Microservice
    updateHealth :: a -> String -> Bool -> IO ()

-- è½®è¯¢è´Ÿè½½å‡è¡¡å™¨
data RoundRobinBalancer = RoundRobinBalancer {
    currentIndex :: IORef Int,
    healthyServices :: IORef [Microservice]
} deriving (Show)

instance LoadBalancer RoundRobinBalancer where
    selectService balancer services = do
        index <- readIORef (currentIndex balancer)
        healthy <- readIORef (healthyServices balancer)
        
        if null healthy
        then error "No healthy services available"
        else do
            let selected = healthy !! (index `mod` length healthy)
            writeIORef (currentIndex balancer) (index + 1)
            return selected
    
    updateHealth balancer serviceName isHealthy = do
        healthy <- readIORef (healthyServices balancer)
        -- ç®€åŒ–çš„å¥åº·æ£€æŸ¥æ›´æ–°
        return ()

-- ç†”æ–­å™¨
data CircuitBreaker = CircuitBreaker {
    failureThreshold :: Int,
    failureCount :: IORef Int,
    state :: IORef CircuitState,
    lastFailureTime :: IORef (Maybe UTCTime)
} deriving (Show)

data CircuitState = 
    Closed
  | Open
  | HalfOpen
  deriving (Show, Eq)

-- ç†”æ–­å™¨æ“ä½œ
executeWithCircuitBreaker :: CircuitBreaker -> IO a -> IO (Either String a)
executeWithCircuitBreaker breaker action = do
    currentState <- readIORef (state breaker)
    
    case currentState of
        Open -> do
            lastFailure <- readIORef (lastFailureTime breaker)
            currentTime <- getCurrentTime
            
            case lastFailure of
                Just failureTime -> do
                    let timeDiff = diffUTCTime currentTime failureTime
                    if timeDiff > 60 -- 60ç§’åå°è¯•åŠå¼€
                    then do
                        writeIORef (state breaker) HalfOpen
                        executeWithCircuitBreaker breaker action
                    else
                        return $ Left "Circuit breaker is open"
                Nothing ->
                    return $ Left "Circuit breaker is open"
        
        HalfOpen -> do
            result <- try action
            case result of
                Left _ -> do
                    writeIORef (state breaker) Open
                    writeIORef (lastFailureTime breaker) (Just =<< getCurrentTime)
                    return $ Left "Circuit breaker opened"
                Right value -> do
                    writeIORef (state breaker) Closed
                    writeIORef (failureCount breaker) 0
                    return $ Right value
        
        Closed -> do
            result <- try action
            case result of
                Left _ -> do
                    count <- readIORef (failureCount breaker)
                    writeIORef (failureCount breaker) (count + 1)
                    
                    if count + 1 >= failureThreshold breaker
                    then do
                        writeIORef (state breaker) Open
                        writeIORef (lastFailureTime breaker) (Just =<< getCurrentTime)
                        return $ Left "Circuit breaker opened"
                    else
                        return $ Left "Operation failed"
                Right value ->
                    return $ Right value

-- äº‹ä»¶æ€»çº¿
data EventBus = EventBus {
    subscribers :: IORef [(String, String -> IO ())],
    eventQueue :: IORef [Event]
} deriving (Show)

data Event = Event {
    eventType :: String,
    eventData :: String,
    eventTimestamp :: UTCTime
} deriving (Show)

-- äº‹ä»¶æ€»çº¿æ“ä½œ
publishEvent :: EventBus -> Event -> IO ()
publishEvent bus event = do
    queue <- readIORef (eventQueue bus)
    writeIORef (eventQueue bus) (event : queue)
    
    subs <- readIORef (subscribers bus)
    mapM_ (\(eventType, handler) -> 
        when (eventType == eventType event) $ handler (eventData event)) subs

subscribeToEvent :: EventBus -> String -> (String -> IO ()) -> IO ()
subscribeToEvent bus eventType handler = do
    subs <- readIORef (subscribers bus)
    writeIORef (subscribers bus) ((eventType, handler) : subs)

-- å¾®æœåŠ¡æ¶æ„
data MicroserviceArchitecture = MicroserviceArchitecture {
    serviceRegistry :: SimpleRegistry,
    loadBalancer :: RoundRobinBalancer,
    eventBus :: EventBus,
    circuitBreakers :: IORef [(String, CircuitBreaker)]
} deriving (Show)

-- åˆ›å»ºå¾®æœåŠ¡æ¶æ„
createMicroserviceArchitecture :: IO MicroserviceArchitecture
createMicroserviceArchitecture = do
    registry <- SimpleRegistry <$> newIORef []
    balancer <- RoundRobinBalancer <$> newIORef 0 <*> newIORef []
    bus <- EventBus <$> newIORef [] <*> newIORef []
    breakers <- newIORef []
    
    return $ MicroserviceArchitecture registry balancer bus breakers

-- æœåŠ¡è°ƒç”¨
callService :: MicroserviceArchitecture -> String -> String -> IO (Either String String)
callService arch serviceName request = do
    -- æœåŠ¡å‘ç°
    maybeService <- discoverService (serviceRegistry arch) serviceName
    case maybeService of
        Nothing -> return $ Left "Service not found"
        Just service -> do
            -- è·å–ç†”æ–­å™¨
            breakers <- readIORef (circuitBreakers arch)
            let maybeBreaker = lookup serviceName breakers
            
            case maybeBreaker of
                Just breaker -> do
                    -- ä½¿ç”¨ç†”æ–­å™¨è°ƒç”¨æœåŠ¡
                    result <- executeWithCircuitBreaker breaker (callEndpoint service request)
                    case result of
                        Left err -> do
                            -- å‘å¸ƒå¤±è´¥äº‹ä»¶
                            publishEvent (eventBus arch) Event {
                                eventType = "service_failure",
                                eventData = serviceName,
                                eventTimestamp = undefined
                            }
                            return $ Left err
                        Right response -> return $ Right response
                Nothing -> do
                    -- æ²¡æœ‰ç†”æ–­å™¨ï¼Œç›´æ¥è°ƒç”¨
                    callEndpoint service request >>= return . Right

-- è°ƒç”¨æœåŠ¡ç«¯ç‚¹
callEndpoint :: Microservice -> String -> IO String
callEndpoint service request = do
    -- ç®€åŒ–çš„ç«¯ç‚¹è°ƒç”¨
    let endpoint = head (serviceEndpoints service)
    endpointHandler endpoint request

-- ç¤ºä¾‹æœåŠ¡
createUserService :: IO Microservice
createUserService = do
    let endpoints = [
            Endpoint {
                endpointPath = "/users",
                endpointMethod = "GET",
                endpointHandler = \request -> return $ "User data: " ++ request
            }
        ]
    
    return $ Microservice {
        serviceName = "user-service",
        serviceEndpoints = endpoints,
        serviceDependencies = [],
        serviceData = ServiceData [] []
    }

-- æµ‹è¯•
testMicroserviceArchitecture :: IO ()
testMicroserviceArchitecture = do
    arch <- createMicroserviceArchitecture
    
    -- æ³¨å†ŒæœåŠ¡
    userService <- createUserService
    registerService (serviceRegistry arch) "user-service" userService
    
    -- è°ƒç”¨æœåŠ¡
    result <- callService arch "user-service" "get_user_123"
    print result
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç”µå•†ç³»ç»Ÿæ¶æ„

```rust
/// ç”µå•†ç³»ç»Ÿåˆ†å±‚æ¶æ„
#[derive(Debug, Clone)]
struct ECommerceSystem {
    presentation: PresentationLayer,
    business: BusinessLayer,
    data: DataLayer,
}

impl ECommerceSystem {
    fn new() -> Self {
        let data_layer = DataLayer::new();
        let business_layer = BusinessLayer::new(Arc::new(data_layer.clone()));
        let presentation_layer = PresentationLayer::new();

        Self {
            presentation: presentation_layer,
            business: business_layer,
            data: data_layer,
        }
    }

    fn process_order(&self, order_request: &str) -> Result<String, String> {
        // è¡¨ç°å±‚å¤„ç†
        let validated_request = self.presentation.validate_request(order_request)?;
        
        // ä¸šåŠ¡å±‚å¤„ç†
        let order_result = self.business.process_order(&validated_request)?;
        
        // æ•°æ®å±‚æŒä¹…åŒ–
        let saved_order = self.data.save_order(&order_result)?;
        
        Ok(saved_order)
    }
}

/// è®¢å•å¤„ç†ä¸šåŠ¡é€»è¾‘
impl BusinessLayer {
    fn process_order(&self, order_data: &str) -> Result<String, String> {
        // éªŒè¯è®¢å•
        self.validate_order(order_data)?;
        
        // è®¡ç®—ä»·æ ¼
        let price = self.calculate_price(order_data)?;
        
        // æ£€æŸ¥åº“å­˜
        self.check_inventory(order_data)?;
        
        // åº”ç”¨æŠ˜æ‰£
        let final_price = self.apply_discounts(price, order_data)?;
        
        Ok(format!("Order processed: {}", final_price))
    }

    fn validate_order(&self, order_data: &str) -> Result<(), String> {
        // è®¢å•éªŒè¯é€»è¾‘
        if order_data.is_empty() {
            return Err("Empty order data".to_string());
        }
        Ok(())
    }

    fn calculate_price(&self, order_data: &str) -> Result<f64, String> {
        // ä»·æ ¼è®¡ç®—é€»è¾‘
        Ok(100.0) // ç®€åŒ–å®ç°
    }

    fn check_inventory(&self, order_data: &str) -> Result<(), String> {
        // åº“å­˜æ£€æŸ¥é€»è¾‘
        Ok(())
    }

    fn apply_discounts(&self, price: f64, order_data: &str) -> Result<f64, String> {
        // æŠ˜æ‰£åº”ç”¨é€»è¾‘
        Ok(price * 0.9) // 10%æŠ˜æ‰£
    }
}
```

### 5.2 å¾®æœåŠ¡é€šä¿¡

```rust
/// å¾®æœåŠ¡é€šä¿¡æ¨¡å¼
#[derive(Debug, Clone)]
struct ServiceCommunication {
    service_registry: Arc<ServiceRegistry>,
    load_balancer: Arc<LoadBalancer>,
    circuit_breaker: Arc<CircuitBreaker>,
}

impl ServiceCommunication {
    fn new() -> Self {
        Self {
            service_registry: Arc::new(ServiceRegistry::new()),
            load_balancer: Arc::new(LoadBalancer::new()),
            circuit_breaker: Arc::new(CircuitBreaker::new()),
        }
    }

    fn call_service(&self, service_name: &str, request: &str) -> Result<String, String> {
        // æœåŠ¡å‘ç°
        let service = self.service_registry.discover(service_name)?;
        
        // è´Ÿè½½å‡è¡¡
        let selected_service = self.load_balancer.select(&service)?;
        
        // ç†”æ–­å™¨ä¿æŠ¤
        self.circuit_breaker.execute(|| {
            selected_service.call(request)
        })
    }
}

/// æœåŠ¡æ³¨å†Œè¡¨
struct ServiceRegistry {
    services: HashMap<String, Vec<ServiceInstance>>,
}

impl ServiceRegistry {
    fn new() -> Self {
        Self {
            services: HashMap::new(),
        }
    }

    fn register(&mut self, name: String, instance: ServiceInstance) {
        self.services.entry(name).or_insert_with(Vec::new).push(instance);
    }

    fn discover(&self, name: &str) -> Result<Vec<ServiceInstance>, String> {
        self.services.get(name)
            .cloned()
            .ok_or_else(|| "Service not found".to_string())
    }
}

/// æœåŠ¡å®ä¾‹
#[derive(Debug, Clone)]
struct ServiceInstance {
    id: String,
    url: String,
    health: HealthStatus,
}

#[derive(Debug, Clone)]
enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}

impl ServiceInstance {
    fn call(&self, request: &str) -> Result<String, String> {
        // ç®€åŒ–çš„æœåŠ¡è°ƒç”¨
        Ok(format!("Response from {}: {}", self.id, request))
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸è½¯ä»¶æ¶æ„çš„å…³ç³»

- **æ¶æ„å†³ç­–**ï¼šæ¨¡å¼æŒ‡å¯¼æ¶æ„å†³ç­–
- **æ¶æ„è¯„ä¼°**ï¼šæ¨¡å¼æä¾›è¯„ä¼°æ ‡å‡†
- **æ¶æ„æ¼”åŒ–**ï¼šæ¨¡å¼æ”¯æŒæ¶æ„æ¼”åŒ–

### 6.2 ä¸è®¾è®¡æ¨¡å¼çš„å…³ç³»

- **å±‚æ¬¡å…³ç³»**ï¼šæ¶æ„æ¨¡å¼é«˜äºè®¾è®¡æ¨¡å¼
- **ç»„åˆå…³ç³»**ï¼šæ¶æ„æ¨¡å¼åŒ…å«è®¾è®¡æ¨¡å¼
- **æŠ½è±¡å±‚æ¬¡**ï¼šä¸åŒæŠ½è±¡å±‚æ¬¡çš„æ¨¡å¼

### 6.3 ä¸ç³»ç»Ÿè®¾è®¡çš„å…³ç³»

- **ç³»ç»Ÿåˆ†è§£**ï¼šæ¨¡å¼æŒ‡å¯¼ç³»ç»Ÿåˆ†è§£
- **ç»„ä»¶è®¾è®¡**ï¼šæ¨¡å¼å®šä¹‰ç»„ä»¶æ¥å£
- **äº¤äº’è®¾è®¡**ï¼šæ¨¡å¼è§„èŒƒç»„ä»¶äº¤äº’

### 6.4 ä¸è´¨é‡å±æ€§çš„å…³ç³»

- **å¯ç»´æŠ¤æ€§**ï¼šæ¨¡å¼æé«˜å¯ç»´æŠ¤æ€§
- **å¯æ‰©å±•æ€§**ï¼šæ¨¡å¼æ”¯æŒç³»ç»Ÿæ‰©å±•
- **å¯é æ€§**ï¼šæ¨¡å¼å¢å¼ºç³»ç»Ÿå¯é æ€§

## 7. å‚è€ƒæ–‡çŒ®

1. Buschmann, F., Meunier, R., Rohnert, H., Sommerlad, P., & Stal, M. (1996). Pattern-oriented software architecture: A system of patterns. John Wiley & Sons.
2. Hohpe, G., & Woolf, B. (2003). Enterprise integration patterns: Designing, building, and deploying messaging solutions. Addison-Wesley.
3. Newman, S. (2021). Building microservices: Designing fine-grained systems. O'Reilly Media.
4. Fowler, M. (2018). Patterns of enterprise application architecture. Addison-Wesley.
5. Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design patterns: Elements of reusable object-oriented software. Pearson Education.

---

**ç›¸å…³æ–‡æ¡£**:
- [è½¯ä»¶æ¶æ„è®¾è®¡åŸåˆ™](../02_Software_Architecture/01_Architecture_Design_Principles.md)
- [å¾®æœåŠ¡æ¶æ„](../02_Software_Architecture/03_Microservice_Architecture.md)
- [äº‹ä»¶é©±åŠ¨æ¶æ„](../02_Software_Architecture/04_Event_Driven_Architecture.md)
- [å½¢å¼åŒ–è§„æ ¼è¯´æ˜](../01_Formal_Methods/01_Formal_Specification.md) 