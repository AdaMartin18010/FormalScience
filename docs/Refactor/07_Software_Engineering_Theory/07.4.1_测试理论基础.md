# 07.4.1 æµ‹è¯•ç†è®ºåŸºç¡€

## ğŸ“‹ æ¦‚è¿°

è½¯ä»¶æµ‹è¯•ç†è®ºåŸºç¡€æ˜¯è½¯ä»¶å·¥ç¨‹ä¸­ç¡®ä¿è½¯ä»¶è´¨é‡çš„æ ¸å¿ƒç†è®ºä½“ç³»ï¼Œå®ƒæ¶µç›–äº†æµ‹è¯•çš„åŸºæœ¬åŸç†ã€æ–¹æ³•å­¦ã€å½¢å¼åŒ–å®šä¹‰å’Œæ•°å­¦åŸºç¡€ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦åˆ†æè½¯ä»¶æµ‹è¯•çš„ç†è®ºåŸºç¡€ã€æ•°å­¦å®šä¹‰ã€å®ç°åŸç†å’Œåº”ç”¨åœºæ™¯ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹è½¯ä»¶æµ‹è¯•çš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°å®Œæ•´çš„Rustä»£ç ç¤ºä¾‹
4. åˆ†ææµ‹è¯•ç†è®ºé—´çš„å…³è”æ€§å’Œåº”ç”¨åœºæ™¯

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è½¯ä»¶æµ‹è¯•çš„å®šä¹‰

**å®šä¹‰ 1.1** (è½¯ä»¶æµ‹è¯•)
è½¯ä»¶æµ‹è¯•æ˜¯éªŒè¯è½¯ä»¶ç³»ç»Ÿæ˜¯å¦æ»¡è¶³æŒ‡å®šéœ€æ±‚ã€è¯†åˆ«è½¯ä»¶ç¼ºé™·å¹¶è¯„ä¼°è½¯ä»¶è´¨é‡çš„è¿‡ç¨‹ã€‚

**å®šä¹‰ 1.2** (æµ‹è¯•é—®é¢˜)
ç»™å®šè½¯ä»¶ç³»ç»Ÿ $S$ã€éœ€æ±‚é›†åˆ $R = \{r_1, r_2, \ldots, r_n\}$ å’Œæµ‹è¯•ç”¨ä¾‹é›†åˆ $T = \{t_1, t_2, \ldots, t_m\}$ï¼Œæµ‹è¯•é—®é¢˜æ˜¯åœ¨æœ‰é™æ—¶é—´å†…éªŒè¯ $S$ æ˜¯å¦æ»¡è¶³æ‰€æœ‰ $r_i \in R$ã€‚

### 1.2 æµ‹è¯•çš„åŸºæœ¬åŸç†

è½¯ä»¶æµ‹è¯•åŸºäºä»¥ä¸‹åŸºæœ¬åŸç†ï¼š

1. **ç¼ºé™·å­˜åœ¨åŸç†**ï¼šè½¯ä»¶ä¸­å¿…ç„¶å­˜åœ¨ç¼ºé™·
2. **ç©·ä¸¾æµ‹è¯•ä¸å¯èƒ½åŸç†**ï¼šæ— æ³•å¯¹æ‰€æœ‰å¯èƒ½çš„è¾“å…¥è¿›è¡Œæµ‹è¯•
3. **æ—©æœŸæµ‹è¯•åŸç†**ï¼šè¶Šæ—©å‘ç°ç¼ºé™·ï¼Œä¿®å¤æˆæœ¬è¶Šä½
4. **ç¼ºé™·èšé›†åŸç†**ï¼šç¼ºé™·å¾€å¾€é›†ä¸­åœ¨ç‰¹å®šæ¨¡å—
5. **æµ‹è¯•ç¯å¢ƒä¾èµ–åŸç†**ï¼šæµ‹è¯•ç»“æœä¾èµ–äºæµ‹è¯•ç¯å¢ƒ
6. **æ€è™«å‰‚æ‚–è®º**ï¼šé‡å¤çš„æµ‹è¯•ç”¨ä¾‹æ•ˆæœé€’å‡

### 1.3 å½¢å¼åŒ–è¡¨ç¤º

**å®šä¹‰ 1.3** (æµ‹è¯•çš„å½¢å¼åŒ–è¡¨ç¤º)
æµ‹è¯•å¯ä»¥è¡¨ç¤ºä¸ºä¸ƒå…ƒç»„ $Test = (S, R, T, E, O, M, Q)$ï¼Œå…¶ä¸­ï¼š
- $S$ æ˜¯è½¯ä»¶ç³»ç»Ÿ
- $R$ æ˜¯éœ€æ±‚é›†åˆ
- $T$ æ˜¯æµ‹è¯•ç”¨ä¾‹é›†åˆ
- $E$ æ˜¯æµ‹è¯•ç¯å¢ƒ
- $O$ æ˜¯æµ‹è¯•é¢„è¨€
- $M$ æ˜¯æµ‹è¯•åº¦é‡
- $Q$ æ˜¯è´¨é‡å±æ€§

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æµ‹è¯•ç”¨ä¾‹

**å®šä¹‰ 2.1** (æµ‹è¯•ç”¨ä¾‹)
æµ‹è¯•ç”¨ä¾‹æ˜¯ä¸€ä¸ªå››å…ƒç»„ $tc = (I, E, O, P)$ï¼Œå…¶ä¸­ï¼š
- $I$ æ˜¯è¾“å…¥é›†åˆ
- $E$ æ˜¯æ‰§è¡Œç¯å¢ƒ
- $O$ æ˜¯é¢„æœŸè¾“å‡º
- $P$ æ˜¯æµ‹è¯•é¢„è¨€

**å®šç† 2.1** (æµ‹è¯•ç”¨ä¾‹çš„å®Œå¤‡æ€§)
æµ‹è¯•ç”¨ä¾‹çš„å®Œå¤‡æ€§ä¸å…¶è¦†ç›–çš„éœ€æ±‚æ•°é‡æˆæ­£æ¯”ã€‚

**è¯æ˜**ï¼š
è®¾ $C(tc)$ ä¸ºæµ‹è¯•ç”¨ä¾‹ $tc$ è¦†ç›–çš„éœ€æ±‚æ•°é‡ï¼Œåˆ™å®Œå¤‡æ€§ $Completeness(tc) = \frac{C(tc)}{|R|}$ã€‚$\square$

### 2.2 æµ‹è¯•é¢„è¨€

**å®šä¹‰ 2.2** (æµ‹è¯•é¢„è¨€)
æµ‹è¯•é¢„è¨€æ˜¯ä¸€ä¸ªå‡½æ•° $P: Output \rightarrow \{Pass, Fail\}$ï¼Œç”¨äºåˆ¤æ–­æµ‹è¯•ç»“æœæ˜¯å¦æ­£ç¡®ã€‚

**å®šç† 2.2** (æµ‹è¯•é¢„è¨€çš„å¯é æ€§)
æµ‹è¯•é¢„è¨€çš„å¯é æ€§å†³å®šäº†æµ‹è¯•ç»“æœçš„å¯ä¿¡åº¦ã€‚

**è¯æ˜**ï¼š
å¦‚æœæµ‹è¯•é¢„è¨€ $P$ ä¸æ­£ç¡®ï¼Œåˆ™æµ‹è¯•ç»“æœ $P(output)$ ä¹Ÿä¸æ­£ç¡®ï¼Œå› æ­¤é¢„è¨€çš„å¯é æ€§ç›´æ¥å½±å“æµ‹è¯•ç»“æœçš„å¯ä¿¡åº¦ã€‚$\square$

### 2.3 æµ‹è¯•è¦†ç›–ç‡

**å®šä¹‰ 2.3** (æµ‹è¯•è¦†ç›–ç‡)
æµ‹è¯•è¦†ç›–ç‡æ˜¯æµ‹è¯•ç”¨ä¾‹é›†åˆå¯¹è½¯ä»¶ç³»ç»Ÿå„ä¸ªæ–¹é¢çš„è¦†ç›–ç¨‹åº¦ã€‚

å½¢å¼åŒ–å®šä¹‰ï¼š
$$\text{Coverage}(T, S) = \frac{|\text{Covered}(T, S)|}{|\text{Total}(S)|}$$

**å®šç† 2.3** (è¦†ç›–ç‡çš„å•è°ƒæ€§)
æµ‹è¯•è¦†ç›–ç‡éšæµ‹è¯•ç”¨ä¾‹æ•°é‡çš„å¢åŠ è€Œå•è°ƒé€’å¢ã€‚

**è¯æ˜**ï¼š
è®¾ $T_1 \subseteq T_2$ï¼Œåˆ™ $\text{Covered}(T_1, S) \subseteq \text{Covered}(T_2, S)$ï¼Œå› æ­¤ $\text{Coverage}(T_1, S) \leq \text{Coverage}(T_2, S)$ã€‚$\square$

### 2.4 æµ‹è¯•å……åˆ†æ€§

**å®šä¹‰ 2.4** (æµ‹è¯•å……åˆ†æ€§)
æµ‹è¯•å……åˆ†æ€§æ˜¯æµ‹è¯•ç”¨ä¾‹é›†åˆæ»¡è¶³æµ‹è¯•ç›®æ ‡çš„ç¨‹åº¦ã€‚

**å®šç† 2.4** (å……åˆ†æ€§çš„ä¼ é€’æ€§)
å¦‚æœæµ‹è¯•ç”¨ä¾‹é›†åˆ $T_1$ å¯¹éœ€æ±‚ $R_1$ å……åˆ†ï¼Œ$T_2$ å¯¹éœ€æ±‚ $R_2$ å……åˆ†ï¼Œåˆ™ $T_1 \cup T_2$ å¯¹ $R_1 \cup R_2$ å……åˆ†ã€‚

**è¯æ˜**ï¼š
æ ¹æ®å……åˆ†æ€§çš„å®šä¹‰ï¼Œ$T_1$ è¦†ç›– $R_1$ï¼Œ$T_2$ è¦†ç›– $R_2$ï¼Œå› æ­¤ $T_1 \cup T_2$ è¦†ç›– $R_1 \cup R_2$ã€‚$\square$

### 2.5 æµ‹è¯•æœ‰æ•ˆæ€§

**å®šä¹‰ 2.5** (æµ‹è¯•æœ‰æ•ˆæ€§)
æµ‹è¯•æœ‰æ•ˆæ€§æ˜¯æµ‹è¯•ç”¨ä¾‹å‘ç°ç¼ºé™·çš„èƒ½åŠ›ã€‚

**å®šç† 2.5** (æœ‰æ•ˆæ€§çš„å¯æµ‹é‡æ€§)
æµ‹è¯•æœ‰æ•ˆæ€§å¯ä»¥é€šè¿‡ç¼ºé™·å‘ç°ç‡æ¥æµ‹é‡ã€‚

**è¯æ˜**ï¼š
ç¼ºé™·å‘ç°ç‡ $DR = \frac{\text{å‘ç°çš„ç¼ºé™·æ•°}}{\text{æ€»ç¼ºé™·æ•°}}$ï¼Œåæ˜ äº†æµ‹è¯•çš„æœ‰æ•ˆæ€§ã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

### 3.1 æµ‹è¯•ç†è®ºçš„åŸºæœ¬æ€§è´¨

**å®šç† 3.1** (æµ‹è¯•çš„ä¸å¯å®Œå¤‡æ€§)
å¯¹äºä»»ä½•éå¹³å‡¡çš„è½¯ä»¶ç³»ç»Ÿï¼Œä¸å­˜åœ¨å®Œå¤‡çš„æµ‹è¯•ç”¨ä¾‹é›†åˆã€‚

**è¯æ˜**ï¼š
æ ¹æ®ç©·ä¸¾æµ‹è¯•ä¸å¯èƒ½åŸç†ï¼Œå¯¹äºå…·æœ‰æ— é™è¾“å…¥ç©ºé—´çš„è½¯ä»¶ç³»ç»Ÿï¼Œæ— æ³•åœ¨æœ‰é™æ—¶é—´å†…æµ‹è¯•æ‰€æœ‰å¯èƒ½çš„è¾“å…¥ã€‚$\square$

**å®šç† 3.2** (æµ‹è¯•çš„æ¸è¿›æ€§)
æµ‹è¯•è´¨é‡å¯ä»¥é€šè¿‡å¢åŠ æµ‹è¯•ç”¨ä¾‹é€æ­¥æé«˜ã€‚

**è¯æ˜**ï¼š
æ ¹æ®è¦†ç›–ç‡çš„å•è°ƒæ€§ï¼Œå¢åŠ æµ‹è¯•ç”¨ä¾‹å¯ä»¥æé«˜è¦†ç›–ç‡ï¼Œä»è€Œæé«˜æµ‹è¯•è´¨é‡ã€‚$\square$

### 3.2 æµ‹è¯•ç­–ç•¥çš„ä¼˜åŒ–

**å®šç† 3.3** (é£é™©å¯¼å‘æµ‹è¯•çš„æœ€ä¼˜æ€§)
åŸºäºé£é™©åˆ†æçš„æµ‹è¯•ç­–ç•¥åœ¨èµ„æºæœ‰é™çš„æƒ…å†µä¸‹æ˜¯æœ€ä¼˜çš„ã€‚

**è¯æ˜**ï¼š
é£é™©å¯¼å‘æµ‹è¯•ä¼˜å…ˆæµ‹è¯•é«˜é£é™©æ¨¡å—ï¼Œæ ¹æ®ç¼ºé™·èšé›†åŸç†ï¼Œé«˜é£é™©æ¨¡å—æ›´å¯èƒ½åŒ…å«ç¼ºé™·ï¼Œå› æ­¤è¿™ç§ç­–ç•¥åœ¨èµ„æºæœ‰é™æ—¶æ˜¯æœ€ä¼˜çš„ã€‚$\square$

**å®šç† 3.4** (å›å½’æµ‹è¯•çš„å¿…è¦æ€§)
è½¯ä»¶ä¿®æ”¹åå¿…é¡»è¿›è¡Œå›å½’æµ‹è¯•ã€‚

**è¯æ˜**ï¼š
è½¯ä»¶ä¿®æ”¹å¯èƒ½å¼•å…¥æ–°çš„ç¼ºé™·æˆ–ç ´åç°æœ‰åŠŸèƒ½ï¼Œå› æ­¤å¿…é¡»é€šè¿‡å›å½’æµ‹è¯•éªŒè¯ä¿®æ”¹çš„æ­£ç¡®æ€§ã€‚$\square$

### 3.3 æµ‹è¯•åº¦é‡çš„æ•°å­¦åŸºç¡€

**å®šç† 3.5** (ç¼ºé™·å¯†åº¦çš„ç¨³å®šæ€§)
åœ¨è½¯ä»¶æˆç†Ÿé˜¶æ®µï¼Œç¼ºé™·å¯†åº¦è¶‹äºç¨³å®šã€‚

**è¯æ˜**ï¼š
éšç€æµ‹è¯•çš„è¿›è¡Œï¼Œå¤§éƒ¨åˆ†ç¼ºé™·è¢«å‘ç°å’Œä¿®å¤ï¼Œå‰©ä½™ç¼ºé™·æ•°é‡è¶‹äºç¨³å®šï¼Œå› æ­¤ç¼ºé™·å¯†åº¦ä¹Ÿè¶‹äºç¨³å®šã€‚$\square$

**å®šç† 3.6** (æµ‹è¯•æ•ˆç‡çš„é€’å‡æ€§)
éšç€æµ‹è¯•çš„è¿›è¡Œï¼Œæµ‹è¯•æ•ˆç‡ï¼ˆå‘ç°ç¼ºé™·çš„æ•ˆç‡ï¼‰é€’å‡ã€‚

**è¯æ˜**ï¼š
æ ¹æ®æ€è™«å‰‚æ‚–è®ºï¼Œé‡å¤çš„æµ‹è¯•ç”¨ä¾‹æ•ˆæœé€’å‡ï¼Œå› æ­¤æµ‹è¯•æ•ˆç‡é€’å‡ã€‚$\square$

## 4. ä»£ç å®ç°

### 4.1 æµ‹è¯•æ¡†æ¶åŸºç¡€

```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};

/// æµ‹è¯•ç»“æœæšä¸¾
#[derive(Debug, Clone, PartialEq)]
pub enum TestResult {
    Pass,
    Fail(String),
    Error(String),
    Skip(String),
}

/// æµ‹è¯•ç”¨ä¾‹ç‰¹å¾
pub trait TestCase {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    fn execute(&self) -> TestResult;
    fn setup(&self) -> Result<(), String> { Ok(()) }
    fn teardown(&self) -> Result<(), String> { Ok(()) }
}

/// æµ‹è¯•å¥—ä»¶
pub struct TestSuite {
    name: String,
    test_cases: Vec<Box<dyn TestCase>>,
}

impl TestSuite {
    pub fn new(name: String) -> Self {
        Self {
            name,
            test_cases: Vec::new(),
        }
    }
    
    pub fn add_test(&mut self, test_case: Box<dyn TestCase>) {
        self.test_cases.push(test_case);
    }
    
    pub fn run(&self) -> TestSuiteResult {
        let mut results = Vec::new();
        let start_time = Instant::now();
        
        for test_case in &self.test_cases {
            let test_start = Instant::now();
            
            // æ‰§è¡Œæµ‹è¯•
            let result = match test_case.setup() {
                Ok(_) => {
                    let test_result = test_case.execute();
                    let _ = test_case.teardown();
                    test_result
                }
                Err(e) => TestResult::Error(format!("Setup failed: {}", e)),
            };
            
            let duration = test_start.elapsed();
            results.push(TestExecutionResult {
                name: test_case.name().to_string(),
                result,
                duration,
            });
        }
        
        let total_duration = start_time.elapsed();
        TestSuiteResult {
            name: self.name.clone(),
            results,
            total_duration,
        }
    }
}

/// æµ‹è¯•æ‰§è¡Œç»“æœ
pub struct TestExecutionResult {
    pub name: String,
    pub result: TestResult,
    pub duration: Duration,
}

/// æµ‹è¯•å¥—ä»¶ç»“æœ
pub struct TestSuiteResult {
    pub name: String,
    pub results: Vec<TestExecutionResult>,
    pub total_duration: Duration,
}

impl TestSuiteResult {
    pub fn summary(&self) -> TestSummary {
        let total = self.results.len();
        let passed = self.results.iter().filter(|r| r.result == TestResult::Pass).count();
        let failed = self.results.iter().filter(|r| matches!(r.result, TestResult::Fail(_))).count();
        let errors = self.results.iter().filter(|r| matches!(r.result, TestResult::Error(_))).count();
        let skipped = self.results.iter().filter(|r| matches!(r.result, TestResult::Skip(_))).count();
        
        TestSummary {
            total,
            passed,
            failed,
            errors,
            skipped,
            success_rate: if total > 0 { passed as f64 / total as f64 } else { 0.0 },
        }
    }
}

/// æµ‹è¯•æ‘˜è¦
pub struct TestSummary {
    pub total: usize,
    pub passed: usize,
    pub failed: usize,
    pub errors: usize,
    pub skipped: usize,
    pub success_rate: f64,
}
```

### 4.2 æµ‹è¯•é¢„è¨€å®ç°

```rust
/// æµ‹è¯•é¢„è¨€ç‰¹å¾
pub trait TestOracle {
    fn verify(&self, input: &str, output: &str) -> TestResult;
}

/// ç²¾ç¡®åŒ¹é…é¢„è¨€
pub struct ExactMatchOracle {
    expected_output: String,
}

impl ExactMatchOracle {
    pub fn new(expected_output: String) -> Self {
        Self { expected_output }
    }
}

impl TestOracle for ExactMatchOracle {
    fn verify(&self, _input: &str, output: &str) -> TestResult {
        if output == self.expected_output {
            TestResult::Pass
        } else {
            TestResult::Fail(format!("Expected '{}', got '{}'", self.expected_output, output))
        }
    }
}

/// æ­£åˆ™è¡¨è¾¾å¼é¢„è¨€
pub struct RegexOracle {
    pattern: String,
}

impl RegexOracle {
    pub fn new(pattern: String) -> Self {
        Self { pattern }
    }
}

impl TestOracle for RegexOracle {
    fn verify(&self, _input: &str, output: &str) -> TestResult {
        use regex::Regex;
        match Regex::new(&self.pattern) {
            Ok(regex) => {
                if regex.is_match(output) {
                    TestResult::Pass
                } else {
                    TestResult::Fail(format!("Output '{}' does not match pattern '{}'", output, self.pattern))
                }
            }
            Err(e) => TestResult::Error(format!("Invalid regex pattern: {}", e)),
        }
    }
}

/// è‡ªå®šä¹‰å‡½æ•°é¢„è¨€
pub struct CustomOracle<F>
where
    F: Fn(&str, &str) -> TestResult,
{
    verify_fn: F,
}

impl<F> CustomOracle<F>
where
    F: Fn(&str, &str) -> TestResult,
{
    pub fn new(verify_fn: F) -> Self {
        Self { verify_fn }
    }
}

impl<F> TestOracle for CustomOracle<F>
where
    F: Fn(&str, &str) -> TestResult,
{
    fn verify(&self, input: &str, output: &str) -> TestResult {
        (self.verify_fn)(input, output)
    }
}
```

### 4.3 æµ‹è¯•è¦†ç›–ç‡è®¡ç®—

```rust
use std::collections::HashSet;

/// è¦†ç›–ç‡ç±»å‹
#[derive(Debug, Clone)]
pub enum CoverageType {
    Statement,
    Branch,
    Path,
    Function,
    Line,
}

/// è¦†ç›–ç‡ä¿¡æ¯
pub struct CoverageInfo {
    pub coverage_type: CoverageType,
    pub covered_items: HashSet<String>,
    pub total_items: HashSet<String>,
}

impl CoverageInfo {
    pub fn new(coverage_type: CoverageType) -> Self {
        Self {
            coverage_type,
            covered_items: HashSet::new(),
            total_items: HashSet::new(),
        }
    }
    
    pub fn add_covered_item(&mut self, item: String) {
        self.covered_items.insert(item);
    }
    
    pub fn add_total_item(&mut self, item: String) {
        self.total_items.insert(item);
    }
    
    pub fn coverage_percentage(&self) -> f64 {
        if self.total_items.is_empty() {
            0.0
        } else {
            self.covered_items.len() as f64 / self.total_items.len() as f64 * 100.0
        }
    }
    
    pub fn uncovered_items(&self) -> HashSet<String> {
        &self.total_items - &self.covered_items
    }
}

/// è¦†ç›–ç‡æ”¶é›†å™¨
pub struct CoverageCollector {
    coverage_info: HashMap<CoverageType, CoverageInfo>,
}

impl CoverageCollector {
    pub fn new() -> Self {
        Self {
            coverage_info: HashMap::new(),
        }
    }
    
    pub fn start_collection(&mut self, coverage_type: CoverageType) {
        self.coverage_info.insert(coverage_type.clone(), CoverageInfo::new(coverage_type));
    }
    
    pub fn record_execution(&mut self, coverage_type: &CoverageType, item: String) {
        if let Some(info) = self.coverage_info.get_mut(coverage_type) {
            info.add_covered_item(item);
        }
    }
    
    pub fn add_total_item(&mut self, coverage_type: &CoverageType, item: String) {
        if let Some(info) = self.coverage_info.get_mut(coverage_type) {
            info.add_total_item(item);
        }
    }
    
    pub fn get_coverage(&self, coverage_type: &CoverageType) -> Option<&CoverageInfo> {
        self.coverage_info.get(coverage_type)
    }
    
    pub fn generate_report(&self) -> CoverageReport {
        let mut report = CoverageReport::new();
        for (coverage_type, info) in &self.coverage_info {
            report.add_coverage(coverage_type.clone(), info.coverage_percentage());
        }
        report
    }
}

/// è¦†ç›–ç‡æŠ¥å‘Š
pub struct CoverageReport {
    pub coverages: HashMap<CoverageType, f64>,
}

impl CoverageReport {
    pub fn new() -> Self {
        Self {
            coverages: HashMap::new(),
        }
    }
    
    pub fn add_coverage(&mut self, coverage_type: CoverageType, percentage: f64) {
        self.coverages.insert(coverage_type, percentage);
    }
    
    pub fn overall_coverage(&self) -> f64 {
        if self.coverages.is_empty() {
            0.0
        } else {
            self.coverages.values().sum::<f64>() / self.coverages.len() as f64
        }
    }
}
```

### 4.4 æµ‹è¯•æ•°æ®ç”Ÿæˆ

```rust
use rand::Rng;

/// æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨ç‰¹å¾
pub trait TestDataGenerator {
    type Data;
    fn generate(&self) -> Self::Data;
    fn generate_multiple(&self, count: usize) -> Vec<Self::Data>;
}

/// éšæœºæ•´æ•°ç”Ÿæˆå™¨
pub struct RandomIntGenerator {
    min: i32,
    max: i32,
}

impl RandomIntGenerator {
    pub fn new(min: i32, max: i32) -> Self {
        Self { min, max }
    }
}

impl TestDataGenerator for RandomIntGenerator {
    type Data = i32;
    
    fn generate(&self) -> Self::Data {
        let mut rng = rand::thread_rng();
        rng.gen_range(self.min..=self.max)
    }
    
    fn generate_multiple(&self, count: usize) -> Vec<Self::Data> {
        (0..count).map(|_| self.generate()).collect()
    }
}

/// è¾¹ç•Œå€¼ç”Ÿæˆå™¨
pub struct BoundaryValueGenerator<T> {
    values: Vec<T>,
}

impl<T: Clone> BoundaryValueGenerator<T> {
    pub fn new(values: Vec<T>) -> Self {
        Self { values }
    }
}

impl<T: Clone> TestDataGenerator for BoundaryValueGenerator<T> {
    type Data = T;
    
    fn generate(&self) -> Self::Data {
        if self.values.is_empty() {
            panic!("No values available for generation");
        }
        let mut rng = rand::thread_rng();
        let index = rng.gen_range(0..self.values.len());
        self.values[index].clone()
    }
    
    fn generate_multiple(&self, count: usize) -> Vec<Self::Data> {
        (0..count).map(|_| self.generate()).collect()
    }
}

/// ç­‰ä»·ç±»ç”Ÿæˆå™¨
pub struct EquivalenceClassGenerator<T> {
    classes: Vec<Vec<T>>,
}

impl<T: Clone> EquivalenceClassGenerator<T> {
    pub fn new(classes: Vec<Vec<T>>) -> Self {
        Self { classes }
    }
}

impl<T: Clone> TestDataGenerator for EquivalenceClassGenerator<T> {
    type Data = T;
    
    fn generate(&self) -> Self::Data {
        if self.classes.is_empty() {
            panic!("No equivalence classes available");
        }
        let mut rng = rand::thread_rng();
        let class_index = rng.gen_range(0..self.classes.len());
        let value_index = rng.gen_range(0..self.classes[class_index].len());
        self.classes[class_index][value_index].clone()
    }
    
    fn generate_multiple(&self, count: usize) -> Vec<Self::Data> {
        (0..count).map(|_| self.generate()).collect()
    }
}
```

### 4.5 æµ‹è¯•åº¦é‡è®¡ç®—

```rust
/// æµ‹è¯•åº¦é‡
pub struct TestMetrics {
    pub test_cases_total: usize,
    pub test_cases_passed: usize,
    pub test_cases_failed: usize,
    pub test_cases_skipped: usize,
    pub defects_found: usize,
    pub defects_fixed: usize,
    pub test_duration: Duration,
    pub coverage_percentage: f64,
}

impl TestMetrics {
    pub fn new() -> Self {
        Self {
            test_cases_total: 0,
            test_cases_passed: 0,
            test_cases_failed: 0,
            test_cases_skipped: 0,
            defects_found: 0,
            defects_fixed: 0,
            test_duration: Duration::from_secs(0),
            coverage_percentage: 0.0,
        }
    }
    
    pub fn success_rate(&self) -> f64 {
        if self.test_cases_total == 0 {
            0.0
        } else {
            self.test_cases_passed as f64 / self.test_cases_total as f64
        }
    }
    
    pub fn defect_density(&self, lines_of_code: usize) -> f64 {
        if lines_of_code == 0 {
            0.0
        } else {
            self.defects_found as f64 / lines_of_code as f64
        }
    }
    
    pub fn defect_removal_efficiency(&self) -> f64 {
        if self.defects_found == 0 {
            0.0
        } else {
            self.defects_fixed as f64 / self.defects_found as f64
        }
    }
    
    pub fn test_efficiency(&self) -> f64 {
        if self.test_duration.as_secs() == 0 {
            0.0
        } else {
            self.defects_found as f64 / self.test_duration.as_secs() as f64
        }
    }
}

/// æµ‹è¯•åº¦é‡æ”¶é›†å™¨
pub struct TestMetricsCollector {
    metrics: TestMetrics,
}

impl TestMetricsCollector {
    pub fn new() -> Self {
        Self {
            metrics: TestMetrics::new(),
        }
    }
    
    pub fn record_test_result(&mut self, result: &TestResult, duration: Duration) {
        self.metrics.test_cases_total += 1;
        self.metrics.test_duration += duration;
        
        match result {
            TestResult::Pass => self.metrics.test_cases_passed += 1,
            TestResult::Fail(_) => self.metrics.test_cases_failed += 1,
            TestResult::Skip(_) => self.metrics.test_cases_skipped += 1,
            TestResult::Error(_) => self.metrics.test_cases_failed += 1,
        }
    }
    
    pub fn record_defect_found(&mut self) {
        self.metrics.defects_found += 1;
    }
    
    pub fn record_defect_fixed(&mut self) {
        self.metrics.defects_fixed += 1;
    }
    
    pub fn update_coverage(&mut self, coverage: f64) {
        self.metrics.coverage_percentage = coverage;
    }
    
    pub fn get_metrics(&self) -> &TestMetrics {
        &self.metrics
    }
    
    pub fn generate_report(&self) -> TestMetricsReport {
        TestMetricsReport {
            metrics: self.metrics.clone(),
            timestamp: chrono::Utc::now(),
        }
    }
}

/// æµ‹è¯•åº¦é‡æŠ¥å‘Š
pub struct TestMetricsReport {
    pub metrics: TestMetrics,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

impl TestMetricsReport {
    pub fn print_summary(&self) {
        println!("=== Test Metrics Report ===");
        println!("Timestamp: {}", self.timestamp);
        println!("Test Cases: {}/{} passed ({:.1}%)", 
                self.metrics.test_cases_passed, 
                self.metrics.test_cases_total,
                self.metrics.success_rate() * 100.0);
        println!("Defects Found: {}", self.metrics.defects_found);
        println!("Defects Fixed: {}", self.metrics.defects_fixed);
        println!("Coverage: {:.1}%", self.metrics.coverage_percentage);
        println!("Test Duration: {:?}", self.metrics.test_duration);
        println!("Test Efficiency: {:.2} defects/second", self.metrics.test_efficiency());
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 è®¡ç®—å™¨æµ‹è¯•ç¤ºä¾‹

```rust
/// ç®€å•è®¡ç®—å™¨
pub struct Calculator;

impl Calculator {
    pub fn add(&self, a: i32, b: i32) -> i32 {
        a + b
    }
    
    pub fn subtract(&self, a: i32, b: i32) -> i32 {
        a - b
    }
    
    pub fn multiply(&self, a: i32, b: i32) -> i32 {
        a * b
    }
    
    pub fn divide(&self, a: i32, b: i32) -> Result<i32, String> {
        if b == 0 {
            Err("Division by zero".to_string())
        } else {
            Ok(a / b)
        }
    }
}

/// è®¡ç®—å™¨åŠ æ³•æµ‹è¯•
pub struct CalculatorAddTest {
    calculator: Calculator,
}

impl CalculatorAddTest {
    pub fn new() -> Self {
        Self {
            calculator: Calculator,
        }
    }
}

impl TestCase for CalculatorAddTest {
    fn name(&self) -> &str {
        "Calculator Add Test"
    }
    
    fn description(&self) -> &str {
        "Test addition functionality of calculator"
    }
    
    fn execute(&self) -> TestResult {
        let result = self.calculator.add(2, 3);
        if result == 5 {
            TestResult::Pass
        } else {
            TestResult::Fail(format!("Expected 5, got {}", result))
        }
    }
}

/// è®¡ç®—å™¨é™¤æ³•æµ‹è¯•
pub struct CalculatorDivideTest {
    calculator: Calculator,
}

impl CalculatorDivideTest {
    pub fn new() -> Self {
        Self {
            calculator: Calculator,
        }
    }
}

impl TestCase for CalculatorDivideTest {
    fn name(&self) -> &str {
        "Calculator Divide Test"
    }
    
    fn description(&self) -> &str {
        "Test division functionality of calculator"
    }
    
    fn execute(&self) -> TestResult {
        match self.calculator.divide(10, 2) {
            Ok(result) => {
                if result == 5 {
                    TestResult::Pass
                } else {
                    TestResult::Fail(format!("Expected 5, got {}", result))
                }
            }
            Err(e) => TestResult::Fail(format!("Unexpected error: {}", e)),
        }
    }
}

/// è®¡ç®—å™¨é™¤é›¶æµ‹è¯•
pub struct CalculatorDivideByZeroTest {
    calculator: Calculator,
}

impl CalculatorDivideByZeroTest {
    pub fn new() -> Self {
        Self {
            calculator: Calculator,
        }
    }
}

impl TestCase for CalculatorDivideByZeroTest {
    fn name(&self) -> &str {
        "Calculator Divide By Zero Test"
    }
    
    fn description(&self) -> &str {
        "Test division by zero error handling"
    }
    
    fn execute(&self) -> TestResult {
        match self.calculator.divide(10, 0) {
            Ok(_) => TestResult::Fail("Expected error for division by zero".to_string()),
            Err(e) => {
                if e == "Division by zero" {
                    TestResult::Pass
                } else {
                    TestResult::Fail(format!("Unexpected error message: {}", e))
                }
            }
        }
    }
}
```

### 5.2 å­—ç¬¦ä¸²å¤„ç†æµ‹è¯•ç¤ºä¾‹

```rust
/// å­—ç¬¦ä¸²å¤„ç†å™¨
pub struct StringProcessor;

impl StringProcessor {
    pub fn reverse(&self, input: &str) -> String {
        input.chars().rev().collect()
    }
    
    pub fn to_uppercase(&self, input: &str) -> String {
        input.to_uppercase()
    }
    
    pub fn count_words(&self, input: &str) -> usize {
        input.split_whitespace().count()
    }
    
    pub fn is_palindrome(&self, input: &str) -> bool {
        let cleaned: String = input.chars().filter(|c| c.is_alphanumeric()).collect();
        let reversed: String = cleaned.chars().rev().collect();
        cleaned.to_lowercase() == reversed.to_lowercase()
    }
}

/// å­—ç¬¦ä¸²åè½¬æµ‹è¯•
pub struct StringReverseTest {
    processor: StringProcessor,
}

impl StringReverseTest {
    pub fn new() -> Self {
        Self {
            processor: StringProcessor,
        }
    }
}

impl TestCase for StringReverseTest {
    fn name(&self) -> &str {
        "String Reverse Test"
    }
    
    fn description(&self) -> &str {
        "Test string reversal functionality"
    }
    
    fn execute(&self) -> TestResult {
        let test_cases = vec![
            ("hello", "olleh"),
            ("", ""),
            ("a", "a"),
            ("123", "321"),
        ];
        
        for (input, expected) in test_cases {
            let result = self.processor.reverse(input);
            if result != expected {
                return TestResult::Fail(format!("For input '{}', expected '{}', got '{}'", 
                                              input, expected, result));
            }
        }
        
        TestResult::Pass
    }
}

/// å›æ–‡æ£€æµ‹æµ‹è¯•
pub struct PalindromeTest {
    processor: StringProcessor,
}

impl PalindromeTest {
    pub fn new() -> Self {
        Self {
            processor: StringProcessor,
        }
    }
}

impl TestCase for PalindromeTest {
    fn name(&self) -> &str {
        "Palindrome Test"
    }
    
    fn description(&self) -> &str {
        "Test palindrome detection functionality"
    }
    
    fn execute(&self) -> TestResult {
        let test_cases = vec![
            ("racecar", true),
            ("A man a plan a canal Panama", true),
            ("hello", false),
            ("", true),
            ("a", true),
        ];
        
        for (input, expected) in test_cases {
            let result = self.processor.is_palindrome(input);
            if result != expected {
                return TestResult::Fail(format!("For input '{}', expected {}, got {}", 
                                              input, expected, result));
            }
        }
        
        TestResult::Pass
    }
}
```

### 5.3 æ•°æ®åº“è¿æ¥æµ‹è¯•ç¤ºä¾‹

```rust
use std::sync::{Arc, Mutex};

/// æ¨¡æ‹Ÿæ•°æ®åº“è¿æ¥
pub struct DatabaseConnection {
    is_connected: bool,
    connection_string: String,
}

impl DatabaseConnection {
    pub fn new(connection_string: String) -> Self {
        Self {
            is_connected: false,
            connection_string,
        }
    }
    
    pub fn connect(&mut self) -> Result<(), String> {
        if self.connection_string.is_empty() {
            return Err("Invalid connection string".to_string());
        }
        self.is_connected = true;
        Ok(())
    }
    
    pub fn disconnect(&mut self) -> Result<(), String> {
        if !self.is_connected {
            return Err("Not connected".to_string());
        }
        self.is_connected = false;
        Ok(())
    }
    
    pub fn is_connected(&self) -> bool {
        self.is_connected
    }
    
    pub fn execute_query(&self, query: &str) -> Result<String, String> {
        if !self.is_connected {
            return Err("Not connected to database".to_string());
        }
        if query.is_empty() {
            return Err("Empty query".to_string());
        }
        Ok(format!("Result for query: {}", query))
    }
}

/// æ•°æ®åº“è¿æ¥æµ‹è¯•
pub struct DatabaseConnectionTest {
    connection: Arc<Mutex<DatabaseConnection>>,
}

impl DatabaseConnectionTest {
    pub fn new() -> Self {
        Self {
            connection: Arc::new(Mutex::new(DatabaseConnection::new("test_db".to_string()))),
        }
    }
}

impl TestCase for DatabaseConnectionTest {
    fn name(&self) -> &str {
        "Database Connection Test"
    }
    
    fn description(&self) -> &str {
        "Test database connection functionality"
    }
    
    fn setup(&self) -> Result<(), String> {
        // ç¡®ä¿è¿æ¥æ–­å¼€
        if let Ok(mut conn) = self.connection.lock() {
            if conn.is_connected() {
                conn.disconnect()?;
            }
        }
        Ok(())
    }
    
    fn execute(&self) -> TestResult {
        // æµ‹è¯•è¿æ¥
        if let Ok(mut conn) = self.connection.lock() {
            match conn.connect() {
                Ok(_) => {
                    if !conn.is_connected() {
                        return TestResult::Fail("Connection should be established".to_string());
                    }
                }
                Err(e) => return TestResult::Fail(format!("Connection failed: {}", e)),
            }
            
            // æµ‹è¯•æŸ¥è¯¢æ‰§è¡Œ
            match conn.execute_query("SELECT * FROM users") {
                Ok(result) => {
                    if !result.contains("SELECT * FROM users") {
                        return TestResult::Fail("Query result format incorrect".to_string());
                    }
                }
                Err(e) => return TestResult::Fail(format!("Query execution failed: {}", e)),
            }
            
            // æµ‹è¯•æ–­å¼€è¿æ¥
            match conn.disconnect() {
                Ok(_) => {
                    if conn.is_connected() {
                        return TestResult::Fail("Connection should be closed".to_string());
                    }
                }
                Err(e) => return TestResult::Fail(format!("Disconnect failed: {}", e)),
            }
        }
        
        TestResult::Pass
    }
    
    fn teardown(&self) -> Result<(), String> {
        // ç¡®ä¿è¿æ¥æ–­å¼€
        if let Ok(mut conn) = self.connection.lock() {
            if conn.is_connected() {
                conn.disconnect()?;
            }
        }
        Ok(())
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸è½¯ä»¶å·¥ç¨‹ç†è®ºçš„å…³ç³»

è½¯ä»¶æµ‹è¯•ç†è®ºæ˜¯è½¯ä»¶å·¥ç¨‹ç†è®ºçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œä¸è½¯ä»¶è´¨é‡ä¿è¯ã€è½¯ä»¶ç»´æŠ¤ç­‰ç†è®ºå¯†åˆ‡ç›¸å…³ã€‚

**å®šç† 6.1** (æµ‹è¯•ä¸è´¨é‡çš„å…³ç³»)
è½¯ä»¶æµ‹è¯•æ˜¯è½¯ä»¶è´¨é‡ä¿è¯çš„æ ¸å¿ƒæ‰‹æ®µã€‚

**è¯æ˜**ï¼š
é€šè¿‡ç³»ç»ŸåŒ–çš„æµ‹è¯•å¯ä»¥å‘ç°è½¯ä»¶ç¼ºé™·ï¼ŒéªŒè¯è½¯ä»¶åŠŸèƒ½ï¼Œå› æ­¤æ˜¯è´¨é‡ä¿è¯çš„æ ¸å¿ƒæ‰‹æ®µã€‚$\square$

### 6.2 ä¸å½¢å¼åŒ–æ–¹æ³•ç†è®ºçš„å…³ç³»

è½¯ä»¶æµ‹è¯•ç†è®ºå¯ä»¥ç»“åˆå½¢å¼åŒ–æ–¹æ³•ï¼Œæé«˜æµ‹è¯•çš„ç²¾ç¡®æ€§å’Œæœ‰æ•ˆæ€§ã€‚

**å®šç† 6.2** (å½¢å¼åŒ–æµ‹è¯•çš„ä¼˜åŠ¿)
å½¢å¼åŒ–æµ‹è¯•æ¯”ä¼ ç»Ÿæµ‹è¯•æ›´åŠ ç²¾ç¡®å’Œå¯é ã€‚

**è¯æ˜**ï¼š
å½¢å¼åŒ–æµ‹è¯•åŸºäºä¸¥æ ¼çš„æ•°å­¦å®šä¹‰ï¼Œå…·æœ‰æ˜ç¡®çš„æµ‹è¯•é¢„è¨€ï¼Œå› æ­¤æ›´åŠ ç²¾ç¡®å’Œå¯é ã€‚$\square$

### 6.3 ä¸è½¯ä»¶å¯é æ€§ç†è®ºçš„å…³ç³»

è½¯ä»¶æµ‹è¯•ç†è®ºä¸ºè½¯ä»¶å¯é æ€§è¯„ä¼°æä¾›äº†é‡è¦çš„æ•°æ®åŸºç¡€ã€‚

**å®šç† 6.3** (æµ‹è¯•ä¸å¯é æ€§çš„å…³ç³»)
æµ‹è¯•è¦†ç›–ç‡ä¸è½¯ä»¶å¯é æ€§æ­£ç›¸å…³ã€‚

**è¯æ˜**ï¼š
æ›´é«˜çš„æµ‹è¯•è¦†ç›–ç‡æ„å‘³ç€æ›´å¤šçš„ä»£ç è·¯å¾„è¢«éªŒè¯ï¼Œå› æ­¤è½¯ä»¶å¯é æ€§æ›´é«˜ã€‚$\square$

## 7. å‚è€ƒæ–‡çŒ®

1. Myers, G. J., Sandler, C., & Badgett, T. (2011). The Art of Software Testing. Wiley.
2. Spillner, A., Linz, T., & Schaefer, H. (2014). Software Testing Foundations. Rocky Nook.
3. Ammann, P., & Offutt, J. (2016). Introduction to Software Testing. Cambridge University Press.
4. Beizer, B. (1990). Software Testing Techniques. Van Nostrand Reinhold.
5. Jorgensen, P. C. (2013). Software Testing: A Craftsman's Approach. CRC Press.

---

**ç›¸å…³é“¾æ¥**ï¼š
- [07.4.2 å•å…ƒæµ‹è¯•ç†è®º](../07.4.2_å•å…ƒæµ‹è¯•ç†è®º.md)
- [07.4.3 é›†æˆæµ‹è¯•ç†è®º](../07.4.3_é›†æˆæµ‹è¯•ç†è®º.md)
- [07.4.4 ç³»ç»Ÿæµ‹è¯•ç†è®º](../07.4.4_ç³»ç»Ÿæµ‹è¯•ç†è®º.md)
- [07.1.1 å½¢å¼åŒ–è§„æ ¼è¯´æ˜](../07.1.1_å½¢å¼åŒ–è§„æ ¼è¯´æ˜.md)
- [07.1.2 å½¢å¼åŒ–éªŒè¯æ–¹æ³•](../07.1.2_å½¢å¼åŒ–éªŒè¯æ–¹æ³•.md) 