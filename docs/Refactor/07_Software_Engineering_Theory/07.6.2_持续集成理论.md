# 07.6.2 æŒç»­é›†æˆç†è®º

## ğŸ“‹ æ¦‚è¿°

æŒç»­é›†æˆç†è®ºæ˜¯è½¯ä»¶å·¥ç¨‹ä¸­è‡ªåŠ¨åŒ–æ„å»ºã€æµ‹è¯•å’Œéƒ¨ç½²çš„æ ¸å¿ƒç†è®ºä½“ç³»ï¼Œé€šè¿‡å»ºç«‹å½¢å¼åŒ–çš„CI/CDæµç¨‹æ¨¡å‹ï¼Œä¸ºå¿«é€Ÿã€å¯é çš„è½¯ä»¶äº¤ä»˜æä¾›ç§‘å­¦ä¾æ®ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹æŒç»­é›†æˆçš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°RustæŒç»­é›†æˆç¤ºä¾‹
4. åˆ†æCI/CDæµç¨‹ä¸æœ€ä½³å®è·µ

## ğŸ“š ç›®å½•

1. åŸºæœ¬æ¦‚å¿µ
2. å½¢å¼åŒ–å®šä¹‰
3. å®šç†ä¸è¯æ˜
4. ä»£ç å®ç°
5. åº”ç”¨ç¤ºä¾‹
6. ç›¸å…³ç†è®º
7. å‚è€ƒæ–‡çŒ®

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æŒç»­é›†æˆå®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆæŒç»­é›†æˆï¼‰
æŒç»­é›†æˆæ˜¯ä¸€ç§è½¯ä»¶å¼€å‘å®è·µï¼Œé€šè¿‡é¢‘ç¹åœ°å°†ä»£ç é›†æˆåˆ°ä¸»å¹²åˆ†æ”¯ï¼Œå¹¶è‡ªåŠ¨æ‰§è¡Œæ„å»ºå’Œæµ‹è¯•ï¼Œä»¥å¿«é€Ÿå‘ç°å’Œä¿®å¤é—®é¢˜ã€‚

### 1.2 CI/CDæµç¨‹

- ä»£ç æäº¤ï¼ˆCode Commitï¼‰
- è‡ªåŠ¨æ„å»ºï¼ˆAutomated Buildï¼‰
- è‡ªåŠ¨æµ‹è¯•ï¼ˆAutomated Testingï¼‰
- ä»£ç è´¨é‡æ£€æŸ¥ï¼ˆCode Quality Checkï¼‰
- è‡ªåŠ¨éƒ¨ç½²ï¼ˆAutomated Deploymentï¼‰

## 2. å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1**ï¼ˆæŒç»­é›†æˆæ¨¡å‹ï¼‰
æŒç»­é›†æˆæ¨¡å‹æ˜¯ä¸€ä¸ªå…«å…ƒç»„ $CIM = (R, B, T, Q, D, P, F, S)$ï¼Œå…¶ä¸­ï¼š

- $R$ æ˜¯ä»£ç ä»“åº“é›†åˆ
- $B$ æ˜¯æ„å»ºç³»ç»Ÿé›†åˆ
- $T$ æ˜¯æµ‹è¯•ç³»ç»Ÿé›†åˆ
- $Q$ æ˜¯è´¨é‡æ£€æŸ¥é›†åˆ
- $D$ æ˜¯éƒ¨ç½²ç³»ç»Ÿé›†åˆ
- $P$ æ˜¯æµæ°´çº¿é›†åˆ
- $F$ æ˜¯åé¦ˆå‡½æ•°
- $S$ æ˜¯çŠ¶æ€å‡½æ•°

**å®šä¹‰ 2.2**ï¼ˆæ„å»ºæµæ°´çº¿ï¼‰
æ„å»ºæµæ°´çº¿ $P$ æ˜¯ä¸€ä¸ªæœ‰åºçš„æ“ä½œåºåˆ—ï¼š
$P = (commit, build, test, quality, deploy)$

**å®šç† 2.1**ï¼ˆå¿«é€Ÿåé¦ˆåŸåˆ™ï¼‰
æŒç»­é›†æˆé€šè¿‡å¿«é€Ÿåé¦ˆæœºåˆ¶æé«˜è½¯ä»¶è´¨é‡ã€‚

**è¯æ˜**ï¼š
é¢‘ç¹é›†æˆå’Œè‡ªåŠ¨åŒ–æµ‹è¯•èƒ½å¤Ÿå¿«é€Ÿå‘ç°ç¼ºé™·ï¼Œå‡å°‘ä¿®å¤æˆæœ¬ã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

**å®šç† 3.1**ï¼ˆè‡ªåŠ¨åŒ–å¯é æ€§ï¼‰
è‡ªåŠ¨åŒ–æµç¨‹æ¯”æ‰‹åŠ¨æ“ä½œæ›´å¯é å’Œä¸€è‡´ã€‚

**è¯æ˜**ï¼š
è‡ªåŠ¨åŒ–æ¶ˆé™¤äº†äººä¸ºé”™è¯¯ï¼Œç¡®ä¿æ¯æ¬¡æ‰§è¡Œéƒ½éµå¾ªç›¸åŒçš„æ­¥éª¤ã€‚$\square$

**å®šç† 3.2**ï¼ˆé›†æˆé¢‘ç‡ä¸è´¨é‡å…³ç³»ï¼‰
é›†æˆé¢‘ç‡ä¸è½¯ä»¶è´¨é‡å‘ˆæ­£ç›¸å…³å…³ç³»ã€‚

**è¯æ˜**ï¼š
é¢‘ç¹é›†æˆå‡å°‘äº†ä»£ç å·®å¼‚ï¼Œé™ä½äº†åˆå¹¶å†²çªå’Œé›†æˆé—®é¢˜çš„é£é™©ã€‚$\square$

## 4. ä»£ç å®ç°

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};
use std::process::Command;

/// æ„å»ºçŠ¶æ€
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum BuildStatus {
    Pending,
    Running,
    Success,
    Failed,
    Cancelled,
}

/// æµ‹è¯•ç»“æœ
#[derive(Debug, Clone)]
pub struct TestResult {
    pub total_tests: u32,
    pub passed_tests: u32,
    pub failed_tests: u32,
    pub skipped_tests: u32,
    pub coverage: f64,
    pub duration: Duration,
}

/// ä»£ç è´¨é‡æŒ‡æ ‡
#[derive(Debug, Clone)]
pub struct QualityMetrics {
    pub complexity: f64,
    pub maintainability: f64,
    pub test_coverage: f64,
    pub code_duplication: f64,
    pub security_score: f64,
}

/// æ„å»ºä»»åŠ¡
pub struct BuildTask {
    pub id: String,
    pub commit_hash: String,
    pub branch: String,
    pub status: BuildStatus,
    pub start_time: Option<Instant>,
    pub end_time: Option<Instant>,
    pub duration: Option<Duration>,
    pub artifacts: Vec<String>,
    pub logs: Vec<String>,
}

/// æŒç»­é›†æˆæœåŠ¡å™¨
pub struct CIServer {
    pub builds: Arc<Mutex<HashMap<String, BuildTask>>>,
    pub pipelines: Vec<BuildPipeline>,
    pub repositories: Vec<CodeRepository>,
    pub notification_system: NotificationSystem,
}

/// ä»£ç ä»“åº“
pub struct CodeRepository {
    pub id: String,
    pub url: String,
    pub branch: String,
    pub last_commit: String,
    pub webhook_url: String,
}

/// æ„å»ºæµæ°´çº¿
pub struct BuildPipeline {
    pub id: String,
    pub name: String,
    pub stages: Vec<PipelineStage>,
    pub triggers: Vec<Trigger>,
    pub environment: BuildEnvironment,
}

/// æµæ°´çº¿é˜¶æ®µ
pub enum PipelineStage {
    Checkout(CheckoutStage),
    Build(BuildStage),
    Test(TestStage),
    Quality(QualityStage),
    Deploy(DeployStage),
}

/// æ£€å‡ºé˜¶æ®µ
pub struct CheckoutStage {
    pub repository: String,
    pub branch: String,
    pub credentials: Option<String>,
}

/// æ„å»ºé˜¶æ®µ
pub struct BuildStage {
    pub commands: Vec<String>,
    pub artifacts: Vec<String>,
    pub timeout: Duration,
}

/// æµ‹è¯•é˜¶æ®µ
pub struct TestStage {
    pub test_commands: Vec<String>,
    pub coverage_threshold: f64,
    pub timeout: Duration,
}

/// è´¨é‡æ£€æŸ¥é˜¶æ®µ
pub struct QualityStage {
    pub linter_commands: Vec<String>,
    pub security_scan: bool,
    pub quality_threshold: f64,
}

/// éƒ¨ç½²é˜¶æ®µ
pub struct DeployStage {
    pub environment: String,
    pub deployment_script: String,
    pub rollback_script: Option<String>,
}

/// è§¦å‘å™¨
pub enum Trigger {
    Push { branch: String },
    PullRequest { branch: String },
    Schedule { cron: String },
    Manual,
}

/// æ„å»ºç¯å¢ƒ
pub struct BuildEnvironment {
    pub os: String,
    pub runtime: String,
    pub dependencies: Vec<String>,
    pub variables: HashMap<String, String>,
}

/// é€šçŸ¥ç³»ç»Ÿ
pub struct NotificationSystem {
    pub channels: Vec<NotificationChannel>,
    pub templates: HashMap<String, String>,
}

/// é€šçŸ¥æ¸ é“
pub enum NotificationChannel {
    Email { recipients: Vec<String> },
    Slack { webhook: String },
    Teams { webhook: String },
    Webhook { url: String },
}

/// æ„å»ºæ‰§è¡Œå™¨
pub struct BuildExecutor;

impl BuildExecutor {
    /// æ‰§è¡Œæ„å»ºæµæ°´çº¿
    pub fn execute_pipeline(&self, pipeline: &BuildPipeline, commit_hash: &str) -> BuildResult {
        let mut result = BuildResult {
            success: true,
            stages: Vec::new(),
            total_duration: Duration::from_secs(0),
            artifacts: Vec::new(),
        };
        
        for stage in &pipeline.stages {
            let stage_result = self.execute_stage(stage, commit_hash);
            result.stages.push(stage_result.clone());
            
            if !stage_result.success {
                result.success = false;
                break;
            }
            
            result.total_duration += stage_result.duration;
        }
        
        result
    }
    
    /// æ‰§è¡Œå•ä¸ªé˜¶æ®µ
    fn execute_stage(&self, stage: &PipelineStage, commit_hash: &str) -> StageResult {
        match stage {
            PipelineStage::Checkout(checkout) => self.execute_checkout(checkout, commit_hash),
            PipelineStage::Build(build) => self.execute_build(build),
            PipelineStage::Test(test) => self.execute_test(test),
            PipelineStage::Quality(quality) => self.execute_quality_check(quality),
            PipelineStage::Deploy(deploy) => self.execute_deploy(deploy),
        }
    }
    
    /// æ‰§è¡Œæ£€å‡ºé˜¶æ®µ
    fn execute_checkout(&self, checkout: &CheckoutStage, commit_hash: &str) -> StageResult {
        let start_time = Instant::now();
        
        // æ¨¡æ‹Ÿgitæ£€å‡º
        let output = Command::new("git")
            .args(&["clone", &checkout.repository, "workspace"])
            .output();
        
        let success = output.is_ok();
        let duration = start_time.elapsed();
        
        StageResult {
            name: "Checkout".to_string(),
            success,
            duration,
            logs: vec![format!("Checked out commit: {}", commit_hash)],
        }
    }
    
    /// æ‰§è¡Œæ„å»ºé˜¶æ®µ
    fn execute_build(&self, build: &BuildStage) -> StageResult {
        let start_time = Instant::now();
        let mut logs = Vec::new();
        let mut success = true;
        
        for command in &build.commands {
            logs.push(format!("Executing: {}", command));
            
            // æ¨¡æ‹Ÿå‘½ä»¤æ‰§è¡Œ
            if command.contains("cargo build") {
                logs.push("Building Rust project...".to_string());
                // æ¨¡æ‹Ÿæ„å»ºæˆåŠŸ
            } else if command.contains("npm install") {
                logs.push("Installing Node.js dependencies...".to_string());
                // æ¨¡æ‹Ÿå®‰è£…æˆåŠŸ
            }
        }
        
        let duration = start_time.elapsed();
        
        StageResult {
            name: "Build".to_string(),
            success,
            duration,
            logs,
        }
    }
    
    /// æ‰§è¡Œæµ‹è¯•é˜¶æ®µ
    fn execute_test(&self, test: &TestStage) -> StageResult {
        let start_time = Instant::now();
        let mut logs = Vec::new();
        
        for command in &test.test_commands {
            logs.push(format!("Running test: {}", command));
            
            if command.contains("cargo test") {
                logs.push("Running Rust tests...".to_string());
                logs.push("Test results: 100 tests passed, 0 failed".to_string());
            } else if command.contains("npm test") {
                logs.push("Running JavaScript tests...".to_string());
                logs.push("Test results: 50 tests passed, 0 failed".to_string());
            }
        }
        
        let duration = start_time.elapsed();
        
        StageResult {
            name: "Test".to_string(),
            success: true,
            duration,
            logs,
        }
    }
    
    /// æ‰§è¡Œè´¨é‡æ£€æŸ¥é˜¶æ®µ
    fn execute_quality_check(&self, quality: &QualityStage) -> StageResult {
        let start_time = Instant::now();
        let mut logs = Vec::new();
        
        for command in &quality.linter_commands {
            logs.push(format!("Running linter: {}", command));
            
            if command.contains("cargo clippy") {
                logs.push("Running Rust linter...".to_string());
                logs.push("No warnings found".to_string());
            } else if command.contains("eslint") {
                logs.push("Running JavaScript linter...".to_string());
                logs.push("No issues found".to_string());
            }
        }
        
        if quality.security_scan {
            logs.push("Running security scan...".to_string());
            logs.push("No security vulnerabilities found".to_string());
        }
        
        let duration = start_time.elapsed();
        
        StageResult {
            name: "Quality Check".to_string(),
            success: true,
            duration,
            logs,
        }
    }
    
    /// æ‰§è¡Œéƒ¨ç½²é˜¶æ®µ
    fn execute_deploy(&self, deploy: &DeployStage) -> StageResult {
        let start_time = Instant::now();
        let mut logs = Vec::new();
        
        logs.push(format!("Deploying to environment: {}", deploy.environment));
        logs.push(format!("Executing deployment script: {}", deploy.deployment_script));
        logs.push("Deployment completed successfully".to_string());
        
        let duration = start_time.elapsed();
        
        StageResult {
            name: "Deploy".to_string(),
            success: true,
            duration,
            logs,
        }
    }
}

/// æ„å»ºç»“æœ
pub struct BuildResult {
    pub success: bool,
    pub stages: Vec<StageResult>,
    pub total_duration: Duration,
    pub artifacts: Vec<String>,
}

/// é˜¶æ®µç»“æœ
#[derive(Debug, Clone)]
pub struct StageResult {
    pub name: String,
    pub success: bool,
    pub duration: Duration,
    pub logs: Vec<String>,
}

/// æŒç»­é›†æˆç®¡ç†å™¨
pub struct CIManager {
    pub server: CIServer,
    pub executor: BuildExecutor,
    pub webhook_handler: WebhookHandler,
}

impl CIManager {
    pub fn new() -> Self {
        Self {
            server: CIServer {
                builds: Arc::new(Mutex::new(HashMap::new())),
                pipelines: Vec::new(),
                repositories: Vec::new(),
                notification_system: NotificationSystem {
                    channels: Vec::new(),
                    templates: HashMap::new(),
                },
            },
            executor: BuildExecutor,
            webhook_handler: WebhookHandler,
        }
    }
    
    /// æ·»åŠ ä»£ç ä»“åº“
    pub fn add_repository(&mut self, repository: CodeRepository) {
        self.server.repositories.push(repository);
    }
    
    /// åˆ›å»ºæ„å»ºæµæ°´çº¿
    pub fn create_pipeline(&mut self, pipeline: BuildPipeline) {
        self.server.pipelines.push(pipeline);
    }
    
    /// å¤„ç†ä»£ç æ¨é€äº‹ä»¶
    pub fn handle_push_event(&mut self, repository: &str, branch: &str, commit_hash: &str) {
        // æŸ¥æ‰¾åŒ¹é…çš„æµæ°´çº¿
        for pipeline in &self.server.pipelines {
            if Self::should_trigger_pipeline(pipeline, repository, branch) {
                self.trigger_build(pipeline, commit_hash);
            }
        }
    }
    
    /// åˆ¤æ–­æ˜¯å¦åº”è¯¥è§¦å‘æµæ°´çº¿
    fn should_trigger_pipeline(pipeline: &BuildPipeline, repository: &str, branch: &str) -> bool {
        pipeline.triggers.iter().any(|trigger| {
            match trigger {
                Trigger::Push { branch: trigger_branch } => {
                    trigger_branch == branch
                }
                _ => false,
            }
        })
    }
    
    /// è§¦å‘æ„å»º
    fn trigger_build(&mut self, pipeline: &BuildPipeline, commit_hash: &str) {
        let build_task = BuildTask {
            id: Self::generate_build_id(),
            commit_hash: commit_hash.to_string(),
            branch: "main".to_string(),
            status: BuildStatus::Running,
            start_time: Some(Instant::now()),
            end_time: None,
            duration: None,
            artifacts: Vec::new(),
            logs: Vec::new(),
        };
        
        // ä¿å­˜æ„å»ºä»»åŠ¡
        if let Ok(mut builds) = self.server.builds.lock() {
            builds.insert(build_task.id.clone(), build_task);
        }
        
        // å¼‚æ­¥æ‰§è¡Œæ„å»º
        let pipeline_clone = pipeline.clone();
        let builds_clone = Arc::clone(&self.server.builds);
        let executor = self.executor.clone();
        
        std::thread::spawn(move || {
            let result = executor.execute_pipeline(&pipeline_clone, commit_hash);
            
            // æ›´æ–°æ„å»ºçŠ¶æ€
            if let Ok(mut builds) = builds_clone.lock() {
                if let Some(build) = builds.get_mut(&build_task.id) {
                    build.status = if result.success {
                        BuildStatus::Success
                    } else {
                        BuildStatus::Failed
                    };
                    build.end_time = Some(Instant::now());
                    build.duration = Some(result.total_duration);
                    build.artifacts = result.artifacts;
                }
            }
        });
    }
    
    fn generate_build_id() -> String {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        use std::time::SystemTime;
        
        let mut hasher = DefaultHasher::new();
        SystemTime::now().hash(&mut hasher);
        format!("build-{:x}", hasher.finish())
    }
}

/// Webhookå¤„ç†å™¨
pub struct WebhookHandler;

impl WebhookHandler {
    pub fn handle_github_webhook(&self, payload: &str) -> WebhookResult {
        // è§£æGitHub webhook payload
        // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥è§£æJSON
        if payload.contains("push") {
            WebhookResult {
                event_type: "push".to_string(),
                repository: "example/repo".to_string(),
                branch: "main".to_string(),
                commit_hash: "abc123".to_string(),
            }
        } else {
            WebhookResult {
                event_type: "unknown".to_string(),
                repository: "".to_string(),
                branch: "".to_string(),
                commit_hash: "".to_string(),
            }
        }
    }
}

/// Webhookç»“æœ
pub struct WebhookResult {
    pub event_type: String,
    pub repository: String,
    pub branch: String,
    pub commit_hash: String,
}

// ä¸ºBuildExecutorå®ç°Clone
impl Clone for BuildExecutor {
    fn clone(&self) -> Self {
        BuildExecutor
    }
}

// ä¸ºPipelineStageå®ç°Clone
impl Clone for PipelineStage {
    fn clone(&self) -> Self {
        match self {
            PipelineStage::Checkout(checkout) => PipelineStage::Checkout(checkout.clone()),
            PipelineStage::Build(build) => PipelineStage::Build(build.clone()),
            PipelineStage::Test(test) => PipelineStage::Test(test.clone()),
            PipelineStage::Quality(quality) => PipelineStage::Quality(quality.clone()),
            PipelineStage::Deploy(deploy) => PipelineStage::Deploy(deploy.clone()),
        }
    }
}

// ä¸ºç›¸å…³ç»“æ„ä½“å®ç°Clone
impl Clone for CheckoutStage {
    fn clone(&self) -> Self {
        Self {
            repository: self.repository.clone(),
            branch: self.branch.clone(),
            credentials: self.credentials.clone(),
        }
    }
}

impl Clone for BuildStage {
    fn clone(&self) -> Self {
        Self {
            commands: self.commands.clone(),
            artifacts: self.artifacts.clone(),
            timeout: self.timeout,
        }
    }
}

impl Clone for TestStage {
    fn clone(&self) -> Self {
        Self {
            test_commands: self.test_commands.clone(),
            coverage_threshold: self.coverage_threshold,
            timeout: self.timeout,
        }
    }
}

impl Clone for QualityStage {
    fn clone(&self) -> Self {
        Self {
            linter_commands: self.linter_commands.clone(),
            security_scan: self.security_scan,
            quality_threshold: self.quality_threshold,
        }
    }
}

impl Clone for DeployStage {
    fn clone(&self) -> Self {
        Self {
            environment: self.environment.clone(),
            deployment_script: self.deployment_script.clone(),
            rollback_script: self.rollback_script.clone(),
        }
    }
}

impl Clone for BuildPipeline {
    fn clone(&self) -> Self {
        Self {
            id: self.id.clone(),
            name: self.name.clone(),
            stages: self.stages.clone(),
            triggers: self.triggers.clone(),
            environment: self.environment.clone(),
        }
    }
}

impl Clone for BuildEnvironment {
    fn clone(&self) -> Self {
        Self {
            os: self.os.clone(),
            runtime: self.runtime.clone(),
            dependencies: self.dependencies.clone(),
            variables: self.variables.clone(),
        }
    }
}

impl Clone for Trigger {
    fn clone(&self) -> Self {
        match self {
            Trigger::Push { branch } => Trigger::Push { branch: branch.clone() },
            Trigger::PullRequest { branch } => Trigger::PullRequest { branch: branch.clone() },
            Trigger::Schedule { cron } => Trigger::Schedule { cron: cron.clone() },
            Trigger::Manual => Trigger::Manual,
        }
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_build_pipeline_creation() {
        let mut ci_manager = CIManager::new();
        
        let pipeline = BuildPipeline {
            id: "pipeline-1".to_string(),
            name: "Rust CI Pipeline".to_string(),
            stages: vec![
                PipelineStage::Checkout(CheckoutStage {
                    repository: "https://github.com/example/rust-project".to_string(),
                    branch: "main".to_string(),
                    credentials: None,
                }),
                PipelineStage::Build(BuildStage {
                    commands: vec!["cargo build --release".to_string()],
                    artifacts: vec!["target/release/app".to_string()],
                    timeout: Duration::from_secs(300),
                }),
                PipelineStage::Test(TestStage {
                    test_commands: vec!["cargo test".to_string()],
                    coverage_threshold: 0.8,
                    timeout: Duration::from_secs(120),
                }),
                PipelineStage::Quality(QualityStage {
                    linter_commands: vec!["cargo clippy".to_string()],
                    security_scan: true,
                    quality_threshold: 0.9,
                }),
                PipelineStage::Deploy(DeployStage {
                    environment: "staging".to_string(),
                    deployment_script: "deploy.sh".to_string(),
                    rollback_script: Some("rollback.sh".to_string()),
                }),
            ],
            triggers: vec![
                Trigger::Push { branch: "main".to_string() },
                Trigger::PullRequest { branch: "main".to_string() },
            ],
            environment: BuildEnvironment {
                os: "ubuntu-latest".to_string(),
                runtime: "rust:1.70".to_string(),
                dependencies: vec!["git".to_string()],
                variables: HashMap::new(),
            },
        };
        
        ci_manager.create_pipeline(pipeline);
        assert_eq!(ci_manager.server.pipelines.len(), 1);
    }
    
    #[test]
    fn test_webhook_handling() {
        let webhook_handler = WebhookHandler;
        
        let payload = r#"{
            "ref": "refs/heads/main",
            "repository": {"full_name": "example/repo"},
            "head_commit": {"id": "abc123"}
        }"#;
        
        let result = webhook_handler.handle_github_webhook(payload);
        assert_eq!(result.event_type, "push");
        assert_eq!(result.repository, "example/repo");
        assert_eq!(result.branch, "main");
        assert_eq!(result.commit_hash, "abc123");
    }
    
    #[test]
    fn test_build_execution() {
        let executor = BuildExecutor;
        
        let pipeline = BuildPipeline {
            id: "test-pipeline".to_string(),
            name: "Test Pipeline".to_string(),
            stages: vec![
                PipelineStage::Checkout(CheckoutStage {
                    repository: "https://github.com/test/repo".to_string(),
                    branch: "main".to_string(),
                    credentials: None,
                }),
                PipelineStage::Build(BuildStage {
                    commands: vec!["echo 'Building...'".to_string()],
                    artifacts: vec![],
                    timeout: Duration::from_secs(60),
                }),
                PipelineStage::Test(TestStage {
                    test_commands: vec!["echo 'Testing...'".to_string()],
                    coverage_threshold: 0.8,
                    timeout: Duration::from_secs(60),
                }),
            ],
            triggers: vec![],
            environment: BuildEnvironment {
                os: "linux".to_string(),
                runtime: "bash".to_string(),
                dependencies: vec![],
                variables: HashMap::new(),
            },
        };
        
        let result = executor.execute_pipeline(&pipeline, "test-commit");
        assert!(result.success);
        assert_eq!(result.stages.len(), 3);
        assert!(result.total_duration > Duration::from_secs(0));
    }
    
    #[test]
    fn test_ci_manager_integration() {
        let mut ci_manager = CIManager::new();
        
        // æ·»åŠ ä»“åº“
        let repository = CodeRepository {
            id: "repo-1".to_string(),
            url: "https://github.com/example/repo".to_string(),
            branch: "main".to_string(),
            last_commit: "abc123".to_string(),
            webhook_url: "https://ci.example.com/webhook".to_string(),
        };
        ci_manager.add_repository(repository);
        
        // åˆ›å»ºæµæ°´çº¿
        let pipeline = BuildPipeline {
            id: "pipeline-1".to_string(),
            name: "Test Pipeline".to_string(),
            stages: vec![
                PipelineStage::Build(BuildStage {
                    commands: vec!["echo 'Build successful'".to_string()],
                    artifacts: vec![],
                    timeout: Duration::from_secs(60),
                }),
            ],
            triggers: vec![Trigger::Push { branch: "main".to_string() }],
            environment: BuildEnvironment {
                os: "linux".to_string(),
                runtime: "bash".to_string(),
                dependencies: vec![],
                variables: HashMap::new(),
            },
        };
        ci_manager.create_pipeline(pipeline);
        
        // å¤„ç†æ¨é€äº‹ä»¶
        ci_manager.handle_push_event("example/repo", "main", "def456");
        
        // éªŒè¯æ„å»ºä»»åŠ¡è¢«åˆ›å»º
        let builds = ci_manager.server.builds.lock().unwrap();
        assert!(!builds.is_empty());
    }
}
```

## 6. ç›¸å…³ç†è®º

- è½¯ä»¶æ„å»ºç†è®º
- è‡ªåŠ¨åŒ–æµ‹è¯•ç†è®º
- éƒ¨ç½²ç†è®º
- ç‰ˆæœ¬æ§åˆ¶ç†è®º

## 7. å‚è€ƒæ–‡çŒ®

1. Fowler, M. "Continuous Integration"
2. Humble, J., Farley, D. "Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation"
3. Kim, G., et al. "The DevOps Handbook"
4. Allspaw, J., Robbins, J. "Web Operations: Keeping the Data On Time"

---

**ç›¸å…³é“¾æ¥**ï¼š

- [07.6.1 æ•æ·å¼€å‘ç†è®º](../07.6.1_æ•æ·å¼€å‘ç†è®º.md)
- [07.6.3 æŒç»­éƒ¨ç½²ç†è®º](../07.6.3_æŒç»­éƒ¨ç½²ç†è®º.md)
- [07.6.4 DevOpsç†è®º](../07.6.4_DevOpsç†è®º.md)
