# 07.6.1 æ•æ·å¼€å‘ç†è®º

## ğŸ“‹ æ¦‚è¿°

æ•æ·å¼€å‘ç†è®ºæ˜¯è½¯ä»¶å·¥ç¨‹ä¸­ç°ä»£è½¯ä»¶å¼€å‘æ–¹æ³•è®ºçš„æ ¸å¿ƒç†è®ºä½“ç³»ï¼Œé€šè¿‡å»ºç«‹å½¢å¼åŒ–çš„æ•æ·æ¡†æ¶å’Œæµç¨‹æ¨¡å‹ï¼Œä¸ºå¿«é€Ÿå“åº”å˜åŒ–ã€æŒç»­äº¤ä»˜ä»·å€¼æä¾›ç§‘å­¦ä¾æ®ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹æ•æ·å¼€å‘çš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°Rustæ•æ·å¼€å‘ç¤ºä¾‹
4. åˆ†ææ•æ·å®è·µä¸åŸåˆ™

## ğŸ“š ç›®å½•

1. åŸºæœ¬æ¦‚å¿µ
2. å½¢å¼åŒ–å®šä¹‰
3. å®šç†ä¸è¯æ˜
4. ä»£ç å®ç°
5. åº”ç”¨ç¤ºä¾‹
6. ç›¸å…³ç†è®º
7. å‚è€ƒæ–‡çŒ®

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ•æ·å¼€å‘å®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆæ•æ·å¼€å‘ï¼‰
æ•æ·å¼€å‘æ˜¯ä¸€ç§ä»¥äººä¸ºæ ¸å¿ƒã€è¿­ä»£ã€å¢é‡çš„è½¯ä»¶å¼€å‘æ–¹æ³•ï¼Œå¼ºè°ƒå¿«é€Ÿå“åº”å˜åŒ–ã€æŒç»­äº¤ä»˜å’Œå›¢é˜Ÿåä½œã€‚

### 1.2 æ•æ·åŸåˆ™

- ä¸ªä½“å’Œäº’åŠ¨é«˜äºæµç¨‹å’Œå·¥å…·
- å·¥ä½œçš„è½¯ä»¶é«˜äºè¯¦å°½çš„æ–‡æ¡£
- å®¢æˆ·åˆä½œé«˜äºåˆåŒè°ˆåˆ¤
- å“åº”å˜åŒ–é«˜äºéµå¾ªè®¡åˆ’

## 2. å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1**ï¼ˆæ•æ·å¼€å‘æ¨¡å‹ï¼‰
æ•æ·å¼€å‘æ¨¡å‹æ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $ADM = (T, S, I, R, V, F, C)$ï¼Œå…¶ä¸­ï¼š

- $T$ æ˜¯å›¢é˜Ÿé›†åˆ
- $S$ æ˜¯å†²åˆºé›†åˆ
- $I$ æ˜¯è¿­ä»£é›†åˆ
- $R$ æ˜¯éœ€æ±‚é›†åˆ
- $V$ æ˜¯ä»·å€¼å‡½æ•°
- $F$ æ˜¯åé¦ˆå‡½æ•°
- $C$ æ˜¯å˜æ›´å‡½æ•°

**å®šä¹‰ 2.2**ï¼ˆç”¨æˆ·æ•…äº‹ï¼‰
ç”¨æˆ·æ•…äº‹ $US$ æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(role, feature, value)$ï¼Œè¡¨ç¤ºè§’è‰²ã€åŠŸèƒ½ç‰¹æ€§å’Œä»·å€¼ã€‚

**å®šç† 2.1**ï¼ˆæ•æ·è¿­ä»£æ€§ï¼‰
æ•æ·å¼€å‘é€šè¿‡çŸ­å‘¨æœŸè¿­ä»£å®ç°æŒç»­æ”¹è¿›ã€‚

**è¯æ˜**ï¼š
æ¯ä¸ªè¿­ä»£éƒ½åŒ…å«è®¡åˆ’ã€å¼€å‘ã€æµ‹è¯•å’Œå›é¡¾ï¼Œå½¢æˆæŒç»­æ”¹è¿›çš„å¾ªç¯ã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

**å®šç† 3.1**ï¼ˆä»·å€¼é©±åŠ¨åŸåˆ™ï¼‰
æ•æ·å¼€å‘ä»¥äº¤ä»˜å®¢æˆ·ä»·å€¼ä¸ºæ ¸å¿ƒç›®æ ‡ã€‚

**è¯æ˜**ï¼š
é€šè¿‡é¢‘ç¹äº¤ä»˜å¯å·¥ä½œçš„è½¯ä»¶ï¼ŒåŠæ—¶è·å¾—å®¢æˆ·åé¦ˆï¼Œç¡®ä¿å¼€å‘æ–¹å‘æ­£ç¡®ã€‚$\square$

**å®šç† 3.2**ï¼ˆå˜åŒ–é€‚åº”æ€§ï¼‰
æ•æ·å¼€å‘èƒ½å¤Ÿå¿«é€Ÿé€‚åº”éœ€æ±‚å˜åŒ–ã€‚

**è¯æ˜**ï¼š
çŸ­å‘¨æœŸè¿­ä»£å’ŒæŒç»­é›†æˆä½¿å¾—ç³»ç»Ÿèƒ½å¤Ÿå¿«é€Ÿå“åº”å˜åŒ–ã€‚$\square$

## 4. ä»£ç å®ç°

```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};
use std::sync::{Arc, Mutex};

/// ç”¨æˆ·è§’è‰²
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum UserRole {
    ProductOwner,
    ScrumMaster,
    Developer,
    Tester,
    Stakeholder,
}

/// ç”¨æˆ·æ•…äº‹ä¼˜å…ˆçº§
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum StoryPriority {
    Low,
    Medium,
    High,
    Critical,
}

/// ä»»åŠ¡çŠ¶æ€
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TaskStatus {
    ToDo,
    InProgress,
    InReview,
    Done,
}

/// ç”¨æˆ·æ•…äº‹
pub struct UserStory {
    pub id: String,
    pub title: String,
    pub description: String,
    pub role: UserRole,
    pub priority: StoryPriority,
    pub story_points: u32,
    pub acceptance_criteria: Vec<String>,
    pub status: TaskStatus,
    pub created_at: Instant,
    pub completed_at: Option<Instant>,
}

/// å†²åˆºï¼ˆSprintï¼‰
pub struct Sprint {
    pub id: String,
    pub name: String,
    pub start_date: Instant,
    pub end_date: Instant,
    pub duration: Duration,
    pub velocity: u32,
    pub stories: Vec<UserStory>,
    pub team_capacity: u32,
}

/// æ•æ·å›¢é˜Ÿ
pub struct AgileTeam {
    pub id: String,
    pub name: String,
    pub members: Vec<TeamMember>,
    pub roles: HashMap<UserRole, Vec<String>>,
    pub velocity_history: Vec<u32>,
}

/// å›¢é˜Ÿæˆå‘˜
pub struct TeamMember {
    pub id: String,
    pub name: String,
    pub role: UserRole,
    pub skills: Vec<String>,
    pub availability: f64, // 0.0 to 1.0
}

/// äº§å“å¾…åŠäº‹é¡¹
pub struct ProductBacklog {
    pub stories: Vec<UserStory>,
    pub priorities: HashMap<String, StoryPriority>,
}

impl ProductBacklog {
    pub fn new() -> Self {
        Self {
            stories: Vec::new(),
            priorities: HashMap::new(),
        }
    }
    
    pub fn add_story(&mut self, story: UserStory) {
        self.priorities.insert(story.id.clone(), story.priority.clone());
        self.stories.push(story);
    }
    
    pub fn prioritize_stories(&mut self) {
        self.stories.sort_by(|a, b| b.priority.cmp(&a.priority));
    }
    
    pub fn get_top_stories(&self, count: usize) -> Vec<&UserStory> {
        self.stories.iter().take(count).collect()
    }
    
    pub fn estimate_velocity(&self, team_capacity: u32) -> u32 {
        // åŸºäºå†å²æ•°æ®å’Œå›¢é˜Ÿå®¹é‡ä¼°ç®—é€Ÿåº¦
        let total_points: u32 = self.stories.iter().map(|s| s.story_points).sum();
        (total_points as f64 * 0.8).round() as u32 // å‡è®¾80%å®Œæˆç‡
    }
}

/// å†²åˆºè§„åˆ’å™¨
pub struct SprintPlanner;

impl SprintPlanner {
    pub fn plan_sprint(backlog: &ProductBacklog, team_capacity: u32, sprint_duration: Duration) -> Sprint {
        let velocity = backlog.estimate_velocity(team_capacity);
        let available_stories = Self::select_stories_for_sprint(backlog, velocity);
        
        Sprint {
            id: Self::generate_sprint_id(),
            name: format!("Sprint {}", Self::generate_sprint_id()),
            start_date: Instant::now(),
            end_date: Instant::now() + sprint_duration,
            duration: sprint_duration,
            velocity,
            stories: available_stories,
            team_capacity,
        }
    }
    
    fn select_stories_for_sprint(backlog: &ProductBacklog, velocity: u32) -> Vec<UserStory> {
        let mut selected_stories = Vec::new();
        let mut total_points = 0;
        
        for story in &backlog.stories {
            if total_points + story.story_points <= velocity {
                selected_stories.push(story.clone());
                total_points += story.story_points;
            } else {
                break;
            }
        }
        
        selected_stories
    }
    
    fn generate_sprint_id() -> String {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        use std::time::SystemTime;
        
        let mut hasher = DefaultHasher::new();
        SystemTime::now().hash(&mut hasher);
        format!("{:x}", hasher.finish())
    }
}

/// æ¯æ—¥ç«™ä¼šç®¡ç†å™¨
pub struct DailyStandup {
    pub sprint: Arc<Mutex<Sprint>>,
    pub team: Arc<Mutex<AgileTeam>>,
    pub updates: Vec<StandupUpdate>,
}

/// ç«™ä¼šæ›´æ–°
pub struct StandupUpdate {
    pub member_id: String,
    pub yesterday_work: String,
    pub today_plan: String,
    pub blockers: Vec<String>,
    pub timestamp: Instant,
}

impl DailyStandup {
    pub fn new(sprint: Arc<Mutex<Sprint>>, team: Arc<Mutex<AgileTeam>>) -> Self {
        Self {
            sprint,
            team,
            updates: Vec::new(),
        }
    }
    
    pub fn add_update(&mut self, update: StandupUpdate) {
        self.updates.push(update);
    }
    
    pub fn get_sprint_progress(&self) -> SprintProgress {
        let sprint = self.sprint.lock().unwrap();
        let total_stories = sprint.stories.len();
        let completed_stories = sprint.stories.iter()
            .filter(|s| s.status == TaskStatus::Done)
            .count();
        
        SprintProgress {
            total_stories,
            completed_stories,
            completion_rate: if total_stories > 0 {
                completed_stories as f64 / total_stories as f64
            } else {
                0.0
            },
            remaining_days: sprint.end_date.duration_since(Instant::now()).as_secs() / 86400,
        }
    }
    
    pub fn identify_blockers(&self) -> Vec<String> {
        self.updates.iter()
            .flat_map(|update| update.blockers.clone())
            .collect()
    }
}

#[derive(Debug)]
pub struct SprintProgress {
    pub total_stories: usize,
    pub completed_stories: usize,
    pub completion_rate: f64,
    pub remaining_days: u64,
}

/// æŒç»­é›†æˆç®¡ç†å™¨
pub struct ContinuousIntegration {
    pub builds: Vec<Build>,
    pub tests: Vec<TestResult>,
    pub deployments: Vec<Deployment>,
}

/// æ„å»º
pub struct Build {
    pub id: String,
    pub status: BuildStatus,
    pub duration: Duration,
    pub artifacts: Vec<String>,
    pub timestamp: Instant,
}

/// æ„å»ºçŠ¶æ€
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum BuildStatus {
    Success,
    Failed,
    InProgress,
}

/// æµ‹è¯•ç»“æœ
pub struct TestResult {
    pub build_id: String,
    pub total_tests: u32,
    pub passed_tests: u32,
    pub failed_tests: u32,
    pub coverage: f64,
    pub duration: Duration,
}

/// éƒ¨ç½²
pub struct Deployment {
    pub id: String,
    pub environment: String,
    pub status: DeploymentStatus,
    pub version: String,
    pub timestamp: Instant,
}

/// éƒ¨ç½²çŠ¶æ€
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DeploymentStatus {
    Success,
    Failed,
    InProgress,
    Rollback,
}

impl ContinuousIntegration {
    pub fn new() -> Self {
        Self {
            builds: Vec::new(),
            tests: Vec::new(),
            deployments: Vec::new(),
        }
    }
    
    pub fn trigger_build(&mut self, source_code: &str) -> Build {
        let build = Build {
            id: Self::generate_build_id(),
            status: BuildStatus::InProgress,
            duration: Duration::from_secs(0),
            artifacts: vec!["binary".to_string(), "docs".to_string()],
            timestamp: Instant::now(),
        };
        
        self.builds.push(build.clone());
        build
    }
    
    pub fn run_tests(&mut self, build_id: &str) -> TestResult {
        let test_result = TestResult {
            build_id: build_id.to_string(),
            total_tests: 100,
            passed_tests: 95,
            failed_tests: 5,
            coverage: 0.85,
            duration: Duration::from_secs(30),
        };
        
        self.tests.push(test_result.clone());
        test_result
    }
    
    pub fn deploy(&mut self, build_id: &str, environment: &str) -> Deployment {
        let deployment = Deployment {
            id: Self::generate_deployment_id(),
            environment: environment.to_string(),
            status: DeploymentStatus::Success,
            version: build_id.to_string(),
            timestamp: Instant::now(),
        };
        
        self.deployments.push(deployment.clone());
        deployment
    }
    
    fn generate_build_id() -> String {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        use std::time::SystemTime;
        
        let mut hasher = DefaultHasher::new();
        SystemTime::now().hash(&mut hasher);
        format!("build-{:x}", hasher.finish())
    }
    
    fn generate_deployment_id() -> String {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        use std::time::SystemTime;
        
        let mut hasher = DefaultHasher::new();
        SystemTime::now().hash(&mut hasher);
        format!("deploy-{:x}", hasher.finish())
    }
}

/// æ•æ·é¡¹ç›®ç®¡ç†å™¨
pub struct AgileProjectManager {
    pub backlog: ProductBacklog,
    pub current_sprint: Option<Arc<Mutex<Sprint>>>,
    pub team: Arc<Mutex<AgileTeam>>,
    pub ci: ContinuousIntegration,
    pub standup: Option<DailyStandup>,
}

impl AgileProjectManager {
    pub fn new() -> Self {
        Self {
            backlog: ProductBacklog::new(),
            current_sprint: None,
            team: Arc::new(Mutex::new(AgileTeam {
                id: "team-1".to_string(),
                name: "Development Team".to_string(),
                members: Vec::new(),
                roles: HashMap::new(),
                velocity_history: Vec::new(),
            })),
            ci: ContinuousIntegration::new(),
            standup: None,
        }
    }
    
    pub fn start_sprint(&mut self, duration: Duration) {
        let team_capacity = 40; // å‡è®¾å›¢é˜Ÿå®¹é‡ä¸º40æ•…äº‹ç‚¹
        let sprint = SprintPlanner::plan_sprint(&self.backlog, team_capacity, duration);
        self.current_sprint = Some(Arc::new(Mutex::new(sprint)));
        
        // åˆå§‹åŒ–æ¯æ—¥ç«™ä¼š
        if let Some(sprint) = &self.current_sprint {
            self.standup = Some(DailyStandup::new(
                Arc::clone(sprint),
                Arc::clone(&self.team)
            ));
        }
    }
    
    pub fn complete_story(&mut self, story_id: &str) {
        if let Some(sprint) = &self.current_sprint {
            let mut sprint = sprint.lock().unwrap();
            if let Some(story) = sprint.stories.iter_mut().find(|s| s.id == story_id) {
                story.status = TaskStatus::Done;
                story.completed_at = Some(Instant::now());
            }
        }
    }
    
    pub fn get_sprint_status(&self) -> Option<SprintProgress> {
        self.standup.as_ref().map(|standup| standup.get_sprint_progress())
    }
    
    pub fn trigger_ci_pipeline(&mut self) {
        let build = self.ci.trigger_build("source code");
        let test_result = self.ci.run_tests(&build.id);
        
        if test_result.failed_tests == 0 {
            self.ci.deploy(&build.id, "staging");
        }
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_product_backlog() {
        let mut backlog = ProductBacklog::new();
        
        let story1 = UserStory {
            id: "US-001".to_string(),
            title: "ç”¨æˆ·ç™»å½•åŠŸèƒ½".to_string(),
            description: "ä½œä¸ºç”¨æˆ·ï¼Œæˆ‘å¸Œæœ›èƒ½å¤Ÿç™»å½•ç³»ç»Ÿ".to_string(),
            role: UserRole::Stakeholder,
            priority: StoryPriority::High,
            story_points: 8,
            acceptance_criteria: vec![
                "ç”¨æˆ·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ".to_string(),
                "ç³»ç»ŸéªŒè¯ç”¨æˆ·å‡­æ®".to_string(),
                "ç™»å½•æˆåŠŸåè·³è½¬åˆ°ä¸»é¡µ".to_string(),
            ],
            status: TaskStatus::ToDo,
            created_at: Instant::now(),
            completed_at: None,
        };
        
        backlog.add_story(story1);
        backlog.prioritize_stories();
        
        let top_stories = backlog.get_top_stories(1);
        assert_eq!(top_stories.len(), 1);
        assert_eq!(top_stories[0].priority, StoryPriority::High);
    }
    
    #[test]
    fn test_sprint_planning() {
        let mut backlog = ProductBacklog::new();
        
        // æ·»åŠ å¤šä¸ªç”¨æˆ·æ•…äº‹
        for i in 1..=5 {
            let story = UserStory {
                id: format!("US-{:03}", i),
                title: format!("åŠŸèƒ½ {}", i),
                description: format!("åŠŸèƒ½æè¿° {}", i),
                role: UserRole::Stakeholder,
                priority: StoryPriority::Medium,
                story_points: 5,
                acceptance_criteria: vec!["å®ŒæˆåŠŸèƒ½".to_string()],
                status: TaskStatus::ToDo,
                created_at: Instant::now(),
                completed_at: None,
            };
            backlog.add_story(story);
        }
        
        let sprint = SprintPlanner::plan_sprint(&backlog, 20, Duration::from_secs(14 * 24 * 3600));
        
        assert_eq!(sprint.stories.len(), 4); // åº”è¯¥é€‰æ‹©4ä¸ªæ•…äº‹ï¼ˆ4 * 5 = 20ç‚¹ï¼‰
        assert_eq!(sprint.velocity, 20);
    }
    
    #[test]
    fn test_daily_standup() {
        let sprint = Arc::new(Mutex::new(Sprint {
            id: "sprint-1".to_string(),
            name: "Sprint 1".to_string(),
            start_date: Instant::now(),
            end_date: Instant::now() + Duration::from_secs(14 * 24 * 3600),
            duration: Duration::from_secs(14 * 24 * 3600),
            velocity: 20,
            stories: vec![
                UserStory {
                    id: "US-001".to_string(),
                    title: "åŠŸèƒ½1".to_string(),
                    description: "æè¿°1".to_string(),
                    role: UserRole::Stakeholder,
                    priority: StoryPriority::High,
                    story_points: 5,
                    acceptance_criteria: vec![],
                    status: TaskStatus::Done,
                    created_at: Instant::now(),
                    completed_at: Some(Instant::now()),
                },
                UserStory {
                    id: "US-002".to_string(),
                    title: "åŠŸèƒ½2".to_string(),
                    description: "æè¿°2".to_string(),
                    role: UserRole::Stakeholder,
                    priority: StoryPriority::High,
                    story_points: 5,
                    acceptance_criteria: vec![],
                    status: TaskStatus::InProgress,
                    created_at: Instant::now(),
                    completed_at: None,
                },
            ],
            team_capacity: 20,
        }));
        
        let team = Arc::new(Mutex::new(AgileTeam {
            id: "team-1".to_string(),
            name: "Team 1".to_string(),
            members: Vec::new(),
            roles: HashMap::new(),
            velocity_history: Vec::new(),
        }));
        
        let mut standup = DailyStandup::new(sprint, team);
        
        let update = StandupUpdate {
            member_id: "dev-1".to_string(),
            yesterday_work: "å®Œæˆäº†US-001".to_string(),
            today_plan: "å¼€å§‹US-002".to_string(),
            blockers: vec!["éœ€è¦è®¾è®¡è¯„å®¡".to_string()],
            timestamp: Instant::now(),
        };
        
        standup.add_update(update);
        
        let progress = standup.get_sprint_progress();
        assert_eq!(progress.total_stories, 2);
        assert_eq!(progress.completed_stories, 1);
        assert_eq!(progress.completion_rate, 0.5);
        
        let blockers = standup.identify_blockers();
        assert_eq!(blockers.len(), 1);
        assert_eq!(blockers[0], "éœ€è¦è®¾è®¡è¯„å®¡");
    }
    
    #[test]
    fn test_continuous_integration() {
        let mut ci = ContinuousIntegration::new();
        
        let build = ci.trigger_build("source code");
        assert_eq!(build.status, BuildStatus::InProgress);
        
        let test_result = ci.run_tests(&build.id);
        assert_eq!(test_result.total_tests, 100);
        assert_eq!(test_result.passed_tests, 95);
        assert_eq!(test_result.failed_tests, 5);
        
        let deployment = ci.deploy(&build.id, "staging");
        assert_eq!(deployment.status, DeploymentStatus::Success);
        assert_eq!(deployment.environment, "staging");
    }
    
    #[test]
    fn test_agile_project_manager() {
        let mut manager = AgileProjectManager::new();
        
        // æ·»åŠ ç”¨æˆ·æ•…äº‹åˆ°å¾…åŠäº‹é¡¹
        let story = UserStory {
            id: "US-001".to_string(),
            title: "ç”¨æˆ·æ³¨å†Œ".to_string(),
            description: "ç”¨æˆ·èƒ½å¤Ÿæ³¨å†Œæ–°è´¦æˆ·".to_string(),
            role: UserRole::Stakeholder,
            priority: StoryPriority::High,
            story_points: 8,
            acceptance_criteria: vec![],
            status: TaskStatus::ToDo,
            created_at: Instant::now(),
            completed_at: None,
        };
        
        manager.backlog.add_story(story);
        
        // å¼€å§‹å†²åˆº
        manager.start_sprint(Duration::from_secs(14 * 24 * 3600));
        assert!(manager.current_sprint.is_some());
        assert!(manager.standup.is_some());
        
        // å®Œæˆæ•…äº‹
        manager.complete_story("US-001");
        
        // è·å–å†²åˆºçŠ¶æ€
        let status = manager.get_sprint_status();
        assert!(status.is_some());
        
        // è§¦å‘CIæµæ°´çº¿
        manager.trigger_ci_pipeline();
    }
}
```

## 6. ç›¸å…³ç†è®º

- è½¯ä»¶é¡¹ç›®ç®¡ç†ç†è®º
- å›¢é˜Ÿåä½œç†è®º
- æŒç»­é›†æˆç†è®º
- è½¯ä»¶äº¤ä»˜ç†è®º

## 7. å‚è€ƒæ–‡çŒ®

1. Beck, K., et al. "Manifesto for Agile Software Development"
2. Sutherland, J. "Scrum: The Art of Doing Twice the Work in Half the Time"
3. Kniberg, H. "Scrum and XP from the Trenches"
4. Cohn, M. "User Stories Applied: For Agile Software Development"

---

**ç›¸å…³é“¾æ¥**ï¼š

- [07.6.2 æŒç»­é›†æˆç†è®º](../07.6.2_æŒç»­é›†æˆç†è®º.md)
- [07.6.3 æŒç»­éƒ¨ç½²ç†è®º](../07.6.3_æŒç»­éƒ¨ç½²ç†è®º.md)
- [07.6.4 DevOpsç†è®º](../07.6.4_DevOpsç†è®º.md)
