# 07.5.2 ä»£ç è´¨é‡ç†è®º

## ğŸ“‹ æ¦‚è¿°

ä»£ç è´¨é‡ç†è®ºæ˜¯è½¯ä»¶å·¥ç¨‹ä¸­è¯„ä¼°å’Œæ”¹è¿›æºä»£ç è´¨é‡çš„æ ¸å¿ƒç†è®ºä½“ç³»ï¼Œé€šè¿‡å»ºç«‹å½¢å¼åŒ–çš„ä»£ç è´¨é‡æ ‡å‡†å’Œåº¦é‡æ–¹æ³•ï¼Œä¸ºä»£ç å®¡æŸ¥ã€é‡æ„å’Œä¼˜åŒ–æä¾›ç§‘å­¦ä¾æ®ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ä»£ç è´¨é‡çš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°Rustä»£ç è´¨é‡è¯„ä¼°ç¤ºä¾‹
4. åˆ†æä»£ç è´¨é‡æ”¹è¿›ç­–ç•¥

## ğŸ“š ç›®å½•

1. åŸºæœ¬æ¦‚å¿µ
2. å½¢å¼åŒ–å®šä¹‰
3. å®šç†ä¸è¯æ˜
4. ä»£ç å®ç°
5. åº”ç”¨ç¤ºä¾‹
6. ç›¸å…³ç†è®º
7. å‚è€ƒæ–‡çŒ®

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ä»£ç è´¨é‡å®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆä»£ç è´¨é‡ï¼‰
ä»£ç è´¨é‡æ˜¯æºä»£ç åœ¨å¯è¯»æ€§ã€å¯ç»´æŠ¤æ€§ã€å¯æ‰©å±•æ€§ã€æ€§èƒ½å’Œå®‰å…¨æ€§ç­‰æ–¹é¢çš„ç»¼åˆè¡¨ç°ã€‚

### 1.2 ä»£ç è´¨é‡ç»´åº¦
- å¯è¯»æ€§ï¼ˆReadabilityï¼‰
- å¯ç»´æŠ¤æ€§ï¼ˆMaintainabilityï¼‰
- å¯æ‰©å±•æ€§ï¼ˆExtensibilityï¼‰
- æ€§èƒ½ï¼ˆPerformanceï¼‰
- å®‰å…¨æ€§ï¼ˆSecurityï¼‰
- å¯æµ‹è¯•æ€§ï¼ˆTestabilityï¼‰

## 2. å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.1**ï¼ˆä»£ç è´¨é‡æ¨¡å‹ï¼‰
ä»£ç è´¨é‡æ¨¡å‹æ˜¯ä¸€ä¸ªå…­å…ƒç»„ $CQM = (D, M, S, W, T, E)$ï¼Œå…¶ä¸­ï¼š
- $D$ æ˜¯è´¨é‡ç»´åº¦é›†åˆ
- $M$ æ˜¯åº¦é‡æŒ‡æ ‡é›†åˆ
- $S$ æ˜¯è´¨é‡æ ‡å‡†é›†åˆ
- $W$ æ˜¯æƒé‡é›†åˆ
- $T$ æ˜¯é˜ˆå€¼é›†åˆ
- $E$ æ˜¯è¯„ä¼°å‡½æ•°

**å®šä¹‰ 2.2**ï¼ˆä»£ç å¤æ‚åº¦ï¼‰
ä»£ç å¤æ‚åº¦ $C$ æ˜¯è¡¡é‡ä»£ç ç»“æ„å¤æ‚ç¨‹åº¦çš„å‡½æ•°ï¼š
$C = f(LOC, CC, NEST, COUPLING)$
å…¶ä¸­ $LOC$ æ˜¯ä»£ç è¡Œæ•°ï¼Œ$CC$ æ˜¯åœˆå¤æ‚åº¦ï¼Œ$NEST$ æ˜¯åµŒå¥—æ·±åº¦ï¼Œ$COUPLING$ æ˜¯è€¦åˆåº¦ã€‚

**å®šç† 2.1**ï¼ˆå¤æ‚åº¦ä¸å¯ç»´æŠ¤æ€§çš„å…³ç³»ï¼‰
ä»£ç å¤æ‚åº¦ä¸å¯ç»´æŠ¤æ€§å‘ˆè´Ÿç›¸å…³å…³ç³»ã€‚

**è¯æ˜**ï¼š
å¤æ‚åº¦è¶Šé«˜ï¼Œç†è§£ã€ä¿®æ”¹å’Œæµ‹è¯•ä»£ç çš„éš¾åº¦è¶Šå¤§ï¼Œå› æ­¤å¯ç»´æŠ¤æ€§è¶Šä½ã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

**å®šç† 3.1**ï¼ˆä»£ç è´¨é‡çš„å¯åº¦é‡æ€§ï¼‰
ä»£ç è´¨é‡å¯ä»¥é€šè¿‡å®¢è§‚æŒ‡æ ‡è¿›è¡Œé‡åŒ–è¯„ä¼°ã€‚

**è¯æ˜**ï¼š
é€šè¿‡å®šä¹‰æ˜ç¡®çš„åº¦é‡æŒ‡æ ‡ï¼ˆå¦‚åœˆå¤æ‚åº¦ã€ä»£ç è¡Œæ•°ã€æ³¨é‡Šç‡ç­‰ï¼‰ï¼Œå¯ä»¥å®¢è§‚è¯„ä¼°ä»£ç è´¨é‡ã€‚$\square$

**å®šç† 3.2**ï¼ˆè´¨é‡æ”¹è¿›çš„æ¸è¿›æ€§ï¼‰
ä»£ç è´¨é‡æ”¹è¿›æ˜¯ä¸€ä¸ªæ¸è¿›è¿‡ç¨‹ï¼Œéœ€è¦æŒç»­é‡æ„å’Œä¼˜åŒ–ã€‚

**è¯æ˜**ï¼š
ä»£ç è´¨é‡æ”¹è¿›æ¶‰åŠå¤šä¸ªç»´åº¦çš„ä¼˜åŒ–ï¼Œä¸å¯èƒ½ä¸€æ¬¡æ€§å®Œæˆæ‰€æœ‰æ”¹è¿›ã€‚$\square$

## 4. ä»£ç å®ç°

```rust
use std::collections::HashMap;

/// ä»£ç è´¨é‡ç»´åº¦
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum QualityDimension {
    Readability,
    Maintainability,
    Extensibility,
    Performance,
    Security,
    Testability,
}

/// ä»£ç è´¨é‡æŒ‡æ ‡
pub struct CodeQualityMetric {
    pub dimension: QualityDimension,
    pub name: String,
    pub value: f64,
    pub unit: String,
    pub threshold: f64,
    pub weight: f64,
}

/// ä»£ç è´¨é‡åˆ†æå™¨
pub struct CodeQualityAnalyzer;

impl CodeQualityAnalyzer {
    /// åˆ†æä»£ç å¯è¯»æ€§
    pub fn analyze_readability(code: &str) -> CodeQualityMetric {
        let lines = code.lines().count();
        let comments = Self::count_comments(code);
        let comment_ratio = if lines > 0 { comments as f64 / lines as f64 } else { 0.0 };
        let avg_line_length = Self::calculate_avg_line_length(code);
        let naming_score = Self::analyze_naming_conventions(code);
        
        let readability_score = (comment_ratio * 0.3 + 
                                (1.0 - (avg_line_length / 80.0).min(1.0)) * 0.4 + 
                                naming_score * 0.3).min(1.0);
        
        CodeQualityMetric {
            dimension: QualityDimension::Readability,
            name: "Readability Score".to_string(),
            value: readability_score,
            unit: "score".to_string(),
            threshold: 0.7,
            weight: 0.25,
        }
    }
    
    /// åˆ†æä»£ç å¯ç»´æŠ¤æ€§
    pub fn analyze_maintainability(code: &str) -> CodeQualityMetric {
        let complexity = Self::calculate_cyclomatic_complexity(code);
        let nesting_depth = Self::calculate_max_nesting_depth(code);
        let function_length = Self::calculate_avg_function_length(code);
        
        let maintainability_score = (1.0 - (complexity as f64 / 10.0).min(1.0)) * 0.4 +
                                   (1.0 - (nesting_depth as f64 / 5.0).min(1.0)) * 0.3 +
                                   (1.0 - (function_length / 50.0).min(1.0)) * 0.3;
        
        CodeQualityMetric {
            dimension: QualityDimension::Maintainability,
            name: "Maintainability Score".to_string(),
            value: maintainability_score,
            unit: "score".to_string(),
            threshold: 0.6,
            weight: 0.3,
        }
    }
    
    /// åˆ†æä»£ç æ€§èƒ½
    pub fn analyze_performance(code: &str) -> CodeQualityMetric {
        let algorithm_complexity = Self::analyze_algorithm_complexity(code);
        let memory_usage = Self::analyze_memory_patterns(code);
        let optimization_opportunities = Self::find_optimization_opportunities(code);
        
        let performance_score = (1.0 - algorithm_complexity) * 0.5 +
                               (1.0 - memory_usage) * 0.3 +
                               optimization_opportunities * 0.2;
        
        CodeQualityMetric {
            dimension: QualityDimension::Performance,
            name: "Performance Score".to_string(),
            value: performance_score,
            unit: "score".to_string(),
            threshold: 0.7,
            weight: 0.2,
        }
    }
    
    /// åˆ†æä»£ç å®‰å…¨æ€§
    pub fn analyze_security(code: &str) -> CodeQualityMetric {
        let vulnerabilities = Self::detect_security_vulnerabilities(code);
        let input_validation = Self::check_input_validation(code);
        let error_handling = Self::analyze_error_handling(code);
        
        let security_score = (1.0 - vulnerabilities) * 0.4 +
                            input_validation * 0.3 +
                            error_handling * 0.3;
        
        CodeQualityMetric {
            dimension: QualityDimension::Security,
            name: "Security Score".to_string(),
            value: security_score,
            unit: "score".to_string(),
            threshold: 0.8,
            weight: 0.15,
        }
    }
    
    /// åˆ†æä»£ç å¯æµ‹è¯•æ€§
    pub fn analyze_testability(code: &str) -> CodeQualityMetric {
        let coupling = Self::calculate_coupling(code);
        let cohesion = Self::calculate_cohesion(code);
        let test_coverage = Self::estimate_test_coverage(code);
        
        let testability_score = (1.0 - coupling) * 0.4 +
                               cohesion * 0.3 +
                               test_coverage * 0.3;
        
        CodeQualityMetric {
            dimension: QualityDimension::Testability,
            name: "Testability Score".to_string(),
            value: testability_score,
            unit: "score".to_string(),
            threshold: 0.6,
            weight: 0.1,
        }
    }
    
    // è¾…åŠ©æ–¹æ³•
    fn count_comments(code: &str) -> usize {
        code.lines()
            .filter(|line| line.trim().starts_with("//") || line.trim().starts_with("/*"))
            .count()
    }
    
    fn calculate_avg_line_length(code: &str) -> f64 {
        let lines: Vec<&str> = code.lines().collect();
        if lines.is_empty() {
            return 0.0;
        }
        let total_length: usize = lines.iter().map(|line| line.len()).sum();
        total_length as f64 / lines.len() as f64
    }
    
    fn analyze_naming_conventions(code: &str) -> f64 {
        let mut score = 0.0;
        let mut count = 0;
        
        for line in code.lines() {
            if line.contains("fn ") || line.contains("let ") || line.contains("struct ") {
                count += 1;
                if Self::is_good_naming(line) {
                    score += 1.0;
                }
            }
        }
        
        if count > 0 { score / count as f64 } else { 0.0 }
    }
    
    fn is_good_naming(line: &str) -> bool {
        // ç®€åŒ–çš„å‘½åè§„èŒƒæ£€æŸ¥
        !line.contains("a ") && !line.contains("x ") && !line.contains("temp")
    }
    
    fn calculate_cyclomatic_complexity(code: &str) -> usize {
        let mut complexity = 1;
        for line in code.lines() {
            let line = line.trim();
            if line.starts_with("if ") || line.starts_with("while ") || 
               line.starts_with("for ") || line.starts_with("match ") ||
               line.contains(" && ") || line.contains(" || ") {
                complexity += 1;
            }
        }
        complexity
    }
    
    fn calculate_max_nesting_depth(code: &str) -> usize {
        let mut max_depth = 0;
        let mut current_depth = 0;
        
        for line in code.lines() {
            let line = line.trim();
            if line.contains('{') {
                current_depth += 1;
                max_depth = max_depth.max(current_depth);
            }
            if line.contains('}') {
                current_depth = current_depth.saturating_sub(1);
            }
        }
        max_depth
    }
    
    fn calculate_avg_function_length(code: &str) -> f64 {
        // ç®€åŒ–çš„å‡½æ•°é•¿åº¦è®¡ç®—
        let lines = code.lines().count();
        if lines == 0 { 0.0 } else { lines as f64 }
    }
    
    fn analyze_algorithm_complexity(code: &str) -> f64 {
        // ç®€åŒ–çš„ç®—æ³•å¤æ‚åº¦åˆ†æ
        if code.contains("for ") && code.contains("for ") {
            0.8 // åµŒå¥—å¾ªç¯
        } else if code.contains("for ") {
            0.5 // å•å±‚å¾ªç¯
        } else {
            0.2 // å¸¸æ•°æ—¶é—´
        }
    }
    
    fn analyze_memory_patterns(code: &str) -> f64 {
        // ç®€åŒ–çš„å†…å­˜ä½¿ç”¨åˆ†æ
        if code.contains("Vec::new()") || code.contains("String::new()") {
            0.6
        } else {
            0.3
        }
    }
    
    fn find_optimization_opportunities(code: &str) -> f64 {
        // ç®€åŒ–çš„ä¼˜åŒ–æœºä¼šåˆ†æ
        if code.contains("clone()") || code.contains("to_string()") {
            0.7
        } else {
            0.3
        }
    }
    
    fn detect_security_vulnerabilities(code: &str) -> f64 {
        // ç®€åŒ–çš„å®‰å…¨æ¼æ´æ£€æµ‹
        if code.contains("unsafe") || code.contains("unwrap()") {
            0.6
        } else {
            0.2
        }
    }
    
    fn check_input_validation(code: &str) -> f64 {
        // ç®€åŒ–çš„è¾“å…¥éªŒè¯æ£€æŸ¥
        if code.contains("if ") && code.contains("return") {
            0.8
        } else {
            0.4
        }
    }
    
    fn analyze_error_handling(code: &str) -> f64 {
        // ç®€åŒ–çš„é”™è¯¯å¤„ç†åˆ†æ
        if code.contains("Result") || code.contains("Option") {
            0.8
        } else {
            0.4
        }
    }
    
    fn calculate_coupling(code: &str) -> f64 {
        // ç®€åŒ–çš„è€¦åˆåº¦è®¡ç®—
        if code.contains("use ") || code.contains("extern") {
            0.6
        } else {
            0.3
        }
    }
    
    fn calculate_cohesion(code: &str) -> f64 {
        // ç®€åŒ–çš„å†…èšåº¦è®¡ç®—
        if code.contains("impl ") && code.contains("fn ") {
            0.8
        } else {
            0.5
        }
    }
    
    fn estimate_test_coverage(code: &str) -> f64 {
        // ç®€åŒ–çš„æµ‹è¯•è¦†ç›–ç‡ä¼°è®¡
        if code.contains("#[test]") || code.contains("mod tests") {
            0.7
        } else {
            0.3
        }
    }
}

/// ä»£ç è´¨é‡æŠ¥å‘Š
pub struct CodeQualityReport {
    pub metrics: Vec<CodeQualityMetric>,
    pub overall_score: f64,
    pub recommendations: Vec<String>,
}

impl CodeQualityReport {
    pub fn new(metrics: Vec<CodeQualityMetric>) -> Self {
        let overall_score = Self::calculate_overall_score(&metrics);
        let recommendations = Self::generate_recommendations(&metrics);
        
        Self {
            metrics,
            overall_score,
            recommendations,
        }
    }
    
    fn calculate_overall_score(metrics: &[CodeQualityMetric]) -> f64 {
        let mut total_score = 0.0;
        let mut total_weight = 0.0;
        
        for metric in metrics {
            total_score += metric.value * metric.weight;
            total_weight += metric.weight;
        }
        
        if total_weight > 0.0 {
            total_score / total_weight
        } else {
            0.0
        }
    }
    
    fn generate_recommendations(metrics: &[CodeQualityMetric]) -> Vec<String> {
        let mut recommendations = Vec::new();
        
        for metric in metrics {
            if metric.value < metric.threshold {
                match metric.dimension {
                    QualityDimension::Readability => {
                        recommendations.push("å¢åŠ ä»£ç æ³¨é‡Šå’Œæ–‡æ¡£".to_string());
                        recommendations.push("æ”¹è¿›å˜é‡å’Œå‡½æ•°å‘½å".to_string());
                    }
                    QualityDimension::Maintainability => {
                        recommendations.push("é™ä½ä»£ç å¤æ‚åº¦".to_string());
                        recommendations.push("å‡å°‘åµŒå¥—æ·±åº¦".to_string());
                    }
                    QualityDimension::Performance => {
                        recommendations.push("ä¼˜åŒ–ç®—æ³•å¤æ‚åº¦".to_string());
                        recommendations.push("å‡å°‘å†…å­˜åˆ†é…".to_string());
                    }
                    QualityDimension::Security => {
                        recommendations.push("åŠ å¼ºè¾“å…¥éªŒè¯".to_string());
                        recommendations.push("æ”¹è¿›é”™è¯¯å¤„ç†".to_string());
                    }
                    QualityDimension::Testability => {
                        recommendations.push("é™ä½æ¨¡å—è€¦åˆåº¦".to_string());
                        recommendations.push("å¢åŠ å•å…ƒæµ‹è¯•".to_string());
                    }
                    _ => {}
                }
            }
        }
        
        recommendations
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_code_quality_analysis() {
        let sample_code = r#"
            // è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—
            fn fibonacci(n: u32) -> u32 {
                if n <= 1 {
                    return n;
                }
                fibonacci(n - 1) + fibonacci(n - 2)
            }
            
            #[cfg(test)]
            mod tests {
                use super::*;
                
                #[test]
                fn test_fibonacci() {
                    assert_eq!(fibonacci(0), 0);
                    assert_eq!(fibonacci(1), 1);
                    assert_eq!(fibonacci(10), 55);
                }
            }
        "#;
        
        let mut metrics = Vec::new();
        metrics.push(CodeQualityAnalyzer::analyze_readability(sample_code));
        metrics.push(CodeQualityAnalyzer::analyze_maintainability(sample_code));
        metrics.push(CodeQualityAnalyzer::analyze_performance(sample_code));
        metrics.push(CodeQualityAnalyzer::analyze_security(sample_code));
        metrics.push(CodeQualityAnalyzer::analyze_testability(sample_code));
        
        let report = CodeQualityReport::new(metrics);
        
        assert!(report.overall_score >= 0.0 && report.overall_score <= 1.0);
        assert!(!report.recommendations.is_empty());
    }
    
    #[test]
    fn test_complexity_analysis() {
        let complex_code = r#"
            fn complex_function(x: i32, y: i32, z: i32) -> i32 {
                let mut result = 0;
                if x > 0 {
                    if y > 0 {
                        if z > 0 {
                            for i in 0..x {
                                for j in 0..y {
                                    for k in 0..z {
                                        result += i * j * k;
                                    }
                                }
                            }
                        } else {
                            result = x * y;
                        }
                    } else {
                        result = x;
                    }
                } else {
                    result = 0;
                }
                result
            }
        "#;
        
        let maintainability = CodeQualityAnalyzer::analyze_maintainability(complex_code);
        assert!(maintainability.value < 0.5); // å¤æ‚ä»£ç åº”è¯¥å¾—åˆ†è¾ƒä½
    }
}
```

## 6. ç›¸å…³ç†è®º

- è½¯ä»¶åº¦é‡ç†è®º
- ä»£ç é‡æ„ç†è®º
- è½¯ä»¶ç»´æŠ¤ç†è®º
- è½¯ä»¶æµ‹è¯•ç†è®º

## 7. å‚è€ƒæ–‡çŒ®

1. Martin, R. C. "Clean Code: A Handbook of Agile Software Craftsmanship"
2. Fowler, M. "Refactoring: Improving the Design of Existing Code"
3. McCabe, T. J. "A Complexity Measure"
4. Halstead, M. H. "Elements of Software Science"

---

**ç›¸å…³é“¾æ¥**ï¼š
- [07.5.1 è´¨é‡æ¨¡å‹ç†è®º](../07.5.1_è´¨é‡æ¨¡å‹ç†è®º.md)
- [07.5.3 æ€§èƒ½ä¼˜åŒ–ç†è®º](../07.5.3_æ€§èƒ½ä¼˜åŒ–ç†è®º.md)
- [07.5.4 å®‰å…¨å·¥ç¨‹ç†è®º](../07.5.4_å®‰å…¨å·¥ç¨‹ç†è®º.md) 