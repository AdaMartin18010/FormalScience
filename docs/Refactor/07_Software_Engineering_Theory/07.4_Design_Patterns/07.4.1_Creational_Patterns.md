[返回设计模式分支索引](./README.md)

# 07.4.1 创建型模式（Creational Patterns）

> 本文档系统整理创建型设计模式，包括单例、工厂方法、抽象工厂、建造者、原型等，严格树形编号、目录、本地跳转锚点与交叉引用，内容持续规范化中。

## 目录

- [07.4.1 创建型模式 (Creational Patterns)](#0741-创建型模式-creational-patterns)
  - [目录](#目录)
  - [1. 定义与背景](#1-定义与背景)
  - [2. 核心模式](#2-核心模式)
    - [2.1 工厂方法 (Factory Method)](#21-工厂方法-factory-method)
    - [2.2 抽象工厂 (Abstract Factory)](#22-抽象工厂-abstract-factory)
    - [2.3 生成器 (Builder)](#23-生成器-builder)
    - [2.4 原型 (Prototype)](#24-原型-prototype)
    - [2.5 单例 (Singleton)](#25-单例-singleton)
  - [3. 多表征分析](#3-多表征分析)
  - [4. 交叉引用](#4-交叉引用)

---

## 1. 定义与背景

创建型模式提供了一系列用于实例化对象的机制。它们的核心思想是将对象的创建过程与使用过程解耦，使得系统在"创建什么"、"由谁创建"、"如何创建"以及"何时创建"这些方面更具灵活性。

---

## 2. 核心模式

### 2.1 工厂方法 (Factory Method)

- **意图**: 定义一个用于创建对象的接口，但让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
- **应用场景**: 当一个类不知道它所必须创建的对象的类时。

### 2.2 抽象工厂 (Abstract Factory)

- **意图**: 提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。
- **应用场景**: 当系统需要与多个产品系列中的一个进行配置时。

### 2.3 生成器 (Builder)

- **意图**: 将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
- **应用场景**: 当一个对象的构造过程非常复杂，包含多个步骤时。

### 2.4 原型 (Prototype)

- **意图**: 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
- **应用场景**: 当创建一个对象代价过大时，或者当要实例化的类是在运行时动态指定时。

### 2.5 单例 (Singleton)

- **意图**: 保证一个类仅有一个实例，并提供一个访问它的全局访问点。
- **应用场景**: 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时，如日志、配置管理器。

---

## 3. 多表征分析

| 模式 | 核心问题 | 解决方案 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- | :--- |
| **工厂方法** | 如何让子类决定创建哪个对象？ | 定义创建接口，子类实现 | 易于扩展 | 类数量增多 |
| **抽象工厂** | 如何创建一系列相关的对象？ | 为每个产品系列提供一个工厂接口 | 客户端与具体产品解耦 | 难以增加新产品 |
| **生成器** | 如何分步构建一个复杂对象？ | 分离构建过程和表示 | 精确控制构建过程 | 模式本身较复杂 |
| **原型** | 如何高效地创建对象？ | 通过复制现有对象来创建 | 性能高，避免构造函数约束 | 深度拷贝复杂 |
| **单例** | 如何保证类只有一个实例？ | 静态实例，私有构造，全局访问点 | 全局访问，节省资源 | 违反单一职责，测试困难 |

---

## 4. 交叉引用

- [设计模式总览](./README.md)
- [结构型模式](./07.4.2_Structural_Patterns.md)
- [行为型模式](./07.4.3_Behavioral_Patterns.md)
