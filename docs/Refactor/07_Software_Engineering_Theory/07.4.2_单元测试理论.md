# 07.4.2 å•å…ƒæµ‹è¯•ç†è®º

## ğŸ“‹ æ¦‚è¿°

å•å…ƒæµ‹è¯•ç†è®ºæ˜¯è½¯ä»¶æµ‹è¯•ç†è®ºçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œä¸“æ³¨äºå¯¹è½¯ä»¶æœ€å°å¯æµ‹è¯•å•å…ƒè¿›è¡ŒéªŒè¯ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦åˆ†æå•å…ƒæµ‹è¯•çš„ç†è®ºåŸºç¡€ã€æ•°å­¦å®šä¹‰ã€å®ç°åŸç†å’Œåº”ç”¨åœºæ™¯ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹å•å…ƒæµ‹è¯•çš„å½¢å¼åŒ–ç†è®ºåŸºç¡€
2. æä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œè¯æ˜
3. å®ç°å®Œæ•´çš„Rustä»£ç ç¤ºä¾‹
4. åˆ†æå•å…ƒæµ‹è¯•çš„æœ€ä½³å®è·µ

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å•å…ƒæµ‹è¯•çš„å®šä¹‰

**å®šä¹‰ 1.1** (å•å…ƒæµ‹è¯•)
å•å…ƒæµ‹è¯•æ˜¯å¯¹è½¯ä»¶ä¸­æœ€å°å¯æµ‹è¯•å•å…ƒï¼ˆé€šå¸¸æ˜¯å‡½æ•°ã€æ–¹æ³•æˆ–ç±»ï¼‰è¿›è¡ŒéªŒè¯çš„æµ‹è¯•æ–¹æ³•ã€‚

**å®šä¹‰ 1.2** (æµ‹è¯•å•å…ƒ)
æµ‹è¯•å•å…ƒæ˜¯è½¯ä»¶ä¸­å…·æœ‰ç‹¬ç«‹åŠŸèƒ½çš„æœ€å°å¯æµ‹è¯•ç»„ä»¶ï¼Œé€šå¸¸å…·æœ‰æ˜ç¡®çš„è¾“å…¥è¾“å‡ºæ¥å£ã€‚

### 1.2 å•å…ƒæµ‹è¯•çš„ç‰¹å¾

1. **ç‹¬ç«‹æ€§**ï¼šæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ç‹¬ç«‹è¿è¡Œ
2. **å¯é‡å¤æ€§**ï¼šæµ‹è¯•ç»“æœå¯é‡å¤éªŒè¯
3. **å¿«é€Ÿæ€§**ï¼šæ‰§è¡Œæ—¶é—´çŸ­
4. **è‡ªåŠ¨åŒ–**ï¼šå¯è‡ªåŠ¨æ‰§è¡Œå’ŒéªŒè¯
5. **éš”ç¦»æ€§**ï¼šä¸ä¾èµ–å¤–éƒ¨ç¯å¢ƒ

### 1.3 å½¢å¼åŒ–è¡¨ç¤º

**å®šä¹‰ 1.3** (å•å…ƒæµ‹è¯•çš„å½¢å¼åŒ–è¡¨ç¤º)
å•å…ƒæµ‹è¯•å¯ä»¥è¡¨ç¤ºä¸ºäº”å…ƒç»„ $UT = (U, I, O, T, P)$ï¼Œå…¶ä¸­ï¼š
- $U$ æ˜¯è¢«æµ‹è¯•å•å…ƒ
- $I$ æ˜¯è¾“å…¥é›†åˆ
- $O$ æ˜¯è¾“å‡ºé›†åˆ
- $T$ æ˜¯æµ‹è¯•ç”¨ä¾‹é›†åˆ
- $P$ æ˜¯æµ‹è¯•é¢„è¨€

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æµ‹è¯•å•å…ƒ

**å®šä¹‰ 2.1** (æµ‹è¯•å•å…ƒ)
æµ‹è¯•å•å…ƒæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $u = (F, D, R)$ï¼Œå…¶ä¸­ï¼š
- $F$ æ˜¯åŠŸèƒ½å‡½æ•°
- $D$ æ˜¯å®šä¹‰åŸŸ
- $R$ æ˜¯å€¼åŸŸ

**å®šç† 2.1** (å•å…ƒçš„ç‹¬ç«‹æ€§)
æµ‹è¯•å•å…ƒåº”è¯¥å…·æœ‰ç‹¬ç«‹çš„åŠŸèƒ½å’Œæ¥å£ã€‚

**è¯æ˜**ï¼š
æ ¹æ®å•å…ƒæµ‹è¯•çš„å®šä¹‰ï¼Œæµ‹è¯•å•å…ƒæ˜¯æœ€å°å¯æµ‹è¯•ç»„ä»¶ï¼Œå› æ­¤åº”è¯¥å…·æœ‰ç‹¬ç«‹çš„åŠŸèƒ½å’Œæ¥å£ã€‚$\square$

### 2.2 å•å…ƒæµ‹è¯•ç”¨ä¾‹

**å®šä¹‰ 2.2** (å•å…ƒæµ‹è¯•ç”¨ä¾‹)
å•å…ƒæµ‹è¯•ç”¨ä¾‹æ˜¯ä¸€ä¸ªå››å…ƒç»„ $tc = (i, e, o, p)$ï¼Œå…¶ä¸­ï¼š
- $i$ æ˜¯è¾“å…¥å€¼
- $e$ æ˜¯æ‰§è¡Œç¯å¢ƒ
- $o$ æ˜¯é¢„æœŸè¾“å‡º
- $p$ æ˜¯æµ‹è¯•é¢„è¨€

**å®šç† 2.2** (æµ‹è¯•ç”¨ä¾‹çš„å®Œå¤‡æ€§)
å•å…ƒæµ‹è¯•ç”¨ä¾‹åº”è¯¥è¦†ç›–æ‰€æœ‰é‡è¦çš„è¾“å…¥è¾¹ç•Œå’Œå¼‚å¸¸æƒ…å†µã€‚

**è¯æ˜**ï¼š
æ ¹æ®æµ‹è¯•å……åˆ†æ€§åŸåˆ™ï¼Œæµ‹è¯•ç”¨ä¾‹åº”è¯¥è¦†ç›–æ‰€æœ‰é‡è¦çš„è¾“å…¥æƒ…å†µã€‚$\square$

### 2.3 æµ‹è¯•éš”ç¦»

**å®šä¹‰ 2.3** (æµ‹è¯•éš”ç¦»)
æµ‹è¯•éš”ç¦»æ˜¯ç¡®ä¿å•å…ƒæµ‹è¯•ä¸ä¾èµ–å¤–éƒ¨ç¯å¢ƒå’Œå…¶ä»–ç»„ä»¶çš„æœºåˆ¶ã€‚

**å®šç† 2.3** (éš”ç¦»çš„å¿…è¦æ€§)
æµ‹è¯•éš”ç¦»æ˜¯å•å…ƒæµ‹è¯•å¯é æ€§çš„å¿…è¦æ¡ä»¶ã€‚

**è¯æ˜**ï¼š
å¦‚æœæµ‹è¯•ä¸éš”ç¦»ï¼Œå¤–éƒ¨ä¾èµ–çš„å˜åŒ–ä¼šå½±å“æµ‹è¯•ç»“æœï¼Œé™ä½æµ‹è¯•çš„å¯é æ€§ã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

### 3.1 å•å…ƒæµ‹è¯•çš„åŸºæœ¬æ€§è´¨

**å®šç† 3.1** (å•å…ƒæµ‹è¯•çš„å¿«é€Ÿæ€§)
å•å…ƒæµ‹è¯•çš„æ‰§è¡Œæ—¶é—´åº”è¯¥å¾ˆçŸ­ã€‚

**è¯æ˜**ï¼š
æ ¹æ®å•å…ƒæµ‹è¯•çš„å®šä¹‰ï¼Œå®ƒæµ‹è¯•çš„æ˜¯æœ€å°å¯æµ‹è¯•å•å…ƒï¼Œå› æ­¤æ‰§è¡Œæ—¶é—´åº”è¯¥å¾ˆçŸ­ã€‚$\square$

**å®šç† 3.2** (å•å…ƒæµ‹è¯•çš„å¯é‡å¤æ€§)
å•å…ƒæµ‹è¯•çš„ç»“æœåº”è¯¥æ˜¯ç¡®å®šæ€§çš„ã€‚

**è¯æ˜**ï¼š
å•å…ƒæµ‹è¯•ä¸ä¾èµ–å¤–éƒ¨çŠ¶æ€ï¼Œå› æ­¤ç»“æœåº”è¯¥æ˜¯ç¡®å®šæ€§çš„ã€‚$\square$

### 3.2 æµ‹è¯•ç­–ç•¥

**å®šç† 3.3** (è¾¹ç•Œå€¼æµ‹è¯•çš„é‡è¦æ€§)
è¾¹ç•Œå€¼æµ‹è¯•æ˜¯å•å…ƒæµ‹è¯•çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚

**è¯æ˜**ï¼š
æ ¹æ®ç»éªŒï¼Œå¤§éƒ¨åˆ†ç¼ºé™·å‡ºç°åœ¨è¾¹ç•Œå€¼é™„è¿‘ï¼Œå› æ­¤è¾¹ç•Œå€¼æµ‹è¯•å¾ˆé‡è¦ã€‚$\square$

**å®šç† 3.4** (å¼‚å¸¸æµ‹è¯•çš„å¿…è¦æ€§)
å•å…ƒæµ‹è¯•åº”è¯¥åŒ…å«å¼‚å¸¸æƒ…å†µçš„æµ‹è¯•ã€‚

**è¯æ˜**ï¼š
å¼‚å¸¸æƒ…å†µæ˜¯è½¯ä»¶ç¼ºé™·çš„é‡è¦æ¥æºï¼Œå› æ­¤éœ€è¦ä¸“é—¨æµ‹è¯•ã€‚$\square$

## 4. ä»£ç å®ç°

### 4.1 å•å…ƒæµ‹è¯•æ¡†æ¶

```rust
use std::time::{Duration, Instant};

/// å•å…ƒæµ‹è¯•ç»“æœ
#[derive(Debug, Clone, PartialEq)]
pub enum UnitTestResult {
    Pass,
    Fail(String),
    Error(String),
}

/// å•å…ƒæµ‹è¯•ç”¨ä¾‹ç‰¹å¾
pub trait UnitTestCase {
    fn name(&self) -> &str;
    fn description(&self) -> &str;
    fn run(&self) -> UnitTestResult;
    fn setup(&self) -> Result<(), String> { Ok(()) }
    fn teardown(&self) -> Result<(), String> { Ok(()) }
}

/// å•å…ƒæµ‹è¯•å¥—ä»¶
pub struct UnitTestSuite {
    name: String,
    tests: Vec<Box<dyn UnitTestCase>>,
}

impl UnitTestSuite {
    pub fn new(name: String) -> Self {
        Self { name, tests: Vec::new() }
    }
    
    pub fn add_test(&mut self, test: Box<dyn UnitTestCase>) {
        self.tests.push(test);
    }
    
    pub fn run_all(&self) -> UnitTestReport {
        let mut results = Vec::new();
        let start_time = Instant::now();
        
        for test in &self.tests {
            let test_start = Instant::now();
            let result = match test.setup() {
                Ok(_) => {
                    let test_result = test.run();
                    let _ = test.teardown();
                    test_result
                }
                Err(e) => UnitTestResult::Error(format!("Setup failed: {}", e)),
            };
            
            results.push(UnitTestExecution {
                name: test.name().to_string(),
                result,
                duration: test_start.elapsed(),
            });
        }
        
        UnitTestReport {
            suite_name: self.name.clone(),
            results,
            total_duration: start_time.elapsed(),
        }
    }
}

/// å•å…ƒæµ‹è¯•æ‰§è¡Œç»“æœ
pub struct UnitTestExecution {
    pub name: String,
    pub result: UnitTestResult,
    pub duration: Duration,
}

/// å•å…ƒæµ‹è¯•æŠ¥å‘Š
pub struct UnitTestReport {
    pub suite_name: String,
    pub results: Vec<UnitTestExecution>,
    pub total_duration: Duration,
}

impl UnitTestReport {
    pub fn summary(&self) -> UnitTestSummary {
        let total = self.results.len();
        let passed = self.results.iter().filter(|r| r.result == UnitTestResult::Pass).count();
        let failed = self.results.iter().filter(|r| matches!(r.result, UnitTestResult::Fail(_))).count();
        let errors = self.results.iter().filter(|r| matches!(r.result, UnitTestResult::Error(_))).count();
        
        UnitTestSummary {
            total,
            passed,
            failed,
            errors,
            success_rate: if total > 0 { passed as f64 / total as f64 } else { 0.0 },
        }
    }
}

/// å•å…ƒæµ‹è¯•æ‘˜è¦
pub struct UnitTestSummary {
    pub total: usize,
    pub passed: usize,
    pub failed: usize,
    pub errors: usize,
    pub success_rate: f64,
}
```

### 4.2 æµ‹è¯•æ›¿èº«å®ç°

```rust
/// æµ‹è¯•æ›¿èº«ç‰¹å¾
pub trait TestDouble {
    fn get_name(&self) -> &str;
}

/// æ¨¡æ‹Ÿå¯¹è±¡
pub struct MockObject {
    name: String,
    expectations: Vec<MockExpectation>,
    calls: Vec<MockCall>,
}

impl MockObject {
    pub fn new(name: String) -> Self {
        Self {
            name,
            expectations: Vec::new(),
            calls: Vec::new(),
        }
    }
    
    pub fn expect_call(&mut self, method: String, args: Vec<String>, return_value: String) {
        self.expectations.push(MockExpectation {
            method,
            args,
            return_value,
        });
    }
    
    pub fn record_call(&mut self, method: String, args: Vec<String>) {
        self.calls.push(MockCall { method, args });
    }
    
    pub fn verify(&self) -> bool {
        self.calls.len() == self.expectations.len()
    }
}

impl TestDouble for MockObject {
    fn get_name(&self) -> &str {
        &self.name
    }
}

/// æ¨¡æ‹ŸæœŸæœ›
pub struct MockExpectation {
    pub method: String,
    pub args: Vec<String>,
    pub return_value: String,
}

/// æ¨¡æ‹Ÿè°ƒç”¨
pub struct MockCall {
    pub method: String,
    pub args: Vec<String>,
}

/// å­˜æ ¹å¯¹è±¡
pub struct StubObject {
    name: String,
    return_values: std::collections::HashMap<String, String>,
}

impl StubObject {
    pub fn new(name: String) -> Self {
        Self {
            name,
            return_values: std::collections::HashMap::new(),
        }
    }
    
    pub fn set_return_value(&mut self, method: String, value: String) {
        self.return_values.insert(method, value);
    }
    
    pub fn get_return_value(&self, method: &str) -> Option<&String> {
        self.return_values.get(method)
    }
}

impl TestDouble for StubObject {
    fn get_name(&self) -> &str {
        &self.name
    }
}
```

### 4.3 æ–­è¨€åº“å®ç°

```rust
/// æ–­è¨€ç‰¹å¾
pub trait Assertion {
    fn assert(&self) -> Result<(), String>;
}

/// ç›¸ç­‰æ–­è¨€
pub struct AssertEqual<T> {
    expected: T,
    actual: T,
    message: String,
}

impl<T: PartialEq + std::fmt::Debug> AssertEqual<T> {
    pub fn new(expected: T, actual: T, message: String) -> Self {
        Self { expected, actual, message }
    }
}

impl<T: PartialEq + std::fmt::Debug> Assertion for AssertEqual<T> {
    fn assert(&self) -> Result<(), String> {
        if self.expected == self.actual {
            Ok(())
        } else {
            Err(format!("{}: Expected {:?}, got {:?}", 
                       self.message, self.expected, self.actual))
        }
    }
}

/// çœŸå€¼æ–­è¨€
pub struct AssertTrue {
    value: bool,
    message: String,
}

impl AssertTrue {
    pub fn new(value: bool, message: String) -> Self {
        Self { value, message }
    }
}

impl Assertion for AssertTrue {
    fn assert(&self) -> Result<(), String> {
        if self.value {
            Ok(())
        } else {
            Err(format!("{}: Expected true, got false", self.message))
        }
    }
}

/// å¼‚å¸¸æ–­è¨€
pub struct AssertThrows<F> {
    function: F,
    expected_error: String,
}

impl<F> AssertThrows<F>
where
    F: FnOnce() -> Result<(), String>,
{
    pub fn new(function: F, expected_error: String) -> Self {
        Self { function, expected_error }
    }
}

impl<F> Assertion for AssertThrows<F>
where
    F: FnOnce() -> Result<(), String>,
{
    fn assert(&self) -> Result<(), String> {
        match (self.function)() {
            Ok(_) => Err("Expected error, but function succeeded".to_string()),
            Err(e) => {
                if e.contains(&self.expected_error) {
                    Ok(())
                } else {
                    Err(format!("Expected error containing '{}', got '{}'", 
                               self.expected_error, e))
                }
            }
        }
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 æ•°å­¦å‡½æ•°å•å…ƒæµ‹è¯•

```rust
/// æ•°å­¦å·¥å…·ç±»
pub struct MathUtils;

impl MathUtils {
    pub fn factorial(n: u32) -> u32 {
        if n <= 1 {
            1
        } else {
            n * Self::factorial(n - 1)
        }
    }
    
    pub fn fibonacci(n: u32) -> u32 {
        if n <= 1 {
            n
        } else {
            Self::fibonacci(n - 1) + Self::fibonacci(n - 2)
        }
    }
    
    pub fn is_prime(n: u32) -> bool {
        if n < 2 {
            return false;
        }
        if n == 2 {
            return true;
        }
        if n % 2 == 0 {
            return false;
        }
        
        let sqrt_n = (n as f64).sqrt() as u32;
        for i in (3..=sqrt_n).step_by(2) {
            if n % i == 0 {
                return false;
            }
        }
        true
    }
}

/// é˜¶ä¹˜å‡½æ•°æµ‹è¯•
pub struct FactorialTest;

impl UnitTestCase for FactorialTest {
    fn name(&self) -> &str {
        "Factorial Function Test"
    }
    
    fn description(&self) -> &str {
        "Test factorial function with various inputs"
    }
    
    fn run(&self) -> UnitTestResult {
        let test_cases = vec![
            (0, 1),
            (1, 1),
            (2, 2),
            (3, 6),
            (4, 24),
            (5, 120),
        ];
        
        for (input, expected) in test_cases {
            let result = MathUtils::factorial(input);
            if result != expected {
                return UnitTestResult::Fail(format!(
                    "Factorial({}) = {}, expected {}", input, result, expected
                ));
            }
        }
        
        UnitTestResult::Pass
    }
}

/// æ–æ³¢é‚£å¥‘å‡½æ•°æµ‹è¯•
pub struct FibonacciTest;

impl UnitTestCase for FibonacciTest {
    fn name(&self) -> &str {
        "Fibonacci Function Test"
    }
    
    fn description(&self) -> &str {
        "Test fibonacci function with various inputs"
    }
    
    fn run(&self) -> UnitTestResult {
        let test_cases = vec![
            (0, 0),
            (1, 1),
            (2, 1),
            (3, 2),
            (4, 3),
            (5, 5),
            (6, 8),
        ];
        
        for (input, expected) in test_cases {
            let result = MathUtils::fibonacci(input);
            if result != expected {
                return UnitTestResult::Fail(format!(
                    "Fibonacci({}) = {}, expected {}", input, result, expected
                ));
            }
        }
        
        UnitTestResult::Pass
    }
}

/// ç´ æ•°æ£€æµ‹æµ‹è¯•
pub struct PrimeTest;

impl UnitTestCase for PrimeTest {
    fn name(&self) -> &str {
        "Prime Number Test"
    }
    
    fn description(&self) -> &str {
        "Test prime number detection function"
    }
    
    fn run(&self) -> UnitTestResult {
        let test_cases = vec![
            (0, false),
            (1, false),
            (2, true),
            (3, true),
            (4, false),
            (5, true),
            (6, false),
            (7, true),
            (8, false),
            (9, false),
            (10, false),
            (11, true),
        ];
        
        for (input, expected) in test_cases {
            let result = MathUtils::is_prime(input);
            if result != expected {
                return UnitTestResult::Fail(format!(
                    "is_prime({}) = {}, expected {}", input, result, expected
                ));
            }
        }
        
        UnitTestResult::Pass
    }
}
```

### 5.2 å­—ç¬¦ä¸²å¤„ç†å•å…ƒæµ‹è¯•

```rust
/// å­—ç¬¦ä¸²å·¥å…·ç±»
pub struct StringUtils;

impl StringUtils {
    pub fn reverse(input: &str) -> String {
        input.chars().rev().collect()
    }
    
    pub fn is_palindrome(input: &str) -> bool {
        let cleaned: String = input.chars()
            .filter(|c| c.is_alphanumeric())
            .collect();
        let reversed: String = cleaned.chars().rev().collect();
        cleaned.to_lowercase() == reversed.to_lowercase()
    }
    
    pub fn count_vowels(input: &str) -> usize {
        input.chars()
            .filter(|c| "aeiouAEIOU".contains(*c))
            .count()
    }
    
    pub fn remove_duplicates(input: &str) -> String {
        let mut seen = std::collections::HashSet::new();
        input.chars()
            .filter(|c| seen.insert(*c))
            .collect()
    }
}

/// å­—ç¬¦ä¸²åè½¬æµ‹è¯•
pub struct StringReverseTest;

impl UnitTestCase for StringReverseTest {
    fn name(&self) -> &str {
        "String Reverse Test"
    }
    
    fn description(&self) -> &str {
        "Test string reversal functionality"
    }
    
    fn run(&self) -> UnitTestResult {
        let test_cases = vec![
            ("", ""),
            ("a", "a"),
            ("hello", "olleh"),
            ("123", "321"),
            ("Hello World", "dlroW olleH"),
        ];
        
        for (input, expected) in test_cases {
            let result = StringUtils::reverse(input);
            if result != expected {
                return UnitTestResult::Fail(format!(
                    "reverse('{}') = '{}', expected '{}'", input, result, expected
                ));
            }
        }
        
        UnitTestResult::Pass
    }
}

/// å›æ–‡æ£€æµ‹æµ‹è¯•
pub struct PalindromeTest;

impl UnitTestCase for PalindromeTest {
    fn name(&self) -> &str {
        "Palindrome Detection Test"
    }
    
    fn description(&self) -> &str {
        "Test palindrome detection functionality"
    }
    
    fn run(&self) -> UnitTestResult {
        let test_cases = vec![
            ("", true),
            ("a", true),
            ("racecar", true),
            ("A man a plan a canal Panama", true),
            ("hello", false),
            ("12321", true),
            ("12345", false),
        ];
        
        for (input, expected) in test_cases {
            let result = StringUtils::is_palindrome(input);
            if result != expected {
                return UnitTestResult::Fail(format!(
                    "is_palindrome('{}') = {}, expected {}", input, result, expected
                ));
            }
        }
        
        UnitTestResult::Pass
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸æµ‹è¯•ç†è®ºçš„å…³ç³»

å•å…ƒæµ‹è¯•æ˜¯è½¯ä»¶æµ‹è¯•ç†è®ºçš„åŸºç¡€ï¼Œä¸ºå…¶ä»–æµ‹è¯•ç±»å‹æä¾›åŸºç¡€ã€‚

**å®šç† 6.1** (å•å…ƒæµ‹è¯•çš„åŸºç¡€æ€§)
å•å…ƒæµ‹è¯•æ˜¯é›†æˆæµ‹è¯•å’Œç³»ç»Ÿæµ‹è¯•çš„åŸºç¡€ã€‚

**è¯æ˜**ï¼š
åªæœ‰å•å…ƒæµ‹è¯•é€šè¿‡ï¼Œæ‰èƒ½è¿›è¡Œæ›´é«˜å±‚æ¬¡çš„æµ‹è¯•ã€‚$\square$

### 6.2 ä¸è½¯ä»¶è´¨é‡çš„å…³ç³»

å•å…ƒæµ‹è¯•ç›´æ¥å½±å“è½¯ä»¶è´¨é‡ã€‚

**å®šç† 6.2** (å•å…ƒæµ‹è¯•ä¸è´¨é‡çš„å…³ç³»)
å•å…ƒæµ‹è¯•è¦†ç›–ç‡ä¸è½¯ä»¶è´¨é‡æ­£ç›¸å…³ã€‚

**è¯æ˜**ï¼š
æ›´é«˜çš„å•å…ƒæµ‹è¯•è¦†ç›–ç‡æ„å‘³ç€æ›´å¤šçš„ä»£ç è¢«éªŒè¯ï¼Œå› æ­¤è´¨é‡æ›´é«˜ã€‚$\square$

## 7. å‚è€ƒæ–‡çŒ®

1. Beck, K. (2002). Test Driven Development: By Example. Addison-Wesley.
2. Freeman, S., & Pryce, N. (2009). Growing Object-Oriented Software, Guided by Tests. Addison-Wesley.
3. Meszaros, G. (2007). xUnit Test Patterns: Refactoring Test Code. Addison-Wesley.
4. Fowler, M. (2006). Refactoring: Improving the Design of Existing Code. Addison-Wesley.

---

**ç›¸å…³é“¾æ¥**ï¼š
- [07.4.1 æµ‹è¯•ç†è®ºåŸºç¡€](../07.4.1_æµ‹è¯•ç†è®ºåŸºç¡€.md)
- [07.4.3 é›†æˆæµ‹è¯•ç†è®º](../07.4.3_é›†æˆæµ‹è¯•ç†è®º.md)
- [07.4.4 ç³»ç»Ÿæµ‹è¯•ç†è®º](../07.4.4_ç³»ç»Ÿæµ‹è¯•ç†è®º.md)
- [07.3.1 åˆ›å»ºå‹æ¨¡å¼](../07.3.1_åˆ›å»ºå‹æ¨¡å¼.md)
- [07.3.2 ç»“æ„å‹æ¨¡å¼](../07.3.2_ç»“æ„å‹æ¨¡å¼.md) 