# 01-经典逻辑理论 (Classical Logic Theory)

## 目录

1. [命题逻辑](#1-命题逻辑)
2. [谓词逻辑](#2-谓词逻辑)
3. [模态逻辑](#3-模态逻辑)
4. [时态逻辑](#4-时态逻辑)
5. [二阶逻辑](#5-二阶逻辑)
6. [逻辑系统](#6-逻辑系统)
7. [证明理论](#7-证明理论)
8. [模型理论](#8-模型理论)
9. [逻辑应用](#9-逻辑应用)
10. [逻辑扩展](#10-逻辑扩展)

## 1. 命题逻辑

### 1.1 命题基础

**定义 1.1.1 (命题)**
命题是具有真值的陈述句：$\text{Proposition} = \{p : \text{Statement} \land \text{HasTruthValue}(p)\}$

**定义 1.1.2 (命题变元)**
命题变元是可取真值或假值的变量：$p, q, r, \ldots \in \text{PropVar}$

**定义 1.1.3 (命题公式)**
命题公式的语法：
$$\phi ::= p \mid \bot \mid \top \mid \phi_1 \land \phi_2 \mid \phi_1 \lor \phi_2 \mid \phi_1 \rightarrow \phi_2 \mid \phi_1 \leftrightarrow \phi_2 \mid \neg \phi$$

**公理 1.1.1 (排中律)**
对于任何命题 $p$：$p \lor \neg p$

**公理 1.1.2 (矛盾律)**
对于任何命题 $p$：$\neg(p \land \neg p)$

### 1.2 语义定义

**定义 1.1.4 (真值赋值)**
真值赋值是函数 $v : \text{PropVar} \rightarrow \{\text{true}, \text{false}\}$

**定义 1.1.5 (语义函数)**
语义函数 $\llbracket \cdot \rrbracket_v$ 定义为：

- $\llbracket p \rrbracket_v = v(p)$
- $\llbracket \bot \rrbracket_v = \text{false}$
- $\llbracket \top \rrbracket_v = \text{true}$
- $\llbracket \phi \land \psi \rrbracket_v = \llbracket \phi \rrbracket_v \land \llbracket \psi \rrbracket_v$
- $\llbracket \phi \lor \psi \rrbracket_v = \llbracket \phi \rrbracket_v \lor \llbracket \psi \rrbracket_v$
- $\llbracket \phi \rightarrow \psi \rrbracket_v = \neg \llbracket \phi \rrbracket_v \lor \llbracket \psi \rrbracket_v$
- $\llbracket \neg \phi \rrbracket_v = \neg \llbracket \phi \rrbracket_v$

**定义 1.1.6 (满足关系)**
$v \models \phi$ 当且仅当 $\llbracket \phi \rrbracket_v = \text{true}$

**定义 1.1.7 (重言式)**
$\phi$ 是重言式当且仅当 $\forall v, v \models \phi$

### 1.3 命题逻辑定理

**定理 1.1.1 (德摩根律)**
$\neg(\phi \land \psi) \equiv \neg \phi \lor \neg \psi$ 和 $\neg(\phi \lor \psi) \equiv \neg \phi \land \neg \psi$

**证明：** 通过真值表：

```haskell
-- 德摩根律证明
demorganLaw :: Bool
demorganLaw = 
  let formulas = generateAllFormulas
      demorgan1 = all (\f -> not (and f) == or (map not f)) formulas
      demorgan2 = all (\f -> not (or f) == and (map not f)) formulas
  in demorgan1 && demorgan2

-- 真值表生成
generateTruthTable :: Formula -> [(Assignment, Bool)]
generateTruthTable formula = 
  let variables = extractVariables formula
      assignments = generateAssignments variables
  in [(assign, evaluate formula assign) | assign <- assignments]

-- 公式求值
evaluate :: Formula -> Assignment -> Bool
evaluate formula assignment = 
  case formula of
    Variable p -> assignment p
    And phi psi -> evaluate phi assignment && evaluate psi assignment
    Or phi psi -> evaluate phi assignment || evaluate psi assignment
    Not phi -> not (evaluate phi assignment)
    Implies phi psi -> not (evaluate phi assignment) || evaluate psi assignment
```

**定理 1.1.2 (分配律)**
$\phi \land (\psi \lor \chi) \equiv (\phi \land \psi) \lor (\phi \land \chi)$

**定理 1.1.3 (双重否定律)**
$\neg \neg \phi \equiv \phi$

## 2. 谓词逻辑

### 2.1 谓词基础

**定义 2.1.1 (谓词)**
谓词是属性或关系：$\text{Predicate} = \{P : \text{Property} \lor \text{Relation}\}$

**定义 2.1.2 (个体变元)**
个体变元是论域中的对象：$x, y, z, \ldots \in \text{Var}$

**定义 2.1.3 (谓词公式)**
谓词公式的语法：
$$\phi ::= P(t_1, \ldots, t_n) \mid t_1 = t_2 \mid \bot \mid \top \mid \phi_1 \land \phi_2 \mid \phi_1 \lor \phi_2 \mid \phi_1 \rightarrow \phi_2 \mid \neg \phi \mid \forall x \phi \mid \exists x \phi$$

**定义 2.1.4 (项)**
项的语法：
$$t ::= x \mid c \mid f(t_1, \ldots, t_n)$$

### 2.2 语义定义

**定义 2.1.5 (结构)**
结构 $\mathcal{M} = (D, I)$，其中：

- $D$ 是论域
- $I$ 是解释函数

**定义 2.1.6 (赋值)**
赋值是函数 $\sigma : \text{Var} \rightarrow D$

**定义 2.1.7 (语义函数)**
语义函数 $\llbracket \cdot \rrbracket_{\mathcal{M}, \sigma}$ 定义为：

- $\llbracket x \rrbracket_{\mathcal{M}, \sigma} = \sigma(x)$
- $\llbracket c \rrbracket_{\mathcal{M}, \sigma} = I(c)$
- $\llbracket f(t_1, \ldots, t_n) \rrbracket_{\mathcal{M}, \sigma} = I(f)(\llbracket t_1 \rrbracket_{\mathcal{M}, \sigma}, \ldots, \llbracket t_n \rrbracket_{\mathcal{M}, \sigma})$
- $\llbracket P(t_1, \ldots, t_n) \rrbracket_{\mathcal{M}, \sigma} = I(P)(\llbracket t_1 \rrbracket_{\mathcal{M}, \sigma}, \ldots, \llbracket t_n \rrbracket_{\mathcal{M}, \sigma})$
- $\llbracket \forall x \phi \rrbracket_{\mathcal{M}, \sigma} = \text{true}$ 当且仅当 $\forall d \in D, \llbracket \phi \rrbracket_{\mathcal{M}, \sigma[x \mapsto d]} = \text{true}$
- $\llbracket \exists x \phi \rrbracket_{\mathcal{M}, \sigma} = \text{true}$ 当且仅当 $\exists d \in D, \llbracket \phi \rrbracket_{\mathcal{M}, \sigma[x \mapsto d]} = \text{true}$

### 2.3 谓词逻辑定理

**定理 2.1.1 (量词对偶定理)**
$\neg \forall x P(x) \equiv \exists x \neg P(x)$ 和 $\neg \exists x P(x) \equiv \forall x \neg P(x)$

**证明：** 通过语义等价：

```haskell
-- 量词对偶证明
quantifierDuality :: Bool
quantifierDuality = 
  let structures = generateStructures
      formulas = generateFormulas
      duality1 = all (\s -> all (\f -> 
        not (forallQuantifier f) == existsQuantifier (not f)) formulas) structures
      duality2 = all (\s -> all (\f -> 
        not (existsQuantifier f) == forallQuantifier (not f)) formulas) structures
  in duality1 && duality2

-- 全称量词语义
forallQuantifier :: Formula -> Structure -> Assignment -> Bool
forallQuantifier formula structure assignment = 
  let domain = structureDomain structure
  in all (\d -> evaluate formula structure (assignment `update` d)) domain

-- 存在量词语义
existsQuantifier :: Formula -> Structure -> Assignment -> Bool
existsQuantifier formula structure assignment = 
  let domain = structureDomain structure
  in any (\d -> evaluate formula structure (assignment `update` d)) domain
```

**定理 2.1.2 (量词分配律)**
$\forall x (\phi \land \psi) \equiv \forall x \phi \land \forall x \psi$

**定理 2.1.3 (存在分配律)**
$\exists x (\phi \lor \psi) \equiv \exists x \phi \lor \exists x \psi$

## 3. 模态逻辑

### 3.1 模态基础

**定义 3.1.1 (模态算子)**
模态算子包括：

- $\Box$：必然性
- $\Diamond$：可能性

**定义 3.1.2 (模态公式)**
模态公式的语法：
$$\phi ::= p \mid \bot \mid \top \mid \phi_1 \land \phi_2 \mid \phi_1 \lor \phi_2 \mid \phi_1 \rightarrow \phi_2 \mid \neg \phi \mid \Box \phi \mid \Diamond \phi$$

**公理 3.1.1 (K公理)**
$\Box(\phi \rightarrow \psi) \rightarrow (\Box \phi \rightarrow \Box \psi)$

**公理 3.1.2 (T公理)**
$\Box \phi \rightarrow \phi$

**公理 3.1.3 (4公理)**
$\Box \phi \rightarrow \Box \Box \phi$

**公理 3.1.4 (5公理)**
$\Diamond \phi \rightarrow \Box \Diamond \phi$

### 3.2 可能世界语义

**定义 3.1.3 (克里普克模型)**
克里普克模型 $\mathcal{M} = (W, R, V)$，其中：

- $W$ 是可能世界集合
- $R \subseteq W \times W$ 是可达关系
- $V : W \rightarrow \mathcal{P}(\text{PropVar})$ 是赋值函数

**定义 3.1.4 (模态语义)**
模态语义定义为：

- $\mathcal{M}, w \models p$ 当且仅当 $p \in V(w)$
- $\mathcal{M}, w \models \Box \phi$ 当且仅当 $\forall v, wRv \Rightarrow \mathcal{M}, v \models \phi$
- $\mathcal{M}, w \models \Diamond \phi$ 当且仅当 $\exists v, wRv \land \mathcal{M}, v \models \phi$

**定理 3.1.1 (模态对偶定理)**
$\Box \phi \equiv \neg \Diamond \neg \phi$ 和 $\Diamond \phi \equiv \neg \Box \neg \phi$

**证明：** 通过语义等价：

```haskell
-- 模态对偶证明
modalDuality :: Bool
modalDuality = 
  let models = generateKripkeModels
      formulas = generateModalFormulas
      duality1 = all (\m -> all (\w -> all (\f -> 
        evaluate (necessarily f) m w == evaluate (not (possibly (not f))) m w) formulas) (worlds m)) models
      duality2 = all (\m -> all (\w -> all (\f -> 
        evaluate (possibly f) m w == evaluate (not (necessarily (not f))) m w) formulas) (worlds m)) models
  in duality1 && duality2

-- 必然性语义
necessarily :: Formula -> KripkeModel -> World -> Bool
necessarily formula model world = 
  let accessible = accessibleWorlds model world
  in all (\w -> evaluate formula model w) accessible

-- 可能性语义
possibly :: Formula -> KripkeModel -> World -> Bool
possibly formula model world = 
  let accessible = accessibleWorlds model world
  in any (\w -> evaluate formula model w) accessible
```

### 3.3 模态系统

**定义 3.1.5 (模态系统)**
不同的模态系统：

- **K**：基本模态逻辑
- **T**：K + T公理
- **S4**：T + 4公理
- **S5**：S4 + 5公理

**定理 3.1.2 (S5特征定理)**
S5中的可达关系是等价关系。

**证明：** 通过公理推导：

```haskell
-- S5特征证明
s5Characterization :: Bool
s5Characterization = 
  let s5Models = generateS5Models
      reflexivity = all (\m -> isReflexive (accessibilityRelation m)) s5Models
      transitivity = all (\m -> isTransitive (accessibilityRelation m)) s5Models
      euclidean = all (\m -> isEuclidean (accessibilityRelation m)) s5Models
  in reflexivity && transitivity && euclidean

-- 等价关系检查
isEquivalenceRelation :: Relation -> Bool
isEquivalenceRelation relation = 
  let reflexive = isReflexive relation
      symmetric = isSymmetric relation
      transitive = isTransitive relation
  in reflexive && symmetric && transitive
```

## 4. 时态逻辑

### 4.1 时态基础

**定义 4.1.1 (时态算子)**
时态算子包括：

- $\text{G}$：总是（全局）
- $\text{F}$：最终（将来）
- $\text{X}$：下一个
- $\text{U}$：直到

**定义 4.1.2 (时态公式)**
时态公式的语法：
$$\phi ::= p \mid \bot \mid \top \mid \phi_1 \land \phi_2 \mid \phi_1 \lor \phi_2 \mid \phi_1 \rightarrow \phi_2 \mid \neg \phi \mid \text{G} \phi \mid \text{F} \phi \mid \text{X} \phi \mid \phi_1 \text{U} \phi_2$$

**公理 4.1.1 (时态公理)**

- $\text{G} \phi \rightarrow \phi$
- $\text{G} \phi \rightarrow \text{X} \phi$
- $\text{G} \phi \rightarrow \text{G} \text{G} \phi$

### 4.2 线性时态语义

**定义 4.1.3 (线性时态模型)**
线性时态模型 $\mathcal{M} = (S, \rightarrow, V)$，其中：

- $S$ 是状态集合
- $\rightarrow \subseteq S \times S$ 是转移关系
- $V : S \rightarrow \mathcal{P}(\text{PropVar})$ 是赋值函数

**定义 4.1.4 (时态语义)**
时态语义定义为：

- $\mathcal{M}, s \models \text{X} \phi$ 当且仅当 $\exists s', s \rightarrow s' \land \mathcal{M}, s' \models \phi$
- $\mathcal{M}, s \models \text{G} \phi$ 当且仅当 $\forall s', s \rightarrow^* s' \Rightarrow \mathcal{M}, s' \models \phi$
- $\mathcal{M}, s \models \text{F} \phi$ 当且仅当 $\exists s', s \rightarrow^* s' \land \mathcal{M}, s' \models \phi$
- $\mathcal{M}, s \models \phi \text{U} \psi$ 当且仅当 $\exists s', s \rightarrow^* s' \land \mathcal{M}, s' \models \psi \land \forall s'', s \rightarrow^* s'' \rightarrow^* s' \Rightarrow \mathcal{M}, s'' \models \phi$

**定理 4.1.1 (时态对偶定理)**
$\text{G} \phi \equiv \neg \text{F} \neg \phi$ 和 $\text{F} \phi \equiv \neg \text{G} \neg \phi$

**证明：** 通过语义等价：

```haskell
-- 时态对偶证明
temporalDuality :: Bool
temporalDuality = 
  let models = generateTemporalModels
      formulas = generateTemporalFormulas
      duality1 = all (\m -> all (\s -> all (\f -> 
        evaluate (globally f) m s == evaluate (not (finally (not f))) m s) formulas) (states m)) models
      duality2 = all (\m -> all (\s -> all (\f -> 
        evaluate (finally f) m s == evaluate (not (globally (not f))) m s) formulas) (states m)) models
  in duality1 && duality2

-- 全局语义
globally :: Formula -> TemporalModel -> State -> Bool
globally formula model state = 
  let reachable = reachableStates model state
  in all (\s -> evaluate formula model s) reachable

-- 最终语义
finally :: Formula -> TemporalModel -> State -> Bool
finally formula model state = 
  let reachable = reachableStates model state
  in any (\s -> evaluate formula model s) reachable
```

## 5. 二阶逻辑

### 5.1 二阶基础

**定义 5.1.1 (二阶变元)**
二阶变元是关系变元：$X, Y, Z, \ldots \in \text{RelVar}$

**定义 5.1.2 (二阶公式)**
二阶公式的语法：
$$\phi ::= P(t_1, \ldots, t_n) \mid X(t_1, \ldots, t_n) \mid t_1 = t_2 \mid \bot \mid \top \mid \phi_1 \land \phi_2 \mid \phi_1 \lor \phi_2 \mid \phi_1 \rightarrow \phi_2 \mid \neg \phi \mid \forall x \phi \mid \exists x \phi \mid \forall X \phi \mid \exists X \phi$$

**定义 5.1.3 (二阶语义)**
二阶语义扩展一阶语义：

- $\llbracket \forall X \phi \rrbracket_{\mathcal{M}, \sigma} = \text{true}$ 当且仅当 $\forall R \subseteq D^n, \llbracket \phi \rrbracket_{\mathcal{M}, \sigma[X \mapsto R]} = \text{true}$
- $\llbracket \exists X \phi \rrbracket_{\mathcal{M}, \sigma} = \text{true}$ 当且仅当 $\exists R \subseteq D^n, \llbracket \phi \rrbracket_{\mathcal{M}, \sigma[X \mapsto R]} = \text{true}$

### 5.2 二阶逻辑性质

**定理 5.1.1 (二阶逻辑不完备性)**
二阶逻辑是不完备的。

**证明：** 通过哥德尔不完备定理：

```haskell
-- 二阶逻辑不完备性
secondOrderIncompleteness :: Bool
secondOrderIncompleteness = 
  let consistent = isConsistent secondOrderLogic
      complete = isComplete secondOrderLogic
      strong = isStrongEnough secondOrderLogic
  in strong && (not consistent || not complete)

-- 一致性检查
isConsistent :: LogicSystem -> Bool
isConsistent system = 
  not (provable system contradiction)

-- 完备性检查
isComplete :: LogicSystem -> Bool
isComplete system = 
  all (\phi -> valid system phi == provable system phi) (allFormulas system)
```

**定理 5.1.2 (二阶逻辑表达能力)**
二阶逻辑可以表达一阶逻辑无法表达的概念。

**证明：** 通过构造性证明：

```haskell
-- 表达能力证明
expressivePower :: Bool
expressivePower = 
  let finiteness = expressFiniteness secondOrderLogic
      wellOrdering = expressWellOrdering secondOrderLogic
      induction = expressInduction secondOrderLogic
  in finiteness && wellOrdering && induction

-- 有限性表达
expressFiniteness :: LogicSystem -> Bool
expressFiniteness system = 
  let finitenessFormula = forallRel (\r -> 
        injective r && surjective r ==> bijective r)
  in expressible system finitenessFormula
```

## 6. 逻辑系统

### 6.1 公理化系统

**定义 6.1.1 (公理化系统)**
公理化系统 $\mathcal{S} = (L, A, R)$，其中：

- $L$ 是语言
- $A$ 是公理集合
- $R$ 是推理规则集合

**公理 6.1.1 (经典逻辑公理)**
经典逻辑的公理包括：

1. $\phi \rightarrow (\psi \rightarrow \phi)$
2. $(\phi \rightarrow (\psi \rightarrow \chi)) \rightarrow ((\phi \rightarrow \psi) \rightarrow (\phi \rightarrow \chi))$
3. $(\neg \phi \rightarrow \neg \psi) \rightarrow (\psi \rightarrow \phi)$

**规则 6.1.1 (分离规则)**
$$\frac{\phi \quad \phi \rightarrow \psi}{\psi}$$

### 6.2 自然演绎

**定义 6.1.2 (自然演绎规则)**
自然演绎规则包括：

- **引入规则**：$\frac{\Gamma, \phi \vdash \psi}{\Gamma \vdash \phi \rightarrow \psi}$
- **消解规则**：$\frac{\Gamma \vdash \phi \rightarrow \psi \quad \Gamma \vdash \phi}{\Gamma \vdash \psi}$
- **全称引入**：$\frac{\Gamma \vdash \phi}{\Gamma \vdash \forall x \phi}$ （$x$ 不在 $\Gamma$ 中自由出现）
- **全称消解**：$\frac{\Gamma \vdash \forall x \phi}{\Gamma \vdash \phi[t/x]}$

**定理 6.1.1 (演绎定理)**
$\Gamma, \phi \vdash \psi$ 当且仅当 $\Gamma \vdash \phi \rightarrow \psi$

**证明：** 通过规则应用：

```haskell
-- 演绎定理证明
deductionTheorem :: Context -> Formula -> Formula -> Bool
deductionTheorem context phi psi = 
  let leftToRight = context `proves` (phi `implies` psi)
      rightToLeft = (context `extend` phi) `proves` psi
  in leftToRight == rightToLeft

-- 证明检查
proves :: Context -> Formula -> Bool
proves context formula = 
  let rules = naturalDeductionRules
      proof = constructProof context formula rules
  in isJust proof
```

## 7. 证明理论

### 7.1 证明构造

**定义 7.1.1 (证明)**
证明是公式序列 $\phi_1, \phi_2, \ldots, \phi_n$，其中每个 $\phi_i$ 要么是公理，要么通过推理规则从前面的公式得到。

**定义 7.1.2 (证明树)**
证明树是证明的结构化表示。

**定理 7.1.1 (证明规范化)**
每个证明都可以规范化。

**证明：** 通过归约规则：

```haskell
-- 证明规范化
normalizeProof :: Proof -> Proof
normalizeProof proof = 
  let redexes = findRedexes proof
      normalized = reduceRedexes proof redexes
  in if null redexes
     then proof
     else normalizeProof normalized

-- 归约查找
findRedexes :: Proof -> [Redex]
findRedexes proof = 
  case proof of
    ImplicationElim (ImplicationIntro p) q -> [Redex p q]
    _ -> concatMap findRedexes (subProofs proof)
```

### 7.2 证明搜索

**定义 7.1.3 (证明搜索)**
证明搜索是自动寻找证明的过程。

**算法 7.1.1 (反向证明搜索)**

```haskell
-- 反向证明搜索
backwardProofSearch :: Formula -> Maybe Proof
backwardProofSearch goal = 
  let subgoals = decomposeGoal goal
      proofs = map backwardProofSearch subgoals
  in if all isJust proofs
     then Just (constructProof goal (map fromJust proofs))
     else Nothing

-- 目标分解
decomposeGoal :: Formula -> [Formula]
decomposeGoal formula = 
  case formula of
    Implies phi psi -> [psi]
    And phi psi -> [phi, psi]
    Or phi psi -> [phi]  -- 选择左分支
    Not phi -> [phi]     -- 矛盾证明
    _ -> []
```

## 8. 模型理论

### 8.1 模型构造

**定义 8.1.1 (模型)**
模型是语言的解释：$\mathcal{M} = (D, I)$，其中 $D$ 是论域，$I$ 是解释函数。

**定义 8.1.2 (同构)**
两个模型 $\mathcal{M}_1$ 和 $\mathcal{M}_2$ 是同构的，如果存在双射 $f : D_1 \rightarrow D_2$ 保持所有结构。

**定理 8.1.1 (同构保持定理)**
同构的模型满足相同的句子。

**证明：** 通过结构保持：

```haskell
-- 同构保持证明
isomorphismPreservation :: Model -> Model -> Bool
isomorphismPreservation model1 model2 = 
  let isomorphism = findIsomorphism model1 model2
      sentences = allSentences
      preservation = all (\s -> 
        evaluate s model1 == evaluate s model2) sentences
  in isJust isomorphism && preservation

-- 同构查找
findIsomorphism :: Model -> Model -> Maybe Isomorphism
findIsomorphism model1 model2 = 
  let domain1 = modelDomain model1
      domain2 = modelDomain model2
      bijections = generateBijections domain1 domain2
      isomorphisms = filter (\f -> isIsomorphism f model1 model2) bijections
  in if null isomorphisms then Nothing else Just (head isomorphisms)
```

### 8.2 紧致性定理

**定理 8.1.2 (紧致性定理)**
如果公式集 $\Gamma$ 的每个有限子集都有模型，则 $\Gamma$ 有模型。

**证明：** 通过超积构造：

```haskell
-- 紧致性定理
compactnessTheorem :: [Formula] -> Bool
compactnessTheorem formulas = 
  let finiteSubsets = generateFiniteSubsets formulas
      allSatisfiable = all hasModel finiteSubsets
      wholeSatisfiable = hasModel formulas
  in allSatisfiable == wholeSatisfiable

-- 模型存在检查
hasModel :: [Formula] -> Bool
hasModel formulas = 
  let interpretations = generateInterpretations formulas
      satisfying = filter (\i -> satisfies i formulas) interpretations
  in not (null satisfying)
```

## 9. 逻辑应用

### 9.1 程序验证

**应用 9.1.1 (霍尔逻辑)**
使用霍尔逻辑进行程序验证：

```haskell
-- 霍尔逻辑
hoareLogic :: Program -> Precondition -> Postcondition -> Bool
hoareLogic program pre post = 
  let hoareTriple = HoareTriple pre program post
      valid = isValidHoareTriple hoareTriple
  in valid

-- 霍尔三元组验证
isValidHoareTriple :: HoareTriple -> Bool
isValidHoareTriple triple = 
  let pre = precondition triple
      program = program triple
      post = postcondition triple
      semantics = programSemantics program
  in all (\state -> 
    evaluate pre state ==> 
    all (\finalState -> evaluate post finalState) (semantics state)) allStates
```

**应用 9.1.2 (模型检查)**
使用模型检查验证系统性质：

```haskell
-- 模型检查
modelChecking :: System -> Formula -> Bool
modelChecking system formula = 
  let model = systemToModel system
      satisfaction = all (\state -> evaluate formula model state) (systemStates system)
  in satisfaction

-- 系统到模型转换
systemToModel :: System -> Model
systemToModel system = 
  let states = systemStates system
      transitions = systemTransitions system
      labels = systemLabels system
  in Model { domain = states
           , interpretation = \p -> filter (\s -> p `member` labels s) states }
```

### 9.2 知识表示

**应用 9.2.1 (描述逻辑)**
使用描述逻辑进行知识表示：

```haskell
-- 描述逻辑
descriptionLogic :: KnowledgeBase -> Query -> Bool
descriptionLogic kb query = 
  let model = knowledgeBaseToModel kb
      satisfaction = evaluate query model
  in satisfaction

-- 知识库到模型转换
knowledgeBaseToModel :: KnowledgeBase -> Model
knowledgeBaseToModel kb = 
  let concepts = knowledgeBaseConcepts kb
      roles = knowledgeBaseRoles kb
      individuals = knowledgeBaseIndividuals kb
  in Model { domain = individuals
           , interpretation = \c -> conceptExtension c concepts }
```

## 10. 逻辑扩展

### 10.1 非经典逻辑

**扩展 10.1.1 (直觉主义逻辑)**
直觉主义逻辑拒绝排中律：

```haskell
-- 直觉主义逻辑
intuitionisticLogic :: Formula -> Bool
intuitionisticLogic formula = 
  let classicalValid = classicalValidity formula
      intuitionisticValid = intuitionisticValidity formula
  in intuitionisticValid && not classicalValid

-- 直觉主义有效性
intuitionisticValidity :: Formula -> Bool
intuitionisticValidity formula = 
  let kripkeModels = generateKripkeModels
  in all (\m -> all (\w -> evaluate formula m w) (worlds m)) kripkeModels
```

**扩展 10.1.2 (模糊逻辑)**
模糊逻辑处理模糊性：

```haskell
-- 模糊逻辑
fuzzyLogic :: FuzzyFormula -> FuzzyValue
fuzzyLogic formula = 
  case formula of
    FuzzyAnd phi psi -> min (fuzzyLogic phi) (fuzzyLogic psi)
    FuzzyOr phi psi -> max (fuzzyLogic phi) (fuzzyLogic psi)
    FuzzyNot phi -> 1 - fuzzyLogic phi
    FuzzyImplies phi psi -> max (1 - fuzzyLogic phi) (fuzzyLogic psi)
```

### 10.2 高阶逻辑

**扩展 10.2.1 (类型论)**
类型论作为高阶逻辑：

```haskell
-- 类型论
typeTheory :: Type -> Term -> Bool
typeTheory typ term = 
  let typeCheck = typeCheckTerm term typ
      wellTyped = isWellTyped term
  in typeCheck && wellTyped

-- 类型检查
typeCheckTerm :: Term -> Type -> Bool
typeCheckTerm term typ = 
  case term of
    Variable x -> variableType x == typ
    Application f arg -> 
      let functionType = typeCheckTerm f (FunctionType dom cod)
          argumentType = typeCheckTerm arg dom
      in functionType && argumentType && cod == typ
    Lambda x body -> 
      let bodyType = typeCheckTerm body cod
      in bodyType && typ == FunctionType (variableType x) cod
```

## 总结

本文档建立了经典逻辑理论的完整框架，包括：

1. **命题逻辑**：命题、语义、重言式
2. **谓词逻辑**：谓词、量词、语义
3. **模态逻辑**：模态算子、可能世界语义
4. **时态逻辑**：时态算子、线性语义
5. **二阶逻辑**：二阶变元、表达能力
6. **逻辑系统**：公理化系统、自然演绎
7. **证明理论**：证明构造、证明搜索
8. **模型理论**：模型构造、紧致性
9. **逻辑应用**：程序验证、知识表示
10. **逻辑扩展**：非经典逻辑、高阶逻辑

该框架为逻辑研究提供了：

- 严格的形式化基础
- 完整的语义定义
- 重要的定理证明
- 实际的应用指导
- 理论的扩展方向

该经典逻辑理论为计算机科学、人工智能、哲学等领域提供了重要的理论基础。
