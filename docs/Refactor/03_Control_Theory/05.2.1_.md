# 05.2.1 ç°ä»£æ§åˆ¶ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç°ä»£æ§åˆ¶ç†è®ºæ˜¯æ§åˆ¶ç†è®ºçš„é‡è¦åˆ†æ”¯ï¼Œä¸»è¦åŸºäºçŠ¶æ€ç©ºé—´æ–¹æ³•ï¼Œç ”ç©¶å¤šè¾“å…¥å¤šè¾“å‡ºç³»ç»Ÿçš„æ§åˆ¶é—®é¢˜ã€‚ç°ä»£æ§åˆ¶ç†è®ºå¼ºè°ƒç³»ç»Ÿçš„å†…éƒ¨ç»“æ„ï¼Œé€šè¿‡çŠ¶æ€å˜é‡æè¿°ç³»ç»ŸåŠ¨æ€ç‰¹æ€§ï¼Œä¸ºå¤æ‚ç³»ç»Ÿçš„åˆ†æå’Œè®¾è®¡æä¾›äº†å¼ºæœ‰åŠ›çš„æ•°å­¦å·¥å…·ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **çŠ¶æ€ç©ºé—´å»ºæ¨¡**ï¼šå»ºç«‹ç³»ç»ŸçŠ¶æ€ç©ºé—´æ¨¡å‹ï¼Œæè¿°ç³»ç»Ÿå†…éƒ¨åŠ¨æ€
2. **å¯æ§æ€§ä¸å¯è§‚æ€§**ï¼šåˆ†æç³»ç»Ÿçš„åŸºæœ¬ç»“æ„æ€§è´¨
3. **çŠ¶æ€åé¦ˆæ§åˆ¶**ï¼šè®¾è®¡åŸºäºçŠ¶æ€åé¦ˆçš„æ§åˆ¶å¾‹
4. **æœ€ä¼˜æ§åˆ¶**ï¼šæ±‚è§£æœ€ä¼˜æ§åˆ¶é—®é¢˜
5. **é²æ£’æ§åˆ¶**ï¼šå¤„ç†ç³»ç»Ÿä¸ç¡®å®šæ€§å’Œå¤–éƒ¨æ‰°åŠ¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [çŠ¶æ€ç©ºé—´æ–¹æ³•](#2-çŠ¶æ€ç©ºé—´æ–¹æ³•)
3. [å¯æ§æ€§ä¸å¯è§‚æ€§](#3-å¯æ§æ€§ä¸å¯è§‚æ€§)
4. [çŠ¶æ€åé¦ˆæ§åˆ¶](#4-çŠ¶æ€åé¦ˆæ§åˆ¶)
5. [æœ€ä¼˜æ§åˆ¶ç†è®º](#5-æœ€ä¼˜æ§åˆ¶ç†è®º)
6. [é²æ£’æ§åˆ¶ç†è®º](#6-é²æ£’æ§åˆ¶ç†è®º)
7. [ä»£ç å®ç°](#7-ä»£ç å®ç°)
8. [åº”ç”¨ç¤ºä¾‹](#8-åº”ç”¨ç¤ºä¾‹)
9. [ç›¸å…³ç†è®º](#9-ç›¸å…³ç†è®º)
10. [å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 çŠ¶æ€å˜é‡

**å®šä¹‰ 1.1.1** (çŠ¶æ€å˜é‡)
å¯¹äºåŠ¨æ€ç³»ç»Ÿï¼ŒçŠ¶æ€å˜é‡æ˜¯èƒ½å¤Ÿå®Œå…¨æè¿°ç³»ç»Ÿåœ¨ä»»æ„æ—¶åˆ»è¡Œä¸ºçš„æœ€å°å˜é‡é›†åˆã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
è®¾ç³»ç»Ÿåœ¨æ—¶åˆ» $t$ çš„çŠ¶æ€ä¸º $x(t) \in \mathbb{R}^n$ï¼Œåˆ™ç³»ç»Ÿçš„åŠ¨æ€è¡Œä¸ºç”±ä»¥ä¸‹å¾®åˆ†æ–¹ç¨‹æè¿°ï¼š

$$\dot{x}(t) = f(x(t), u(t), t)$$

å…¶ä¸­ï¼š

- $x(t)$ æ˜¯çŠ¶æ€å‘é‡
- $u(t)$ æ˜¯æ§åˆ¶è¾“å…¥å‘é‡
- $f$ æ˜¯çŠ¶æ€è½¬ç§»å‡½æ•°

### 1.2 çŠ¶æ€ç©ºé—´

**å®šä¹‰ 1.2.1** (çŠ¶æ€ç©ºé—´)
çŠ¶æ€ç©ºé—´æ˜¯æ‰€æœ‰å¯èƒ½çŠ¶æ€ç»„æˆçš„å‘é‡ç©ºé—´ï¼Œé€šå¸¸è®°ä¸º $\mathbb{R}^n$ã€‚

**æ€§è´¨**ï¼š

- çŠ¶æ€ç©ºé—´æ˜¯ç³»ç»ŸåŠ¨æ€æ¼”åŒ–çš„èˆå°
- æ¯ä¸ªçŠ¶æ€å¯¹åº”çŠ¶æ€ç©ºé—´ä¸­çš„ä¸€ä¸ªç‚¹
- ç³»ç»Ÿè½¨è¿¹æ˜¯çŠ¶æ€ç©ºé—´ä¸­çš„ä¸€æ¡æ›²çº¿

### 1.3 çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿ

**å®šä¹‰ 1.3.1** (çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿ)
çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿçš„çŠ¶æ€ç©ºé—´æ¨¡å‹ä¸ºï¼š

$$\begin{align}
\dot{x}(t) &= Ax(t) + Bu(t) \\
y(t) &= Cx(t) + Du(t)
\end{align}$$

å…¶ä¸­ï¼š
- $A \in \mathbb{R}^{n \times n}$ æ˜¯ç³»ç»ŸçŸ©é˜µ
- $B \in \mathbb{R}^{n \times m}$ æ˜¯è¾“å…¥çŸ©é˜µ
- $C \in \mathbb{R}^{p \times n}$ æ˜¯è¾“å‡ºçŸ©é˜µ
- $D \in \mathbb{R}^{p \times m}$ æ˜¯ç›´æ¥ä¼ é€’çŸ©é˜µ

## 2. çŠ¶æ€ç©ºé—´æ–¹æ³•

### 2.1 çŠ¶æ€ç©ºé—´å»ºæ¨¡

**å®šç† 2.1.1** (çŠ¶æ€ç©ºé—´æ¨¡å‹çš„å­˜åœ¨æ€§)
å¯¹äºä»»æ„å› æœç³»ç»Ÿï¼Œå¦‚æœæ»¡è¶³å±€éƒ¨åˆ©æ™®å¸ŒèŒ¨æ¡ä»¶ï¼Œåˆ™å­˜åœ¨çŠ¶æ€ç©ºé—´æ¨¡å‹ã€‚

**è¯æ˜**ï¼š
è®¾ç³»ç»Ÿè¾“å…¥è¾“å‡ºå…³ç³»ä¸º $y(t) = H(u(t))$ï¼Œå…¶ä¸­ $H$ æ˜¯å› æœç®—å­ã€‚
æ ¹æ®å› æœæ€§ï¼Œ$y(t)$ åªä¾èµ–äº $u(\tau)$ï¼Œ$\tau \leq t$ã€‚
å®šä¹‰çŠ¶æ€å˜é‡ $x(t) = \{u(\tau) : \tau \leq t\}$ï¼Œåˆ™ç³»ç»Ÿå¯è¡¨ç¤ºä¸ºï¼š

$$\begin{align}
\dot{x}(t) &= f(x(t), u(t)) \\
y(t) &= g(x(t), u(t))
\end{align}$$

### 2.2 çŠ¶æ€è½¬ç§»çŸ©é˜µ

**å®šä¹‰ 2.2.1** (çŠ¶æ€è½¬ç§»çŸ©é˜µ)
å¯¹äºçº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿï¼ŒçŠ¶æ€è½¬ç§»çŸ©é˜µå®šä¹‰ä¸ºï¼š

$$\Phi(t) = e^{At} = \sum_{k=0}^{\infty} \frac{(At)^k}{k!}$$

**æ€§è´¨**ï¼š
1. $\Phi(0) = I$
2. $\Phi(t_1 + t_2) = \Phi(t_1)\Phi(t_2)$
3. $\Phi^{-1}(t) = \Phi(-t)$

### 2.3 ç³»ç»Ÿå“åº”

**å®šç† 2.3.1** (ç³»ç»Ÿå“åº”)
çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿçš„çŠ¶æ€å“åº”ä¸ºï¼š

$$x(t) = e^{At}x(0) + \int_0^t e^{A(t-\tau)}Bu(\tau)d\tau$$

**è¯æ˜**ï¼š
å¯¹çŠ¶æ€æ–¹ç¨‹ $\dot{x}(t) = Ax(t) + Bu(t)$ ä¸¤è¾¹ä¹˜ä»¥ $e^{-At}$ï¼š

$$e^{-At}\dot{x}(t) = e^{-At}Ax(t) + e^{-At}Bu(t)$$

æ³¨æ„åˆ° $\frac{d}{dt}(e^{-At}x(t)) = e^{-At}\dot{x}(t) - e^{-At}Ax(t)$ï¼Œå› æ­¤ï¼š

$$\frac{d}{dt}(e^{-At}x(t)) = e^{-At}Bu(t)$$

ç§¯åˆ†å¾—åˆ°ï¼š

$$e^{-At}x(t) = x(0) + \int_0^t e^{-A\tau}Bu(\tau)d\tau$$

æ•´ç†å¾—åˆ°çŠ¶æ€å“åº”å…¬å¼ã€‚

## 3. å¯æ§æ€§ä¸å¯è§‚æ€§

### 3.1 å¯æ§æ€§

**å®šä¹‰ 3.1.1** (å¯æ§æ€§)
ç³»ç»Ÿ $(A,B)$ åœ¨æ—¶åˆ» $t_0$ å¯æ§ï¼Œå¦‚æœå¯¹äºä»»æ„åˆå§‹çŠ¶æ€ $x_0$ å’Œç›®æ ‡çŠ¶æ€ $x_f$ï¼Œå­˜åœ¨æ§åˆ¶è¾“å…¥ $u(t)$ï¼Œä½¿å¾—ç³»ç»Ÿåœ¨æœ‰é™æ—¶é—´å†…ä» $x_0$ è½¬ç§»åˆ° $x_f$ã€‚

**å®šç† 3.1.1** (å¯æ§æ€§åˆ¤æ®)
çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿ $(A,B)$ å¯æ§çš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯å¯æ§æ€§çŸ©é˜µæ»¡ç§©ï¼š

$$\text{rank}[B \quad AB \quad A^2B \quad \cdots \quad A^{n-1}B] = n$$

**è¯æ˜**ï¼š
å¿…è¦æ€§ï¼šå‡è®¾ç³»ç»Ÿå¯æ§ä½†å¯æ§æ€§çŸ©é˜µä¸æ»¡ç§©ï¼Œåˆ™å­˜åœ¨éé›¶å‘é‡ $v$ ä½¿å¾—ï¼š

$$v^T[B \quad AB \quad A^2B \quad \cdots \quad A^{n-1}B] = 0$$

è¿™æ„å‘³ç€ $v^TA^kB = 0$ å¯¹æ‰€æœ‰ $k \geq 0$ æˆç«‹ã€‚
æ ¹æ®å‡¯è±-å“ˆå¯†é¡¿å®šç†ï¼Œ$A^n$ å¯ä»¥è¡¨ç¤ºä¸º $A^0, A^1, \ldots, A^{n-1}$ çš„çº¿æ€§ç»„åˆï¼Œå› æ­¤ $v^TA^kB = 0$ å¯¹æ‰€æœ‰ $k \geq 0$ æˆç«‹ã€‚
è¿™ä¸å¯æ§æ€§çŸ›ç›¾ã€‚

å……åˆ†æ€§ï¼šå¦‚æœå¯æ§æ€§çŸ©é˜µæ»¡ç§©ï¼Œåˆ™å¯¹äºä»»æ„ $x_0$ å’Œ $x_f$ï¼Œå¯ä»¥æ„é€ æ§åˆ¶è¾“å…¥ï¼š

$$u(t) = B^Te^{A^T(T-t)}W_c^{-1}(T)(x_f - e^{AT}x_0)$$

å…¶ä¸­ $W_c(T) = \int_0^T e^{A\tau}BB^Te^{A^T\tau}d\tau$ æ˜¯å¯æ§æ€§æ ¼æ‹‰å§†çŸ©é˜µã€‚

### 3.2 å¯è§‚æ€§

**å®šä¹‰ 3.2.1** (å¯è§‚æ€§)
ç³»ç»Ÿ $(A,C)$ å¯è§‚ï¼Œå¦‚æœç³»ç»Ÿçš„åˆå§‹çŠ¶æ€å¯ä»¥é€šè¿‡è¾“å‡ºåœ¨æœ‰é™æ—¶é—´å†…å”¯ä¸€ç¡®å®šã€‚

**å®šç† 3.2.1** (å¯è§‚æ€§åˆ¤æ®)
çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿ $(A,C)$ å¯è§‚çš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯å¯è§‚æ€§çŸ©é˜µæ»¡ç§©ï¼š

$$\text{rank}\begin{bmatrix} C \\ CA \\ CA^2 \\ \vdots \\ CA^{n-1} \end{bmatrix} = n$$

### 3.3 å¯¹å¶æ€§

**å®šç† 3.3.1** (å¯æ§å¯è§‚å¯¹å¶æ€§)
ç³»ç»Ÿ $(A,B,C)$ çš„å¯æ§æ€§ä¸ç³»ç»Ÿ $(A^T,C^T,B^T)$ çš„å¯è§‚æ€§ç­‰ä»·ã€‚

## 4. çŠ¶æ€åé¦ˆæ§åˆ¶

### 4.1 çŠ¶æ€åé¦ˆ

**å®šä¹‰ 4.1.1** (çŠ¶æ€åé¦ˆ)
çŠ¶æ€åé¦ˆæ§åˆ¶å¾‹ä¸ºï¼š

$$u(t) = -Kx(t) + v(t)$$

å…¶ä¸­ $K \in \mathbb{R}^{m \times n}$ æ˜¯åé¦ˆå¢ç›ŠçŸ©é˜µï¼Œ$v(t)$ æ˜¯å‚è€ƒè¾“å…¥ã€‚

**é—­ç¯ç³»ç»Ÿ**ï¼š
$$\dot{x}(t) = (A - BK)x(t) + Bv(t)$$

### 4.2 æç‚¹é…ç½®

**å®šç† 4.2.1** (æç‚¹é…ç½®å®šç†)
å¦‚æœç³»ç»Ÿ $(A,B)$ å¯æ§ï¼Œåˆ™å¯¹äºä»»æ„ç»™å®šçš„ç‰¹å¾å€¼é›†åˆ $\{\lambda_1, \lambda_2, \ldots, \lambda_n\}$ï¼Œå­˜åœ¨åé¦ˆå¢ç›ŠçŸ©é˜µ $K$ï¼Œä½¿å¾—é—­ç¯ç³»ç»Ÿ $A - BK$ çš„ç‰¹å¾å€¼ä¸º $\{\lambda_1, \lambda_2, \ldots, \lambda_n\}$ã€‚

**è¯æ˜**ï¼š
ç”±äºç³»ç»Ÿå¯æ§ï¼Œå­˜åœ¨éå¥‡å¼‚å˜æ¢ $T$ ä½¿å¾—ï¼š

$$T^{-1}AT = \begin{bmatrix} 0 & 1 & 0 & \cdots & 0 \\ 0 & 0 & 1 & \cdots & 0 \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & 0 & \cdots & 1 \\ -a_0 & -a_1 & -a_2 & \cdots & -a_{n-1} \end{bmatrix}$$

$$T^{-1}B = \begin{bmatrix} 0 \\ 0 \\ \vdots \\ 0 \\ 1 \end{bmatrix}$$

è®¾æœŸæœ›ç‰¹å¾å¤šé¡¹å¼ä¸ºï¼š

$$p_d(s) = (s - \lambda_1)(s - \lambda_2) \cdots (s - \lambda_n) = s^n + d_{n-1}s^{n-1} + \cdots + d_0$$

åˆ™åé¦ˆå¢ç›ŠçŸ©é˜µä¸ºï¼š

$$K = [a_0 - d_0 \quad a_1 - d_1 \quad \cdots \quad a_{n-1} - d_{n-1}]T^{-1}$$

### 4.3 çº¿æ€§äºŒæ¬¡å‹è°ƒèŠ‚å™¨

**å®šä¹‰ 4.3.1** (LQRé—®é¢˜)
çº¿æ€§äºŒæ¬¡å‹è°ƒèŠ‚å™¨é—®é¢˜å®šä¹‰ä¸ºï¼š

$$\min_{u(t)} J = \int_0^{\infty} (x^T(t)Qx(t) + u^T(t)Ru(t))dt$$

å…¶ä¸­ $Q \geq 0$ å’Œ $R > 0$ æ˜¯æƒé‡çŸ©é˜µã€‚

**å®šç† 4.3.1** (LQRæœ€ä¼˜è§£)
LQRé—®é¢˜çš„æœ€ä¼˜æ§åˆ¶å¾‹ä¸ºï¼š

$$u^*(t) = -R^{-1}B^TPx(t)$$

å…¶ä¸­ $P$ æ˜¯ä»£æ•°é»å¡ææ–¹ç¨‹çš„è§£ï¼š

$$A^TP + PA - PBR^{-1}B^TP + Q = 0$$

## 5. æœ€ä¼˜æ§åˆ¶ç†è®º

### 5.1 å˜åˆ†æ³•

**å®šç† 5.1.1** (æ¬§æ‹‰-æ‹‰æ ¼æœ—æ—¥æ–¹ç¨‹)
å¯¹äºæ³›å‡½ï¼š

$$J = \int_{t_0}^{t_f} L(x(t), \dot{x}(t), t)dt$$

å…¶æå€¼æ¡ä»¶ä¸ºï¼š

$$\frac{\partial L}{\partial x} - \frac{d}{dt}\frac{\partial L}{\partial \dot{x}} = 0$$

### 5.2 æå¤§å€¼åŸç†

**å®šç† 5.2.1** (åºç‰¹é‡Œäºšé‡‘æå¤§å€¼åŸç†)
å¯¹äºæœ€ä¼˜æ§åˆ¶é—®é¢˜ï¼š

$$\min_{u(t)} J = \int_{t_0}^{t_f} L(x(t), u(t), t)dt$$

çº¦æŸæ¡ä»¶ï¼š
$$\dot{x}(t) = f(x(t), u(t), t)$$

æœ€ä¼˜æ§åˆ¶ $u^*(t)$ æ»¡è¶³ï¼š

$$u^*(t) = \arg\min_{u(t)} H(x^*(t), u(t), \lambda^*(t), t)$$

å…¶ä¸­å“ˆå¯†é¡¿å‡½æ•°ä¸ºï¼š

$$H(x, u, \lambda, t) = L(x, u, t) + \lambda^T f(x, u, t)$$

åæ€å˜é‡ $\lambda(t)$ æ»¡è¶³ï¼š

$$\dot{\lambda}(t) = -\frac{\partial H}{\partial x}$$

## 6. é²æ£’æ§åˆ¶ç†è®º

### 6.1 ä¸ç¡®å®šæ€§å»ºæ¨¡

**å®šä¹‰ 6.1.1** (ä¸ç¡®å®šæ€§æ¨¡å‹)
ç³»ç»Ÿä¸ç¡®å®šæ€§å¯ä»¥å»ºæ¨¡ä¸ºï¼š

$$\dot{x}(t) = (A + \Delta A)x(t) + (B + \Delta B)u(t) + w(t)$$

å…¶ä¸­ $\Delta A$ å’Œ $\Delta B$ æ˜¯å‚æ•°ä¸ç¡®å®šæ€§ï¼Œ$w(t)$ æ˜¯å¤–éƒ¨æ‰°åŠ¨ã€‚

### 6.2 Hâˆæ§åˆ¶

**å®šä¹‰ 6.2.1** (Hâˆæ§åˆ¶é—®é¢˜)
Hâˆæ§åˆ¶é—®é¢˜å®šä¹‰ä¸ºï¼š

$$\min_{K} \|T_{zw}\|_{\infty} < \gamma$$

å…¶ä¸­ $T_{zw}$ æ˜¯ä»æ‰°åŠ¨ $w$ åˆ°æ€§èƒ½è¾“å‡º $z$ çš„ä¼ é€’å‡½æ•°ã€‚

**å®šç† 6.2.1** (Hâˆæ§åˆ¶è§£)
Hâˆæ§åˆ¶å™¨çš„å­˜åœ¨æ¡ä»¶æ˜¯ä¸¤ä¸ªä»£æ•°é»å¡ææ–¹ç¨‹æœ‰æ­£å®šè§£ï¼š

$$A^TX + XA + X(\frac{1}{\gamma^2}B_1B_1^T - B_2B_2^T)X + C_1^TC_1 = 0$$

$$AY + YA^T + Y(\frac{1}{\gamma^2}C_1^TC_1 - C_2^TC_2)Y + B_1B_1^T = 0$$

## 7. ä»£ç å®ç°

### 7.1 çŠ¶æ€ç©ºé—´æ¨¡å‹

```rust
use nalgebra::{DMatrix, DVector};

/// çº¿æ€§æ—¶ä¸å˜ç³»ç»Ÿ
pub struct LinearSystem {
    pub A: DMatrix<f64>,
    pub B: DMatrix<f64>,
    pub C: DMatrix<f64>,
    pub D: DMatrix<f64>,
}

impl LinearSystem {
    /// åˆ›å»ºæ–°çš„çº¿æ€§ç³»ç»Ÿ
    pub fn new(A: DMatrix<f64>, B: DMatrix<f64>, C: DMatrix<f64>, D: DMatrix<f64>) -> Self {
        Self { A, B, C, D }
    }

    /// è®¡ç®—çŠ¶æ€è½¬ç§»çŸ©é˜µ
    pub fn state_transition_matrix(&self, t: f64) -> DMatrix<f64> {
        let n = self.A.nrows();
        let mut phi = DMatrix::identity(n, n);
        let mut term = DMatrix::identity(n, n);
        let mut factorial = 1.0;

        for k in 1..=10 {
            factorial *= k as f64;
            term = &term * &self.A * (t / k as f64);
            phi += &term;
        }

        phi
    }

    /// ç³»ç»Ÿå“åº”
    pub fn response(&self, x0: &DVector<f64>, u: &[DVector<f64>], dt: f64) -> Vec<DVector<f64>> {
        let mut x = x0.clone();
        let mut response = vec![x.clone()];

        for uk in u {
            let phi = self.state_transition_matrix(dt);
            let integral = self.compute_integral(&x, uk, dt);
            x = &phi * &x + &integral;
            response.push(x.clone());
        }

        response
    }

    /// è®¡ç®—ç§¯åˆ†é¡¹
    fn compute_integral(&self, x: &DVector<f64>, u: &DVector<f64>, dt: f64) -> DVector<f64> {
        // ä½¿ç”¨æ¢¯å½¢æ³•åˆ™è¿‘ä¼¼ç§¯åˆ†
        let phi_half = self.state_transition_matrix(dt / 2.0);
        &phi_half * &self.B * u * dt
    }
}
```

### 7.2 å¯æ§æ€§åˆ†æ

```rust
impl LinearSystem {
    /// æ£€æŸ¥ç³»ç»Ÿå¯æ§æ€§
    pub fn is_controllable(&self) -> bool {
        let n = self.A.nrows();
        let mut controllability_matrix = DMatrix::zeros(n, n * self.B.ncols());

        let mut power = DMatrix::identity(n, n);
        for i in 0..n {
            let start_col = i * self.B.ncols();
            let end_col = start_col + self.B.ncols();
            controllability_matrix.slice_mut((0, start_col), (n, self.B.ncols())).copy_from(&(&power * &self.B));
            power = &power * &self.A;
        }

        controllability_matrix.rank() == n
    }

    /// è®¡ç®—å¯æ§æ€§çŸ©é˜µ
    pub fn controllability_matrix(&self) -> DMatrix<f64> {
        let n = self.A.nrows();
        let mut matrix = DMatrix::zeros(n, n * self.B.ncols());

        let mut power = DMatrix::identity(n, n);
        for i in 0..n {
            let start_col = i * self.B.ncols();
            matrix.slice_mut((0, start_col), (n, self.B.ncols())).copy_from(&(&power * &self.B));
            power = &power * &self.A;
        }

        matrix
    }
}
```

### 7.3 çŠ¶æ€åé¦ˆæ§åˆ¶

```rust
/// çŠ¶æ€åé¦ˆæ§åˆ¶å™¨
pub struct StateFeedbackController {
    pub K: DMatrix<f64>,
}

impl StateFeedbackController {
    /// åˆ›å»ºçŠ¶æ€åé¦ˆæ§åˆ¶å™¨
    pub fn new(K: DMatrix<f64>) -> Self {
        Self { K }
    }

    /// æç‚¹é…ç½®
    pub fn pole_placement(system: &LinearSystem, desired_poles: &[f64]) -> Option<Self> {
        if !system.is_controllable() {
            return None;
        }

        let n = system.A.nrows();
        let desired_char_poly = Self::compute_characteristic_polynomial(desired_poles);

        // è½¬æ¢ä¸ºå¯æ§æ ‡å‡†å‹
        let (T, A_bar, B_bar) = Self::controllable_canonical_form(system);

        // è®¡ç®—åé¦ˆå¢ç›Š
        let mut K_bar = DVector::zeros(n);
        for i in 0..n {
            K_bar[i] = A_bar[(n-1, i)] - desired_char_poly[i];
        }

        let K = K_bar.transpose() * T.inverse();
        Some(Self::new(K))
    }

    /// è®¡ç®—ç‰¹å¾å¤šé¡¹å¼
    fn compute_characteristic_polynomial(poles: &[f64]) -> DVector<f64> {
        let n = poles.len();
        let mut poly = DVector::zeros(n);

        // ä½¿ç”¨Vietaå…¬å¼è®¡ç®—å¤šé¡¹å¼ç³»æ•°
        poly[0] = 1.0;
        for &pole in poles {
            let mut new_poly = DVector::zeros(n);
            for i in 0..n-1 {
                new_poly[i+1] = poly[i];
                new_poly[i] = poly[i] * (-pole);
            }
            poly = new_poly;
        }

        poly
    }

    /// è½¬æ¢ä¸ºå¯æ§æ ‡å‡†å‹
    fn controllable_canonical_form(system: &LinearSystem) -> (DMatrix<f64>, DMatrix<f64>, DMatrix<f64>) {
        let n = system.A.nrows();
        let controllability_matrix = system.controllability_matrix();

        // è®¡ç®—å˜æ¢çŸ©é˜µ
        let mut T = DMatrix::zeros(n, n);
        T.slice_mut((0, 0), (n, 1)).copy_from(&controllability_matrix.slice((0, 0), (n, 1)));

        for i in 1..n {
            T.slice_mut((0, i), (n, 1)).copy_from(&(&system.A * T.slice((0, i-1), (n, 1))));
        }

        let T_inv = T.inverse();
        let A_bar = &T_inv * &system.A * &T;
        let B_bar = &T_inv * &system.B;

        (T, A_bar, B_bar)
    }

    /// è®¡ç®—æ§åˆ¶è¾“å…¥
    pub fn compute_control(&self, x: &DVector<f64>, v: &DVector<f64>) -> DVector<f64> {
        -&self.K * x + v
    }
}
```

### 7.4 LQRæ§åˆ¶å™¨

```rust
/// çº¿æ€§äºŒæ¬¡å‹è°ƒèŠ‚å™¨
pub struct LQRController {
    pub K: DMatrix<f64>,
}

impl LQRController {
    /// è®¾è®¡LQRæ§åˆ¶å™¨
    pub fn design(system: &LinearSystem, Q: &DMatrix<f64>, R: &DMatrix<f64>) -> Option<Self> {
        if !system.is_controllable() {
            return None;
        }

        // æ±‚è§£ä»£æ•°é»å¡ææ–¹ç¨‹
        let P = Self::solve_algebraic_riccati_equation(system, Q, R)?;

        // è®¡ç®—æœ€ä¼˜åé¦ˆå¢ç›Š
        let R_inv = R.inverse();
        let K = &R_inv * &system.B.transpose() * &P;

        Some(Self::new(K))
    }

    /// æ±‚è§£ä»£æ•°é»å¡ææ–¹ç¨‹
    fn solve_algebraic_riccati_equation(
        system: &LinearSystem,
        Q: &DMatrix<f64>,
        R: &DMatrix<f64>
    ) -> Option<DMatrix<f64>> {
        let n = system.A.nrows();
        let mut P = DMatrix::identity(n, n);
        let R_inv = R.inverse();

        // ä½¿ç”¨è¿­ä»£æ–¹æ³•æ±‚è§£
        for _ in 0..100 {
            let P_new = &system.A.transpose() * &P + &P * &system.A
                - &P * &system.B * &R_inv * &system.B.transpose() * &P + Q;

            let diff = (&P_new - &P).norm();
            P = P_new;

            if diff < 1e-6 {
                return Some(P);
            }
        }

        None
    }

    /// è®¡ç®—æœ€ä¼˜æ§åˆ¶
    pub fn compute_control(&self, x: &DVector<f64>) -> DVector<f64> {
        -&self.K * x
    }
}
```

## 8. åº”ç”¨ç¤ºä¾‹

### 8.1 å€’ç«‹æ‘†ç³»ç»Ÿ

```rust
/// å€’ç«‹æ‘†ç³»ç»Ÿç¤ºä¾‹
pub fn inverted_pendulum_example() {
    // ç³»ç»Ÿå‚æ•°
    let M = 0.5; // å°è½¦è´¨é‡
    let m = 0.2; // æ‘†æ†è´¨é‡
    let b = 0.1; // æ‘©æ“¦ç³»æ•°
    let I = 0.006; // è½¬åŠ¨æƒ¯é‡
    let g = 9.8; // é‡åŠ›åŠ é€Ÿåº¦
    let l = 0.3; // æ‘†æ†é•¿åº¦

    // çŠ¶æ€ç©ºé—´æ¨¡å‹
    let p = I * (M + m) + M * m * l * l;

    let A = DMatrix::from_row_slice(4, 4, &[
        0.0, 1.0, 0.0, 0.0,
        0.0, -(I + m * l * l) * b / p, m * m * g * l * l / p, 0.0,
        0.0, 0.0, 0.0, 1.0,
        0.0, -m * l * b / p, m * g * l * (M + m) / p, 0.0
    ]);

    let B = DMatrix::from_column_slice(4, 1, &[
        0.0,
        (I + m * l * l) / p,
        0.0,
        m * l / p
    ]);

    let C = DMatrix::from_row_slice(2, 4, &[
        1.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0
    ]);

    let D = DMatrix::zeros(2, 1);

    let system = LinearSystem::new(A, B, C, D);

    // è®¾è®¡LQRæ§åˆ¶å™¨
    let Q = DMatrix::diagonal(4, &[1.0, 1.0, 10.0, 10.0]);
    let R = DMatrix::from_element(1, 1, 0.1);

    if let Some(lqr) = LQRController::design(&system, &Q, &R) {
        println!("LQRæ§åˆ¶å™¨è®¾è®¡æˆåŠŸ");

        // åˆå§‹çŠ¶æ€ï¼šå°è½¦ä½ç½®=0.1mï¼Œæ‘†æ†è§’åº¦=0.1rad
        let x0 = DVector::from_column_slice(&[0.1, 0.0, 0.1, 0.0]);

        // ä»¿çœŸ
        let dt = 0.01;
        let t_final = 10.0;
        let steps = (t_final / dt) as usize;

        let mut x = x0.clone();
        let mut t = 0.0;

        for _ in 0..steps {
            let u = lqr.compute_control(&x);
            let phi = system.state_transition_matrix(dt);
            let integral = system.compute_integral(&x, &u, dt);
            x = &phi * &x + &integral;
            t += dt;

            if t % 1.0 < dt {
                println!("t={:.1}s: ä½ç½®={:.3}m, è§’åº¦={:.3}rad",
                    t, x[0], x[2]);
            }
        }
    } else {
        println!("LQRæ§åˆ¶å™¨è®¾è®¡å¤±è´¥");
    }
}
```

### 8.2 é²æ£’æ§åˆ¶ç¤ºä¾‹

```rust
/// é²æ£’æ§åˆ¶ç¤ºä¾‹
pub fn robust_control_example() {
    // æ ‡ç§°ç³»ç»Ÿ
    let A = DMatrix::from_row_slice(2, 2, &[
        0.0, 1.0,
        -1.0, -0.1
    ]);

    let B = DMatrix::from_column_slice(2, 1, &[0.0, 1.0]);
    let C = DMatrix::from_row_slice(1, 2, &[1.0, 0.0]);
    let D = DMatrix::zeros(1, 1);

    let nominal_system = LinearSystem::new(A, B, C, D);

    // ä¸ç¡®å®šæ€§æ¨¡å‹
    let delta_A = DMatrix::from_row_slice(2, 2, &[
        0.0, 0.0,
        0.1, 0.05
    ]);

    let A_perturbed = &A + &delta_A;
    let perturbed_system = LinearSystem::new(A_perturbed, B, C, D);

    // è®¾è®¡é²æ£’æ§åˆ¶å™¨
    let Q = DMatrix::diagonal(2, &[1.0, 1.0]);
    let R = DMatrix::from_element(1, 1, 0.1);

    if let Some(robust_controller) = LQRController::design(&nominal_system, &Q, &R) {
        println!("é²æ£’æ§åˆ¶å™¨è®¾è®¡æˆåŠŸ");

        // æµ‹è¯•æ ‡ç§°ç³»ç»Ÿ
        let x0 = DVector::from_column_slice(&[1.0, 0.0]);
        let response_nominal = test_controller(&nominal_system, &robust_controller, &x0);

        // æµ‹è¯•æ‰°åŠ¨ç³»ç»Ÿ
        let response_perturbed = test_controller(&perturbed_system, &robust_controller, &x0);

        println!("æ ‡ç§°ç³»ç»Ÿæœ€ç»ˆçŠ¶æ€: [{:.3}, {:.3}]",
            response_nominal.last().unwrap()[0],
            response_nominal.last().unwrap()[1]);
        println!("æ‰°åŠ¨ç³»ç»Ÿæœ€ç»ˆçŠ¶æ€: [{:.3}, {:.3}]",
            response_perturbed.last().unwrap()[0],
            response_perturbed.last().unwrap()[1]);
    }
}

fn test_controller(
    system: &LinearSystem,
    controller: &LQRController,
    x0: &DVector<f64>
) -> Vec<DVector<f64>> {
    let dt = 0.01;
    let t_final = 5.0;
    let steps = (t_final / dt) as usize;

    let mut x = x0.clone();
    let mut response = vec![x.clone()];

    for _ in 0..steps {
        let u = controller.compute_control(&x);
        let phi = system.state_transition_matrix(dt);
        let integral = system.compute_integral(&x, &u, dt);
        x = &phi * &x + &integral;
        response.push(x.clone());
    }

    response
}
```

## 9. ç›¸å…³ç†è®º

### 9.1 ä¸ç»å…¸æ§åˆ¶ç†è®ºçš„å…³ç³»

ç°ä»£æ§åˆ¶ç†è®ºæ˜¯ç»å…¸æ§åˆ¶ç†è®ºçš„å‘å±•ï¼Œä¸»è¦åŒºåˆ«åœ¨äºï¼š

1. **å»ºæ¨¡æ–¹æ³•**ï¼šç»å…¸æ§åˆ¶ç†è®ºä½¿ç”¨ä¼ é€’å‡½æ•°ï¼Œç°ä»£æ§åˆ¶ç†è®ºä½¿ç”¨çŠ¶æ€ç©ºé—´
2. **ç³»ç»Ÿæè¿°**ï¼šç»å…¸æ§åˆ¶ç†è®ºå…³æ³¨è¾“å…¥è¾“å‡ºå…³ç³»ï¼Œç°ä»£æ§åˆ¶ç†è®ºå…³æ³¨å†…éƒ¨çŠ¶æ€
3. **è®¾è®¡æ–¹æ³•**ï¼šç»å…¸æ§åˆ¶ç†è®ºä½¿ç”¨é¢‘åŸŸæ–¹æ³•ï¼Œç°ä»£æ§åˆ¶ç†è®ºä½¿ç”¨æ—¶åŸŸæ–¹æ³•

### 9.2 ä¸éçº¿æ€§æ§åˆ¶ç†è®ºçš„å…³ç³»

ç°ä»£æ§åˆ¶ç†è®ºä¸ºéçº¿æ€§æ§åˆ¶ç†è®ºæä¾›äº†åŸºç¡€ï¼š

1. **çº¿æ€§åŒ–æ–¹æ³•**ï¼šåœ¨å¹³è¡¡ç‚¹é™„è¿‘çº¿æ€§åŒ–éçº¿æ€§ç³»ç»Ÿ
2. **å±€éƒ¨ç¨³å®šæ€§**ï¼šåˆ©ç”¨çº¿æ€§åŒ–ç³»ç»Ÿåˆ†æå±€éƒ¨ç¨³å®šæ€§
3. **æ§åˆ¶å™¨è®¾è®¡**ï¼šåŸºäºçº¿æ€§åŒ–ç³»ç»Ÿè®¾è®¡æ§åˆ¶å™¨

### 9.3 ä¸è‡ªé€‚åº”æ§åˆ¶ç†è®ºçš„å…³ç³»

ç°ä»£æ§åˆ¶ç†è®ºä¸ºè‡ªé€‚åº”æ§åˆ¶æä¾›äº†æ¡†æ¶ï¼š

1. **å‚æ•°ä¼°è®¡**ï¼šåœ¨çº¿ä¼°è®¡ç³»ç»Ÿå‚æ•°
2. **æ§åˆ¶å™¨è°ƒæ•´**ï¼šæ ¹æ®å‚æ•°ä¼°è®¡è°ƒæ•´æ§åˆ¶å™¨
3. **ç¨³å®šæ€§åˆ†æ**ï¼šåˆ†æè‡ªé€‚åº”ç³»ç»Ÿçš„ç¨³å®šæ€§

## 10. å‚è€ƒæ–‡çŒ®

1. Ogata, K. (2010). Modern Control Engineering. Pearson.
2. Astrom, K. J., & Murray, R. M. (2008). Feedback Systems: An Introduction for Scientists and Engineers. Princeton University Press.
3. Lewis, F. L., Vrabie, D., & Syrmos, V. L. (2012). Optimal Control. John Wiley & Sons.
4. Zhou, K., & Doyle, J. C. (1998). Essentials of Robust Control. Prentice Hall.
5. Anderson, B. D., & Moore, J. B. (1990). Optimal Control: Linear Quadratic Methods. Prentice Hall.
6. Kwakernaak, H., & Sivan, R. (1972). Linear Optimal Control Systems. Wiley-Interscience.
7. Skogestad, S., & Postlethwaite, I. (2005). Multivariable Feedback Control: Analysis and Design. John Wiley & Sons.
8. Hespanha, J. P. (2009). Linear Systems Theory. Princeton University Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [05.1.1 åŸºç¡€æ§åˆ¶ç†è®º](../05_Control_Theory/05.1.1_åŸºç¡€æ§åˆ¶ç†è®º.md)
- [05.2.2 æœ€ä¼˜æ§åˆ¶ç†è®º](05.2.2_æœ€ä¼˜æ§åˆ¶ç†è®º.md)
- [05.2.3 é²æ£’æ§åˆ¶ç†è®º](05.2.3_é²æ£’æ§åˆ¶ç†è®º.md)
- [05.3.1 éçº¿æ€§æ§åˆ¶ç†è®º](05.3.1_éçº¿æ€§æ§åˆ¶ç†è®º.md)


## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
