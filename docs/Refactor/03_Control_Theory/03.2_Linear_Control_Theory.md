# 03.2 线性控制理论

## 目录

1. [理论基础](#1-理论基础)
2. [线性系统建模](#2-线性系统建模)
3. [状态空间表示](#3-状态空间表示)
4. [传递函数](#4-传递函数)
5. [稳定性分析](#5-稳定性分析)
6. [可控性与可观性](#6-可控性与可观性)
7. [极点配置](#7-极点配置)
8. [线性二次型调节器](#8-线性二次型调节器)
9. [观测器设计](#9-观测器设计)
10. [鲁棒控制](#10-鲁棒控制)
11. [实际应用](#11-实际应用)
12. [代码实现](#12-代码实现)
13. [参考文献](#13-参考文献)

## 1. 理论基础

### 1.1 线性系统定义

**定义 1.1** (线性系统)
一个系统称为线性系统，如果它满足叠加原理：

- 齐次性：$f(αx) = αf(x)$
- 可加性：$f(x_1 + x_2) = f(x_1) + f(x_2)$

对于连续时间线性系统，其状态方程表示为：
$$\dot{x}(t) = A(t)x(t) + B(t)u(t)$$
$$y(t) = C(t)x(t) + D(t)u(t)$$

其中：

- $x(t) \in \mathbb{R}^n$ 是状态向量
- $u(t) \in \mathbb{R}^m$ 是输入向量
- $y(t) \in \mathbb{R}^p$ 是输出向量
- $A(t), B(t), C(t), D(t)$ 是时变矩阵

### 1.2 时不变线性系统

对于时不变线性系统，矩阵为常数：
$$\dot{x}(t) = Ax(t) + Bu(t)$$
$$y(t) = Cx(t) + Du(t)$$

**定理 1.1** (线性系统解的存在唯一性)
对于给定的初始条件 $x(0) = x_0$ 和输入 $u(t)$，线性系统的解存在且唯一。

**证明**：
状态方程的解为：
$$x(t) = e^{At}x_0 + \int_0^t e^{A(t-\tau)}Bu(\tau)d\tau$$

其中 $e^{At}$ 是矩阵指数函数。

## 2. 线性系统建模

### 2.1 物理系统建模

**示例 2.1** (弹簧-质量-阻尼系统)
考虑一个弹簧-质量-阻尼系统：
$$m\ddot{y} + c\dot{y} + ky = u(t)$$

定义状态变量：
$$x_1 = y, \quad x_2 = \dot{y}$$

得到状态空间表示：
$$\begin{bmatrix} \dot{x}_1 \\ \dot{x}_2 \end{bmatrix} =
\begin{bmatrix} 0 & 1 \\ -\frac{k}{m} & -\frac{c}{m} \end{bmatrix}
\begin{bmatrix} x_1 \\ x_2 \end{bmatrix} +
\begin{bmatrix} 0 \\ \frac{1}{m} \end{bmatrix} u$$

### 2.2 电路系统建模

**示例 2.2** (RLC电路)
考虑RLC串联电路：
$$L\frac{di}{dt} + Ri + \frac{1}{C}\int i dt = v(t)$$

定义状态变量：
$$x_1 = i, \quad x_2 = \frac{1}{C}\int i dt$$

得到状态空间表示：
$$\begin{bmatrix} \dot{x}_1 \\ \dot{x}_2 \end{bmatrix} =
\begin{bmatrix} -\frac{R}{L} & -\frac{1}{L} \\ \frac{1}{C} & 0 \end{bmatrix}
\begin{bmatrix} x_1 \\ x_2 \end{bmatrix} +
\begin{bmatrix} \frac{1}{L} \\ 0 \end{bmatrix} v$$

## 3. 状态空间表示

### 3.1 标准形式

线性系统的标准状态空间表示为：
$$\dot{x} = Ax + Bu$$
$$y = Cx + Du$$

其中：
- $A \in \mathbb{R}^{n \times n}$ 是系统矩阵
- $B \in \mathbb{R}^{n \times m}$ 是输入矩阵
- $C \in \mathbb{R}^{p \times n}$ 是输出矩阵
- $D \in \mathbb{R}^{p \times m}$ 是直接传递矩阵

### 3.2 状态变换

**定义 3.1** (相似变换)
对于非奇异矩阵 $T$，定义新的状态变量：
$$\bar{x} = T^{-1}x$$

变换后的系统为：
$$\dot{\bar{x}} = \bar{A}\bar{x} + \bar{B}u$$
$$y = \bar{C}\bar{x} + \bar{D}u$$

其中：
$$\bar{A} = T^{-1}AT, \quad \bar{B} = T^{-1}B, \quad \bar{C} = CT, \quad \bar{D} = D$$

### 3.3 对角化

**定理 3.1** (对角化条件)
如果矩阵 $A$ 有 $n$ 个线性无关的特征向量，则存在相似变换使 $A$ 对角化。

**证明**：
设 $A$ 的特征值为 $\lambda_1, \lambda_2, \ldots, \lambda_n$，对应的特征向量为 $v_1, v_2, \ldots, v_n$。
定义变换矩阵 $T = [v_1, v_2, \ldots, v_n]$，则：
$$\bar{A} = T^{-1}AT = \text{diag}(\lambda_1, \lambda_2, \ldots, \lambda_n)$$

## 4. 传递函数

### 4.1 定义

**定义 4.1** (传递函数)
对于零初始条件，传递函数定义为：
$$G(s) = \frac{Y(s)}{U(s)} = C(sI - A)^{-1}B + D$$

### 4.2 极点与零点

**定义 4.2** (极点)
传递函数的极点是方程 $\det(sI - A) = 0$ 的根。

**定义 4.3** (零点)
传递函数的零点是方程 $\det\begin{bmatrix} sI-A & -B \\ C & D \end{bmatrix} = 0$ 的根。

### 4.3 最小实现

**定义 4.4** (最小实现)
传递函数的最小实现是状态空间表示中状态变量个数最少的实现。

**定理 4.1** (最小实现条件)
状态空间表示是最小实现的充要条件是系统完全可控且完全可观。

## 5. 稳定性分析

### 5.1 李雅普诺夫稳定性

**定义 5.1** (李雅普诺夫稳定性)
平衡点 $x_e = 0$ 是李雅普诺夫稳定的，如果对于任意 $\epsilon > 0$，存在 $\delta > 0$，使得：
$$\|x(0)\| < \delta \Rightarrow \|x(t)\| < \epsilon, \quad \forall t \geq 0$$

**定理 5.1** (线性系统稳定性)
线性系统 $\dot{x} = Ax$ 的李雅普诺夫稳定的充要条件是 $A$ 的所有特征值都有非正实部。

### 5.2 渐近稳定性

**定义 5.2** (渐近稳定性)
平衡点 $x_e = 0$ 是渐近稳定的，如果它是李雅普诺夫稳定的，且：
$$\lim_{t \to \infty} x(t) = 0$$

**定理 5.2** (线性系统渐近稳定性)
线性系统 $\dot{x} = Ax$ 渐近稳定的充要条件是 $A$ 的所有特征值都有负实部。

### 5.3 李雅普诺夫方程

**定理 5.3** (李雅普诺夫方程)
对于渐近稳定的矩阵 $A$，李雅普诺夫方程：
$$A^TP + PA = -Q$$

有唯一正定解 $P$，其中 $Q$ 是任意正定矩阵。

## 6. 可控性与可观性

### 6.1 可控性

**定义 6.1** (可控性)
系统 $(A, B)$ 完全可控，如果对于任意初始状态 $x_0$ 和任意目标状态 $x_f$，存在有限时间 $T$ 和输入 $u(t)$，使得 $x(T) = x_f$。

**定理 6.1** (可控性判据)
系统 $(A, B)$ 完全可控的充要条件是可控性矩阵：
$$\mathcal{C} = [B, AB, A^2B, \ldots, A^{n-1}B]$$
满秩，即 $\text{rank}(\mathcal{C}) = n$。

### 6.2 可观性

**定义 6.2** (可观性)
系统 $(A, C)$ 完全可观，如果对于任意初始状态 $x_0$，可以通过有限时间的输出测量确定 $x_0$。

**定理 6.2** (可观性判据)
系统 $(A, C)$ 完全可控的充要条件是可观性矩阵：
$$\mathcal{O} = \begin{bmatrix} C \\ CA \\ CA^2 \\ \vdots \\ CA^{n-1} \end{bmatrix}$$
满秩，即 $\text{rank}(\mathcal{O}) = n$。

### 6.3 标准分解

**定理 6.3** (卡尔曼分解)
任何线性系统都可以通过相似变换分解为四个子系统：
1. 可控且可观
2. 可控但不可观
3. 不可控但可观
4. 不可控且不可观

## 7. 极点配置

### 7.1 状态反馈

**定义 7.1** (状态反馈)
状态反馈控制律为：
$$u = -Kx + r$$

其中 $K$ 是反馈增益矩阵，$r$ 是参考输入。

闭环系统为：
$$\dot{x} = (A - BK)x + Br$$

### 7.2 极点配置定理

**定理 7.1** (极点配置)
对于完全可控的系统 $(A, B)$，可以通过状态反馈任意配置闭环极点的充要条件是系统完全可控。

**证明**：
设期望的闭环特征多项式为：
$$\alpha_c(s) = s^n + a_1s^{n-1} + \cdots + a_n$$

通过阿克曼公式计算反馈增益：
$$K = [0, 0, \ldots, 1]\mathcal{C}^{-1}\alpha_c(A)$$

### 7.3 阿克曼公式

**定理 7.2** (阿克曼公式)
对于单输入系统，反馈增益为：
$$K = [0, 0, \ldots, 1][B, AB, \ldots, A^{n-1}B]^{-1}\alpha_c(A)$$

其中 $\alpha_c(A)$ 是期望特征多项式在 $A$ 处的值。

## 8. 线性二次型调节器

### 8.1 性能指标

**定义 8.1** (LQR性能指标)
线性二次型调节器的性能指标为：
$$J = \int_0^{\infty} (x^TQx + u^TRu)dt$$

其中 $Q \geq 0$ 和 $R > 0$ 是权重矩阵。

### 8.2 最优控制律

**定理 8.1** (LQR最优控制)
最优控制律为：
$$u^* = -R^{-1}B^TPx$$

其中 $P$ 是代数黎卡提方程的解：
$$A^TP + PA - PBR^{-1}B^TP + Q = 0$$

### 8.3 闭环稳定性

**定理 8.2** (LQR稳定性)
如果 $(A, B)$ 可控且 $(A, Q^{1/2})$ 可观，则LQR闭环系统渐近稳定。

## 9. 观测器设计

### 9.1 全维观测器

**定义 9.1** (全维观测器)
全维观测器的状态方程为：
$$\dot{\hat{x}} = A\hat{x} + Bu + L(y - C\hat{x})$$

其中 $L$ 是观测器增益矩阵。

观测误差动态为：
$$\dot{e} = (A - LC)e$$

### 9.2 观测器极点配置

**定理 9.1** (观测器极点配置)
对于完全可观的系统 $(A, C)$，可以通过选择观测器增益 $L$ 任意配置观测器极点。

**证明**：
观测器极点配置等价于 $(A^T, C^T)$ 的极点配置问题。

### 9.3 分离原理

**定理 9.3** (分离原理)
对于完全可控且完全可观的系统，状态反馈和观测器可以独立设计，组合后的闭环系统极点等于状态反馈极点和观测器极点的并集。

## 10. 鲁棒控制

### 10.1 不确定性建模

**定义 10.1** (参数不确定性)
系统矩阵的不确定性表示为：
$$A = A_0 + \Delta A$$

其中 $\Delta A$ 是未知但有界的扰动。

### 10.2 H∞控制

**定义 10.2** (H∞性能)
H∞控制的目标是最小化从干扰到输出的传递函数的H∞范数：
$$\|T_{zw}\|_{\infty} < \gamma$$

### 10.3 线性矩阵不等式

**定理 10.1** (LMI稳定性条件)
系统渐近稳定的充要条件是存在正定矩阵 $P$ 满足：
$$A^TP + PA < 0$$

## 11. 实际应用

### 11.1 飞行器控制

**应用 11.1** (飞机姿态控制)
考虑飞机俯仰角控制：
$$\ddot{\theta} + a_1\dot{\theta} + a_0\theta = b_0\delta$$

其中 $\theta$ 是俯仰角，$\delta$ 是升降舵偏角。

### 11.2 机器人控制

**应用 11.2** (机械臂控制)
考虑单关节机械臂：
$$J\ddot{q} + b\dot{q} + mgl\sin(q) = \tau$$

线性化后得到：
$$\Delta\ddot{q} + \frac{b}{J}\Delta\dot{q} + \frac{mgl\cos(q_0)}{J}\Delta q = \frac{1}{J}\Delta\tau$$

## 12. 代码实现

### 12.1 Rust实现

```rust
use nalgebra::{DMatrix, DVector, Matrix4, Vector4};
use std::f64::consts::PI;

// 线性系统结构
# [derive(Debug, Clone)]
pub struct LinearSystem {
    pub A: DMatrix<f64>,
    pub B: DMatrix<f64>,
    pub C: DMatrix<f64>,
    pub D: DMatrix<f64>,
}

impl LinearSystem {
    pub fn new(A: DMatrix<f64>, B: DMatrix<f64>, C: DMatrix<f64>, D: DMatrix<f64>) -> Self {
        LinearSystem { A, B, C, D }
    }

    // 系统响应
    pub fn response(&self, x0: &DVector<f64>, u: &DVector<f64>, dt: f64, steps: usize) -> Vec<DVector<f64>> {
        let mut x = x0.clone();
        let mut trajectory = Vec::new();

        for _ in 0..steps {
            trajectory.push(x.clone());
            x = x + dt * (self.A.clone() * x.clone() + self.B.clone() * u.clone());
        }

        trajectory
    }

    // 可控性检查
    pub fn is_controllable(&self) -> bool {
        let n = self.A.nrows();
        let mut C = DMatrix::zeros(n, n * self.B.ncols());

        let mut Ak = DMatrix::identity(n, n);
        for i in 0..n {
            C.slice_mut((0, i * self.B.ncols()), (n, self.B.ncols())).copy_from(&(Ak.clone() * self.B.clone()));
            Ak = Ak * self.A.clone();
        }

        C.rank() == n
    }

    // 可观性检查
    pub fn is_observable(&self) -> bool {
        let n = self.A.nrows();
        let mut O = DMatrix::zeros(n * self.C.nrows(), n);

        let mut Ak = DMatrix::identity(n, n);
        for i in 0..n {
            O.slice_mut((i * self.C.nrows(), 0), (self.C.nrows(), n)).copy_from(&(self.C.clone() * Ak.clone()));
            Ak = Ak * self.A.clone();
        }

        O.rank() == n
    }

    // 极点配置
    pub fn pole_placement(&self, desired_poles: &[f64]) -> Option<DMatrix<f64>> {
        if !self.is_controllable() {
            return None;
        }

        let n = self.A.nrows();
        let mut K = DMatrix::zeros(self.B.ncols(), n);

        // 阿克曼公式实现
        let mut controllability = DMatrix::zeros(n, n);
        let mut Ak = DMatrix::identity(n, n);

        for i in 0..n {
            controllability.slice_mut((0, i), (n, 1)).copy_from(&(Ak.clone() * self.B.clone()));
            Ak = Ak * self.A.clone();
        }

        // 计算期望特征多项式
        let mut alpha_c = DMatrix::zeros(n, n);
        for &pole in desired_poles {
            alpha_c = alpha_c + (self.A.clone() - pole * DMatrix::identity(n, n));
        }

        let mut last_row = DVector::zeros(n);
        last_row[n-1] = 1.0;

        K = last_row.transpose() * controllability.try_inverse()? * alpha_c;

        Some(K)
    }

    // LQR控制器
    pub fn lqr(&self, Q: &DMatrix<f64>, R: &DMatrix<f64>) -> Option<DMatrix<f64>> {
        // 简化的LQR实现
        let n = self.A.nrows();
        let m = self.B.ncols();

        // 使用极点配置作为LQR的近似
        let poles = vec![-1.0, -2.0, -3.0, -4.0];
        self.pole_placement(&poles[..n.min(poles.len())])
    }
}

// 观测器实现
# [derive(Debug, Clone)]
pub struct Observer {
    pub A: DMatrix<f64>,
    pub B: DMatrix<f64>,
    pub C: DMatrix<f64>,
    pub L: DMatrix<f64>,
    pub x_hat: DVector<f64>,
}

impl Observer {
    pub fn new(system: &LinearSystem, observer_poles: &[f64]) -> Option<Self> {
        if !system.is_observable() {
            return None;
        }

        let n = system.A.nrows();
        let mut L = DMatrix::zeros(n, system.C.nrows());

        // 观测器增益计算（对偶问题）
        let mut observability = DMatrix::zeros(n * system.C.nrows(), n);
        let mut Ak = DMatrix::identity(n, n);

        for i in 0..n {
            observability.slice_mut((i * system.C.nrows(), 0), (system.C.nrows(), n))
                .copy_from(&(system.C.clone() * Ak.clone()));
            Ak = Ak * system.A.clone();
        }

        // 简化的观测器增益计算
        L = DMatrix::identity(n, system.C.nrows()) * 2.0;

        Some(Observer {
            A: system.A.clone(),
            B: system.B.clone(),
            C: system.C.clone(),
            L,
            x_hat: DVector::zeros(n),
        })
    }

    pub fn update(&mut self, u: &DVector<f64>, y: &DVector<f64>, dt: f64) {
        let y_hat = self.C.clone() * self.x_hat.clone();
        let error = y - y_hat;

        self.x_hat = self.x_hat.clone() + dt * (
            self.A.clone() * self.x_hat.clone() +
            self.B.clone() * u.clone() +
            self.L.clone() * error
        );
    }
}

// 示例：弹簧-质量-阻尼系统
pub fn spring_mass_damper_system() -> LinearSystem {
    let m = 1.0; // 质量
    let c = 2.0; // 阻尼系数
    let k = 5.0; // 弹簧常数

    let A = DMatrix::from_row_slice(2, 2, &[
        0.0, 1.0,
        -k/m, -c/m
    ]);

    let B = DMatrix::from_row_slice(2, 1, &[
        0.0,
        1.0/m
    ]);

    let C = DMatrix::from_row_slice(1, 2, &[
        1.0, 0.0
    ]);

    let D = DMatrix::zeros(1, 1);

    LinearSystem::new(A, B, C, D)
}

// 示例：RLC电路
pub fn rlc_circuit_system() -> LinearSystem {
    let R = 1.0; // 电阻
    let L = 1.0; // 电感
    let C = 1.0; // 电容

    let A = DMatrix::from_row_slice(2, 2, &[
        -R/L, -1.0/L,
        1.0/C, 0.0
    ]);

    let B = DMatrix::from_row_slice(2, 1, &[
        1.0/L,
        0.0
    ]);

    let C = DMatrix::from_row_slice(1, 2, &[
        1.0, 0.0
    ]);

    let D = DMatrix::zeros(1, 1);

    LinearSystem::new(A, B, C, D)
}

# [cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_controllability() {
        let system = spring_mass_damper_system();
        assert!(system.is_controllable());
    }

    #[test]
    fn test_observability() {
        let system = spring_mass_damper_system();
        assert!(system.is_observable());
    }

    #[test]
    fn test_pole_placement() {
        let system = spring_mass_damper_system();
        let desired_poles = vec![-2.0, -3.0];
        let K = system.pole_placement(&desired_poles);
        assert!(K.is_some());
    }

    #[test]
    fn test_observer() {
        let system = spring_mass_damper_system();
        let observer_poles = vec![-5.0, -6.0];
        let observer = Observer::new(&system, &observer_poles);
        assert!(observer.is_some());
    }
}
```

### 12.2 Haskell实现

```haskell
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE TypeFamilies #-}

module LinearControlTheory where

import Numeric.LinearAlgebra
import Numeric.LinearAlgebra.Data
import Control.Monad
import Data.Maybe

-- 线性系统数据类型
data LinearSystem = LinearSystem
    { matrixA :: Matrix Double
    , matrixB :: Matrix Double
    , matrixC :: Matrix Double
    , matrixD :: Matrix Double
    } deriving (Show, Eq)

-- 创建线性系统
createLinearSystem :: Matrix Double -> Matrix Double -> Matrix Double -> Matrix Double -> LinearSystem
createLinearSystem a b c d = LinearSystem a b c d

-- 系统维度
systemOrder :: LinearSystem -> Int
systemOrder = rows . matrixA

inputDimension :: LinearSystem -> Int
inputDimension = cols . matrixB

outputDimension :: LinearSystem -> Int
outputDimension = rows . matrixC

-- 可控性矩阵
controllabilityMatrix :: LinearSystem -> Matrix Double
controllabilityMatrix sys = fromColumns $ concatMap (\i -> [matrixA sys ^ i `multiply` matrixB sys]) [0..n-1]
  where n = systemOrder sys

-- 可观性矩阵
observabilityMatrix :: LinearSystem -> Matrix Double
observabilityMatrix sys = fromRows $ concatMap (\i -> [matrixC sys `multiply` (matrixA sys ^ i)]) [0..n-1]
  where n = systemOrder sys

-- 可控性检查
isControllable :: LinearSystem -> Bool
isControllable sys = rank (controllabilityMatrix sys) == systemOrder sys

-- 可观性检查
isObservable :: LinearSystem -> Bool
isObservable sys = rank (observabilityMatrix sys) == systemOrder sys

-- 特征值计算
eigenvalues :: LinearSystem -> [Complex Double]
eigenvalues sys = toList $ eigVal $ matrixA sys

-- 稳定性检查
isStable :: LinearSystem -> Bool
isStable sys = all (\λ -> realPart λ < 0) (eigenvalues sys)

-- 极点配置（阿克曼公式）
polePlacement :: LinearSystem -> [Double] -> Maybe (Matrix Double)
polePlacement sys desiredPoles
    | not (isControllable sys) = Nothing
    | otherwise = Just K
  where
    n = systemOrder sys
    m = inputDimension sys

    -- 可控性矩阵
    C = controllabilityMatrix sys

    -- 期望特征多项式
    desiredPoly = product $ map (\λ -> matrixA sys - λ `scale` ident n) desiredPoles

    -- 阿克曼公式
    lastRow = (0><n) $ replicate (n-1) 0 ++ [1]
    K = lastRow `multiply` inv C `multiply` desiredPoly

-- LQR控制器（简化实现）
lqrController :: LinearSystem -> Matrix Double -> Matrix Double -> Maybe (Matrix Double)
lqrController sys Q R
    | not (isControllable sys) = Nothing
    | not (isObservable sys) = Nothing
    | otherwise = polePlacement sys defaultPoles
  where
    n = systemOrder sys
    defaultPoles = take n [-1, -2, -3, -4, -5, -6, -7, -8]

-- 观测器设计
observerGain :: LinearSystem -> [Double] -> Maybe (Matrix Double)
observerGain sys observerPoles
    | not (isObservable sys) = Nothing
    | otherwise = Just L
  where
    n = systemOrder sys
    p = outputDimension sys

    -- 对偶系统
    dualA = tr $ matrixA sys
    dualB = tr $ matrixC sys
    dualC = tr $ matrixB sys

    dualSys = LinearSystem dualA dualB dualC (0><p) 0

    -- 对偶系统的极点配置
    dualK = polePlacement dualSys observerPoles

    L = case dualK of
        Just k -> tr k
        Nothing -> (0><n) 0

-- 系统响应模拟
simulateSystem :: LinearSystem -> Vector Double -> Vector Double -> Double -> Int -> [Vector Double]
simulateSystem sys x0 u dt steps = take steps $ iterate step x0
  where
    step x = x + scale dt (matrixA sys `multiply` x + matrixB sys `multiply` u)

-- 观测器实现
data Observer = Observer
    { observerSystem :: LinearSystem
    , observerGain :: Matrix Double
    , observerState :: Vector Double
    } deriving (Show)

createObserver :: LinearSystem -> [Double] -> Maybe Observer
createObserver sys poles = do
    L <- observerGain sys poles
    let n = systemOrder sys
    return $ Observer sys L (0 `constant` n)

updateObserver :: Observer -> Vector Double -> Vector Double -> Double -> Observer
updateObserver obs u y dt = obs { observerState = newState }
  where
    yHat = matrixC (observerSystem obs) `multiply` observerState obs
    error = y - yHat
    newState = observerState obs + scale dt (
        matrixA (observerSystem obs) `multiply` observerState obs +
        matrixB (observerSystem obs) `multiply` u +
        observerGain obs `multiply` error
    )

-- 示例系统：弹簧-质量-阻尼系统
springMassDamperSystem :: Double -> Double -> Double -> LinearSystem
springMassDamperSystem m c k = LinearSystem a b c d
  where
    a = (2><2) [0, 1, -k/m, -c/m]
    b = (2><1) [0, 1/m]
    c = (1><2) [1, 0]
    d = (1><1) [0]

-- 示例系统：RLC电路
rlcCircuitSystem :: Double -> Double -> Double -> LinearSystem
rlcCircuitSystem R L C = LinearSystem a b c d
  where
    a = (2><2) [-R/L, -1/L, 1/C, 0]
    b = (2><1) [1/L, 0]
    c = (1><2) [1, 0]
    d = (1><1) [0]

-- 李雅普诺夫稳定性分析
lyapunovStability :: LinearSystem -> Bool
lyapunovStability sys = isJust solution
  where
    n = systemOrder sys
    A = matrixA sys
    Q = ident n  -- 单位矩阵作为权重

    -- 简化的李雅普诺夫方程求解
    -- 实际应用中需要使用专门的求解器
    solution = Just $ ident n  -- 简化实现

-- 传递函数计算
transferFunction :: LinearSystem -> Double -> Complex Double
transferFunction sys s = C `multiply` inv (s `scale` ident n - A) `multiply` B + D
  where
    A = matrixA sys
    B = matrixB sys
    C = matrixC sys
    D = matrixD sys
    n = systemOrder sys

-- 频率响应
frequencyResponse :: LinearSystem -> [Double] -> [Complex Double]
frequencyResponse sys frequencies = map (transferFunction sys . (0:+)) frequencies

-- 鲁棒性分析
robustnessAnalysis :: LinearSystem -> Matrix Double -> Double
robustnessAnalysis sys uncertainty = maximum $ map magnitude $ eigenvalues perturbedSys
  where
    A = matrixA sys
    perturbedA = A + uncertainty
    perturbedSys = sys { matrixA = perturbedA }

-- 测试函数
testLinearControl :: IO ()
testLinearControl = do
    putStrLn "=== 线性控制理论测试 ==="

    -- 创建弹簧-质量-阻尼系统
    let sys = springMassDamperSystem 1.0 2.0 5.0
    putStrLn $ "系统维度: " ++ show (systemOrder sys)
    putStrLn $ "可控性: " ++ show (isControllable sys)
    putStrLn $ "可观性: " ++ show (isObservable sys)
    putStrLn $ "稳定性: " ++ show (isStable sys)

    -- 极点配置测试
    let desiredPoles = [-2.0, -3.0]
    case polePlacement sys desiredPoles of
        Just K -> putStrLn $ "极点配置成功，反馈增益: " ++ show K
        Nothing -> putStrLn "极点配置失败"

    -- 观测器测试
    let observerPoles = [-5.0, -6.0]
    case createObserver sys observerPoles of
        Just obs -> putStrLn $ "观测器创建成功: " ++ show obs
        Nothing -> putStrLn "观测器创建失败"

    -- 系统响应模拟
    let x0 = vector [1.0, 0.0]
    let u = vector [0.0]
    let response = simulateSystem sys x0 u 0.01 100
    putStrLn $ "系统响应模拟完成，步数: " ++ show (length response)

-- 主函数
main :: IO ()
main = testLinearControl
```

## 13. 参考文献

1. Ogata, K. (2010). *Modern Control Engineering*. Prentice Hall.
2. Franklin, G. F., Powell, J. D., & Emami-Naeini, A. (2015). *Feedback Control of Dynamic Systems*. Pearson.
3. Chen, C. T. (1999). *Linear System Theory and Design*. Oxford University Press.
4. Kailath, T. (1980). *Linear Systems*. Prentice Hall.
5. Antsaklis, P. J., & Michel, A. N. (2006). *Linear Systems*. Birkhäuser.
6. Hespanha, J. P. (2009). *Linear Systems Theory*. Princeton University Press.
7. Sontag, E. D. (1998). *Mathematical Control Theory: Deterministic Finite Dimensional Systems*. Springer.
8. Zhou, K., & Doyle, J. C. (1998). *Essentials of Robust Control*. Prentice Hall.

---

**相关文档链接**：
- [03.1 控制论基础](../03.1_Control_Theory_Foundation.md)
- [03.3 非线性控制理论](../03.3_Nonlinear_Control_Theory.md)
- [03.4 最优控制理论](../03.4_Optimal_Control_Theory.md)
- [01.1 类型理论基础](../../01_Type_Theory/01.1_Type_Theory_Foundation.md)
- [02.1 形式语言基础](../../02_Formal_Language/02.1_Formal_Language_Foundation.md)
