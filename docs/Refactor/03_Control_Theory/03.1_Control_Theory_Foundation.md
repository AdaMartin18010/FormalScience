# 03.1 控制论基础

## 目录

```markdown
03.1 控制论基础
├── 1. 引言
│   ├── 1.1 控制论概述
│   ├── 1.2 历史发展
│   ├── 1.3 基本概念
│   └── 1.4 应用领域
├── 2. 数学基础
│   ├── 2.1 系统建模
│   ├── 2.2 状态空间
│   ├── 2.3 传递函数
│   └── 2.4 稳定性分析
├── 3. 核心理论
│   ├── 3.1 反馈控制
│   ├── 3.2 状态反馈
│   ├── 3.3 观测器设计
│   └── 3.4 最优控制
├── 4. 实现示例
│   ├── 4.1 Rust实现
│   ├── 4.2 数值计算
│   └── 4.3 仿真验证
└── 5. 参考文献
```

## 1. 引言

### 1.1 控制论概述

控制论是研究动态系统行为控制和调节的科学，它提供了一套完整的理论框架来分析和设计控制系统。

**定义 1.1.1** (控制系统)
控制系统是由被控对象、控制器、传感器和执行器组成的动态系统，目的是使系统输出达到期望值。

### 1.2 历史发展

控制论的发展历程：
1. **经典控制理论** (1940s-1960s)
2. **现代控制理论** (1960s-1980s)
3. **鲁棒控制理论** (1980s-2000s)
4. **智能控制理论** (2000s-至今)

### 1.3 基本概念

**定义 1.3.1** (系统状态)
系统状态是描述系统在某一时刻完整信息的变量集合。

**定义 1.3.2** (控制输入)
控制输入是影响系统行为的可调节变量。

**定义 1.3.3** (系统输出)
系统输出是系统对外部环境的响应。

## 2. 数学基础

### 2.1 系统建模

**定义 2.1.1** (线性时不变系统)
线性时不变系统的状态方程：
$$\dot{x}(t) = Ax(t) + Bu(t)$$
$$y(t) = Cx(t) + Du(t)$$

其中：
- $x(t) \in \mathbb{R}^n$ 是状态向量
- $u(t) \in \mathbb{R}^m$ 是控制输入
- $y(t) \in \mathbb{R}^p$ 是系统输出
- $A, B, C, D$ 是系统矩阵

### 2.2 状态空间

**定义 2.2.1** (状态空间)
状态空间是系统所有可能状态的集合，通常表示为 $\mathbb{R}^n$。

**定理 2.2.1** (状态转移)
系统状态转移方程：
$$x(t) = e^{At}x(0) + \int_0^t e^{A(t-\tau)}Bu(\tau)d\tau$$

### 2.3 传递函数

**定义 2.3.1** (传递函数)
传递函数是系统输入输出关系的频域表示：
$$G(s) = C(sI - A)^{-1}B + D$$

### 2.4 稳定性分析

**定义 2.4.1** (稳定性)
系统是稳定的，如果对于有界输入产生有界输出。

**定理 2.4.1** (Lyapunov稳定性)
如果存在正定矩阵 $P$ 使得 $A^TP + PA < 0$，则系统稳定。

## 3. 核心理论

### 3.1 反馈控制

**定义 3.1.1** (反馈控制)
反馈控制律：$u(t) = -Kx(t) + r(t)$

其中 $K$ 是反馈增益矩阵，$r(t)$ 是参考输入。

### 3.2 状态反馈

**定理 3.2.1** (极点配置)
对于可控系统，可以通过状态反馈任意配置闭环极点。

### 3.3 观测器设计

**定义 3.3.1** (Luenberger观测器)
$$\dot{\hat{x}}(t) = A\hat{x}(t) + Bu(t) + L(y(t) - C\hat{x}(t))$$

### 3.4 最优控制

**定义 3.4.1** (LQR问题)
最小化性能指标：
$$J = \int_0^\infty (x^TQx + u^TRu)dt$$

## 4. 实现示例

### 4.1 Rust实现

```rust
use nalgebra::{DMatrix, DVector};

// 线性系统结构
struct LinearSystem {
    a: DMatrix<f64>,
    b: DMatrix<f64>,
    c: DMatrix<f64>,
    d: DMatrix<f64>,
}

impl LinearSystem {
    fn new(a: DMatrix<f64>, b: DMatrix<f64>, c: DMatrix<f64>, d: DMatrix<f64>) -> Self {
        LinearSystem { a, b, c, d }
    }
    
    fn step(&self, x: &DVector<f64>, u: &DVector<f64>) -> DVector<f64> {
        &self.a * x + &self.b * u
    }
    
    fn output(&self, x: &DVector<f64>, u: &DVector<f64>) -> DVector<f64> {
        &self.c * x + &self.d * u
    }
}

// 状态反馈控制器
struct StateFeedbackController {
    k: DMatrix<f64>,
}

impl StateFeedbackController {
    fn new(k: DMatrix<f64>) -> Self {
        StateFeedbackController { k }
    }
    
    fn control(&self, x: &DVector<f64>, r: &DVector<f64>) -> DVector<f64> {
        -&self.k * x + r
    }
}

// 观测器
struct Observer {
    l: DMatrix<f64>,
}

impl Observer {
    fn new(l: DMatrix<f64>) -> Self {
        Observer { l }
    }
    
    fn estimate(&self, x_hat: &DVector<f64>, u: &DVector<f64>, y: &DVector<f64>, system: &LinearSystem) -> DVector<f64> {
        let y_hat = system.output(x_hat, u);
        &system.a * x_hat + &system.b * u + &self.l * (y - y_hat)
    }
}

// 示例：倒立摆系统
fn inverted_pendulum_example() {
    // 系统参数
    let m = 0.1; // 摆质量
    let l = 0.5; // 摆长
    let g = 9.81; // 重力加速度
    
    // 状态空间模型
    let a = DMatrix::from_row_slice(2, 2, &[
        0.0, 1.0,
        g/l, 0.0
    ]);
    let b = DMatrix::from_row_slice(2, 1, &[0.0, 1.0/(m*l*l)]);
    let c = DMatrix::from_row_slice(1, 2, &[1.0, 0.0]);
    let d = DMatrix::zeros(1, 1);
    
    let system = LinearSystem::new(a, b, c, d);
    
    // 设计反馈控制器
    let k = DMatrix::from_row_slice(1, 2, &[-10.0, -5.0]);
    let controller = StateFeedbackController::new(k);
    
    // 仿真
    let mut x = DVector::from_column_slice(&[0.1, 0.0]); // 初始状态
    let r = DVector::zeros(1); // 参考输入
    
    for t in 0..100 {
        let u = controller.control(&x, &r);
        x = system.step(&x, &u);
        let y = system.output(&x, &u);
        
        println!("t={}, theta={:.3}, omega={:.3}, y={:.3}", 
                t, x[0], x[1], y[0]);
    }
}
```

### 4.2 数值计算

```rust
// 数值积分方法
trait Integrator {
    fn integrate<F>(&self, f: F, x0: f64, t0: f64, tf: f64, dt: f64) -> Vec<(f64, f64)>
    where F: Fn(f64, f64) -> f64;
}

struct EulerIntegrator;

impl Integrator for EulerIntegrator {
    fn integrate<F>(&self, f: F, x0: f64, t0: f64, tf: f64, dt: f64) -> Vec<(f64, f64)>
    where F: Fn(f64, f64) -> f64 {
        let mut result = Vec::new();
        let mut t = t0;
        let mut x = x0;
        
        while t <= tf {
            result.push((t, x));
            x += dt * f(t, x);
            t += dt;
        }
        
        result
    }
}

struct RK4Integrator;

impl Integrator for RK4Integrator {
    fn integrate<F>(&self, f: F, x0: f64, t0: f64, tf: f64, dt: f64) -> Vec<(f64, f64)>
    where F: Fn(f64, f64) -> f64 {
        let mut result = Vec::new();
        let mut t = t0;
        let mut x = x0;
        
        while t <= tf {
            result.push((t, x));
            
            let k1 = f(t, x);
            let k2 = f(t + dt/2.0, x + dt*k1/2.0);
            let k3 = f(t + dt/2.0, x + dt*k2/2.0);
            let k4 = f(t + dt, x + dt*k3);
            
            x += dt * (k1 + 2.0*k2 + 2.0*k3 + k4) / 6.0;
            t += dt;
        }
        
        result
    }
}
```

### 4.3 仿真验证

```rust
// 系统仿真器
struct Simulator {
    system: LinearSystem,
    controller: Option<StateFeedbackController>,
    observer: Option<Observer>,
    integrator: Box<dyn Integrator>,
}

impl Simulator {
    fn new(system: LinearSystem, integrator: Box<dyn Integrator>) -> Self {
        Simulator {
            system,
            controller: None,
            observer: None,
            integrator,
        }
    }
    
    fn set_controller(&mut self, controller: StateFeedbackController) {
        self.controller = Some(controller);
    }
    
    fn set_observer(&mut self, observer: Observer) {
        self.observer = Some(observer);
    }
    
    fn simulate(&self, x0: DVector<f64>, t0: f64, tf: f64, dt: f64) -> Vec<(f64, DVector<f64>)> {
        let mut result = Vec::new();
        let mut t = t0;
        let mut x = x0.clone();
        let mut x_hat = x0.clone();
        
        while t <= tf {
            result.push((t, x.clone()));
            
            let u = if let Some(ref controller) = self.controller {
                if let Some(ref observer) = self.observer {
                    controller.control(&x_hat, &DVector::zeros(1))
                } else {
                    controller.control(&x, &DVector::zeros(1))
                }
            } else {
                DVector::zeros(1)
            };
            
            // 更新真实状态
            x = self.system.step(&x, &u);
            
            // 更新观测器状态
            if let Some(ref observer) = self.observer {
                let y = self.system.output(&x, &u);
                x_hat = observer.estimate(&x_hat, &u, &y, &self.system);
            }
            
            t += dt;
        }
        
        result
    }
}
```

## 5. 参考文献

1. Ogata, K. (2010). *Modern Control Engineering*. Prentice Hall.
2. Franklin, G. F., Powell, J. D., & Emami-Naeini, A. (2015). *Feedback Control of Dynamic Systems*. Pearson.
3. Astrom, K. J., & Murray, R. M. (2021). *Feedback Systems: An Introduction for Scientists and Engineers*. Princeton University Press.
4. Sontag, E. D. (1998). *Mathematical Control Theory: Deterministic Finite Dimensional Systems*. Springer.
5. Khalil, H. K. (2015). *Nonlinear Systems*. Prentice Hall.

---

**相关文档**:
- [03.2 线性控制理论](03.2_Linear_Control_Theory.md)
- [03.3 非线性控制理论](03.3_Nonlinear_Control_Theory.md)
- [03.4 最优控制理论](03.4_Optimal_Control_Theory.md)
- [09.1 形式化模型基础](../09_Formal_Model_Theory/09.1_Formal_Model_Foundation.md)
