# 03.1 控制论基础 (Control Theory Foundation)

## 目录

```markdown
03.1 控制论基础
├── 1. 理论基础
│   ├── 1.1 控制系统定义
│   ├── 1.2 系统分类
│   └── 1.3 基本概念
├── 2. 形式化定义
│   ├── 2.1 状态空间模型
│   ├── 2.2 传递函数模型
│   └── 2.3 系统表示
├── 3. 系统性质
│   ├── 3.1 稳定性
│   ├── 3.2 可控性
│   ├── 3.3 可观性
│   └── 3.4 鲁棒性
├── 4. 控制设计
│   ├── 4.1 反馈控制
│   ├── 4.2 前馈控制
│   ├── 4.3 最优控制
│   └── 4.4 自适应控制
├── 5. 数学工具
│   ├── 5.1 拉普拉斯变换
│   ├── 5.2 傅里叶变换
│   └── 5.3 李雅普诺夫理论
├── 6. 实际应用
│   ├── 6.1 工业控制
│   ├── 6.2 机器人控制
│   └── 6.3 网络控制
├── 7. 高级主题
│   ├── 7.1 非线性控制
│   ├── 7.2 鲁棒控制
│   └── 7.3 智能控制
└── 8. 参考文献
```

## 1. 理论基础

### 1.1 控制系统定义

**定义 1.1 (控制系统)**
控制系统是由被控对象、控制器、传感器和执行器组成的系统，用于实现期望的系统行为。

**定义 1.2 (开环控制)**
开环控制系统不依赖输出反馈：
$$u(t) = K_r r(t)$$

**定义 1.3 (闭环控制)**
闭环控制系统依赖输出反馈：
$$u(t) = K_r r(t) - K_y y(t)$$

**定义 1.4 (控制目标)**
控制目标包括：
1. 稳定性：系统输出有界
2. 跟踪性：输出跟踪参考信号
3. 鲁棒性：对扰动不敏感
4. 最优性：性能指标最优

### 1.2 系统分类

**定义 1.5 (线性系统)**
线性系统满足叠加原理：
$$f(ax_1 + bx_2) = af(x_1) + bf(x_2)$$

**定义 1.6 (时不变系统)**
时不变系统的性质不随时间变化：
$$f(x(t)) = y(t) \Rightarrow f(x(t-\tau)) = y(t-\tau)$$

**定义 1.7 (因果系统)**
因果系统的输出只依赖于当前和过去的输入：
$$y(t) = f(u(\tau) : \tau \leq t)$$

**定理 1.1 (系统分类)**
控制系统可以按以下维度分类：
1. 线性/非线性
2. 时变/时不变
3. 连续/离散
4. 单输入单输出/多输入多输出

### 1.3 基本概念

**定义 1.8 (状态)**
状态是描述系统内部信息的变量集合：
$$x(t) \in \mathbb{R}^n$$

**定义 1.9 (输入)**
输入是系统的控制信号：
$$u(t) \in \mathbb{R}^m$$

**定义 1.10 (输出)**
输出是系统的可测量信号：
$$y(t) \in \mathbb{R}^p$$

**定义 1.11 (扰动)**
扰动是影响系统但不可控的信号：
$$d(t) \in \mathbb{R}^q$$

## 2. 形式化定义

### 2.1 状态空间模型

**定义 2.1 (连续时间状态空间模型)**
$$\begin{align}
\dot{x}(t) &= Ax(t) + Bu(t) + Ed(t) \\
y(t) &= Cx(t) + Du(t) + Fd(t)
\end{align}$$

其中：
- $A \in \mathbb{R}^{n \times n}$：系统矩阵
- $B \in \mathbb{R}^{n \times m}$：输入矩阵
- $C \in \mathbb{R}^{p \times n}$：输出矩阵
- $D \in \mathbb{R}^{p \times m}$：直接传递矩阵
- $E \in \mathbb{R}^{n \times q}$：扰动输入矩阵
- $F \in \mathbb{R}^{p \times q}$：扰动输出矩阵

**定义 2.2 (离散时间状态空间模型)**
$$\begin{align}
x(k+1) &= Ax(k) + Bu(k) + Ed(k) \\
y(k) &= Cx(k) + Du(k) + Fd(k)
\end{align}$$

**定理 2.1 (状态空间解)**
连续时间状态空间方程的解：
$$x(t) = e^{At}x(0) + \int_0^t e^{A(t-\tau)}Bu(\tau)d\tau$$

**证明：** 通过拉普拉斯变换或直接积分。

### 2.2 传递函数模型

**定义 2.3 (传递函数)**
传递函数是系统输入输出关系的拉普拉斯变换：
$$G(s) = \frac{Y(s)}{U(s)} = C(sI - A)^{-1}B + D$$

**定义 2.4 (特征多项式)**
特征多项式：
$$\Delta(s) = \det(sI - A) = s^n + a_{n-1}s^{n-1} + \cdots + a_0$$

**定义 2.5 (极点)**
极点是特征多项式的根：
$$\Delta(s_i) = 0$$

**定理 2.2 (传递函数性质)**
传递函数满足：
1. 有理函数形式
2. 真有理函数（分子次数 ≤ 分母次数）
3. 极点决定稳定性

### 2.3 系统表示

**定义 2.6 (可控标准型)**
$$\begin{align}
\dot{x} &= \begin{bmatrix}
0 & 1 & 0 & \cdots & 0 \\
0 & 0 & 1 & \cdots & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
0 & 0 & 0 & \cdots & 1 \\
-a_0 & -a_1 & -a_2 & \cdots & -a_{n-1}
\end{bmatrix} x + \begin{bmatrix}
0 \\ 0 \\ \vdots \\ 0 \\ 1
\end{bmatrix} u \\
y &= \begin{bmatrix}
b_0 & b_1 & b_2 & \cdots & b_{n-1}
\end{bmatrix} x
\end{align}$$

**定义 2.7 (可观标准型)**
$$\begin{align}
\dot{x} &= \begin{bmatrix}
0 & 0 & \cdots & 0 & -a_0 \\
1 & 0 & \cdots & 0 & -a_1 \\
0 & 1 & \cdots & 0 & -a_2 \\
\vdots & \vdots & \ddots & \vdots & \vdots \\
0 & 0 & \cdots & 1 & -a_{n-1}
\end{bmatrix} x + \begin{bmatrix}
b_0 \\ b_1 \\ b_2 \\ \vdots \\ b_{n-1}
\end{bmatrix} u \\
y &= \begin{bmatrix}
0 & 0 & \cdots & 0 & 1
\end{bmatrix} x
\end{align}$$

## 3. 系统性质

### 3.1 稳定性

**定义 3.1 (渐近稳定性)**
系统渐近稳定，如果：
$$\lim_{t \to \infty} x(t) = 0 \quad \forall x(0) \in \mathbb{R}^n$$

**定义 3.2 (李雅普诺夫稳定性)**
系统李雅普诺夫稳定，如果：
$$\forall \epsilon > 0, \exists \delta > 0 : \|x(0)\| < \delta \Rightarrow \|x(t)\| < \epsilon$$

**定理 3.1 (线性系统稳定性)**
线性系统渐近稳定当且仅当所有极点具有负实部：
$$\text{Re}(\lambda_i) < 0 \quad \forall i$$

**证明：** 通过状态空间解的形式和极点的定义。

**定理 3.2 (李雅普诺夫稳定性定理)**
如果存在正定函数 $V(x)$ 使得 $\dot{V}(x) < 0$，则系统渐近稳定。

**证明：** 通过李雅普诺夫函数的单调递减性质。

### 3.2 可控性

**定义 3.3 (可控性)**
系统可控，如果对于任意初始状态 $x_0$ 和目标状态 $x_f$，存在控制输入 $u(t)$ 使得 $x(T) = x_f$。

**定义 3.4 (可控性矩阵)**
可控性矩阵：
$$\mathcal{C} = \begin{bmatrix}
B & AB & A^2B & \cdots & A^{n-1}B
\end{bmatrix}$$

**定理 3.3 (可控性判据)**
系统可控当且仅当可控性矩阵满秩：
$$\text{rank}(\mathcal{C}) = n$$

**证明：** 通过凯莱-哈密顿定理和格拉姆矩阵。

### 3.3 可观性

**定义 3.5 (可观性)**
系统可观，如果任意初始状态 $x_0$ 都可以通过输出 $y(t)$ 唯一确定。

**定义 3.6 (可观性矩阵)**
可观性矩阵：
$$\mathcal{O} = \begin{bmatrix}
C \\ CA \\ CA^2 \\ \vdots \\ CA^{n-1}
\end{bmatrix}$$

**定理 3.4 (可观性判据)**
系统可观当且仅当可观性矩阵满秩：
$$\text{rank}(\mathcal{O}) = n$$

**证明：** 通过对偶性和可控性判据。

### 3.4 鲁棒性

**定义 3.7 (鲁棒性)**
系统鲁棒，如果对参数摄动和外部扰动具有不敏感性。

**定义 3.8 (鲁棒稳定性)**
系统鲁棒稳定，如果在参数摄动下保持稳定性。

**定理 3.5 (小增益定理)**
如果 $\|G_1\|_\infty \|G_2\|_\infty < 1$，则反馈系统稳定。

## 4. 控制设计

### 4.1 反馈控制

**定义 4.1 (状态反馈)**
状态反馈控制律：
$$u(t) = -Kx(t) + K_r r(t)$$

**定义 4.2 (输出反馈)**
输出反馈控制律：
$$u(t) = -K_y y(t) + K_r r(t)$$

**定理 4.1 (极点配置)**
如果系统可控，则可以通过状态反馈任意配置闭环极点。

**证明：** 通过可控标准型和阿克曼公式。

**示例：极点配置**
```rust
// Rust 实现极点配置
use nalgebra::{DMatrix, DVector};

struct StateFeedback {
    k: DMatrix<f64>,
    kr: DVector<f64>,
}

impl StateFeedback {
    fn new(a: &DMatrix<f64>, b: &DMatrix<f64>, desired_poles: &[f64]) -> Self {
        let n = a.nrows();
        
        // 计算期望特征多项式
        let mut desired_char_poly = vec![1.0];
        for &pole in desired_poles {
            let mut new_poly = vec![0.0; desired_char_poly.len() + 1];
            for (i, &coeff) in desired_char_poly.iter().enumerate() {
                new_poly[i] += coeff;
                new_poly[i + 1] -= coeff * pole;
            }
            desired_char_poly = new_poly;
        }
        
        // 计算当前特征多项式系数
        let mut current_char_poly = vec![1.0];
        let mut power = DMatrix::identity(n, n);
        for i in 0..n {
            power = power * a;
            current_char_poly.push(-power.trace() / (i + 1) as f64);
        }
        
        // 计算反馈增益
        let mut k = DVector::zeros(n);
        for i in 0..n {
            k[i] = desired_char_poly[i + 1] - current_char_poly[i + 1];
        }
        
        // 转换为矩阵形式
        let k_matrix = DMatrix::from_column_vector(&k);
        let kr = DVector::ones(1);
        
        StateFeedback {
            k: k_matrix,
            kr,
        }
    }
    
    fn control(&self, x: &DVector<f64>, r: f64) -> f64 {
        -self.k.dot(x) + self.kr[0] * r
    }
}

fn main() {
    // 示例：二阶系统
    let a = DMatrix::from_row_slice(2, 2, &[0.0, 1.0, -1.0, -2.0]);
    let b = DMatrix::from_column_slice(2, 1, &[0.0, 1.0]);
    
    // 期望极点：-2 ± 2j
    let desired_poles = vec![-2.0 + 2.0, -2.0 - 2.0];
    
    let controller = StateFeedback::new(&a, &b, &desired_poles);
    
    let x = DVector::from_column_slice(&[1.0, 0.0]);
    let r = 1.0;
    let u = controller.control(&x, r);
    
    println!("Control input: {}", u);
}
```

### 4.2 前馈控制

**定义 4.3 (前馈控制)**
前馈控制基于扰动或参考信号的预测：
$$u_{ff}(t) = G_{ff}(s)r(s)$$

**定理 4.2 (前馈控制设计)**
理想前馈控制器：
$$G_{ff}(s) = G^{-1}(s)$$

**证明：** 通过传递函数分析和理想跟踪条件。

### 4.3 最优控制

**定义 4.4 (最优控制问题)**
最小化性能指标：
$$J = \int_0^T (x^T Q x + u^T R u) dt$$

**定理 4.3 (线性二次型调节器)**
最优控制律：
$$u^*(t) = -R^{-1}B^T P(t)x(t)$$

其中 $P(t)$ 满足黎卡提微分方程。

**证明：** 通过变分法和庞特里亚金最大原理。

### 4.4 自适应控制

**定义 4.5 (自适应控制)**
自适应控制在线调整控制器参数：
$$\dot{\theta}(t) = \gamma \phi(t)e(t)$$

**定理 4.4 (自适应控制稳定性)**
在持续激励条件下，自适应控制系统稳定。

## 5. 数学工具

### 5.1 拉普拉斯变换

**定义 5.1 (拉普拉斯变换)**
$$F(s) = \mathcal{L}\{f(t)\} = \int_0^\infty f(t)e^{-st}dt$$

**定理 5.1 (拉普拉斯变换性质)**
1. 线性性：$\mathcal{L}\{af(t) + bg(t)\} = aF(s) + bG(s)$
2. 时移：$\mathcal{L}\{f(t-\tau)\} = e^{-s\tau}F(s)$
3. 微分：$\mathcal{L}\{\dot{f}(t)\} = sF(s) - f(0)$
4. 积分：$\mathcal{L}\{\int_0^t f(\tau)d\tau\} = \frac{F(s)}{s}$

### 5.2 傅里叶变换

**定义 5.2 (傅里叶变换)**
$$F(j\omega) = \mathcal{F}\{f(t)\} = \int_{-\infty}^\infty f(t)e^{-j\omega t}dt$$

**定理 5.2 (频率响应)**
系统频率响应：
$$G(j\omega) = C(j\omega I - A)^{-1}B + D$$

### 5.3 李雅普诺夫理论

**定义 5.3 (李雅普诺夫函数)**
正定函数 $V(x)$ 满足：
1. $V(0) = 0$
2. $V(x) > 0$ for $x \neq 0$
3. $\dot{V}(x) \leq 0$ (稳定性) 或 $\dot{V}(x) < 0$ (渐近稳定性)

**定理 5.3 (李雅普诺夫稳定性)**
如果存在李雅普诺夫函数，则系统稳定。

## 6. 实际应用

### 6.1 工业控制

**定理 6.1 (PID控制)**
PID控制器：
$$u(t) = K_p e(t) + K_i \int_0^t e(\tau)d\tau + K_d \frac{de(t)}{dt}$$

**示例：PID控制器**
```haskell
-- Haskell 实现 PID 控制器
data PIDController = PIDController {
    kp :: Double,
    ki :: Double,
    kd :: Double,
    integral :: Double,
    prevError :: Double,
    dt :: Double
}

newPID :: Double -> Double -> Double -> Double -> PIDController
newPID kp ki kd dt = PIDController {
    kp = kp,
    ki = ki,
    kd = kd,
    integral = 0.0,
    prevError = 0.0,
    dt = dt
}

updatePID :: PIDController -> Double -> Double -> (PIDController, Double)
updatePID pid setpoint measurement = 
    let error = setpoint - measurement
        newIntegral = integral pid + error * dt pid
        derivative = (error - prevError pid) / dt pid
        output = kp pid * error + ki pid * newIntegral + kd pid * derivative
        newPID = pid {
            integral = newIntegral,
            prevError = error
        }
    in (newPID, output)

-- 使用示例
simulatePID :: PIDController -> Double -> [Double] -> [Double]
simulatePID _ _ [] = []
simulatePID pid setpoint (measurement:measurements) =
    let (newPID, output) = updatePID pid setpoint measurement
    in output : simulatePID newPID setpoint measurements
```

### 6.2 机器人控制

**定理 6.2 (机器人动力学)**
机器人动力学方程：
$$M(q)\ddot{q} + C(q,\dot{q})\dot{q} + G(q) = \tau$$

**示例：机器人控制**
```rust
// Rust 实现简单机器人控制
use nalgebra::{DVector, DMatrix};

struct RobotController {
    kp: DMatrix<f64>,
    kd: DMatrix<f64>,
    ki: DMatrix<f64>,
    integral: DVector<f64>,
}

impl RobotController {
    fn new(kp: f64, kd: f64, ki: f64, n_joints: usize) -> Self {
        RobotController {
            kp: DMatrix::identity(n_joints, n_joints) * kp,
            kd: DMatrix::identity(n_joints, n_joints) * kd,
            ki: DMatrix::identity(n_joints, n_joints) * ki,
            integral: DVector::zeros(n_joints),
        }
    }
    
    fn control(&mut self, 
               q_desired: &DVector<f64>, 
               q_current: &DVector<f64>, 
               qd_current: &DVector<f64>,
               dt: f64) -> DVector<f64> {
        let error = q_desired - q_current;
        self.integral += error * dt;
        
        let tau = self.kp * error + 
                  self.kd * (-qd_current) + 
                  self.ki * self.integral;
        
        tau
    }
}

fn main() {
    let mut controller = RobotController::new(100.0, 20.0, 10.0, 2);
    
    let q_desired = DVector::from_column_slice(&[1.0, 0.5]);
    let q_current = DVector::from_column_slice(&[0.0, 0.0]);
    let qd_current = DVector::from_column_slice(&[0.0, 0.0]);
    
    let tau = controller.control(&q_desired, &q_current, &qd_current, 0.01);
    println!("Control torques: {:?}", tau);
}
```

### 6.3 网络控制

**定理 6.3 (网络控制系统)**
网络控制系统考虑通信延迟和丢包：
$$\dot{x}(t) = Ax(t) + Bu(t-\tau(t))$$

**示例：网络控制**
```haskell
-- Haskell 实现网络控制系统
data NetworkControl = NetworkControl {
    controller :: PIDController,
    buffer :: [Double],
    maxDelay :: Int,
    packetLoss :: Double
}

newNetworkControl :: PIDController -> Int -> Double -> NetworkControl
newNetworkControl pid maxDelay loss = NetworkControl {
    controller = pid,
    buffer = replicate maxDelay 0.0,
    maxDelay = maxDelay,
    packetLoss = loss
}

updateNetworkControl :: NetworkControl -> Double -> Double -> IO (NetworkControl, Double)
updateNetworkControl nc setpoint measurement = do
    -- 模拟网络延迟
    let delayedMeasurement = head (buffer nc)
    let newBuffer = tail (buffer nc) ++ [measurement]
    
    -- 模拟丢包
    loss <- randomRIO (0.0, 1.0)
    let (newController, output) = if loss > packetLoss nc
        then updatePID (controller nc) setpoint delayedMeasurement
        else (controller nc, 0.0)
    
    return (nc {
        controller = newController,
        buffer = newBuffer
    }, output)
```

## 7. 高级主题

### 7.1 非线性控制

**定理 7.1 (非线性系统)**
非线性系统：
$$\dot{x} = f(x, u)$$

**定理 7.2 (反馈线性化)**
通过状态反馈和坐标变换，某些非线性系统可以线性化。

### 7.2 鲁棒控制

**定理 7.3 (H∞控制)**
H∞控制最小化最坏情况下的性能：
$$\min_K \max_w \|T_{zw}\|_\infty$$

### 7.3 智能控制

**定理 7.4 (模糊控制)**
模糊控制基于模糊逻辑和专家知识。

**定理 7.5 (神经网络控制)**
神经网络控制通过学习和适应实现控制。

## 8. 参考文献

1. Ogata, K. (2010). Modern control engineering. Pearson Education.
2. Franklin, G. F., Powell, J. D., & Emami-Naeini, A. (2015). Feedback control of dynamic systems. Pearson.
3. Åström, K. J., & Murray, R. M. (2021). Feedback systems: an introduction for scientists and engineers. Princeton University Press.
4. Slotine, J. J. E., & Li, W. (1991). Applied nonlinear control. Prentice Hall.
5. Doyle, J. C., Francis, B. A., & Tannenbaum, A. R. (2013). Feedback control theory. Courier Corporation.

---

**相关文档链接**：
- [03.2 线性控制理论](../03.2_Linear_Control_Theory.md)
- [03.3 非线性控制理论](../03.3_Nonlinear_Control_Theory.md)
- [03.4 最优控制理论](../03.4_Optimal_Control_Theory.md)
- [04.1 分布式系统基础](../04_Distributed_Systems/04.1_Distributed_Systems_Foundation.md)
- [01.1 类型理论基础](../01_Foundational_Theory/01.1_Type_Theory_Foundation.md)
