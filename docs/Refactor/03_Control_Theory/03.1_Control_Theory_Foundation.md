# 03.1 控制论理论基础

## 目录

```markdown
03.1 控制论理论基础
├── 1. 概述
│   ├── 1.1 定义与动机
│   ├── 1.2 历史发展
│   └── 1.3 应用领域
├── 2. 基本概念
│   ├── 2.1 系统定义
│   ├── 2.2 控制目标
│   ├── 2.3 反馈原理
│   └── 2.4 系统分类
├── 3. 数学基础
│   ├── 3.1 状态空间表示
│   ├── 3.2 传递函数
│   ├── 3.3 频域分析
│   └── 3.4 时域分析
├── 4. 系统建模
│   ├── 4.1 物理建模
│   ├── 4.2 数学建模
│   ├── 4.3 线性化
│   └── 4.4 模型验证
├── 5. 稳定性理论
│   ├── 5.1 稳定性定义
│   ├── 5.2 Lyapunov稳定性
│   ├── 5.3 频域稳定性
│   └── 5.4 鲁棒稳定性
├── 6. 控制设计
│   ├── 6.1 PID控制
│   ├── 6.2 状态反馈
│   ├── 6.3 观测器设计
│   └── 6.4 最优控制
├── 7. 算法实现
│   ├── 7.1 Haskell实现
│   ├── 7.2 Rust实现
│   └── 7.3 数值方法
├── 8. 应用实例
│   ├── 8.1 机械系统
│   ├── 8.2 电气系统
│   └── 8.3 生物系统
└── 9. 参考文献
```

## 1. 概述

### 1.1 定义与动机

**定义 1.1** (控制论)
控制论是研究动态系统行为调节的科学，通过设计控制器使系统达到期望的性能指标。

**核心概念**:
- **系统**: 具有输入、输出和内部状态的动态对象
- **控制**: 通过调节输入来影响系统行为的过程
- **反馈**: 将输出信息用于调节输入的控制策略

**动机**:
- 系统性能优化
- 稳定性保证
- 鲁棒性设计
- 自动化实现

### 1.2 历史发展

控制论的发展历程：

1. **古代**: 简单机械控制装置
2. **18世纪**: 蒸汽机调速器
3. **19世纪**: 数学控制理论萌芽
4. **20世纪初**: 频域方法发展
5. **1940年代**: 经典控制理论形成
6. **1960年代**: 现代控制理论兴起
7. **1980年代**: 鲁棒控制理论
8. **2000年代**: 智能控制技术

### 1.3 应用领域

- **工业控制**: 过程控制、机器人控制
- **航空航天**: 飞行控制、卫星姿态控制
- **汽车工业**: 发动机控制、自动驾驶
- **生物医学**: 药物输注、人工器官
- **经济系统**: 宏观经济调控
- **社会系统**: 人口控制、资源管理

## 2. 基本概念

### 2.1 系统定义

**定义 2.1** (动态系统)
动态系统是一个数学对象，描述输入、状态和输出之间的关系：

$$\begin{align}
\dot{x}(t) &= f(x(t), u(t), t) \\
y(t) &= h(x(t), u(t), t)
\end{align}$$

其中：
- $x(t) \in \mathbb{R}^n$ 是状态向量
- $u(t) \in \mathbb{R}^m$ 是输入向量
- $y(t) \in \mathbb{R}^p$ 是输出向量
- $f: \mathbb{R}^n \times \mathbb{R}^m \times \mathbb{R} \to \mathbb{R}^n$ 是状态方程
- $h: \mathbb{R}^n \times \mathbb{R}^m \times \mathbb{R} \to \mathbb{R}^p$ 是输出方程

**定义 2.2** (线性系统)
如果 $f$ 和 $h$ 是线性函数，则系统是线性的：

$$\begin{align}
\dot{x}(t) &= A(t)x(t) + B(t)u(t) \\
y(t) &= C(t)x(t) + D(t)u(t)
\end{align}$$

其中 $A(t), B(t), C(t), D(t)$ 是适当维数的矩阵。

### 2.2 控制目标

**定义 2.3** (控制目标)
控制系统的设计目标包括：

1. **稳定性**: 系统在扰动下保持有界响应
2. **跟踪性能**: 输出跟踪期望参考信号
3. **调节性能**: 抑制外部扰动的影响
4. **鲁棒性**: 对模型不确定性的不敏感性
5. **最优性**: 在某种性能指标下的最优表现

**定义 2.4** (性能指标)
常用的性能指标包括：

- **稳态误差**: $\lim_{t \to \infty} |e(t)|$
- **超调量**: $\max_{t \geq 0} |y(t) - y_{ss}|$
- **调节时间**: 输出进入稳态误差带的时间
- **上升时间**: 输出从10%到90%的时间

### 2.3 反馈原理

**定义 2.5** (反馈控制)
反馈控制是将系统输出与期望值比较，根据误差调节控制输入的过程：

$$u(t) = K(r(t) - y(t))$$

其中：
- $r(t)$ 是参考输入
- $y(t)$ 是系统输出
- $K$ 是控制器增益
- $e(t) = r(t) - y(t)$ 是误差信号

**定理 2.6** (反馈优势)
反馈控制具有以下优势：

1. **扰动抑制**: 自动补偿外部扰动
2. **参数变化鲁棒性**: 对系统参数变化不敏感
3. **稳定性改善**: 可能改善开环不稳定系统
4. **性能调节**: 通过调节控制器参数优化性能

### 2.4 系统分类

**定义 2.7** (系统分类)
根据系统特性进行分类：

1. **线性/非线性**: 基于系统方程的线性性
2. **时变/时不变**: 基于参数的时间依赖性
3. **连续/离散**: 基于时间变量的连续性
4. **单输入单输出/多输入多输出**: 基于输入输出维数
5. **集中参数/分布参数**: 基于状态变量的分布特性

## 3. 数学基础

### 3.1 状态空间表示

**定义 3.1** (状态空间)
状态空间是描述系统动态行为的数学框架：

$$\begin{align}
\dot{x}(t) &= Ax(t) + Bu(t) \\
y(t) &= Cx(t) + Du(t)
\end{align}$$

其中：
- $A \in \mathbb{R}^{n \times n}$ 是系统矩阵
- $B \in \mathbb{R}^{n \times m}$ 是输入矩阵
- $C \in \mathbb{R}^{p \times n}$ 是输出矩阵
- $D \in \mathbb{R}^{p \times m}$ 是直接传递矩阵

**定理 3.2** (状态方程解)
线性时不变系统的状态方程解为：

$$x(t) = e^{At}x(0) + \int_0^t e^{A(t-\tau)}Bu(\tau)d\tau$$

**定义 3.3** (状态转移矩阵)
状态转移矩阵 $\Phi(t) = e^{At}$ 满足：

$$\frac{d}{dt}\Phi(t) = A\Phi(t), \quad \Phi(0) = I$$

### 3.2 传递函数

**定义 3.4** (传递函数)
对于线性时不变系统，传递函数定义为：

$$G(s) = C(sI - A)^{-1}B + D$$

其中 $s$ 是拉普拉斯变换变量。

**定理 3.5** (传递函数性质)
传递函数具有以下性质：

1. **有理函数**: $G(s) = \frac{N(s)}{D(s)}$，其中 $N(s), D(s)$ 是多项式
2. **极点**: $D(s) = 0$ 的根
3. **零点**: $N(s) = 0$ 的根
4. **相对阶**: $\deg(D(s)) - \deg(N(s))$

**定义 3.6** (频率响应)
频率响应是传递函数在虚轴上的值：

$$G(j\omega) = |G(j\omega)|e^{j\angle G(j\omega)}$$

其中：
- $|G(j\omega)|$ 是幅值响应
- $\angle G(j\omega)$ 是相位响应

### 3.3 频域分析

**定义 3.7** (频域性能指标)
常用的频域性能指标包括：

1. **带宽**: $|G(j\omega)| = \frac{1}{\sqrt{2}}|G(0)|$ 的频率
2. **相位裕度**: $\pi + \angle G(j\omega_c)$，其中 $\omega_c$ 是穿越频率
3. **幅值裕度**: $\frac{1}{|G(j\omega_\pi)|}$，其中 $\omega_\pi$ 是相位穿越频率

**定理 3.8** (奈奎斯特稳定性判据)
闭环系统稳定的充分必要条件是奈奎斯特图不包围点 $(-1, 0)$。

### 3.4 时域分析

**定义 3.9** (时域响应)
系统的时域响应包括：

1. **单位阶跃响应**: $h(t) = \mathcal{L}^{-1}\{\frac{G(s)}{s}\}$
2. **单位脉冲响应**: $g(t) = \mathcal{L}^{-1}\{G(s)\}$
3. **单位斜坡响应**: $r(t) = \mathcal{L}^{-1}\{\frac{G(s)}{s^2}\}$

**定理 3.10** (终值定理)
如果 $\lim_{s \to 0} sF(s)$ 存在，则：

$$\lim_{t \to \infty} f(t) = \lim_{s \to 0} sF(s)$$

## 4. 系统建模

### 4.1 物理建模

**定义 4.1** (物理建模)
基于物理定律建立系统数学模型的过程。

**例 4.2** (机械系统建模)
质量-弹簧-阻尼系统：

$$m\ddot{x}(t) + c\dot{x}(t) + kx(t) = u(t)$$

状态空间表示：
$$\begin{align}
\dot{x}_1(t) &= x_2(t) \\
\dot{x}_2(t) &= -\frac{k}{m}x_1(t) - \frac{c}{m}x_2(t) + \frac{1}{m}u(t)
\end{align}$$

**例 4.3** (电气系统建模)
RLC电路：

$$L\frac{di(t)}{dt} + Ri(t) + \frac{1}{C}\int i(t)dt = v(t)$$

### 4.2 数学建模

**定义 4.4** (数学建模步骤)
1. **系统识别**: 确定系统结构和参数
2. **方程建立**: 根据物理定律建立微分方程
3. **状态选择**: 选择合适的状态变量
4. **模型简化**: 忽略次要因素，简化模型

**定理 4.5** (模型等价性)
不同的状态选择可能导致不同的状态空间表示，但传递函数相同。

### 4.3 线性化

**定义 4.6** (线性化)
在平衡点附近将非线性系统近似为线性系统：

$$\delta \dot{x}(t) = A\delta x(t) + B\delta u(t)$$

其中：
- $A = \frac{\partial f}{\partial x}\big|_{x_e, u_e}$
- $B = \frac{\partial f}{\partial u}\big|_{x_e, u_e}$

**定理 4.7** (线性化有效性)
线性化模型在平衡点附近有效，误差为高阶项。

### 4.4 模型验证

**定义 4.8** (模型验证)
通过实验数据验证数学模型准确性的过程。

**方法**:
1. **参数辨识**: 最小化预测误差
2. **残差分析**: 分析模型残差的统计特性
3. **交叉验证**: 使用不同数据集验证模型

## 5. 稳定性理论

### 5.1 稳定性定义

**定义 5.1** (Lyapunov稳定性)
平衡点 $x_e$ 是稳定的，如果对于任意 $\varepsilon > 0$，存在 $\delta > 0$，使得：

$$\|x(0) - x_e\| < \delta \implies \|x(t) - x_e\| < \varepsilon, \quad \forall t \geq 0$$

**定义 5.2** (渐近稳定性)
平衡点 $x_e$ 是渐近稳定的，如果它是稳定的且：

$$\lim_{t \to \infty} x(t) = x_e$$

**定义 5.3** (指数稳定性)
平衡点 $x_e$ 是指数稳定的，如果存在常数 $M, \alpha > 0$，使得：

$$\|x(t) - x_e\| \leq M\|x(0) - x_e\|e^{-\alpha t}$$

### 5.2 Lyapunov稳定性

**定理 5.4** (Lyapunov稳定性定理)
如果存在正定函数 $V(x)$，使得 $\dot{V}(x) \leq 0$，则平衡点是稳定的。

**定理 5.5** (Lyapunov渐近稳定性定理)
如果存在正定函数 $V(x)$，使得 $\dot{V}(x) < 0$，则平衡点是渐近稳定的。

**定义 5.6** (Lyapunov函数)
Lyapunov函数是满足以下条件的标量函数：

1. $V(0) = 0$
2. $V(x) > 0$ for $x \neq 0$
3. $\dot{V}(x) \leq 0$ (稳定性) 或 $\dot{V}(x) < 0$ (渐近稳定性)

### 5.3 频域稳定性

**定理 5.7** (Routh-Hurwitz判据)
多项式 $D(s) = a_ns^n + a_{n-1}s^{n-1} + \cdots + a_0$ 的所有根具有负实部的充分必要条件是Routh表第一列所有元素同号。

**定理 5.8** (奈奎斯特判据)
闭环系统稳定的充分必要条件是奈奎斯特图不包围点 $(-1, 0)$。

### 5.4 鲁棒稳定性

**定义 5.9** (鲁棒稳定性)
系统在参数不确定性下保持稳定的能力。

**定理 5.10** (小增益定理)
如果 $\|G_1\|_\infty \|G_2\|_\infty < 1$，则反馈系统稳定。

## 6. 控制设计

### 6.1 PID控制

**定义 6.1** (PID控制器)
PID控制器的传递函数为：

$$G_c(s) = K_p + \frac{K_i}{s} + K_ds$$

其中：
- $K_p$ 是比例增益
- $K_i$ 是积分增益
- $K_d$ 是微分增益

**定理 6.2** (PID调节规则)
Ziegler-Nichols调节规则：

1. **比例控制**: $K_p = 0.5K_{cr}$
2. **PI控制**: $K_p = 0.45K_{cr}, T_i = 0.83T_{cr}$
3. **PID控制**: $K_p = 0.6K_{cr}, T_i = 0.5T_{cr}, T_d = 0.125T_{cr}$

其中 $K_{cr}, T_{cr}$ 是临界增益和临界周期。

### 6.2 状态反馈

**定义 6.3** (状态反馈)
状态反馈控制律为：

$$u(t) = -Kx(t) + r(t)$$

其中 $K$ 是反馈增益矩阵。

**定理 6.4** (极点配置)
如果系统 $(A, B)$ 可控，则可以通过状态反馈任意配置闭环极点。

**算法 6.5** (极点配置算法)
```rust
fn pole_placement(a: &Matrix, b: &Matrix, desired_poles: &[Complex]) -> Matrix {
    // 1. 计算可控性矩阵
    let controllability = compute_controllability_matrix(a, b);
    
    // 2. 检查可控性
    if controllability.rank() != a.rows() {
        panic!("System is not controllable");
    }
    
    // 3. 计算期望特征多项式
    let desired_char_poly = polynomial_from_roots(desired_poles);
    
    // 4. 计算反馈增益
    let k = compute_feedback_gain(a, b, &desired_char_poly);
    
    k
}
```

### 6.3 观测器设计

**定义 6.6** (状态观测器)
状态观测器的动态方程为：

$$\dot{\hat{x}}(t) = A\hat{x}(t) + Bu(t) + L(y(t) - C\hat{x}(t))$$

其中 $L$ 是观测器增益矩阵。

**定理 6.7** (观测器设计)
如果系统 $(A, C)$ 可观，则可以通过选择 $L$ 任意配置观测器极点。

**定义 6.8** (分离原理)
状态反馈和观测器可以独立设计，组合后的系统极点等于控制器极点和观测器极点的并集。

### 6.4 最优控制

**定义 6.9** (线性二次型调节器)
LQR问题的性能指标为：

$$J = \int_0^\infty [x^T(t)Qx(t) + u^T(t)Ru(t)]dt$$

其中 $Q \geq 0, R > 0$ 是权重矩阵。

**定理 6.10** (LQR解)
LQR问题的最优控制律为：

$$u(t) = -Kx(t)$$

其中 $K = R^{-1}B^TP$，$P$ 是代数Riccati方程的解：

$$A^TP + PA - PBR^{-1}B^TP + Q = 0$$

## 7. 算法实现

### 7.1 Haskell实现

```haskell
-- 系统状态类型
type State = Vector Double
type Input = Vector Double
type Output = Vector Double

-- 系统矩阵类型
type SystemMatrix = Matrix Double

-- 线性系统
data LinearSystem = LinearSystem {
    a :: SystemMatrix,
    b :: SystemMatrix,
    c :: SystemMatrix,
    d :: SystemMatrix
}

-- 系统仿真
simulate :: LinearSystem -> State -> [Input] -> [State]
simulate sys x0 inputs = scanl step x0 inputs
  where
    step x u = a sys `multiply` x + b sys `multiply` u

-- 传递函数
transferFunction :: LinearSystem -> Complex Double -> Complex Double
transferFunction sys s = c sys `multiply` inv (s * identity - a sys) `multiply` b sys + d sys

-- PID控制器
data PIDController = PIDController {
    kp :: Double,
    ki :: Double,
    kd :: Double,
    integral :: Double,
    previous_error :: Double
}

-- PID控制律
pidControl :: PIDController -> Double -> Double -> (PIDController, Double)
pidControl pid error dt = (new_pid, output)
  where
    new_integral = integral pid + error * dt
    derivative = (error - previous_error pid) / dt
    output = kp pid * error + ki pid * new_integral + kd pid * derivative
    new_pid = pid {
        integral = new_integral,
        previous_error = error
    }

-- Lyapunov函数
lyapunovFunction :: SystemMatrix -> State -> Double
lyapunovFunction p x = x `dot` (p `multiply` x)

-- 稳定性检查
isStable :: SystemMatrix -> Bool
isStable a = all (\eigenval -> realPart eigenval < 0) (eigenvalues a)

-- 极点配置
polePlacement :: LinearSystem -> [Complex Double] -> Maybe (Vector Double)
polePlacement sys desired_poles = do
    -- 检查可控性
    guard $ isControllable sys
    
    -- 计算反馈增益
    let k = computeFeedbackGain sys desired_poles
    return k

-- 观测器设计
observerDesign :: LinearSystem -> [Complex Double] -> Maybe (Vector Double)
observerDesign sys desired_poles = do
    -- 检查可观性
    guard $ isObservable sys
    
    -- 计算观测器增益
    let l = computeObserverGain sys desired_poles
    return l

-- LQR设计
lqrDesign :: LinearSystem -> SystemMatrix -> SystemMatrix -> Maybe (Vector Double)
lqrDesign sys q r = do
    -- 求解Riccati方程
    p <- solveRiccatiEquation sys q r
    
    -- 计算最优反馈增益
    let k = inv r `multiply` transpose (b sys) `multiply` p
    return k
```

### 7.2 Rust实现

```rust
use nalgebra::{DMatrix, DVector, Complex};

// 系统状态类型
type State = DVector<f64>;
type Input = DVector<f64>;
type Output = DVector<f64>;

// 线性系统
#[derive(Clone, Debug)]
struct LinearSystem {
    a: DMatrix<f64>,
    b: DMatrix<f64>,
    c: DMatrix<f64>,
    d: DMatrix<f64>,
}

impl LinearSystem {
    // 系统仿真
    fn simulate(&self, x0: &State, inputs: &[Input], dt: f64) -> Vec<State> {
        let mut states = Vec::new();
        let mut x = x0.clone();
        
        for u in inputs {
            // 欧拉法积分
            let dx = &self.a * &x + &self.b * u;
            x = &x + &(dx * dt);
            states.push(x.clone());
        }
        
        states
    }
    
    // 传递函数计算
    fn transfer_function(&self, s: Complex<f64>) -> Complex<f64> {
        let n = self.a.nrows();
        let s_matrix = DMatrix::identity(n, n) * s;
        let denominator = s_matrix - &self.a;
        
        if let Some(inv_denom) = denominator.try_inverse() {
            let numerator = &self.c * &inv_denom * &self.b;
            numerator[(0, 0)] + self.d[(0, 0)]
        } else {
            Complex::new(f64::INFINITY, 0.0)
        }
    }
    
    // 可控性检查
    fn is_controllable(&self) -> bool {
        let n = self.a.nrows();
        let mut controllability = DMatrix::zeros(n, n * self.b.ncols());
        
        for i in 0..n {
            let power = self.a.pow(i as u32);
            controllability.set_column(i * self.b.ncols(), &(&power * &self.b));
        }
        
        controllability.rank() == n
    }
    
    // 可观性检查
    fn is_observable(&self) -> bool {
        let n = self.a.nrows();
        let mut observability = DMatrix::zeros(n * self.c.nrows(), n);
        
        for i in 0..n {
            let power = self.a.pow(i as u32);
            observability.set_row(i * self.c.nrows(), &(&self.c * &power));
        }
        
        observability.rank() == n
    }
}

// PID控制器
#[derive(Clone, Debug)]
struct PIDController {
    kp: f64,
    ki: f64,
    kd: f64,
    integral: f64,
    previous_error: f64,
}

impl PIDController {
    fn new(kp: f64, ki: f64, kd: f64) -> Self {
        PIDController {
            kp,
            ki,
            kd,
            integral: 0.0,
            previous_error: 0.0,
        }
    }
    
    fn control(&mut self, error: f64, dt: f64) -> f64 {
        self.integral += error * dt;
        let derivative = (error - self.previous_error) / dt;
        
        let output = self.kp * error + self.ki * self.integral + self.kd * derivative;
        
        self.previous_error = error;
        output
    }
    
    fn reset(&mut self) {
        self.integral = 0.0;
        self.previous_error = 0.0;
    }
}

// 极点配置
fn pole_placement(sys: &LinearSystem, desired_poles: &[Complex<f64>]) -> Option<DVector<f64>> {
    if !sys.is_controllable() {
        return None;
    }
    
    // 计算期望特征多项式
    let desired_poly = polynomial_from_roots(desired_poles);
    
    // 计算反馈增益
    compute_feedback_gain(sys, &desired_poly)
}

// 观测器设计
fn observer_design(sys: &LinearSystem, desired_poles: &[Complex<f64>]) -> Option<DVector<f64>> {
    if !sys.is_observable() {
        return None;
    }
    
    // 计算期望特征多项式
    let desired_poly = polynomial_from_roots(desired_poles);
    
    // 计算观测器增益
    compute_observer_gain(sys, &desired_poly)
}

// LQR设计
fn lqr_design(sys: &LinearSystem, q: &DMatrix<f64>, r: &DMatrix<f64>) -> Option<DVector<f64>> {
    // 求解Riccati方程
    let p = solve_riccati_equation(sys, q, r)?;
    
    // 计算最优反馈增益
    let r_inv = r.try_inverse()?;
    let k = &r_inv * &sys.b.transpose() * &p;
    
    Some(k.column(0).clone_owned())
}

// Lyapunov稳定性检查
fn lyapunov_stability(a: &DMatrix<f64>) -> bool {
    let eigenvals = a.eigenvalues();
    eigenvals.iter().all(|&e| e.re < 0.0)
}

// 传递函数分析
fn frequency_response(sys: &LinearSystem, frequencies: &[f64]) -> Vec<Complex<f64>> {
    frequencies
        .iter()
        .map(|&f| {
            let s = Complex::new(0.0, 2.0 * std::f64::consts::PI * f);
            sys.transfer_function(s)
        })
        .collect()
}

// 根轨迹分析
fn root_locus(sys: &LinearSystem, k_range: &[f64]) -> Vec<Vec<Complex<f64>>> {
    k_range
        .iter()
        .map(|&k| {
            let closed_loop_a = &sys.a - &(&sys.b * k * &sys.c);
            closed_loop_a.eigenvalues().iter().cloned().collect()
        })
        .collect()
}
```

### 7.3 数值方法

**数值积分方法**:
```rust
// Runge-Kutta 4阶方法
fn rk4_step<F>(f: F, t: f64, x: &State, dt: f64) -> State
where
    F: Fn(f64, &State) -> State,
{
    let k1 = f(t, x);
    let k2 = f(t + dt/2.0, &(x + &(&k1 * dt/2.0)));
    let k3 = f(t + dt/2.0, &(x + &(&k2 * dt/2.0)));
    let k4 = f(t + dt, &(x + &(&k3 * dt)));
    
    x + &(&(&k1 + &(&k2 * 2.0) + &(&k3 * 2.0) + &k4) * (dt/6.0))
}

// 自适应步长控制
fn adaptive_step<F>(f: F, t: f64, x: &State, dt: f64, tol: f64) -> (State, f64)
where
    F: Fn(f64, &State) -> State,
{
    let x1 = rk4_step(&f, t, x, dt);
    let x2 = rk4_step(&f, t, x, dt/2.0);
    let x2 = rk4_step(&f, t + dt/2.0, &x2, dt/2.0);
    
    let error = (&x1 - &x2).norm();
    let new_dt = dt * (tol / error).powf(0.25);
    
    (x1, new_dt)
}
```

## 8. 应用实例

### 8.1 机械系统

**倒立摆控制**:
```rust
// 倒立摆系统建模
fn inverted_pendulum_system() -> LinearSystem {
    let m = 0.1; // 摆质量
    let M = 0.5; // 小车质量
    let l = 0.3; // 摆长
    let g = 9.81; // 重力加速度
    
    // 线性化后的系统矩阵
    let a = DMatrix::from_row_slice(4, 4, &[
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, -m*g/(M+m), 0.0,
        0.0, 0.0, 0.0, 1.0,
        0.0, 0.0, g/l, 0.0,
    ]);
    
    let b = DVector::from_column_slice(&[0.0, 1.0/(M+m), 0.0, -1.0/(l*(M+m))]);
    let c = DMatrix::identity(2, 4);
    let d = DMatrix::zeros(2, 1);
    
    LinearSystem { a, b, c, d }
}

// 倒立摆控制器设计
fn inverted_pendulum_controller() -> impl Fn(&State) -> f64 {
    let sys = inverted_pendulum_system();
    
    // 期望极点
    let desired_poles = vec![
        Complex::new(-2.0, 0.0),
        Complex::new(-2.0, 0.0),
        Complex::new(-3.0, 1.0),
        Complex::new(-3.0, -1.0),
    ];
    
    // 极点配置
    let k = pole_placement(&sys, &desired_poles).unwrap();
    
    move |x: &State| -> f64 {
        -k.dot(x)
    }
}
```

### 8.2 电气系统

**直流电机控制**:
```rust
// 直流电机系统建模
fn dc_motor_system() -> LinearSystem {
    let r = 1.0; // 电阻
    let l = 0.1; // 电感
    let j = 0.01; // 转动惯量
    let b = 0.1; // 阻尼系数
    let k = 0.1; // 电机常数
    
    // 状态: [电流, 角速度]
    let a = DMatrix::from_row_slice(2, 2, &[
        -r/l, -k/l,
        k/j, -b/j,
    ]);
    
    let b = DVector::from_column_slice(&[1.0/l, 0.0]);
    let c = DMatrix::identity(2, 2);
    let d = DMatrix::zeros(2, 1);
    
    LinearSystem { a, b, c, d }
}

// 速度控制器
fn speed_controller() -> PIDController {
    PIDController::new(10.0, 5.0, 0.1)
}
```

### 8.3 生物系统

**药物输注控制**:
```rust
// 药物动力学模型
fn drug_kinetics_system() -> LinearSystem {
    let k12 = 0.1; // 吸收速率
    let k21 = 0.05; // 消除速率
    let ke = 0.02; // 排泄速率
    
    // 状态: [中央室浓度, 外周室浓度]
    let a = DMatrix::from_row_slice(2, 2, &[
        -(k12 + ke), k21,
        k12, -k21,
    ]);
    
    let b = DVector::from_column_slice(&[1.0, 0.0]);
    let c = DMatrix::from_row_slice(1, 2, &[1.0, 0.0]);
    let d = DMatrix::zeros(1, 1);
    
    LinearSystem { a, b, c, d }
}

// 药物输注控制器
fn drug_infusion_controller(target_concentration: f64) -> impl Fn(f64) -> f64 {
    let mut pid = PIDController::new(0.1, 0.01, 0.001);
    
    move |current_concentration: f64| -> f64 {
        let error = target_concentration - current_concentration;
        pid.control(error, 0.1) // 采样时间0.1秒
    }
}
```

## 9. 参考文献

1. Ogata, K. (2010). *Modern Control Engineering*.
2. Franklin, G. F., Powell, J. D., & Emami-Naeini, A. (2015). *Feedback Control of Dynamic Systems*.
3. Åström, K. J., & Murray, R. M. (2021). *Feedback Systems: An Introduction for Scientists and Engineers*.
4. Khalil, H. K. (2015). *Nonlinear Systems*.
5. Skogestad, S., & Postlethwaite, I. (2005). *Multivariable Feedback Control: Analysis and Design*.

---

**相关链接**:
- [03.2 线性控制理论](03.2_Linear_Control_Theory.md)
- [03.3 非线性控制理论](03.3_Nonlinear_Control_Theory.md)
- [03.4 最优控制理论](03.4_Optimal_Control_Theory.md)
- [09.1 形式化模型基础](../09_Formal_Model_Theory/09.1_Formal_Model_Foundation.md)
- [06.7 分析学](../06_Mathematical_Foundation/06.7_Analysis.md)
