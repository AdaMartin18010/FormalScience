# 01.1.4 æœ¬ä½“è®ºæ¡†æ¶

## ğŸ“‹ æ¦‚è¿°

æœ¬ä½“è®ºæ¡†æ¶æ˜¯å½¢è€Œä¸Šå­¦çš„åŸºç¡€ç†è®ºï¼Œç ”ç©¶å­˜åœ¨çš„åŸºæœ¬ç»“æ„å’Œç»„ç»‡æ–¹å¼ã€‚æœ¬ä½“è®ºæ¢è®¨ä»€ä¹ˆæ˜¯å­˜åœ¨ã€ä»€ä¹ˆå­˜åœ¨ã€å¦‚ä½•å­˜åœ¨ç­‰æ ¹æœ¬é—®é¢˜ï¼Œä¸ºæ•´ä¸ªå“²å­¦ä½“ç³»æä¾›å­˜åœ¨è®ºåŸºç¡€ã€‚æœ¬ä½“è®ºæ¡†æ¶åŒ…æ‹¬å­˜åœ¨çš„åŸºæœ¬èŒƒç•´ã€å®ä½“åˆ†ç±»ã€å­˜åœ¨æ¨¡æ€å’Œæœ¬ä½“è®ºå…³ç³»ç­‰æ ¸å¿ƒå†…å®¹ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å­˜åœ¨ç»“æ„åˆ†æ**: åˆ†æå­˜åœ¨çš„åŸºæœ¬ç»“æ„å’Œç»„ç»‡æ–¹å¼
2. **æœ¬ä½“è®ºèŒƒç•´å»ºç«‹**: å»ºç«‹å­˜åœ¨çš„åŸºæœ¬èŒƒç•´ä½“ç³»
3. **å®ä½“åˆ†ç±»ç ”ç©¶**: ç ”ç©¶å®ä½“çš„åˆ†ç±»å’Œå±‚æ¬¡ç»“æ„
4. **å­˜åœ¨å…³ç³»æ¢è®¨**: æ¢è®¨å­˜åœ¨ä¹‹é—´çš„åŸºæœ¬å…³ç³»

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æœ¬ä½“è®ºçš„å®šä¹‰

**æœ¬ä½“è®º**æ˜¯ç ”ç©¶å­˜åœ¨æœ¬èº«åŠå…¶åŸºæœ¬ç»“æ„çš„å“²å­¦åˆ†æ”¯ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
è®¾ $O$ ä¸ºæœ¬ä½“è®ºç³»ç»Ÿï¼Œ$E$ ä¸ºå­˜åœ¨åŸŸï¼Œåˆ™ï¼š
$$O = \langle E, C, R, M \rangle$$

å…¶ä¸­ï¼š

- $E$: å­˜åœ¨åŸŸ (Domain of Existence)
- $C$: èŒƒç•´é›† (Categories)
- $R$: å…³ç³»é›† (Relations)
- $M$: æ¨¡æ€é›† (Modalities)

### 1.2 å­˜åœ¨çš„åŸºæœ¬èŒƒç•´

#### 1.2.1 å®ä½“ (Substance)

**å®šä¹‰**: å®ä½“æ˜¯ç‹¬ç«‹å­˜åœ¨çš„ã€ä¸ä¾èµ–å…¶ä»–äº‹ç‰©è€Œå­˜åœ¨çš„åŸºæœ¬å­˜åœ¨è€…ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$Substance(x) \iff \exists x \land \forall y (y \neq x \rightarrow \neg Depends(x, y))$$

#### 1.2.2 å±æ€§ (Property)

**å®šä¹‰**: å±æ€§æ˜¯ä¾é™„äºå®ä½“è€Œå­˜åœ¨çš„ç‰¹å¾æˆ–æ€§è´¨ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$Property(p) \iff \exists x (Substance(x) \land Inheres(p, x))$$

#### 1.2.3 å…³ç³» (Relation)

**å®šä¹‰**: å…³ç³»æ˜¯è¿æ¥ä¸¤ä¸ªæˆ–å¤šä¸ªå®ä½“çš„å­˜åœ¨è€…ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$Relation(r) \iff \exists x, y (Substance(x) \land Substance(y) \land Relates(r, x, y))$$

#### 1.2.4 äº‹ä»¶ (Event)

**å®šä¹‰**: äº‹ä»¶æ˜¯æ—¶é—´ä¸­çš„å˜åŒ–æˆ–è¿‡ç¨‹ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$Event(e) \iff \exists t_1, t_2 (t_1 < t_2 \land Occurs(e, t_1, t_2))$$

### 1.3 å­˜åœ¨æ¨¡æ€

#### 1.3.1 å¿…ç„¶å­˜åœ¨ (Necessary Existence)

**å®šä¹‰**: å¿…ç„¶å­˜åœ¨æ˜¯åœ¨æ‰€æœ‰å¯èƒ½ä¸–ç•Œä¸­éƒ½å­˜åœ¨çš„äº‹ç‰©ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\square \exists x \phi(x) \iff \forall w \in W (w \models \exists x \phi(x))$$

#### 1.3.2 å¶ç„¶å­˜åœ¨ (Contingent Existence)

**å®šä¹‰**: å¶ç„¶å­˜åœ¨æ˜¯åœ¨æŸäº›å¯èƒ½ä¸–ç•Œä¸­å­˜åœ¨ï¼Œåœ¨å¦ä¸€äº›ä¸­ä¸å­˜åœ¨çš„äº‹ç‰©ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\diamond \exists x \phi(x) \land \diamond \neg \exists x \phi(x)$$

#### 1.3.3 ä¸å¯èƒ½å­˜åœ¨ (Impossible Existence)

**å®šä¹‰**: ä¸å¯èƒ½å­˜åœ¨æ˜¯åœ¨ä»»ä½•å¯èƒ½ä¸–ç•Œä¸­éƒ½ä¸å­˜åœ¨çš„äº‹ç‰©ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
$$\square \neg \exists x \phi(x) \iff \forall w \in W (w \models \neg \exists x \phi(x))$$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æœ¬ä½“è®ºè¯­è¨€

**æœ¬ä½“è®ºè¯­è¨€** $\mathcal{L}_{Ont}$:

$$\mathcal{L}_{Ont} = \mathcal{L}_0 \cup \{Exists, Substance, Property, Relation, Event\} \cup \{Inheres, Relates, Occurs, Depends\}$$

å…¶ä¸­ $\mathcal{L}_0$ æ˜¯åŸºç¡€é€»è¾‘è¯­è¨€ã€‚

### 2.2 æœ¬ä½“è®ºæ¨¡å‹

**æœ¬ä½“è®ºæ¨¡å‹** $M = \langle W, D, I, R \rangle$:

- $W$: å¯èƒ½ä¸–ç•Œé›†åˆ
- $D$: åŸŸå‡½æ•°ï¼Œ$D: W \rightarrow 2^U$ï¼Œå…¶ä¸­ $U$ æ˜¯å…¨åŸŸ
- $I$: è§£é‡Šå‡½æ•°
- $R$: å¯åŠå…³ç³»

### 2.3 æœ¬ä½“è®ºè¯­ä¹‰

å¯¹äºä»»æ„ $w \in W$ å’Œå…¬å¼ $\phi$:

$$M, w \models Exists(x) \iff x \in D(w)$$
$$M, w \models Substance(x) \iff x \in I(Substance, w)$$
$$M, w \models Property(p) \iff p \in I(Property, w)$$
$$M, w \models Inheres(p, x) \iff (p, x) \in I(Inheres, w)$$

### 2.4 æœ¬ä½“è®ºå…¬ç†ç³»ç»Ÿ

**æœ¬ä½“è®ºå…¬ç†**:

1. **å­˜åœ¨å…¬ç†**: $\exists x Exists(x)$
2. **å®ä½“å…¬ç†**: $\forall x (Substance(x) \rightarrow Exists(x))$
3. **å±æ€§å…¬ç†**: $\forall p (Property(p) \rightarrow \exists x Inheres(p, x))$
4. **å…³ç³»å…¬ç†**: $\forall r (Relation(r) \rightarrow \exists x, y Relates(r, x, y))$
5. **ä¾èµ–å…¬ç†**: $\forall x, y (Depends(x, y) \rightarrow Exists(x) \land Exists(y))$

## 3. å®šç†ä¸è¯æ˜

### 3.1 å­˜åœ¨æ€§å®šç†

#### 3.1.1 å­˜åœ¨éç©ºå®šç†

**å®šç†**: å­˜åœ¨åŸŸéç©ºã€‚

**è¯æ˜**:

1. æ ¹æ®å­˜åœ¨å…¬ç†ï¼š$\exists x Exists(x)$
2. è¿™æ„å‘³ç€å­˜åœ¨æŸä¸ª $x$ ä½¿å¾— $Exists(x)$ ä¸ºçœŸ
3. å› æ­¤å­˜åœ¨åŸŸ $E$ éç©º

#### 3.1.2 å®ä½“å­˜åœ¨å®šç†

**å®šç†**: å¦‚æœ $x$ æ˜¯å®ä½“ï¼Œé‚£ä¹ˆ $x$ å­˜åœ¨ã€‚

**è¯æ˜**:

1. å‡è®¾ $Substance(x)$
2. æ ¹æ®å®ä½“å…¬ç†ï¼š$\forall x (Substance(x) \rightarrow Exists(x))$
3. åº”ç”¨å…¨ç§°å®ä¾‹åŒ–å¾—åˆ°ï¼š$Substance(x) \rightarrow Exists(x)$
4. ä»å‡è®¾å’Œè•´å«å¾—åˆ°ï¼š$Exists(x)$

#### 3.1.3 å±æ€§ä¾é™„å®šç†

**å®šç†**: å¦‚æœ $p$ æ˜¯å±æ€§ï¼Œé‚£ä¹ˆå­˜åœ¨æŸä¸ªå®ä½“ $x$ ä½¿å¾— $p$ ä¾é™„äº $x$ã€‚

**è¯æ˜**:

1. å‡è®¾ $Property(p)$
2. æ ¹æ®å±æ€§å…¬ç†ï¼š$\forall p (Property(p) \rightarrow \exists x Inheres(p, x))$
3. åº”ç”¨å…¨ç§°å®ä¾‹åŒ–å¾—åˆ°ï¼š$Property(p) \rightarrow \exists x Inheres(p, x)$
4. ä»å‡è®¾å’Œè•´å«å¾—åˆ°ï¼š$\exists x Inheres(p, x)$

### 3.2 æ¨¡æ€å­˜åœ¨å®šç†

#### 3.2.1 å¿…ç„¶å­˜åœ¨å®šç†

**å®šç†**: å¦‚æœ $x$ å¿…ç„¶å­˜åœ¨ï¼Œé‚£ä¹ˆ $x$ åœ¨æ‰€æœ‰å¯èƒ½ä¸–ç•Œä¸­éƒ½å­˜åœ¨ã€‚

**è¯æ˜**:

1. å‡è®¾ $\square \exists x \phi(x)$
2. æ ¹æ®å¿…ç„¶æ¨¡æ€çš„è¯­ä¹‰ï¼š$\forall w \in W (w \models \exists x \phi(x))$
3. è¿™æ„å‘³ç€åœ¨æ‰€æœ‰å¯èƒ½ä¸–ç•Œ $w$ ä¸­ï¼Œéƒ½å­˜åœ¨æŸä¸ª $x$ æ»¡è¶³ $\phi(x)$
4. å› æ­¤ $x$ åœ¨æ‰€æœ‰å¯èƒ½ä¸–ç•Œä¸­éƒ½å­˜åœ¨

#### 3.2.2 å¶ç„¶å­˜åœ¨å®šç†

**å®šç†**: å¦‚æœ $x$ å¶ç„¶å­˜åœ¨ï¼Œé‚£ä¹ˆ $x$ åœ¨æŸäº›å¯èƒ½ä¸–ç•Œä¸­å­˜åœ¨ï¼Œåœ¨å¦ä¸€äº›ä¸­ä¸å­˜åœ¨ã€‚

**è¯æ˜**:

1. å‡è®¾ $\diamond \exists x \phi(x) \land \diamond \neg \exists x \phi(x)$
2. æ ¹æ®å¯èƒ½æ¨¡æ€çš„è¯­ä¹‰ï¼š
   - $\exists w_1 \in W (w_1 \models \exists x \phi(x))$
   - $\exists w_2 \in W (w_2 \models \neg \exists x \phi(x))$
3. è¿™æ„å‘³ç€å­˜åœ¨ä¸–ç•Œ $w_1$ ä½¿å¾— $x$ å­˜åœ¨ï¼Œå­˜åœ¨ä¸–ç•Œ $w_2$ ä½¿å¾— $x$ ä¸å­˜åœ¨
4. å› æ­¤ $x$ æ˜¯å¶ç„¶å­˜åœ¨çš„

### 3.3 æœ¬ä½“è®ºå…³ç³»å®šç†

#### 3.3.1 ä¾èµ–ä¼ é€’å®šç†

**å®šç†**: å¦‚æœ $x$ ä¾èµ– $y$ï¼Œ$y$ ä¾èµ– $z$ï¼Œé‚£ä¹ˆ $x$ ä¾èµ– $z$ã€‚

**è¯æ˜**:

1. å‡è®¾ $Depends(x, y)$ ä¸” $Depends(y, z)$
2. æ ¹æ®ä¾èµ–çš„å®šä¹‰ï¼Œ$x$ çš„å­˜åœ¨éœ€è¦ $y$ çš„å­˜åœ¨
3. $y$ çš„å­˜åœ¨éœ€è¦ $z$ çš„å­˜åœ¨
4. å› æ­¤ $x$ çš„å­˜åœ¨éœ€è¦ $z$ çš„å­˜åœ¨
5. æ‰€ä»¥ $Depends(x, z)$

#### 3.3.2 å®ä½“ç‹¬ç«‹æ€§å®šç†

**å®šç†**: å®ä½“ä¸ä¾èµ–å…¶ä»–å®ä½“è€Œå­˜åœ¨ã€‚

**è¯æ˜**:

1. å‡è®¾ $Substance(x)$
2. æ ¹æ®å®ä½“çš„å®šä¹‰ï¼š$\forall y (y \neq x \rightarrow \neg Depends(x, y))$
3. è¿™æ„å‘³ç€å¯¹äºä»»ä½•ä¸ç­‰äº $x$ çš„ $y$ï¼Œ$x$ éƒ½ä¸ä¾èµ– $y$
4. å› æ­¤å®ä½“æ˜¯ç‹¬ç«‹å­˜åœ¨çš„

## 4. ä»£ç å®ç°

### 4.1 æœ¬ä½“è®ºç³»ç»Ÿå®ç° (Rust)

```rust
use std::collections::HashMap;
use std::collections::HashSet;

/// æœ¬ä½“è®ºç³»ç»Ÿ
pub struct OntologySystem {
    entities: HashMap<String, Entity>,
    categories: HashMap<String, Category>,
    relations: HashMap<String, Relation>,
    modalities: HashMap<String, Modality>,
    worlds: Vec<PossibleWorld>,
}

/// å®ä½“
#[derive(Debug, Clone, PartialEq)]
pub struct Entity {
    id: String,
    name: String,
    category: EntityCategory,
    properties: HashSet<String>,
    dependencies: HashSet<String>,
}

/// å®ä½“ç±»åˆ«
#[derive(Debug, Clone, PartialEq)]
pub enum EntityCategory {
    Substance,
    Property,
    Relation,
    Event,
}

/// èŒƒç•´
#[derive(Debug, Clone)]
pub struct Category {
    id: String,
    name: String,
    entities: HashSet<String>,
    parent_category: Option<String>,
}

/// å…³ç³»
#[derive(Debug, Clone)]
pub struct Relation {
    id: String,
    name: String,
    domain: Vec<String>,
    codomain: Vec<String>,
    properties: HashSet<RelationProperty>,
}

/// å…³ç³»æ€§è´¨
#[derive(Debug, Clone, PartialEq)]
pub enum RelationProperty {
    Reflexive,
    Symmetric,
    Transitive,
    Antisymmetric,
    Irreflexive,
}

/// æ¨¡æ€
#[derive(Debug, Clone, PartialEq)]
pub enum Modality {
    Necessary,
    Contingent,
    Impossible,
    Possible,
}

/// å¯èƒ½ä¸–ç•Œ
#[derive(Debug, Clone)]
pub struct PossibleWorld {
    id: String,
    name: String,
    entities: HashSet<String>,
    relations: HashSet<String>,
    accessibility: HashSet<String>, // å¯åŠçš„ä¸–ç•Œ
}

impl OntologySystem {
    /// åˆ›å»ºæ–°çš„æœ¬ä½“è®ºç³»ç»Ÿ
    pub fn new() -> Self {
        Self {
            entities: HashMap::new(),
            categories: HashMap::new(),
            relations: HashMap::new(),
            modalities: HashMap::new(),
            worlds: Vec::new(),
        }
    }

    /// æ·»åŠ å®ä½“
    pub fn add_entity(&mut self, entity: Entity) {
        self.entities.insert(entity.id.clone(), entity);
    }

    /// æ·»åŠ èŒƒç•´
    pub fn add_category(&mut self, category: Category) {
        self.categories.insert(category.id.clone(), category);
    }

    /// æ·»åŠ å…³ç³»
    pub fn add_relation(&mut self, relation: Relation) {
        self.relations.insert(relation.id.clone(), relation);
    }

    /// æ·»åŠ å¯èƒ½ä¸–ç•Œ
    pub fn add_world(&mut self, world: PossibleWorld) {
        self.worlds.push(world);
    }

    /// æ£€æŸ¥å®ä½“å­˜åœ¨
    pub fn entity_exists(&self, entity_id: &str) -> bool {
        self.entities.contains_key(entity_id)
    }

    /// æ£€æŸ¥å®ä½“ç±»åˆ«
    pub fn get_entity_category(&self, entity_id: &str) -> Option<&EntityCategory> {
        self.entities.get(entity_id).map(|e| &e.category)
    }

    /// æ£€æŸ¥å±æ€§ä¾é™„
    pub fn property_inheres(&self, property_id: &str, entity_id: &str) -> bool {
        if let Some(entity) = self.entities.get(entity_id) {
            entity.properties.contains(property_id)
        } else {
            false
        }
    }

    /// æ£€æŸ¥å…³ç³»è¿æ¥
    pub fn relation_relates(&self, relation_id: &str, entity1_id: &str, entity2_id: &str) -> bool {
        if let Some(relation) = self.relations.get(relation_id) {
            relation.domain.contains(&entity1_id.to_string()) && 
            relation.codomain.contains(&entity2_id.to_string())
        } else {
            false
        }
    }

    /// æ£€æŸ¥ä¾èµ–å…³ç³»
    pub fn entity_depends(&self, dependent_id: &str, dependency_id: &str) -> bool {
        if let Some(entity) = self.entities.get(dependent_id) {
            entity.dependencies.contains(dependency_id)
        } else {
            false
        }
    }

    /// æ£€æŸ¥å¿…ç„¶å­˜åœ¨
    pub fn necessarily_exists(&self, entity_id: &str) -> bool {
        self.worlds.iter().all(|world| world.entities.contains(entity_id))
    }

    /// æ£€æŸ¥å¶ç„¶å­˜åœ¨
    pub fn contingently_exists(&self, entity_id: &str) -> bool {
        let exists_in_some = self.worlds.iter().any(|world| world.entities.contains(entity_id));
        let exists_in_all = self.worlds.iter().all(|world| world.entities.contains(entity_id));
        exists_in_some && !exists_in_all
    }

    /// æ£€æŸ¥ä¸å¯èƒ½å­˜åœ¨
    pub fn impossibly_exists(&self, entity_id: &str) -> bool {
        self.worlds.iter().all(|world| !world.entities.contains(entity_id))
    }

    /// éªŒè¯æœ¬ä½“è®ºå…¬ç†
    pub fn verify_axioms(&self) -> HashMap<String, bool> {
        let mut results = HashMap::new();

        // å­˜åœ¨å…¬ç†ï¼šå­˜åœ¨è‡³å°‘ä¸€ä¸ªå®ä½“
        results.insert("existence_axiom".to_string(), !self.entities.is_empty());

        // å®ä½“å…¬ç†ï¼šæ‰€æœ‰å®ä½“éƒ½å­˜åœ¨
        let all_entities_exist = self.entities.values().all(|e| self.entity_exists(&e.id));
        results.insert("substance_axiom".to_string(), all_entities_exist);

        // å±æ€§å…¬ç†ï¼šæ‰€æœ‰å±æ€§éƒ½ä¾é™„äºæŸä¸ªå®ä½“
        let all_properties_inhere = self.entities.values()
            .filter(|e| e.category == EntityCategory::Property)
            .all(|p| {
                self.entities.values()
                    .any(|e| self.property_inheres(&p.id, &e.id))
            });
        results.insert("property_axiom".to_string(), all_properties_inhere);

        // å…³ç³»å…¬ç†ï¼šæ‰€æœ‰å…³ç³»éƒ½è¿æ¥å®ä½“
        let all_relations_relate = self.relations.values().all(|r| {
            !r.domain.is_empty() && !r.codomain.is_empty()
        });
        results.insert("relation_axiom".to_string(), all_relations_relate);

        // ä¾èµ–å…¬ç†ï¼šä¾èµ–å…³ç³»ä¸­çš„å®ä½“éƒ½å­˜åœ¨
        let all_dependencies_exist = self.entities.values().all(|e| {
            e.dependencies.iter().all(|dep_id| self.entity_exists(dep_id))
        });
        results.insert("dependency_axiom".to_string(), all_dependencies_exist);

        results
    }

    /// æœ¬ä½“è®ºæ¨ç†
    pub fn ontological_reasoning(&self) -> Vec<OntologicalInference> {
        let mut inferences = Vec::new();

        // æ¨ç†1ï¼šå®ä½“çš„ç‹¬ç«‹æ€§
        for entity in self.entities.values() {
            if entity.category == EntityCategory::Substance {
                let is_independent = entity.dependencies.is_empty();
                inferences.push(OntologicalInference::EntityIndependence(
                    entity.id.clone(),
                    is_independent
                ));
            }
        }

        // æ¨ç†2ï¼šå±æ€§çš„ä¾é™„æ€§
        for entity in self.entities.values() {
            if entity.category == EntityCategory::Property {
                let has_host = self.entities.values()
                    .any(|e| self.property_inheres(&entity.id, &e.id));
                inferences.push(OntologicalInference::PropertyInherence(
                    entity.id.clone(),
                    has_host
                ));
            }
        }

        // æ¨ç†3ï¼šæ¨¡æ€å­˜åœ¨æ€§
        for entity in self.entities.values() {
            let modality = if self.necessarily_exists(&entity.id) {
                Modality::Necessary
            } else if self.contingently_exists(&entity.id) {
                Modality::Contingent
            } else if self.impossibly_exists(&entity.id) {
                Modality::Impossible
            } else {
                Modality::Possible
            };
            inferences.push(OntologicalInference::ModalExistence(
                entity.id.clone(),
                modality
            ));
        }

        inferences
    }

    /// æœ¬ä½“è®ºåˆ†æ
    pub fn analyze_ontology(&self) -> OntologyAnalysis {
        let total_entities = self.entities.len();
        let substances = self.entities.values()
            .filter(|e| e.category == EntityCategory::Substance).count();
        let properties = self.entities.values()
            .filter(|e| e.category == EntityCategory::Property).count();
        let relations = self.entities.values()
            .filter(|e| e.category == EntityCategory::Relation).count();
        let events = self.entities.values()
            .filter(|e| e.category == EntityCategory::Event).count();

        let necessary_entities = self.entities.values()
            .filter(|e| self.necessarily_exists(&e.id)).count();
        let contingent_entities = self.entities.values()
            .filter(|e| self.contingently_exists(&e.id)).count();

        OntologyAnalysis {
            total_entities,
            substances,
            properties,
            relations,
            events,
            necessary_entities,
            contingent_entities,
            total_worlds: self.worlds.len(),
        }
    }
}

/// æœ¬ä½“è®ºæ¨ç†
#[derive(Debug)]
pub enum OntologicalInference {
    EntityIndependence(String, bool),
    PropertyInherence(String, bool),
    ModalExistence(String, Modality),
}

/// æœ¬ä½“è®ºåˆ†æ
#[derive(Debug)]
pub struct OntologyAnalysis {
    total_entities: usize,
    substances: usize,
    properties: usize,
    relations: usize,
    events: usize,
    necessary_entities: usize,
    contingent_entities: usize,
    total_worlds: usize,
}

/// æœ¬ä½“è®ºæŸ¥è¯¢ç³»ç»Ÿ
pub struct OntologyQuery {
    ontology: OntologySystem,
}

impl OntologyQuery {
    /// åˆ›å»ºæ–°çš„æŸ¥è¯¢ç³»ç»Ÿ
    pub fn new(ontology: OntologySystem) -> Self {
        Self { ontology }
    }

    /// æŸ¥è¯¢å®ä½“
    pub fn query_entity(&self, entity_id: &str) -> Option<&Entity> {
        self.ontology.entities.get(entity_id)
    }

    /// æŸ¥è¯¢èŒƒç•´
    pub fn query_category(&self, category_id: &str) -> Option<&Category> {
        self.ontology.categories.get(category_id)
    }

    /// æŸ¥è¯¢å…³ç³»
    pub fn query_relation(&self, relation_id: &str) -> Option<&Relation> {
        self.ontology.relations.get(relation_id)
    }

    /// æŸ¥è¯¢æ¨¡æ€
    pub fn query_modality(&self, entity_id: &str) -> Modality {
        if self.ontology.necessarily_exists(entity_id) {
            Modality::Necessary
        } else if self.ontology.contingently_exists(entity_id) {
            Modality::Contingent
        } else if self.ontology.impossibly_exists(entity_id) {
            Modality::Impossible
        } else {
            Modality::Possible
        }
    }

    /// å¤æ‚æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ‰€æœ‰ç‹¬ç«‹å®ä½“
    pub fn find_independent_entities(&self) -> Vec<&Entity> {
        self.ontology.entities.values()
            .filter(|e| e.category == EntityCategory::Substance && e.dependencies.is_empty())
            .collect()
    }

    /// å¤æ‚æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ‰€æœ‰å¿…ç„¶å­˜åœ¨çš„å®ä½“
    pub fn find_necessary_entities(&self) -> Vec<&Entity> {
        self.ontology.entities.values()
            .filter(|e| self.ontology.necessarily_exists(&e.id))
            .collect()
    }

    /// å¤æ‚æŸ¥è¯¢ï¼šæŸ¥æ‰¾æ‰€æœ‰ä¾é™„äºç‰¹å®šå®ä½“çš„å±æ€§
    pub fn find_properties_of_entity(&self, entity_id: &str) -> Vec<&Entity> {
        self.ontology.entities.values()
            .filter(|e| e.category == EntityCategory::Property && 
                       self.ontology.property_inheres(&e.id, entity_id))
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ontology_creation() {
        let mut ontology = OntologySystem::new();
        
        // åˆ›å»ºå®ä½“
        let substance = Entity {
            id: "s1".to_string(),
            name: "Socrates".to_string(),
            category: EntityCategory::Substance,
            properties: HashSet::new(),
            dependencies: HashSet::new(),
        };
        
        let property = Entity {
            id: "p1".to_string(),
            name: "wisdom".to_string(),
            category: EntityCategory::Property,
            properties: HashSet::new(),
            dependencies: HashSet::new(),
        };
        
        ontology.add_entity(substance);
        ontology.add_entity(property);
        
        assert!(ontology.entity_exists("s1"));
        assert!(ontology.entity_exists("p1"));
        assert_eq!(ontology.get_entity_category("s1"), Some(&EntityCategory::Substance));
        assert_eq!(ontology.get_entity_category("p1"), Some(&EntityCategory::Property));
    }

    #[test]
    fn test_modal_existence() {
        let mut ontology = OntologySystem::new();
        
        // åˆ›å»ºå¯èƒ½ä¸–ç•Œ
        let world1 = PossibleWorld {
            id: "w1".to_string(),
            name: "World 1".to_string(),
            entities: HashSet::from(["e1".to_string(), "e2".to_string()]),
            relations: HashSet::new(),
            accessibility: HashSet::new(),
        };
        
        let world2 = PossibleWorld {
            id: "w2".to_string(),
            name: "World 2".to_string(),
            entities: HashSet::from(["e1".to_string()]),
            relations: HashSet::new(),
            accessibility: HashSet::new(),
        };
        
        ontology.add_world(world1);
        ontology.add_world(world2);
        
        // e1åœ¨æ‰€æœ‰ä¸–ç•Œä¸­éƒ½å­˜åœ¨ï¼Œæ˜¯å¿…ç„¶å­˜åœ¨
        assert!(ontology.necessarily_exists("e1"));
        
        // e2åªåœ¨æŸäº›ä¸–ç•Œä¸­å­˜åœ¨ï¼Œæ˜¯å¶ç„¶å­˜åœ¨
        assert!(ontology.contingently_exists("e2"));
        
        // e3åœ¨ä»»ä½•ä¸–ç•Œä¸­éƒ½ä¸å­˜åœ¨ï¼Œæ˜¯ä¸å¯èƒ½å­˜åœ¨
        assert!(ontology.impossibly_exists("e3"));
    }

    #[test]
    fn test_axiom_verification() {
        let mut ontology = OntologySystem::new();
        
        // æ·»åŠ å®ä½“ä»¥æ»¡è¶³å…¬ç†
        let substance = Entity {
            id: "s1".to_string(),
            name: "Substance".to_string(),
            category: EntityCategory::Substance,
            properties: HashSet::new(),
            dependencies: HashSet::new(),
        };
        
        ontology.add_entity(substance);
        
        let axioms = ontology.verify_axioms();
        assert!(axioms["existence_axiom"]);
        assert!(axioms["substance_axiom"]);
    }
}
```

### 4.2 æœ¬ä½“è®ºç³»ç»Ÿå®ç° (Haskell)

```haskell
module OntologyFramework where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set

-- æœ¬ä½“è®ºç³»ç»Ÿæ•°æ®ç±»å‹
data OntologySystem = OntologySystem
    { entities :: Map String Entity
    , categories :: Map String Category
    , relations :: Map String Relation
    , modalities :: Map String Modality
    , worlds :: [PossibleWorld]
    }

-- å®ä½“
data Entity = Entity
    { entityId :: String
    , entityName :: String
    , entityCategory :: EntityCategory
    , entityProperties :: Set String
    , entityDependencies :: Set String
    }
    deriving (Eq, Ord, Show)

-- å®ä½“ç±»åˆ«
data EntityCategory
    = Substance
    | Property
    | Relation
    | Event
    deriving (Eq, Ord, Show)

-- èŒƒç•´
data Category = Category
    { categoryId :: String
    , categoryName :: String
    , categoryEntities :: Set String
    , parentCategory :: Maybe String
    }
    deriving (Eq, Ord, Show)

-- å…³ç³»
data Relation = Relation
    { relationId :: String
    , relationName :: String
    , relationDomain :: [String]
    , relationCodomain :: [String]
    , relationProperties :: Set RelationProperty
    }
    deriving (Eq, Ord, Show)

-- å…³ç³»æ€§è´¨
data RelationProperty
    = Reflexive
    | Symmetric
    | Transitive
    | Antisymmetric
    | Irreflexive
    deriving (Eq, Ord, Show)

-- æ¨¡æ€
data Modality
    = Necessary
    | Contingent
    | Impossible
    | Possible
    deriving (Eq, Ord, Show)

-- å¯èƒ½ä¸–ç•Œ
data PossibleWorld = PossibleWorld
    { worldId :: String
    , worldName :: String
    , worldEntities :: Set String
    , worldRelations :: Set String
    , accessibility :: Set String
    }
    deriving (Eq, Ord, Show)

-- åˆ›å»ºç©ºæœ¬ä½“è®ºç³»ç»Ÿ
emptyOntology :: OntologySystem
emptyOntology = OntologySystem
    { entities = Map.empty
    , categories = Map.empty
    , relations = Map.empty
    , modalities = Map.empty
    , worlds = []
    }

-- æ·»åŠ å®ä½“
addEntity :: Entity -> OntologySystem -> OntologySystem
addEntity entity ontology = ontology
    { entities = Map.insert (entityId entity) entity (entities ontology)
    }

-- æ·»åŠ èŒƒç•´
addCategory :: Category -> OntologySystem -> OntologySystem
addCategory category ontology = ontology
    { categories = Map.insert (categoryId category) category (categories ontology)
    }

-- æ·»åŠ å…³ç³»
addRelation :: Relation -> OntologySystem -> OntologySystem
addRelation relation ontology = ontology
    { relations = Map.insert (relationId relation) relation (relations ontology)
    }

-- æ·»åŠ å¯èƒ½ä¸–ç•Œ
addWorld :: PossibleWorld -> OntologySystem -> OntologySystem
addWorld world ontology = ontology
    { worlds = world : worlds ontology
    }

-- æ£€æŸ¥å®ä½“å­˜åœ¨
entityExists :: String -> OntologySystem -> Bool
entityExists entityId ontology = Map.member entityId (entities ontology)

-- è·å–å®ä½“ç±»åˆ«
getEntityCategory :: String -> OntologySystem -> Maybe EntityCategory
getEntityCategory entityId ontology = entityCategory <$> Map.lookup entityId (entities ontology)

-- æ£€æŸ¥å±æ€§ä¾é™„
propertyInheres :: String -> String -> OntologySystem -> Bool
propertyInheres propertyId entityId ontology = case Map.lookup entityId (entities ontology) of
    Just entity -> propertyId `Set.member` entityProperties entity
    Nothing -> False

-- æ£€æŸ¥å…³ç³»è¿æ¥
relationRelates :: String -> String -> String -> OntologySystem -> Bool
relationRelates relationId entity1Id entity2Id ontology = case Map.lookup relationId (relations ontology) of
    Just relation -> entity1Id `elem` relationDomain relation && entity2Id `elem` relationCodomain relation
    Nothing -> False

-- æ£€æŸ¥ä¾èµ–å…³ç³»
entityDepends :: String -> String -> OntologySystem -> Bool
entityDepends dependentId dependencyId ontology = case Map.lookup dependentId (entities ontology) of
    Just entity -> dependencyId `Set.member` entityDependencies entity
    Nothing -> False

-- æ£€æŸ¥å¿…ç„¶å­˜åœ¨
necessarilyExists :: String -> OntologySystem -> Bool
necessarilyExists entityId ontology = all (\world -> entityId `Set.member` worldEntities world) (worlds ontology)

-- æ£€æŸ¥å¶ç„¶å­˜åœ¨
contingentlyExists :: String -> OntologySystem -> Bool
contingentlyExists entityId ontology = 
    let existsInSome = any (\world -> entityId `Set.member` worldEntities world) (worlds ontology)
        existsInAll = necessarilyExists entityId ontology
    in existsInSome && not existsInAll

-- æ£€æŸ¥ä¸å¯èƒ½å­˜åœ¨
impossiblyExists :: String -> OntologySystem -> Bool
impossiblyExists entityId ontology = all (\world -> entityId `Set.notMember` worldEntities world) (worlds ontology)

-- éªŒè¯æœ¬ä½“è®ºå…¬ç†
verifyAxioms :: OntologySystem -> Map String Bool
verifyAxioms ontology = Map.fromList
    [ ("existence_axiom", not (Map.null (entities ontology)))
    , ("substance_axiom", all (\entity -> entityExists (entityId entity) ontology) (Map.elems (entities ontology)))
    , ("property_axiom", all (\entity -> 
        entityCategory entity == Property -> 
        any (\e -> propertyInheres (entityId entity) (entityId e) ontology) (Map.elems (entities ontology))) 
        (Map.elems (entities ontology)))
    , ("relation_axiom", all (\relation -> 
        not (null (relationDomain relation)) && not (null (relationCodomain relation))) 
        (Map.elems (relations ontology)))
    , ("dependency_axiom", all (\entity -> 
        all (\depId -> entityExists depId ontology) (entityDependencies entity)) 
        (Map.elems (entities ontology)))
    ]

-- æœ¬ä½“è®ºæ¨ç†
ontologicalReasoning :: OntologySystem -> [OntologicalInference]
ontologicalReasoning ontology = 
    entityIndependenceInferences ++ propertyInherenceInferences ++ modalExistenceInferences
  where
    entityIndependenceInferences = 
        [ EntityIndependence (entityId entity) (Set.null (entityDependencies entity))
        | entity <- Map.elems (entities ontology)
        , entityCategory entity == Substance
        ]
    
    propertyInherenceInferences = 
        [ PropertyInherence (entityId entity) 
            (any (\e -> propertyInheres (entityId entity) (entityId e) ontology) (Map.elems (entities ontology)))
        | entity <- Map.elems (entities ontology)
        , entityCategory entity == Property
        ]
    
    modalExistenceInferences = 
        [ ModalExistence (entityId entity) (getModality entityId ontology)
        | entity <- Map.elems (entities ontology)
        ]
      where
        entityId = entityId entity
        getModality id ontology
            | necessarilyExists id ontology = Necessary
            | contingentlyExists id ontology = Contingent
            | impossiblyExists id ontology = Impossible
            | otherwise = Possible

-- æœ¬ä½“è®ºæ¨ç†ç±»å‹
data OntologicalInference
    = EntityIndependence String Bool
    | PropertyInherence String Bool
    | ModalExistence String Modality
    deriving (Eq, Ord, Show)

-- æœ¬ä½“è®ºåˆ†æ
analyzeOntology :: OntologySystem -> OntologyAnalysis
analyzeOntology ontology = OntologyAnalysis
    { totalEntities = Map.size (entities ontology)
    , substances = length [() | entity <- Map.elems (entities ontology), entityCategory entity == Substance]
    , properties = length [() | entity <- Map.elems (entities ontology), entityCategory entity == Property]
    , relations = length [() | entity <- Map.elems (entities ontology), entityCategory entity == Relation]
    , events = length [() | entity <- Map.elems (entities ontology), entityCategory entity == Event]
    , necessaryEntities = length [() | entity <- Map.elems (entities ontology), necessarilyExists (entityId entity) ontology]
    , contingentEntities = length [() | entity <- Map.elems (entities ontology), contingentlyExists (entityId entity) ontology]
    , totalWorlds = length (worlds ontology)
    }

data OntologyAnalysis = OntologyAnalysis
    { totalEntities :: Int
    , substances :: Int
    , properties :: Int
    , relations :: Int
    , events :: Int
    , necessaryEntities :: Int
    , contingentEntities :: Int
    , totalWorlds :: Int
    }
    deriving (Eq, Ord, Show)

-- æœ¬ä½“è®ºæŸ¥è¯¢
data OntologyQuery = OntologyQuery
    { ontology :: OntologySystem
    }

-- åˆ›å»ºæŸ¥è¯¢ç³»ç»Ÿ
createQuery :: OntologySystem -> OntologyQuery
createQuery = OntologyQuery

-- æŸ¥è¯¢å®ä½“
queryEntity :: String -> OntologyQuery -> Maybe Entity
queryEntity entityId query = Map.lookup entityId (entities (ontology query))

-- æŸ¥è¯¢æ¨¡æ€
queryModality :: String -> OntologyQuery -> Modality
queryModality entityId query = 
    let ont = ontology query
    in if necessarilyExists entityId ont then Necessary
       else if contingentlyExists entityId ont then Contingent
       else if impossiblyExists entityId ont then Impossible
       else Possible

-- æŸ¥æ‰¾ç‹¬ç«‹å®ä½“
findIndependentEntities :: OntologyQuery -> [Entity]
findIndependentEntities query = 
    [ entity | entity <- Map.elems (entities (ontology query))
    , entityCategory entity == Substance
    , Set.null (entityDependencies entity)
    ]

-- æŸ¥æ‰¾å¿…ç„¶å­˜åœ¨çš„å®ä½“
findNecessaryEntities :: OntologyQuery -> [Entity]
findNecessaryEntities query = 
    [ entity | entity <- Map.elems (entities (ontology query))
    , necessarilyExists (entityId entity) (ontology query)
    ]

-- æœ¬ä½“è®ºç¤ºä¾‹
ontologyExample :: IO ()
ontologyExample = do
    let ontology = emptyOntology
        
        -- åˆ›å»ºå®ä½“
        socrates = Entity "s1" "Socrates" Substance Set.empty Set.empty
        wisdom = Entity "p1" "wisdom" Property Set.empty Set.empty
        
        -- åˆ›å»ºå¯èƒ½ä¸–ç•Œ
        world1 = PossibleWorld "w1" "World 1" (Set.fromList ["s1", "p1"]) Set.empty Set.empty
        world2 = PossibleWorld "w2" "World 2" (Set.fromList ["s1"]) Set.empty Set.empty
        
        -- æ„å»ºæœ¬ä½“è®ºç³»ç»Ÿ
        ontology' = addEntity socrates ontology
        ontology'' = addEntity wisdom ontology'
        ontology''' = addWorld world1 ontology''
        finalOntology = addWorld world2 ontology'''
        
        -- åˆ†æ
        analysis = analyzeOntology finalOntology
        axioms = verifyAxioms finalOntology
        inferences = ontologicalReasoning finalOntology
    
    putStrLn "Ontology Framework Example:"
    putStrLn $ "Analysis: " ++ show analysis
    putStrLn $ "Axioms: " ++ show axioms
    putStrLn $ "Inferences: " ++ show (take 3 inferences)
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å“²å­¦æœ¬ä½“è®ºç³»ç»Ÿ

```rust
// å“²å­¦æœ¬ä½“è®ºç³»ç»Ÿç¤ºä¾‹
fn philosophical_ontology_system() {
    let mut ontology = OntologySystem::new();
    
    // åˆ›å»ºå“²å­¦å®ä½“
    let god = Entity {
        id: "god".to_string(),
        name: "God".to_string(),
        category: EntityCategory::Substance,
        properties: HashSet::from(["omnipotent".to_string(), "omniscient".to_string()]),
        dependencies: HashSet::new(),
    };
    
    let soul = Entity {
        id: "soul".to_string(),
        name: "Soul".to_string(),
        category: EntityCategory::Substance,
        properties: HashSet::new(),
        dependencies: HashSet::new(),
    };
    
    let consciousness = Entity {
        id: "consciousness".to_string(),
        name: "Consciousness".to_string(),
        category: EntityCategory::Property,
        properties: HashSet::new(),
        dependencies: HashSet::from(["soul".to_string()]),
    };
    
    ontology.add_entity(god);
    ontology.add_entity(soul);
    ontology.add_entity(consciousness);
    
    // åˆ›å»ºå¯èƒ½ä¸–ç•Œ
    let actual_world = PossibleWorld {
        id: "actual".to_string(),
        name: "Actual World".to_string(),
        entities: HashSet::from(["god".to_string(), "soul".to_string(), "consciousness".to_string()]),
        relations: HashSet::new(),
        accessibility: HashSet::new(),
    };
    
    let possible_world = PossibleWorld {
        id: "possible".to_string(),
        name: "Possible World".to_string(),
        entities: HashSet::from(["god".to_string()]),
        relations: HashSet::new(),
        accessibility: HashSet::new(),
    };
    
    ontology.add_world(actual_world);
    ontology.add_world(possible_world);
    
    // åˆ†æ
    let analysis = ontology.analyze_ontology();
    println!("Philosophical Ontology Analysis: {:?}", analysis);
    
    // éªŒè¯å…¬ç†
    let axioms = ontology.verify_axioms();
    println!("Axiom Verification: {:?}", axioms);
    
    // æ¨¡æ€åˆ†æ
    println!("God necessarily exists: {}", ontology.necessarily_exists("god"));
    println!("Soul contingently exists: {}", ontology.contingently_exists("soul"));
}
```

### 5.2 ç§‘å­¦æœ¬ä½“è®ºç³»ç»Ÿ

```haskell
-- ç§‘å­¦æœ¬ä½“è®ºç³»ç»Ÿç¤ºä¾‹
scientificOntologyExample :: IO ()
scientificOntologyExample = do
    let ontology = emptyOntology
        
        -- åˆ›å»ºç§‘å­¦å®ä½“
        electron = Entity "electron" "Electron" Substance Set.empty Set.empty
        mass = Entity "mass" "Mass" Property Set.empty Set.empty
        charge = Entity "charge" "Charge" Property Set.empty Set.empty
        interaction = Entity "interaction" "Interaction" Relation Set.empty Set.empty
        
        -- åˆ›å»ºå¯èƒ½ä¸–ç•Œï¼ˆä¸åŒçš„ç‰©ç†å®šå¾‹ï¼‰
        newtonianWorld = PossibleWorld "newtonian" "Newtonian World" 
            (Set.fromList ["electron", "mass"]) Set.empty Set.empty
        quantumWorld = PossibleWorld "quantum" "Quantum World" 
            (Set.fromList ["electron", "mass", "charge", "interaction"]) Set.empty Set.empty
        
        -- æ„å»ºç³»ç»Ÿ
        ontology' = foldr addEntity ontology [electron, mass, charge, interaction]
        ontology'' = foldr addWorld ontology' [newtonianWorld, quantumWorld]
        
        -- åˆ†æ
        analysis = analyzeOntology ontology''
        axioms = verifyAxioms ontology''
        query = createQuery ontology''
        
        -- æŸ¥è¯¢
        necessaryEntities = findNecessaryEntities query
        independentEntities = findIndependentEntities query
    
    putStrLn "Scientific Ontology Example:"
    putStrLn $ "Analysis: " ++ show analysis
    putStrLn $ "Axioms: " ++ show axioms
    putStrLn $ "Necessary entities: " ++ show (map entityName necessaryEntities)
    putStrLn $ "Independent entities: " ++ show (map entityName independentEntities)
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å½¢è€Œä¸Šå­¦çš„å…³ç³»

æœ¬ä½“è®ºæ˜¯å½¢è€Œä¸Šå­¦çš„æ ¸å¿ƒï¼š

- **å­˜åœ¨è®º**: æœ¬ä½“è®ºç ”ç©¶å­˜åœ¨æœ¬èº«
- **å®ä½“è®º**: æœ¬ä½“è®ºç ”ç©¶å®ä½“çš„æœ¬è´¨
- **èŒƒç•´è®º**: æœ¬ä½“è®ºå»ºç«‹å­˜åœ¨çš„åŸºæœ¬èŒƒç•´

### 6.2 ä¸è®¤è¯†è®ºçš„å…³ç³»

æœ¬ä½“è®ºä¸ºè®¤è¯†è®ºæä¾›åŸºç¡€ï¼š

- **å­˜åœ¨ä¸è®¤è¯†**: æœ¬ä½“è®ºç¡®å®šä»€ä¹ˆå­˜åœ¨ï¼Œè®¤è¯†è®ºç ”ç©¶å¦‚ä½•è®¤è¯†
- **å®åœ¨è®º**: æœ¬ä½“è®ºçš„å®åœ¨è®ºç«‹åœºå½±å“è®¤è¯†è®º
- **çœŸç†ç†è®º**: æœ¬ä½“è®ºä¸ºçœŸç†ç†è®ºæä¾›å­˜åœ¨åŸºç¡€

### 6.3 ä¸é€»è¾‘å­¦çš„å…³ç³»

æœ¬ä½“è®ºä¸é€»è¾‘å­¦ç›¸äº’æ”¯æŒï¼š

- **å½¢å¼åŒ–**: é€»è¾‘å­¦ä¸ºæœ¬ä½“è®ºæä¾›å½¢å¼åŒ–å·¥å…·
- **æ¨¡æ€é€»è¾‘**: æ¨¡æ€é€»è¾‘å¤„ç†å­˜åœ¨æ¨¡æ€
- **èŒƒç•´é€»è¾‘**: èŒƒç•´é€»è¾‘å¤„ç†æœ¬ä½“è®ºèŒƒç•´

## 7. å‚è€ƒæ–‡çŒ®

1. **Quine, W. V. O.** (1948). "On What There Is". *Review of Metaphysics*.
2. **Carnap, R.** (1950). "Empiricism, Semantics, and Ontology". *Revue Internationale de Philosophie*.
3. **Strawson, P. F.** (1959). *Individuals: An Essay in Descriptive Metaphysics*. Methuen.
4. **Kripke, S. A.** (1980). *Naming and Necessity*. Harvard University Press.
5. **Lewis, D.** (1986). *On the Plurality of Worlds*. Blackwell.
6. **Armstrong, D. M.** (1997). *A World of States of Affairs*. Cambridge University Press.
7. **Lowe, E. J.** (2006). *The Four-Category Ontology: A Metaphysical Foundation for Natural Science*. Oxford University Press.

---

**ç›¸å…³æ–‡æ¡£**:

- [01.1.1 å­˜åœ¨ç†è®º](../01.1.1_å­˜åœ¨ç†è®º.md)
- [01.1.2 å®ä½“ç†è®º](../01.1.2_å®ä½“ç†è®º.md)
- [01.1.3 æ¨¡æ€ç†è®º](../01.1.3_æ¨¡æ€ç†è®º.md)
- [01.3.2 å®ä½“åˆ†ç±»](../01.3.2_å®ä½“åˆ†ç±».md)
