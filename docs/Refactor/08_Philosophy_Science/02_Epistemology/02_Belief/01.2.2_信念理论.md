# 01.2.2 ä¿¡å¿µç†è®º

## ğŸ“‹ æ¦‚è¿°

ä¿¡å¿µç†è®ºæ˜¯è®¤è¯†è®ºä¸­ç ”ç©¶ä¿¡å¿µæœ¬è´¨ã€ç»“æ„ã€å½¢æˆå’Œç¡®è¯çš„æ ¸å¿ƒç†è®ºã€‚å®ƒæ¢è®¨ä»€ä¹ˆæ˜¯ä¿¡å¿µã€ä¿¡å¿µå¦‚ä½•å½¢æˆã€ä¿¡å¿µçš„åˆç†æ€§ç­‰é—®é¢˜ï¼Œä¸ºç†è§£äººç±»è®¤çŸ¥æ´»åŠ¨ä¸­çš„ä¿¡å¿µç³»ç»Ÿæä¾›å“²å­¦åŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹ä¿¡å¿µæ¦‚å¿µçš„å½¢å¼åŒ–ä½“ç³»**
2. **åˆ†æä¿¡å¿µçš„æœ¬è´¨ç‰¹å¾å’Œæ¡ä»¶**
3. **æ¢è®¨ä¿¡å¿µçš„å½¢æˆå’Œå˜åŒ–æœºåˆ¶**
4. **æ„å»ºä¿¡å¿µç¡®è¯çš„ç†è®ºæ¡†æ¶**
5. **ç ”ç©¶ä¿¡å¿µæ¨ç†çš„æœ‰æ•ˆæ€§**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ä¿¡å¿µæ¦‚å¿µ

**å®šä¹‰ 1.1.1** (ä¿¡å¿µ)
ä¿¡å¿µæ˜¯æŒ‡ä¸»ä½“å¯¹æŸä¸ªå‘½é¢˜æˆ–é™ˆè¿°çš„å¿ƒç†æ€åº¦ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š

- **å‘½é¢˜æ€§**: ä¿¡å¿µæ€»æ˜¯å…³äºæŸä¸ªå‘½é¢˜çš„
- **å¿ƒç†æ€§**: ä¿¡å¿µæ˜¯ä¸€ç§å¿ƒç†çŠ¶æ€
- **æ„å‘æ€§**: ä¿¡å¿µå…·æœ‰æŒ‡å‘æ€§ï¼ŒæŒ‡å‘æŸä¸ªå†…å®¹
- **æŒä¹…æ€§**: ä¿¡å¿µå…·æœ‰ä¸€å®šçš„ç¨³å®šæ€§

### 1.2 ä¿¡å¿µç±»å‹

**å®šä¹‰ 1.1.2** (ä¿¡å¿µç±»å‹åˆ†ç±»)
ä¿¡å¿µå¯ä»¥åˆ†ä¸ºä»¥ä¸‹ç±»å‹ï¼š

1. **æè¿°æ€§ä¿¡å¿µ**: å…³äºäº‹å®çš„ä¿¡å¿µ
2. **è§„èŒƒæ€§ä¿¡å¿µ**: å…³äºåº”è¯¥åšä»€ä¹ˆçš„ä¿¡å¿µ
3. **å·¥å…·æ€§ä¿¡å¿µ**: å…³äºæ‰‹æ®µå’Œç›®çš„çš„ä¿¡å¿µ
4. **åŸºç¡€ä¿¡å¿µ**: ä¸éœ€è¦å…¶ä»–ä¿¡å¿µæ”¯æŒçš„ä¿¡å¿µ
5. **æ´¾ç”Ÿä¿¡å¿µ**: åŸºäºå…¶ä»–ä¿¡å¿µæ¨ç†å¾—å‡ºçš„ä¿¡å¿µ

### 1.3 ä¿¡å¿µç¨‹åº¦

**å®šä¹‰ 1.1.3** (ä¿¡å¿µç¨‹åº¦)
ä¿¡å¿µå¯ä»¥æœ‰ä¸åŒçš„ç¡®ä¿¡ç¨‹åº¦ï¼š

- **ç¡®å®šæ€§ä¿¡å¿µ**: å®Œå…¨ç¡®ä¿¡çš„ä¿¡å¿µ
- **é«˜åº¦ç¡®ä¿¡ä¿¡å¿µ**: é«˜åº¦ç¡®ä¿¡ä½†ä¸å®Œå…¨ç¡®å®šçš„ä¿¡å¿µ
- **ä¸­ç­‰ç¡®ä¿¡ä¿¡å¿µ**: ä¸­ç­‰ç¨‹åº¦çš„ä¿¡å¿µ
- **ä½åº¦ç¡®ä¿¡ä¿¡å¿µ**: ä½åº¦ç¡®ä¿¡çš„ä¿¡å¿µ
- **æ€€ç–‘**: å¯¹ä¿¡å¿µçš„æ€€ç–‘æ€åº¦

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ä¿¡å¿µé€»è¾‘è¯­è¨€

**å®šä¹‰ 1.2.1** (ä¿¡å¿µé€»è¾‘è¯­è¨€)
ä¿¡å¿µé€»è¾‘è¯­è¨€ $\mathcal{L}_B$ ç”±ä»¥ä¸‹éƒ¨åˆ†ç»„æˆï¼š

1. **ä¸»ä½“å˜å…ƒ**: $a_1, a_2, a_3, \ldots \in \mathcal{A}$
2. **å‘½é¢˜å˜å…ƒ**: $p, q, r, \ldots \in \mathcal{P}$
3. **ä¿¡å¿µç®—å­**: $B_a$ (ä¸»ä½“aç›¸ä¿¡)
4. **ä¿¡å¿µç¨‹åº¦ç®—å­**: $B_a^r$ (ä¸»ä½“aä»¥ç¨‹åº¦rç›¸ä¿¡)
5. **é€»è¾‘è¿æ¥è¯**: $\neg, \land, \lor, \rightarrow, \leftrightarrow$

**è¯­æ³•è§„åˆ™**:

- å¦‚æœ $p \in \mathcal{P}$ï¼Œåˆ™ $p$ æ˜¯å…¬å¼
- å¦‚æœ $\varphi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\neg\varphi$ æ˜¯å…¬å¼
- å¦‚æœ $\varphi, \psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $(\varphi \land \psi), (\varphi \lor \psi), (\varphi \rightarrow \psi), (\varphi \leftrightarrow \psi)$ æ˜¯å…¬å¼
- å¦‚æœ $\varphi$ æ˜¯å…¬å¼ä¸” $a \in \mathcal{A}$ï¼Œåˆ™ $B_a\varphi$ æ˜¯å…¬å¼
- å¦‚æœ $\varphi$ æ˜¯å…¬å¼ï¼Œ$a \in \mathcal{A}$ï¼Œä¸” $r \in [0,1]$ï¼Œåˆ™ $B_a^r\varphi$ æ˜¯å…¬å¼

### 2.2 ä¿¡å¿µè¯­ä¹‰

**å®šä¹‰ 1.2.2** (ä¿¡å¿µæ¨¡å‹)
ä¿¡å¿µæ¨¡å‹æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $\mathcal{B} = (W, \sim_a, V, \mu_a, \mathcal{E})$ï¼Œå…¶ä¸­ï¼š

- $W$ æ˜¯éç©ºçš„ä¸–ç•Œé›†åˆ
- $\sim_a \subseteq W \times W$ æ˜¯ä¸»ä½“açš„ä¿¡å¿µå¯è¾¾å…³ç³»
- $V: \mathcal{P} \rightarrow 2^W$ æ˜¯å‘½é¢˜èµ‹å€¼å‡½æ•°
- $\mu_a: W \times \mathcal{P} \rightarrow [0,1]$ æ˜¯ä¿¡å¿µåº¦å‡½æ•°
- $\mathcal{E}: \mathcal{A} \times W \rightarrow 2^{\mathcal{P}}$ æ˜¯è¯æ®å‡½æ•°

**å®šä¹‰ 1.2.3** (ä¿¡å¿µå…¬å¼çš„çœŸå€¼)
ç»™å®šä¿¡å¿µæ¨¡å‹ $\mathcal{B} = (W, \sim_a, V, \mu_a, \mathcal{E})$ å’Œä¸–ç•Œ $w \in W$ï¼Œä¿¡å¿µå…¬å¼çš„çœŸå€¼å®šä¹‰å¦‚ä¸‹ï¼š

1. $\mathcal{B}, w \models p$ å½“ä¸”ä»…å½“ $w \in V(p)$
2. $\mathcal{B}, w \models \neg\varphi$ å½“ä¸”ä»…å½“ $\mathcal{B}, w \not\models \varphi$
3. $\mathcal{B}, w \models \varphi \land \psi$ å½“ä¸”ä»…å½“ $\mathcal{B}, w \models \varphi$ ä¸” $\mathcal{B}, w \models \psi$
4. $\mathcal{B}, w \models \varphi \lor \psi$ å½“ä¸”ä»…å½“ $\mathcal{B}, w \models \varphi$ æˆ– $\mathcal{B}, w \models \psi$
5. $\mathcal{B}, w \models \varphi \rightarrow \psi$ å½“ä¸”ä»…å½“ $\mathcal{B}, w \not\models \varphi$ æˆ– $\mathcal{B}, w \models \psi$
6. $\mathcal{B}, w \models B_a\varphi$ å½“ä¸”ä»…å½“ å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{B}, v \models \varphi$
7. $\mathcal{B}, w \models B_a^r\varphi$ å½“ä¸”ä»…å½“ $\mu_a(w, \varphi) = r$

### 2.3 ä¿¡å¿µæ›´æ–°

**å®šä¹‰ 1.2.4** (ä¿¡å¿µæ›´æ–°)
ä¿¡å¿µæ›´æ–°æ˜¯æŒ‡ä¸»ä½“æ ¹æ®æ–°ä¿¡æ¯è°ƒæ•´å…¶ä¿¡å¿µçš„è¿‡ç¨‹ã€‚

ç»™å®šä¿¡å¿µæ¨¡å‹ $\mathcal{B}$ å’Œæ–°ä¿¡æ¯ $\varphi$ï¼Œæ›´æ–°åçš„ä¿¡å¿µæ¨¡å‹ $\mathcal{B}[\varphi]$ å®šä¹‰ä¸ºï¼š

- $W[\varphi] = \{w \in W : \mathcal{B}, w \models \varphi\}$
- $\sim_a[\varphi] = \sim_a \cap (W[\varphi] \times W[\varphi])$
- $V[\varphi] = V \cap W[\varphi]$
- $\mu_a[\varphi](w, \psi) = \frac{\mu_a(w, \psi \land \varphi)}{\mu_a(w, \varphi)}$

## 3. å®šç†ä¸è¯æ˜

### 3.1 ä¿¡å¿µå…¬ç†

**å®šç† 1.3.1** (ä¿¡å¿µå…¬ç†)
ä¿¡å¿µç®—å­æ»¡è¶³ä»¥ä¸‹å…¬ç†ï¼š

1. **ä¸€è‡´æ€§**: $\neg B_a \bot$ (ä¸»ä½“ä¸ç›¸ä¿¡çŸ›ç›¾)
2. **æ­£å†…çœ**: $B_a \varphi \rightarrow B_a B_a \varphi$
3. **è´Ÿå†…çœ**: $\neg B_a \varphi \rightarrow B_a \neg B_a \varphi$
4. **åˆ†é…å¾‹**: $B_a(\varphi \rightarrow \psi) \rightarrow (B_a \varphi \rightarrow B_a \psi)$

**è¯æ˜**:
è®¾ $\mathcal{B} = (W, \sim_a, V, \mu_a, \mathcal{E})$ æ˜¯ä¿¡å¿µæ¨¡å‹ï¼Œ$w \in W$ æ˜¯ä»»æ„ä¸–ç•Œã€‚

1. è¯æ˜ä¸€è‡´æ€§ $\neg B_a \bot$:
   - å‡è®¾ $\mathcal{B}, w \models B_a \bot$
   - è¿™æ„å‘³ç€å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{B}, v \models \bot$
   - ä½† $\bot$ åœ¨æ‰€æœ‰ä¸–ç•Œä¸­éƒ½ä¸ºå‡ï¼ŒçŸ›ç›¾
   - å› æ­¤ $\mathcal{B}, w \models \neg B_a \bot$

2. è¯æ˜æ­£å†…çœ $B_a \varphi \rightarrow B_a B_a \varphi$:
   - å‡è®¾ $\mathcal{B}, w \models B_a \varphi$
   - è¿™æ„å‘³ç€å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{B}, v \models \varphi$
   - ç”±äº $\sim_a$ æ˜¯ä¼ é€’çš„ï¼Œå¯¹æ‰€æœ‰ $u$ ä½¿å¾— $v \sim_a u$ï¼Œæœ‰ $\mathcal{B}, u \models \varphi$
   - å› æ­¤ $\mathcal{B}, v \models B_a \varphi$ å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ æˆç«‹
   - æ‰€ä»¥ $\mathcal{B}, w \models B_a B_a \varphi$

3. è¯æ˜è´Ÿå†…çœ $\neg B_a \varphi \rightarrow B_a \neg B_a \varphi$:
   - å‡è®¾ $\mathcal{B}, w \models \neg B_a \varphi$
   - è¿™æ„å‘³ç€å­˜åœ¨ $v$ ä½¿å¾— $w \sim_a v$ ä¸” $\mathcal{B}, v \not\models \varphi$
   - ç”±äº $\sim_a$ æ˜¯å¯¹ç§°çš„ï¼Œå¯¹æ‰€æœ‰ $u$ ä½¿å¾— $w \sim_a u$ï¼Œå­˜åœ¨ $v$ ä½¿å¾— $u \sim_a v$ ä¸” $\mathcal{B}, v \not\models \varphi$
   - å› æ­¤ $\mathcal{B}, u \models \neg B_a \varphi$ å¯¹æ‰€æœ‰ $u$ ä½¿å¾— $w \sim_a u$ æˆç«‹
   - æ‰€ä»¥ $\mathcal{B}, w \models B_a \neg B_a \varphi$

4. è¯æ˜åˆ†é…å¾‹ $B_a(\varphi \rightarrow \psi) \rightarrow (B_a \varphi \rightarrow B_a \psi)$:
   - å‡è®¾ $\mathcal{B}, w \models B_a(\varphi \rightarrow \psi)$ ä¸” $\mathcal{B}, w \models B_a \varphi$
   - è¿™æ„å‘³ç€å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{B}, v \models \varphi \rightarrow \psi$ ä¸” $\mathcal{B}, v \models \varphi$
   - å› æ­¤å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{B}, v \models \psi$
   - æ‰€ä»¥ $\mathcal{B}, w \models B_a \psi$

### 3.2 ä¿¡å¿µç¨‹åº¦

**å®šç† 1.3.2** (ä¿¡å¿µç¨‹åº¦æ€§è´¨)
ä¿¡å¿µç¨‹åº¦å‡½æ•°æ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š

1. **æ¦‚ç‡æ€§**: $\mu_a(w, \varphi) + \mu_a(w, \neg\varphi) = 1$
2. **å•è°ƒæ€§**: å¦‚æœ $\varphi \rightarrow \psi$ æ˜¯æœ‰æ•ˆçš„ï¼Œåˆ™ $\mu_a(w, \varphi) \leq \mu_a(w, \psi)$
3. **å¯åŠ æ€§**: $\mu_a(w, \varphi \lor \psi) = \mu_a(w, \varphi) + \mu_a(w, \psi) - \mu_a(w, \varphi \land \psi)$

**è¯æ˜**:

1. è¯æ˜æ¦‚ç‡æ€§ $\mu_a(w, \varphi) + \mu_a(w, \neg\varphi) = 1$:
   - æ ¹æ®ä¿¡å¿µç¨‹åº¦çš„å®šä¹‰ï¼Œ$\mu_a(w, \varphi)$ è¡¨ç¤ºä¸»ä½“aåœ¨ä¸–ç•Œwä¸­å¯¹$\varphi$çš„ä¿¡å¿µç¨‹åº¦
   - ç”±äº$\varphi$å’Œ$\neg\varphi$æ˜¯äº’æ–¥çš„ï¼Œä¸”å®ƒä»¬çš„å¹¶é›†è¦†ç›–æ‰€æœ‰å¯èƒ½æƒ…å†µ
   - å› æ­¤ $\mu_a(w, \varphi) + \mu_a(w, \neg\varphi) = 1$

2. è¯æ˜å•è°ƒæ€§:
   - å¦‚æœ $\varphi \rightarrow \psi$ æ˜¯æœ‰æ•ˆçš„ï¼Œåˆ™ $\varphi$ ä¸ºçœŸæ—¶ $\psi$ ä¹Ÿä¸ºçœŸ
   - å› æ­¤ä¸»ä½“å¯¹ $\psi$ çš„ä¿¡å¿µç¨‹åº¦ä¸åº”ä½äºå¯¹ $\varphi$ çš„ä¿¡å¿µç¨‹åº¦
   - æ‰€ä»¥ $\mu_a(w, \varphi) \leq \mu_a(w, \psi)$

3. è¯æ˜å¯åŠ æ€§:
   - æ ¹æ®æ¦‚ç‡è®ºçš„åŸºæœ¬åŸç†ï¼Œä¸¤ä¸ªäº‹ä»¶çš„å¹¶é›†çš„æ¦‚ç‡ç­‰äºå„è‡ªæ¦‚ç‡ä¹‹å’Œå‡å»äº¤é›†çš„æ¦‚ç‡
   - å› æ­¤ $\mu_a(w, \varphi \lor \psi) = \mu_a(w, \varphi) + \mu_a(w, \psi) - \mu_a(w, \varphi \land \psi)$

### 3.3 ä¿¡å¿µæ›´æ–°å®šç†

**å®šç† 1.3.3** (ä¿¡å¿µæ›´æ–°ä¸€è‡´æ€§)
å¦‚æœä¸»ä½“ç›¸ä¿¡ $\varphi$ï¼Œä¸”æ¥æ”¶åˆ°æ–°ä¿¡æ¯ $\varphi$ï¼Œåˆ™æ›´æ–°åçš„ä¿¡å¿µä¿æŒä¸€è‡´æ€§ã€‚

**å½¢å¼åŒ–**: $B_a \varphi \rightarrow B_a[\varphi] \varphi$

**è¯æ˜**:
è®¾ $\mathcal{B}$ æ˜¯ä¿¡å¿µæ¨¡å‹ï¼Œ$w$ æ˜¯ä»»æ„ä¸–ç•Œã€‚

å‡è®¾ $\mathcal{B}, w \models B_a \varphi$ï¼Œè¿™æ„å‘³ç€å¯¹æ‰€æœ‰ $v$ ä½¿å¾— $w \sim_a v$ï¼Œæœ‰ $\mathcal{B}, v \models \varphi$ã€‚

åœ¨æ›´æ–°åçš„æ¨¡å‹ $\mathcal{B}[\varphi]$ ä¸­ï¼š

- $W[\varphi] = \{v \in W : \mathcal{B}, v \models \varphi\}$
- å› æ­¤æ‰€æœ‰å¯è¾¾ä¸–ç•Œéƒ½åœ¨ $W[\varphi]$ ä¸­
- æ‰€ä»¥ $\mathcal{B}[\varphi], w \models B_a \varphi$

**å®šç† 1.3.4** (ä¿¡å¿µæ›´æ–°å•è°ƒæ€§)
å¦‚æœ $\varphi \rightarrow \psi$ æ˜¯æœ‰æ•ˆçš„ï¼Œä¸”ä¸»ä½“ç›¸ä¿¡ $\varphi$ï¼Œåˆ™æ›´æ–°åä¸»ä½“ä»ç„¶ç›¸ä¿¡ $\psi$ã€‚

**å½¢å¼åŒ–**: $(\varphi \rightarrow \psi) \land B_a \varphi \rightarrow B_a[\varphi] \psi$

**è¯æ˜**:
è®¾ $\mathcal{B}$ æ˜¯ä¿¡å¿µæ¨¡å‹ï¼Œ$w$ æ˜¯ä»»æ„ä¸–ç•Œã€‚

å‡è®¾ $\mathcal{B}, w \models \varphi \rightarrow \psi$ ä¸” $\mathcal{B}, w \models B_a \varphi$ã€‚

åœ¨æ›´æ–°åçš„æ¨¡å‹ $\mathcal{B}[\varphi]$ ä¸­ï¼š

- æ‰€æœ‰å¯è¾¾ä¸–ç•Œéƒ½æ»¡è¶³ $\varphi$
- ç”±äº $\varphi \rightarrow \psi$ æ˜¯æœ‰æ•ˆçš„ï¼Œæ‰€æœ‰å¯è¾¾ä¸–ç•Œä¹Ÿæ»¡è¶³ $\psi$
- å› æ­¤ $\mathcal{B}[\varphi], w \models B_a \psi$

## 4. ä»£ç å®ç°

### 4.1 ä¿¡å¿µé€»è¾‘è¯­è¨€å®ç°

```rust
use std::collections::HashMap;
use std::fmt;

/// ä¸»ä½“æ ‡è¯†ç¬¦
pub type AgentId = String;

/// ä¸–ç•Œæ ‡è¯†ç¬¦
pub type WorldId = usize;

/// ä¿¡å¿µç¨‹åº¦
pub type BeliefDegree = f64;

/// ä¿¡å¿µé€»è¾‘å…¬å¼
#[derive(Debug, Clone, PartialEq)]
pub enum BeliefFormula {
    /// å‘½é¢˜å˜å…ƒ
    Proposition(String),
    /// å¦å®š
    Not(Box<BeliefFormula>),
    /// åˆå–
    And(Box<BeliefFormula>, Box<BeliefFormula>),
    /// æå–
    Or(Box<BeliefFormula>, Box<BeliefFormula>),
    /// è•´å«
    Implies(Box<BeliefFormula>, Box<BeliefFormula>),
    /// ç­‰ä»·
    Iff(Box<BeliefFormula>, Box<BeliefFormula>),
    /// ä¿¡å¿µç®—å­
    Believes(AgentId, Box<BeliefFormula>),
    /// ä¿¡å¿µç¨‹åº¦ç®—å­
    BelievesDegree(AgentId, BeliefDegree, Box<BeliefFormula>),
}

impl fmt::Display for BeliefFormula {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            BeliefFormula::Proposition(p) => write!(f, "{}", p),
            BeliefFormula::Not(phi) => write!(f, "Â¬({})", phi),
            BeliefFormula::And(phi, psi) => write!(f, "({} âˆ§ {})", phi, psi),
            BeliefFormula::Or(phi, psi) => write!(f, "({} âˆ¨ {})", phi, psi),
            BeliefFormula::Implies(phi, psi) => write!(f, "({} â†’ {})", phi, psi),
            BeliefFormula::Iff(phi, psi) => write!(f, "({} â†” {})", phi, psi),
            BeliefFormula::Believes(agent, phi) => write!(f, "B_{}({})", agent, phi),
            BeliefFormula::BelievesDegree(agent, degree, phi) => write!(f, "B_{}^{}({})", agent, degree, phi),
        }
    }
}

/// ä¿¡å¿µå¯è¾¾å…³ç³»
pub type BeliefAccessibilityRelation = HashMap<AgentId, Vec<Vec<WorldId>>>;

/// ä¿¡å¿µåº¦å‡½æ•°
pub type BeliefDegreeFunction = HashMap<(AgentId, WorldId, String), BeliefDegree>;

/// è¯æ®å‡½æ•°
pub type EvidenceFunction = HashMap<(AgentId, WorldId), Vec<String>>;

/// ä¿¡å¿µæ¨¡å‹
#[derive(Debug)]
pub struct BeliefModel {
    pub worlds: Vec<WorldId>,
    pub accessibility: BeliefAccessibilityRelation,
    pub proposition_valuation: HashMap<String, Vec<WorldId>>,
    pub belief_degrees: BeliefDegreeFunction,
    pub evidence: EvidenceFunction,
}

impl BeliefModel {
    /// åˆ›å»ºæ–°çš„ä¿¡å¿µæ¨¡å‹
    pub fn new(world_count: usize) -> Self {
        let worlds: Vec<WorldId> = (0..world_count).collect();
        let accessibility = HashMap::new();
        let proposition_valuation = HashMap::new();
        let belief_degrees = HashMap::new();
        let evidence = HashMap::new();
        
        BeliefModel {
            worlds,
            accessibility,
            proposition_valuation,
            belief_degrees,
            evidence,
        }
    }
    
    /// è®¾ç½®ä¿¡å¿µå¯è¾¾å…³ç³»
    pub fn set_accessibility(&mut self, agent: &str, relations: Vec<Vec<WorldId>>) {
        self.accessibility.insert(agent.to_string(), relations);
    }
    
    /// è®¾ç½®å‘½é¢˜åœ¨ä¸–ç•Œä¸­çš„çœŸå€¼
    pub fn set_proposition(&mut self, proposition: &str, worlds: Vec<WorldId>) {
        self.proposition_valuation.insert(proposition.to_string(), worlds);
    }
    
    /// è®¾ç½®ä¿¡å¿µåº¦
    pub fn set_belief_degree(&mut self, agent: &str, world: WorldId, proposition: &str, degree: BeliefDegree) {
        self.belief_degrees.insert((agent.to_string(), world, proposition.to_string()), degree);
    }
    
    /// è®¾ç½®è¯æ®
    pub fn set_evidence(&mut self, agent: &str, world: WorldId, evidence: Vec<String>) {
        self.evidence.insert((agent.to_string(), world), evidence);
    }
    
    /// æ£€æŸ¥å…¬å¼åœ¨ä¸–ç•Œçš„çœŸå€¼
    pub fn satisfies(&self, world: WorldId, formula: &BeliefFormula) -> bool {
        match formula {
            BeliefFormula::Proposition(p) => {
                self.proposition_valuation.get(p)
                    .map(|worlds| worlds.contains(&world))
                    .unwrap_or(false)
            }
            BeliefFormula::Not(phi) => !self.satisfies(world, phi),
            BeliefFormula::And(phi, psi) => {
                self.satisfies(world, phi) && self.satisfies(world, psi)
            }
            BeliefFormula::Or(phi, psi) => {
                self.satisfies(world, phi) || self.satisfies(world, psi)
            }
            BeliefFormula::Implies(phi, psi) => {
                !self.satisfies(world, phi) || self.satisfies(world, psi)
            }
            BeliefFormula::Iff(phi, psi) => {
                self.satisfies(world, phi) == self.satisfies(world, psi)
            }
            BeliefFormula::Believes(agent, phi) => {
                self.evaluate_belief(world, agent, phi)
            }
            BeliefFormula::BelievesDegree(agent, degree, phi) => {
                self.evaluate_belief_degree(world, agent, *degree, phi)
            }
        }
    }
    
    /// è¯„ä¼°ä¿¡å¿µ
    fn evaluate_belief(&self, world: WorldId, agent: &str, phi: &BeliefFormula) -> bool {
        if let Some(accessible_worlds) = self.accessibility.get(agent) {
            if world < accessible_worlds.len() {
                for &accessible_world in &accessible_worlds[world] {
                    if !self.satisfies(accessible_world, phi) {
                        return false;
                    }
                }
                true
            } else {
                false
            }
        } else {
            false
        }
    }
    
    /// è¯„ä¼°ä¿¡å¿µåº¦
    fn evaluate_belief_degree(&self, world: WorldId, agent: &str, expected_degree: BeliefDegree, phi: &BeliefFormula) -> bool {
        if let BeliefFormula::Proposition(proposition) = phi {
            if let Some(&actual_degree) = self.belief_degrees.get(&(agent.to_string(), world, proposition.clone())) {
                (actual_degree - expected_degree).abs() < f64::EPSILON
            } else {
                false
            }
        } else {
            false
        }
    }
    
    /// è·å–ä¿¡å¿µåº¦
    pub fn get_belief_degree(&self, agent: &str, world: WorldId, proposition: &str) -> Option<BeliefDegree> {
        self.belief_degrees.get(&(agent.to_string(), world, proposition.to_string())).cloned()
    }
    
    /// æ£€æŸ¥å…¬å¼æ˜¯å¦åœ¨æ‰€æœ‰ä¸–ç•Œä¸ºçœŸ
    pub fn is_valid(&self, formula: &BeliefFormula) -> bool {
        self.worlds.iter().all(|&w| self.satisfies(w, formula))
    }
    
    /// æ£€æŸ¥å…¬å¼æ˜¯å¦åœ¨æŸä¸ªä¸–ç•Œä¸ºçœŸ
    pub fn is_satisfiable(&self, formula: &BeliefFormula) -> bool {
        self.worlds.iter().any(|&w| self.satisfies(w, formula))
    }
}

/// ä¿¡å¿µæ›´æ–°
pub struct BeliefUpdater;

impl BeliefUpdater {
    /// æ›´æ–°ä¿¡å¿µæ¨¡å‹
    pub fn update(model: &BeliefModel, agent: &str, new_information: &BeliefFormula) -> BeliefModel {
        let mut updated_model = model.clone();
        
        // è¿‡æ»¤æ»¡è¶³æ–°ä¿¡æ¯çš„ä¸–ç•Œ
        let valid_worlds: Vec<WorldId> = model.worlds.iter()
            .filter(|&&w| model.satisfies(w, new_information))
            .cloned()
            .collect();
        
        // æ›´æ–°å¯è¾¾å…³ç³»
        if let Some(accessibility) = model.accessibility.get(agent) {
            let mut new_accessibility = Vec::new();
            for (world, accessible) in accessibility.iter().enumerate() {
                if valid_worlds.contains(&world) {
                    let filtered_accessible: Vec<WorldId> = accessible.iter()
                        .filter(|&&w| valid_worlds.contains(&w))
                        .cloned()
                        .collect();
                    new_accessibility.push(filtered_accessible);
                }
            }
            updated_model.set_accessibility(agent, new_accessibility);
        }
        
        // æ›´æ–°ä¿¡å¿µåº¦
        for &world in &valid_worlds {
            for (key, &degree) in &model.belief_degrees {
                if key.1 == world {
                    updated_model.set_belief_degree(&key.0, key.1, &key.2, degree);
                }
            }
        }
        
        updated_model
    }
    
    /// æ¡ä»¶åŒ–ä¿¡å¿µåº¦
    pub fn conditionalize_belief_degree(
        model: &BeliefModel,
        agent: &str,
        world: WorldId,
        proposition: &str,
        condition: &str
    ) -> Option<BeliefDegree> {
        let p_and_q_degree = model.get_belief_degree(agent, world, &format!("{}_and_{}", proposition, condition));
        let q_degree = model.get_belief_degree(agent, world, condition);
        
        match (p_and_q_degree, q_degree) {
            (Some(p_and_q), Some(q)) if q > 0.0 => Some(p_and_q / q),
            _ => None
        }
    }
}

/// ä¿¡å¿µæ¨ç†ç³»ç»Ÿ
pub struct BeliefReasoningSystem {
    pub model: BeliefModel,
}

impl BeliefReasoningSystem {
    pub fn new(model: BeliefModel) -> Self {
        BeliefReasoningSystem { model }
    }
    
    /// éªŒè¯ä¿¡å¿µå…¬ç†
    pub fn verify_belief_axioms(&self, agent: &str, phi: &BeliefFormula) -> bool {
        // éªŒè¯ä¸€è‡´æ€§å…¬ç†
        let consistency = BeliefFormula::Not(Box::new(
            BeliefFormula::Believes(agent.to_string(), Box::new(BeliefFormula::Proposition("false".to_string())))
        ));
        
        self.model.is_valid(&consistency)
    }
    
    /// éªŒè¯æ­£å†…çœå…¬ç†
    pub fn verify_positive_introspection(&self, agent: &str, phi: &BeliefFormula) -> bool {
        let positive_introspection = BeliefFormula::Implies(
            Box::new(BeliefFormula::Believes(agent.to_string(), Box::new(phi.clone()))),
            Box::new(BeliefFormula::Believes(
                agent.to_string(),
                Box::new(BeliefFormula::Believes(agent.to_string(), Box::new(phi.clone())))
            ))
        );
        
        self.model.is_valid(&positive_introspection)
    }
    
    /// éªŒè¯åˆ†é…å¾‹
    pub fn verify_distribution(&self, agent: &str, phi: &BeliefFormula, psi: &BeliefFormula) -> bool {
        let distribution = BeliefFormula::Implies(
            Box::new(BeliefFormula::Believes(
                agent.to_string(),
                Box::new(BeliefFormula::Implies(Box::new(phi.clone()), Box::new(psi.clone())))
            )),
            Box::new(BeliefFormula::Implies(
                Box::new(BeliefFormula::Believes(agent.to_string(), Box::new(phi.clone()))),
                Box::new(BeliefFormula::Believes(agent.to_string(), Box::new(psi.clone())))
            ))
        );
        
        self.model.is_valid(&distribution)
    }
    
    /// ä¿¡å¿µæ¨ç†
    pub fn belief_inference(&self, premises: &[BeliefFormula], conclusion: &BeliefFormula) -> bool {
        // æ£€æŸ¥å‰ææ˜¯å¦åœ¨æ‰€æœ‰ä¸–ç•Œä¸ºçœŸ
        let premises_valid = premises.iter().all(|p| self.model.is_valid(p));
        
        if premises_valid {
            // æ£€æŸ¥ç»“è®ºæ˜¯å¦åœ¨æ‰€æœ‰ä¸–ç•Œä¸ºçœŸ
            self.model.is_valid(conclusion)
        } else {
            false
        }
    }
}

/// ä¿¡å¿µåˆ†æå™¨
pub struct BeliefAnalyzer {
    system: BeliefReasoningSystem,
}

impl BeliefAnalyzer {
    pub fn new(system: BeliefReasoningSystem) -> Self {
        BeliefAnalyzer { system }
    }
    
    /// åˆ†æä¿¡å¿µä¸€è‡´æ€§
    pub fn analyze_consistency(&self, agent: &str, beliefs: &[BeliefFormula]) -> bool {
        // æ£€æŸ¥ä¿¡å¿µé›†åˆæ˜¯å¦ä¸€è‡´
        for phi in beliefs {
            for psi in beliefs {
                if phi != psi {
                    let contradiction = BeliefFormula::And(
                        Box::new(phi.clone()),
                        Box::new(BeliefFormula::Not(Box::new(psi.clone())))
                    );
                    if self.system.model.is_satisfiable(&contradiction) {
                        return false;
                    }
                }
            }
        }
        true
    }
    
    /// åˆ†æä¿¡å¿µå¼ºåº¦
    pub fn analyze_belief_strength(&self, agent: &str, world: WorldId, proposition: &str) -> Option<BeliefDegree> {
        self.system.model.get_belief_degree(agent, world, proposition)
    }
    
    /// ä¿¡å¿µæ›´æ–°åˆ†æ
    pub fn analyze_belief_update(&self, agent: &str, new_information: &BeliefFormula) -> BeliefModel {
        BeliefUpdater::update(&self.system.model, agent, new_information)
    }
    
    /// ä¿¡å¿µä¼ æ’­åˆ†æ
    pub fn analyze_belief_propagation(&self, agent: &str, phi: &BeliefFormula, psi: &BeliefFormula) -> bool {
        // æ£€æŸ¥ä¿¡å¿µä¼ æ’­ï¼šå¦‚æœç›¸ä¿¡phiä¸”phiè•´å«psiï¼Œåˆ™ç›¸ä¿¡psi
        let propagation = BeliefFormula::Implies(
            Box::new(BeliefFormula::And(
                Box::new(BeliefFormula::Believes(agent.to_string(), Box::new(phi.clone()))),
                Box::new(BeliefFormula::Implies(Box::new(phi.clone()), Box::new(psi.clone())))
            )),
            Box::new(BeliefFormula::Believes(agent.to_string(), Box::new(psi.clone())))
        );
        
        self.system.model.is_valid(&propagation)
    }
}

/// ä¿¡å¿µç†è®ºæµ‹è¯•
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_belief_axioms() {
        let mut model = BeliefModel::new(3);
        
        // è®¾ç½®ä¿¡å¿µå¯è¾¾å…³ç³»ï¼ˆç­‰ä»·å…³ç³»ï¼‰
        model.set_accessibility("Alice", vec![
            vec![0, 1], // ä¸–ç•Œ0å’Œ1ä¸å¯åŒºåˆ†
            vec![0, 1],
            vec![2],    // ä¸–ç•Œ2å•ç‹¬
        ]);
        
        // è®¾ç½®å‘½é¢˜çœŸå€¼
        model.set_proposition("p", vec![0, 1]);
        
        // è®¾ç½®ä¿¡å¿µåº¦
        model.set_belief_degree("Alice", 0, "p", 0.8);
        model.set_belief_degree("Alice", 1, "p", 0.8);
        
        let system = BeliefReasoningSystem::new(model);
        let analyzer = BeliefAnalyzer::new(system);
        
        let phi = BeliefFormula::Proposition("p".to_string());
        assert!(analyzer.system.verify_belief_axioms("Alice", &phi));
    }
    
    #[test]
    fn test_belief_degree() {
        let mut model = BeliefModel::new(2);
        
        // è®¾ç½®ä¿¡å¿µåº¦
        model.set_belief_degree("Bob", 0, "q", 0.7);
        model.set_belief_degree("Bob", 0, "r", 0.3);
        
        let system = BeliefReasoningSystem::new(model);
        let analyzer = BeliefAnalyzer::new(system);
        
        // æ£€æŸ¥ä¿¡å¿µåº¦
        let degree = analyzer.analyze_belief_strength("Bob", 0, "q");
        assert_eq!(degree, Some(0.7));
    }
    
    #[test]
    fn test_belief_update() {
        let mut model = BeliefModel::new(3);
        
        // è®¾ç½®åˆå§‹ä¿¡å¿µ
        model.set_proposition("p", vec![0, 1]);
        model.set_accessibility("Charlie", vec![
            vec![0, 1, 2],
            vec![0, 1, 2],
            vec![0, 1, 2],
        ]);
        
        let system = BeliefReasoningSystem::new(model);
        let analyzer = BeliefAnalyzer::new(system);
        
        // æ›´æ–°ä¿¡å¿µ
        let new_info = BeliefFormula::Proposition("p".to_string());
        let updated_model = analyzer.analyze_belief_update("Charlie", &new_info);
        
        // éªŒè¯æ›´æ–°åçš„ä¿¡å¿µ
        assert!(updated_model.satisfies(0, &BeliefFormula::Believes(
            "Charlie".to_string(), Box::new(new_info.clone())
        )));
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 è®¤çŸ¥çŠ¶æ€åˆ†æ

**ç¤ºä¾‹ 1**: è®¤çŸ¥çŠ¶æ€åˆ†æ

```rust
// è®¤çŸ¥çŠ¶æ€åˆ†æ
let mut cognitive_model = BeliefModel::new(4);

// è®¾ç½®è®¤çŸ¥ä¸å¯åŒºåˆ†å…³ç³»
cognitive_model.set_accessibility("Agent", vec![
    vec![0, 1], // ä¸–ç•Œ0å’Œ1ä¸å¯åŒºåˆ†
    vec![0, 1],
    vec![2, 3], // ä¸–ç•Œ2å’Œ3ä¸å¯åŒºåˆ†
    vec![2, 3],
]);

// è®¾ç½®å‘½é¢˜ï¼šå¤©æ°”æ™´æœ—
cognitive_model.set_proposition("sunny", vec![0, 2]);

// è®¾ç½®ä¿¡å¿µåº¦
cognitive_model.set_belief_degree("Agent", 0, "sunny", 0.9);
cognitive_model.set_belief_degree("Agent", 1, "sunny", 0.1);
cognitive_model.set_belief_degree("Agent", 2, "sunny", 0.8);
cognitive_model.set_belief_degree("Agent", 3, "sunny", 0.2);

let system = BeliefReasoningSystem::new(cognitive_model);
let analyzer = BeliefAnalyzer::new(system);

// åˆ†æAgentçš„ä¿¡å¿µçŠ¶æ€
let belief_strength = analyzer.analyze_belief_strength("Agent", 0, "sunny");
println!("Agentå¯¹å¤©æ°”æ™´æœ—çš„ä¿¡å¿µå¼ºåº¦: {:?}", belief_strength);
```

### 5.2 ç§‘å­¦ä¿¡å¿µåˆ†æ

**ç¤ºä¾‹ 2**: ç§‘å­¦ä¿¡å¿µåˆ†æ

```rust
// ç§‘å­¦ä¿¡å¿µåˆ†æ
let mut scientific_model = BeliefModel::new(3);

// è®¾ç½®ç§‘å­¦å‘½é¢˜
scientific_model.set_proposition("evolution_true", vec![0, 1]);
scientific_model.set_proposition("climate_change", vec![0, 2]);

// è®¾ç½®ç§‘å­¦å®¶çš„ä¿¡å¿µåº¦
scientific_model.set_belief_degree("Scientist", 0, "evolution_true", 0.95);
scientific_model.set_belief_degree("Scientist", 0, "climate_change", 0.85);

// è®¾ç½®ä¿¡å¿µå¯è¾¾å…³ç³»
scientific_model.set_accessibility("Scientist", vec![
    vec![0, 1], // åŸºäºè¯æ®çš„å¯è¾¾å…³ç³»
    vec![0, 1],
    vec![2],
]);

let system = BeliefReasoningSystem::new(scientific_model);
let analyzer = BeliefAnalyzer::new(system);

// æ£€æŸ¥ä¿¡å¿µä¸€è‡´æ€§
let beliefs = vec![
    BeliefFormula::Proposition("evolution_true".to_string()),
    BeliefFormula::Proposition("climate_change".to_string()),
];

let is_consistent = analyzer.analyze_consistency("Scientist", &beliefs);
println!("ç§‘å­¦å®¶ä¿¡å¿µä¸€è‡´æ€§: {}", is_consistent);
```

### 5.3 ç¤¾ä¼šä¿¡å¿µåˆ†æ

**ç¤ºä¾‹ 3**: ç¤¾ä¼šä¿¡å¿µåˆ†æ

```rust
// ç¤¾ä¼šä¿¡å¿µåˆ†æ
let mut social_model = BeliefModel::new(5);

// è®¾ç½®ç¤¾ä¼šå‘½é¢˜
social_model.set_proposition("policy_effective", vec![0, 1, 2]);
social_model.set_proposition("public_support", vec![0, 1]);

// è®¾ç½®ä¸åŒä¸»ä½“çš„ä¿¡å¿µåº¦
social_model.set_belief_degree("Politician", 0, "policy_effective", 0.9);
social_model.set_belief_degree("Expert", 0, "policy_effective", 0.7);
social_model.set_belief_degree("Public", 0, "policy_effective", 0.5);

// è®¾ç½®ä¿¡å¿µä¼ æ’­
social_model.set_accessibility("Politician", vec![
    vec![0, 1, 2], // æ”¿æ²»å®¶çš„ä¿¡å¿µèŒƒå›´
    vec![0, 1, 2],
    vec![0, 1, 2],
    vec![3, 4],
    vec![3, 4],
]);

let system = BeliefReasoningSystem::new(social_model);
let analyzer = BeliefAnalyzer::new(system);

// åˆ†æä¿¡å¿µä¼ æ’­
let policy = BeliefFormula::Proposition("policy_effective".to_string());
let support = BeliefFormula::Proposition("public_support".to_string());

let propagation = analyzer.analyze_belief_propagation("Politician", &policy, &support);
println!("ä¿¡å¿µä¼ æ’­æœ‰æ•ˆæ€§: {}", propagation);
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸çŸ¥è¯†ç†è®ºçš„å…³ç³»

ä¿¡å¿µç†è®ºä¸çŸ¥è¯†ç†è®ºå¯†åˆ‡ç›¸å…³ï¼š

- **çŸ¥è¯†vsä¿¡å¿µ**: çŸ¥è¯†æ˜¯ç¡®è¯çš„çœŸä¿¡å¿µ
- **ä¿¡å¿µæ¡ä»¶**: çŸ¥è¯†å¿…é¡»åŒ…å«ä¿¡å¿µæˆåˆ†
- **ä¿¡å¿µç¡®è¯**: ä¿¡å¿µçš„ç¡®è¯æ˜¯çŸ¥è¯†çš„å¿…è¦æ¡ä»¶

### 6.2 ä¸ç¡®è¯ç†è®ºçš„å…³ç³»

ä¿¡å¿µç†è®ºä¾èµ–ç¡®è¯ç†è®ºï¼š

- **ä¿¡å¿µç¡®è¯**: ä¿¡å¿µéœ€è¦ç¡®è¯æ”¯æŒ
- **ç¡®è¯ç¨‹åº¦**: ç¡®è¯ç¨‹åº¦å½±å“ä¿¡å¿µå¼ºåº¦
- **ç¡®è¯æ¥æº**: ä¸åŒæ¥æºçš„ç¡®è¯å¯¹ä¿¡å¿µçš„å½±å“

### 6.3 ä¸çœŸç†ç†è®ºçš„å…³ç³»

ä¿¡å¿µç†è®ºä¸çœŸç†ç†è®ºç›¸å…³ï¼š

- **ä¿¡å¿µçœŸå€¼**: ä¿¡å¿µå¯ä»¥æ˜¯çœŸæˆ–å‡
- **çœŸç†æ¡ä»¶**: ä¿¡å¿µçš„çœŸç†æ¡ä»¶
- **ä¿¡å¿µä¿®æ­£**: åŸºäºçœŸç†çš„ä¿¡å¿µä¿®æ­£

## 7. å‚è€ƒæ–‡çŒ®

1. Davidson, D. (1984). *Inquiries into truth and interpretation*. Oxford University Press.

2. Dennett, D. C. (1987). *The intentional stance*. MIT Press.

3. Fodor, J. A. (1987). *Psychosemantics: The problem of meaning in the philosophy of mind*. MIT Press.

4. Stalnaker, R. (1984). *Inquiry*. MIT Press.

5. van Fraassen, B. C. (1980). *The scientific image*. Oxford University Press.

---

**ç›¸å…³æ–‡æ¡£**:

- [01.1.1 å­˜åœ¨ç†è®º](../01_Metaphysics/01.1.1_å­˜åœ¨ç†è®º.md)
- [01.1.2 å®ä½“ç†è®º](../01_Metaphysics/01.1.2_å®ä½“ç†è®º.md)
- [01.2.1 çŸ¥è¯†ç†è®º](01.2.1_çŸ¥è¯†ç†è®º.md)
- [01.2.3 ç¡®è¯ç†è®º](01.2.3_ç¡®è¯ç†è®º.md)

**è¿”å›**: [å“²å­¦åŸºç¡€ç†è®º](../README.md) | [ä¸»ç´¢å¼•](../../00_Master_Index/README.md)
