# 02.5.4 ç­‰ä»·å…³ç³»ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç­‰ä»·å…³ç³»æ˜¯æ•°å­¦ä¸­æœ€é‡è¦çš„å…³ç³»ç±»å‹ä¹‹ä¸€ï¼Œå®ƒåœ¨é›†åˆè®ºã€ä»£æ•°ã€æ‹“æ‰‘å­¦ç­‰é¢†åŸŸéƒ½æœ‰å¹¿æ³›åº”ç”¨ã€‚ç­‰ä»·å…³ç³»å°†é›†åˆåˆ’åˆ†ä¸ºä¸ç›¸äº¤çš„ç­‰ä»·ç±»ï¼Œä¸ºæŠ½è±¡å’Œåˆ†ç±»æä¾›äº†å¼ºå¤§çš„æ•°å­¦å·¥å…·ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ç­‰ä»·å…³ç³»çš„ä¸¥æ ¼å½¢å¼åŒ–å®šä¹‰
2. è¯æ˜ç­‰ä»·å…³ç³»çš„åŸºæœ¬æ€§è´¨
3. ç ”ç©¶ç­‰ä»·ç±»çš„ç»“æ„å’Œæ€§è´¨
4. æ¢è®¨å•†é›†å’Œè‡ªç„¶æ˜ å°„
5. æä¾›å®Œæ•´çš„ä»£ç å®ç°

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ç­‰ä»·ç±»ä¸å•†é›†](#4-ç­‰ä»·ç±»ä¸å•†é›†)
5. [ä»£ç å®ç°](#5-ä»£ç å®ç°)
6. [åº”ç”¨ç¤ºä¾‹](#6-åº”ç”¨ç¤ºä¾‹)
7. [ç›¸å…³ç†è®º](#7-ç›¸å…³ç†è®º)
8. [å‚è€ƒæ–‡çŒ®](#8-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç­‰ä»·å…³ç³»çš„ç›´è§‚ç†è§£

ç­‰ä»·å…³ç³»æ˜¯æ»¡è¶³è‡ªåæ€§ã€å¯¹ç§°æ€§å’Œä¼ é€’æ€§çš„äºŒå…ƒå…³ç³»ã€‚å®ƒå¯ä»¥å°†é›†åˆä¸­çš„å…ƒç´ æŒ‰ç…§æŸç§æ ‡å‡†è¿›è¡Œåˆ†ç±»ï¼Œä½¿å¾—åŒä¸€ç±»ä¸­çš„å…ƒç´ åœ¨æŸç§æ„ä¹‰ä¸Šæ˜¯"ç›¸åŒçš„"ã€‚

**ç¤ºä¾‹**ï¼š

- æ•´æ•°é›†åˆä¸Šçš„"æ¨¡nåŒä½™"å…³ç³»
- é›†åˆä¸Šçš„"åŸºæ•°ç›¸ç­‰"å…³ç³»
- å›¾è®ºä¸­çš„"è¿é€šæ€§"å…³ç³»

### 1.2 ç­‰ä»·å…³ç³»çš„ä¸‰ä¸ªåŸºæœ¬æ€§è´¨

1. **è‡ªåæ€§**ï¼šæ¯ä¸ªå…ƒç´ éƒ½ä¸è‡ªå·±ç­‰ä»·
2. **å¯¹ç§°æ€§**ï¼šå¦‚æœaä¸bç­‰ä»·ï¼Œåˆ™bä¸aç­‰ä»·
3. **ä¼ é€’æ€§**ï¼šå¦‚æœaä¸bç­‰ä»·ï¼Œbä¸cç­‰ä»·ï¼Œåˆ™aä¸cç­‰ä»·

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ç­‰ä»·å…³ç³»çš„å®šä¹‰

**å®šä¹‰ 2.1.1** (ç­‰ä»·å…³ç³»)
è®¾ $R$ æ˜¯é›†åˆ $A$ ä¸Šçš„äºŒå…ƒå…³ç³»ï¼Œå¦‚æœ $R$ æ»¡è¶³ä»¥ä¸‹ä¸‰ä¸ªæ¡ä»¶ï¼Œåˆ™ç§° $R$ ä¸º $A$ ä¸Šçš„ç­‰ä»·å…³ç³»ï¼š

1. **è‡ªåæ€§**ï¼š$\forall x \in A, (x, x) \in R$
2. **å¯¹ç§°æ€§**ï¼š$\forall x, y \in A, (x, y) \in R \Rightarrow (y, x) \in R$
3. **ä¼ é€’æ€§**ï¼š$\forall x, y, z \in A, (x, y) \in R \land (y, z) \in R \Rightarrow (x, z) \in R$

### 2.2 ç­‰ä»·å…³ç³»çš„ç¬¦å·è¡¨ç¤º

é€šå¸¸ç”¨ $\sim$ æˆ– $\equiv$ è¡¨ç¤ºç­‰ä»·å…³ç³»ï¼Œå³ï¼š

- $x \sim y$ è¡¨ç¤º $x$ ä¸ $y$ ç­‰ä»·
- $x \not\sim y$ è¡¨ç¤º $x$ ä¸ $y$ ä¸ç­‰ä»·

### 2.3 ç­‰ä»·å…³ç³»çš„é›†åˆè¡¨ç¤º

ç­‰ä»·å…³ç³» $R$ å¯ä»¥è¡¨ç¤ºä¸ºï¼š
$$R = \{(x, y) \in A \times A \mid x \sim y\}$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 ç­‰ä»·å…³ç³»çš„åŸºæœ¬æ€§è´¨

**å®šç† 3.1.1** (ç­‰ä»·å…³ç³»çš„é—­åŒ…æ€§è´¨)
è®¾ $R$ æ˜¯é›†åˆ $A$ ä¸Šçš„ç­‰ä»·å…³ç³»ï¼Œåˆ™ï¼š

1. $R$ åŒ…å«æ’ç­‰å…³ç³»ï¼š$\Delta_A \subseteq R$
2. $R$ æ˜¯å¯¹ç§°çš„ï¼š$R = R^{-1}$
3. $R$ æ˜¯ä¼ é€’çš„ï¼š$R \circ R \subseteq R$

**è¯æ˜**ï¼š

1. ç”±è‡ªåæ€§ï¼Œ$\forall x \in A, (x, x) \in R$ï¼Œæ‰€ä»¥ $\Delta_A \subseteq R$
2. ç”±å¯¹ç§°æ€§ï¼Œ$(x, y) \in R \Rightarrow (y, x) \in R$ï¼Œæ‰€ä»¥ $R = R^{-1}$
3. ç”±ä¼ é€’æ€§ï¼Œ$(x, y) \in R \land (y, z) \in R \Rightarrow (x, z) \in R$ï¼Œæ‰€ä»¥ $R \circ R \subseteq R$

### 3.2 ç­‰ä»·å…³ç³»çš„æ„é€ å®šç†

**å®šç† 3.2.1** (ç­‰ä»·å…³ç³»çš„æ„é€ )
è®¾ $A$ æ˜¯é›†åˆï¼Œ$P = \{A_i\}_{i \in I}$ æ˜¯ $A$ çš„ä¸€ä¸ªåˆ’åˆ†ï¼Œåˆ™å…³ç³»ï¼š
$$R_P = \{(x, y) \in A \times A \mid \exists i \in I, x, y \in A_i\}$$
æ˜¯ $A$ ä¸Šçš„ç­‰ä»·å…³ç³»ã€‚

**è¯æ˜**ï¼š

1. **è‡ªåæ€§**ï¼š$\forall x \in A$ï¼Œå­˜åœ¨ $i \in I$ ä½¿å¾— $x \in A_i$ï¼Œæ‰€ä»¥ $(x, x) \in R_P$
2. **å¯¹ç§°æ€§**ï¼š$(x, y) \in R_P \Rightarrow \exists i \in I, x, y \in A_i \Rightarrow (y, x) \in R_P$
3. **ä¼ é€’æ€§**ï¼š$(x, y) \in R_P \land (y, z) \in R_P \Rightarrow \exists i, j \in I, x, y \in A_i \land y, z \in A_j$
   ç”±äº $y \in A_i \cap A_j$ ä¸” $P$ æ˜¯åˆ’åˆ†ï¼Œæ‰€ä»¥ $A_i = A_j$ï¼Œå› æ­¤ $(x, z) \in R_P$

## 4. ç­‰ä»·ç±»ä¸å•†é›†

### 4.1 ç­‰ä»·ç±»çš„å®šä¹‰

**å®šä¹‰ 4.1.1** (ç­‰ä»·ç±»)
è®¾ $\sim$ æ˜¯é›†åˆ $A$ ä¸Šçš„ç­‰ä»·å…³ç³»ï¼Œå¯¹äº $a \in A$ï¼Œ$a$ çš„ç­‰ä»·ç±»å®šä¹‰ä¸ºï¼š
$$[a] = \{x \in A \mid x \sim a\}$$

### 4.2 ç­‰ä»·ç±»çš„æ€§è´¨

**å®šç† 4.2.1** (ç­‰ä»·ç±»çš„åŸºæœ¬æ€§è´¨)
è®¾ $\sim$ æ˜¯é›†åˆ $A$ ä¸Šçš„ç­‰ä»·å…³ç³»ï¼Œåˆ™ï¼š

1. **éç©ºæ€§**ï¼š$\forall a \in A, a \in [a]$
2. **å¯¹ç§°æ€§**ï¼š$a \sim b \Leftrightarrow [a] = [b]$
3. **ä¸ç›¸äº¤æ€§**ï¼š$[a] \neq [b] \Rightarrow [a] \cap [b] = \emptyset$
4. **è¦†ç›–æ€§**ï¼š$\bigcup_{a \in A} [a] = A$

**è¯æ˜**ï¼š

1. ç”±è‡ªåæ€§ï¼Œ$a \sim a$ï¼Œæ‰€ä»¥ $a \in [a]$
2. å¦‚æœ $a \sim b$ï¼Œåˆ™ $\forall x \in A$ï¼š
   - $x \in [a] \Rightarrow x \sim a \Rightarrow x \sim b \Rightarrow x \in [b]$
   - $x \in [b] \Rightarrow x \sim b \Rightarrow x \sim a \Rightarrow x \in [a]$
   æ‰€ä»¥ $[a] = [b]$
3. å¦‚æœ $[a] \cap [b] \neq \emptyset$ï¼Œåˆ™å­˜åœ¨ $c \in [a] \cap [b]$ï¼Œå³ $c \sim a$ ä¸” $c \sim b$ï¼Œç”±ä¼ é€’æ€§ $a \sim b$ï¼Œæ‰€ä»¥ $[a] = [b]$
4. æ˜¾ç„¶ $\bigcup_{a \in A} [a] \subseteq A$ï¼Œåˆ $\forall a \in A, a \in [a]$ï¼Œæ‰€ä»¥ $A \subseteq \bigcup_{a \in A} [a]$

### 4.3 å•†é›†çš„å®šä¹‰

**å®šä¹‰ 4.3.1** (å•†é›†)
è®¾ $\sim$ æ˜¯é›†åˆ $A$ ä¸Šçš„ç­‰ä»·å…³ç³»ï¼Œ$A$ å…³äº $\sim$ çš„å•†é›†å®šä¹‰ä¸ºï¼š
$$A/\sim = \{[a] \mid a \in A\}$$

### 4.4 è‡ªç„¶æ˜ å°„

**å®šä¹‰ 4.4.1** (è‡ªç„¶æ˜ å°„)
è®¾ $\sim$ æ˜¯é›†åˆ $A$ ä¸Šçš„ç­‰ä»·å…³ç³»ï¼Œè‡ªç„¶æ˜ å°„ $\pi: A \to A/\sim$ å®šä¹‰ä¸ºï¼š
$$\pi(a) = [a]$$

**å®šç† 4.4.1** (è‡ªç„¶æ˜ å°„çš„æ€§è´¨)
è‡ªç„¶æ˜ å°„ $\pi$ æ˜¯æ»¡å°„ï¼Œä¸” $\pi(a) = \pi(b) \Leftrightarrow a \sim b$

## 5. ä»£ç å®ç°

### 5.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::hash::Hash;

/// ç­‰ä»·å…³ç³»ç‰¹å¾
pub trait EquivalenceRelation<T> {
    fn is_equivalent(&self, a: &T, b: &T) -> bool;
}

/// ç­‰ä»·å…³ç³»å®ç°
pub struct EquivalenceRelationImpl<T> {
    relation: HashSet<(T, T)>,
}

impl<T: Clone + Hash + Eq> EquivalenceRelationImpl<T> {
    /// åˆ›å»ºæ–°çš„ç­‰ä»·å…³ç³»
    pub fn new() -> Self {
        Self {
            relation: HashSet::new(),
        }
    }
    
    /// æ·»åŠ ç­‰ä»·å¯¹
    pub fn add_equivalence(&mut self, a: T, b: T) {
        self.relation.insert((a.clone(), b.clone()));
        self.relation.insert((b, a.clone()));
        self.relation.insert((a, a));
    }
    
    /// æ£€æŸ¥è‡ªåæ€§
    pub fn is_reflexive(&self, elements: &[T]) -> bool {
        elements.iter().all(|x| self.relation.contains(&(x.clone(), x.clone())))
    }
    
    /// æ£€æŸ¥å¯¹ç§°æ€§
    pub fn is_symmetric(&self) -> bool {
        self.relation.iter().all(|(a, b)| {
            self.relation.contains(&(b.clone(), a.clone()))
        })
    }
    
    /// æ£€æŸ¥ä¼ é€’æ€§
    pub fn is_transitive(&self) -> bool {
        for (a, b) in &self.relation {
            for (c, d) in &self.relation {
                if b == c {
                    if !self.relation.contains(&(a.clone(), d.clone())) {
                        return false;
                    }
                }
            }
        }
        true
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºç­‰ä»·å…³ç³»
    pub fn is_equivalence_relation(&self, elements: &[T]) -> bool {
        self.is_reflexive(elements) && self.is_symmetric() && self.is_transitive()
    }
    
    /// è·å–ç­‰ä»·ç±»
    pub fn get_equivalence_class(&self, element: &T) -> HashSet<T> {
        let mut class = HashSet::new();
        for (a, b) in &self.relation {
            if a == element {
                class.insert(b.clone());
            }
        }
        class
    }
    
    /// è·å–æ‰€æœ‰ç­‰ä»·ç±»
    pub fn get_all_equivalence_classes(&self, elements: &[T]) -> Vec<HashSet<T>> {
        let mut classes = Vec::new();
        let mut processed = HashSet::new();
        
        for element in elements {
            if !processed.contains(element) {
                let class = self.get_equivalence_class(element);
                for item in &class {
                    processed.insert(item.clone());
                }
                classes.push(class);
            }
        }
        
        classes
    }
    
    /// è·å–å•†é›†
    pub fn get_quotient_set(&self, elements: &[T]) -> Vec<Vec<T>> {
        self.get_all_equivalence_classes(elements)
            .into_iter()
            .map(|set| set.into_iter().collect())
            .collect()
    }
}

impl<T: Clone + Hash + Eq> EquivalenceRelation<T> for EquivalenceRelationImpl<T> {
    fn is_equivalent(&self, a: &T, b: &T) -> bool {
        self.relation.contains(&(a.clone(), b.clone()))
    }
}

/// æ¨¡nåŒä½™å…³ç³»
pub struct ModuloEquivalence {
    modulus: i32,
}

impl ModuloEquivalence {
    pub fn new(modulus: i32) -> Self {
        Self { modulus }
    }
}

impl EquivalenceRelation<i32> for ModuloEquivalence {
    fn is_equivalent(&self, a: &i32, b: &i32) -> bool {
        (a - b) % self.modulus == 0
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_modulo_equivalence() {
        let mod3 = ModuloEquivalence::new(3);
        assert!(mod3.is_equivalent(&0, &3));
        assert!(mod3.is_equivalent(&1, &4));
        assert!(mod3.is_equivalent(&2, &5));
        assert!(!mod3.is_equivalent(&0, &1));
    }
    
    #[test]
    fn test_equivalence_relation_impl() {
        let mut relation = EquivalenceRelationImpl::new();
        let elements = vec![1, 2, 3, 4];
        
        // åˆ›å»ºç­‰ä»·å…³ç³»ï¼š{1,2} å’Œ {3,4}
        relation.add_equivalence(1, 2);
        relation.add_equivalence(3, 4);
        
        assert!(relation.is_equivalence_relation(&elements));
        
        let classes = relation.get_all_equivalence_classes(&elements);
        assert_eq!(classes.len(), 2);
        
        let quotient = relation.get_quotient_set(&elements);
        assert_eq!(quotient.len(), 2);
    }
}
```

### 5.2 Haskell å®ç°

```haskell
module EquivalenceRelation where

import Data.Set (Set)
import qualified Data.Set as Set
import Data.List (nub)

-- ç­‰ä»·å…³ç³»ç±»å‹
type EquivalenceRelation a = Set (a, a)

-- åˆ›å»ºç©ºç­‰ä»·å…³ç³»
emptyRelation :: EquivalenceRelation a
emptyRelation = Set.empty

-- æ·»åŠ ç­‰ä»·å¯¹
addEquivalence :: (Ord a) => a -> a -> EquivalenceRelation a -> EquivalenceRelation a
addEquivalence a b rel = Set.insert (a, b) $ Set.insert (b, a) $ Set.insert (a, a) rel

-- æ£€æŸ¥è‡ªåæ€§
isReflexive :: (Ord a) => EquivalenceRelation a -> [a] -> Bool
isReflexive rel elements = all (\x -> Set.member (x, x) rel) elements

-- æ£€æŸ¥å¯¹ç§°æ€§
isSymmetric :: (Ord a) => EquivalenceRelation a -> Bool
isSymmetric rel = all (\(a, b) -> Set.member (b, a) rel) (Set.toList rel)

-- æ£€æŸ¥ä¼ é€’æ€§
isTransitive :: (Ord a) => EquivalenceRelation a -> Bool
isTransitive rel = all (\(a, b) -> 
    all (\(c, d) -> 
        if b == c then Set.member (a, d) rel else True
    ) (Set.toList rel)
) (Set.toList rel)

-- æ£€æŸ¥æ˜¯å¦ä¸ºç­‰ä»·å…³ç³»
isEquivalenceRelation :: (Ord a) => EquivalenceRelation a -> [a] -> Bool
isEquivalenceRelation rel elements = 
    isReflexive rel elements && isSymmetric rel && isTransitive rel

-- è·å–ç­‰ä»·ç±»
getEquivalenceClass :: (Ord a) => EquivalenceRelation a -> a -> Set a
getEquivalenceClass rel element = 
    Set.fromList [b | (a, b) <- Set.toList rel, a == element]

-- è·å–æ‰€æœ‰ç­‰ä»·ç±»
getAllEquivalenceClasses :: (Ord a) => EquivalenceRelation a -> [a] -> [Set a]
getAllEquivalenceClasses rel elements = nub [getEquivalenceClass rel e | e <- elements]

-- è·å–å•†é›†
getQuotientSet :: (Ord a) => EquivalenceRelation a -> [a] -> [[a]]
getQuotientSet rel elements = 
    map Set.toList $ getAllEquivalenceClasses rel elements

-- æ¨¡nåŒä½™å…³ç³»
moduloEquivalence :: Int -> Int -> Int -> Bool
moduloEquivalence n a b = (a - b) `mod` n == 0

-- åˆ›å»ºæ¨¡nåŒä½™å…³ç³»çš„ç­‰ä»·ç±»
moduloEquivalenceClasses :: Int -> [Int] -> [[Int]]
moduloEquivalenceClasses n elements = 
    let rel = foldr (\a acc -> foldr (\b acc' -> addEquivalence a b acc') acc elements) 
                   emptyRelation elements
        filteredRel = Set.filter (\(a, b) -> moduloEquivalence n a b) rel
    in getQuotientSet filteredRel elements

-- ç¤ºä¾‹ï¼šæ¨¡3åŒä½™
exampleMod3 :: [[Int]]
exampleMod3 = moduloEquivalenceClasses 3 [0..8]
-- ç»“æœï¼š[[0,3,6], [1,4,7], [2,5,8]]
```

## 6. åº”ç”¨ç¤ºä¾‹

### 6.1 æ•´æ•°æ¨¡nåŒä½™

**ç¤ºä¾‹ 6.1.1** (æ¨¡3åŒä½™å…³ç³»)
åœ¨æ•´æ•°é›† $\mathbb{Z}$ ä¸Šå®šä¹‰å…³ç³»ï¼š
$$a \equiv b \pmod{3} \Leftrightarrow 3 \mid (a - b)$$

è¿™æ˜¯ä¸€ä¸ªç­‰ä»·å…³ç³»ï¼Œå°† $\mathbb{Z}$ åˆ’åˆ†ä¸ºä¸‰ä¸ªç­‰ä»·ç±»ï¼š

- $[0] = \{..., -6, -3, 0, 3, 6, ...\}$
- $[1] = \{..., -5, -2, 1, 4, 7, ...\}$
- $[2] = \{..., -4, -1, 2, 5, 8, ...\}$

å•†é›† $\mathbb{Z}/{\equiv_3} = \{[0], [1], [2]\}$

### 6.2 é›†åˆçš„åŸºæ•°ç›¸ç­‰

**ç¤ºä¾‹ 6.1.2** (åŸºæ•°ç›¸ç­‰å…³ç³»)
åœ¨é›†åˆæ—ä¸Šå®šä¹‰å…³ç³»ï¼š
$$A \sim B \Leftrightarrow |A| = |B|$$

è¿™æ˜¯ä¸€ä¸ªç­‰ä»·å…³ç³»ï¼Œæ¯ä¸ªç­‰ä»·ç±»åŒ…å«æ‰€æœ‰å…·æœ‰ç›¸åŒåŸºæ•°çš„é›†åˆã€‚

### 6.3 å›¾çš„è¿é€šæ€§

**ç¤ºä¾‹ 6.1.3** (å›¾çš„è¿é€šæ€§å…³ç³»)
åœ¨æ— å‘å›¾çš„é¡¶ç‚¹é›†ä¸Šå®šä¹‰å…³ç³»ï¼š
$$v \sim w \Leftrightarrow v \text{ ä¸ } w \text{ è¿é€š}$$

è¿™æ˜¯ä¸€ä¸ªç­‰ä»·å…³ç³»ï¼Œç­‰ä»·ç±»å°±æ˜¯è¿é€šåˆ†é‡ã€‚

## 7. ç›¸å…³ç†è®º

### 7.1 ä¸åˆ’åˆ†çš„å…³ç³»

ç­‰ä»·å…³ç³»ä¸é›†åˆåˆ’åˆ†ä¹‹é—´å­˜åœ¨ä¸€ä¸€å¯¹åº”å…³ç³»ï¼š

- æ¯ä¸ªç­‰ä»·å…³ç³»å¯¹åº”ä¸€ä¸ªåˆ’åˆ†ï¼ˆç­‰ä»·ç±»é›†åˆï¼‰
- æ¯ä¸ªåˆ’åˆ†å¯¹åº”ä¸€ä¸ªç­‰ä»·å…³ç³»

### 7.2 ä¸åŒä½™çš„å…³ç³»

åœ¨ä»£æ•°ç»“æ„ä¸­ï¼ŒåŒä½™å…³ç³»æ˜¯ä¿æŒè¿ç®—çš„ç­‰ä»·å…³ç³»ã€‚

### 7.3 ä¸å•†ä»£æ•°çš„å…³ç³»

é€šè¿‡ç­‰ä»·å…³ç³»å¯ä»¥æ„é€ å•†ä»£æ•°ï¼Œè¿™æ˜¯æŠ½è±¡ä»£æ•°ä¸­çš„é‡è¦æ¦‚å¿µã€‚

## 8. å‚è€ƒæ–‡çŒ®

1. Halmos, P. R. (1974). *Naive Set Theory*. Springer-Verlag.
2. Enderton, H. B. (1977). *Elements of Set Theory*. Academic Press.
3. Dummit, D. S., & Foote, R. M. (2004). *Abstract Algebra*. John Wiley & Sons.
4. Hungerford, T. W. (2003). *Algebra*. Springer-Verlag.
5. Rotman, J. J. (2002). *Advanced Modern Algebra*. Prentice Hall.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.5.1 å…³ç³»æ¦‚å¿µ](../02_Mathematical_Foundation/02.5.1_Relation_Concept.md)
- [02.5.2 å…³ç³»æ€§è´¨](../02_Mathematical_Foundation/02.5.2_å…³ç³»æ€§è´¨.md)
- [02.5.3 å…³ç³»è¿ç®—](../02_Mathematical_Foundation/02.5.3_å…³ç³»è¿ç®—.md)
- [02.1.1 æœ´ç´ é›†åˆè®º](../02_Mathematical_Foundation/02.1.1_æœ´ç´ é›†åˆè®º.md)
- [02.1.2 å…¬ç†é›†åˆè®º](../02_Mathematical_Foundation/02.1.2_å…¬ç†é›†åˆè®º.md)
