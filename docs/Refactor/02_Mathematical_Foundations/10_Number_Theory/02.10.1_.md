# 02.10.1 æ•´é™¤ç†è®º

## ğŸ“‹ æ¦‚è¿°

æ•´é™¤ç†è®ºæ˜¯æ•°è®ºçš„åŸºç¡€ï¼Œç ”ç©¶æ•´æ•°ä¹‹é—´çš„æ•´é™¤å…³ç³»ã€‚æœ¬æ–‡æ¡£å»ºç«‹ä¸¥æ ¼çš„æ•´é™¤ç†è®ºæ¡†æ¶ï¼ŒåŒ…å«å½¢å¼åŒ–å®šä¹‰ã€å®šç†è¯æ˜å’Œå®é™…åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ä¸¥æ ¼çš„æ•´é™¤æ¦‚å¿µå’Œå½¢å¼åŒ–å®šä¹‰
2. è¯æ˜æ•´é™¤ç†è®ºçš„åŸºæœ¬å®šç†
3. æä¾›å®Œæ•´çš„ä»£ç å®ç°
4. å±•ç¤ºæ•´é™¤ç†è®ºåœ¨å½¢å¼ç§‘å­¦ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ•´é™¤å…³ç³»

**å®šä¹‰ 1.1.1** (æ•´é™¤)
è®¾ $a, b \in \mathbb{Z}$ï¼Œå¦‚æœå­˜åœ¨ $q \in \mathbb{Z}$ ä½¿å¾— $b = aq$ï¼Œåˆ™ç§° $a$ æ•´é™¤ $b$ï¼Œè®°ä½œ $a \mid b$ã€‚

**å®šä¹‰ 1.1.2** (ä¸æ•´é™¤)
å¦‚æœ $a$ ä¸æ•´é™¤ $b$ï¼Œè®°ä½œ $a \nmid b$ã€‚

### 1.2 çº¦æ•°å’Œå€æ•°

**å®šä¹‰ 1.2.1** (çº¦æ•°)
å¦‚æœ $a \mid b$ï¼Œåˆ™ç§° $a$ æ˜¯ $b$ çš„çº¦æ•°ï¼ˆæˆ–å› å­ï¼‰ã€‚

**å®šä¹‰ 1.2.2** (å€æ•°)
å¦‚æœ $a \mid b$ï¼Œåˆ™ç§° $b$ æ˜¯ $a$ çš„å€æ•°ã€‚

### 1.3 çœŸçº¦æ•°

**å®šä¹‰ 1.3.1** (çœŸçº¦æ•°)
è®¾ $a \in \mathbb{Z}$ï¼Œ$d$ æ˜¯ $a$ çš„çº¦æ•°ï¼Œå¦‚æœ $1 < d < |a|$ï¼Œåˆ™ç§° $d$ æ˜¯ $a$ çš„çœŸçº¦æ•°ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ•´é™¤çš„å…¬ç†åŒ–å®šä¹‰

**å®šä¹‰ 2.1.1** (æ•´é™¤å…³ç³»)
æ•´é™¤å…³ç³» $\mid$ æ˜¯ $\mathbb{Z} \times \mathbb{Z}$ ä¸Šçš„äºŒå…ƒå…³ç³»ï¼Œæ»¡è¶³ï¼š

1. è‡ªåæ€§ï¼š$a \mid a$ å¯¹æ‰€æœ‰ $a \in \mathbb{Z}$ æˆç«‹
2. ä¼ é€’æ€§ï¼šå¦‚æœ $a \mid b$ ä¸” $b \mid c$ï¼Œåˆ™ $a \mid c$
3. åå¯¹ç§°æ€§ï¼šå¦‚æœ $a \mid b$ ä¸” $b \mid a$ï¼Œåˆ™ $a = \pm b$

### 2.2 æœ€å¤§å…¬çº¦æ•°

**å®šä¹‰ 2.2.1** (æœ€å¤§å…¬çº¦æ•°)
è®¾ $a, b \in \mathbb{Z}$ï¼Œä¸å…¨ä¸ºé›¶ï¼Œ$d$ æ˜¯ $a$ å’Œ $b$ çš„å…¬çº¦æ•°ï¼Œå¦‚æœå¯¹ä»»æ„å…¬çº¦æ•° $c$ éƒ½æœ‰ $c \mid d$ï¼Œåˆ™ç§° $d$ æ˜¯ $a$ å’Œ $b$ çš„æœ€å¤§å…¬çº¦æ•°ï¼Œè®°ä½œ $\gcd(a, b)$ã€‚

### 2.3 æœ€å°å…¬å€æ•°

**å®šä¹‰ 2.3.1** (æœ€å°å…¬å€æ•°)
è®¾ $a, b \in \mathbb{Z}$ï¼Œ$m$ æ˜¯ $a$ å’Œ $b$ çš„å…¬å€æ•°ï¼Œå¦‚æœå¯¹ä»»æ„å…¬å€æ•° $n$ éƒ½æœ‰ $m \mid n$ï¼Œåˆ™ç§° $m$ æ˜¯ $a$ å’Œ $b$ çš„æœ€å°å…¬å€æ•°ï¼Œè®°ä½œ $\operatorname{lcm}(a, b)$ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 æ•´é™¤çš„åŸºæœ¬æ€§è´¨

**å®šç† 3.1.1** (æ•´é™¤çš„åŸºæœ¬æ€§è´¨)
è®¾ $a, b, c \in \mathbb{Z}$ï¼Œåˆ™ï¼š

1. å¦‚æœ $a \mid b$ ä¸” $b \mid c$ï¼Œåˆ™ $a \mid c$
2. å¦‚æœ $a \mid b$ ä¸” $a \mid c$ï¼Œåˆ™ $a \mid (bx + cy)$ å¯¹æ‰€æœ‰ $x, y \in \mathbb{Z}$ æˆç«‹
3. å¦‚æœ $a \mid b$ï¼Œåˆ™ $|a| \leq |b|$ æˆ– $b = 0$

**è¯æ˜**ï¼š

1. ç”±å®šä¹‰ï¼Œå­˜åœ¨ $q_1, q_2 \in \mathbb{Z}$ ä½¿å¾— $b = aq_1$ å’Œ $c = bq_2$ï¼Œå› æ­¤ $c = a(q_1q_2)$ï¼Œå³ $a \mid c$ã€‚

2. å­˜åœ¨ $q_1, q_2 \in \mathbb{Z}$ ä½¿å¾— $b = aq_1$ å’Œ $c = aq_2$ï¼Œå› æ­¤ï¼š
   $$bx + cy = aq_1x + aq_2y = a(q_1x + q_2y)$$
   æ‰€ä»¥ $a \mid (bx + cy)$ã€‚

3. å¦‚æœ $b \neq 0$ï¼Œåˆ™ $|a| \leq |b|$ï¼Œå› ä¸º $b = aq$ ä¸” $q \neq 0$ï¼Œæ‰€ä»¥ $|b| = |a| \cdot |q| \geq |a|$ã€‚

### 3.2 å¸¦ä½™é™¤æ³•

**å®šç† 3.2.1** (å¸¦ä½™é™¤æ³•)
è®¾ $a, b \in \mathbb{Z}$ï¼Œ$b \neq 0$ï¼Œåˆ™å­˜åœ¨å”¯ä¸€çš„æ•´æ•° $q$ å’Œ $r$ ä½¿å¾—ï¼š
$$a = bq + r \quad \text{ä¸”} \quad 0 \leq r < |b|$$

**è¯æ˜**ï¼š
å­˜åœ¨æ€§ï¼šè€ƒè™‘é›†åˆ $S = \{a - bx : x \in \mathbb{Z}\}$ï¼Œç”±è‰¯åºåŸç†ï¼Œ$S$ ä¸­æœ‰æœ€å°éè´Ÿå…ƒç´  $r = a - bq$ã€‚

å”¯ä¸€æ€§ï¼šå‡è®¾ $a = bq_1 + r_1 = bq_2 + r_2$ï¼Œå…¶ä¸­ $0 \leq r_1, r_2 < |b|$ï¼Œåˆ™ï¼š
$$b(q_1 - q_2) = r_2 - r_1$$

ç”±äº $|r_2 - r_1| < |b|$ï¼Œæ‰€ä»¥ $q_1 = q_2$ ä¸” $r_1 = r_2$ã€‚

### 3.3 æ¬§å‡ é‡Œå¾—ç®—æ³•

**å®šç† 3.3.1** (æ¬§å‡ é‡Œå¾—ç®—æ³•)
è®¾ $a, b \in \mathbb{Z}$ï¼Œä¸å…¨ä¸ºé›¶ï¼Œåˆ™ï¼š
$$\gcd(a, b) = \gcd(b, a \bmod b)$$

**è¯æ˜**ï¼š
è®¾ $d = \gcd(a, b)$ï¼Œ$d' = \gcd(b, a \bmod b)$ã€‚

ç”±äº $d \mid a$ ä¸” $d \mid b$ï¼Œæ‰€ä»¥ $d \mid (a \bmod b)$ï¼Œå› æ­¤ $d \mid d'$ã€‚

ç”±äº $d' \mid b$ ä¸” $d' \mid (a \bmod b)$ï¼Œæ‰€ä»¥ $d' \mid a$ï¼Œå› æ­¤ $d' \mid d$ã€‚

å› æ­¤ $d = d'$ã€‚

### 3.4 è´ç¥–å®šç†

**å®šç† 3.4.1** (è´ç¥–å®šç†)
è®¾ $a, b \in \mathbb{Z}$ï¼Œä¸å…¨ä¸ºé›¶ï¼Œåˆ™å­˜åœ¨ $x, y \in \mathbb{Z}$ ä½¿å¾—ï¼š
$$ax + by = \gcd(a, b)$$

**è¯æ˜**ï¼š
è€ƒè™‘é›†åˆ $S = \{ax + by : x, y \in \mathbb{Z}\}$ï¼Œè®¾ $d$ æ˜¯ $S$ ä¸­çš„æœ€å°æ­£æ•´æ•°ã€‚

é¦–å…ˆè¯æ˜ $d \mid a$ å’Œ $d \mid b$ï¼š
ç”±å¸¦ä½™é™¤æ³•ï¼Œ$a = dq + r$ï¼Œå…¶ä¸­ $0 \leq r < d$ã€‚
å¦‚æœ $r > 0$ï¼Œåˆ™ $r = a - dq \in S$ï¼Œä¸ $d$ çš„æœ€å°æ€§çŸ›ç›¾ã€‚
å› æ­¤ $r = 0$ï¼Œå³ $d \mid a$ã€‚åŒç† $d \mid b$ã€‚

ç„¶åè¯æ˜ $d = \gcd(a, b)$ï¼š
ç”±äº $d \in S$ï¼Œå­˜åœ¨ $x, y \in \mathbb{Z}$ ä½¿å¾— $d = ax + by$ã€‚
å¯¹ä»»æ„å…¬çº¦æ•° $c$ï¼Œ$c \mid (ax + by) = d$ï¼Œå› æ­¤ $d = \gcd(a, b)$ã€‚

## 4. ä»£ç å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::HashMap;

/// æ•´é™¤ç†è®ºå®ç°
pub struct DivisibilityTheory;

impl DivisibilityTheory {
    /// æ£€æŸ¥æ•´é™¤å…³ç³»
    pub fn divides(a: i64, b: i64) -> bool {
        if a == 0 {
            b == 0
        } else {
            b % a == 0
        }
    }
    
    /// è®¡ç®—æœ€å¤§å…¬çº¦æ•°
    pub fn gcd(mut a: i64, mut b: i64) -> i64 {
        a = a.abs();
        b = b.abs();
        
        while b != 0 {
            let temp = b;
            b = a % b;
            a = temp;
        }
        
        a
    }
    
    /// æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•
    pub fn extended_gcd(a: i64, b: i64) -> (i64, i64, i64) {
        if b == 0 {
            (a, 1, 0)
        } else {
            let (gcd, x, y) = Self::extended_gcd(b, a % b);
            (gcd, y, x - (a / b) * y)
        }
    }
    
    /// è®¡ç®—æœ€å°å…¬å€æ•°
    pub fn lcm(a: i64, b: i64) -> i64 {
        if a == 0 || b == 0 {
            0
        } else {
            (a.abs() / Self::gcd(a, b)) * b.abs()
        }
    }
    
    /// è·å–æ‰€æœ‰çº¦æ•°
    pub fn get_divisors(n: i64) -> Vec<i64> {
        let mut divisors = Vec::new();
        let n_abs = n.abs();
        
        for i in 1..=(n_abs as f64).sqrt() as i64 + 1 {
            if n_abs % i == 0 {
                divisors.push(i);
                if i != n_abs / i {
                    divisors.push(n_abs / i);
                }
            }
        }
        
        divisors.sort();
        divisors
    }
    
    /// è·å–çœŸçº¦æ•°
    pub fn get_proper_divisors(n: i64) -> Vec<i64> {
        let mut divisors = Self::get_divisors(n);
        divisors.retain(|&x| x != 1 && x != n.abs());
        divisors
    }
    
    /// è®¡ç®—çº¦æ•°ä¸ªæ•°
    pub fn count_divisors(n: i64) -> i32 {
        let prime_factors = Self::prime_factorization(n.abs());
        prime_factors.values().map(|&exp| exp + 1).product()
    }
    
    /// è®¡ç®—çº¦æ•°å’Œ
    pub fn sum_divisors(n: i64) -> i64 {
        let prime_factors = Self::prime_factorization(n.abs());
        prime_factors.iter().map(|(&prime, &exp)| {
            (prime.pow(exp + 1) - 1) / (prime - 1)
        }).product()
    }
    
    /// ç´ å› å­åˆ†è§£
    pub fn prime_factorization(mut n: i64) -> HashMap<i64, u32> {
        let mut factors = HashMap::new();
        
        // å¤„ç†2
        let mut count = 0;
        while n % 2 == 0 {
            count += 1;
            n /= 2;
        }
        if count > 0 {
            factors.insert(2, count);
        }
        
        // å¤„ç†å¥‡æ•°
        let mut i = 3;
        while i * i <= n {
            count = 0;
            while n % i == 0 {
                count += 1;
                n /= i;
            }
            if count > 0 {
                factors.insert(i, count);
            }
            i += 2;
        }
        
        if n > 1 {
            factors.insert(n, 1);
        }
        
        factors
    }
    
    /// æ£€æŸ¥å®Œå…¨æ•°
    pub fn is_perfect(n: i64) -> bool {
        if n <= 0 {
            return false;
        }
        Self::sum_proper_divisors(n) == n
    }
    
    /// è®¡ç®—çœŸçº¦æ•°å’Œ
    pub fn sum_proper_divisors(n: i64) -> i64 {
        Self::sum_divisors(n) - n.abs()
    }
    
    /// æ£€æŸ¥äº²å’Œæ•°
    pub fn are_amicable(a: i64, b: i64) -> bool {
        a > 0 && b > 0 && 
        Self::sum_proper_divisors(a) == b && 
        Self::sum_proper_divisors(b) == a
    }
}

/// çº¿æ€§åŒä½™æ–¹ç¨‹æ±‚è§£
pub struct LinearCongruence;

impl LinearCongruence {
    /// æ±‚è§£çº¿æ€§åŒä½™æ–¹ç¨‹ ax â‰¡ b (mod m)
    pub fn solve(a: i64, b: i64, m: i64) -> Option<Vec<i64>> {
        let (gcd, x, _) = DivisibilityTheory::extended_gcd(a, m);
        
        if b % gcd != 0 {
            None
        } else {
            let x0 = (x * (b / gcd)) % m;
            let solutions: Vec<i64> = (0..gcd).map(|k| {
                (x0 + k * (m / gcd)) % m
            }).collect();
            Some(solutions)
        }
    }
    
    /// ä¸­å›½å‰©ä½™å®šç†
    pub fn chinese_remainder_theorem(remainders: &[i64], moduli: &[i64]) -> Option<i64> {
        if remainders.len() != moduli.len() {
            return None;
        }
        
        let mut result = 0;
        let mut product = 1;
        
        for &m in moduli {
            product *= m;
        }
        
        for i in 0..remainders.len() {
            let pi = product / moduli[i];
            let (_, inv, _) = DivisibilityTheory::extended_gcd(pi, moduli[i]);
            let inv = (inv % moduli[i] + moduli[i]) % moduli[i];
            result = (result + remainders[i] * pi * inv) % product;
        }
        
        Some(result)
    }
}

/// æ•°è®ºå‡½æ•°
pub struct NumberTheoreticFunctions;

impl NumberTheoreticFunctions {
    /// æ¬§æ‹‰å‡½æ•° Ï†(n)
    pub fn euler_totient(n: i64) -> i64 {
        if n <= 0 {
            return 0;
        }
        
        let prime_factors = DivisibilityTheory::prime_factorization(n);
        prime_factors.iter().fold(n, |acc, (&prime, &exp)| {
            acc * (prime - 1) / prime
        })
    }
    
    /// è«æ¯”ä¹Œæ–¯å‡½æ•° Î¼(n)
    pub fn mobius_function(n: i64) -> i32 {
        if n <= 0 {
            return 0;
        }
        
        let prime_factors = DivisibilityTheory::prime_factorization(n);
        if prime_factors.values().any(|&exp| exp > 1) {
            0
        } else {
            if prime_factors.len() % 2 == 0 {
                1
            } else {
                -1
            }
        }
    }
    
    /// é™¤æ•°å‡½æ•° Ïƒ_k(n)
    pub fn divisor_function(n: i64, k: i32) -> i64 {
        if n <= 0 {
            return 0;
        }
        
        let prime_factors = DivisibilityTheory::prime_factorization(n);
        prime_factors.iter().map(|(&prime, &exp)| {
            let mut sum = 0;
            let mut power = 1;
            for _ in 0..=exp {
                sum += power;
                power *= prime.pow(k as u32);
            }
            sum
        }).product()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_divides() {
        assert!(DivisibilityTheory::divides(3, 12));
        assert!(!DivisibilityTheory::divides(5, 12));
        assert!(DivisibilityTheory::divides(0, 0));
        assert!(!DivisibilityTheory::divides(0, 1));
    }
    
    #[test]
    fn test_gcd() {
        assert_eq!(DivisibilityTheory::gcd(48, 18), 6);
        assert_eq!(DivisibilityTheory::gcd(0, 5), 5);
        assert_eq!(DivisibilityTheory::gcd(-48, 18), 6);
    }
    
    #[test]
    fn test_extended_gcd() {
        let (gcd, x, y) = DivisibilityTheory::extended_gcd(48, 18);
        assert_eq!(gcd, 6);
        assert_eq!(48 * x + 18 * y, 6);
    }
    
    #[test]
    fn test_lcm() {
        assert_eq!(DivisibilityTheory::lcm(12, 18), 36);
        assert_eq!(DivisibilityTheory::lcm(0, 5), 0);
    }
    
    #[test]
    fn test_divisors() {
        let divisors = DivisibilityTheory::get_divisors(12);
        assert_eq!(divisors, vec![1, 2, 3, 4, 6, 12]);
    }
    
    #[test]
    fn test_prime_factorization() {
        let factors = DivisibilityTheory::prime_factorization(84);
        let expected: HashMap<i64, u32> = [(2, 2), (3, 1), (7, 1)].iter().cloned().collect();
        assert_eq!(factors, expected);
    }
    
    #[test]
    fn test_perfect_number() {
        assert!(DivisibilityTheory::is_perfect(6));
        assert!(DivisibilityTheory::is_perfect(28));
        assert!(!DivisibilityTheory::is_perfect(10));
    }
    
    #[test]
    fn test_linear_congruence() {
        let solutions = LinearCongruence::solve(3, 2, 7);
        assert_eq!(solutions, Some(vec![3]));
    }
    
    #[test]
    fn test_euler_totient() {
        assert_eq!(NumberTheoreticFunctions::euler_totient(12), 4);
        assert_eq!(NumberTheoreticFunctions::euler_totient(7), 6);
    }
}
```

### 4.2 Haskell å®ç°

```haskell
-- æ•´é™¤ç†è®º
module DivisibilityTheory where

import Data.List
import qualified Data.Map as Map

-- æ£€æŸ¥æ•´é™¤å…³ç³»
divides :: Integer -> Integer -> Bool
divides a b = if a == 0 then b == 0 else b `mod` a == 0

-- æœ€å¤§å…¬çº¦æ•°
gcd :: Integer -> Integer -> Integer
gcd a b = gcd' (abs a) (abs b)
  where
    gcd' a 0 = a
    gcd' a b = gcd' b (a `mod` b)

-- æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•
extendedGcd :: Integer -> Integer -> (Integer, Integer, Integer)
extendedGcd a 0 = (a, 1, 0)
extendedGcd a b = (g, y, x - (a `div` b) * y)
  where
    (g, x, y) = extendedGcd b (a `mod` b)

-- æœ€å°å…¬å€æ•°
lcm :: Integer -> Integer -> Integer
lcm a b = if a == 0 || b == 0 then 0 else (abs a `div` gcd a b) * abs b

-- è·å–æ‰€æœ‰çº¦æ•°
getDivisors :: Integer -> [Integer]
getDivisors n = sort [d | d <- [1..abs n], abs n `mod` d == 0]

-- è·å–çœŸçº¦æ•°
getProperDivisors :: Integer -> [Integer]
getProperDivisors n = [d | d <- getDivisors n, d /= 1, d /= abs n]

-- ç´ å› å­åˆ†è§£
primeFactorization :: Integer -> Map.Map Integer Integer
primeFactorization n = go n 2 Map.empty
  where
    go 1 _ factors = factors
    go n p factors
      | p * p > n = Map.insert n 1 factors
      | n `mod` p == 0 = go (n `div` p) p (Map.insertWith (+) p 1 factors)
      | otherwise = go n (p + 1) factors

-- çº¦æ•°ä¸ªæ•°
countDivisors :: Integer -> Integer
countDivisors n = product [exp + 1 | (_, exp) <- Map.toList (primeFactorization n)]

-- çº¦æ•°å’Œ
sumDivisors :: Integer -> Integer
sumDivisors n = product [sum [p^k | k <- [0..exp]] | (p, exp) <- Map.toList (primeFactorization n)]

-- çœŸçº¦æ•°å’Œ
sumProperDivisors :: Integer -> Integer
sumProperDivisors n = sumDivisors n - abs n

-- å®Œå…¨æ•°æ£€æŸ¥
isPerfect :: Integer -> Bool
isPerfect n = n > 0 && sumProperDivisors n == n

-- äº²å’Œæ•°æ£€æŸ¥
areAmicable :: Integer -> Integer -> Bool
areAmicable a b = a > 0 && b > 0 && 
                  sumProperDivisors a == b && 
                  sumProperDivisors b == a

-- çº¿æ€§åŒä½™æ–¹ç¨‹æ±‚è§£
solveLinearCongruence :: Integer -> Integer -> Integer -> Maybe [Integer]
solveLinearCongruence a b m = 
  let (g, x, _) = extendedGcd a m
  in if b `mod` g /= 0 
     then Nothing
     else Just [x0 + k * (m `div` g) | k <- [0..g-1]]
  where
    x0 = (x * (b `div` g)) `mod` m

-- ä¸­å›½å‰©ä½™å®šç†
chineseRemainderTheorem :: [Integer] -> [Integer] -> Maybe Integer
chineseRemainderTheorem remainders moduli
  | length remainders /= length moduli = Nothing
  | otherwise = Just result
  where
    product = product moduli
    result = sum [remainder * pi * inv | 
                  (remainder, modulus) <- zip remainders moduli,
                  let pi = product `div` modulus,
                  let (_, inv, _) = extendedGcd pi modulus,
                  let inv' = (inv `mod` modulus + modulus) `mod` modulus]
    result = result `mod` product

-- æ¬§æ‹‰å‡½æ•°
eulerTotient :: Integer -> Integer
eulerTotient n = if n <= 0 then 0 else go n
  where
    go 1 = 1
    go n = n * product [(p - 1) `div` p | (p, _) <- Map.toList (primeFactorization n)]

-- è«æ¯”ä¹Œæ–¯å‡½æ•°
mobiusFunction :: Integer -> Integer
mobiusFunction n
  | n <= 0 = 0
  | any (> 1) (Map.elems factors) = 0
  | odd (length factors) = -1
  | otherwise = 1
  where
    factors = primeFactorization n

-- é™¤æ•°å‡½æ•°
divisorFunction :: Integer -> Integer -> Integer
divisorFunction n k = if n <= 0 then 0 else product [sum [p^(k*exp') | exp' <- [0..exp]] | (p, exp) <- Map.toList (primeFactorization n)]

-- æµ‹è¯•å‡½æ•°
testDivisibility :: IO ()
testDivisibility = do
    putStrLn "æ•´é™¤å…³ç³»æµ‹è¯•:"
    print $ divides 3 12
    print $ divides 5 12
    
    putStrLn "æœ€å¤§å…¬çº¦æ•°æµ‹è¯•:"
    print $ gcd 48 18
    
    putStrLn "çº¦æ•°æµ‹è¯•:"
    print $ getDivisors 12
    
    putStrLn "å®Œå…¨æ•°æµ‹è¯•:"
    print $ isPerfect 6
    print $ isPerfect 28
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å¯†ç å­¦ä¸­çš„åº”ç”¨

```rust
/// RSA åŠ å¯†ç³»ç»Ÿ
pub struct RSA {
    public_key: (i64, i64),
    private_key: (i64, i64),
}

impl RSA {
    /// ç”ŸæˆRSAå¯†é’¥å¯¹
    pub fn generate_key_pair(bit_length: usize) -> Self {
        // ç”Ÿæˆå¤§ç´ æ•°
        let p = Self::generate_prime(bit_length / 2);
        let q = Self::generate_prime(bit_length / 2);
        
        let n = p * q;
        let phi_n = (p - 1) * (q - 1);
        
        // é€‰æ‹©å…¬é’¥æŒ‡æ•°
        let e = 65537; // å¸¸ç”¨çš„å…¬é’¥æŒ‡æ•°
        
        // è®¡ç®—ç§é’¥æŒ‡æ•°
        let (_, d, _) = DivisibilityTheory::extended_gcd(e, phi_n);
        let d = (d % phi_n + phi_n) % phi_n;
        
        Self {
            public_key: (n, e),
            private_key: (n, d),
        }
    }
    
    /// åŠ å¯†
    pub fn encrypt(&self, message: i64) -> i64 {
        Self::modular_pow(message, self.public_key.1, self.public_key.0)
    }
    
    /// è§£å¯†
    pub fn decrypt(&self, ciphertext: i64) -> i64 {
        Self::modular_pow(ciphertext, self.private_key.1, self.private_key.0)
    }
    
    /// æ¨¡å¹‚è¿ç®—
    fn modular_pow(mut base: i64, mut exponent: i64, modulus: i64) -> i64 {
        let mut result = 1;
        base %= modulus;
        
        while exponent > 0 {
            if exponent % 2 == 1 {
                result = (result * base) % modulus;
            }
            base = (base * base) % modulus;
            exponent /= 2;
        }
        
        result
    }
    
    /// ç”Ÿæˆç´ æ•°ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
    fn generate_prime(bit_length: usize) -> i64 {
        // å®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨æ›´å®‰å…¨çš„ç´ æ•°ç”Ÿæˆç®—æ³•
        let mut candidate = (1 << (bit_length - 1)) + 1;
        while !Self::is_prime(candidate) {
            candidate += 2;
        }
        candidate
    }
    
    /// ç´ æ•°æ£€æµ‹ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
    fn is_prime(n: i64) -> bool {
        if n < 2 {
            return false;
        }
        if n == 2 {
            return true;
        }
        if n % 2 == 0 {
            return false;
        }
        
        for i in (3..=(n as f64).sqrt() as i64).step_by(2) {
            if n % i == 0 {
                return false;
            }
        }
        true
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let rsa = RSA::generate_key_pair(32);
    
    let message = 12345;
    let encrypted = rsa.encrypt(message);
    let decrypted = rsa.decrypt(encrypted);
    
    println!("åŸå§‹æ¶ˆæ¯: {}", message);
    println!("åŠ å¯†å: {}", encrypted);
    println!("è§£å¯†å: {}", decrypted);
    println!("è§£å¯†æˆåŠŸ: {}", message == decrypted);
}
```

### 5.2 ç®—æ³•ä¼˜åŒ–ä¸­çš„åº”ç”¨

```rust
/// å¿«é€Ÿå¹‚ç®—æ³•
pub struct FastPower;

impl FastPower {
    /// å¿«é€Ÿå¹‚
    pub fn pow(mut base: i64, mut exponent: u64) -> i64 {
        let mut result = 1;
        
        while exponent > 0 {
            if exponent % 2 == 1 {
                result *= base;
            }
            base *= base;
            exponent /= 2;
        }
        
        result
    }
    
    /// æ¨¡å¹‚è¿ç®—
    pub fn modular_pow(mut base: i64, mut exponent: u64, modulus: i64) -> i64 {
        let mut result = 1;
        base %= modulus;
        
        while exponent > 0 {
            if exponent % 2 == 1 {
                result = (result * base) % modulus;
            }
            base = (base * base) % modulus;
            exponent /= 2;
        }
        
        result
    }
}

/// æ–æ³¢é‚£å¥‘æ•°åˆ—ä¼˜åŒ–
pub struct Fibonacci;

impl Fibonacci {
    /// çŸ©é˜µå¿«é€Ÿå¹‚è®¡ç®—æ–æ³¢é‚£å¥‘æ•°
    pub fn fast_fibonacci(n: u64) -> i64 {
        if n <= 1 {
            return n as i64;
        }
        
        let matrix = [[1, 1], [1, 0]];
        let result = Self::matrix_pow(matrix, n - 1);
        result[0][0]
    }
    
    /// çŸ©é˜µå¿«é€Ÿå¹‚
    fn matrix_pow(mut matrix: [[i64; 2]; 2], mut exponent: u64) -> [[i64; 2]; 2] {
        let mut result = [[1, 0], [0, 1]];
        
        while exponent > 0 {
            if exponent % 2 == 1 {
                result = Self::matrix_multiply(result, matrix);
            }
            matrix = Self::matrix_multiply(matrix, matrix);
            exponent /= 2;
        }
        
        result
    }
    
    /// çŸ©é˜µä¹˜æ³•
    fn matrix_multiply(a: [[i64; 2]; 2], b: [[i64; 2]; 2]) -> [[i64; 2]; 2] {
        [
            [a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]],
            [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]],
        ]
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸åŒä½™ç†è®ºçš„å…³ç³»

æ•´é™¤ç†è®ºä¸åŒä½™ç†è®ºç´§å¯†ç›¸å…³ï¼Œé€šè¿‡åŒä½™å…³ç³»å¯ä»¥æ›´æ·±å…¥åœ°ç ”ç©¶æ•´é™¤æ€§è´¨ã€‚

### 6.2 ä¸ç´ æ•°ç†è®ºçš„å…³ç³»

**å®šç† 6.2.1** (ç®—æœ¯åŸºæœ¬å®šç†)
æ¯ä¸ªå¤§äº1çš„æ•´æ•°éƒ½å¯ä»¥å”¯ä¸€åœ°è¡¨ç¤ºä¸ºç´ æ•°çš„ä¹˜ç§¯ã€‚

### 6.3 ä¸ä»£æ•°æ•°è®ºçš„å…³ç³»

æ•´é™¤ç†è®ºä¸ºä»£æ•°æ•°è®ºä¸­çš„ç†æƒ³ç†è®ºæä¾›åŸºç¡€ï¼Œåœ¨ä»£æ•°æ•´æ•°ç¯ä¸­ç ”ç©¶æ•´é™¤å…³ç³»ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. **Hardy, G. H., & Wright, E. M.** (2008). *An Introduction to the Theory of Numbers*. Oxford University Press.
2. **Ireland, K., & Rosen, M.** (1990). *A Classical Introduction to Modern Number Theory*. Springer.
3. **Niven, I., Zuckerman, H. S., & Montgomery, H. L.** (1991). *An Introduction to the Theory of Numbers*. Wiley.
4. **Rosen, K. H.** (2011). *Elementary Number Theory and Its Applications*. Pearson.
5. **Davenport, H.** (2008). *The Higher Arithmetic: An Introduction to the Theory of Numbers*. Cambridge University Press.

---

**ç›¸å…³æ–‡æ¡£**:

- [02.10.2 åŒä½™ç†è®º](../02.10.2_åŒä½™ç†è®º.md)
- [02.10.3 ç´ æ•°ç†è®º](../02.10.3_ç´ æ•°ç†è®º.md)
- [02.10.4 äºŒæ¬¡å‰©ä½™](../02.10.4_äºŒæ¬¡å‰©ä½™.md)
- [02.3.1 è‡ªç„¶æ•°ç³»ç»Ÿ](../02.3.1_è‡ªç„¶æ•°ç³»ç»Ÿ.md)
- [02.3.2 æ•´æ•°ç³»ç»Ÿ](../02.3.2_æ•´æ•°ç³»ç»Ÿ.md)


## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
