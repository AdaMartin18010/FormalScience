# 02.6.1 ç¾¤è®ºåŸºç¡€

## ğŸ“‹ æ¦‚è¿°

ç¾¤è®ºæ˜¯ä»£æ•°å­¦çš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶å…·æœ‰ç‰¹å®šä»£æ•°ç»“æ„çš„é›†åˆã€‚ç¾¤è®ºåœ¨æ•°å­¦ã€ç‰©ç†å­¦ã€åŒ–å­¦ã€è®¡ç®—æœºç§‘å­¦ç­‰é¢†åŸŸå…·æœ‰å¹¿æ³›åº”ç”¨ã€‚æœ¬æ–‡æ¡£å»ºç«‹ç¾¤è®ºåŸºç¡€çš„å½¢å¼åŒ–ç†è®ºæ¡†æ¶ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹ç¾¤çš„å½¢å¼åŒ–å®šä¹‰**
2. **ç ”ç©¶ç¾¤çš„åŸºæœ¬æ€§è´¨**
3. **æ¢è®¨ç¾¤çš„åˆ†ç±»**
4. **åˆ†æç¾¤çš„å­ç¾¤å’ŒåŒæ€**
5. **æ„å»ºç¾¤è®ºçš„åº”ç”¨æ¡†æ¶**

## ğŸ“š ç›®å½•

- [02.6.1 ç¾¤è®ºåŸºç¡€](#0261-ç¾¤è®ºåŸºç¡€)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒç›®æ ‡](#-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 ç¾¤çš„å®šä¹‰](#11-ç¾¤çš„å®šä¹‰)
    - [1.2 ç¾¤çš„åŸºæœ¬æ¦‚å¿µ](#12-ç¾¤çš„åŸºæœ¬æ¦‚å¿µ)
  - [2. å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
    - [2.1 ç¾¤çš„å…¬ç†åŒ–å®šä¹‰](#21-ç¾¤çš„å…¬ç†åŒ–å®šä¹‰)
    - [2.2 å­ç¾¤çš„å½¢å¼åŒ–å®šä¹‰](#22-å­ç¾¤çš„å½¢å¼åŒ–å®šä¹‰)
    - [2.3 ç¾¤åŒæ€](#23-ç¾¤åŒæ€)
  - [3. å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
    - [3.1 æ‹‰æ ¼æœ—æ—¥å®šç†](#31-æ‹‰æ ¼æœ—æ—¥å®šç†)
    - [3.2 åŒæ€åŸºæœ¬å®šç†](#32-åŒæ€åŸºæœ¬å®šç†)
    - [3.3 è¥¿ç½—å®šç†](#33-è¥¿ç½—å®šç†)
  - [4. ä»£ç å®ç°](#4-ä»£ç å®ç°)
    - [4.1 Rustå®ç°](#41-rustå®ç°)
    - [4.2 Haskellå®ç°](#42-haskellå®ç°)
  - [5. åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
    - [5.1 ç¾¤è¿ç®—åº”ç”¨](#51-ç¾¤è¿ç®—åº”ç”¨)
    - [5.2 ç¾¤åŒæ€åº”ç”¨](#52-ç¾¤åŒæ€åº”ç”¨)
  - [6. ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
    - [6.1 ä¸ç¯è®ºçš„å…³ç³»](#61-ä¸ç¯è®ºçš„å…³ç³»)
    - [6.2 ä¸åŸŸè®ºçš„å…³ç³»](#62-ä¸åŸŸè®ºçš„å…³ç³»)
    - [6.3 ä¸çº¿æ€§ä»£æ•°çš„å…³ç³»](#63-ä¸çº¿æ€§ä»£æ•°çš„å…³ç³»)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç¾¤çš„å®šä¹‰

**å®šä¹‰ 1.1** (ç¾¤)
ç¾¤æ˜¯ä¸€ä¸ªäºŒå…ƒç»„ $(G, \cdot)$ï¼Œå…¶ä¸­ $G$ æ˜¯ä¸€ä¸ªéç©ºé›†åˆï¼Œ$\cdot$ æ˜¯ $G$ ä¸Šçš„äºŒå…ƒè¿ç®—ï¼Œæ»¡è¶³ä»¥ä¸‹å…¬ç†ï¼š

1. **å°é—­æ€§**ï¼š$\forall a, b \in G. a \cdot b \in G$
2. **ç»“åˆå¾‹**ï¼š$\forall a, b, c \in G. (a \cdot b) \cdot c = a \cdot (b \cdot c)$
3. **å•ä½å…ƒ**ï¼š$\exists e \in G. \forall a \in G. e \cdot a = a \cdot e = a$
4. **é€†å…ƒ**ï¼š$\forall a \in G. \exists a^{-1} \in G. a \cdot a^{-1} = a^{-1} \cdot a = e$

**å®šä¹‰ 1.2** (é˜¿è´å°”ç¾¤)
å¦‚æœç¾¤ $(G, \cdot)$ è¿˜æ»¡è¶³äº¤æ¢å¾‹ï¼š
$\forall a, b \in G. a \cdot b = b \cdot a$

åˆ™ç§° $G$ ä¸ºé˜¿è´å°”ç¾¤ï¼ˆäº¤æ¢ç¾¤ï¼‰ã€‚

### 1.2 ç¾¤çš„åŸºæœ¬æ¦‚å¿µ

**å®šä¹‰ 1.3** (ç¾¤çš„é˜¶)
ç¾¤ $G$ çš„é˜¶æ˜¯é›†åˆ $G$ çš„åŸºæ•°ï¼Œè®°ä¸º $|G|$ã€‚

**å®šä¹‰ 1.4** (å…ƒç´ çš„é˜¶)
å…ƒç´  $a \in G$ çš„é˜¶æ˜¯æ»¡è¶³ $a^n = e$ çš„æœ€å°æ­£æ•´æ•° $n$ï¼Œå¦‚æœä¸å­˜åœ¨è¿™æ ·çš„ $n$ï¼Œåˆ™ç§° $a$ çš„é˜¶ä¸ºæ— ç©·ã€‚

**å®šä¹‰ 1.5** (å­ç¾¤)
ç¾¤ $G$ çš„å­é›† $H$ æ˜¯ $G$ çš„å­ç¾¤ï¼Œå¦‚æœ $H$ åœ¨ $G$ çš„è¿ç®—ä¸‹æ„æˆç¾¤ï¼Œè®°ä¸º $H \leq G$ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ç¾¤çš„å…¬ç†åŒ–å®šä¹‰

**å®šä¹‰ 2.1** (ç¾¤å…¬ç†)
ç¾¤ $(G, \cdot)$ æ»¡è¶³ä»¥ä¸‹å…¬ç†ï¼š

1. **G1** (å°é—­æ€§)ï¼š$\forall a, b \in G. a \cdot b \in G$
2. **G2** (ç»“åˆå¾‹)ï¼š$\forall a, b, c \in G. (a \cdot b) \cdot c = a \cdot (b \cdot c)$
3. **G3** (å·¦å•ä½å…ƒ)ï¼š$\exists e \in G. \forall a \in G. e \cdot a = a$
4. **G4** (å·¦é€†å…ƒ)ï¼š$\forall a \in G. \exists a^{-1} \in G. a^{-1} \cdot a = e$

**å®šç† 2.1** (å•ä½å…ƒå”¯ä¸€æ€§)
ç¾¤çš„å•ä½å…ƒæ˜¯å”¯ä¸€çš„ã€‚

**è¯æ˜**ï¼š
å‡è®¾ $e$ å’Œ $e'$ éƒ½æ˜¯å•ä½å…ƒï¼Œåˆ™ï¼š
$e = e \cdot e' = e'$ $\square$

**å®šç† 2.2** (é€†å…ƒå”¯ä¸€æ€§)
ç¾¤ä¸­æ¯ä¸ªå…ƒç´ çš„é€†å…ƒæ˜¯å”¯ä¸€çš„ã€‚

**è¯æ˜**ï¼š
å‡è®¾ $a^{-1}$ å’Œ $a'$ éƒ½æ˜¯ $a$ çš„é€†å…ƒï¼Œåˆ™ï¼š
$a^{-1} = a^{-1} \cdot e = a^{-1} \cdot (a \cdot a') = (a^{-1} \cdot a) \cdot a' = e \cdot a' = a'$ $\square$

### 2.2 å­ç¾¤çš„å½¢å¼åŒ–å®šä¹‰

**å®šä¹‰ 2.2** (å­ç¾¤åˆ¤å®š)
å­é›† $H \subseteq G$ æ˜¯å­ç¾¤ï¼Œå½“ä¸”ä»…å½“ï¼š

1. $H \neq \emptyset$
2. $\forall a, b \in H. a \cdot b \in H$ (å°é—­æ€§)
3. $\forall a \in H. a^{-1} \in H$ (é€†å…ƒå°é—­æ€§)

**å®šç† 2.3** (å­ç¾¤åˆ¤å®šå®šç†)
å­é›† $H \subseteq G$ æ˜¯å­ç¾¤ï¼Œå½“ä¸”ä»…å½“ï¼š

$$\forall a, b \in H. a \cdot b^{-1} \in H$$

**è¯æ˜**ï¼š
å¿…è¦æ€§ï¼šå¦‚æœ $H$ æ˜¯å­ç¾¤ï¼Œåˆ™ $b^{-1} \in H$ï¼Œæ‰€ä»¥ $a \cdot b^{-1} \in H$ã€‚

å……åˆ†æ€§ï¼š

1. å– $a = b$ï¼Œåˆ™ $e = a \cdot a^{-1} \in H$
2. å– $a = e$ï¼Œåˆ™ $b^{-1} = e \cdot b^{-1} \in H$
3. å¯¹äºä»»æ„ $a, b \in H$ï¼Œ$a \cdot b = a \cdot (b^{-1})^{-1} \in H$ $\square$

### 2.3 ç¾¤åŒæ€

**å®šä¹‰ 2.3** (ç¾¤åŒæ€)
è®¾ $(G, \cdot)$ å’Œ $(H, *)$ æ˜¯ä¸¤ä¸ªç¾¤ï¼Œæ˜ å°„ $\phi: G \rightarrow H$ æ˜¯ç¾¤åŒæ€ï¼Œå¦‚æœï¼š

$$\forall a, b \in G. \phi(a \cdot b) = \phi(a) * \phi(b)$$

**å®šä¹‰ 2.4** (ç¾¤åŒæ„)
ç¾¤åŒæ€ $\phi: G \rightarrow H$ æ˜¯ç¾¤åŒæ„ï¼Œå¦‚æœ $\phi$ æ˜¯åŒå°„ã€‚

**å®šä¹‰ 2.5** (æ ¸å’Œåƒ)
ç¾¤åŒæ€ $\phi: G \rightarrow H$ çš„æ ¸å’Œåƒå®šä¹‰ä¸ºï¼š

- **æ ¸**ï¼š$\ker(\phi) = \{a \in G : \phi(a) = e_H\}$
- **åƒ**ï¼š$\text{im}(\phi) = \{\phi(a) : a \in G\}$

## 3. å®šç†ä¸è¯æ˜

### 3.1 æ‹‰æ ¼æœ—æ—¥å®šç†

**å®šç† 3.1** (æ‹‰æ ¼æœ—æ—¥å®šç†)
å¦‚æœ $H$ æ˜¯æœ‰é™ç¾¤ $G$ çš„å­ç¾¤ï¼Œåˆ™ $|H|$ æ•´é™¤ $|G|$ã€‚

**è¯æ˜**ï¼š
å®šä¹‰ $G$ ä¸Šçš„ç­‰ä»·å…³ç³»ï¼š$a \sim b$ å½“ä¸”ä»…å½“ $a \cdot b^{-1} \in H$ã€‚

æ¯ä¸ªç­‰ä»·ç±»çš„å…ƒç´ ä¸ªæ•°ç­‰äº $|H|$ï¼Œå› æ­¤ $|G| = |H| \cdot [G : H]$ï¼Œå…¶ä¸­ $[G : H]$ æ˜¯ $H$ åœ¨ $G$ ä¸­çš„æŒ‡æ•°ã€‚$\square$

**æ¨è®º 3.1**
æœ‰é™ç¾¤ä¸­å…ƒç´ çš„é˜¶æ•´é™¤ç¾¤çš„é˜¶ã€‚

**è¯æ˜**ï¼š
å…ƒç´  $a$ ç”Ÿæˆçš„å¾ªç¯å­ç¾¤ $\langle a \rangle$ çš„é˜¶ç­‰äº $a$ çš„é˜¶ï¼Œæ ¹æ®æ‹‰æ ¼æœ—æ—¥å®šç†ï¼Œ$|\langle a \rangle|$ æ•´é™¤ $|G|$ã€‚$\square$

### 3.2 åŒæ€åŸºæœ¬å®šç†

**å®šç† 3.2** (åŒæ€åŸºæœ¬å®šç†)
è®¾ $\phi: G \rightarrow H$ æ˜¯ç¾¤åŒæ€ï¼Œåˆ™ï¼š

$$G / \ker(\phi) \cong \text{im}(\phi)$$

**è¯æ˜**ï¼š
å®šä¹‰æ˜ å°„ $\psi: G / \ker(\phi) \rightarrow \text{im}(\phi)$ ä¸ºï¼š
$\psi(a \ker(\phi)) = \phi(a)$

å¯ä»¥è¯æ˜ $\psi$ æ˜¯è‰¯å®šä¹‰çš„ç¾¤åŒæ„ã€‚$\square$

### 3.3 è¥¿ç½—å®šç†

**å®šç† 3.3** (è¥¿ç½—ç¬¬ä¸€å®šç†)
è®¾ $G$ æ˜¯æœ‰é™ç¾¤ï¼Œ$p$ æ˜¯ç´ æ•°ï¼Œ$p^k$ æ•´é™¤ $|G|$ï¼Œåˆ™ $G$ åŒ…å«é˜¶ä¸º $p^k$ çš„å­ç¾¤ã€‚

**å®šç† 3.4** (è¥¿ç½—ç¬¬äºŒå®šç†)
è®¾ $G$ æ˜¯æœ‰é™ç¾¤ï¼Œ$p$ æ˜¯ç´ æ•°ï¼Œåˆ™ $G$ çš„æ‰€æœ‰è¥¿ç½— $p$-å­ç¾¤å…±è½­ã€‚

**å®šç† 3.5** (è¥¿ç½—ç¬¬ä¸‰å®šç†)
è®¾ $G$ æ˜¯æœ‰é™ç¾¤ï¼Œ$p$ æ˜¯ç´ æ•°ï¼Œ$n_p$ æ˜¯è¥¿ç½— $p$-å­ç¾¤çš„ä¸ªæ•°ï¼Œåˆ™ $n_p \equiv 1 \pmod{p}$ ä¸” $n_p$ æ•´é™¤ $|G|$ã€‚

## 4. ä»£ç å®ç°

### 4.1 Rustå®ç°

```rust
use std::collections::HashMap;
use std::fmt;
use std::hash::Hash;

/// ç¾¤å…ƒç´ ç‰¹å¾
pub trait GroupElement: Clone + Eq + Hash + fmt::Debug {
    /// å•ä½å…ƒ
    fn identity() -> Self;
    /// é€†å…ƒ
    fn inverse(&self) -> Self;
    /// ç¾¤è¿ç®—
    fn multiply(&self, other: &Self) -> Self;
    /// å¹‚è¿ç®—
    fn power(&self, n: i32) -> Self {
        if n == 0 {
            Self::identity()
        } else if n > 0 {
            let mut result = self.clone();
            for _ in 1..n {
                result = result.multiply(self);
            }
            result
        } else {
            let mut result = self.inverse();
            for _ in 1..(-n) {
                result = result.multiply(&self.inverse());
            }
            result
        }
    }
}

/// ç¾¤ç»“æ„
#[derive(Debug, Clone)]
pub struct Group<T: GroupElement> {
    elements: Vec<T>,
    operation_table: HashMap<(T, T), T>,
}

impl<T: GroupElement> Group<T> {
    /// åˆ›å»ºæ–°ç¾¤
    pub fn new(elements: Vec<T>) -> Self {
        let mut group = Self {
            elements: elements.clone(),
            operation_table: HashMap::new(),
        };
        
        // æ„å»ºè¿ç®—è¡¨
        for a in &elements {
            for b in &elements {
                let result = a.multiply(b);
                group.operation_table.insert((a.clone(), b.clone()), result);
            }
        }
        
        group
    }

    /// è·å–ç¾¤çš„é˜¶
    pub fn order(&self) -> usize {
        self.elements.len()
    }

    /// æ£€æŸ¥å…ƒç´ æ˜¯å¦åœ¨ç¾¤ä¸­
    pub fn contains(&self, element: &T) -> bool {
        self.elements.contains(element)
    }

    /// ç¾¤è¿ç®—
    pub fn multiply(&self, a: &T, b: &T) -> Option<&T> {
        self.operation_table.get(&(a.clone(), b.clone()))
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºé˜¿è´å°”ç¾¤
    pub fn is_abelian(&self) -> bool {
        for a in &self.elements {
            for b in &self.elements {
                if self.multiply(a, b) != self.multiply(b, a) {
                    return false;
                }
            }
        }
        true
    }

    /// è·å–å…ƒç´ çš„é˜¶
    pub fn element_order(&self, element: &T) -> Option<usize> {
        let mut power = element.clone();
        let mut order = 1;
        
        while power != T::identity() {
            power = power.multiply(element);
            order += 1;
            
            if order > self.order() {
                return None; // æ— ç©·é˜¶
            }
        }
        
        Some(order)
    }

    /// ç”Ÿæˆå­ç¾¤
    pub fn generate_subgroup(&self, generators: &[T]) -> Group<T> {
        let mut subgroup_elements = vec![T::identity()];
        let mut new_elements = generators.to_vec();
        
        while !new_elements.is_empty() {
            let mut next_elements = Vec::new();
            
            for element in &new_elements {
                if !subgroup_elements.contains(element) {
                    subgroup_elements.push(element.clone());
                    
                    // ç”Ÿæˆæ–°çš„å…ƒç´ 
                    for existing in &subgroup_elements {
                        let product = element.multiply(existing);
                        if !subgroup_elements.contains(&product) && !next_elements.contains(&product) {
                            next_elements.push(product);
                        }
                    }
                }
            }
            
            new_elements = next_elements;
        }
        
        Group::new(subgroup_elements)
    }

    /// æ£€æŸ¥å­ç¾¤
    pub fn is_subgroup(&self, other: &Group<T>) -> bool {
        for element in &other.elements {
            if !self.contains(element) {
                return false;
            }
        }
        
        // æ£€æŸ¥è¿ç®—å°é—­æ€§
        for a in &other.elements {
            for b in &other.elements {
                if let Some(result) = self.multiply(a, b) {
                    if !other.contains(result) {
                        return false;
                    }
                }
            }
        }
        
        true
    }
}

/// æ•´æ•°æ¨¡nç¾¤
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuloGroup {
    value: i32,
    modulus: i32,
}

impl ModuloGroup {
    pub fn new(value: i32, modulus: i32) -> Self {
        Self {
            value: ((value % modulus) + modulus) % modulus,
            modulus,
        }
    }
}

impl GroupElement for ModuloGroup {
    fn identity() -> Self {
        ModuloGroup::new(0, 1)
    }

    fn inverse(&self) -> Self {
        // ä½¿ç”¨æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚é€†
        let mut a = self.value;
        let mut b = self.modulus;
        let mut x = 1;
        let mut y = 0;
        
        while b != 0 {
            let q = a / b;
            let temp = b;
            b = a % b;
            a = temp;
            let temp = y;
            y = x - q * y;
            x = temp;
        }
        
        ModuloGroup::new(x, self.modulus)
    }

    fn multiply(&self, other: &Self) -> Self {
        if self.modulus != other.modulus {
            panic!("ä¸åŒæ¨¡æ•°çš„å…ƒç´ ä¸èƒ½ç›¸ä¹˜");
        }
        ModuloGroup::new(self.value * other.value, self.modulus)
    }
}

/// ç¾¤åŒæ€
pub struct GroupHomomorphism<G: GroupElement, H: GroupElement> {
    mapping: HashMap<G, H>,
}

impl<G: GroupElement, H: GroupElement> GroupHomomorphism<G, H> {
    pub fn new() -> Self {
        Self {
            mapping: HashMap::new(),
        }
    }

    pub fn add_mapping(&mut self, from: G, to: H) {
        self.mapping.insert(from, to);
    }

    pub fn apply(&self, element: &G) -> Option<&H> {
        self.mapping.get(element)
    }

    pub fn is_homomorphism(&self, source_group: &Group<G>, target_group: &Group<H>) -> bool {
        for a in &source_group.elements {
            for b in &source_group.elements {
                if let (Some(phi_a), Some(phi_b), Some(phi_ab)) = (
                    self.apply(a),
                    self.apply(b),
                    self.apply(&a.multiply(b))
                ) {
                    if phi_ab != &phi_a.multiply(phi_b) {
                        return false;
                    }
                }
            }
        }
        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_modulo_group() {
        let g1 = ModuloGroup::new(3, 7);
        let g2 = ModuloGroup::new(5, 7);
        
        let product = g1.multiply(&g2);
        assert_eq!(product, ModuloGroup::new(15 % 7, 7));
        
        let inverse = g1.inverse();
        let identity = g1.multiply(&inverse);
        assert_eq!(identity, ModuloGroup::new(0, 7));
    }

    #[test]
    fn test_group_creation() {
        let elements = vec![
            ModuloGroup::new(0, 4),
            ModuloGroup::new(1, 4),
            ModuloGroup::new(2, 4),
            ModuloGroup::new(3, 4),
        ];
        
        let group = Group::new(elements);
        assert_eq!(group.order(), 4);
        assert!(group.is_abelian());
    }

    #[test]
    fn test_subgroup() {
        let elements = vec![
            ModuloGroup::new(0, 6),
            ModuloGroup::new(1, 6),
            ModuloGroup::new(2, 6),
            ModuloGroup::new(3, 6),
            ModuloGroup::new(4, 6),
            ModuloGroup::new(5, 6),
        ];
        
        let group = Group::new(elements);
        let subgroup = group.generate_subgroup(&[ModuloGroup::new(2, 6)]);
        
        assert!(group.is_subgroup(&subgroup));
        assert_eq!(subgroup.order(), 3);
    }
}
```

### 4.2 Haskellå®ç°

```haskell
-- ç¾¤ç±»å‹ç±»
class (Eq a, Show a) => Group a where
  -- å•ä½å…ƒ
  identity :: a
  -- é€†å…ƒ
  inverse :: a -> a
  -- ç¾¤è¿ç®—
  multiply :: a -> a -> a
  -- å¹‚è¿ç®—
  power :: a -> Integer -> a
  power a n
    | n == 0 = identity
    | n > 0 = foldr multiply identity (replicate (fromIntegral n) a)
    | otherwise = foldr multiply identity (replicate (fromIntegral (-n)) (inverse a))

-- æ•´æ•°æ¨¡nç¾¤
data ModuloGroup = ModuloGroup Integer Integer
  deriving (Show, Eq)

instance Group ModuloGroup where
  identity = ModuloGroup 0 1
  
  inverse (ModuloGroup a n) = ModuloGroup (mod (-a) n) n
  
  multiply (ModuloGroup a n) (ModuloGroup b m) = 
    if n == m 
    then ModuloGroup (mod (a * b) n) n
    else error "Different moduli"
  
  power a n = power' a n
    where
      power' _ 0 = identity
      power' a n
        | n > 0 = multiply a (power' a (n - 1))
        | otherwise = multiply (inverse a) (power' a (n + 1))

-- ç¾¤ç»“æ„
data Group a = Group [a] deriving Show

-- åˆ›å»ºç¾¤
makeGroup :: Group a => [a] -> Group a
makeGroup elements = Group elements

-- ç¾¤çš„é˜¶
groupOrder :: Group a -> Int
groupOrder (Group elements) = length elements

-- æ£€æŸ¥å…ƒç´ æ˜¯å¦åœ¨ç¾¤ä¸­
contains :: Eq a => Group a -> a -> Bool
contains (Group elements) a = a `elem` elements

-- æ£€æŸ¥æ˜¯å¦ä¸ºé˜¿è´å°”ç¾¤
isAbelian :: Group a => Group a -> Bool
isAbelian (Group elements) = 
  all (\(a, b) -> multiply a b == multiply b a) [(a, b) | a <- elements, b <- elements]

-- å…ƒç´ çš„é˜¶
elementOrder :: Group a => Group a -> a -> Maybe Integer
elementOrder group a = elementOrder' a 1
  where
    elementOrder' a n
      | power a n == identity = Just n
      | n > fromIntegral (groupOrder group) = Nothing
      | otherwise = elementOrder' a (n + 1)

-- ç”Ÿæˆå­ç¾¤
generateSubgroup :: Group a => Group a -> [a] -> Group a
generateSubgroup (Group elements) generators = 
  Group (generateSubgroup' [identity] generators)
  where
    generateSubgroup' current new
      | null new = current
      | otherwise = generateSubgroup' (current ++ new) (generateNewElements current new)
    
    generateNewElements current new = 
      nub [multiply a b | a <- new, b <- current, 
           let product = multiply a b, 
           product `notElem` current && product `notElem` new]

-- ç¾¤åŒæ€
data GroupHomomorphism a b = GroupHomomorphism [(a, b)]

-- åˆ›å»ºåŒæ€
makeHomomorphism :: [(a, b)] -> GroupHomomorphism a b
makeHomomorphism mapping = GroupHomomorphism mapping

-- åº”ç”¨åŒæ€
applyHomomorphism :: Eq a => GroupHomomorphism a b -> a -> Maybe b
applyHomomorphism (GroupHomomorphism mapping) a = lookup a mapping

-- æ£€æŸ¥æ˜¯å¦ä¸ºåŒæ€
isHomomorphism :: (Group a, Group b, Eq a, Eq b) => 
                  GroupHomomorphism a b -> Group a -> Group b -> Bool
isHomomorphism hom (Group elements) _ = 
  all (\(a, b) -> 
    case (applyHomomorphism hom a, applyHomomorphism hom b, applyHomomorphism hom (multiply a b)) of
      (Just phi_a, Just phi_b, Just phi_ab) -> multiply phi_a phi_b == phi_ab
      _ -> False
  ) [(a, b) | a <- elements, b <- elements]

-- ç¤ºä¾‹ä½¿ç”¨
example :: IO ()
example = do
  -- åˆ›å»ºæ¨¡4ç¾¤
  let elements = [ModuloGroup i 4 | i <- [0..3]]
      group = makeGroup elements
  
  putStrLn $ "ç¾¤: " ++ show group
  putStrLn $ "ç¾¤çš„é˜¶: " ++ show (groupOrder group)
  putStrLn $ "æ˜¯å¦ä¸ºé˜¿è´å°”ç¾¤: " ++ show (isAbelian group)
  
  -- æ£€æŸ¥å…ƒç´ é˜¶
  let a = ModuloGroup 1 4
  putStrLn $ "å…ƒç´  " ++ show a ++ " çš„é˜¶: " ++ show (elementOrder group a)
  
  -- ç”Ÿæˆå­ç¾¤
  let subgroup = generateSubgroup group [ModuloGroup 2 4]
  putStrLn $ "ç”± " ++ show (ModuloGroup 2 4) ++ " ç”Ÿæˆçš„å­ç¾¤: " ++ show subgroup
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç¾¤è¿ç®—åº”ç”¨

```rust
fn main() {
    // åˆ›å»ºæ¨¡6ç¾¤
    let elements = vec![
        ModuloGroup::new(0, 6),
        ModuloGroup::new(1, 6),
        ModuloGroup::new(2, 6),
        ModuloGroup::new(3, 6),
        ModuloGroup::new(4, 6),
        ModuloGroup::new(5, 6),
    ];
    
    let group = Group::new(elements);
    
    println!("ç¾¤ G çš„é˜¶: {}", group.order());
    println!("G æ˜¯å¦ä¸ºé˜¿è´å°”ç¾¤: {}", group.is_abelian());
    
    // æ£€æŸ¥å…ƒç´ é˜¶
    for i in 0..6 {
        let element = ModuloGroup::new(i, 6);
        if let Some(order) = group.element_order(&element) {
            println!("å…ƒç´  {} çš„é˜¶: {}", i, order);
        } else {
            println!("å…ƒç´  {} çš„é˜¶: æ— ç©·", i);
        }
    }
    
    // ç”Ÿæˆå­ç¾¤
    let generator = ModuloGroup::new(2, 6);
    let subgroup = group.generate_subgroup(&[generator]);
    
    println!("ç”± {} ç”Ÿæˆçš„å­ç¾¤é˜¶: {}", 2, subgroup.order());
    println!("å­ç¾¤å…ƒç´ : {:?}", subgroup.elements);
}
```

### 5.2 ç¾¤åŒæ€åº”ç”¨

```rust
fn main() {
    // åˆ›å»ºä¸¤ä¸ªç¾¤
    let g1_elements = vec![
        ModuloGroup::new(0, 4),
        ModuloGroup::new(1, 4),
        ModuloGroup::new(2, 4),
        ModuloGroup::new(3, 4),
    ];
    
    let g2_elements = vec![
        ModuloGroup::new(0, 2),
        ModuloGroup::new(1, 2),
    ];
    
    let group1 = Group::new(g1_elements);
    let group2 = Group::new(g2_elements);
    
    // åˆ›å»ºåŒæ€ï¼šf(x) = x mod 2
    let mut homomorphism = GroupHomomorphism::new();
    homomorphism.add_mapping(ModuloGroup::new(0, 4), ModuloGroup::new(0, 2));
    homomorphism.add_mapping(ModuloGroup::new(1, 4), ModuloGroup::new(1, 2));
    homomorphism.add_mapping(ModuloGroup::new(2, 4), ModuloGroup::new(0, 2));
    homomorphism.add_mapping(ModuloGroup::new(3, 4), ModuloGroup::new(1, 2));
    
    println!("åŒæ€æ˜¯å¦ä¸ºç¾¤åŒæ€: {}", 
             homomorphism.is_homomorphism(&group1, &group2));
    
    // åº”ç”¨åŒæ€
    let element = ModuloGroup::new(3, 4);
    if let Some(image) = homomorphism.apply(&element) {
        println!("f({}) = {}", element.value, image.value);
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸ç¯è®ºçš„å…³ç³»

ç¾¤è®ºä¸ºç¯è®ºæä¾›åŸºç¡€ï¼Œå‚è§ï¼š

- [02.6.2 ç¯è®ºåŸºç¡€](./02.6.2_Ring_Theory_Foundation.md)

### 6.2 ä¸åŸŸè®ºçš„å…³ç³»

ç¾¤è®ºåœ¨åŸŸè®ºä¸­æœ‰é‡è¦åº”ç”¨ï¼Œå‚è§ï¼š

- [02.6.3 åŸŸè®ºåŸºç¡€](./02.6.3_Field_Theory_Foundation.md)

### 6.3 ä¸çº¿æ€§ä»£æ•°çš„å…³ç³»

ç¾¤è®ºåœ¨çº¿æ€§ä»£æ•°ä¸­æœ‰é‡è¦åº”ç”¨ï¼Œå‚è§ï¼š

- [02.6.4 æ¨¡è®ºåŸºç¡€](./02.6.4_Module_Theory_Foundation.md)

## 7. å‚è€ƒæ–‡çŒ®

1. Herstein, I. N. (1975). *Topics in Algebra*. Wiley.
2. Dummit, D. S., & Foote, R. M. (2004). *Abstract Algebra*. Wiley.
3. Lang, S. (2002). *Algebra*. Springer.
4. Hungerford, T. W. (1974). *Algebra*. Springer.
5. Rotman, J. J. (1995). *An Introduction to the Theory of Groups*. Springer.
6. Hall, M. (1959). *The Theory of Groups*. Macmillan.
7. Zassenhaus, H. (1958). *The Theory of Groups*. Chelsea.
8. Burnside, W. (1911). *Theory of Groups of Finite Order*. Cambridge University Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.6.2 ç¯è®ºåŸºç¡€](./02.6.2_Ring_Theory_Foundation.md)
- [02.6.3 åŸŸè®ºåŸºç¡€](./02.6.3_Field_Theory_Foundation.md)
- [02.6.4 æ¨¡è®ºåŸºç¡€](./02.6.4_Module_Theory_Foundation.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
