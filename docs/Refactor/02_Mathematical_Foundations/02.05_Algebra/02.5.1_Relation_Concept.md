# 02.5.1 å…³ç³»æ¦‚å¿µ

## ğŸ“‹ æ¦‚è¿°

å…³ç³»æ¦‚å¿µæ˜¯æ•°å­¦åŸºç¡€ç†è®ºä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼Œç”¨äºæè¿°é›†åˆå…ƒç´ ä¹‹é—´çš„å…³è”ã€‚å…³ç³»ç†è®ºåœ¨é€»è¾‘å­¦ã€ä»£æ•°ã€å›¾è®ºã€æ•°æ®åº“ç†è®ºç­‰é¢†åŸŸå…·æœ‰å¹¿æ³›åº”ç”¨ã€‚æœ¬æ–‡æ¡£å»ºç«‹å…³ç³»æ¦‚å¿µçš„å½¢å¼åŒ–ç†è®ºæ¡†æ¶ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹å…³ç³»çš„å½¢å¼åŒ–å®šä¹‰**
2. **ç ”ç©¶å…³ç³»çš„åŸºæœ¬æ€§è´¨**
3. **æ¢è®¨å…³ç³»çš„åˆ†ç±»**
4. **åˆ†æå…³ç³»çš„è¿ç®—**
5. **æ„å»ºå…³ç³»çš„åº”ç”¨æ¡†æ¶**

## ğŸ“š ç›®å½•

- [02.5.1 å…³ç³»æ¦‚å¿µ](#0251-å…³ç³»æ¦‚å¿µ)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒç›®æ ‡](#-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 å…³ç³»çš„å®šä¹‰](#11-å…³ç³»çš„å®šä¹‰)
    - [1.2 å…³ç³»çš„åŸºæœ¬æ¦‚å¿µ](#12-å…³ç³»çš„åŸºæœ¬æ¦‚å¿µ)
  - [2. å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
    - [2.1 å…³ç³»çš„é›†åˆè®ºå®šä¹‰](#21-å…³ç³»çš„é›†åˆè®ºå®šä¹‰)
    - [2.2 å…³ç³»çš„è¿ç®—](#22-å…³ç³»çš„è¿ç®—)
    - [2.3 å…³ç³»çš„æ€§è´¨](#23-å…³ç³»çš„æ€§è´¨)
  - [3. å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
    - [3.1 å…³ç³»è¿ç®—çš„åŸºæœ¬æ€§è´¨](#31-å…³ç³»è¿ç®—çš„åŸºæœ¬æ€§è´¨)
    - [3.2 å…³ç³»æ€§è´¨çš„ä¿æŒ](#32-å…³ç³»æ€§è´¨çš„ä¿æŒ)
    - [3.3 å…³ç³»çš„é—­åŒ…](#33-å…³ç³»çš„é—­åŒ…)
  - [4. ä»£ç å®ç°](#4-ä»£ç å®ç°)
    - [4.1 Rustå®ç°](#41-rustå®ç°)
    - [4.2 Haskellå®ç°](#42-haskellå®ç°)
  - [5. åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
    - [5.1 å…³ç³»è¿ç®—åº”ç”¨](#51-å…³ç³»è¿ç®—åº”ç”¨)
    - [5.2 å…³ç³»æ€§è´¨åˆ†æåº”ç”¨](#52-å…³ç³»æ€§è´¨åˆ†æåº”ç”¨)
  - [6. ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
    - [6.1 ä¸é›†åˆè®ºçš„å…³ç³»](#61-ä¸é›†åˆè®ºçš„å…³ç³»)
    - [6.2 ä¸é€»è¾‘å­¦çš„å…³ç³»](#62-ä¸é€»è¾‘å­¦çš„å…³ç³»)
    - [6.3 ä¸å‡½æ•°è®ºçš„å…³ç³»](#63-ä¸å‡½æ•°è®ºçš„å…³ç³»)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å…³ç³»çš„å®šä¹‰

**å®šä¹‰ 1.1** (äºŒå…ƒå…³ç³»)
è®¾ $A$ å’Œ $B$ æ˜¯ä¸¤ä¸ªé›†åˆï¼Œ$A$ åˆ° $B$ çš„äºŒå…ƒå…³ç³» $R$ æ˜¯ç¬›å¡å°”ç§¯ $A \times B$ çš„ä¸€ä¸ªå­é›†ï¼š

$$R \subseteq A \times B$$

**å®šä¹‰ 1.2** (nå…ƒå…³ç³»)
è®¾ $A_1, A_2, \ldots, A_n$ æ˜¯ $n$ ä¸ªé›†åˆï¼Œ$n$ å…ƒå…³ç³» $R$ æ˜¯ç¬›å¡å°”ç§¯ $A_1 \times A_2 \times \cdots \times A_n$ çš„ä¸€ä¸ªå­é›†ï¼š

$$R \subseteq A_1 \times A_2 \times \cdots \times A_n$$

### 1.2 å…³ç³»çš„åŸºæœ¬æ¦‚å¿µ

**å®šä¹‰ 1.3** (å…³ç³»çš„å®šä¹‰åŸŸå’Œå€¼åŸŸ)
å¯¹äºå…³ç³» $R \subseteq A \times B$ï¼š

- **å®šä¹‰åŸŸ**ï¼š$\text{dom}(R) = \{a \in A : \exists b \in B. (a, b) \in R\}$
- **å€¼åŸŸ**ï¼š$\text{ran}(R) = \{b \in B : \exists a \in A. (a, b) \in R\}$

**å®šä¹‰ 1.4** (å…³ç³»çš„é€†)
å…³ç³» $R \subseteq A \times B$ çš„é€†å…³ç³»å®šä¹‰ä¸ºï¼š

$$R^{-1} = \{(b, a) : (a, b) \in R\} \subseteq B \times A$$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å…³ç³»çš„é›†åˆè®ºå®šä¹‰

**å®šä¹‰ 2.1** (å…³ç³»ä½œä¸ºé›†åˆ)
å…³ç³»å¯ä»¥å®Œå…¨ç”¨é›†åˆè®ºè¯­è¨€å®šä¹‰ï¼š

$$R = \{(a, b) : a \in A \land b \in B \land P(a, b)\}$$

å…¶ä¸­ $P(a, b)$ æ˜¯æè¿°å…³ç³»æ€§è´¨çš„è°“è¯ã€‚

**å®šä¹‰ 2.2** (å…³ç³»çš„ç‰¹å¾å‡½æ•°)
å…³ç³» $R \subseteq A \times B$ çš„ç‰¹å¾å‡½æ•°å®šä¹‰ä¸ºï¼š

$$\chi_R : A \times B \rightarrow \{0, 1\}$$

$$
\chi_R(a, b) = \begin{cases}
1 & \text{if } (a, b) \in R \\
0 & \text{if } (a, b) \notin R
\end{cases}
$$

### 2.2 å…³ç³»çš„è¿ç®—

**å®šä¹‰ 2.3** (å…³ç³»çš„å¹¶)
ä¸¤ä¸ªå…³ç³» $R, S \subseteq A \times B$ çš„å¹¶å®šä¹‰ä¸ºï¼š

$$R \cup S = \{(a, b) : (a, b) \in R \lor (a, b) \in S\}$$

**å®šä¹‰ 2.4** (å…³ç³»çš„äº¤)
ä¸¤ä¸ªå…³ç³» $R, S \subseteq A \times B$ çš„äº¤å®šä¹‰ä¸ºï¼š

$$R \cap S = \{(a, b) : (a, b) \in R \land (a, b) \in S\}$$

**å®šä¹‰ 2.5** (å…³ç³»çš„å·®)
ä¸¤ä¸ªå…³ç³» $R, S \subseteq A \times B$ çš„å·®å®šä¹‰ä¸ºï¼š

$$R \setminus S = \{(a, b) : (a, b) \in R \land (a, b) \notin S\}$$

**å®šä¹‰ 2.6** (å…³ç³»çš„å¤åˆ)
å…³ç³» $R \subseteq A \times B$ å’Œ $S \subseteq B \times C$ çš„å¤åˆå®šä¹‰ä¸ºï¼š

$$R \circ S = \{(a, c) : \exists b \in B. (a, b) \in R \land (b, c) \in S\}$$

### 2.3 å…³ç³»çš„æ€§è´¨

**å®šä¹‰ 2.7** (è‡ªåæ€§)
å…³ç³» $R \subseteq A \times A$ æ˜¯è‡ªåçš„ï¼Œå½“ä¸”ä»…å½“ï¼š

$$\forall a \in A. (a, a) \in R$$

**å®šä¹‰ 2.8** (å¯¹ç§°æ€§)
å…³ç³» $R \subseteq A \times A$ æ˜¯å¯¹ç§°çš„ï¼Œå½“ä¸”ä»…å½“ï¼š

$$\forall a, b \in A. (a, b) \in R \Rightarrow (b, a) \in R$$

**å®šä¹‰ 2.9** (åå¯¹ç§°æ€§)
å…³ç³» $R \subseteq A \times A$ æ˜¯åå¯¹ç§°çš„ï¼Œå½“ä¸”ä»…å½“ï¼š

$$\forall a, b \in A. (a, b) \in R \land (b, a) \in R \Rightarrow a = b$$

**å®šä¹‰ 2.10** (ä¼ é€’æ€§)
å…³ç³» $R \subseteq A \times A$ æ˜¯ä¼ é€’çš„ï¼Œå½“ä¸”ä»…å½“ï¼š

$$\forall a, b, c \in A. (a, b) \in R \land (b, c) \in R \Rightarrow (a, c) \in R$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 å…³ç³»è¿ç®—çš„åŸºæœ¬æ€§è´¨

**å®šç† 3.1** (å…³ç³»è¿ç®—çš„ç»“åˆå¾‹)
å…³ç³»çš„å¤åˆè¿ç®—æ»¡è¶³ç»“åˆå¾‹ï¼š

$$(R \circ S) \circ T = R \circ (S \circ T)$$

**è¯æ˜**ï¼š
å¯¹äºä»»æ„ $(a, d) \in (R \circ S) \circ T$ï¼Œå­˜åœ¨ $c$ ä½¿å¾— $(a, c) \in R \circ S$ ä¸” $(c, d) \in T$ã€‚
åˆå­˜åœ¨ $b$ ä½¿å¾— $(a, b) \in R$ ä¸” $(b, c) \in S$ã€‚
å› æ­¤ $(a, b) \in R$ ä¸” $(b, d) \in S \circ T$ï¼Œæ‰€ä»¥ $(a, d) \in R \circ (S \circ T)$ã€‚
åŒç†å¯è¯åå‘åŒ…å«ã€‚$\square$

**å®šç† 3.2** (å…³ç³»é€†çš„æ€§è´¨)
å¯¹äºå…³ç³» $R, S \subseteq A \times B$ï¼š

1. $(R^{-1})^{-1} = R$
2. $(R \cup S)^{-1} = R^{-1} \cup S^{-1}$
3. $(R \cap S)^{-1} = R^{-1} \cap S^{-1}$
4. $(R \circ S)^{-1} = S^{-1} \circ R^{-1}$

**è¯æ˜**ï¼š

1. $(R^{-1})^{-1} = \{(a, b) : (b, a) \in R^{-1}\} = \{(a, b) : (a, b) \in R\} = R$
2. $(R \cup S)^{-1} = \{(b, a) : (a, b) \in R \cup S\} = \{(b, a) : (a, b) \in R \lor (a, b) \in S\} = R^{-1} \cup S^{-1}$
3. ç±»ä¼¼å¯è¯
4. $(R \circ S)^{-1} = \{(c, a) : (a, c) \in R \circ S\} = \{(c, a) : \exists b. (a, b) \in R \land (b, c) \in S\} = S^{-1} \circ R^{-1}$ $\square$

### 3.2 å…³ç³»æ€§è´¨çš„ä¿æŒ

**å®šç† 3.3** (å…³ç³»æ€§è´¨çš„ä¿æŒ)
è®¾ $R, S \subseteq A \times A$ æ˜¯è‡ªåï¼ˆå¯¹ç§°ã€ä¼ é€’ï¼‰å…³ç³»ï¼Œåˆ™ï¼š

1. $R \cap S$ æ˜¯è‡ªåï¼ˆå¯¹ç§°ã€ä¼ é€’ï¼‰çš„
2. $R \cup S$ æ˜¯è‡ªåçš„ï¼Œä½†ä¸ä¸€å®šæ˜¯å¯¹ç§°æˆ–ä¼ é€’çš„

**è¯æ˜**ï¼š

1. **è‡ªåæ€§**ï¼šå¯¹äºä»»æ„ $a \in A$ï¼Œ$(a, a) \in R$ ä¸” $(a, a) \in S$ï¼Œæ‰€ä»¥ $(a, a) \in R \cap S$
2. **å¯¹ç§°æ€§**ï¼šå¯¹äºä»»æ„ $(a, b) \in R \cap S$ï¼Œ$(a, b) \in R$ ä¸” $(a, b) \in S$ï¼Œæ‰€ä»¥ $(b, a) \in R$ ä¸” $(b, a) \in S$ï¼Œå› æ­¤ $(b, a) \in R \cap S$
3. **ä¼ é€’æ€§**ï¼šå¯¹äºä»»æ„ $(a, b), (b, c) \in R \cap S$ï¼Œ$(a, b), (b, c) \in R$ ä¸” $(a, b), (b, c) \in S$ï¼Œæ‰€ä»¥ $(a, c) \in R$ ä¸” $(a, c) \in S$ï¼Œå› æ­¤ $(a, c) \in R \cap S$ $\square$

### 3.3 å…³ç³»çš„é—­åŒ…

**å®šç† 3.4** (å…³ç³»çš„ä¼ é€’é—­åŒ…)
å¯¹äºå…³ç³» $R \subseteq A \times A$ï¼Œå…¶ä¼ é€’é—­åŒ…å®šä¹‰ä¸ºï¼š

$$R^+ = \bigcup_{n=1}^{\infty} R^n$$

å…¶ä¸­ $R^n = R \circ R \circ \cdots \circ R$ï¼ˆnæ¬¡å¤åˆï¼‰ã€‚

**è¯æ˜**ï¼š

1. $R \subseteq R^+$ï¼ˆå½“ $n=1$ æ—¶ï¼‰
2. ä¼ é€’æ€§ï¼šå¯¹äºä»»æ„ $(a, b), (b, c) \in R^+$ï¼Œå­˜åœ¨ $m, n$ ä½¿å¾— $(a, b) \in R^m$ ä¸” $(b, c) \in R^n$ï¼Œå› æ­¤ $(a, c) \in R^{m+n} \subseteq R^+$
3. æœ€å°æ€§ï¼šä»»ä½•åŒ…å« $R$ çš„ä¼ é€’å…³ç³»éƒ½åŒ…å« $R^+$ $\square$

## 4. ä»£ç å®ç°

### 4.1 Rustå®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::fmt;
use std::hash::Hash;

/// äºŒå…ƒå…³ç³»
# [derive(Debug, Clone)]
pub struct BinaryRelation<T> {
    /// å…³ç³»é›†åˆ
    pairs: HashSet<(T, T)>,
    /// å®šä¹‰åŸŸ
    domain: HashSet<T>,
    /// å€¼åŸŸ
    codomain: HashSet<T>,
}

impl<T: Hash + Eq + Clone> BinaryRelation<T> {
    /// åˆ›å»ºç©ºå…³ç³»
    pub fn new() -> Self {
        Self {
            pairs: HashSet::new(),
            domain: HashSet::new(),
            codomain: HashSet::new(),
        }
    }

    /// æ·»åŠ å…³ç³»å¯¹
    pub fn add_pair(&mut self, a: T, b: T) {
        self.pairs.insert((a.clone(), b.clone()));
        self.domain.insert(a);
        self.codomain.insert(b);
    }

    /// æ£€æŸ¥å…³ç³»å¯¹æ˜¯å¦å­˜åœ¨
    pub fn contains(&self, a: &T, b: &T) -> bool {
        self.pairs.contains(&(a.clone(), b.clone()))
    }

    /// è·å–å®šä¹‰åŸŸ
    pub fn domain(&self) -> &HashSet<T> {
        &self.domain
    }

    /// è·å–å€¼åŸŸ
    pub fn codomain(&self) -> &HashSet<T> {
        &self.codomain
    }

    /// è·å–æ‰€æœ‰å…³ç³»å¯¹
    pub fn pairs(&self) -> &HashSet<(T, T)> {
        &self.pairs
    }

    /// å…³ç³»çš„é€†
    pub fn inverse(&self) -> BinaryRelation<T> {
        let mut inv = BinaryRelation::new();
        for (a, b) in &self.pairs {
            inv.add_pair(b.clone(), a.clone());
        }
        inv
    }

    /// å…³ç³»çš„å¹¶
    pub fn union(&self, other: &BinaryRelation<T>) -> BinaryRelation<T> {
        let mut result = self.clone();
        for (a, b) in &other.pairs {
            result.add_pair(a.clone(), b.clone());
        }
        result
    }

    /// å…³ç³»çš„äº¤
    pub fn intersection(&self, other: &BinaryRelation<T>) -> BinaryRelation<T> {
        let mut result = BinaryRelation::new();
        for (a, b) in &self.pairs {
            if other.contains(a, b) {
                result.add_pair(a.clone(), b.clone());
            }
        }
        result
    }

    /// å…³ç³»çš„å·®
    pub fn difference(&self, other: &BinaryRelation<T>) -> BinaryRelation<T> {
        let mut result = BinaryRelation::new();
        for (a, b) in &self.pairs {
            if !other.contains(a, b) {
                result.add_pair(a.clone(), b.clone());
            }
        }
        result
    }

    /// å…³ç³»çš„å¤åˆ
    pub fn compose(&self, other: &BinaryRelation<T>) -> BinaryRelation<T> {
        let mut result = BinaryRelation::new();
        for (a, b) in &self.pairs {
            for (c, d) in &other.pairs {
                if b == c {
                    result.add_pair(a.clone(), d.clone());
                }
            }
        }
        result
    }

    /// æ£€æŸ¥è‡ªåæ€§
    pub fn is_reflexive(&self) -> bool {
        for a in &self.domain {
            if !self.contains(a, a) {
                return false;
            }
        }
        true
    }

    /// æ£€æŸ¥å¯¹ç§°æ€§
    pub fn is_symmetric(&self) -> bool {
        for (a, b) in &self.pairs {
            if !self.contains(b, a) {
                return false;
            }
        }
        true
    }

    /// æ£€æŸ¥åå¯¹ç§°æ€§
    pub fn is_antisymmetric(&self) -> bool {
        for (a, b) in &self.pairs {
            if a != b && self.contains(b, a) {
                return false;
            }
        }
        true
    }

    /// æ£€æŸ¥ä¼ é€’æ€§
    pub fn is_transitive(&self) -> bool {
        for (a, b) in &self.pairs {
            for (c, d) in &self.pairs {
                if b == c && !self.contains(a, d) {
                    return false;
                }
            }
        }
        true
    }

    /// è®¡ç®—ä¼ é€’é—­åŒ…
    pub fn transitive_closure(&self) -> BinaryRelation<T> {
        let mut closure = self.clone();
        let mut changed = true;

        while changed {
            changed = false;
            let mut new_pairs = HashSet::new();

            for (a, b) in &closure.pairs {
                for (c, d) in &closure.pairs {
                    if b == c && !closure.contains(a, d) {
                        new_pairs.insert((a.clone(), d.clone()));
                        changed = true;
                    }
                }
            }

            for (a, b) in new_pairs {
                closure.add_pair(a, b);
            }
        }

        closure
    }
}

/// å…³ç³»ç±»å‹æšä¸¾
# [derive(Debug, Clone, PartialEq)]
pub enum RelationType {
    Reflexive,
    Symmetric,
    Antisymmetric,
    Transitive,
    Equivalence,
    PartialOrder,
    TotalOrder,
}

impl<T: Hash + Eq + Clone> BinaryRelation<T> {
    /// åˆ¤æ–­å…³ç³»ç±»å‹
    pub fn relation_type(&self) -> Vec<RelationType> {
        let mut types = Vec::new();

        if self.is_reflexive() {
            types.push(RelationType::Reflexive);
        }
        if self.is_symmetric() {
            types.push(RelationType::Symmetric);
        }
        if self.is_antisymmetric() {
            types.push(RelationType::Antisymmetric);
        }
        if self.is_transitive() {
            types.push(RelationType::Transitive);
        }

        // ç­‰ä»·å…³ç³»
        if self.is_reflexive() && self.is_symmetric() && self.is_transitive() {
            types.push(RelationType::Equivalence);
        }

        // ååºå…³ç³»
        if self.is_reflexive() && self.is_antisymmetric() && self.is_transitive() {
            types.push(RelationType::PartialOrder);
        }

        types
    }
}

# [cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_binary_relation() {
        let mut relation = BinaryRelation::new();

        // æ·»åŠ å…³ç³»å¯¹
        relation.add_pair(1, 2);
        relation.add_pair(2, 3);
        relation.add_pair(1, 3);

        assert!(relation.contains(&1, &2));
        assert!(relation.contains(&2, &3));
        assert!(relation.contains(&1, &3));
        assert!(!relation.contains(&2, &1));
    }

    #[test]
    fn test_relation_operations() {
        let mut r1 = BinaryRelation::new();
        r1.add_pair(1, 2);
        r1.add_pair(2, 3);

        let mut r2 = BinaryRelation::new();
        r2.add_pair(2, 3);
        r2.add_pair(3, 4);

        // å¤åˆ
        let composition = r1.compose(&r2);
        assert!(composition.contains(&1, &3));
        assert!(composition.contains(&2, &4));
    }

    #[test]
    fn test_relation_properties() {
        let mut relation = BinaryRelation::new();

        // åˆ›å»ºç­‰ä»·å…³ç³»
        relation.add_pair(1, 1);
        relation.add_pair(2, 2);
        relation.add_pair(3, 3);
        relation.add_pair(1, 2);
        relation.add_pair(2, 1);
        relation.add_pair(2, 3);
        relation.add_pair(3, 2);
        relation.add_pair(1, 3);
        relation.add_pair(3, 1);

        assert!(relation.is_reflexive());
        assert!(relation.is_symmetric());
        assert!(relation.is_transitive());

        let types = relation.relation_type();
        assert!(types.contains(&RelationType::Equivalence));
    }
}
```

### 4.2 Haskellå®ç°

```haskell
-- äºŒå…ƒå…³ç³»ç±»å‹
type BinaryRelation a = [(a, a)]

-- åˆ›å»ºç©ºå…³ç³»
emptyRelation :: BinaryRelation a
emptyRelation = []

-- æ·»åŠ å…³ç³»å¯¹
addPair :: Eq a => a -> a -> BinaryRelation a -> BinaryRelation a
addPair a b relation = (a, b) : relation

-- æ£€æŸ¥å…³ç³»å¯¹æ˜¯å¦å­˜åœ¨
contains :: Eq a => a -> a -> BinaryRelation a -> Bool
contains a b relation = (a, b) `elem` relation

-- è·å–å®šä¹‰åŸŸ
domain :: BinaryRelation a -> [a]
domain relation = nub [a | (a, _) <- relation]

-- è·å–å€¼åŸŸ
codomain :: BinaryRelation a -> [a]
codomain relation = nub [b | (_, b) <- relation]

-- å…³ç³»çš„é€†
inverse :: BinaryRelation a -> BinaryRelation a
inverse relation = [(b, a) | (a, b) <- relation]

-- å…³ç³»çš„å¹¶
union :: Eq a => BinaryRelation a -> BinaryRelation a -> BinaryRelation a
union r1 r2 = nub (r1 ++ r2)

-- å…³ç³»çš„äº¤
intersection :: Eq a => BinaryRelation a -> BinaryRelation a -> BinaryRelation a
intersection r1 r2 = [(a, b) | (a, b) <- r1, (a, b) `elem` r2]

-- å…³ç³»çš„å·®
difference :: Eq a => BinaryRelation a -> BinaryRelation a -> BinaryRelation a
difference r1 r2 = [(a, b) | (a, b) <- r1, (a, b) `notElem` r2]

-- å…³ç³»çš„å¤åˆ
compose :: Eq a => BinaryRelation a -> BinaryRelation a -> BinaryRelation a
compose r1 r2 = nub [(a, c) | (a, b) <- r1, (b', c) <- r2, b == b']

-- æ£€æŸ¥è‡ªåæ€§
isReflexive :: Eq a => BinaryRelation a -> Bool
isReflexive relation = all (\a -> contains a a relation) (domain relation)

-- æ£€æŸ¥å¯¹ç§°æ€§
isSymmetric :: Eq a => BinaryRelation a -> Bool
isSymmetric relation = all (\(a, b) -> contains b a relation) relation

-- æ£€æŸ¥åå¯¹ç§°æ€§
isAntisymmetric :: Eq a => BinaryRelation a -> Bool
isAntisymmetric relation = all (\(a, b) -> a == b || not (contains b a relation)) relation

-- æ£€æŸ¥ä¼ é€’æ€§
isTransitive :: Eq a => BinaryRelation a -> Bool
isTransitive relation = all (\(a, b) -> all (\(c, d) -> b /= c || contains a d relation) relation) relation

-- ä¼ é€’é—­åŒ…
transitiveClosure :: Eq a => BinaryRelation a -> BinaryRelation a
transitiveClosure relation = fix (\r -> union relation (compose r r))
  where
    fix f = let x = f x in x

-- å…³ç³»ç±»å‹
data RelationType = Reflexive | Symmetric | Antisymmetric | Transitive | Equivalence | PartialOrder
  deriving (Show, Eq)

-- åˆ¤æ–­å…³ç³»ç±»å‹
relationTypes :: Eq a => BinaryRelation a -> [RelationType]
relationTypes relation =
  let types = [Reflexive | isReflexive relation] ++
              [Symmetric | isSymmetric relation] ++
              [Antisymmetric | isAntisymmetric relation] ++
              [Transitive | isTransitive relation]
  in types ++
     [Equivalence | isReflexive relation && isSymmetric relation && isTransitive relation] ++
     [PartialOrder | isReflexive relation && isAntisymmetric relation && isTransitive relation]

-- ç¤ºä¾‹ä½¿ç”¨
example :: IO ()
example = do
  let relation = [(1, 1), (2, 2), (3, 3), (1, 2), (2, 1), (2, 3), (3, 2), (1, 3), (3, 1)]
  
  putStrLn $ "å…³ç³»: " ++ show relation
  putStrLn $ "å®šä¹‰åŸŸ: " ++ show (domain relation)
  putStrLn $ "å€¼åŸŸ: " ++ show (codomain relation)
  putStrLn $ "è‡ªåæ€§: " ++ show (isReflexive relation)
  putStrLn $ "å¯¹ç§°æ€§: " ++ show (isSymmetric relation)
  putStrLn $ "ä¼ é€’æ€§: " ++ show (isTransitive relation)
  putStrLn $ "å…³ç³»ç±»å‹: " ++ show (relationTypes relation)
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å…³ç³»è¿ç®—åº”ç”¨

```rust
fn main() {
    // åˆ›å»ºå…³ç³»
    let mut r1 = BinaryRelation::new();
    r1.add_pair(1, 2);
    r1.add_pair(2, 3);
    r1.add_pair(1, 3);

    let mut r2 = BinaryRelation::new();
    r2.add_pair(2, 3);
    r2.add_pair(3, 4);
    r2.add_pair(2, 4);

    println!("å…³ç³» R1: {:?}", r1.pairs());
    println!("å…³ç³» R2: {:?}", r2.pairs());

    // å…³ç³»è¿ç®—
    let union = r1.union(&r2);
    println!("R1 âˆª R2: {:?}", union.pairs());

    let intersection = r1.intersection(&r2);
    println!("R1 âˆ© R2: {:?}", intersection.pairs());

    let composition = r1.compose(&r2);
    println!("R1 âˆ˜ R2: {:?}", composition.pairs());

    let inverse = r1.inverse();
    println!("R1^(-1): {:?}", inverse.pairs());
}
```

### 5.2 å…³ç³»æ€§è´¨åˆ†æåº”ç”¨

```rust
fn main() {
    // åˆ›å»ºç­‰ä»·å…³ç³»
    let mut equivalence = BinaryRelation::new();
    equivalence.add_pair(1, 1);
    equivalence.add_pair(2, 2);
    equivalence.add_pair(3, 3);
    equivalence.add_pair(1, 2);
    equivalence.add_pair(2, 1);
    equivalence.add_pair(2, 3);
    equivalence.add_pair(3, 2);
    equivalence.add_pair(1, 3);
    equivalence.add_pair(3, 1);

    println!("ç­‰ä»·å…³ç³»æ€§è´¨:");
    println!("è‡ªåæ€§: {}", equivalence.is_reflexive());
    println!("å¯¹ç§°æ€§: {}", equivalence.is_symmetric());
    println!("ä¼ é€’æ€§: {}", equivalence.is_transitive());

    let types = equivalence.relation_type();
    println!("å…³ç³»ç±»å‹: {:?}", types);

    // åˆ›å»ºååºå…³ç³»
    let mut partial_order = BinaryRelation::new();
    partial_order.add_pair(1, 1);
    partial_order.add_pair(2, 2);
    partial_order.add_pair(3, 3);
    partial_order.add_pair(1, 2);
    partial_order.add_pair(1, 3);
    partial_order.add_pair(2, 3);

    println!("\nååºå…³ç³»æ€§è´¨:");
    println!("è‡ªåæ€§: {}", partial_order.is_reflexive());
    println!("åå¯¹ç§°æ€§: {}", partial_order.is_antisymmetric());
    println!("ä¼ é€’æ€§: {}", partial_order.is_transitive());

    let types = partial_order.relation_type();
    println!("å…³ç³»ç±»å‹: {:?}", types);
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸é›†åˆè®ºçš„å…³ç³»

å…³ç³»æ¦‚å¿µåŸºäºé›†åˆè®ºï¼Œå‚è§ï¼š

- [02.1.1 æœ´ç´ é›†åˆè®º](../01_Set_Theory/02.1.1_Naive_Set_Theory.md)
- [02.1.2 å…¬ç†é›†åˆè®º](./02.1.2_Axiomatic_Set_Theory.md)

### 6.2 ä¸é€»è¾‘å­¦çš„å…³ç³»

å…³ç³»åœ¨é€»è¾‘å­¦ä¸­æœ‰é‡è¦åº”ç”¨ï¼Œå‚è§ï¼š

- [02.2.1 å‘½é¢˜é€»è¾‘](./02.2.1_Propositional_Logic.md)
- [02.2.2 è°“è¯é€»è¾‘](./02.2.2_Predicate_Logic.md)

### 6.3 ä¸å‡½æ•°è®ºçš„å…³ç³»

å‡½æ•°æ˜¯ç‰¹æ®Šçš„å…³ç³»ï¼Œå‚è§ï¼š

- [02.4.1 å‡½æ•°æ¦‚å¿µ](./02.4.1_Function_Concept.md)

## 7. å‚è€ƒæ–‡çŒ®

1. Halmos, P. R. (1960). *Naive Set Theory*. Van Nostrand.
2. Enderton, H. B. (1977). *Elements of Set Theory*. Academic Press.
3. Suppes, P. (1960). *Axiomatic Set Theory*. Van Nostrand.
4. Jech, T. (2003). *Set Theory*. Springer.
5. Kunen, K. (1980). *Set Theory: An Introduction to Independence Proofs*. North-Holland.
6. Levy, A. (1979). *Basic Set Theory*. Springer.
7. Fraenkel, A. A. (1953). *Abstract Set Theory*. North-Holland.
8. Kuratowski, K. (1966). *Introduction to Set Theory and Topology*. Pergamon.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.1.1 æœ´ç´ é›†åˆè®º](../01_Set_Theory/02.1.1_Naive_Set_Theory.md)
- [02.1.2 å…¬ç†é›†åˆè®º](./02.1.2_Axiomatic_Set_Theory.md)
- [02.5.2 å…³ç³»æ€§è´¨](./02.5.2_Relation_Properties.md)
- [02.5.3 å…³ç³»è¿ç®—](./02.5.3_Relation_Operations.md)
- [02.5.4 ç­‰ä»·å…³ç³»](./02.5.4_Equivalence_Relations.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
