# 02.2.3 æ¨¡æ€é€»è¾‘

## ğŸ“‹ æ¦‚è¿°

æ¨¡æ€é€»è¾‘æ˜¯ç»å…¸é€»è¾‘çš„æ‰©å±•ï¼Œç ”ç©¶å¿…ç„¶æ€§å’Œå¯èƒ½æ€§ç­‰æ¨¡æ€æ¦‚å¿µã€‚æœ¬æ–‡æ¡£å»ºç«‹æ¨¡æ€é€»è¾‘çš„å½¢å¼åŒ–ç†è®ºï¼ŒåŒ…æ‹¬å¯èƒ½ä¸–ç•Œè¯­ä¹‰ã€æ¨¡æ€ç®—å­ã€å…¬ç†ç³»ç»Ÿå’Œæ¨ç†è§„åˆ™ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹æ¨¡æ€é€»è¾‘çš„å½¢å¼åŒ–åŸºç¡€
2. å®šä¹‰å¯èƒ½ä¸–ç•Œè¯­ä¹‰å­¦
3. æ„å»ºæ¨¡æ€é€»è¾‘çš„å…¬ç†ç³»ç»Ÿ
4. æä¾›æ¨¡æ€æ¨ç†çš„å½¢å¼åŒ–è¯æ˜
5. å®ç°æ¨¡æ€é€»è¾‘çš„ç®—æ³•åŒ–

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ¨¡æ€é€»è¾‘çš„æœ¬è´¨

æ¨¡æ€é€»è¾‘ç ”ç©¶å¿…ç„¶æ€§($\Box$)å’Œå¯èƒ½æ€§($\Diamond$)ç­‰æ¨¡æ€æ¦‚å¿µï¼Œæ‰©å±•äº†ç»å…¸å‘½é¢˜é€»è¾‘ã€‚

**å®šä¹‰ 1.1.1** (æ¨¡æ€ç®—å­)
æ¨¡æ€ç®—å­æ˜¯è¡¨ç¤ºå¿…ç„¶æ€§å’Œå¯èƒ½æ€§çš„é€»è¾‘è¿ç®—ç¬¦ï¼š

- $\Box \phi$ï¼šå¿…ç„¶ $\phi$
- $\Diamond \phi$ï¼šå¯èƒ½ $\phi$

**å®šä¹‰ 1.1.2** (æ¨¡æ€ç­‰ä»·)
$\Box \phi \equiv \neg \Diamond \neg \phi$ å’Œ $\Diamond \phi \equiv \neg \Box \neg \phi$

### 1.2 å¯èƒ½ä¸–ç•Œè¯­ä¹‰

**å®šä¹‰ 1.1.3** (å¯èƒ½ä¸–ç•Œ)
å¯èƒ½ä¸–ç•Œæ˜¯æè¿°ä¸–ç•Œå¯èƒ½çŠ¶æ€çš„æ¦‚å¿µå®ä½“ã€‚

**å®šä¹‰ 1.1.4** (å¯è¾¾å…³ç³»)
å¯è¾¾å…³ç³» $R$ æ˜¯å¯èƒ½ä¸–ç•Œä¹‹é—´çš„äºŒå…ƒå…³ç³»ï¼Œè¡¨ç¤ºä¸–ç•Œé—´çš„å¯è®¿é—®æ€§ã€‚

### 1.3 æ¨¡æ€é€»è¾‘çš„ç±»å‹

**å®šä¹‰ 1.1.5** (ç³»ç»ŸK)
æœ€åŸºæœ¬çš„æ¨¡æ€é€»è¾‘ç³»ç»Ÿï¼ŒåŒ…å«å¿…ç„¶åŒ–è§„åˆ™ã€‚

**å®šä¹‰ 1.1.6** (ç³»ç»ŸT)
åœ¨KåŸºç¡€ä¸Šæ·»åŠ å…¬ç† $\Box \phi \rightarrow \phi$ã€‚

**å®šä¹‰ 1.1.7** (ç³»ç»ŸS4)
åœ¨TåŸºç¡€ä¸Šæ·»åŠ å…¬ç† $\Box \phi \rightarrow \Box \Box \phi$ã€‚

**å®šä¹‰ 1.1.8** (ç³»ç»ŸS5)
åœ¨S4åŸºç¡€ä¸Šæ·»åŠ å…¬ç† $\Diamond \phi \rightarrow \Box \Diamond \phi$ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ¨¡æ€é€»è¾‘è¯­è¨€

**å®šä¹‰ 2.1.1** (æ¨¡æ€é€»è¾‘è¯­è¨€)
æ¨¡æ€é€»è¾‘è¯­è¨€ $\mathcal{L}_M$ åœ¨ç»å…¸å‘½é¢˜é€»è¾‘åŸºç¡€ä¸Šæ·»åŠ ï¼š

1. **æ¨¡æ€ç®—å­**ï¼š$\{\Box, \Diamond\}$
2. **åˆå¼å…¬å¼**ï¼š
   - å¦‚æœ $\phi$ æ˜¯åˆå¼å…¬å¼ï¼Œåˆ™ $\Box \phi$ å’Œ $\Diamond \phi$ æ˜¯åˆå¼å…¬å¼

**å®šä¹‰ 2.1.2** (æ¨¡æ€å…¬å¼)
æ¨¡æ€å…¬å¼é€’å½’å®šä¹‰å¦‚ä¸‹ï¼š

1. æ¯ä¸ªå‘½é¢˜å˜å…ƒ $p \in \mathcal{P}$ æ˜¯æ¨¡æ€å…¬å¼
2. å¦‚æœ $\phi$ æ˜¯æ¨¡æ€å…¬å¼ï¼Œåˆ™ $\neg \phi$ã€$\Box \phi$ã€$\Diamond \phi$ æ˜¯æ¨¡æ€å…¬å¼
3. å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯æ¨¡æ€å…¬å¼ï¼Œåˆ™ $(\phi \land \psi)$ã€$(\phi \lor \psi)$ã€$(\phi \rightarrow \psi)$ã€$(\phi \leftrightarrow \psi)$ æ˜¯æ¨¡æ€å…¬å¼

### 2.2 å…‹é‡Œæ™®å…‹æ¨¡å‹

**å®šä¹‰ 2.2.1** (å…‹é‡Œæ™®å…‹æ¡†æ¶)
å…‹é‡Œæ™®å…‹æ¡†æ¶æ˜¯äºŒå…ƒç»„ $\mathcal{F} = (W, R)$ï¼Œå…¶ä¸­ï¼š

- $W$ æ˜¯éç©ºçš„å¯èƒ½ä¸–ç•Œé›†
- $R \subseteq W \times W$ æ˜¯å¯è¾¾å…³ç³»

**å®šä¹‰ 2.2.2** (å…‹é‡Œæ™®å…‹æ¨¡å‹)
å…‹é‡Œæ™®å…‹æ¨¡å‹æ˜¯ä¸‰å…ƒç»„ $\mathcal{M} = (W, R, V)$ï¼Œå…¶ä¸­ï¼š

- $(W, R)$ æ˜¯å…‹é‡Œæ™®å…‹æ¡†æ¶
- $V: \mathcal{P} \times W \rightarrow \{\top, \bot\}$ æ˜¯èµ‹å€¼å‡½æ•°

**å®šä¹‰ 2.2.3** (çœŸå€¼å®šä¹‰)
æ¨¡æ€å…¬å¼åœ¨æ¨¡å‹ $\mathcal{M} = (W, R, V)$ ä¸­ä¸–ç•Œ $w$ çš„çœŸå€¼é€’å½’å®šä¹‰ï¼š

1. $\mathcal{M}, w \models p$ å½“ä¸”ä»…å½“ $V(p, w) = \top$
2. $\mathcal{M}, w \models \neg \phi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \not\models \phi$
3. $\mathcal{M}, w \models \phi \land \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \phi$ ä¸” $\mathcal{M}, w \models \psi$
4. $\mathcal{M}, w \models \phi \lor \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \models \phi$ æˆ– $\mathcal{M}, w \models \psi$
5. $\mathcal{M}, w \models \phi \rightarrow \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \not\models \phi$ æˆ– $\mathcal{M}, w \models \psi$
6. $\mathcal{M}, w \models \Box \phi$ å½“ä¸”ä»…å½“å¯¹æ‰€æœ‰ $v \in W$ï¼Œå¦‚æœ $wRv$ï¼Œåˆ™ $\mathcal{M}, v \models \phi$
7. $\mathcal{M}, w \models \Diamond \phi$ å½“ä¸”ä»…å½“å­˜åœ¨ $v \in W$ï¼Œä½¿å¾— $wRv$ ä¸” $\mathcal{M}, v \models \phi$

### 2.3 æ¨¡æ€é€»è¾‘ç³»ç»Ÿ

**å®šä¹‰ 2.3.1** (ç³»ç»ŸKçš„å…¬ç†)
ç³»ç»ŸKåŒ…å«ä»¥ä¸‹å…¬ç†ï¼š

1. æ‰€æœ‰ç»å…¸å‘½é¢˜é€»è¾‘çš„é‡è¨€å¼
2. **Kå…¬ç†**ï¼š$\Box(\phi \rightarrow \psi) \rightarrow (\Box \phi \rightarrow \Box \psi)$
3. **å¿…ç„¶åŒ–è§„åˆ™**ï¼šå¦‚æœ $\vdash \phi$ï¼Œåˆ™ $\vdash \Box \phi$

**å®šä¹‰ 2.3.2** (ç³»ç»ŸTçš„å…¬ç†)
ç³»ç»ŸTåœ¨KåŸºç¡€ä¸Šæ·»åŠ ï¼š

- **Tå…¬ç†**ï¼š$\Box \phi \rightarrow \phi$

**å®šä¹‰ 2.3.3** (ç³»ç»ŸS4çš„å…¬ç†)
ç³»ç»ŸS4åœ¨TåŸºç¡€ä¸Šæ·»åŠ ï¼š

- **4å…¬ç†**ï¼š$\Box \phi \rightarrow \Box \Box \phi$

**å®šä¹‰ 2.3.4** (ç³»ç»ŸS5çš„å…¬ç†)
ç³»ç»ŸS5åœ¨S4åŸºç¡€ä¸Šæ·»åŠ ï¼š

- **5å…¬ç†**ï¼š$\Diamond \phi \rightarrow \Box \Diamond \phi$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬æ¨¡æ€å®šç†

**å®šç† 3.1.1** (æ¨¡æ€ç­‰ä»·æ€§)
$$\models \Box \phi \leftrightarrow \neg \Diamond \neg \phi$$
$$\models \Diamond \phi \leftrightarrow \neg \Box \neg \phi$$

**è¯æ˜**ï¼š
æ ¹æ®çœŸå€¼å®šä¹‰ï¼š

- $\mathcal{M}, w \models \Box \phi$ å½“ä¸”ä»…å½“å¯¹æ‰€æœ‰ $v$ï¼Œå¦‚æœ $wRv$ åˆ™ $\mathcal{M}, v \models \phi$
- $\mathcal{M}, w \models \neg \Diamond \neg \phi$ å½“ä¸”ä»…å½“ $\mathcal{M}, w \not\models \Diamond \neg \phi$
- $\mathcal{M}, w \not\models \Diamond \neg \phi$ å½“ä¸”ä»…å½“ä¸å­˜åœ¨ $v$ ä½¿å¾— $wRv$ ä¸” $\mathcal{M}, v \models \neg \phi$
- è¿™ç­‰ä»·äºå¯¹æ‰€æœ‰ $v$ï¼Œå¦‚æœ $wRv$ åˆ™ $\mathcal{M}, v \not\models \neg \phi$ï¼Œå³ $\mathcal{M}, v \models \phi$

**å®šç† 3.1.2** (æ¨¡æ€åˆ†é…å¾‹)
$$\models \Box(\phi \land \psi) \leftrightarrow (\Box \phi \land \Box \psi)$$
$$\models \Diamond(\phi \lor \psi) \leftrightarrow (\Diamond \phi \lor \Diamond \psi)$$

**å®šç† 3.1.3** (æ¨¡æ€å•è°ƒæ€§)
$$\models (\Box \phi \land \Box \psi) \rightarrow \Box(\phi \land \psi)$$
$$\models \Diamond(\phi \land \psi) \rightarrow (\Diamond \phi \land \Diamond \psi)$$

### 3.2 ç³»ç»Ÿæ€§è´¨å®šç†

**å®šç† 3.2.1** (ç³»ç»ŸKçš„å¯é æ€§)
ç³»ç»ŸKçš„æ‰€æœ‰å®šç†åœ¨æ‰€æœ‰å…‹é‡Œæ™®å…‹æ¨¡å‹ä¸­æœ‰æ•ˆã€‚

**å®šç† 3.2.2** (ç³»ç»ŸTçš„å¯é æ€§)
ç³»ç»ŸTçš„æ‰€æœ‰å®šç†åœ¨æ‰€æœ‰è‡ªåå…‹é‡Œæ™®å…‹æ¨¡å‹ä¸­æœ‰æ•ˆã€‚

**å®šç† 3.2.3** (ç³»ç»ŸS4çš„å¯é æ€§)
ç³»ç»ŸS4çš„æ‰€æœ‰å®šç†åœ¨æ‰€æœ‰è‡ªåä¼ é€’å…‹é‡Œæ™®å…‹æ¨¡å‹ä¸­æœ‰æ•ˆã€‚

**å®šç† 3.2.4** (ç³»ç»ŸS5çš„å¯é æ€§)
ç³»ç»ŸS5çš„æ‰€æœ‰å®šç†åœ¨æ‰€æœ‰ç­‰ä»·å…‹é‡Œæ™®å…‹æ¨¡å‹ä¸­æœ‰æ•ˆã€‚

### 3.3 å®Œå…¨æ€§å®šç†

**å®šç† 3.3.1** (ç³»ç»ŸKçš„å®Œå…¨æ€§)
å¦‚æœå…¬å¼ $\phi$ åœ¨æ‰€æœ‰å…‹é‡Œæ™®å…‹æ¨¡å‹ä¸­æœ‰æ•ˆï¼Œåˆ™ $\phi$ åœ¨ç³»ç»ŸKä¸­å¯è¯æ˜ã€‚

**å®šç† 3.3.2** (ç³»ç»ŸTçš„å®Œå…¨æ€§)
å¦‚æœå…¬å¼ $\phi$ åœ¨æ‰€æœ‰è‡ªåå…‹é‡Œæ™®å…‹æ¨¡å‹ä¸­æœ‰æ•ˆï¼Œåˆ™ $\phi$ åœ¨ç³»ç»ŸTä¸­å¯è¯æ˜ã€‚

**å®šç† 3.3.3** (ç³»ç»ŸS4çš„å®Œå…¨æ€§)
å¦‚æœå…¬å¼ $\phi$ åœ¨æ‰€æœ‰è‡ªåä¼ é€’å…‹é‡Œæ™®å…‹æ¨¡å‹ä¸­æœ‰æ•ˆï¼Œåˆ™ $\phi$ åœ¨ç³»ç»ŸS4ä¸­å¯è¯æ˜ã€‚

**å®šç† 3.3.4** (ç³»ç»ŸS5çš„å®Œå…¨æ€§)
å¦‚æœå…¬å¼ $\phi$ åœ¨æ‰€æœ‰ç­‰ä»·å…‹é‡Œæ™®å…‹æ¨¡å‹ä¸­æœ‰æ•ˆï¼Œåˆ™ $\phi$ åœ¨ç³»ç»ŸS5ä¸­å¯è¯æ˜ã€‚

## 4. ä»£ç å®ç°

### 4.1 æ¨¡æ€é€»è¾‘æ•°æ®ç»“æ„

```rust
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone, PartialEq)]
pub enum ModalProposition {
    Variable(String),
    Negation(Box<ModalProposition>),
    Conjunction(Box<ModalProposition>, Box<ModalProposition>),
    Disjunction(Box<ModalProposition>, Box<ModalProposition>),
    Implication(Box<ModalProposition>, Box<ModalProposition>),
    Equivalence(Box<ModalProposition>, Box<ModalProposition>),
    Necessity(Box<ModalProposition>),
    Possibility(Box<ModalProposition>),
}

#[derive(Debug, Clone)]
pub struct PossibleWorld {
    id: String,
    properties: HashMap<String, bool>,
}

#[derive(Debug, Clone)]
pub struct AccessibilityRelation {
    relations: HashSet<(String, String)>,
}

#[derive(Debug, Clone)]
pub struct KripkeModel {
    worlds: HashMap<String, PossibleWorld>,
    accessibility: AccessibilityRelation,
}

#[derive(Debug, Clone)]
pub struct ModalLogicSystem {
    axioms: Vec<ModalProposition>,
    rules: Vec<ModalInferenceRule>,
}

#[derive(Debug, Clone)]
pub enum ModalInferenceRule {
    Necessitation,
    ModusPonens,
    Substitution,
}
```

### 4.2 å…‹é‡Œæ™®å…‹æ¨¡å‹å®ç°

```rust
impl KripkeModel {
    pub fn new() -> Self {
        Self {
            worlds: HashMap::new(),
            accessibility: AccessibilityRelation {
                relations: HashSet::new(),
            },
        }
    }
    
    pub fn add_world(&mut self, world: PossibleWorld) {
        self.worlds.insert(world.id.clone(), world);
    }
    
    pub fn add_relation(&mut self, from: &str, to: &str) {
        self.accessibility.relations.insert((from.to_string(), to.to_string()));
    }
    
    pub fn is_accessible(&self, from: &str, to: &str) -> bool {
        self.accessibility.relations.contains(&(from.to_string(), to.to_string()))
    }
    
    pub fn evaluate(&self, world_id: &str, proposition: &ModalProposition) -> bool {
        let world = self.worlds.get(world_id).expect("World not found");
        
        match proposition {
            ModalProposition::Variable(name) => {
                world.properties.get(name).copied().unwrap_or(false)
            }
            ModalProposition::Negation(inner) => {
                !self.evaluate(world_id, inner)
            }
            ModalProposition::Conjunction(left, right) => {
                self.evaluate(world_id, left) && self.evaluate(world_id, right)
            }
            ModalProposition::Disjunction(left, right) => {
                self.evaluate(world_id, left) || self.evaluate(world_id, right)
            }
            ModalProposition::Implication(antecedent, consequent) => {
                !self.evaluate(world_id, antecedent) || self.evaluate(world_id, consequent)
            }
            ModalProposition::Equivalence(left, right) => {
                self.evaluate(world_id, left) == self.evaluate(world_id, right)
            }
            ModalProposition::Necessity(inner) => {
                // å¯¹æ‰€æœ‰å¯è¾¾ä¸–ç•Œï¼Œinneréƒ½ä¸ºçœŸ
                for (other_id, _) in &self.worlds {
                    if self.is_accessible(world_id, other_id) {
                        if !self.evaluate(other_id, inner) {
                            return false;
                        }
                    }
                }
                true
            }
            ModalProposition::Possibility(inner) => {
                // å­˜åœ¨å¯è¾¾ä¸–ç•Œï¼Œinnerä¸ºçœŸ
                for (other_id, _) in &self.worlds {
                    if self.is_accessible(world_id, other_id) {
                        if self.evaluate(other_id, inner) {
                            return true;
                        }
                    }
                }
                false
            }
        }
    }
}

impl PossibleWorld {
    pub fn new(id: String) -> Self {
        Self {
            id,
            properties: HashMap::new(),
        }
    }
    
    pub fn set_property(&mut self, property: &str, value: bool) {
        self.properties.insert(property.to_string(), value);
    }
    
    pub fn get_property(&self, property: &str) -> bool {
        self.properties.get(property).copied().unwrap_or(false)
    }
}
```

### 4.3 æ¨¡æ€é€»è¾‘ç³»ç»Ÿå®ç°

```rust
impl ModalLogicSystem {
    pub fn system_k() -> Self {
        let mut system = Self {
            axioms: Vec::new(),
            rules: vec![
                ModalInferenceRule::Necessitation,
                ModalInferenceRule::ModusPonens,
                ModalInferenceRule::Substitution,
            ],
        };
        
        // æ·»åŠ Kå…¬ç†
        let k_axiom = ModalProposition::Implication(
            Box::new(ModalProposition::Necessity(Box::new(
                ModalProposition::Implication(
                    Box::new(ModalProposition::Variable("p".to_string())),
                    Box::new(ModalProposition::Variable("q".to_string())),
                )
            ))),
            Box::new(ModalProposition::Implication(
                Box::new(ModalProposition::Necessity(Box::new(
                    ModalProposition::Variable("p".to_string())
                ))),
                Box::new(ModalProposition::Necessity(Box::new(
                    ModalProposition::Variable("q".to_string())
                ))),
            )),
        );
        system.axioms.push(k_axiom);
        
        system
    }
    
    pub fn system_t() -> Self {
        let mut system = Self::system_k();
        
        // æ·»åŠ Tå…¬ç†
        let t_axiom = ModalProposition::Implication(
            Box::new(ModalProposition::Necessity(Box::new(
                ModalProposition::Variable("p".to_string())
            ))),
            Box::new(ModalProposition::Variable("p".to_string())),
        );
        system.axioms.push(t_axiom);
        
        system
    }
    
    pub fn system_s4() -> Self {
        let mut system = Self::system_t();
        
        // æ·»åŠ 4å…¬ç†
        let axiom_4 = ModalProposition::Implication(
            Box::new(ModalProposition::Necessity(Box::new(
                ModalProposition::Variable("p".to_string())
            ))),
            Box::new(ModalProposition::Necessity(Box::new(
                ModalProposition::Necessity(Box::new(
                    ModalProposition::Variable("p".to_string())
                ))
            ))),
        );
        system.axioms.push(axiom_4);
        
        system
    }
    
    pub fn system_s5() -> Self {
        let mut system = Self::system_s4();
        
        // æ·»åŠ 5å…¬ç†
        let axiom_5 = ModalProposition::Implication(
            Box::new(ModalProposition::Possibility(Box::new(
                ModalProposition::Variable("p".to_string())
            ))),
            Box::new(ModalProposition::Necessity(Box::new(
                ModalProposition::Possibility(Box::new(
                    ModalProposition::Variable("p".to_string())
                ))
            ))),
        );
        system.axioms.push(axiom_5);
        
        system
    }
}
```

### 4.4 æ¨¡æ€æ¨ç†å¼•æ“

```rust
pub struct ModalLogicEngine;

impl ModalLogicEngine {
    /// æ£€æŸ¥æ¨¡æ€å…¬å¼çš„æœ‰æ•ˆæ€§
    pub fn is_valid(
        proposition: &ModalProposition,
        model: &KripkeModel,
        system: &ModalLogicSystem
    ) -> bool {
        // æ£€æŸ¥åœ¨æ‰€æœ‰ä¸–ç•Œä¸­æ˜¯å¦éƒ½ä¸ºçœŸ
        for world_id in model.worlds.keys() {
            if !model.evaluate(world_id, proposition) {
                return false;
            }
        }
        true
    }
    
    /// æ£€æŸ¥æ¨¡æ€å…¬å¼çš„å¯æ»¡è¶³æ€§
    pub fn is_satisfiable(
        proposition: &ModalProposition,
        model: &KripkeModel
    ) -> bool {
        // æ£€æŸ¥æ˜¯å¦å­˜åœ¨ä¸–ç•Œä½¿å¾—å…¬å¼ä¸ºçœŸ
        for world_id in model.worlds.keys() {
            if model.evaluate(world_id, proposition) {
                return true;
            }
        }
        false
    }
    
    /// æ¨¡æ€ç­‰ä»·è½¬æ¢
    pub fn convert_necessity_to_possibility(proposition: &ModalProposition) -> ModalProposition {
        match proposition {
            ModalProposition::Necessity(inner) => {
                ModalProposition::Negation(Box::new(
                    ModalProposition::Possibility(Box::new(
                        ModalProposition::Negation(Box::new(inner.clone()))
                    ))
                ))
            }
            _ => proposition.clone(),
        }
    }
    
    pub fn convert_possibility_to_necessity(proposition: &ModalProposition) -> ModalProposition {
        match proposition {
            ModalProposition::Possibility(inner) => {
                ModalProposition::Negation(Box::new(
                    ModalProposition::Necessity(Box::new(
                        ModalProposition::Negation(Box::new(inner.clone()))
                    ))
                ))
            }
            _ => proposition.clone(),
        }
    }
    
    /// æ„å»ºè‡ªåæ¨¡å‹
    pub fn build_reflexive_model() -> KripkeModel {
        let mut model = KripkeModel::new();
        
        // æ·»åŠ ä¸–ç•Œ
        let mut world1 = PossibleWorld::new("w1".to_string());
        world1.set_property("p", true);
        model.add_world(world1);
        
        let mut world2 = PossibleWorld::new("w2".to_string());
        world2.set_property("p", false);
        model.add_world(world2);
        
        // æ·»åŠ è‡ªåå…³ç³»
        model.add_relation("w1", "w1");
        model.add_relation("w2", "w2");
        model.add_relation("w1", "w2");
        
        model
    }
    
    /// æ„å»ºç­‰ä»·æ¨¡å‹
    pub fn build_equivalence_model() -> KripkeModel {
        let mut model = Self::build_reflexive_model();
        
        // æ·»åŠ å¯¹ç§°å’Œä¼ é€’å…³ç³»
        model.add_relation("w2", "w1");
        
        model
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 åŸºæœ¬æ¨¡æ€æ¨ç†

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_modal_equivalence() {
        let p = ModalProposition::Variable("p".to_string());
        let necessity_p = ModalProposition::Necessity(Box::new(p.clone()));
        let not_possibility_not_p = ModalProposition::Negation(Box::new(
            ModalProposition::Possibility(Box::new(
                ModalProposition::Negation(Box::new(p))
            ))
        ));
        
        let model = ModalLogicEngine::build_reflexive_model();
        let system = ModalLogicSystem::system_k();
        
        let necessity_valid = ModalLogicEngine::is_valid(&necessity_p, &model, &system);
        let negation_valid = ModalLogicEngine::is_valid(&not_possibility_not_p, &model, &system);
        
        // è¿™ä¸¤ä¸ªå…¬å¼åœ¨è¯­ä¹‰ä¸Šç­‰ä»·
        assert_eq!(necessity_valid, negation_valid);
    }
    
    #[test]
    fn test_system_t_axiom() {
        let p = ModalProposition::Variable("p".to_string());
        let necessity_p = ModalProposition::Necessity(Box::new(p.clone()));
        let t_axiom = ModalProposition::Implication(
            Box::new(necessity_p),
            Box::new(p),
        );
        
        let model = ModalLogicEngine::build_reflexive_model();
        let system = ModalLogicSystem::system_t();
        
        assert!(ModalLogicEngine::is_valid(&t_axiom, &model, &system));
    }
    
    #[test]
    fn test_system_s4_axiom() {
        let p = ModalProposition::Variable("p".to_string());
        let necessity_p = ModalProposition::Necessity(Box::new(p.clone()));
        let necessity_necessity_p = ModalProposition::Necessity(Box::new(
            ModalProposition::Necessity(Box::new(p))
        ));
        let axiom_4 = ModalProposition::Implication(
            Box::new(necessity_p),
            Box::new(necessity_necessity_p),
        );
        
        let model = ModalLogicEngine::build_reflexive_model();
        let system = ModalLogicSystem::system_s4();
        
        assert!(ModalLogicEngine::is_valid(&axiom_4, &model, &system));
    }
    
    #[test]
    fn test_system_s5_axiom() {
        let p = ModalProposition::Variable("p".to_string());
        let possibility_p = ModalProposition::Possibility(Box::new(p.clone()));
        let necessity_possibility_p = ModalProposition::Necessity(Box::new(
            ModalProposition::Possibility(Box::new(p))
        ));
        let axiom_5 = ModalProposition::Implication(
            Box::new(possibility_p),
            Box::new(necessity_possibility_p),
        );
        
        let model = ModalLogicEngine::build_equivalence_model();
        let system = ModalLogicSystem::system_s5();
        
        assert!(ModalLogicEngine::is_valid(&axiom_5, &model, &system));
    }
}
```

### 5.2 å¤æ‚æ¨¡æ€æ¨ç†

```rust
#[test]
fn test_complex_modal_reasoning() {
    // æ„å»ºå¤æ‚æ¨¡æ€å…¬å¼ï¼šâ–¡(p â†’ q) â†’ (â–¡p â†’ â–¡q)
    let p = ModalProposition::Variable("p".to_string());
    let q = ModalProposition::Variable("q".to_string());
    
    let p_implies_q = ModalProposition::Implication(Box::new(p.clone()), Box::new(q.clone()));
    let necessity_p_implies_q = ModalProposition::Necessity(Box::new(p_implies_q));
    
    let necessity_p = ModalProposition::Necessity(Box::new(p));
    let necessity_q = ModalProposition::Necessity(Box::new(q));
    let necessity_p_implies_necessity_q = ModalProposition::Implication(
        Box::new(necessity_p),
        Box::new(necessity_q),
    );
    
    let k_axiom = ModalProposition::Implication(
        Box::new(necessity_p_implies_q),
        Box::new(necessity_p_implies_necessity_q),
    );
    
    let model = ModalLogicEngine::build_reflexive_model();
    let system = ModalLogicSystem::system_k();
    
    assert!(ModalLogicEngine::is_valid(&k_axiom, &model, &system));
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å‘½é¢˜é€»è¾‘çš„å…³ç³»

æ¨¡æ€é€»è¾‘æ˜¯å‘½é¢˜é€»è¾‘çš„æ‰©å±•ï¼Œæ·»åŠ äº†æ¨¡æ€ç®—å­ã€‚

### 6.2 ä¸è°“è¯é€»è¾‘çš„å…³ç³»

æ¨¡æ€é€»è¾‘å¯ä»¥ä¸è°“è¯é€»è¾‘ç»“åˆå½¢æˆæ¨¡æ€è°“è¯é€»è¾‘ã€‚

### 6.3 ä¸å“²å­¦çš„å…³ç³»

æ¨¡æ€é€»è¾‘ä¸ºå“²å­¦ä¸­çš„å¿…ç„¶æ€§ã€å¯èƒ½æ€§ç­‰æ¦‚å¿µæä¾›å½¢å¼åŒ–å·¥å…·ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Hughes, G. E., & Cresswell, M. J. (1996). A New Introduction to Modal Logic. Routledge.
2. Blackburn, P., de Rijke, M., & Venema, Y. (2001). Modal Logic. Cambridge University Press.
3. Chellas, B. F. (1980). Modal Logic: An Introduction. Cambridge University Press.
4. ç‹å®ªé’§. (1998). æ•°ç†é€»è¾‘å¼•è®º. åŒ—äº¬å¤§å­¦å‡ºç‰ˆç¤¾.
5. å¼ æ¸…å®‡. (2006). é€»è¾‘å“²å­¦ä¹ç« . æ±Ÿè‹äººæ°‘å‡ºç‰ˆç¤¾.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.2.1 å‘½é¢˜é€»è¾‘](../02.2.1_å‘½é¢˜é€»è¾‘.md)
- [02.2.2 è°“è¯é€»è¾‘](../02.2.2_è°“è¯é€»è¾‘.md)
- [02.2.4 ç›´è§‰é€»è¾‘](../02.2.4_ç›´è§‰é€»è¾‘.md)
- [01.4.1 é€»è¾‘åŸºç¡€](../../01_Philosophical_Foundation/01.4.1_é€»è¾‘åŸºç¡€.md)
- [01.4.2 æ¨ç†ç†è®º](../../01_Philosophical_Foundation/01.4.2_æ¨ç†ç†è®º.md)
