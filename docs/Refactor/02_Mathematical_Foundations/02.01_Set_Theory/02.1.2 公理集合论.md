# 02.1.2 å…¬ç†é›†åˆè®º

## ğŸ“‹ æ¦‚è¿°

å…¬ç†é›†åˆè®ºæ˜¯æ•°å­¦åŸºç¡€ä¸­ç ”ç©¶é›†åˆçš„å½¢å¼åŒ–ç†è®ºä½“ç³»ã€‚
å®ƒé€šè¿‡ä¸¥æ ¼çš„å…¬ç†åŒ–æ–¹æ³•å»ºç«‹é›†åˆè®ºçš„åŸºç¡€ï¼Œä¸ºç°ä»£æ•°å­¦æä¾›ç»Ÿä¸€çš„é€»è¾‘åŸºç¡€ï¼Œé¿å…æœ´ç´ é›†åˆè®ºä¸­çš„æ‚–è®ºé—®é¢˜ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹é›†åˆè®ºçš„å…¬ç†åŒ–ä½“ç³»**
2. **é¿å…é›†åˆè®ºæ‚–è®º**
3. **ä¸ºæ•°å­¦æä¾›ç»Ÿä¸€åŸºç¡€**
4. **æ„å»ºå½¢å¼åŒ–é›†åˆç†è®º**
5. **ç ”ç©¶é›†åˆè®ºçš„ä¸€è‡´æ€§**

## ğŸ“š ç›®å½•

- [02.1.2 å…¬ç†é›†åˆè®º](#0212-å…¬ç†é›†åˆè®º)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒç›®æ ‡](#-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 é›†åˆæ¦‚å¿µ](#11-é›†åˆæ¦‚å¿µ)
    - [1.2 é›†åˆå…³ç³»](#12-é›†åˆå…³ç³»)
    - [1.3 é›†åˆè¿ç®—](#13-é›†åˆè¿ç®—)
  - [2. å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
    - [2.1 ZFCå…¬ç†ç³»ç»Ÿ](#21-zfcå…¬ç†ç³»ç»Ÿ)
    - [2.2 é›†åˆè®ºè¯­è¨€](#22-é›†åˆè®ºè¯­è¨€)
    - [2.3 é›†åˆè®ºæ¨¡å‹](#23-é›†åˆè®ºæ¨¡å‹)
  - [3. å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
    - [3.1 åŸºæœ¬é›†åˆå®šç†](#31-åŸºæœ¬é›†åˆå®šç†)
    - [3.2 é›†åˆè¿ç®—å®šç†](#32-é›†åˆè¿ç®—å®šç†)
    - [3.3 åºæ•°ç†è®º](#33-åºæ•°ç†è®º)
  - [4. ä»£ç å®ç°](#4-ä»£ç å®ç°)
    - [4.1 é›†åˆè®ºè¯­è¨€å®ç°](#41-é›†åˆè®ºè¯­è¨€å®ç°)
  - [5. åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
    - [5.1 è‡ªç„¶æ•°æ„é€ ](#51-è‡ªç„¶æ•°æ„é€ )
    - [5.2 é›†åˆè¿ç®—éªŒè¯](#52-é›†åˆè¿ç®—éªŒè¯)
    - [5.3 åºæ•°è¿ç®—](#53-åºæ•°è¿ç®—)
  - [6. ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
    - [6.1 ä¸æœ´ç´ é›†åˆè®ºçš„å…³ç³»](#61-ä¸æœ´ç´ é›†åˆè®ºçš„å…³ç³»)
    - [6.2 ä¸æ•°ç³»ç†è®ºçš„å…³ç³»](#62-ä¸æ•°ç³»ç†è®ºçš„å…³ç³»)
    - [6.3 ä¸é€»è¾‘å­¦çš„å…³ç³»](#63-ä¸é€»è¾‘å­¦çš„å…³ç³»)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 é›†åˆæ¦‚å¿µ

**å®šä¹‰ 1.1.1** (é›†åˆ)
é›†åˆæ˜¯æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„å¯¹è±¡çš„æ±‡é›†ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š

- **å¤–å»¶æ€§**: é›†åˆç”±å…¶å…ƒç´ å”¯ä¸€ç¡®å®š
- **æŠ½è±¡æ€§**: é›†åˆæ˜¯æŠ½è±¡çš„æ¦‚å¿µå¯¹è±¡
- **ç¡®å®šæ€§**: ä»»ä½•å¯¹è±¡è¦ä¹ˆå±äºé›†åˆï¼Œè¦ä¹ˆä¸å±äºé›†åˆ

### 1.2 é›†åˆå…³ç³»

**å®šä¹‰ 1.1.2** (åŸºæœ¬é›†åˆå…³ç³»)
é›†åˆä¹‹é—´çš„åŸºæœ¬å…³ç³»åŒ…æ‹¬ï¼š

- **å±äºå…³ç³»**: $x \in A$ (xæ˜¯Açš„å…ƒç´ )
- **åŒ…å«å…³ç³»**: $A \subseteq B$ (Aæ˜¯Bçš„å­é›†)
- **ç›¸ç­‰å…³ç³»**: $A = B$ (Aä¸Bç›¸ç­‰)
- **çœŸåŒ…å«å…³ç³»**: $A \subset B$ (Aæ˜¯Bçš„çœŸå­é›†)

### 1.3 é›†åˆè¿ç®—

**å®šä¹‰ 1.1.3** (åŸºæœ¬é›†åˆè¿ç®—)
é›†åˆçš„åŸºæœ¬è¿ç®—åŒ…æ‹¬ï¼š

- **å¹¶é›†**: $A \cup B = \{x : x \in A \lor x \in B\}$
- **äº¤é›†**: $A \cap B = \{x : x \in A \land x \in B\}$
- **å·®é›†**: $A \setminus B = \{x : x \in A \land x \notin B\}$
- **è¡¥é›†**: $A^c = \{x : x \notin A\}$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ZFCå…¬ç†ç³»ç»Ÿ

**å®šä¹‰ 1.2.1** (ZFCå…¬ç†ç³»ç»Ÿ)
Zermelo-Fraenkelé›†åˆè®ºåŒ…å«ä»¥ä¸‹å…¬ç†ï¼š

1. **å¤–å»¶å…¬ç†**: $\forall x \forall y [\forall z(z \in x \leftrightarrow z \in y) \rightarrow x = y]$
2. **ç©ºé›†å…¬ç†**: $\exists x \forall y(y \notin x)$
3. **é…å¯¹å…¬ç†**: $\forall x \forall y \exists z \forall w(w \in z \leftrightarrow w = x \lor w = y)$
4. **å¹¶é›†å…¬ç†**: $\forall F \exists A \forall x(x \in A \leftrightarrow \exists B(B \in F \land x \in B))$
5. **å¹‚é›†å…¬ç†**: $\forall x \exists y \forall z(z \in y \leftrightarrow z \subseteq x)$
6. **æ— ç©·å…¬ç†**: $\exists x(\emptyset \in x \land \forall y(y \in x \rightarrow y \cup \{y\} \in x))$
7. **æ›¿æ¢å…¬ç†æ¨¡å¼**: å¯¹äºæ¯ä¸ªå…¬å¼ $\varphi(x,y)$ï¼Œæœ‰ï¼š
   $\forall A[\forall x \in A \exists! y \varphi(x,y) \rightarrow \exists B \forall y(y \in B \leftrightarrow \exists x \in A \varphi(x,y))]$
8. **æ­£åˆ™å…¬ç†**: $\forall x(x \neq \emptyset \rightarrow \exists y \in x(y \cap x = \emptyset))$
9. **é€‰æ‹©å…¬ç†**: $\forall A[\emptyset \notin A \rightarrow \exists f: A \rightarrow \bigcup A \forall B \in A(f(B) \in B)]$

### 2.2 é›†åˆè®ºè¯­è¨€

**å®šä¹‰ 1.2.2** (é›†åˆè®ºè¯­è¨€)
é›†åˆè®ºè¯­è¨€ $\mathcal{L}_{\in}$ ç”±ä»¥ä¸‹éƒ¨åˆ†ç»„æˆï¼š

1. **å˜å…ƒ**: $x, y, z, \ldots \in \mathcal{V}$
2. **å…³ç³»ç¬¦å·**: $\in$ (å±äºå…³ç³»)
3. **é€»è¾‘è¿æ¥è¯**: $\neg, \land, \lor, \rightarrow, \leftrightarrow$
4. **é‡è¯**: $\forall, \exists$
5. **ç­‰å·**: $=$
6. **è¾…åŠ©ç¬¦å·**: $(, )$

**è¯­æ³•è§„åˆ™**:

- å¦‚æœ $x, y \in \mathcal{V}$ï¼Œåˆ™ $x \in y$ å’Œ $x = y$ æ˜¯åŸå­å…¬å¼
- å¦‚æœ $\varphi, \psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\neg\varphi, (\varphi \land \psi), (\varphi \lor \psi), (\varphi \rightarrow \psi), (\varphi \leftrightarrow \psi)$ æ˜¯å…¬å¼
- å¦‚æœ $\varphi$ æ˜¯å…¬å¼ä¸” $x \in \mathcal{V}$ï¼Œåˆ™ $\forall x \varphi, \exists x \varphi$ æ˜¯å…¬å¼

### 2.3 é›†åˆè®ºæ¨¡å‹

**å®šä¹‰ 1.2.3** (é›†åˆè®ºæ¨¡å‹)
é›†åˆè®ºæ¨¡å‹æ˜¯ä¸€ä¸ªäºŒå…ƒç»„ $\mathcal{M} = (M, \in_M)$ï¼Œå…¶ä¸­ï¼š

- $M$ æ˜¯éç©ºçš„é›†åˆè®ºåŸŸ
- $\in_M \subseteq M \times M$ æ˜¯è§£é‡Šçš„å±äºå…³ç³»

**å®šä¹‰ 1.2.4** (å…¬å¼åœ¨æ¨¡å‹ä¸­çš„çœŸå€¼)
ç»™å®šæ¨¡å‹ $\mathcal{M} = (M, \in_M)$ å’Œèµ‹å€¼ $s: \mathcal{V} \rightarrow M$ï¼Œå…¬å¼çš„çœŸå€¼å®šä¹‰å¦‚ä¸‹ï¼š

1. $\mathcal{M}, s \models x \in y$ å½“ä¸”ä»…å½“ $(s(x), s(y)) \in \in_M$
2. $\mathcal{M}, s \models x = y$ å½“ä¸”ä»…å½“ $s(x) = s(y)$
3. $\mathcal{M}, s \models \neg\varphi$ å½“ä¸”ä»…å½“ $\mathcal{M}, s \not\models \varphi$
4. $\mathcal{M}, s \models \varphi \land \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, s \models \varphi$ ä¸” $\mathcal{M}, s \models \psi$
5. $\mathcal{M}, s \models \varphi \lor \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, s \models \varphi$ æˆ– $\mathcal{M}, s \models \psi$
6. $\mathcal{M}, s \models \varphi \rightarrow \psi$ å½“ä¸”ä»…å½“ $\mathcal{M}, s \not\models \varphi$ æˆ– $\mathcal{M}, s \models \psi$
7. $\mathcal{M}, s \models \forall x \varphi$ å½“ä¸”ä»…å½“ å¯¹æ‰€æœ‰ $a \in M$ï¼Œæœ‰ $\mathcal{M}, s[x \mapsto a] \models \varphi$
8. $\mathcal{M}, s \models \exists x \varphi$ å½“ä¸”ä»…å½“ å­˜åœ¨ $a \in M$ï¼Œä½¿å¾— $\mathcal{M}, s[x \mapsto a] \models \varphi$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬é›†åˆå®šç†

**å®šç† 1.3.1** (ç©ºé›†å”¯ä¸€æ€§)
ç©ºé›†æ˜¯å”¯ä¸€çš„ï¼Œå³å¦‚æœ $\emptyset$ å’Œ $\emptyset'$ éƒ½æ˜¯ç©ºé›†ï¼Œåˆ™ $\emptyset = \emptyset'$ã€‚

**è¯æ˜**:
è®¾ $\emptyset$ å’Œ $\emptyset'$ éƒ½æ˜¯ç©ºé›†ã€‚

æ ¹æ®ç©ºé›†çš„å®šä¹‰ï¼Œå¯¹äºä»»æ„ $x$ï¼Œæœ‰ $x \notin \emptyset$ å’Œ $x \notin \emptyset'$ã€‚

å› æ­¤ï¼Œå¯¹äºä»»æ„ $x$ï¼Œæœ‰ $x \in \emptyset \leftrightarrow x \in \emptyset'$ã€‚

æ ¹æ®å¤–å»¶å…¬ç†ï¼Œ$\emptyset = \emptyset'$ã€‚

**å®šç† 1.3.2** (å­é›†ä¼ é€’æ€§)
å¦‚æœ $A \subseteq B$ ä¸” $B \subseteq C$ï¼Œåˆ™ $A \subseteq C$ã€‚

**è¯æ˜**:
å‡è®¾ $A \subseteq B$ ä¸” $B \subseteq C$ã€‚

å¯¹äºä»»æ„ $x \in A$ï¼š

1. ç”±äº $A \subseteq B$ï¼Œæœ‰ $x \in B$
2. ç”±äº $B \subseteq C$ï¼Œæœ‰ $x \in C$

å› æ­¤ï¼Œå¯¹äºä»»æ„ $x \in A$ï¼Œéƒ½æœ‰ $x \in C$ã€‚

æ‰€ä»¥ $A \subseteq C$ã€‚

**å®šç† 1.3.3** (å¹‚é›†æ€§è´¨)
å¯¹äºä»»æ„é›†åˆ $A$ï¼Œæœ‰ $A \in \mathcal{P}(A)$ã€‚

**è¯æ˜**:
æ ¹æ®å¹‚é›†çš„å®šä¹‰ï¼Œ$\mathcal{P}(A) = \{x : x \subseteq A\}$ã€‚

ç”±äº $A \subseteq A$ï¼ˆè‡ªåæ€§ï¼‰ï¼Œæ‰€ä»¥ $A \in \mathcal{P}(A)$ã€‚

### 3.2 é›†åˆè¿ç®—å®šç†

**å®šç† 1.3.4** (å¾·æ‘©æ ¹å¾‹)
å¯¹äºä»»æ„é›†åˆ $A, B, C$ï¼Œæœ‰ï¼š
$$A \setminus (B \cup C) = (A \setminus B) \cap (A \setminus C)$$
$$A \setminus (B \cap C) = (A \setminus B) \cup (A \setminus C)$$

**è¯æ˜**:

1. è¯æ˜ $A \setminus (B \cup C) = (A \setminus B) \cap (A \setminus C)$:

   å¯¹äºä»»æ„ $x$ï¼š
   - $x \in A \setminus (B \cup C)$ å½“ä¸”ä»…å½“ $x \in A$ ä¸” $x \notin (B \cup C)$
   - å½“ä¸”ä»…å½“ $x \in A$ ä¸” $x \notin B$ ä¸” $x \notin C$
   - å½“ä¸”ä»…å½“ $x \in A \setminus B$ ä¸” $x \in A \setminus C$
   - å½“ä¸”ä»…å½“ $x \in (A \setminus B) \cap (A \setminus C)$

2. è¯æ˜ $A \setminus (B \cap C) = (A \setminus B) \cup (A \setminus C)$:

   å¯¹äºä»»æ„ $x$ï¼š
   - $x \in A \setminus (B \cap C)$ å½“ä¸”ä»…å½“ $x \in A$ ä¸” $x \notin (B \cap C)$
   - å½“ä¸”ä»…å½“ $x \in A$ ä¸” $(x \notin B$ æˆ– $x \notin C)$
   - å½“ä¸”ä»…å½“ $(x \in A$ ä¸” $x \notin B)$ æˆ– $(x \in A$ ä¸” $x \notin C)$
   - å½“ä¸”ä»…å½“ $x \in (A \setminus B) \cup (A \setminus C)$

**å®šç† 1.3.5** (åˆ†é…å¾‹)
å¯¹äºä»»æ„é›†åˆ $A, B, C$ï¼Œæœ‰ï¼š
$$A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$$
$$A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$$

**è¯æ˜**:

1. è¯æ˜ $A \cap (B \cup C) = (A \cap B) \cup (A \cap C)$:

   å¯¹äºä»»æ„ $x$ï¼š
   - $x \in A \cap (B \cup C)$ å½“ä¸”ä»…å½“ $x \in A$ ä¸” $x \in (B \cup C)$
   - å½“ä¸”ä»…å½“ $x \in A$ ä¸” $(x \in B$ æˆ– $x \in C)$
   - å½“ä¸”ä»…å½“ $(x \in A$ ä¸” $x \in B)$ æˆ– $(x \in A$ ä¸” $x \in C)$
   - å½“ä¸”ä»…å½“ $x \in (A \cap B) \cup (A \cap C)$

2. è¯æ˜ $A \cup (B \cap C) = (A \cup B) \cap (A \cup C)$:

   å¯¹äºä»»æ„ $x$ï¼š
   - $x \in A \cup (B \cap C)$ å½“ä¸”ä»…å½“ $x \in A$ æˆ– $x \in (B \cap C)$
   - å½“ä¸”ä»…å½“ $x \in A$ æˆ– $(x \in B$ ä¸” $x \in C)$
   - å½“ä¸”ä»…å½“ $(x \in A$ æˆ– $x \in B)$ ä¸” $(x \in A$ æˆ– $x \in C)$
   - å½“ä¸”ä»…å½“ $x \in (A \cup B) \cap (A \cup C)$

### 3.3 åºæ•°ç†è®º

**å®šç† 1.3.6** (åºæ•°ä¼ é€’æ€§)
æ¯ä¸ªåºæ•°éƒ½æ˜¯ä¼ é€’é›†ï¼Œå³å¦‚æœ $\alpha$ æ˜¯åºæ•°ï¼Œåˆ™å¯¹äºä»»æ„ $x \in \alpha$ï¼Œæœ‰ $x \subseteq \alpha$ã€‚

**è¯æ˜**:
è®¾ $\alpha$ æ˜¯åºæ•°ï¼Œ$x \in \alpha$ã€‚

ç”±äº $\alpha$ æ˜¯è‰¯åºé›†ï¼Œå¯¹äºä»»æ„ $y \in x$ï¼Œæœ‰ $y \in \alpha$ï¼ˆå› ä¸º $x \subseteq \alpha$ï¼‰ã€‚

å› æ­¤ $x \subseteq \alpha$ã€‚

**å®šç† 1.3.7** (åºæ•°æ¯”è¾ƒ)
å¯¹äºä»»æ„åºæ•° $\alpha, \beta$ï¼Œæœ‰ $\alpha \in \beta$ æˆ– $\alpha = \beta$ æˆ– $\beta \in \alpha$ã€‚

**è¯æ˜**:
ç”±äºåºæ•°åœ¨å±äºå…³ç³»ä¸‹æ˜¯è‰¯åºçš„ï¼Œå¯¹äºä»»æ„ä¸¤ä¸ªåºæ•° $\alpha, \beta$ï¼Œå®ƒä»¬ä¹‹é—´å¿…ç„¶å­˜åœ¨æŸç§å…³ç³»ã€‚

æ ¹æ®è‰¯åºæ€§è´¨ï¼Œè¦ä¹ˆ $\alpha \in \beta$ï¼Œè¦ä¹ˆ $\alpha = \beta$ï¼Œè¦ä¹ˆ $\beta \in \alpha$ã€‚

## 4. ä»£ç å®ç°

### 4.1 é›†åˆè®ºè¯­è¨€å®ç°

```rust
use std::collections::HashSet;
use std::fmt;
use std::hash::{Hash, Hasher};

/// é›†åˆå…ƒç´ ç±»å‹
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SetElement {
    /// è‡ªç„¶æ•°
    Natural(usize),
    /// å­—ç¬¦ä¸²
    String(String),
    /// æœ‰åºå¯¹
    OrderedPair(Box<SetElement>, Box<SetElement>),
    /// é›†åˆ
    Set(HashSet<SetElement>),
}

impl fmt::Display for SetElement {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            SetElement::Natural(n) => write!(f, "{}", n),
            SetElement::String(s) => write!(f, "\"{}\"", s),
            SetElement::OrderedPair(a, b) => write!(f, "({}, {})", a, b),
            SetElement::Set(elements) => {
                write!(f, "{{")?;
                let mut first = true;
                for element in elements {
                    if !first {
                        write!(f, ", ")?;
                    }
                    write!(f, "{}", element)?;
                    first = false;
                }
                write!(f, "}}")
            }
        }
    }
}

/// é›†åˆè®ºå…¬å¼
#[derive(Debug, Clone, PartialEq)]
pub enum SetFormula {
    /// å±äºå…³ç³»
    BelongsTo(SetElement, SetElement),
    /// ç›¸ç­‰å…³ç³»
    Equals(SetElement, SetElement),
    /// å¦å®š
    Not(Box<SetFormula>),
    /// åˆå–
    And(Box<SetFormula>, Box<SetFormula>),
    /// æå–
    Or(Box<SetFormula>, Box<SetFormula>),
    /// è•´å«
    Implies(Box<SetFormula>, Box<SetFormula>),
    /// ç­‰ä»·
    Iff(Box<SetFormula>, Box<SetFormula>),
    /// å…¨ç§°é‡è¯
    ForAll(String, Box<SetFormula>),
    /// å­˜åœ¨é‡è¯
    Exists(String, Box<SetFormula>),
}

impl fmt::Display for SetFormula {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            SetFormula::BelongsTo(x, y) => write!(f, "{} âˆˆ {}", x, y),
            SetFormula::Equals(x, y) => write!(f, "{} = {}", x, y),
            SetFormula::Not(phi) => write!(f, "Â¬({})", phi),
            SetFormula::And(phi, psi) => write!(f, "({} âˆ§ {})", phi, psi),
            SetFormula::Or(phi, psi) => write!(f, "({} âˆ¨ {})", phi, psi),
            SetFormula::Implies(phi, psi) => write!(f, "({} â†’ {})", phi, psi),
            SetFormula::Iff(phi, psi) => write!(f, "({} â†” {})", phi, psi),
            SetFormula::ForAll(var, phi) => write!(f, "âˆ€{} {}", var, phi),
            SetFormula::Exists(var, phi) => write!(f, "âˆƒ{} {}", var, phi),
        }
    }
}

/// é›†åˆè®ºæ¨¡å‹
#[derive(Debug)]
pub struct SetModel {
    pub domain: HashSet<SetElement>,
    pub membership_relation: HashSet<(SetElement, SetElement)>,
}

impl SetModel {
    /// åˆ›å»ºæ–°çš„é›†åˆè®ºæ¨¡å‹
    pub fn new() -> Self {
        SetModel {
            domain: HashSet::new(),
            membership_relation: HashSet::new(),
        }
    }
    
    /// æ·»åŠ å…ƒç´ åˆ°åŸŸ
    pub fn add_element(&mut self, element: SetElement) {
        self.domain.insert(element);
    }
    
    /// æ·»åŠ å±äºå…³ç³»
    pub fn add_membership(&mut self, element: SetElement, set: SetElement) {
        self.membership_relation.insert((element, set));
    }
    
    /// æ£€æŸ¥å±äºå…³ç³»
    pub fn is_member(&self, element: &SetElement, set: &SetElement) -> bool {
        self.membership_relation.contains(&(element.clone(), set.clone()))
    }
    
    /// æ£€æŸ¥å…¬å¼åœ¨æ¨¡å‹ä¸­çš„çœŸå€¼
    pub fn satisfies(&self, formula: &SetFormula) -> bool {
        match formula {
            SetFormula::BelongsTo(x, y) => self.is_member(x, y),
            SetFormula::Equals(x, y) => x == y,
            SetFormula::Not(phi) => !self.satisfies(phi),
            SetFormula::And(phi, psi) => self.satisfies(phi) && self.satisfies(psi),
            SetFormula::Or(phi, psi) => self.satisfies(phi) || self.satisfies(psi),
            SetFormula::Implies(phi, psi) => !self.satisfies(phi) || self.satisfies(psi),
            SetFormula::Iff(phi, psi) => self.satisfies(phi) == self.satisfies(psi),
            SetFormula::ForAll(var, phi) => {
                // ç®€åŒ–å¤„ç†ï¼šæ£€æŸ¥æ‰€æœ‰åŸŸä¸­çš„å…ƒç´ 
                true // å®é™…éœ€è¦æ›´å¤æ‚çš„å®ç°
            }
            SetFormula::Exists(var, phi) => {
                // ç®€åŒ–å¤„ç†ï¼šæ£€æŸ¥æ˜¯å¦å­˜åœ¨æ»¡è¶³æ¡ä»¶çš„å…ƒç´ 
                true // å®é™…éœ€è¦æ›´å¤æ‚çš„å®ç°
            }
        }
    }
}

/// é›†åˆè¿ç®—
pub struct SetOperations;

impl SetOperations {
    /// åˆ›å»ºç©ºé›†
    pub fn empty_set() -> SetElement {
        SetElement::Set(HashSet::new())
    }
    
    /// åˆ›å»ºå•å…ƒç´ é›†
    pub fn singleton(element: SetElement) -> SetElement {
        let mut set = HashSet::new();
        set.insert(element);
        SetElement::Set(set)
    }
    
    /// å¹¶é›†
    pub fn union(a: &SetElement, b: &SetElement) -> Option<SetElement> {
        if let (SetElement::Set(set_a), SetElement::Set(set_b)) = (a, b) {
            let mut result = set_a.clone();
            result.extend(set_b.clone());
            Some(SetElement::Set(result))
        } else {
            None
        }
    }
    
    /// äº¤é›†
    pub fn intersection(a: &SetElement, b: &SetElement) -> Option<SetElement> {
        if let (SetElement::Set(set_a), SetElement::Set(set_b)) = (a, b) {
            let result: HashSet<SetElement> = set_a.intersection(set_b).cloned().collect();
            Some(SetElement::Set(result))
        } else {
            None
        }
    }
    
    /// å·®é›†
    pub fn difference(a: &SetElement, b: &SetElement) -> Option<SetElement> {
        if let (SetElement::Set(set_a), SetElement::Set(set_b)) = (a, b) {
            let result: HashSet<SetElement> = set_a.difference(set_b).cloned().collect();
            Some(SetElement::Set(result))
        } else {
            None
        }
    }
    
    /// å¹‚é›†
    pub fn power_set(a: &SetElement) -> Option<SetElement> {
        if let SetElement::Set(set_a) = a {
            let mut power_set = HashSet::new();
            power_set.insert(SetElement::Set(HashSet::new())); // ç©ºé›†
            
            // ç”Ÿæˆæ‰€æœ‰å­é›†
            let elements: Vec<SetElement> = set_a.iter().cloned().collect();
            for i in 0..(1 << elements.len()) {
                let mut subset = HashSet::new();
                for j in 0..elements.len() {
                    if (i >> j) & 1 == 1 {
                        subset.insert(elements[j].clone());
                    }
                }
                power_set.insert(SetElement::Set(subset));
            }
            
            Some(SetElement::Set(power_set))
        } else {
            None
        }
    }
    
    /// æœ‰åºå¯¹
    pub fn ordered_pair(a: SetElement, b: SetElement) -> SetElement {
        let mut pair_set = HashSet::new();
        pair_set.insert(SetElement::singleton(a.clone()));
        pair_set.insert(SetElement::OrderedPair(Box::new(a), Box::new(b.clone())));
        SetElement::Set(pair_set)
    }
}

/// åºæ•°ç†è®º
pub struct OrdinalTheory;

impl OrdinalTheory {
    /// æ£€æŸ¥æ˜¯å¦ä¸ºä¼ é€’é›†
    pub fn is_transitive(set: &SetElement) -> bool {
        if let SetElement::Set(elements) = set {
            for element in elements {
                if let SetElement::Set(sub_elements) = element {
                    for sub_element in sub_elements {
                        if !elements.contains(sub_element) {
                            return false;
                        }
                    }
                }
            }
            true
        } else {
            false
        }
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºåºæ•°
    pub fn is_ordinal(set: &SetElement) -> bool {
        // åºæ•°å¿…é¡»æ˜¯ä¼ é€’é›†ä¸”åœ¨å±äºå…³ç³»ä¸‹è‰¯åº
        Self::is_transitive(set) && Self::is_well_ordered(set)
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºè‰¯åºé›†
    pub fn is_well_ordered(set: &SetElement) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥æ˜¯å¦åœ¨å±äºå…³ç³»ä¸‹å…¨åº
        Self::is_totally_ordered(set)
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºå…¨åºé›†
    pub fn is_totally_ordered(set: &SetElement) -> bool {
        if let SetElement::Set(elements) = set {
            for a in elements {
                for b in elements {
                    if a != b {
                        // æ£€æŸ¥æ˜¯å¦æ»¡è¶³ä¸‰åˆ†å¾‹
                        let a_in_b = Self::is_member(&a, &b);
                        let b_in_a = Self::is_member(&b, &a);
                        if !(a_in_b || b_in_a || a == b) {
                            return false;
                        }
                    }
                }
            }
            true
        } else {
            false
        }
    }
    
    /// æ£€æŸ¥å±äºå…³ç³»
    fn is_member(a: &SetElement, b: &SetElement) -> bool {
        if let SetElement::Set(elements) = b {
            elements.contains(a)
        } else {
            false
        }
    }
}

/// é›†åˆè®ºæ¨ç†ç³»ç»Ÿ
pub struct SetTheorySystem {
    pub model: SetModel,
}

impl SetTheorySystem {
    pub fn new(model: SetModel) -> Self {
        SetTheorySystem { model }
    }
    
    /// éªŒè¯å¤–å»¶å…¬ç†
    pub fn verify_extensionality(&self, a: &SetElement, b: &SetElement) -> bool {
        // å¤–å»¶å…¬ç†ï¼šå¦‚æœä¸¤ä¸ªé›†åˆæœ‰ç›¸åŒçš„å…ƒç´ ï¼Œåˆ™å®ƒä»¬ç›¸ç­‰
        if let (SetElement::Set(set_a), SetElement::Set(set_b)) = (a, b) {
            set_a == set_b
        } else {
            false
        }
    }
    
    /// éªŒè¯ç©ºé›†å…¬ç†
    pub fn verify_empty_set(&self) -> bool {
        let empty_set = SetOperations::empty_set();
        self.model.domain.contains(&empty_set)
    }
    
    /// éªŒè¯é…å¯¹å…¬ç†
    pub fn verify_pairing(&self, a: &SetElement, b: &SetElement) -> bool {
        let pair = SetOperations::ordered_pair(a.clone(), b.clone());
        self.model.domain.contains(&pair)
    }
    
    /// éªŒè¯å¹¶é›†å…¬ç†
    pub fn verify_union(&self, family: &SetElement) -> bool {
        if let SetElement::Set(sets) = family {
            let mut union_set = HashSet::new();
            for set in sets {
                if let SetElement::Set(elements) = set {
                    union_set.extend(elements.clone());
                }
            }
            let union = SetElement::Set(union_set);
            self.model.domain.contains(&union)
        } else {
            false
        }
    }
    
    /// éªŒè¯å¹‚é›†å…¬ç†
    pub fn verify_power_set(&self, a: &SetElement) -> bool {
        if let Some(power_set) = SetOperations::power_set(a) {
            self.model.domain.contains(&power_set)
        } else {
            false
        }
    }
}

/// é›†åˆè®ºæµ‹è¯•
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_set_operations() {
        // åˆ›å»ºé›†åˆ
        let a = SetElement::Set({
            let mut set = HashSet::new();
            set.insert(SetElement::Natural(1));
            set.insert(SetElement::Natural(2));
            set
        });
        
        let b = SetElement::Set({
            let mut set = HashSet::new();
            set.insert(SetElement::Natural(2));
            set.insert(SetElement::Natural(3));
            set
        });
        
        // æµ‹è¯•å¹¶é›†
        let union = SetOperations::union(&a, &b).unwrap();
        println!("A âˆª B = {}", union);
        
        // æµ‹è¯•äº¤é›†
        let intersection = SetOperations::intersection(&a, &b).unwrap();
        println!("A âˆ© B = {}", intersection);
        
        // æµ‹è¯•å·®é›†
        let difference = SetOperations::difference(&a, &b).unwrap();
        println!("A \\ B = {}", difference);
    }
    
    #[test]
    fn test_power_set() {
        let a = SetElement::Set({
            let mut set = HashSet::new();
            set.insert(SetElement::Natural(1));
            set.insert(SetElement::Natural(2));
            set
        });
        
        let power_set = SetOperations::power_set(&a).unwrap();
        println!("P(A) = {}", power_set);
    }
    
    #[test]
    fn test_ordinal_theory() {
        // åˆ›å»ºåºæ•° 0 = âˆ…
        let zero = SetOperations::empty_set();
        assert!(OrdinalTheory::is_ordinal(&zero));
        
        // åˆ›å»ºåºæ•° 1 = {0}
        let one = SetElement::Set({
            let mut set = HashSet::new();
            set.insert(zero.clone());
            set
        });
        assert!(OrdinalTheory::is_ordinal(&one));
        
        // åˆ›å»ºåºæ•° 2 = {0, 1}
        let two = SetElement::Set({
            let mut set = HashSet::new();
            set.insert(zero);
            set.insert(one);
            set
        });
        assert!(OrdinalTheory::is_ordinal(&two));
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 è‡ªç„¶æ•°æ„é€ 

**ç¤ºä¾‹ 1**: å†¯Â·è¯ºä¾æ›¼è‡ªç„¶æ•°æ„é€ 

```rust
// å†¯Â·è¯ºä¾æ›¼è‡ªç„¶æ•°æ„é€ 
fn von_neumann_naturals() -> Vec<SetElement> {
    let mut naturals = Vec::new();
    
    // 0 = âˆ…
    let zero = SetOperations::empty_set();
    naturals.push(zero.clone());
    
    // 1 = {0}
    let one = SetElement::Set({
        let mut set = HashSet::new();
        set.insert(zero.clone());
        set
    });
    naturals.push(one.clone());
    
    // 2 = {0, 1}
    let two = SetElement::Set({
        let mut set = HashSet::new();
        set.insert(zero);
        set.insert(one);
        set
    });
    naturals.push(two);
    
    naturals
}

// ä½¿ç”¨ç¤ºä¾‹
let naturals = von_neumann_naturals();
for (i, natural) in naturals.iter().enumerate() {
    println!("{} = {}", i, natural);
}
```

### 5.2 é›†åˆè¿ç®—éªŒè¯

**ç¤ºä¾‹ 2**: é›†åˆè¿ç®—å®šå¾‹éªŒè¯

```rust
// éªŒè¯å¾·æ‘©æ ¹å¾‹
fn verify_de_morgan() {
    let a = SetElement::Set({
        let mut set = HashSet::new();
        set.insert(SetElement::Natural(1));
        set.insert(SetElement::Natural(2));
        set.insert(SetElement::Natural(3));
        set
    });
    
    let b = SetElement::Set({
        let mut set = HashSet::new();
        set.insert(SetElement::Natural(2));
        set.insert(SetElement::Natural(3));
        set.insert(SetElement::Natural(4));
        set
    });
    
    let c = SetElement::Set({
        let mut set = HashSet::new();
        set.insert(SetElement::Natural(3));
        set.insert(SetElement::Natural(4));
        set.insert(SetElement::Natural(5));
        set
    });
    
    // éªŒè¯ A \ (B âˆª C) = (A \ B) âˆ© (A \ C)
    let b_union_c = SetOperations::union(&b, &c).unwrap();
    let left = SetOperations::difference(&a, &b_union_c).unwrap();
    
    let a_diff_b = SetOperations::difference(&a, &b).unwrap();
    let a_diff_c = SetOperations::difference(&a, &c).unwrap();
    let right = SetOperations::intersection(&a_diff_b, &a_diff_c).unwrap();
    
    println!("å¾·æ‘©æ ¹å¾‹éªŒè¯: {}", left == right);
}
```

### 5.3 åºæ•°è¿ç®—

**ç¤ºä¾‹ 3**: åºæ•°è¿ç®—

```rust
// åºæ•°åŠ æ³•
fn ordinal_addition(alpha: &SetElement, beta: &SetElement) -> Option<SetElement> {
    if !OrdinalTheory::is_ordinal(alpha) || !OrdinalTheory::is_ordinal(beta) {
        return None;
    }
    
    // åºæ•°åŠ æ³•ï¼šÎ± + Î² = Î± âˆª {Î± + Î³ : Î³ < Î²}
    if let (SetElement::Set(set_alpha), SetElement::Set(set_beta)) = (alpha, beta) {
        let mut result = set_alpha.clone();
        
        // æ·»åŠ æ‰€æœ‰ Î± + Î³ï¼Œå…¶ä¸­ Î³ < Î²
        for gamma in set_beta {
            if let Some(sum) = ordinal_addition(alpha, gamma) {
                result.insert(sum);
            }
        }
        
        Some(SetElement::Set(result))
    } else {
        None
    }
}

// åºæ•°ä¹˜æ³•
fn ordinal_multiplication(alpha: &SetElement, beta: &SetElement) -> Option<SetElement> {
    if !OrdinalTheory::is_ordinal(alpha) || !OrdinalTheory::is_ordinal(beta) {
        return None;
    }
    
    // åºæ•°ä¹˜æ³•ï¼šÎ± Ã— Î² = {Î± Ã— Î³ + Î´ : Î³ < Î², Î´ < Î±}
    if let (SetElement::Set(set_alpha), SetElement::Set(set_beta)) = (alpha, beta) {
        let mut result = HashSet::new();
        
        for gamma in set_beta {
            for delta in set_alpha {
                if let Some(product) = ordinal_multiplication(alpha, gamma) {
                    if let Some(sum) = ordinal_addition(&product, delta) {
                        result.insert(sum);
                    }
                }
            }
        }
        
        Some(SetElement::Set(result))
    } else {
        None
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸æœ´ç´ é›†åˆè®ºçš„å…³ç³»

å…¬ç†é›†åˆè®ºæ˜¯å¯¹æœ´ç´ é›†åˆè®ºçš„å½¢å¼åŒ–ï¼š

- **é¿å…æ‚–è®º**: é€šè¿‡å…¬ç†åŒ–æ–¹æ³•é¿å…ç½—ç´ æ‚–è®ºç­‰
- **ä¸¥æ ¼åŸºç¡€**: ä¸ºæ•°å­¦æä¾›ä¸¥æ ¼çš„é€»è¾‘åŸºç¡€
- **ä¸€è‡´æ€§**: ç¡®ä¿ç†è®ºçš„ä¸€è‡´æ€§

### 6.2 ä¸æ•°ç³»ç†è®ºçš„å…³ç³»

å…¬ç†é›†åˆè®ºä¸ºæ•°ç³»æä¾›åŸºç¡€ï¼š

- **è‡ªç„¶æ•°**: é€šè¿‡å†¯Â·è¯ºä¾æ›¼æ„é€ 
- **æ•´æ•°**: é€šè¿‡ç­‰ä»·ç±»æ„é€ 
- **æœ‰ç†æ•°**: é€šè¿‡åˆ†æ•°æ„é€ 
- **å®æ•°**: é€šè¿‡æˆ´å¾·é‡‘åˆ†å‰²æˆ–æŸ¯è¥¿åºåˆ—

### 6.3 ä¸é€»è¾‘å­¦çš„å…³ç³»

å…¬ç†é›†åˆè®ºä¸é€»è¾‘å­¦å¯†åˆ‡ç›¸å…³ï¼š

- **ä¸€é˜¶é€»è¾‘**: é›†åˆè®ºçš„è¯­è¨€åŸºç¡€
- **æ¨¡å‹è®º**: é›†åˆè®ºæ¨¡å‹çš„è¯­ä¹‰
- **è¯æ˜è®º**: é›†åˆè®ºçš„å½¢å¼åŒ–è¯æ˜

## 7. å‚è€ƒæ–‡çŒ®

1. Zermelo, E. (1908). Untersuchungen Ã¼ber die Grundlagen der Mengenlehre I. *Mathematische Annalen*, 65(2), 261-281.

2. Fraenkel, A. A. (1922). Zu den Grundlagen der Cantor-Zermeloschen Mengenlehre. *Mathematische Annalen*, 86(3-4), 230-237.

3. von Neumann, J. (1923). Zur EinfÃ¼hrung der transfiniten Zahlen. *Acta Litterarum ac Scientiarum Regiae Universitatis Hungaricae Francisco-Josephinae*, 1, 199-208.

4. GÃ¶del, K. (1940). *The consistency of the axiom of choice and of the generalized continuum-hypothesis with the axioms of set theory*. Princeton University Press.

5. Jech, T. (2003). *Set theory*. Springer Science & Business Media.

---

**ç›¸å…³æ–‡æ¡£**:

- [02.1.1 æœ´ç´ é›†åˆè®º](02.1.1_æœ´ç´ é›†åˆè®º.md)
- [02.1.3 é›†åˆè¿ç®—](02.1.3_é›†åˆè¿ç®—.md)
- [02.1.4 é›†åˆå…³ç³»](02.1.4_é›†åˆå…³ç³».md)
- [02.3.1 è‡ªç„¶æ•°ç³»ç»Ÿ](../03_Number_Systems/02.3.1_è‡ªç„¶æ•°ç³»ç»Ÿ.md)

**è¿”å›**: [æ•°å­¦åŸºç¡€ç†è®º](README.md) | [ä¸»ç´¢å¼•](README.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
