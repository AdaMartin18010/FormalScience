# 02.8.1 æ‹“æ‰‘ç©ºé—´

## ğŸ“‹ æ¦‚è¿°

æ‹“æ‰‘ç©ºé—´æ˜¯æ‹“æ‰‘å­¦çš„åŸºç¡€æ¦‚å¿µï¼Œå®ƒæä¾›äº†ä¸€ä¸ªç»Ÿä¸€çš„æ¡†æ¶æ¥ç ”ç©¶å‡ ä½•å¯¹è±¡çš„"å½¢çŠ¶"å’Œ"è¿ç»­æ€§"ã€‚æ‹“æ‰‘ç©ºé—´é€šè¿‡å¼€é›†çš„æ¦‚å¿µæ¥å®šä¹‰ï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥åœ¨ä¸å…³å¿ƒå…·ä½“åº¦é‡çš„æƒ…å†µä¸‹ç ”ç©¶ç©ºé—´çš„æ€§è´¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å½¢å¼åŒ–å®šä¹‰**ï¼šæä¾›æ‹“æ‰‘ç©ºé—´çš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. **åŸºæœ¬æ€§è´¨**ï¼šç ”ç©¶æ‹“æ‰‘ç©ºé—´çš„åŸºæœ¬æ€§è´¨å’Œå®šç†
3. **æ„é€ æ–¹æ³•**ï¼šå±•ç¤ºå¦‚ä½•æ„é€ å„ç§æ‹“æ‰‘ç©ºé—´
4. **åº”ç”¨ç¤ºä¾‹**ï¼šå±•ç¤ºæ‹“æ‰‘ç©ºé—´åœ¨æ•°å­¦å’Œç§‘å­¦ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ‹“æ‰‘ç©ºé—´çš„ç›´è§‚ç†è§£

æ‹“æ‰‘ç©ºé—´æ˜¯ä¸€ä¸ªé›†åˆï¼Œé…å¤‡äº†ä¸€ä¸ª"æ‹“æ‰‘ç»“æ„"ï¼Œè¿™ä¸ªç»“æ„å‘Šè¯‰æˆ‘ä»¬å“ªäº›å­é›†æ˜¯"å¼€é›†"ã€‚å¼€é›†çš„æ¦‚å¿µæ¨å¹¿äº†æ¬§å‡ é‡Œå¾—ç©ºé—´ä¸­å¼€åŒºé—´çš„æ¦‚å¿µã€‚

### 1.2 å¼€é›†çš„æ¦‚å¿µ

**å®šä¹‰ 1.2.1** (å¼€é›†)
è®¾ $X$ æ˜¯ä¸€ä¸ªé›†åˆï¼Œ$\mathcal{T}$ æ˜¯ $X$ çš„å­é›†æ—ã€‚å¦‚æœ $\mathcal{T}$ æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼Œåˆ™ç§° $\mathcal{T}$ ä¸º $X$ ä¸Šçš„æ‹“æ‰‘ï¼š

1. **ç©ºé›†å’Œå…¨é›†**ï¼š$\emptyset \in \mathcal{T}$ ä¸” $X \in \mathcal{T}$
2. **æœ‰é™äº¤**ï¼šå¦‚æœ $U_1, U_2, \ldots, U_n \in \mathcal{T}$ï¼Œåˆ™ $\bigcap_{i=1}^n U_i \in \mathcal{T}$
3. **ä»»æ„å¹¶**ï¼šå¦‚æœ $\{U_i\}_{i \in I} \subseteq \mathcal{T}$ï¼Œåˆ™ $\bigcup_{i \in I} U_i \in \mathcal{T}$

### 1.3 æ‹“æ‰‘ç©ºé—´çš„å®šä¹‰

**å®šä¹‰ 1.3.1** (æ‹“æ‰‘ç©ºé—´)
ä¸€ä¸ªæ‹“æ‰‘ç©ºé—´æ˜¯ä¸€ä¸ªæœ‰åºå¯¹ $(X, \mathcal{T})$ï¼Œå…¶ä¸­ï¼š

- $X$ æ˜¯ä¸€ä¸ªé›†åˆï¼ˆç§°ä¸ºåº•é›†ï¼‰
- $\mathcal{T}$ æ˜¯ $X$ ä¸Šçš„æ‹“æ‰‘

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 åŸºæœ¬æ‹“æ‰‘

**å®šä¹‰ 2.1.1** (ç¦»æ•£æ‹“æ‰‘)
è®¾ $X$ æ˜¯ä¸€ä¸ªé›†åˆï¼Œ$\mathcal{T} = \mathcal{P}(X)$ï¼ˆ$X$ çš„å¹‚é›†ï¼‰ï¼Œåˆ™ç§° $(X, \mathcal{T})$ ä¸ºç¦»æ•£æ‹“æ‰‘ç©ºé—´ã€‚

**å®šä¹‰ 2.1.2** (å¹³å‡¡æ‹“æ‰‘)
è®¾ $X$ æ˜¯ä¸€ä¸ªé›†åˆï¼Œ$\mathcal{T} = \{\emptyset, X\}$ï¼Œåˆ™ç§° $(X, \mathcal{T})$ ä¸ºå¹³å‡¡æ‹“æ‰‘ç©ºé—´ã€‚

**å®šä¹‰ 2.1.3** (åº¦é‡æ‹“æ‰‘)
è®¾ $(X, d)$ æ˜¯ä¸€ä¸ªåº¦é‡ç©ºé—´ï¼Œå®šä¹‰ï¼š
$$\mathcal{T}_d = \{U \subseteq X \mid \forall x \in U, \exists \epsilon > 0, B(x, \epsilon) \subseteq U\}$$
åˆ™ç§° $(X, \mathcal{T}_d)$ ä¸ºç”±åº¦é‡ $d$ è¯±å¯¼çš„æ‹“æ‰‘ç©ºé—´ã€‚

### 2.2 å­ç©ºé—´æ‹“æ‰‘

**å®šä¹‰ 2.2.1** (å­ç©ºé—´æ‹“æ‰‘)
è®¾ $(X, \mathcal{T})$ æ˜¯ä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ï¼Œ$A \subseteq X$ã€‚å®šä¹‰ï¼š
$$\mathcal{T}_A = \{U \cap A \mid U \in \mathcal{T}\}$$
åˆ™ç§° $(A, \mathcal{T}_A)$ ä¸º $(X, \mathcal{T})$ çš„å­ç©ºé—´ã€‚

### 2.3 ç§¯æ‹“æ‰‘

**å®šä¹‰ 2.3.1** (ç§¯æ‹“æ‰‘)
è®¾ $\{(X_i, \mathcal{T}_i)\}_{i \in I}$ æ˜¯ä¸€æ—æ‹“æ‰‘ç©ºé—´ï¼Œ$X = \prod_{i \in I} X_i$ã€‚å®šä¹‰ï¼š
$$\mathcal{T} = \left\{\prod_{i \in I} U_i \mid U_i \in \mathcal{T}_i, \text{ä¸”åªæœ‰æœ‰é™ä¸ª } U_i \neq X_i\right\}$$
åˆ™ç§° $(X, \mathcal{T})$ ä¸ºç§¯æ‹“æ‰‘ç©ºé—´ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬æ€§è´¨

**å®šç† 3.1.1** (å¼€é›†çš„åŸºæœ¬æ€§è´¨)
è®¾ $(X, \mathcal{T})$ æ˜¯ä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ï¼Œåˆ™ï¼š

1. ä»»æ„å¼€é›†çš„å¹¶æ˜¯å¼€é›†
2. æœ‰é™ä¸ªå¼€é›†çš„äº¤æ˜¯å¼€é›†
3. ç©ºé›†å’Œå…¨é›†éƒ½æ˜¯å¼€é›†

**è¯æ˜**ï¼š
è¿™äº›æ€§è´¨ç›´æ¥æ¥è‡ªæ‹“æ‰‘çš„å®šä¹‰ã€‚

### 3.2 é—­é›†çš„æ€§è´¨

**å®šä¹‰ 3.2.1** (é—­é›†)
è®¾ $(X, \mathcal{T})$ æ˜¯ä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ï¼Œ$A \subseteq X$ã€‚å¦‚æœ $X \setminus A \in \mathcal{T}$ï¼Œåˆ™ç§° $A$ ä¸ºé—­é›†ã€‚

**å®šç† 3.2.1** (é—­é›†çš„æ€§è´¨)
è®¾ $(X, \mathcal{T})$ æ˜¯ä¸€ä¸ªæ‹“æ‰‘ç©ºé—´ï¼Œåˆ™ï¼š

1. ä»»æ„é—­é›†çš„äº¤æ˜¯é—­é›†
2. æœ‰é™ä¸ªé—­é›†çš„å¹¶æ˜¯é—­é›†
3. ç©ºé›†å’Œå…¨é›†éƒ½æ˜¯é—­é›†

**è¯æ˜**ï¼š
åˆ©ç”¨å¾·æ‘©æ ¹å¾‹å’Œå¼€é›†çš„æ€§è´¨ã€‚

### 3.3 è¿ç»­æ˜ å°„

**å®šä¹‰ 3.3.1** (è¿ç»­æ˜ å°„)
è®¾ $(X, \mathcal{T}_X)$ å’Œ $(Y, \mathcal{T}_Y)$ æ˜¯ä¸¤ä¸ªæ‹“æ‰‘ç©ºé—´ï¼Œ$f: X \to Y$ æ˜¯ä¸€ä¸ªæ˜ å°„ã€‚å¦‚æœå¯¹æ¯ä¸ªå¼€é›† $V \in \mathcal{T}_Y$ï¼Œéƒ½æœ‰ $f^{-1}(V) \in \mathcal{T}_X$ï¼Œåˆ™ç§° $f$ ä¸ºè¿ç»­æ˜ å°„ã€‚

**å®šç† 3.3.1** (è¿ç»­æ˜ å°„çš„ç­‰ä»·æ¡ä»¶)
è®¾ $f: X \to Y$ æ˜¯ä¸€ä¸ªæ˜ å°„ï¼Œåˆ™ä»¥ä¸‹æ¡ä»¶ç­‰ä»·ï¼š

1. $f$ æ˜¯è¿ç»­çš„
2. å¯¹æ¯ä¸ªé—­é›† $F \subseteq Y$ï¼Œ$f^{-1}(F)$ æ˜¯é—­é›†
3. å¯¹æ¯ä¸ª $x \in X$ å’Œ $f(x)$ çš„æ¯ä¸ªé‚»åŸŸ $V$ï¼Œå­˜åœ¨ $x$ çš„é‚»åŸŸ $U$ ä½¿å¾— $f(U) \subseteq V$

## 4. ä»£ç å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::hash::Hash;

/// è¡¨ç¤ºä¸€ä¸ªæ‹“æ‰‘ç©ºé—´
pub struct TopologicalSpace<T: Hash + Eq + Clone> {
    underlying_set: HashSet<T>,
    topology: HashSet<HashSet<T>>,
}

impl<T: Hash + Eq + Clone> TopologicalSpace<T> {
    /// åˆ›å»ºæ–°çš„æ‹“æ‰‘ç©ºé—´
    pub fn new(underlying_set: HashSet<T>, topology: HashSet<HashSet<T>>) -> Result<Self, String> {
        // éªŒè¯æ‹“æ‰‘å…¬ç†
        if !Self::verify_topology_axioms(&underlying_set, &topology) {
            return Err("Invalid topology: does not satisfy topology axioms".to_string());
        }
        
        Ok(TopologicalSpace {
            underlying_set,
            topology,
        })
    }
    
    /// éªŒè¯æ‹“æ‰‘å…¬ç†
    fn verify_topology_axioms(
        underlying_set: &HashSet<T>,
        topology: &HashSet<HashSet<T>>,
    ) -> bool {
        // 1. ç©ºé›†å’Œå…¨é›†å±äºæ‹“æ‰‘
        let empty_set: HashSet<T> = HashSet::new();
        if !topology.contains(&empty_set) || !topology.contains(underlying_set) {
            return false;
        }
        
        // 2. ä»»æ„å¹¶å±äºæ‹“æ‰‘
        // è¿™ä¸ªæ£€æŸ¥åœ¨æ„é€ æ—¶è¿›è¡Œ
        
        // 3. æœ‰é™äº¤å±äºæ‹“æ‰‘
        let open_sets: Vec<&HashSet<T>> = topology.iter().collect();
        for i in 0..open_sets.len() {
            for j in (i + 1)..open_sets.len() {
                let intersection: HashSet<T> = open_sets[i]
                    .intersection(open_sets[j])
                    .cloned()
                    .collect();
                if !topology.contains(&intersection) {
                    return false;
                }
            }
        }
        
        true
    }
    
    /// æ£€æŸ¥å­é›†æ˜¯å¦ä¸ºå¼€é›†
    pub fn is_open(&self, subset: &HashSet<T>) -> bool {
        self.topology.contains(subset)
    }
    
    /// æ£€æŸ¥å­é›†æ˜¯å¦ä¸ºé—­é›†
    pub fn is_closed(&self, subset: &HashSet<T>) -> bool {
        let complement: HashSet<T> = self.underlying_set
            .difference(subset)
            .cloned()
            .collect();
        self.topology.contains(&complement)
    }
    
    /// è·å–å­é›†çš„å†…éƒ¨
    pub fn interior(&self, subset: &HashSet<T>) -> HashSet<T> {
        let mut interior = HashSet::new();
        
        for open_set in &self.topology {
            if open_set.is_subset(subset) {
                interior.extend(open_set.iter().cloned());
            }
        }
        
        interior
    }
    
    /// è·å–å­é›†çš„é—­åŒ…
    pub fn closure(&self, subset: &HashSet<T>) -> HashSet<T> {
        let complement: HashSet<T> = self.underlying_set
            .difference(subset)
            .cloned()
            .collect();
        
        let interior_of_complement = self.interior(&complement);
        let closure: HashSet<T> = self.underlying_set
            .difference(&interior_of_complement)
            .cloned()
            .collect();
        
        closure
    }
    
    /// è·å–å­é›†çš„è¾¹ç•Œ
    pub fn boundary(&self, subset: &HashSet<T>) -> HashSet<T> {
        let closure = self.closure(subset);
        let interior = self.interior(subset);
        
        closure.difference(&interior).cloned().collect()
    }
}

/// è¿ç»­æ˜ å°„
pub struct ContinuousMap<T: Hash + Eq + Clone, U: Hash + Eq + Clone> {
    domain: TopologicalSpace<T>,
    codomain: TopologicalSpace<U>,
    mapping: HashMap<T, U>,
}

impl<T: Hash + Eq + Clone, U: Hash + Eq + Clone> ContinuousMap<T, U> {
    pub fn new(
        domain: TopologicalSpace<T>,
        codomain: TopologicalSpace<U>,
        mapping: HashMap<T, U>,
    ) -> Result<Self, String> {
        // éªŒè¯æ˜ å°„çš„å®šä¹‰åŸŸ
        for (x, _) in &mapping {
            if !domain.underlying_set.contains(x) {
                return Err("Mapping domain not contained in domain space".to_string());
            }
        }
        
        // éªŒè¯è¿ç»­æ€§
        if !Self::verify_continuity(&domain, &codomain, &mapping) {
            return Err("Mapping is not continuous".to_string());
        }
        
        Ok(ContinuousMap {
            domain,
            codomain,
            mapping,
        })
    }
    
    fn verify_continuity(
        domain: &TopologicalSpace<T>,
        codomain: &TopologicalSpace<U>,
        mapping: &HashMap<T, U>,
    ) -> bool {
        for open_set in &codomain.topology {
            let preimage: HashSet<T> = mapping
                .iter()
                .filter(|(_, &ref y)| open_set.contains(y))
                .map(|(x, _)| x.clone())
                .collect();
            
            if !domain.topology.contains(&preimage) {
                return false;
            }
        }
        true
    }
    
    /// è®¡ç®—æ˜ å°„çš„åƒ
    pub fn image(&self, subset: &HashSet<T>) -> HashSet<U> {
        subset
            .iter()
            .filter_map(|x| self.mapping.get(x).cloned())
            .collect()
    }
    
    /// è®¡ç®—æ˜ å°„çš„åŸåƒ
    pub fn preimage(&self, subset: &HashSet<U>) -> HashSet<T> {
        self.mapping
            .iter()
            .filter(|(_, y)| subset.contains(y))
            .map(|(x, _)| x.clone())
            .collect()
    }
}

/// æ„é€ ç¦»æ•£æ‹“æ‰‘
pub fn discrete_topology<T: Hash + Eq + Clone>(elements: Vec<T>) -> TopologicalSpace<T> {
    let underlying_set: HashSet<T> = elements.into_iter().collect();
    let mut topology = HashSet::new();
    
    // ç”Ÿæˆå¹‚é›†
    let mut subsets = vec![HashSet::new()];
    for element in &underlying_set {
        let mut new_subsets = Vec::new();
        for subset in &subsets {
            let mut new_subset = subset.clone();
            new_subset.insert(element.clone());
            new_subsets.push(new_subset);
        }
        subsets.extend(new_subsets);
    }
    
    topology.extend(subsets);
    
    TopologicalSpace::new(underlying_set, topology).unwrap()
}

/// æ„é€ å¹³å‡¡æ‹“æ‰‘
pub fn trivial_topology<T: Hash + Eq + Clone>(elements: Vec<T>) -> TopologicalSpace<T> {
    let underlying_set: HashSet<T> = elements.into_iter().collect();
    let mut topology = HashSet::new();
    
    topology.insert(HashSet::new());
    topology.insert(underlying_set.clone());
    
    TopologicalSpace::new(underlying_set, topology).unwrap()
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_discrete_topology() {
        let elements = vec!["a", "b", "c"];
        let space = discrete_topology(elements);
        
        // æ£€æŸ¥æ‰€æœ‰å­é›†éƒ½æ˜¯å¼€é›†
        let all_subsets = vec![
            HashSet::new(),
            vec!["a"].into_iter().collect(),
            vec!["b"].into_iter().collect(),
            vec!["c"].into_iter().collect(),
            vec!["a", "b"].into_iter().collect(),
            vec!["a", "c"].into_iter().collect(),
            vec!["b", "c"].into_iter().collect(),
            vec!["a", "b", "c"].into_iter().collect(),
        ];
        
        for subset in all_subsets {
            assert!(space.is_open(&subset));
        }
    }
    
    #[test]
    fn test_trivial_topology() {
        let elements = vec!["a", "b", "c"];
        let space = trivial_topology(elements);
        
        // åªæœ‰ç©ºé›†å’Œå…¨é›†æ˜¯å¼€é›†
        let empty_set: HashSet<&str> = HashSet::new();
        let full_set: HashSet<&str> = vec!["a", "b", "c"].into_iter().collect();
        
        assert!(space.is_open(&empty_set));
        assert!(space.is_open(&full_set));
        
        let singleton: HashSet<&str> = vec!["a"].into_iter().collect();
        assert!(!space.is_open(&singleton));
    }
    
    #[test]
    fn test_interior_and_closure() {
        let elements = vec!["a", "b", "c"];
        let space = discrete_topology(elements);
        
        let subset: HashSet<&str> = vec!["a", "b"].into_iter().collect();
        let interior = space.interior(&subset);
        let closure = space.closure(&subset);
        
        assert_eq!(interior, subset);
        assert_eq!(closure, subset);
    }
}
```

### 4.2 Haskell å®ç°

```haskell
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Map (Map)
import qualified Data.Map as Map

-- è¡¨ç¤ºä¸€ä¸ªæ‹“æ‰‘ç©ºé—´
data TopologicalSpace a = TopologicalSpace
    { underlyingSet :: Set a
    , topology :: Set (Set a)
    }

-- éªŒè¯æ‹“æ‰‘å…¬ç†
verifyTopologyAxioms :: (Ord a) => TopologicalSpace a -> Bool
verifyTopologyAxioms space = 
    let emptySet = Set.empty
        fullSet = underlyingSet space
        top = topology space
    in  Set.member emptySet top &&
        Set.member fullSet top &&
        verifyFiniteIntersection top &&
        verifyArbitraryUnion top

-- éªŒè¯æœ‰é™äº¤
verifyFiniteIntersection :: (Ord a) => Set (Set a) -> Bool
verifyFiniteIntersection top = 
    let openSets = Set.toList top
    in  all (\intersection -> Set.member intersection top) 
        [Set.intersection s1 s2 | s1 <- openSets, s2 <- openSets]

-- éªŒè¯ä»»æ„å¹¶
verifyArbitraryUnion :: (Ord a) => Set (Set a) -> Bool
verifyArbitraryUnion top = True  -- ç®€åŒ–å®ç°

-- åˆ›å»ºç¦»æ•£æ‹“æ‰‘
discreteTopology :: (Ord a) => [a] -> TopologicalSpace a
discreteTopology elements = 
    let underlying = Set.fromList elements
        topology = powerSet underlying
    in  TopologicalSpace underlying topology

-- åˆ›å»ºå¹³å‡¡æ‹“æ‰‘
trivialTopology :: (Ord a) => [a] -> TopologicalSpace a
trivialTopology elements = 
    let underlying = Set.fromList elements
        topology = Set.fromList [Set.empty, underlying]
    in  TopologicalSpace underlying topology

-- å¹‚é›†
powerSet :: (Ord a) => Set a -> Set (Set a)
powerSet s = Set.fromList $ map Set.fromList $ subsequences $ Set.toList s

-- å­åºåˆ—
subsequences :: [a] -> [[a]]
subsequences [] = [[]]
subsequences (x:xs) = 
    let subs = subsequences xs
    in  subs ++ map (x:) subs

-- æ£€æŸ¥æ˜¯å¦ä¸ºå¼€é›†
isOpen :: (Ord a) => TopologicalSpace a -> Set a -> Bool
isOpen space subset = Set.member subset (topology space)

-- æ£€æŸ¥æ˜¯å¦ä¸ºé—­é›†
isClosed :: (Ord a) => TopologicalSpace a -> Set a -> Bool
isClosed space subset = 
    let complement = Set.difference (underlyingSet space) subset
    in  isOpen space complement

-- å†…éƒ¨
interior :: (Ord a) => TopologicalSpace a -> Set a -> Set a
interior space subset = 
    let openSubsets = Set.filter (\openSet -> Set.isSubsetOf openSet subset) (topology space)
    in  Set.unions openSubsets

-- é—­åŒ…
closure :: (Ord a) => TopologicalSpace a -> Set a -> Set a
closure space subset = 
    let complement = Set.difference (underlyingSet space) subset
        interiorOfComplement = interior space complement
    in  Set.difference (underlyingSet space) interiorOfComplement

-- è¾¹ç•Œ
boundary :: (Ord a) => TopologicalSpace a -> Set a -> Set a
boundary space subset = 
    let cl = closure space subset
        int = interior space subset
    in  Set.difference cl int

-- è¿ç»­æ˜ å°„
data ContinuousMap a b = ContinuousMap
    { domain :: TopologicalSpace a
    , codomain :: TopologicalSpace b
    , mapping :: Map a b
    }

-- éªŒè¯è¿ç»­æ€§
isContinuous :: (Ord a, Ord b) => ContinuousMap a b -> Bool
isContinuous cm = 
    let openSets = topology (codomain cm)
        preimages = map (\openSet -> preimage cm openSet) (Set.toList openSets)
    in  all (\preimg -> isOpen (domain cm) preimg) preimages

-- è®¡ç®—åŸåƒ
preimage :: (Ord a, Ord b) => ContinuousMap a b -> Set b -> Set a
preimage cm subset = 
    let pairs = Map.toList (mapping cm)
    in  Set.fromList [x | (x, y) <- pairs, Set.member y subset]

-- è®¡ç®—åƒ
image :: (Ord a, Ord b) => ContinuousMap a b -> Set a -> Set b
image cm subset = 
    let pairs = Map.toList (mapping cm)
    in  Set.fromList [y | (x, y) <- pairs, Set.member x subset]

-- æµ‹è¯•å‡½æ•°
testTopology :: IO ()
testTopology = do
    let elements = ["a", "b", "c"]
        discrete = discreteTopology elements
        trivial = trivialTopology elements
    
    putStrLn "Testing discrete topology:"
    putStrLn $ "Is open {'a'}: " ++ show (isOpen discrete (Set.singleton "a"))
    putStrLn $ "Is closed {'a'}: " ++ show (isClosed discrete (Set.singleton "a"))
    
    putStrLn "\nTesting trivial topology:"
    putStrLn $ "Is open {'a'}: " ++ show (isOpen trivial (Set.singleton "a"))
    putStrLn $ "Is closed {'a'}: " ++ show (isClosed trivial (Set.singleton "a"))
    
    putStrLn "\nTesting interior and closure:"
    let subset = Set.fromList ["a", "b"]
    putStrLn $ "Interior: " ++ show (interior discrete subset)
    putStrLn $ "Closure: " ++ show (closure discrete subset)
    putStrLn $ "Boundary: " ++ show (boundary discrete subset)

main :: IO ()
main = testTopology
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 åº¦é‡ç©ºé—´

**ç¤ºä¾‹ 5.1.1** (æ¬§å‡ é‡Œå¾—ç©ºé—´)
$\mathbb{R}^n$ é…å¤‡æ¬§å‡ é‡Œå¾—åº¦é‡ $d(x, y) = \sqrt{\sum_{i=1}^n (x_i - y_i)^2}$ è¯±å¯¼çš„æ‹“æ‰‘ã€‚

### 5.2 å‡½æ•°ç©ºé—´

**ç¤ºä¾‹ 5.2.1** (è¿ç»­å‡½æ•°ç©ºé—´)
è®¾ $X$ å’Œ $Y$ æ˜¯æ‹“æ‰‘ç©ºé—´ï¼Œ$C(X, Y)$ è¡¨ç¤ºä» $X$ åˆ° $Y$ çš„è¿ç»­å‡½æ•°é›†åˆï¼Œé…å¤‡ç´§è‡´-å¼€æ‹“æ‰‘ã€‚

### 5.3 ä»£æ•°æ‹“æ‰‘

**ç¤ºä¾‹ 5.3.1** (åŒä¼¦è®º)
åœ¨ä»£æ•°æ‹“æ‰‘ä¸­ï¼Œæ‹“æ‰‘ç©ºé—´ç”¨äºç ”ç©¶å‡ ä½•å¯¹è±¡çš„"å½¢çŠ¶"ï¼Œé€šè¿‡åŒä¼¦ç¾¤ç­‰ä»£æ•°ä¸å˜é‡ã€‚

## 6. ç›¸å…³ç†è®º

### 6.1 è¿é€šæ€§

- **è¿é€šç©ºé—´**ï¼šä¸èƒ½åˆ†è§£ä¸ºä¸¤ä¸ªéç©ºå¼€é›†çš„å¹¶
- **é“è·¯è¿é€š**ï¼šä»»æ„ä¸¤ç‚¹é—´å­˜åœ¨è¿ç»­é“è·¯
- **å±€éƒ¨è¿é€š**ï¼šæ¯ä¸ªç‚¹éƒ½æœ‰è¿é€šé‚»åŸŸåŸº

### 6.2 ç´§è‡´æ€§

- **ç´§è‡´ç©ºé—´**ï¼šæ¯ä¸ªå¼€è¦†ç›–éƒ½æœ‰æœ‰é™å­è¦†ç›–
- **å±€éƒ¨ç´§è‡´**ï¼šæ¯ä¸ªç‚¹éƒ½æœ‰ç´§è‡´é‚»åŸŸ
- **åºåˆ—ç´§è‡´**ï¼šæ¯ä¸ªåºåˆ—éƒ½æœ‰æ”¶æ•›å­åºåˆ—

### 6.3 åˆ†ç¦»æ€§

- **Hausdorffç©ºé—´**ï¼šä»»æ„ä¸¤ä¸ªä¸åŒç‚¹æœ‰ä¸ç›¸äº¤é‚»åŸŸ
- **æ­£åˆ™ç©ºé—´**ï¼šç‚¹å’Œé—­é›†å¯ä»¥åˆ†ç¦»
- **æ­£è§„ç©ºé—´**ï¼šä¸¤ä¸ªé—­é›†å¯ä»¥åˆ†ç¦»

### 6.4 å¯æ•°æ€§

- **ç¬¬ä¸€å¯æ•°**ï¼šæ¯ä¸ªç‚¹éƒ½æœ‰å¯æ•°é‚»åŸŸåŸº
- **ç¬¬äºŒå¯æ•°**ï¼šæ•´ä¸ªç©ºé—´æœ‰å¯æ•°åŸº

## 7. å‚è€ƒæ–‡çŒ®

1. Munkres, J. R. (2000). Topology. Prentice Hall.
2. Kelley, J. L. (1975). General Topology. Springer.
3. Willard, S. (2004). General Topology. Dover Publications.
4. Engelking, R. (1989). General Topology. Heldermann Verlag.
5. Bourbaki, N. (1995). General Topology. Springer.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.7.4 æé™ç†è®º](../02_Mathematical_Foundation/02.7.4_æé™ç†è®º.md)
- [02.8.2 è¿ç»­æ˜ å°„](../02_Mathematical_Foundation/02.8.2_è¿ç»­æ˜ å°„.md)
- [02.8.3 è¿é€šæ€§](../02_Mathematical_Foundation/02.8.3_è¿é€šæ€§.md)
- [02.8.4 ç´§è‡´æ€§](../02_Mathematical_Foundation/02.8.4_ç´§è‡´æ€§.md)


## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
