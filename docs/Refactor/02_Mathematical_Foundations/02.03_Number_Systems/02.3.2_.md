# 02.3.2 æ•´æ•°ç³»ç»Ÿ

## ğŸ“‹ æ¦‚è¿°

æ•´æ•°ç³»ç»Ÿæ˜¯è‡ªç„¶æ•°ç³»ç»Ÿçš„æ‰©å±•ï¼ŒåŒ…å«è´Ÿæ•°å’Œé›¶ã€‚æœ¬æ–‡æ¡£å»ºç«‹æ•´æ•°ç³»ç»Ÿçš„å®Œæ•´ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬æ•´æ•°çš„æ„é€ ã€ä»£æ•°ç»“æ„ã€åºå…³ç³»å’Œæ•´æ•°çš„æ€§è´¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹æ•´æ•°ç³»ç»Ÿçš„æ„é€ æ€§å®šä¹‰
2. å®šä¹‰æ•´æ•°çš„ä»£æ•°ç»“æ„
3. æ„å»ºæ•´æ•°çš„åºå…³ç³»ç†è®º
4. æä¾›æ•´æ•°è¿ç®—çš„å½¢å¼åŒ–å®šä¹‰
5. å®ç°æ•´æ•°ç³»ç»Ÿçš„ç®—æ³•åŒ–

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ•´æ•°çš„æœ¬è´¨

æ•´æ•°æ˜¯è‡ªç„¶æ•°ç³»ç»Ÿçš„æ‰©å±•ï¼ŒåŒ…å«è‡ªç„¶æ•°ã€é›¶å’Œè´Ÿè‡ªç„¶æ•°ã€‚

**å®šä¹‰ 1.1.1** (æ•´æ•°)
æ•´æ•°æ˜¯è‡ªç„¶æ•°å¯¹çš„ç­‰ä»·ç±»ï¼Œç”¨äºè¡¨ç¤ºæœ‰å‘è·ç¦»ã€‚

**å®šä¹‰ 1.1.2** (æ•´æ•°æ„é€ )
æ•´æ•°é€šè¿‡è‡ªç„¶æ•°å¯¹çš„ç­‰ä»·å…³ç³»æ„é€ ï¼š
$(a, b) \sim (c, d)$ å½“ä¸”ä»…å½“ $a + d = b + c$

### 1.2 æ•´æ•°çš„åˆ†ç±»

**å®šä¹‰ 1.1.3** (æ­£æ•´æ•°)
æ­£æ•´æ•°æ˜¯å½¢å¦‚ $(n, 0)$ çš„æ•´æ•°ï¼Œå…¶ä¸­ $n \in \mathbb{N}^+$ã€‚

**å®šä¹‰ 1.1.4** (è´Ÿæ•´æ•°)
è´Ÿæ•´æ•°æ˜¯å½¢å¦‚ $(0, n)$ çš„æ•´æ•°ï¼Œå…¶ä¸­ $n \in \mathbb{N}^+$ã€‚

**å®šä¹‰ 1.1.5** (é›¶)
é›¶æ˜¯æ•´æ•° $(0, 0)$ã€‚

### 1.3 æ•´æ•°çš„ä»£æ•°ç»“æ„

**å®šä¹‰ 1.1.6** (æ•´æ•°ç¯)
æ•´æ•°å½¢æˆäº¤æ¢ç¯ $(\mathbb{Z}, +, \cdot)$ã€‚

**å®šä¹‰ 1.1.7** (æ•´æ•°åŸŸ)
æ•´æ•°ä¸å½¢æˆåŸŸï¼Œå› ä¸ºå¤§å¤šæ•°éé›¶å…ƒç´ æ²¡æœ‰ä¹˜æ³•é€†å…ƒã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ•´æ•°çš„æ„é€ 

**å®šä¹‰ 2.1.1** (æ•´æ•°æ„é€ )
è®¾ $\mathbb{N} \times \mathbb{N}$ æ˜¯è‡ªç„¶æ•°å¯¹çš„é›†åˆï¼Œå®šä¹‰ç­‰ä»·å…³ç³»ï¼š
$$(a, b) \sim (c, d) \Leftrightarrow a + d = b + c$$

æ•´æ•°é›† $\mathbb{Z}$ æ˜¯ $\mathbb{N} \times \mathbb{N} / \sim$ çš„å•†é›†ã€‚

**å®šä¹‰ 2.1.2** (æ•´æ•°è¡¨ç¤º)
æ•´æ•°çš„æ ‡å‡†è¡¨ç¤ºï¼š

- æ­£æ•´æ•°ï¼š$n = [(n, 0)]$
- è´Ÿæ•´æ•°ï¼š$-n = [(0, n)]$
- é›¶ï¼š$0 = [(0, 0)]$

**å®šä¹‰ 2.1.3** (æ•´æ•°åµŒå…¥)
è‡ªç„¶æ•°åˆ°æ•´æ•°çš„åµŒå…¥æ˜ å°„ï¼š
$$\iota: \mathbb{N} \rightarrow \mathbb{Z}, \iota(n) = [(n, 0)]$$

### 2.2 æ•´æ•°è¿ç®—

**å®šä¹‰ 2.2.1** (æ•´æ•°åŠ æ³•)
æ•´æ•°åŠ æ³•å®šä¹‰ä¸ºï¼š
$$[(a, b)] + [(c, d)] = [(a + c, b + d)]$$

**å®šä¹‰ 2.2.2** (æ•´æ•°ä¹˜æ³•)
æ•´æ•°ä¹˜æ³•å®šä¹‰ä¸ºï¼š
$$[(a, b)] \cdot [(c, d)] = [(ac + bd, ad + bc)]$$

**å®šä¹‰ 2.2.3** (æ•´æ•°å‡æ³•)
æ•´æ•°å‡æ³•å®šä¹‰ä¸ºï¼š
$$[(a, b)] - [(c, d)] = [(a, b)] + [(d, c)]$$

**å®šä¹‰ 2.2.4** (æ•´æ•°ç»å¯¹å€¼)
æ•´æ•°ç»å¯¹å€¼å®šä¹‰ä¸ºï¼š
$$|[(a, b)]| = \max(a, b)$$

### 2.3 æ•´æ•°åºå…³ç³»

**å®šä¹‰ 2.3.1** (æ•´æ•°åºå…³ç³»)
æ•´æ•°åºå…³ç³»å®šä¹‰ä¸ºï¼š
$$[(a, b)] \leq [(c, d)] \Leftrightarrow a + d \leq b + c$$

**å®šä¹‰ 2.3.2** (æ•´æ•°ä¸¥æ ¼åº)
æ•´æ•°ä¸¥æ ¼åºå®šä¹‰ä¸ºï¼š
$$[(a, b)] < [(c, d)] \Leftrightarrow [(a, b)] \leq [(c, d)] \land [(a, b)] \neq [(c, d)]$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬æ€§è´¨å®šç†

**å®šç† 3.1.1** (æ•´æ•°æ„é€ çš„è‰¯å®šä¹‰æ€§)
æ•´æ•°è¿ç®—ä¸ç­‰ä»·ç±»ä»£è¡¨çš„é€‰æ‹©æ— å…³ã€‚

**è¯æ˜**ï¼š
è®¾ $(a, b) \sim (a', b')$ å’Œ $(c, d) \sim (c', d')$ã€‚
åˆ™ $a + b' = b + a'$ å’Œ $c + d' = d + c'$ã€‚
å¯¹äºåŠ æ³•ï¼š
$(a + c) + (b' + d') = (a + b') + (c + d') = (b + a') + (d + c') = (b + d) + (a' + c')$
å› æ­¤ $(a + c, b + d) \sim (a' + c', b' + d')$ã€‚

**å®šç† 3.1.2** (æ•´æ•°ç¯çš„æ€§è´¨)
æ•´æ•°ç¯ $(\mathbb{Z}, +, \cdot)$ å…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼š

1. **åŠ æ³•äº¤æ¢å¾‹**ï¼š$a + b = b + a$
2. **åŠ æ³•ç»“åˆå¾‹**ï¼š$(a + b) + c = a + (b + c)$
3. **åŠ æ³•å•ä½å…ƒ**ï¼š$a + 0 = a$
4. **åŠ æ³•é€†å…ƒ**ï¼š$a + (-a) = 0$
5. **ä¹˜æ³•äº¤æ¢å¾‹**ï¼š$a \cdot b = b \cdot a$
6. **ä¹˜æ³•ç»“åˆå¾‹**ï¼š$(a \cdot b) \cdot c = a \cdot (b \cdot c)$
7. **ä¹˜æ³•å•ä½å…ƒ**ï¼š$a \cdot 1 = a$
8. **åˆ†é…å¾‹**ï¼š$a \cdot (b + c) = a \cdot b + a \cdot c$

**è¯æ˜**ï¼š
é€šè¿‡ç­‰ä»·ç±»çš„å®šä¹‰å’Œè‡ªç„¶æ•°çš„æ€§è´¨è¯æ˜ã€‚

### 3.2 åºå…³ç³»å®šç†

**å®šç† 3.2.1** (æ•´æ•°åºå…³ç³»çš„æ€§è´¨)
æ•´æ•°åºå…³ç³»å…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼š

1. **è‡ªåæ€§**ï¼š$\forall a \in \mathbb{Z}, a \leq a$
2. **åå¯¹ç§°æ€§**ï¼š$\forall a, b \in \mathbb{Z}, a \leq b \land b \leq a \Rightarrow a = b$
3. **ä¼ é€’æ€§**ï¼š$\forall a, b, c \in \mathbb{Z}, a \leq b \land b \leq c \Rightarrow a \leq c$
4. **å®Œå…¨æ€§**ï¼š$\forall a, b \in \mathbb{Z}, a \leq b \lor b \leq a$

**å®šç† 3.2.2** (æ•´æ•°åºä¸è¿ç®—çš„ç›¸å®¹æ€§)
æ•´æ•°åºå…³ç³»ä¸è¿ç®—ç›¸å®¹ï¼š

1. **åŠ æ³•å•è°ƒæ€§**ï¼š$a \leq b \Rightarrow a + c \leq b + c$
2. **ä¹˜æ³•å•è°ƒæ€§**ï¼š$a \leq b \land c \geq 0 \Rightarrow a \cdot c \leq b \cdot c$

### 3.3 æ•´æ•°æ€§è´¨å®šç†

**å®šç† 3.3.1** (æ•´æ•°çš„è‰¯åºæ€§)
æ•´æ•°çš„æ¯ä¸ªéç©ºæœ‰ä¸‹ç•Œçš„å­é›†éƒ½æœ‰æœ€å°å…ƒç´ ã€‚

**å®šç† 3.3.2** (æ•´æ•°çš„é˜¿åŸºç±³å¾·æ€§è´¨)
å¯¹äºä»»æ„æ­£æ•´æ•° $a, b$ï¼Œå­˜åœ¨è‡ªç„¶æ•° $n$ ä½¿å¾— $n \cdot a > b$ã€‚

**å®šç† 3.3.3** (æ•´æ•°çš„å”¯ä¸€åˆ†è§£)
æ¯ä¸ªéé›¶æ•´æ•°å¯ä»¥å”¯ä¸€è¡¨ç¤ºä¸ºç´ æ•°çš„ä¹˜ç§¯ï¼ˆè€ƒè™‘ç¬¦å·ï¼‰ã€‚

## 4. ä»£ç å®ç°

### 4.1 æ•´æ•°æ•°æ®ç»“æ„

```rust
use std::fmt;
use std::ops::{Add, Sub, Mul, Neg, AddAssign, SubAssign, MulAssign};

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Integer {
    positive: u64,
    negative: u64,
}

impl Integer {
    pub fn zero() -> Self {
        Self {
            positive: 0,
            negative: 0,
        }
    }
    
    pub fn from_natural(n: u64) -> Self {
        Self {
            positive: n,
            negative: 0,
        }
    }
    
    pub fn from_negative_natural(n: u64) -> Self {
        Self {
            positive: 0,
            negative: n,
        }
    }
    
    pub fn from_i64(n: i64) -> Self {
        if n >= 0 {
            Self::from_natural(n as u64)
        } else {
            Self::from_negative_natural((-n) as u64)
        }
    }
    
    pub fn to_i64(&self) -> i64 {
        if self.positive > self.negative {
            (self.positive - self.negative) as i64
        } else if self.negative > self.positive {
            -((self.negative - self.positive) as i64)
        } else {
            0
        }
    }
    
    pub fn is_zero(&self) -> bool {
        self.positive == 0 && self.negative == 0
    }
    
    pub fn is_positive(&self) -> bool {
        self.positive > self.negative
    }
    
    pub fn is_negative(&self) -> bool {
        self.negative > self.positive
    }
    
    pub fn abs(&self) -> u64 {
        if self.positive > self.negative {
            self.positive - self.negative
        } else {
            self.negative - self.positive
        }
    }
    
    pub fn normalize(&mut self) {
        let min = std::cmp::min(self.positive, self.negative);
        self.positive -= min;
        self.negative -= min;
    }
}
```

### 4.2 æ•´æ•°è¿ç®—å®ç°

```rust
impl Integer {
    /// åŠ æ³•è¿ç®—
    pub fn add(&self, other: &Integer) -> Integer {
        let mut result = Integer {
            positive: self.positive + other.positive,
            negative: self.negative + other.negative,
        };
        result.normalize();
        result
    }
    
    /// å‡æ³•è¿ç®—
    pub fn subtract(&self, other: &Integer) -> Integer {
        let mut result = Integer {
            positive: self.positive + other.negative,
            negative: self.negative + other.positive,
        };
        result.normalize();
        result
    }
    
    /// ä¹˜æ³•è¿ç®—
    pub fn multiply(&self, other: &Integer) -> Integer {
        let positive_part = self.positive * other.positive + self.negative * other.negative;
        let negative_part = self.positive * other.negative + self.negative * other.positive;
        
        let mut result = Integer {
            positive: positive_part,
            negative: negative_part,
        };
        result.normalize();
        result
    }
    
    /// é™¤æ³•è¿ç®—
    pub fn divide(&self, other: &Integer) -> Option<Integer> {
        if other.is_zero() {
            None // é™¤é›¶é”™è¯¯
        } else {
            let abs_self = self.abs();
            let abs_other = other.abs();
            
            if abs_self < abs_other {
                Some(Integer::zero())
            } else {
                let quotient = abs_self / abs_other;
                let remainder = abs_self % abs_other;
                
                if remainder == 0 {
                    let sign = if (self.is_positive() && other.is_positive()) || 
                                   (self.is_negative() && other.is_negative()) {
                        Integer::from_natural(quotient)
                    } else {
                        Integer::from_negative_natural(quotient)
                    };
                    Some(sign)
                } else {
                    None // ä¸æ˜¯æ•´é™¤
                }
            }
        }
    }
    
    /// æ¨¡è¿ç®—
    pub fn modulo(&self, other: &Integer) -> Option<Integer> {
        if other.is_zero() {
            None
        } else {
            let abs_self = self.abs();
            let abs_other = other.abs();
            let remainder = abs_self % abs_other;
            
            if remainder == 0 {
                Some(Integer::zero())
            } else {
                let sign = if self.is_positive() {
                    Integer::from_natural(remainder)
                } else {
                    Integer::from_negative_natural(remainder)
                };
                Some(sign)
            }
        }
    }
    
    /// å¹‚è¿ç®—
    pub fn power(&self, exponent: &Integer) -> Option<Integer> {
        if exponent.is_negative() {
            None // è´ŸæŒ‡æ•°åœ¨æ•´æ•°ä¸­æœªå®šä¹‰
        } else {
            let exp = exponent.to_i64() as u64;
            if exp == 0 {
                Some(Integer::from_natural(1))
            } else {
                let base = self.abs();
                let result = base.pow(exp as u32);
                
                let sign = if self.is_negative() && exp % 2 == 1 {
                    Integer::from_negative_natural(result)
                } else {
                    Integer::from_natural(result)
                };
                Some(sign)
            }
        }
    }
}

// è¿ç®—ç¬¦é‡è½½
impl Add for Integer {
    type Output = Integer;
    
    fn add(self, other: Integer) -> Integer {
        self.add(&other)
    }
}

impl Sub for Integer {
    type Output = Integer;
    
    fn sub(self, other: Integer) -> Integer {
        self.subtract(&other)
    }
}

impl Mul for Integer {
    type Output = Integer;
    
    fn mul(self, other: Integer) -> Integer {
        self.multiply(&other)
    }
}

impl Neg for Integer {
    type Output = Integer;
    
    fn neg(self) -> Integer {
        Integer {
            positive: self.negative,
            negative: self.positive,
        }
    }
}

impl AddAssign for Integer {
    fn add_assign(&mut self, other: Integer) {
        *self = self.add(&other);
    }
}

impl SubAssign for Integer {
    fn sub_assign(&mut self, other: Integer) {
        *self = self.subtract(&other);
    }
}

impl MulAssign for Integer {
    fn mul_assign(&mut self, other: Integer) {
        *self = self.multiply(&other);
    }
}
```

### 4.3 æ•´æ•°æ€§è´¨éªŒè¯

```rust
impl Integer {
    /// æœ€å¤§å…¬çº¦æ•°
    pub fn gcd(&self, other: &Integer) -> Integer {
        let a = self.abs();
        let b = other.abs();
        
        if b == 0 {
            Integer::from_natural(a)
        } else {
            let remainder = a % b;
            Integer::from_natural(remainder).gcd(&Integer::from_natural(b))
        }
    }
    
    /// æœ€å°å…¬å€æ•°
    pub fn lcm(&self, other: &Integer) -> Integer {
        let a = self.abs();
        let b = other.abs();
        let gcd = self.gcd(other).abs();
        
        if gcd == 0 {
            Integer::zero()
        } else {
            Integer::from_natural(a / gcd * b)
        }
    }
    
    /// åˆ¤æ–­æ˜¯å¦ä¸ºç´ æ•°
    pub fn is_prime(&self) -> bool {
        if self.is_negative() || self.is_zero() {
            false
        } else {
            let n = self.abs();
            if n < 2 {
                false
            } else if n == 2 {
                true
            } else if n % 2 == 0 {
                false
            } else {
                let sqrt_n = (n as f64).sqrt() as u64;
                for i in (3..=sqrt_n).step_by(2) {
                    if n % i == 0 {
                        return false;
                    }
                }
                true
            }
        }
    }
    
    /// æ¬§æ‹‰å‡½æ•°
    pub fn euler_totient(&self) -> Integer {
        if self.is_negative() || self.is_zero() {
            Integer::zero()
        } else {
            let mut n = self.abs();
            let mut result = n;
            
            for i in 2..=n {
                if i * i > n {
                    break;
                }
                if n % i == 0 {
                    while n % i == 0 {
                        n /= i;
                    }
                    result = result / i * (i - 1);
                }
            }
            
            if n > 1 {
                result = result / n * (n - 1);
            }
            
            Integer::from_natural(result)
        }
    }
}
```

### 4.4 æ•´æ•°ç³»ç»ŸéªŒè¯

```rust
pub struct IntegerSystemValidator;

impl IntegerSystemValidator {
    /// éªŒè¯æ•´æ•°ç¯æ€§è´¨
    pub fn verify_ring_properties() -> bool {
        let a = Integer::from_i64(5);
        let b = Integer::from_i64(-3);
        let c = Integer::from_i64(2);
        
        // åŠ æ³•äº¤æ¢å¾‹
        if a.clone() + b.clone() != b.clone() + a.clone() {
            return false;
        }
        
        // åŠ æ³•ç»“åˆå¾‹
        if (a.clone() + b.clone()) + c.clone() != a.clone() + (b.clone() + c.clone()) {
            return false;
        }
        
        // åŠ æ³•å•ä½å…ƒ
        if a.clone() + Integer::zero() != a {
            return false;
        }
        
        // åŠ æ³•é€†å…ƒ
        if a.clone() + (-a.clone()) != Integer::zero() {
            return false;
        }
        
        // ä¹˜æ³•äº¤æ¢å¾‹
        if a.clone() * b.clone() != b.clone() * a.clone() {
            return false;
        }
        
        // ä¹˜æ³•ç»“åˆå¾‹
        if (a.clone() * b.clone()) * c.clone() != a.clone() * (b.clone() * c.clone()) {
            return false;
        }
        
        // ä¹˜æ³•å•ä½å…ƒ
        if a.clone() * Integer::from_natural(1) != a {
            return false;
        }
        
        // åˆ†é…å¾‹
        if a.clone() * (b.clone() + c.clone()) != a.clone() * b.clone() + a.clone() * c.clone() {
            return false;
        }
        
        true
    }
    
    /// éªŒè¯åºå…³ç³»æ€§è´¨
    pub fn verify_order_properties() -> bool {
        let a = Integer::from_i64(3);
        let b = Integer::from_i64(-2);
        let c = Integer::from_i64(5);
        
        // è‡ªåæ€§
        if !(a <= a) {
            return false;
        }
        
        // åå¯¹ç§°æ€§
        if a < b && b < a {
            return false;
        }
        
        // ä¼ é€’æ€§
        if a < b && b < c && !(a < c) {
            return false;
        }
        
        // å®Œå…¨æ€§
        if !(a <= b || b <= a) {
            return false;
        }
        
        true
    }
    
    /// éªŒè¯é˜¿åŸºç±³å¾·æ€§è´¨
    pub fn verify_archimedean_property() -> bool {
        let a = Integer::from_natural(1);
        let b = Integer::from_natural(1000);
        
        // å­˜åœ¨è‡ªç„¶æ•°nä½¿å¾—n*a > b
        let n = Integer::from_natural(1001);
        n * a > b
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 åŸºæœ¬è¿ç®—ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_basic_arithmetic() {
        let a = Integer::from_i64(5);
        let b = Integer::from_i64(-3);
        
        // åŠ æ³•
        assert_eq!(a.clone() + b.clone(), Integer::from_i64(2));
        assert_eq!(b.clone() + a.clone(), Integer::from_i64(2));
        
        // å‡æ³•
        assert_eq!(a.clone() - b.clone(), Integer::from_i64(8));
        assert_eq!(b.clone() - a.clone(), Integer::from_i64(-8));
        
        // ä¹˜æ³•
        assert_eq!(a.clone() * b.clone(), Integer::from_i64(-15));
        assert_eq!(b.clone() * a.clone(), Integer::from_i64(-15));
        
        // ç»å¯¹å€¼
        assert_eq!(a.abs(), 5);
        assert_eq!(b.abs(), 3);
    }
    
    #[test]
    fn test_division() {
        let a = Integer::from_i64(15);
        let b = Integer::from_i64(3);
        let c = Integer::from_i64(7);
        
        assert_eq!(a.divide(&b), Some(Integer::from_i64(5)));
        assert_eq!(a.divide(&c), None); // ä¸æ˜¯æ•´é™¤
        assert_eq!(a.divide(&Integer::zero()), None); // é™¤é›¶
    }
    
    #[test]
    fn test_power() {
        let a = Integer::from_i64(2);
        let b = Integer::from_i64(-2);
        
        assert_eq!(a.power(&Integer::from_natural(3)), Some(Integer::from_i64(8)));
        assert_eq!(b.power(&Integer::from_natural(3)), Some(Integer::from_i64(-8)));
        assert_eq!(a.power(&Integer::from_natural(0)), Some(Integer::from_natural(1)));
        assert_eq!(a.power(&Integer::from_negative_natural(1)), None); // è´ŸæŒ‡æ•°
    }
    
    #[test]
    fn test_gcd_lcm() {
        let a = Integer::from_i64(12);
        let b = Integer::from_i64(18);
        
        assert_eq!(a.gcd(&b), Integer::from_natural(6));
        assert_eq!(a.lcm(&b), Integer::from_natural(36));
    }
    
    #[test]
    fn test_prime() {
        assert!(Integer::from_i64(2).is_prime());
        assert!(Integer::from_i64(3).is_prime());
        assert!(Integer::from_i64(5).is_prime());
        assert!(!Integer::from_i64(4).is_prime());
        assert!(!Integer::from_i64(1).is_prime());
        assert!(!Integer::from_i64(0).is_prime());
        assert!(!Integer::from_i64(-2).is_prime());
    }
    
    #[test]
    fn test_euler_totient() {
        assert_eq!(Integer::from_i64(1).euler_totient(), Integer::from_natural(1));
        assert_eq!(Integer::from_i64(6).euler_totient(), Integer::from_natural(2));
        assert_eq!(Integer::from_i64(8).euler_totient(), Integer::from_natural(4));
    }
    
    #[test]
    fn test_ring_properties() {
        assert!(IntegerSystemValidator::verify_ring_properties());
    }
    
    #[test]
    fn test_order_properties() {
        assert!(IntegerSystemValidator::verify_order_properties());
    }
    
    #[test]
    fn test_archimedean_property() {
        assert!(IntegerSystemValidator::verify_archimedean_property());
    }
}
```

### 5.2 å¤æ‚è¿ç®—ç¤ºä¾‹

```rust
#[test]
fn test_complex_operations() {
    // è®¡ç®—å¤§æ•´æ•°çš„è¿ç®—
    let large_a = Integer::from_natural(1000000);
    let large_b = Integer::from_natural(999999);
    
    let sum = large_a.clone() + large_b.clone();
    let product = large_a.clone() * large_b.clone();
    
    assert_eq!(sum, Integer::from_natural(1999999));
    assert_eq!(product, Integer::from_natural(999999000000));
    
    // æµ‹è¯•è´Ÿæ•°çš„å¤æ‚è¿ç®—
    let neg_a = Integer::from_i64(-100);
    let pos_b = Integer::from_i64(50);
    
    let result = neg_a.clone() * pos_b.clone() + neg_a.clone();
    assert_eq!(result, Integer::from_i64(-5050));
}

#[test]
fn test_number_theory() {
    // è´¹é©¬å°å®šç†éªŒè¯
    let p = Integer::from_i64(7);
    let a = Integer::from_i64(3);
    
    if p.is_prime() {
        let power = a.power(&(p.clone() - Integer::from_natural(1))).unwrap();
        let remainder = power.modulo(&p).unwrap();
        assert_eq!(remainder, Integer::from_natural(1));
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸è‡ªç„¶æ•°çš„å…³ç³»

æ•´æ•°æ˜¯è‡ªç„¶æ•°çš„æ‰©å±•ï¼ŒåŒ…å«è‡ªç„¶æ•°ä½œä¸ºå­é›†ã€‚

### 6.2 ä¸æœ‰ç†æ•°çš„å…³ç³»

æ•´æ•°æ˜¯æœ‰ç†æ•°çš„å­é›†ï¼Œæœ‰ç†æ•°é€šè¿‡æ•´æ•°å¯¹æ„é€ ã€‚

### 6.3 ä¸ä»£æ•°ç»“æ„çš„å…³ç³»

æ•´æ•°å½¢æˆäº¤æ¢ç¯ï¼Œæ˜¯ä»£æ•°ç»“æ„çš„é‡è¦ä¾‹å­ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Hungerford, T. W. (2012). Abstract Algebra: An Introduction. Cengage Learning.
2. Dummit, D. S., & Foote, R. M. (2004). Abstract Algebra. John Wiley & Sons.
3. Herstein, I. N. (1996). Abstract Algebra. Prentice Hall.
4. ç‹å®ªé’§. (1998). æ•°ç†é€»è¾‘å¼•è®º. åŒ—äº¬å¤§å­¦å‡ºç‰ˆç¤¾.
5. å¼ æ¸…å®‡. (2006). é€»è¾‘å“²å­¦ä¹ç« . æ±Ÿè‹äººæ°‘å‡ºç‰ˆç¤¾.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.3.1 è‡ªç„¶æ•°ç³»ç»Ÿ](../02.3.1_è‡ªç„¶æ•°ç³»ç»Ÿ.md)
- [02.3.3 æœ‰ç†æ•°ç³»ç»Ÿ](../02.3.3_æœ‰ç†æ•°ç³»ç»Ÿ.md)
- [02.3.4 å®æ•°ç³»ç»Ÿ](../02.3.4_å®æ•°ç³»ç»Ÿ.md)
- [02.6.1 ç¾¤è®ºåŸºç¡€](../02.6.1_ç¾¤è®ºåŸºç¡€.md)
- [02.6.2 ç¯è®ºåŸºç¡€](../02.6.2_ç¯è®ºåŸºç¡€.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
