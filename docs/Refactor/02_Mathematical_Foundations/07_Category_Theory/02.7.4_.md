# 02.7.4 æé™ç†è®º

## ğŸ“‹ æ¦‚è¿°

æé™ç†è®ºæ˜¯èŒƒç•´è®ºä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå®ƒç»Ÿä¸€äº†æ•°å­¦ä¸­å„ç§"æé™"æ¦‚å¿µï¼ŒåŒ…æ‹¬é›†åˆè®ºä¸­çš„äº¤é›†ã€ä»£æ•°ä¸­çš„ç›´ç§¯ã€æ‹“æ‰‘å­¦ä¸­çš„æé™ç­‰ã€‚æé™ç†è®ºä¸ºæ•°å­¦æä¾›äº†ä¸€ä¸ªç»Ÿä¸€çš„æ¡†æ¶æ¥ç†è§£å„ç§æ„é€ æ€§æ“ä½œã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **ç»Ÿä¸€æé™æ¦‚å¿µ**ï¼šå°†å„ç§æ•°å­¦åˆ†æ”¯ä¸­çš„æé™æ¦‚å¿µç»Ÿä¸€åœ¨èŒƒç•´è®ºæ¡†æ¶ä¸‹
2. **å½¢å¼åŒ–å®šä¹‰**ï¼šæä¾›ä¸¥æ ¼çš„æ•°å­¦å®šä¹‰å’Œå½¢å¼åŒ–è¡¨è¾¾
3. **æ„é€ æ€§æ–¹æ³•**ï¼šå±•ç¤ºå¦‚ä½•æ„é€ å’Œè®¡ç®—æé™
4. **åº”ç”¨ç¤ºä¾‹**ï¼šå±•ç¤ºæé™ç†è®ºåœ¨å„ä¸ªæ•°å­¦åˆ†æ”¯ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æé™çš„ç›´è§‚ç†è§£

åœ¨èŒƒç•´è®ºä¸­ï¼Œæé™æ˜¯å¯¹ä¸€ä¸ªå›¾ï¼ˆdiagramï¼‰çš„"æœ€ä½³è¿‘ä¼¼"ã€‚ç»™å®šä¸€ä¸ªå›¾ $F: J \to C$ï¼Œæé™ $\lim F$ æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå®ƒå…·æœ‰åˆ°å›¾ä¸­æ‰€æœ‰å¯¹è±¡çš„æ€å°„ï¼Œå¹¶ä¸”æ»¡è¶³æŸç§"é€šç”¨æ€§è´¨"ã€‚

### 1.2 å›¾çš„æ¦‚å¿µ

**å®šä¹‰ 1.2.1** (å›¾)
ä¸€ä¸ªå›¾ $F: J \to C$ ç”±ä»¥ä¸‹ç»„æˆï¼š

- ä¸€ä¸ªå°èŒƒç•´ $J$ï¼ˆç§°ä¸ºç´¢å¼•èŒƒç•´ï¼‰
- ä¸€ä¸ªå‡½å­ $F: J \to C$

### 1.3 é”¥çš„æ¦‚å¿µ

**å®šä¹‰ 1.3.1** (é”¥)
ç»™å®šå›¾ $F: J \to C$ï¼Œä¸€ä¸ªé”¥ $(L, \lambda)$ ç”±ä»¥ä¸‹ç»„æˆï¼š

- ä¸€ä¸ªå¯¹è±¡ $L \in C$
- ä¸€æ—æ€å°„ $\lambda_j: L \to F(j)$ï¼Œå¯¹æ¯ä¸ª $j \in J$
- æ»¡è¶³ï¼šå¯¹æ¯ä¸ªæ€å°„ $f: j \to j'$ åœ¨ $J$ ä¸­ï¼Œæœ‰ $F(f) \circ \lambda_j = \lambda_{j'}$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æé™çš„ä¸¥æ ¼å®šä¹‰

**å®šä¹‰ 2.1.1** (æé™)
ç»™å®šå›¾ $F: J \to C$ï¼Œæé™ $\lim F$ æ˜¯ä¸€ä¸ªé”¥ $(L, \lambda)$ï¼Œæ»¡è¶³ä»¥ä¸‹é€šç”¨æ€§è´¨ï¼š

å¯¹ä»»æ„é”¥ $(M, \mu)$ï¼Œå­˜åœ¨å”¯ä¸€çš„æ€å°„ $u: M \to L$ï¼Œä½¿å¾—å¯¹æ¯ä¸ª $j \in J$ï¼Œæœ‰ï¼š
$$\lambda_j \circ u = \mu_j$$

### 2.2 æé™çš„å­˜åœ¨æ€§

**å®šç† 2.2.1** (æé™å­˜åœ¨æ€§)
å¦‚æœèŒƒç•´ $C$ æœ‰æ‰€æœ‰å°æé™ï¼Œåˆ™ç§° $C$ æ˜¯å®Œå¤‡çš„ã€‚

### 2.3 æé™çš„æ„é€ 

**å®šç† 2.3.1** (ç§¯çš„æ„é€ )
å¦‚æœ $C$ æœ‰ç§¯å’Œç­‰åŒ–å­ï¼Œåˆ™ $C$ æœ‰æ‰€æœ‰å°æé™ã€‚

**è¯æ˜**ï¼š
è®¾ $F: J \to C$ æ˜¯ä¸€ä¸ªå°å›¾ã€‚æ„é€ ï¼š

1. ç§¯ $P = \prod_{j \in J} F(j)$
2. ç­‰åŒ–å­ $E$ ä½¿å¾—å¯¹æ¯ä¸ªæ€å°„ $f: j \to j'$ï¼Œæœ‰ $p_j = F(f) \circ p_{j'}$
3. åˆ™ $E$ å°±æ˜¯ $\lim F$

## 3. å®šç†ä¸è¯æ˜

### 3.1 æé™çš„å”¯ä¸€æ€§

**å®šç† 3.1.1** (æé™å”¯ä¸€æ€§)
å¦‚æœæé™å­˜åœ¨ï¼Œåˆ™å®ƒåœ¨åŒæ„æ„ä¹‰ä¸‹å”¯ä¸€ã€‚

**è¯æ˜**ï¼š
è®¾ $(L, \lambda)$ å’Œ $(L', \lambda')$ éƒ½æ˜¯ $F$ çš„æé™ã€‚ç”±é€šç”¨æ€§è´¨ï¼Œå­˜åœ¨å”¯ä¸€æ€å°„ $u: L' \to L$ å’Œ $v: L \to L'$ã€‚

è€ƒè™‘å¤åˆ $v \circ u: L' \to L'$ã€‚ç”±é€šç”¨æ€§è´¨ï¼Œ$v \circ u = \text{id}_{L'}$ã€‚
åŒç†ï¼Œ$u \circ v = \text{id}_L$ã€‚

å› æ­¤ $L \cong L'$ã€‚

### 3.2 æé™çš„ä¿æŒæ€§

**å®šç† 3.2.1** (å‡½å­ä¿æŒæé™)
å¦‚æœå‡½å­ $G: C \to D$ ä¿æŒæé™ï¼Œåˆ™å¯¹ä»»æ„å›¾ $F: J \to C$ï¼Œæœ‰ï¼š
$$G(\lim F) \cong \lim(G \circ F)$$

### 3.3 æé™çš„è®¡ç®—

**å®šç† 3.3.1** (æé™è®¡ç®—)
åœ¨é›†åˆèŒƒç•´ $\mathbf{Set}$ ä¸­ï¼Œæé™å¯ä»¥æ˜¾å¼è®¡ç®—ï¼š

$$\lim F = \left\{ (x_j)_{j \in J} \in \prod_{j \in J} F(j) \mid \forall f: j \to j', F(f)(x_j) = x_{j'} \right\}$$

## 4. ä»£ç å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::HashMap;

/// è¡¨ç¤ºä¸€ä¸ªå›¾
pub struct Diagram<J, C> {
    objects: HashMap<J, C>,
    morphisms: HashMap<(J, J), Box<dyn Fn(&C) -> C>>,
}

/// è¡¨ç¤ºä¸€ä¸ªé”¥
pub struct Cone<J, C> {
    apex: C,
    projections: HashMap<J, Box<dyn Fn(&C) -> C>>,
}

/// æé™çš„trait
pub trait Limit<J, C> {
    fn limit(diagram: &Diagram<J, C>) -> Option<Cone<J, C>>;
}

/// åœ¨é›†åˆèŒƒç•´ä¸­çš„æé™å®ç°
impl Limit<String, Vec<String>> for Vec<String> {
    fn limit(diagram: &Diagram<String, Vec<String>>) -> Option<Cone<String, Vec<String>>> {
        // è®¡ç®—ç§¯
        let mut product = Vec::new();
        let mut current = vec![String::new(); diagram.objects.len()];
        
        // é€’å½’ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„ç»„åˆ
        Self::generate_combinations(diagram, &mut current, 0, &mut product);
        
        // è¿‡æ»¤æ»¡è¶³äº¤æ¢æ¡ä»¶çš„å…ƒç´ 
        let limit_elements: Vec<String> = product
            .into_iter()
            .filter(|combo| Self::satisfies_commutativity(diagram, combo))
            .collect();
        
        Some(Cone {
            apex: limit_elements,
            projections: Self::create_projections(diagram),
        })
    }
}

impl Vec<String> {
    fn generate_combinations(
        diagram: &Diagram<String, Vec<String>>,
        current: &mut [String],
        index: usize,
        result: &mut Vec<String>,
    ) {
        if index >= current.len() {
            result.push(current.join("|"));
            return;
        }
        
        let object_keys: Vec<_> = diagram.objects.keys().cloned().collect();
        if let Some(object) = diagram.objects.get(&object_keys[index]) {
            for element in object {
                current[index] = element.clone();
                Self::generate_combinations(diagram, current, index + 1, result);
            }
        }
    }
    
    fn satisfies_commutativity(
        diagram: &Diagram<String, Vec<String>>,
        combo: &str,
    ) -> bool {
        // æ£€æŸ¥æ‰€æœ‰æ€å°„çš„äº¤æ¢æ€§
        for ((src, dst), morphism) in &diagram.morphisms {
            let src_index = diagram.objects.keys().position(|k| k == src).unwrap();
            let dst_index = diagram.objects.keys().position(|k| k == dst).unwrap();
            
            let src_val = combo.split('|').nth(src_index).unwrap();
            let dst_val = combo.split('|').nth(dst_index).unwrap();
            
            // æ£€æŸ¥ F(f)(src_val) == dst_val
            if morphism(&vec![src_val.to_string()])[0] != dst_val {
                return false;
            }
        }
        true
    }
    
    fn create_projections(
        diagram: &Diagram<String, Vec<String>>,
    ) -> HashMap<String, Box<dyn Fn(&Vec<String>) -> Vec<String>>> {
        let mut projections = HashMap::new();
        
        for (index, key) in diagram.objects.keys().enumerate() {
            let idx = index;
            projections.insert(
                key.clone(),
                Box::new(move |limit_elements: &Vec<String>| {
                    limit_elements
                        .iter()
                        .map(|element| element.split('|').nth(idx).unwrap().to_string())
                        .collect()
                }),
            );
        }
        
        projections
    }
}

/// æµ‹è¯•æé™è®¡ç®—
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_limit_computation() {
        let mut diagram = Diagram {
            objects: HashMap::new(),
            morphisms: HashMap::new(),
        };
        
        // æ·»åŠ å¯¹è±¡
        diagram.objects.insert("A".to_string(), vec!["a1".to_string(), "a2".to_string()]);
        diagram.objects.insert("B".to_string(), vec!["b1".to_string(), "b2".to_string()]);
        
        // æ·»åŠ æ€å°„
        diagram.morphisms.insert(
            ("A".to_string(), "B".to_string()),
            Box::new(|_| vec!["b1".to_string()]),
        );
        
        // è®¡ç®—æé™
        if let Some(limit) = Vec::<String>::limit(&diagram) {
            println!("Limit apex: {:?}", limit.apex);
            assert!(!limit.apex.is_empty());
        } else {
            panic!("Limit should exist");
        }
    }
}
```

### 4.2 Haskell å®ç°

```haskell
{-# LANGUAGE TypeFamilies, FlexibleContexts #-}

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set

-- è¡¨ç¤ºä¸€ä¸ªå›¾
data Diagram j c = Diagram
    { objects :: Map j c
    , morphisms :: Map (j, j) (c -> c)
    }

-- è¡¨ç¤ºä¸€ä¸ªé”¥
data Cone j c = Cone
    { apex :: c
    , projections :: Map j (c -> c)
    }

-- æé™çš„ç±»
class Limit j c where
    limit :: Diagram j c -> Maybe (Cone j c)

-- åœ¨é›†åˆèŒƒç•´ä¸­çš„æé™å®ç°
instance (Ord j, Show j) => Limit j [String] where
    limit diagram = Just $ Cone
        { apex = limitElements
        , projections = createProjections diagram
        }
      where
        limitElements = filter (satisfiesCommutativity diagram) allCombinations
        allCombinations = generateCombinations diagram

-- ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„ç»„åˆ
generateCombinations :: Diagram j c -> [[String]]
generateCombinations diagram = 
    let objectLists = map snd $ Map.toList $ objects diagram
    in  cartesianProduct objectLists

-- ç¬›å¡å°”ç§¯
cartesianProduct :: [[String]] -> [[String]]
cartesianProduct [] = [[]]
cartesianProduct (xs:xss) = 
    [y:ys | y <- xs, ys <- cartesianProduct xss]

-- æ£€æŸ¥äº¤æ¢æ€§
satisfiesCommutativity :: Diagram j c -> [String] -> Bool
satisfiesCommutativity diagram combo =
    all (\((src, dst), morphism) -> 
        let srcIndex = getIndex diagram src
            dstIndex = getIndex diagram dst
            srcVal = combo !! srcIndex
            dstVal = combo !! dstIndex
        in  morphism [srcVal] == [dstVal]
    ) $ Map.toList $ morphisms diagram

-- è·å–ç´¢å¼•
getIndex :: Diagram j c -> j -> Int
getIndex diagram obj = 
    length $ takeWhile (/= obj) $ map fst $ Map.toList $ objects diagram

-- åˆ›å»ºæŠ•å½±
createProjections :: Diagram j c -> Map j ([String] -> [String])
createProjections diagram = 
    Map.fromList $ zip (Map.keys $ objects diagram) 
        [\limitElements -> [limitElements !! i] | i <- [0..]]

-- æµ‹è¯•å‡½æ•°
testLimit :: IO ()
testLimit = do
    let diagram = Diagram
            { objects = Map.fromList 
                [("A", ["a1", "a2"])
                ,("B", ["b1", "b2"])
                ]
            , morphisms = Map.fromList 
                [((("A", "B"), \_ -> ["b1"]))
                ]
            }
    
    case limit diagram of
        Just cone -> do
            putStrLn $ "Limit apex: " ++ show (apex cone)
            putStrLn $ "Projections: " ++ show (Map.keys $ projections cone)
        Nothing -> putStrLn "No limit found"

main :: IO ()
main = testLimit
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 é›†åˆè®ºä¸­çš„åº”ç”¨

**ç¤ºä¾‹ 5.1.1** (äº¤é›†ä½œä¸ºæé™)
è®¾ $I$ æ˜¯ä¸€ä¸ªé›†åˆï¼Œ$\{A_i\}_{i \in I}$ æ˜¯ä¸€æ—é›†åˆã€‚è€ƒè™‘å›¾ï¼š
$$F: I \to \mathbf{Set}, \quad F(i) = A_i$$

åˆ™ $\lim F = \bigcap_{i \in I} A_i$

### 5.2 ä»£æ•°ä¸­çš„åº”ç”¨

**ç¤ºä¾‹ 5.2.1** (ç›´ç§¯ä½œä¸ºæé™)
è®¾ $I$ æ˜¯ä¸€ä¸ªé›†åˆï¼Œ$\{G_i\}_{i \in I}$ æ˜¯ä¸€æ—ç¾¤ã€‚è€ƒè™‘å›¾ï¼š
$$F: I \to \mathbf{Grp}, \quad F(i) = G_i$$

åˆ™ $\lim F = \prod_{i \in I} G_i$

### 5.3 æ‹“æ‰‘å­¦ä¸­çš„åº”ç”¨

**ç¤ºä¾‹ 5.3.1** (æ‹“æ‰‘æé™)
è®¾ $\{X_i\}_{i \in I}$ æ˜¯ä¸€æ—æ‹“æ‰‘ç©ºé—´ï¼Œ$f_{ij}: X_i \to X_j$ æ˜¯è¿ç»­æ˜ å°„ã€‚è€ƒè™‘å›¾ï¼š
$$F: I \to \mathbf{Top}, \quad F(i) = X_i$$

åˆ™ $\lim F$ æ˜¯é€†æé™ï¼ˆinverse limitï¼‰ã€‚

## 6. ç›¸å…³ç†è®º

### 6.1 ä½™æé™

ä½™æé™æ˜¯æé™çš„å¯¹å¶æ¦‚å¿µï¼Œè¡¨ç¤º"æœ€ä½³ä¸Šç•Œ"ã€‚

### 6.2 å®Œå¤‡æ€§

ä¸€ä¸ªèŒƒç•´å¦‚æœæœ‰æ‰€æœ‰å°æé™ï¼Œåˆ™ç§°å…¶ä¸ºå®Œå¤‡çš„ã€‚

### 6.3 æé™ä¿æŒ

ä¸€ä¸ªå‡½å­å¦‚æœä¿æŒæé™ï¼Œåˆ™ç§°å…¶ä¸ºè¿ç»­å‡½å­ã€‚

### 6.4 æé™çš„è®¡ç®—

- **é›†åˆèŒƒç•´**ï¼šæé™æ˜¯æ»¡è¶³äº¤æ¢æ¡ä»¶çš„å…ƒç´ é›†åˆ
- **ç¾¤èŒƒç•´**ï¼šæé™æ˜¯æ»¡è¶³äº¤æ¢æ¡ä»¶çš„ç¾¤
- **æ‹“æ‰‘ç©ºé—´èŒƒç•´**ï¼šæé™æ˜¯å¸¦æœ‰é€‚å½“æ‹“æ‰‘çš„ç©ºé—´

## 7. å‚è€ƒæ–‡çŒ®

1. Mac Lane, S. (1998). Categories for the Working Mathematician. Springer.
2. Awodey, S. (2010). Category Theory. Oxford University Press.
3. Leinster, T. (2014). Basic Category Theory. Cambridge University Press.
4. Riehl, E. (2017). Category Theory in Context. Dover Publications.
5. Barr, M., & Wells, C. (1990). Category Theory for Computing Science. Prentice Hall.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.7.1 èŒƒç•´æ¦‚å¿µ](../02_Mathematical_Foundation/02.7.1_èŒƒç•´æ¦‚å¿µ.md)
- [02.7.2 å‡½å­ç†è®º](../02_Mathematical_Foundation/02.7.2_å‡½å­ç†è®º.md)
- [02.7.3 è‡ªç„¶å˜æ¢](../02_Mathematical_Foundation/02.7.3_è‡ªç„¶å˜æ¢.md)
- [02.8.1 æ‹“æ‰‘ç©ºé—´](../02_Mathematical_Foundation/02.8.1_æ‹“æ‰‘ç©ºé—´.md)


## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
