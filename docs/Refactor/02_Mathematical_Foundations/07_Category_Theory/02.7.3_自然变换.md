# 02.7.3 è‡ªç„¶å˜æ¢

## ğŸ“‹ æ¦‚è¿°

è‡ªç„¶å˜æ¢æ˜¯èŒƒç•´è®ºä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå®ƒæè¿°äº†å‡½å­ä¹‹é—´çš„æ˜ å°„å…³ç³»ã€‚è‡ªç„¶å˜æ¢ä¸ä»…ä¿æŒäº†å‡½å­çš„ç»“æ„ï¼Œè¿˜ä¸ºä¸åŒæ•°å­¦æ„é€ ä¹‹é—´å»ºç«‹äº†è‡ªç„¶çš„å¯¹åº”å…³ç³»ã€‚æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»è‡ªç„¶å˜æ¢çš„å®šä¹‰ã€æ€§è´¨å’Œåº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. ç†è§£è‡ªç„¶å˜æ¢çš„åŸºæœ¬æ¦‚å¿µå’Œæ€§è´¨
2. æŒæ¡è‡ªç„¶å˜æ¢çš„äº¤æ¢æ€§æ¡ä»¶
3. å­¦ä¹ è‡ªç„¶å˜æ¢çš„é‡è¦ä¾‹å­å’Œåº”ç”¨
4. ä¸ºæé™ç†è®ºå’Œä¼´éšå‡½å­å¥ å®šåŸºç¡€

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è‡ªç„¶å˜æ¢çš„å®šä¹‰

**å®šä¹‰ 1.1.1** (è‡ªç„¶å˜æ¢)
è®¾ $F, G: \mathcal{C} \to \mathcal{D}$ æ˜¯ä¸¤ä¸ªå‡½å­ã€‚ä¸€ä¸ªè‡ªç„¶å˜æ¢ $\alpha: F \Rightarrow G$ ç”±ä»¥ä¸‹æ•°æ®ç»„æˆï¼š

å¯¹äº $\mathcal{C}$ ä¸­çš„æ¯ä¸ªå¯¹è±¡ $A$ï¼Œå­˜åœ¨ $\mathcal{D}$ ä¸­çš„æ€å°„ï¼š
$$\alpha_A: F(A) \to G(A)$$

æ»¡è¶³è‡ªç„¶æ€§æ¡ä»¶ï¼šå¯¹äº $\mathcal{C}$ ä¸­çš„ä»»æ„æ€å°„ $f: A \to B$ï¼Œä¸‹å›¾äº¤æ¢ï¼š

```text
F(A) ----Î±_A----> G(A)
 |                |
 |                |
F(f)             G(f)
 |                |
 v                v
F(B) ----Î±_B----> G(B)
```

å³ï¼š$G(f) \circ \alpha_A = \alpha_B \circ F(f)$

### 1.2 è‡ªç„¶å˜æ¢çš„æ€§è´¨

**å®šä¹‰ 1.2.1** (è‡ªç„¶åŒæ„)
è‡ªç„¶å˜æ¢ $\alpha: F \Rightarrow G$ ç§°ä¸ºè‡ªç„¶åŒæ„ï¼Œå¦‚æœå¯¹äºæ¯ä¸ªå¯¹è±¡ $A$ï¼Œæ€å°„ $\alpha_A$ éƒ½æ˜¯åŒæ„ã€‚

**å®šä¹‰ 1.2.2** (è‡ªç„¶å˜æ¢çš„å¤åˆ)
è®¾ $\alpha: F \Rightarrow G$ å’Œ $\beta: G \Rightarrow H$ æ˜¯ä¸¤ä¸ªè‡ªç„¶å˜æ¢ï¼Œå®ƒä»¬çš„å¤åˆ $\beta \circ \alpha: F \Rightarrow H$ å®šä¹‰ä¸ºï¼š
$$(\beta \circ \alpha)_A = \beta_A \circ \alpha_A$$

**å®šä¹‰ 1.2.3** (æ’ç­‰è‡ªç„¶å˜æ¢)
æ’ç­‰è‡ªç„¶å˜æ¢ $1_F: F \Rightarrow F$ å®šä¹‰ä¸ºï¼š
$$(1_F)_A = 1_{F(A)}$$

### 1.3 åŸºæœ¬ä¾‹å­

**ä¾‹å­ 1.3.1** (åˆ—è¡¨çš„reverseè‡ªç„¶å˜æ¢)
è€ƒè™‘å‡½å­ $F(X) = [X]$ å’Œ $G(X) = [X]$ï¼Œå®šä¹‰è‡ªç„¶å˜æ¢ $\alpha: F \Rightarrow G$ ä¸ºï¼š
$$\alpha_X = \text{reverse}: [X] \to [X]$$

è‡ªç„¶æ€§éªŒè¯ï¼šå¯¹äºå‡½æ•° $f: X \to Y$ï¼Œ
$$\text{reverse} \circ \text{map } f = \text{map } f \circ \text{reverse}$$

**ä¾‹å­ 1.3.2** (Maybeçš„joinè‡ªç„¶å˜æ¢)
è€ƒè™‘å‡½å­ $F(X) = \text{Maybe}(\text{Maybe } X)$ å’Œ $G(X) = \text{Maybe } X$ï¼Œå®šä¹‰è‡ªç„¶å˜æ¢ $\alpha: F \Rightarrow G$ ä¸ºï¼š
$$\alpha_X = \text{join}: \text{Maybe}(\text{Maybe } X) \to \text{Maybe } X$$

å…¶ä¸­ $\text{join}$ å®šä¹‰ä¸ºï¼š
$$\text{join Nothing} = \text{Nothing}$$
$$\text{join (Just Nothing)} = \text{Nothing}$$
$$\text{join (Just (Just x))} = \text{Just x}$$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 è‡ªç„¶å˜æ¢çš„ç±»å‹ç±»å®šä¹‰

```haskell
-- è‡ªç„¶å˜æ¢çš„ç±»å‹ç±»
class (Functor f, Functor g) => NaturalTransformation f g where
    -- è‡ªç„¶å˜æ¢çš„ç»„ä»¶
    eta :: f a -> g a
    
    -- è‡ªç„¶æ€§æ¡ä»¶
    naturality :: (a -> b) -> f a -> Bool
    naturality f fa = eta (fmap f fa) == fmap f (eta fa)

-- è‡ªç„¶åŒæ„
class NaturalTransformation f g => NaturalIsomorphism f g where
    -- é€†è‡ªç„¶å˜æ¢
    eta_inv :: g a -> f a
    
    -- åŒæ„æ¡ä»¶
    isomorphism :: f a -> Bool
    isomorphism fa = eta_inv (eta fa) == fa && eta (eta_inv (ga)) == ga
      where ga = eta fa

-- è‡ªç„¶å˜æ¢çš„å¤åˆ
newtype ComposeNT f g h a = ComposeNT { getComposeNT :: f a -> h a }

instance (NaturalTransformation f g, NaturalTransformation g h) => 
         NaturalTransformation f h where
    eta = ComposeNT (\fa -> eta (eta fa))
```

### 2.2 è‡ªç„¶å˜æ¢çš„éªŒè¯

**å®šä¹‰ 2.2.1** (è‡ªç„¶å˜æ¢çš„éªŒè¯)
è‡ªç„¶å˜æ¢ $\alpha: F \Rightarrow G$ æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š

1. **å¯¹è±¡æ˜ å°„**ï¼šå¯¹äºæ¯ä¸ªå¯¹è±¡ $A$ï¼Œå­˜åœ¨æ€å°„ $\alpha_A: F(A) \to G(A)$
2. **è‡ªç„¶æ€§**ï¼šå¯¹äºæ¯ä¸ªæ€å°„ $f: A \to B$ï¼Œæœ‰ $G(f) \circ \alpha_A = \alpha_B \circ F(f)$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬å®šç†

**å®šç† 3.1.1** (è‡ªç„¶å˜æ¢çš„å¤åˆç»“åˆå¾‹)
è®¾ $\alpha: F \Rightarrow G$, $\beta: G \Rightarrow H$, $\gamma: H \Rightarrow K$ æ˜¯è‡ªç„¶å˜æ¢ï¼Œåˆ™ï¼š
$$(\gamma \circ \beta) \circ \alpha = \gamma \circ (\beta \circ \alpha)$$

**è¯æ˜**ï¼š
å¯¹äºä»»æ„å¯¹è±¡ $A$ï¼š
$$((\gamma \circ \beta) \circ \alpha)_A = (\gamma \circ \beta)_A \circ \alpha_A = (\gamma_A \circ \beta_A) \circ \alpha_A$$
$$= \gamma_A \circ (\beta_A \circ \alpha_A) = \gamma_A \circ (\beta \circ \alpha)_A = (\gamma \circ (\beta \circ \alpha))_A$$

**å®šç† 3.1.2** (è‡ªç„¶å˜æ¢çš„å•ä½å¾‹)
è®¾ $\alpha: F \Rightarrow G$ æ˜¯è‡ªç„¶å˜æ¢ï¼Œåˆ™ï¼š
$$1_G \circ \alpha = \alpha = \alpha \circ 1_F$$

**è¯æ˜**ï¼š
å¯¹äºä»»æ„å¯¹è±¡ $A$ï¼š
$$(1_G \circ \alpha)_A = (1_G)_A \circ \alpha_A = 1_{G(A)} \circ \alpha_A = \alpha_A$$
$$(\alpha \circ 1_F)_A = \alpha_A \circ (1_F)_A = \alpha_A \circ 1_{F(A)} = \alpha_A$$

### 3.2 é‡è¦æ€§è´¨

**å‘½é¢˜ 3.2.1** (è‡ªç„¶å˜æ¢ä¿æŒæé™)
å¦‚æœ $\alpha: F \Rightarrow G$ æ˜¯è‡ªç„¶åŒæ„ï¼Œä¸” $F$ ä¿æŒæé™ï¼Œåˆ™ $G$ ä¹Ÿä¿æŒæé™ã€‚

**è¯æ˜**ï¼š
è®¾ $D: \mathcal{J} \to \mathcal{C}$ æ˜¯å›¾è¡¨ï¼Œ$L$ æ˜¯ $D$ çš„æé™ã€‚ç”±äº $F$ ä¿æŒæé™ï¼Œ$F(L)$ æ˜¯ $F \circ D$ çš„æé™ã€‚
ç”±äº $\alpha$ æ˜¯è‡ªç„¶åŒæ„ï¼Œ$G(L) \cong F(L)$ï¼Œå› æ­¤ $G(L)$ ä¹Ÿæ˜¯ $G \circ D$ çš„æé™ã€‚

**å‘½é¢˜ 3.2.2** (è‡ªç„¶å˜æ¢çš„Yonedaå¼•ç†)
å¯¹äºå‡½å­ $F: \mathcal{C} \to \mathbf{Set}$ å’Œå¯¹è±¡ $A \in \mathcal{C}$ï¼Œå­˜åœ¨åŒå°„ï¼š
$$\text{Nat}(\text{Hom}(A, -), F) \cong F(A)$$

## 4. ä»£ç å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::HashMap;

/// è‡ªç„¶å˜æ¢çš„åŸºæœ¬å®šä¹‰
pub trait NaturalTransformation<F, G, A, B>
where
    F: Functor<A, B>,
    G: Functor<A, B>,
{
    /// è‡ªç„¶å˜æ¢çš„ç»„ä»¶
    fn eta(&self, fa: F::F) -> G::F;
    
    /// è‡ªç„¶æ€§æ¡ä»¶éªŒè¯
    fn naturality<C>(&self, f: impl Fn(A) -> B, fa: F::F) -> bool
    where
        F: Functor<A, C>,
        G: Functor<B, C>,
    {
        let left = self.eta(fa.fmap(f));
        let right = self.eta(fa).fmap(f);
        left == right
    }
}

/// è‡ªç„¶åŒæ„
pub trait NaturalIsomorphism<F, G, A, B>: NaturalTransformation<F, G, A, B>
where
    F: Functor<A, B>,
    G: Functor<A, B>,
{
    /// é€†è‡ªç„¶å˜æ¢
    fn eta_inv(&self, ga: G::F) -> F::F;
    
    /// åŒæ„æ¡ä»¶éªŒè¯
    fn isomorphism(&self, fa: F::F) -> bool {
        let ga = self.eta(fa.clone());
        let fa_prime = self.eta_inv(ga.clone());
        fa == fa_prime && self.eta(fa_prime) == ga
    }
}

/// åˆ—è¡¨reverseè‡ªç„¶å˜æ¢
pub struct ReverseNaturalTransformation;

impl<A> NaturalTransformation<Vec<A>, Vec<A>, A, A> for ReverseNaturalTransformation {
    fn eta(&self, fa: Vec<A>) -> Vec<A> {
        let mut result = fa;
        result.reverse();
        result
    }
}

/// Maybe joinè‡ªç„¶å˜æ¢
pub struct JoinNaturalTransformation;

impl<A> NaturalTransformation<Option<Option<A>>, Option<A>, A, A> for JoinNaturalTransformation {
    fn eta(&self, fa: Option<Option<A>>) -> Option<A> {
        match fa {
            None => None,
            Some(None) => None,
            Some(Some(a)) => Some(a),
        }
    }
}

/// è‡ªç„¶å˜æ¢çš„å¤åˆ
pub struct ComposeNaturalTransformation<NT1, NT2> {
    nt1: NT1,
    nt2: NT2,
}

impl<NT1, NT2, F, G, H, A, B> NaturalTransformation<F, H, A, B> 
for ComposeNaturalTransformation<NT1, NT2>
where
    NT1: NaturalTransformation<F, G, A, B>,
    NT2: NaturalTransformation<G, H, A, B>,
    F: Functor<A, B>,
    G: Functor<A, B>,
    H: Functor<A, B>,
{
    fn eta(&self, fa: F::F) -> H::F {
        let ga = self.nt1.eta(fa);
        self.nt2.eta(ga)
    }
}

/// æ’ç­‰è‡ªç„¶å˜æ¢
pub struct IdentityNaturalTransformation<F> {
    _phantom: std::marker::PhantomData<F>,
}

impl<F, A, B> NaturalTransformation<F, F, A, B> for IdentityNaturalTransformation<F>
where
    F: Functor<A, B>,
{
    fn eta(&self, fa: F::F) -> F::F {
        fa
    }
}

/// è‡ªç„¶å˜æ¢éªŒè¯å™¨
pub struct NaturalTransformationValidator<NT, F, G> {
    _phantom: std::marker::PhantomData<(NT, F, G)>,
}

impl<NT, F, G, A, B> NaturalTransformationValidator<NT, F, G>
where
    NT: NaturalTransformation<F, G, A, B>,
    F: Functor<A, B>,
    G: Functor<A, B>,
{
    /// éªŒè¯è‡ªç„¶æ€§
    pub fn verify_naturality<C>(
        nt: &NT,
        f: impl Fn(A) -> B,
        fa: F::F,
    ) -> bool
    where
        F: Functor<A, C>,
        G: Functor<B, C>,
    {
        nt.naturality(f, fa)
    }
    
    /// éªŒè¯åŒæ„
    pub fn verify_isomorphism(nt: &NT, fa: F::F) -> bool
    where
        NT: NaturalIsomorphism<F, G, A, B>,
    {
        nt.isomorphism(fa)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_reverse_natural_transformation() {
        let nt = ReverseNaturalTransformation;
        let vec = vec![1, 2, 3];
        let result = nt.eta(vec);
        assert_eq!(result, vec![3, 2, 1]);
    }
    
    #[test]
    fn test_join_natural_transformation() {
        let nt = JoinNaturalTransformation;
        let opt = Some(Some(5));
        let result = nt.eta(opt);
        assert_eq!(result, Some(5));
        
        let opt_none = Some(None::<i32>);
        let result_none = nt.eta(opt_none);
        assert_eq!(result_none, None);
    }
    
    #[test]
    fn test_naturality() {
        let nt = ReverseNaturalTransformation;
        let vec = vec![1, 2, 3];
        let f = |x: i32| x * 2;
        
        // éªŒè¯è‡ªç„¶æ€§ï¼šreverse . map f = map f . reverse
        let left = nt.eta(vec.clone().fmap(f));
        let right = nt.eta(vec).fmap(f);
        assert_eq!(left, right);
    }
}
```

### 4.2 Haskell å®ç°

```haskell
-- è‡ªç„¶å˜æ¢çš„ç±»å‹ç±»
class (Functor f, Functor g) => NaturalTransformation f g where
    -- è‡ªç„¶å˜æ¢çš„ç»„ä»¶
    eta :: f a -> g a
    
    -- è‡ªç„¶æ€§æ¡ä»¶
    naturality :: (a -> b) -> f a -> Bool
    naturality f fa = eta (fmap f fa) == fmap f (eta fa)

-- è‡ªç„¶åŒæ„
class NaturalTransformation f g => NaturalIsomorphism f g where
    -- é€†è‡ªç„¶å˜æ¢
    eta_inv :: g a -> f a
    
    -- åŒæ„æ¡ä»¶
    isomorphism :: f a -> Bool
    isomorphism fa = eta_inv (eta fa) == fa

-- åˆ—è¡¨reverseè‡ªç„¶å˜æ¢
newtype ReverseNT a = ReverseNT { getReverse :: [a] -> [a] }

instance NaturalTransformation [] [] where
    eta = reverse

-- Maybe joinè‡ªç„¶å˜æ¢
newtype JoinNT a = JoinNT { getJoin :: Maybe (Maybe a) -> Maybe a }

instance NaturalTransformation (Compose Maybe Maybe) Maybe where
    eta Nothing = Nothing
    eta (Just Nothing) = Nothing
    eta (Just (Just a)) = Just a

-- è‡ªç„¶å˜æ¢çš„å¤åˆ
newtype ComposeNT f g h a = ComposeNT { getComposeNT :: f a -> h a }

instance (NaturalTransformation f g, NaturalTransformation g h) => 
         NaturalTransformation f h where
    eta = ComposeNT (\fa -> eta (eta fa))

-- æ’ç­‰è‡ªç„¶å˜æ¢
newtype IdentityNT f a = IdentityNT { getIdentity :: f a -> f a }

instance Functor f => NaturalTransformation f f where
    eta = id

-- è‡ªç„¶å˜æ¢çš„éªŒè¯
class NaturalTransformation f g => NaturalTransformationLaws f g where
    -- éªŒè¯è‡ªç„¶æ€§
    verify_naturality :: (a -> b) -> f a -> Bool
    verify_naturality f fa = naturality f fa
    
    -- éªŒè¯åŒæ„
    verify_isomorphism :: f a -> Bool
    verify_isomorphism fa = isomorphism fa

-- å…·ä½“å®ç°ç¤ºä¾‹
instance NaturalTransformationLaws [] [] where
    verify_naturality f fa = naturality f fa

-- Yonedaå¼•ç†çš„å®ç°
newtype Yoneda f a = Yoneda { runYoneda :: forall b. (a -> b) -> f b }

instance Functor (Yoneda f) where
    fmap f (Yoneda g) = Yoneda (\h -> g (h . f))

-- YonedaåµŒå…¥
yoneda :: Functor f => f a -> Yoneda f a
yoneda fa = Yoneda (\f -> fmap f fa)

-- YonedaæŠ•å½±
coyoneda :: Yoneda f a -> f a
coyoneda (Yoneda f) = f id
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„åº”ç”¨

è‡ªç„¶å˜æ¢åœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­å¹¿æ³›åº”ç”¨ï¼š

```rust
/// å•å­å˜æ¢çš„è‡ªç„¶å˜æ¢
pub trait MonadTrans<M, N>
where
    M: Monad<A, B>,
    N: Monad<A, B>,
{
    /// æå‡æ“ä½œ
    fn lift(&self, ma: M::M) -> N::M;
}

/// MaybeTå•å­å˜æ¢å™¨
pub struct MaybeT<M, A> {
    run_maybe_t: M::M,
}

impl<M, A, B> MonadTrans<M, MaybeT<M, B>> for MaybeT<M, A>
where
    M: Monad<A, B>,
{
    fn lift(&self, ma: M::M) -> MaybeT<M, B> {
        MaybeT {
            run_maybe_t: ma.fmap(|a| Some(a)),
        }
    }
}

/// è‡ªç„¶å˜æ¢åœ¨è§£æå™¨ä¸­çš„åº”ç”¨
pub struct ParserNaturalTransformation<F, G> {
    transform: Box<dyn Fn(F::F) -> G::F>,
}

impl<F, G, A, B> NaturalTransformation<F, G, A, B> for ParserNaturalTransformation<F, G>
where
    F: Functor<A, B>,
    G: Functor<A, B>,
{
    fn eta(&self, fa: F::F) -> G::F {
        (self.transform)(fa)
    }
}
```

### 5.2 æ•°å­¦ç»“æ„ä¸­çš„åº”ç”¨

```rust
/// ä»£æ•°ç»“æ„çš„è‡ªç„¶å˜æ¢
pub trait AlgebraicNaturalTransformation<F, G> {
    type Structure;
    
    /// ä¿æŒä»£æ•°ç»“æ„çš„è‡ªç„¶å˜æ¢
    fn algebraic_eta<A, B>(&self, fa: F::F) -> G::F
    where
        F: Functor<A, B>,
        G: Functor<A, B>;
}

/// ç¾¤åŒæ€çš„è‡ªç„¶å˜æ¢
pub struct GroupNaturalTransformation<G, H> {
    transform: Box<dyn Fn(G) -> H>,
}

impl<G, H> AlgebraicNaturalTransformation<Group<G>, Group<H>> 
for GroupNaturalTransformation<G, H> {
    type Structure = Group<H>;
    
    fn algebraic_eta<A, B>(&self, fa: Group<G>) -> Group<H> {
        Group {
            elements: fa.elements.into_iter().map(|g| (self.transform)(g)).collect(),
            operation: Box::new(|a, b| (self.transform)(fa.operation(a, b))),
            identity: (self.transform)(fa.identity),
        }
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸èŒƒç•´è®ºçš„å…³ç³»

è‡ªç„¶å˜æ¢æ˜¯å‡½å­èŒƒç•´ä¸­çš„æ€å°„ï¼š

- **å‡½å­** â†’ **å¯¹è±¡**
- **è‡ªç„¶å˜æ¢** â†’ **æ€å°„**
- **è‡ªç„¶å˜æ¢å¤åˆ** â†’ **æ€å°„å¤åˆ**
- **æ’ç­‰è‡ªç„¶å˜æ¢** â†’ **æ’ç­‰æ€å°„**

### 6.2 ä¸æé™ç†è®ºçš„å…³ç³»

è‡ªç„¶å˜æ¢åœ¨æé™ç†è®ºä¸­èµ·é‡è¦ä½œç”¨ï¼š

- **æé™** â†’ **è‡ªç„¶å˜æ¢çš„ç›®æ ‡**
- **é”¥** â†’ **è‡ªç„¶å˜æ¢**
- **æé™çš„å”¯ä¸€æ€§** â†’ **è‡ªç„¶åŒæ„**

### 6.3 ä¸ä¼´éšå‡½å­çš„å…³ç³»

è‡ªç„¶å˜æ¢æ˜¯ä¼´éšå‡½å­çš„æ ¸å¿ƒï¼š

- **å•ä½** â†’ **è‡ªç„¶å˜æ¢**
- **ä½™å•ä½** â†’ **è‡ªç„¶å˜æ¢**
- **ä¼´éšå…³ç³»** â†’ **è‡ªç„¶åŒæ„**

## 7. å‚è€ƒæ–‡çŒ®

1. Mac Lane, S. (1998). *Categories for the Working Mathematician*. Springer.
2. Awodey, S. (2010). *Category Theory*. Oxford University Press.
3. Barr, M., & Wells, C. (1990). *Category Theory for Computing Science*. Prentice Hall.
4. Pierce, B. C. (1991). *Basic Category Theory for Computer Scientists*. MIT Press.
5. Spivak, D. I. (2014). *Category Theory for the Sciences*. MIT Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.7.1 èŒƒç•´æ¦‚å¿µ](../02_Mathematical_Foundation/02.7.1_èŒƒç•´æ¦‚å¿µ.md)
- [02.7.2 å‡½å­ç†è®º](../02_Mathematical_Foundation/02.7.2_å‡½å­ç†è®º.md)
- [02.7.4 æé™ç†è®º](../02_Mathematical_Foundation/02.7.4_æé™ç†è®º.md)
- [04.1.1 ç®€å•ç±»å‹ç†è®º](../04_Type_Theory/04.1.1_ç®€å•ç±»å‹ç†è®º.md)
- [08.1.1 è¯­è¨€è®¾è®¡åŸç†](../08_Programming_Language_Theory/08.1.1_è¯­è¨€è®¾è®¡åŸç†.md)
