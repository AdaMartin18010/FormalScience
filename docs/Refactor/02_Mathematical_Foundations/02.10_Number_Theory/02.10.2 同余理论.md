# 02.10.2 åŒä½™ç†è®º

## ğŸ“‹ æ¦‚è¿°

åŒä½™ç†è®ºæ˜¯æ•°è®ºçš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶æ•´æ•°åœ¨æ¨¡è¿ç®—ä¸‹çš„æ€§è´¨ã€‚æœ¬æ–‡æ¡£å»ºç«‹ä¸¥æ ¼çš„åŒä½™ç†è®ºæ¡†æ¶ï¼ŒåŒ…å«å½¢å¼åŒ–å®šä¹‰ã€å®šç†è¯æ˜å’Œå®é™…åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ä¸¥æ ¼çš„åŒä½™æ¦‚å¿µå’Œå½¢å¼åŒ–å®šä¹‰
2. è¯æ˜åŒä½™ç†è®ºçš„åŸºæœ¬å®šç†
3. æä¾›å®Œæ•´çš„ä»£ç å®ç°
4. å±•ç¤ºåŒä½™ç†è®ºåœ¨å½¢å¼ç§‘å­¦ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

- [02.10.2 åŒä½™ç†è®º](#02102-åŒä½™ç†è®º)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒç›®æ ‡](#-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 åŒä½™å…³ç³»](#11-åŒä½™å…³ç³»)
    - [1.2 åŒä½™ç±»](#12-åŒä½™ç±»)
    - [1.3 å®Œå…¨å‰©ä½™ç³»](#13-å®Œå…¨å‰©ä½™ç³»)
  - [2. å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
    - [2.1 åŒä½™çš„å…¬ç†åŒ–å®šä¹‰](#21-åŒä½™çš„å…¬ç†åŒ–å®šä¹‰)
    - [2.2 åŒä½™è¿ç®—](#22-åŒä½™è¿ç®—)
    - [2.3 æ¬§æ‹‰å‡½æ•°](#23-æ¬§æ‹‰å‡½æ•°)
  - [3. å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
    - [3.1 åŒä½™çš„åŸºæœ¬æ€§è´¨](#31-åŒä½™çš„åŸºæœ¬æ€§è´¨)
    - [3.2 è´¹é©¬å°å®šç†](#32-è´¹é©¬å°å®šç†)
    - [3.3 æ¬§æ‹‰å®šç†](#33-æ¬§æ‹‰å®šç†)
    - [3.4 ä¸­å›½å‰©ä½™å®šç†](#34-ä¸­å›½å‰©ä½™å®šç†)
  - [4. ä»£ç å®ç°](#4-ä»£ç å®ç°)
    - [4.1 Rust å®ç°](#41-rust-å®ç°)
    - [4.2 Haskell å®ç°](#42-haskell-å®ç°)
  - [5. åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
    - [5.1 å¯†ç å­¦ä¸­çš„åº”ç”¨](#51-å¯†ç å­¦ä¸­çš„åº”ç”¨)
    - [5.2 ç®—æ³•ä¼˜åŒ–ä¸­çš„åº”ç”¨](#52-ç®—æ³•ä¼˜åŒ–ä¸­çš„åº”ç”¨)
  - [6. ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
    - [6.1 ä¸æ•´é™¤ç†è®ºçš„å…³ç³»](#61-ä¸æ•´é™¤ç†è®ºçš„å…³ç³»)
    - [6.2 ä¸ç¾¤è®ºçš„å…³ç³»](#62-ä¸ç¾¤è®ºçš„å…³ç³»)
    - [6.3 ä¸ç¯è®ºçš„å…³ç³»](#63-ä¸ç¯è®ºçš„å…³ç³»)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 åŒä½™å…³ç³»

**å®šä¹‰ 1.1.1** (åŒä½™)
è®¾ $a, b, m \in \mathbb{Z}$ï¼Œ$m \neq 0$ï¼Œå¦‚æœ $m \mid (a - b)$ï¼Œåˆ™ç§° $a$ ä¸ $b$ æ¨¡ $m$ åŒä½™ï¼Œè®°ä½œï¼š
$$a \equiv b \pmod{m}$$

### 1.2 åŒä½™ç±»

**å®šä¹‰ 1.2.1** (åŒä½™ç±»)
è®¾ $m \in \mathbb{Z}$ï¼Œ$m > 0$ï¼Œå¯¹ä»»æ„ $a \in \mathbb{Z}$ï¼Œå®šä¹‰ $a$ çš„åŒä½™ç±»ä¸ºï¼š
$$[a]_m = \{b \in \mathbb{Z} : b \equiv a \pmod{m}\}$$

### 1.3 å®Œå…¨å‰©ä½™ç³»

**å®šä¹‰ 1.3.1** (å®Œå…¨å‰©ä½™ç³»)
æ¨¡ $m$ çš„å®Œå…¨å‰©ä½™ç³»æ˜¯ $m$ ä¸ªæ•´æ•° $r_0, r_1, \ldots, r_{m-1}$ï¼Œä½¿å¾—å¯¹ä»»æ„æ•´æ•° $a$ï¼Œå­˜åœ¨å”¯ä¸€çš„ $i$ ä½¿å¾— $a \equiv r_i \pmod{m}$ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 åŒä½™çš„å…¬ç†åŒ–å®šä¹‰

**å®šä¹‰ 2.1.1** (åŒä½™å…³ç³»)
åŒä½™å…³ç³» $\equiv_m$ æ˜¯ $\mathbb{Z} \times \mathbb{Z}$ ä¸Šçš„ç­‰ä»·å…³ç³»ï¼Œæ»¡è¶³ï¼š

1. è‡ªåæ€§ï¼š$a \equiv_m a$
2. å¯¹ç§°æ€§ï¼šå¦‚æœ $a \equiv_m b$ï¼Œåˆ™ $b \equiv_m a$
3. ä¼ é€’æ€§ï¼šå¦‚æœ $a \equiv_m b$ ä¸” $b \equiv_m c$ï¼Œåˆ™ $a \equiv_m c$

### 2.2 åŒä½™è¿ç®—

**å®šä¹‰ 2.2.1** (åŒä½™åŠ æ³•)
$$[a]_m + [b]_m = [a + b]_m$$

**å®šä¹‰ 2.2.2** (åŒä½™ä¹˜æ³•)
$$[a]_m \cdot [b]_m = [a \cdot b]_m$$

### 2.3 æ¬§æ‹‰å‡½æ•°

**å®šä¹‰ 2.3.1** (æ¬§æ‹‰å‡½æ•°)
æ¬§æ‹‰å‡½æ•° $\phi(n)$ å®šä¹‰ä¸ºå°äº $n$ ä¸”ä¸ $n$ äº’ç´ çš„æ­£æ•´æ•°çš„ä¸ªæ•°ï¼š
$$\phi(n) = |\{k \in \mathbb{N} : 1 \leq k < n, \gcd(k, n) = 1\}|$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŒä½™çš„åŸºæœ¬æ€§è´¨

**å®šç† 3.1.1** (åŒä½™è¿ç®—æ€§è´¨)
è®¾ $a \equiv b \pmod{m}$ï¼Œ$c \equiv d \pmod{m}$ï¼Œåˆ™ï¼š

1. $a + c \equiv b + d \pmod{m}$
2. $a - c \equiv b - d \pmod{m}$
3. $ac \equiv bd \pmod{m}$
4. $a^n \equiv b^n \pmod{m}$ å¯¹æ‰€æœ‰ $n \in \mathbb{N}$ æˆç«‹

**è¯æ˜**ï¼š

1. ç”±äº $m \mid (a - b)$ å’Œ $m \mid (c - d)$ï¼Œæ‰€ä»¥ï¼š
   $$m \mid ((a - b) + (c - d)) = (a + c) - (b + d)$$
   å› æ­¤ $a + c \equiv b + d \pmod{m}$ã€‚

2. ç±»ä¼¼åœ°ï¼Œ$m \mid ((a - b) - (c - d)) = (a - c) - (b - d)$ã€‚

3. ç”±äº $a = b + km$ï¼Œ$c = d + lm$ï¼Œæ‰€ä»¥ï¼š
   $$ac = (b + km)(d + lm) = bd + b(lm) + d(km) + k(lm^2)$$
   å› æ­¤ $m \mid (ac - bd)$ã€‚

4. é€šè¿‡æ•°å­¦å½’çº³æ³•è¯æ˜ã€‚

### 3.2 è´¹é©¬å°å®šç†

**å®šç† 3.2.1** (è´¹é©¬å°å®šç†)
è®¾ $p$ æ˜¯ç´ æ•°ï¼Œ$a$ æ˜¯æ•´æ•°ä¸” $p \nmid a$ï¼Œåˆ™ï¼š
$$a^{p-1} \equiv 1 \pmod{p}$$

**è¯æ˜**ï¼š
è€ƒè™‘é›†åˆ $S = \{a, 2a, 3a, \ldots, (p-1)a\}$ã€‚

é¦–å…ˆè¯æ˜ $S$ ä¸­çš„å…ƒç´ æ¨¡ $p$ äº’ä¸ç›¸åŒï¼š
å‡è®¾å­˜åœ¨ $1 \leq i < j < p$ ä½¿å¾— $ia \equiv ja \pmod{p}$ï¼Œåˆ™ $p \mid (j-i)a$ã€‚
ç”±äº $p \nmid a$ï¼Œæ‰€ä»¥ $p \mid (j-i)$ï¼Œè¿™ä¸ $1 \leq j-i < p$ çŸ›ç›¾ã€‚

å› æ­¤ $S$ æ¨¡ $p$ çš„ä½™æ•°æ°å¥½æ˜¯ $1, 2, \ldots, p-1$ çš„ä¸€ä¸ªæ’åˆ—ã€‚

æ‰€ä»¥ï¼š
$$a \cdot 2a \cdot 3a \cdots (p-1)a \equiv 1 \cdot 2 \cdot 3 \cdots (p-1) \pmod{p}$$

å³ï¼š
$$a^{p-1} \cdot (p-1)! \equiv (p-1)! \pmod{p}$$

ç”±äº $(p-1)!$ ä¸ $p$ äº’ç´ ï¼Œæ‰€ä»¥ $a^{p-1} \equiv 1 \pmod{p}$ã€‚

### 3.3 æ¬§æ‹‰å®šç†

**å®šç† 3.3.1** (æ¬§æ‹‰å®šç†)
è®¾ $a, n \in \mathbb{Z}$ï¼Œ$\gcd(a, n) = 1$ï¼Œåˆ™ï¼š
$$a^{\phi(n)} \equiv 1 \pmod{n}$$

**è¯æ˜**ï¼š
è®¾ $r_1, r_2, \ldots, r_{\phi(n)}$ æ˜¯æ¨¡ $n$ çš„ç®€åŒ–å‰©ä½™ç³»ã€‚

ç”±äº $\gcd(a, n) = 1$ï¼Œæ‰€ä»¥ $ar_1, ar_2, \ldots, ar_{\phi(n)}$ ä¹Ÿæ˜¯æ¨¡ $n$ çš„ç®€åŒ–å‰©ä½™ç³»ã€‚

å› æ­¤ï¼š
$$ar_1 \cdot ar_2 \cdots ar_{\phi(n)} \equiv r_1 \cdot r_2 \cdots r_{\phi(n)} \pmod{n}$$

å³ï¼š
$$a^{\phi(n)} \cdot (r_1 \cdot r_2 \cdots r_{\phi(n)}) \equiv r_1 \cdot r_2 \cdots r_{\phi(n)} \pmod{n}$$

ç”±äº $r_1 \cdot r_2 \cdots r_{\phi(n)}$ ä¸ $n$ äº’ç´ ï¼Œæ‰€ä»¥ $a^{\phi(n)} \equiv 1 \pmod{n}$ã€‚

### 3.4 ä¸­å›½å‰©ä½™å®šç†

**å®šç† 3.4.1** (ä¸­å›½å‰©ä½™å®šç†)
è®¾ $m_1, m_2, \ldots, m_k$ æ˜¯ä¸¤ä¸¤äº’ç´ çš„æ­£æ•´æ•°ï¼Œ$a_1, a_2, \ldots, a_k$ æ˜¯ä»»æ„æ•´æ•°ï¼Œåˆ™åŒä½™æ–¹ç¨‹ç»„ï¼š

$$
\begin{cases}
x \equiv a_1 \pmod{m_1} \\
x \equiv a_2 \pmod{m_2} \\
\vdots \\
x \equiv a_k \pmod{m_k}
\end{cases}
$$

æœ‰å”¯ä¸€è§£æ¨¡ $M = m_1m_2 \cdots m_k$ã€‚

**è¯æ˜**ï¼š
è®¾ $M_i = M/m_i$ï¼Œç”±äº $m_1, m_2, \ldots, m_k$ ä¸¤ä¸¤äº’ç´ ï¼Œæ‰€ä»¥ $\gcd(M_i, m_i) = 1$ã€‚

å› æ­¤å­˜åœ¨ $y_i$ ä½¿å¾— $M_i y_i \equiv 1 \pmod{m_i}$ã€‚

ä»¤ $x = a_1M_1y_1 + a_2M_2y_2 + \cdots + a_kM_ky_k$ã€‚

å¯¹ä»»æ„ $i$ï¼Œå½“ $j \neq i$ æ—¶ï¼Œ$m_i \mid M_j$ï¼Œæ‰€ä»¥ï¼š
$$x \equiv a_iM_iy_i \equiv a_i \pmod{m_i}$$

å› æ­¤ $x$ æ˜¯æ–¹ç¨‹ç»„çš„è§£ã€‚

å”¯ä¸€æ€§ï¼šå¦‚æœ $x'$ ä¹Ÿæ˜¯è§£ï¼Œåˆ™ $x \equiv x' \pmod{m_i}$ å¯¹æ‰€æœ‰ $i$ æˆç«‹ã€‚
ç”±äº $m_1, m_2, \ldots, m_k$ ä¸¤ä¸¤äº’ç´ ï¼Œæ‰€ä»¥ $x \equiv x' \pmod{M}$ã€‚

## 4. ä»£ç å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::HashMap;

/// åŒä½™ç†è®ºå®ç°
pub struct CongruenceTheory;

impl CongruenceTheory {
    /// æ£€æŸ¥åŒä½™å…³ç³»
    pub fn is_congruent(a: i64, b: i64, m: i64) -> bool {
        if m == 0 {
            return false;
        }
        (a - b) % m == 0
    }

    /// è®¡ç®—æ¨¡è¿ç®—
    pub fn mod_positive(a: i64, m: i64) -> i64 {
        if m <= 0 {
            panic!("æ¨¡æ•°å¿…é¡»ä¸ºæ­£æ•°");
        }
        let remainder = a % m;
        if remainder < 0 {
            remainder + m
        } else {
            remainder
        }
    }

    /// è®¡ç®—æ¨¡é€†å…ƒ
    pub fn mod_inverse(a: i64, m: i64) -> Option<i64> {
        let (gcd, x, _) = DivisibilityTheory::extended_gcd(a, m);
        if gcd != 1 {
            None
        } else {
            Some(Self::mod_positive(x, m))
        }
    }

    /// å¿«é€Ÿå¹‚æ¨¡è¿ç®—
    pub fn mod_pow(mut base: i64, mut exponent: u64, modulus: i64) -> i64 {
        if modulus == 1 {
            return 0;
        }

        let mut result = 1;
        base = Self::mod_positive(base, modulus);

        while exponent > 0 {
            if exponent % 2 == 1 {
                result = (result * base) % modulus;
            }
            base = (base * base) % modulus;
            exponent /= 2;
        }

        result
    }

    /// è´¹é©¬å°å®šç†
    pub fn fermat_little_theorem(a: i64, p: i64) -> bool {
        if !Self::is_prime(p) {
            return false;
        }
        if a % p == 0 {
            return true;
        }
        Self::mod_pow(a, (p - 1) as u64, p) == 1
    }

    /// æ¬§æ‹‰å‡½æ•°
    pub fn euler_totient(n: i64) -> i64 {
        if n <= 0 {
            return 0;
        }

        let prime_factors = DivisibilityTheory::prime_factorization(n);
        prime_factors.iter().fold(n, |acc, (&prime, &exp)| {
            acc * (prime - 1) / prime
        })
    }

    /// æ¬§æ‹‰å®šç†
    pub fn euler_theorem(a: i64, n: i64) -> bool {
        if DivisibilityTheory::gcd(a, n) != 1 {
            return false;
        }
        Self::mod_pow(a, Self::euler_totient(n) as u64, n) == 1
    }

    /// ä¸­å›½å‰©ä½™å®šç†
    pub fn chinese_remainder_theorem(remainders: &[i64], moduli: &[i64]) -> Option<i64> {
        if remainders.len() != moduli.len() {
            return None;
        }

        let mut result = 0;
        let mut product = 1;

        for &m in moduli {
            product *= m;
        }

        for i in 0..remainders.len() {
            let mi = product / moduli[i];
            let inv = Self::mod_inverse(mi, moduli[i])?;
            result = (result + remainders[i] * mi * inv) % product;
        }

        Some(result)
    }

    /// ç”Ÿæˆå®Œå…¨å‰©ä½™ç³»
    pub fn complete_residue_system(m: i64) -> Vec<i64> {
        (0..m).collect()
    }

    /// ç”Ÿæˆç®€åŒ–å‰©ä½™ç³»
    pub fn reduced_residue_system(m: i64) -> Vec<i64> {
        (1..m).filter(|&k| DivisibilityTheory::gcd(k, m) == 1).collect()
    }

    /// äºŒæ¬¡å‰©ä½™
    pub fn quadratic_residue(a: i64, p: i64) -> bool {
        if !Self::is_prime(p) || p == 2 {
            return true;
        }
        Self::mod_pow(a, ((p - 1) / 2) as u64, p) == 1
    }

    /// å‹’è®©å¾·ç¬¦å·
    pub fn legendre_symbol(a: i64, p: i64) -> i32 {
        if !Self::is_prime(p) || p == 2 {
            return 0;
        }
        if a % p == 0 {
            return 0;
        }
        if Self::quadratic_residue(a, p) {
            1
        } else {
            -1
        }
    }

    /// ç´ æ•°æ£€æµ‹ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
    fn is_prime(n: i64) -> bool {
        if n < 2 {
            return false;
        }
        if n == 2 {
            return true;
        }
        if n % 2 == 0 {
            return false;
        }

        for i in (3..=(n as f64).sqrt() as i64).step_by(2) {
            if n % i == 0 {
                return false;
            }
        }
        true
    }
}

/// åŒä½™ç±»
# [derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CongruenceClass {
    pub representative: i64,
    pub modulus: i64,
}

impl CongruenceClass {
    pub fn new(representative: i64, modulus: i64) -> Self {
        Self {
            representative: CongruenceTheory::mod_positive(representative, modulus),
            modulus,
        }
    }

    pub fn add(&self, other: &CongruenceClass) -> Option<CongruenceClass> {
        if self.modulus != other.modulus {
            return None;
        }
        Some(CongruenceClass::new(
            self.representative + other.representative,
            self.modulus,
        ))
    }

    pub fn multiply(&self, other: &CongruenceClass) -> Option<CongruenceClass> {
        if self.modulus != other.modulus {
            return None;
        }
        Some(CongruenceClass::new(
            self.representative * other.representative,
            self.modulus,
        ))
    }

    pub fn inverse(&self) -> Option<CongruenceClass> {
        CongruenceTheory::mod_inverse(self.representative, self.modulus)
            .map(|inv| CongruenceClass::new(inv, self.modulus))
    }

    pub fn power(&self, exponent: u64) -> CongruenceClass {
        CongruenceClass::new(
            CongruenceTheory::mod_pow(self.representative, exponent, self.modulus),
            self.modulus,
        )
    }
}

/// åŒä½™æ–¹ç¨‹æ±‚è§£å™¨
pub struct CongruenceEquationSolver;

impl CongruenceEquationSolver {
    /// æ±‚è§£çº¿æ€§åŒä½™æ–¹ç¨‹ ax â‰¡ b (mod m)
    pub fn solve_linear_congruence(a: i64, b: i64, m: i64) -> Option<Vec<i64>> {
        let (gcd, x, _) = DivisibilityTheory::extended_gcd(a, m);

        if b % gcd != 0 {
            None
        } else {
            let x0 = (x * (b / gcd)) % m;
            let solutions: Vec<i64> = (0..gcd).map(|k| {
                CongruenceTheory::mod_positive(x0 + k * (m / gcd), m)
            }).collect();
            Some(solutions)
        }
    }

    /// æ±‚è§£äºŒæ¬¡åŒä½™æ–¹ç¨‹ xÂ² â‰¡ a (mod p)
    pub fn solve_quadratic_congruence(a: i64, p: i64) -> Option<Vec<i64>> {
        if !CongruenceTheory::is_prime(p) {
            return None;
        }

        if a % p == 0 {
            return Some(vec![0]);
        }

        if !CongruenceTheory::quadratic_residue(a, p) {
            return None;
        }

        if p % 4 == 3 {
            // ç®€å•æƒ…å†µï¼šp â‰¡ 3 (mod 4)
            let x = CongruenceTheory::mod_pow(a, ((p + 1) / 4) as u64, p);
            Some(vec![x, p - x])
        } else {
            // ä¸€èˆ¬æƒ…å†µï¼šä½¿ç”¨Tonelli-Shanksç®—æ³•
            Self::tonelli_shanks(a, p)
        }
    }

    /// Tonelli-Shanksç®—æ³•
    fn tonelli_shanks(a: i64, p: i64) -> Option<Vec<i64>> {
        // å¯»æ‰¾äºŒæ¬¡éå‰©ä½™
        let mut q = 2;
        while CongruenceTheory::quadratic_residue(q, p) {
            q += 1;
        }

        let mut s = 0;
        let mut t = p - 1;
        while t % 2 == 0 {
            s += 1;
            t /= 2;
        }

        let mut m = s;
        let mut c = CongruenceTheory::mod_pow(q, t as u64, p);
        let mut r = CongruenceTheory::mod_pow(a, ((t + 1) / 2) as u64, p);
        let mut t_val = CongruenceTheory::mod_pow(a, t as u64, p);

        while t_val != 1 {
            let mut i = 0;
            let mut temp = t_val;
            while temp != 1 && i < m {
                temp = (temp * temp) % p;
                i += 1;
            }

            if i == 0 {
                return None;
            }

            let b = CongruenceTheory::mod_pow(c, (1 << (m - i - 1)) as u64, p);
            m = i;
            c = (b * b) % p;
            r = (r * b) % p;
            t_val = (t_val * c) % p;
        }

        Some(vec![r, p - r])
    }
}

/// ç¦»æ•£å¯¹æ•°
pub struct DiscreteLogarithm;

impl DiscreteLogarithm {
    /// è®¡ç®—ç¦»æ•£å¯¹æ•° g^x â‰¡ h (mod p)
    pub fn discrete_log(g: i64, h: i64, p: i64) -> Option<i64> {
        if !CongruenceTheory::is_prime(p) {
            return None;
        }

        // Baby-step Giant-stepç®—æ³•
        let m = (p as f64).sqrt().ceil() as i64;
        let mut baby_steps = HashMap::new();

        // Baby steps
        let mut current = 1;
        for j in 0..m {
            baby_steps.insert(current, j);
            current = (current * g) % p;
        }

        // Giant steps
        let factor = CongruenceTheory::mod_pow(g, (m * (p - 2)) as u64, p);
        current = h;

        for i in 0..m {
            if let Some(&j) = baby_steps.get(&current) {
                return Some(i * m + j);
            }
            current = (current * factor) % p;
        }

        None
    }
}

# [cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_congruence() {
        assert!(CongruenceTheory::is_congruent(17, 5, 12));
        assert!(!CongruenceTheory::is_congruent(17, 6, 12));
    }

    #[test]
    fn test_mod_inverse() {
        assert_eq!(CongruenceTheory::mod_inverse(3, 7), Some(5));
        assert_eq!(CongruenceTheory::mod_inverse(2, 4), None);
    }

    #[test]
    fn test_mod_pow() {
        assert_eq!(CongruenceTheory::mod_pow(2, 10, 7), 2);
        assert_eq!(CongruenceTheory::mod_pow(3, 4, 5), 1);
    }

    #[test]
    fn test_fermat_little_theorem() {
        assert!(CongruenceTheory::fermat_little_theorem(2, 7));
        assert!(CongruenceTheory::fermat_little_theorem(3, 5));
    }

    #[test]
    fn test_euler_totient() {
        assert_eq!(CongruenceTheory::euler_totient(12), 4);
        assert_eq!(CongruenceTheory::euler_totient(7), 6);
    }

    #[test]
    fn test_chinese_remainder_theorem() {
        let remainders = vec![2, 3, 2];
        let moduli = vec![3, 5, 7];
        let result = CongruenceTheory::chinese_remainder_theorem(&remainders, &moduli);
        assert_eq!(result, Some(23));
    }

    #[test]
    fn test_congruence_class() {
        let a = CongruenceClass::new(5, 7);
        let b = CongruenceClass::new(3, 7);
        let sum = a.add(&b).unwrap();
        assert_eq!(sum.representative, 1);
    }

    #[test]
    fn test_linear_congruence() {
        let solutions = CongruenceEquationSolver::solve_linear_congruence(3, 2, 7);
        assert_eq!(solutions, Some(vec![3]));
    }
}
```

### 4.2 Haskell å®ç°

```haskell
-- åŒä½™ç†è®º
module CongruenceTheory where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Maybe

-- æ£€æŸ¥åŒä½™å…³ç³»
isCongruent :: Integer -> Integer -> Integer -> Bool
isCongruent a b m = m /= 0 && (a - b) `mod` m == 0

-- æ­£æ¨¡è¿ç®—
modPositive :: Integer -> Integer -> Integer
modPositive a m
  | m <= 0 = error "æ¨¡æ•°å¿…é¡»ä¸ºæ­£æ•°"
  | otherwise = let r = a `mod` m in if r < 0 then r + m else r

-- æ¨¡é€†å…ƒ
modInverse :: Integer -> Integer -> Maybe Integer
modInverse a m =
  let (gcd, x, _) = extendedGcd a m
  in if gcd == 1 then Just (modPositive x m) else Nothing

-- æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•
extendedGcd :: Integer -> Integer -> (Integer, Integer, Integer)
extendedGcd a 0 = (a, 1, 0)
extendedGcd a b = (g, y, x - (a `div` b) * y)
  where
    (g, x, y) = extendedGcd b (a `mod` b)

-- å¿«é€Ÿå¹‚æ¨¡è¿ç®—
modPow :: Integer -> Integer -> Integer -> Integer
modPow base exponent modulus
  | modulus == 1 = 0
  | otherwise = go base exponent 1
  where
    go _ 0 result = result
    go b e result
      | odd e = go (b * b `mod` modulus) (e `div` 2) (result * b `mod` modulus)
      | otherwise = go (b * b `mod` modulus) (e `div` 2) result

-- è´¹é©¬å°å®šç†
fermatLittleTheorem :: Integer -> Integer -> Bool
fermatLittleTheorem a p
  | not (isPrime p) = False
  | a `mod` p == 0 = True
  | otherwise = modPow a (p - 1) p == 1

-- ç´ æ•°æ£€æµ‹
isPrime :: Integer -> Bool
isPrime n
  | n < 2 = False
  | n == 2 = True
  | even n = False
  | otherwise = all (\i -> n `mod` i /= 0) [3, 5..sqrt' n]
  where
    sqrt' = floor . sqrt . fromIntegral

-- æ¬§æ‹‰å‡½æ•°
eulerTotient :: Integer -> Integer
eulerTotient n
  | n <= 0 = 0
  | otherwise = product [n * (p - 1) `div` p | (p, _) <- primeFactorization n]

-- ç´ å› å­åˆ†è§£
primeFactorization :: Integer -> [(Integer, Integer)]
primeFactorization n = go n 2 []
  where
    go 1 _ factors = factors
    go n p factors
      | p * p > n = (n, 1) : factors
      | n `mod` p == 0 = go (n `div` p) p (updateCount p factors)
      | otherwise = go n (p + 1) factors

    updateCount p [] = [(p, 1)]
    updateCount p ((q, count) : rest)
      | p == q = (q, count + 1) : rest
      | otherwise = (q, count) : updateCount p rest

-- æ¬§æ‹‰å®šç†
eulerTheorem :: Integer -> Integer -> Bool
eulerTheorem a n = gcd a n == 1 && modPow a (eulerTotient n) n == 1

-- ä¸­å›½å‰©ä½™å®šç†
chineseRemainderTheorem :: [Integer] -> [Integer] -> Maybe Integer
chineseRemainderTheorem remainders moduli
  | length remainders /= length moduli = Nothing
  | otherwise = Just result
  where
    product = product moduli
    result = sum [remainder * mi * inv |
                  (remainder, modulus) <- zip remainders moduli,
                  let mi = product `div` modulus,
                  let inv = fromJust (modInverse mi modulus)]
    result = result `mod` product

-- å®Œå…¨å‰©ä½™ç³»
completeResidueSystem :: Integer -> [Integer]
completeResidueSystem m = [0..m-1]

-- ç®€åŒ–å‰©ä½™ç³»
reducedResidueSystem :: Integer -> [Integer]
reducedResidueSystem m = [k | k <- [1..m-1], gcd k m == 1]

-- äºŒæ¬¡å‰©ä½™
quadraticResidue :: Integer -> Integer -> Bool
quadraticResidue a p
  | not (isPrime p) || p == 2 = True
  | otherwise = modPow a ((p - 1) `div` 2) p == 1

-- å‹’è®©å¾·ç¬¦å·
legendreSymbol :: Integer -> Integer -> Integer
legendreSymbol a p
  | not (isPrime p) || p == 2 = 0
  | a `mod` p == 0 = 0
  | quadraticResidue a p = 1
  | otherwise = -1

-- åŒä½™ç±»
data CongruenceClass = CongruenceClass {
    representative :: Integer,
    modulus :: Integer
} deriving (Eq, Show)

instance Num CongruenceClass where
    (CongruenceClass a m) + (CongruenceClass b n)
      | m /= n = error "ä¸åŒæ¨¡æ•°çš„åŒä½™ç±»ä¸èƒ½ç›¸åŠ "
      | otherwise = CongruenceClass (modPositive (a + b) m) m

    (CongruenceClass a m) * (CongruenceClass b n)
      | m /= n = error "ä¸åŒæ¨¡æ•°çš„åŒä½™ç±»ä¸èƒ½ç›¸ä¹˜"
      | otherwise = CongruenceClass (modPositive (a * b) m) m

    negate (CongruenceClass a m) = CongruenceClass (modPositive (-a) m) m
    abs = id
    signum _ = CongruenceClass 1 1
    fromInteger n = CongruenceClass n 1

-- åŒä½™æ–¹ç¨‹æ±‚è§£
solveLinearCongruence :: Integer -> Integer -> Integer -> Maybe [Integer]
solveLinearCongruence a b m =
  let (gcd, x, _) = extendedGcd a m
  in if b `mod` gcd /= 0
     then Nothing
     else Just [modPositive (x * (b `div` gcd) + k * (m `div` gcd)) m | k <- [0..gcd-1]]

-- æµ‹è¯•å‡½æ•°
testCongruence :: IO ()
testCongruence = do
    putStrLn "åŒä½™ç†è®ºæµ‹è¯•:"

    -- æµ‹è¯•åŒä½™å…³ç³»
    print $ isCongruent 17 5 12
    print $ isCongruent 17 6 12

    -- æµ‹è¯•æ¨¡é€†å…ƒ
    print $ modInverse 3 7
    print $ modInverse 2 4

    -- æµ‹è¯•è´¹é©¬å°å®šç†
    print $ fermatLittleTheorem 2 7
    print $ fermatLittleTheorem 3 5

    -- æµ‹è¯•æ¬§æ‹‰å‡½æ•°
    print $ eulerTotient 12
    print $ eulerTotient 7

    -- æµ‹è¯•ä¸­å›½å‰©ä½™å®šç†
    let remainders = [2, 3, 2]
    let moduli = [3, 5, 7]
    print $ chineseRemainderTheorem remainders moduli
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å¯†ç å­¦ä¸­çš„åº”ç”¨

```rust
/// RSAåŠ å¯†ç³»ç»Ÿ
pub struct RSACryptosystem {
    public_key: (i64, i64),
    private_key: (i64, i64),
}

impl RSACryptosystem {
    /// ç”ŸæˆRSAå¯†é’¥å¯¹
    pub fn generate_key_pair(bit_length: usize) -> Self {
        let p = Self::generate_prime(bit_length / 2);
        let q = Self::generate_prime(bit_length / 2);

        let n = p * q;
        let phi_n = (p - 1) * (q - 1);

        let e = 65537; // å¸¸ç”¨çš„å…¬é’¥æŒ‡æ•°
        let d = CongruenceTheory::mod_inverse(e, phi_n).unwrap();

        Self {
            public_key: (n, e),
            private_key: (n, d),
        }
    }

    /// åŠ å¯†
    pub fn encrypt(&self, message: i64) -> i64 {
        CongruenceTheory::mod_pow(message, self.public_key.1 as u64, self.public_key.0)
    }

    /// è§£å¯†
    pub fn decrypt(&self, ciphertext: i64) -> i64 {
        CongruenceTheory::mod_pow(ciphertext, self.private_key.1 as u64, self.private_key.0)
    }

    /// æ•°å­—ç­¾å
    pub fn sign(&self, message: i64) -> i64 {
        CongruenceTheory::mod_pow(message, self.private_key.1 as u64, self.private_key.0)
    }

    /// éªŒè¯ç­¾å
    pub fn verify(&self, message: i64, signature: i64) -> bool {
        let decrypted = CongruenceTheory::mod_pow(signature, self.public_key.1 as u64, self.public_key.0);
        decrypted == message
    }

    fn generate_prime(bit_length: usize) -> i64 {
        // å®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨æ›´å®‰å…¨çš„ç´ æ•°ç”Ÿæˆç®—æ³•
        let mut candidate = (1 << (bit_length - 1)) + 1;
        while !CongruenceTheory::is_prime(candidate) {
            candidate += 2;
        }
        candidate
    }
}

/// æ¤­åœ†æ›²çº¿å¯†ç å­¦
pub struct EllipticCurveCrypto {
    pub p: i64,
    pub a: i64,
    pub b: i64,
    pub g: (i64, i64),
    pub n: i64,
}

impl EllipticCurveCrypto {
    pub fn new(p: i64, a: i64, b: i64, g: (i64, i64), n: i64) -> Self {
        Self { p, a, b, g, n }
    }

    /// æ¤­åœ†æ›²çº¿ç‚¹åŠ æ³•
    pub fn point_add(&self, p1: (i64, i64), p2: (i64, i64)) -> (i64, i64) {
        if p1 == (0, 0) {
            return p2;
        }
        if p2 == (0, 0) {
            return p1;
        }

        let (x1, y1) = p1;
        let (x2, y2) = p2;

        if x1 == x2 && y1 != y2 {
            return (0, 0); // æ— ç©·è¿œç‚¹
        }

        let lambda = if x1 == x2 {
            // åˆ‡çº¿
            let numerator = (3 * x1 * x1 + self.a) % self.p;
            let denominator = (2 * y1) % self.p;
            let inv = CongruenceTheory::mod_inverse(denominator, self.p).unwrap();
            (numerator * inv) % self.p
        } else {
            // å‰²çº¿
            let numerator = (y2 - y1) % self.p;
            let denominator = (x2 - x1) % self.p;
            let inv = CongruenceTheory::mod_inverse(denominator, self.p).unwrap();
            (numerator * inv) % self.p
        };

        let x3 = (lambda * lambda - x1 - x2) % self.p;
        let y3 = (lambda * (x1 - x3) - y1) % self.p;

        (CongruenceTheory::mod_positive(x3, self.p),
         CongruenceTheory::mod_positive(y3, self.p))
    }

    /// æ¤­åœ†æ›²çº¿æ ‡é‡ä¹˜æ³•
    pub fn scalar_multiply(&self, k: i64, point: (i64, i64)) -> (i64, i64) {
        let mut result = (0, 0);
        let mut current = point;
        let mut k_val = k;

        while k_val > 0 {
            if k_val % 2 == 1 {
                result = self.point_add(result, current);
            }
            current = self.point_add(current, current);
            k_val /= 2;
        }

        result
    }
}
```

### 5.2 ç®—æ³•ä¼˜åŒ–ä¸­çš„åº”ç”¨

```rust
/// æ¨¡è¿ç®—ä¼˜åŒ–
pub struct ModularArithmeticOptimizer;

impl ModularArithmeticOptimizer {
    /// è’™å“¥é©¬åˆ©ä¹˜æ³•
    pub fn montgomery_multiply(a: i64, b: i64, m: i64, r: i64) -> i64 {
        let t = a * b;
        let m_prime = Self::mod_inverse_negative(m, r);
        let u = (t + ((t * m_prime) % r) * m) / r;

        if u >= m {
            u - m
        } else {
            u
        }
    }

    /// è´Ÿæ¨¡é€†å…ƒ
    fn mod_inverse_negative(a: i64, m: i64) -> i64 {
        let (_, x, _) = DivisibilityTheory::extended_gcd(a, m);
        if x < 0 {
            x + m
        } else {
            x
        }
    }

    /// Barrettçº¦ç®€
    pub fn barrett_reduction(x: i64, m: i64, mu: i64) -> i64 {
        let q1 = x >> 64;
        let q2 = q1 * mu;
        let q3 = q2 >> 64;
        let r1 = x & ((1 << 64) - 1);
        let r2 = (q3 * m) & ((1 << 64) - 1);
        let mut r = r1 - r2;

        if r < 0 {
            r += 1 << 64;
        }

        while r >= m {
            r -= m;
        }

        r
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸æ•´é™¤ç†è®ºçš„å…³ç³»

åŒä½™ç†è®ºæ˜¯æ•´é™¤ç†è®ºçš„æ‰©å±•ï¼Œé€šè¿‡æ¨¡è¿ç®—ç ”ç©¶æ•´æ•°çš„æ€§è´¨ã€‚

### 6.2 ä¸ç¾¤è®ºçš„å…³ç³»

**å®šç† 6.2.1** (åŒä½™ç±»ç¾¤)
æ¨¡ $m$ çš„åŒä½™ç±»åœ¨åŠ æ³•ä¸‹æ„æˆä¸€ä¸ªç¾¤ï¼Œç§°ä¸º $\mathbb{Z}/m\mathbb{Z}$ã€‚

### 6.3 ä¸ç¯è®ºçš„å…³ç³»

**å®šç† 6.3.1** (åŒä½™ç±»ç¯)
æ¨¡ $m$ çš„åŒä½™ç±»åœ¨åŠ æ³•å’Œä¹˜æ³•ä¸‹æ„æˆä¸€ä¸ªç¯ï¼Œç§°ä¸º $\mathbb{Z}/m\mathbb{Z}$ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. **Hardy, G. H., & Wright, E. M.** (2008). *An Introduction to the Theory of Numbers*. Oxford University Press.
2. **Ireland, K., & Rosen, M.** (1990). *A Classical Introduction to Modern Number Theory*. Springer.
3. **Niven, I., Zuckerman, H. S., & Montgomery, H. L.** (1991). *An Introduction to the Theory of Numbers*. Wiley.
4. **Rosen, K. H.** (2011). *Elementary Number Theory and Its Applications*. Pearson.
5. **Davenport, H.** (2008). *The Higher Arithmetic: An Introduction to the Theory of Numbers*. Cambridge University Press.

---

**ç›¸å…³æ–‡æ¡£**:

- [02.10.1 æ•´é™¤ç†è®º](../02.10.1_æ•´é™¤ç†è®º.md)
- [02.10.3 ç´ æ•°ç†è®º](../02.10.3_ç´ æ•°ç†è®º.md)
- [02.10.4 äºŒæ¬¡å‰©ä½™](../02.10.4_äºŒæ¬¡å‰©ä½™.md)
- [02.3.1 è‡ªç„¶æ•°ç³»ç»Ÿ](../02.3.1_è‡ªç„¶æ•°ç³»ç»Ÿ.md)
- [02.3.2 æ•´æ•°ç³»ç»Ÿ](../02.3.2_æ•´æ•°ç³»ç»Ÿ.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
