# 02.10.3 ç´ æ•°ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç´ æ•°ç†è®ºæ˜¯æ•°è®ºçš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶ç´ æ•°çš„æ€§è´¨ã€åˆ†å¸ƒè§„å¾‹å’Œç›¸å…³çš„æ•°å­¦ç»“æ„ã€‚ç´ æ•°ä½œä¸ºè‡ªç„¶æ•°çš„åŸºæœ¬æ„å»ºå—ï¼Œåœ¨æ•°å­¦çš„å„ä¸ªé¢†åŸŸéƒ½æœ‰é‡è¦åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹ç´ æ•°çš„åŸºç¡€ç†è®ºä½“ç³»**
2. **ç ”ç©¶ç´ æ•°çš„åˆ†å¸ƒè§„å¾‹**
3. **å‘å±•ç´ æ•°æ£€æµ‹å’Œç”Ÿæˆç®—æ³•**
4. **æ¢ç´¢ç´ æ•°åœ¨å¯†ç å­¦ä¸­çš„åº”ç”¨**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç´ æ•°å®šä¹‰

**ç´ æ•°**æ˜¯å¤§äº1çš„è‡ªç„¶æ•°ï¼Œé™¤äº†1å’Œå®ƒæœ¬èº«å¤–æ²¡æœ‰å…¶ä»–æ­£å› å­ã€‚

### 1.2 åˆæ•°å®šä¹‰

**åˆæ•°**æ˜¯å¤§äº1çš„è‡ªç„¶æ•°ï¼Œé™¤äº†1å’Œå®ƒæœ¬èº«å¤–è¿˜æœ‰å…¶ä»–æ­£å› å­ã€‚

### 1.3 ç´ æ•°åºåˆ—

å‰å‡ ä¸ªç´ æ•°ä¸ºï¼š2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, ...

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ç´ æ•°åˆ¤å®šå‡½æ•°

å¯¹äºè‡ªç„¶æ•° $n > 1$ï¼Œå®šä¹‰ç´ æ•°åˆ¤å®šå‡½æ•°ï¼š

$$\text{isPrime}(n) = \begin{cases}
\text{true} & \text{if } \forall d \in \mathbb{N}, 1 < d < n \Rightarrow d \nmid n \\
\text{false} & \text{otherwise}
\end{cases}$$

### 2.2 ç´ æ•°è®¡æ•°å‡½æ•°

å®šä¹‰ç´ æ•°è®¡æ•°å‡½æ•° $\pi(x)$ ä¸ºä¸è¶…è¿‡ $x$ çš„ç´ æ•°ä¸ªæ•°ï¼š

$$\pi(x) = \sum_{p \leq x, p \text{ prime}} 1$$

### 2.3 ç¬¬nä¸ªç´ æ•°å‡½æ•°

å®šä¹‰ $p_n$ ä¸ºç¬¬ $n$ ä¸ªç´ æ•°ï¼š

$$p_1 = 2, p_2 = 3, p_3 = 5, \ldots$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 ç®—æœ¯åŸºæœ¬å®šç†

**å®šç† 3.1.1** (ç®—æœ¯åŸºæœ¬å®šç†)ï¼šæ¯ä¸ªå¤§äº1çš„è‡ªç„¶æ•°éƒ½å¯ä»¥å”¯ä¸€åœ°è¡¨ç¤ºä¸ºç´ æ•°çš„ä¹˜ç§¯ã€‚

**è¯æ˜**ï¼š
1. **å­˜åœ¨æ€§**ï¼šä½¿ç”¨æ•°å­¦å½’çº³æ³•
   - åŸºç¡€æƒ…å†µï¼š$n = 2$ æ˜¯ç´ æ•°ï¼Œæˆç«‹
   - å½’çº³å‡è®¾ï¼šå‡è®¾å¯¹äºæ‰€æœ‰ $k < n$ éƒ½æˆç«‹
   - å½’çº³æ­¥éª¤ï¼šå¦‚æœ $n$ æ˜¯ç´ æ•°ï¼Œåˆ™ $n = n$ï¼›å¦‚æœ $n$ æ˜¯åˆæ•°ï¼Œåˆ™ $n = ab$ï¼Œå…¶ä¸­ $1 < a, b < n$ï¼Œç”±å½’çº³å‡è®¾ï¼Œ$a$ å’Œ $b$ éƒ½å¯ä»¥è¡¨ç¤ºä¸ºç´ æ•°ä¹˜ç§¯

2. **å”¯ä¸€æ€§**ï¼šå‡è®¾ $n = p_1 p_2 \cdots p_k = q_1 q_2 \cdots q_m$
   - ç”±äº $p_1$ æ•´é™¤ $n$ï¼Œæ‰€ä»¥ $p_1$ æ•´é™¤æŸä¸ª $q_i$
   - ç”±äº $q_i$ æ˜¯ç´ æ•°ï¼Œæ‰€ä»¥ $p_1 = q_i$
   - é‡å¤æ­¤è¿‡ç¨‹ï¼Œå¾—åˆ°å”¯ä¸€æ€§

### 3.2 ç´ æ•°æ— ç©·æ€§å®šç†

**å®šç† 3.2.1** (æ¬§å‡ é‡Œå¾—å®šç†)ï¼šç´ æ•°æœ‰æ— ç©·å¤šä¸ªã€‚

**è¯æ˜**ï¼š
å‡è®¾ç´ æ•°åªæœ‰æœ‰é™ä¸ªï¼š$p_1, p_2, \ldots, p_n$

æ„é€ æ•° $N = p_1 p_2 \cdots p_n + 1$

- å¦‚æœ $N$ æ˜¯ç´ æ•°ï¼Œåˆ™ä¸å‡è®¾çŸ›ç›¾
- å¦‚æœ $N$ æ˜¯åˆæ•°ï¼Œåˆ™ $N$ æœ‰ç´ å› å­ $p$ï¼Œä½† $p$ ä¸èƒ½æ˜¯ $p_1, p_2, \ldots, p_n$ ä¸­çš„ä»»ä½•ä¸€ä¸ªï¼Œå› ä¸º $N$ é™¤ä»¥è¿™äº›ç´ æ•°éƒ½ä½™1

å› æ­¤å‡è®¾é”™è¯¯ï¼Œç´ æ•°æœ‰æ— ç©·å¤šä¸ªã€‚

### 3.3 ç´ æ•°åˆ†å¸ƒå®šç†

**å®šç† 3.3.1** (ç´ æ•°å®šç†)ï¼šå½“ $x \to \infty$ æ—¶ï¼Œ

$$\pi(x) \sim \frac{x}{\ln x}$$

å³ï¼š

$$\lim_{x \to \infty} \frac{\pi(x)}{x/\ln x} = 1$$

### 3.4 å¨å°”é€Šå®šç†

**å®šç† 3.4.1** (å¨å°”é€Šå®šç†)ï¼šå¯¹äºç´ æ•° $p$ï¼Œ

$$(p-1)! \equiv -1 \pmod{p}$$

**è¯æ˜**ï¼š
åœ¨æ¨¡ $p$ çš„ä¹˜æ³•ç¾¤ä¸­ï¼Œé™¤äº†1å’Œ-1ï¼Œå…¶ä»–å…ƒç´ éƒ½ä¸è‡ªå·±çš„é€†å…ƒé…å¯¹ã€‚
å› æ­¤ï¼š

$$(p-1)! \equiv 1 \cdot (-1) \cdot \prod_{a \neq \pm 1} (a \cdot a^{-1}) \equiv -1 \pmod{p}$$

## 4. ä»£ç å®ç°

### 4.1 Rustå®ç°

```rust
use std::collections::HashSet;

/// ç´ æ•°ç†è®ºå®ç°
pub struct PrimeTheory;

impl PrimeTheory {
    /// åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦ä¸ºç´ æ•°
    pub fn is_prime(n: u64) -> bool {
        if n < 2 {
            return false;
        }
        if n == 2 {
            return true;
        }
        if n % 2 == 0 {
            return false;
        }
        
        let sqrt_n = (n as f64).sqrt() as u64;
        for i in (3..=sqrt_n).step_by(2) {
            if n % i == 0 {
                return false;
            }
        }
        true
    }
    
    /// åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•ç”Ÿæˆç´ æ•°
    pub fn sieve_of_eratosthenes(n: usize) -> Vec<usize> {
        if n < 2 {
            return vec![];
        }
        
        let mut is_prime = vec![true; n + 1];
        is_prime[0] = false;
        is_prime[1] = false;
        
        let sqrt_n = (n as f64).sqrt() as usize;
        for i in 2..=sqrt_n {
            if is_prime[i] {
                for j in (i * i..=n).step_by(i) {
                    is_prime[j] = false;
                }
            }
        }
        
        is_prime.iter()
            .enumerate()
            .filter(|&(_, &is_p)| is_p)
            .map(|(i, _)| i)
            .collect()
    }
    
    /// è®¡ç®—ç´ æ•°è®¡æ•°å‡½æ•° Ï€(x)
    pub fn prime_count(x: u64) -> u64 {
        if x < 2 {
            return 0;
        }
        
        let primes = Self::sieve_of_eratosthenes(x as usize);
        primes.len() as u64
    }
    
    /// è·å–ç¬¬nä¸ªç´ æ•°
    pub fn nth_prime(n: usize) -> Option<u64> {
        if n == 0 {
            return None;
        }
        
        // ä½¿ç”¨ç´ æ•°å®šç†ä¼°è®¡ä¸Šç•Œ
        let upper_bound = if n <= 6 {
            n * 2
        } else {
            (n as f64 * (n as f64).ln() * 1.2) as usize
        };
        
        let primes = Self::sieve_of_eratosthenes(upper_bound);
        primes.get(n - 1).map(|&p| p as u64)
    }
    
    /// ç´ æ•°åˆ†è§£
    pub fn prime_factorization(mut n: u64) -> Vec<(u64, u32)> {
        let mut factors = Vec::new();
        let mut d = 2;
        
        while d * d <= n {
            let mut count = 0;
            while n % d == 0 {
                n /= d;
                count += 1;
            }
            if count > 0 {
                factors.push((d, count));
            }
            d += 1;
        }
        
        if n > 1 {
            factors.push((n, 1));
        }
        
        factors
    }
    
    /// æ¬§æ‹‰å‡½æ•° Ï†(n)
    pub fn euler_totient(n: u64) -> u64 {
        if n == 1 {
            return 1;
        }
        
        let factors = Self::prime_factorization(n);
        let mut result = n;
        
        for (p, _) in factors {
            result = result / p * (p - 1);
        }
        
        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_is_prime() {
        assert!(!PrimeTheory::is_prime(0));
        assert!(!PrimeTheory::is_prime(1));
        assert!(PrimeTheory::is_prime(2));
        assert!(PrimeTheory::is_prime(3));
        assert!(!PrimeTheory::is_prime(4));
        assert!(PrimeTheory::is_prime(5));
        assert!(!PrimeTheory::is_prime(6));
        assert!(PrimeTheory::is_prime(7));
        assert!(!PrimeTheory::is_prime(8));
        assert!(!PrimeTheory::is_prime(9));
        assert!(!PrimeTheory::is_prime(10));
        assert!(PrimeTheory::is_prime(11));
    }
    
    #[test]
    fn test_sieve_of_eratosthenes() {
        let primes = PrimeTheory::sieve_of_eratosthenes(20);
        assert_eq!(primes, vec![2, 3, 5, 7, 11, 13, 17, 19]);
    }
    
    #[test]
    fn test_prime_count() {
        assert_eq!(PrimeTheory::prime_count(10), 4);
        assert_eq!(PrimeTheory::prime_count(20), 8);
        assert_eq!(PrimeTheory::prime_count(30), 10);
    }
    
    #[test]
    fn test_nth_prime() {
        assert_eq!(PrimeTheory::nth_prime(1), Some(2));
        assert_eq!(PrimeTheory::nth_prime(2), Some(3));
        assert_eq!(PrimeTheory::nth_prime(3), Some(5));
        assert_eq!(PrimeTheory::nth_prime(4), Some(7));
        assert_eq!(PrimeTheory::nth_prime(5), Some(11));
    }
    
    #[test]
    fn test_prime_factorization() {
        assert_eq!(PrimeTheory::prime_factorization(12), vec![(2, 2), (3, 1)]);
        assert_eq!(PrimeTheory::prime_factorization(100), vec![(2, 2), (5, 2)]);
        assert_eq!(PrimeTheory::prime_factorization(17), vec![(17, 1)]);
    }
    
    #[test]
    fn test_euler_totient() {
        assert_eq!(PrimeTheory::euler_totient(1), 1);
        assert_eq!(PrimeTheory::euler_totient(6), 2);
        assert_eq!(PrimeTheory::euler_totient(8), 4);
        assert_eq!(PrimeTheory::euler_totient(12), 4);
    }
}
```

### 4.2 Haskellå®ç°

```haskell
module PrimeTheory where

import Data.List (nub)
import Data.Maybe (fromJust)

-- ç´ æ•°ç†è®ºå®ç°
class PrimeTheory a where
    isPrime :: a -> Bool
    sieveOfEratosthenes :: Int -> [Int]
    primeCount :: Int -> Int
    nthPrime :: Int -> Maybe Int
    primeFactorization :: Int -> [(Int, Int)]
    eulerTotient :: Int -> Int

instance PrimeTheory Int where
    -- åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦ä¸ºç´ æ•°
    isPrime n
        | n < 2 = False
        | n == 2 = True
        | even n = False
        | otherwise = all (\d -> n `mod` d /= 0) [3, 5..sqrt_n]
        where sqrt_n = floor $ sqrt $ fromIntegral n
    
    -- åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•
    sieveOfEratosthenes n
        | n < 2 = []
        | otherwise = sieve [2..n]
        where
            sieve [] = []
            sieve (p:xs) = p : sieve [x | x <- xs, x `mod` p /= 0]
    
    -- ç´ æ•°è®¡æ•°å‡½æ•°
    primeCount x = length $ takeWhile (<= x) $ sieveOfEratosthenes x
    
    -- ç¬¬nä¸ªç´ æ•°
    nthPrime n
        | n <= 0 = Nothing
        | otherwise = Just $ (sieveOfEratosthenes upperBound) !! (n - 1)
        where
            upperBound = if n <= 6 
                then n * 2 
                else ceiling $ fromIntegral n * log (fromIntegral n) * 1.2
    
    -- ç´ æ•°åˆ†è§£
    primeFactorization n = factorize n 2 []
        where
            factorize 1 _ factors = factors
            factorize n d factors
                | d * d > n = (n, 1) : factors
                | n `mod` d == 0 = factorize (n `div` d) d (addFactor d factors)
                | otherwise = factorize n (d + 1) factors
            
            addFactor d [] = [(d, 1)]
            addFactor d ((p, count):rest)
                | p == d = (p, count + 1) : rest
                | otherwise = (p, count) : addFactor d rest
    
    -- æ¬§æ‹‰å‡½æ•°
    eulerTotient n = foldl (\acc (p, _) -> acc `div` p * (p - 1)) n factors
        where factors = primeFactorization n

-- æµ‹è¯•å‡½æ•°
testPrimeTheory :: IO ()
testPrimeTheory = do
    putStrLn "Testing Prime Theory..."
    
    -- æµ‹è¯•ç´ æ•°åˆ¤å®š
    putStrLn $ "isPrime 2: " ++ show (isPrime 2)
    putStrLn $ "isPrime 3: " ++ show (isPrime 3)
    putStrLn $ "isPrime 4: " ++ show (isPrime 4)
    putStrLn $ "isPrime 17: " ++ show (isPrime 17)
    
    -- æµ‹è¯•ç´ æ•°ç”Ÿæˆ
    putStrLn $ "First 10 primes: " ++ show (take 10 $ sieveOfEratosthenes 30)
    
    -- æµ‹è¯•ç´ æ•°è®¡æ•°
    putStrLn $ "Ï€(20): " ++ show (primeCount 20)
    putStrLn $ "Ï€(30): " ++ show (primeCount 30)
    
    -- æµ‹è¯•ç¬¬nä¸ªç´ æ•°
    putStrLn $ "5th prime: " ++ show (nthPrime 5)
    
    -- æµ‹è¯•ç´ æ•°åˆ†è§£
    putStrLn $ "Prime factorization of 12: " ++ show (primeFactorization 12)
    putStrLn $ "Prime factorization of 100: " ++ show (primeFactorization 100)
    
    -- æµ‹è¯•æ¬§æ‹‰å‡½æ•°
    putStrLn $ "Ï†(6): " ++ show (eulerTotient 6)
    putStrLn $ "Ï†(12): " ++ show (eulerTotient 12)
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å¯†ç å­¦åº”ç”¨

ç´ æ•°åœ¨RSAåŠ å¯†ç®—æ³•ä¸­çš„åº”ç”¨ï¼š

```rust
use num_bigint::{BigUint, RandBigInt};
use rand::thread_rng;

pub struct RSA {
    public_key: (BigUint, BigUint),
    private_key: BigUint,
}

impl RSA {
    pub fn new(bit_length: usize) -> Self {
        let mut rng = thread_rng();
        
        // ç”Ÿæˆä¸¤ä¸ªå¤§ç´ æ•°
        let p = Self::generate_prime(bit_length / 2, &mut rng);
        let q = Self::generate_prime(bit_length / 2, &mut rng);
        
        let n = &p * &q;
        let phi_n = (&p - 1u32) * (&q - 1u32);
        
        // é€‰æ‹©å…¬é’¥æŒ‡æ•°
        let e = BigUint::from(65537u32);
        
        // è®¡ç®—ç§é’¥
        let d = Self::mod_inverse(&e, &phi_n).unwrap();
        
        RSA {
            public_key: (n, e),
            private_key: d,
        }
    }
    
    fn generate_prime(bits: usize, rng: &mut impl rand::Rng) -> BigUint {
        loop {
            let candidate = rng.gen_biguint(bits);
            if Self::is_prime(&candidate) {
                return candidate;
            }
        }
    }
    
    fn is_prime(n: &BigUint) -> bool {
        if n.is_zero() || n.is_one() {
            return false;
        }
        
        // ç®€å•çš„ç´ æ•°æµ‹è¯•ï¼ˆå®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨æ›´é«˜æ•ˆçš„ç®—æ³•ï¼‰
        let n_u64 = n.to_u64().unwrap_or(0);
        if n_u64 > 0 {
            return PrimeTheory::is_prime(n_u64);
        }
        
        // å¯¹äºå¤§æ•°ï¼Œä½¿ç”¨æ¦‚ç‡æµ‹è¯•
        true // ç®€åŒ–å®ç°
    }
    
    fn mod_inverse(a: &BigUint, m: &BigUint) -> Option<BigUint> {
        // æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•å®ç°
        None // ç®€åŒ–å®ç°
    }
    
    pub fn encrypt(&self, message: &BigUint) -> BigUint {
        message.modpow(&self.public_key.1, &self.public_key.0)
    }
    
    pub fn decrypt(&self, ciphertext: &BigUint) -> BigUint {
        ciphertext.modpow(&self.private_key, &self.public_key.0)
    }
}
```

### 5.2 ç´ æ•°åˆ†å¸ƒå¯è§†åŒ–

```rust
use plotters::prelude::*;

pub fn plot_prime_distribution(max_n: u64) -> Result<(), Box<dyn std::error::Error>> {
    let root = BitMapBackend::new("prime_distribution.png", (800, 600)).into_drawing_area();
    root.fill(&WHITE)?;
    
    let mut chart = ChartBuilder::on(&root)
        .caption("Prime Distribution", ("sans-serif", 30))
        .margin(5)
        .x_label_area_size(40)
        .y_label_area_size(40)
        .build_cartesian_2d(0..max_n, 0..PrimeTheory::prime_count(max_n))?;
    
    chart.configure_mesh().draw()?;
    
    // ç»˜åˆ¶ç´ æ•°è®¡æ•°å‡½æ•°
    let points: Vec<(u64, u64)> = (1..=max_n)
        .map(|x| (x, PrimeTheory::prime_count(x)))
        .collect();
    
    chart.draw_series(LineSeries::new(points, &RED))?;
    
    // ç»˜åˆ¶ç´ æ•°å®šç†è¿‘ä¼¼
    let approx_points: Vec<(u64, u64)> = (1..=max_n)
        .map(|x| (x, (x as f64 / (x as f64).ln()) as u64))
        .collect();
    
    chart.draw_series(LineSeries::new(approx_points, &BLUE))?;
    
    root.present()?;
    Ok(())
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸æ•´é™¤ç†è®ºçš„å…³ç³»

ç´ æ•°ç†è®ºæ˜¯æ•´é™¤ç†è®ºçš„æ ¸å¿ƒï¼Œç´ æ•°åˆ†è§£æ˜¯æ•´é™¤ç†è®ºçš„åŸºç¡€ã€‚

### 6.2 ä¸åŒä½™ç†è®ºçš„å…³ç³»

ç´ æ•°åœ¨æ¨¡è¿ç®—ä¸­å…·æœ‰ç‰¹æ®Šæ€§è´¨ï¼Œå¨å°”é€Šå®šç†å°±æ˜¯ç´ æ•°åœ¨åŒä½™ç†è®ºä¸­çš„é‡è¦åº”ç”¨ã€‚

### 6.3 ä¸äºŒæ¬¡å‰©ä½™çš„å…³ç³»

äºŒæ¬¡å‰©ä½™ç†è®ºä¸»è¦ç ”ç©¶ç´ æ•°æ¨¡ä¸‹çš„äºŒæ¬¡æ–¹ç¨‹è§£çš„å­˜åœ¨æ€§ã€‚

### 6.4 ä¸ä»£æ•°æ•°è®ºçš„å…³ç³»

ç´ æ•°åœ¨ä»£æ•°æ•°è®ºä¸­æ¨å¹¿ä¸ºç´ ç†æƒ³ï¼Œæ˜¯æ›´é«˜çº§æ•°è®ºçš„åŸºç¡€ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Hardy, G. H., & Wright, E. M. (2008). An Introduction to the Theory of Numbers. Oxford University Press.
2. Apostol, T. M. (2010). Introduction to Analytic Number Theory. Springer.
3. Davenport, H. (2008). Multiplicative Number Theory. Springer.
4. Crandall, R., & Pomerance, C. (2005). Prime Numbers: A Computational Perspective. Springer.
5. Ribenboim, P. (2004). The Little Book of Bigger Primes. Springer.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [02.10.1 æ•´é™¤ç†è®º](../02.10.1_æ•´é™¤ç†è®º.md)
- [02.10.2 åŒä½™ç†è®º](../02.10.2_åŒä½™ç†è®º.md)
- [02.10.4 äºŒæ¬¡å‰©ä½™](../02.10.4_äºŒæ¬¡å‰©ä½™.md)
- [02.11.1 è®¡æ•°åŸç†](../02.11.1_è®¡æ•°åŸç†.md) 

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
