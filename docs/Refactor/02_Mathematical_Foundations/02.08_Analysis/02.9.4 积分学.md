# 02.9.4 ç§¯åˆ†å­¦

## ğŸ“‹ æ¦‚è¿°

ç§¯åˆ†å­¦æ˜¯æ•°å­¦åˆ†æçš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶å‡½æ•°çš„ç´¯ç§¯æ•ˆåº”å’Œé¢ç§¯è®¡ç®—ã€‚
æœ¬æ–‡æ¡£å»ºç«‹ä¸¥æ ¼çš„ç§¯åˆ†å­¦ç†è®ºæ¡†æ¶ï¼ŒåŒ…å«å½¢å¼åŒ–å®šä¹‰ã€å®šç†è¯æ˜å’Œå®é™…åº”ç”¨ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ä¸¥æ ¼çš„ç§¯åˆ†æ¦‚å¿µå’Œå½¢å¼åŒ–å®šä¹‰
2. è¯æ˜ç§¯åˆ†å­¦çš„åŸºæœ¬å®šç†
3. æä¾›å®Œæ•´çš„ä»£ç å®ç°
4. å±•ç¤ºç§¯åˆ†å­¦åœ¨å½¢å¼ç§‘å­¦ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

- [02.9.4 ç§¯åˆ†å­¦](#0294-ç§¯åˆ†å­¦)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒç›®æ ‡](#-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 ç§¯åˆ†çš„ç›´è§‚ç†è§£](#11-ç§¯åˆ†çš„ç›´è§‚ç†è§£)
    - [1.2 é»æ›¼ç§¯åˆ†](#12-é»æ›¼ç§¯åˆ†)
    - [1.3 ä¸å®šç§¯åˆ†](#13-ä¸å®šç§¯åˆ†)
  - [2. å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
    - [2.1 è¾¾å¸ƒç§¯åˆ†](#21-è¾¾å¸ƒç§¯åˆ†)
    - [2.2 å‹’è´æ ¼ç§¯åˆ†](#22-å‹’è´æ ¼ç§¯åˆ†)
    - [2.3 å¹¿ä¹‰ç§¯åˆ†](#23-å¹¿ä¹‰ç§¯åˆ†)
  - [3. å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
    - [3.1 ç§¯åˆ†åŸºæœ¬æ€§è´¨](#31-ç§¯åˆ†åŸºæœ¬æ€§è´¨)
    - [3.2 å¾®ç§¯åˆ†åŸºæœ¬å®šç†](#32-å¾®ç§¯åˆ†åŸºæœ¬å®šç†)
    - [3.3 ç§¯åˆ†ä¸­å€¼å®šç†](#33-ç§¯åˆ†ä¸­å€¼å®šç†)
  - [4. ä»£ç å®ç°](#4-ä»£ç å®ç°)
    - [4.1 Rust å®ç°](#41-rust-å®ç°)
    - [4.2 Haskell å®ç°](#42-haskell-å®ç°)
  - [5. åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
    - [5.1 æ¦‚ç‡è®ºä¸­çš„åº”ç”¨](#51-æ¦‚ç‡è®ºä¸­çš„åº”ç”¨)
    - [5.2 ç‰©ç†å­¦ä¸­çš„åº”ç”¨](#52-ç‰©ç†å­¦ä¸­çš„åº”ç”¨)
  - [6. ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
    - [6.1 ä¸å¾®åˆ†å­¦çš„å…³ç³»](#61-ä¸å¾®åˆ†å­¦çš„å…³ç³»)
    - [6.2 ä¸çº§æ•°çš„å…³ç³»](#62-ä¸çº§æ•°çš„å…³ç³»)
    - [6.3 ä¸å‚…é‡Œå¶åˆ†æçš„å…³ç³»](#63-ä¸å‚…é‡Œå¶åˆ†æçš„å…³ç³»)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç§¯åˆ†çš„ç›´è§‚ç†è§£

ç§¯åˆ†æè¿°å‡½æ•°åœ¨åŒºé—´ä¸Šçš„ç´¯ç§¯æ•ˆåº”ï¼Œå‡ ä½•ä¸Šè¡¨ç¤ºæ›²çº¿ä¸‹çš„é¢ç§¯ã€‚

**å®šä¹‰ 1.1.1** (å®šç§¯åˆ†ç›´è§‚å®šä¹‰)
è®¾å‡½æ•° $f: [a, b] \to \mathbb{R}$ï¼Œå°†åŒºé—´ $[a, b]$ åˆ†å‰²ä¸º $n$ ä¸ªå­åŒºé—´ï¼Œåœ¨æ¯ä¸ªå­åŒºé—´ä¸Šå–ä¸€ç‚¹ $\xi_i$ï¼Œåˆ™å®šç§¯åˆ†å®šä¹‰ä¸ºï¼š
$$\int_a^b f(x) dx = \lim_{n \to \infty} \sum_{i=1}^n f(\xi_i) \Delta x_i$$

### 1.2 é»æ›¼ç§¯åˆ†

**å®šä¹‰ 1.2.1** (é»æ›¼ç§¯åˆ†)
è®¾ $f: [a, b] \to \mathbb{R}$ï¼Œ$P = \{x_0, x_1, \ldots, x_n\}$ æ˜¯ $[a, b]$ çš„ä¸€ä¸ªåˆ†å‰²ï¼Œ$\xi_i \in [x_{i-1}, x_i]$ï¼Œåˆ™é»æ›¼å’Œå®šä¹‰ä¸ºï¼š
$$S(f, P, \xi) = \sum_{i=1}^n f(\xi_i)(x_i - x_{i-1})$$

å¦‚æœå­˜åœ¨å®æ•° $I$ï¼Œä½¿å¾—å¯¹ä»»æ„ $\varepsilon > 0$ï¼Œå­˜åœ¨ $\delta > 0$ï¼Œå½“åˆ†å‰²çš„èŒƒæ•° $||P|| < \delta$ æ—¶ï¼š
$$|S(f, P, \xi) - I| < \varepsilon$$

åˆ™ç§° $f$ åœ¨ $[a, b]$ ä¸Šé»æ›¼å¯ç§¯ï¼Œ$I$ ç§°ä¸º $f$ åœ¨ $[a, b]$ ä¸Šçš„å®šç§¯åˆ†ï¼Œè®°ä½œï¼š
$$I = \int_a^b f(x) dx$$

### 1.3 ä¸å®šç§¯åˆ†

**å®šä¹‰ 1.3.1** (åŸå‡½æ•°)
è®¾ $f: [a, b] \to \mathbb{R}$ï¼Œå¦‚æœå‡½æ•° $F: [a, b] \to \mathbb{R}$ æ»¡è¶³ï¼š
$$F'(x) = f(x) \quad \forall x \in [a, b]$$

åˆ™ç§° $F$ æ˜¯ $f$ çš„ä¸€ä¸ªåŸå‡½æ•°ã€‚

**å®šä¹‰ 1.3.2** (ä¸å®šç§¯åˆ†)
å‡½æ•° $f$ çš„æ‰€æœ‰åŸå‡½æ•°çš„é›†åˆç§°ä¸º $f$ çš„ä¸å®šç§¯åˆ†ï¼Œè®°ä½œï¼š
$$\int f(x) dx = F(x) + C$$

å…¶ä¸­ $C$ æ˜¯ä»»æ„å¸¸æ•°ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 è¾¾å¸ƒç§¯åˆ†

**å®šä¹‰ 2.1.1** (è¾¾å¸ƒä¸Šä¸‹å’Œ)
è®¾ $f: [a, b] \to \mathbb{R}$ï¼Œ$P = \{x_0, x_1, \ldots, x_n\}$ æ˜¯åˆ†å‰²ï¼Œå®šä¹‰ï¼š
$$M_i = \sup_{x \in [x_{i-1}, x_i]} f(x)$$
$$m_i = \inf_{x \in [x_{i-1}, x_i]} f(x)$$

ä¸Šè¾¾å¸ƒå’Œï¼š$U(f, P) = \sum_{i=1}^n M_i(x_i - x_{i-1})$
ä¸‹è¾¾å¸ƒå’Œï¼š$L(f, P) = \sum_{i=1}^n m_i(x_i - x_{i-1})$

**å®šä¹‰ 2.1.2** (è¾¾å¸ƒç§¯åˆ†)
ä¸Šç§¯åˆ†ï¼š$\overline{\int_a^b} f(x) dx = \inf_P U(f, P)$
ä¸‹ç§¯åˆ†ï¼š$\underline{\int_a^b} f(x) dx = \sup_P L(f, P)$

å¦‚æœä¸Šä¸‹ç§¯åˆ†ç›¸ç­‰ï¼Œåˆ™ç§° $f$ è¾¾å¸ƒå¯ç§¯ã€‚

### 2.2 å‹’è´æ ¼ç§¯åˆ†

**å®šä¹‰ 2.2.1** (ç®€å•å‡½æ•°)
è®¾ $E \subset \mathbb{R}$ å¯æµ‹ï¼Œå‡½æ•° $s: E \to \mathbb{R}$ ç§°ä¸ºç®€å•å‡½æ•°ï¼Œå¦‚æœå®ƒå¯ä»¥è¡¨ç¤ºä¸ºï¼š
$$s(x) = \sum_{i=1}^n a_i \chi_{A_i}(x)$$

å…¶ä¸­ $A_i$ æ˜¯ $E$ çš„å¯æµ‹å­é›†ï¼Œ$\chi_{A_i}$ æ˜¯ç‰¹å¾å‡½æ•°ã€‚

**å®šä¹‰ 2.2.2** (å‹’è´æ ¼ç§¯åˆ†)
è®¾ $f: E \to \mathbb{R}$ éè´Ÿå¯æµ‹ï¼Œå®šä¹‰ï¼š
$$\int_E f(x) dx = \sup \left\{\int_E s(x) dx : 0 \leq s \leq f, s \text{ ç®€å•å‡½æ•°}\right\}$$

### 2.3 å¹¿ä¹‰ç§¯åˆ†

**å®šä¹‰ 2.3.1** (æ— ç©·åŒºé—´ç§¯åˆ†)
è®¾ $f: [a, \infty) \to \mathbb{R}$ï¼Œå¦‚æœæé™å­˜åœ¨ï¼Œå®šä¹‰ï¼š
$$\int_a^\infty f(x) dx = \lim_{b \to \infty} \int_a^b f(x) dx$$

**å®šä¹‰ 2.3.2** (ç‘•ç§¯åˆ†)
è®¾ $f: (a, b] \to \mathbb{R}$ åœ¨ $a$ ç‚¹é™„è¿‘æ— ç•Œï¼Œå¦‚æœæé™å­˜åœ¨ï¼Œå®šä¹‰ï¼š
$$\int_a^b f(x) dx = \lim_{\varepsilon \to 0^+} \int_{a+\varepsilon}^b f(x) dx$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 ç§¯åˆ†åŸºæœ¬æ€§è´¨

**å®šç† 3.1.1** (çº¿æ€§æ€§)
è®¾ $f, g$ åœ¨ $[a, b]$ ä¸Šå¯ç§¯ï¼Œ$\alpha, \beta \in \mathbb{R}$ï¼Œåˆ™ï¼š
$$\int_a^b (\alpha f + \beta g)(x) dx = \alpha \int_a^b f(x) dx + \beta \int_a^b g(x) dx$$

**è¯æ˜**ï¼š

$$
\begin{align}
\int_a^b (\alpha f + \beta g)(x) dx &= \lim_{n \to \infty} \sum_{i=1}^n (\alpha f + \beta g)(\xi_i) \Delta x_i \\
&= \lim_{n \to \infty} \sum_{i=1}^n (\alpha f(\xi_i) + \beta g(\xi_i)) \Delta x_i \\
&= \alpha \lim_{n \to \infty} \sum_{i=1}^n f(\xi_i) \Delta x_i + \beta \lim_{n \to \infty} \sum_{i=1}^n g(\xi_i) \Delta x_i \\
&= \alpha \int_a^b f(x) dx + \beta \int_a^b g(x) dx
\end{align}
$$

**å®šç† 3.1.2** (åŒºé—´å¯åŠ æ€§)
è®¾ $f$ åœ¨ $[a, c]$ ä¸Šå¯ç§¯ï¼Œ$a < b < c$ï¼Œåˆ™ï¼š
$$\int_a^c f(x) dx = \int_a^b f(x) dx + \int_b^c f(x) dx$$

**è¯æ˜**ï¼š
å°† $[a, c]$ çš„åˆ†å‰²é™åˆ¶åœ¨ $[a, b]$ å’Œ $[b, c]$ ä¸Šï¼Œåˆ©ç”¨ç§¯åˆ†çš„å®šä¹‰ç›´æ¥å¾—åˆ°ã€‚

### 3.2 å¾®ç§¯åˆ†åŸºæœ¬å®šç†

**å®šç† 3.2.1** (å¾®ç§¯åˆ†åŸºæœ¬å®šç† I)
è®¾ $f$ åœ¨ $[a, b]$ ä¸Šè¿ç»­ï¼Œ$F(x) = \int_a^x f(t) dt$ï¼Œåˆ™ $F$ åœ¨ $[a, b]$ ä¸Šå¯å¯¼ï¼Œä¸”ï¼š
$$F'(x) = f(x) \quad \forall x \in [a, b]$$

**è¯æ˜**ï¼š
å¯¹ä»»æ„ $x \in [a, b]$ï¼Œ$h \neq 0$ ä¸” $x + h \in [a, b]$ï¼š

$$
\begin{align}
\frac{F(x + h) - F(x)}{h} &= \frac{1}{h} \int_x^{x+h} f(t) dt \\
&= \frac{1}{h} \int_x^{x+h} (f(t) - f(x) + f(x)) dt \\
&= f(x) + \frac{1}{h} \int_x^{x+h} (f(t) - f(x)) dt
\end{align}
$$

ç”±äº $f$ è¿ç»­ï¼Œå¯¹ä»»æ„ $\varepsilon > 0$ï¼Œå­˜åœ¨ $\delta > 0$ï¼Œå½“ $|t - x| < \delta$ æ—¶ $|f(t) - f(x)| < \varepsilon$ã€‚

å› æ­¤å½“ $|h| < \delta$ æ—¶ï¼š
$$\left|\frac{1}{h} \int_x^{x+h} (f(t) - f(x)) dt\right| \leq \varepsilon$$

æ‰€ä»¥ï¼š
$$\lim_{h \to 0} \frac{F(x + h) - F(x)}{h} = f(x)$$

**å®šç† 3.2.2** (å¾®ç§¯åˆ†åŸºæœ¬å®šç† II)
è®¾ $f$ åœ¨ $[a, b]$ ä¸Šè¿ç»­ï¼Œ$F$ æ˜¯ $f$ çš„ä»»æ„åŸå‡½æ•°ï¼Œåˆ™ï¼š
$$\int_a^b f(x) dx = F(b) - F(a)$$

**è¯æ˜**ï¼š
ç”±å®šç† 3.2.1ï¼Œ$G(x) = \int_a^x f(t) dt$ æ˜¯ $f$ çš„ä¸€ä¸ªåŸå‡½æ•°ã€‚
å› æ­¤ $F(x) = G(x) + C$ï¼Œå…¶ä¸­ $C$ æ˜¯å¸¸æ•°ã€‚

æ‰€ä»¥ï¼š
$$\int_a^b f(x) dx = G(b) = F(b) - C = F(b) - (F(a) - G(a)) = F(b) - F(a)$$

### 3.3 ç§¯åˆ†ä¸­å€¼å®šç†

**å®šç† 3.3.1** (ç§¯åˆ†ä¸­å€¼å®šç†)
è®¾ $f$ åœ¨ $[a, b]$ ä¸Šè¿ç»­ï¼Œåˆ™å­˜åœ¨ $\xi \in [a, b]$ ä½¿å¾—ï¼š
$$\int_a^b f(x) dx = f(\xi)(b - a)$$

**è¯æ˜**ï¼š
ç”±äº $f$ åœ¨ $[a, b]$ ä¸Šè¿ç»­ï¼Œå­˜åœ¨ $m = \min_{x \in [a, b]} f(x)$ å’Œ $M = \max_{x \in [a, b]} f(x)$ã€‚

å› æ­¤ï¼š
$$m(b - a) \leq \int_a^b f(x) dx \leq M(b - a)$$

ç”±ä»‹å€¼å®šç†ï¼Œå­˜åœ¨ $\xi \in [a, b]$ ä½¿å¾—ï¼š
$$f(\xi) = \frac{1}{b - a} \int_a^b f(x) dx$$

## 4. ä»£ç å®ç°

### 4.1 Rust å®ç°

```rust
use std::f64;

/// æ•°å€¼ç§¯åˆ†å®ç°
pub struct NumericalIntegration;

impl NumericalIntegration {
    /// çŸ©å½¢æ³•åˆ™
    pub fn rectangle_rule<F>(f: F, a: f64, b: f64, n: usize) -> f64
    where
        F: Fn(f64) -> f64,
    {
        let h = (b - a) / n as f64;
        let mut sum = 0.0;

        for i in 0..n {
            let x = a + (i as f64 + 0.5) * h;
            sum += f(x);
        }

        sum * h
    }

    /// æ¢¯å½¢æ³•åˆ™
    pub fn trapezoidal_rule<F>(f: F, a: f64, b: f64, n: usize) -> f64
    where
        F: Fn(f64) -> f64,
    {
        let h = (b - a) / n as f64;
        let mut sum = (f(a) + f(b)) / 2.0;

        for i in 1..n {
            let x = a + i as f64 * h;
            sum += f(x);
        }

        sum * h
    }

    /// è¾›æ™®æ£®æ³•åˆ™
    pub fn simpson_rule<F>(f: F, a: f64, b: f64, n: usize) -> f64
    where
        F: Fn(f64) -> f64,
    {
        if n % 2 != 0 {
            panic!("è¾›æ™®æ£®æ³•åˆ™éœ€è¦å¶æ•°ä¸ªå­åŒºé—´");
        }

        let h = (b - a) / n as f64;
        let mut sum = f(a) + f(b);

        for i in 1..n {
            let x = a + i as f64 * h;
            if i % 2 == 0 {
                sum += 2.0 * f(x);
            } else {
                sum += 4.0 * f(x);
            }
        }

        sum * h / 3.0
    }

    /// è‡ªé€‚åº”ç§¯åˆ†
    pub fn adaptive_integration<F>(f: F, a: f64, b: f64, tolerance: f64) -> f64
    where
        F: Fn(f64) -> f64,
    {
        let mut h = (b - a) / 10.0;
        let mut prev_integral = Self::simpson_rule(&f, a, b, 10);

        loop {
            h /= 2.0;
            let n = ((b - a) / h) as usize;
            let current_integral = Self::simpson_rule(&f, a, b, n);

            if (current_integral - prev_integral).abs() < tolerance {
                return current_integral;
            }

            prev_integral = current_integral;
        }
    }

    /// é«˜æ–¯æ±‚ç§¯
    pub fn gauss_quadrature<F>(f: F, a: f64, b: f64, n: usize) -> f64
    where
        F: Fn(f64) -> f64,
    {
        // é«˜æ–¯-å‹’è®©å¾·æ±‚ç§¯ç‚¹å’Œæƒé‡
        let (points, weights) = Self::gauss_legendre_points_weights(n);

        let mut sum = 0.0;
        for i in 0..n {
            let x = (b - a) / 2.0 * points[i] + (a + b) / 2.0;
            sum += weights[i] * f(x);
        }

        sum * (b - a) / 2.0
    }

    fn gauss_legendre_points_weights(n: usize) -> (Vec<f64>, Vec<f64>) {
        match n {
            2 => (
                vec![-0.5773502691896257, 0.5773502691896257],
                vec![1.0, 1.0],
            ),
            3 => (
                vec![-0.7745966692414834, 0.0, 0.7745966692414834],
                vec![0.5555555555555556, 0.8888888888888888, 0.5555555555555556],
            ),
            4 => (
                vec![-0.8611363115940526, -0.3399810435848563, 0.3399810435848563, 0.8611363115940526],
                vec![0.3478548451374538, 0.6521451548625461, 0.6521451548625461, 0.3478548451374538],
            ),
            _ => panic!("ä»…æ”¯æŒ2-4ç‚¹é«˜æ–¯æ±‚ç§¯"),
        }
    }
}

/// ç¬¦å·ç§¯åˆ†å®ç°
pub struct SymbolicIntegration;

impl SymbolicIntegration {
    /// åŸºæœ¬ç§¯åˆ†è§„åˆ™
    pub fn integrate_basic_function(func_type: &str, x: f64, constant: f64) -> f64 {
        match func_type {
            "power" => {
                if constant == -1.0 {
                    x.ln()
                } else {
                    x.powf(constant + 1.0) / (constant + 1.0)
                }
            },
            "sin" => -x.cos(),
            "cos" => x.sin(),
            "exp" => x.exp(),
            "ln" => x * x.ln() - x,
            _ => panic!("æœªçŸ¥å‡½æ•°ç±»å‹"),
        }
    }

    /// å¤šé¡¹å¼ç§¯åˆ†
    pub fn integrate_polynomial(coefficients: &[f64]) -> Vec<f64> {
        let mut result = vec![0.0]; // ç§¯åˆ†å¸¸æ•°
        for (i, &coeff) in coefficients.iter().enumerate() {
            result.push(coeff / (i + 1) as f64);
        }
        result
    }
}

/// å¤šé‡ç§¯åˆ†å®ç°
pub struct MultipleIntegration;

impl MultipleIntegration {
    /// äºŒé‡ç§¯åˆ† - çŸ©å½¢åŒºåŸŸ
    pub fn double_integral_rectangle<F>(f: F, a: f64, b: f64, c: f64, d: f64,
                                       nx: usize, ny: usize) -> f64
    where
        F: Fn(f64, f64) -> f64,
    {
        let hx = (b - a) / nx as f64;
        let hy = (d - c) / ny as f64;
        let mut sum = 0.0;

        for i in 0..nx {
            for j in 0..ny {
                let x = a + (i as f64 + 0.5) * hx;
                let y = c + (j as f64 + 0.5) * hy;
                sum += f(x, y);
            }
        }

        sum * hx * hy
    }

    /// ä¸‰é‡ç§¯åˆ† - ç«‹æ–¹ä½“åŒºåŸŸ
    pub fn triple_integral_cube<F>(f: F, a: f64, b: f64, c: f64, d: f64,
                                  e: f64, f_val: f64, nx: usize, ny: usize, nz: usize) -> f64
    where
        F: Fn(f64, f64, f64) -> f64,
    {
        let hx = (b - a) / nx as f64;
        let hy = (d - c) / ny as f64;
        let hz = (f_val - e) / nz as f64;
        let mut sum = 0.0;

        for i in 0..nx {
            for j in 0..ny {
                for k in 0..nz {
                    let x = a + (i as f64 + 0.5) * hx;
                    let y = c + (j as f64 + 0.5) * hy;
                    let z = e + (k as f64 + 0.5) * hz;
                    sum += f(x, y, z);
                }
            }
        }

        sum * hx * hy * hz
    }
}

# [cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rectangle_rule() {
        let f = |x: f64| x.powi(2);
        let integral = NumericalIntegration::rectangle_rule(f, 0.0, 1.0, 1000);
        assert!((integral - 1.0/3.0).abs() < 1e-3);
    }

    #[test]
    fn test_trapezoidal_rule() {
        let f = |x: f64| x.powi(2);
        let integral = NumericalIntegration::trapezoidal_rule(f, 0.0, 1.0, 1000);
        assert!((integral - 1.0/3.0).abs() < 1e-3);
    }

    #[test]
    fn test_simpson_rule() {
        let f = |x: f64| x.powi(2);
        let integral = NumericalIntegration::simpson_rule(f, 0.0, 1.0, 1000);
        assert!((integral - 1.0/3.0).abs() < 1e-6);
    }

    #[test]
    fn test_double_integral() {
        let f = |x: f64, y: f64| x + y;
        let integral = MultipleIntegration::double_integral_rectangle(f, 0.0, 1.0, 0.0, 1.0, 100, 100);
        assert!((integral - 1.0).abs() < 1e-2);
    }
}
```

### 4.2 Haskell å®ç°

```haskell
-- æ•°å€¼ç§¯åˆ†
module Integration where

import Data.List

-- çŸ©å½¢æ³•åˆ™
rectangleRule :: (Double -> Double) -> Double -> Double -> Int -> Double
rectangleRule f a b n = h * sum [f (a + (fromIntegral i + 0.5) * h) | i <- [0..n-1]]
  where h = (b - a) / fromIntegral n

-- æ¢¯å½¢æ³•åˆ™
trapezoidalRule :: (Double -> Double) -> Double -> Double -> Int -> Double
trapezoidalRule f a b n = h * (f a / 2 + sum [f (a + fromIntegral i * h) | i <- [1..n-1]] + f b / 2)
  where h = (b - a) / fromIntegral n

-- è¾›æ™®æ£®æ³•åˆ™
simpsonRule :: (Double -> Double) -> Double -> Double -> Int -> Double
simpsonRule f a b n
  | odd n = error "è¾›æ™®æ£®æ³•åˆ™éœ€è¦å¶æ•°ä¸ªå­åŒºé—´"
  | otherwise = h/3 * (f a + 4*sum1 + 2*sum2 + f b)
  where
    h = (b - a) / fromIntegral n
    sum1 = sum [f (a + fromIntegral i * h) | i <- [1,3..n-1]]
    sum2 = sum [f (a + fromIntegral i * h) | i <- [2,4..n-2]]

-- è‡ªé€‚åº”ç§¯åˆ†
adaptiveIntegration :: (Double -> Double) -> Double -> Double -> Double -> Double
adaptiveIntegration f a b tolerance = go 10
  where
    go n = let
        current = simpsonRule f a b n
        next = simpsonRule f a b (2*n)
        in if abs (next - current) < tolerance
           then next
           else go (2*n)

-- é«˜æ–¯æ±‚ç§¯
gaussQuadrature :: (Double -> Double) -> Double -> Double -> Int -> Double
gaussQuadrature f a b n = (b-a)/2 * sum [w * f x | (x, w) <- zip points weights]
  where
    (points, weights) = gaussLegendrePointsWeights n
    points' = [(b-a)/2 * x + (a+b)/2 | x <- points]

gaussLegendrePointsWeights :: Int -> ([Double], [Double])
gaussLegendrePointsWeights 2 = ([-0.5773502691896257, 0.5773502691896257], [1.0, 1.0])
gaussLegendrePointsWeights 3 = ([-0.7745966692414834, 0.0, 0.7745966692414834],
                                [0.5555555555555556, 0.8888888888888888, 0.5555555555555556])
gaussLegendrePointsWeights 4 = ([-0.8611363115940526, -0.3399810435848563, 0.3399810435848563, 0.8611363115940526],
                                [0.3478548451374538, 0.6521451548625461, 0.6521451548625461, 0.3478548451374538])
gaussLegendrePointsWeights _ = error "ä»…æ”¯æŒ2-4ç‚¹é«˜æ–¯æ±‚ç§¯"

-- å¤šé‡ç§¯åˆ†
doubleIntegralRectangle :: (Double -> Double -> Double) -> Double -> Double -> Double -> Double -> Int -> Int -> Double
doubleIntegralRectangle f a b c d nx ny = hx * hy * sum [f x y | i <- [0..nx-1], j <- [0..ny-1]]
  where
    hx = (b - a) / fromIntegral nx
    hy = (d - c) / fromIntegral ny
    x = a + (fromIntegral i + 0.5) * hx
    y = c + (fromIntegral j + 0.5) * hy

-- ç¬¦å·ç§¯åˆ†
data Expression =
    Constant Double
  | Variable String
  | Add Expression Expression
  | Multiply Expression Expression
  | Power Expression Double
  | Sin Expression
  | Cos Expression
  | Exp Expression
  | Ln Expression

-- ç¬¦å·ç§¯åˆ†
integrate :: Expression -> Expression
integrate (Constant c) = Multiply (Constant c) (Variable "x")
integrate (Variable _) = Power (Variable "x") 2 / Constant 2
integrate (Add e1 e2) = Add (integrate e1) (integrate e2)
integrate (Multiply (Constant c) e) = Multiply (Constant c) (integrate e)
integrate (Power e n) = if n == -1
                        then Ln e
                        else Multiply (Power e (n + 1)) (Constant (1 / (n + 1)))
integrate (Sin e) = Multiply (Constant (-1)) (Cos e)
integrate (Cos e) = Sin e
integrate (Exp e) = Exp e
integrate (Ln e) = Multiply e (Ln e) - e

-- æµ‹è¯•å‡½æ•°
testIntegration :: IO ()
testIntegration = do
    let f x = x^2
    putStrLn "çŸ©å½¢æ³•åˆ™æµ‹è¯•:"
    print $ rectangleRule f 0 1 1000
    putStrLn "è¾›æ™®æ£®æ³•åˆ™æµ‹è¯•:"
    print $ simpsonRule f 0 1 1000
    putStrLn "é«˜æ–¯æ±‚ç§¯æµ‹è¯•:"
    print $ gaussQuadrature f 0 1 4
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 æ¦‚ç‡è®ºä¸­çš„åº”ç”¨

```rust
/// æ¦‚ç‡å¯†åº¦å‡½æ•°ç§¯åˆ†
pub struct ProbabilityIntegration;

impl ProbabilityIntegration {
    /// è®¡ç®—ç´¯ç§¯åˆ†å¸ƒå‡½æ•°
    pub fn cumulative_distribution<F>(pdf: F, a: f64, b: f64, tolerance: f64) -> f64
    where
        F: Fn(f64) -> f64,
    {
        NumericalIntegration::adaptive_integration(pdf, a, b, tolerance)
    }

    /// è®¡ç®—æœŸæœ›å€¼
    pub fn expected_value<F>(pdf: F, a: f64, b: f64, tolerance: f64) -> f64
    where
        F: Fn(f64) -> f64,
    {
        let integrand = |x: f64| x * pdf(x);
        NumericalIntegration::adaptive_integration(integrand, a, b, tolerance)
    }

    /// è®¡ç®—æ–¹å·®
    pub fn variance<F>(pdf: F, a: f64, b: f64, tolerance: f64) -> f64
    where
        F: Fn(f64) -> f64,
    {
        let mean = Self::expected_value(&pdf, a, b, tolerance);
        let integrand = |x: f64| (x - mean).powi(2) * pdf(x);
        NumericalIntegration::adaptive_integration(integrand, a, b, tolerance)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    // æ ‡å‡†æ­£æ€åˆ†å¸ƒçš„PDF
    let normal_pdf = |x: f64| (-x.powi(2) / 2.0).exp() / (2.0 * std::f64::consts::PI).sqrt();

    // è®¡ç®—ç´¯ç§¯åˆ†å¸ƒå‡½æ•° P(X â‰¤ 1)
    let cdf = ProbabilityIntegration::cumulative_distribution(normal_pdf, f64::NEG_INFINITY, 1.0, 1e-6);
    println!("P(X â‰¤ 1) = {}", cdf);

    // è®¡ç®—æœŸæœ›å€¼
    let mean = ProbabilityIntegration::expected_value(normal_pdf, f64::NEG_INFINITY, f64::INFINITY, 1e-6);
    println!("æœŸæœ›å€¼ = {}", mean);

    // è®¡ç®—æ–¹å·®
    let variance = ProbabilityIntegration::variance(normal_pdf, f64::NEG_INFINITY, f64::INFINITY, 1e-6);
    println!("æ–¹å·® = {}", variance);
}
```

### 5.2 ç‰©ç†å­¦ä¸­çš„åº”ç”¨

```rust
/// ç‰©ç†é‡è®¡ç®—
pub struct PhysicsIntegration;

impl PhysicsIntegration {
    /// è®¡ç®—è´¨å¿ƒ
    pub fn center_of_mass<F>(density: F, a: f64, b: f64, tolerance: f64) -> f64
    where
        F: Fn(f64) -> f64,
    {
        let mass = NumericalIntegration::adaptive_integration(&density, a, b, tolerance);
        let moment = NumericalIntegration::adaptive_integration(|x| x * density(x), a, b, tolerance);
        moment / mass
    }

    /// è®¡ç®—è½¬åŠ¨æƒ¯é‡
    pub fn moment_of_inertia<F>(density: F, a: f64, b: f64, tolerance: f64) -> f64
    where
        F: Fn(f64) -> f64,
    {
        let integrand = |x: f64| x.powi(2) * density(x);
        NumericalIntegration::adaptive_integration(integrand, a, b, tolerance)
    }

    /// è®¡ç®—åŠŸ
    pub fn work<F>(force: F, a: f64, b: f64, tolerance: f64) -> f64
    where
        F: Fn(f64) -> f64,
    {
        NumericalIntegration::adaptive_integration(force, a, b, tolerance)
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å¾®åˆ†å­¦çš„å…³ç³»

ç§¯åˆ†å­¦ä¸å¾®åˆ†å­¦é€šè¿‡å¾®ç§¯åˆ†åŸºæœ¬å®šç†ç´§å¯†è”ç³»ï¼Œå½¢æˆäº†å®Œæ•´çš„å¾®ç§¯åˆ†ç†è®ºä½“ç³»ã€‚

### 6.2 ä¸çº§æ•°çš„å…³ç³»

**å®šç† 6.2.1** (ç§¯åˆ†åˆ¤åˆ«æ³•)
è®¾ $f$ åœ¨ $[1, \infty)$ ä¸Šè¿ç»­ã€éè´Ÿã€é€’å‡ï¼Œåˆ™çº§æ•° $\sum_{n=1}^\infty f(n)$ æ”¶æ•›å½“ä¸”ä»…å½“ç§¯åˆ† $\int_1^\infty f(x) dx$ æ”¶æ•›ã€‚

### 6.3 ä¸å‚…é‡Œå¶åˆ†æçš„å…³ç³»

ç§¯åˆ†å­¦ä¸ºå‚…é‡Œå¶å˜æ¢æä¾›åŸºç¡€ï¼š

**å®šä¹‰ 6.3.1** (å‚…é‡Œå¶å˜æ¢)
å‡½æ•° $f$ çš„å‚…é‡Œå¶å˜æ¢å®šä¹‰ä¸ºï¼š
$$\hat{f}(\xi) = \int_{-\infty}^\infty f(x) e^{-2\pi i \xi x} dx$$

## 7. å‚è€ƒæ–‡çŒ®

1. **Rudin, W.** (1976). *Principles of Mathematical Analysis*. McGraw-Hill.
2. **Apostol, T. M.** (1974). *Mathematical Analysis*. Addison-Wesley.
3. **Spivak, M.** (2008). *Calculus*. Publish or Perish.
4. **Courant, R., & John, F.** (1999). *Introduction to Calculus and Analysis*. Springer.
5. **DieudonnÃ©, J.** (1969). *Foundations of Modern Analysis*. Academic Press.

---

**ç›¸å…³æ–‡æ¡£**:

- [02.9.1 æé™ç†è®º](../02.9.1_æé™ç†è®º.md)
- [02.9.2 è¿ç»­æ€§](../02.9.2_è¿ç»­æ€§.md)
- [02.9.3 å¾®åˆ†å­¦](../02.9.3_å¾®åˆ†å­¦.md)
- [02.4.1 å‡½æ•°æ¦‚å¿µ](../02.4.1_å‡½æ•°æ¦‚å¿µ.md)
- [02.4.2 å‡½æ•°æ€§è´¨](../02.4.2_å‡½æ•°æ€§è´¨.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
