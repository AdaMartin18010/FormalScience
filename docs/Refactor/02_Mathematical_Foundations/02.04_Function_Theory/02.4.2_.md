# 02.4.2 å‡½æ•°æ€§è´¨

## ğŸ“‹ æ¦‚è¿°

å‡½æ•°æ€§è´¨æ˜¯å‡½æ•°ç†è®ºçš„æ ¸å¿ƒå†…å®¹ï¼ŒåŒ…æ‹¬å•è°ƒæ€§ã€è¿ç»­æ€§ã€å¯å¾®æ€§ã€å‘¨æœŸæ€§ç­‰åŸºæœ¬æ€§è´¨ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦æ„å»ºå‡½æ•°æ€§è´¨çš„ç†è®ºæ¡†æ¶ï¼Œä¸ºåç»­çš„å‡½æ•°åˆ†æå’Œåº”ç”¨å¥ å®šåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹å‡½æ•°æ€§è´¨çš„å½¢å¼åŒ–åŸºç¡€**
2. **åˆ†æå‡½æ•°çš„åŸºæœ¬æ€§è´¨**
3. **æ¢è®¨å‡½æ•°æ€§è´¨çš„åˆ¤å®šæ–¹æ³•**
4. **ç ”ç©¶å‡½æ•°æ€§è´¨ä¹‹é—´çš„å…³ç³»**
5. **æ„å»ºå‡½æ•°æ€§è´¨çš„åº”ç”¨æ¡†æ¶**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å‡½æ•°æ€§è´¨çš„å®šä¹‰

å‡½æ•°æ€§è´¨æè¿°äº†å‡½æ•°åœ¨å®šä¹‰åŸŸå†…çš„è¡Œä¸ºç‰¹å¾ï¼ŒåŒ…æ‹¬ï¼š

- **å•è°ƒæ€§**ï¼šå‡½æ•°çš„å¢å‡æ€§è´¨
- **è¿ç»­æ€§**ï¼šå‡½æ•°çš„å…‰æ»‘ç¨‹åº¦
- **å¯å¾®æ€§**ï¼šå‡½æ•°çš„å¯å¯¼æ€§è´¨
- **å‘¨æœŸæ€§**ï¼šå‡½æ•°çš„é‡å¤æ€§è´¨
- **æœ‰ç•Œæ€§**ï¼šå‡½æ•°çš„å–å€¼èŒƒå›´

### 1.2 ä¸»è¦æ€§è´¨ç±»å‹

1. **ä»£æ•°æ€§è´¨**ï¼šå•è°ƒæ€§ã€å¥‡å¶æ€§ã€å‘¨æœŸæ€§
2. **åˆ†ææ€§è´¨**ï¼šè¿ç»­æ€§ã€å¯å¾®æ€§ã€å¯ç§¯æ€§
3. **æ‹“æ‰‘æ€§è´¨**ï¼šæœ‰ç•Œæ€§ã€ç´§è‡´æ€§ã€è¿é€šæ€§
4. **å‡ ä½•æ€§è´¨**ï¼šå‡¸æ€§ã€å‡¹æ€§ã€å¯¹ç§°æ€§

### 1.3 æ€§è´¨çš„é‡è¦æ€§

- **ç†è®ºä»·å€¼**ï¼šå‡½æ•°æ€§è´¨æ˜¯åˆ†æå­¦çš„åŸºç¡€
- **åº”ç”¨ä»·å€¼**ï¼šå‡½æ•°æ€§è´¨åœ¨å·¥ç¨‹ä¸­æœ‰å¹¿æ³›åº”ç”¨
- **è®¡ç®—ä»·å€¼**ï¼šå‡½æ•°æ€§è´¨å½±å“æ•°å€¼è®¡ç®—çš„æ•ˆç‡

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å•è°ƒæ€§

**å®šä¹‰ 2.1.1** (å•è°ƒé€’å¢)
å‡½æ•° $f: A \to \mathbb{R}$ åœ¨é›†åˆ $A$ ä¸Šå•è°ƒé€’å¢ï¼Œå½“ä¸”ä»…å½“ï¼š

$$\forall x_1, x_2 \in A: x_1 < x_2 \implies f(x_1) \leq f(x_2)$$

**å®šä¹‰ 2.1.2** (ä¸¥æ ¼å•è°ƒé€’å¢)
å‡½æ•° $f: A \to \mathbb{R}$ åœ¨é›†åˆ $A$ ä¸Šä¸¥æ ¼å•è°ƒé€’å¢ï¼Œå½“ä¸”ä»…å½“ï¼š

$$\forall x_1, x_2 \in A: x_1 < x_2 \implies f(x_1) < f(x_2)$$

**å®šä¹‰ 2.1.3** (å•è°ƒé€’å‡)
å‡½æ•° $f: A \to \mathbb{R}$ åœ¨é›†åˆ $A$ ä¸Šå•è°ƒé€’å‡ï¼Œå½“ä¸”ä»…å½“ï¼š

$$\forall x_1, x_2 \in A: x_1 < x_2 \implies f(x_1) \geq f(x_2)$$

### 2.2 è¿ç»­æ€§

**å®šä¹‰ 2.2.1** (è¿ç»­æ€§)
å‡½æ•° $f: A \to \mathbb{R}$ åœ¨ç‚¹ $a \in A$ è¿ç»­ï¼Œå½“ä¸”ä»…å½“ï¼š

$$\forall \varepsilon > 0, \exists \delta > 0: \forall x \in A: |x - a| < \delta \implies |f(x) - f(a)| < \varepsilon$$

**å®šä¹‰ 2.2.2** (ä¸€è‡´è¿ç»­æ€§)
å‡½æ•° $f: A \to \mathbb{R}$ åœ¨é›†åˆ $A$ ä¸Šä¸€è‡´è¿ç»­ï¼Œå½“ä¸”ä»…å½“ï¼š

$$\forall \varepsilon > 0, \exists \delta > 0: \forall x_1, x_2 \in A: |x_1 - x_2| < \delta \implies |f(x_1) - f(x_2)| < \varepsilon$$

### 2.3 å¯å¾®æ€§

**å®šä¹‰ 2.3.1** (å¯å¾®æ€§)
å‡½æ•° $f: A \to \mathbb{R}$ åœ¨ç‚¹ $a \in A$ å¯å¾®ï¼Œå½“ä¸”ä»…å½“æé™ï¼š

$$f'(a) = \lim_{h \to 0} \frac{f(a + h) - f(a)}{h}$$

å­˜åœ¨ä¸”æœ‰é™ã€‚

### 2.4 å‘¨æœŸæ€§

**å®šä¹‰ 2.4.1** (å‘¨æœŸæ€§)
å‡½æ•° $f: \mathbb{R} \to \mathbb{R}$ æ˜¯å‘¨æœŸå‡½æ•°ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨æ­£æ•° $T$ ä½¿å¾—ï¼š

$$\forall x \in \mathbb{R}: f(x + T) = f(x)$$

æœ€å°çš„æ­£æ•° $T$ ç§°ä¸ºå‡½æ•°çš„åŸºæœ¬å‘¨æœŸã€‚

### 2.5 æœ‰ç•Œæ€§

**å®šä¹‰ 2.5.1** (æœ‰ç•Œæ€§)
å‡½æ•° $f: A \to \mathbb{R}$ åœ¨é›†åˆ $A$ ä¸Šæœ‰ç•Œï¼Œå½“ä¸”ä»…å½“ï¼š

$$\exists M > 0: \forall x \in A: |f(x)| \leq M$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 å•è°ƒå‡½æ•°çš„æ€§è´¨

**å®šç† 3.1.1** (å•è°ƒå‡½æ•°çš„å¯é€†æ€§)
ä¸¥æ ¼å•è°ƒå‡½æ•°åœ¨å…¶å®šä¹‰åŸŸä¸Šæ˜¯ä¸€ä¸€å¯¹åº”çš„ã€‚

**è¯æ˜**ï¼š

1. å‡è®¾ $f$ ä¸¥æ ¼å•è°ƒé€’å¢
2. å¯¹äºä»»æ„ $x_1 \neq x_2$ï¼Œæœ‰ $f(x_1) \neq f(x_2)$
3. å› æ­¤ $f$ æ˜¯ä¸€ä¸€å¯¹åº”çš„
4. åŒç†å¯è¯ä¸¥æ ¼å•è°ƒé€’å‡çš„æƒ…å†µ

### 3.2 è¿ç»­å‡½æ•°çš„æ€§è´¨

**å®šç† 3.2.1** (è¿ç»­å‡½æ•°çš„ä»‹å€¼å®šç†)
è®¾ $f: [a, b] \to \mathbb{R}$ è¿ç»­ï¼Œä¸” $f(a) < f(b)$ï¼Œåˆ™å¯¹äºä»»æ„ $c \in (f(a), f(b))$ï¼Œå­˜åœ¨ $x \in (a, b)$ ä½¿å¾— $f(x) = c$ã€‚

**è¯æ˜**ï¼š

1. æ„é€ é›†åˆ $S = \{x \in [a, b] : f(x) < c\}$
2. $S$ éç©ºä¸”æœ‰ä¸Šç•Œ $b$
3. è®¾ $x_0 = \sup S$
4. è¯æ˜ $f(x_0) = c$

### 3.3 å¯å¾®å‡½æ•°çš„æ€§è´¨

**å®šç† 3.3.1** (å¯å¾®å‡½æ•°çš„å•è°ƒæ€§)
è®¾ $f: (a, b) \to \mathbb{R}$ å¯å¾®ï¼Œåˆ™ï¼š

1. $f'(x) \geq 0$ å¯¹æ‰€æœ‰ $x \in (a, b)$ å½“ä¸”ä»…å½“ $f$ å•è°ƒé€’å¢
2. $f'(x) > 0$ å¯¹æ‰€æœ‰ $x \in (a, b)$ å½“ä¸”ä»…å½“ $f$ ä¸¥æ ¼å•è°ƒé€’å¢

**è¯æ˜**ï¼š

1. ä½¿ç”¨æ‹‰æ ¼æœ—æ—¥ä¸­å€¼å®šç†
2. å¯¹äºä»»æ„ $x_1 < x_2$ï¼Œå­˜åœ¨ $c \in (x_1, x_2)$ ä½¿å¾—ï¼š
   $f(x_2) - f(x_1) = f'(c)(x_2 - x_1)$
3. æ ¹æ®å¯¼æ•°çš„ç¬¦å·åˆ¤æ–­å•è°ƒæ€§

### 3.4 å‘¨æœŸå‡½æ•°çš„æ€§è´¨

**å®šç† 3.4.1** (å‘¨æœŸå‡½æ•°çš„æ€§è´¨)
è®¾ $f$ æ˜¯å‘¨æœŸä¸º $T$ çš„å‡½æ•°ï¼Œåˆ™ï¼š

1. $f$ çš„å›¾åƒåœ¨ä»»æ„é•¿åº¦ä¸º $T$ çš„åŒºé—´ä¸Šé‡å¤
2. $f$ çš„ç§¯åˆ†åœ¨ä»»æ„é•¿åº¦ä¸º $T$ çš„åŒºé—´ä¸Šç›¸ç­‰
3. $f$ çš„å‚…é‡Œå¶çº§æ•°å…·æœ‰ç‰¹æ®Šå½¢å¼

**è¯æ˜**ï¼š

1. æ ¹æ®å‘¨æœŸæ€§å®šä¹‰ç›´æ¥å¾—åˆ°
2. ä½¿ç”¨ç§¯åˆ†çš„çº¿æ€§æ€§è´¨
3. ä½¿ç”¨å‚…é‡Œå¶çº§æ•°çš„æ€§è´¨

## 4. ä»£ç å®ç°

### 4.1 å‡½æ•°æ€§è´¨åˆ†æå™¨

```rust
use std::collections::HashMap;

/// å‡½æ•°æ€§è´¨
#[derive(Debug, Clone, PartialEq)]
pub enum FunctionProperty {
    MonotonicIncreasing,
    MonotonicDecreasing,
    StrictlyMonotonicIncreasing,
    StrictlyMonotonicDecreasing,
    Continuous,
    UniformlyContinuous,
    Differentiable,
    Periodic,
    Bounded,
    Even,
    Odd,
}

/// å‡½æ•°æ€§è´¨åˆ†æç»“æœ
#[derive(Debug, Clone)]
pub struct FunctionAnalysis {
    properties: Vec<FunctionProperty>,
    domain: (f64, f64),
    range: (f64, f64),
    period: Option<f64>,
    critical_points: Vec<f64>,
    inflection_points: Vec<f64>,
}

/// æ•°å€¼å‡½æ•°
pub struct NumericFunction {
    expression: String,
    domain: (f64, f64),
    samples: Vec<(f64, f64)>,
}

impl NumericFunction {
    /// åˆ›å»ºæ–°çš„æ•°å€¼å‡½æ•°
    pub fn new(expression: String, domain: (f64, f64)) -> Self {
        let mut samples = Vec::new();
        let step = (domain.1 - domain.0) / 1000.0;
        
        for i in 0..=1000 {
            let x = domain.0 + i as f64 * step;
            if let Ok(y) = Self::evaluate_expression(&expression, x) {
                samples.push((x, y));
            }
        }
        
        Self {
            expression,
            domain,
            samples,
        }
    }
    
    /// æ±‚å€¼å‡½æ•°
    fn evaluate_expression(expr: &str, x: f64) -> Result<f64, String> {
        match expr {
            "x^2" => Ok(x * x),
            "x^3" => Ok(x * x * x),
            "sin(x)" => Ok(x.sin()),
            "cos(x)" => Ok(x.cos()),
            "exp(x)" => Ok(x.exp()),
            "log(x)" => {
                if x <= 0.0 {
                    Err("å¯¹æ•°å‡½æ•°å®šä¹‰åŸŸé”™è¯¯".to_string())
                } else {
                    Ok(x.ln())
                }
            }
            "1/x" => {
                if x == 0.0 {
                    Err("é™¤é›¶é”™è¯¯".to_string())
                } else {
                    Ok(1.0 / x)
                }
            }
            _ => Err("ä¸æ”¯æŒçš„å‡½æ•°è¡¨è¾¾å¼".to_string()),
        }
    }
    
    /// åˆ†æå‡½æ•°æ€§è´¨
    pub fn analyze(&self) -> FunctionAnalysis {
        let mut properties = Vec::new();
        
        // æ£€æŸ¥å•è°ƒæ€§
        if self.is_monotonic_increasing() {
            properties.push(FunctionProperty::MonotonicIncreasing);
        }
        if self.is_strictly_monotonic_increasing() {
            properties.push(FunctionProperty::StrictlyMonotonicIncreasing);
        }
        if self.is_monotonic_decreasing() {
            properties.push(FunctionProperty::MonotonicDecreasing);
        }
        if self.is_strictly_monotonic_decreasing() {
            properties.push(FunctionProperty::StrictlyMonotonicDecreasing);
        }
        
        // æ£€æŸ¥è¿ç»­æ€§
        if self.is_continuous() {
            properties.push(FunctionProperty::Continuous);
        }
        if self.is_uniformly_continuous() {
            properties.push(FunctionProperty::UniformlyContinuous);
        }
        
        // æ£€æŸ¥å¯å¾®æ€§
        if self.is_differentiable() {
            properties.push(FunctionProperty::Differentiable);
        }
        
        // æ£€æŸ¥å‘¨æœŸæ€§
        if let Some(period) = self.find_period() {
            properties.push(FunctionProperty::Periodic);
        }
        
        // æ£€æŸ¥æœ‰ç•Œæ€§
        if self.is_bounded() {
            properties.push(FunctionProperty::Bounded);
        }
        
        // æ£€æŸ¥å¥‡å¶æ€§
        if self.is_even() {
            properties.push(FunctionProperty::Even);
        }
        if self.is_odd() {
            properties.push(FunctionProperty::Odd);
        }
        
        FunctionAnalysis {
            properties,
            domain: self.domain,
            range: self.find_range(),
            period: self.find_period(),
            critical_points: self.find_critical_points(),
            inflection_points: self.find_inflection_points(),
        }
    }
    
    /// æ£€æŸ¥å•è°ƒé€’å¢
    fn is_monotonic_increasing(&self) -> bool {
        for i in 1..self.samples.len() {
            if self.samples[i].1 < self.samples[i-1].1 {
                return false;
            }
        }
        true
    }
    
    /// æ£€æŸ¥ä¸¥æ ¼å•è°ƒé€’å¢
    fn is_strictly_monotonic_increasing(&self) -> bool {
        for i in 1..self.samples.len() {
            if self.samples[i].1 <= self.samples[i-1].1 {
                return false;
            }
        }
        true
    }
    
    /// æ£€æŸ¥å•è°ƒé€’å‡
    fn is_monotonic_decreasing(&self) -> bool {
        for i in 1..self.samples.len() {
            if self.samples[i].1 > self.samples[i-1].1 {
                return false;
            }
        }
        true
    }
    
    /// æ£€æŸ¥ä¸¥æ ¼å•è°ƒé€’å‡
    fn is_strictly_monotonic_decreasing(&self) -> bool {
        for i in 1..self.samples.len() {
            if self.samples[i].1 >= self.samples[i-1].1 {
                return false;
            }
        }
        true
    }
    
    /// æ£€æŸ¥è¿ç»­æ€§
    fn is_continuous(&self) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥ç›¸é‚»ç‚¹ä¹‹é—´çš„å·®å€¼
        for i in 1..self.samples.len() {
            let diff = (self.samples[i].1 - self.samples[i-1].1).abs();
            if diff > 1.0 {
                return false;
            }
        }
        true
    }
    
    /// æ£€æŸ¥ä¸€è‡´è¿ç»­æ€§
    fn is_uniformly_continuous(&self) -> bool {
        // ç®€åŒ–å®ç°ï¼šåŸºäºè¿ç»­æ€§å’Œæœ‰ç•Œæ€§
        self.is_continuous() && self.is_bounded()
    }
    
    /// æ£€æŸ¥å¯å¾®æ€§
    fn is_differentiable(&self) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥å¯¼æ•°æ˜¯å¦å­˜åœ¨
        match self.expression.as_str() {
            "x^2" | "x^3" | "sin(x)" | "cos(x)" | "exp(x)" => true,
            "log(x)" | "1/x" => false, // åœ¨æŸäº›ç‚¹ä¸å¯å¾®
            _ => false,
        }
    }
    
    /// æŸ¥æ‰¾å‘¨æœŸ
    fn find_period(&self) -> Option<f64> {
        match self.expression.as_str() {
            "sin(x)" | "cos(x)" => Some(2.0 * std::f64::consts::PI),
            _ => None,
        }
    }
    
    /// æ£€æŸ¥æœ‰ç•Œæ€§
    fn is_bounded(&self) -> bool {
        let (min_y, max_y) = self.find_range();
        min_y.is_finite() && max_y.is_finite()
    }
    
    /// æ£€æŸ¥å¶å‡½æ•°
    fn is_even(&self) -> bool {
        match self.expression.as_str() {
            "x^2" | "cos(x)" => true,
            _ => false,
        }
    }
    
    /// æ£€æŸ¥å¥‡å‡½æ•°
    fn is_odd(&self) -> bool {
        match self.expression.as_str() {
            "x^3" | "sin(x)" | "1/x" => true,
            _ => false,
        }
    }
    
    /// æŸ¥æ‰¾å€¼åŸŸ
    fn find_range(&self) -> (f64, f64) {
        let mut min_y = f64::INFINITY;
        let mut max_y = f64::NEG_INFINITY;
        
        for (_, y) in &self.samples {
            if y.is_finite() {
                min_y = min_y.min(*y);
                max_y = max_y.max(*y);
            }
        }
        
        (min_y, max_y)
    }
    
    /// æŸ¥æ‰¾ä¸´ç•Œç‚¹
    fn find_critical_points(&self) -> Vec<f64> {
        let mut critical_points = Vec::new();
        
        for i in 1..self.samples.len()-1 {
            let x = self.samples[i].0;
            let y_prev = self.samples[i-1].1;
            let y_curr = self.samples[i].1;
            let y_next = self.samples[i+1].1;
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºå±€éƒ¨æå€¼ç‚¹
            if (y_curr > y_prev && y_curr > y_next) || 
               (y_curr < y_prev && y_curr < y_next) {
                critical_points.push(x);
            }
        }
        
        critical_points
    }
    
    /// æŸ¥æ‰¾æ‹ç‚¹
    fn find_inflection_points(&self) -> Vec<f64> {
        let mut inflection_points = Vec::new();
        
        for i in 2..self.samples.len()-2 {
            let x = self.samples[i].0;
            let y_prev2 = self.samples[i-2].1;
            let y_prev1 = self.samples[i-1].1;
            let y_curr = self.samples[i].1;
            let y_next1 = self.samples[i+1].1;
            let y_next2 = self.samples[i+2].1;
            
            // æ£€æŸ¥äºŒé˜¶å¯¼æ•°çš„ç¬¦å·å˜åŒ–
            let second_deriv_prev = y_prev2 - 2.0 * y_prev1 + y_curr;
            let second_deriv_next = y_curr - 2.0 * y_next1 + y_next2;
            
            if second_deriv_prev * second_deriv_next < 0.0 {
                inflection_points.push(x);
            }
        }
        
        inflection_points
    }
}

/// å‡½æ•°æ€§è´¨æ¯”è¾ƒå™¨
pub struct FunctionPropertyComparator;

impl FunctionPropertyComparator {
    /// æ¯”è¾ƒä¸¤ä¸ªå‡½æ•°çš„æ€§è´¨
    pub fn compare(&self, f1: &NumericFunction, f2: &NumericFunction) -> FunctionComparison {
        let analysis1 = f1.analyze();
        let analysis2 = f2.analyze();
        
        let common_properties: Vec<_> = analysis1.properties.iter()
            .filter(|p| analysis2.properties.contains(p))
            .cloned()
            .collect();
        
        let unique_to_f1: Vec<_> = analysis1.properties.iter()
            .filter(|p| !analysis2.properties.contains(p))
            .cloned()
            .collect();
        
        let unique_to_f2: Vec<_> = analysis2.properties.iter()
            .filter(|p| !analysis1.properties.contains(p))
            .cloned()
            .collect();
        
        FunctionComparison {
            common_properties,
            unique_to_f1,
            unique_to_f2,
            similarity_score: self.calculate_similarity(&analysis1, &analysis2),
        }
    }
    
    /// è®¡ç®—ç›¸ä¼¼åº¦åˆ†æ•°
    fn calculate_similarity(&self, analysis1: &FunctionAnalysis, analysis2: &FunctionAnalysis) -> f64 {
        let total_properties = analysis1.properties.len() + analysis2.properties.len();
        if total_properties == 0 {
            return 1.0;
        }
        
        let common_count = analysis1.properties.iter()
            .filter(|p| analysis2.properties.contains(p))
            .count();
        
        2.0 * common_count as f64 / total_properties as f64
    }
}

/// å‡½æ•°æ¯”è¾ƒç»“æœ
#[derive(Debug, Clone)]
pub struct FunctionComparison {
    common_properties: Vec<FunctionProperty>,
    unique_to_f1: Vec<FunctionProperty>,
    unique_to_f2: Vec<FunctionProperty>,
    similarity_score: f64,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_monotonic_function() {
        let function = NumericFunction::new("x^2".to_string(), (-2.0, 2.0));
        let analysis = function.analyze();
        
        assert!(analysis.properties.contains(&FunctionProperty::Bounded));
    }

    #[test]
    fn test_periodic_function() {
        let function = NumericFunction::new("sin(x)".to_string(), (0.0, 4.0 * std::f64::consts::PI));
        let analysis = function.analyze();
        
        assert!(analysis.properties.contains(&FunctionProperty::Periodic));
        assert!(analysis.properties.contains(&FunctionProperty::Bounded));
    }

    #[test]
    fn test_function_comparison() {
        let f1 = NumericFunction::new("x^2".to_string(), (-2.0, 2.0));
        let f2 = NumericFunction::new("x^3".to_string(), (-2.0, 2.0));
        
        let comparator = FunctionPropertyComparator;
        let comparison = comparator.compare(&f1, &f2);
        
        assert!(comparison.similarity_score > 0.0);
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å‡½æ•°æ€§è´¨åˆ†æ

```rust
fn main() {
    // åˆ†æä¸åŒç±»å‹çš„å‡½æ•°
    let functions = vec![
        ("x^2", "äºŒæ¬¡å‡½æ•°"),
        ("x^3", "ä¸‰æ¬¡å‡½æ•°"),
        ("sin(x)", "æ­£å¼¦å‡½æ•°"),
        ("cos(x)", "ä½™å¼¦å‡½æ•°"),
        ("exp(x)", "æŒ‡æ•°å‡½æ•°"),
        ("log(x)", "å¯¹æ•°å‡½æ•°"),
    ];
    
    for (expression, name) in functions {
        let function = NumericFunction::new(expression.to_string(), (-5.0, 5.0));
        let analysis = function.analyze();
        
        println!("{} åˆ†æ:", name);
        println!("  æ€§è´¨: {:?}", analysis.properties);
        println!("  å€¼åŸŸ: {:?}", analysis.range);
        if let Some(period) = analysis.period {
            println!("  å‘¨æœŸ: {}", period);
        }
        println!("  ä¸´ç•Œç‚¹: {:?}", analysis.critical_points);
        println!();
    }
}
```

### 5.2 å‡½æ•°æ€§è´¨æ¯”è¾ƒ

```rust
fn compare_function_properties() {
    let comparator = FunctionPropertyComparator;
    
    // æ¯”è¾ƒç›¸ä¼¼å‡½æ•°
    let f1 = NumericFunction::new("x^2".to_string(), (-2.0, 2.0));
    let f2 = NumericFunction::new("x^4".to_string(), (-2.0, 2.0));
    
    let comparison = comparator.compare(&f1, &f2);
    
    println!("å‡½æ•°æ€§è´¨æ¯”è¾ƒ:");
    println!("å…±åŒæ€§è´¨: {:?}", comparison.common_properties);
    println!("f1ç‹¬æœ‰æ€§è´¨: {:?}", comparison.unique_to_f1);
    println!("f2ç‹¬æœ‰æ€§è´¨: {:?}", comparison.unique_to_f2);
    println!("ç›¸ä¼¼åº¦: {:.2}", comparison.similarity_score);
}
```

### 5.3 å‡½æ•°æ€§è´¨åº”ç”¨

```rust
fn apply_function_properties() {
    // åŸºäºå‡½æ•°æ€§è´¨è¿›è¡Œä¼˜åŒ–
    let function = NumericFunction::new("x^2".to_string(), (-10.0, 10.0));
    let analysis = function.analyze();
    
    if analysis.properties.contains(&FunctionProperty::MonotonicIncreasing) {
        println!("å‡½æ•°å•è°ƒé€’å¢ï¼Œå¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾ä¼˜åŒ–");
    }
    
    if analysis.properties.contains(&FunctionProperty::Periodic) {
        println!("å‡½æ•°å…·æœ‰å‘¨æœŸæ€§ï¼Œå¯ä»¥ç®€åŒ–è®¡ç®—");
    }
    
    if analysis.properties.contains(&FunctionProperty::Bounded) {
        println!("å‡½æ•°æœ‰ç•Œï¼Œæ•°å€¼è®¡ç®—ç¨³å®š");
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å¾®ç§¯åˆ†çš„å…³ç³»

- **å¯¼æ•°ç†è®º**ï¼šå‡½æ•°æ€§è´¨ä¸å¯¼æ•°çš„å…³ç³»
- **ç§¯åˆ†ç†è®º**ï¼šå‡½æ•°æ€§è´¨ä¸ç§¯åˆ†çš„æ€§è´¨
- **çº§æ•°ç†è®º**ï¼šå‡½æ•°æ€§è´¨ä¸çº§æ•°æ”¶æ•›æ€§

### 6.2 ä¸å®åˆ†æçš„å…³ç³»

- **æé™ç†è®º**ï¼šå‡½æ•°æ€§è´¨ä¸æé™çš„å…³ç³»
- **è¿ç»­æ€§ç†è®º**ï¼šè¿ç»­å‡½æ•°çš„æ€§è´¨
- **å¯æµ‹æ€§ç†è®º**ï¼šå¯æµ‹å‡½æ•°çš„æ€§è´¨

### 6.3 ä¸å¤åˆ†æçš„å…³ç³»

- **è§£æå‡½æ•°**ï¼šå¤å‡½æ•°çš„æ€§è´¨
- **è°ƒå’Œå‡½æ•°**ï¼šè°ƒå’Œå‡½æ•°çš„æ€§è´¨
- **å…¨çº¯å‡½æ•°**ï¼šå…¨çº¯å‡½æ•°çš„æ€§è´¨

### 6.4 ä¸æ³›å‡½åˆ†æçš„å…³ç³»

- **ç®—å­ç†è®º**ï¼šçº¿æ€§ç®—å­çš„æ€§è´¨
- **ç©ºé—´ç†è®º**ï¼šå‡½æ•°ç©ºé—´çš„æ€§è´¨
- **è°±ç†è®º**ï¼šç®—å­çš„è°±æ€§è´¨

## 7. å‚è€ƒæ–‡çŒ®

1. **Rudin, W.** (1976). *Principles of Mathematical Analysis*. McGraw-Hill.
2. **Apostol, T.** (1974). *Mathematical Analysis*. Addison-Wesley.
3. **Spivak, M.** (2006). *Calculus*. Cambridge University Press.
4. **Stewart, J.** (2015). *Calculus: Early Transcendentals*. Cengage Learning.
5. **Courant, R., John, F.** (1999). *Introduction to Calculus and Analysis*. Springer.
6. **Lang, S.** (1997). *Undergraduate Analysis*. Springer.
7. **Bartle, R., Sherbert, D.** (2011). *Introduction to Real Analysis*. Wiley.
8. **Royden, H., Fitzpatrick, P.** (2010). *Real Analysis*. Pearson.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.4.1 å‡½æ•°æ¦‚å¿µ](02.4.1_å‡½æ•°æ¦‚å¿µ.md)
- [02.4.3 å‡½æ•°è¿ç®—](../02_Mathematical_Foundation/02.4.3_å‡½æ•°è¿ç®—.md)
- [02.4.4 å‡½æ•°åˆ†ç±»](../02_Mathematical_Foundation/02.4.4_å‡½æ•°åˆ†ç±».md)
- [02.9.1 æé™ç†è®º](../02_Mathematical_Foundation/02.9.1_æé™ç†è®º.md)
- [02.9.2 è¿ç»­æ€§](../02_Mathematical_Foundation/02.9.2_è¿ç»­æ€§.md)
- [02.9.3 å¾®åˆ†å­¦](../02_Mathematical_Foundation/02.9.3_å¾®åˆ†å­¦.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
