# 02.4.4 å‡½æ•°åˆ†ç±»

## ğŸ“‹ æ¦‚è¿°

**æ–‡æ¡£ç¼–å·**: 02.4.4  
**æ–‡æ¡£æ ‡é¢˜**: å‡½æ•°åˆ†ç±»  
**æ‰€å±æ¨¡å—**: 02. æ•°å­¦åŸºç¡€ç†è®º â†’ 02.4 å‡½æ•°è®ºåŸºç¡€  
**åˆ›å»ºæ—¶é—´**: 2024-12-21  
**ç»´æŠ¤çŠ¶æ€**: æŒç»­æ„å»ºä¸­  

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

å»ºç«‹ä¸¥æ ¼çš„å‡½æ•°åˆ†ç±»ç†è®ºä½“ç³»ï¼Œä¸ºå‡½æ•°è®ºæä¾›ç³»ç»ŸåŒ–çš„åˆ†ç±»æ¡†æ¶ã€‚

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å‡½æ•°åˆ†ç±»çš„åŸºæœ¬æ€æƒ³

å‡½æ•°åˆ†ç±»æ˜¯å‡½æ•°è®ºä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå®ƒåŸºäºå‡½æ•°çš„å„ç§æ€§è´¨å°†å‡½æ•°åˆ’åˆ†ä¸ºä¸åŒçš„ç±»åˆ«ã€‚

**å®šä¹‰ 1.1.1** (å‡½æ•°åˆ†ç±»)
è®¾ $f: A \to B$ æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå‡½æ•°åˆ†ç±»æ˜¯åŸºäº $f$ çš„ç‰¹å®šæ€§è´¨å°†å…¶å½’å…¥æŸä¸ªå‡½æ•°ç±»åˆ«çš„è¿‡ç¨‹ã€‚

### 1.2 åˆ†ç±»æ ‡å‡†

å‡½æ•°åˆ†ç±»çš„ä¸»è¦æ ‡å‡†åŒ…æ‹¬ï¼š

1. **æ˜ å°„æ€§è´¨**: å•å°„ã€æ»¡å°„ã€åŒå°„
2. **å®šä¹‰åŸŸæ€§è´¨**: æœ‰é™ã€å¯æ•°ã€ä¸å¯æ•°
3. **å€¼åŸŸæ€§è´¨**: æœ‰é™ã€å¯æ•°ã€ä¸å¯æ•°
4. **è¿ç»­æ€§**: è¿ç»­ã€é—´æ–­
5. **å¯å¾®æ€§**: å¯å¾®ã€ä¸å¯å¾®
6. **å•è°ƒæ€§**: å•è°ƒé€’å¢ã€å•è°ƒé€’å‡
7. **å‘¨æœŸæ€§**: å‘¨æœŸå‡½æ•°ã€éå‘¨æœŸå‡½æ•°
8. **å¥‡å¶æ€§**: å¥‡å‡½æ•°ã€å¶å‡½æ•°

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 åŸºäºæ˜ å°„æ€§è´¨çš„åˆ†ç±»

**å®šä¹‰ 2.1.1** (å•å°„å‡½æ•°)
å‡½æ•° $f: A \to B$ ç§°ä¸ºå•å°„å‡½æ•°ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall x_1, x_2 \in A: f(x_1) = f(x_2) \Rightarrow x_1 = x_2$$

**å®šä¹‰ 2.1.2** (æ»¡å°„å‡½æ•°)
å‡½æ•° $f: A \to B$ ç§°ä¸ºæ»¡å°„å‡½æ•°ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall y \in B, \exists x \in A: f(x) = y$$

**å®šä¹‰ 2.1.3** (åŒå°„å‡½æ•°)
å‡½æ•° $f: A \to B$ ç§°ä¸ºåŒå°„å‡½æ•°ï¼Œå½“ä¸”ä»…å½“ $f$ æ—¢æ˜¯å•å°„åˆæ˜¯æ»¡å°„ã€‚

### 2.2 åŸºäºè¿ç»­æ€§çš„åˆ†ç±»

**å®šä¹‰ 2.2.1** (è¿ç»­å‡½æ•°)
è®¾ $f: \mathbb{R} \to \mathbb{R}$ï¼Œ$f$ åœ¨ç‚¹ $a \in \mathbb{R}$ è¿ç»­ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall \varepsilon > 0, \exists \delta > 0: |x - a| < \delta \Rightarrow |f(x) - f(a)| < \varepsilon$$

**å®šä¹‰ 2.2.2** (ä¸€è‡´è¿ç»­å‡½æ•°)
å‡½æ•° $f: \mathbb{R} \to \mathbb{R}$ ç§°ä¸ºä¸€è‡´è¿ç»­ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall \varepsilon > 0, \exists \delta > 0: \forall x, y \in \mathbb{R}, |x - y| < \delta \Rightarrow |f(x) - f(y)| < \varepsilon$$

### 2.3 åŸºäºå¯å¾®æ€§çš„åˆ†ç±»

**å®šä¹‰ 2.3.1** (å¯å¾®å‡½æ•°)
å‡½æ•° $f: \mathbb{R} \to \mathbb{R}$ åœ¨ç‚¹ $a \in \mathbb{R}$ å¯å¾®ï¼Œå½“ä¸”ä»…å½“æé™ï¼š
$$\lim_{h \to 0} \frac{f(a + h) - f(a)}{h}$$
å­˜åœ¨ä¸”æœ‰é™ã€‚

**å®šä¹‰ 2.3.2** (å…‰æ»‘å‡½æ•°)
å‡½æ•° $f: \mathbb{R} \to \mathbb{R}$ ç§°ä¸º $C^n$ ç±»å‡½æ•°ï¼Œå½“ä¸”ä»…å½“ $f$ çš„ $n$ é˜¶å¯¼æ•°å­˜åœ¨ä¸”è¿ç»­ã€‚

### 2.4 åŸºäºå•è°ƒæ€§çš„åˆ†ç±»

**å®šä¹‰ 2.4.1** (å•è°ƒé€’å¢å‡½æ•°)
å‡½æ•° $f: A \to \mathbb{R}$ ç§°ä¸ºå•è°ƒé€’å¢ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall x_1, x_2 \in A: x_1 < x_2 \Rightarrow f(x_1) \leq f(x_2)$$

**å®šä¹‰ 2.4.2** (ä¸¥æ ¼å•è°ƒé€’å¢å‡½æ•°)
å‡½æ•° $f: A \to \mathbb{R}$ ç§°ä¸ºä¸¥æ ¼å•è°ƒé€’å¢ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall x_1, x_2 \in A: x_1 < x_2 \Rightarrow f(x_1) < f(x_2)$$

### 2.5 åŸºäºå‘¨æœŸæ€§çš„åˆ†ç±»

**å®šä¹‰ 2.5.1** (å‘¨æœŸå‡½æ•°)
å‡½æ•° $f: \mathbb{R} \to \mathbb{R}$ ç§°ä¸ºå‘¨æœŸå‡½æ•°ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨ $T > 0$ï¼Œä½¿å¾—ï¼š
$$\forall x \in \mathbb{R}: f(x + T) = f(x)$$

**å®šä¹‰ 2.5.2** (åŸºæœ¬å‘¨æœŸ)
å‘¨æœŸå‡½æ•° $f$ çš„æœ€å°æ­£å‘¨æœŸç§°ä¸º $f$ çš„åŸºæœ¬å‘¨æœŸã€‚

### 2.6 åŸºäºå¥‡å¶æ€§çš„åˆ†ç±»

**å®šä¹‰ 2.6.1** (å¶å‡½æ•°)
å‡½æ•° $f: \mathbb{R} \to \mathbb{R}$ ç§°ä¸ºå¶å‡½æ•°ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall x \in \mathbb{R}: f(-x) = f(x)$$

**å®šä¹‰ 2.6.2** (å¥‡å‡½æ•°)
å‡½æ•° $f: \mathbb{R} \to \mathbb{R}$ ç§°ä¸ºå¥‡å‡½æ•°ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall x \in \mathbb{R}: f(-x) = -f(x)$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 å‡½æ•°åˆ†ç±»çš„åŸºæœ¬å®šç†

**å®šç† 3.1.1** (å‡½æ•°åˆ†ç±»çš„å”¯ä¸€æ€§)
è®¾ $f: A \to B$ æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œåˆ™ $f$ åœ¨ä»»æ„åˆ†ç±»æ ‡å‡†ä¸‹çš„ç±»åˆ«æ˜¯å”¯ä¸€ç¡®å®šçš„ã€‚

**è¯æ˜**:
å‡è®¾ $f$ åœ¨æŸä¸ªåˆ†ç±»æ ‡å‡†ä¸‹å±äºä¸¤ä¸ªä¸åŒçš„ç±»åˆ« $C_1$ å’Œ $C_2$ã€‚
æ ¹æ®åˆ†ç±»çš„å®šä¹‰ï¼Œ$C_1$ å’Œ $C_2$ æ˜¯äº’æ–¥çš„é›†åˆã€‚
å› æ­¤ï¼Œ$f$ ä¸å¯èƒ½åŒæ—¶å±äº $C_1$ å’Œ $C_2$ï¼ŒçŸ›ç›¾ã€‚
å› æ­¤ï¼Œ$f$ åœ¨ä»»æ„åˆ†ç±»æ ‡å‡†ä¸‹çš„ç±»åˆ«æ˜¯å”¯ä¸€ç¡®å®šçš„ã€‚

**å®šç† 3.1.2** (åŒå°„å‡½æ•°çš„é€†å‡½æ•°å­˜åœ¨æ€§)
è®¾ $f: A \to B$ æ˜¯åŒå°„å‡½æ•°ï¼Œåˆ™å­˜åœ¨å”¯ä¸€çš„é€†å‡½æ•° $f^{-1}: B \to A$ã€‚

**è¯æ˜**:
ç”±äº $f$ æ˜¯åŒå°„å‡½æ•°ï¼Œå¯¹äºä»»æ„ $y \in B$ï¼Œå­˜åœ¨å”¯ä¸€çš„ $x \in A$ ä½¿å¾— $f(x) = y$ã€‚
å®šä¹‰ $f^{-1}: B \to A$ ä¸º $f^{-1}(y) = x$ï¼Œå…¶ä¸­ $f(x) = y$ã€‚
å®¹æ˜“éªŒè¯ $f^{-1}$ æ»¡è¶³é€†å‡½æ•°çš„å®šä¹‰ï¼š

- $f \circ f^{-1} = \text{id}_B$
- $f^{-1} \circ f = \text{id}_A$

**å®šç† 3.1.3** (è¿ç»­å‡½æ•°çš„æ€§è´¨)
è®¾ $f, g: \mathbb{R} \to \mathbb{R}$ æ˜¯è¿ç»­å‡½æ•°ï¼Œåˆ™ï¼š

1. $f + g$ æ˜¯è¿ç»­å‡½æ•°
2. $f \cdot g$ æ˜¯è¿ç»­å‡½æ•°
3. $f \circ g$ æ˜¯è¿ç»­å‡½æ•°

**è¯æ˜**:

1. å¯¹äºä»»æ„ $a \in \mathbb{R}$ï¼Œç”±äº $f$ å’Œ $g$ åœ¨ $a$ ç‚¹è¿ç»­ï¼Œæœ‰ï¼š
   $$\lim_{x \to a} f(x) = f(a), \lim_{x \to a} g(x) = g(a)$$
   å› æ­¤ï¼š
   $$\lim_{x \to a} (f + g)(x) = \lim_{x \to a} f(x) + \lim_{x \to a} g(x) = f(a) + g(a) = (f + g)(a)$$
   æ‰€ä»¥ $f + g$ åœ¨ $a$ ç‚¹è¿ç»­ã€‚

2. ç±»ä¼¼åœ°ï¼Œå¯ä»¥è¯æ˜ $f \cdot g$ çš„è¿ç»­æ€§ã€‚

3. å¯¹äºå¤åˆå‡½æ•° $f \circ g$ï¼Œç”±äº $g$ åœ¨ $a$ ç‚¹è¿ç»­ï¼Œ$f$ åœ¨ $g(a)$ ç‚¹è¿ç»­ï¼Œæ ¹æ®å¤åˆå‡½æ•°çš„è¿ç»­æ€§å®šç†ï¼Œ$f \circ g$ åœ¨ $a$ ç‚¹è¿ç»­ã€‚

### 3.2 å‡½æ•°åˆ†ç±»çš„å±‚æ¬¡ç»“æ„

**å®šç† 3.2.1** (å‡½æ•°åˆ†ç±»çš„å±‚æ¬¡æ€§)
å‡½æ•°åˆ†ç±»å…·æœ‰å±‚æ¬¡ç»“æ„ï¼Œå³ä¸€ä¸ªå‡½æ•°å¯ä»¥åŒæ—¶å±äºå¤šä¸ªä¸åŒå±‚æ¬¡çš„ç±»åˆ«ã€‚

**è¯æ˜**:
è€ƒè™‘å‡½æ•° $f(x) = x^2$ï¼š

1. åœ¨æ˜ å°„æ€§è´¨å±‚æ¬¡ï¼š$f$ ä¸æ˜¯å•å°„ï¼ˆå› ä¸º $f(-1) = f(1) = 1$ï¼‰ï¼Œä½†å¯ä»¥æ˜¯æ»¡å°„ï¼ˆå¦‚æœå®šä¹‰åŸŸå’Œå€¼åŸŸé€‚å½“é€‰æ‹©ï¼‰
2. åœ¨è¿ç»­æ€§å±‚æ¬¡ï¼š$f$ æ˜¯è¿ç»­å‡½æ•°
3. åœ¨å¯å¾®æ€§å±‚æ¬¡ï¼š$f$ æ˜¯å¯å¾®å‡½æ•°
4. åœ¨å•è°ƒæ€§å±‚æ¬¡ï¼š$f$ åœ¨ $(-\infty, 0]$ ä¸Šå•è°ƒé€’å‡ï¼Œåœ¨ $[0, +\infty)$ ä¸Šå•è°ƒé€’å¢
5. åœ¨å¥‡å¶æ€§å±‚æ¬¡ï¼š$f$ æ˜¯å¶å‡½æ•°

è¿™è¯æ˜äº†å‡½æ•°åˆ†ç±»çš„å±‚æ¬¡æ€§ã€‚

## 4. ä»£ç å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::HashMap;

/// å‡½æ•°åˆ†ç±»æšä¸¾
#[derive(Debug, Clone, PartialEq)]
pub enum FunctionType {
    /// å•å°„å‡½æ•°
    Injective,
    /// æ»¡å°„å‡½æ•°
    Surjective,
    /// åŒå°„å‡½æ•°
    Bijective,
    /// è¿ç»­å‡½æ•°
    Continuous,
    /// å¯å¾®å‡½æ•°
    Differentiable,
    /// å•è°ƒé€’å¢å‡½æ•°
    MonotonicIncreasing,
    /// å•è°ƒé€’å‡å‡½æ•°
    MonotonicDecreasing,
    /// å‘¨æœŸå‡½æ•°
    Periodic(f64), // å‘¨æœŸå€¼
    /// å¶å‡½æ•°
    Even,
    /// å¥‡å‡½æ•°
    Odd,
}

/// å‡½æ•°åˆ†ç±»å™¨
pub struct FunctionClassifier {
    /// å‡½æ•°å®šä¹‰åŸŸ
    domain: Vec<f64>,
    /// å‡½æ•°å€¼åŸŸ
    codomain: Vec<f64>,
    /// å‡½æ•°æ˜ å°„
    mapping: HashMap<f64, f64>,
}

impl FunctionClassifier {
    /// åˆ›å»ºæ–°çš„å‡½æ•°åˆ†ç±»å™¨
    pub fn new(domain: Vec<f64>, codomain: Vec<f64>) -> Self {
        Self {
            domain,
            codomain,
            mapping: HashMap::new(),
        }
    }

    /// æ·»åŠ å‡½æ•°æ˜ å°„
    pub fn add_mapping(&mut self, x: f64, y: f64) {
        self.mapping.insert(x, y);
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºå•å°„å‡½æ•°
    pub fn is_injective(&self) -> bool {
        let mut seen_values = std::collections::HashSet::new();
        for &y in self.mapping.values() {
            if !seen_values.insert(y) {
                return false;
            }
        }
        true
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºæ»¡å°„å‡½æ•°
    pub fn is_surjective(&self) -> bool {
        let mapped_values: std::collections::HashSet<_> = self.mapping.values().cloned().collect();
        let codomain_set: std::collections::HashSet<_> = self.codomain.iter().cloned().collect();
        mapped_values == codomain_set
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºåŒå°„å‡½æ•°
    pub fn is_bijective(&self) -> bool {
        self.is_injective() && self.is_surjective()
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºå¶å‡½æ•°
    pub fn is_even(&self) -> bool {
        for (&x, &y) in &self.mapping {
            if let Some(&neg_y) = self.mapping.get(&(-x)) {
                if (y - neg_y).abs() > f64::EPSILON {
                    return false;
                }
            }
        }
        true
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºå¥‡å‡½æ•°
    pub fn is_odd(&self) -> bool {
        for (&x, &y) in &self.mapping {
            if let Some(&neg_y) = self.mapping.get(&(-x)) {
                if (y + neg_y).abs() > f64::EPSILON {
                    return false;
                }
            }
        }
        true
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºå‘¨æœŸå‡½æ•°
    pub fn is_periodic(&self) -> Option<f64> {
        // ç®€åŒ–çš„å‘¨æœŸæ£€æµ‹ç®—æ³•
        let values: Vec<_> = self.mapping.values().cloned().collect();
        if values.len() < 2 {
            return None;
        }

        for period in 1..=values.len() / 2 {
            let mut is_periodic = true;
            for i in 0..values.len() - period {
                if (values[i] - values[i + period]).abs() > f64::EPSILON {
                    is_periodic = false;
                    break;
                }
            }
            if is_periodic {
                return Some(period as f64);
            }
        }
        None
    }

    /// è·å–å‡½æ•°çš„æ‰€æœ‰åˆ†ç±»
    pub fn classify(&self) -> Vec<FunctionType> {
        let mut classifications = Vec::new();

        if self.is_injective() {
            classifications.push(FunctionType::Injective);
        }
        if self.is_surjective() {
            classifications.push(FunctionType::Surjective);
        }
        if self.is_bijective() {
            classifications.push(FunctionType::Bijective);
        }
        if self.is_even() {
            classifications.push(FunctionType::Even);
        }
        if self.is_odd() {
            classifications.push(FunctionType::Odd);
        }
        if let Some(period) = self.is_periodic() {
            classifications.push(FunctionType::Periodic(period));
        }

        classifications
    }
}

/// æ•°å­¦å‡½æ•°å®ç°
pub mod math_functions {
    use super::*;

    /// çº¿æ€§å‡½æ•° f(x) = ax + b
    pub struct LinearFunction {
        pub a: f64,
        pub b: f64,
    }

    impl LinearFunction {
        pub fn new(a: f64, b: f64) -> Self {
            Self { a, b }
        }

        pub fn evaluate(&self, x: f64) -> f64 {
            self.a * x + self.b
        }

        pub fn classify(&self) -> Vec<FunctionType> {
            let mut classifications = vec![FunctionType::Continuous, FunctionType::Differentiable];
            
            if self.a > 0.0 {
                classifications.push(FunctionType::MonotonicIncreasing);
            } else if self.a < 0.0 {
                classifications.push(FunctionType::MonotonicDecreasing);
            }
            
            if self.a != 0.0 {
                classifications.push(FunctionType::Bijective);
            }
            
            if self.b == 0.0 {
                classifications.push(FunctionType::Odd);
            }
            
            classifications
        }
    }

    /// äºŒæ¬¡å‡½æ•° f(x) = axÂ² + bx + c
    pub struct QuadraticFunction {
        pub a: f64,
        pub b: f64,
        pub c: f64,
    }

    impl QuadraticFunction {
        pub fn new(a: f64, b: f64, c: f64) -> Self {
            Self { a, b, c }
        }

        pub fn evaluate(&self, x: f64) -> f64 {
            self.a * x * x + self.b * x + self.c
        }

        pub fn classify(&self) -> Vec<FunctionType> {
            let mut classifications = vec![FunctionType::Continuous, FunctionType::Differentiable];
            
            if self.b == 0.0 {
                classifications.push(FunctionType::Even);
            }
            
            classifications
        }
    }

    /// ä¸‰è§’å‡½æ•° sin(x)
    pub struct SineFunction;

    impl SineFunction {
        pub fn evaluate(&self, x: f64) -> f64 {
            x.sin()
        }

        pub fn classify(&self) -> Vec<FunctionType> {
            vec![
                FunctionType::Continuous,
                FunctionType::Differentiable,
                FunctionType::Periodic(2.0 * std::f64::consts::PI),
                FunctionType::Odd,
            ]
        }
    }

    /// ä¸‰è§’å‡½æ•° cos(x)
    pub struct CosineFunction;

    impl CosineFunction {
        pub fn evaluate(&self, x: f64) -> f64 {
            x.cos()
        }

        pub fn classify(&self) -> Vec<FunctionType> {
            vec![
                FunctionType::Continuous,
                FunctionType::Differentiable,
                FunctionType::Periodic(2.0 * std::f64::consts::PI),
                FunctionType::Even,
            ]
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use math_functions::*;

    #[test]
    fn test_linear_function_classification() {
        let f = LinearFunction::new(2.0, 0.0);
        let classifications = f.classify();
        
        assert!(classifications.contains(&FunctionType::Continuous));
        assert!(classifications.contains(&FunctionType::Differentiable));
        assert!(classifications.contains(&FunctionType::MonotonicIncreasing));
        assert!(classifications.contains(&FunctionType::Bijective));
        assert!(classifications.contains(&FunctionType::Odd));
    }

    #[test]
    fn test_quadratic_function_classification() {
        let f = QuadraticFunction::new(1.0, 0.0, 0.0);
        let classifications = f.classify();
        
        assert!(classifications.contains(&FunctionType::Continuous));
        assert!(classifications.contains(&FunctionType::Differentiable));
        assert!(classifications.contains(&FunctionType::Even));
    }

    #[test]
    fn test_sine_function_classification() {
        let f = SineFunction;
        let classifications = f.classify();
        
        assert!(classifications.contains(&FunctionType::Continuous));
        assert!(classifications.contains(&FunctionType::Differentiable));
        assert!(classifications.contains(&FunctionType::Odd));
        
        if let Some(FunctionType::Periodic(period)) = classifications.iter().find(|&&ref c| matches!(c, FunctionType::Periodic(_))) {
            assert!((period - 2.0 * std::f64::consts::PI).abs() < f64::EPSILON);
        }
    }

    #[test]
    fn test_function_classifier() {
        let mut classifier = FunctionClassifier::new(
            vec![-2.0, -1.0, 0.0, 1.0, 2.0],
            vec![4.0, 1.0, 0.0, 1.0, 4.0],
        );
        
        classifier.add_mapping(-2.0, 4.0);
        classifier.add_mapping(-1.0, 1.0);
        classifier.add_mapping(0.0, 0.0);
        classifier.add_mapping(1.0, 1.0);
        classifier.add_mapping(2.0, 4.0);
        
        let classifications = classifier.classify();
        assert!(classifications.contains(&FunctionType::Even));
    }
}
```

### 4.2 Haskell å®ç°

```haskell
-- å‡½æ•°åˆ†ç±»ç±»å‹
data FunctionType = Injective
                  | Surjective
                  | Bijective
                  | Continuous
                  | Differentiable
                  | MonotonicIncreasing
                  | MonotonicDecreasing
                  | Periodic Double
                  | Even
                  | Odd
                  deriving (Eq, Show)

-- å‡½æ•°åˆ†ç±»å™¨
data FunctionClassifier = FunctionClassifier
    { domain :: [Double]
    , codomain :: [Double]
    , mapping :: [(Double, Double)]
    }

-- åˆ›å»ºå‡½æ•°åˆ†ç±»å™¨
createClassifier :: [Double] -> [Double] -> FunctionClassifier
createClassifier dom cod = FunctionClassifier dom cod []

-- æ·»åŠ æ˜ å°„
addMapping :: FunctionClassifier -> Double -> Double -> FunctionClassifier
addMapping fc x y = fc { mapping = (x, y) : mapping fc }

-- æ£€æŸ¥å•å°„
isInjective :: FunctionClassifier -> Bool
isInjective fc = length (map snd (mapping fc)) == length (nub (map snd (mapping fc)))

-- æ£€æŸ¥æ»¡å°„
isSurjective :: FunctionClassifier -> Bool
isSurjective fc = all (`elem` map snd (mapping fc)) (codomain fc)

-- æ£€æŸ¥åŒå°„
isBijective :: FunctionClassifier -> Bool
isBijective fc = isInjective fc && isSurjective fc

-- æ£€æŸ¥å¶å‡½æ•°
isEven :: FunctionClassifier -> Bool
isEven fc = all (\x -> any (\(x', y') -> x' == -x && abs (y - y') < epsilon) (mapping fc))
                [x | (x, _) <- mapping fc, x /= 0]
  where
    epsilon = 1e-10
    y = snd (head (mapping fc))

-- æ£€æŸ¥å¥‡å‡½æ•°
isOdd :: FunctionClassifier -> Bool
isOdd fc = all (\x -> any (\(x', y') -> x' == -x && abs (y + y') < epsilon) (mapping fc))
               [x | (x, _) <- mapping fc, x /= 0]
  where
    epsilon = 1e-10
    y = snd (head (mapping fc))

-- æ£€æŸ¥å‘¨æœŸæ€§
isPeriodic :: FunctionClassifier -> Maybe Double
isPeriodic fc = findPeriod (map snd (mapping fc))
  where
    findPeriod values
        | length values < 2 = Nothing
        | otherwise = findPeriod' values 1
      where
        findPeriod' values period
            | period > length values `div` 2 = Nothing
            | isPeriodicWithPeriod values period = Just (fromIntegral period)
            | otherwise = findPeriod' values (period + 1)
        
        isPeriodicWithPeriod values period =
            all (\i -> abs (values !! i - values !! (i + period)) < epsilon)
                [0..length values - period - 1]
          where
            epsilon = 1e-10

-- è·å–æ‰€æœ‰åˆ†ç±»
classify :: FunctionClassifier -> [FunctionType]
classify fc = concat
    [ if isInjective fc then [Injective] else []
    , if isSurjective fc then [Surjective] else []
    , if isBijective fc then [Bijective] else []
    , if isEven fc then [Even] else []
    , if isOdd fc then [Odd] else []
    , maybe [] (\p -> [Periodic p]) (isPeriodic fc)
    ]

-- æ•°å­¦å‡½æ•°ç±»å‹ç±»
class MathFunction f where
    evaluate :: f -> Double -> Double
    classify :: f -> [FunctionType]

-- çº¿æ€§å‡½æ•°
data LinearFunction = LinearFunction Double Double

instance MathFunction LinearFunction where
    evaluate (LinearFunction a b) x = a * x + b
    
    classify (LinearFunction a b) = concat
        [ [Continuous, Differentiable]
        , if a > 0 then [MonotonicIncreasing] else []
        , if a < 0 then [MonotonicDecreasing] else []
        , if a /= 0 then [Bijective] else []
        , if b == 0 then [Odd] else []
        ]

-- äºŒæ¬¡å‡½æ•°
data QuadraticFunction = QuadraticFunction Double Double Double

instance MathFunction QuadraticFunction where
    evaluate (QuadraticFunction a b c) x = a * x * x + b * x + c
    
    classify (QuadraticFunction a b c) = concat
        [ [Continuous, Differentiable]
        , if b == 0 then [Even] else []
        ]

-- æ­£å¼¦å‡½æ•°
data SineFunction = SineFunction

instance MathFunction SineFunction where
    evaluate SineFunction x = sin x
    
    classify SineFunction = [Continuous, Differentiable, Periodic (2 * pi), Odd]

-- ä½™å¼¦å‡½æ•°
data CosineFunction = CosineFunction

instance MathFunction CosineFunction where
    evaluate CosineFunction x = cos x
    
    classify CosineFunction = [Continuous, Differentiable, Periodic (2 * pi), Even]

-- æµ‹è¯•å‡½æ•°
testFunctionClassification :: IO ()
testFunctionClassification = do
    putStrLn "=== å‡½æ•°åˆ†ç±»æµ‹è¯• ==="
    
    -- æµ‹è¯•çº¿æ€§å‡½æ•°
    let linear = LinearFunction 2.0 0.0
    putStrLn $ "çº¿æ€§å‡½æ•° f(x) = 2x çš„åˆ†ç±»: " ++ show (classify linear)
    
    -- æµ‹è¯•äºŒæ¬¡å‡½æ•°
    let quadratic = QuadraticFunction 1.0 0.0 0.0
    putStrLn $ "äºŒæ¬¡å‡½æ•° f(x) = xÂ² çš„åˆ†ç±»: " ++ show (classify quadratic)
    
    -- æµ‹è¯•æ­£å¼¦å‡½æ•°
    let sine = SineFunction
    putStrLn $ "æ­£å¼¦å‡½æ•° f(x) = sin(x) çš„åˆ†ç±»: " ++ show (classify sine)
    
    -- æµ‹è¯•ä½™å¼¦å‡½æ•°
    let cosine = CosineFunction
    putStrLn $ "ä½™å¼¦å‡½æ•° f(x) = cos(x) çš„åˆ†ç±»: " ++ show (classify cosine)
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å‡½æ•°åˆ†ç±»åœ¨æ•°å­¦åˆ†æä¸­çš„åº”ç”¨

**ç¤ºä¾‹ 5.1.1** (è¿ç»­å‡½æ•°çš„åˆ†ç±»)
è€ƒè™‘å‡½æ•° $f(x) = x^3$ï¼š

- æ˜ å°„æ€§è´¨ï¼šåŒå°„å‡½æ•°
- è¿ç»­æ€§ï¼šè¿ç»­å‡½æ•°
- å¯å¾®æ€§ï¼šå¯å¾®å‡½æ•°
- å•è°ƒæ€§ï¼šä¸¥æ ¼å•è°ƒé€’å¢
- å¥‡å¶æ€§ï¼šå¥‡å‡½æ•°

**ç¤ºä¾‹ 5.1.2** (å‘¨æœŸå‡½æ•°çš„åˆ†ç±»)
è€ƒè™‘å‡½æ•° $f(x) = \sin(x)$ï¼š

- æ˜ å°„æ€§è´¨ï¼šéå•å°„ï¼Œéæ»¡å°„
- è¿ç»­æ€§ï¼šè¿ç»­å‡½æ•°
- å¯å¾®æ€§ï¼šå¯å¾®å‡½æ•°
- å‘¨æœŸæ€§ï¼šå‘¨æœŸå‡½æ•°ï¼ŒåŸºæœ¬å‘¨æœŸä¸º $2\pi$
- å¥‡å¶æ€§ï¼šå¥‡å‡½æ•°

### 5.2 å‡½æ•°åˆ†ç±»åœ¨è®¡ç®—æœºç§‘å­¦ä¸­çš„åº”ç”¨

**ç¤ºä¾‹ 5.2.1** (å“ˆå¸Œå‡½æ•°çš„åˆ†ç±»)
å“ˆå¸Œå‡½æ•° $h: U \to \{0, 1, \ldots, m-1\}$ çš„åˆ†ç±»ï¼š

- æ˜ å°„æ€§è´¨ï¼šé€šå¸¸ä¸æ˜¯å•å°„ï¼ˆå­˜åœ¨ç¢°æ’ï¼‰
- å®šä¹‰åŸŸï¼šé€šå¸¸å¾ˆå¤§æˆ–æ— é™
- å€¼åŸŸï¼šæœ‰é™é›†åˆ
- è®¡ç®—æ€§è´¨ï¼šé«˜æ•ˆå¯è®¡ç®—

**ç¤ºä¾‹ 5.2.2** (åŠ å¯†å‡½æ•°çš„åˆ†ç±»)
åŠ å¯†å‡½æ•° $E: \mathcal{P} \times \mathcal{K} \to \mathcal{C}$ çš„åˆ†ç±»ï¼š

- æ˜ å°„æ€§è´¨ï¼šé€šå¸¸è¦æ±‚å¯é€†
- å®‰å…¨æ€§ï¼šæŠµæŠ—å„ç§æ”»å‡»
- æ•ˆç‡ï¼šè®¡ç®—å¤æ‚åº¦é€‚ä¸­

### 5.3 å‡½æ•°åˆ†ç±»åœ¨ç‰©ç†å­¦ä¸­çš„åº”ç”¨

**ç¤ºä¾‹ 5.3.1** (æ³¢åŠ¨å‡½æ•°çš„åˆ†ç±»)
é‡å­åŠ›å­¦ä¸­çš„æ³¢åŠ¨å‡½æ•° $\psi(x, t)$ çš„åˆ†ç±»ï¼š

- è¿ç»­æ€§ï¼šé€šå¸¸è¦æ±‚è¿ç»­
- å¯å¾®æ€§ï¼šé€šå¸¸è¦æ±‚å¯å¾®
- å½’ä¸€åŒ–ï¼šæ»¡è¶³å½’ä¸€åŒ–æ¡ä»¶
- è¾¹ç•Œæ¡ä»¶ï¼šæ»¡è¶³ç‰¹å®šçš„è¾¹ç•Œæ¡ä»¶

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å‡½æ•°æ¦‚å¿µçš„å…³ç³»

å‡½æ•°åˆ†ç±»ç†è®ºç›´æ¥å»ºç«‹åœ¨å‡½æ•°æ¦‚å¿µçš„åŸºç¡€ä¸Šï¼Œæ˜¯å‡½æ•°è®ºçš„æ·±åŒ–å’Œå‘å±•ã€‚

**ç›¸å…³æ–‡æ¡£**:

- [02.4.1 å‡½æ•°æ¦‚å¿µ](../02_Mathematical_Foundation/02.4.1_å‡½æ•°æ¦‚å¿µ.md)
- [02.4.2 å‡½æ•°æ€§è´¨](../02_Mathematical_Foundation/02.4.2_å‡½æ•°æ€§è´¨.md)
- [02.4.3 å‡½æ•°è¿ç®—](../02_Mathematical_Foundation/02.4.3_å‡½æ•°è¿ç®—.md)

### 6.2 ä¸é›†åˆè®ºçš„å…³ç³»

å‡½æ•°åˆ†ç±»ç†è®ºå¤§é‡ä½¿ç”¨é›†åˆè®ºçš„æ¦‚å¿µå’Œæ–¹æ³•ï¼Œç‰¹åˆ«æ˜¯é›†åˆçš„åŒ…å«å…³ç³»ã€ç­‰ä»·å…³ç³»ç­‰ã€‚

**ç›¸å…³æ–‡æ¡£**:

- [02.1.1 æœ´ç´ é›†åˆè®º](../02_Mathematical_Foundation/02.1.1_æœ´ç´ é›†åˆè®º.md)
- [02.1.2 å…¬ç†é›†åˆè®º](../02_Mathematical_Foundation/02.1.2_å…¬ç†é›†åˆè®º.md)
- [02.1.3 é›†åˆè¿ç®—](../02_Mathematical_Foundation/02.1.3_é›†åˆè¿ç®—.md)
- [02.1.4 é›†åˆå…³ç³»](../02_Mathematical_Foundation/02.1.4_é›†åˆå…³ç³».md)

### 6.3 ä¸é€»è¾‘å­¦çš„å…³ç³»

å‡½æ•°åˆ†ç±»ç†è®ºä¸­çš„è¯æ˜å’Œæ¨ç†è¿‡ç¨‹ä¾èµ–äºé€»è¾‘å­¦çš„åŸºç¡€ã€‚

**ç›¸å…³æ–‡æ¡£**:

- [02.2.1 å‘½é¢˜é€»è¾‘](../02_Mathematical_Foundation/02.2.1_å‘½é¢˜é€»è¾‘.md)
- [02.2.2 è°“è¯é€»è¾‘](../02_Mathematical_Foundation/02.2.2_è°“è¯é€»è¾‘.md)
- [02.2.3 æ¨¡æ€é€»è¾‘](../02_Mathematical_Foundation/02.2.3_æ¨¡æ€é€»è¾‘.md)
- [02.2.4 ç›´è§‰é€»è¾‘](../02_Mathematical_Foundation/02.2.4_ç›´è§‰é€»è¾‘.md)

### 6.4 ä¸å½¢å¼è¯­è¨€ç†è®ºçš„å…³ç³»

å‡½æ•°åˆ†ç±»ç†è®ºä¸ºå½¢å¼è¯­è¨€ç†è®ºä¸­çš„è¯­è¨€åˆ†ç±»æä¾›äº†æ•°å­¦åŸºç¡€ã€‚

**ç›¸å…³æ–‡æ¡£**:

- [03.1.1 æœ‰é™è‡ªåŠ¨æœº](../03_Formal_Language_Theory/03.1.1_æœ‰é™è‡ªåŠ¨æœº.md)
- [03.1.2 ä¸‹æ¨è‡ªåŠ¨æœº](../03_Formal_Language_Theory/03.1.2_ä¸‹æ¨è‡ªåŠ¨æœº.md)
- [03.1.3 çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº](../03_Formal_Language_Theory/03.1.3_çº¿æ€§æœ‰ç•Œè‡ªåŠ¨æœº.md)

### 6.5 ä¸ç±»å‹ç†è®ºçš„å…³ç³»

å‡½æ•°åˆ†ç±»ç†è®ºä¸ºç±»å‹ç†è®ºä¸­çš„å‡½æ•°ç±»å‹åˆ†ç±»æä¾›äº†åŸºç¡€ã€‚

**ç›¸å…³æ–‡æ¡£**:

- [04.1.1 ç®€å•ç±»å‹ç†è®º](../04_Type_Theory/04.1.1_ç®€å•ç±»å‹ç†è®º.md)
- [04.1.2 çº¿æ€§ç±»å‹ç†è®º](../04_Type_Theory/04.1.2_çº¿æ€§ç±»å‹ç†è®º.md)
- [04.1.3 ä»¿å°„ç±»å‹ç†è®º](../04_Type_Theory/04.1.3_ä»¿å°„ç±»å‹ç†è®º.md)

## 7. å‚è€ƒæ–‡çŒ®

1. **Rudin, W.** (1976). *Principles of Mathematical Analysis*. McGraw-Hill.
   - è¿ç»­å‡½æ•°å’Œå¯å¾®å‡½æ•°çš„ä¸¥æ ¼å®šä¹‰
   - å‡½æ•°åˆ†ç±»çš„åŸºæœ¬ç†è®º

2. **Apostol, T. M.** (1974). *Mathematical Analysis*. Addison-Wesley.
   - å‡½æ•°åˆ†ç±»çš„ç³»ç»ŸåŒ–å¤„ç†
   - å‡½æ•°æ€§è´¨çš„è¯¦ç»†åˆ†æ

3. **Royden, H. L.** (1988). *Real Analysis*. Macmillan.
   - å¯æµ‹å‡½æ•°çš„åˆ†ç±»
   - å‡½æ•°ç©ºé—´çš„ç†è®º

4. **Folland, G. B.** (1999). *Real Analysis: Modern Techniques and Their Applications*. Wiley.
   - ç°ä»£åˆ†æå­¦ä¸­çš„å‡½æ•°åˆ†ç±»
   - æ³›å‡½åˆ†æä¸­çš„å‡½æ•°åˆ†ç±»

5. **DieudonnÃ©, J.** (1969). *Foundations of Modern Analysis*. Academic Press.
   - å‡½æ•°åˆ†ç±»çš„å…¬ç†åŒ–å¤„ç†
   - æ‹“æ‰‘å­¦ä¸­çš„å‡½æ•°åˆ†ç±»

---

**æ–‡æ¡£ç»´æŠ¤ä¿¡æ¯**:

- **åˆ›å»ºæ—¶é—´**: 2024-12-21
- **æœ€åæ›´æ–°**: 2024-12-21
- **ç‰ˆæœ¬**: v1.0
- **ç»´æŠ¤è€…**: å½¢å¼ç§‘å­¦ç†è®ºä½“ç³»æ„å»ºå›¢é˜Ÿ
- **çŠ¶æ€**: æŒç»­æ„å»ºä¸­

**ç›¸å…³é“¾æ¥**:

- [æ•°å­¦åŸºç¡€ç†è®ºç´¢å¼•](../README.md)
- [å‡½æ•°è®ºåŸºç¡€ç´¢å¼•](../README.md)
- [é‡æ„ä¸»ç´¢å¼•](../../00_Master_Index/01_é‡æ„ä¸»ç´¢å¼•_v9.0.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
