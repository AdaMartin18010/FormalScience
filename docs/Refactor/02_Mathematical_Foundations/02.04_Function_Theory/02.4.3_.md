# 02.4.3 å‡½æ•°è¿ç®—

## ğŸ“‹ æ¦‚è¿°

å‡½æ•°è¿ç®—æ˜¯å‡½æ•°ç†è®ºçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼ŒåŒ…æ‹¬å‡½æ•°çš„åŠ æ³•ã€ä¹˜æ³•ã€å¤åˆã€é€†è¿ç®—ç­‰åŸºæœ¬è¿ç®—ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦æ„å»ºå‡½æ•°è¿ç®—çš„ç†è®ºæ¡†æ¶ï¼Œä¸ºå‡½æ•°åˆ†æå’Œåº”ç”¨æä¾›åŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹å‡½æ•°è¿ç®—çš„å½¢å¼åŒ–åŸºç¡€**
2. **åˆ†æå‡½æ•°è¿ç®—çš„æ€§è´¨**
3. **æ¢è®¨å‡½æ•°è¿ç®—çš„ä»£æ•°ç»“æ„**
4. **ç ”ç©¶å‡½æ•°è¿ç®—çš„åº”ç”¨**
5. **æ„å»ºå‡½æ•°è¿ç®—çš„è®¡ç®—æ¡†æ¶**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å‡½æ•°è¿ç®—çš„å®šä¹‰

å‡½æ•°è¿ç®—æ˜¯åœ¨å‡½æ•°é›†åˆä¸Šå®šä¹‰çš„ä»£æ•°è¿ç®—ï¼ŒåŒ…æ‹¬ï¼š

- **åŠ æ³•è¿ç®—**ï¼š$(f + g)(x) = f(x) + g(x)$
- **ä¹˜æ³•è¿ç®—**ï¼š$(f \cdot g)(x) = f(x) \cdot g(x)$
- **å¤åˆè¿ç®—**ï¼š$(f \circ g)(x) = f(g(x))$
- **é€†è¿ç®—**ï¼š$f^{-1}(y) = x$ å½“ä¸”ä»…å½“ $f(x) = y$

### 1.2 è¿ç®—çš„ç±»å‹

1. **ç‚¹å¼è¿ç®—**ï¼šé€ç‚¹è¿›è¡Œçš„è¿ç®—
2. **å¤åˆè¿ç®—**ï¼šå‡½æ•°ä¹‹é—´çš„ç»„åˆè¿ç®—
3. **é€†è¿ç®—**ï¼šå‡½æ•°çš„é€†å˜æ¢
4. **æé™è¿ç®—**ï¼šå‡½æ•°çš„æé™è¿ç®—

### 1.3 è¿ç®—çš„æ€§è´¨

- **ç»“åˆå¾‹**ï¼šè¿ç®—çš„ç»“åˆæ€§è´¨
- **äº¤æ¢å¾‹**ï¼šè¿ç®—çš„äº¤æ¢æ€§è´¨
- **åˆ†é…å¾‹**ï¼šè¿ç®—çš„åˆ†é…æ€§è´¨
- **å•ä½å…ƒ**ï¼šè¿ç®—çš„å•ä½å…ƒç´ 

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å‡½æ•°åŠ æ³•

**å®šä¹‰ 2.1.1** (å‡½æ•°åŠ æ³•)
è®¾ $f, g: A \to \mathbb{R}$ï¼Œå…¶åŠ æ³•å®šä¹‰ä¸ºï¼š

$$(f + g)(x) = f(x) + g(x)$$

### 2.2 å‡½æ•°ä¹˜æ³•

**å®šä¹‰ 2.2.1** (å‡½æ•°ä¹˜æ³•)
è®¾ $f, g: A \to \mathbb{R}$ï¼Œå…¶ä¹˜æ³•å®šä¹‰ä¸ºï¼š

$$(f \cdot g)(x) = f(x) \cdot g(x)$$

### 2.3 å‡½æ•°å¤åˆ

**å®šä¹‰ 2.3.1** (å‡½æ•°å¤åˆ)
è®¾ $f: B \to C$ å’Œ $g: A \to B$ï¼Œå…¶å¤åˆå®šä¹‰ä¸ºï¼š

$$(f \circ g)(x) = f(g(x))$$

### 2.4 å‡½æ•°é€†

**å®šä¹‰ 2.4.1** (å‡½æ•°é€†)
è®¾ $f: A \to B$ æ˜¯åŒå°„å‡½æ•°ï¼Œå…¶é€†å‡½æ•° $f^{-1}: B \to A$ å®šä¹‰ä¸ºï¼š

$$f^{-1}(y) = x \iff f(x) = y$$

### 2.5 å‡½æ•°æ ‡é‡ä¹˜æ³•

**å®šä¹‰ 2.5.1** (å‡½æ•°æ ‡é‡ä¹˜æ³•)
è®¾ $f: A \to \mathbb{R}$ å’Œ $c \in \mathbb{R}$ï¼Œå…¶æ ‡é‡ä¹˜æ³•å®šä¹‰ä¸ºï¼š

$$(c \cdot f)(x) = c \cdot f(x)$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 å‡½æ•°è¿ç®—çš„ç»“åˆå¾‹

**å®šç† 3.1.1** (åŠ æ³•ç»“åˆå¾‹)
å‡½æ•°åŠ æ³•æ»¡è¶³ç»“åˆå¾‹ï¼š

$$(f + g) + h = f + (g + h)$$

**è¯æ˜**ï¼š
å¯¹äºä»»æ„ $x \in A$ï¼š

1. $((f + g) + h)(x) = (f + g)(x) + h(x) = (f(x) + g(x)) + h(x)$
2. $(f + (g + h))(x) = f(x) + (g + h)(x) = f(x) + (g(x) + h(x))$
3. æ ¹æ®å®æ•°çš„ç»“åˆå¾‹ï¼Œä¸¤è€…ç›¸ç­‰

### 3.2 å‡½æ•°å¤åˆçš„ç»“åˆå¾‹

**å®šç† 3.2.1** (å¤åˆç»“åˆå¾‹)
å‡½æ•°å¤åˆæ»¡è¶³ç»“åˆå¾‹ï¼š

$$(f \circ g) \circ h = f \circ (g \circ h)$$

**è¯æ˜**ï¼š
å¯¹äºä»»æ„ $x \in A$ï¼š

1. $((f \circ g) \circ h)(x) = (f \circ g)(h(x)) = f(g(h(x)))$
2. $(f \circ (g \circ h))(x) = f((g \circ h)(x)) = f(g(h(x)))$
3. å› æ­¤ä¸¤è€…ç›¸ç­‰

### 3.3 å‡½æ•°è¿ç®—çš„åˆ†é…å¾‹

**å®šç† 3.3.1** (åˆ†é…å¾‹)
å‡½æ•°è¿ç®—æ»¡è¶³åˆ†é…å¾‹ï¼š

$$f \cdot (g + h) = f \cdot g + f \cdot h$$

**è¯æ˜**ï¼š
å¯¹äºä»»æ„ $x \in A$ï¼š

1. $(f \cdot (g + h))(x) = f(x) \cdot (g + h)(x) = f(x) \cdot (g(x) + h(x))$
2. $(f \cdot g + f \cdot h)(x) = (f \cdot g)(x) + (f \cdot h)(x) = f(x) \cdot g(x) + f(x) \cdot h(x)$
3. æ ¹æ®å®æ•°çš„åˆ†é…å¾‹ï¼Œä¸¤è€…ç›¸ç­‰

### 3.4 é€†å‡½æ•°çš„æ€§è´¨

**å®šç† 3.4.1** (é€†å‡½æ•°æ€§è´¨)
è®¾ $f: A \to B$ æ˜¯åŒå°„å‡½æ•°ï¼Œåˆ™ï¼š

1. $(f^{-1})^{-1} = f$
2. $f \circ f^{-1} = \text{id}_B$
3. $f^{-1} \circ f = \text{id}_A$

**è¯æ˜**ï¼š

1. **$(f^{-1})^{-1} = f$**ï¼š
   - å¯¹äºä»»æ„ $x \in A$ï¼Œ$f^{-1}(f(x)) = x$
   - å› æ­¤ $(f^{-1})^{-1}(x) = f(x)$

2. **$f \circ f^{-1} = \text{id}_B$**ï¼š
   - å¯¹äºä»»æ„ $y \in B$ï¼Œ$(f \circ f^{-1})(y) = f(f^{-1}(y)) = y$

3. **$f^{-1} \circ f = \text{id}_A$**ï¼š
   - å¯¹äºä»»æ„ $x \in A$ï¼Œ$(f^{-1} \circ f)(x) = f^{-1}(f(x)) = x$

## 4. ä»£ç å®ç°

### 4.1 å‡½æ•°è¿ç®—å®ç°

```rust
use std::collections::HashMap;

/// å‡½æ•°è¿ç®—ç±»å‹
#[derive(Debug, Clone)]
pub enum FunctionOperation {
    Add(Box<Function>, Box<Function>),
    Multiply(Box<Function>, Box<Function>),
    Compose(Box<Function>, Box<Function>),
    ScalarMultiply(f64, Box<Function>),
    Inverse(Box<Function>),
}

/// å‡½æ•°
#[derive(Debug, Clone)]
pub struct Function {
    operation: FunctionOperation,
    domain: (f64, f64),
}

/// åŸºæœ¬å‡½æ•°
#[derive(Debug, Clone)]
pub enum BasicFunction {
    Identity,
    Constant(f64),
    Power(i32),
    Exponential,
    Logarithm,
    Sine,
    Cosine,
    Tangent,
}

impl Function {
    /// åˆ›å»ºåŸºæœ¬å‡½æ•°
    pub fn basic(basic: BasicFunction, domain: (f64, f64)) -> Self {
        Self {
            operation: FunctionOperation::Basic(basic),
            domain,
        }
    }
    
    /// å‡½æ•°åŠ æ³•
    pub fn add(self, other: Function) -> Function {
        Function {
            operation: FunctionOperation::Add(Box::new(self), Box::new(other)),
            domain: self.intersect_domain(&other),
        }
    }
    
    /// å‡½æ•°ä¹˜æ³•
    pub fn multiply(self, other: Function) -> Function {
        Function {
            operation: FunctionOperation::Multiply(Box::new(self), Box::new(other)),
            domain: self.intersect_domain(&other),
        }
    }
    
    /// å‡½æ•°å¤åˆ
    pub fn compose(self, other: Function) -> Function {
        Function {
            operation: FunctionOperation::Compose(Box::new(self), Box::new(other)),
            domain: other.domain,
        }
    }
    
    /// æ ‡é‡ä¹˜æ³•
    pub fn scale(self, scalar: f64) -> Function {
        Function {
            operation: FunctionOperation::ScalarMultiply(scalar, Box::new(self)),
            domain: self.domain,
        }
    }
    
    /// æ±‚é€†å‡½æ•°
    pub fn inverse(self) -> Result<Function, String> {
        if !self.is_bijective() {
            return Err("å‡½æ•°ä¸æ˜¯åŒå°„ï¼Œæ— æ³•æ±‚é€†".to_string());
        }
        
        Ok(Function {
            operation: FunctionOperation::Inverse(Box::new(self)),
            domain: self.find_range(),
        })
    }
    
    /// æ±‚å€¼
    pub fn evaluate(&self, x: f64) -> Result<f64, String> {
        if x < self.domain.0 || x > self.domain.1 {
            return Err("è¾“å…¥è¶…å‡ºå®šä¹‰åŸŸ".to_string());
        }
        
        match &self.operation {
            FunctionOperation::Basic(basic) => self.evaluate_basic(basic, x),
            FunctionOperation::Add(f, g) => {
                let y1 = f.evaluate(x)?;
                let y2 = g.evaluate(x)?;
                Ok(y1 + y2)
            }
            FunctionOperation::Multiply(f, g) => {
                let y1 = f.evaluate(x)?;
                let y2 = g.evaluate(x)?;
                Ok(y1 * y2)
            }
            FunctionOperation::Compose(f, g) => {
                let y = g.evaluate(x)?;
                f.evaluate(y)
            }
            FunctionOperation::ScalarMultiply(c, f) => {
                let y = f.evaluate(x)?;
                Ok(c * y)
            }
            FunctionOperation::Inverse(f) => {
                self.evaluate_inverse(f, x)
            }
        }
    }
    
    /// æ±‚å€¼åŸºæœ¬å‡½æ•°
    fn evaluate_basic(&self, basic: &BasicFunction, x: f64) -> Result<f64, String> {
        match basic {
            BasicFunction::Identity => Ok(x),
            BasicFunction::Constant(c) => Ok(*c),
            BasicFunction::Power(n) => {
                if *n == 0 {
                    Ok(1.0)
                } else if *n > 0 {
                    Ok(x.powi(*n))
                } else {
                    if x == 0.0 {
                        Err("é›¶çš„è´Ÿå¹‚æœªå®šä¹‰".to_string())
                    } else {
                        Ok(x.powi(*n))
                    }
                }
            }
            BasicFunction::Exponential => Ok(x.exp()),
            BasicFunction::Logarithm => {
                if x <= 0.0 {
                    Err("å¯¹æ•°å‡½æ•°å®šä¹‰åŸŸé”™è¯¯".to_string())
                } else {
                    Ok(x.ln())
                }
            }
            BasicFunction::Sine => Ok(x.sin()),
            BasicFunction::Cosine => Ok(x.cos()),
            BasicFunction::Tangent => {
                if (x / std::f64::consts::PI - 0.5).abs() < 1e-10 {
                    Err("æ­£åˆ‡å‡½æ•°åœ¨Ï€/2å¤„æ— å®šä¹‰".to_string())
                } else {
                    Ok(x.tan())
                }
            }
        }
    }
    
    /// æ±‚å€¼é€†å‡½æ•°
    fn evaluate_inverse(&self, f: &Function, y: f64) -> Result<f64, String> {
        // ç®€åŒ–å®ç°ï¼šä½¿ç”¨æ•°å€¼æ–¹æ³•æ±‚é€†
        let mut x = 0.0;
        let mut step = 1.0;
        let max_iterations = 100;
        
        for _ in 0..max_iterations {
            match f.evaluate(x) {
                Ok(fx) => {
                    let diff = fx - y;
                    if diff.abs() < 1e-10 {
                        return Ok(x);
                    }
                    if diff > 0.0 {
                        x -= step;
                    } else {
                        x += step;
                    }
                    step *= 0.5;
                }
                Err(_) => {
                    x += step;
                }
            }
        }
        
        Err("æ— æ³•æ‰¾åˆ°é€†å‡½æ•°å€¼".to_string())
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºåŒå°„
    fn is_bijective(&self) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥åŸºæœ¬å‡½æ•°æ˜¯å¦ä¸ºåŒå°„
        match &self.operation {
            FunctionOperation::Basic(basic) => {
                matches!(basic, BasicFunction::Identity | BasicFunction::Exponential | BasicFunction::Logarithm)
            }
            _ => false,
        }
    }
    
    /// æŸ¥æ‰¾å€¼åŸŸ
    fn find_range(&self) -> (f64, f64) {
        // ç®€åŒ–å®ç°ï¼šè¿”å›ä¸€ä¸ªä¼°è®¡çš„èŒƒå›´
        match &self.operation {
            FunctionOperation::Basic(basic) => {
                match basic {
                    BasicFunction::Identity => (f64::NEG_INFINITY, f64::INFINITY),
                    BasicFunction::Constant(c) => (*c, *c),
                    BasicFunction::Power(n) => {
                        if *n % 2 == 0 {
                            (0.0, f64::INFINITY)
                        } else {
                            (f64::NEG_INFINITY, f64::INFINITY)
                        }
                    }
                    BasicFunction::Exponential => (0.0, f64::INFINITY),
                    BasicFunction::Logarithm => (f64::NEG_INFINITY, f64::INFINITY),
                    BasicFunction::Sine | BasicFunction::Cosine => (-1.0, 1.0),
                    BasicFunction::Tangent => (f64::NEG_INFINITY, f64::INFINITY),
                }
            }
            _ => (f64::NEG_INFINITY, f64::INFINITY),
        }
    }
    
    /// æ±‚å®šä¹‰åŸŸäº¤é›†
    fn intersect_domain(&self, other: &Function) -> (f64, f64) {
        let start = self.domain.0.max(other.domain.0);
        let end = self.domain.1.min(other.domain.1);
        (start, end)
    }
    
    /// æ±‚å¯¼æ•°
    pub fn derivative(&self) -> Function {
        match &self.operation {
            FunctionOperation::Basic(basic) => self.derivative_basic(basic),
            FunctionOperation::Add(f, g) => {
                f.derivative().add(g.derivative())
            }
            FunctionOperation::Multiply(f, g) => {
                f.derivative().multiply(g.clone()).add(f.clone().multiply(g.derivative()))
            }
            FunctionOperation::Compose(f, g) => {
                f.derivative().compose(g.clone()).multiply(g.derivative())
            }
            FunctionOperation::ScalarMultiply(c, f) => {
                f.derivative().scale(*c)
            }
            FunctionOperation::Inverse(f) => {
                // é€†å‡½æ•°çš„å¯¼æ•°
                let f_prime = f.derivative();
                let f_inv = self.clone();
                f_prime.compose(f_inv).scale(-1.0)
            }
        }
    }
    
    /// æ±‚åŸºæœ¬å‡½æ•°çš„å¯¼æ•°
    fn derivative_basic(&self, basic: &BasicFunction) -> Function {
        match basic {
            BasicFunction::Identity => Function::basic(BasicFunction::Constant(1.0), self.domain),
            BasicFunction::Constant(_) => Function::basic(BasicFunction::Constant(0.0), self.domain),
            BasicFunction::Power(n) => {
                if *n == 0 {
                    Function::basic(BasicFunction::Constant(0.0), self.domain)
                } else {
                    Function::basic(BasicFunction::Power(n - 1), self.domain).scale(*n as f64)
                }
            }
            BasicFunction::Exponential => Function::basic(BasicFunction::Exponential, self.domain),
            BasicFunction::Logarithm => {
                Function::basic(BasicFunction::Power(-1), self.domain)
            }
            BasicFunction::Sine => Function::basic(BasicFunction::Cosine, self.domain),
            BasicFunction::Cosine => {
                Function::basic(BasicFunction::Sine, self.domain).scale(-1.0)
            }
            BasicFunction::Tangent => {
                let sec = Function::basic(BasicFunction::Power(2), self.domain);
                sec.compose(Function::basic(BasicFunction::Cosine, self.domain).inverse().unwrap())
            }
        }
    }
}

/// å‡½æ•°è¿ç®—åˆ†æå™¨
pub struct FunctionOperationAnalyzer;

impl FunctionOperationAnalyzer {
    /// åˆ†æå‡½æ•°è¿ç®—çš„æ€§è´¨
    pub fn analyze(&self, f: &Function) -> FunctionOperationAnalysis {
        let is_linear = self.is_linear(f);
        let is_polynomial = self.is_polynomial(f);
        let is_rational = self.is_rational(f);
        let is_transcendental = self.is_transcendental(f);
        let degree = self.get_degree(f);
        
        FunctionOperationAnalysis {
            is_linear,
            is_polynomial,
            is_rational,
            is_transcendental,
            degree,
            complexity: self.estimate_complexity(f),
        }
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºçº¿æ€§å‡½æ•°
    fn is_linear(&self, f: &Function) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥æ˜¯å¦ä¸ºä¸€æ¬¡å‡½æ•°
        matches!(&f.operation, FunctionOperation::Basic(BasicFunction::Identity))
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºå¤šé¡¹å¼å‡½æ•°
    fn is_polynomial(&self, f: &Function) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥æ˜¯å¦åªåŒ…å«å¹‚å‡½æ•°å’Œå¸¸æ•°
        matches!(&f.operation, FunctionOperation::Basic(BasicFunction::Power(_)))
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰ç†å‡½æ•°
    fn is_rational(&self, f: &Function) -> bool {
        // ç®€åŒ–å®ç°
        false
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºè¶…è¶Šå‡½æ•°
    fn is_transcendental(&self, f: &Function) -> bool {
        // ç®€åŒ–å®ç°ï¼šæ£€æŸ¥æ˜¯å¦åŒ…å«æŒ‡æ•°ã€å¯¹æ•°ã€ä¸‰è§’å‡½æ•°
        matches!(&f.operation, 
            FunctionOperation::Basic(BasicFunction::Exponential) |
            FunctionOperation::Basic(BasicFunction::Logarithm) |
            FunctionOperation::Basic(BasicFunction::Sine) |
            FunctionOperation::Basic(BasicFunction::Cosine) |
            FunctionOperation::Basic(BasicFunction::Tangent)
        )
    }
    
    /// è·å–å‡½æ•°æ¬¡æ•°
    fn get_degree(&self, f: &Function) -> Option<i32> {
        match &f.operation {
            FunctionOperation::Basic(BasicFunction::Power(n)) => Some(*n),
            FunctionOperation::Basic(BasicFunction::Constant(_)) => Some(0),
            FunctionOperation::Basic(BasicFunction::Identity) => Some(1),
            _ => None,
        }
    }
    
    /// ä¼°è®¡å¤æ‚åº¦
    fn estimate_complexity(&self, f: &Function) -> Complexity {
        match &f.operation {
            FunctionOperation::Basic(_) => Complexity::Simple,
            FunctionOperation::Add(_, _) | FunctionOperation::Multiply(_, _) => Complexity::Moderate,
            FunctionOperation::Compose(_, _) | FunctionOperation::Inverse(_) => Complexity::Complex,
            _ => Complexity::Moderate,
        }
    }
}

/// å‡½æ•°è¿ç®—åˆ†æç»“æœ
#[derive(Debug, Clone)]
pub struct FunctionOperationAnalysis {
    is_linear: bool,
    is_polynomial: bool,
    is_rational: bool,
    is_transcendental: bool,
    degree: Option<i32>,
    complexity: Complexity,
}

/// å¤æ‚åº¦çº§åˆ«
#[derive(Debug, Clone)]
pub enum Complexity {
    Simple,
    Moderate,
    Complex,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_function_addition() {
        let f = Function::basic(BasicFunction::Identity, (-10.0, 10.0));
        let g = Function::basic(BasicFunction::Constant(2.0), (-10.0, 10.0));
        let h = f.add(g);
        
        assert_eq!(h.evaluate(3.0), Ok(5.0));
    }

    #[test]
    fn test_function_multiplication() {
        let f = Function::basic(BasicFunction::Identity, (-10.0, 10.0));
        let g = Function::basic(BasicFunction::Constant(3.0), (-10.0, 10.0));
        let h = f.multiply(g);
        
        assert_eq!(h.evaluate(4.0), Ok(12.0));
    }

    #[test]
    fn test_function_composition() {
        let f = Function::basic(BasicFunction::Power(2), (-10.0, 10.0));
        let g = Function::basic(BasicFunction::Identity, (-10.0, 10.0));
        let h = f.compose(g);
        
        assert_eq!(h.evaluate(3.0), Ok(9.0));
    }

    #[test]
    fn test_function_derivative() {
        let f = Function::basic(BasicFunction::Power(2), (-10.0, 10.0));
        let f_prime = f.derivative();
        
        assert_eq!(f_prime.evaluate(3.0), Ok(6.0));
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 åŸºæœ¬å‡½æ•°è¿ç®—

```rust
fn main() {
    // åˆ›å»ºåŸºæœ¬å‡½æ•°
    let f = Function::basic(BasicFunction::Identity, (-10.0, 10.0));
    let g = Function::basic(BasicFunction::Power(2), (-10.0, 10.0));
    let h = Function::basic(BasicFunction::Sine, (-10.0, 10.0));
    
    // å‡½æ•°è¿ç®—
    let sum = f.clone().add(g.clone());
    let product = f.clone().multiply(g.clone());
    let composition = h.clone().compose(g.clone());
    let scaled = f.clone().scale(2.0);
    
    println!("å‡½æ•°è¿ç®—ç¤ºä¾‹:");
    println!("f(x) = x, g(x) = xÂ², h(x) = sin(x)");
    println!("(f + g)(2) = {:?}", sum.evaluate(2.0));
    println!("(f * g)(2) = {:?}", product.evaluate(2.0));
    println!("(h âˆ˜ g)(2) = {:?}", composition.evaluate(2.0));
    println!("(2f)(2) = {:?}", scaled.evaluate(2.0));
}
```

### 5.2 å‡½æ•°åˆ†æ

```rust
fn analyze_functions() {
    let analyzer = FunctionOperationAnalyzer;
    
    let functions = vec![
        ("çº¿æ€§å‡½æ•°", Function::basic(BasicFunction::Identity, (-10.0, 10.0))),
        ("äºŒæ¬¡å‡½æ•°", Function::basic(BasicFunction::Power(2), (-10.0, 10.0))),
        ("æŒ‡æ•°å‡½æ•°", Function::basic(BasicFunction::Exponential, (-5.0, 5.0))),
        ("æ­£å¼¦å‡½æ•°", Function::basic(BasicFunction::Sine, (-10.0, 10.0))),
    ];
    
    for (name, function) in functions {
        let analysis = analyzer.analyze(&function);
        println!("{} åˆ†æ:", name);
        println!("  çº¿æ€§: {}", analysis.is_linear);
        println!("  å¤šé¡¹å¼: {}", analysis.is_polynomial);
        println!("  è¶…è¶Š: {}", analysis.is_transcendental);
        println!("  æ¬¡æ•°: {:?}", analysis.degree);
        println!("  å¤æ‚åº¦: {:?}", analysis.complexity);
        println!();
    }
}
```

### 5.3 å‡½æ•°æ±‚å¯¼

```rust
fn function_differentiation() {
    let functions = vec![
        ("f(x) = xÂ²", Function::basic(BasicFunction::Power(2), (-10.0, 10.0))),
        ("f(x) = xÂ³", Function::basic(BasicFunction::Power(3), (-10.0, 10.0))),
        ("f(x) = sin(x)", Function::basic(BasicFunction::Sine, (-10.0, 10.0))),
        ("f(x) = exp(x)", Function::basic(BasicFunction::Exponential, (-5.0, 5.0))),
    ];
    
    println!("å‡½æ•°æ±‚å¯¼ç¤ºä¾‹:");
    for (name, function) in functions {
        let derivative = function.derivative();
        println!("{}", name);
        println!("  åŸå‡½æ•°: f(2) = {:?}", function.evaluate(2.0));
        println!("  å¯¼æ•°: f'(2) = {:?}", derivative.evaluate(2.0));
        println!();
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸ä»£æ•°çš„å…³ç³»

- **ç¯è®º**ï¼šå‡½æ•°é›†åˆæ„æˆç¯
- **åŸŸè®º**ï¼šå¯é€†å‡½æ•°æ„æˆåŸŸ
- **ç¾¤è®º**ï¼šåŒå°„å‡½æ•°æ„æˆç¾¤

### 6.2 ä¸çº¿æ€§ä»£æ•°çš„å…³ç³»

- **å‘é‡ç©ºé—´**ï¼šå‡½æ•°ç©ºé—´æ˜¯å‘é‡ç©ºé—´
- **çº¿æ€§å˜æ¢**ï¼šçº¿æ€§å‡½æ•°æ˜¯çº¿æ€§å˜æ¢
- **ç‰¹å¾å€¼**ï¼šå‡½æ•°çš„ç‰¹å¾å€¼é—®é¢˜

### 6.3 ä¸æ³›å‡½åˆ†æçš„å…³ç³»

- **ç®—å­ç†è®º**ï¼šå‡½æ•°è¿ç®—ä½œä¸ºç®—å­
- **è°±ç†è®º**ï¼šå‡½æ•°ç®—å­çš„è°±
- **ç©ºé—´ç†è®º**ï¼šå‡½æ•°ç©ºé—´çš„æ€§è´¨

### 6.4 ä¸æ•°å€¼åˆ†æçš„å…³ç³»

- **æ•°å€¼ç§¯åˆ†**ï¼šå‡½æ•°è¿ç®—çš„æ•°å€¼è®¡ç®—
- **æ•°å€¼å¾®åˆ†**ï¼šå‡½æ•°å¯¼æ•°çš„æ•°å€¼è®¡ç®—
- **æ’å€¼ç†è®º**ï¼šå‡½æ•°æ’å€¼çš„è¿ç®—

## 7. å‚è€ƒæ–‡çŒ®

1. **Lang, S.** (2002). *Algebra*. Springer.
2. **Artin, M.** (2011). *Algebra*. Pearson.
3. **Hungerford, T.** (2003). *Algebra*. Springer.
4. **Dummit, D., Foote, R.** (2004). *Abstract Algebra*. Wiley.
5. **Herstein, I.** (1996). *Abstract Algebra*. Prentice Hall.
6. **Jacobson, N.** (2009). *Basic Algebra*. Dover.
7. **Rotman, J.** (2002). *Advanced Modern Algebra*. Prentice Hall.
8. **Cohn, P.** (2003). *Basic Algebra*. Springer.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.4.1 å‡½æ•°æ¦‚å¿µ](02.4.1_å‡½æ•°æ¦‚å¿µ.md)
- [02.4.2 å‡½æ•°æ€§è´¨](02.4.2_å‡½æ•°æ€§è´¨.md)
- [02.4.4 å‡½æ•°åˆ†ç±»](../02_Mathematical_Foundation/02.4.4_å‡½æ•°åˆ†ç±».md)
- [02.6.1 ç¾¤è®ºåŸºç¡€](../02_Mathematical_Foundation/02.6.1_ç¾¤è®ºåŸºç¡€.md)
- [02.6.2 ç¯è®ºåŸºç¡€](../02_Mathematical_Foundation/02.6.2_ç¯è®ºåŸºç¡€.md)
- [02.6.3 åŸŸè®ºåŸºç¡€](../02_Mathematical_Foundation/02.6.3_åŸŸè®ºåŸºç¡€.md)


## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
