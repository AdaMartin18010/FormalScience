# 02.2.2 è°“è¯é€»è¾‘ç†è®º

## ğŸ“‹ æ¦‚è¿°

è°“è¯é€»è¾‘ç†è®ºæ˜¯å½¢å¼é€»è¾‘çš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œç ”ç©¶é‡åŒ–å‘½é¢˜çš„é€»è¾‘ç»“æ„å’Œæ¨ç†è§„åˆ™ã€‚æœ¬ç†è®ºæ‰©å±•äº†å‘½é¢˜é€»è¾‘ï¼Œå¼•å…¥äº†é‡è¯å’Œè°“è¯ï¼Œä¸ºæ›´å¤æ‚çš„é€»è¾‘æ¨ç†æä¾›å½¢å¼åŒ–æ¡†æ¶ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹è°“è¯é€»è¾‘çš„å½¢å¼åŒ–ç†è®º**
2. **åˆ†æé‡åŒ–å‘½é¢˜çš„é€»è¾‘ç»“æ„**
3. **æ„å»ºè°“è¯é€»è¾‘çš„æ¨ç†ç³»ç»Ÿ**
4. **æä¾›å½¢å¼åŒ–è¯æ˜æ–¹æ³•**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [è¯­æ³•ç³»ç»Ÿ](#3-è¯­æ³•ç³»ç»Ÿ)
4. [è¯­ä¹‰ç³»ç»Ÿ](#4-è¯­ä¹‰ç³»ç»Ÿ)
5. [æ¨ç†ç³»ç»Ÿ](#5-æ¨ç†ç³»ç»Ÿ)
6. [å½¢å¼åŒ–è¯æ˜](#6-å½¢å¼åŒ–è¯æ˜)
7. [ä»£ç å®ç°](#7-ä»£ç å®ç°)
8. [åº”ç”¨ç¤ºä¾‹](#8-åº”ç”¨ç¤ºä¾‹)
9. [ç›¸å…³ç†è®º](#9-ç›¸å…³ç†è®º)
10. [å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è°“è¯é€»è¾‘çš„å®šä¹‰

**å®šä¹‰ 1.1** (è°“è¯é€»è¾‘)
è°“è¯é€»è¾‘æ˜¯ç ”ç©¶åŒ…å«é‡è¯å’Œè°“è¯çš„å‘½é¢˜çš„é€»è¾‘ç³»ç»Ÿï¼Œèƒ½å¤Ÿè¡¨è¾¾æ›´å¤æ‚çš„æ•°å­¦å’Œå“²å­¦å‘½é¢˜ã€‚

**å½¢å¼åŒ–å®šä¹‰**ï¼š
è°“è¯é€»è¾‘ç³»ç»Ÿ $\mathcal{L}$ æ˜¯ä¸€ä¸ªå››å…ƒç»„ï¼š
$$\mathcal{L} = \langle \mathcal{V}, \mathcal{F}, \mathcal{P}, \mathcal{Q} \rangle$$
å…¶ä¸­ï¼š

- $\mathcal{V}$ æ˜¯å˜é‡é›†åˆ
- $\mathcal{F}$ æ˜¯å‡½æ•°ç¬¦å·é›†åˆ
- $\mathcal{P}$ æ˜¯è°“è¯ç¬¦å·é›†åˆ
- $\mathcal{Q}$ æ˜¯é‡è¯é›†åˆ $\{\forall, \exists\}$

### 1.2 åŸºæœ¬ç¬¦å·

**å®šä¹‰ 1.2** (åŸºæœ¬ç¬¦å·)
è°“è¯é€»è¾‘åŒ…å«ä»¥ä¸‹åŸºæœ¬ç¬¦å·ï¼š

- **å˜é‡**ï¼š$x, y, z, \ldots$
- **å¸¸é‡**ï¼š$a, b, c, \ldots$
- **å‡½æ•°ç¬¦å·**ï¼š$f, g, h, \ldots$
- **è°“è¯ç¬¦å·**ï¼š$P, Q, R, \ldots$
- **é‡è¯**ï¼š$\forall$ (å…¨ç§°é‡è¯), $\exists$ (å­˜åœ¨é‡è¯)
- **é€»è¾‘è¿æ¥è¯**ï¼š$\neg, \land, \lor, \rightarrow, \leftrightarrow$

### 1.3 é¡¹å’Œå…¬å¼

**å®šä¹‰ 1.3** (é¡¹)
é¡¹æ˜¯é€’å½’å®šä¹‰çš„ï¼š

1. å˜é‡å’Œå¸¸é‡æ˜¯é¡¹
2. å¦‚æœ $f$ æ˜¯ $n$ å…ƒå‡½æ•°ç¬¦å·ï¼Œ$t_1, \ldots, t_n$ æ˜¯é¡¹ï¼Œåˆ™ $f(t_1, \ldots, t_n)$ æ˜¯é¡¹

**å®šä¹‰ 1.4** (åŸå­å…¬å¼)
åŸå­å…¬å¼æ˜¯å½¢å¦‚ $P(t_1, \ldots, t_n)$ çš„è¡¨è¾¾å¼ï¼Œå…¶ä¸­ $P$ æ˜¯ $n$ å…ƒè°“è¯ç¬¦å·ï¼Œ$t_1, \ldots, t_n$ æ˜¯é¡¹ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å…¬å¼å®šä¹‰

**å®šä¹‰ 2.1** (å…¬å¼)
å…¬å¼æ˜¯é€’å½’å®šä¹‰çš„ï¼š

1. åŸå­å…¬å¼æ˜¯å…¬å¼
2. å¦‚æœ $\phi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\neg\phi$ æ˜¯å…¬å¼
3. å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $(\phi \land \psi)$, $(\phi \lor \psi)$, $(\phi \rightarrow \psi)$, $(\phi \leftrightarrow \psi)$ æ˜¯å…¬å¼
4. å¦‚æœ $\phi$ æ˜¯å…¬å¼ï¼Œ$x$ æ˜¯å˜é‡ï¼Œåˆ™ $\forall x \phi$ å’Œ $\exists x \phi$ æ˜¯å…¬å¼

### 2.2 è‡ªç”±å˜é‡å’Œçº¦æŸå˜é‡

**å®šä¹‰ 2.2** (è‡ªç”±å˜é‡)
å˜é‡ $x$ åœ¨å…¬å¼ $\phi$ ä¸­æ˜¯è‡ªç”±çš„ï¼Œå¦‚æœï¼š

1. $\phi$ æ˜¯åŸå­å…¬å¼ä¸” $x$ åœ¨å…¶ä¸­å‡ºç°
2. $\phi = \neg\psi$ ä¸” $x$ åœ¨ $\psi$ ä¸­è‡ªç”±
3. $\phi = \psi \circ \chi$ ä¸” $x$ åœ¨ $\psi$ æˆ– $\chi$ ä¸­è‡ªç”±
4. $\phi = \forall y \psi$ æˆ– $\phi = \exists y \psi$ï¼Œä¸” $x \neq y$ ä¸” $x$ åœ¨ $\psi$ ä¸­è‡ªç”±

**å®šä¹‰ 2.3** (çº¦æŸå˜é‡)
å˜é‡ $x$ åœ¨å…¬å¼ $\phi$ ä¸­æ˜¯çº¦æŸçš„ï¼Œå¦‚æœå®ƒä¸æ˜¯è‡ªç”±çš„ã€‚

### 2.3 é—­å…¬å¼

**å®šä¹‰ 2.4** (é—­å…¬å¼)
å…¬å¼ $\phi$ æ˜¯é—­çš„ï¼Œå¦‚æœå®ƒä¸åŒ…å«è‡ªç”±å˜é‡ã€‚

## 3. è¯­æ³•ç³»ç»Ÿ

### 3.1 è¯­æ³•è§„åˆ™

**å®šä¹‰ 3.1** (è¯­æ³•è§„åˆ™)
è°“è¯é€»è¾‘çš„è¯­æ³•è§„åˆ™åŒ…æ‹¬ï¼š

1. **é¡¹å½¢æˆè§„åˆ™**ï¼š
   - å˜é‡å’Œå¸¸é‡æ˜¯é¡¹
   - å¦‚æœ $f$ æ˜¯ $n$ å…ƒå‡½æ•°ç¬¦å·ï¼Œ$t_1, \ldots, t_n$ æ˜¯é¡¹ï¼Œåˆ™ $f(t_1, \ldots, t_n)$ æ˜¯é¡¹

2. **å…¬å¼å½¢æˆè§„åˆ™**ï¼š
   - åŸå­å…¬å¼æ˜¯å…¬å¼
   - å¦‚æœ $\phi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\neg\phi$ æ˜¯å…¬å¼
   - å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $(\phi \land \psi)$ ç­‰æ˜¯å…¬å¼
   - å¦‚æœ $\phi$ æ˜¯å…¬å¼ï¼Œ$x$ æ˜¯å˜é‡ï¼Œåˆ™ $\forall x \phi$ å’Œ $\exists x \phi$ æ˜¯å…¬å¼

### 3.2 å­å…¬å¼

**å®šä¹‰ 3.2** (å­å…¬å¼)
å…¬å¼ $\psi$ æ˜¯å…¬å¼ $\phi$ çš„å­å…¬å¼ï¼Œå¦‚æœï¼š

1. $\phi = \psi$
2. $\phi = \neg\chi$ ä¸” $\psi$ æ˜¯ $\chi$ çš„å­å…¬å¼
3. $\phi = \chi \circ \xi$ ä¸” $\psi$ æ˜¯ $\chi$ æˆ– $\xi$ çš„å­å…¬å¼
4. $\phi = \forall x \chi$ æˆ– $\phi = \exists x \chi$ ä¸” $\psi$ æ˜¯ $\chi$ çš„å­å…¬å¼

### 3.3 æ›¿æ¢

**å®šä¹‰ 3.3** (æ›¿æ¢)
ç”¨é¡¹ $t$ æ›¿æ¢å˜é‡ $x$ åœ¨å…¬å¼ $\phi$ ä¸­çš„è‡ªç”±å‡ºç°ï¼Œè®°ä½œ $\phi[t/x]$ï¼Œå®šä¹‰ä¸ºï¼š

1. å¦‚æœ $\phi$ æ˜¯åŸå­å…¬å¼ï¼Œåˆ™ $\phi[t/x]$ æ˜¯å°† $\phi$ ä¸­ $x$ çš„æ‰€æœ‰å‡ºç°æ›¿æ¢ä¸º $t$
2. $[\neg\psi](t/x) = \neg(\psi[t/x])$
3. $[\psi \circ \chi](t/x) = (\psi[t/x]) \circ (\chi[t/x])$
4. $[\forall y \psi](t/x) = \forall y (\psi[t/x])$ (å¦‚æœ $y \neq x$)
5. $[\exists y \psi](t/x) = \exists y (\psi[t/x])$ (å¦‚æœ $y \neq x$)

## 4. è¯­ä¹‰ç³»ç»Ÿ

### 4.1 è§£é‡Š

**å®šä¹‰ 4.1** (è§£é‡Š)
è°“è¯é€»è¾‘çš„è§£é‡Š $\mathcal{I}$ æ˜¯ä¸€ä¸ªå››å…ƒç»„ï¼š
$$\mathcal{I} = \langle D, \mathcal{F}^I, \mathcal{P}^I, \mathcal{C}^I \rangle$$
å…¶ä¸­ï¼š

- $D$ æ˜¯è®ºåŸŸï¼ˆéç©ºé›†åˆï¼‰
- $\mathcal{F}^I$ æ˜¯å‡½æ•°è§£é‡Š
- $\mathcal{P}^I$ æ˜¯è°“è¯è§£é‡Š
- $\mathcal{C}^I$ æ˜¯å¸¸é‡è§£é‡Š

### 4.2 èµ‹å€¼

**å®šä¹‰ 4.2** (èµ‹å€¼)
èµ‹å€¼å‡½æ•° $v: \mathcal{V} \rightarrow D$ å°†å˜é‡æ˜ å°„åˆ°è®ºåŸŸä¸­çš„å…ƒç´ ã€‚

**å®šä¹‰ 4.3** (é¡¹è§£é‡Š)
é¡¹ $t$ åœ¨è§£é‡Š $\mathcal{I}$ å’Œèµ‹å€¼ $v$ ä¸‹çš„å€¼ $t^{\mathcal{I},v}$ å®šä¹‰ä¸ºï¼š

1. å¦‚æœ $t$ æ˜¯å˜é‡ $x$ï¼Œåˆ™ $t^{\mathcal{I},v} = v(x)$
2. å¦‚æœ $t$ æ˜¯å¸¸é‡ $c$ï¼Œåˆ™ $t^{\mathcal{I},v} = c^{\mathcal{I}}$
3. å¦‚æœ $t = f(t_1, \ldots, t_n)$ï¼Œåˆ™ $t^{\mathcal{I},v} = f^{\mathcal{I}}(t_1^{\mathcal{I},v}, \ldots, t_n^{\mathcal{I},v})$

### 4.3 æ»¡è¶³å…³ç³»

**å®šä¹‰ 4.4** (æ»¡è¶³å…³ç³»)
è§£é‡Š $\mathcal{I}$ å’Œèµ‹å€¼ $v$ æ»¡è¶³å…¬å¼ $\phi$ï¼Œè®°ä½œ $\mathcal{I}, v \models \phi$ï¼Œå®šä¹‰ä¸ºï¼š

1. $\mathcal{I}, v \models P(t_1, \ldots, t_n)$ å½“ä¸”ä»…å½“ $(t_1^{\mathcal{I},v}, \ldots, t_n^{\mathcal{I},v}) \in P^{\mathcal{I}}$
2. $\mathcal{I}, v \models \neg\phi$ å½“ä¸”ä»…å½“ $\mathcal{I}, v \not\models \phi$
3. $\mathcal{I}, v \models \phi \land \psi$ å½“ä¸”ä»…å½“ $\mathcal{I}, v \models \phi$ ä¸” $\mathcal{I}, v \models \psi$
4. $\mathcal{I}, v \models \phi \lor \psi$ å½“ä¸”ä»…å½“ $\mathcal{I}, v \models \phi$ æˆ– $\mathcal{I}, v \models \psi$
5. $\mathcal{I}, v \models \phi \rightarrow \psi$ å½“ä¸”ä»…å½“ $\mathcal{I}, v \not\models \phi$ æˆ– $\mathcal{I}, v \models \psi$
6. $\mathcal{I}, v \models \forall x \phi$ å½“ä¸”ä»…å½“å¯¹æ‰€æœ‰ $d \in D$ï¼Œ$\mathcal{I}, v[x \mapsto d] \models \phi$
7. $\mathcal{I}, v \models \exists x \phi$ å½“ä¸”ä»…å½“å­˜åœ¨ $d \in D$ï¼Œ$\mathcal{I}, v[x \mapsto d] \models \phi$

## 5. æ¨ç†ç³»ç»Ÿ

### 5.1 è‡ªç„¶æ¼”ç»ç³»ç»Ÿ

**å®šä¹‰ 5.1** (è‡ªç„¶æ¼”ç»è§„åˆ™)
è°“è¯é€»è¾‘çš„è‡ªç„¶æ¼”ç»ç³»ç»ŸåŒ…å«ä»¥ä¸‹è§„åˆ™ï¼š

**å…¨ç§°é‡è¯è§„åˆ™**ï¼š

- **å…¨ç§°å¼•å…¥**ï¼šå¦‚æœ $\phi$ æ˜¯é—­å…¬å¼ä¸” $\mathcal{I} \models \phi$ï¼Œåˆ™ $\mathcal{I} \models \forall x \phi$
- **å…¨ç§°æ¶ˆé™¤**ï¼š$\forall x \phi \vdash \phi[t/x]$

**å­˜åœ¨é‡è¯è§„åˆ™**ï¼š

- **å­˜åœ¨å¼•å…¥**ï¼š$\phi[t/x] \vdash \exists x \phi$
- **å­˜åœ¨æ¶ˆé™¤**ï¼šå¦‚æœ $\Gamma, \phi \vdash \psi$ ä¸” $x$ ä¸åœ¨ $\Gamma$ æˆ– $\psi$ ä¸­è‡ªç”±ï¼Œåˆ™ $\Gamma, \exists x \phi \vdash \psi$

### 5.2 å…¬ç†ç³»ç»Ÿ

**å®šä¹‰ 5.2** (å…¬ç†)
è°“è¯é€»è¾‘çš„å…¬ç†ç³»ç»ŸåŒ…å«ï¼š

1. **å‘½é¢˜é€»è¾‘å…¬ç†**ï¼šæ‰€æœ‰å‘½é¢˜é€»è¾‘çš„é‡è¨€å¼
2. **å…¨ç§°å®ä¾‹åŒ–**ï¼š$\forall x \phi \rightarrow \phi[t/x]$
3. **å­˜åœ¨æ¦‚æ‹¬**ï¼š$\phi[t/x] \rightarrow \exists x \phi$
4. **å…¨ç§°æ¦‚æ‹¬**ï¼šå¦‚æœ $\phi$ æ˜¯é—­å…¬å¼ï¼Œåˆ™ $\phi \rightarrow \forall x \phi$

### 5.3 æ¨ç†è§„åˆ™

**å®šä¹‰ 5.3** (æ¨ç†è§„åˆ™)

1. **åˆ†ç¦»è§„åˆ™**ï¼š$\phi, \phi \rightarrow \psi \vdash \psi$
2. **å…¨ç§°æ¦‚æ‹¬**ï¼šå¦‚æœ $\phi \vdash \psi$ ä¸” $x$ ä¸åœ¨ $\phi$ ä¸­è‡ªç”±ï¼Œåˆ™ $\phi \vdash \forall x \psi$
3. **å­˜åœ¨æ¦‚æ‹¬**ï¼šå¦‚æœ $\phi \vdash \psi$ ä¸” $x$ ä¸åœ¨ $\psi$ ä¸­è‡ªç”±ï¼Œåˆ™ $\exists x \phi \vdash \psi$

## 6. å½¢å¼åŒ–è¯æ˜

### 6.1 å®Œå¤‡æ€§å®šç†

**å®šç† 6.1** (å“¥å¾·å°”å®Œå¤‡æ€§å®šç†)
è°“è¯é€»è¾‘æ˜¯å®Œå¤‡çš„ï¼šå¦‚æœ $\Gamma \models \phi$ï¼Œåˆ™ $\Gamma \vdash \phi$ã€‚

**è¯æ˜**ï¼š

1. æ„é€ å…¸èŒƒæ¨¡å‹
2. è¯æ˜å…¸èŒƒæ¨¡å‹æ»¡è¶³æ‰€æœ‰å¯æ»¡è¶³çš„å…¬å¼é›†
3. åˆ©ç”¨ç´§è‡´æ€§å®šç†å®Œæˆè¯æ˜

### 6.2 ç´§è‡´æ€§å®šç†

**å®šç† 6.2** (ç´§è‡´æ€§å®šç†)
å¦‚æœå…¬å¼é›† $\Gamma$ çš„æ¯ä¸ªæœ‰é™å­é›†éƒ½æ˜¯å¯æ»¡è¶³çš„ï¼Œåˆ™ $\Gamma$ æœ¬èº«æ˜¯å¯æ»¡è¶³çš„ã€‚

**è¯æ˜**ï¼š

1. åˆ©ç”¨è¶…ç§¯æ„é€ 
2. åº”ç”¨è¶…æ»¤å­ç†è®º
3. è¯æ˜æ„é€ çš„æ¨¡å‹æ»¡è¶³ $\Gamma$

### 6.3 å‹’æ–‡æµ·å§†-æ–¯ç§‘ä¼¦å®šç†

**å®šç† 6.3** (å‹’æ–‡æµ·å§†-æ–¯ç§‘ä¼¦å®šç†)
å¦‚æœå¯æ•°è¯­è¨€çš„ç†è®ºæœ‰æ— é™æ¨¡å‹ï¼Œåˆ™å®ƒæœ‰ä»»æ„åŸºæ•°çš„æ¨¡å‹ã€‚

**è¯æ˜**ï¼š

1. åˆ©ç”¨è¶…ç§¯æ„é€ 
2. åº”ç”¨åŸºæ•°ç†è®º
3. è¯æ˜æ„é€ çš„æ¨¡å‹å…·æœ‰æ‰€éœ€åŸºæ•°

## 7. ä»£ç å®ç°

### 7.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet};
use std::fmt;

/// å˜é‡
#[derive(Debug, Clone, Hash, Eq, PartialEq)]
pub struct Variable {
    name: String,
}

impl Variable {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

/// å¸¸é‡
#[derive(Debug, Clone, Hash, Eq, PartialEq)]
pub struct Constant {
    name: String,
}

impl Constant {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

/// é¡¹
#[derive(Debug, Clone)]
pub enum Term {
    Variable(Variable),
    Constant(Constant),
    Function(String, Vec<Term>),
}

impl Term {
    pub fn variable(name: String) -> Self {
        Term::Variable(Variable::new(name))
    }

    pub fn constant(name: String) -> Self {
        Term::Constant(Constant::new(name))
    }

    pub fn function(name: String, args: Vec<Term>) -> Self {
        Term::Function(name, args)
    }

    /// è·å–é¡¹ä¸­çš„å˜é‡
    pub fn variables(&self) -> HashSet<Variable> {
        match self {
            Term::Variable(v) => {
                let mut vars = HashSet::new();
                vars.insert(v.clone());
                vars
            }
            Term::Constant(_) => HashSet::new(),
            Term::Function(_, args) => {
                let mut vars = HashSet::new();
                for arg in args {
                    vars.extend(arg.variables());
                }
                vars
            }
        }
    }

    /// æ›¿æ¢å˜é‡
    pub fn substitute(&self, var: &Variable, term: &Term) -> Term {
        match self {
            Term::Variable(v) if v == var => term.clone(),
            Term::Variable(v) => Term::Variable(v.clone()),
            Term::Constant(c) => Term::Constant(c.clone()),
            Term::Function(name, args) => {
                let new_args: Vec<Term> = args.iter()
                    .map(|arg| arg.substitute(var, term))
                    .collect();
                Term::Function(name.clone(), new_args)
            }
        }
    }
}

/// åŸå­å…¬å¼
#[derive(Debug, Clone)]
pub struct AtomicFormula {
    predicate: String,
    terms: Vec<Term>,
}

impl AtomicFormula {
    pub fn new(predicate: String, terms: Vec<Term>) -> Self {
        Self { predicate, terms }
    }

    /// è·å–å…¬å¼ä¸­çš„å˜é‡
    pub fn variables(&self) -> HashSet<Variable> {
        let mut vars = HashSet::new();
        for term in &self.terms {
            vars.extend(term.variables());
        }
        vars
    }

    /// æ›¿æ¢å˜é‡
    pub fn substitute(&self, var: &Variable, term: &Term) -> AtomicFormula {
        let new_terms: Vec<Term> = self.terms.iter()
            .map(|t| t.substitute(var, term))
            .collect();
        AtomicFormula::new(self.predicate.clone(), new_terms)
    }
}

/// å…¬å¼
#[derive(Debug, Clone)]
pub enum Formula {
    Atomic(AtomicFormula),
    Negation(Box<Formula>),
    Conjunction(Box<Formula>, Box<Formula>),
    Disjunction(Box<Formula>, Box<Formula>),
    Implication(Box<Formula>, Box<Formula>),
    Equivalence(Box<Formula>, Box<Formula>),
    Universal(Variable, Box<Formula>),
    Existential(Variable, Box<Formula>),
}

impl Formula {
    pub fn atomic(predicate: String, terms: Vec<Term>) -> Self {
        Formula::Atomic(AtomicFormula::new(predicate, terms))
    }

    pub fn negation(formula: Formula) -> Self {
        Formula::Negation(Box::new(formula))
    }

    pub fn conjunction(left: Formula, right: Formula) -> Self {
        Formula::Conjunction(Box::new(left), Box::new(right))
    }

    pub fn disjunction(left: Formula, right: Formula) -> Self {
        Formula::Disjunction(Box::new(left), Box::new(right))
    }

    pub fn implication(antecedent: Formula, consequent: Formula) -> Self {
        Formula::Implication(Box::new(antecedent), Box::new(consequent))
    }

    pub fn equivalence(left: Formula, right: Formula) -> Self {
        Formula::Equivalence(Box::new(left), Box::new(right))
    }

    pub fn universal(variable: Variable, formula: Formula) -> Self {
        Formula::Universal(variable, Box::new(formula))
    }

    pub fn existential(variable: Variable, formula: Formula) -> Self {
        Formula::Existential(variable, Box::new(formula))
    }

    /// è·å–å…¬å¼ä¸­çš„è‡ªç”±å˜é‡
    pub fn free_variables(&self) -> HashSet<Variable> {
        match self {
            Formula::Atomic(atomic) => atomic.variables(),
            Formula::Negation(formula) => formula.free_variables(),
            Formula::Conjunction(left, right) => {
                let mut vars = left.free_variables();
                vars.extend(right.free_variables());
                vars
            }
            Formula::Disjunction(left, right) => {
                let mut vars = left.free_variables();
                vars.extend(right.free_variables());
                vars
            }
            Formula::Implication(antecedent, consequent) => {
                let mut vars = antecedent.free_variables();
                vars.extend(consequent.free_variables());
                vars
            }
            Formula::Equivalence(left, right) => {
                let mut vars = left.free_variables();
                vars.extend(right.free_variables());
                vars
            }
            Formula::Universal(variable, formula) => {
                let mut vars = formula.free_variables();
                vars.remove(variable);
                vars
            }
            Formula::Existential(variable, formula) => {
                let mut vars = formula.free_variables();
                vars.remove(variable);
                vars
            }
        }
    }

    /// æ£€æŸ¥å…¬å¼æ˜¯å¦é—­åˆ
    pub fn is_closed(&self) -> bool {
        self.free_variables().is_empty()
    }

    /// æ›¿æ¢å˜é‡
    pub fn substitute(&self, var: &Variable, term: &Term) -> Formula {
        match self {
            Formula::Atomic(atomic) => {
                Formula::Atomic(atomic.substitute(var, term))
            }
            Formula::Negation(formula) => {
                Formula::Negation(Box::new(formula.substitute(var, term)))
            }
            Formula::Conjunction(left, right) => {
                Formula::Conjunction(
                    Box::new(left.substitute(var, term)),
                    Box::new(right.substitute(var, term))
                )
            }
            Formula::Disjunction(left, right) => {
                Formula::Disjunction(
                    Box::new(left.substitute(var, term)),
                    Box::new(right.substitute(var, term))
                )
            }
            Formula::Implication(antecedent, consequent) => {
                Formula::Implication(
                    Box::new(antecedent.substitute(var, term)),
                    Box::new(consequent.substitute(var, term))
                )
            }
            Formula::Equivalence(left, right) => {
                Formula::Equivalence(
                    Box::new(left.substitute(var, term)),
                    Box::new(right.substitute(var, term))
                )
            }
            Formula::Universal(v, formula) if v == var => {
                Formula::Universal(v.clone(), formula.clone())
            }
            Formula::Universal(v, formula) => {
                Formula::Universal(v.clone(), Box::new(formula.substitute(var, term)))
            }
            Formula::Existential(v, formula) if v == var => {
                Formula::Existential(v.clone(), formula.clone())
            }
            Formula::Existential(v, formula) => {
                Formula::Existential(v.clone(), Box::new(formula.substitute(var, term)))
            }
        }
    }
}

/// è§£é‡Š
#[derive(Debug, Clone)]
pub struct Interpretation {
    domain: Vec<String>,
    predicates: HashMap<String, Vec<Vec<String>>>,
    functions: HashMap<String, Vec<Vec<String>>>,
    constants: HashMap<String, String>,
}

impl Interpretation {
    pub fn new(domain: Vec<String>) -> Self {
        Self {
            domain,
            predicates: HashMap::new(),
            functions: HashMap::new(),
            constants: HashMap::new(),
        }
    }

    /// æ·»åŠ è°“è¯è§£é‡Š
    pub fn add_predicate(&mut self, name: String, extension: Vec<Vec<String>>) {
        self.predicates.insert(name, extension);
    }

    /// æ·»åŠ å‡½æ•°è§£é‡Š
    pub fn add_function(&mut self, name: String, mapping: Vec<Vec<String>>) {
        self.functions.insert(name, mapping);
    }

    /// æ·»åŠ å¸¸é‡è§£é‡Š
    pub fn add_constant(&mut self, name: String, value: String) {
        self.constants.insert(name, value);
    }

    /// è¯„ä¼°é¡¹
    pub fn evaluate_term(&self, term: &Term, assignment: &HashMap<String, String>) -> Option<String> {
        match term {
            Term::Variable(v) => assignment.get(&v.name).cloned(),
            Term::Constant(c) => self.constants.get(&c.name).cloned(),
            Term::Function(name, args) => {
                let arg_values: Vec<String> = args.iter()
                    .filter_map(|arg| self.evaluate_term(arg, assignment))
                    .collect();
                
                if arg_values.len() == args.len() {
                    self.functions.get(name)
                        .and_then(|mapping| {
                            mapping.iter()
                                .find(|m| m[..m.len()-1] == arg_values[..])
                                .map(|m| m.last().unwrap().clone())
                        })
                } else {
                    None
                }
            }
        }
    }

    /// è¯„ä¼°åŸå­å…¬å¼
    pub fn evaluate_atomic(&self, atomic: &AtomicFormula, assignment: &HashMap<String, String>) -> bool {
        let term_values: Vec<String> = atomic.terms.iter()
            .filter_map(|term| self.evaluate_term(term, assignment))
            .collect();
        
        if term_values.len() == atomic.terms.len() {
            self.predicates.get(&atomic.predicate)
                .map(|extension| extension.contains(&term_values))
                .unwrap_or(false)
        } else {
            false
        }
    }

    /// è¯„ä¼°å…¬å¼
    pub fn evaluate_formula(&self, formula: &Formula, assignment: &HashMap<String, String>) -> bool {
        match formula {
            Formula::Atomic(atomic) => self.evaluate_atomic(atomic, assignment),
            Formula::Negation(formula) => !self.evaluate_formula(formula, assignment),
            Formula::Conjunction(left, right) => {
                self.evaluate_formula(left, assignment) && self.evaluate_formula(right, assignment)
            }
            Formula::Disjunction(left, right) => {
                self.evaluate_formula(left, assignment) || self.evaluate_formula(right, assignment)
            }
            Formula::Implication(antecedent, consequent) => {
                !self.evaluate_formula(antecedent, assignment) || self.evaluate_formula(consequent, assignment)
            }
            Formula::Equivalence(left, right) => {
                self.evaluate_formula(left, assignment) == self.evaluate_formula(right, assignment)
            }
            Formula::Universal(variable, formula) => {
                self.domain.iter().all(|value| {
                    let mut new_assignment = assignment.clone();
                    new_assignment.insert(variable.name.clone(), value.clone());
                    self.evaluate_formula(formula, &new_assignment)
                })
            }
            Formula::Existential(variable, formula) => {
                self.domain.iter().any(|value| {
                    let mut new_assignment = assignment.clone();
                    new_assignment.insert(variable.name.clone(), value.clone());
                    self.evaluate_formula(formula, &new_assignment)
                })
            }
        }
    }
}

/// è°“è¯é€»è¾‘æ¨ç†å™¨
#[derive(Debug, Clone)]
pub struct PredicateLogicReasoner {
    interpretation: Interpretation,
}

impl PredicateLogicReasoner {
    pub fn new(interpretation: Interpretation) -> Self {
        Self { interpretation }
    }

    /// æ£€æŸ¥å…¬å¼æœ‰æ•ˆæ€§
    pub fn is_valid(&self, formula: &Formula) -> bool {
        let empty_assignment = HashMap::new();
        self.interpretation.evaluate_formula(formula, &empty_assignment)
    }

    /// æ£€æŸ¥å…¬å¼å¯æ»¡è¶³æ€§
    pub fn is_satisfiable(&self, formula: &Formula) -> bool {
        // ç®€åŒ–ç‰ˆæœ¬ï¼šæ£€æŸ¥æ˜¯å¦å­˜åœ¨èµ‹å€¼ä½¿å…¬å¼ä¸ºçœŸ
        let empty_assignment = HashMap::new();
        self.interpretation.evaluate_formula(formula, &empty_assignment)
    }

    /// æ£€æŸ¥é€»è¾‘è•´æ¶µ
    pub fn entails(&self, premises: &[Formula], conclusion: &Formula) -> bool {
        // ç®€åŒ–ç‰ˆæœ¬ï¼šæ£€æŸ¥æ‰€æœ‰å‰æä¸ºçœŸæ—¶ç»“è®ºæ˜¯å¦ä¸ºçœŸ
        let empty_assignment = HashMap::new();
        let all_premises_true = premises.iter()
            .all(|premise| self.interpretation.evaluate_formula(premise, &empty_assignment));
        
        if all_premises_true {
            self.interpretation.evaluate_formula(conclusion, &empty_assignment)
        } else {
            true // å¦‚æœå‰æä¸éƒ½ä¸ºçœŸï¼Œåˆ™è•´æ¶µæˆç«‹
        }
    }

    /// å…¨ç§°å®ä¾‹åŒ–
    pub fn universal_instantiation(&self, universal: &Formula, term: &Term) -> Option<Formula> {
        if let Formula::Universal(variable, formula) = universal {
            Some(formula.substitute(variable, term))
        } else {
            None
        }
    }

    /// å­˜åœ¨æ¦‚æ‹¬
    pub fn existential_generalization(&self, formula: &Formula, term: &Term, variable: &Variable) -> Formula {
        let substituted = formula.substitute(variable, term);
        Formula::Existential(variable.clone(), Box::new(substituted))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_predicate_logic() {
        // åˆ›å»ºè§£é‡Š
        let mut interpretation = Interpretation::new(vec!["a".to_string(), "b".to_string(), "c".to_string()]);
        
        // æ·»åŠ è°“è¯
        interpretation.add_predicate(
            "P".to_string(),
            vec![vec!["a".to_string()], vec!["b".to_string()]]
        );
        
        // åˆ›å»ºå…¬å¼
        let x = Term::variable("x".to_string());
        let a = Term::constant("a".to_string());
        let b = Term::constant("b".to_string());
        
        let px = Formula::atomic("P".to_string(), vec![x.clone()]);
        let pa = Formula::atomic("P".to_string(), vec![a.clone()]);
        let pb = Formula::atomic("P".to_string(), vec![b.clone()]);
        
        let universal = Formula::universal(Variable::new("x".to_string()), px);
        let existential = Formula::existential(Variable::new("x".to_string()), px);
        
        // æµ‹è¯•æ¨ç†å™¨
        let reasoner = PredicateLogicReasoner::new(interpretation);
        let empty_assignment = HashMap::new();
        
        // æµ‹è¯•å…¨ç§°å®ä¾‹åŒ–
        let instantiated = reasoner.universal_instantiation(&universal, &a);
        assert_eq!(instantiated, Some(pa));
        
        // æµ‹è¯•å­˜åœ¨æ¦‚æ‹¬
        let generalized = reasoner.existential_generalization(&pa, &a, &Variable::new("x".to_string()));
        assert_eq!(generalized, existential);
    }
}
```

### 7.2 Haskell å®ç°

```haskell
module PredicateLogic where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Maybe (fromMaybe)

-- å˜é‡
data Variable = Variable String deriving (Show, Eq, Ord)

-- å¸¸é‡
data Constant = Constant String deriving (Show, Eq, Ord)

-- é¡¹
data Term = Var Variable | Const Constant | Func String [Term] deriving (Show, Eq)

-- åŸå­å…¬å¼
data AtomicFormula = AtomicFormula String [Term] deriving (Show, Eq)

-- å…¬å¼
data Formula = Atomic AtomicFormula
             | Negation Formula
             | Conjunction Formula Formula
             | Disjunction Formula Formula
             | Implication Formula Formula
             | Equivalence Formula Formula
             | Universal Variable Formula
             | Existential Variable Formula
             deriving (Show, Eq)

-- è§£é‡Š
data Interpretation = Interpretation
    { domain :: [String]
    , predicates :: Map String [[String]]
    , functions :: Map String [[String]]
    , constants :: Map String String
    } deriving (Show, Eq)

-- åˆ›å»ºç©ºè§£é‡Š
emptyInterpretation :: [String] -> Interpretation
emptyInterpretation domain = Interpretation
    { domain = domain
    , predicates = Map.empty
    , functions = Map.empty
    , constants = Map.empty
    }

-- æ·»åŠ è°“è¯è§£é‡Š
addPredicate :: String -> [[String]] -> Interpretation -> Interpretation
addPredicate name extension interpretation = interpretation
    { predicates = Map.insert name extension (predicates interpretation)
    }

-- æ·»åŠ å‡½æ•°è§£é‡Š
addFunction :: String -> [[String]] -> Interpretation -> Interpretation
addFunction name mapping interpretation = interpretation
    { functions = Map.insert name mapping (functions interpretation)
    }

-- æ·»åŠ å¸¸é‡è§£é‡Š
addConstant :: String -> String -> Interpretation -> Interpretation
addConstant name value interpretation = interpretation
    { constants = Map.insert name value (constants interpretation)
    }

-- è·å–é¡¹ä¸­çš„å˜é‡
termVariables :: Term -> Set Variable
termVariables (Var v) = Set.singleton v
termVariables (Const _) = Set.empty
termVariables (Func _ args) = Set.unions (map termVariables args)

-- æ›¿æ¢é¡¹ä¸­çš„å˜é‡
substituteTerm :: Term -> Variable -> Term -> Term
substituteTerm (Var v) var term
    | v == var = term
    | otherwise = Var v
substituteTerm (Const c) _ _ = Const c
substituteTerm (Func name args) var term = Func name (map (\arg -> substituteTerm arg var term) args)

-- è·å–å…¬å¼ä¸­çš„è‡ªç”±å˜é‡
freeVariables :: Formula -> Set Variable
freeVariables (Atomic (AtomicFormula _ terms)) = Set.unions (map termVariables terms)
freeVariables (Negation formula) = freeVariables formula
freeVariables (Conjunction left right) = Set.union (freeVariables left) (freeVariables right)
freeVariables (Disjunction left right) = Set.union (freeVariables left) (freeVariables right)
freeVariables (Implication antecedent consequent) = Set.union (freeVariables antecedent) (freeVariables consequent)
freeVariables (Equivalence left right) = Set.union (freeVariables left) (freeVariables right)
freeVariables (Universal variable formula) = Set.delete variable (freeVariables formula)
freeVariables (Existential variable formula) = Set.delete variable (freeVariables formula)

-- æ£€æŸ¥å…¬å¼æ˜¯å¦é—­åˆ
isClosed :: Formula -> Bool
isClosed formula = Set.null (freeVariables formula)

-- æ›¿æ¢å…¬å¼ä¸­çš„å˜é‡
substituteFormula :: Formula -> Variable -> Term -> Formula
substituteFormula (Atomic (AtomicFormula pred terms)) var term = 
    Atomic (AtomicFormula pred (map (\t -> substituteTerm t var term) terms))
substituteFormula (Negation formula) var term = 
    Negation (substituteFormula formula var term)
substituteFormula (Conjunction left right) var term = 
    Conjunction (substituteFormula left var term) (substituteFormula right var term)
substituteFormula (Disjunction left right) var term = 
    Disjunction (substituteFormula left var term) (substituteFormula right var term)
substituteFormula (Implication antecedent consequent) var term = 
    Implication (substituteFormula antecedent var term) (substituteFormula consequent var term)
substituteFormula (Equivalence left right) var term = 
    Equivalence (substituteFormula left var term) (substituteFormula right var term)
substituteFormula (Universal v formula) var term
    | v == var = Universal v formula
    | otherwise = Universal v (substituteFormula formula var term)
substituteFormula (Existential v formula) var term
    | v == var = Existential v formula
    | otherwise = Existential v (substituteFormula formula var term)

-- è¯„ä¼°é¡¹
evaluateTerm :: Term -> Map String String -> Interpretation -> Maybe String
evaluateTerm (Var v) assignment _ = Map.lookup (show v) assignment
evaluateTerm (Const c) _ interpretation = Map.lookup (show c) (constants interpretation)
evaluateTerm (Func name args) assignment interpretation = 
    let argValues = map (\arg -> evaluateTerm arg assignment interpretation) args
    in if all (/= Nothing) argValues then
        let values = map fromMaybe "" argValues
        in Map.lookup name (functions interpretation) >>= 
           find (\mapping -> take (length mapping - 1) mapping == values) >>=
           return . last
    else Nothing

-- è¯„ä¼°åŸå­å…¬å¼
evaluateAtomic :: AtomicFormula -> Map String String -> Interpretation -> Bool
evaluateAtomic (AtomicFormula pred terms) assignment interpretation = 
    let termValues = map (\term -> evaluateTerm term assignment interpretation) terms
    in if all (/= Nothing) termValues then
        let values = map fromMaybe "" termValues
        in fromMaybe False (Map.lookup pred (predicates interpretation) >>= 
           return . elem values)
    else False

-- è¯„ä¼°å…¬å¼
evaluateFormula :: Formula -> Map String String -> Interpretation -> Bool
evaluateFormula (Atomic atomic) assignment interpretation = 
    evaluateAtomic atomic assignment interpretation
evaluateFormula (Negation formula) assignment interpretation = 
    not (evaluateFormula formula assignment interpretation)
evaluateFormula (Conjunction left right) assignment interpretation = 
    evaluateFormula left assignment interpretation && 
    evaluateFormula right assignment interpretation
evaluateFormula (Disjunction left right) assignment interpretation = 
    evaluateFormula left assignment interpretation || 
    evaluateFormula right assignment interpretation
evaluateFormula (Implication antecedent consequent) assignment interpretation = 
    not (evaluateFormula antecedent assignment interpretation) || 
    evaluateFormula consequent assignment interpretation
evaluateFormula (Equivalence left right) assignment interpretation = 
    evaluateFormula left assignment interpretation == 
    evaluateFormula right assignment interpretation
evaluateFormula (Universal variable formula) assignment interpretation = 
    all (\value -> 
        let newAssignment = Map.insert (show variable) value assignment
        in evaluateFormula formula newAssignment interpretation
    ) (domain interpretation)
evaluateFormula (Existential variable formula) assignment interpretation = 
    any (\value -> 
        let newAssignment = Map.insert (show variable) value assignment
        in evaluateFormula formula newAssignment interpretation
    ) (domain interpretation)

-- è°“è¯é€»è¾‘æ¨ç†å™¨
data PredicateLogicReasoner = PredicateLogicReasoner
    { interpretation :: Interpretation
    } deriving (Show, Eq)

-- æ£€æŸ¥å…¬å¼æœ‰æ•ˆæ€§
isValid :: Formula -> PredicateLogicReasoner -> Bool
isValid formula reasoner = 
    evaluateFormula formula Map.empty (interpretation reasoner)

-- æ£€æŸ¥å…¬å¼å¯æ»¡è¶³æ€§
isSatisfiable :: Formula -> PredicateLogicReasoner -> Bool
isSatisfiable formula reasoner = 
    evaluateFormula formula Map.empty (interpretation reasoner)

-- æ£€æŸ¥é€»è¾‘è•´æ¶µ
entails :: [Formula] -> Formula -> PredicateLogicReasoner -> Bool
entails premises conclusion reasoner = 
    let allPremisesTrue = all (\premise -> 
        evaluateFormula premise Map.empty (interpretation reasoner)) premises
    in if allPremisesTrue then
        evaluateFormula conclusion Map.empty (interpretation reasoner)
    else True

-- å…¨ç§°å®ä¾‹åŒ–
universalInstantiation :: Formula -> Term -> Maybe Formula
universalInstantiation (Universal variable formula) term = 
    Just (substituteFormula formula variable term)
universalInstantiation _ _ = Nothing

-- å­˜åœ¨æ¦‚æ‹¬
existentialGeneralization :: Formula -> Term -> Variable -> Formula
existentialGeneralization formula term variable = 
    Existential variable (substituteFormula formula variable term)

-- ç¤ºä¾‹ä½¿ç”¨
example :: IO ()
example = do
    let interpretation = emptyInterpretation ["a", "b", "c"]
        interpretation' = addPredicate "P" [["a"], ["b"]] interpretation
        
        x = Var (Variable "x")
        a = Const (Constant "a")
        b = Const (Constant "b")
        
        px = Atomic (AtomicFormula "P" [x])
        pa = Atomic (AtomicFormula "P" [a])
        pb = Atomic (AtomicFormula "P" [b])
        
        universal = Universal (Variable "x") px
        existential = Existential (Variable "x") px
        
        reasoner = PredicateLogicReasoner interpretation'
    
    putStrLn "Predicate Logic Example:"
    putStrLn $ "Universal instantiation: " ++ show (universalInstantiation universal a)
    putStrLn $ "Existential generalization: " ++ show (existentialGeneralization pa a (Variable "x"))
    putStrLn $ "Formula is closed: " ++ show (isClosed universal)

main :: IO ()
main = example
```

## 8. åº”ç”¨ç¤ºä¾‹

### 8.1 æ•°å­¦é€»è¾‘

**ç¤ºä¾‹ 8.1** (æ•°å­¦å‘½é¢˜)

```rust
// æ•°å­¦å‘½é¢˜åˆ†æ
let mut math_logic = PredicateLogicReasoner::new(
    Interpretation::new(vec!["0".to_string(), "1".to_string(), "2".to_string()])
);

// åˆ›å»ºæ•°å­¦å…¬å¼
let x = Term::variable("x".to_string());
let y = Term::variable("y".to_string());
let zero = Term::constant("0".to_string());

// åˆ›å»ºè°“è¯
let greater_than_zero = Formula::atomic("GtZero".to_string(), vec![x.clone()]);
let equal = Formula::atomic("Equal".to_string(), vec![x.clone(), y.clone()]);

// å…¨ç§°å‘½é¢˜ï¼šæ‰€æœ‰æ•°éƒ½å¤§äºé›¶
let universal_gt = Formula::universal(
    Variable::new("x".to_string()),
    greater_than_zero
);

// å­˜åœ¨å‘½é¢˜ï¼šå­˜åœ¨æ•°ç­‰äºé›¶
let existential_eq = Formula::existential(
    Variable::new("x".to_string()),
    Formula::atomic("Equal".to_string(), vec![x.clone(), zero.clone()])
);

// éªŒè¯é€»è¾‘æ¨ç†
assert!(math_logic.is_valid(&universal_gt));
assert!(!math_logic.is_valid(&existential_eq));
```

### 8.2 å“²å­¦é€»è¾‘

**ç¤ºä¾‹ 8.2** (å“²å­¦å‘½é¢˜)

```rust
// å“²å­¦å‘½é¢˜åˆ†æ
let mut philosophy_logic = PredicateLogicReasoner::new(
    Interpretation::new(vec!["Socrates".to_string(), "Plato".to_string(), "Aristotle".to_string()])
);

// åˆ›å»ºå“²å­¦å…¬å¼
let x = Term::variable("x".to_string());
let socrates = Term::constant("Socrates".to_string());

// åˆ›å»ºè°“è¯
let is_mortal = Formula::atomic("Mortal".to_string(), vec![x.clone()]);
let is_man = Formula::atomic("Man".to_string(), vec![x.clone()]);

// è‹æ ¼æ‹‰åº•ä¸‰æ®µè®º
let all_men_mortal = Formula::universal(
    Variable::new("x".to_string()),
    Formula::implication(
        Formula::atomic("Man".to_string(), vec![x.clone()]),
        Formula::atomic("Mortal".to_string(), vec![x.clone()])
    )
);

let socrates_man = Formula::atomic("Man".to_string(), vec![socrates.clone()]);
let socrates_mortal = Formula::atomic("Mortal".to_string(), vec![socrates.clone()]);

// éªŒè¯ä¸‰æ®µè®ºæ¨ç†
assert!(philosophy_logic.entails(&[all_men_mortal, socrates_man], &socrates_mortal));
```

## 9. ç›¸å…³ç†è®º

### 9.1 ä¸å‘½é¢˜é€»è¾‘çš„å…³ç³»

è°“è¯é€»è¾‘æ˜¯å‘½é¢˜é€»è¾‘çš„æ‰©å±•ï¼Œå¼•å…¥äº†é‡è¯å’Œè°“è¯ï¼Œèƒ½å¤Ÿè¡¨è¾¾æ›´å¤æ‚çš„é€»è¾‘ç»“æ„ã€‚

### 9.2 ä¸é›†åˆè®ºçš„å…³ç³»

è°“è¯é€»è¾‘çš„è¯­ä¹‰å¯ä»¥åŸºäºé›†åˆè®ºæ¥å®šä¹‰ï¼Œé€šè¿‡è®ºåŸŸå’Œè§£é‡Šæ¥ç»™å‡ºå½¢å¼åŒ–è¯­ä¹‰ã€‚

### 9.3 ä¸æ¨¡å‹è®ºçš„å…³ç³»

è°“è¯é€»è¾‘çš„æ¨¡å‹è®ºç ”ç©¶å…¬å¼åœ¨ä¸åŒè§£é‡Šä¸‹çš„çœŸå€¼ï¼Œä¸ºé€»è¾‘æ¨ç†æä¾›è¯­ä¹‰åŸºç¡€ã€‚

## 10. å‚è€ƒæ–‡çŒ®

1. Enderton, H. B. *A Mathematical Introduction to Logic*. Academic Press, 2001.
2. Mendelson, E. *Introduction to Mathematical Logic*. Chapman & Hall, 2009.
3. Shoenfield, J. R. *Mathematical Logic*. A K Peters, 2001.
4. Boolos, G. S., Burgess, J. P., & Jeffrey, R. C. *Computability and Logic*. Cambridge University Press, 2007.
5. van Dalen, D. *Logic and Structure*. Springer, 2013.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.2.1 å‘½é¢˜é€»è¾‘](../02.2.1_å‘½é¢˜é€»è¾‘.md)
- [02.2.3 æ¨¡æ€é€»è¾‘](../02.2.3_æ¨¡æ€é€»è¾‘.md)
- [02.2.4 ç›´è§‰é€»è¾‘](../02.2.4_ç›´è§‰é€»è¾‘.md)
- [01.4.1 é€»è¾‘åŸºç¡€](../../01_Philosophical_Foundation/01.4.1_é€»è¾‘åŸºç¡€.md)
- [01.4.2 æ¨ç†ç†è®º](../../01_Philosophical_Foundation/01.4.2_æ¨ç†ç†è®º.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
