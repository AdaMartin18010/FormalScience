# 02.2.1 å‘½é¢˜é€»è¾‘

## ğŸ“‹ æ¦‚è¿°

å‘½é¢˜é€»è¾‘æ˜¯æ•°ç†é€»è¾‘çš„åŸºç¡€åˆ†æ”¯ï¼Œç ”ç©¶å‘½é¢˜ä¹‹é—´çš„é€»è¾‘å…³ç³»å’Œæ¨ç†è§„åˆ™ã€‚å‘½é¢˜é€»è¾‘ä»¥åŸå­å‘½é¢˜ä¸ºåŸºæœ¬å•ä½ï¼Œé€šè¿‡é€»è¾‘è¿æ¥è¯æ„å»ºå¤åˆå‘½é¢˜ï¼Œå»ºç«‹å½¢å¼åŒ–çš„æ¨ç†ç³»ç»Ÿã€‚å®ƒæ˜¯è®¡ç®—æœºç§‘å­¦ã€äººå·¥æ™ºèƒ½å’Œæ•°å­¦æ¨ç†çš„é‡è¦ç†è®ºåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å‘½é¢˜ç³»ç»Ÿå»ºç«‹**: æ„å»ºå½¢å¼åŒ–çš„å‘½é¢˜ç³»ç»Ÿ
2. **é€»è¾‘è¿æ¥è¯å®šä¹‰**: å®šä¹‰åŸºæœ¬çš„é€»è¾‘è¿æ¥è¯
3. **æ¨ç†è§„åˆ™ç ”ç©¶**: å»ºç«‹æœ‰æ•ˆçš„æ¨ç†è§„åˆ™
4. **å½¢å¼åŒ–è¯æ˜**: æ„å»ºå½¢å¼åŒ–çš„è¯æ˜ç³»ç»Ÿ

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å‘½é¢˜

**å®šä¹‰**: å‘½é¢˜æ˜¯å…·æœ‰ç¡®å®šçœŸå€¼çš„é™ˆè¿°å¥ã€‚

**å½¢å¼åŒ–å®šä¹‰**:
è®¾ $P$ ä¸ºå‘½é¢˜å˜å…ƒé›†åˆï¼Œåˆ™å‘½é¢˜è¯­è¨€ $\mathcal{L}$ å®šä¹‰ä¸ºï¼š
$$\mathcal{L} = P \cup \{\neg, \land, \lor, \rightarrow, \leftrightarrow, (, )\}$$

### 1.2 é€»è¾‘è¿æ¥è¯

#### 1.2.1 å¦å®š (Negation)

**å®šä¹‰**: å¦å®šè¿æ¥è¯ $\neg$ å°†çœŸå‘½é¢˜å˜ä¸ºå‡å‘½é¢˜ï¼Œå‡å‘½é¢˜å˜ä¸ºçœŸå‘½é¢˜ã€‚

**çœŸå€¼è¡¨**:

| $p$ | $\neg p$ |
|-----|----------|
| T   | F        |
| F   | T        |

#### 1.2.2 åˆå– (Conjunction)

**å®šä¹‰**: åˆå–è¿æ¥è¯ $\land$ è¡¨ç¤º"ä¸”"çš„å…³ç³»ã€‚

**çœŸå€¼è¡¨**:

| $p$ | $q$ | $p \land q$ |
|-----|-----|-------------|
| T   | T   | T           |
| T   | F   | F           |
| F   | T   | F           |
| F   | F   | F           |

#### 1.2.3 æå– (Disjunction)

**å®šä¹‰**: æå–è¿æ¥è¯ $\lor$ è¡¨ç¤º"æˆ–"çš„å…³ç³»ã€‚

**çœŸå€¼è¡¨**:

| $p$ | $q$ | $p \lor q$ |
|-----|-----|------------|
| T   | T   | T          |
| T   | F   | T          |
| F   | T   | T          |
| F   | F   | F          |

#### 1.2.4 è•´å« (Implication)

**å®šä¹‰**: è•´å«è¿æ¥è¯ $\rightarrow$ è¡¨ç¤º"å¦‚æœ...é‚£ä¹ˆ..."çš„å…³ç³»ã€‚

**çœŸå€¼è¡¨**:

| $p$ | $q$ | $p \rightarrow q$ |
|-----|-----|-------------------|
| T   | T   | T                 |
| T   | F   | F                 |
| F   | T   | T                 |
| F   | F   | T                 |

#### 1.2.5 ç­‰ä»· (Equivalence)

**å®šä¹‰**: ç­‰ä»·è¿æ¥è¯ $\leftrightarrow$ è¡¨ç¤º"å½“ä¸”ä»…å½“"çš„å…³ç³»ã€‚

**çœŸå€¼è¡¨**:

| $p$ | $q$ | $p \leftrightarrow q$ |
|-----|-----|----------------------|
| T   | T   | T                    |
| T   | F   | F                    |
| F   | T   | F                    |
| F   | F   | T                    |

### 1.3 å‘½é¢˜å…¬å¼

**å®šä¹‰**: å‘½é¢˜å…¬å¼çš„é€’å½’å®šä¹‰ï¼š

1. **åŸå­å…¬å¼**: æ¯ä¸ªå‘½é¢˜å˜å…ƒ $p \in P$ æ˜¯å…¬å¼
2. **å¤åˆå…¬å¼**:
   - å¦‚æœ $\phi$ æ˜¯å…¬å¼ï¼Œåˆ™ $\neg \phi$ æ˜¯å…¬å¼
   - å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $(\phi \land \psi)$ æ˜¯å…¬å¼
   - å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $(\phi \lor \psi)$ æ˜¯å…¬å¼
   - å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $(\phi \rightarrow \psi)$ æ˜¯å…¬å¼
   - å¦‚æœ $\phi$ å’Œ $\psi$ æ˜¯å…¬å¼ï¼Œåˆ™ $(\phi \leftrightarrow \psi)$ æ˜¯å…¬å¼

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å‘½é¢˜é€»è¾‘çš„å…¬ç†ç³»ç»Ÿ

**Hilbertå…¬ç†ç³»ç»Ÿ**:

1. **A1**: $\phi \rightarrow (\psi \rightarrow \phi)$
2. **A2**: $(\phi \rightarrow (\psi \rightarrow \chi)) \rightarrow ((\phi \rightarrow \psi) \rightarrow (\phi \rightarrow \chi))$
3. **A3**: $(\neg \phi \rightarrow \neg \psi) \rightarrow (\psi \rightarrow \phi)$

**æ¨ç†è§„åˆ™**:

- **åˆ†ç¦»è§„åˆ™ (MP)**: ä» $\phi$ å’Œ $\phi \rightarrow \psi$ æ¨å‡º $\psi$

### 2.2 è¯­ä¹‰å®šä¹‰

**èµ‹å€¼å‡½æ•°**: $v: P \rightarrow \{T, F\}$

**çœŸå€¼å‡½æ•°**: $V: \mathcal{L} \rightarrow \{T, F\}$ é€’å½’å®šä¹‰ä¸ºï¼š

1. $V(p) = v(p)$ å¯¹äº $p \in P$
2. $V(\neg \phi) = T$ å½“ä¸”ä»…å½“ $V(\phi) = F$
3. $V(\phi \land \psi) = T$ å½“ä¸”ä»…å½“ $V(\phi) = T$ ä¸” $V(\psi) = T$
4. $V(\phi \lor \psi) = T$ å½“ä¸”ä»…å½“ $V(\phi) = T$ æˆ– $V(\psi) = T$
5. $V(\phi \rightarrow \psi) = T$ å½“ä¸”ä»…å½“ $V(\phi) = F$ æˆ– $V(\psi) = T$
6. $V(\phi \leftrightarrow \psi) = T$ å½“ä¸”ä»…å½“ $V(\phi) = V(\psi)$

### 2.3 é€»è¾‘æ¦‚å¿µ

#### 2.3.1 é‡è¨€å¼ (Tautology)

**å®šä¹‰**: å…¬å¼ $\phi$ æ˜¯é‡è¨€å¼ï¼Œå½“ä¸”ä»…å½“å¯¹æ‰€æœ‰èµ‹å€¼ $v$ï¼Œéƒ½æœ‰ $V(\phi) = T$ã€‚

#### 2.3.2 çŸ›ç›¾å¼ (Contradiction)

**å®šä¹‰**: å…¬å¼ $\phi$ æ˜¯çŸ›ç›¾å¼ï¼Œå½“ä¸”ä»…å½“å¯¹æ‰€æœ‰èµ‹å€¼ $v$ï¼Œéƒ½æœ‰ $V(\phi) = F$ã€‚

#### 2.3.3 å¯æ»¡è¶³å¼ (Satisfiable)

**å®šä¹‰**: å…¬å¼ $\phi$ æ˜¯å¯æ»¡è¶³çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨èµ‹å€¼ $v$ï¼Œä½¿å¾— $V(\phi) = T$ã€‚

#### 2.3.4 é€»è¾‘ç­‰ä»· (Logical Equivalence)

**å®šä¹‰**: å…¬å¼ $\phi$ å’Œ $\psi$ é€»è¾‘ç­‰ä»·ï¼Œè®°ä½œ $\phi \equiv \psi$ï¼Œå½“ä¸”ä»…å½“å¯¹æ‰€æœ‰èµ‹å€¼ $v$ï¼Œéƒ½æœ‰ $V(\phi) = V(\psi)$ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬é€»è¾‘å®šå¾‹

#### 3.1.1 åŒé‡å¦å®šå¾‹

**å®šç†**: $\neg \neg \phi \equiv \phi$

**è¯æ˜**:

1. è®¾ $v$ ä¸ºä»»æ„èµ‹å€¼
2. å¦‚æœ $V(\phi) = T$ï¼Œåˆ™ $V(\neg \phi) = F$ï¼Œå› æ­¤ $V(\neg \neg \phi) = T$
3. å¦‚æœ $V(\phi) = F$ï¼Œåˆ™ $V(\neg \phi) = T$ï¼Œå› æ­¤ $V(\neg \neg \phi) = F$
4. å› æ­¤ $V(\neg \neg \phi) = V(\phi)$ å¯¹æ‰€æœ‰èµ‹å€¼æˆç«‹
5. æ‰€ä»¥ $\neg \neg \phi \equiv \phi$

#### 3.1.2 å¾·æ‘©æ ¹å¾‹

**å®šç†**:

1. $\neg(\phi \land \psi) \equiv \neg \phi \lor \neg \psi$
2. $\neg(\phi \lor \psi) \equiv \neg \phi \land \neg \psi$

**è¯æ˜** (ç¬¬ä¸€ä¸ªå®šå¾‹):

1. è®¾ $v$ ä¸ºä»»æ„èµ‹å€¼
2. $V(\neg(\phi \land \psi)) = T$ å½“ä¸”ä»…å½“ $V(\phi \land \psi) = F$
3. $V(\phi \land \psi) = F$ å½“ä¸”ä»…å½“ $V(\phi) = F$ æˆ– $V(\psi) = F$
4. å½“ä¸”ä»…å½“ $V(\neg \phi) = T$ æˆ– $V(\neg \psi) = T$
5. å½“ä¸”ä»…å½“ $V(\neg \phi \lor \neg \psi) = T$
6. å› æ­¤ $\neg(\phi \land \psi) \equiv \neg \phi \lor \neg \psi$

#### 3.1.3 åˆ†é…å¾‹

**å®šç†**:

1. $\phi \land (\psi \lor \chi) \equiv (\phi \land \psi) \lor (\phi \land \chi)$
2. $\phi \lor (\psi \land \chi) \equiv (\phi \lor \psi) \land (\phi \lor \chi)$

#### 3.1.4 è•´å«çš„ç­‰ä»·å½¢å¼

**å®šç†**: $\phi \rightarrow \psi \equiv \neg \phi \lor \psi$

**è¯æ˜**:

1. è®¾ $v$ ä¸ºä»»æ„èµ‹å€¼
2. $V(\phi \rightarrow \psi) = T$ å½“ä¸”ä»…å½“ $V(\phi) = F$ æˆ– $V(\psi) = T$
3. å½“ä¸”ä»…å½“ $V(\neg \phi) = T$ æˆ– $V(\psi) = T$
4. å½“ä¸”ä»…å½“ $V(\neg \phi \lor \psi) = T$
5. å› æ­¤ $\phi \rightarrow \psi \equiv \neg \phi \lor \psi$

### 3.2 æ¨ç†è§„åˆ™

#### 3.2.1 å‡è¨€æ¨ç† (Modus Ponens)

**å®šç†**: å¦‚æœ $\phi$ å’Œ $\phi \rightarrow \psi$ éƒ½æ˜¯é‡è¨€å¼ï¼Œé‚£ä¹ˆ $\psi$ ä¹Ÿæ˜¯é‡è¨€å¼ã€‚

**è¯æ˜**:

1. å‡è®¾ $\phi$ å’Œ $\phi \rightarrow \psi$ éƒ½æ˜¯é‡è¨€å¼
2. å¯¹äºä»»æ„èµ‹å€¼ $v$ï¼Œ$V(\phi) = T$ ä¸” $V(\phi \rightarrow \psi) = T$
3. ä» $V(\phi \rightarrow \psi) = T$ å’Œ $V(\phi) = T$ å¾—åˆ° $V(\psi) = T$
4. å› æ­¤ $\psi$ å¯¹æ‰€æœ‰èµ‹å€¼éƒ½ä¸ºçœŸ
5. æ‰€ä»¥ $\psi$ æ˜¯é‡è¨€å¼

#### 3.2.2 åè¯æ³• (Reductio ad Absurdum)

**å®šç†**: å¦‚æœ $\neg \phi$ å¯¼è‡´çŸ›ç›¾ï¼Œé‚£ä¹ˆ $\phi$ æ˜¯é‡è¨€å¼ã€‚

**è¯æ˜**:

1. å‡è®¾ $\neg \phi$ å¯¼è‡´çŸ›ç›¾
2. è¿™æ„å‘³ç€ $\neg \phi$ æ˜¯çŸ›ç›¾å¼
3. å› æ­¤å¯¹æ‰€æœ‰èµ‹å€¼ $v$ï¼Œ$V(\neg \phi) = F$
4. æ‰€ä»¥å¯¹æ‰€æœ‰èµ‹å€¼ $v$ï¼Œ$V(\phi) = T$
5. å› æ­¤ $\phi$ æ˜¯é‡è¨€å¼

### 3.3 å®Œå¤‡æ€§å®šç†

#### 3.3.1 å‘½é¢˜é€»è¾‘çš„å®Œå¤‡æ€§

**å®šç†**: å‘½é¢˜é€»è¾‘æ˜¯å®Œå¤‡çš„ï¼Œå³æ‰€æœ‰é‡è¨€å¼éƒ½å¯ä»¥ä»å…¬ç†ç³»ç»Ÿæ¨å¯¼å‡ºæ¥ã€‚

**è¯æ˜æ€è·¯**:

1. ä½¿ç”¨çœŸå€¼è¡¨æ–¹æ³•
2. å°†å…¬å¼è½¬æ¢ä¸ºæå–èŒƒå¼ (DNF)
3. è¯æ˜æ¯ä¸ªåŸºæœ¬åˆå–é¡¹éƒ½å¯ä»¥ä»å…¬ç†æ¨å¯¼
4. ä½¿ç”¨æå–çš„æ€§è´¨å®Œæˆè¯æ˜

## 4. ä»£ç å®ç°

### 4.1 å‘½é¢˜é€»è¾‘å®ç° (Rust)

```rust
use std::collections::HashMap;

/// å‘½é¢˜é€»è¾‘ç³»ç»Ÿ
pub struct PropositionalLogic {
    variables: HashMap<String, bool>,
    formulas: Vec<Formula>,
}

/// å‘½é¢˜å…¬å¼
#[derive(Debug, Clone, PartialEq)]
pub enum Formula {
    Variable(String),
    Not(Box<Formula>),
    And(Box<Formula>, Box<Formula>),
    Or(Box<Formula>, Box<Formula>),
    Implies(Box<Formula>, Box<Formula>),
    Equiv(Box<Formula>, Box<Formula>),
}

/// çœŸå€¼è¡¨
pub struct TruthTable {
    variables: Vec<String>,
    rows: Vec<HashMap<String, bool>>,
    results: Vec<bool>,
}

impl PropositionalLogic {
    /// åˆ›å»ºæ–°çš„å‘½é¢˜é€»è¾‘ç³»ç»Ÿ
    pub fn new() -> Self {
        Self {
            variables: HashMap::new(),
            formulas: Vec::new(),
        }
    }

    /// æ·»åŠ å˜é‡
    pub fn add_variable(&mut self, name: String, value: bool) {
        self.variables.insert(name, value);
    }

    /// åˆ›å»ºåŸå­å…¬å¼
    pub fn variable(name: String) -> Formula {
        Formula::Variable(name)
    }

    /// åˆ›å»ºå¦å®šå…¬å¼
    pub fn not(formula: Formula) -> Formula {
        Formula::Not(Box::new(formula))
    }

    /// åˆ›å»ºåˆå–å…¬å¼
    pub fn and(left: Formula, right: Formula) -> Formula {
        Formula::And(Box::new(left), Box::new(right))
    }

    /// åˆ›å»ºæå–å…¬å¼
    pub fn or(left: Formula, right: Formula) -> Formula {
        Formula::Or(Box::new(left), Box::new(right))
    }

    /// åˆ›å»ºè•´å«å…¬å¼
    pub fn implies(left: Formula, right: Formula) -> Formula {
        Formula::Implies(Box::new(left), Box::new(right))
    }

    /// åˆ›å»ºç­‰ä»·å…¬å¼
    pub fn equiv(left: Formula, right: Formula) -> Formula {
        Formula::Equiv(Box::new(left), Box::new(right))
    }

    /// è®¡ç®—å…¬å¼çš„çœŸå€¼
    pub fn evaluate(&self, formula: &Formula) -> Option<bool> {
        match formula {
            Formula::Variable(name) => self.variables.get(name).copied(),
            Formula::Not(f) => {
                self.evaluate(f).map(|val| !val)
            }
            Formula::And(left, right) => {
                let left_val = self.evaluate(left)?;
                let right_val = self.evaluate(right)?;
                Some(left_val && right_val)
            }
            Formula::Or(left, right) => {
                let left_val = self.evaluate(left)?;
                let right_val = self.evaluate(right)?;
                Some(left_val || right_val)
            }
            Formula::Implies(left, right) => {
                let left_val = self.evaluate(left)?;
                let right_val = self.evaluate(right)?;
                Some(!left_val || right_val)
            }
            Formula::Equiv(left, right) => {
                let left_val = self.evaluate(left)?;
                let right_val = self.evaluate(right)?;
                Some(left_val == right_val)
            }
        }
    }

    /// ç”ŸæˆçœŸå€¼è¡¨
    pub fn generate_truth_table(&self, formula: &Formula) -> TruthTable {
        let variables = self.get_variables(formula);
        let mut rows = Vec::new();
        let mut results = Vec::new();

        // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„èµ‹å€¼ç»„åˆ
        let num_vars = variables.len();
        for i in 0..(1 << num_vars) {
            let mut assignment = HashMap::new();
            for (j, var) in variables.iter().enumerate() {
                assignment.insert(var.clone(), (i >> j) & 1 == 1);
            }
            rows.push(assignment);
        }

        // è®¡ç®—æ¯ä¸ªèµ‹å€¼ä¸‹çš„çœŸå€¼
        for assignment in &rows {
            let mut logic = PropositionalLogic::new();
            logic.variables = assignment.clone();
            results.push(logic.evaluate(formula).unwrap_or(false));
        }

        TruthTable {
            variables,
            rows,
            results,
        }
    }

    /// è·å–å…¬å¼ä¸­çš„æ‰€æœ‰å˜é‡
    fn get_variables(&self, formula: &Formula) -> Vec<String> {
        match formula {
            Formula::Variable(name) => vec![name.clone()],
            Formula::Not(f) => self.get_variables(f),
            Formula::And(left, right) | Formula::Or(left, right) |
            Formula::Implies(left, right) | Formula::Equiv(left, right) => {
                let mut vars = self.get_variables(left);
                vars.extend(self.get_variables(right));
                vars.sort();
                vars.dedup();
                vars
            }
        }
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºé‡è¨€å¼
    pub fn is_tautology(&self, formula: &Formula) -> bool {
        let truth_table = self.generate_truth_table(formula);
        truth_table.results.iter().all(|&result| result)
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºçŸ›ç›¾å¼
    pub fn is_contradiction(&self, formula: &Formula) -> bool {
        let truth_table = self.generate_truth_table(formula);
        truth_table.results.iter().all(|&result| !result)
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºå¯æ»¡è¶³å¼
    pub fn is_satisfiable(&self, formula: &Formula) -> bool {
        let truth_table = self.generate_truth_table(formula);
        truth_table.results.iter().any(|&result| result)
    }

    /// æ£€æŸ¥é€»è¾‘ç­‰ä»·
    pub fn is_logically_equivalent(&self, f1: &Formula, f2: &Formula) -> bool {
        let combined = Formula::Equiv(Box::new(f1.clone()), Box::new(f2.clone()));
        self.is_tautology(&combined)
    }

    /// è½¬æ¢ä¸ºæå–èŒƒå¼ (DNF)
    pub fn to_dnf(&self, formula: &Formula) -> Formula {
        // ç®€åŒ–å®ç°ï¼šåŸºæœ¬è½¬æ¢
        match formula {
            Formula::Variable(_) => formula.clone(),
            Formula::Not(f) => {
                match &**f {
                    Formula::Variable(name) => Formula::Not(Box::new(Formula::Variable(name.clone()))),
                    Formula::And(left, right) => {
                        // å¾·æ‘©æ ¹å¾‹ï¼šÂ¬(p âˆ§ q) â‰¡ Â¬p âˆ¨ Â¬q
                        Formula::Or(
                            Box::new(self.to_dnf(&Formula::Not(Box::new(left.clone())))),
                            Box::new(self.to_dnf(&Formula::Not(Box::new(right.clone()))))
                        )
                    }
                    Formula::Or(left, right) => {
                        // å¾·æ‘©æ ¹å¾‹ï¼šÂ¬(p âˆ¨ q) â‰¡ Â¬p âˆ§ Â¬q
                        Formula::And(
                            Box::new(self.to_dnf(&Formula::Not(Box::new(left.clone())))),
                            Box::new(self.to_dnf(&Formula::Not(Box::new(right.clone()))))
                        )
                    }
                    _ => Formula::Not(Box::new(self.to_dnf(f)))
                }
            }
            Formula::And(left, right) => {
                Formula::And(
                    Box::new(self.to_dnf(left)),
                    Box::new(self.to_dnf(right))
                )
            }
            Formula::Or(left, right) => {
                Formula::Or(
                    Box::new(self.to_dnf(left)),
                    Box::new(self.to_dnf(right))
                )
            }
            Formula::Implies(left, right) => {
                // p â†’ q â‰¡ Â¬p âˆ¨ q
                Formula::Or(
                    Box::new(self.to_dnf(&Formula::Not(Box::new(left.clone())))),
                    Box::new(self.to_dnf(right))
                )
            }
            Formula::Equiv(left, right) => {
                // p â†” q â‰¡ (p â†’ q) âˆ§ (q â†’ p)
                Formula::And(
                    Box::new(self.to_dnf(&Formula::Implies(Box::new(left.clone()), Box::new(right.clone())))),
                    Box::new(self.to_dnf(&Formula::Implies(Box::new(right.clone()), Box::new(left.clone()))))
                )
            }
        }
    }

    /// è½¬æ¢ä¸ºåˆå–èŒƒå¼ (CNF)
    pub fn to_cnf(&self, formula: &Formula) -> Formula {
        // ç®€åŒ–å®ç°ï¼šé€šè¿‡DNFè½¬æ¢
        let dnf = self.to_dnf(formula);
        // è¿™é‡Œéœ€è¦æ›´å¤æ‚çš„è½¬æ¢ç®—æ³•
        dnf
    }
}

impl TruthTable {
    /// æ‰“å°çœŸå€¼è¡¨
    pub fn print(&self) {
        // æ‰“å°è¡¨å¤´
        for var in &self.variables {
            print!("{} | ", var);
        }
        println!("Result");
        
        // æ‰“å°åˆ†éš”çº¿
        for _ in &self.variables {
            print!("---|");
        }
        println!("-------");
        
        // æ‰“å°æ•°æ®è¡Œ
        for (i, row) in self.rows.iter().enumerate() {
            for var in &self.variables {
                let value = if row[var] { "T" } else { "F" };
                print!("{} | ", value);
            }
            let result = if self.results[i] { "T" } else { "F" };
            println!("{}", result);
        }
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºé‡è¨€å¼
    pub fn is_tautology(&self) -> bool {
        self.results.iter().all(|&result| result)
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºçŸ›ç›¾å¼
    pub fn is_contradiction(&self) -> bool {
        self.results.iter().all(|&result| !result)
    }

    /// æ£€æŸ¥æ˜¯å¦ä¸ºå¯æ»¡è¶³å¼
    pub fn is_satisfiable(&self) -> bool {
        self.results.iter().any(|&result| result)
    }
}

/// å‘½é¢˜é€»è¾‘æ¨ç†ç³»ç»Ÿ
pub struct PropositionalReasoner {
    logic: PropositionalLogic,
    axioms: Vec<Formula>,
    theorems: Vec<Formula>,
}

impl PropositionalReasoner {
    /// åˆ›å»ºæ–°çš„æ¨ç†ç³»ç»Ÿ
    pub fn new() -> Self {
        let mut reasoner = Self {
            logic: PropositionalLogic::new(),
            axioms: Vec::new(),
            theorems: Vec::new(),
        };
        
        // æ·»åŠ Hilbertå…¬ç†
        let p = Formula::Variable("p".to_string());
        let q = Formula::Variable("q".to_string());
        let r = Formula::Variable("r".to_string());
        
        // A1: p â†’ (q â†’ p)
        reasoner.axioms.push(Formula::Implies(
            Box::new(p.clone()),
            Box::new(Formula::Implies(Box::new(q.clone()), Box::new(p.clone())))
        ));
        
        // A2: (p â†’ (q â†’ r)) â†’ ((p â†’ q) â†’ (p â†’ r))
        reasoner.axioms.push(Formula::Implies(
            Box::new(Formula::Implies(
                Box::new(p.clone()),
                Box::new(Formula::Implies(Box::new(q.clone()), Box::new(r.clone())))
            )),
            Box::new(Formula::Implies(
                Box::new(Formula::Implies(Box::new(p.clone()), Box::new(q.clone()))),
                Box::new(Formula::Implies(Box::new(p.clone()), Box::new(r.clone())))
            ))
        ));
        
        // A3: (Â¬p â†’ Â¬q) â†’ (q â†’ p)
        reasoner.axioms.push(Formula::Implies(
            Box::new(Formula::Implies(
                Box::new(Formula::Not(Box::new(p.clone()))),
                Box::new(Formula::Not(Box::new(q.clone())))
            )),
            Box::new(Formula::Implies(Box::new(q.clone()), Box::new(p.clone())))
        ));
        
        reasoner
    }

    /// æ·»åŠ å®šç†
    pub fn add_theorem(&mut self, theorem: Formula) {
        self.theorems.push(theorem);
    }

    /// åº”ç”¨åˆ†ç¦»è§„åˆ™
    pub fn modus_ponens(&self, premise1: &Formula, premise2: &Formula) -> Option<Formula> {
        if let Formula::Implies(antecedent, consequent) = premise2 {
            if antecedent.as_ref() == premise1 {
                return Some(*consequent.clone());
            }
        }
        None
    }

    /// è¯æ˜å®šç†
    pub fn prove(&self, theorem: &Formula) -> bool {
        self.logic.is_tautology(theorem)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_evaluation() {
        let mut logic = PropositionalLogic::new();
        logic.add_variable("p".to_string(), true);
        logic.add_variable("q".to_string(), false);
        
        let p = Formula::Variable("p".to_string());
        let q = Formula::Variable("q".to_string());
        
        assert_eq!(logic.evaluate(&p), Some(true));
        assert_eq!(logic.evaluate(&q), Some(false));
        assert_eq!(logic.evaluate(&Formula::Not(Box::new(p))), Some(false));
        assert_eq!(logic.evaluate(&Formula::And(Box::new(p), Box::new(q))), Some(false));
        assert_eq!(logic.evaluate(&Formula::Or(Box::new(p), Box::new(q))), Some(true));
    }

    #[test]
    fn test_tautology() {
        let logic = PropositionalLogic::new();
        let p = Formula::Variable("p".to_string());
        let not_p = Formula::Not(Box::new(p.clone()));
        let tautology = Formula::Or(Box::new(p), Box::new(not_p)); // p âˆ¨ Â¬p
        
        assert!(logic.is_tautology(&tautology));
    }

    #[test]
    fn test_contradiction() {
        let logic = PropositionalLogic::new();
        let p = Formula::Variable("p".to_string());
        let contradiction = Formula::And(Box::new(p.clone()), Box::new(Formula::Not(Box::new(p)))); // p âˆ§ Â¬p
        
        assert!(logic.is_contradiction(&contradiction));
    }

    #[test]
    fn test_logical_equivalence() {
        let logic = PropositionalLogic::new();
        let p = Formula::Variable("p".to_string());
        let q = Formula::Variable("q".to_string());
        
        let f1 = Formula::Implies(Box::new(p.clone()), Box::new(q.clone()));
        let f2 = Formula::Or(Box::new(Formula::Not(Box::new(p))), Box::new(q.clone()));
        
        assert!(logic.is_logically_equivalent(&f1, &f2));
    }

    #[test]
    fn test_truth_table() {
        let logic = PropositionalLogic::new();
        let p = Formula::Variable("p".to_string());
        let q = Formula::Variable("q".to_string());
        let formula = Formula::And(Box::new(p), Box::new(q));
        
        let truth_table = logic.generate_truth_table(&formula);
        assert_eq!(truth_table.results, vec![false, false, false, true]);
    }
}
```

### 4.2 å‘½é¢˜é€»è¾‘å®ç° (Haskell)

```haskell
module PropositionalLogic where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set

-- å‘½é¢˜å…¬å¼æ•°æ®ç±»å‹
data Formula
    = Variable String
    | Not Formula
    | And Formula Formula
    | Or Formula Formula
    | Implies Formula Formula
    | Equiv Formula Formula
    deriving (Eq, Ord, Show)

-- çœŸå€¼è¡¨
data TruthTable = TruthTable
    { variables :: [String]
    , assignments :: [[Bool]]
    , results :: [Bool]
    }
    deriving (Eq, Ord, Show)

-- å‘½é¢˜é€»è¾‘ç³»ç»Ÿ
data PropositionalLogic = PropositionalLogic
    { variables :: Map String Bool
    , formulas :: [Formula]
    }

-- åˆ›å»ºç©ºé€»è¾‘ç³»ç»Ÿ
emptyLogic :: PropositionalLogic
emptyLogic = PropositionalLogic Map.empty []

-- æ·»åŠ å˜é‡
addVariable :: String -> Bool -> PropositionalLogic -> PropositionalLogic
addVariable name value logic = logic { variables = Map.insert name value (variables logic) }

-- è®¡ç®—å…¬å¼çœŸå€¼
evaluate :: Formula -> PropositionalLogic -> Maybe Bool
evaluate formula logic = case formula of
    Variable name -> Map.lookup name (variables logic)
    Not f -> not <$> evaluate f logic
    And f1 f2 -> (&&) <$> evaluate f1 logic <*> evaluate f2 logic
    Or f1 f2 -> (||) <$> evaluate f1 logic <*> evaluate f2 logic
    Implies f1 f2 -> do
        v1 <- evaluate f1 logic
        v2 <- evaluate f2 logic
        return (not v1 || v2)
    Equiv f1 f2 -> do
        v1 <- evaluate f1 logic
        v2 <- evaluate f2 logic
        return (v1 == v2)

-- è·å–å…¬å¼ä¸­çš„å˜é‡
getVariables :: Formula -> Set String
getVariables formula = case formula of
    Variable name -> Set.singleton name
    Not f -> getVariables f
    And f1 f2 -> Set.union (getVariables f1) (getVariables f2)
    Or f1 f2 -> Set.union (getVariables f1) (getVariables f2)
    Implies f1 f2 -> Set.union (getVariables f1) (getVariables f2)
    Equiv f1 f2 -> Set.union (getVariables f1) (getVariables f2)

-- ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„èµ‹å€¼
generateAssignments :: [String] -> [[Bool]]
generateAssignments [] = [[]]
generateAssignments (var:vars) = 
    let rest = generateAssignments vars
    in map (True:) rest ++ map (False:) rest

-- ç”ŸæˆçœŸå€¼è¡¨
generateTruthTable :: Formula -> TruthTable
generateTruthTable formula = 
    let vars = Set.toList (getVariables formula)
        assignments = generateAssignments vars
        results = map (\assignment -> 
            let logic = PropositionalLogic (Map.fromList (zip vars assignment)) []
            in maybe False id (evaluate formula logic)) assignments
    in TruthTable vars assignments results

-- æ£€æŸ¥é‡è¨€å¼
isTautology :: Formula -> Bool
isTautology formula = 
    let truthTable = generateTruthTable formula
    in all id (results truthTable)

-- æ£€æŸ¥çŸ›ç›¾å¼
isContradiction :: Formula -> Bool
isContradiction formula = 
    let truthTable = generateTruthTable formula
    in all not (results truthTable)

-- æ£€æŸ¥å¯æ»¡è¶³æ€§
isSatisfiable :: Formula -> Bool
isSatisfiable formula = 
    let truthTable = generateTruthTable formula
    in any id (results truthTable)

-- æ£€æŸ¥é€»è¾‘ç­‰ä»·
isLogicallyEquivalent :: Formula -> Formula -> Bool
isLogicallyEquivalent f1 f2 = 
    let equiv = Equiv f1 f2
    in isTautology equiv

-- è½¬æ¢ä¸ºæå–èŒƒå¼ (ç®€åŒ–ç‰ˆæœ¬)
toDNF :: Formula -> Formula
toDNF formula = case formula of
    Variable _ -> formula
    Not f -> case f of
        Variable name -> Not (Variable name)
        And f1 f2 -> Or (toDNF (Not f1)) (toDNF (Not f2)) -- å¾·æ‘©æ ¹å¾‹
        Or f1 f2 -> And (toDNF (Not f1)) (toDNF (Not f2)) -- å¾·æ‘©æ ¹å¾‹
        _ -> Not (toDNF f)
    And f1 f2 -> And (toDNF f1) (toDNF f2)
    Or f1 f2 -> Or (toDNF f1) (toDNF f2)
    Implies f1 f2 -> Or (toDNF (Not f1)) (toDNF f2) -- p â†’ q â‰¡ Â¬p âˆ¨ q
    Equiv f1 f2 -> And (toDNF (Implies f1 f2)) (toDNF (Implies f2 f1))

-- é€»è¾‘æ¨ç†ç³»ç»Ÿ
data PropositionalReasoner = PropositionalReasoner
    { axioms :: [Formula]
    , theorems :: [Formula]
    }

-- åˆ›å»ºæ¨ç†ç³»ç»Ÿ
createReasoner :: PropositionalReasoner
createReasoner = PropositionalReasoner
    { axioms = [axiom1, axiom2, axiom3]
    , theorems = []
    }
  where
    p = Variable "p"
    q = Variable "q"
    r = Variable "r"
    
    -- A1: p â†’ (q â†’ p)
    axiom1 = Implies p (Implies q p)
    
    -- A2: (p â†’ (q â†’ r)) â†’ ((p â†’ q) â†’ (p â†’ r))
    axiom2 = Implies (Implies p (Implies q r)) (Implies (Implies p q) (Implies p r))
    
    -- A3: (Â¬p â†’ Â¬q) â†’ (q â†’ p)
    axiom3 = Implies (Implies (Not p) (Not q)) (Implies q p)

-- åˆ†ç¦»è§„åˆ™
modusPonens :: Formula -> Formula -> Maybe Formula
modusPonens premise1 premise2 = case premise2 of
    Implies antecedent consequent -> 
        if antecedent == premise1 then Just consequent else Nothing
    _ -> Nothing

-- è¯æ˜å®šç†
prove :: Formula -> Bool
prove theorem = isTautology theorem

-- çœŸå€¼è¡¨åˆ†æ
analyzeTruthTable :: TruthTable -> TruthTableAnalysis
analyzeTruthTable table = TruthTableAnalysis
    { numVariables = length (variables table)
    , numRows = length (results table)
    , isTautology = all id (results table)
    , isContradiction = all not (results table)
    , isSatisfiable = any id (results table)
    , numTrueRows = length (filter id (results table))
    }

data TruthTableAnalysis = TruthTableAnalysis
    { numVariables :: Int
    , numRows :: Int
    , isTautology :: Bool
    , isContradiction :: Bool
    , isSatisfiable :: Bool
    , numTrueRows :: Int
    }
    deriving (Eq, Ord, Show)

-- å‘½é¢˜é€»è¾‘ç¤ºä¾‹
propositionalLogicExample :: IO ()
propositionalLogicExample = do
    let p = Variable "p"
        q = Variable "q"
        
        -- åŸºæœ¬å…¬å¼
        notP = Not p
        pAndQ = And p q
        pOrQ = Or p q
        pImpliesQ = Implies p q
        pEquivQ = Equiv p q
        
        -- é‡è¨€å¼
        tautology = Or p (Not p) -- p âˆ¨ Â¬p
        
        -- çŸ›ç›¾å¼
        contradiction = And p (Not p) -- p âˆ§ Â¬p
        
        -- ç”ŸæˆçœŸå€¼è¡¨
        truthTable = generateTruthTable pAndQ
        analysis = analyzeTruthTable truthTable
    
    putStrLn "Propositional Logic Example:"
    putStrLn $ "Formula: " ++ show pAndQ
    putStrLn $ "Tautology check: " ++ show (isTautology tautology)
    putStrLn $ "Contradiction check: " ++ show (isContradiction contradiction)
    putStrLn $ "Satisfiable check: " ++ show (isSatisfiable pAndQ)
    putStrLn $ "Truth table analysis: " ++ show analysis
    putStrLn $ "DNF of p â†’ q: " ++ show (toDNF pImpliesQ)
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 æ•°å­—ç”µè·¯è®¾è®¡

```rust
// æ•°å­—ç”µè·¯è®¾è®¡ç¤ºä¾‹
fn digital_circuit_design() {
    let logic = PropositionalLogic::new();
    
    // å®šä¹‰è¾“å…¥å˜é‡
    let a = Formula::Variable("a".to_string());
    let b = Formula::Variable("b".to_string());
    let c = Formula::Variable("c".to_string());
    
    // è®¾è®¡åŠåŠ å™¨
    let sum = Formula::Xor(Box::new(a.clone()), Box::new(b.clone()));
    let carry = Formula::And(Box::new(a.clone()), Box::new(b.clone()));
    
    // è®¾è®¡å…¨åŠ å™¨
    let full_sum = Formula::Xor(Box::new(sum.clone()), Box::new(c.clone()));
    let full_carry = Formula::Or(
        Box::new(Formula::And(Box::new(a.clone()), Box::new(b.clone()))),
        Box::new(Formula::And(Box::new(sum.clone()), Box::new(c.clone())))
    );
    
    println!("Half Adder:");
    println!("Sum: {}", sum);
    println!("Carry: {}", carry);
    
    println!("\nFull Adder:");
    println!("Sum: {}", full_sum);
    println!("Carry: {}", full_carry);
}
```

### 5.2 é€»è¾‘æ¨ç†ç³»ç»Ÿ

```haskell
-- é€»è¾‘æ¨ç†ç³»ç»Ÿç¤ºä¾‹
logicalReasoningExample :: IO ()
logicalReasoningExample = do
    let p = Variable "p" -- "å¤©åœ¨ä¸‹é›¨"
        q = Variable "q" -- "åœ°é¢æ˜¯æ¹¿çš„"
        r = Variable "r" -- "æˆ‘ä¼šå¸¦ä¼"
        
        -- å‰æ
        premise1 = p -- å¤©åœ¨ä¸‹é›¨
        premise2 = Implies p q -- å¦‚æœå¤©åœ¨ä¸‹é›¨ï¼Œé‚£ä¹ˆåœ°é¢æ˜¯æ¹¿çš„
        premise3 = Implies q r -- å¦‚æœåœ°é¢æ˜¯æ¹¿çš„ï¼Œé‚£ä¹ˆæˆ‘ä¼šå¸¦ä¼
        
        -- ç»“è®º
        conclusion = Implies p r -- å¦‚æœå¤©åœ¨ä¸‹é›¨ï¼Œé‚£ä¹ˆæˆ‘ä¼šå¸¦ä¼
        
        -- éªŒè¯æ¨ç†
        validReasoning = isTautology (Implies (And (And premise1 premise2) premise3) conclusion)
        
        -- ç”ŸæˆçœŸå€¼è¡¨
        truthTable = generateTruthTable conclusion
        analysis = analyzeTruthTable truthTable
    
    putStrLn "Logical Reasoning Example:"
    putStrLn "Premises:"
    putStrLn $ "1. " ++ show premise1
    putStrLn $ "2. " ++ show premise2
    putStrLn $ "3. " ++ show premise3
    putStrLn $ "Conclusion: " ++ show conclusion
    putStrLn $ "Valid reasoning: " ++ show validReasoning
    putStrLn $ "Truth table analysis: " ++ show analysis
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸è°“è¯é€»è¾‘çš„å…³ç³»

å‘½é¢˜é€»è¾‘æ˜¯è°“è¯é€»è¾‘çš„åŸºç¡€ï¼š

- **å‘½é¢˜é€»è¾‘**: ç ”ç©¶åŸå­å‘½é¢˜ä¹‹é—´çš„é€»è¾‘å…³ç³»
- **è°“è¯é€»è¾‘**: æ‰©å±•å‘½é¢˜é€»è¾‘ï¼Œå¼•å…¥é‡è¯å’Œè°“è¯
- **è¡¨è¾¾èƒ½åŠ›**: è°“è¯é€»è¾‘æ¯”å‘½é¢˜é€»è¾‘è¡¨è¾¾èƒ½åŠ›æ›´å¼º

### 6.2 ä¸æ¨¡æ€é€»è¾‘çš„å…³ç³»

å‘½é¢˜é€»è¾‘æ˜¯æ¨¡æ€é€»è¾‘çš„åŸºç¡€ï¼š

- **å‘½é¢˜é€»è¾‘**: ç»å…¸é€»è¾‘çš„åŸºç¡€
- **æ¨¡æ€é€»è¾‘**: æ‰©å±•å‘½é¢˜é€»è¾‘ï¼Œå¼•å…¥æ¨¡æ€ç®—å­
- **åº”ç”¨é¢†åŸŸ**: æ¨¡æ€é€»è¾‘åœ¨å“²å­¦å’Œè®¡ç®—æœºç§‘å­¦ä¸­æœ‰é‡è¦åº”ç”¨

### 6.3 ä¸å¸ƒå°”ä»£æ•°çš„å…³ç³»

å‘½é¢˜é€»è¾‘ä¸å¸ƒå°”ä»£æ•°ç­‰ä»·ï¼š

- **ä»£æ•°ç»“æ„**: å‘½é¢˜é€»è¾‘å½¢æˆå¸ƒå°”ä»£æ•°
- **è¿ç®—å¯¹åº”**: é€»è¾‘è¿æ¥è¯å¯¹åº”å¸ƒå°”è¿ç®—
- **åº”ç”¨é¢†åŸŸ**: åœ¨æ•°å­—ç”µè·¯å’Œè®¡ç®—æœºç§‘å­¦ä¸­æœ‰å¹¿æ³›åº”ç”¨

## 7. å‚è€ƒæ–‡çŒ®

1. **Enderton, H. B.** (2001). *A Mathematical Introduction to Logic*. Academic Press.
2. **Mendelson, E.** (2015). *Introduction to Mathematical Logic*. CRC Press.
3. **Boolos, G. S., Burgess, J. P., & Jeffrey, R. C.** (2007). *Computability and Logic*. Cambridge University Press.
4. **Hodges, W.** (2001). *Logic*. Penguin Books.
5. **Copi, I. M., Cohen, C., & McMahon, K.** (2016). *Introduction to Logic*. Routledge.
6. **Quine, W. V. O.** (1982). *Methods of Logic*. Harvard University Press.
7. **Smullyan, R. M.** (1995). *First-Order Logic*. Dover Publications.

---

**ç›¸å…³æ–‡æ¡£**:

- [02.2.2 è°“è¯é€»è¾‘](../02.2.2_è°“è¯é€»è¾‘.md)
- [02.2.3 æ¨¡æ€é€»è¾‘](../02.2.3_æ¨¡æ€é€»è¾‘.md)
- [02.2.4 ç›´è§‰é€»è¾‘](../02.2.4_ç›´è§‰é€»è¾‘.md)
- [01.4.1 é€»è¾‘åŸºç¡€](../01.4.1_é€»è¾‘åŸºç¡€.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
