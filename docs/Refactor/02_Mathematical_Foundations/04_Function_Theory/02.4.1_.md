# 02.4.1 å‡½æ•°æ¦‚å¿µ

## ğŸ“‹ æ¦‚è¿°

å‡½æ•°æ˜¯æ•°å­¦ä¸­æœ€åŸºæœ¬å’Œæœ€é‡è¦çš„æ¦‚å¿µä¹‹ä¸€ï¼Œå®ƒæè¿°äº†é›†åˆä¹‹é—´çš„å¯¹åº”å…³ç³»ã€‚æœ¬æ–‡æ¡£ä»å½¢å¼åŒ–è§’åº¦æ„å»ºå‡½æ•°æ¦‚å¿µçš„ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬å‡½æ•°çš„å®šä¹‰ã€æ€§è´¨å’ŒåŸºæœ¬è¿ç®—ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹å‡½æ•°æ¦‚å¿µçš„å½¢å¼åŒ–åŸºç¡€**
2. **åˆ†æå‡½æ•°çš„å®šä¹‰å’Œè¡¨ç¤º**
3. **æ¢è®¨å‡½æ•°çš„æ€§è´¨**
4. **ç ”ç©¶å‡½æ•°çš„è¿ç®—**
5. **æ„å»ºå‡½æ•°æ¦‚å¿µçš„åº”ç”¨æ¡†æ¶**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å‡½æ•°çš„å®šä¹‰

å‡½æ•°æ˜¯ä»ä¸€ä¸ªé›†åˆåˆ°å¦ä¸€ä¸ªé›†åˆçš„æ˜ å°„ï¼Œæ»¡è¶³ï¼š

- **å•å€¼æ€§**ï¼šæ¯ä¸ªè¾“å…¥å¯¹åº”å”¯ä¸€çš„è¾“å‡º
- **å®šä¹‰åŸŸ**ï¼šå‡½æ•°æœ‰æ˜ç¡®çš„å®šä¹‰åŸŸ
- **å€¼åŸŸ**ï¼šå‡½æ•°æœ‰æ˜ç¡®çš„å€¼åŸŸ

### 1.2 å‡½æ•°çš„è¡¨ç¤ºæ–¹æ³•

1. **é›†åˆè®ºè¡¨ç¤º**ï¼šå‡½æ•°æ˜¯æœ‰åºå¯¹çš„é›†åˆ
2. **æ˜ å°„è¡¨ç¤º**ï¼š$f: A \to B$
3. **è¡¨è¾¾å¼è¡¨ç¤º**ï¼š$f(x) = x^2$
4. **å›¾å½¢è¡¨ç¤º**ï¼šå‡½æ•°çš„å›¾åƒ

### 1.3 å‡½æ•°çš„åŸºæœ¬æ€§è´¨

- **å•å°„æ€§**ï¼šä¸åŒçš„è¾“å…¥å¯¹åº”ä¸åŒçš„è¾“å‡º
- **æ»¡å°„æ€§**ï¼šå€¼åŸŸç­‰äºé™ªåŸŸ
- **åŒå°„æ€§**ï¼šæ—¢æ˜¯å•å°„åˆæ˜¯æ»¡å°„
- **å•è°ƒæ€§**ï¼šä¿æŒåºå…³ç³»

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å‡½æ•°çš„åŸºæœ¬å®šä¹‰

**å®šä¹‰ 2.1.1** (å‡½æ•°)
è®¾ $A$ å’Œ $B$ æ˜¯ä¸¤ä¸ªé›†åˆï¼Œå‡½æ•° $f$ æ˜¯ä» $A$ åˆ° $B$ çš„æ˜ å°„ï¼Œè®°ä½œ $f: A \to B$ï¼Œæ»¡è¶³ï¼š

1. $\forall a \in A, \exists b \in B: (a, b) \in f$
2. $\forall a \in A, \forall b_1, b_2 \in B: ((a, b_1) \in f \land (a, b_2) \in f) \implies b_1 = b_2$

### 2.2 å®šä¹‰åŸŸå’Œå€¼åŸŸ

**å®šä¹‰ 2.2.1** (å®šä¹‰åŸŸ)
å‡½æ•° $f: A \to B$ çš„å®šä¹‰åŸŸæ˜¯ï¼š

$$\text{dom}(f) = \{a \in A : \exists b \in B: (a, b) \in f\}$$

**å®šä¹‰ 2.2.2** (å€¼åŸŸ)
å‡½æ•° $f: A \to B$ çš„å€¼åŸŸæ˜¯ï¼š

$$\text{ran}(f) = \{b \in B : \exists a \in A: (a, b) \in f\}$$

### 2.3 å‡½æ•°çš„æ€§è´¨

**å®šä¹‰ 2.3.1** (å•å°„)
å‡½æ•° $f: A \to B$ æ˜¯å•å°„çš„ï¼Œå½“ä¸”ä»…å½“ï¼š

$$\forall a_1, a_2 \in A: f(a_1) = f(a_2) \implies a_1 = a_2$$

**å®šä¹‰ 2.3.2** (æ»¡å°„)
å‡½æ•° $f: A \to B$ æ˜¯æ»¡å°„çš„ï¼Œå½“ä¸”ä»…å½“ï¼š

$$\forall b \in B, \exists a \in A: f(a) = b$$

**å®šä¹‰ 2.3.3** (åŒå°„)
å‡½æ•° $f: A \to B$ æ˜¯åŒå°„çš„ï¼Œå½“ä¸”ä»…å½“ $f$ æ—¢æ˜¯å•å°„åˆæ˜¯æ»¡å°„ã€‚

### 2.4 å‡½æ•°çš„è¿ç®—

**å®šä¹‰ 2.4.1** (å‡½æ•°å¤åˆ)
è®¾ $f: A \to B$ å’Œ $g: B \to C$ï¼Œå…¶å¤åˆå‡½æ•° $g \circ f: A \to C$ å®šä¹‰ä¸ºï¼š

$$(g \circ f)(a) = g(f(a))$$

**å®šä¹‰ 2.4.2** (é€†å‡½æ•°)
è®¾ $f: A \to B$ æ˜¯åŒå°„å‡½æ•°ï¼Œå…¶é€†å‡½æ•° $f^{-1}: B \to A$ å®šä¹‰ä¸ºï¼š

$$f^{-1}(b) = a \iff f(a) = b$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 å‡½æ•°å¤åˆçš„ç»“åˆå¾‹

**å®šç† 3.1.1** (å‡½æ•°å¤åˆç»“åˆå¾‹)
è®¾ $f: A \to B$ï¼Œ$g: B \to C$ï¼Œ$h: C \to D$ï¼Œåˆ™ï¼š

$$(h \circ g) \circ f = h \circ (g \circ f)$$

**è¯æ˜**ï¼š

1. å¯¹äºä»»æ„ $a \in A$ï¼š
2. $((h \circ g) \circ f)(a) = (h \circ g)(f(a)) = h(g(f(a)))$
3. $(h \circ (g \circ f))(a) = h((g \circ f)(a)) = h(g(f(a)))$
4. å› æ­¤ $(h \circ g) \circ f = h \circ (g \circ f)$

### 3.2 é€†å‡½æ•°çš„å”¯ä¸€æ€§

**å®šç† 3.2.1** (é€†å‡½æ•°å”¯ä¸€æ€§)
å¦‚æœå‡½æ•° $f: A \to B$ æœ‰é€†å‡½æ•°ï¼Œåˆ™é€†å‡½æ•°æ˜¯å”¯ä¸€çš„ã€‚

**è¯æ˜**ï¼š

1. å‡è®¾ $f$ æœ‰ä¸¤ä¸ªé€†å‡½æ•° $g_1$ å’Œ $g_2$
2. å¯¹äºä»»æ„ $b \in B$ï¼š
3. $g_1(b) = g_1(f(g_2(b))) = (g_1 \circ f)(g_2(b)) = g_2(b)$
4. å› æ­¤ $g_1 = g_2$

### 3.3 åŒå°„å‡½æ•°çš„æ€§è´¨

**å®šç† 3.3.1** (åŒå°„å‡½æ•°æ€§è´¨)
è®¾ $f: A \to B$ æ˜¯åŒå°„å‡½æ•°ï¼Œåˆ™ï¼š

1. $f^{-1}: B \to A$ ä¹Ÿæ˜¯åŒå°„å‡½æ•°
2. $f \circ f^{-1} = \text{id}_B$
3. $f^{-1} \circ f = \text{id}_A$

**è¯æ˜**ï¼š

1. **$f^{-1}$ æ˜¯åŒå°„**ï¼š
   - å•å°„ï¼š$f^{-1}(b_1) = f^{-1}(b_2) \implies f(f^{-1}(b_1)) = f(f^{-1}(b_2)) \implies b_1 = b_2$
   - æ»¡å°„ï¼šå¯¹äºä»»æ„ $a \in A$ï¼Œå­˜åœ¨ $b = f(a)$ ä½¿å¾— $f^{-1}(b) = a$

2. **$f \circ f^{-1} = \text{id}_B$**ï¼š
   - å¯¹äºä»»æ„ $b \in B$ï¼š$(f \circ f^{-1})(b) = f(f^{-1}(b)) = b$

3. **$f^{-1} \circ f = \text{id}_A$**ï¼š
   - å¯¹äºä»»æ„ $a \in A$ï¼š$(f^{-1} \circ f)(a) = f^{-1}(f(a)) = a$

### 3.4 å‡½æ•°çš„åŸºæ•°å…³ç³»

**å®šç† 3.4.1** (å‡½æ•°åŸºæ•°å…³ç³»)
è®¾ $f: A \to B$ æ˜¯å‡½æ•°ï¼Œåˆ™ï¼š

1. å¦‚æœ $f$ æ˜¯å•å°„ï¼Œåˆ™ $|A| \leq |B|$
2. å¦‚æœ $f$ æ˜¯æ»¡å°„ï¼Œåˆ™ $|B| \leq |A|$
3. å¦‚æœ $f$ æ˜¯åŒå°„ï¼Œåˆ™ $|A| = |B|$

**è¯æ˜**ï¼š

1. **å•å°„æƒ…å†µ**ï¼š$f$ å°† $A$ çš„ä¸åŒå…ƒç´ æ˜ å°„åˆ° $B$ çš„ä¸åŒå…ƒç´ ï¼Œå› æ­¤ $|A| \leq |B|$
2. **æ»¡å°„æƒ…å†µ**ï¼š$f$ å°† $A$ çš„å…ƒç´ æ˜ å°„åˆ° $B$ çš„æ‰€æœ‰å…ƒç´ ï¼Œå› æ­¤ $|B| \leq |A|$
3. **åŒå°„æƒ…å†µ**ï¼šç»“åˆå•å°„å’Œæ»¡å°„çš„æ€§è´¨ï¼Œå¾—åˆ° $|A| = |B|$

## 4. ä»£ç å®ç°

### 4.1 å‡½æ•°æ¦‚å¿µå®ç°

```rust
use std::collections::HashMap;
use std::hash::Hash;

/// å‡½æ•°
#[derive(Debug, Clone)]
pub struct Function<A, B> {
    domain: Vec<A>,
    mapping: HashMap<A, B>,
    codomain: Vec<B>,
}

/// å‡½æ•°æ€§è´¨
#[derive(Debug, Clone, PartialEq)]
pub enum FunctionProperty {
    Injective,    // å•å°„
    Surjective,   // æ»¡å°„
    Bijective,    // åŒå°„
    Monotonic,    // å•è°ƒ
    Continuous,   // è¿ç»­
}

/// å‡½æ•°åˆ†æç»“æœ
#[derive(Debug, Clone)]
pub struct FunctionAnalysis<A, B> {
    properties: Vec<FunctionProperty>,
    domain_size: usize,
    codomain_size: usize,
    range_size: usize,
    is_injective: bool,
    is_surjective: bool,
    is_bijective: bool,
}

impl<A, B> Function<A, B>
where
    A: Clone + Hash + Eq,
    B: Clone + Hash + Eq,
{
    /// åˆ›å»ºæ–°å‡½æ•°
    pub fn new(domain: Vec<A>, codomain: Vec<B>) -> Self {
        Self {
            domain,
            mapping: HashMap::new(),
            codomain,
        }
    }
    
    /// æ·»åŠ æ˜ å°„å…³ç³»
    pub fn add_mapping(&mut self, input: A, output: B) -> Result<(), String> {
        if !self.domain.contains(&input) {
            return Err("è¾“å…¥ä¸åœ¨å®šä¹‰åŸŸä¸­".to_string());
        }
        if !self.codomain.contains(&output) {
            return Err("è¾“å‡ºä¸åœ¨é™ªåŸŸä¸­".to_string());
        }
        
        self.mapping.insert(input, output);
        Ok(())
    }
    
    /// åº”ç”¨å‡½æ•°
    pub fn apply(&self, input: &A) -> Option<&B> {
        self.mapping.get(input)
    }
    
    /// è·å–å®šä¹‰åŸŸ
    pub fn domain(&self) -> &[A] {
        &self.domain
    }
    
    /// è·å–é™ªåŸŸ
    pub fn codomain(&self) -> &[B] {
        &self.codomain
    }
    
    /// è·å–å€¼åŸŸ
    pub fn range(&self) -> Vec<&B> {
        self.mapping.values().collect()
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºå•å°„
    pub fn is_injective(&self) -> bool {
        let mut seen = HashMap::new();
        for (input, output) in &self.mapping {
            if seen.contains_key(output) {
                return false;
            }
            seen.insert(output, input);
        }
        true
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºæ»¡å°„
    pub fn is_surjective(&self) -> bool {
        let range: std::collections::HashSet<_> = self.mapping.values().collect();
        let codomain: std::collections::HashSet<_> = self.codomain.iter().collect();
        range == codomain
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºåŒå°„
    pub fn is_bijective(&self) -> bool {
        self.is_injective() && self.is_surjective()
    }
    
    /// è·å–é€†å‡½æ•°ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    pub fn inverse(&self) -> Option<Function<B, A>> {
        if !self.is_bijective() {
            return None;
        }
        
        let mut inverse_mapping = HashMap::new();
        for (input, output) in &self.mapping {
            inverse_mapping.insert(output.clone(), input.clone());
        }
        
        Some(Function {
            domain: self.codomain.clone(),
            mapping: inverse_mapping,
            codomain: self.domain.clone(),
        })
    }
    
    /// å¤åˆå‡½æ•°
    pub fn compose<C>(&self, other: &Function<B, C>) -> Function<A, C>
    where
        C: Clone + Hash + Eq,
    {
        let mut composed_mapping = HashMap::new();
        for (input, output) in &self.mapping {
            if let Some(final_output) = other.apply(output) {
                composed_mapping.insert(input.clone(), final_output.clone());
            }
        }
        
        Function {
            domain: self.domain.clone(),
            mapping: composed_mapping,
            codomain: other.codomain.clone(),
        }
    }
    
    /// åˆ†æå‡½æ•°æ€§è´¨
    pub fn analyze(&self) -> FunctionAnalysis<A, B> {
        let is_injective = self.is_injective();
        let is_surjective = self.is_surjective();
        let is_bijective = self.is_bijective();
        
        let mut properties = Vec::new();
        if is_injective {
            properties.push(FunctionProperty::Injective);
        }
        if is_surjective {
            properties.push(FunctionProperty::Surjective);
        }
        if is_bijective {
            properties.push(FunctionProperty::Bijective);
        }
        
        FunctionAnalysis {
            properties,
            domain_size: self.domain.len(),
            codomain_size: self.codomain.len(),
            range_size: self.range().len(),
            is_injective,
            is_surjective,
            is_bijective,
        }
    }
}

/// æ•°å€¼å‡½æ•°
#[derive(Debug, Clone)]
pub struct NumericFunction {
    expression: String,
    domain: (f64, f64),
}

impl NumericFunction {
    /// åˆ›å»ºæ–°çš„æ•°å€¼å‡½æ•°
    pub fn new(expression: String, domain: (f64, f64)) -> Self {
        Self { expression, domain }
    }
    
    /// è®¡ç®—å‡½æ•°å€¼
    pub fn evaluate(&self, x: f64) -> Result<f64, String> {
        if x < self.domain.0 || x > self.domain.1 {
            return Err("è¾“å…¥è¶…å‡ºå®šä¹‰åŸŸ".to_string());
        }
        
        // ç®€åŒ–çš„è¡¨è¾¾å¼æ±‚å€¼ï¼ˆå®é™…åº”ç”¨ä¸­å¯ä»¥ä½¿ç”¨æ›´å¤æ‚çš„è§£æå™¨ï¼‰
        match self.expression.as_str() {
            "x^2" => Ok(x * x),
            "sin(x)" => Ok(x.sin()),
            "cos(x)" => Ok(x.cos()),
            "exp(x)" => Ok(x.exp()),
            "log(x)" => {
                if x <= 0.0 {
                    Err("å¯¹æ•°å‡½æ•°å®šä¹‰åŸŸé”™è¯¯".to_string())
                } else {
                    Ok(x.ln())
                }
            }
            _ => Err("ä¸æ”¯æŒçš„å‡½æ•°è¡¨è¾¾å¼".to_string()),
        }
    }
    
    /// æ£€æŸ¥å•è°ƒæ€§
    pub fn is_monotonic(&self) -> Option<bool> {
        // ç®€åŒ–çš„å•è°ƒæ€§æ£€æŸ¥
        let x1 = self.domain.0;
        let x2 = self.domain.1;
        
        if let (Ok(y1), Ok(y2)) = (self.evaluate(x1), self.evaluate(x2)) {
            Some(y1 <= y2) // å‡è®¾å•è°ƒé€’å¢
        } else {
            None
        }
    }
    
    /// æ£€æŸ¥è¿ç»­æ€§
    pub fn is_continuous(&self) -> bool {
        // ç®€åŒ–çš„è¿ç»­æ€§æ£€æŸ¥
        match self.expression.as_str() {
            "x^2" | "sin(x)" | "cos(x)" | "exp(x)" => true,
            "log(x)" => true,
            _ => false,
        }
    }
}

/// å‡½æ•°åˆ†æå™¨
pub struct FunctionAnalyzer;

impl FunctionAnalyzer {
    /// åˆ†æå‡½æ•°æ€§è´¨
    pub fn analyze_function<A, B>(&self, function: &Function<A, B>) -> FunctionAnalysis<A, B>
    where
        A: Clone + Hash + Eq,
        B: Clone + Hash + Eq,
    {
        function.analyze()
    }
    
    /// åˆ†ææ•°å€¼å‡½æ•°
    pub fn analyze_numeric_function(&self, function: &NumericFunction) -> NumericFunctionAnalysis {
        let is_monotonic = function.is_monotonic();
        let is_continuous = function.is_continuous();
        
        NumericFunctionAnalysis {
            expression: function.expression.clone(),
            domain: function.domain,
            is_monotonic,
            is_continuous,
        }
    }
    
    /// æ¯”è¾ƒä¸¤ä¸ªå‡½æ•°
    pub fn compare_functions<A, B>(
        &self,
        f1: &Function<A, B>,
        f2: &Function<A, B>,
    ) -> FunctionComparison
    where
        A: Clone + Hash + Eq,
        B: Clone + Hash + Eq,
    {
        let analysis1 = f1.analyze();
        let analysis2 = f2.analyze();
        
        FunctionComparison {
            f1_analysis: analysis1,
            f2_analysis: analysis2,
            are_equal: f1.mapping == f2.mapping,
        }
    }
}

/// æ•°å€¼å‡½æ•°åˆ†æç»“æœ
#[derive(Debug, Clone)]
pub struct NumericFunctionAnalysis {
    expression: String,
    domain: (f64, f64),
    is_monotonic: Option<bool>,
    is_continuous: bool,
}

/// å‡½æ•°æ¯”è¾ƒç»“æœ
#[derive(Debug, Clone)]
pub struct FunctionComparison<A, B> {
    f1_analysis: FunctionAnalysis<A, B>,
    f2_analysis: FunctionAnalysis<A, B>,
    are_equal: bool,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_function_creation() {
        let domain = vec![1, 2, 3];
        let codomain = vec!['a', 'b', 'c'];
        let mut function = Function::new(domain, codomain);
        
        function.add_mapping(1, 'a').unwrap();
        function.add_mapping(2, 'b').unwrap();
        function.add_mapping(3, 'c').unwrap();
        
        assert_eq!(function.apply(&1), Some(&'a'));
        assert_eq!(function.apply(&2), Some(&'b'));
        assert_eq!(function.apply(&3), Some(&'c'));
    }

    #[test]
    fn test_injective_function() {
        let domain = vec![1, 2, 3];
        let codomain = vec!['a', 'b', 'c', 'd'];
        let mut function = Function::new(domain, codomain);
        
        function.add_mapping(1, 'a').unwrap();
        function.add_mapping(2, 'b').unwrap();
        function.add_mapping(3, 'c').unwrap();
        
        assert!(function.is_injective());
        assert!(!function.is_surjective());
        assert!(!function.is_bijective());
    }

    #[test]
    fn test_bijective_function() {
        let domain = vec![1, 2, 3];
        let codomain = vec!['a', 'b', 'c'];
        let mut function = Function::new(domain, codomain);
        
        function.add_mapping(1, 'a').unwrap();
        function.add_mapping(2, 'b').unwrap();
        function.add_mapping(3, 'c').unwrap();
        
        assert!(function.is_injective());
        assert!(function.is_surjective());
        assert!(function.is_bijective());
        
        let inverse = function.inverse().unwrap();
        assert_eq!(inverse.apply(&'a'), Some(&1));
    }

    #[test]
    fn test_numeric_function() {
        let function = NumericFunction::new("x^2".to_string(), (-10.0, 10.0));
        
        assert_eq!(function.evaluate(2.0), Ok(4.0));
        assert_eq!(function.evaluate(-3.0), Ok(9.0));
        assert!(function.is_continuous());
    }
}
```

### 4.2 Haskellå®ç°

```haskell
-- å‡½æ•°æ¦‚å¿µæ¨¡å—
module FunctionConcept where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set

-- å‡½æ•°
data Function a b = Function
    { domain :: [a]
    , mapping :: Map a b
    , codomain :: [b]
    }

-- å‡½æ•°æ€§è´¨
data FunctionProperty
    = Injective
    | Surjective
    | Bijective
    | Monotonic
    | Continuous
    deriving (Eq, Show)

-- å‡½æ•°åˆ†æç»“æœ
data FunctionAnalysis a b = FunctionAnalysis
    { properties :: [FunctionProperty]
    , domainSize :: Int
    , codomainSize :: Int
    , rangeSize :: Int
    , isInjective :: Bool
    , isSurjective :: Bool
    , isBijective :: Bool
    } deriving (Show)

-- æ•°å€¼å‡½æ•°
data NumericFunction = NumericFunction
    { expression :: String
    , domain :: (Double, Double)
    }

-- åˆ›å»ºæ–°å‡½æ•°
newFunction :: [a] -> [b] -> Function a b
newFunction domain codomain = Function
    { domain = domain
    , mapping = Map.empty
    , codomain = codomain
    }

-- æ·»åŠ æ˜ å°„å…³ç³»
addMapping :: (Ord a, Eq b) => a -> b -> Function a b -> Either String (Function a b)
addMapping input output function
    | input `notElem` domain function = Left "è¾“å…¥ä¸åœ¨å®šä¹‰åŸŸä¸­"
    | output `notElem` codomain function = Left "è¾“å‡ºä¸åœ¨é™ªåŸŸä¸­"
    | otherwise = Right function { mapping = Map.insert input output (mapping function) }

-- åº”ç”¨å‡½æ•°
apply :: Ord a => a -> Function a b -> Maybe b
apply input function = Map.lookup input (mapping function)

-- è·å–å€¼åŸŸ
range :: Function a b -> [b]
range function = Map.elems (mapping function)

-- æ£€æŸ¥æ˜¯å¦ä¸ºå•å°„
isInjective :: (Ord a, Eq b) => Function a b -> Bool
isInjective function = 
    let values = Map.elems (mapping function)
    in length values == length (nub values)

-- æ£€æŸ¥æ˜¯å¦ä¸ºæ»¡å°„
isSurjective :: (Ord a, Eq b) => Function a b -> Bool
isSurjective function =
    let rangeSet = Set.fromList (range function)
        codomainSet = Set.fromList (codomain function)
    in rangeSet == codomainSet

-- æ£€æŸ¥æ˜¯å¦ä¸ºåŒå°„
isBijective :: (Ord a, Eq b) => Function a b -> Bool
isBijective function = isInjective function && isSurjective function

-- è·å–é€†å‡½æ•°
inverse :: (Ord a, Ord b, Eq a, Eq b) => Function a b -> Maybe (Function b a)
inverse function
    | not (isBijective function) = Nothing
    | otherwise = Just Function
        { domain = codomain function
        , mapping = Map.fromList [(b, a) | (a, b) <- Map.toList (mapping function)]
        , codomain = domain function
        }

-- å¤åˆå‡½æ•°
compose :: (Ord a, Ord b, Eq b) => Function b c -> Function a b -> Function a c
compose g f = Function
    { domain = domain f
    , mapping = Map.fromList [(a, c) | (a, b) <- Map.toList (mapping f), 
                                      Just c <- [apply b g]]
    , codomain = codomain g
    }

-- åˆ†æå‡½æ•°
analyze :: (Ord a, Eq b) => Function a b -> FunctionAnalysis a b
analyze function = FunctionAnalysis
    { properties = properties'
    , domainSize = length (domain function)
    , codomainSize = length (codomain function)
    , rangeSize = length (range function)
    , isInjective = isInjective function
    , isSurjective = isSurjective function
    , isBijective = isBijective function
    }
  where
    properties' = concat
        [ if isInjective function then [Injective] else []
        , if isSurjective function then [Surjective] else []
        , if isBijective function then [Bijective] else []
        ]

-- æ•°å€¼å‡½æ•°æ±‚å€¼
evaluate :: NumericFunction -> Double -> Either String Double
evaluate function x
    | x < fst (domain function) || x > snd (domain function) = 
        Left "è¾“å…¥è¶…å‡ºå®šä¹‰åŸŸ"
    | otherwise = case expression function of
        "x^2" -> Right (x * x)
        "sin(x)" -> Right (sin x)
        "cos(x)" -> Right (cos x)
        "exp(x)" -> Right (exp x)
        "log(x)" -> 
            if x <= 0 then Left "å¯¹æ•°å‡½æ•°å®šä¹‰åŸŸé”™è¯¯"
            else Right (log x)
        _ -> Left "ä¸æ”¯æŒçš„å‡½æ•°è¡¨è¾¾å¼"

-- æ£€æŸ¥æ•°å€¼å‡½æ•°è¿ç»­æ€§
isContinuous :: NumericFunction -> Bool
isContinuous function = case expression function of
    "x^2" -> True
    "sin(x)" -> True
    "cos(x)" -> True
    "exp(x)" -> True
    "log(x)" -> True
    _ -> False

-- å‡½æ•°åˆ†æå™¨
data FunctionAnalyzer = FunctionAnalyzer

-- åˆ†ææ•°å€¼å‡½æ•°
analyzeNumericFunction :: NumericFunction -> IO ()
analyzeNumericFunction function = do
    putStrLn $ "å‡½æ•°è¡¨è¾¾å¼: " ++ expression function
    putStrLn $ "å®šä¹‰åŸŸ: " ++ show (domain function)
    putStrLn $ "è¿ç»­æ€§: " ++ show (isContinuous function)
    
    case evaluate function 2.0 of
        Left err -> putStrLn $ "æ±‚å€¼é”™è¯¯: " ++ err
        Right result -> putStrLn $ "f(2.0) = " ++ show result

-- ç¤ºä¾‹ç”¨æ³•
example :: IO ()
example = do
    let domain = [1, 2, 3]
    let codomain = ['a', 'b', 'c']
    let function = newFunction domain codomain
    
    let function' = case addMapping 1 'a' function of
        Right f -> case addMapping 2 'b' f of
            Right f' -> case addMapping 3 'c' f' of
                Right f'' -> f''
                Left _ -> f'
            Left _ -> f
        Left _ -> function
    
    let analysis = analyze function'
    putStrLn $ "å‡½æ•°åˆ†æ: " ++ show analysis
    
    let numericFunction = NumericFunction "x^2" (-10.0, 10.0)
    analyzeNumericFunction numericFunction
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 åŸºæœ¬å‡½æ•°æ“ä½œ

```rust
fn main() {
    // åˆ›å»ºå‡½æ•°
    let domain = vec![1, 2, 3, 4];
    let codomain = vec!['a', 'b', 'c', 'd'];
    let mut function = Function::new(domain, codomain);
    
    // æ·»åŠ æ˜ å°„å…³ç³»
    function.add_mapping(1, 'a').unwrap();
    function.add_mapping(2, 'b').unwrap();
    function.add_mapping(3, 'c').unwrap();
    function.add_mapping(4, 'd').unwrap();
    
    // åº”ç”¨å‡½æ•°
    println!("å‡½æ•°åº”ç”¨:");
    println!("f(1) = {:?}", function.apply(&1));
    println!("f(2) = {:?}", function.apply(&2));
    println!("f(3) = {:?}", function.apply(&3));
    println!("f(4) = {:?}", function.apply(&4));
    
    // åˆ†æå‡½æ•°æ€§è´¨
    let analyzer = FunctionAnalyzer;
    let analysis = analyzer.analyze_function(&function);
    
    println!("\nå‡½æ•°åˆ†æ:");
    println!("å•å°„: {}", analysis.is_injective);
    println!("æ»¡å°„: {}", analysis.is_surjective);
    println!("åŒå°„: {}", analysis.is_bijective);
}
```

### 5.2 å‡½æ•°å¤åˆ

```rust
fn function_composition() {
    // åˆ›å»ºä¸¤ä¸ªå‡½æ•°
    let mut f = Function::new(vec![1, 2, 3], vec!['a', 'b', 'c']);
    f.add_mapping(1, 'a').unwrap();
    f.add_mapping(2, 'b').unwrap();
    f.add_mapping(3, 'c').unwrap();
    
    let mut g = Function::new(vec!['a', 'b', 'c'], vec![10, 20, 30]);
    g.add_mapping('a', 10).unwrap();
    g.add_mapping('b', 20).unwrap();
    g.add_mapping('c', 30).unwrap();
    
    // è®¡ç®—å¤åˆå‡½æ•°
    let h = f.compose(&g);
    
    println!("å¤åˆå‡½æ•°:");
    println!("h(1) = {:?}", h.apply(&1));
    println!("h(2) = {:?}", h.apply(&2));
    println!("h(3) = {:?}", h.apply(&3));
}
```

### 5.3 æ•°å€¼å‡½æ•°åˆ†æ

```rust
fn numeric_function_analysis() {
    let analyzer = FunctionAnalyzer;
    
    // åˆ†æäºŒæ¬¡å‡½æ•°
    let quadratic = NumericFunction::new("x^2".to_string(), (-10.0, 10.0));
    let quadratic_analysis = analyzer.analyze_numeric_function(&quadratic);
    
    println!("äºŒæ¬¡å‡½æ•°åˆ†æ:");
    println!("è¡¨è¾¾å¼: {}", quadratic_analysis.expression);
    println!("å®šä¹‰åŸŸ: {:?}", quadratic_analysis.domain);
    println!("è¿ç»­æ€§: {}", quadratic_analysis.is_continuous);
    println!("å•è°ƒæ€§: {:?}", quadratic_analysis.is_monotonic);
    
    // è®¡ç®—å‡½æ•°å€¼
    println!("å‡½æ•°å€¼:");
    for x in [-2.0, -1.0, 0.0, 1.0, 2.0] {
        match quadratic.evaluate(x) {
            Ok(y) => println!("f({}) = {}", x, y),
            Err(e) => println!("f({}) = é”™è¯¯: {}", x, e),
        }
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸é›†åˆè®ºçš„å…³ç³»

- **ç¬›å¡å°”ç§¯**ï¼šå‡½æ•°æ˜¯ç¬›å¡å°”ç§¯çš„å­é›†
- **å…³ç³»ç†è®º**ï¼šå‡½æ•°æ˜¯ç‰¹æ®Šçš„å…³ç³»
- **åŸºæ•°ç†è®º**ï¼šå‡½æ•°ä¸é›†åˆçš„åŸºæ•°ç›¸å…³

### 6.2 ä¸ä»£æ•°çš„å…³ç³»

- **ç¾¤è®º**ï¼šå‡½æ•°çš„å¤åˆè¿ç®—
- **ç¯è®º**ï¼šå‡½æ•°çš„åŠ æ³•å’Œä¹˜æ³•
- **åŸŸè®º**ï¼šå‡½æ•°çš„é™¤æ³•è¿ç®—

### 6.3 ä¸åˆ†æå­¦çš„å…³ç³»

- **æé™ç†è®º**ï¼šå‡½æ•°çš„æé™
- **è¿ç»­æ€§**ï¼šå‡½æ•°çš„è¿ç»­æ€§
- **å¾®åˆ†å­¦**ï¼šå‡½æ•°çš„å¯¼æ•°
- **ç§¯åˆ†å­¦**ï¼šå‡½æ•°çš„ç§¯åˆ†

### 6.4 ä¸æ‹“æ‰‘å­¦çš„å…³ç³»

- **è¿ç»­æ˜ å°„**ï¼šæ‹“æ‰‘ç©ºé—´ä¹‹é—´çš„å‡½æ•°
- **åŒèƒš**ï¼šåŒå°„è¿ç»­å‡½æ•°
- **åŒä¼¦**ï¼šå‡½æ•°çš„è¿ç»­å˜å½¢

## 7. å‚è€ƒæ–‡çŒ®

1. **Bourbaki, N.** (1968). *Theory of Sets*. Springer.
2. **Halmos, P.** (1960). *Naive Set Theory*. Van Nostrand.
3. **Enderton, H.** (1977). *Elements of Set Theory*. Academic Press.
4. **Kunen, K.** (1980). *Set Theory: An Introduction to Independence Proofs*. North-Holland.
5. **Jech, T.** (2003). *Set Theory*. Springer.
6. **Suppes, P.** (1972). *Axiomatic Set Theory*. Dover.
7. **Fraenkel, A.** (1973). *Abstract Set Theory*. North-Holland.
8. **Cohen, P.** (1966). *Set Theory and the Continuum Hypothesis*. Benjamin.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.3.1 è‡ªç„¶æ•°ç³»ç»Ÿ](02.3.1_è‡ªç„¶æ•°ç³»ç»Ÿ.md)
- [02.3.2 æ•´æ•°ç³»ç»Ÿ](02.3.2_æ•´æ•°ç³»ç»Ÿ.md)
- [02.3.3 æœ‰ç†æ•°ç³»ç»Ÿ](02.3.3_æœ‰ç†æ•°ç³»ç»Ÿ.md)
- [02.3.4 å®æ•°ç³»ç»Ÿ](02.3.4_å®æ•°ç³»ç»Ÿ.md)
- [02.4.2 å‡½æ•°æ€§è´¨](../02_Mathematical_Foundation/02.4.2_å‡½æ•°æ€§è´¨.md)
- [02.4.3 å‡½æ•°è¿ç®—](../02_Mathematical_Foundation/02.4.3_å‡½æ•°è¿ç®—.md)
- [02.4.4 å‡½æ•°åˆ†ç±»](../02_Mathematical_Foundation/02.4.4_å‡½æ•°åˆ†ç±».md)


## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
