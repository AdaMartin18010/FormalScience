# 02.3.3 æœ‰ç†æ•°ç³»ç»Ÿ

## ğŸ“‹ æ¦‚è¿°

æœ‰ç†æ•°ç³»ç»Ÿæ˜¯æ•°å­¦åŸºç¡€ç†è®ºä¸­çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œæ‰©å±•äº†æ•´æ•°ç³»ç»Ÿï¼Œå¼•å…¥äº†åˆ†æ•°æ¦‚å¿µã€‚æœ‰ç†æ•°ç³»ç»Ÿåœ¨ä»£æ•°è¿ç®—ã€æ•°è®ºã€åˆ†æå­¦ç­‰é¢†åŸŸå…·æœ‰é‡è¦åº”ç”¨ã€‚æœ¬æ–‡æ¡£å»ºç«‹æœ‰ç†æ•°ç³»ç»Ÿçš„å½¢å¼åŒ–ç†è®ºæ¡†æ¶ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹æœ‰ç†æ•°çš„å½¢å¼åŒ–å®šä¹‰**
2. **ç ”ç©¶æœ‰ç†æ•°çš„ä»£æ•°æ€§è´¨**
3. **æ¢è®¨æœ‰ç†æ•°çš„åºç»“æ„**
4. **åˆ†ææœ‰ç†æ•°çš„å®Œå¤‡æ€§**
5. **æ„å»ºæœ‰ç†æ•°çš„åº”ç”¨æ¡†æ¶**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æœ‰ç†æ•°çš„å®šä¹‰

**å®šä¹‰ 1.1** (æœ‰ç†æ•°)
æœ‰ç†æ•°æ˜¯å½¢å¦‚ $\frac{a}{b}$ çš„æ•°ï¼Œå…¶ä¸­ $a, b \in \mathbb{Z}$ ä¸” $b \neq 0$ã€‚æœ‰ç†æ•°é›†åˆè®°ä¸º $\mathbb{Q}$ã€‚

**å®šä¹‰ 1.2** (æœ‰ç†æ•°ç­‰ä»·å…³ç³»)
ä¸¤ä¸ªæœ‰ç†æ•° $\frac{a}{b}$ å’Œ $\frac{c}{d}$ ç›¸ç­‰ï¼Œå½“ä¸”ä»…å½“ $ad = bc$ï¼š

$$\frac{a}{b} = \frac{c}{d} \Leftrightarrow ad = bc$$

### 1.2 æœ‰ç†æ•°çš„åŸºæœ¬æ€§è´¨

**æ€§è´¨ 1.1** (æœ‰ç†æ•°çš„åŸºæœ¬æ€§è´¨)
æœ‰ç†æ•°å…·æœ‰ä»¥ä¸‹åŸºæœ¬æ€§è´¨ï¼š

1. **å°é—­æ€§**ï¼šæœ‰ç†æ•°åœ¨åŠ æ³•ã€å‡æ³•ã€ä¹˜æ³•ä¸‹å°é—­
2. **äº¤æ¢å¾‹**ï¼šåŠ æ³•å’Œä¹˜æ³•æ»¡è¶³äº¤æ¢å¾‹
3. **ç»“åˆå¾‹**ï¼šåŠ æ³•å’Œä¹˜æ³•æ»¡è¶³ç»“åˆå¾‹
4. **åˆ†é…å¾‹**ï¼šä¹˜æ³•å¯¹åŠ æ³•æ»¡è¶³åˆ†é…å¾‹
5. **å•ä½å…ƒ**ï¼šåŠ æ³•å•ä½å…ƒä¸º0ï¼Œä¹˜æ³•å•ä½å…ƒä¸º1
6. **é€†å…ƒ**ï¼šæ¯ä¸ªæœ‰ç†æ•°éƒ½æœ‰åŠ æ³•é€†å…ƒï¼Œéé›¶æœ‰ç†æ•°æœ‰ä¹˜æ³•é€†å…ƒ

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æœ‰ç†æ•°çš„æ„é€ 

**å®šä¹‰ 2.1** (æœ‰ç†æ•°æ„é€ )
æœ‰ç†æ•°å¯ä»¥é€šè¿‡æ•´æ•°å¯¹çš„ç­‰ä»·ç±»æ„é€ ï¼š

$$\mathbb{Q} = (\mathbb{Z} \times \mathbb{Z}^*) / \sim$$

å…¶ä¸­ $\mathbb{Z}^* = \mathbb{Z} \setminus \{0\}$ï¼Œç­‰ä»·å…³ç³» $\sim$ å®šä¹‰ä¸ºï¼š

$$(a, b) \sim (c, d) \Leftrightarrow ad = bc$$

**å®šä¹‰ 2.2** (æœ‰ç†æ•°è¿ç®—)
æœ‰ç†æ•°çš„è¿ç®—å®šä¹‰ä¸ºï¼š

1. **åŠ æ³•**ï¼š$\frac{a}{b} + \frac{c}{d} = \frac{ad + bc}{bd}$
2. **ä¹˜æ³•**ï¼š$\frac{a}{b} \cdot \frac{c}{d} = \frac{ac}{bd}$
3. **å‡æ³•**ï¼š$\frac{a}{b} - \frac{c}{d} = \frac{ad - bc}{bd}$
4. **é™¤æ³•**ï¼š$\frac{a}{b} \div \frac{c}{d} = \frac{ad}{bc}$ (å½“ $c \neq 0$)

### 2.2 æœ‰ç†æ•°çš„åºç»“æ„

**å®šä¹‰ 2.3** (æœ‰ç†æ•°åº)
æœ‰ç†æ•°çš„åºå…³ç³»å®šä¹‰ä¸ºï¼š

$$\frac{a}{b} < \frac{c}{d} \Leftrightarrow ad < bc$$

å…¶ä¸­ $b, d > 0$ã€‚

**å®šä¹‰ 2.4** (æœ‰ç†æ•°çš„ç»å¯¹å€¼)
æœ‰ç†æ•° $\frac{a}{b}$ çš„ç»å¯¹å€¼å®šä¹‰ä¸ºï¼š

$$\left|\frac{a}{b}\right| = \frac{|a|}{|b|}$$

### 2.3 æœ‰ç†æ•°çš„ç¨ å¯†æ€§

**å®šä¹‰ 2.5** (ç¨ å¯†æ€§)
æœ‰ç†æ•°é›†åˆåœ¨å®æ•°ä¸­æ˜¯ç¨ å¯†çš„ï¼Œå³å¯¹äºä»»æ„ä¸¤ä¸ªä¸åŒçš„æœ‰ç†æ•° $r_1 < r_2$ï¼Œå­˜åœ¨æœ‰ç†æ•° $r$ ä½¿å¾— $r_1 < r < r_2$ã€‚

**å®šç† 2.1** (æœ‰ç†æ•°ç¨ å¯†æ€§)
æœ‰ç†æ•°é›†åˆ $\mathbb{Q}$ åœ¨å®æ•° $\mathbb{R}$ ä¸­æ˜¯ç¨ å¯†çš„ã€‚

**è¯æ˜**ï¼š
å¯¹äºä»»æ„ $r_1, r_2 \in \mathbb{Q}$ ä¸” $r_1 < r_2$ï¼Œå– $r = \frac{r_1 + r_2}{2}$ï¼Œåˆ™ $r \in \mathbb{Q}$ ä¸” $r_1 < r < r_2$ã€‚$\square$

## 3. å®šç†ä¸è¯æ˜

### 3.1 æœ‰ç†æ•°çš„ä»£æ•°æ€§è´¨

**å®šç† 3.1** (æœ‰ç†æ•°åŸŸ)
æœ‰ç†æ•°é›†åˆ $\mathbb{Q}$ æ„æˆä¸€ä¸ªåŸŸã€‚

**è¯æ˜**ï¼š

1. **åŠ æ³•ç¾¤**ï¼š$(\mathbb{Q}, +)$ æ„æˆé˜¿è´å°”ç¾¤
   - å°é—­æ€§ï¼š$\frac{a}{b} + \frac{c}{d} = \frac{ad + bc}{bd} \in \mathbb{Q}$
   - ç»“åˆå¾‹ï¼š$(\frac{a}{b} + \frac{c}{d}) + \frac{e}{f} = \frac{a}{b} + (\frac{c}{d} + \frac{e}{f})$
   - å•ä½å…ƒï¼š$\frac{0}{1}$ æ˜¯åŠ æ³•å•ä½å…ƒ
   - é€†å…ƒï¼š$\frac{a}{b}$ çš„åŠ æ³•é€†å…ƒæ˜¯ $\frac{-a}{b}$

2. **ä¹˜æ³•ç¾¤**ï¼š$(\mathbb{Q}^*, \cdot)$ æ„æˆé˜¿è´å°”ç¾¤
   - å°é—­æ€§ï¼š$\frac{a}{b} \cdot \frac{c}{d} = \frac{ac}{bd} \in \mathbb{Q}^*$
   - ç»“åˆå¾‹ï¼š$(\frac{a}{b} \cdot \frac{c}{d}) \cdot \frac{e}{f} = \frac{a}{b} \cdot (\frac{c}{d} \cdot \frac{e}{f})$
   - å•ä½å…ƒï¼š$\frac{1}{1}$ æ˜¯ä¹˜æ³•å•ä½å…ƒ
   - é€†å…ƒï¼š$\frac{a}{b}$ çš„ä¹˜æ³•é€†å…ƒæ˜¯ $\frac{b}{a}$

3. **åˆ†é…å¾‹**ï¼š$\frac{a}{b} \cdot (\frac{c}{d} + \frac{e}{f}) = \frac{a}{b} \cdot \frac{c}{d} + \frac{a}{b} \cdot \frac{e}{f}$

å› æ­¤ï¼Œ$\mathbb{Q}$ æ„æˆä¸€ä¸ªåŸŸã€‚$\square$

### 3.2 æœ‰ç†æ•°çš„åºæ€§è´¨

**å®šç† 3.2** (æœ‰ç†æ•°å…¨åº)
æœ‰ç†æ•°é›†åˆ $\mathbb{Q}$ æ„æˆä¸€ä¸ªå…¨åºé›†ã€‚

**è¯æ˜**ï¼š

1. **è‡ªåæ€§**ï¼š$\frac{a}{b} \leq \frac{a}{b}$
2. **åå¯¹ç§°æ€§**ï¼šå¦‚æœ $\frac{a}{b} \leq \frac{c}{d}$ ä¸” $\frac{c}{d} \leq \frac{a}{b}$ï¼Œåˆ™ $\frac{a}{b} = \frac{c}{d}$
3. **ä¼ é€’æ€§**ï¼šå¦‚æœ $\frac{a}{b} \leq \frac{c}{d}$ ä¸” $\frac{c}{d} \leq \frac{e}{f}$ï¼Œåˆ™ $\frac{a}{b} \leq \frac{e}{f}$
4. **å®Œå…¨æ€§**ï¼šå¯¹äºä»»æ„ä¸¤ä¸ªæœ‰ç†æ•°ï¼Œè¦ä¹ˆ $\frac{a}{b} \leq \frac{c}{d}$ï¼Œè¦ä¹ˆ $\frac{c}{d} \leq \frac{a}{b}$

å› æ­¤ï¼Œ$\mathbb{Q}$ æ„æˆä¸€ä¸ªå…¨åºé›†ã€‚$\square$

### 3.3 æœ‰ç†æ•°çš„å®Œå¤‡æ€§

**å®šç† 3.3** (æœ‰ç†æ•°ä¸å®Œå¤‡)
æœ‰ç†æ•°é›†åˆ $\mathbb{Q}$ ä¸æ˜¯å®Œå¤‡çš„ã€‚

**è¯æ˜**ï¼š
è€ƒè™‘é›†åˆ $A = \{x \in \mathbb{Q} : x^2 < 2\}$ã€‚$A$ åœ¨ $\mathbb{Q}$ ä¸­æœ‰ä¸Šç•Œï¼ˆä¾‹å¦‚2ï¼‰ï¼Œä½†æ²¡æœ‰æœ€å°ä¸Šç•Œã€‚å¦‚æœå­˜åœ¨æœ€å°ä¸Šç•Œ $r \in \mathbb{Q}$ï¼Œåˆ™ $r^2 = 2$ï¼Œä½† $\sqrt{2}$ ä¸æ˜¯æœ‰ç†æ•°ã€‚å› æ­¤ï¼Œ$\mathbb{Q}$ ä¸æ˜¯å®Œå¤‡çš„ã€‚$\square$

## 4. ä»£ç å®ç°

### 4.1 Rustå®ç°

```rust
use std::cmp::Ordering;
use std::fmt;
use std::ops::{Add, Sub, Mul, Div, Neg};

/// æœ‰ç†æ•°ç»“æ„
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Rational {
    /// åˆ†å­
    numerator: i64,
    /// åˆ†æ¯
    denominator: i64,
}

impl Rational {
    /// åˆ›å»ºæ–°çš„æœ‰ç†æ•°
    pub fn new(numerator: i64, denominator: i64) -> Result<Self, &'static str> {
        if denominator == 0 {
            return Err("åˆ†æ¯ä¸èƒ½ä¸ºé›¶");
        }
        
        let mut r = Rational { numerator, denominator };
        r.reduce();
        Ok(r)
    }

    /// çº¦åˆ†
    fn reduce(&mut self) {
        let gcd = self.gcd(self.numerator.abs(), self.denominator.abs());
        self.numerator /= gcd;
        self.denominator /= gcd;
        
        // ç¡®ä¿åˆ†æ¯ä¸ºæ­£
        if self.denominator < 0 {
            self.numerator = -self.numerator;
            self.denominator = -self.denominator;
        }
    }

    /// è®¡ç®—æœ€å¤§å…¬çº¦æ•°
    fn gcd(&self, mut a: i64, mut b: i64) -> i64 {
        while b != 0 {
            let temp = b;
            b = a % b;
            a = temp;
        }
        a
    }

    /// è·å–åˆ†å­
    pub fn numerator(&self) -> i64 {
        self.numerator
    }

    /// è·å–åˆ†æ¯
    pub fn denominator(&self) -> i64 {
        self.denominator
    }

    /// è½¬æ¢ä¸ºæµ®ç‚¹æ•°
    pub fn to_f64(&self) -> f64 {
        self.numerator as f64 / self.denominator as f64
    }

    /// ç»å¯¹å€¼
    pub fn abs(&self) -> Rational {
        Rational {
            numerator: self.numerator.abs(),
            denominator: self.denominator.abs(),
        }
    }

    /// å€’æ•°
    pub fn reciprocal(&self) -> Result<Rational, &'static str> {
        if self.numerator == 0 {
            return Err("é›¶æ²¡æœ‰å€’æ•°");
        }
        Ok(Rational {
            numerator: self.denominator,
            denominator: self.numerator,
        })
    }
}

impl Add for Rational {
    type Output = Rational;

    fn add(self, other: Rational) -> Rational {
        let numerator = self.numerator * other.denominator + other.numerator * self.denominator;
        let denominator = self.denominator * other.denominator;
        Rational::new(numerator, denominator).unwrap()
    }
}

impl Sub for Rational {
    type Output = Rational;

    fn sub(self, other: Rational) -> Rational {
        let numerator = self.numerator * other.denominator - other.numerator * self.denominator;
        let denominator = self.denominator * other.denominator;
        Rational::new(numerator, denominator).unwrap()
    }
}

impl Mul for Rational {
    type Output = Rational;

    fn mul(self, other: Rational) -> Rational {
        let numerator = self.numerator * other.numerator;
        let denominator = self.denominator * other.denominator;
        Rational::new(numerator, denominator).unwrap()
    }
}

impl Div for Rational {
    type Output = Result<Rational, &'static str>;

    fn div(self, other: Rational) -> Result<Rational, &'static str> {
        if other.numerator == 0 {
            return Err("é™¤æ•°ä¸èƒ½ä¸ºé›¶");
        }
        let numerator = self.numerator * other.denominator;
        let denominator = self.denominator * other.numerator;
        Ok(Rational::new(numerator, denominator)?)
    }
}

impl Neg for Rational {
    type Output = Rational;

    fn neg(self) -> Rational {
        Rational::new(-self.numerator, self.denominator).unwrap()
    }
}

impl PartialOrd for Rational {
    fn partial_cmp(&self, other: &Rational) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Rational {
    fn cmp(&self, other: &Rational) -> Ordering {
        let lhs = self.numerator * other.denominator;
        let rhs = other.numerator * self.denominator;
        lhs.cmp(&rhs)
    }
}

impl fmt::Display for Rational {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.denominator == 1 {
            write!(f, "{}", self.numerator)
        } else {
            write!(f, "{}/{}", self.numerator, self.denominator)
        }
    }
}

/// æœ‰ç†æ•°é›†åˆ
pub struct RationalSet {
    elements: Vec<Rational>,
}

impl RationalSet {
    pub fn new() -> Self {
        Self {
            elements: Vec::new(),
        }
    }

    /// æ·»åŠ æœ‰ç†æ•°
    pub fn add(&mut self, r: Rational) {
        if !self.elements.contains(&r) {
            self.elements.push(r);
        }
    }

    /// æ£€æŸ¥ç¨ å¯†æ€§
    pub fn is_dense(&self) -> bool {
        if self.elements.len() < 2 {
            return true;
        }
        
        for i in 0..self.elements.len() - 1 {
            for j in i + 1..self.elements.len() {
                let r1 = &self.elements[i];
                let r2 = &self.elements[j];
                let mid = (r1 + r2.clone()) * Rational::new(1, 2).unwrap();
                
                if !self.elements.contains(&mid) {
                    return false;
                }
            }
        }
        true
    }

    /// æ‰¾åˆ°æœ€å°ä¸Šç•Œ
    pub fn supremum(&self) -> Option<Rational> {
        if self.elements.is_empty() {
            return None;
        }
        
        let mut max = &self.elements[0];
        for r in &self.elements[1..] {
            if r > max {
                max = r;
            }
        }
        Some(max.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rational_creation() {
        let r = Rational::new(3, 4).unwrap();
        assert_eq!(r.numerator(), 3);
        assert_eq!(r.denominator(), 4);
    }

    #[test]
    fn test_rational_arithmetic() {
        let r1 = Rational::new(1, 2).unwrap();
        let r2 = Rational::new(1, 3).unwrap();
        
        let sum = r1.clone() + r2.clone();
        assert_eq!(sum, Rational::new(5, 6).unwrap());
        
        let product = r1 * r2;
        assert_eq!(product, Rational::new(1, 6).unwrap());
    }

    #[test]
    fn test_rational_ordering() {
        let r1 = Rational::new(1, 2).unwrap();
        let r2 = Rational::new(2, 3).unwrap();
        
        assert!(r1 < r2);
        assert!(r2 > r1);
    }

    #[test]
    fn test_rational_set() {
        let mut set = RationalSet::new();
        set.add(Rational::new(1, 2).unwrap());
        set.add(Rational::new(2, 3).unwrap());
        set.add(Rational::new(3, 4).unwrap());
        
        assert_eq!(set.elements.len(), 3);
    }
}
```

### 4.2 Haskellå®ç°

```haskell
-- æœ‰ç†æ•°ç±»å‹
data Rational = Rational Integer Integer
  deriving (Show, Eq)

-- åˆ›å»ºæœ‰ç†æ•°
makeRational :: Integer -> Integer -> Maybe Rational
makeRational _ 0 = Nothing
makeRational n d = Just $ reduce $ Rational n d

-- çº¦åˆ†
reduce :: Rational -> Rational
reduce (Rational n d) = Rational (n `div` g) (d `div` g)
  where g = gcd n d

-- åˆ†å­
numerator :: Rational -> Integer
numerator (Rational n _) = n

-- åˆ†æ¯
denominator :: Rational -> Integer
denominator (Rational _ d) = d

-- è½¬æ¢ä¸ºæµ®ç‚¹æ•°
toDouble :: Rational -> Double
toDouble (Rational n d) = fromIntegral n / fromIntegral d

-- ç»å¯¹å€¼
absRational :: Rational -> Rational
absRational (Rational n d) = Rational (abs n) (abs d)

-- å€’æ•°
reciprocal :: Rational -> Maybe Rational
reciprocal (Rational 0 _) = Nothing
reciprocal (Rational n d) = Just $ Rational d n

-- åŠ æ³•
instance Num Rational where
  (Rational n1 d1) + (Rational n2 d2) = 
    reduce $ Rational (n1 * d2 + n2 * d1) (d1 * d2)
  
  (Rational n1 d1) * (Rational n2 d2) = 
    reduce $ Rational (n1 * n2) (d1 * d2)
  
  negate (Rational n d) = Rational (-n) d
  
  abs = absRational
  
  signum (Rational n _) = Rational (signum n) 1
  
  fromInteger n = Rational n 1

-- é™¤æ³•
instance Fractional Rational where
  (Rational n1 d1) / (Rational n2 d2) = 
    case makeRational n2 d2 of
      Nothing -> error "Division by zero"
      Just _ -> reduce $ Rational (n1 * d2) (d1 * n2)
  
  fromRational r = Rational (numerator r) (denominator r)

-- åºå…³ç³»
instance Ord Rational where
  compare (Rational n1 d1) (Rational n2 d2) = 
    compare (n1 * d2) (n2 * d1)

-- æœ‰ç†æ•°é›†åˆ
type RationalSet = [Rational]

-- æ·»åŠ æœ‰ç†æ•°
addRational :: Rational -> RationalSet -> RationalSet
addRational r set = if r `elem` set then set else r : set

-- æ£€æŸ¥ç¨ å¯†æ€§
isDense :: RationalSet -> Bool
isDense [] = True
isDense [_] = True
isDense set = 
  all (\r -> r `elem` set) [mid r1 r2 | r1 <- set, r2 <- set, r1 < r2]
  where
    mid r1 r2 = (r1 + r2) / 2

-- æœ€å°ä¸Šç•Œ
supremum :: RationalSet -> Maybe Rational
supremum [] = Nothing
supremum set = Just $ maximum set

-- ç¤ºä¾‹ä½¿ç”¨
example :: IO ()
example = do
  let r1 = makeRational 1 2
      r2 = makeRational 1 3
  
  case (r1, r2) of
    (Just a, Just b) -> do
      putStrLn $ "r1 = " ++ show a
      putStrLn $ "r2 = " ++ show b
      putStrLn $ "r1 + r2 = " ++ show (a + b)
      putStrLn $ "r1 * r2 = " ++ show (a * b)
      putStrLn $ "r1 < r2 = " ++ show (a < b)
    _ -> putStrLn "Invalid rational numbers"
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 æœ‰ç†æ•°è¿ç®—åº”ç”¨

```rust
fn main() {
    // åˆ›å»ºæœ‰ç†æ•°
    let r1 = Rational::new(1, 2).unwrap();
    let r2 = Rational::new(1, 3).unwrap();
    let r3 = Rational::new(2, 5).unwrap();
    
    println!("r1 = {}", r1);
    println!("r2 = {}", r2);
    println!("r3 = {}", r3);
    
    // åŸºæœ¬è¿ç®—
    println!("r1 + r2 = {}", r1.clone() + r2.clone());
    println!("r1 - r2 = {}", r1.clone() - r2.clone());
    println!("r1 * r2 = {}", r1.clone() * r2.clone());
    println!("r1 / r2 = {}", (r1.clone() / r2.clone()).unwrap());
    
    // åºå…³ç³»
    println!("r1 < r2: {}", r1 < r2);
    println!("r2 < r3: {}", r2 < r3);
    
    // ç»å¯¹å€¼
    println!("|r1| = {}", r1.abs());
    println!("|-r1| = {}", (-r1.clone()).abs());
    
    // å€’æ•°
    println!("1/r1 = {}", r1.reciprocal().unwrap());
    
    // è½¬æ¢ä¸ºæµ®ç‚¹æ•°
    println!("r1 as f64 = {}", r1.to_f64());
}
```

### 5.2 æœ‰ç†æ•°é›†åˆåº”ç”¨

```rust
fn main() {
    let mut set = RationalSet::new();
    
    // æ·»åŠ æœ‰ç†æ•°
    set.add(Rational::new(1, 2).unwrap());
    set.add(Rational::new(1, 3).unwrap());
    set.add(Rational::new(2, 3).unwrap());
    set.add(Rational::new(3, 4).unwrap());
    
    println!("æœ‰ç†æ•°é›†åˆ: {:?}", set.elements);
    
    // æ£€æŸ¥ç¨ å¯†æ€§
    println!("é›†åˆæ˜¯å¦ç¨ å¯†: {}", set.is_dense());
    
    // æ‰¾åˆ°æœ€å°ä¸Šç•Œ
    if let Some(sup) = set.supremum() {
        println!("æœ€å°ä¸Šç•Œ: {}", sup);
    }
    
    // æ’åº
    let mut sorted = set.elements.clone();
    sorted.sort();
    println!("æ’åºåçš„é›†åˆ: {:?}", sorted);
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸æ•´æ•°ç³»ç»Ÿçš„å…³ç³»

æœ‰ç†æ•°ç³»ç»Ÿæ‰©å±•äº†æ•´æ•°ç³»ç»Ÿï¼Œå‚è§ï¼š

- [02.3.2 æ•´æ•°ç³»ç»Ÿ](./02.3.2_Integer_System.md)

### 6.2 ä¸å®æ•°ç³»ç»Ÿçš„å…³ç³»

æœ‰ç†æ•°ç³»ç»Ÿæ˜¯å®æ•°ç³»ç»Ÿçš„ç¨ å¯†å­é›†ï¼Œå‚è§ï¼š

- [02.3.4 å®æ•°ç³»ç»Ÿ](./02.3.4_Real_Number_System.md)

### 6.3 ä¸ä»£æ•°ç»“æ„çš„å…³ç³»

æœ‰ç†æ•°æ„æˆåŸŸï¼Œå‚è§ï¼š

- [02.6.3 åŸŸè®ºåŸºç¡€](./02.6.3_Field_Theory.md)

## 7. å‚è€ƒæ–‡çŒ®

1. Dedekind, R. (1872). *Stetigkeit und irrationale Zahlen*. Vieweg.
2. Cantor, G. (1874). "Ãœber eine Eigenschaft des Inbegriffes aller reellen algebraischen Zahlen". *Journal fÃ¼r die reine und angewandte Mathematik*.
3. Peano, G. (1889). *Arithmetices principia, nova methodo exposita*. Fratres Bocca.
4. Landau, E. (1930). *Grundlagen der Analysis*. Akademische Verlagsgesellschaft.
5. Hardy, G. H. (1908). *A Course of Pure Mathematics*. Cambridge University Press.
6. Rudin, W. (1976). *Principles of Mathematical Analysis*. McGraw-Hill.
7. Apostol, T. M. (1974). *Mathematical Analysis*. Addison-Wesley.
8. Courant, R. (1937). *Differential and Integral Calculus*. Interscience.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.3.1 è‡ªç„¶æ•°ç³»ç»Ÿ](./02.3.1_Natural_Number_System.md)
- [02.3.2 æ•´æ•°ç³»ç»Ÿ](./02.3.2_Integer_System.md)
- [02.3.4 å®æ•°ç³»ç»Ÿ](./02.3.4_Real_Number_System.md)
- [02.6.3 åŸŸè®ºåŸºç¡€](./02.6.3_Field_Theory.md)
