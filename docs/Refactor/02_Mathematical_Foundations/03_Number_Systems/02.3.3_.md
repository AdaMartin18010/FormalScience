# 02.3.3 æœ‰ç†æ•°ç³»ç»Ÿ

## ğŸ“‹ æ¦‚è¿°

æœ‰ç†æ•°ç³»ç»Ÿæ˜¯æ•´æ•°ç³»ç»Ÿçš„æ‰©å±•ï¼ŒåŒ…å«æ‰€æœ‰å¯ä»¥è¡¨ç¤ºä¸ºåˆ†æ•°å½¢å¼çš„æ•°ã€‚æœ¬æ–‡æ¡£å»ºç«‹æœ‰ç†æ•°ç³»ç»Ÿçš„å®Œæ•´ç†è®ºæ¡†æ¶ï¼ŒåŒ…æ‹¬æœ‰ç†æ•°çš„æ„é€ ã€åˆ†æ•°è¿ç®—ã€åºå…³ç³»å’Œæœ‰ç†æ•°çš„ä»£æ•°ç»“æ„ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹æœ‰ç†æ•°ç³»ç»Ÿçš„æ„é€ æ€§å®šä¹‰
2. å®šä¹‰æœ‰ç†æ•°çš„ä»£æ•°ç»“æ„
3. æ„å»ºæœ‰ç†æ•°çš„åºå…³ç³»ç†è®º
4. æä¾›æœ‰ç†æ•°è¿ç®—çš„å½¢å¼åŒ–å®šä¹‰
5. å®ç°æœ‰ç†æ•°ç³»ç»Ÿçš„ç®—æ³•åŒ–

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æœ‰ç†æ•°çš„æœ¬è´¨

æœ‰ç†æ•°æ˜¯å¯ä»¥è¡¨ç¤ºä¸ºä¸¤ä¸ªæ•´æ•°ä¹‹æ¯”çš„æ•°ï¼Œæ˜¯æ•´æ•°ç³»ç»Ÿçš„æ‰©å±•ã€‚

**å®šä¹‰ 1.1.1** (æœ‰ç†æ•°)
æœ‰ç†æ•°æ˜¯å½¢å¦‚ $\frac{a}{b}$ çš„æ•°ï¼Œå…¶ä¸­ $a, b \in \mathbb{Z}$ ä¸” $b \neq 0$ã€‚

**å®šä¹‰ 1.1.2** (åˆ†æ•°)
åˆ†æ•°æ˜¯æœ‰ç†æ•°çš„è¡¨ç¤ºå½¢å¼ï¼Œç”±åˆ†å­å’Œåˆ†æ¯ç»„æˆã€‚

### 1.2 æœ‰ç†æ•°çš„æ„é€ 

**å®šä¹‰ 1.1.3** (æœ‰ç†æ•°æ„é€ )
æœ‰ç†æ•°é€šè¿‡æ•´æ•°å¯¹çš„ç­‰ä»·å…³ç³»æ„é€ ï¼š
$(a, b) \sim (c, d)$ å½“ä¸”ä»…å½“ $a \cdot d = b \cdot c$

**å®šä¹‰ 1.1.4** (æœ€ç®€åˆ†æ•°)
æœ€ç®€åˆ†æ•°æ˜¯åˆ†å­åˆ†æ¯äº’ç´ çš„åˆ†æ•°ã€‚

### 1.3 æœ‰ç†æ•°çš„ä»£æ•°ç»“æ„

**å®šä¹‰ 1.1.5** (æœ‰ç†æ•°åŸŸ)
æœ‰ç†æ•°å½¢æˆåŸŸ $(\mathbb{Q}, +, \cdot)$ã€‚

**å®šä¹‰ 1.1.6** (æœ‰ç†æ•°çš„ç¨ å¯†æ€§)
æœ‰ç†æ•°åœ¨å®æ•°ä¸­æ˜¯ç¨ å¯†çš„ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æœ‰ç†æ•°çš„æ„é€ 

**å®šä¹‰ 2.1.1** (æœ‰ç†æ•°æ„é€ )
è®¾ $\mathbb{Z} \times \mathbb{Z}^*$ æ˜¯æ•´æ•°å¯¹çš„é›†åˆï¼Œå…¶ä¸­ $\mathbb{Z}^* = \mathbb{Z} \setminus \{0\}$ï¼Œå®šä¹‰ç­‰ä»·å…³ç³»ï¼š
$$(a, b) \sim (c, d) \Leftrightarrow a \cdot d = b \cdot c$$

æœ‰ç†æ•°é›† $\mathbb{Q}$ æ˜¯ $\mathbb{Z} \times \mathbb{Z}^* / \sim$ çš„å•†é›†ã€‚

**å®šä¹‰ 2.1.2** (æœ‰ç†æ•°è¡¨ç¤º)
æœ‰ç†æ•°çš„æ ‡å‡†è¡¨ç¤ºï¼š

- æ­£æœ‰ç†æ•°ï¼š$\frac{a}{b} = [(a, b)]$ï¼Œå…¶ä¸­ $a, b > 0$
- è´Ÿæœ‰ç†æ•°ï¼š$-\frac{a}{b} = [(-a, b)]$ï¼Œå…¶ä¸­ $a, b > 0$
- é›¶ï¼š$0 = [(0, 1)]$

**å®šä¹‰ 2.1.3** (æœ‰ç†æ•°åµŒå…¥)
æ•´æ•°åˆ°æœ‰ç†æ•°çš„åµŒå…¥æ˜ å°„ï¼š
$$\iota: \mathbb{Z} \rightarrow \mathbb{Q}, \iota(n) = [(n, 1)]$$

### 2.2 æœ‰ç†æ•°è¿ç®—

**å®šä¹‰ 2.2.1** (æœ‰ç†æ•°åŠ æ³•)
æœ‰ç†æ•°åŠ æ³•å®šä¹‰ä¸ºï¼š
$$[(a, b)] + [(c, d)] = [(a \cdot d + b \cdot c, b \cdot d)]$$

**å®šä¹‰ 2.2.2** (æœ‰ç†æ•°ä¹˜æ³•)
æœ‰ç†æ•°ä¹˜æ³•å®šä¹‰ä¸ºï¼š
$$[(a, b)] \cdot [(c, d)] = [(a \cdot c, b \cdot d)]$$

**å®šä¹‰ 2.2.3** (æœ‰ç†æ•°å‡æ³•)
æœ‰ç†æ•°å‡æ³•å®šä¹‰ä¸ºï¼š
$$[(a, b)] - [(c, d)] = [(a, b)] + [(-c, d)]$$

**å®šä¹‰ 2.2.4** (æœ‰ç†æ•°é™¤æ³•)
æœ‰ç†æ•°é™¤æ³•å®šä¹‰ä¸ºï¼š
$$[(a, b)] \div [(c, d)] = [(a, b)] \cdot [(d, c)]$$

### 2.3 æœ‰ç†æ•°åºå…³ç³»

**å®šä¹‰ 2.3.1** (æœ‰ç†æ•°åºå…³ç³»)
æœ‰ç†æ•°åºå…³ç³»å®šä¹‰ä¸ºï¼š
$$[(a, b)] \leq [(c, d)] \Leftrightarrow a \cdot d \leq b \cdot c$$

**å®šä¹‰ 2.3.2** (æœ‰ç†æ•°ä¸¥æ ¼åº)
æœ‰ç†æ•°ä¸¥æ ¼åºå®šä¹‰ä¸ºï¼š
$$[(a, b)] < [(c, d)] \Leftrightarrow [(a, b)] \leq [(c, d)] \land [(a, b)] \neq [(c, d)]$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬æ€§è´¨å®šç†

**å®šç† 3.1.1** (æœ‰ç†æ•°æ„é€ çš„è‰¯å®šä¹‰æ€§)
æœ‰ç†æ•°è¿ç®—ä¸ç­‰ä»·ç±»ä»£è¡¨çš„é€‰æ‹©æ— å…³ã€‚

**è¯æ˜**ï¼š
è®¾ $(a, b) \sim (a', b')$ å’Œ $(c, d) \sim (c', d')$ã€‚
åˆ™ $a \cdot b' = b \cdot a'$ å’Œ $c \cdot d' = d \cdot c'$ã€‚
å¯¹äºåŠ æ³•ï¼š
$(a \cdot d + b \cdot c) \cdot (b' \cdot d') = (a \cdot b') \cdot (d \cdot d') + (b \cdot b') \cdot (c \cdot d') = (b \cdot a') \cdot (d \cdot d') + (b \cdot b') \cdot (d \cdot c') = (b \cdot d) \cdot (a' \cdot d' + b' \cdot c')$
å› æ­¤ $(a \cdot d + b \cdot c, b \cdot d) \sim (a' \cdot d' + b' \cdot c', b' \cdot d')$ã€‚

**å®šç† 3.1.2** (æœ‰ç†æ•°åŸŸçš„æ€§è´¨)
æœ‰ç†æ•°åŸŸ $(\mathbb{Q}, +, \cdot)$ å…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼š

1. **åŠ æ³•äº¤æ¢å¾‹**ï¼š$a + b = b + a$
2. **åŠ æ³•ç»“åˆå¾‹**ï¼š$(a + b) + c = a + (b + c)$
3. **åŠ æ³•å•ä½å…ƒ**ï¼š$a + 0 = a$
4. **åŠ æ³•é€†å…ƒ**ï¼š$a + (-a) = 0$
5. **ä¹˜æ³•äº¤æ¢å¾‹**ï¼š$a \cdot b = b \cdot a$
6. **ä¹˜æ³•ç»“åˆå¾‹**ï¼š$(a \cdot b) \cdot c = a \cdot (b \cdot c)$
7. **ä¹˜æ³•å•ä½å…ƒ**ï¼š$a \cdot 1 = a$
8. **ä¹˜æ³•é€†å…ƒ**ï¼š$a \cdot a^{-1} = 1$ (å¯¹äº $a \neq 0$)
9. **åˆ†é…å¾‹**ï¼š$a \cdot (b + c) = a \cdot b + a \cdot c$

**è¯æ˜**ï¼š
é€šè¿‡ç­‰ä»·ç±»çš„å®šä¹‰å’Œæ•´æ•°çš„æ€§è´¨è¯æ˜ã€‚

### 3.2 åºå…³ç³»å®šç†

**å®šç† 3.2.1** (æœ‰ç†æ•°åºå…³ç³»çš„æ€§è´¨)
æœ‰ç†æ•°åºå…³ç³»å…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼š

1. **è‡ªåæ€§**ï¼š$\forall a \in \mathbb{Q}, a \leq a$
2. **åå¯¹ç§°æ€§**ï¼š$\forall a, b \in \mathbb{Q}, a \leq b \land b \leq a \Rightarrow a = b$
3. **ä¼ é€’æ€§**ï¼š$\forall a, b, c \in \mathbb{Q}, a \leq b \land b \leq c \Rightarrow a \leq c$
4. **å®Œå…¨æ€§**ï¼š$\forall a, b \in \mathbb{Q}, a \leq b \lor b \leq a$

**å®šç† 3.2.2** (æœ‰ç†æ•°åºä¸è¿ç®—çš„ç›¸å®¹æ€§)
æœ‰ç†æ•°åºå…³ç³»ä¸è¿ç®—ç›¸å®¹ï¼š

1. **åŠ æ³•å•è°ƒæ€§**ï¼š$a \leq b \Rightarrow a + c \leq b + c$
2. **ä¹˜æ³•å•è°ƒæ€§**ï¼š$a \leq b \land c \geq 0 \Rightarrow a \cdot c \leq b \cdot c$

### 3.3 æœ‰ç†æ•°æ€§è´¨å®šç†

**å®šç† 3.3.1** (æœ‰ç†æ•°çš„ç¨ å¯†æ€§)
å¯¹äºä»»æ„ä¸¤ä¸ªä¸åŒçš„æœ‰ç†æ•° $a < b$ï¼Œå­˜åœ¨æœ‰ç†æ•° $c$ ä½¿å¾— $a < c < b$ã€‚

**è¯æ˜**ï¼š
å– $c = \frac{a + b}{2}$ï¼Œåˆ™ $a < c < b$ã€‚

**å®šç† 3.3.2** (æœ‰ç†æ•°çš„å¯æ•°æ€§)
æœ‰ç†æ•°é›†æ˜¯å¯æ•°çš„ã€‚

**è¯æ˜**ï¼š
é€šè¿‡æ„é€ åŒå°„å‡½æ•°è¯æ˜æœ‰ç†æ•°ä¸è‡ªç„¶æ•°ç­‰åŠ¿ã€‚

**å®šç† 3.3.3** (æœ‰ç†æ•°çš„é˜¿åŸºç±³å¾·æ€§è´¨)
å¯¹äºä»»æ„æ­£æœ‰ç†æ•° $a, b$ï¼Œå­˜åœ¨è‡ªç„¶æ•° $n$ ä½¿å¾— $n \cdot a > b$ã€‚

## 4. ä»£ç å®ç°

### 4.1 æœ‰ç†æ•°æ•°æ®ç»“æ„

```rust
use std::fmt;
use std::ops::{Add, Sub, Mul, Div, Neg, AddAssign, SubAssign, MulAssign, DivAssign};

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Rational {
    numerator: i64,
    denominator: i64,
}

impl Rational {
    pub fn new(numerator: i64, denominator: i64) -> Option<Self> {
        if denominator == 0 {
            None
        } else {
            let mut rational = Self {
                numerator,
                denominator,
            };
            rational.normalize();
            Some(rational)
        }
    }
    
    pub fn from_integer(n: i64) -> Self {
        Self {
            numerator: n,
            denominator: 1,
        }
    }
    
    pub fn zero() -> Self {
        Self::from_integer(0)
    }
    
    pub fn one() -> Self {
        Self::from_integer(1)
    }
    
    pub fn numerator(&self) -> i64 {
        self.numerator
    }
    
    pub fn denominator(&self) -> i64 {
        self.denominator
    }
    
    pub fn is_zero(&self) -> bool {
        self.numerator == 0
    }
    
    pub fn is_positive(&self) -> bool {
        self.numerator > 0 && self.denominator > 0
    }
    
    pub fn is_negative(&self) -> bool {
        (self.numerator > 0 && self.denominator < 0) || 
        (self.numerator < 0 && self.denominator > 0)
    }
    
    pub fn abs(&self) -> Self {
        Self {
            numerator: self.numerator.abs(),
            denominator: self.denominator.abs(),
        }
    }
    
    pub fn reciprocal(&self) -> Option<Self> {
        if self.numerator == 0 {
            None
        } else {
            Some(Self {
                numerator: self.denominator,
                denominator: self.numerator,
            })
        }
    }
    
    fn normalize(&mut self) {
        if self.denominator < 0 {
            self.numerator = -self.numerator;
            self.denominator = -self.denominator;
        }
        
        let gcd = Self::gcd(self.numerator.abs(), self.denominator.abs());
        self.numerator /= gcd;
        self.denominator /= gcd;
    }
    
    fn gcd(mut a: i64, mut b: i64) -> i64 {
        while b != 0 {
            let temp = b;
            b = a % b;
            a = temp;
        }
        a
    }
    
    fn lcm(a: i64, b: i64) -> i64 {
        (a * b).abs() / Self::gcd(a, b)
    }
}
```

### 4.2 æœ‰ç†æ•°è¿ç®—å®ç°

```rust
impl Rational {
    /// åŠ æ³•è¿ç®—
    pub fn add(&self, other: &Rational) -> Rational {
        let lcm = Self::lcm(self.denominator, other.denominator);
        let numerator = self.numerator * (lcm / self.denominator) + 
                       other.numerator * (lcm / other.denominator);
        
        let mut result = Rational {
            numerator,
            denominator: lcm,
        };
        result.normalize();
        result
    }
    
    /// å‡æ³•è¿ç®—
    pub fn subtract(&self, other: &Rational) -> Rational {
        self.add(&(-other))
    }
    
    /// ä¹˜æ³•è¿ç®—
    pub fn multiply(&self, other: &Rational) -> Rational {
        let mut result = Rational {
            numerator: self.numerator * other.numerator,
            denominator: self.denominator * other.denominator,
        };
        result.normalize();
        result
    }
    
    /// é™¤æ³•è¿ç®—
    pub fn divide(&self, other: &Rational) -> Option<Rational> {
        if other.is_zero() {
            None
        } else {
            Some(self.multiply(&other.reciprocal().unwrap()))
        }
    }
    
    /// å¹‚è¿ç®—
    pub fn power(&self, exponent: i32) -> Option<Rational> {
        if exponent == 0 {
            Some(Rational::one())
        } else if exponent > 0 {
            Some(Rational {
                numerator: self.numerator.pow(exponent as u32),
                denominator: self.denominator.pow(exponent as u32),
            })
        } else {
            // è´ŸæŒ‡æ•°
            if self.is_zero() {
                None
            } else {
                Some(Rational {
                    numerator: self.denominator.pow((-exponent) as u32),
                    denominator: self.numerator.pow((-exponent) as u32),
                })
            }
        }
    }
    
    /// è½¬æ¢ä¸ºæµ®ç‚¹æ•°
    pub fn to_f64(&self) -> f64 {
        self.numerator as f64 / self.denominator as f64
    }
    
    /// ä»æµ®ç‚¹æ•°æ„é€ ï¼ˆè¿‘ä¼¼ï¼‰
    pub fn from_f64(f: f64) -> Rational {
        // ä½¿ç”¨è¿åˆ†æ•°å±•å¼€
        Self::continued_fraction_approximation(f, 1000)
    }
    
    fn continued_fraction_approximation(f: f64, max_denominator: i64) -> Rational {
        let mut a = f.floor() as i64;
        let mut b = 1;
        let mut c = 1;
        let mut d = 0;
        
        let mut x = f - a as f64;
        
        while b <= max_denominator && x.abs() > 1e-10 {
            x = 1.0 / x;
            let ai = x.floor() as i64;
            
            let new_a = ai * a + c;
            let new_b = ai * b + d;
            
            c = a;
            d = b;
            a = new_a;
            b = new_b;
            
            x -= ai as f64;
        }
        
        Rational::new(a, b).unwrap()
    }
}

// è¿ç®—ç¬¦é‡è½½
impl Add for Rational {
    type Output = Rational;
    
    fn add(self, other: Rational) -> Rational {
        self.add(&other)
    }
}

impl Sub for Rational {
    type Output = Rational;
    
    fn sub(self, other: Rational) -> Rational {
        self.subtract(&other)
    }
}

impl Mul for Rational {
    type Output = Rational;
    
    fn mul(self, other: Rational) -> Rational {
        self.multiply(&other)
    }
}

impl Div for Rational {
    type Output = Option<Rational>;
    
    fn div(self, other: Rational) -> Option<Rational> {
        self.divide(&other)
    }
}

impl Neg for Rational {
    type Output = Rational;
    
    fn neg(self) -> Rational {
        Rational {
            numerator: -self.numerator,
            denominator: self.denominator,
        }
    }
}

impl AddAssign for Rational {
    fn add_assign(&mut self, other: Rational) {
        *self = self.add(&other);
    }
}

impl SubAssign for Rational {
    fn sub_assign(&mut self, other: Rational) {
        *self = self.subtract(&other);
    }
}

impl MulAssign for Rational {
    fn mul_assign(&mut self, other: Rational) {
        *self = self.multiply(&other);
    }
}

impl DivAssign for Rational {
    fn div_assign(&mut self, other: Rational) {
        if let Some(result) = self.divide(&other) {
            *self = result;
        }
    }
}

impl fmt::Display for Rational {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.denominator == 1 {
            write!(f, "{}", self.numerator)
        } else {
            write!(f, "{}/{}", self.numerator, self.denominator)
        }
    }
}
```

### 4.3 æœ‰ç†æ•°æ€§è´¨éªŒè¯

```rust
impl Rational {
    /// æ£€æŸ¥æ˜¯å¦ä¸ºæ•´æ•°
    pub fn is_integer(&self) -> bool {
        self.denominator == 1
    }
    
    /// æ£€æŸ¥æ˜¯å¦ä¸ºæœ€ç®€åˆ†æ•°
    pub fn is_reduced(&self) -> bool {
        Self::gcd(self.numerator.abs(), self.denominator.abs()) == 1
    }
    
    /// è·å–æ•´æ•°éƒ¨åˆ†
    pub fn integer_part(&self) -> i64 {
        self.numerator / self.denominator
    }
    
    /// è·å–å°æ•°éƒ¨åˆ†
    pub fn fractional_part(&self) -> Rational {
        Rational::new(
            self.numerator % self.denominator,
            self.denominator,
        ).unwrap()
    }
    
    /// è¿åˆ†æ•°å±•å¼€
    pub fn continued_fraction_expansion(&self) -> Vec<i64> {
        let mut result = Vec::new();
        let mut r = self.clone();
        
        while !r.is_integer() {
            let integer_part = r.integer_part();
            result.push(integer_part);
            
            r = r - Rational::from_integer(integer_part);
            r = r.reciprocal().unwrap();
        }
        
        result.push(r.numerator());
        result
    }
    
    /// ä»è¿åˆ†æ•°å±•å¼€æ„é€ 
    pub fn from_continued_fraction(coefficients: &[i64]) -> Rational {
        if coefficients.is_empty() {
            Rational::zero()
        } else if coefficients.len() == 1 {
            Rational::from_integer(coefficients[0])
        } else {
            let mut result = Rational::from_integer(coefficients[coefficients.len() - 1]);
            
            for i in (0..coefficients.len() - 1).rev() {
                result = Rational::from_integer(coefficients[i]) + result.reciprocal().unwrap();
            }
            
            result
        }
    }
}

pub struct RationalProperties;

impl RationalProperties {
    /// éªŒè¯æœ‰ç†æ•°åŸŸæ€§è´¨
    pub fn verify_field_properties() -> bool {
        let a = Rational::new(2, 3).unwrap();
        let b = Rational::new(-1, 4).unwrap();
        let c = Rational::new(5, 6).unwrap();
        
        // åŠ æ³•äº¤æ¢å¾‹
        if a.clone() + b.clone() != b.clone() + a.clone() {
            return false;
        }
        
        // åŠ æ³•ç»“åˆå¾‹
        if (a.clone() + b.clone()) + c.clone() != a.clone() + (b.clone() + c.clone()) {
            return false;
        }
        
        // åŠ æ³•å•ä½å…ƒ
        if a.clone() + Rational::zero() != a {
            return false;
        }
        
        // åŠ æ³•é€†å…ƒ
        if a.clone() + (-a.clone()) != Rational::zero() {
            return false;
        }
        
        // ä¹˜æ³•äº¤æ¢å¾‹
        if a.clone() * b.clone() != b.clone() * a.clone() {
            return false;
        }
        
        // ä¹˜æ³•ç»“åˆå¾‹
        if (a.clone() * b.clone()) * c.clone() != a.clone() * (b.clone() * c.clone()) {
            return false;
        }
        
        // ä¹˜æ³•å•ä½å…ƒ
        if a.clone() * Rational::one() != a {
            return false;
        }
        
        // ä¹˜æ³•é€†å…ƒ
        if let Some(inverse) = a.clone().reciprocal() {
            if a.clone() * inverse != Rational::one() {
                return false;
            }
        } else {
            return false;
        }
        
        // åˆ†é…å¾‹
        if a.clone() * (b.clone() + c.clone()) != a.clone() * b.clone() + a.clone() * c.clone() {
            return false;
        }
        
        true
    }
    
    /// éªŒè¯åºå…³ç³»æ€§è´¨
    pub fn verify_order_properties() -> bool {
        let a = Rational::new(1, 2).unwrap();
        let b = Rational::new(3, 4).unwrap();
        let c = Rational::new(5, 6).unwrap();
        
        // è‡ªåæ€§
        if !(a <= a) {
            return false;
        }
        
        // åå¯¹ç§°æ€§
        if a < b && b < a {
            return false;
        }
        
        // ä¼ é€’æ€§
        if a < b && b < c && !(a < c) {
            return false;
        }
        
        // å®Œå…¨æ€§
        if !(a <= b || b <= a) {
            return false;
        }
        
        true
    }
    
    /// éªŒè¯ç¨ å¯†æ€§
    pub fn verify_density() -> bool {
        let a = Rational::new(1, 3).unwrap();
        let b = Rational::new(2, 3).unwrap();
        
        let c = (a.clone() + b.clone()) / Rational::from_integer(2);
        
        a < c && c < b
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 åŸºæœ¬è¿ç®—ç¤ºä¾‹

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_basic_arithmetic() {
        let a = Rational::new(2, 3).unwrap();
        let b = Rational::new(-1, 4).unwrap();
        
        // åŠ æ³•
        assert_eq!(a.clone() + b.clone(), Rational::new(5, 12).unwrap());
        assert_eq!(b.clone() + a.clone(), Rational::new(5, 12).unwrap());
        
        // å‡æ³•
        assert_eq!(a.clone() - b.clone(), Rational::new(11, 12).unwrap());
        assert_eq!(b.clone() - a.clone(), Rational::new(-11, 12).unwrap());
        
        // ä¹˜æ³•
        assert_eq!(a.clone() * b.clone(), Rational::new(-1, 6).unwrap());
        assert_eq!(b.clone() * a.clone(), Rational::new(-1, 6).unwrap());
        
        // é™¤æ³•
        assert_eq!(a.clone() / b.clone(), Some(Rational::new(-8, 3).unwrap()));
        assert_eq!(b.clone() / a.clone(), Some(Rational::new(-3, 8).unwrap()));
    }
    
    #[test]
    fn test_power() {
        let a = Rational::new(2, 3).unwrap();
        
        assert_eq!(a.power(0), Some(Rational::one()));
        assert_eq!(a.power(2), Some(Rational::new(4, 9).unwrap()));
        assert_eq!(a.power(-1), Some(Rational::new(3, 2).unwrap()));
        assert_eq!(a.power(-2), Some(Rational::new(9, 4).unwrap()));
    }
    
    #[test]
    fn test_normalization() {
        let a = Rational::new(4, 6).unwrap();
        assert_eq!(a, Rational::new(2, 3).unwrap());
        
        let b = Rational::new(-8, -12).unwrap();
        assert_eq!(b, Rational::new(2, 3).unwrap());
    }
    
    #[test]
    fn test_continued_fraction() {
        let a = Rational::new(355, 113).unwrap(); // Ï€çš„è¿‘ä¼¼
        let expansion = a.continued_fraction_expansion();
        let reconstructed = Rational::from_continued_fraction(&expansion);
        assert_eq!(a, reconstructed);
    }
    
    #[test]
    fn test_field_properties() {
        assert!(RationalProperties::verify_field_properties());
    }
    
    #[test]
    fn test_order_properties() {
        assert!(RationalProperties::verify_order_properties());
    }
    
    #[test]
    fn test_density() {
        assert!(RationalProperties::verify_density());
    }
}
```

### 5.2 å¤æ‚è¿ç®—ç¤ºä¾‹

```rust
#[test]
fn test_complex_operations() {
    // è®¡ç®—å¤æ‚çš„æœ‰ç†æ•°è¡¨è¾¾å¼
    let a = Rational::new(1, 2).unwrap();
    let b = Rational::new(1, 3).unwrap();
    let c = Rational::new(1, 4).unwrap();
    
    let result = (a.clone() + b.clone()) * c.clone() / (a.clone() - b.clone());
    let expected = Rational::new(5, 12).unwrap() * Rational::new(1, 4).unwrap() / 
                   Rational::new(1, 6).unwrap();
    
    assert_eq!(result, expected);
    
    // æµ‹è¯•è¿åˆ†æ•°è¿‘ä¼¼
    let pi_approx = Rational::from_f64(3.14159);
    println!("Ï€çš„è¿‘ä¼¼: {}", pi_approx);
    
    let e_approx = Rational::from_f64(2.71828);
    println!("eçš„è¿‘ä¼¼: {}", e_approx);
}

#[test]
fn test_rational_sequences() {
    // è®¡ç®—è°ƒå’Œçº§æ•°çš„éƒ¨åˆ†å’Œ
    let mut sum = Rational::zero();
    for n in 1..=10 {
        sum += Rational::new(1, n as i64).unwrap();
    }
    
    println!("è°ƒå’Œçº§æ•°å‰10é¡¹å’Œ: {}", sum);
    
    // è®¡ç®—å‡ ä½•çº§æ•°
    let r = Rational::new(1, 2).unwrap();
    let mut geometric_sum = Rational::zero();
    for n in 0..10 {
        geometric_sum += r.power(n).unwrap();
    }
    
    println!("å‡ ä½•çº§æ•°å‰10é¡¹å’Œ: {}", geometric_sum);
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸æ•´æ•°çš„å…³ç³»

æœ‰ç†æ•°åŒ…å«æ•´æ•°ä½œä¸ºå­é›†ï¼Œæ•´æ•°å¯ä»¥åµŒå…¥åˆ°æœ‰ç†æ•°ä¸­ã€‚

### 6.2 ä¸å®æ•°çš„å…³ç³»

æœ‰ç†æ•°æ˜¯å®æ•°çš„ç¨ å¯†å­é›†ï¼Œä½†æœ‰ç†æ•°ä¸å®Œå¤‡ã€‚

### 6.3 ä¸ä»£æ•°ç»“æ„çš„å…³ç³»

æœ‰ç†æ•°å½¢æˆåŸŸï¼Œæ˜¯ä»£æ•°ç»“æ„çš„é‡è¦ä¾‹å­ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Hungerford, T. W. (2012). Abstract Algebra: An Introduction. Cengage Learning.
2. Dummit, D. S., & Foote, R. M. (2004). Abstract Algebra. John Wiley & Sons.
3. Herstein, I. N. (1996). Abstract Algebra. Prentice Hall.
4. ç‹å®ªé’§. (1998). æ•°ç†é€»è¾‘å¼•è®º. åŒ—äº¬å¤§å­¦å‡ºç‰ˆç¤¾.
5. å¼ æ¸…å®‡. (2006). é€»è¾‘å“²å­¦ä¹ç« . æ±Ÿè‹äººæ°‘å‡ºç‰ˆç¤¾.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.3.1 è‡ªç„¶æ•°ç³»ç»Ÿ](../02.3.1_è‡ªç„¶æ•°ç³»ç»Ÿ.md)
- [02.3.2 æ•´æ•°ç³»ç»Ÿ](../02.3.2_æ•´æ•°ç³»ç»Ÿ.md)
- [02.3.4 å®æ•°ç³»ç»Ÿ](../02.3.4_å®æ•°ç³»ç»Ÿ.md)
- [02.6.1 ç¾¤è®ºåŸºç¡€](../02.6.1_ç¾¤è®ºåŸºç¡€.md)
- [02.6.3 åŸŸè®ºåŸºç¡€](../02.6.3_åŸŸè®ºåŸºç¡€.md)


## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
