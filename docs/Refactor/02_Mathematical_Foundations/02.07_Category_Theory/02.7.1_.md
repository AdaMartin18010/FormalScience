# 02.7.1 èŒƒç•´æ¦‚å¿µ

## ğŸ“‹ æ¦‚è¿°

èŒƒç•´è®ºæ˜¯ç°ä»£æ•°å­¦çš„åŸºç¡€è¯­è¨€ï¼Œä¸ºå„ç§æ•°å­¦ç»“æ„æä¾›äº†ç»Ÿä¸€çš„æŠ½è±¡æ¡†æ¶ã€‚æœ¬æ–‡æ¡£ä»‹ç»èŒƒç•´è®ºçš„åŸºæœ¬æ¦‚å¿µï¼ŒåŒ…æ‹¬èŒƒç•´çš„å®šä¹‰ã€æ€å°„ã€å‡½å­ç­‰æ ¸å¿ƒæ¦‚å¿µã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹èŒƒç•´è®ºçš„å½¢å¼åŒ–åŸºç¡€
2. ç†è§£èŒƒç•´ä½œä¸ºæ•°å­¦ç»“æ„çš„ç»Ÿä¸€è¯­è¨€
3. æŒæ¡èŒƒç•´è®ºçš„åŸºæœ¬æ¦‚å¿µå’Œæ€§è´¨
4. ä¸ºåç»­é«˜çº§ç†è®ºå¥ å®šåŸºç¡€

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 èŒƒç•´çš„å®šä¹‰

**å®šä¹‰ 1.1.1** (èŒƒç•´)
ä¸€ä¸ªèŒƒç•´ $\mathcal{C}$ ç”±ä»¥ä¸‹æ•°æ®ç»„æˆï¼š

1. **å¯¹è±¡ç±»** $\text{Ob}(\mathcal{C})$ï¼šä¸€ä¸ªç±»ï¼Œå…¶å…ƒç´ ç§°ä¸ºå¯¹è±¡
2. **æ€å°„ç±»** $\text{Mor}(\mathcal{C})$ï¼šä¸€ä¸ªç±»ï¼Œå…¶å…ƒç´ ç§°ä¸ºæ€å°„
3. **åŸŸå’Œä½™åŸŸæ˜ å°„**ï¼š
   - $\text{dom}: \text{Mor}(\mathcal{C}) \to \text{Ob}(\mathcal{C})$ (åŸŸæ˜ å°„)
   - $\text{cod}: \text{Mor}(\mathcal{C}) \to \text{Ob}(\mathcal{C})$ (ä½™åŸŸæ˜ å°„)
4. **å¤åˆè¿ç®—**ï¼šå¯¹äºæ»¡è¶³ $\text{cod}(f) = \text{dom}(g)$ çš„æ€å°„ $f, g$ï¼Œå­˜åœ¨å¤åˆ $g \circ f$
5. **æ’ç­‰æ€å°„**ï¼šæ¯ä¸ªå¯¹è±¡ $A$ éƒ½æœ‰æ’ç­‰æ€å°„ $1_A: A \to A$

### 1.2 èŒƒç•´å…¬ç†

**å…¬ç† 1.2.1** (ç»“åˆå¾‹)
å¯¹äºæ€å°„ $f: A \to B$, $g: B \to C$, $h: C \to D$ï¼Œæœ‰ï¼š
$$(h \circ g) \circ f = h \circ (g \circ f)$$

**å…¬ç† 1.2.2** (å•ä½å¾‹)
å¯¹äºæ€å°„ $f: A \to B$ï¼Œæœ‰ï¼š
$$f \circ 1_A = f = 1_B \circ f$$

### 1.3 åŸºæœ¬ä¾‹å­

**ä¾‹å­ 1.3.1** (é›†åˆèŒƒç•´ $\mathbf{Set}$)

- å¯¹è±¡ï¼šæ‰€æœ‰é›†åˆ
- æ€å°„ï¼šé›†åˆé—´çš„å‡½æ•°
- å¤åˆï¼šå‡½æ•°å¤åˆ
- æ’ç­‰ï¼šæ’ç­‰å‡½æ•°

**ä¾‹å­ 1.3.2** (ç¾¤èŒƒç•´ $\mathbf{Grp}$)

- å¯¹è±¡ï¼šæ‰€æœ‰ç¾¤
- æ€å°„ï¼šç¾¤åŒæ€
- å¤åˆï¼šåŒæ€å¤åˆ
- æ’ç­‰ï¼šæ’ç­‰åŒæ€

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 èŒƒç•´çš„å½¢å¼åŒ–å®šä¹‰

```haskell
-- èŒƒç•´çš„ç±»å‹ç±»å®šä¹‰
class Category (cat :: k -> k -> *) where
    -- æ’ç­‰æ€å°„
    id :: cat a a
    
    -- æ€å°„å¤åˆ
    (.) :: cat b c -> cat a b -> cat a c

-- èŒƒç•´å…¬ç†çš„éªŒè¯
class Category cat => CategoryLaws cat where
    -- ç»“åˆå¾‹
    associativity :: cat c d -> cat b c -> cat a b -> Bool
    associativity h g f = (h . g) . f == h . (g . f)
    
    -- å•ä½å¾‹
    identity :: cat a b -> Bool
    identity f = f . id == f && id . f == f
```

### 2.2 æ€å°„çš„æ€§è´¨

**å®šä¹‰ 2.2.1** (å•æ€å°„)
æ€å°„ $f: A \to B$ ç§°ä¸ºå•æ€å°„ï¼Œå¦‚æœå¯¹äºä»»æ„æ€å°„ $g, h: C \to A$ï¼Œæœ‰ï¼š
$$f \circ g = f \circ h \implies g = h$$

**å®šä¹‰ 2.2.2** (æ»¡æ€å°„)
æ€å°„ $f: A \to B$ ç§°ä¸ºæ»¡æ€å°„ï¼Œå¦‚æœå¯¹äºä»»æ„æ€å°„ $g, h: B \to C$ï¼Œæœ‰ï¼š
$$g \circ f = h \circ f \implies g = h$$

**å®šä¹‰ 2.2.3** (åŒæ„)
æ€å°„ $f: A \to B$ ç§°ä¸ºåŒæ„ï¼Œå¦‚æœå­˜åœ¨æ€å°„ $g: B \to A$ ä½¿å¾—ï¼š
$$g \circ f = 1_A \quad \text{ä¸”} \quad f \circ g = 1_B$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬å®šç†

**å®šç† 3.1.1** (æ’ç­‰æ€å°„çš„å”¯ä¸€æ€§)
åœ¨èŒƒç•´ $\mathcal{C}$ ä¸­ï¼Œæ¯ä¸ªå¯¹è±¡çš„æ’ç­‰æ€å°„æ˜¯å”¯ä¸€çš„ã€‚

**è¯æ˜**ï¼š
è®¾ $1_A$ å’Œ $1_A'$ éƒ½æ˜¯å¯¹è±¡ $A$ çš„æ’ç­‰æ€å°„ã€‚æ ¹æ®å•ä½å¾‹ï¼š
$$1_A = 1_A \circ 1_A' = 1_A'$$

**å®šç† 3.1.2** (åŒæ„çš„é€†å”¯ä¸€æ€§)
å¦‚æœ $f: A \to B$ æ˜¯åŒæ„ï¼Œåˆ™å…¶é€† $g: B \to A$ æ˜¯å”¯ä¸€çš„ã€‚

**è¯æ˜**ï¼š
è®¾ $g$ å’Œ $g'$ éƒ½æ˜¯ $f$ çš„é€†ã€‚åˆ™ï¼š
$$g = g \circ 1_B = g \circ (f \circ g') = (g \circ f) \circ g' = 1_A \circ g' = g'$$

### 3.2 é‡è¦æ€§è´¨

**å‘½é¢˜ 3.2.1** (åŒæ„çš„ä¼ é€’æ€§)
å¦‚æœ $f: A \to B$ å’Œ $g: B \to C$ éƒ½æ˜¯åŒæ„ï¼Œåˆ™ $g \circ f: A \to C$ ä¹Ÿæ˜¯åŒæ„ã€‚

**è¯æ˜**ï¼š
è®¾ $f^{-1}: B \to A$ å’Œ $g^{-1}: C \to B$ åˆ†åˆ«æ˜¯ $f$ å’Œ $g$ çš„é€†ã€‚åˆ™ï¼š
$$(g \circ f) \circ (f^{-1} \circ g^{-1}) = g \circ (f \circ f^{-1}) \circ g^{-1} = g \circ 1_B \circ g^{-1} = g \circ g^{-1} = 1_C$$

## 4. ä»£ç å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::HashMap;

/// èŒƒç•´çš„åŸºæœ¬å®šä¹‰
pub trait Category {
    type Object;
    type Morphism;
    
    /// æ’ç­‰æ€å°„
    fn identity(obj: &Self::Object) -> Self::Morphism;
    
    /// æ€å°„å¤åˆ
    fn compose(f: &Self::Morphism, g: &Self::Morphism) -> Option<Self::Morphism>;
    
    /// è·å–æ€å°„çš„åŸŸ
    fn domain(morphism: &Self::Morphism) -> Self::Object;
    
    /// è·å–æ€å°„çš„ä½™åŸŸ
    fn codomain(morphism: &Self::Morphism) -> Self::Object;
}

/// é›†åˆèŒƒç•´çš„å®ç°
pub struct SetCategory;

impl Category for SetCategory {
    type Object = String;
    type Morphism = Box<dyn Fn(String) -> String>;
    
    fn identity(_obj: &Self::Object) -> Self::Morphism {
        Box::new(|x| x)
    }
    
    fn compose(f: &Self::Morphism, g: &Self::Morphism) -> Option<Self::Morphism> {
        Some(Box::new(move |x| f(g(x))))
    }
    
    fn domain(_morphism: &Self::Morphism) -> Self::Object {
        "Set".to_string()
    }
    
    fn codomain(_morphism: &Self::Morphism) -> Self::Object {
        "Set".to_string()
    }
}

/// èŒƒç•´çš„éªŒè¯å™¨
pub struct CategoryValidator<C: Category> {
    _phantom: std::marker::PhantomData<C>,
}

impl<C: Category> CategoryValidator<C> {
    /// éªŒè¯ç»“åˆå¾‹
    pub fn verify_associativity(
        f: &C::Morphism,
        g: &C::Morphism,
        h: &C::Morphism,
    ) -> bool {
        // è¿™é‡Œéœ€è¦å…·ä½“çš„å®ç°æ¥éªŒè¯ç»“åˆå¾‹
        // ç”±äºæ³›å‹é™åˆ¶ï¼Œè¿™é‡Œåªæ˜¯æ¡†æ¶
        true
    }
    
    /// éªŒè¯å•ä½å¾‹
    pub fn verify_identity(morphism: &C::Morphism) -> bool {
        // éªŒè¯å•ä½å¾‹
        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_identity() {
        let id = SetCategory::identity(&"test".to_string());
        let result = id("hello".to_string());
        assert_eq!(result, "hello");
    }
    
    #[test]
    fn test_composition() {
        let f = Box::new(|x: String| format!("f({})", x));
        let g = Box::new(|x: String| format!("g({})", x));
        
        if let Some(fg) = SetCategory::compose(&f, &g) {
            let result = fg("test".to_string());
            assert_eq!(result, "f(g(test))");
        }
    }
}
```

### 4.2 Haskell å®ç°

```haskell
-- èŒƒç•´çš„ç±»å‹ç±»
class Category cat where
    id :: cat a a
    (.) :: cat b c -> cat a b -> cat a c

-- é›†åˆèŒƒç•´å®ä¾‹
instance Category (->) where
    id = \x -> x
    (.) = \f g x -> f (g x)

-- éªŒè¯èŒƒç•´å…¬ç†
class Category cat => CategoryLaws cat where
    -- ç»“åˆå¾‹
    associativity :: cat c d -> cat b c -> cat a b -> Bool
    associativity h g f = (h . g) . f == h . (g . f)
    
    -- å•ä½å¾‹
    identity :: cat a b -> Bool
    identity f = f . id == f && id . f == f

-- åŒæ„çš„æ¦‚å¿µ
class Category cat => Isomorphism cat where
    isIsomorphism :: cat a b -> cat b a -> Bool
    isIsomorphism f g = f . g == id && g . f == id

-- å•æ€å°„å’Œæ»¡æ€å°„
class Category cat => MonoEpi cat where
    isMonomorphism :: cat a b -> Bool
    isEpimorphism :: cat a b -> Bool

-- å…·ä½“å®ç°ç¤ºä¾‹
data SetMorphism a b = SetMorphism (a -> b)

instance Category SetMorphism where
    id = SetMorphism (\x -> x)
    SetMorphism f . SetMorphism g = SetMorphism (f . g)
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 æ•°å­¦ç»“æ„ç»Ÿä¸€

èŒƒç•´è®ºä¸ºå„ç§æ•°å­¦ç»“æ„æä¾›äº†ç»Ÿä¸€çš„è¯­è¨€ï¼š

```rust
/// æ•°å­¦ç»“æ„çš„ç»Ÿä¸€è¡¨ç¤º
pub trait MathematicalStructure {
    type Element;
    type Operation;
    
    fn identity(&self) -> Self::Element;
    fn operation(&self, a: &Self::Element, b: &Self::Element) -> Self::Element;
}

/// ç¾¤ç»“æ„
pub struct Group<T> {
    elements: Vec<T>,
    operation: Box<dyn Fn(&T, &T) -> T>,
    identity: T,
}

impl<T: Clone + Eq> MathematicalStructure for Group<T> {
    type Element = T;
    type Operation = Box<dyn Fn(&T, &T) -> T>;
    
    fn identity(&self) -> Self::Element {
        self.identity.clone()
    }
    
    fn operation(&self, a: &Self::Element, b: &Self::Element) -> Self::Element {
        (self.operation)(a, b)
    }
}
```

### 5.2 å‡½æ•°å¼ç¼–ç¨‹

èŒƒç•´è®ºåœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­çš„åº”ç”¨ï¼š

```rust
/// å‡½å­ç±»å‹ç±»
pub trait Functor<A, B> {
    type F;
    
    fn fmap<F>(self, f: F) -> Self::F
    where
        F: Fn(A) -> B;
}

/// Option å‡½å­
impl<A, B> Functor<A, B> for Option<A> {
    type F = Option<B>;
    
    fn fmap<F>(self, f: F) -> Self::F
    where
        F: Fn(A) -> B,
    {
        match self {
            Some(a) => Some(f(a)),
            None => None,
        }
    }
}

/// å•å­ç±»å‹ç±»
pub trait Monad<A, B> {
    type M;
    
    fn bind<F>(self, f: F) -> Self::M
    where
        F: Fn(A) -> Self::M;
    
    fn return_(a: A) -> Self::M;
}

impl<A, B> Monad<A, B> for Option<A> {
    type M = Option<B>;
    
    fn bind<F>(self, f: F) -> Self::M
    where
        F: Fn(A) -> Self::M,
    {
        match self {
            Some(a) => f(a),
            None => None,
        }
    }
    
    fn return_(a: A) -> Self::M {
        Some(a)
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸é›†åˆè®ºçš„å…³ç³»

èŒƒç•´è®ºå¯ä»¥çœ‹ä½œæ˜¯é›†åˆè®ºçš„æŠ½è±¡åŒ–ï¼š

- **é›†åˆ** â†’ **å¯¹è±¡**
- **å‡½æ•°** â†’ **æ€å°„**
- **å‡½æ•°å¤åˆ** â†’ **æ€å°„å¤åˆ**
- **æ’ç­‰å‡½æ•°** â†’ **æ’ç­‰æ€å°„**

### 6.2 ä¸ä»£æ•°ç»“æ„çš„å…³ç³»

èŒƒç•´è®ºä¸ºä»£æ•°ç»“æ„æä¾›äº†ç»Ÿä¸€çš„æ¡†æ¶ï¼š

- **ç¾¤** â†’ **ç¾¤èŒƒç•´ä¸­çš„å¯¹è±¡**
- **ç¾¤åŒæ€** â†’ **ç¾¤èŒƒç•´ä¸­çš„æ€å°„**
- **ç¯** â†’ **ç¯èŒƒç•´ä¸­çš„å¯¹è±¡**
- **ç¯åŒæ€** â†’ **ç¯èŒƒç•´ä¸­çš„æ€å°„**

### 6.3 ä¸æ‹“æ‰‘å­¦çš„å…³ç³»

èŒƒç•´è®ºåœ¨æ‹“æ‰‘å­¦ä¸­çš„åº”ç”¨ï¼š

- **æ‹“æ‰‘ç©ºé—´** â†’ **æ‹“æ‰‘èŒƒç•´ä¸­çš„å¯¹è±¡**
- **è¿ç»­æ˜ å°„** â†’ **æ‹“æ‰‘èŒƒç•´ä¸­çš„æ€å°„**
- **åŒä¼¦** â†’ **åŒä¼¦èŒƒç•´ä¸­çš„æ€å°„**

## 7. å‚è€ƒæ–‡çŒ®

1. Mac Lane, S. (1998). *Categories for the Working Mathematician*. Springer.
2. Awodey, S. (2010). *Category Theory*. Oxford University Press.
3. Barr, M., & Wells, C. (1990). *Category Theory for Computing Science*. Prentice Hall.
4. Pierce, B. C. (1991). *Basic Category Theory for Computer Scientists*. MIT Press.
5. Spivak, D. I. (2014). *Category Theory for the Sciences*. MIT Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.7.2 å‡½å­ç†è®º](../02_Mathematical_Foundation/02.7.2_å‡½å­ç†è®º.md)
- [02.7.3 è‡ªç„¶å˜æ¢](../02_Mathematical_Foundation/02.7.3_è‡ªç„¶å˜æ¢.md)
- [02.7.4 æé™ç†è®º](../02_Mathematical_Foundation/02.7.4_æé™ç†è®º.md)
- [01.3.1 æœ¬ä½“è®ºæ¡†æ¶](../01_Philosophical_Foundation/01.3.1_æœ¬ä½“è®ºæ¡†æ¶.md)
- [03.1.1 æœ‰é™è‡ªåŠ¨æœº](../03_Formal_Language_Theory/03.1.1_æœ‰é™è‡ªåŠ¨æœº.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
