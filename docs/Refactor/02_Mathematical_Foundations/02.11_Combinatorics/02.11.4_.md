# 02.11.4 å›¾è®ºåŸºç¡€

## ğŸ“‹ æ¦‚è¿°

å›¾è®ºæ˜¯ç ”ç©¶å›¾ï¼ˆGraphï¼‰çš„æ•°å­¦åˆ†æ”¯ï¼Œå›¾æ˜¯ç”±é¡¶ç‚¹ï¼ˆVertexï¼‰å’Œè¾¹ï¼ˆEdgeï¼‰ç»„æˆçš„ç¦»æ•£ç»“æ„ï¼Œå¹¿æ³›åº”ç”¨äºè®¡ç®—æœºç§‘å­¦ã€ç½‘ç»œåˆ†æã€è¿ç­¹å­¦ç­‰é¢†åŸŸã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹å›¾è®ºçš„åŸºæœ¬æ¦‚å¿µå’Œå®šä¹‰
2. æŒæ¡å›¾çš„åŸºæœ¬æ€§è´¨å’Œåˆ†ç±»
3. ç†è§£å›¾çš„éå†å’Œè¿é€šæ€§
4. æŒæ¡å›¾è®ºä¸­çš„ç»å…¸ç®—æ³•
5. ç†è§£å›¾è®ºåœ¨å½¢å¼ç§‘å­¦ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å›¾çš„å®šä¹‰

**å®šä¹‰ 1.1** (å›¾)
ä¸€ä¸ª**å›¾** $G$ æ˜¯ä¸€ä¸ªæœ‰åºå¯¹ $(V, E)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯ä¸€ä¸ªéç©ºæœ‰é™é›†åˆï¼Œç§°ä¸º**é¡¶ç‚¹é›†**ï¼ˆVertex Setï¼‰
- $E$ æ˜¯ $V$ ä¸­å…ƒç´ çš„æ— åºå¯¹é›†åˆï¼Œç§°ä¸º**è¾¹é›†**ï¼ˆEdge Setï¼‰

**å®šä¹‰ 1.2** (æœ‰å‘å›¾)
ä¸€ä¸ª**æœ‰å‘å›¾** $D$ æ˜¯ä¸€ä¸ªæœ‰åºå¯¹ $(V, A)$ï¼Œå…¶ä¸­ï¼š

- $V$ æ˜¯ä¸€ä¸ªéç©ºæœ‰é™é›†åˆï¼Œç§°ä¸º**é¡¶ç‚¹é›†**
- $A$ æ˜¯ $V$ ä¸­å…ƒç´ çš„æœ‰åºå¯¹é›†åˆï¼Œç§°ä¸º**å¼§é›†**ï¼ˆArc Setï¼‰

### 1.2 å›¾çš„åŸºæœ¬æ¦‚å¿µ

**å®šä¹‰ 1.3** (é‚»æ¥)
åœ¨å›¾ $G = (V, E)$ ä¸­ï¼š

- å¦‚æœ $uv \in E$ï¼Œåˆ™ç§°é¡¶ç‚¹ $u$ å’Œ $v$ æ˜¯**é‚»æ¥çš„**ï¼ˆAdjacentï¼‰
- å¦‚æœ $e = uv \in E$ï¼Œåˆ™ç§°è¾¹ $e$ **å…³è”**ï¼ˆIncidentï¼‰äºé¡¶ç‚¹ $u$ å’Œ $v$

**å®šä¹‰ 1.4** (åº¦æ•°)
åœ¨å›¾ $G = (V, E)$ ä¸­ï¼Œé¡¶ç‚¹ $v$ çš„**åº¦æ•°**ï¼ˆDegreeï¼‰æ˜¯ä¸ $v$ å…³è”çš„è¾¹çš„æ•°é‡ï¼Œè®°ä½œ $\deg(v)$ã€‚

**å®šä¹‰ 1.5** (è·¯å¾„)
åœ¨å›¾ $G = (V, E)$ ä¸­ï¼Œä¸€ä¸ª**è·¯å¾„**ï¼ˆPathï¼‰æ˜¯ä¸€ä¸ªé¡¶ç‚¹åºåˆ— $v_0, v_1, \ldots, v_k$ï¼Œä½¿å¾—å¯¹äºæ¯ä¸ª $i$ï¼Œ$v_i v_{i+1} \in E$ã€‚

### 1.3 å›¾çš„åˆ†ç±»

**å®šä¹‰ 1.6** (ç®€å•å›¾)
ä¸€ä¸ª**ç®€å•å›¾**æ˜¯ä¸åŒ…å«è‡ªç¯å’Œé‡è¾¹çš„å›¾ã€‚

**å®šä¹‰ 1.7** (å®Œå…¨å›¾)
ä¸€ä¸ª**å®Œå…¨å›¾** $K_n$ æ˜¯æœ‰ $n$ ä¸ªé¡¶ç‚¹çš„ç®€å•å›¾ï¼Œå…¶ä¸­ä»»æ„ä¸¤ä¸ªä¸åŒçš„é¡¶ç‚¹ä¹‹é—´éƒ½æœ‰ä¸€æ¡è¾¹ã€‚

**å®šä¹‰ 1.8** (äºŒåˆ†å›¾)
ä¸€ä¸ª**äºŒåˆ†å›¾** $G = (V, E)$ çš„é¡¶ç‚¹é›†å¯ä»¥åˆ’åˆ†ä¸ºä¸¤ä¸ªä¸ç›¸äº¤çš„å­é›† $V_1$ å’Œ $V_2$ï¼Œä½¿å¾—æ¯æ¡è¾¹çš„ä¸€ä¸ªç«¯ç‚¹å±äº $V_1$ï¼Œå¦ä¸€ä¸ªç«¯ç‚¹å±äº $V_2$ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å›¾çš„ä»£æ•°ç»“æ„

**å®šä¹‰ 2.1** (å›¾çš„é‚»æ¥çŸ©é˜µ)
è®¾ $G = (V, E)$ æ˜¯ä¸€ä¸ªæœ‰ $n$ ä¸ªé¡¶ç‚¹çš„å›¾ï¼Œ$V = \{v_1, v_2, \ldots, v_n\}$ã€‚å›¾ $G$ çš„**é‚»æ¥çŸ©é˜µ** $A = [a_{ij}]$ æ˜¯ä¸€ä¸ª $n \times n$ çŸ©é˜µï¼Œå…¶ä¸­ï¼š
$$a_{ij} = \begin{cases}
1 & \text{if } v_i v_j \in E \\
0 & \text{otherwise}
\end{cases}$$

**å®šä¹‰ 2.2** (å›¾çš„å…³è”çŸ©é˜µ)
è®¾ $G = (V, E)$ æ˜¯ä¸€ä¸ªæœ‰ $n$ ä¸ªé¡¶ç‚¹å’Œ $m$ æ¡è¾¹çš„å›¾ã€‚å›¾ $G$ çš„**å…³è”çŸ©é˜µ** $B = [b_{ij}]$ æ˜¯ä¸€ä¸ª $n \times m$ çŸ©é˜µï¼Œå…¶ä¸­ï¼š
$$b_{ij} = \begin{cases}
1 & \text{if vertex } v_i \text{ is incident to edge } e_j \\
0 & \text{otherwise}
\end{cases}$$

### 2.2 å›¾çš„è¿ç®—

**å®šä¹‰ 2.3** (å›¾çš„å¹¶)
è®¾ $G_1 = (V_1, E_1)$ å’Œ $G_2 = (V_2, E_2)$ æ˜¯ä¸¤ä¸ªå›¾ï¼Œåˆ™å®ƒä»¬çš„**å¹¶**å®šä¹‰ä¸ºï¼š
$$G_1 \cup G_2 = (V_1 \cup V_2, E_1 \cup E_2)$$

**å®šä¹‰ 2.4** (å›¾çš„äº¤)
è®¾ $G_1 = (V_1, E_1)$ å’Œ $G_2 = (V_2, E_2)$ æ˜¯ä¸¤ä¸ªå›¾ï¼Œåˆ™å®ƒä»¬çš„**äº¤**å®šä¹‰ä¸ºï¼š
$$G_1 \cap G_2 = (V_1 \cap V_2, E_1 \cap E_2)$$

**å®šä¹‰ 2.5** (å›¾çš„è¡¥)
è®¾ $G = (V, E)$ æ˜¯ä¸€ä¸ªå›¾ï¼Œåˆ™ $G$ çš„**è¡¥å›¾** $\overline{G}$ å®šä¹‰ä¸ºï¼š
$$\overline{G} = (V, \overline{E})$$
å…¶ä¸­ $\overline{E} = \{uv : u, v \in V, u \neq v, uv \notin E\}$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬å®šç†

**å®šç† 3.1** (æ¡æ‰‹å®šç†)
åœ¨ä»»ä½•å›¾ä¸­ï¼Œæ‰€æœ‰é¡¶ç‚¹çš„åº¦æ•°ä¹‹å’Œç­‰äºè¾¹æ•°çš„ä¸¤å€ï¼š
$$\sum_{v \in V} \deg(v) = 2|E|$$

**è¯æ˜**ï¼š
æ¯æ¡è¾¹è´¡çŒ®ç»™ä¸¤ä¸ªé¡¶ç‚¹çš„åº¦æ•°å„1ï¼Œå› æ­¤æ‰€æœ‰åº¦æ•°ä¹‹å’Œç­‰äºè¾¹æ•°çš„ä¸¤å€ã€‚

**æ¨è®º 3.1** (å¥‡åº¦æ•°é¡¶ç‚¹å®šç†)
åœ¨ä»»ä½•å›¾ä¸­ï¼Œå¥‡åº¦æ•°çš„é¡¶ç‚¹ä¸ªæ•°æ˜¯å¶æ•°ã€‚

**è¯æ˜**ï¼š
è®¾å¥‡åº¦æ•°é¡¶ç‚¹é›†åˆä¸º $S$ï¼Œå¶åº¦æ•°é¡¶ç‚¹é›†åˆä¸º $T$ã€‚ç”±æ¡æ‰‹å®šç†ï¼š
$$\sum_{v \in S} \deg(v) + \sum_{v \in T} \deg(v) = 2|E|$$

ç”±äº $\sum_{v \in T} \deg(v)$ æ˜¯å¶æ•°ï¼Œ$\sum_{v \in S} \deg(v)$ ä¹Ÿå¿…é¡»æ˜¯å¶æ•°ã€‚è€Œ $S$ ä¸­æ¯ä¸ªé¡¶ç‚¹çš„åº¦æ•°éƒ½æ˜¯å¥‡æ•°ï¼Œæ‰€ä»¥ $|S|$ å¿…é¡»æ˜¯å¶æ•°ã€‚

### 3.2 è¿é€šæ€§å®šç†

**å®šä¹‰ 3.1** (è¿é€šå›¾)
ä¸€ä¸ªå›¾ $G$ æ˜¯**è¿é€šçš„**ï¼ˆConnectedï¼‰ï¼Œå¦‚æœå¯¹äºä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ $u$ å’Œ $v$ï¼Œéƒ½å­˜åœ¨ä» $u$ åˆ° $v$ çš„è·¯å¾„ã€‚

**å®šç† 3.2** (è¿é€šæ€§åˆ¤å®š)
ä¸€ä¸ªå›¾ $G$ æ˜¯è¿é€šçš„å½“ä¸”ä»…å½“å¯¹äºä»»æ„éç©ºçœŸå­é›† $S \subset V$ï¼Œéƒ½å­˜åœ¨ä¸€æ¡è¾¹è¿æ¥ $S$ å’Œ $V \setminus S$ã€‚

**è¯æ˜**ï¼š
å¿…è¦æ€§ï¼šå¦‚æœ $G$ æ˜¯è¿é€šçš„ï¼Œé‚£ä¹ˆå¯¹äºä»»æ„ $S \subset V$ï¼Œå­˜åœ¨ $u \in S$ å’Œ $v \in V \setminus S$ï¼Œç”±äº $G$ è¿é€šï¼Œå­˜åœ¨ä» $u$ åˆ° $v$ çš„è·¯å¾„ï¼Œè¯¥è·¯å¾„å¿…æœ‰ä¸€æ¡è¾¹è¿æ¥ $S$ å’Œ $V \setminus S$ã€‚

å……åˆ†æ€§ï¼šå‡è®¾æ¡ä»¶æˆç«‹ã€‚å¯¹äºä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ $u$ å’Œ $v$ï¼Œè®¾ $S$ ä¸ºä» $u$ å¯è¾¾çš„é¡¶ç‚¹é›†åˆã€‚å¦‚æœ $v \notin S$ï¼Œåˆ™å­˜åœ¨è¾¹è¿æ¥ $S$ å’Œ $V \setminus S$ï¼Œè¿™ä¸ $S$ çš„å®šä¹‰çŸ›ç›¾ã€‚å› æ­¤ $v \in S$ï¼Œå³å­˜åœ¨ä» $u$ åˆ° $v$ çš„è·¯å¾„ã€‚

### 3.3 æ ‘çš„æ€§è´¨

**å®šä¹‰ 3.2** (æ ‘)
ä¸€ä¸ª**æ ‘**ï¼ˆTreeï¼‰æ˜¯ä¸€ä¸ªè¿é€šæ— ç¯å›¾ã€‚

**å®šç† 3.3** (æ ‘çš„æ€§è´¨)
è®¾ $T$ æ˜¯ä¸€ä¸ªæœ‰ $n$ ä¸ªé¡¶ç‚¹çš„å›¾ï¼Œåˆ™ä»¥ä¸‹å‘½é¢˜ç­‰ä»·ï¼š
1. $T$ æ˜¯ä¸€ä¸ªæ ‘
2. $T$ æ˜¯è¿é€šçš„ä¸”æœ‰ $n-1$ æ¡è¾¹
3. $T$ æ˜¯æ— ç¯çš„ä¸”æœ‰ $n-1$ æ¡è¾¹
4. $T$ ä¸­ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´æœ‰å”¯ä¸€è·¯å¾„
5. $T$ æ˜¯è¿é€šçš„ï¼Œä½†åˆ é™¤ä»»æ„ä¸€æ¡è¾¹åä¸å†è¿é€š

**è¯æ˜**ï¼š
æˆ‘ä»¬è¯æ˜ $1 \Rightarrow 2 \Rightarrow 3 \Rightarrow 4 \Rightarrow 5 \Rightarrow 1$ã€‚

$1 \Rightarrow 2$ï¼šæ ‘æ˜¯è¿é€šçš„ï¼Œä¸”æ— ç¯æ„å‘³ç€æ¯æ¡è¾¹éƒ½æ˜¯æ¡¥ï¼Œå› æ­¤è¾¹æ•°ä¸º $n-1$ã€‚

$2 \Rightarrow 3$ï¼šå¦‚æœ $T$ æœ‰ç¯ï¼Œåˆ™åˆ é™¤ç¯ä¸Šçš„ä¸€æ¡è¾¹åä»è¿é€šï¼Œè¿™ä¸è¾¹æ•°ä¸º $n-1$ çŸ›ç›¾ã€‚

$3 \Rightarrow 4$ï¼šæ— ç¯å›¾æ˜¯æ£®æ—ï¼Œ$n-1$ æ¡è¾¹æ„å‘³ç€åªæœ‰ä¸€ä¸ªè¿é€šåˆ†é‡ï¼Œå³è¿é€šã€‚ä»»æ„ä¸¤ç‚¹é—´è·¯å¾„å”¯ä¸€ã€‚

$4 \Rightarrow 5$ï¼šå¦‚æœåˆ é™¤è¾¹ $e$ åä»è¿é€šï¼Œåˆ™å­˜åœ¨ä¸¤æ¡ä¸åŒçš„è·¯å¾„è¿æ¥ $e$ çš„ä¸¤ä¸ªç«¯ç‚¹ï¼Œè¿™ä¸å”¯ä¸€æ€§çŸ›ç›¾ã€‚

$5 \Rightarrow 1$ï¼šè¿é€šä¸”æ¯æ¡è¾¹éƒ½æ˜¯æ¡¥æ„å‘³ç€æ— ç¯ã€‚

## 4. ä»£ç å®ç°

### 4.1 Rustå®ç°

```rust
use std::collections::{HashMap, HashSet, VecDeque};

/// å›¾çš„è¡¨ç¤º
# [derive(Debug, Clone)]
pub struct Graph {
    adjacency_list: HashMap<usize, HashSet<usize>>,
    directed: bool,
}

impl Graph {
    /// åˆ›å»ºæ–°çš„å›¾
    pub fn new(directed: bool) -> Self {
        Self {
            adjacency_list: HashMap::new(),
            directed,
        }
    }

    /// æ·»åŠ é¡¶ç‚¹
    pub fn add_vertex(&mut self, vertex: usize) {
        self.adjacency_list.entry(vertex).or_insert_with(HashSet::new);
    }

    /// æ·»åŠ è¾¹
    pub fn add_edge(&mut self, from: usize, to: usize) {
        self.add_vertex(from);
        self.add_vertex(to);

        self.adjacency_list.get_mut(&from).unwrap().insert(to);

        if !self.directed {
            self.adjacency_list.get_mut(&to).unwrap().insert(from);
        }
    }

    /// è·å–é¡¶ç‚¹çš„é‚»å±…
    pub fn get_neighbors(&self, vertex: usize) -> Vec<usize> {
        self.adjacency_list
            .get(&vertex)
            .map(|neighbors| neighbors.iter().cloned().collect())
            .unwrap_or_vec![]
    }

    /// è·å–æ‰€æœ‰é¡¶ç‚¹
    pub fn get_vertices(&self) -> Vec<usize> {
        self.adjacency_list.keys().cloned().collect()
    }

    /// è·å–æ‰€æœ‰è¾¹
    pub fn get_edges(&self) -> Vec<(usize, usize)> {
        let mut edges = Vec::new();
        for (&vertex, neighbors) in &self.adjacency_list {
            for &neighbor in neighbors {
                if !self.directed || vertex < neighbor {
                    edges.push((vertex, neighbor));
                }
            }
        }
        edges
    }

    /// è®¡ç®—é¡¶ç‚¹çš„åº¦æ•°
    pub fn degree(&self, vertex: usize) -> usize {
        self.adjacency_list
            .get(&vertex)
            .map(|neighbors| neighbors.len())
            .unwrap_or(0)
    }

    /// æ£€æŸ¥å›¾æ˜¯å¦è¿é€š
    pub fn is_connected(&self) -> bool {
        if self.adjacency_list.is_empty() {
            return true;
        }

        let vertices = self.get_vertices();
        if vertices.is_empty() {
            return true;
        }

        let start_vertex = vertices[0];
        let mut visited = HashSet::new();
        self.dfs(start_vertex, &mut visited);

        visited.len() == vertices.len()
    }

    /// æ·±åº¦ä¼˜å…ˆæœç´¢
    pub fn dfs(&self, start: usize, visited: &mut HashSet<usize>) {
        visited.insert(start);
        for &neighbor in &self.get_neighbors(start) {
            if !visited.contains(&neighbor) {
                self.dfs(neighbor, visited);
            }
        }
    }

    /// å¹¿åº¦ä¼˜å…ˆæœç´¢
    pub fn bfs(&self, start: usize) -> Vec<usize> {
        let mut visited = HashSet::new();
        let mut queue = VecDeque::new();
        let mut result = Vec::new();

        visited.insert(start);
        queue.push_back(start);

        while let Some(vertex) = queue.pop_front() {
            result.push(vertex);

            for &neighbor in &self.get_neighbors(vertex) {
                if !visited.contains(&neighbor) {
                    visited.insert(neighbor);
                    queue.push_back(neighbor);
                }
            }
        }

        result
    }

    /// æ£€æŸ¥æ˜¯å¦æœ‰ç¯
    pub fn has_cycle(&self) -> bool {
        let mut visited = HashSet::new();
        let mut rec_stack = HashSet::new();

        for &vertex in &self.get_vertices() {
            if !visited.contains(&vertex) {
                if self.has_cycle_dfs(vertex, &mut visited, &mut rec_stack) {
                    return true;
                }
            }
        }
        false
    }

    /// æ£€æŸ¥æ˜¯å¦æœ‰ç¯çš„è¾…åŠ©å‡½æ•°
    fn has_cycle_dfs(&self, vertex: usize, visited: &mut HashSet<usize>, rec_stack: &mut HashSet<usize>) -> bool {
        visited.insert(vertex);
        rec_stack.insert(vertex);

        for &neighbor in &self.get_neighbors(vertex) {
            if !visited.contains(&neighbor) {
                if self.has_cycle_dfs(neighbor, visited, rec_stack) {
                    return true;
                }
            } else if rec_stack.contains(&neighbor) {
                return true;
            }
        }

        rec_stack.remove(&vertex);
        false
    }

    /// è®¡ç®—æœ€çŸ­è·¯å¾„ï¼ˆæ— æƒå›¾ï¼‰
    pub fn shortest_path(&self, start: usize, end: usize) -> Option<Vec<usize>> {
        let mut visited = HashSet::new();
        let mut queue = VecDeque::new();
        let mut parent = HashMap::new();

        visited.insert(start);
        queue.push_back(start);

        while let Some(vertex) = queue.pop_front() {
            if vertex == end {
                // é‡å»ºè·¯å¾„
                let mut path = Vec::new();
                let mut current = end;
                while current != start {
                    path.push(current);
                    current = parent[&current];
                }
                path.push(start);
                path.reverse();
                return Some(path);
            }

            for &neighbor in &self.get_neighbors(vertex) {
                if !visited.contains(&neighbor) {
                    visited.insert(neighbor);
                    parent.insert(neighbor, vertex);
                    queue.push_back(neighbor);
                }
            }
        }

        None
    }

    /// è·å–é‚»æ¥çŸ©é˜µ
    pub fn adjacency_matrix(&self) -> Vec<Vec<usize>> {
        let vertices = self.get_vertices();
        let n = vertices.len();
        let mut matrix = vec![vec![0; n]; n];

        for (i, &vertex) in vertices.iter().enumerate() {
            for &neighbor in &self.get_neighbors(vertex) {
                if let Some(j) = vertices.iter().position(|&v| v == neighbor) {
                    matrix[i][j] = 1;
                }
            }
        }

        matrix
    }
}

/// æ ‘çš„ç»“æ„
# [derive(Debug, Clone)]
pub struct Tree {
    graph: Graph,
}

impl Tree {
    /// åˆ›å»ºæ–°çš„æ ‘
    pub fn new() -> Self {
        Self {
            graph: Graph::new(false),
        }
    }

    /// æ·»åŠ è¾¹ï¼ˆç¡®ä¿ä¸å½¢æˆç¯ï¼‰
    pub fn add_edge(&mut self, from: usize, to: usize) -> bool {
        // æ£€æŸ¥æ·»åŠ è¾¹æ˜¯å¦ä¼šå½¢æˆç¯
        self.graph.add_edge(from, to);
        if self.graph.has_cycle() {
            // ç§»é™¤è¾¹
            self.graph.adjacency_list.get_mut(&from).unwrap().remove(&to);
            self.graph.adjacency_list.get_mut(&to).unwrap().remove(&from);
            return false;
        }
        true
    }

    /// è·å–æ ¹åˆ°å¶å­çš„è·¯å¾„
    pub fn get_path_to_leaf(&self, root: usize) -> Vec<Vec<usize>> {
        let mut paths = Vec::new();
        self.get_paths_dfs(root, &mut Vec::new(), &mut paths);
        paths
    }

    /// è·å–è·¯å¾„çš„è¾…åŠ©å‡½æ•°
    fn get_paths_dfs(&self, vertex: usize, current_path: &mut Vec<usize>, paths: &mut Vec<Vec<usize>>) {
        current_path.push(vertex);

        let neighbors = self.graph.get_neighbors(vertex);
        let unvisited_neighbors: Vec<_> = neighbors
            .iter()
            .filter(|&&n| !current_path.contains(&n))
            .collect();

        if unvisited_neighbors.is_empty() {
            // å¶å­èŠ‚ç‚¹
            paths.push(current_path.clone());
        } else {
            for &&neighbor in &unvisited_neighbors {
                self.get_paths_dfs(neighbor, current_path, paths);
            }
        }

        current_path.pop();
    }
}

# [cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_graph_basic() {
        let mut graph = Graph::new(false);
        graph.add_edge(0, 1);
        graph.add_edge(1, 2);
        graph.add_edge(2, 3);

        assert_eq!(graph.degree(1), 2);
        assert_eq!(graph.get_neighbors(1), vec![0, 2]);
        assert!(graph.is_connected());
    }

    #[test]
    fn test_graph_bfs() {
        let mut graph = Graph::new(false);
        graph.add_edge(0, 1);
        graph.add_edge(0, 2);
        graph.add_edge(1, 3);
        graph.add_edge(2, 4);

        let bfs_result = graph.bfs(0);
        assert_eq!(bfs_result, vec![0, 1, 2, 3, 4]);
    }

    #[test]
    fn test_graph_shortest_path() {
        let mut graph = Graph::new(false);
        graph.add_edge(0, 1);
        graph.add_edge(1, 2);
        graph.add_edge(0, 2);
        graph.add_edge(2, 3);

        let path = graph.shortest_path(0, 3);
        assert_eq!(path, Some(vec![0, 2, 3]));
    }

    #[test]
    fn test_tree() {
        let mut tree = Tree::new();
        assert!(tree.add_edge(0, 1));
        assert!(tree.add_edge(1, 2));
        assert!(tree.add_edge(1, 3));

        let paths = tree.get_path_to_leaf(0);
        assert_eq!(paths.len(), 2);
    }
}
```

### 4.2 Haskellå®ç°

```haskell
import Data.List (nub, (\\), intersect)
import Data.Maybe (fromJust)
import qualified Data.Map as Map
import qualified Data.Set as Set

-- å›¾çš„è¡¨ç¤º
data Graph = Graph {
    adjacencyList :: Map.Map Int [Int],
    isDirected :: Bool
} deriving (Show, Eq)

-- åˆ›å»ºæ–°å›¾
emptyGraph :: Bool -> Graph
emptyGraph directed = Graph Map.empty directed

-- æ·»åŠ é¡¶ç‚¹
addVertex :: Int -> Graph -> Graph
addVertex v g = g { adjacencyList = Map.insert v [] (adjacencyList g) }

-- æ·»åŠ è¾¹
addEdge :: Int -> Int -> Graph -> Graph
addEdge from to g =
    let g' = addVertex from $ addVertex to g
        neighbors = Map.findWithDefault [] from (adjacencyList g')
        newNeighbors = to : neighbors
        g'' = g' { adjacencyList = Map.insert from newNeighbors (adjacencyList g') }
    in if isDirected g
       then g''
       else let neighbors' = Map.findWithDefault [] to (adjacencyList g'')
                newNeighbors' = from : neighbors'
            in g'' { adjacencyList = Map.insert to newNeighbors' (adjacencyList g'') }

-- è·å–é¡¶ç‚¹çš„é‚»å±…
getNeighbors :: Int -> Graph -> [Int]
getNeighbors v g = Map.findWithDefault [] v (adjacencyList g)

-- è·å–æ‰€æœ‰é¡¶ç‚¹
getVertices :: Graph -> [Int]
getVertices g = Map.keys (adjacencyList g)

-- è·å–æ‰€æœ‰è¾¹
getEdges :: Graph -> [(Int, Int)]
getEdges g = concatMap (\(v, neighbors) -> map (v,) neighbors) (Map.toList (adjacencyList g))

-- è®¡ç®—é¡¶ç‚¹çš„åº¦æ•°
degree :: Int -> Graph -> Int
degree v g = length (getNeighbors v g)

-- æ·±åº¦ä¼˜å…ˆæœç´¢
dfs :: Int -> Graph -> [Int]
dfs start g = dfsHelper start g Set.empty
  where
    dfsHelper v g visited
        | Set.member v visited = []
        | otherwise = v : concatMap (\n -> dfsHelper n g (Set.insert v visited)) (getNeighbors v g)

-- å¹¿åº¦ä¼˜å…ˆæœç´¢
bfs :: Int -> Graph -> [Int]
bfs start g = bfsHelper [start] g Set.empty
  where
    bfsHelper [] _ _ = []
    bfsHelper (v:vs) g visited
        | Set.member v visited = bfsHelper vs g visited
        | otherwise = v : bfsHelper (vs ++ getNeighbors v g) g (Set.insert v visited)

-- æ£€æŸ¥å›¾æ˜¯å¦è¿é€š
isConnected :: Graph -> Bool
isConnected g =
    let vertices = getVertices g
    in if null vertices
       then True
       else let start = head vertices
                reachable = Set.fromList (dfs start g)
            in Set.size reachable == length vertices

-- æ£€æŸ¥æ˜¯å¦æœ‰ç¯
hasCycle :: Graph -> Bool
hasCycle g = any (\v -> hasCycleFrom v g Set.empty Set.empty) (getVertices g)
  where
    hasCycleFrom v g visited recStack
        | Set.member v recStack = True
        | Set.member v visited = False
        | otherwise = let visited' = Set.insert v visited
                         recStack' = Set.insert v recStack
                     in any (\n -> hasCycleFrom n g visited' recStack') (getNeighbors v g)

-- æœ€çŸ­è·¯å¾„ï¼ˆæ— æƒå›¾ï¼‰
shortestPath :: Int -> Int -> Graph -> Maybe [Int]
shortestPath start end g = shortestPathHelper [start] g Map.empty
  where
    shortestPathHelper [] _ _ = Nothing
    shortestPathHelper (v:vs) g parent
        | v == end = Just (reverse (reconstructPath v parent))
        | otherwise = let neighbors = filter (\n -> not (Map.member n parent)) (getNeighbors v g)
                         parent' = foldr (\n p -> Map.insert n v p) parent neighbors
                     in shortestPathHelper (vs ++ neighbors) g parent'

    reconstructPath v parent
        | v == start = [v]
        | otherwise = v : reconstructPath (fromJust (Map.lookup v parent)) parent

-- é‚»æ¥çŸ©é˜µ
adjacencyMatrix :: Graph -> [[Int]]
adjacencyMatrix g =
    let vertices = getVertices g
        n = length vertices
    in [[if j `elem` getNeighbors i g then 1 else 0 | j <- vertices] | i <- vertices]

-- æ ‘çš„ç»“æ„
data Tree = Tree Graph deriving (Show, Eq)

-- åˆ›å»ºæ–°æ ‘
emptyTree :: Tree
emptyTree = Tree (emptyGraph False)

-- æ·»åŠ è¾¹åˆ°æ ‘ï¼ˆç¡®ä¿ä¸å½¢æˆç¯ï¼‰
addTreeEdge :: Int -> Int -> Tree -> Maybe Tree
addTreeEdge from to (Tree g) =
    let g' = addEdge from to g
    in if hasCycle g'
       then Nothing
       else Just (Tree g')

-- è·å–æ ¹åˆ°å¶å­çš„è·¯å¾„
getPathsToLeaves :: Int -> Tree -> [[Int]]
getPathsToLeaves root (Tree g) = getPathsHelper root g []
  where
    getPathsHelper v g currentPath
        | null unvisitedNeighbors = [reverse (v:currentPath)]
        | otherwise = concatMap (\n -> getPathsHelper n g (v:currentPath)) unvisitedNeighbors
      where
        neighbors = getNeighbors v g
        unvisitedNeighbors = filter (\n -> n `notElem` (v:currentPath)) neighbors

-- ç¤ºä¾‹ä½¿ç”¨
main :: IO ()
main = do
    putStrLn "å›¾è®ºåŸºç¡€ç¤ºä¾‹ï¼š"

    -- åˆ›å»ºæ— å‘å›¾
    let g = foldr (uncurry addEdge) (emptyGraph False) [(0,1), (1,2), (2,3), (0,2)]

    putStrLn $ "å›¾çš„é¡¶ç‚¹: " ++ show (getVertices g)
    putStrLn $ "å›¾çš„è¾¹: " ++ show (getEdges g)
    putStrLn $ "é¡¶ç‚¹0çš„åº¦æ•°: " ++ show (degree 0 g)
    putStrLn $ "å›¾æ˜¯å¦è¿é€š: " ++ show (isConnected g)
    putStrLn $ "BFSéå†: " ++ show (bfs 0 g)
    putStrLn $ "æœ€çŸ­è·¯å¾„ 0->3: " ++ show (shortestPath 0 3 g)

    -- åˆ›å»ºæ ‘
    let tree = fromJust $ foldr (uncurry addTreeEdge) (Just emptyTree) [(0,1), (1,2), (1,3)]
    putStrLn $ "æ ‘ä¸­ä»æ ¹åˆ°å¶å­çš„è·¯å¾„: " ++ show (getPathsToLeaves 0 tree)
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç¤¾äº¤ç½‘ç»œåˆ†æ

**é—®é¢˜**ï¼šåœ¨ä¸€ä¸ªç¤¾äº¤ç½‘ç»œä¸­ï¼Œå¦‚ä½•æ‰¾åˆ°ä¸¤ä¸ªç”¨æˆ·ä¹‹é—´çš„æœ€çŸ­è¿æ¥è·¯å¾„ï¼Ÿ

**è§£**ï¼š
ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢ç®—æ³•ï¼š

```rust
pub fn find_shortest_connection(graph: &Graph, user1: usize, user2: usize) -> Option<Vec<usize>> {
    graph.shortest_path(user1, user2)
}
```

### 5.2 ç½‘ç»œæ‹“æ‰‘è®¾è®¡

**é—®é¢˜**ï¼šè®¾è®¡ä¸€ä¸ªåŒ…å«nä¸ªèŠ‚ç‚¹çš„ç½‘ç»œï¼Œä½¿å¾—ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´éƒ½æœ‰è¿æ¥ï¼Œä¸”æ€»è¾¹æ•°æœ€å°‘ã€‚

**è§£**ï¼š
è¿™æ˜¯ä¸€ä¸ªæœ€å°ç”Ÿæˆæ ‘é—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨Kruskalæˆ–Primç®—æ³•ï¼š

```rust
pub fn minimum_spanning_tree(graph: &Graph) -> Graph {
    // å®ç°Kruskalç®—æ³•
    let mut mst = Graph::new(false);
    let mut edges = graph.get_edges();
    edges.sort_by_key(|(u, v)| graph.weight(*u, *v)); // å‡è®¾æœ‰æƒé‡å‡½æ•°

    for (u, v) in edges {
        if !mst.has_cycle() {
            mst.add_edge(u, v);
        }
    }
    mst
}
```

### 5.3 ä»»åŠ¡è°ƒåº¦

**é—®é¢˜**ï¼šæœ‰nä¸ªä»»åŠ¡ï¼ŒæŸäº›ä»»åŠ¡å¿…é¡»åœ¨å…¶ä»–ä»»åŠ¡å®Œæˆåæ‰èƒ½å¼€å§‹ï¼Œå¦‚ä½•å®‰æ’ä»»åŠ¡é¡ºåºï¼Ÿ

**è§£**ï¼š
ä½¿ç”¨æ‹“æ‰‘æ’åºï¼š

```rust
pub fn topological_sort(graph: &Graph) -> Option<Vec<usize>> {
    let mut in_degree = HashMap::new();
    let mut queue = VecDeque::new();
    let mut result = Vec::new();

    // è®¡ç®—å…¥åº¦
    for &vertex in &graph.get_vertices() {
        in_degree.insert(vertex, 0);
    }

    for &(_, to) in &graph.get_edges() {
        *in_degree.get_mut(&to).unwrap() += 1;
    }

    // æ‰¾åˆ°å…¥åº¦ä¸º0çš„é¡¶ç‚¹
    for (&vertex, &degree) in &in_degree {
        if degree == 0 {
            queue.push_back(vertex);
        }
    }

    while let Some(vertex) = queue.pop_front() {
        result.push(vertex);

        for &neighbor in &graph.get_neighbors(vertex) {
            let degree = in_degree.get_mut(&neighbor).unwrap();
            *degree -= 1;
            if *degree == 0 {
                queue.push_back(neighbor);
            }
        }
    }

    if result.len() == graph.get_vertices().len() {
        Some(result)
    } else {
        None // æœ‰ç¯
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸ç»„åˆæ•°å­¦çš„å…³ç³»

- **è®¡æ•°é—®é¢˜**ï¼šå›¾çš„è®¡æ•°ã€è·¯å¾„è®¡æ•°
- **ç”Ÿæˆå‡½æ•°**ï¼šå›¾çš„ç”Ÿæˆå‡½æ•°è¡¨ç¤º
- **æ’åˆ—ç»„åˆ**ï¼šå›¾çš„æ’åˆ—å’Œç»„åˆ

### 6.2 ä¸å½¢å¼è¯­è¨€ç†è®ºçš„å…³ç³»

- **è‡ªåŠ¨æœº**ï¼šçŠ¶æ€è½¬ç§»å›¾
- **æ­£åˆ™è¡¨è¾¾å¼**ï¼šå¯¹åº”çš„æœ‰é™è‡ªåŠ¨æœº
- **ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•**ï¼šè¯­æ³•åˆ†ææ ‘

### 6.3 ä¸ç±»å‹ç†è®ºçš„å…³ç³»

- **ç±»å‹å›¾**ï¼šç±»å‹ä¹‹é—´çš„å…³ç³»å›¾
- **ä¾èµ–å›¾**ï¼šç±»å‹ä¾èµ–å…³ç³»
- **ç±»å‹æ¨å¯¼**ï¼šå›¾çš„éå†ç®—æ³•

### 6.4 ä¸åˆ†å¸ƒå¼ç³»ç»Ÿçš„å…³ç³»

- **ç½‘ç»œæ‹“æ‰‘**ï¼šèŠ‚ç‚¹è¿æ¥å…³ç³»
- **è·¯ç”±ç®—æ³•**ï¼šæœ€çŸ­è·¯å¾„ç®—æ³•
- **ä¸€è‡´æ€§åè®®**ï¼šå›¾çš„è¿é€šæ€§

## 7. å‚è€ƒæ–‡çŒ®

1. Bondy, J. A., & Murty, U. S. R. (2008). *Graph Theory*. Springer.
2. Diestel, R. (2017). *Graph Theory*. Springer.
3. West, D. B. (2001). *Introduction to Graph Theory*. Prentice Hall.
4. Harary, F. (1969). *Graph Theory*. Addison-Wesley.
5. BollobÃ¡s, B. (1998). *Modern Graph Theory*. Springer.

---

**ç›¸å…³æ–‡æ¡£**ï¼š
- [02.11.1 è®¡æ•°åŸç†](../02_Mathematical_Foundation/02.11.1_è®¡æ•°åŸç†.md)
- [02.11.2 æ’åˆ—ç»„åˆ](../02_Mathematical_Foundation/02.11.2_æ’åˆ—ç»„åˆ.md)
- [02.11.3 ç”Ÿæˆå‡½æ•°](../02_Mathematical_Foundation/02.11.3_ç”Ÿæˆå‡½æ•°.md)
- [03.1.1 æœ‰é™è‡ªåŠ¨æœº](../03_Formal_Language_Theory/03.1.1_æœ‰é™è‡ªåŠ¨æœº.md)
- [04.1.1 ç®€å•ç±»å‹Î»æ¼”ç®—](../04_Type_Theory/04.1.1_ç®€å•ç±»å‹Î»æ¼”ç®—.md)


## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
