# 02.11.4 å›¾è®ºåŸºç¡€

## ğŸ“‹ æ¦‚è¿°

å›¾è®ºæ˜¯ç ”ç©¶å›¾ç»“æ„çš„æ•°å­¦åˆ†æ”¯ï¼Œä¸ºè®¡ç®—æœºç§‘å­¦ã€ç½‘ç»œåˆ†æã€è¿ç­¹å­¦ç­‰æä¾›åŸºç¡€å·¥å…·ã€‚æœ¬ç†è®ºå»ºç«‹å›¾çš„åŸºæœ¬æ¦‚å¿µã€æ€§è´¨å’Œç®—æ³•ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹å›¾è®ºçš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. è¯æ˜åŸºæœ¬æ€§è´¨å’Œå®šç†
3. æä¾›é«˜æ•ˆçš„ç®—æ³•å®ç°
4. å±•ç¤ºåœ¨å½¢å¼ç§‘å­¦ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

- [02.11.4 å›¾è®ºåŸºç¡€](#02114-å›¾è®ºåŸºç¡€)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒç›®æ ‡](#-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 å›¾çš„åŸºæœ¬å®šä¹‰](#11-å›¾çš„åŸºæœ¬å®šä¹‰)
    - [1.2 å›¾çš„ç±»å‹](#12-å›¾çš„ç±»å‹)
    - [1.3 åŸºæœ¬æ€§è´¨](#13-åŸºæœ¬æ€§è´¨)
  - [2. å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
    - [2.1 å›¾çš„æ•°å­¦è¡¨ç¤º](#21-å›¾çš„æ•°å­¦è¡¨ç¤º)
    - [2.2 è·¯å¾„å’Œè¿é€šæ€§](#22-è·¯å¾„å’Œè¿é€šæ€§)
  - [3. å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
    - [3.1 æ¡æ‰‹å®šç†](#31-æ¡æ‰‹å®šç†)
    - [3.2 æ¬§æ‹‰å®šç†](#32-æ¬§æ‹‰å®šç†)
  - [4. ç®—æ³•å®ç°](#4-ç®—æ³•å®ç°)
    - [4.1 Rust å®ç°](#41-rust-å®ç°)
  - [5. åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
    - [5.1 ç½‘ç»œåˆ†æ](#51-ç½‘ç»œåˆ†æ)
    - [5.2 ç®—æ³•è®¾è®¡](#52-ç®—æ³•è®¾è®¡)
    - [5.3 å½¢å¼éªŒè¯](#53-å½¢å¼éªŒè¯)
  - [6. ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
    - [6.1 ç»„åˆæ•°å­¦](#61-ç»„åˆæ•°å­¦)
    - [6.2 çº¿æ€§ä»£æ•°](#62-çº¿æ€§ä»£æ•°)
    - [6.3 ç®—æ³•ç†è®º](#63-ç®—æ³•ç†è®º)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 å›¾çš„åŸºæœ¬å®šä¹‰

**å®šä¹‰ 1.1.1** (å›¾)
å›¾ $G = (V, E)$ ç”±é¡¶ç‚¹é›† $V$ å’Œè¾¹é›† $E \subseteq V \times V$ ç»„æˆã€‚

### 1.2 å›¾çš„ç±»å‹

**å®šä¹‰ 1.1.2** (æ— å‘å›¾)
æ— å‘å›¾ä¸­è¾¹æ˜¯æ— åºå¯¹ï¼Œ$(u,v) = (v,u)$ã€‚

**å®šä¹‰ 1.1.3** (æœ‰å‘å›¾)
æœ‰å‘å›¾ä¸­è¾¹æ˜¯æœ‰åºå¯¹ï¼Œ$(u,v) \neq (v,u)$ã€‚

### 1.3 åŸºæœ¬æ€§è´¨

**å®šä¹‰ 1.1.4** (åº¦æ•°)
é¡¶ç‚¹ $v$ çš„åº¦æ•° $deg(v)$ æ˜¯ä¸ $v$ ç›¸é‚»çš„è¾¹æ•°ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 å›¾çš„æ•°å­¦è¡¨ç¤º

**å®šä¹‰ 2.1.1** (é‚»æ¥çŸ©é˜µ)
å›¾ $G = (V, E)$ çš„é‚»æ¥çŸ©é˜µ $A$ å®šä¹‰ä¸ºï¼š
$$
A_{ij} = \begin{cases}
1 & \text{if } (v_i, v_j) \in E \\
0 & \text{otherwise}
\end{cases}
$$

### 2.2 è·¯å¾„å’Œè¿é€šæ€§

**å®šä¹‰ 2.1.2** (è·¯å¾„)
è·¯å¾„æ˜¯é¡¶ç‚¹åºåˆ— $v_0, v_1, \ldots, v_k$ï¼Œå…¶ä¸­ $(v_i, v_{i+1}) \in E$ã€‚

**å®šä¹‰ 2.1.3** (è¿é€šæ€§)
å›¾æ˜¯è¿é€šçš„ï¼Œå½“ä¸”ä»…å½“ä»»æ„ä¸¤é¡¶ç‚¹é—´å­˜åœ¨è·¯å¾„ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 æ¡æ‰‹å®šç†

**å®šç† 3.1.1** (æ¡æ‰‹å®šç†)
å¯¹äºä»»æ„å›¾ $G = (V, E)$ï¼š
$$\sum_{v \in V} deg(v) = 2|E|$$

**è¯æ˜**ï¼š
æ¯æ¡è¾¹è´¡çŒ®ç»™ä¸¤ä¸ªé¡¶ç‚¹çš„åº¦æ•°ï¼Œå› æ­¤æ€»åº¦æ•°ç­‰äºè¾¹æ•°çš„ä¸¤å€ã€‚

### 3.2 æ¬§æ‹‰å®šç†

**å®šç† 3.2.1** (æ¬§æ‹‰å®šç†)
è¿é€šå›¾å­˜åœ¨æ¬§æ‹‰å›è·¯çš„å……è¦æ¡ä»¶æ˜¯æ‰€æœ‰é¡¶ç‚¹çš„åº¦æ•°éƒ½æ˜¯å¶æ•°ã€‚

**è¯æ˜**ï¼š
å¿…è¦æ€§ï¼šæ¬§æ‹‰å›è·¯ä¸­æ¯ä¸ªé¡¶ç‚¹è¿›å‡ºæ¬¡æ•°ç›¸ç­‰ã€‚
å……åˆ†æ€§ï¼šä½¿ç”¨æ„é€ æ€§è¯æ˜ã€‚

## 4. ç®—æ³•å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::{HashMap, HashSet, VecDeque};
use std::fmt;

/// å›¾ç»“æ„
# [derive(Debug, Clone)]
pub struct Graph {
    vertices: Vec<usize>,
    edges: Vec<(usize, usize)>,
    is_directed: bool,
}

impl Graph {
    /// åˆ›å»ºæ–°å›¾
    pub fn new(is_directed: bool) -> Self {
        Self {
            vertices: Vec::new(),
            edges: Vec::new(),
            is_directed,
        }
    }

    /// æ·»åŠ é¡¶ç‚¹
    pub fn add_vertex(&mut self, vertex: usize) {
        if !self.vertices.contains(&vertex) {
            self.vertices.push(vertex);
        }
    }

    /// æ·»åŠ è¾¹
    pub fn add_edge(&mut self, from: usize, to: usize) {
        self.add_vertex(from);
        self.add_vertex(to);
        self.edges.push((from, to));

        if !self.is_directed {
            self.edges.push((to, from));
        }
    }

    /// è·å–é‚»æ¥è¡¨
    pub fn adjacency_list(&self) -> HashMap<usize, Vec<usize>> {
        let mut adj_list = HashMap::new();

        for &vertex in &self.vertices {
            adj_list.insert(vertex, Vec::new());
        }

        for &(from, to) in &self.edges {
            adj_list.get_mut(&from).unwrap().push(to);
        }

        adj_list
    }

    /// è·å–é‚»æ¥çŸ©é˜µ
    pub fn adjacency_matrix(&self) -> Vec<Vec<bool>> {
        let n = self.vertices.len();
        let mut matrix = vec![vec![false; n]; n];

        for &(from, to) in &self.edges {
            let from_idx = self.vertices.iter().position(|&x| x == from).unwrap();
            let to_idx = self.vertices.iter().position(|&x| x == to).unwrap();
            matrix[from_idx][to_idx] = true;
        }

        matrix
    }

    /// è®¡ç®—åº¦æ•°
    pub fn degree(&self, vertex: usize) -> usize {
        self.edges.iter().filter(|&&(from, to)| from == vertex || to == vertex).count()
    }

    /// æ·±åº¦ä¼˜å…ˆæœç´¢
    pub fn dfs(&self, start: usize) -> Vec<usize> {
        let mut visited = HashSet::new();
        let mut result = Vec::new();
        let adj_list = self.adjacency_list();

        self.dfs_recursive(start, &adj_list, &mut visited, &mut result);
        result
    }

    /// æ·±åº¦ä¼˜å…ˆæœç´¢é€’å½’å®ç°
    fn dfs_recursive(
        &self,
        vertex: usize,
        adj_list: &HashMap<usize, Vec<usize>>,
        visited: &mut HashSet<usize>,
        result: &mut Vec<usize>
    ) {
        if visited.contains(&vertex) {
            return;
        }

        visited.insert(vertex);
        result.push(vertex);

        if let Some(neighbors) = adj_list.get(&vertex) {
            for &neighbor in neighbors {
                self.dfs_recursive(neighbor, adj_list, visited, result);
            }
        }
    }

    /// å¹¿åº¦ä¼˜å…ˆæœç´¢
    pub fn bfs(&self, start: usize) -> Vec<usize> {
        let mut visited = HashSet::new();
        let mut result = Vec::new();
        let mut queue = VecDeque::new();
        let adj_list = self.adjacency_list();

        queue.push_back(start);
        visited.insert(start);

        while let Some(vertex) = queue.pop_front() {
            result.push(vertex);

            if let Some(neighbors) = adj_list.get(&vertex) {
                for &neighbor in neighbors {
                    if !visited.contains(&neighbor) {
                        visited.insert(neighbor);
                        queue.push_back(neighbor);
                    }
                }
            }
        }

        result
    }

    /// æ£€æŸ¥è¿é€šæ€§
    pub fn is_connected(&self) -> bool {
        if self.vertices.is_empty() {
            return true;
        }

        let start = self.vertices[0];
        let reachable = self.dfs(start);
        reachable.len() == self.vertices.len()
    }

    /// æŸ¥æ‰¾æœ€çŸ­è·¯å¾„ (Dijkstraç®—æ³•)
    pub fn shortest_paths(&self, start: usize) -> HashMap<usize, usize> {
        let mut distances = HashMap::new();
        let mut visited = HashSet::new();
        let adj_list = self.adjacency_list();

        // åˆå§‹åŒ–è·ç¦»
        for &vertex in &self.vertices {
            distances.insert(vertex, usize::MAX);
        }
        distances.insert(start, 0);

        while visited.len() < self.vertices.len() {
            // æ‰¾åˆ°æœªè®¿é—®çš„æœ€å°è·ç¦»é¡¶ç‚¹
            let current = self.vertices.iter()
                .filter(|&&v| !visited.contains(&v))
                .min_by_key(|&&v| distances.get(&v).unwrap_or(&usize::MAX))
                .unwrap();

            visited.insert(*current);

            // æ›´æ–°é‚»å±…è·ç¦»
            if let Some(neighbors) = adj_list.get(current) {
                for &neighbor in neighbors {
                    let new_distance = distances[current] + 1; // å‡è®¾æ‰€æœ‰è¾¹æƒé‡ä¸º1
                    if new_distance < *distances.get(&neighbor).unwrap_or(&usize::MAX) {
                        distances.insert(neighbor, new_distance);
                    }
                }
            }
        }

        distances
    }

    /// æ£€æµ‹ç¯
    pub fn has_cycle(&self) -> bool {
        let mut visited = HashSet::new();
        let mut rec_stack = HashSet::new();
        let adj_list = self.adjacency_list();

        for &vertex in &self.vertices {
            if !visited.contains(&vertex) {
                if self.dfs_cycle(vertex, &adj_list, &mut visited, &mut rec_stack) {
                    return true;
                }
            }
        }

        false
    }

    /// æ·±åº¦ä¼˜å…ˆæœç´¢æ£€æµ‹ç¯
    fn dfs_cycle(
        &self,
        vertex: usize,
        adj_list: &HashMap<usize, Vec<usize>>,
        visited: &mut HashSet<usize>,
        rec_stack: &mut HashSet<usize>
    ) -> bool {
        visited.insert(vertex);
        rec_stack.insert(vertex);

        if let Some(neighbors) = adj_list.get(&vertex) {
            for &neighbor in neighbors {
                if !visited.contains(&neighbor) {
                    if self.dfs_cycle(neighbor, adj_list, visited, rec_stack) {
                        return true;
                    }
                } else if rec_stack.contains(&neighbor) {
                    return true;
                }
            }
        }

        rec_stack.remove(&vertex);
        false
    }

    /// æ‹“æ‰‘æ’åº
    pub fn topological_sort(&self) -> Option<Vec<usize>> {
        if !self.is_directed {
            return None;
        }

        let mut in_degree = HashMap::new();
        let adj_list = self.adjacency_list();

        // è®¡ç®—å…¥åº¦
        for &vertex in &self.vertices {
            in_degree.insert(vertex, 0);
        }

        for neighbors in adj_list.values() {
            for &neighbor in neighbors {
                *in_degree.get_mut(&neighbor).unwrap() += 1;
            }
        }

        // Kahnç®—æ³•
        let mut queue = VecDeque::new();
        let mut result = Vec::new();

        for &vertex in &self.vertices {
            if in_degree[&vertex] == 0 {
                queue.push_back(vertex);
            }
        }

        while let Some(vertex) = queue.pop_front() {
            result.push(vertex);

            if let Some(neighbors) = adj_list.get(&vertex) {
                for &neighbor in neighbors {
                    let degree = in_degree.get_mut(&neighbor).unwrap();
                    *degree -= 1;
                    if *degree == 0 {
                        queue.push_back(neighbor);
                    }
                }
            }
        }

        if result.len() == self.vertices.len() {
            Some(result)
        } else {
            None // å­˜åœ¨ç¯
        }
    }
}

/// ç‰¹æ®Šå›¾ç±»å‹
pub struct SpecialGraphs;

impl SpecialGraphs {
    /// å®Œå…¨å›¾
    pub fn complete_graph(n: usize) -> Graph {
        let mut graph = Graph::new(false);

        for i in 0..n {
            for j in (i+1)..n {
                graph.add_edge(i, j);
            }
        }

        graph
    }

    /// è·¯å¾„å›¾
    pub fn path_graph(n: usize) -> Graph {
        let mut graph = Graph::new(false);

        for i in 0..(n-1) {
            graph.add_edge(i, i+1);
        }

        graph
    }

    /// ç¯å›¾
    pub fn cycle_graph(n: usize) -> Graph {
        let mut graph = Graph::new(false);

        for i in 0..n {
            graph.add_edge(i, (i+1) % n);
        }

        graph
    }

    /// æ˜Ÿå›¾
    pub fn star_graph(n: usize) -> Graph {
        let mut graph = Graph::new(false);

        for i in 1..n {
            graph.add_edge(0, i);
        }

        graph
    }

    /// äºŒåˆ†å›¾
    pub fn bipartite_graph(left_size: usize, right_size: usize) -> Graph {
        let mut graph = Graph::new(false);

        for i in 0..left_size {
            for j in left_size..(left_size + right_size) {
                graph.add_edge(i, j);
            }
        }

        graph
    }
}

# [cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_graph_basic() {
        let mut graph = Graph::new(false);
        graph.add_edge(0, 1);
        graph.add_edge(1, 2);
        graph.add_edge(2, 0);

        assert_eq!(graph.vertices.len(), 3);
        assert_eq!(graph.edges.len(), 6); // æ— å‘å›¾æ¯æ¡è¾¹ç®—ä¸¤æ¬¡
    }

    #[test]
    fn test_dfs() {
        let mut graph = Graph::new(false);
        graph.add_edge(0, 1);
        graph.add_edge(1, 2);
        graph.add_edge(2, 3);

        let dfs_result = graph.dfs(0);
        assert_eq!(dfs_result, vec![0, 1, 2, 3]);
    }

    #[test]
    fn test_bfs() {
        let mut graph = Graph::new(false);
        graph.add_edge(0, 1);
        graph.add_edge(0, 2);
        graph.add_edge(1, 3);
        graph.add_edge(2, 3);

        let bfs_result = graph.bfs(0);
        assert_eq!(bfs_result[0], 0);
    }

    #[test]
    fn test_connectivity() {
        let mut graph = Graph::new(false);
        graph.add_edge(0, 1);
        graph.add_edge(1, 2);
        graph.add_edge(2, 0);

        assert!(graph.is_connected());

        graph.add_vertex(3);
        assert!(!graph.is_connected());
    }

    #[test]
    fn test_cycle_detection() {
        let mut graph = Graph::new(true);
        graph.add_edge(0, 1);
        graph.add_edge(1, 2);
        graph.add_edge(2, 0);

        assert!(graph.has_cycle());

        let mut acyclic_graph = Graph::new(true);
        acyclic_graph.add_edge(0, 1);
        acyclic_graph.add_edge(1, 2);

        assert!(!acyclic_graph.has_cycle());
    }

    #[test]
    fn test_topological_sort() {
        let mut graph = Graph::new(true);
        graph.add_edge(0, 1);
        graph.add_edge(1, 2);
        graph.add_edge(0, 2);

        let sort_result = graph.topological_sort();
        assert!(sort_result.is_some());

        let sorted = sort_result.unwrap();
        assert_eq!(sorted[0], 0);
        assert_eq!(sorted[2], 2);
    }

    #[test]
    fn test_special_graphs() {
        let complete = SpecialGraphs::complete_graph(4);
        assert_eq!(complete.edges.len(), 12); // 6æ¡è¾¹ï¼Œæ— å‘å›¾ç®—ä¸¤æ¬¡

        let path = SpecialGraphs::path_graph(4);
        assert_eq!(path.edges.len(), 6); // 3æ¡è¾¹ï¼Œæ— å‘å›¾ç®—ä¸¤æ¬¡

        let cycle = SpecialGraphs::cycle_graph(4);
        assert_eq!(cycle.edges.len(), 8); // 4æ¡è¾¹ï¼Œæ— å‘å›¾ç®—ä¸¤æ¬¡
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç½‘ç»œåˆ†æ

- ç¤¾äº¤ç½‘ç»œåˆ†æ
- è®¡ç®—æœºç½‘ç»œæ‹“æ‰‘
- äº¤é€šç½‘ç»œè§„åˆ’

### 5.2 ç®—æ³•è®¾è®¡

- æœ€çŸ­è·¯å¾„ç®—æ³•
- æœ€å°ç”Ÿæˆæ ‘
- ç½‘ç»œæµç®—æ³•

### 5.3 å½¢å¼éªŒè¯

- çŠ¶æ€è½¬æ¢å›¾
- ç¨‹åºæ§åˆ¶æµå›¾
- æ¨¡å‹æ£€æŸ¥

## 6. ç›¸å…³ç†è®º

### 6.1 ç»„åˆæ•°å­¦

- [02.11.2 æ’åˆ—ç»„åˆ](02.11.2_Permutations_and_Combinations.md)
- [02.11.3 ç”Ÿæˆå‡½æ•°](02.11.3_Generating_Functions.md)

### 6.2 çº¿æ€§ä»£æ•°

- [02.4.1 å‡½æ•°æ¦‚å¿µ](../02.04_Function_Theory/02.4.1_Function_Concepts.md)

### 6.3 ç®—æ³•ç†è®º

- [03.6.1 å¯è®¡ç®—æ€§ç†è®º](../../04_Formal_Language_Theory/03.6_Computation_Theory/03.6.1_Computability_Theory.md)

## 7. å‚è€ƒæ–‡çŒ®

1. Bondy, J. A., & Murty, U. S. R. (2008). *Graph Theory*. Springer.

2. Diestel, R. (2017). *Graph Theory*. Springer.

3. West, D. B. (2001). *Introduction to Graph Theory*. Prentice Hall.

4. BollobÃ¡s, B. (1998). *Modern Graph Theory*. Springer.

5. Harary, F. (1969). *Graph Theory*. Addison-Wesley.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [ä¸Šä¸€çº§ï¼š02.11 ç»„åˆæ•°å­¦](../README.md)
- [ä¸‹ä¸€çº§ï¼š02.12 æ¦‚ç‡è®º](../README.md)
- [ä¸»ç´¢å¼•ï¼šå½¢å¼ç§‘å­¦ç†è®ºä½“ç³»](../README.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
