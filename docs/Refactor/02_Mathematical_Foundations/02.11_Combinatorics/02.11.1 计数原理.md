# 02.11.1 è®¡æ•°åŸç†

## ğŸ“‹ æ¦‚è¿°

è®¡æ•°åŸç†æ˜¯ç»„åˆæ•°å­¦çš„åŸºç¡€ï¼Œç ”ç©¶å¦‚ä½•è®¡ç®—æœ‰é™é›†åˆä¸­å…ƒç´ çš„æ•°é‡ã€‚å®ƒåŒ…æ‹¬åŠ æ³•åŸç†ã€ä¹˜æ³•åŸç†ã€å®¹æ–¥åŸç†ç­‰åŸºæœ¬æ–¹æ³•ï¼Œæ˜¯è§£å†³ç»„åˆé—®é¢˜çš„é‡è¦å·¥å…·ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹è®¡æ•°çš„åŸºç¡€ç†è®ºä½“ç³»**
2. **æŒæ¡åŠ æ³•åŸç†å’Œä¹˜æ³•åŸç†**
3. **ç†è§£å®¹æ–¥åŸç†çš„åº”ç”¨**
4. **å‘å±•ç»„åˆè®¡æ•°çš„ç®—æ³•**

## ğŸ“š ç›®å½•

- [02.11.1 è®¡æ•°åŸç†](#02111-è®¡æ•°åŸç†)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒç›®æ ‡](#-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 åŠ æ³•åŸç†](#11-åŠ æ³•åŸç†)
    - [1.2 ä¹˜æ³•åŸç†](#12-ä¹˜æ³•åŸç†)
    - [1.3 å®¹æ–¥åŸç†](#13-å®¹æ–¥åŸç†)
  - [2. å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
    - [2.1 åŠ æ³•åŸç†å½¢å¼åŒ–](#21-åŠ æ³•åŸç†å½¢å¼åŒ–)
    - [2.2 ä¹˜æ³•åŸç†å½¢å¼åŒ–](#22-ä¹˜æ³•åŸç†å½¢å¼åŒ–)
    - [2.3 å®¹æ–¥åŸç†å½¢å¼åŒ–](#23-å®¹æ–¥åŸç†å½¢å¼åŒ–)
    - [2.4 é¸½å·¢åŸç†](#24-é¸½å·¢åŸç†)
  - [3. å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
    - [3.1 åŠ æ³•åŸç†çš„æ¨å¹¿](#31-åŠ æ³•åŸç†çš„æ¨å¹¿)
    - [3.2 ä¹˜æ³•åŸç†çš„æ¨å¹¿](#32-ä¹˜æ³•åŸç†çš„æ¨å¹¿)
    - [3.3 å®¹æ–¥åŸç†çš„è¯æ˜](#33-å®¹æ–¥åŸç†çš„è¯æ˜)
    - [3.4 é¸½å·¢åŸç†çš„æ¨å¹¿](#34-é¸½å·¢åŸç†çš„æ¨å¹¿)
  - [4. ä»£ç å®ç°](#4-ä»£ç å®ç°)
    - [4.1 Rustå®ç°](#41-rustå®ç°)
    - [4.2 Haskellå®ç°](#42-haskellå®ç°)
  - [5. åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
    - [5.1 å¯†ç å­¦åº”ç”¨](#51-å¯†ç å­¦åº”ç”¨)
    - [5.2 ç»„åˆä¼˜åŒ–åº”ç”¨](#52-ç»„åˆä¼˜åŒ–åº”ç”¨)
  - [6. ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
    - [6.1 ä¸æ’åˆ—ç»„åˆçš„å…³ç³»](#61-ä¸æ’åˆ—ç»„åˆçš„å…³ç³»)
    - [6.2 ä¸æ¦‚ç‡è®ºçš„å…³ç³»](#62-ä¸æ¦‚ç‡è®ºçš„å…³ç³»)
    - [6.3 ä¸å›¾è®ºçš„å…³ç³»](#63-ä¸å›¾è®ºçš„å…³ç³»)
    - [6.4 ä¸ä»£æ•°ç»„åˆçš„å…³ç³»](#64-ä¸ä»£æ•°ç»„åˆçš„å…³ç³»)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 åŠ æ³•åŸç†

å¦‚æœäº‹ä»¶ $A$ æœ‰ $m$ ç§æ–¹å¼å‘ç”Ÿï¼Œäº‹ä»¶ $B$ æœ‰ $n$ ç§æ–¹å¼å‘ç”Ÿï¼Œä¸” $A$ å’Œ $B$ ä¸èƒ½åŒæ—¶å‘ç”Ÿï¼Œé‚£ä¹ˆ $A$ æˆ– $B$ å‘ç”Ÿçš„æ€»æ–¹å¼æ•°ä¸º $m + n$ã€‚

### 1.2 ä¹˜æ³•åŸç†

å¦‚æœäº‹ä»¶ $A$ æœ‰ $m$ ç§æ–¹å¼å‘ç”Ÿï¼Œäº‹ä»¶ $B$ æœ‰ $n$ ç§æ–¹å¼å‘ç”Ÿï¼Œä¸” $A$ å’Œ $B$ æ˜¯ç‹¬ç«‹çš„ï¼Œé‚£ä¹ˆ $A$ å’Œ $B$ åŒæ—¶å‘ç”Ÿçš„æ€»æ–¹å¼æ•°ä¸º $m \times n$ã€‚

### 1.3 å®¹æ–¥åŸç†

å¯¹äºæœ‰é™é›†åˆ $A_1, A_2, \ldots, A_n$ï¼Œæœ‰ï¼š

$$|A_1 \cup A_2 \cup \cdots \cup A_n| = \sum_{i=1}^n |A_i| - \sum_{1 \leq i < j \leq n} |A_i \cap A_j| + \sum_{1 \leq i < j < k \leq n} |A_i \cap A_j \cap A_k| - \cdots + (-1)^{n+1} |A_1 \cap A_2 \cap \cdots \cap A_n|$$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 åŠ æ³•åŸç†å½¢å¼åŒ–

è®¾ $A$ å’Œ $B$ ä¸ºäº’æ–¥çš„æœ‰é™é›†åˆï¼Œåˆ™ï¼š

$$|A \cup B| = |A| + |B|$$

### 2.2 ä¹˜æ³•åŸç†å½¢å¼åŒ–

è®¾ $A$ å’Œ $B$ ä¸ºæœ‰é™é›†åˆï¼Œåˆ™ç¬›å¡å°”ç§¯çš„åŸºæ•°ä¸ºï¼š

$$|A \times B| = |A| \times |B|$$

### 2.3 å®¹æ–¥åŸç†å½¢å¼åŒ–

å¯¹äºæœ‰é™é›†åˆ $A_1, A_2, \ldots, A_n$ï¼Œå®šä¹‰ï¼š

$$|A_1 \cup A_2 \cup \cdots \cup A_n| = \sum_{k=1}^n (-1)^{k+1} \sum_{1 \leq i_1 < i_2 < \cdots < i_k \leq n} |A_{i_1} \cap A_{i_2} \cap \cdots \cap A_{i_k}|$$

### 2.4 é¸½å·¢åŸç†

å¦‚æœ $n$ ä¸ªç‰©ä½“æ”¾å…¥ $m$ ä¸ªç›’å­ä¸­ï¼Œä¸” $n > m$ï¼Œé‚£ä¹ˆè‡³å°‘æœ‰ä¸€ä¸ªç›’å­åŒ…å«è‡³å°‘ $\lceil \frac{n}{m} \rceil$ ä¸ªç‰©ä½“ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŠ æ³•åŸç†çš„æ¨å¹¿

**å®šç† 3.1.1**ï¼šè®¾ $A_1, A_2, \ldots, A_n$ ä¸ºä¸¤ä¸¤äº’æ–¥çš„æœ‰é™é›†åˆï¼Œåˆ™ï¼š

$$|A_1 \cup A_2 \cup \cdots \cup A_n| = \sum_{i=1}^n |A_i|$$

**è¯æ˜**ï¼š
ä½¿ç”¨æ•°å­¦å½’çº³æ³•ï¼š

- åŸºç¡€æƒ…å†µï¼š$n = 2$ æ—¶ï¼Œç”±åŠ æ³•åŸç†ç›´æ¥æˆç«‹
- å½’çº³å‡è®¾ï¼šå‡è®¾å¯¹äº $n = k$ æˆç«‹
- å½’çº³æ­¥éª¤ï¼šå¯¹äº $n = k + 1$ï¼Œ
  $$|A_1 \cup A_2 \cup \cdots \cup A_k \cup A_{k+1}| = |(A_1 \cup A_2 \cup \cdots \cup A_k) \cup A_{k+1}|$$
  ç”±äº $A_{k+1}$ ä¸ $A_1, A_2, \ldots, A_k$ éƒ½äº’æ–¥ï¼Œç”±åŠ æ³•åŸç†å’Œå½’çº³å‡è®¾ï¼š
  $$= |A_1 \cup A_2 \cup \cdots \cup A_k| + |A_{k+1}| = \sum_{i=1}^k |A_i| + |A_{k+1}| = \sum_{i=1}^{k+1} |A_i|$$

### 3.2 ä¹˜æ³•åŸç†çš„æ¨å¹¿

**å®šç† 3.2.1**ï¼šè®¾ $A_1, A_2, \ldots, A_n$ ä¸ºæœ‰é™é›†åˆï¼Œåˆ™ï¼š

$$|A_1 \times A_2 \times \cdots \times A_n| = \prod_{i=1}^n |A_i|$$

**è¯æ˜**ï¼š
ä½¿ç”¨æ•°å­¦å½’çº³æ³•ï¼š

- åŸºç¡€æƒ…å†µï¼š$n = 2$ æ—¶ï¼Œç”±ä¹˜æ³•åŸç†ç›´æ¥æˆç«‹
- å½’çº³å‡è®¾ï¼šå‡è®¾å¯¹äº $n = k$ æˆç«‹
- å½’çº³æ­¥éª¤ï¼šå¯¹äº $n = k + 1$ï¼Œ
  $$|A_1 \times A_2 \times \cdots \times A_k \times A_{k+1}| = |(A_1 \times A_2 \times \cdots \times A_k) \times A_{k+1}|$$
  ç”±ä¹˜æ³•åŸç†å’Œå½’çº³å‡è®¾ï¼š
  $$= |A_1 \times A_2 \times \cdots \times A_k| \times |A_{k+1}| = \prod_{i=1}^k |A_i| \times |A_{k+1}| = \prod_{i=1}^{k+1} |A_i|$$

### 3.3 å®¹æ–¥åŸç†çš„è¯æ˜

**å®šç† 3.3.1** (å®¹æ–¥åŸç†)ï¼šå¯¹äºæœ‰é™é›†åˆ $A_1, A_2, \ldots, A_n$ï¼Œæœ‰ï¼š

$$|A_1 \cup A_2 \cup \cdots \cup A_n| = \sum_{k=1}^n (-1)^{k+1} \sum_{1 \leq i_1 < i_2 < \cdots < i_k \leq n} |A_{i_1} \cap A_{i_2} \cap \cdots \cap A_{i_k}|$$

**è¯æ˜**ï¼š
è€ƒè™‘ä»»æ„å…ƒç´  $x$ åœ¨å¹¶é›†ä¸­çš„è´¡çŒ®ã€‚è®¾ $x$ å±äº $m$ ä¸ªé›†åˆ $A_{j_1}, A_{j_2}, \ldots, A_{j_m}$ã€‚

åœ¨å³è¾¹ï¼Œ$x$ è¢«è®¡ç®—çš„æ¬¡æ•°ä¸ºï¼š

- åœ¨å•é‡äº¤é›†ä¸­ï¼š$m$ æ¬¡
- åœ¨åŒé‡äº¤é›†ä¸­ï¼š$\binom{m}{2}$ æ¬¡
- åœ¨ä¸‰é‡äº¤é›†ä¸­ï¼š$\binom{m}{3}$ æ¬¡
- ...
- åœ¨ $m$ é‡äº¤é›†ä¸­ï¼š$\binom{m}{m}$ æ¬¡

æ€»è´¡çŒ®ä¸ºï¼š
$$\sum_{k=1}^m (-1)^{k+1} \binom{m}{k} = 1 - \sum_{k=0}^m (-1)^k \binom{m}{k} = 1 - (1 - 1)^m = 1$$

å› æ­¤æ¯ä¸ªå…ƒç´ åœ¨å¹¶é›†ä¸­è¢«è®¡ç®—æ°å¥½ä¸€æ¬¡ã€‚

### 3.4 é¸½å·¢åŸç†çš„æ¨å¹¿

**å®šç† 3.4.1** (é¸½å·¢åŸç†)ï¼šå¦‚æœ $n$ ä¸ªç‰©ä½“æ”¾å…¥ $m$ ä¸ªç›’å­ä¸­ï¼Œä¸” $n > m$ï¼Œé‚£ä¹ˆè‡³å°‘æœ‰ä¸€ä¸ªç›’å­åŒ…å«è‡³å°‘ $\lceil \frac{n}{m} \rceil$ ä¸ªç‰©ä½“ã€‚

**è¯æ˜**ï¼š
åè¯æ³•ã€‚å‡è®¾æ¯ä¸ªç›’å­æœ€å¤šåŒ…å« $\lceil \frac{n}{m} \rceil - 1$ ä¸ªç‰©ä½“ã€‚

ç”±äº $\lceil \frac{n}{m} \rceil - 1 < \frac{n}{m}$ï¼Œæ‰€ä»¥ï¼š
$$n \leq m \left(\left\lceil \frac{n}{m} \right\rceil - 1\right) < m \cdot \frac{n}{m} = n$$

è¿™ä¸ $n > 0$ çŸ›ç›¾ï¼Œå› æ­¤å‡è®¾é”™è¯¯ã€‚

## 4. ä»£ç å®ç°

### 4.1 Rustå®ç°

```rust
use std::collections::HashSet;

/// è®¡æ•°åŸç†å®ç°
pub struct CountingPrinciples;

impl CountingPrinciples {
    /// åŠ æ³•åŸç†ï¼šè®¡ç®—äº’æ–¥é›†åˆçš„å¹¶é›†å¤§å°
    pub fn addition_principle(sets: &[HashSet<i32>]) -> usize {
        sets.iter().map(|set| set.len()).sum()
    }
    
    /// ä¹˜æ³•åŸç†ï¼šè®¡ç®—ç¬›å¡å°”ç§¯çš„å¤§å°
    pub fn multiplication_principle(sets: &[HashSet<i32>]) -> usize {
        sets.iter().map(|set| set.len()).product()
    }
    
    /// å®¹æ–¥åŸç†ï¼šè®¡ç®—é›†åˆå¹¶é›†çš„å¤§å°
    pub fn inclusion_exclusion_principle(sets: &[HashSet<i32>]) -> usize {
        let n = sets.len();
        let mut result = 0;
        
        // ç”Ÿæˆæ‰€æœ‰éç©ºå­é›†
        for mask in 1..(1 << n) {
            let mut intersection = sets[0].clone();
            let mut count = 0;
            
            for i in 0..n {
                if mask & (1 << i) != 0 {
                    intersection = intersection.intersection(&sets[i]).cloned().collect();
                    count += 1;
                }
            }
            
            if count % 2 == 1 {
                result += intersection.len();
            } else {
                result -= intersection.len();
            }
        }
        
        result
    }
    
    /// é¸½å·¢åŸç†ï¼šæ£€æŸ¥æ˜¯å¦å­˜åœ¨åŒ…å«è‡³å°‘æŒ‡å®šæ•°é‡å…ƒç´ çš„é›†åˆ
    pub fn pigeonhole_principle(items: &[i32], num_boxes: usize, min_items: usize) -> bool {
        if items.len() <= num_boxes {
            return false;
        }
        
        let mut boxes = vec![0; num_boxes];
        for &item in items {
            let box_index = (item as usize) % num_boxes;
            boxes[box_index] += 1;
        }
        
        boxes.iter().any(|&count| count >= min_items)
    }
    
    /// è®¡ç®—æ’åˆ—æ•° P(n, r)
    pub fn permutation(n: usize, r: usize) -> usize {
        if r > n {
            return 0;
        }
        
        let mut result = 1;
        for i in 0..r {
            result *= n - i;
        }
        result
    }
    
    /// è®¡ç®—ç»„åˆæ•° C(n, r)
    pub fn combination(n: usize, r: usize) -> usize {
        if r > n {
            return 0;
        }
        
        if r > n / 2 {
            return Self::combination(n, n - r);
        }
        
        let mut result = 1;
        for i in 0..r {
            result = result * (n - i) / (i + 1);
        }
        result
    }
    
    /// è®¡ç®—å¤šé‡é›†åˆçš„æ’åˆ—æ•°
    pub fn multiset_permutation(counts: &[usize]) -> usize {
        let total: usize = counts.iter().sum();
        let mut result = Self::factorial(total);
        
        for &count in counts {
            if count > 1 {
                result /= Self::factorial(count);
            }
        }
        
        result
    }
    
    /// è®¡ç®—é˜¶ä¹˜
    pub fn factorial(n: usize) -> usize {
        if n <= 1 {
            1
        } else {
            n * Self::factorial(n - 1)
        }
    }
    
    /// è®¡ç®—æ–¯ç‰¹æ—æ•° S(n, k)
    pub fn stirling_number_second_kind(n: usize, k: usize) -> usize {
        if k == 0 || k > n {
            return 0;
        }
        if k == 1 || k == n {
            return 1;
        }
        
        k * Self::stirling_number_second_kind(n - 1, k) + 
        Self::stirling_number_second_kind(n - 1, k - 1)
    }
    
    /// è®¡ç®—è´å°”æ•° B(n)
    pub fn bell_number(n: usize) -> usize {
        if n == 0 {
            return 1;
        }
        
        (0..n).map(|k| Self::combination(n - 1, k) * Self::bell_number(k)).sum()
    }
    
    /// è®¡ç®—å¡ç‰¹å…°æ•° C(n)
    pub fn catalan_number(n: usize) -> usize {
        if n <= 1 {
            return 1;
        }
        
        let mut result = 0;
        for i in 0..n {
            result += Self::catalan_number(i) * Self::catalan_number(n - 1 - i);
        }
        result
    }
    
    /// è®¡ç®—æ¬§æ‹‰æ•° E(n, k)
    pub fn euler_number(n: usize, k: usize) -> usize {
        if k == 0 {
            return 1;
        }
        if k >= n {
            return 0;
        }
        
        (k + 1) * Self::euler_number(n - 1, k) + 
        (n - k) * Self::euler_number(n - 1, k - 1)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashSet;
    
    #[test]
    fn test_addition_principle() {
        let set1: HashSet<i32> = [1, 2, 3].iter().cloned().collect();
        let set2: HashSet<i32> = [4, 5, 6].iter().cloned().collect();
        let set3: HashSet<i32> = [7, 8].iter().cloned().collect();
        
        let result = CountingPrinciples::addition_principle(&[set1, set2, set3]);
        assert_eq!(result, 8);
    }
    
    #[test]
    fn test_multiplication_principle() {
        let set1: HashSet<i32> = [1, 2].iter().cloned().collect();
        let set2: HashSet<i32> = [3, 4, 5].iter().cloned().collect();
        
        let result = CountingPrinciples::multiplication_principle(&[set1, set2]);
        assert_eq!(result, 6);
    }
    
    #[test]
    fn test_inclusion_exclusion_principle() {
        let set1: HashSet<i32> = [1, 2, 3, 4].iter().cloned().collect();
        let set2: HashSet<i32> = [3, 4, 5, 6].iter().cloned().collect();
        let set3: HashSet<i32> = [4, 5, 7, 8].iter().cloned().collect();
        
        let result = CountingPrinciples::inclusion_exclusion_principle(&[set1, set2, set3]);
        assert_eq!(result, 8);
    }
    
    #[test]
    fn test_pigeonhole_principle() {
        let items = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let result = CountingPrinciples::pigeonhole_principle(&items, 3, 4);
        assert!(result);
    }
    
    #[test]
    fn test_permutation() {
        assert_eq!(CountingPrinciples::permutation(5, 3), 60);
        assert_eq!(CountingPrinciples::permutation(4, 4), 24);
        assert_eq!(CountingPrinciples::permutation(3, 5), 0);
    }
    
    #[test]
    fn test_combination() {
        assert_eq!(CountingPrinciples::combination(5, 3), 10);
        assert_eq!(CountingPrinciples::combination(4, 2), 6);
        assert_eq!(CountingPrinciples::combination(3, 5), 0);
    }
    
    #[test]
    fn test_multiset_permutation() {
        let counts = vec![2, 1, 3]; // 2ä¸ªAï¼Œ1ä¸ªBï¼Œ3ä¸ªC
        let result = CountingPrinciples::multiset_permutation(&counts);
        assert_eq!(result, 60); // 6! / (2! * 1! * 3!) = 720 / 12 = 60
    }
    
    #[test]
    fn test_stirling_number() {
        assert_eq!(CountingPrinciples::stirling_number_second_kind(4, 2), 7);
        assert_eq!(CountingPrinciples::stirling_number_second_kind(5, 3), 25);
    }
    
    #[test]
    fn test_bell_number() {
        assert_eq!(CountingPrinciples::bell_number(0), 1);
        assert_eq!(CountingPrinciples::bell_number(1), 1);
        assert_eq!(CountingPrinciples::bell_number(2), 2);
        assert_eq!(CountingPrinciples::bell_number(3), 5);
        assert_eq!(CountingPrinciples::bell_number(4), 15);
    }
    
    #[test]
    fn test_catalan_number() {
        assert_eq!(CountingPrinciples::catalan_number(0), 1);
        assert_eq!(CountingPrinciples::catalan_number(1), 1);
        assert_eq!(CountingPrinciples::catalan_number(2), 2);
        assert_eq!(CountingPrinciples::catalan_number(3), 5);
        assert_eq!(CountingPrinciples::catalan_number(4), 14);
    }
    
    #[test]
    fn test_euler_number() {
        assert_eq!(CountingPrinciples::euler_number(4, 1), 11);
        assert_eq!(CountingPrinciples::euler_number(4, 2), 11);
        assert_eq!(CountingPrinciples::euler_number(5, 2), 66);
    }
}
```

### 4.2 Haskellå®ç°

```haskell
module CountingPrinciples where

import Data.List (subsequences, permutations)
import Data.Set (Set, fromList, intersection, size, unions)

-- è®¡æ•°åŸç†å®ç°
class CountingPrinciples a where
    additionPrinciple :: [Set a] -> Int
    multiplicationPrinciple :: [Set a] -> Int
    inclusionExclusionPrinciple :: [Set a] -> Int
    pigeonholePrinciple :: [a] -> Int -> Int -> Bool
    permutation :: Int -> Int -> Int
    combination :: Int -> Int -> Int
    multisetPermutation :: [Int] -> Int
    factorial :: Int -> Int
    stirlingNumberSecondKind :: Int -> Int -> Int
    bellNumber :: Int -> Int
    catalanNumber :: Int -> Int
    eulerNumber :: Int -> Int -> Int

instance CountingPrinciples Int where
    -- åŠ æ³•åŸç†
    additionPrinciple sets = sum $ map size sets
    
    -- ä¹˜æ³•åŸç†
    multiplicationPrinciple sets = product $ map size sets
    
    -- å®¹æ–¥åŸç†
    inclusionExclusionPrinciple sets = inclusionExclusionHelper sets 1
        where
            inclusionExclusionHelper [] _ = 0
            inclusionExclusionHelper sets sign = 
                sum [sign * size (foldr1 intersection subset) | 
                     subset <- subsequences sets, 
                     not (null subset)] +
                inclusionExclusionHelper (tail sets) (-sign)
    
    -- é¸½å·¢åŸç†
    pigeonholePrinciple items numBoxes minItems
        | length items <= numBoxes = False
        | otherwise = any (>= minItems) boxCounts
        where
            boxCounts = map length $ groupBy (\x y -> x `mod` numBoxes == y `mod` numBoxes) items
    
    -- æ’åˆ—æ•°
    permutation n r
        | r > n = 0
        | otherwise = factorial n `div` factorial (n - r)
    
    -- ç»„åˆæ•°
    combination n r
        | r > n = 0
        | r > n `div` 2 = combination n (n - r)
        | otherwise = factorial n `div` (factorial r * factorial (n - r))
    
    -- å¤šé‡é›†åˆæ’åˆ—æ•°
    multisetPermutation counts = 
        factorial total `div` product (map factorial counts)
        where total = sum counts
    
    -- é˜¶ä¹˜
    factorial n
        | n <= 1 = 1
        | otherwise = n * factorial (n - 1)
    
    -- æ–¯ç‰¹æ—æ•°ç¬¬äºŒç±»
    stirlingNumberSecondKind n k
        | k == 0 || k > n = 0
        | k == 1 || k == n = 1
        | otherwise = k * stirlingNumberSecondKind (n - 1) k + 
                     stirlingNumberSecondKind (n - 1) (k - 1)
    
    -- è´å°”æ•°
    bellNumber n
        | n == 0 = 1
        | otherwise = sum [combination (n - 1) k * bellNumber k | k <- [0..n-1]]
    
    -- å¡ç‰¹å…°æ•°
    catalanNumber n
        | n <= 1 = 1
        | otherwise = sum [catalanNumber i * catalanNumber (n - 1 - i) | i <- [0..n-1]]
    
    -- æ¬§æ‹‰æ•°
    eulerNumber n k
        | k == 0 = 1
        | k >= n = 0
        | otherwise = (k + 1) * eulerNumber (n - 1) k + 
                     (n - k) * eulerNumber (n - 1) (k - 1)

-- è¾…åŠ©å‡½æ•°
groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
groupBy _ [] = []
groupBy _ [x] = [[x]]
groupBy eq (x:y:xs)
    | eq x y = (x : head groups) : tail groups
    | otherwise = [x] : groups
    where groups = groupBy eq (y:xs)

-- æµ‹è¯•å‡½æ•°
testCountingPrinciples :: IO ()
testCountingPrinciples = do
    putStrLn "Testing Counting Principles..."
    
    -- æµ‹è¯•åŠ æ³•åŸç†
    let set1 = fromList [1, 2, 3]
    let set2 = fromList [4, 5, 6]
    let set3 = fromList [7, 8]
    putStrLn $ "Addition principle: " ++ show (additionPrinciple [set1, set2, set3])
    
    -- æµ‹è¯•ä¹˜æ³•åŸç†
    putStrLn $ "Multiplication principle: " ++ show (multiplicationPrinciple [set1, set2])
    
    -- æµ‹è¯•æ’åˆ—æ•°
    putStrLn $ "P(5,3): " ++ show (permutation 5 3)
    putStrLn $ "P(4,4): " ++ show (permutation 4 4)
    
    -- æµ‹è¯•ç»„åˆæ•°
    putStrLn $ "C(5,3): " ++ show (combination 5 3)
    putStrLn $ "C(4,2): " ++ show (combination 4 2)
    
    -- æµ‹è¯•å¤šé‡é›†åˆæ’åˆ—æ•°
    putStrLn $ "Multiset permutation [2,1,3]: " ++ show (multisetPermutation [2,1,3])
    
    -- æµ‹è¯•æ–¯ç‰¹æ—æ•°
    putStrLn $ "S(4,2): " ++ show (stirlingNumberSecondKind 4 2)
    putStrLn $ "S(5,3): " ++ show (stirlingNumberSecondKind 5 3)
    
    -- æµ‹è¯•è´å°”æ•°
    putStrLn $ "B(0): " ++ show (bellNumber 0)
    putStrLn $ "B(1): " ++ show (bellNumber 1)
    putStrLn $ "B(2): " ++ show (bellNumber 2)
    putStrLn $ "B(3): " ++ show (bellNumber 3)
    putStrLn $ "B(4): " ++ show (bellNumber 4)
    
    -- æµ‹è¯•å¡ç‰¹å…°æ•°
    putStrLn $ "C(0): " ++ show (catalanNumber 0)
    putStrLn $ "C(1): " ++ show (catalanNumber 1)
    putStrLn $ "C(2): " ++ show (catalanNumber 2)
    putStrLn $ "C(3): " ++ show (catalanNumber 3)
    putStrLn $ "C(4): " ++ show (catalanNumber 4)
    
    -- æµ‹è¯•æ¬§æ‹‰æ•°
    putStrLn $ "E(4,1): " ++ show (eulerNumber 4 1)
    putStrLn $ "E(4,2): " ++ show (eulerNumber 4 2)
    putStrLn $ "E(5,2): " ++ show (eulerNumber 5 2)
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å¯†ç å­¦åº”ç”¨

è®¡æ•°åŸç†åœ¨å¯†ç å­¦ä¸­çš„åº”ç”¨ï¼š

```rust
use rand::Rng;

pub struct PasswordGenerator {
    charset: Vec<char>,
    length: usize,
}

impl PasswordGenerator {
    pub fn new(charset: Vec<char>, length: usize) -> Self {
        PasswordGenerator { charset, length }
    }
    
    /// è®¡ç®—å¯†ç ç©ºé—´å¤§å°
    pub fn password_space_size(&self) -> usize {
        CountingPrinciples::multiplication_principle(&vec![
            (0..self.charset.len()).collect()
        ].repeat(self.length))
    }
    
    /// ç”Ÿæˆéšæœºå¯†ç 
    pub fn generate_password(&self) -> String {
        let mut rng = rand::thread_rng();
        let mut password = String::new();
        
        for _ in 0..self.length {
            let index = rng.gen_range(0..self.charset.len());
            password.push(self.charset[index]);
        }
        
        password
    }
    
    /// è®¡ç®—å¯†ç å¼ºåº¦
    pub fn password_strength(&self) -> f64 {
        let space_size = self.password_space_size() as f64;
        space_size.log2()
    }
}

pub struct HashCollisionAnalyzer;

impl HashCollisionAnalyzer {
    /// ä½¿ç”¨é¸½å·¢åŸç†åˆ†æå“ˆå¸Œç¢°æ’
    pub fn analyze_collision_probability(hash_bits: usize, num_items: usize) -> f64 {
        let hash_space = 1 << hash_bits;
        
        if num_items > hash_space {
            return 1.0; // å¿…ç„¶æœ‰ç¢°æ’
        }
        
        // ä½¿ç”¨ç”Ÿæ—¥æ‚–è®ºè®¡ç®—ç¢°æ’æ¦‚ç‡
        let mut probability = 1.0;
        for i in 0..num_items {
            probability *= (hash_space - i) as f64 / hash_space as f64;
        }
        
        1.0 - probability
    }
    
    /// è®¡ç®—ç”Ÿæ—¥æ‚–è®ºä¸­çš„ä¸´ç•Œå€¼
    pub fn birthday_paradox_threshold(hash_bits: usize) -> usize {
        let hash_space = 1 << hash_bits;
        ((2.0 * hash_space as f64).sqrt() * 1.177) as usize
    }
}
```

### 5.2 ç»„åˆä¼˜åŒ–åº”ç”¨

```rust
pub struct CombinatorialOptimizer;

impl CombinatorialOptimizer {
    /// è®¡ç®—å­é›†å’Œé—®é¢˜çš„è§£çš„æ•°é‡
    pub fn subset_sum_count(numbers: &[i32], target: i32) -> usize {
        let n = numbers.len();
        let mut count = 0;
        
        // ä½¿ç”¨ä½æ©ç ç”Ÿæˆæ‰€æœ‰å­é›†
        for mask in 0..(1 << n) {
            let mut sum = 0;
            for i in 0..n {
                if mask & (1 << i) != 0 {
                    sum += numbers[i];
                }
            }
            if sum == target {
                count += 1;
            }
        }
        
        count
    }
    
    /// è®¡ç®—æ’åˆ—çš„é€†åºæ•°
    pub fn inversion_count(permutation: &[usize]) -> usize {
        let mut count = 0;
        let n = permutation.len();
        
        for i in 0..n {
            for j in i + 1..n {
                if permutation[i] > permutation[j] {
                    count += 1;
                }
            }
        }
        
        count
    }
    
    /// è®¡ç®—æ’åˆ—çš„å¾ªç¯æ•°
    pub fn cycle_count(permutation: &[usize]) -> usize {
        let n = permutation.len();
        let mut visited = vec![false; n];
        let mut cycles = 0;
        
        for i in 0..n {
            if !visited[i] {
                cycles += 1;
                let mut current = i;
                while !visited[current] {
                    visited[current] = true;
                    current = permutation[current];
                }
            }
        }
        
        cycles
    }
    
    /// è®¡ç®—æ’åˆ—çš„ç¬¦å·
    pub fn permutation_sign(permutation: &[usize]) -> i32 {
        let inversions = Self::inversion_count(permutation);
        if inversions % 2 == 0 { 1 } else { -1 }
    }
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸æ’åˆ—ç»„åˆçš„å…³ç³»

è®¡æ•°åŸç†æ˜¯æ’åˆ—ç»„åˆç†è®ºçš„åŸºç¡€ï¼Œä¸ºè®¡ç®—æ’åˆ—æ•°å’Œç»„åˆæ•°æä¾›åŸºæœ¬æ–¹æ³•ã€‚

### 6.2 ä¸æ¦‚ç‡è®ºçš„å…³ç³»

è®¡æ•°åŸç†åœ¨æ¦‚ç‡è®ºä¸­ç”¨äºè®¡ç®—æ ·æœ¬ç©ºé—´çš„å¤§å°å’Œäº‹ä»¶å‘ç”Ÿçš„å¯èƒ½æ€§ã€‚

### 6.3 ä¸å›¾è®ºçš„å…³ç³»

è®¡æ•°åŸç†åœ¨å›¾è®ºä¸­ç”¨äºè®¡ç®—è·¯å¾„æ•°é‡ã€åŒ¹é…æ•°é‡ç­‰ç»„åˆé—®é¢˜ã€‚

### 6.4 ä¸ä»£æ•°ç»„åˆçš„å…³ç³»

è®¡æ•°åŸç†åœ¨ä»£æ•°ç»„åˆä¸­ç”¨äºç ”ç©¶ç”Ÿæˆå‡½æ•°å’Œç»„åˆæ’ç­‰å¼ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Brualdi, R. A. (2010). Introductory Combinatorics. Pearson.
2. Stanley, R. P. (2011). Enumerative Combinatorics. Cambridge University Press.
3. Graham, R. L., Knuth, D. E., & Patashnik, O. (1994). Concrete Mathematics. Addison-Wesley.
4. Aigner, M. (2007). A Course in Enumeration. Springer.
5. Wilf, H. S. (2006). Generatingfunctionology. A K Peters.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [02.11.2 æ’åˆ—ç»„åˆ](../02.11.2_æ’åˆ—ç»„åˆ.md)
- [02.11.3 ç”Ÿæˆå‡½æ•°](../02.11.3_ç”Ÿæˆå‡½æ•°.md)
- [02.11.4 å›¾è®ºåŸºç¡€](../02.11.4_å›¾è®ºåŸºç¡€.md)
- [02.10.1 æ•´é™¤ç†è®º](../02.10.1_æ•´é™¤ç†è®º.md)

## æ‰¹åˆ¤æ€§åˆ†æ

### å¤šå…ƒç†è®ºè§†è§’

**ç»„åˆæ•°å­¦è§†è§’**ï¼šè®¡æ•°åŸç†æ˜¯ç»„åˆæ•°å­¦çš„åŸºç¡€ï¼Œæä¾›äº†ç³»ç»ŸåŒ–çš„è®¡æ•°æ–¹æ³•ï¼Œä½†å¯èƒ½è¿‡äºæŠ½è±¡è€Œå¿½è§†å…·ä½“é—®é¢˜çš„ç‰¹æ®Šæ€§ã€‚

**ç®—æ³•è§†è§’**ï¼šä»ç®—æ³•è§’åº¦çœ‹ï¼Œè®¡æ•°åŸç†ä¸ºè®¾è®¡é«˜æ•ˆç®—æ³•æä¾›äº†ç†è®ºåŸºç¡€ï¼Œä½†æŸäº›è®¡æ•°é—®é¢˜çš„è®¡ç®—å¤æ‚åº¦ä»ç„¶å¾ˆé«˜ã€‚

**åº”ç”¨è§†è§’**ï¼šè®¡æ•°åŸç†åœ¨å¤šä¸ªé¢†åŸŸæœ‰å¹¿æ³›åº”ç”¨ï¼Œä½†ä¸åŒé¢†åŸŸçš„è®¡æ•°éœ€æ±‚å¯èƒ½ä¸åŒï¼Œéœ€è¦é’ˆå¯¹æ€§çš„æ–¹æ³•ã€‚

### å±€é™æ€§åˆ†æ

**è®¡ç®—å¤æ‚æ€§**ï¼šæŸäº›è®¡æ•°é—®é¢˜çš„è®¡ç®—å¤æ‚åº¦å¾ˆé«˜ï¼Œç‰¹åˆ«æ˜¯å½“é—®é¢˜è§„æ¨¡è¾ƒå¤§æ—¶ï¼Œå¯èƒ½æ— æ³•åœ¨åˆç†æ—¶é—´å†…å¾—åˆ°ç»“æœã€‚

**æŠ½è±¡æ€§**ï¼šè®¡æ•°åŸç†çš„æŠ½è±¡æ€§å¯èƒ½ä½¿å…¶éš¾ä»¥ç›´æ¥åº”ç”¨äºå…·ä½“çš„å®é™…é—®é¢˜ï¼Œéœ€è¦é¢å¤–çš„å»ºæ¨¡å·¥ä½œã€‚

**çº¦æŸå¤„ç†**ï¼šå½“å­˜åœ¨å¤æ‚çº¦æŸæ—¶ï¼Œè®¡æ•°åŸç†çš„åº”ç”¨å¯èƒ½å˜å¾—å›°éš¾ï¼Œéœ€è¦æ›´é«˜çº§çš„ç»„åˆæŠ€æœ¯ã€‚

### äº‰è®®ä¸åˆ†æ­§

**ç²¾ç¡®vsè¿‘ä¼¼**ï¼šå¯¹äºå¤§è§„æ¨¡è®¡æ•°é—®é¢˜ï¼Œæ˜¯å¦åº”è¯¥è¿½æ±‚ç²¾ç¡®è§£è¿˜æ˜¯è¿‘ä¼¼è§£å­˜åœ¨äº‰è®®ã€‚

**ç†è®ºvså®ç”¨**ï¼šæŸäº›è®¡æ•°ç†è®ºåœ¨ç†è®ºä¸Šå®Œç¾ï¼Œä½†åœ¨å®é™…åº”ç”¨ä¸­å¯èƒ½è¿‡äºå¤æ‚ã€‚

**é€šç”¨vsä¸“ç”¨**ï¼šæ˜¯å¦åº”è¯¥å‘å±•é€šç”¨çš„è®¡æ•°æ–¹æ³•è¿˜æ˜¯é’ˆå¯¹ç‰¹å®šé—®é¢˜çš„ä¸“ç”¨æ–¹æ³•å­˜åœ¨åˆ†æ­§ã€‚

### åº”ç”¨å‰æ™¯

**è®¡ç®—æœºç§‘å­¦**ï¼šåœ¨ç®—æ³•åˆ†æã€æ•°æ®ç»“æ„è®¾è®¡ã€ç½‘ç»œåˆ†æç­‰é¢†åŸŸæœ‰é‡è¦åº”ç”¨ã€‚

**ç»Ÿè®¡å­¦**ï¼šåœ¨æ ·æœ¬è®¾è®¡ã€å®éªŒè®¾è®¡ã€æ•°æ®åˆ†æç­‰æ–¹é¢å‘æŒ¥é‡è¦ä½œç”¨ã€‚

**ç”Ÿç‰©ä¿¡æ¯å­¦**ï¼šåœ¨åºåˆ—åˆ†æã€è›‹ç™½è´¨ç»“æ„åˆ†æã€åŸºå› ç½‘ç»œåˆ†æç­‰ä¸­æœ‰åº”ç”¨å‰æ™¯ã€‚

### æ”¹è¿›å»ºè®®

**ç®—æ³•ä¼˜åŒ–**ï¼šå¼€å‘æ›´é«˜æ•ˆçš„è®¡æ•°ç®—æ³•ï¼Œç‰¹åˆ«æ˜¯é’ˆå¯¹å¤§è§„æ¨¡é—®é¢˜çš„è¿‘ä¼¼ç®—æ³•ã€‚

**å·¥å…·å¼€å‘**ï¼šå¼€å‘æ›´å¤šå®ç”¨çš„è®¡æ•°å·¥å…·å’Œè½¯ä»¶ï¼Œé™ä½è®¡æ•°åŸç†çš„åº”ç”¨é—¨æ§›ã€‚

**è·¨å­¦ç§‘åº”ç”¨**ï¼šæ¢ç´¢è®¡æ•°åŸç†åœ¨æ–°å…´é¢†åŸŸä¸­çš„åº”ç”¨ï¼Œå¦‚äººå·¥æ™ºèƒ½ã€é‡å­è®¡ç®—ç­‰ã€‚

**æ•™è‚²æ”¹è¿›**ï¼šæ”¹è¿›è®¡æ•°åŸç†çš„æ•™å­¦æ–¹æ³•ï¼Œä½¿å…¶æ›´å®¹æ˜“ç†è§£å’Œåº”ç”¨ã€‚
