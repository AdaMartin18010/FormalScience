# 02.11.3 ç”Ÿæˆå‡½æ•°ç†è®º

## ğŸ“‹ æ¦‚è¿°

ç”Ÿæˆå‡½æ•°ç†è®ºæ˜¯ç»„åˆæ•°å­¦çš„æ ¸å¿ƒå·¥å…·ï¼Œé€šè¿‡å°†åºåˆ—è½¬æ¢ä¸ºå½¢å¼å¹‚çº§æ•°æ¥ç ”ç©¶ç»„åˆé—®é¢˜ã€‚æœ¬ç†è®ºä¸ºè®¡æ•°é—®é¢˜ã€é€’æ¨å…³ç³»ã€æ¦‚ç‡åˆ†å¸ƒç­‰æä¾›ç»Ÿä¸€çš„åˆ†ææ¡†æ¶ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ç”Ÿæˆå‡½æ•°çš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. è¯æ˜åŸºæœ¬è¿ç®—å’Œå˜æ¢æ€§è´¨
3. æä¾›é«˜æ•ˆçš„ç®—æ³•å®ç°
4. å±•ç¤ºåœ¨ç»„åˆé—®é¢˜ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

- [02.11.3 ç”Ÿæˆå‡½æ•°ç†è®º](#02113-ç”Ÿæˆå‡½æ•°ç†è®º)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒç›®æ ‡](#-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 æ™®é€šç”Ÿæˆå‡½æ•°](#11-æ™®é€šç”Ÿæˆå‡½æ•°)
    - [1.2 æŒ‡æ•°ç”Ÿæˆå‡½æ•°](#12-æŒ‡æ•°ç”Ÿæˆå‡½æ•°)
    - [1.3 æ”¶æ•›æ€§](#13-æ”¶æ•›æ€§)
  - [2. å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
    - [2.1 ç”Ÿæˆå‡½æ•°ç©ºé—´](#21-ç”Ÿæˆå‡½æ•°ç©ºé—´)
    - [2.2 è¿ç®—å®šä¹‰](#22-è¿ç®—å®šä¹‰)
    - [2.3 å¤åˆè¿ç®—](#23-å¤åˆè¿ç®—)
  - [3. å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
    - [3.1 åŸºæœ¬è¿ç®—æ€§è´¨](#31-åŸºæœ¬è¿ç®—æ€§è´¨)
    - [3.2 å·ç§¯å®šç†](#32-å·ç§¯å®šç†)
    - [3.3 æŒ‡æ•°ç”Ÿæˆå‡½æ•°æ€§è´¨](#33-æŒ‡æ•°ç”Ÿæˆå‡½æ•°æ€§è´¨)
    - [3.4 æœ‰ç†ç”Ÿæˆå‡½æ•°](#34-æœ‰ç†ç”Ÿæˆå‡½æ•°)
  - [4. ç®—æ³•å®ç°](#4-ç®—æ³•å®ç°)
    - [4.1 Rust å®ç°](#41-rust-å®ç°)
    - [4.2 Haskell å®ç°](#42-haskell-å®ç°)
  - [5. åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
    - [5.1 ç»„åˆè®¡æ•°åº”ç”¨](#51-ç»„åˆè®¡æ•°åº”ç”¨)
    - [5.2 é€’æ¨å…³ç³»åº”ç”¨](#52-é€’æ¨å…³ç³»åº”ç”¨)
    - [5.3 æ¦‚ç‡è®ºåº”ç”¨](#53-æ¦‚ç‡è®ºåº”ç”¨)
    - [5.4 å›¾è®ºåº”ç”¨](#54-å›¾è®ºåº”ç”¨)
  - [6. ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
    - [6.1 æ’åˆ—ç»„åˆç†è®º](#61-æ’åˆ—ç»„åˆç†è®º)
    - [6.2 å›¾è®ºåŸºç¡€](#62-å›¾è®ºåŸºç¡€)
    - [6.3 å¤åˆ†æ](#63-å¤åˆ†æ)
    - [6.4 æ¦‚ç‡è®º](#64-æ¦‚ç‡è®º)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ™®é€šç”Ÿæˆå‡½æ•°

**å®šä¹‰ 1.1.1** (æ™®é€šç”Ÿæˆå‡½æ•°)
è®¾åºåˆ— $\{a_n\}_{n=0}^{\infty}$ï¼Œå…¶æ™®é€šç”Ÿæˆå‡½æ•°å®šä¹‰ä¸ºï¼š
$$A(x) = \sum_{n=0}^{\infty} a_n x^n$$

### 1.2 æŒ‡æ•°ç”Ÿæˆå‡½æ•°

**å®šä¹‰ 1.1.2** (æŒ‡æ•°ç”Ÿæˆå‡½æ•°)
è®¾åºåˆ— $\{a_n\}_{n=0}^{\infty}$ï¼Œå…¶æŒ‡æ•°ç”Ÿæˆå‡½æ•°å®šä¹‰ä¸ºï¼š
$$A(x) = \sum_{n=0}^{\infty} a_n \frac{x^n}{n!}$$

### 1.3 æ”¶æ•›æ€§

**å®šä¹‰ 1.1.3** (æ”¶æ•›åŠå¾„)
ç”Ÿæˆå‡½æ•° $A(x) = \sum_{n=0}^{\infty} a_n x^n$ çš„æ”¶æ•›åŠå¾„ä¸ºï¼š
$$R = \frac{1}{\limsup_{n \to \infty} \sqrt[n]{|a_n|}}$$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ç”Ÿæˆå‡½æ•°ç©ºé—´

**å®šä¹‰ 2.1.1** (å½¢å¼å¹‚çº§æ•°ç¯)
è®¾ $\mathbb{F}$ ä¸ºåŸŸï¼Œå½¢å¼å¹‚çº§æ•°ç¯ $\mathbb{F}[[x]]$ å®šä¹‰ä¸ºï¼š
$$\mathbb{F}[[x]] = \left\{\sum_{n=0}^{\infty} a_n x^n : a_n \in \mathbb{F}\right\}$$

### 2.2 è¿ç®—å®šä¹‰

**å®šä¹‰ 2.1.2** (åŠ æ³•è¿ç®—)
è®¾ $A(x) = \sum_{n=0}^{\infty} a_n x^n$ï¼Œ$B(x) = \sum_{n=0}^{\infty} b_n x^n$ï¼Œåˆ™ï¼š
$$(A + B)(x) = \sum_{n=0}^{\infty} (a_n + b_n) x^n$$

**å®šä¹‰ 2.1.3** (ä¹˜æ³•è¿ç®—)
è®¾ $A(x) = \sum_{n=0}^{\infty} a_n x^n$ï¼Œ$B(x) = \sum_{n=0}^{\infty} b_n x^n$ï¼Œåˆ™ï¼š
$$(A \cdot B)(x) = \sum_{n=0}^{\infty} c_n x^n$$
å…¶ä¸­ $c_n = \sum_{k=0}^{n} a_k b_{n-k}$

### 2.3 å¤åˆè¿ç®—

**å®šä¹‰ 2.1.4** (å¤åˆè¿ç®—)
è®¾ $A(x) = \sum_{n=0}^{\infty} a_n x^n$ï¼Œ$B(x) = \sum_{n=0}^{\infty} b_n x^n$ï¼Œåˆ™ï¼š
$$(A \circ B)(x) = \sum_{n=0}^{\infty} a_n (B(x))^n$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 åŸºæœ¬è¿ç®—æ€§è´¨

**å®šç† 3.1.1** (çº¿æ€§æ€§è´¨)
è®¾ $A(x)$ å’Œ $B(x)$ ä¸ºç”Ÿæˆå‡½æ•°ï¼Œ$\alpha, \beta \in \mathbb{F}$ï¼Œåˆ™ï¼š
$$\mathcal{G}[\alpha a_n + \beta b_n] = \alpha A(x) + \beta B(x)$$

**è¯æ˜**ï¼š
$$
\begin{align}
\mathcal{G}[\alpha a_n + \beta b_n] &= \sum_{n=0}^{\infty} (\alpha a_n + \beta b_n) x^n \\
&= \alpha \sum_{n=0}^{\infty} a_n x^n + \beta \sum_{n=0}^{\infty} b_n x^n \\
&= \alpha A(x) + \beta B(x)
\end{align}
$$

**å®šç† 3.1.2** (ç§»ä½æ€§è´¨)
è®¾ $A(x)$ ä¸ºåºåˆ— $\{a_n\}$ çš„ç”Ÿæˆå‡½æ•°ï¼Œåˆ™ï¼š
$$\mathcal{G}[a_{n+k}] = \frac{A(x) - a_0 - a_1 x - \cdots - a_{k-1} x^{k-1}}{x^k}$$

**è¯æ˜**ï¼š
$$
\begin{align}
\mathcal{G}[a_{n+k}] &= \sum_{n=0}^{\infty} a_{n+k} x^n \\
&= \sum_{n=k}^{\infty} a_n x^{n-k} \\
&= \frac{1}{x^k} \sum_{n=k}^{\infty} a_n x^n \\
&= \frac{A(x) - \sum_{n=0}^{k-1} a_n x^n}{x^k}
\end{align}
$$

### 3.2 å·ç§¯å®šç†

**å®šç† 3.2.1** (å·ç§¯å®šç†)
è®¾ $A(x)$ å’Œ $B(x)$ åˆ†åˆ«ä¸ºåºåˆ— $\{a_n\}$ å’Œ $\{b_n\}$ çš„ç”Ÿæˆå‡½æ•°ï¼Œåˆ™ï¼š
$$\mathcal{G}[a_n * b_n] = A(x) \cdot B(x)$$
å…¶ä¸­ $a_n * b_n = \sum_{k=0}^{n} a_k b_{n-k}$

**è¯æ˜**ï¼š
$$
\begin{align}
A(x) \cdot B(x) &= \left(\sum_{n=0}^{\infty} a_n x^n\right) \left(\sum_{n=0}^{\infty} b_n x^n\right) \\
&= \sum_{n=0}^{\infty} \sum_{k=0}^{n} a_k b_{n-k} x^n \\
&= \sum_{n=0}^{\infty} (a_n * b_n) x^n \\
&= \mathcal{G}[a_n * b_n]
\end{align}
$$

### 3.3 æŒ‡æ•°ç”Ÿæˆå‡½æ•°æ€§è´¨

**å®šç† 3.3.1** (æŒ‡æ•°ç”Ÿæˆå‡½æ•°å·ç§¯)
è®¾ $A(x)$ å’Œ $B(x)$ åˆ†åˆ«ä¸ºåºåˆ— $\{a_n\}$ å’Œ $\{b_n\}$ çš„æŒ‡æ•°ç”Ÿæˆå‡½æ•°ï¼Œåˆ™ï¼š
$$\mathcal{E}[a_n * b_n] = A(x) \cdot B(x)$$
å…¶ä¸­ $a_n * b_n = \sum_{k=0}^{n} \binom{n}{k} a_k b_{n-k}$

**è¯æ˜**ï¼š
$$
\begin{align}
A(x) \cdot B(x) &= \left(\sum_{n=0}^{\infty} a_n \frac{x^n}{n!}\right) \left(\sum_{n=0}^{\infty} b_n \frac{x^n}{n!}\right) \\
&= \sum_{n=0}^{\infty} \sum_{k=0}^{n} \frac{a_k}{k!} \frac{b_{n-k}}{(n-k)!} x^n \\
&= \sum_{n=0}^{\infty} \frac{1}{n!} \sum_{k=0}^{n} \binom{n}{k} a_k b_{n-k} x^n \\
&= \mathcal{E}[a_n * b_n]
\end{align}
$$

### 3.4 æœ‰ç†ç”Ÿæˆå‡½æ•°

**å®šç† 3.4.1** (æœ‰ç†ç”Ÿæˆå‡½æ•°å±•å¼€)
è®¾ $A(x) = \frac{P(x)}{Q(x)}$ ä¸ºæœ‰ç†ç”Ÿæˆå‡½æ•°ï¼Œå…¶ä¸­ $Q(x) = \prod_{i=1}^{k} (1 - \alpha_i x)^{m_i}$ï¼Œåˆ™ï¼š
$$a_n = \sum_{i=1}^{k} \sum_{j=0}^{m_i-1} c_{i,j} \binom{n+j-1}{j} \alpha_i^n$$

**è¯æ˜**ï¼š
ä½¿ç”¨éƒ¨åˆ†åˆ†å¼åˆ†è§£å’Œå¹¿ä¹‰äºŒé¡¹å¼å®šç†ã€‚

## 4. ç®—æ³•å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::HashMap;
use num::complex::Complex64;
use num::traits::{Zero, One};

/// ç”Ÿæˆå‡½æ•°ç±»å‹
# [derive(Debug, Clone)]
pub struct GeneratingFunction {
    coefficients: Vec<f64>,
    is_exponential: bool,
}

impl GeneratingFunction {
    /// åˆ›å»ºæ™®é€šç”Ÿæˆå‡½æ•°
    pub fn new(coefficients: Vec<f64>) -> Self {
        Self {
            coefficients,
            is_exponential: false,
        }
    }

    /// åˆ›å»ºæŒ‡æ•°ç”Ÿæˆå‡½æ•°
    pub fn exponential(coefficients: Vec<f64>) -> Self {
        Self {
            coefficients,
            is_exponential: true,
        }
    }

    /// è·å–ç³»æ•°
    pub fn coefficient(&self, n: usize) -> f64 {
        if n < self.coefficients.len() {
            self.coefficients[n]
        } else {
            0.0
        }
    }

    /// è®¾ç½®ç³»æ•°
    pub fn set_coefficient(&mut self, n: usize, value: f64) {
        while self.coefficients.len() <= n {
            self.coefficients.push(0.0);
        }
        self.coefficients[n] = value;
    }

    /// è®¡ç®—å‡½æ•°å€¼
    pub fn evaluate(&self, x: f64) -> f64 {
        let mut result = 0.0;
        let mut power = 1.0;

        for (n, &coeff) in self.coefficients.iter().enumerate() {
            if self.is_exponential {
                result += coeff * power / Self::factorial(n as u64) as f64;
            } else {
                result += coeff * power;
            }
            power *= x;
        }

        result
    }

    /// åŠ æ³•è¿ç®—
    pub fn add(&self, other: &Self) -> Self {
        let max_len = self.coefficients.len().max(other.coefficients.len());
        let mut result = vec![0.0; max_len];

        for i in 0..max_len {
            result[i] = self.coefficient(i) + other.coefficient(i);
        }

        Self {
            coefficients: result,
            is_exponential: self.is_exponential && other.is_exponential,
        }
    }

    /// ä¹˜æ³•è¿ç®— (å·ç§¯)
    pub fn multiply(&self, other: &Self) -> Self {
        let result_len = self.coefficients.len() + other.coefficients.len() - 1;
        let mut result = vec![0.0; result_len];

        for i in 0..self.coefficients.len() {
            for j in 0..other.coefficients.len() {
                result[i + j] += self.coefficients[i] * other.coefficients[j];
            }
        }

        Self {
            coefficients: result,
            is_exponential: self.is_exponential && other.is_exponential,
        }
    }

    /// ç§»ä½è¿ç®—
    pub fn shift(&self, k: usize) -> Self {
        let mut result = vec![0.0; self.coefficients.len() + k];

        for i in 0..self.coefficients.len() {
            result[i + k] = self.coefficients[i];
        }

        Self {
            coefficients: result,
            is_exponential: self.is_exponential,
        }
    }

    /// æ±‚å¯¼è¿ç®—
    pub fn differentiate(&self) -> Self {
        let mut result = Vec::new();

        for (n, &coeff) in self.coefficients.iter().enumerate().skip(1) {
            if self.is_exponential {
                result.push(coeff);
            } else {
                result.push(coeff * n as f64);
            }
        }

        Self {
            coefficients: result,
            is_exponential: self.is_exponential,
        }
    }

    /// ç§¯åˆ†è¿ç®—
    pub fn integrate(&self) -> Self {
        let mut result = vec![0.0]; // å¸¸æ•°é¡¹

        for (n, &coeff) in self.coefficients.iter().enumerate() {
            if self.is_exponential {
                result.push(coeff);
            } else {
                result.push(coeff / (n + 1) as f64);
            }
        }

        Self {
            coefficients: result,
            is_exponential: self.is_exponential,
        }
    }

    /// å¤åˆè¿ç®—
    pub fn compose(&self, other: &Self) -> Self {
        let mut result = Self::new(vec![0.0]);
        let mut power = Self::new(vec![1.0]);

        for &coeff in &self.coefficients {
            let term = power.multiply(&Self::new(vec![coeff]));
            result = result.add(&term);
            power = power.multiply(other);
        }

        result
    }

    /// è®¡ç®—é˜¶ä¹˜
    fn factorial(n: u64) -> u64 {
        if n <= 1 {
            1
        } else {
            n * Self::factorial(n - 1)
        }
    }
}

/// ç‰¹æ®Šç”Ÿæˆå‡½æ•°
pub struct SpecialGeneratingFunctions;

impl SpecialGeneratingFunctions {
    /// å‡ ä½•çº§æ•°ç”Ÿæˆå‡½æ•°
    pub fn geometric(r: f64) -> GeneratingFunction {
        let mut gf = GeneratingFunction::new(vec![]);
        gf.set_coefficient(0, 1.0);
        for n in 1..10 {
            gf.set_coefficient(n, r.powi(n as i32));
        }
        gf
    }

    /// æŒ‡æ•°å‡½æ•°ç”Ÿæˆå‡½æ•°
    pub fn exponential() -> GeneratingFunction {
        let mut gf = GeneratingFunction::exponential(vec![]);
        for n in 0..10 {
            gf.set_coefficient(n, 1.0);
        }
        gf
    }

    /// äºŒé¡¹å¼ç”Ÿæˆå‡½æ•°
    pub fn binomial(n: usize) -> GeneratingFunction {
        let mut gf = GeneratingFunction::new(vec![]);
        for k in 0..=n {
            gf.set_coefficient(k, Self::combination(n, k) as f64);
        }
        gf
    }

    /// æ–æ³¢é‚£å¥‘ç”Ÿæˆå‡½æ•°
    pub fn fibonacci() -> GeneratingFunction {
        let mut gf = GeneratingFunction::new(vec![0.0, 1.0]);
        for n in 2..10 {
            let fib_n = gf.coefficient(n-1) + gf.coefficient(n-2);
            gf.set_coefficient(n, fib_n);
        }
        gf
    }

    /// å¡ç‰¹å…°æ•°ç”Ÿæˆå‡½æ•°
    pub fn catalan() -> GeneratingFunction {
        let mut gf = GeneratingFunction::new(vec![1.0]);
        for n in 1..10 {
            let mut cat_n = 0.0;
            for k in 0..n {
                cat_n += gf.coefficient(k) * gf.coefficient(n-1-k);
            }
            gf.set_coefficient(n, cat_n);
        }
        gf
    }

    /// è®¡ç®—ç»„åˆæ•°
    fn combination(n: usize, k: usize) -> usize {
        if k > n {
            return 0;
        }
        if k == 0 || k == n {
            return 1;
        }
        Self::combination(n-1, k) + Self::combination(n-1, k-1)
    }
}

/// ç”Ÿæˆå‡½æ•°æ±‚è§£å™¨
pub struct GeneratingFunctionSolver;

impl GeneratingFunctionSolver {
    /// æ±‚è§£çº¿æ€§é€’æ¨å…³ç³»
    pub fn solve_linear_recurrence(coefficients: &[f64], initial_values: &[f64]) -> GeneratingFunction {
        let order = coefficients.len();
        let mut gf = GeneratingFunction::new(vec![]);

        // è®¾ç½®åˆå§‹å€¼
        for (i, &value) in initial_values.iter().enumerate() {
            gf.set_coefficient(i, value);
        }

        // è®¡ç®—åç»­é¡¹
        for n in order..(order + 10) {
            let mut next_value = 0.0;
            for (i, &coeff) in coefficients.iter().enumerate() {
                next_value += coeff * gf.coefficient(n - i - 1);
            }
            gf.set_coefficient(n, next_value);
        }

        gf
    }

    /// æ±‚è§£æœ‰ç†ç”Ÿæˆå‡½æ•°
    pub fn solve_rational_gf(numerator: &[f64], denominator: &[f64]) -> GeneratingFunction {
        let mut gf = GeneratingFunction::new(vec![]);

        // ä½¿ç”¨é•¿é™¤æ³•è®¡ç®—ç³»æ•°
        for n in 0..20 {
            let mut coeff = 0.0;
            if n < numerator.len() {
                coeff += numerator[n];
            }

            for i in 1..denominator.len() {
                if n >= i {
                    coeff -= denominator[i] * gf.coefficient(n - i);
                }
            }

            if denominator.len() > 0 {
                coeff /= denominator[0];
            }

            gf.set_coefficient(n, coeff);
        }

        gf
    }
}

# [cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generating_function_basic() {
        let gf = GeneratingFunction::new(vec![1.0, 2.0, 3.0]);
        assert_eq!(gf.coefficient(0), 1.0);
        assert_eq!(gf.coefficient(1), 2.0);
        assert_eq!(gf.coefficient(2), 3.0);
        assert_eq!(gf.coefficient(3), 0.0);
    }

    #[test]
    fn test_generating_function_add() {
        let gf1 = GeneratingFunction::new(vec![1.0, 2.0, 3.0]);
        let gf2 = GeneratingFunction::new(vec![4.0, 5.0]);
        let result = gf1.add(&gf2);

        assert_eq!(result.coefficient(0), 5.0);
        assert_eq!(result.coefficient(1), 7.0);
        assert_eq!(result.coefficient(2), 3.0);
    }

    #[test]
    fn test_generating_function_multiply() {
        let gf1 = GeneratingFunction::new(vec![1.0, 1.0]);
        let gf2 = GeneratingFunction::new(vec![1.0, 1.0]);
        let result = gf1.multiply(&gf2);

        assert_eq!(result.coefficient(0), 1.0);
        assert_eq!(result.coefficient(1), 2.0);
        assert_eq!(result.coefficient(2), 1.0);
    }

    #[test]
    fn test_geometric_gf() {
        let gf = SpecialGeneratingFunctions::geometric(0.5);
        assert_eq!(gf.coefficient(0), 1.0);
        assert_eq!(gf.coefficient(1), 0.5);
        assert_eq!(gf.coefficient(2), 0.25);
    }

    #[test]
    fn test_fibonacci_gf() {
        let gf = SpecialGeneratingFunctions::fibonacci();
        assert_eq!(gf.coefficient(0), 0.0);
        assert_eq!(gf.coefficient(1), 1.0);
        assert_eq!(gf.coefficient(2), 1.0);
        assert_eq!(gf.coefficient(3), 2.0);
        assert_eq!(gf.coefficient(4), 3.0);
    }

    #[test]
    fn test_linear_recurrence() {
        let coefficients = vec![1.0, 1.0]; // F(n) = F(n-1) + F(n-2)
        let initial_values = vec![0.0, 1.0]; // F(0) = 0, F(1) = 1
        let gf = GeneratingFunctionSolver::solve_linear_recurrence(&coefficients, &initial_values);

        assert_eq!(gf.coefficient(0), 0.0);
        assert_eq!(gf.coefficient(1), 1.0);
        assert_eq!(gf.coefficient(2), 1.0);
        assert_eq!(gf.coefficient(3), 2.0);
    }
}
```

### 4.2 Haskell å®ç°

```haskell
module GeneratingFunctions where

import Data.List (zipWith, tails)
import Data.Complex

-- ç”Ÿæˆå‡½æ•°ç±»å‹
data GeneratingFunction = GF {
    coefficients :: [Double],
    isExponential :: Bool
} deriving (Show, Eq)

-- åˆ›å»ºæ™®é€šç”Ÿæˆå‡½æ•°
ordinaryGF :: [Double] -> GeneratingFunction
ordinaryGF coeffs = GF coeffs False

-- åˆ›å»ºæŒ‡æ•°ç”Ÿæˆå‡½æ•°
exponentialGF :: [Double] -> GeneratingFunction
exponentialGF coeffs = GF coeffs True

-- è·å–ç³»æ•°
getCoefficient :: GeneratingFunction -> Int -> Double
getCoefficient (GF coeffs _) n
  | n < length coeffs = coeffs !! n
  | otherwise = 0.0

-- è®¾ç½®ç³»æ•°
setCoefficient :: GeneratingFunction -> Int -> Double -> GeneratingFunction
setCoefficient (GF coeffs exp) n value = GF newCoeffs exp
  where
    newCoeffs = take (max (n + 1) (length coeffs)) coeffs ++
                replicate (max 0 (n + 1 - length coeffs)) 0.0
    newCoeffs' = take n newCoeffs ++ [value] ++ drop (n + 1) newCoeffs

-- åŠ æ³•è¿ç®—
addGF :: GeneratingFunction -> GeneratingFunction -> GeneratingFunction
addGF (GF coeffs1 exp1) (GF coeffs2 exp2) = GF newCoeffs (exp1 && exp2)
  where
    maxLen = max (length coeffs1) (length coeffs2)
    newCoeffs = zipWith (+) (coeffs1 ++ repeat 0.0) (coeffs2 ++ repeat 0.0)

-- ä¹˜æ³•è¿ç®— (å·ç§¯)
multiplyGF :: GeneratingFunction -> GeneratingFunction -> GeneratingFunction
multiplyGF (GF coeffs1 exp1) (GF coeffs2 exp2) = GF newCoeffs (exp1 && exp2)
  where
    newCoeffs = [sum [coeffs1 !! i * coeffs2 !! (n - i) | i <- [0..n], i < length coeffs1, n - i < length coeffs2] | n <- [0..(length coeffs1 + length coeffs2 - 1)]]

-- ç§»ä½è¿ç®—
shiftGF :: GeneratingFunction -> Int -> GeneratingFunction
shiftGF (GF coeffs exp) k = GF (replicate k 0.0 ++ coeffs) exp

-- æ±‚å¯¼è¿ç®—
differentiateGF :: GeneratingFunction -> GeneratingFunction
differentiateGF (GF coeffs exp) = GF newCoeffs exp
  where
    newCoeffs = if exp
                then tail coeffs
                else zipWith (*) (tail coeffs) [1.0..]

-- ç§¯åˆ†è¿ç®—
integrateGF :: GeneratingFunction -> GeneratingFunction
integrateGF (GF coeffs exp) = GF newCoeffs exp
  where
    newCoeffs = 0.0 : zipWith (/) coeffs [1.0..]

-- å¤åˆè¿ç®—
composeGF :: GeneratingFunction -> GeneratingFunction -> GeneratingFunction
composeGF (GF coeffs1 exp1) (GF coeffs2 exp2) = foldr addGF zeroGF terms
  where
    terms = zipWith (\a power -> multiplyGF (GF [a] exp1) power) coeffs1 powers
    powers = iterate (`multiplyGF` GF coeffs2 exp2) (GF [1.0] exp1)
    zeroGF = GF [] exp1

-- è®¡ç®—å‡½æ•°å€¼
evaluateGF :: GeneratingFunction -> Double -> Double
evaluateGF (GF coeffs exp) x = sum terms
  where
    terms = zipWith (\a n -> if exp
                             then a * x^n / fromIntegral (factorial n)
                             else a * x^n) coeffs [0..]

-- é˜¶ä¹˜
factorial :: Integer -> Integer
factorial n = product [1..n]

-- ç‰¹æ®Šç”Ÿæˆå‡½æ•°
geometricGF :: Double -> GeneratingFunction
geometricGF r = GF [r^n | n <- [0..]] False

exponentialGF' :: GeneratingFunction
exponentialGF' = exponentialGF [1.0 | _ <- [0..]]

binomialGF :: Int -> GeneratingFunction
binomialGF n = GF [fromIntegral (combination n k) | k <- [0..n]] False

fibonacciGF :: GeneratingFunction
fibonacciGF = GF fibs False
  where
    fibs = 0 : 1 : zipWith (+) fibs (tail fibs)

catalanGF :: GeneratingFunction
catalanGF = GF catalans False
  where
    catalans = 1 : [sum [catalans !! i * catalans !! (n - 1 - i) | i <- [0..(n-1)]] | n <- [1..]]

-- ç»„åˆæ•°
combination :: Int -> Int -> Integer
combination n k
  | k > n = 0
  | k == 0 || k == n = 1
  | otherwise = combination (n-1) k + combination (n-1) (k-1)

-- æ±‚è§£çº¿æ€§é€’æ¨å…³ç³»
solveLinearRecurrence :: [Double] -> [Double] -> GeneratingFunction
solveLinearRecurrence coeffs initial = GF result False
  where
    order = length coeffs
    result = initial ++ [sum [coeffs !! i * result !! (n - i - 1) | i <- [0..(order-1)]] | n <- [order..(order + 9)]]

-- æ±‚è§£æœ‰ç†ç”Ÿæˆå‡½æ•°
solveRationalGF :: [Double] -> [Double] -> GeneratingFunction
solveRationalGF numerator denominator = GF result False
  where
    result = [calculateCoeff n | n <- [0..19]]
    calculateCoeff n = (numeratorTerm - denominatorTerm) / denominatorHead
      where
        numeratorTerm = if n < length numerator then numerator !! n else 0.0
        denominatorTerm = sum [denominator !! i * result !! (n - i) | i <- [1..(length denominator-1)], n >= i]
        denominatorHead = if null denominator then 1.0 else head denominator

-- æµ‹è¯•å‡½æ•°
main :: IO ()
main = do
  putStrLn "ç”Ÿæˆå‡½æ•°æµ‹è¯•:"
  
  let gf1 = ordinaryGF [1.0, 2.0, 3.0]
  let gf2 = ordinaryGF [4.0, 5.0]
  let sumGF = addGF gf1 gf2
  putStrLn $ "åŠ æ³•: " ++ show (getCoefficient sumGF 0)
  
  let prodGF = multiplyGF gf1 gf2
  putStrLn $ "ä¹˜æ³•: " ++ show (getCoefficient prodGF 1)
  
  let fibGF = fibonacciGF
  putStrLn $ "æ–æ³¢é‚£å¥‘: " ++ show (take 5 (coefficients fibGF))
  
  let catGF = catalanGF
  putStrLn $ "å¡ç‰¹å…°æ•°: " ++ show (take 5 (coefficients catGF))
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 ç»„åˆè®¡æ•°åº”ç”¨

**ç¤ºä¾‹ 5.1.1** (äºŒé¡¹å¼ç³»æ•°)
äºŒé¡¹å¼ç³»æ•° $\binom{n}{k}$ çš„ç”Ÿæˆå‡½æ•°ä¸ºï¼š
$$(1+x)^n = \sum_{k=0}^{n} \binom{n}{k} x^k$$

**ç¤ºä¾‹ 5.1.2** (å¡ç‰¹å…°æ•°)
å¡ç‰¹å…°æ•° $C_n$ çš„ç”Ÿæˆå‡½æ•°æ»¡è¶³ï¼š
$$C(x) = 1 + x C(x)^2$$
è§£å¾—ï¼š$C(x) = \frac{1 - \sqrt{1-4x}}{2x}$

### 5.2 é€’æ¨å…³ç³»åº”ç”¨

**ç¤ºä¾‹ 5.2.1** (æ–æ³¢é‚£å¥‘æ•°åˆ—)
æ–æ³¢é‚£å¥‘æ•°åˆ— $F_n$ æ»¡è¶³ $F_{n+2} = F_{n+1} + F_n$ï¼Œå…¶ç”Ÿæˆå‡½æ•°ä¸ºï¼š
$$F(x) = \frac{x}{1-x-x^2}$$

**ç¤ºä¾‹ 5.2.2** (çº¿æ€§é€’æ¨)
ä¸€èˆ¬çº¿æ€§é€’æ¨ $a_{n+k} = c_1 a_{n+k-1} + \cdots + c_k a_n$ çš„ç”Ÿæˆå‡½æ•°ä¸ºæœ‰ç†å‡½æ•°ã€‚

### 5.3 æ¦‚ç‡è®ºåº”ç”¨

**ç¤ºä¾‹ 5.3.1** (äºŒé¡¹åˆ†å¸ƒ)
äºŒé¡¹åˆ†å¸ƒ $B(n,p)$ çš„æ¦‚ç‡ç”Ÿæˆå‡½æ•°ä¸ºï¼š
$$G(x) = (1-p + px)^n$$

**ç¤ºä¾‹ 5.3.2** (æ³Šæ¾åˆ†å¸ƒ)
æ³Šæ¾åˆ†å¸ƒ $P(\lambda)$ çš„æ¦‚ç‡ç”Ÿæˆå‡½æ•°ä¸ºï¼š
$$G(x) = e^{\lambda(x-1)}$$

### 5.4 å›¾è®ºåº”ç”¨

**ç¤ºä¾‹ 5.4.1** (è·¯å¾„è®¡æ•°)
åœ¨ç½‘æ ¼å›¾ä¸­ä» $(0,0)$ åˆ° $(n,n)$ çš„è·¯å¾„æ•°ç”Ÿæˆå‡½æ•°ä¸ºï¼š
$$P(x) = \frac{1}{\sqrt{1-4x}}$$

## 6. ç›¸å…³ç†è®º

### 6.1 æ’åˆ—ç»„åˆç†è®º

- [02.11.2 æ’åˆ—ç»„åˆ](02.11.2_Permutations_and_Combinations.md)

### 6.2 å›¾è®ºåŸºç¡€

- [02.11.4 å›¾è®ºåŸºç¡€](02.11.4_Graph_Theory_Basics.md)

### 6.3 å¤åˆ†æ

- [02.9.4 ç§¯åˆ†å­¦](../02.09_Mathematical_Analysis/02.9.4_Integral_Calculus.md)

### 6.4 æ¦‚ç‡è®º

- [02.12.1 æ¦‚ç‡åŸºç¡€](../02.12_Probability_Theory/02.12.1_Probability_Basics.md)

## 7. å‚è€ƒæ–‡çŒ®

1. Wilf, H. S. (2006). *Generatingfunctionology*. A K Peters.

2. Stanley, R. P. (2011). *Enumerative Combinatorics Volume 1*. Cambridge University Press.

3. Graham, R. L., Knuth, D. E., & Patashnik, O. (1994). *Concrete Mathematics: A Foundation for Computer Science*. Addison-Wesley.

4. Flajolet, P., & Sedgewick, R. (2009). *Analytic Combinatorics*. Cambridge University Press.

5. Aigner, M. (2007). *A Course in Enumeration*. Springer.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [ä¸Šä¸€çº§ï¼š02.11 ç»„åˆæ•°å­¦](../README.md)
- [ä¸‹ä¸€çº§ï¼š02.11.4 å›¾è®ºåŸºç¡€](02.11.4_Graph_Theory_Basics.md)
- [ä¸»ç´¢å¼•ï¼šå½¢å¼ç§‘å­¦ç†è®ºä½“ç³»](../README.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
