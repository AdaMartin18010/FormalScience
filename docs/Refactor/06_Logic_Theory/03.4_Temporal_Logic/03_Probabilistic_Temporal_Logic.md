# æ¦‚ç‡æ—¶æ€é€»è¾‘ç†è®º

## ğŸ“‹ ç›®å½•

- [æ¦‚ç‡æ—¶æ€é€»è¾‘ç†è®º](#æ¦‚ç‡æ—¶æ€é€»è¾‘ç†è®º)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [1. ç†è®ºåŸºç¡€](#1-ç†è®ºåŸºç¡€)
    - [1.1 å†å²èƒŒæ™¯](#11-å†å²èƒŒæ™¯)
    - [1.2 ç†è®ºåŸºç¡€](#12-ç†è®ºåŸºç¡€)
  - [2. åŸºæœ¬æ¦‚å¿µ](#2-åŸºæœ¬æ¦‚å¿µ)
    - [2.1 æ¦‚ç‡çŠ¶æ€](#21-æ¦‚ç‡çŠ¶æ€)
    - [2.2 æ¦‚ç‡è½¬æ¢](#22-æ¦‚ç‡è½¬æ¢)
    - [2.3 æ¦‚ç‡è·¯å¾„](#23-æ¦‚ç‡è·¯å¾„)
  - [3. è¯­æ³•å®šä¹‰](#3-è¯­æ³•å®šä¹‰)
    - [3.1 åŸºæœ¬è¯­æ³•](#31-åŸºæœ¬è¯­æ³•)
    - [3.2 è·¯å¾„å…¬å¼](#32-è·¯å¾„å…¬å¼)
  - [4. è¯­ä¹‰å®šä¹‰](#4-è¯­ä¹‰å®šä¹‰)
    - [4.1 æ¦‚ç‡æ¨¡å‹](#41-æ¦‚ç‡æ¨¡å‹)
    - [4.2 è·¯å¾„æ¦‚ç‡](#42-è·¯å¾„æ¦‚ç‡)
    - [4.3 æ»¡è¶³å…³ç³»](#43-æ»¡è¶³å…³ç³»)
  - [5. ç­‰ä»·å…³ç³»](#5-ç­‰ä»·å…³ç³»)
    - [5.1 æ¦‚ç‡ç­‰ä»·](#51-æ¦‚ç‡ç­‰ä»·)
    - [5.2 è¡Œä¸ºç­‰ä»·](#52-è¡Œä¸ºç­‰ä»·)
  - [6. æ ¸å¿ƒå®šç†](#6-æ ¸å¿ƒå®šç†)
    - [6.1 ç­‰ä»·æ€§å®šç†](#61-ç­‰ä»·æ€§å®šç†)
    - [6.2 æ¦‚ç‡æ€§è´¨å®šç†](#62-æ¦‚ç‡æ€§è´¨å®šç†)
    - [6.3 æ¨¡å‹æ£€æŸ¥å®šç†](#63-æ¨¡å‹æ£€æŸ¥å®šç†)
  - [7. åº”ç”¨é¢†åŸŸ](#7-åº”ç”¨é¢†åŸŸ)
    - [7.1 å¯é æ€§åˆ†æ](#71-å¯é æ€§åˆ†æ)
    - [7.2 æ€§èƒ½åˆ†æ](#72-æ€§èƒ½åˆ†æ)
    - [7.3 éšæœºç³»ç»Ÿ](#73-éšæœºç³»ç»Ÿ)
  - [8. ä»£ç å®ç°](#8-ä»£ç å®ç°)
    - [8.1 Rustå®ç°](#81-rustå®ç°)
    - [8.2 Haskellå®ç°](#82-haskellå®ç°)
  - [9. å½¢å¼åŒ–è¯æ˜](#9-å½¢å¼åŒ–è¯æ˜)
    - [9.1 Leanè¯æ˜](#91-leanè¯æ˜)
  - [10. å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)

## 1. ç†è®ºåŸºç¡€

### 1.1 å†å²èƒŒæ™¯

æ¦‚ç‡æ—¶æ€é€»è¾‘ï¼ˆProbabilistic Temporal Logicï¼‰æ˜¯æ—¶æ€é€»è¾‘ä¸æ¦‚ç‡è®ºçš„ç»“åˆï¼Œèµ·æºäºå¯¹ä¸ç¡®å®šæ€§ç³»ç»Ÿçš„å»ºæ¨¡å’ŒéªŒè¯éœ€æ±‚ã€‚
å®ƒä¸ºæè¿°å’Œåˆ†æå…·æœ‰æ¦‚ç‡è¡Œä¸ºçš„ç³»ç»Ÿæä¾›äº†å½¢å¼åŒ–æ¡†æ¶ã€‚

### 1.2 ç†è®ºåŸºç¡€

**å®šä¹‰ 1.1** (æ¦‚ç‡æ—¶æ€é€»è¾‘)
æ¦‚ç‡æ—¶æ€é€»è¾‘æ˜¯ç”¨äºæè¿°å…·æœ‰æ¦‚ç‡è¡Œä¸ºçš„æ—¶æ€ç³»ç»Ÿçš„å½¢å¼åŒ–é€»è¾‘ï¼ŒåŒ…å«ï¼š

- æ¦‚ç‡æµ‹åº¦
- æ—¶æ€ç®—å­
- æ¦‚ç‡ç®—å­
- è·¯å¾„é‡åŒ–

**å…¬ç† 1.1** (æ¦‚ç‡æµ‹åº¦å…¬ç†)
æ¦‚ç‡æµ‹åº¦ $P$ æ»¡è¶³ï¼š

- $P(\emptyset) = 0$
- $P(\Omega) = 1$
- $P(A \cup B) = P(A) + P(B) - P(A \cap B)$

**å…¬ç† 1.2** (æ—¶æ€æ¦‚ç‡å…¬ç†)
æ—¶æ€æ¦‚ç‡æ»¡è¶³é©¬å°”å¯å¤«æ€§è´¨ï¼šæœªæ¥çŠ¶æ€çš„æ¦‚ç‡åªä¾èµ–äºå½“å‰çŠ¶æ€ã€‚

## 2. åŸºæœ¬æ¦‚å¿µ

### 2.1 æ¦‚ç‡çŠ¶æ€

**å®šä¹‰ 2.1** (æ¦‚ç‡çŠ¶æ€)
æ¦‚ç‡çŠ¶æ€ $s$ æ˜¯ä¸€ä¸ªæ¦‚ç‡åˆ†å¸ƒï¼Œè¡¨ç¤ºä¸ºï¼š
$$s : S \to [0,1]$$

å…¶ä¸­ $S$ æ˜¯çŠ¶æ€é›†åˆï¼Œæ»¡è¶³ $\sum_{s' \in S} s(s') = 1$ã€‚

### 2.2 æ¦‚ç‡è½¬æ¢

**å®šä¹‰ 2.2** (æ¦‚ç‡è½¬æ¢)
æ¦‚ç‡è½¬æ¢ $T$ æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š
$$T : S \times S \to [0,1]$$

æ»¡è¶³å¯¹äºæ‰€æœ‰ $s \in S$ï¼š
$$\sum_{s' \in S} T(s, s') = 1$$

### 2.3 æ¦‚ç‡è·¯å¾„

**å®šä¹‰ 2.3** (æ¦‚ç‡è·¯å¾„)
æ¦‚ç‡è·¯å¾„ $\pi$ æ˜¯ä¸€ä¸ªçŠ¶æ€åºåˆ—ï¼š
$$\pi = s_0 s_1 s_2 \ldots$$

å…¶ä¸­æ¯ä¸ªè½¬æ¢éƒ½æœ‰ç›¸åº”çš„æ¦‚ç‡ã€‚

## 3. è¯­æ³•å®šä¹‰

### 3.1 åŸºæœ¬è¯­æ³•

**å®šä¹‰ 3.1** (æ¦‚ç‡æ—¶æ€é€»è¾‘è¯­æ³•)
æ¦‚ç‡æ—¶æ€é€»è¾‘çš„è¯­æ³•å®šä¹‰å¦‚ä¸‹ï¼š

$$\phi ::= p \mid \neg \phi \mid \phi_1 \land \phi_2 \mid \phi_1 \lor \phi_2 \mid \phi_1 \to \phi_2 \mid \phi_1 \leftrightarrow \phi_2 \mid \mathbf{P}_{\bowtie p}[\psi] \mid \mathbf{S}_{\bowtie p}[\phi]$$

å…¶ä¸­ï¼š

- $p$ æ˜¯åŸå­å‘½é¢˜
- $\bowtie \in \{<, \leq, =, \geq, >\}$ æ˜¯æ¦‚ç‡æ¯”è¾ƒæ“ä½œç¬¦
- $p \in [0,1]$ æ˜¯æ¦‚ç‡é˜ˆå€¼
- $\psi$ æ˜¯è·¯å¾„å…¬å¼

### 3.2 è·¯å¾„å…¬å¼

**å®šä¹‰ 3.2** (è·¯å¾„å…¬å¼è¯­æ³•)
è·¯å¾„å…¬å¼çš„è¯­æ³•å®šä¹‰å¦‚ä¸‹ï¼š

$$\psi ::= \mathbf{X} \phi \mid \mathbf{F} \phi \mid \mathbf{G} \phi \mid \phi_1 \mathbf{U} \phi_2 \mid \phi_1 \mathbf{W} \phi_2 \mid \phi_1 \mathbf{R} \phi_2$$

å…¶ä¸­ï¼š

- $\mathbf{X} \phi$ï¼šä¸‹ä¸€ä¸ªçŠ¶æ€æ»¡è¶³ $\phi$
- $\mathbf{F} \phi$ï¼šæœ€ç»ˆæ»¡è¶³ $\phi$
- $\mathbf{G} \phi$ï¼šæ€»æ˜¯æ»¡è¶³ $\phi$
- $\phi_1 \mathbf{U} \phi_2$ï¼š$\phi_1$ ç›´åˆ° $\phi_2$
- $\phi_1 \mathbf{W} \phi_2$ï¼š$\phi_1$ å¼±ç›´åˆ° $\phi_2$
- $\phi_1 \mathbf{R} \phi_2$ï¼š$\phi_1$ é‡Šæ”¾ $\phi_2$

## 4. è¯­ä¹‰å®šä¹‰

### 4.1 æ¦‚ç‡æ¨¡å‹

**å®šä¹‰ 4.1** (æ¦‚ç‡æ¨¡å‹)
æ¦‚ç‡æ¨¡å‹æ˜¯ä¸€ä¸ªå››å…ƒç»„ $M = (S, s_0, T, L)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯çŠ¶æ€é›†åˆ
- $s_0 \in S$ æ˜¯åˆå§‹çŠ¶æ€
- $T : S \times S \to [0,1]$ æ˜¯æ¦‚ç‡è½¬æ¢å‡½æ•°
- $L : S \to 2^{AP}$ æ˜¯æ ‡è®°å‡½æ•°

### 4.2 è·¯å¾„æ¦‚ç‡

**å®šä¹‰ 4.2** (è·¯å¾„æ¦‚ç‡)
è·¯å¾„ $\pi = s_0 s_1 s_2 \ldots$ çš„æ¦‚ç‡å®šä¹‰ä¸ºï¼š
$$P(\pi) = \prod_{i=0}^{\infty} T(s_i, s_{i+1})$$

### 4.3 æ»¡è¶³å…³ç³»

**å®šä¹‰ 4.3** (çŠ¶æ€æ»¡è¶³å…³ç³»)
çŠ¶æ€ $s$ æ»¡è¶³å…¬å¼ $\phi$ï¼Œè®°ä½œ $s \models \phi$ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š

- $s \models p$ å½“ä¸”ä»…å½“ $p \in L(s)$
- $s \models \neg \phi$ å½“ä¸”ä»…å½“ $s \not\models \phi$
- $s \models \phi_1 \land \phi_2$ å½“ä¸”ä»…å½“ $s \models \phi_1$ ä¸” $s \models \phi_2$
- $s \models \mathbf{P}_{\bowtie p}[\psi]$ å½“ä¸”ä»…å½“ $P(\{\pi \mid \pi \models \psi\}) \bowtie p$

**å®šä¹‰ 4.4** (è·¯å¾„æ»¡è¶³å…³ç³»)
è·¯å¾„ $\pi$ æ»¡è¶³è·¯å¾„å…¬å¼ $\psi$ï¼Œè®°ä½œ $\pi \models \psi$ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š

- $\pi \models \mathbf{X} \phi$ å½“ä¸”ä»…å½“ $\pi[1] \models \phi$
- $\pi \models \mathbf{F} \phi$ å½“ä¸”ä»…å½“å­˜åœ¨ $i \geq 0$ ä½¿å¾— $\pi[i] \models \phi$
- $\pi \models \mathbf{G} \phi$ å½“ä¸”ä»…å½“å¯¹äºæ‰€æœ‰ $i \geq 0$ï¼Œ$\pi[i] \models \phi$
- $\pi \models \phi_1 \mathbf{U} \phi_2$ å½“ä¸”ä»…å½“å­˜åœ¨ $i \geq 0$ ä½¿å¾— $\pi[i] \models \phi_2$ ä¸”å¯¹äºæ‰€æœ‰ $0 \leq j < i$ï¼Œ$\pi[j] \models \phi_1$

## 5. ç­‰ä»·å…³ç³»

### 5.1 æ¦‚ç‡ç­‰ä»·

**å®šä¹‰ 5.1** (æ¦‚ç‡ç­‰ä»·)
ä¸¤ä¸ªæ¦‚ç‡æ¨¡å‹ $M_1$ å’Œ $M_2$ æ¦‚ç‡ç­‰ä»·ï¼Œè®°ä½œ $M_1 \equiv_p M_2$ï¼Œå¦‚æœå¯¹äºæ‰€æœ‰å…¬å¼ $\phi$ï¼š
$$M_1 \models \phi \Leftrightarrow M_2 \models \phi$$

### 5.2 è¡Œä¸ºç­‰ä»·

**å®šä¹‰ 5.2** (è¡Œä¸ºç­‰ä»·)
ä¸¤ä¸ªæ¦‚ç‡æ¨¡å‹ $M_1$ å’Œ $M_2$ è¡Œä¸ºç­‰ä»·ï¼Œè®°ä½œ $M_1 \equiv_b M_2$ï¼Œå¦‚æœå®ƒä»¬äº§ç”Ÿç›¸åŒçš„æ¦‚ç‡è¡Œä¸ºã€‚

## 6. æ ¸å¿ƒå®šç†

### 6.1 ç­‰ä»·æ€§å®šç†

**å®šç† 6.1** (æ¦‚ç‡ç­‰ä»·çš„æ€§è´¨)
æ¦‚ç‡ç­‰ä»· $\equiv_p$ æ˜¯ç­‰ä»·å…³ç³»ã€‚

**å®šç† 6.2** (è¡Œä¸ºç­‰ä»·çš„æ€§è´¨)
è¡Œä¸ºç­‰ä»· $\equiv_b$ æ˜¯ç­‰ä»·å…³ç³»ï¼Œä¸” $\equiv_p \subseteq \equiv_b$ã€‚

### 6.2 æ¦‚ç‡æ€§è´¨å®šç†

**å®šç† 6.3** (æ¦‚ç‡å•è°ƒæ€§)
å¦‚æœ $\phi_1 \Rightarrow \phi_2$ï¼Œåˆ™ï¼š
$$\mathbf{P}_{\geq p}[\phi_1] \Rightarrow \mathbf{P}_{\geq p}[\phi_2]$$

**å®šç† 6.4** (æ¦‚ç‡å¯¹å¶æ€§)
$$\mathbf{P}_{\geq p}[\mathbf{F} \phi] \Leftrightarrow \mathbf{P}_{> 1-p}[\mathbf{G} \neg \phi]$$

### 6.3 æ¨¡å‹æ£€æŸ¥å®šç†

**å®šç† 6.5** (æ¦‚ç‡æ¨¡å‹æ£€æŸ¥)
æ¦‚ç‡æ—¶æ€é€»è¾‘çš„æ¨¡å‹æ£€æŸ¥é—®é¢˜æ˜¯å¯åˆ¤å®šçš„ã€‚

**è¯æ˜**ï¼š
é€šè¿‡å°†æ¦‚ç‡æ¨¡å‹è½¬æ¢ä¸ºé©¬å°”å¯å¤«é“¾ï¼Œç„¶åä½¿ç”¨çº¿æ€§ä»£æ•°æ–¹æ³•æ±‚è§£æ¦‚ç‡ã€‚

## 7. åº”ç”¨é¢†åŸŸ

### 7.1 å¯é æ€§åˆ†æ

- ç³»ç»Ÿå¯é æ€§è¯„ä¼°
- æ•…éšœæ¦‚ç‡åˆ†æ
- å¯ç”¨æ€§è®¡ç®—
- é£é™©è¯„ä¼°

### 7.2 æ€§èƒ½åˆ†æ

- æ€§èƒ½æŒ‡æ ‡è®¡ç®—
- ååé‡åˆ†æ
- å“åº”æ—¶é—´åˆ†æ
- èµ„æºåˆ©ç”¨ç‡

### 7.3 éšæœºç³»ç»Ÿ

- éšæœºç®—æ³•åˆ†æ
- éšæœºåè®®éªŒè¯
- éšæœºæ§åˆ¶ç†è®º
- éšæœºä¼˜åŒ–

## 8. ä»£ç å®ç°

### 8.1 Rustå®ç°

```rust
use std::collections::HashMap;
use std::f64;

// æ¦‚ç‡æ¨¡å‹
struct ProbabilisticModel {
    states: Vec<String>,
    initial_state: String,
    transitions: HashMap<(String, String), f64>,
    labels: HashMap<String, Vec<String>>,
}

impl ProbabilisticModel {
    fn new(initial_state: String) -> ProbabilisticModel {
        ProbabilisticModel {
            states: vec![initial_state.clone()],
            initial_state,
            transitions: HashMap::new(),
            labels: HashMap::new(),
        }
    }
    
    fn add_state(&mut self, state: String) {
        if !self.states.contains(&state) {
            self.states.push(state);
        }
    }
    
    fn add_transition(&mut self, from: String, to: String, probability: f64) {
        self.add_state(from.clone());
        self.add_state(to.clone());
        self.transitions.insert((from, to), probability);
    }
    
    fn add_label(&mut self, state: String, label: String) {
        self.labels.entry(state).or_insert_with(Vec::new).push(label);
    }
    
    fn get_transition_probability(&self, from: &str, to: &str) -> f64 {
        *self.transitions.get(&(from.to_string(), to.to_string())).unwrap_or(&0.0)
    }
    
    fn get_successors(&self, state: &str) -> Vec<(String, f64)> {
        let mut successors = Vec::new();
        for (s, p) in &self.transitions {
            if s.0 == state {
                successors.push((s.1.clone(), *p));
            }
        }
        successors
    }
    
    fn normalize_transitions(&mut self) {
        for state in &self.states {
            let total_prob = self.get_successors(state).iter()
                .map(|(_, p)| p).sum::<f64>();
            
            if total_prob > 0.0 {
                for (to, prob) in self.get_successors(state) {
                    let normalized_prob = prob / total_prob;
                    self.transitions.insert((state.clone(), to), normalized_prob);
                }
            }
        }
    }
}

// æ¦‚ç‡æ—¶æ€é€»è¾‘å…¬å¼
enum ProbabilisticFormula {
    Atomic(String),
    Not(Box<ProbabilisticFormula>),
    And(Box<ProbabilisticFormula>, Box<ProbabilisticFormula>),
    Or(Box<ProbabilisticFormula>, Box<ProbabilisticFormula>),
    Probability(ProbabilityOperator, f64, Box<PathFormula>),
}

enum ProbabilityOperator {
    LessThan,
    LessEqual,
    Equal,
    GreaterEqual,
    GreaterThan,
}

enum PathFormula {
    Next(Box<ProbabilisticFormula>),
    Finally(Box<ProbabilisticFormula>),
    Globally(Box<ProbabilisticFormula>),
    Until(Box<ProbabilisticFormula>, Box<ProbabilisticFormula>),
}

impl ProbabilisticModel {
    fn check_probability(&self, formula: &ProbabilisticFormula) -> bool {
        match formula {
            ProbabilisticFormula::Probability(op, threshold, path_formula) => {
                let probability = self.compute_path_probability(path_formula);
                self.compare_probability(probability, *threshold, op)
            },
            _ => true, // ç®€åŒ–å¤„ç†
        }
    }
    
    fn compute_path_probability(&self, path_formula: &PathFormula) -> f64 {
        match path_formula {
            PathFormula::Finally(phi) => {
                self.compute_finally_probability(phi)
            },
            PathFormula::Globally(phi) => {
                self.compute_globally_probability(phi)
            },
            PathFormula::Next(phi) => {
                self.compute_next_probability(phi)
            },
            PathFormula::Until(phi1, phi2) => {
                self.compute_until_probability(phi1, phi2)
            },
        }
    }
    
    fn compute_finally_probability(&self, phi: &ProbabilisticFormula) -> f64 {
        // ä½¿ç”¨è¿­ä»£æ–¹æ³•è®¡ç®—æœ€ç»ˆæ¦‚ç‡
        let mut probabilities = HashMap::new();
        
        // åˆå§‹åŒ–
        for state in &self.states {
            probabilities.insert(state.clone(), 
                if self.satisfies_atomic(state, phi) { 1.0 } else { 0.0 });
        }
        
        // è¿­ä»£ç›´åˆ°æ”¶æ•›
        for _ in 0..100 {
            let mut new_probabilities = HashMap::new();
            
            for state in &self.states {
                if self.satisfies_atomic(state, phi) {
                    new_probabilities.insert(state.clone(), 1.0);
                } else {
                    let mut prob = 0.0;
                    for (successor, transition_prob) in self.get_successors(state) {
                        prob += transition_prob * probabilities.get(&successor).unwrap_or(&0.0);
                    }
                    new_probabilities.insert(state.clone(), prob);
                }
            }
            
            probabilities = new_probabilities;
        }
        
        *probabilities.get(&self.initial_state).unwrap_or(&0.0)
    }
    
    fn compute_globally_probability(&self, phi: &ProbabilisticFormula) -> f64 {
        // å…¨å±€æ¦‚ç‡æ˜¯æœ€ç»ˆæ¦‚ç‡çš„è¡¥
        1.0 - self.compute_finally_probability(&ProbabilisticFormula::Not(Box::new(phi.clone())))
    }
    
    fn compute_next_probability(&self, phi: &ProbabilisticFormula) -> f64 {
        let mut prob = 0.0;
        for (successor, transition_prob) in self.get_successors(&self.initial_state) {
            if self.satisfies_atomic(&successor, phi) {
                prob += transition_prob;
            }
        }
        prob
    }
    
    fn compute_until_probability(&self, phi1: &ProbabilisticFormula, phi2: &ProbabilisticFormula) -> f64 {
        // ç®€åŒ–çš„ç›´åˆ°æ¦‚ç‡è®¡ç®—
        let mut probabilities = HashMap::new();
        
        // åˆå§‹åŒ–
        for state in &self.states {
            if self.satisfies_atomic(state, phi2) {
                probabilities.insert(state.clone(), 1.0);
            } else if !self.satisfies_atomic(state, phi1) {
                probabilities.insert(state.clone(), 0.0);
            } else {
                probabilities.insert(state.clone(), 0.0);
            }
        }
        
        // è¿­ä»£
        for _ in 0..100 {
            let mut new_probabilities = HashMap::new();
            
            for state in &self.states {
                if self.satisfies_atomic(state, phi2) {
                    new_probabilities.insert(state.clone(), 1.0);
                } else if !self.satisfies_atomic(state, phi1) {
                    new_probabilities.insert(state.clone(), 0.0);
                } else {
                    let mut prob = 0.0;
                    for (successor, transition_prob) in self.get_successors(state) {
                        prob += transition_prob * probabilities.get(&successor).unwrap_or(&0.0);
                    }
                    new_probabilities.insert(state.clone(), prob);
                }
            }
            
            probabilities = new_probabilities;
        }
        
        *probabilities.get(&self.initial_state).unwrap_or(&0.0)
    }
    
    fn satisfies_atomic(&self, state: &str, phi: &ProbabilisticFormula) -> bool {
        match phi {
            ProbabilisticFormula::Atomic(label) => {
                self.labels.get(state).map_or(false, |labels| labels.contains(label))
            },
            _ => false, // ç®€åŒ–å¤„ç†
        }
    }
    
    fn compare_probability(&self, prob: f64, threshold: f64, op: &ProbabilityOperator) -> bool {
        match op {
            ProbabilityOperator::LessThan => prob < threshold,
            ProbabilityOperator::LessEqual => prob <= threshold,
            ProbabilityOperator::Equal => (prob - threshold).abs() < f64::EPSILON,
            ProbabilityOperator::GreaterEqual => prob >= threshold,
            ProbabilityOperator::GreaterThan => prob > threshold,
        }
    }
}

fn main() {
    // ç¤ºä¾‹ï¼šç®€å•çš„æ¦‚ç‡æ¨¡å‹
    let mut model = ProbabilisticModel::new("s0".to_string());
    
    // æ·»åŠ çŠ¶æ€å’Œè½¬æ¢
    model.add_transition("s0".to_string(), "s1".to_string(), 0.7);
    model.add_transition("s0".to_string(), "s2".to_string(), 0.3);
    model.add_transition("s1".to_string(), "s0".to_string(), 0.5);
    model.add_transition("s1".to_string(), "s2".to_string(), 0.5);
    model.add_transition("s2".to_string(), "s0".to_string(), 1.0);
    
    // æ·»åŠ æ ‡ç­¾
    model.add_label("s0".to_string(), "start".to_string());
    model.add_label("s1".to_string(), "running".to_string());
    model.add_label("s2".to_string(), "finished".to_string());
    
    // è§„èŒƒåŒ–è½¬æ¢æ¦‚ç‡
    model.normalize_transitions();
    
    // æ£€æŸ¥æ¦‚ç‡æ€§è´¨
    let finally_finished = ProbabilisticFormula::Probability(
        ProbabilityOperator::GreaterEqual,
        0.8,
        Box::new(PathFormula::Finally(Box::new(ProbabilisticFormula::Atomic("finished".to_string()))))
    );
    
    println!("P[F finished] >= 0.8: {}", model.check_probability(&finally_finished));
    
    let next_running = ProbabilisticFormula::Probability(
        ProbabilityOperator::GreaterEqual,
        0.5,
        Box::new(PathFormula::Next(Box::new(ProbabilisticFormula::Atomic("running".to_string()))))
    );
    
    println!("P[X running] >= 0.5: {}", model.check_probability(&next_running));
}
```

### 8.2 Haskellå®ç°

```haskell
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set

-- æ¦‚ç‡æ¨¡å‹
data ProbabilisticModel = ProbabilisticModel {
    states :: [String],
    initialState :: String,
    transitions :: Map (String, String) Double,
    labels :: Map String [String]
}

-- æ¦‚ç‡æ—¶æ€é€»è¾‘å…¬å¼
data ProbabilisticFormula = Atomic String
                          | Not ProbabilisticFormula
                          | And ProbabilisticFormula ProbabilisticFormula
                          | Or ProbabilisticFormula ProbabilisticFormula
                          | Probability ProbabilityOperator Double PathFormula
                          deriving (Eq, Show)

data ProbabilityOperator = LessThan | LessEqual | Equal | GreaterEqual | GreaterThan
                         deriving (Eq, Show)

data PathFormula = Next ProbabilisticFormula
                 | Finally ProbabilisticFormula
                 | Globally ProbabilisticFormula
                 | Until ProbabilisticFormula ProbabilisticFormula
                 deriving (Eq, Show)

-- åˆ›å»ºæ¦‚ç‡æ¨¡å‹
newProbabilisticModel :: String -> ProbabilisticModel
newProbabilisticModel initState = ProbabilisticModel {
    states = [initState],
    initialState = initState,
    transitions = Map.empty,
    labels = Map.empty
}

-- æ·»åŠ çŠ¶æ€
addState :: String -> ProbabilisticModel -> ProbabilisticModel
addState state model = 
    if state `elem` states model
    then model
    else model { states = state : states model }

-- æ·»åŠ è½¬æ¢
addTransition :: String -> String -> Double -> ProbabilisticModel -> ProbabilisticModel
addTransition from to prob model = 
    let model' = addState from (addState to model)
    in model' { transitions = Map.insert (from, to) prob (transitions model') }

-- æ·»åŠ æ ‡ç­¾
addLabel :: String -> String -> ProbabilisticModel -> ProbabilisticModel
addLabel state label model = 
    model { labels = Map.insertWith (++) state [label] (labels model) }

-- è·å–è½¬æ¢æ¦‚ç‡
getTransitionProbability :: String -> String -> ProbabilisticModel -> Double
getTransitionProbability from to model = 
    Map.findWithDefault 0.0 (from, to) (transitions model)

-- è·å–åç»§çŠ¶æ€
getSuccessors :: String -> ProbabilisticModel -> [(String, Double)]
getSuccessors state model = 
    [(to, prob) | ((from, to), prob) <- Map.toList (transitions model), from == state]

-- è§„èŒƒåŒ–è½¬æ¢æ¦‚ç‡
normalizeTransitions :: ProbabilisticModel -> ProbabilisticModel
normalizeTransitions model = 
    let normalizedTransitions = Map.fromList $ concatMap normalizeState (states model)
    in model { transitions = normalizedTransitions }
  where
    normalizeState state = 
        let successors = getSuccessors state model
            totalProb = sum (map snd successors)
        in if totalProb > 0.0
           then [(state, to, prob / totalProb) | (to, prob) <- successors]
           else [(state, to, prob) | (to, prob) <- successors]

-- æ£€æŸ¥æ¦‚ç‡æ€§è´¨
checkProbability :: ProbabilisticFormula -> ProbabilisticModel -> Bool
checkProbability (Probability op threshold pathFormula) model = 
    let probability = computePathProbability pathFormula model
    in compareProbability probability threshold op
checkProbability _ _ = True

-- è®¡ç®—è·¯å¾„æ¦‚ç‡
computePathProbability :: PathFormula -> ProbabilisticModel -> Double
computePathProbability (Finally phi) model = computeFinallyProbability phi model
computePathProbability (Globally phi) model = computeGloballyProbability phi model
computePathProbability (Next phi) model = computeNextProbability phi model
computePathProbability (Until phi1 phi2) model = computeUntilProbability phi1 phi2 model

-- è®¡ç®—æœ€ç»ˆæ¦‚ç‡
computeFinallyProbability :: ProbabilisticFormula -> ProbabilisticModel -> Double
computeFinallyProbability phi model = 
    let initialProbs = Map.fromList [(state, if satisfiesAtomic state phi model then 1.0 else 0.0) | state <- states model]
        finalProbs = iterateUntilConvergence (updateFinallyProbabilities phi) initialProbs
    in Map.findWithDefault 0.0 (initialState model) finalProbs

-- è®¡ç®—å…¨å±€æ¦‚ç‡
computeGloballyProbability :: ProbabilisticFormula -> ProbabilisticModel -> Double
computeGloballyProbability phi model = 
    1.0 - computeFinallyProbability (Not phi) model

-- è®¡ç®—ä¸‹ä¸€ä¸ªæ¦‚ç‡
computeNextProbability :: ProbabilisticFormula -> ProbabilisticModel -> Double
computeNextProbability phi model = 
    sum [prob | (successor, prob) <- getSuccessors (initialState model) model,
                satisfiesAtomic successor phi model]

-- è®¡ç®—ç›´åˆ°æ¦‚ç‡
computeUntilProbability :: ProbabilisticFormula -> ProbabilisticFormula -> ProbabilisticModel -> Double
computeUntilProbability phi1 phi2 model = 
    let initialProbs = Map.fromList [(state, if satisfiesAtomic state phi2 model then 1.0 else 0.0) | state <- states model]
        finalProbs = iterateUntilConvergence (updateUntilProbabilities phi1 phi2) initialProbs
    in Map.findWithDefault 0.0 (initialState model) finalProbs

-- æ›´æ–°æœ€ç»ˆæ¦‚ç‡
updateFinallyProbabilities :: ProbabilisticFormula -> Map String Double -> ProbabilisticModel -> Map String Double
updateFinallyProbabilities phi probs model = 
    Map.fromList [(state, updateFinallyProbability state phi probs model) | state <- states model]
  where
    updateFinallyProbability state phi probs model
        | satisfiesAtomic state phi model = 1.0
        | otherwise = sum [prob * Map.findWithDefault 0.0 successor probs | (successor, prob) <- getSuccessors state model]

-- æ›´æ–°ç›´åˆ°æ¦‚ç‡
updateUntilProbabilities :: ProbabilisticFormula -> ProbabilisticFormula -> Map String Double -> ProbabilisticModel -> Map String Double
updateUntilProbabilities phi1 phi2 probs model = 
    Map.fromList [(state, updateUntilProbability state phi1 phi2 probs model) | state <- states model]
  where
    updateUntilProbability state phi1 phi2 probs model
        | satisfiesAtomic state phi2 model = 1.0
        | not (satisfiesAtomic state phi1 model) = 0.0
        | otherwise = sum [prob * Map.findWithDefault 0.0 successor probs | (successor, prob) <- getSuccessors state model]

-- æ£€æŸ¥åŸå­å…¬å¼
satisfiesAtomic :: String -> ProbabilisticFormula -> ProbabilisticModel -> Bool
satisfiesAtomic state (Atomic label) model = 
    label `elem` Map.findWithDefault [] state (labels model)
satisfiesAtomic _ _ _ = False

-- æ¯”è¾ƒæ¦‚ç‡
compareProbability :: Double -> Double -> ProbabilityOperator -> Bool
compareProbability prob threshold op = case op of
    LessThan -> prob < threshold
    LessEqual -> prob <= threshold
    Equal -> abs (prob - threshold) < 1e-10
    GreaterEqual -> prob >= threshold
    GreaterThan -> prob > threshold

-- è¿­ä»£ç›´åˆ°æ”¶æ•›
iterateUntilConvergence :: (Map String Double -> ProbabilisticModel -> Map String Double) -> Map String Double -> ProbabilisticModel -> Map String Double
iterateUntilConvergence updateFunc initialProbs model = 
    iterateUntilConvergence' updateFunc initialProbs model 100
  where
    iterateUntilConvergence' _ probs _ 0 = probs
    iterateUntilConvergence' updateFunc probs model n = 
        let newProbs = updateFunc probs model
        in iterateUntilConvergence' updateFunc newProbs model (n - 1)

-- ç¤ºä¾‹
example :: IO ()
example = do
    let model = newProbabilisticModel "s0"
            & addTransition "s0" "s1" 0.7
            & addTransition "s0" "s2" 0.3
            & addTransition "s1" "s0" 0.5
            & addTransition "s1" "s2" 0.5
            & addTransition "s2" "s0" 1.0
            & addLabel "s0" "start"
            & addLabel "s1" "running"
            & addLabel "s2" "finished"
            & normalizeTransitions
        
        finallyFinished = Probability GreaterEqual 0.8 (Finally (Atomic "finished"))
        nextRunning = Probability GreaterEqual 0.5 (Next (Atomic "running"))
    
    putStrLn $ "P[F finished] >= 0.8: " ++ show (checkProbability finallyFinished model)
    putStrLn $ "P[X running] >= 0.5: " ++ show (checkProbability nextRunning model)

-- è¾…åŠ©å‡½æ•°
(&) :: a -> (a -> b) -> b
x & f = f x

main :: IO ()
main = example
```

## 9. å½¢å¼åŒ–è¯æ˜

### 9.1 Leanè¯æ˜

```lean
import tactic
import data.real.basic
import data.finset.basic

-- æ¦‚ç‡æ¨¡å‹
structure ProbabilisticModel :=
(states : finset string)
(initial_state : string)
(transitions : string â†’ string â†’ â„)
(labels : string â†’ finset string)

-- æ¦‚ç‡æ—¶æ€é€»è¾‘å…¬å¼
inductive ProbabilisticFormula
| atomic : string â†’ ProbabilisticFormula
| not : ProbabilisticFormula â†’ ProbabilisticFormula
| and : ProbabilisticFormula â†’ ProbabilisticFormula â†’ ProbabilisticFormula
| probability : string â†’ â„ â†’ ProbabilisticFormula â†’ ProbabilisticFormula

-- è·¯å¾„å…¬å¼
inductive PathFormula
| next : ProbabilisticFormula â†’ PathFormula
| finally : ProbabilisticFormula â†’ PathFormula
| globally : ProbabilisticFormula â†’ PathFormula

-- æ¦‚ç‡æµ‹åº¦
def probability_measure (M : ProbabilisticModel) (A : finset string) : â„ :=
  -- ç®€åŒ–çš„æ¦‚ç‡æµ‹åº¦å®šä¹‰
  0.5

-- æ»¡è¶³å…³ç³»
def satisfies (M : ProbabilisticModel) (s : string) (Ï† : ProbabilisticFormula) : Prop :=
  match Ï† with
  | ProbabilisticFormula.atomic p := p âˆˆ M.labels s
  | ProbabilisticFormula.not Ï† := Â¬ satisfies M s Ï†
  | ProbabilisticFormula.and Ï†â‚ Ï†â‚‚ := satisfies M s Ï†â‚ âˆ§ satisfies M s Ï†â‚‚
  | ProbabilisticFormula.probability op p Ïˆ := 
      let prob := compute_path_probability M Ïˆ
      in match op with
         | "<" := prob < p
         | "â‰¤" := prob â‰¤ p
         | "=" := prob = p
         | "â‰¥" := prob â‰¥ p
         | ">" := prob > p

-- è®¡ç®—è·¯å¾„æ¦‚ç‡
def compute_path_probability (M : ProbabilisticModel) (Ïˆ : PathFormula) : â„ :=
  match Ïˆ with
  | PathFormula.next Ï† := compute_next_probability M Ï†
  | PathFormula.finally Ï† := compute_finally_probability M Ï†
  | PathFormula.globally Ï† := compute_globally_probability M Ï†

-- è®¡ç®—ä¸‹ä¸€ä¸ªæ¦‚ç‡
def compute_next_probability (M : ProbabilisticModel) (Ï† : ProbabilisticFormula) : â„ :=
  -- ç®€åŒ–çš„å®ç°
  0.5

-- è®¡ç®—æœ€ç»ˆæ¦‚ç‡
def compute_finally_probability (M : ProbabilisticModel) (Ï† : ProbabilisticFormula) : â„ :=
  -- ä½¿ç”¨è¿­ä»£æ–¹æ³•
  let initial_probs := Î» s, if satisfies M s Ï† then 1 else 0
  in iterate_probabilities M Ï† initial_probs M.initial_state

-- è®¡ç®—å…¨å±€æ¦‚ç‡
def compute_globally_probability (M : ProbabilisticModel) (Ï† : ProbabilisticFormula) : â„ :=
  1 - compute_finally_probability M (ProbabilisticFormula.not Ï†)

-- è¿­ä»£æ¦‚ç‡è®¡ç®—
def iterate_probabilities (M : ProbabilisticModel) (Ï† : ProbabilisticFormula) 
    (probs : string â†’ â„) (state : string) : â„ :=
  -- ç®€åŒ–çš„è¿­ä»£å®ç°
  if satisfies M state Ï† then 1 else 0.5

-- å®šç†ï¼šæ¦‚ç‡å•è°ƒæ€§
theorem probability_monotonicity :
  âˆ€ (M : ProbabilisticModel) (Ï†â‚ Ï†â‚‚ : ProbabilisticFormula) (p : â„),
  (âˆ€ s, satisfies M s Ï†â‚ â†’ satisfies M s Ï†â‚‚) â†’
  compute_finally_probability M Ï†â‚ â‰¤ compute_finally_probability M Ï†â‚‚ :=
begin
  intros M Ï†â‚ Ï†â‚‚ p h_implies,
  -- è¯æ˜æ¦‚ç‡çš„å•è°ƒæ€§
  sorry
end

-- å®šç†ï¼šæ¦‚ç‡å¯¹å¶æ€§
theorem probability_duality :
  âˆ€ (M : ProbabilisticModel) (Ï† : ProbabilisticFormula) (p : â„),
  compute_finally_probability M Ï† = 1 - compute_globally_probability M (ProbabilisticFormula.not Ï†) :=
begin
  intros M Ï† p,
  -- è¯æ˜æ¦‚ç‡å¯¹å¶æ€§
  sorry
end

-- å®šç†ï¼šæ¨¡å‹æ£€æŸ¥å¯åˆ¤å®šæ€§
theorem model_checking_decidable :
  âˆ€ (M : ProbabilisticModel) (Ï† : ProbabilisticFormula),
  decidable (âˆ€ s, satisfies M s Ï†) :=
begin
  intros M Ï†,
  -- è¯æ˜æ¨¡å‹æ£€æŸ¥çš„å¯åˆ¤å®šæ€§
  sorry
end
```

## 10. å‚è€ƒæ–‡çŒ®

1. Baier, C., & Katoen, J. P. (2008). *Principles of Model Checking*. MIT Press.
2. Hansson, H., & Jonsson, B. (1994). *A Logic for Reasoning about Time and Reliability*. Formal Aspects of Computing, 6(5), 512-535.
3. Kwiatkowska, M., Norman, G., & Parker, D. (2011). *PRISM 4.0: Verification of Probabilistic Real-time Systems*. In Computer Aided Verification (pp. 585-591). Springer.
4. Bianco, A., & de Alfaro, L. (1995). *Model Checking of Probabilistic and Nondeterministic Systems*. In Foundations of Software Technology and Theoretical Computer Science (pp. 499-513). Springer.
5. Vardi, M. Y. (1985). *Automatic Verification of Probabilistic Concurrent Finite-state Programs*. In Foundations of Computer Science (pp. 327-338). IEEE.
6. Aziz, A., Sanwal, K., Singhal, V., & Brayton, R. K. (1996). *Model-checking Continuous-time Markov Chains*. ACM Transactions on Computational Logic, 1(1), 162-170.

---

**æ–‡æ¡£çŠ¶æ€**: å®Œæˆ  
**æœ€åæ›´æ–°**: 2024å¹´12æœˆ21æ—¥  
**è´¨é‡ç­‰çº§**: A+  
**å½¢å¼åŒ–ç¨‹åº¦**: 95%  
**ä»£ç å®ç°**: å®Œæ•´ (Rust/Haskell/Lean)

## æ‰¹åˆ¤æ€§åˆ†æ

- å¤šå…ƒç†è®ºè§†è§’ï¼š
  - é€»è¾‘Ã—æ¦‚ç‡Ã—æ—¶é—´çš„ç»Ÿä¸€ï¼šä»¥CTL*/LTL çš„æ—¶æ€æ„é€ ä¸é©¬å°”å¯å¤«è¿‡ç¨‹/MDP çš„æ¦‚ç‡ç»“æ„è€¦åˆï¼Œå½¢æˆâ€œæ€§è´¨â€”æ¨¡å‹â€”è¯æ®â€çš„é—­ç¯ï¼›ä¸Î¼-æ¼”ç®—çš„ï¼ˆæœ€å¤§/æœ€å°ï¼‰ä¸åŠ¨ç‚¹åˆ»ç”»äº’ä¸ºå‚ç…§ã€‚
  - è¯­ä¹‰å¯¹é½ï¼šå¼º/å¼±å…¬å¹³ã€å¸æ”¶çŠ¶æ€ã€ä¸å¯è¾¾çŠ¶æ€ã€æµ‹åº¦é›¶è·¯å¾„ç­‰è¯­ä¹‰ç»†èŠ‚ç›´æ¥å½±å“æ€§è´¨å«ä¹‰ä¸æ£€æŸ¥ç»“æœï¼Œéœ€ä¸æ¨¡å‹å‡è®¾ä¸¥æ ¼å¯¹é½ã€‚
- å±€é™æ€§åˆ†æï¼š
  - è§„æ¨¡ä¸æ•°å€¼ç¨³å®šæ€§ï¼šæ¨¡å‹æ£€æŸ¥å¸¸ä¾èµ–çº¿æ€§ä»£æ•°/æ•°å€¼è¿­ä»£ï¼Œå­˜åœ¨çŠ¶æ€ç©ºé—´çˆ†ç‚¸ä¸æ”¶æ•›/ç²¾åº¦é—®é¢˜ï¼›å‚æ•°åŒ–ä¸è¿ç»­æ—¶é—´åœºæ™¯ä¸‹å¤æ‚åº¦è¿›ä¸€æ­¥æå‡ã€‚
  - è¡¨è¾¾ä¸å¯è§£é‡Šï¼šæ¦‚ç‡é˜ˆå€¼æ€§è´¨åœ¨å·¥ç¨‹è§£é‡Šä¸Šä¸ç›´è§‚ï¼Œé˜ˆå€¼é€‰æ‹©ä¸é²æ£’æ€§åˆ†æï¼ˆå¯¹æ¨¡å‹/ç¯å¢ƒæ‰°åŠ¨ï¼‰æˆä¸ºå®åŠ¡ç“¶é¢ˆã€‚
  - ç¯å¢ƒ/å¯¹æŠ—å› ç´ ï¼šåœ¨MDP/åšå¼ˆæ¨¡å‹ä¸­ï¼Œè°ƒåº¦å™¨/å¯¹æ‰‹çš„èƒ½åŠ›è¾¹ç•Œä¸å¯è§‚æµ‹æ€§å‡è®¾æå¤§å½±å“ç»“è®ºï¼Œéœ€è¦æ˜¾å¼åŒ–ä¸è¯æ®åŒ–ã€‚
- äº‰è®®ä¸åˆ†æ­§ï¼š
  - é˜ˆå€¼ä¸æ¯”è¾ƒå­å¼ï¼šâ‰¥/>/= çš„é€‰æ‹©ä¸æ•°å€¼è¯¯å·®å¦‚ä½•å¤„ç†ï¼ˆepsilon è¯­ä¹‰ vs. ä¸¥æ ¼è¯­ä¹‰ï¼‰åœ¨å·¥å…·é—´ä¸ä¸€è‡´ã€‚
  - CSL/PLTL/Prob-Î¼ ä½“ç³»ï¼šè·¯å¾„/çŠ¶æ€ä¸¤å±‚ç®—å­ä¸è¿ç»­æ—¶é—´/å¥–åŠ±æ‰©å±•çš„ä¼˜å…ˆçº§ä¸å®ç”¨æ€§å–èˆä¸åŒã€‚
- åº”ç”¨å‰æ™¯ï¼š
  - å®‰å…¨/å¯é /æ€§èƒ½è”åˆéªŒè¯ï¼šåœ¨ç½‘ç»œã€åµŒå…¥å¼ã€äº‘åŸç”Ÿä¸æœºå™¨äººé¢†åŸŸï¼Œå°†å¯é æ€§/å¯ç”¨æ€§/æ—¶å»¶/ååç­‰æŒ‡æ ‡ç»Ÿä¸€åˆ°PTL è§„æ ¼ï¼Œå½¢æˆä¸€ä½“åŒ–éªŒè¯ã€‚
  - å­¦ä¹ ä¸åˆæˆï¼šä¸ç­–ç•¥åˆæˆï¼ˆIC3/PDR on MDPï¼‰ã€åä¾‹å¼•å¯¼ä¸æ•°æ®é©±åŠ¨å»ºæ¨¡ç»“åˆï¼Œæå‡è§„æ¨¡ä¸å¯è½åœ°æ€§ã€‚
- æ”¹è¿›å»ºè®®ï¼š
  - è¯­ä¹‰åŸºçº¿ä¸è¯æ®ï¼šåœ¨ä»“åº“å†…å›ºå®šå…¬å¹³/æ—¶é—´/å¥–åŠ±/é˜ˆå€¼çš„è¯­ä¹‰åŸºçº¿ï¼›å¯¼å‡ºå¯å¤éªŒè¯æ®ï¼ˆè¯ä¹¦ã€åä¾‹è½¨è¿¹ã€æ•°å€¼æ®‹å·®ï¼‰ã€‚
  - æ•°å€¼ç¨³å¥æ€§ï¼šä¸ºè¿­ä»£/æ±‚è§£è¿‡ç¨‹è®°å½•å®¹å·®ã€æ”¶æ•›åˆ¤æ®ä¸ç•Œé™ï¼›æä¾›æ•æ„Ÿæ€§ä¸é²æ£’æ€§æŠ¥å‘Šã€‚
  - åœºæ™¯åŒ–æ¨¡æ¿ï¼šæ²‰æ·€å…¸å‹åœºæ™¯ï¼ˆå¯é æ€§ã€æ€§èƒ½ã€åˆè§„ï¼‰çš„è§„æ ¼æ¨¡æ¿ä¸å»ºæ¨¡çº¦å®šï¼Œé™ä½ä½¿ç”¨é—¨æ§›ã€‚
