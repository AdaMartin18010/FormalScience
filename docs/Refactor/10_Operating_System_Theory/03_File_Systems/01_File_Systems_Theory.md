# 10.3.1 æ–‡ä»¶ç³»ç»Ÿç†è®º

## ğŸ“‹ æ¦‚è¿°

æ–‡ä»¶ç³»ç»Ÿç†è®ºç ”ç©¶æ“ä½œç³»ç»Ÿä¸­æ–‡ä»¶çš„ç»„ç»‡ã€å­˜å‚¨ã€è®¿é—®å’Œç®¡ç†æœºåˆ¶ã€‚è¯¥ç†è®ºæ¶µç›–æ–‡ä»¶ç»“æ„ã€ç›®å½•ç»„ç»‡ã€å­˜å‚¨åˆ†é…ã€æ–‡ä»¶ä¿æŠ¤ç­‰æ ¸å¿ƒæ¦‚å¿µï¼Œä¸ºæ•°æ®æŒä¹…åŒ–æä¾›ç†è®ºåŸºç¡€ã€‚

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æ–‡ä»¶ç³»ç»Ÿå®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆæ–‡ä»¶ç³»ç»Ÿï¼‰
æ–‡ä»¶ç³»ç»Ÿæ˜¯æ“ä½œç³»ç»Ÿç”¨äºç®¡ç†æ–‡ä»¶å’Œç›®å½•çš„è½¯ä»¶ç»„ä»¶ï¼Œæä¾›æ•°æ®çš„æŒä¹…åŒ–å­˜å‚¨ã€‚

### 1.2 æ–‡ä»¶ç³»ç»Ÿç±»å‹åˆ†ç±»

| ç±»å‹         | è‹±æ–‡åç§°         | æè¿°                         | å…¸å‹ä»£è¡¨         |
|--------------|------------------|------------------------------|------------------|
| FAT          | File Allocation  | æ–‡ä»¶åˆ†é…è¡¨ç³»ç»Ÿ               | FAT32, exFAT     |
| NTFS         | New Technology   | æ–°æŠ€æœ¯æ–‡ä»¶ç³»ç»Ÿ               | Windows NT       |
| ext          | Extended         | æ‰©å±•æ–‡ä»¶ç³»ç»Ÿ                 | Linux            |
| ZFS          | Zettabyte        | ç°ä»£æ–‡ä»¶ç³»ç»Ÿ                 | Solaris, FreeBSD |

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 æ–‡ä»¶ç»“æ„

**å®šä¹‰ 2.1**ï¼ˆæ–‡ä»¶ï¼‰
æ–‡ä»¶æ˜¯å­˜å‚¨åœ¨å­˜å‚¨è®¾å¤‡ä¸Šçš„å‘½åæ•°æ®é›†åˆï¼Œå…·æœ‰ç‰¹å®šçš„ç»“æ„å’Œå±æ€§ã€‚

### 2.2 ç›®å½•ç»“æ„

**å®šä¹‰ 2.2**ï¼ˆç›®å½•ï¼‰
ç›®å½•æ˜¯åŒ…å«æ–‡ä»¶å’Œå…¶ä»–ç›®å½•çš„å®¹å™¨ï¼Œå½¢æˆå±‚æ¬¡åŒ–çš„æ–‡ä»¶ç»„ç»‡ã€‚

### 2.3 å­˜å‚¨åˆ†é…

**å®šä¹‰ 2.3**ï¼ˆå­˜å‚¨åˆ†é…ï¼‰
å­˜å‚¨åˆ†é…æ˜¯æ–‡ä»¶ç³»ç»Ÿå°†æ–‡ä»¶æ•°æ®æ˜ å°„åˆ°ç‰©ç†å­˜å‚¨å—çš„è¿‡ç¨‹ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 æ–‡ä»¶ç³»ç»Ÿä¸€è‡´æ€§å®šç†

**å®šç† 3.1**ï¼ˆæ–‡ä»¶ç³»ç»Ÿä¸€è‡´æ€§ï¼‰
è‹¥æ–‡ä»¶ç³»ç»Ÿåœ¨å´©æºƒåèƒ½æ¢å¤åˆ°ä¸€è‡´çŠ¶æ€ï¼Œåˆ™ç§°å…¶å…·æœ‰ä¸€è‡´æ€§ã€‚

**è¯æ˜**ï¼š
é€šè¿‡æ—¥å¿—è®°å½•ã€å†™æ—¶å¤åˆ¶ç­‰æŠ€æœ¯ï¼Œç¡®ä¿æ–‡ä»¶ç³»ç»Ÿæ“ä½œçš„åŸå­æ€§ã€‚â–¡

### 3.2 å­˜å‚¨æ•ˆç‡å®šç†

**å®šç† 3.2**ï¼ˆå­˜å‚¨æ•ˆç‡ï¼‰
æ–‡ä»¶ç³»ç»Ÿçš„å­˜å‚¨æ•ˆç‡å—å—å¤§å°å’Œæ–‡ä»¶å¤§å°åˆ†å¸ƒå½±å“ã€‚

**è¯æ˜**ï¼š
è®¾å—å¤§å°ä¸º $B$ï¼Œæ–‡ä»¶å¤§å°ä¸º $F$ï¼Œåˆ™å†…éƒ¨ç¢ç‰‡ä¸º $B - (F \bmod B)$ã€‚â–¡

## 4. Rustä»£ç å®ç°

### 4.1 æ–‡ä»¶ç³»ç»ŸåŸºæœ¬ç»“æ„

```rust
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Debug, Clone)]
pub struct FileMetadata {
    pub name: String,
    pub size: usize,
    pub created_time: u64,
    pub modified_time: u64,
    pub permissions: FilePermissions,
    pub file_type: FileType,
}

#[derive(Debug, Clone)]
pub struct FilePermissions {
    pub owner_read: bool,
    pub owner_write: bool,
    pub owner_execute: bool,
    pub group_read: bool,
    pub group_write: bool,
    pub group_execute: bool,
    pub other_read: bool,
    pub other_write: bool,
    pub other_execute: bool,
}

#[derive(Debug, Clone)]
pub enum FileType {
    Regular,
    Directory,
    SymbolicLink,
    Device,
}

impl FileMetadata {
    pub fn new(name: String, file_type: FileType) -> Self {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        FileMetadata {
            name,
            size: 0,
            created_time: now,
            modified_time: now,
            permissions: FilePermissions::default(),
            file_type,
        }
    }
}

impl Default for FilePermissions {
    fn default() -> Self {
        FilePermissions {
            owner_read: true,
            owner_write: true,
            owner_execute: false,
            group_read: true,
            group_write: false,
            group_execute: false,
            other_read: true,
            other_write: false,
            other_execute: false,
        }
    }
}

#[derive(Debug, Clone)]
pub struct File {
    pub metadata: FileMetadata,
    pub data: Vec<u8>,
    pub blocks: Vec<usize>,
}

impl File {
    pub fn new(name: String, file_type: FileType) -> Self {
        File {
            metadata: FileMetadata::new(name, file_type),
            data: Vec::new(),
            blocks: Vec::new(),
        }
    }
    
    pub fn write(&mut self, data: &[u8]) {
        self.data = data.to_vec();
        self.metadata.size = data.len();
        self.metadata.modified_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
    }
    
    pub fn read(&self) -> &[u8] {
        &self.data
    }
    
    pub fn append(&mut self, data: &[u8]) {
        self.data.extend_from_slice(data);
        self.metadata.size = self.data.len();
        self.metadata.modified_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
    }
}
```

### 4.2 ç›®å½•ç³»ç»Ÿå®ç°

```rust
use std::collections::HashMap;
use std::path::{Path, PathBuf};

#[derive(Debug, Clone)]
pub struct Directory {
    pub metadata: FileMetadata,
    pub entries: HashMap<String, DirectoryEntry>,
}

#[derive(Debug, Clone)]
pub enum DirectoryEntry {
    File(File),
    Directory(Directory),
    SymLink(String), // ç›®æ ‡è·¯å¾„
}

impl Directory {
    pub fn new(name: String) -> Self {
        Directory {
            metadata: FileMetadata::new(name, FileType::Directory),
            entries: HashMap::new(),
        }
    }
    
    pub fn add_file(&mut self, file: File) -> Result<(), String> {
        let name = file.metadata.name.clone();
        if self.entries.contains_key(&name) {
            return Err(format!("File {} already exists", name));
        }
        self.entries.insert(name, DirectoryEntry::File(file));
        Ok(())
    }
    
    pub fn add_directory(&mut self, dir: Directory) -> Result<(), String> {
        let name = dir.metadata.name.clone();
        if self.entries.contains_key(&name) {
            return Err(format!("Directory {} already exists", name));
        }
        self.entries.insert(name, DirectoryEntry::Directory(dir));
        Ok(())
    }
    
    pub fn remove(&mut self, name: &str) -> Result<DirectoryEntry, String> {
        self.entries.remove(name)
            .ok_or_else(|| format!("Entry {} not found", name))
    }
    
    pub fn get(&self, name: &str) -> Option<&DirectoryEntry> {
        self.entries.get(name)
    }
    
    pub fn list(&self) -> Vec<String> {
        self.entries.keys().cloned().collect()
    }
}

#[derive(Debug, Clone)]
pub struct FileSystem {
    pub root: Directory,
    pub current_directory: PathBuf,
    pub block_size: usize,
    pub total_blocks: usize,
    pub free_blocks: Vec<bool>,
}

impl FileSystem {
    pub fn new(block_size: usize, total_blocks: usize) -> Self {
        FileSystem {
            root: Directory::new("/".to_string()),
            current_directory: PathBuf::from("/"),
            block_size,
            total_blocks,
            free_blocks: vec![true; total_blocks],
        }
    }
    
    pub fn create_file(&mut self, path: &Path, data: &[u8]) -> Result<(), String> {
        let mut current = &mut self.root;
        let path_components: Vec<_> = path.iter().collect();
        
        // å¯¼èˆªåˆ°çˆ¶ç›®å½•
        for component in &path_components[..path_components.len()-1] {
            if let Some(DirectoryEntry::Directory(ref mut dir)) = 
                current.entries.get_mut(component.to_str().unwrap()) {
                current = dir;
            } else {
                return Err(format!("Path component {:?} is not a directory", component));
            }
        }
        
        // åˆ›å»ºæ–‡ä»¶
        let file_name = path_components.last().unwrap().to_str().unwrap();
        let mut file = File::new(file_name.to_string(), FileType::Regular);
        file.write(data);
        
        // åˆ†é…å­˜å‚¨å—
        let blocks_needed = (data.len() + self.block_size - 1) / self.block_size;
        for _ in 0..blocks_needed {
            if let Some(block_index) = self.allocate_block() {
                file.blocks.push(block_index);
            } else {
                return Err("No free blocks available".to_string());
            }
        }
        
        current.add_file(file)
    }
    
    pub fn read_file(&self, path: &Path) -> Result<Vec<u8>, String> {
        let mut current = &self.root;
        let path_components: Vec<_> = path.iter().collect();
        
        // å¯¼èˆªåˆ°æ–‡ä»¶
        for component in &path_components[..path_components.len()-1] {
            if let Some(DirectoryEntry::Directory(ref dir)) = 
                current.entries.get(component.to_str().unwrap()) {
                current = dir;
            } else {
                return Err(format!("Path component {:?} is not a directory", component));
            }
        }
        
        let file_name = path_components.last().unwrap().to_str().unwrap();
        if let Some(DirectoryEntry::File(ref file)) = current.entries.get(file_name) {
            Ok(file.read().to_vec())
        } else {
            Err(format!("File {} not found", file_name))
        }
    }
    
    pub fn list_directory(&self, path: &Path) -> Result<Vec<String>, String> {
        let mut current = &self.root;
        
        for component in path.iter() {
            if let Some(DirectoryEntry::Directory(ref dir)) = 
                current.entries.get(component.to_str().unwrap()) {
                current = dir;
            } else {
                return Err(format!("Path component {:?} is not a directory", component));
            }
        }
        
        Ok(current.list())
    }
    
    fn allocate_block(&mut self) -> Option<usize> {
        for (index, &free) in self.free_blocks.iter().enumerate() {
            if free {
                self.free_blocks[index] = false;
                return Some(index);
            }
        }
        None
    }
    
    pub fn get_free_space(&self) -> usize {
        self.free_blocks.iter().filter(|&&free| free).count() * self.block_size
    }
    
    pub fn get_total_space(&self) -> usize {
        self.total_blocks * self.block_size
    }
}
```

### 4.3 æ–‡ä»¶ç³»ç»Ÿæ—¥å¿—å®ç°

```rust
use std::collections::VecDeque;

#[derive(Debug, Clone)]
pub enum LogEntry {
    CreateFile { path: String, size: usize },
    WriteFile { path: String, offset: usize, data: Vec<u8> },
    DeleteFile { path: String },
    CreateDirectory { path: String },
    DeleteDirectory { path: String },
}

#[derive(Debug, Clone)]
pub struct FileSystemLog {
    pub entries: VecDeque<LogEntry>,
    pub max_entries: usize,
    pub checkpoint_interval: usize,
}

impl FileSystemLog {
    pub fn new(max_entries: usize, checkpoint_interval: usize) -> Self {
        FileSystemLog {
            entries: VecDeque::new(),
            max_entries,
            checkpoint_interval,
        }
    }
    
    pub fn add_entry(&mut self, entry: LogEntry) {
        self.entries.push_back(entry);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ¸…ç†æ—¥å¿—
        if self.entries.len() > self.max_entries {
            self.entries.pop_front();
        }
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ›å»ºæ£€æŸ¥ç‚¹
        if self.entries.len() % self.checkpoint_interval == 0 {
            self.create_checkpoint();
        }
    }
    
    pub fn create_checkpoint(&mut self) {
        // å°†å½“å‰æ–‡ä»¶ç³»ç»ŸçŠ¶æ€å†™å…¥æ£€æŸ¥ç‚¹
        // æ¸…ç©ºæ—¥å¿—æ¡ç›®
        self.entries.clear();
    }
    
    pub fn recover(&self) -> Vec<LogEntry> {
        // ä»æ£€æŸ¥ç‚¹æ¢å¤ï¼Œç„¶åé‡æ”¾æ—¥å¿—
        self.entries.iter().cloned().collect()
    }
    
    pub fn get_log_size(&self) -> usize {
        self.entries.len()
    }
}

#[derive(Debug, Clone)]
pub struct JournalingFileSystem {
    pub fs: FileSystem,
    pub log: FileSystemLog,
}

impl JournalingFileSystem {
    pub fn new(block_size: usize, total_blocks: usize) -> Self {
        JournalingFileSystem {
            fs: FileSystem::new(block_size, total_blocks),
            log: FileSystemLog::new(1000, 100),
        }
    }
    
    pub fn create_file(&mut self, path: &Path, data: &[u8]) -> Result<(), String> {
        // è®°å½•æ—¥å¿—æ¡ç›®
        self.log.add_entry(LogEntry::CreateFile {
            path: path.to_string_lossy().to_string(),
            size: data.len(),
        });
        
        // æ‰§è¡Œå®é™…æ“ä½œ
        self.fs.create_file(path, data)
    }
    
    pub fn write_file(&mut self, path: &Path, offset: usize, data: &[u8]) -> Result<(), String> {
        // è®°å½•æ—¥å¿—æ¡ç›®
        self.log.add_entry(LogEntry::WriteFile {
            path: path.to_string_lossy().to_string(),
            offset,
            data: data.to_vec(),
        });
        
        // æ‰§è¡Œå®é™…æ“ä½œ
        // è¿™é‡Œéœ€è¦å®ç°æ–‡ä»¶å†™å…¥é€»è¾‘
        Ok(())
    }
    
    pub fn delete_file(&mut self, path: &Path) -> Result<(), String> {
        // è®°å½•æ—¥å¿—æ¡ç›®
        self.log.add_entry(LogEntry::DeleteFile {
            path: path.to_string_lossy().to_string(),
        });
        
        // æ‰§è¡Œå®é™…æ“ä½œ
        // è¿™é‡Œéœ€è¦å®ç°æ–‡ä»¶åˆ é™¤é€»è¾‘
        Ok(())
    }
    
    pub fn recover(&mut self) {
        // ä»æ—¥å¿—æ¢å¤æ–‡ä»¶ç³»ç»ŸçŠ¶æ€
        let entries = self.log.recover();
        for entry in entries {
            match entry {
                LogEntry::CreateFile { path, size } => {
                    // é‡æ–°åˆ›å»ºæ–‡ä»¶
                    let path = Path::new(&path);
                    let data = vec![0; size];
                    let _ = self.fs.create_file(path, &data);
                },
                LogEntry::WriteFile { path, offset, data } => {
                    // é‡æ–°å†™å…¥æ–‡ä»¶
                    let path = Path::new(&path);
                    let _ = self.write_file(path, offset, &data);
                },
                LogEntry::DeleteFile { path } => {
                    // é‡æ–°åˆ é™¤æ–‡ä»¶
                    let path = Path::new(&path);
                    let _ = self.delete_file(path);
                },
                _ => {
                    // å¤„ç†å…¶ä»–ç±»å‹çš„æ—¥å¿—æ¡ç›®
                }
            }
        }
    }
}
```

## 5. ç›¸å…³ç†è®ºä¸äº¤å‰å¼•ç”¨

- [è¿›ç¨‹ç®¡ç†ç†è®º](../01_Process_Management/01_Process_Management_Theory.md)
- [å†…å­˜ç®¡ç†ç†è®º](../02_Memory_Management/01_Memory_Management_Theory.md)
- [è®¾å¤‡ç®¡ç†ç†è®º](../04_Device_Management/01_Device_Management_Theory.md)

## 6. å‚è€ƒæ–‡çŒ®

1. Silberschatz, A., Galvin, P. B., & Gagne, G. (2018). Operating System Concepts. Wiley.
2. Tanenbaum, A. S., & Bos, H. (2014). Modern Operating Systems. Pearson.
3. McKusick, M. K., & Neville-Neil, G. V. (2014). The Design and Implementation of the FreeBSD Operating System. Addison-Wesley.

---

**æœ€åæ›´æ–°**: 2024å¹´12æœˆ21æ—¥  
**ç»´æŠ¤è€…**: AIåŠ©æ‰‹  
**ç‰ˆæœ¬**: v1.0
