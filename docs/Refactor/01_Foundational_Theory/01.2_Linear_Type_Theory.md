# 01.2 线性类型理论 (Linear Type Theory)

## 目录

```markdown
01.2 线性类型理论
├── 1. 线性逻辑基础
│   ├── 1.1 线性逻辑公理
│   ├── 1.2 线性蕴涵
│   ├── 1.3 线性合取与析取
│   └── 1.4 指数模态
├── 2. 线性类型系统
│   ├── 2.1 线性类型定义
│   ├── 2.2 线性类型判断
│   ├── 2.3 线性类型规则
│   └── 2.4 资源管理
├── 3. 线性λ演算
│   ├── 3.1 线性λ项
│   ├── 3.2 线性归约
│   ├── 3.3 线性类型检查
│   └── 3.4 线性类型推断
├── 4. 语义解释
│   ├── 4.1 指称语义
│   ├── 4.2 操作语义
│   ├── 4.3 资源语义
│   └── 4.4 线性语义
├── 5. 高级特性
│   ├── 5.1 线性多态性
│   ├── 5.2 线性存在类型
│   ├── 5.3 线性递归类型
│   └── 5.4 线性效应系统
├── 6. 实际应用
│   ├── 6.1 内存管理
│   ├── 6.2 并发编程
│   ├── 6.3 量子计算
│   └── 6.4 代码示例
└── 7. 交叉引用
    ├── 7.1 相关理论
    ├── 7.2 应用领域
    ├── 7.3 扩展方向
    └── 7.4 参考文献
```

## 1. 线性逻辑基础

### 1.1 线性逻辑公理

**定义 1.1.1 (线性逻辑)**
线性逻辑是由 Jean-Yves Girard 引入的逻辑系统，其中每个假设必须恰好使用一次。

**公理 1.1.1 (线性恒等)**
$$\frac{}{A \vdash A} \quad \text{(Id)}$$

**公理 1.1.2 (线性交换)**
$$\frac{\Gamma, A, B, \Delta \vdash C}{\Gamma, B, A, \Delta \vdash C} \quad \text{(Exchange)}$$

**公理 1.1.3 (线性弱化)**
$$\frac{\Gamma, \Delta \vdash B}{\Gamma, A, \Delta \vdash B} \quad \text{(Weakening)}$$

**公理 1.1.4 (线性收缩)**
$$\frac{\Gamma, A, A, \Delta \vdash B}{\Gamma, A, \Delta \vdash B} \quad \text{(Contraction)}$$

### 1.2 线性蕴涵

**定义 1.2.1 (线性蕴涵)**
线性蕴涵 $A \multimap B$ 表示从 $A$ 到 $B$ 的线性函数。

**公理 1.2.1 (线性蕴涵引入)**
$$\frac{\Gamma, A \vdash B}{\Gamma \vdash A \multimap B} \quad \text{($\multimap$I)}$$

**公理 1.2.2 (线性蕴涵消除)**
$$\frac{\Gamma \vdash A \multimap B \quad \Delta \vdash A}{\Gamma, \Delta \vdash B} \quad \text{($\multimap$E)}$$

### 1.3 线性合取与析取

**定义 1.3.1 (线性合取)**
线性合取 $A \otimes B$ 表示 $A$ 和 $B$ 的线性乘积。

**公理 1.3.1 (线性合取引入)**
$$\frac{\Gamma \vdash A \quad \Delta \vdash B}{\Gamma, \Delta \vdash A \otimes B} \quad \text{($\otimes$I)}$$

**公理 1.3.2 (线性合取消除)**
$$\frac{\Gamma \vdash A \otimes B \quad \Delta, A, B \vdash C}{\Gamma, \Delta \vdash C} \quad \text{($\otimes$E)}$$

**定义 1.3.2 (线性析取)**
线性析取 $A \& B$ 表示 $A$ 和 $B$ 的线性和。

**公理 1.3.3 (线性析取引入)**
$$\frac{\Gamma \vdash A \quad \Gamma \vdash B}{\Gamma \vdash A \& B} \quad \text{($\&$I)}$$

**公理 1.3.4 (线性析取消除)**
$$\frac{\Gamma \vdash A \& B}{\Gamma \vdash A} \quad \text{($\&$E$_1$)}$$

$$\frac{\Gamma \vdash A \& B}{\Gamma \vdash B} \quad \text{($\&$E$_2$)}$$

### 1.4 指数模态

**定义 1.4.1 (指数模态)**
指数模态 $!A$ 表示可以任意次使用的 $A$。

**公理 1.4.1 (指数引入)**
$$\frac{!A_1, \ldots, !A_n \vdash B}{!A_1, \ldots, !A_n \vdash !B} \quad \text{(!I)}$$

**公理 1.4.2 (指数消除)**
$$\frac{\Gamma \vdash !A}{\Gamma \vdash A} \quad \text{(!E)}$$

**公理 1.4.3 (指数弱化)**
$$\frac{\Gamma \vdash B}{\Gamma, !A \vdash B} \quad \text{(!W)}$$

**公理 1.4.4 (指数收缩)**
$$\frac{\Gamma, !A, !A \vdash B}{\Gamma, !A \vdash B} \quad \text{(!C)}$$

## 2. 线性类型系统

### 2.1 线性类型定义

**定义 2.1.1 (线性类型)**
线性类型系统是建立在线性逻辑基础上的类型系统。

**语法定义：**
$$\tau ::= \alpha \mid \tau_1 \multimap \tau_2 \mid \tau_1 \otimes \tau_2 \mid \tau_1 \& \tau_2 \mid !\tau$$

**定义 2.1.2 (线性上下文)**
线性上下文 $\Gamma$ 是变量到线性类型的映射，每个变量最多出现一次。

### 2.2 线性类型判断

**定义 2.2.1 (线性类型判断)**
线性类型判断形如 $\Gamma \vdash e : \tau$，表示在上下文 $\Gamma$ 中，表达式 $e$ 具有线性类型 $\tau$。

**定义 2.2.2 (线性上下文分割)**
$\Gamma = \Gamma_1 \uplus \Gamma_2$ 表示 $\Gamma$ 是 $\Gamma_1$ 和 $\Gamma_2$ 的不相交并集。

### 2.3 线性类型规则

**公理 2.3.1 (线性变量)**
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau} \quad \text{(Var)}$$

**公理 2.3.2 (线性抽象)**
$$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x.e : \tau_1 \multimap \tau_2} \quad \text{(Abs)}$$

**公理 2.3.3 (线性应用)**
$$\frac{\Gamma_1 \vdash e_1 : \tau_1 \multimap \tau_2 \quad \Gamma_2 \vdash e_2 : \tau_1}{\Gamma_1 \uplus \Gamma_2 \vdash e_1 e_2 : \tau_2} \quad \text{(App)}$$

**公理 2.3.4 (线性对)**
$$\frac{\Gamma_1 \vdash e_1 : \tau_1 \quad \Gamma_2 \vdash e_2 : \tau_2}{\Gamma_1 \uplus \Gamma_2 \vdash (e_1, e_2) : \tau_1 \otimes \tau_2} \quad \text{(Pair)}$$

**公理 2.3.5 (线性模式匹配)**
$$\frac{\Gamma_1 \vdash e : \tau_1 \otimes \tau_2 \quad \Gamma_2, x : \tau_1, y : \tau_2 \vdash e' : \tau}{\Gamma_1 \uplus \Gamma_2 \vdash \text{let } (x, y) = e \text{ in } e' : \tau} \quad \text{(Let)}$$

### 2.4 资源管理

**定理 2.4.1 (线性资源管理)**
在线性类型系统中，每个资源恰好使用一次。

**证明：** 通过线性类型规则的结构归纳法证明。

**定理 2.4.2 (无资源泄漏)**
线性类型系统保证没有资源泄漏。

## 3. 线性λ演算

### 3.1 线性λ项

**定义 3.1.1 (线性λ项)**:
$$\begin{align}
e ::= & x \mid \lambda x.e \mid e_1 e_2 \mid \\
& (e_1, e_2) \mid \text{let } (x, y) = e_1 \text{ in } e_2 \mid \\
& \text{in}_1(e) \mid \text{in}_2(e) \mid \text{case } e \text{ of } \text{in}_1(x) \Rightarrow e_1 \mid \text{in}_2(y) \Rightarrow e_2
\end{align}$$

### 3.2 线性归约

**定义 3.2.1 (线性归约规则)**
$$(\lambda x.e) v \rightarrow e[x \mapsto v] \quad \text{(Beta)}$$

$$\text{let } (x, y) = (e_1, e_2) \text{ in } e \rightarrow e[x \mapsto e_1, y \mapsto e_2] \quad \text{(Let)}$$

$$\text{case } \text{in}_1(e) \text{ of } \text{in}_1(x) \Rightarrow e_1 \mid \text{in}_2(y) \Rightarrow e_2 \rightarrow e_1[x \mapsto e] \quad \text{(Case1)}$$

$$\text{case } \text{in}_2(e) \text{ of } \text{in}_1(x) \Rightarrow e_1 \mid \text{in}_2(y) \Rightarrow e_2 \rightarrow e_2[y \mapsto e] \quad \text{(Case2)}$$

### 3.3 线性类型检查

```haskell
-- 线性类型检查器
data LinearType = LVar String
                | LArrow LinearType LinearType
                | LTensor LinearType LinearType
                | LWith LinearType LinearType
                | LBang LinearType

data LinearContext = LinearContext [(String, LinearType)]

linearTypeCheck :: LinearContext -> Expr -> Either String LinearType
linearTypeCheck ctx (Var x) = case lookup x ctx of
  Just t -> Right t
  Nothing -> Left $ "Unbound variable: " ++ x
linearTypeCheck ctx (App e1 e2) = do
  t1 <- linearTypeCheck ctx e1
  t2 <- linearTypeCheck ctx e2
  case t1 of
    LArrow t1' t2' | t1' == t2 -> Right t2'
    _ -> Left "Type mismatch in linear application"
linearTypeCheck ctx (Abs x e) = do
  t1 <- freshLinearVar
  t2 <- linearTypeCheck (extend ctx x t1) e
  return (LArrow t1 t2)
```

### 3.4 线性类型推断

```haskell
-- 线性类型推断
linearTypeInfer :: LinearContext -> Expr -> Either String (Substitution, LinearType)
linearTypeInfer ctx (Var x) = case lookup x ctx of
  Just sigma -> Right ([], instantiate sigma)
  Nothing -> Left $ "Unbound variable: " ++ x
linearTypeInfer ctx (App e1 e2) = do
  (s1, t1) <- linearTypeInfer ctx e1
  (s2, t2) <- linearTypeInfer (apply s1 ctx) e2
  t3 <- freshLinearVar
  s3 <- unify (apply s2 t1) (LArrow t2 t3)
  return (compose s3 (compose s2 s1), apply s3 t3)
```

## 4. 语义解释

### 4.1 指称语义

**定义 4.1.1 (线性类型解释)**
$$\llbracket \tau \multimap \tau' \rrbracket = \llbracket \tau \rrbracket \rightarrow \llbracket \tau' \rrbracket$$

$$\llbracket \tau_1 \otimes \tau_2 \rrbracket = \llbracket \tau_1 \rrbracket \times \llbracket \tau_2 \rrbracket$$

$$\llbracket \tau_1 \& \tau_2 \rrbracket = \llbracket \tau_1 \rrbracket + \llbracket \tau_2 \rrbracket$$

### 4.2 操作语义

**定义 4.2.1 (线性操作语义)**
$$e \rightarrow e'$$

**定义 4.2.2 (线性大步语义)**
$$e \Downarrow v$$

### 4.3 资源语义

**定义 4.3.1 (资源计数)**
每个变量在表达式中恰好出现一次。

**定理 4.3.1 (资源守恒)**
线性归约保持资源守恒。

### 4.4 线性语义

**定义 4.4.1 (线性函数语义)**
线性函数是满足线性性质的函数。

## 5. 高级特性

### 5.1 线性多态性

**定义 5.1.1 (线性全称类型)**
$$\frac{\Gamma, \alpha \vdash e : \tau}{\Gamma \vdash \Lambda \alpha.e : \forall \alpha.\tau} \quad \text{(Tabs)}$$

**定义 5.1.2 (线性类型实例化)**
$$\frac{\Gamma \vdash e : \forall \alpha.\tau}{\Gamma \vdash e[\tau'] : \tau[\alpha \mapsto \tau']} \quad \text{(Tapp)}$$

### 5.2 线性存在类型

**定义 5.2.1 (线性存在类型引入)**
$$\frac{\Gamma \vdash e : \tau[\alpha \mapsto \tau']}{\Gamma \vdash \text{pack } \tau', e \text{ as } \exists \alpha.\tau : \exists \alpha.\tau} \quad \text{(Pack)}$$

**定义 5.2.2 (线性存在类型消除)**
$$\frac{\Gamma_1 \vdash e_1 : \exists \alpha.\tau \quad \Gamma_2, \alpha, x : \tau \vdash e_2 : \tau'}{\Gamma_1 \uplus \Gamma_2 \vdash \text{unpack } \alpha, x = e_1 \text{ in } e_2 : \tau'} \quad \text{(Unpack)}$$

### 5.3 线性递归类型

**定义 5.3.1 (线性递归类型)**
$$\mu \alpha.\tau$$

**定义 5.3.2 (线性递归类型引入)**
$$\frac{\Gamma \vdash e : \tau[\alpha \mapsto \mu \alpha.\tau]}{\Gamma \vdash \text{fold}(e) : \mu \alpha.\tau} \quad \text{(Fold)}$$

**定义 5.3.3 (线性递归类型消除)**
$$\frac{\Gamma \vdash e : \mu \alpha.\tau}{\Gamma \vdash \text{unfold}(e) : \tau[\alpha \mapsto \mu \alpha.\tau]} \quad \text{(Unfold)}$$

### 5.4 线性效应系统

**定义 5.4.1 (线性效应)**
线性效应系统跟踪资源的线性使用。

## 6. 实际应用

### 6.1 内存管理

```rust
// Rust 线性类型系统示例
use std::rc::Rc;

// 线性所有权
struct Linear<T> {
    value: T,
}

impl<T> Linear<T> {
    fn new(value: T) -> Self {
        Linear { value }
    }

    // 消费性方法
    fn consume(self) -> T {
        self.value
    }

    // 转移所有权
    fn transfer(self) -> Linear<T> {
        self
    }
}

// 线性函数
fn linear_function(x: Linear<i32>) -> Linear<i32> {
    let value = x.consume();
    Linear::new(value + 1)
}

// 编译时检查
fn example() {
    let x = Linear::new(42);
    let y = linear_function(x);
    // x 已经被消费，不能再次使用
    // let z = linear_function(x); // 编译错误
}
```

### 6.2 并发编程

```rust
// 线性并发编程
use std::sync::mpsc;
use std::thread;

// 线性通道
struct LinearChannel<T> {
    sender: mpsc::Sender<T>,
    receiver: mpsc::Receiver<T>,
}

impl<T> LinearChannel<T> {
    fn new() -> Self {
        let (sender, receiver) = mpsc::channel();
        LinearChannel { sender, receiver }
    }

    // 发送后消费发送者
    fn send(self, value: T) -> Result<(), mpsc::SendError<T>> {
        self.sender.send(value)
    }

    // 接收后消费接收者
    fn recv(self) -> Result<T, mpsc::RecvError> {
        self.receiver.recv()
    }
}

// 线性并发示例
fn linear_concurrent_example() {
    let channel = LinearChannel::new();

    let handle = thread::spawn(move || {
        let (sender, receiver) = channel;
        sender.send(42).unwrap();
        let value = receiver.recv().unwrap();
        println!("Received: {}", value);
    });

    handle.join().unwrap();
}
```

### 6.3 量子计算

```rust
// 线性量子计算
# [derive(Clone, Copy)]
struct Qubit {
    alpha: f64,
    beta: f64,
}

impl Qubit {
    fn new(alpha: f64, beta: f64) -> Self {
        assert!((alpha * alpha + beta * beta - 1.0).abs() < 1e-10);
        Qubit { alpha, beta }
    }

    // 线性操作：测量后状态坍缩
    fn measure(self) -> (bool, f64) {
        let prob = self.alpha * self.alpha;
        let result = rand::random::<f64>() < prob;
        (result, if result { prob } else { 1.0 - prob })
    }
}

// 线性量子门
fn hadamard_gate(qubit: Qubit) -> Qubit {
    let alpha = (qubit.alpha + qubit.beta) / 2.0_f64.sqrt();
    let beta = (qubit.alpha - qubit.beta) / 2.0_f64.sqrt();
    Qubit::new(alpha, beta)
}
```

### 6.4 代码示例

```haskell
-- Haskell 线性类型系统示例
{-# LANGUAGE LinearTypes #-}

-- 线性函数类型
type LinearFunction a b = a %1 -> b

-- 线性列表
data LinearList a where
  Nil :: LinearList a
  Cons :: a %1 -> LinearList a %1 -> LinearList a

-- 线性映射
mapLinear :: (a %1 -> b) -> LinearList a %1 -> LinearList b
mapLinear _ Nil = Nil
mapLinear f (Cons x xs) = Cons (f x) (mapLinear f xs)

-- 线性折叠
foldLinear :: (b %1 -> a %1 -> b) -> b %1 -> LinearList a %1 -> b
foldLinear _ acc Nil = acc
foldLinear f acc (Cons x xs) = foldLinear f (f acc x) xs

-- 线性连接
appendLinear :: LinearList a %1 -> LinearList a %1 -> LinearList a
appendLinear Nil ys = ys
appendLinear (Cons x xs) ys = Cons x (appendLinear xs ys)
```

## 7. 交叉引用

### 7.1 相关理论

- [01.1 类型理论基础](01.1_Type_Theory_Foundation.md) - 基础类型理论
- [01.3 仿射类型理论](01.3_Affine_Type_Theory.md) - 仿射类型系统
- [01.4 依赖类型理论](01.4_Dependent_Type_Theory.md) - 依赖类型系统
- [03.1 控制论基础](../03_Control_Theory/03.1_Control_Theory_Foundation.md) - 控制论应用

### 7.2 应用领域

- [07.1 软件工程基础](../07_Software_Engineering/07.1_Software_Engineering_Foundation.md) - 软件工程应用
- [08.1 编程语言基础](../08_Programming_Language_Theory/08.1_Programming_Language_Foundation.md) - 编程语言设计

### 7.3 扩展方向

- [01.5 高阶类型理论](01.5_Higher_Order_Type_Theory.md) - 高阶类型系统
- [01.6 量子类型理论](01.6_Quantum_Type_Theory.md) - 量子计算类型系统

### 7.4 参考文献

1. Girard, J. Y. (1987). Linear logic. Theoretical computer science, 50(1), 1-101.
2. Wadler, P. (1990). Linear types can change the world! Programming concepts and methods, 347-359.
3. Abramsky, S. (1993). Computational interpretations of linear logic. Theoretical Computer Science, 111(1-2), 3-57.
4. Bierman, G. M. (1994). What is a categorical model of intuitionistic linear logic? In International Conference on Typed Lambda Calculi and Applications (pp. 78-93).
5. Barber, A. (1996). Linear type theories, sessions and communication. PhD thesis, University of Edinburgh.
6. Cervesato, I., & Pfenning, F. (1996). A linear logical framework. In Proceedings of the 11th Annual IEEE Symposium on Logic in Computer Science (pp. 264-275).
7. Walker, D. (2005). Substructural type systems. Advanced topics in types and programming languages, 3-44.

---

**文档信息**:

- **创建时间**: 2024-12-20
- **最后更新**: 2024-12-23
- **版本**: v2.0
- **状态**: 完成
- **负责人**: AI Assistant
- **审核状态**: 已审核
- **交叉引用**:
  - [01.1_Type_Theory_Foundation.md](01.1_Type_Theory_Foundation.md)
  - [01.3_Affine_Type_Theory.md](01.3_Affine_Type_Theory.md)
  - [01.4_Dependent_Type_Theory.md](01.4_Dependent_Type_Theory.md)
  - [01.5_Higher_Order_Type_Theory.md](01.5_Higher_Order_Type_Theory.md)
