# 01.2 线性类型理论 (Linear Type Theory)

## 目录

```markdown
01.2 线性类型理论
├── 1. 线性逻辑基础
│   ├── 1.1 线性逻辑公理
│   ├── 1.2 线性连接词
│   └── 1.3 线性证明论
├── 2. 线性类型系统
│   ├── 2.1 线性类型定义
│   ├── 2.2 线性类型规则
│   └── 2.3 资源管理
├── 3. 线性λ演算
│   ├── 3.1 语法定义
│   ├── 3.2 归约规则
│   └── 3.3 类型安全性
├── 4. 指数类型系统
│   ├── 4.1 指数连接词
│   ├── 4.2 收缩和弱化
│   └── 4.3 模态类型
├── 5. 资源管理理论
│   ├── 5.1 资源计数
│   ├── 5.2 资源传递
│   └── 5.3 资源回收
├── 6. 实际应用
│   ├── 6.1 内存管理
│   ├── 6.2 并发控制
│   └── 6.3 代码示例
├── 7. 元理论
│   ├── 7.1 一致性
│   ├── 7.2 完备性
│   └── 7.3 可判定性
└── 8. 交叉引用
    ├── 8.1 相关理论
    ├── 8.2 扩展阅读
    └── 8.3 参考文献
```

## 1. 线性逻辑基础

### 1.1 线性逻辑公理

**定义 1.1.1 (线性逻辑)**
线性逻辑是一种资源敏感的逻辑系统，其中每个假设必须恰好使用一次。

**公理 1.1.1 (线性恒等)**
$$\frac{}{A \vdash A} \quad \text{(Id)}$$

**公理 1.1.2 (线性交换)**
$$\frac{\Gamma, A, B, \Delta \vdash C}{\Gamma, B, A, \Delta \vdash C} \quad \text{(Exchange)}$$

**公理 1.1.3 (线性切割)**
$$\frac{\Gamma \vdash A \quad \Delta, A \vdash B}{\Gamma, \Delta \vdash B} \quad \text{(Cut)}$$

### 1.2 线性连接词

**定义 1.2.1 (乘法连接词)**

**张量积 (⊗)**：
$$\frac{\Gamma \vdash A \quad \Delta \vdash B}{\Gamma, \Delta \vdash A \otimes B} \quad \text{(⊗R)}$$

$$\frac{\Gamma, A, B \vdash C}{\Gamma, A \otimes B \vdash C} \quad \text{(⊗L)}$$

**单位元 (1)**：
$$\frac{}{\vdash 1} \quad \text{(1R)}$$

$$\frac{\Gamma \vdash C}{\Gamma, 1 \vdash C} \quad \text{(1L)}$$

**定义 1.2.2 (加法连接词)**

**内部和 (⊕)**：
$$\frac{\Gamma \vdash A}{\Gamma \vdash A \oplus B} \quad \text{(⊕R1)}$$

$$\frac{\Gamma \vdash B}{\Gamma \vdash A \oplus B} \quad \text{(⊕R2)}$$

$$\frac{\Gamma, A \vdash C \quad \Gamma, B \vdash C}{\Gamma, A \oplus B \vdash C} \quad \text{(⊕L)}$$

**零 (0)**：
$$\frac{\Gamma, 0 \vdash C}{\Gamma, 0 \vdash C} \quad \text{(0L)}$$

### 1.3 线性证明论

**定理 1.3.1 (线性逻辑的切割消除)**
在线性逻辑中，切割规则是可消除的。

**证明：** 通过双重归纳法证明，首先对切割公式的复杂度进行归纳，然后对切割的高度进行归纳。

## 2. 线性类型系统

### 2.1 线性类型定义

**定义 2.1.1 (线性类型)**
线性类型是表示资源使用方式的类型，每个线性值必须恰好使用一次。

**定义 2.1.2 (线性类型上下文)**
线性类型上下文 $\Gamma$ 是变量到线性类型的映射：
$$\Gamma : \text{Var} \rightarrow \text{LinearType}$$

**定义 2.1.3 (线性类型判断)**
线性类型判断形如 $\Gamma \vdash e : \tau$，表示在上下文 $\Gamma$ 中，表达式 $e$ 具有线性类型 $\tau$。

### 2.2 线性类型规则

**公理 2.2.1 (线性变量)**
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau} \quad \text{(LinVar)}$$

**公理 2.2.2 (线性抽象)**
$$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x.e : \tau_1 \multimap \tau_2} \quad \text{(LinAbs)}$$

**公理 2.2.3 (线性应用)**
$$\frac{\Gamma \vdash e_1 : \tau_1 \multimap \tau_2 \quad \Delta \vdash e_2 : \tau_1}{\Gamma, \Delta \vdash e_1 e_2 : \tau_2} \quad \text{(LinApp)}$$

**公理 2.2.4 (张量积构造)**
$$\frac{\Gamma \vdash e_1 : \tau_1 \quad \Delta \vdash e_2 : \tau_2}{\Gamma, \Delta \vdash (e_1, e_2) : \tau_1 \otimes \tau_2} \quad \text{(Tensor)}$$

**公理 2.2.5 (张量积分解)**
$$\frac{\Gamma, x : \tau_1, y : \tau_2 \vdash e : \tau}{\Gamma, z : \tau_1 \otimes \tau_2 \vdash \text{let } (x, y) = z \text{ in } e : \tau} \quad \text{(LetTensor)}$$

### 2.3 资源管理

**定义 2.3.1 (资源计数)**
资源计数函数 $\text{count}_x(e)$ 计算变量 $x$ 在表达式 $e$ 中的使用次数。

**定义 2.3.2 (线性性检查)**
表达式 $e$ 是线性的，如果对于所有变量 $x$，都有 $\text{count}_x(e) \leq 1$。

**定理 2.3.1 (线性性保持)**
如果 $\Gamma \vdash e : \tau$ 且 $e \rightarrow e'$，则 $e'$ 也是线性的。

## 3. 线性λ演算

### 3.1 语法定义

**定义 3.1.1 (线性λ演算语法)**
$$e ::= x \mid \lambda x.e \mid e_1 e_2 \mid (e_1, e_2) \mid \text{let } (x, y) = e_1 \text{ in } e_2$$

**定义 3.1.2 (线性类型语法)**
$$\tau ::= \alpha \mid \tau_1 \multimap \tau_2 \mid \tau_1 \otimes \tau_2 \mid 1$$

### 3.2 归约规则

**定义 3.2.1 (线性归约规则)**

1. **线性β归约**：$(\lambda x.e_1) e_2 \rightarrow e_1[x \mapsto e_2]$
2. **张量积归约**：$\text{let } (x, y) = (e_1, e_2) \text{ in } e \rightarrow e[x \mapsto e_1, y \mapsto e_2]$
3. **单位元归约**：$\text{let } () = () \text{ in } e \rightarrow e$

### 3.3 类型安全性

**定理 3.3.1 (线性类型保持性)**
如果 $\Gamma \vdash e : \tau$ 且 $e \rightarrow e'$，则 $\Gamma \vdash e' : \tau$。

**定理 3.3.2 (线性进展性)**
如果 $\emptyset \vdash e : \tau$，则要么 $e$ 是值，要么存在 $e'$ 使得 $e \rightarrow e'$。

## 4. 指数类型系统

### 4.1 指数连接词

**定义 4.1.1 (指数连接词)**

**指数 (!)**：
$$\frac{!\Gamma \vdash A}{!\Gamma \vdash !A} \quad \text{(!R)}$$

$$\frac{\Gamma, A \vdash B}{\Gamma, !A \vdash B} \quad \text{(!L)}$$

**定义 4.1.2 (指数类型规则)**

**指数引入**：
$$\frac{\Gamma \vdash e : \tau}{\Gamma \vdash !e : !\tau} \quad \text{(Bang)}$$

**指数消除**：
$$\frac{\Gamma \vdash e_1 : !\tau_1 \quad \Delta, x : \tau_1 \vdash e_2 : \tau_2}{\Gamma, \Delta \vdash \text{let } !x = e_1 \text{ in } e_2 : \tau_2} \quad \text{(LetBang)}$$

### 4.2 收缩和弱化

**公理 4.2.1 (收缩)**
$$\frac{\Gamma, !A, !A \vdash B}{\Gamma, !A \vdash B} \quad \text{(Contraction)}$$

**公理 4.2.2 (弱化)**
$$\frac{\Gamma \vdash B}{\Gamma, !A \vdash B} \quad \text{(Weakening)}$$

### 4.3 模态类型

**定义 4.3.1 (模态类型)**
模态类型表示可以任意使用的类型。

**Rust实现示例：**

```rust
use std::rc::Rc;
use std::cell::RefCell;

// 线性类型标记
struct Linear<T>(T);

// 指数类型（可共享）
struct Exponential<T>(Rc<RefCell<T>>);

// 线性函数类型
trait LinearFn<A, B> {
    fn call(self, a: A) -> B;
}

// 线性抽象
struct LinearAbs<F>(F);

impl<A, B, F> LinearFn<A, B> for LinearAbs<F>
where
    F: FnOnce(A) -> B,
{
    fn call(self, a: A) -> B {
        (self.0)(a)
    }
}

// 张量积
struct Tensor<A, B>(A, B);

// 线性应用
fn linear_app<A, B, F>(f: LinearAbs<F>, a: A) -> B
where
    F: FnOnce(A) -> B,
{
    f.call(a)
}

// 张量积构造
fn tensor<A, B>(a: A, b: B) -> Tensor<A, B> {
    Tensor(a, b)
}

// 张量积分解
fn let_tensor<A, B, C, F>(t: Tensor<A, B>, f: F) -> C
where
    F: FnOnce(A, B) -> C,
{
    f(t.0, t.1)
}

// 指数类型构造
fn bang<T>(t: T) -> Exponential<T> {
    Exponential(Rc::new(RefCell::new(t)))
}

// 指数类型使用
fn let_bang<T, U, F>(e: Exponential<T>, f: F) -> U
where
    F: FnOnce(&mut T) -> U,
{
    f(&mut *e.0.borrow_mut())
}
```

## 5. 资源管理理论

### 5.1 资源计数

**定义 5.1.1 (资源计数函数)**
$$\text{count}_x(e) = \begin{cases}
1 & \text{if } e = x \\
\text{count}_x(e_1) + \text{count}_x(e_2) & \text{if } e = e_1 e_2 \\
\text{count}_x(e_1) + \text{count}_x(e_2) & \text{if } e = (e_1, e_2) \\
\text{count}_x(e') & \text{if } e = \lambda y.e' \text{ and } x \neq y \\
0 & \text{otherwise}
\end{cases}$$

**定理 5.1.1 (线性性检查)**
如果 $\Gamma \vdash e : \tau$，则对于所有 $x \in \text{dom}(\Gamma)$，都有 $\text{count}_x(e) \leq 1$。

### 5.2 资源传递

**定义 5.2.1 (资源传递)**
资源传递确保线性资源在程序执行过程中不会丢失或重复使用。

**定理 5.2.1 (资源传递保持性)**
如果 $\Gamma \vdash e : \tau$ 且 $e \rightarrow e'$，则资源传递性质在归约后保持不变。

### 5.3 资源回收

**定义 5.3.1 (资源回收)**
线性类型系统自动管理资源回收，确保资源在使用后被正确释放。

**Haskell实现示例：**

```haskell
{-# LANGUAGE GADTs, KindSignatures, DataKinds #-}

-- 线性类型标记
data Linear a = Linear a

-- 指数类型标记
data Exponential a = Exponential a

-- 线性函数类型
newtype a :-<> b = LinearFun { runLinearFun :: a -> b }

-- 张量积
data a :*: b = Tensor a b

-- 单位类型
data One = One

-- 线性抽象
linear :: (a -> b) -> a :-<> b
linear = LinearFun

-- 线性应用
(@@) :: a :-<> b -> a -> b
f @@ x = runLinearFun f x

-- 张量积构造
tensor :: a -> b -> a :*: b
tensor = Tensor

-- 张量积分解
letTensor :: a :*: b -> (a -> b -> c) -> c
letTensor (Tensor a b) f = f a b

-- 指数类型构造
bang :: a -> Exponential a
bang = Exponential

-- 指数类型使用
letBang :: Exponential a -> (a -> b) -> b
letBang (Exponential a) f = f a

-- 线性组合
(>>>) :: a :-<> b -> b :-<> c -> a :-<> c
f >>> g = linear (\x -> runLinearFun g (runLinearFun f x))

-- 线性对偶
first :: a :-<> b -> (a :*: c) :-<> (b :*: c)
first f = linear (\(Tensor a c) -> Tensor (runLinearFun f a) c)

second :: a :-<> b -> (c :*: a) :-<> (c :*: b)
second f = linear (\(Tensor c a) -> Tensor c (runLinearFun f a))

-- 线性交换
swap :: (a :*: b) :-<> (b :*: a)
swap = linear (\(Tensor a b) -> Tensor b a)

-- 线性复制（使用指数类型）
copy :: Exponential a -> a :*: a
copy (Exponential a) = Tensor a a

-- 线性丢弃
discard :: a :-<> One
discard = linear (\_ -> One)

-- 线性恒等
idL :: a :-<> a
idL = linear id

-- 线性组合示例
example :: (a :*: b) :-<> (b :*: a)
example = swap

-- 线性函数组合示例
composeExample :: a :-<> b -> b :-<> c -> a :-<> c
composeExample = (>>>)

-- 资源管理示例
resourceExample :: Exponential Int -> Int :*: Int
resourceExample = copy

-- 线性变换示例
transformExample :: (Int :*: Int) :-<> (Int :*: Int)
transformExample = linear (\(Tensor x y) -> Tensor (x + y) (x * y))
```

## 6. 实际应用

### 6.1 内存管理

**线性类型在内存管理中的应用：**

```rust
// 线性所有权系统
struct LinearOwnership<T> {
    data: Option<T>,
}

impl<T> LinearOwnership<T> {
    fn new(data: T) -> Self {
        LinearOwnership { data: Some(data) }
    }
    
    fn take(mut self) -> T {
        self.data.take().expect("Data already taken")
    }
    
    fn map<U, F>(self, f: F) -> LinearOwnership<U>
    where
        F: FnOnce(T) -> U,
    {
        LinearOwnership {
            data: self.data.map(f),
        }
    }
}

// 使用示例
fn example() {
    let ownership = LinearOwnership::new(42);
    let value = ownership.take(); // 所有权转移
    // ownership 不能再使用
    
    let ownership2 = LinearOwnership::new("hello");
    let ownership3 = ownership2.map(|s| s.len()); // 线性变换
}
```

### 6.2 并发控制

**线性类型在并发控制中的应用：**

```rust
use std::sync::{Arc, Mutex};

// 线性锁
struct LinearLock<T> {
    data: Arc<Mutex<T>>,
}

impl<T> LinearLock<T> {
    fn new(data: T) -> Self {
        LinearLock {
            data: Arc::new(Mutex::new(data)),
        }
    }
    
    fn lock(self) -> LinearGuard<T> {
        LinearGuard {
            guard: self.data.lock().unwrap(),
        }
    }
}

struct LinearGuard<'a, T> {
    guard: std::sync::MutexGuard<'a, T>,
}

impl<'a, T> LinearGuard<'a, T> {
    fn access<F, R>(&mut self, f: F) -> R
    where
        F: FnOnce(&mut T) -> R,
    {
        f(&mut *self.guard)
    }
}

// 使用示例
fn concurrent_example() {
    let lock = LinearLock::new(vec![1, 2, 3]);
    let mut guard = lock.lock();
    guard.access(|v| v.push(4));
    // guard 在这里被自动释放
}
```

### 6.3 代码示例

**完整的线性类型系统实现：**

```haskell
{-# LANGUAGE GADTs, KindSignatures, DataKinds, TypeFamilies #-}

-- 线性类型系统
module LinearTypeSystem where

-- 类型级自然数
data Nat = Z | S Nat

-- 线性类型
data LinearType (n :: Nat) where
    LVar :: String -> LinearType n
    LArrow :: LinearType n -> LinearType n -> LinearType n
    LTensor :: LinearType n -> LinearType n -> LinearType n
    LOne :: LinearType n
    LBang :: LinearType n -> LinearType n

-- 线性表达式
data LinearExpr (n :: Nat) where
    LVar :: String -> LinearExpr n
    LAbs :: String -> LinearExpr n -> LinearExpr n
    LApp :: LinearExpr n -> LinearExpr n -> LinearExpr n
    LTensor :: LinearExpr n -> LinearExpr n -> LinearExpr n
    LLetTensor :: LinearExpr n -> String -> String -> LinearExpr n -> LinearExpr n
    LBang :: LinearExpr n -> LinearExpr n
    LLetBang :: LinearExpr n -> String -> LinearExpr n -> LinearExpr n
    LUnit :: LinearExpr n

-- 线性上下文
type LinearContext = [(String, LinearType 'Z)]

-- 线性类型检查
typeCheck :: LinearContext -> LinearExpr 'Z -> Either String (LinearType 'Z)
typeCheck ctx (LVar x) = case lookup x ctx of
    Just t -> Right t
    Nothing -> Left $ "Unbound variable: " ++ x
typeCheck ctx (LAbs x e) = do
    t1 <- freshTypeVar
    t2 <- typeCheck ((x, t1) : ctx) e
    return $ LArrow t1 t2
typeCheck ctx (LApp e1 e2) = do
    t1 <- typeCheck ctx e1
    t2 <- typeCheck ctx e2
    case t1 of
        LArrow t1' t2' | t1' == t2 -> Right t2'
        _ -> Left "Type mismatch in application"
typeCheck ctx (LTensor e1 e2) = do
    t1 <- typeCheck ctx e1
    t2 <- typeCheck ctx e2
    return $ LTensor t1 t2
typeCheck ctx (LLetTensor e1 x y e2) = do
    t1 <- typeCheck ctx e1
    case t1 of
        LTensor t1' t2' -> do
            t <- typeCheck ((x, t1') : (y, t2') : ctx) e2
            return t
        _ -> Left "Expected tensor type"
typeCheck ctx (LBang e) = do
    t <- typeCheck ctx e
    return $ LBang t
typeCheck ctx (LLetBang e1 x e2) = do
    t1 <- typeCheck ctx e1
    case t1 of
        LBang t1' -> do
            t2 <- typeCheck ((x, t1') : ctx) e2
            return t2
        _ -> Left "Expected bang type"
typeCheck ctx LUnit = return LOne

-- 辅助函数
freshTypeVar :: Either String (LinearType 'Z)
freshTypeVar = Right $ LVar "α"

-- 线性归约
reduce :: LinearExpr 'Z -> Either String (LinearExpr 'Z)
reduce (LApp (LAbs x e1) e2) = Right $ substitute e1 x e2
reduce (LLetTensor (LTensor e1 e2) x y e) = Right $ substitute (substitute e x e1) y e2
reduce (LLetBang (LBang e1) x e2) = Right $ substitute e2 x e1
reduce _ = Left "No reduction possible"

-- 替换
substitute :: LinearExpr 'Z -> String -> LinearExpr 'Z -> LinearExpr 'Z
substitute (LVar y) x e
    | x == y = e
    | otherwise = LVar y
substitute (LAbs y e1) x e2
    | x == y = LAbs y e1
    | otherwise = LAbs y (substitute e1 x e2)
substitute (LApp e1 e2) x e = LApp (substitute e1 x e) (substitute e2 x e)
substitute (LTensor e1 e2) x e = LTensor (substitute e1 x e) (substitute e2 x e)
substitute (LLetTensor e1 y z e2) x e = LLetTensor (substitute e1 x e) y z (substitute e2 x e)
substitute (LBang e1) x e = LBang (substitute e1 x e)
substitute (LLetBang e1 y e2) x e = LLetBang (substitute e1 x e) y (substitute e2 x e)
substitute LUnit _ _ = LUnit
```

## 7. 元理论

### 7.1 一致性

**定理 7.1.1 (线性类型系统一致性)**
如果 $\Gamma \vdash e : \tau$，则 $e$ 不会产生类型错误。

**证明：** 结合线性类型保持性和进展性定理。

### 7.2 完备性

**定理 7.2.1 (线性类型推断完备性)**
如果存在线性类型，则线性类型推断算法能够找到。

### 7.3 可判定性

**定理 7.3.1 (线性类型检查可判定性)**
线性类型检查问题是可判定的。

## 8. 交叉引用

### 8.1 相关理论

- [01.1 类型理论基础](./01.1_Type_Theory_Foundation.md)
- [01.3 仿射类型理论](./01.3_Affine_Type_Theory.md)
- [01.4 依赖类型理论](./01.4_Dependent_Type_Theory.md)
- [02.1 形式语言理论](../02_Formal_Language_Theory/02.1_Formal_Language_Foundation.md)
- [03.1 控制论基础](../03_Control_Theory/03.1_Control_Theory_Foundation.md)

### 8.2 扩展阅读

- [04.1 分布式系统理论](../04_Distributed_Systems/04.1_Distributed_Systems_Foundation.md)
- [05.1 哲学基础](../05_Philosophical_Foundation/05.1_Philosophical_Foundation.md)
- [06.1 数学基础](../06_Mathematical_Foundation/06.1_Mathematical_Foundation.md)

### 8.3 参考文献

1. Girard, J. Y. (1987). Linear logic. Theoretical computer science, 50(1), 1-101.
2. Wadler, P. (1993). A taste of linear logic. In Mathematical foundations of computer science 1993 (pp. 185-210).
3. Abramsky, S. (1993). Computational interpretations of linear logic. Theoretical Computer Science, 111(1-2), 3-57.
4. Benton, P. N. (1995). A mixed linear and non-linear logic: Proofs, terms and models. In Computer science logic (pp. 121-135).
5. Barber, A. (1996). Dual intuitionistic linear logic. Technical report, LFCS, University of Edinburgh.
6. Bierman, G. M. (1994). What is a categorical model of intuitionistic linear logic?. In Typed lambda calculi and applications (pp. 78-93).
7. Cervesato, I., & Pfenning, F. (1996). A linear logical framework. In Logic in computer science (pp. 264-275).
8. Hodas, J., & Miller, D. (1994). Logic programming in a fragment of intuitionistic linear logic. Information and computation, 110(2), 327-365.
9. Lincoln, P., Mitchell, J., Scedrov, A., & Shankar, N. (1992). Decision problems for propositional linear logic. Annals of pure and applied logic, 56(1-3), 239-311.
10. Troelstra, A. S. (1992). Lectures on linear logic. CSLI Publications. 