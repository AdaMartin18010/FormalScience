# 01.2 线性类型理论 - 形式科学理论体系

## 目录

```markdown
01.2 线性类型理论
├── 1. 概述
│   ├── 1.1 定义与动机
│   ├── 1.2 历史发展
│   ├── 1.3 应用领域
│   └── 1.4 与其他类型系统的关系
├── 2. 基础概念
│   ├── 2.1 线性类型
│   ├── 2.2 线性环境
│   ├── 2.3 线性约束
│   └── 2.4 资源管理
├── 3. 形式化定义
│   ├── 3.1 语法定义
│   ├── 3.2 类型规则
│   ├── 3.3 归约规则
│   └── 3.4 语义定义
├── 4. 核心定理
│   ├── 4.1 线性保持定理
│   ├── 4.2 资源安全定理
│   ├── 4.3 强正规化定理
│   └── 4.4 一致性定理
├── 5. 实现与示例
│   ├── 5.1 Haskell 实现
│   ├── 5.2 Rust 实现
│   ├── 5.3 线性类型检查器
│   └── 5.4 资源追踪器
├── 6. 扩展与变体
│   ├── 6.1 仿射类型
│   ├── 6.2 相关类型
│   ├── 6.3 量化线性类型
│   └── 6.4 高阶线性类型
├── 7. 应用实例
│   ├── 7.1 内存管理
│   ├── 7.2 并发编程
│   ├── 7.3 量子计算
│   └── 7.4 系统编程
└── 8. 参考文献
    ├── 8.1 经典文献
    ├── 8.2 现代发展
    ├── 8.3 应用研究
    └── 8.4 未来方向
```

## 1. 概述

### 1.1 定义与动机

**线性类型理论** (Linear Type Theory) 是类型理论的一个重要分支，它要求每个变量恰好使用一次。这种约束为资源管理、内存安全和并发编程提供了强大的理论基础。

**核心动机**:

1. **资源安全**: 确保资源（如内存、文件句柄）的正确管理
2. **并发安全**: 防止数据竞争和并发错误
3. **内存安全**: 避免内存泄漏和悬空指针
4. **性能优化**: 通过静态分析优化资源使用

### 1.2 历史发展

线性类型理论的发展历程：

- **1987年**: Girard 提出线性逻辑
- **1991年**: Wadler 将线性逻辑引入函数式编程
- **1993年**: Abramsky 提出线性λ演算
- **2000年**: Rust 语言采用线性类型系统
- **2010年**: 线性类型在并发编程中的应用

### 1.3 应用领域

线性类型理论在以下领域有重要应用：

1. **系统编程**: Rust, C++ 的智能指针
2. **并发编程**: 无锁数据结构
3. **内存管理**: 自动内存管理
4. **量子计算**: 量子比特管理
5. **资源管理**: 文件、网络连接管理

### 1.4 与其他类型系统的关系

线性类型系统与其他类型系统的关系：

- **直觉类型论**: 线性类型论是直觉类型论的扩展
- **仿射类型论**: 线性类型论比仿射类型论更严格
- **相关类型论**: 线性类型论与相关类型论正交
- **依赖类型论**: 可以结合依赖类型论

## 2. 基础概念

### 2.1 线性类型

**定义 2.1.1** (线性类型)
线性类型 $A \multimap B$ 表示一个函数，它恰好使用一次参数 $A$ 来产生结果 $B$。

**定义 2.1.2** (线性乘积)
线性乘积 $A \otimes B$ 表示同时拥有类型 $A$ 和 $B$ 的资源。

**定义 2.1.3** (线性和)
线性和 $A \oplus B$ 表示拥有类型 $A$ 或类型 $B$ 的资源。

### 2.2 线性环境

**定义 2.2.1** (线性环境)
线性环境 $\Gamma$ 是一个多重集，包含变量到类型的映射：
$$\Gamma = x_1 : A_1, x_2 : A_2, \ldots, x_n : A_n$$

**定义 2.2.2** (环境分割)
环境分割 $\Gamma = \Gamma_1 \uplus \Gamma_2$ 表示将环境 $\Gamma$ 分割为两个不相交的环境 $\Gamma_1$ 和 $\Gamma_2$。

### 2.3 线性约束

**约束 2.3.1** (线性使用)
每个变量在项中恰好出现一次。

**约束 2.3.2** (环境分割)
在函数应用中，参数和函数的环境必须分割。

**约束 2.3.3** (资源守恒)
资源在计算过程中既不能创造也不能销毁。

### 2.4 资源管理

**定义 2.4.1** (资源)
资源是具有线性性质的实体，如内存、文件句柄、锁等。

**定义 2.4.2** (资源安全)
资源安全确保每个资源都被正确管理，不会发生泄漏或重复释放。

## 3. 形式化定义

### 3.1 语法定义

**定义 3.1.1** (线性λ演算语法)
线性λ演算的语法定义如下：

**类型**:
$$A, B ::= \text{Unit} \mid A \multimap B \mid A \otimes B \mid A \oplus B$$

**项**:
$$t, u ::= x \mid \lambda x : A. t \mid t(u) \mid \langle t, u \rangle \mid \text{let } \langle x, y \rangle = t \text{ in } u \mid \text{inl}(t) \mid \text{inr}(t) \mid \text{case } t \text{ of } \text{inl}(x) \Rightarrow u \mid \text{inr}(y) \Rightarrow v$$

**环境**:
$$\Gamma ::= \emptyset \mid \Gamma, x : A$$

### 3.2 类型规则

**规则 3.2.1** (Unit类型)
$$\frac{}{\Gamma \vdash \langle \rangle : \text{Unit}}$$

**规则 3.2.2** (变量)
$$\frac{x : A \in \Gamma}{\Gamma \vdash x : A}$$

**规则 3.2.3** (线性抽象)
$$\frac{\Gamma, x : A \vdash t : B}{\Gamma \vdash \lambda x : A. t : A \multimap B}$$

**规则 3.2.4** (线性应用)
$$\frac{\Gamma_1 \vdash t : A \multimap B \quad \Gamma_2 \vdash u : A \quad \Gamma = \Gamma_1 \uplus \Gamma_2}{\Gamma \vdash t(u) : B}$$

**规则 3.2.5** (线性乘积引入)
$$\frac{\Gamma_1 \vdash t : A \quad \Gamma_2 \vdash u : B \quad \Gamma = \Gamma_1 \uplus \Gamma_2}{\Gamma \vdash \langle t, u \rangle : A \otimes B}$$

**规则 3.2.6** (线性乘积消除)
$$\frac{\Gamma_1 \vdash t : A \otimes B \quad \Gamma_2, x : A, y : B \vdash u : C \quad \Gamma = \Gamma_1 \uplus \Gamma_2}{\Gamma \vdash \text{let } \langle x, y \rangle = t \text{ in } u : C}$$

### 3.3 归约规则

**定义 3.3.1** (β归约)
$$(\lambda x : A. t)(u) \to_\beta t[x := u]$$

**定义 3.3.2** (乘积归约)
$$\text{let } \langle x, y \rangle = \langle t, u \rangle \text{ in } v \to v[x := t, y := u]$$

**定义 3.3.3** (和归约)
$$\text{case inl}(t) \text{ of inl}(x) \Rightarrow u \mid \text{inr}(y) \Rightarrow v \to u[x := t]$$

**定义 3.3.4** (上下文归约)
$$\frac{t \to t'}{E[t] \to E[t']}$$

### 3.4 语义定义

**定义 3.4.1** (操作语义)
线性λ演算的操作语义通过归约关系定义：

1. **β归约**: $(\lambda x : A. t)(u) \to t[x := u]$
2. **乘积归约**: $\text{let } \langle x, y \rangle = \langle t, u \rangle \text{ in } v \to v[x := t, y := u]$
3. **和归约**: $\text{case inl}(t) \text{ of inl}(x) \Rightarrow u \mid \text{inr}(y) \Rightarrow v \to u[x := t]$

**定义 3.4.2** (指称语义)
线性λ演算的指称语义通过线性逻辑的模型定义：

- $\llbracket \text{Unit} \rrbracket = \{*\}$
- $\llbracket A \multimap B \rrbracket = \llbracket B \rrbracket^{\llbracket A \rrbracket}$
- $\llbracket A \otimes B \rrbracket = \llbracket A \rrbracket \times \llbracket B \rrbracket$
- $\llbracket A \oplus B \rrbracket = \llbracket A \rrbracket + \llbracket B \rrbracket$

## 4. 核心定理

### 4.1 线性保持定理

**定理 4.1.1** (线性保持定理)
如果 $\Gamma \vdash t : A$ 且 $t \to t'$，则 $\Gamma \vdash t' : A$，且线性约束得到保持。

**证明**:
通过结构归纳法证明。对于每种归约规则：

1. **β归约**: $(\lambda x : A. t)(u) \to t[x := u]$
   - 如果 $\Gamma_1 \vdash \lambda x : A. t : A \multimap B$ 且 $\Gamma_2 \vdash u : A$，则 $\Gamma_1, x : A \vdash t : B$
   - 由替换引理，$\Gamma_1 \uplus \Gamma_2 \vdash t[x := u] : B$

2. **乘积归约**: $\text{let } \langle x, y \rangle = \langle t, u \rangle \text{ in } v \to v[x := t, y := u]$
   - 如果 $\Gamma_1 \vdash \langle t, u \rangle : A \otimes B$ 且 $\Gamma_2, x : A, y : B \vdash v : C$，则 $\Gamma_1 \uplus \Gamma_2 \vdash v[x := t, y := u] : C$

### 4.2 资源安全定理

**定理 4.2.1** (资源安全定理)
在线性λ演算中，所有良类型的项都满足资源安全性质。

**证明**:
通过结构归纳法证明每个项都满足：

1. **变量**: 每个变量恰好使用一次
2. **抽象**: 参数在函数体中恰好使用一次
3. **应用**: 参数和函数的环境分割确保资源不重复使用
4. **乘积**: 乘积的引入和消除确保资源正确分配

### 4.3 强正规化定理

**定理 4.3.1** (强正规化定理)
线性λ演算中的所有良类型项都是强正规化的。

**证明**:
使用逻辑关系方法。定义类型 $A$ 上的逻辑关系 $R_A$：

- $R_{\text{Unit}}(t) \iff t$ 是强正规化的
- $R_{A \multimap B}(t) \iff \forall u. R_A(u) \implies R_B(t(u))$
- $R_{A \otimes B}(t) \iff \exists t_1, t_2. t \to^* \langle t_1, t_2 \rangle \land R_A(t_1) \land R_B(t_2)$

### 4.4 一致性定理

**定理 4.4.1** (一致性定理)
线性λ演算是一致的，即不存在项 $t$ 使得 $\vdash t : \bot$。

**证明**:
假设存在 $t$ 使得 $\vdash t : \bot$。由强正规化定理，$t$ 有正规形式 $t'$。
但 $\bot$ 类型没有引入规则，矛盾。

## 5. 实现与示例

### 5.1 Haskell 实现

```haskell
-- 线性类型定义
data LinearType = Unit | LinearArrow LinearType LinearType | Tensor LinearType LinearType | Sum LinearType LinearType

-- 线性项定义
data LinearTerm = LVar String | LLam String LinearType LinearTerm | LApp LinearTerm LinearTerm | LPair LinearTerm LinearTerm | LLet String String LinearTerm LinearTerm | LInl LinearTerm | LInr LinearTerm | LCase LinearTerm String LinearTerm String LinearTerm

-- 线性环境
type LinearContext = [(String, LinearType)]

-- 环境分割
splitContext :: LinearContext -> LinearContext -> LinearContext -> Bool
splitContext total left right = 
    let leftVars = map fst left
        rightVars = map fst right
        totalVars = map fst total
    in sort leftVars ++ sort rightVars == sort totalVars

-- 线性类型检查
linearTypeCheck :: LinearContext -> LinearTerm -> Maybe LinearType
linearTypeCheck ctx (LVar x) = lookup x ctx
linearTypeCheck ctx (LLam x t body) = do
    bodyType <- linearTypeCheck ((x, t) : ctx) body
    return (LinearArrow t bodyType)
linearTypeCheck ctx (LApp f arg) = do
    LinearArrow dom cod <- linearTypeCheck ctx f
    argType <- linearTypeCheck ctx arg
    if dom == argType then return cod else Nothing
linearTypeCheck ctx (LPair t u) = do
    tType <- linearTypeCheck ctx t
    uType <- linearTypeCheck ctx u
    return (Tensor tType uType)
linearTypeCheck ctx (LLet x y pair body) = do
    Tensor tType uType <- linearTypeCheck ctx pair
    bodyType <- linearTypeCheck ((x, tType) : (y, uType) : ctx) body
    return bodyType
linearTypeCheck ctx Unit = return Unit
```

### 5.2 Rust 实现

```rust
use std::collections::HashMap;

// 线性类型定义
#[derive(Debug, Clone, PartialEq)]
enum LinearType {
    Unit,
    LinearArrow(Box<LinearType>, Box<LinearType>),
    Tensor(Box<LinearType>, Box<LinearType>),
    Sum(Box<LinearType>, Box<LinearType>),
}

// 线性项定义
#[derive(Debug, Clone)]
enum LinearTerm {
    Var(String),
    Lam(String, LinearType, Box<LinearTerm>),
    App(Box<LinearTerm>, Box<LinearTerm>),
    Pair(Box<LinearTerm>, Box<LinearTerm>),
    Let(String, String, Box<LinearTerm>, Box<LinearTerm>),
    Inl(Box<LinearTerm>),
    Inr(Box<LinearTerm>),
    Case(Box<LinearTerm>, String, Box<LinearTerm>, String, Box<LinearTerm>),
}

// 线性类型检查
fn linear_type_check(ctx: &HashMap<String, LinearType>, term: &LinearTerm) -> Option<LinearType> {
    match term {
        LinearTerm::Var(x) => ctx.get(x).cloned(),
        LinearTerm::Lam(x, t, body) => {
            let mut new_ctx = ctx.clone();
            new_ctx.insert(x.clone(), t.clone());
            linear_type_check(&new_ctx, body).map(|body_type| {
                LinearType::LinearArrow(Box::new(t.clone()), Box::new(body_type))
            })
        }
        LinearTerm::App(f, arg) => {
            if let Some(LinearType::LinearArrow(dom, cod)) = linear_type_check(ctx, f) {
                if let Some(arg_type) = linear_type_check(ctx, arg) {
                    if *dom == arg_type {
                        return Some(*cod);
                    }
                }
            }
            None
        }
        LinearTerm::Pair(t, u) => {
            let t_type = linear_type_check(ctx, t)?;
            let u_type = linear_type_check(ctx, u)?;
            Some(LinearType::Tensor(Box::new(t_type), Box::new(u_type)))
        }
        LinearTerm::Unit => Some(LinearType::Unit),
        _ => None,
    }
}

// 资源追踪
struct ResourceTracker {
    resources: HashMap<String, bool>,
}

impl ResourceTracker {
    fn new() -> Self {
        ResourceTracker {
            resources: HashMap::new(),
        }
    }
    
    fn allocate(&mut self, name: &str) -> bool {
        if self.resources.contains_key(name) {
            false
        } else {
            self.resources.insert(name.to_string(), true);
            true
        }
    }
    
    fn deallocate(&mut self, name: &str) -> bool {
        if self.resources.contains_key(name) {
            self.resources.remove(name);
            true
        } else {
            false
        }
    }
    
    fn is_allocated(&self, name: &str) -> bool {
        self.resources.contains_key(name)
    }
}
```

### 5.3 线性类型检查器

```haskell
-- 完整的线性类型检查器
module LinearTypeChecker where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set

-- 错误类型
data LinearTypeError = 
    TypeMismatch LinearType LinearType 
    | UnboundVariable String 
    | NotALinearFunction LinearType
    | DuplicateVariable String
    | UnusedVariable String

-- 线性类型检查器
linearTypeCheck :: Map String LinearType -> LinearTerm -> Either LinearTypeError LinearType
linearTypeCheck ctx (LVar x) = case Map.lookup x ctx of
    Just t -> Right t
    Nothing -> Left (UnboundVariable x)
linearTypeCheck ctx (LLam x t body) = do
    let newCtx = Map.insert x t ctx
    bodyType <- linearTypeCheck newCtx body
    return (LinearArrow t bodyType)
linearTypeCheck ctx (LApp f arg) = do
    fType <- linearTypeCheck ctx f
    argType <- linearTypeCheck ctx arg
    case fType of
        LinearArrow dom cod -> if dom == argType 
            then return cod 
            else Left (TypeMismatch dom argType)
        _ -> Left (NotALinearFunction fType)
linearTypeCheck ctx (LPair t u) = do
    tType <- linearTypeCheck ctx t
    uType <- linearTypeCheck ctx u
    return (Tensor tType uType)
linearTypeCheck ctx (LLet x y pair body) = do
    Tensor tType uType <- linearTypeCheck ctx pair
    bodyType <- linearTypeCheck ((x, tType) : (y, uType) : ctx) body
    return bodyType
linearTypeCheck ctx Unit = return Unit

-- 使用检查
checkUsage :: Set String -> LinearTerm -> Either LinearTypeError (Set String)
checkUsage used (LVar x) = 
    if Set.member x used 
    then Left (DuplicateVariable x)
    else Right (Set.insert x used)
checkUsage used (LLam x _ body) = do
    newUsed <- checkUsage used body
    if Set.member x newUsed 
    then Right (Set.delete x newUsed)
    else Left (UnusedVariable x)
checkUsage used (LApp f arg) = do
    fUsed <- checkUsage used f
    argUsed <- checkUsage fUsed arg
    return argUsed
checkUsage used Unit = return used
```

### 5.4 资源追踪器

```haskell
-- 资源追踪器
module ResourceTracker where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set

-- 资源状态
data ResourceState = Allocated | Deallocated | InUse

-- 资源追踪器
data ResourceTracker = ResourceTracker {
    resources :: Map String ResourceState,
    usageCount :: Map String Int
}

-- 创建追踪器
newTracker :: ResourceTracker
newTracker = ResourceTracker Map.empty Map.empty

-- 分配资源
allocate :: String -> ResourceTracker -> Either String ResourceTracker
allocate name tracker = 
    if Map.member name (resources tracker)
    then Left $ "Resource " ++ name ++ " already allocated"
    else Right $ tracker {
        resources = Map.insert name Allocated (resources tracker),
        usageCount = Map.insert name 0 (usageCount tracker)
    }

-- 使用资源
use :: String -> ResourceTracker -> Either String ResourceTracker
use name tracker = 
    case Map.lookup name (resources tracker) of
        Just Allocated -> Right $ tracker {
            resources = Map.insert name InUse (resources tracker),
            usageCount = Map.insertWith (+) name 1 (usageCount tracker)
        }
        Just InUse -> Right $ tracker {
            usageCount = Map.insertWith (+) name 1 (usageCount tracker)
        }
        Just Deallocated -> Left $ "Resource " ++ name ++ " already deallocated"
        Nothing -> Left $ "Resource " ++ name ++ " not allocated"

-- 释放资源
deallocate :: String -> ResourceTracker -> Either String ResourceTracker
deallocate name tracker = 
    case Map.lookup name (resources tracker) of
        Just InUse -> Right $ tracker {
            resources = Map.insert name Deallocated (resources tracker)
        }
        Just Allocated -> Right $ tracker {
            resources = Map.insert name Deallocated (resources tracker)
        }
        Just Deallocated -> Left $ "Resource " ++ name ++ " already deallocated"
        Nothing -> Left $ "Resource " ++ name ++ " not allocated"

-- 检查资源安全
checkSafety :: ResourceTracker -> Bool
checkSafety tracker = 
    all (\state -> state /= InUse) (Map.elems (resources tracker))
```

## 6. 扩展与变体

### 6.1 仿射类型

**定义 6.1.1** (仿射类型)
仿射类型 $A \rightarrow B$ 允许参数最多使用一次，但不强制使用。

**规则 6.1.2** (仿射抽象)
$$\frac{\Gamma, x : A \vdash t : B}{\Gamma \vdash \lambda x : A. t : A \rightarrow B}$$

### 6.2 相关类型

**定义 6.2.1** (相关类型)
相关类型 $A \& B$ 表示同时拥有类型 $A$ 和 $B$ 的资源，但只能使用其中一个。

**规则 6.2.2** (相关类型引入)
$$\frac{\Gamma \vdash t : A \quad \Gamma \vdash u : B}{\Gamma \vdash \langle t, u \rangle : A \& B}$$

### 6.3 量化线性类型

**定义 6.3.1** (量化线性类型)
量化线性类型允许类型参数，如 $\forall X. X \multimap X$。

**示例 6.3.2** (线性恒等函数)
$$\text{id} : \forall X. X \multimap X$$

### 6.4 高阶线性类型

**定义 6.4.1** (高阶线性类型)
高阶线性类型允许线性类型构造子作为参数。

**示例 6.4.2** (线性函子)
$$\text{map} : \forall F : \text{Type} \multimap \text{Type}. \forall A, B. (A \multimap B) \multimap F(A) \multimap F(B)$$

## 7. 应用实例

### 7.1 内存管理

线性类型系统用于安全的内存管理：

```rust
// Rust 的所有权系统
fn process_data(data: String) -> String {
    // data 被移动，原变量不能再使用
    data.to_uppercase()
}

fn main() {
    let s = String::from("hello");
    let result = process_data(s);
    // println!("{}", s); // 编译错误：s 已被移动
    println!("{}", result);
}
```

### 7.2 并发编程

线性类型系统用于安全的并发编程：

```haskell
-- 线性锁类型
data Lock a = Lock (MVar a)

-- 获取锁
acquire :: Lock a -> IO a
acquire (Lock mv) = takeMVar mv

-- 释放锁
release :: Lock a -> a -> IO ()
release (Lock mv) val = putMVar mv val

-- 使用锁
withLock :: Lock a -> (a -> IO b) -> IO b
withLock lock action = do
    val <- acquire lock
    result <- action val
    release lock val
    return result
```

### 7.3 量子计算

线性类型系统用于量子计算：

```haskell
-- 量子比特类型
data Qubit = Qubit (Complex Double)

-- 量子门操作
hadamard :: Qubit -> Qubit
hadamard (Qubit a) = Qubit ((a + conjugate a) / sqrt 2)

-- 测量操作（消耗量子比特）
measure :: Qubit -> IO Bool
measure (Qubit a) = do
    let prob = magnitude a ^ 2
    random <- randomIO
    return (random < prob)
```

### 7.4 系统编程

线性类型系统用于系统编程：

```rust
// 文件句柄的线性管理
struct File {
    handle: FileHandle,
}

impl File {
    fn open(path: &str) -> Result<File, Error> {
        let handle = FileHandle::open(path)?;
        Ok(File { handle })
    }
    
    fn read(&mut self, buffer: &mut [u8]) -> Result<usize, Error> {
        self.handle.read(buffer)
    }
}

impl Drop for File {
    fn drop(&mut self) {
        // 自动关闭文件
        self.handle.close();
    }
}
```

## 8. 参考文献

### 8.1 经典文献

1. **Girard, J.-Y.** (1987). Linear logic. *Theoretical Computer Science*, 50(1), 1-102.

2. **Wadler, P.** (1991). Is there a use for linear logic? *ACM SIGPLAN Notices*, 26(9), 255-273.

3. **Abramsky, S.** (1993). Computational interpretations of linear logic. *Theoretical Computer Science*, 111(1-2), 3-57.

### 8.2 现代发展

1. **Mazurak, K., Zhao, J., & Zdancewic, S.** (2010). Lightweight linear types in system F°. *ACM SIGPLAN Notices*, 45(9), 101-112.

2. **Bernardy, J.-P., Boespflug, M., Newton, R. R., Jones, S. P., & Spiwack, A.** (2018). Linear haskell: practical linearity in a higher-order polymorphic language. *ACM SIGPLAN Notices*, 53(10), 5-29.

3. **Jung, R., Krebbers, R., Dreyer, D., & Birkedal, L.** (2018). Iris from the ground up: A modular foundation for higher-order concurrent separation logic. *Journal of Functional Programming*, 28.

### 8.3 应用研究

1. **Rust Team** (2021). *The Rust Programming Language*. No Starch Press.

2. **Kiselyov, O.** (2016). The design and implementation of BER MetaOCaml. *Science of Computer Programming*, 111, 1-54.

3. **Morris, J. G.** (2016). The best of both worlds: linear functional programming without compromise. *ACM SIGPLAN Notices*, 51(9), 448-461.

### 8.4 未来方向

1. **量子线性类型**: 量子计算中的线性类型系统
2. **分布式线性类型**: 分布式系统中的资源管理
3. **机器学习线性类型**: AI系统中的资源优化
4. **硬件线性类型**: 硬件设计中的资源约束

---

## 交叉引用

- [01.1 类型理论基础](01.1_Type_Theory_Foundation.md)
- [01.3 仿射类型理论](01.3_Affine_Type_Theory.md)
- [01.4 依赖类型理论](01.4_Dependent_Type_Theory.md)
- [11.1 并发理论基础](../11_Concurrency_Theory/11.1_Concurrency_Theory_Foundation.md)
- [06.2 范畴论](../06_Mathematical_Foundation/06.2_Category_Theory.md)

## 更新日志

- **v1.0** (2024-12-23): 初始版本，包含基础理论和实现
- **v1.1** (2024-12-23): 添加完整的数学符号规范化
- **v1.2** (2024-12-23): 完善交叉引用和参考文献
