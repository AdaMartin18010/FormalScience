# 01.3 仿射类型理论 (Affine Type Theory)

## 目录

```markdown
01.3 仿射类型理论
├── 1. 理论基础
│   ├── 1.1 仿射逻辑公理系统
│   ├── 1.2 仿射性约束
│   └── 1.3 与线性类型的关系
├── 2. 形式化定义
│   ├── 2.1 语法定义
│   ├── 2.2 类型规则
│   └── 2.3 归约规则
├── 3. 语义理论
│   ├── 3.1 指称语义
│   ├── 3.2 操作语义
│   └── 3.3 范畴语义
├── 4. 元理论性质
│   ├── 4.1 类型安全性
│   ├── 4.2 强正规化
│   └── 4.3 一致性
├── 5. 实际应用
│   ├── 5.1 Rust 实现
│   ├── 5.2 Haskell 实现
│   └── 5.3 系统编程应用
├── 6. 扩展理论
│   ├── 6.1 高阶仿射类型
│   ├── 6.2 仿射依赖类型
│   └── 6.3 仿射量子类型
└── 7. 参考文献
```

## 1. 理论基础

### 1.1 仿射逻辑公理系统

**定义 1.1 (仿射上下文)**
仿射上下文 $\Gamma$ 是变量到类型的映射，其中每个变量最多使用一次：
$$\Gamma : \text{Var} \rightarrow \text{Type}$$

**定义 1.2 (仿射类型)**
仿射类型系统包含以下类型构造子：
$$\tau ::= \text{Base} \mid \tau_1 \rightarrow \tau_2 \mid \tau_1 \& \tau_2 \mid \tau_1 \oplus \tau_2$$

其中：
- $\rightarrow$ 表示仿射函数类型
- $\&$ 表示合取类型（with）
- $\oplus$ 表示析取类型（plus）

**公理 1.1 (仿射变量规则)**
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau}$$

**公理 1.2 (仿射抽象)**
$$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2}$$

**公理 1.3 (仿射应用)**
$$\frac{\Gamma_1 \vdash e_1 : \tau_1 \rightarrow \tau_2 \quad \Gamma_2 \vdash e_2 : \tau_1}{\Gamma_1, \Gamma_2 \vdash e_1 e_2 : \tau_2}$$

**公理 1.4 (仿射弱化)**
$$\frac{\Gamma \vdash e : \tau}{\Gamma, x : \tau' \vdash e : \tau}$$

### 1.2 仿射性约束

**定理 1.1 (仿射性保持)**
在仿射类型系统中，如果 $\Gamma \vdash e : \tau$，则 $\Gamma$ 中的每个变量在 $e$ 中最多出现一次。

**证明：** 通过结构归纳法证明。对于每个语法构造：

1. **变量**：直接满足仿射性
2. **抽象**：通过归纳假设，变量在体中最多出现一次
3. **应用**：通过上下文分离，确保变量不重复使用
4. **弱化**：允许忽略未使用的变量

**定理 1.2 (上下文分离)**
如果 $\Gamma_1, \Gamma_2 \vdash e : \tau$，则 $\Gamma_1$ 和 $\Gamma_2$ 中的变量集合不相交。

**证明：** 通过仿射性约束，每个变量最多使用一次，因此上下文必须分离。

### 1.3 与线性类型的关系

**定理 1.3 (仿射性蕴含线性性)**
如果 $\Gamma \vdash e : \tau$ 在仿射类型系统中成立，且 $e$ 中每个变量恰好出现一次，则在线性类型系统中也成立。

**证明：** 仿射类型系统是线性类型系统的弱化版本，通过移除收缩规则得到。

## 2. 形式化定义

### 2.1 语法定义

**定义 2.1 (仿射λ演算语法)**
$$\begin{align}
e &::= x \mid \lambda x.e \mid e_1 e_2 \mid \langle e_1, e_2 \rangle \mid \pi_1 e \mid \pi_2 e \\
   &\mid \text{inl } e \mid \text{inr } e \mid \text{case } e \text{ of } \text{inl } x_1 \Rightarrow e_1 \mid \text{inr } x_2 \Rightarrow e_2
\end{align}$$

**定义 2.2 (类型语法)**
$$\tau ::= \text{Base} \mid \tau_1 \rightarrow \tau_2 \mid \tau_1 \& \tau_2 \mid \tau_1 \oplus \tau_2$$

### 2.2 类型规则

**公理 2.1 (合取类型引入)**
$$\frac{\Gamma_1 \vdash e_1 : \tau_1 \quad \Gamma_2 \vdash e_2 : \tau_2}{\Gamma_1, \Gamma_2 \vdash \langle e_1, e_2 \rangle : \tau_1 \& \tau_2}$$

**公理 2.2 (合取类型消除)**
$$\frac{\Gamma \vdash e : \tau_1 \& \tau_2}{\Gamma \vdash \pi_1 e : \tau_1} \quad \frac{\Gamma \vdash e : \tau_1 \& \tau_2}{\Gamma \vdash \pi_2 e : \tau_2}$$

**公理 2.3 (析取类型引入)**
$$\frac{\Gamma \vdash e : \tau_1}{\Gamma \vdash \text{inl } e : \tau_1 \oplus \tau_2} \quad \frac{\Gamma \vdash e : \tau_2}{\Gamma \vdash \text{inr } e : \tau_1 \oplus \tau_2}$$

**公理 2.4 (析取类型消除)**
$$\frac{\Gamma \vdash e : \tau_1 \oplus \tau_2 \quad \Gamma, x_1 : \tau_1 \vdash e_1 : \tau \quad \Gamma, x_2 : \tau_2 \vdash e_2 : \tau}{\Gamma \vdash \text{case } e \text{ of } \text{inl } x_1 \Rightarrow e_1 \mid \text{inr } x_2 \Rightarrow e_2 : \tau}$$

### 2.3 归约规则

**定义 2.3 (仿射归约)**
$$\begin{align}
(\lambda x.e) v &\rightarrow e[v/x] \\
\pi_1 \langle e_1, e_2 \rangle &\rightarrow e_1 \\
\pi_2 \langle e_1, e_2 \rangle &\rightarrow e_2 \\
\text{case } (\text{inl } v) \text{ of } \text{inl } x_1 \Rightarrow e_1 \mid \text{inr } x_2 \Rightarrow e_2 &\rightarrow e_1[v/x_1] \\
\text{case } (\text{inr } v) \text{ of } \text{inl } x_1 \Rightarrow e_1 \mid \text{inr } x_2 \Rightarrow e_2 &\rightarrow e_2[v/x_2]
\end{align}$$

## 3. 语义理论

### 3.1 指称语义

**定义 3.1 (仿射函数空间)**
仿射函数空间 $A \rightarrow B$ 的语义：
$$\llbracket A \rightarrow B \rrbracket = \llbracket A \rrbracket \rightarrow \llbracket B \rrbracket$$

**定义 3.2 (合取类型语义)**
合取类型 $A \& B$ 的语义：
$$\llbracket A \& B \rrbracket = \llbracket A \rrbracket \times \llbracket B \rrbracket$$

**定义 3.3 (析取类型语义)**
析取类型 $A \oplus B$ 的语义：
$$\llbracket A \oplus B \rrbracket = \llbracket A \rrbracket + \llbracket B \rrbracket$$

### 3.2 操作语义

**定义 3.4 (小步语义)**
$$e \rightarrow e'$$

**定义 3.5 (大步语义)**
$$e \Downarrow v$$

**定理 3.1 (仿射归约保持类型)**
如果 $\Gamma \vdash e : \tau$ 且 $e \rightarrow e'$，则 $\Gamma \vdash e' : \tau$。

**证明：** 通过结构归纳法，对每个归约规则验证类型保持性。

### 3.3 范畴语义

**定义 3.6 (仿射范畴)**
仿射范畴是具有有限积和有限余积的范畴，满足仿射性约束。

**定理 3.2 (仿射类型系统的范畴语义)**
仿射类型系统可以解释为仿射范畴中的项。

## 4. 元理论性质

### 4.1 类型安全性

**定理 4.1 (类型保持性)**
如果 $\Gamma \vdash e : \tau$ 且 $e \rightarrow e'$，则 $\Gamma \vdash e' : \tau$。

**定理 4.2 (进展性)**
如果 $\emptyset \vdash e : \tau$，则要么 $e$ 是值，要么存在 $e'$ 使得 $e \rightarrow e'$。

### 4.2 强正规化

**定理 4.3 (强正规化)**
在仿射类型系统中，所有良类型的项都是强正规化的。

**证明：** 通过逻辑关系方法，构造强正规化关系并证明其保持性。

### 4.3 一致性

**定理 4.4 (类型系统一致性)**
如果 $\Gamma \vdash e : \tau$，则 $e$ 不会产生类型错误。

## 5. 实际应用

### 5.1 Rust 实现

```rust
// 仿射类型系统的 Rust 实现
use std::marker::PhantomData;

// 仿射函数类型
struct AffineFn<A, B> {
    f: Box<dyn FnOnce(A) -> B>,
}

impl<A, B> AffineFn<A, B> {
    fn new<F>(f: F) -> Self 
    where 
        F: FnOnce(A) -> B + 'static 
    {
        AffineFn { f: Box::new(f) }
    }
    
    fn apply(self, a: A) -> B {
        (self.f)(a)
    }
}

// 合取类型（with）
struct With<A, B> {
    a: A,
    b: B,
}

impl<A, B> With<A, B> {
    fn new(a: A, b: B) -> Self {
        With { a, b }
    }
    
    fn fst(self) -> A {
        self.a
    }
    
    fn snd(self) -> B {
        self.b
    }
}

// 析取类型（plus）
enum Plus<A, B> {
    Inl(A),
    Inr(B),
}

case' :: Plus a b -> (a -> c) -> (b -> c) -> c
case' (Inl a) f _ = f a
case' (Inr b) _ g = g b

// 示例：资源管理
struct FileHandle {
    id: u32,
}

impl Drop for FileHandle {
    fn drop(&mut self) {
        println!("Closing file handle {}", self.id);
    }
}

fn process_file(handle: FileHandle) -> String {
    // 处理文件，handle 被消费
    format!("Processed file {}", handle.id)
}

fn main() {
    let handle = FileHandle { id: 1 };
    let processor = AffineFn::new(process_file);
    let result = processor.apply(handle);
    println!("{}", result);
    // handle 已经被消费，无法再次使用
}
```

### 5.2 Haskell 实现

```haskell
-- 仿射类型系统的 Haskell 实现
{-# LANGUAGE GADTs #-}
{-# LANGUAGE TypeFamilies #-}

-- 仿射函数类型
newtype Affine a b = Affine { unAffine :: a -> b }

-- 合取类型（with）
data With a b = With a b

fst :: With a b -> a
fst (With a _) = a

snd :: With a b -> b
snd (With _ b) = b

-- 析取类型（plus）
data Plus a b = Inl a | Inr b

case' :: Plus a b -> (a -> c) -> (b -> c) -> c
case' (Inl a) f _ = f a
case' (Inr b) _ g = g b

-- 仿射单子
class AffineMonad m where
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b
    -- 注意：这里没有 join :: m (m a) -> m a

-- 资源管理示例
data Resource a = Resource a

instance AffineMonad Resource where
    return = Resource
    Resource a >>= f = f a

-- 文件处理示例
data FileHandle = FileHandle String

readFile :: FileHandle -> IO String
readFile (FileHandle path) = readFile path

processFile :: FileHandle -> Resource String
processFile handle = Resource $ "Processed: " ++ show handle

-- 使用示例
example :: IO ()
example = do
    let handle = FileHandle "test.txt"
    let processor = Affine processFile
    let result = unAffine processor handle
    print result
```

### 5.3 系统编程应用

**定理 5.1 (资源安全)**
仿射类型系统保证资源不会被重复释放或遗忘。

**证明：** 通过仿射性约束，每个资源变量最多使用一次，确保资源管理的安全性。

## 6. 扩展理论

### 6.1 高阶仿射类型

**定义 6.1 (高阶仿射类型)**
$$\tau ::= \alpha \mid \tau_1 \rightarrow \tau_2 \mid \forall \alpha.\tau \mid \exists \alpha.\tau$$

**公理 6.1 (全称类型引入)**
$$\frac{\Gamma, \alpha \vdash e : \tau}{\Gamma \vdash \Lambda \alpha.e : \forall \alpha.\tau}$$

**公理 6.2 (全称类型消除)**
$$\frac{\Gamma \vdash e : \forall \alpha.\tau}{\Gamma \vdash e[\tau'] : \tau[\alpha \mapsto \tau']}$$

### 6.2 仿射依赖类型

**定义 6.2 (Π类型)**
$$\frac{\Gamma, x : A \vdash B : \text{Type}}{\Gamma \vdash \Pi x : A.B : \text{Type}}$$

**定义 6.3 (Σ类型)**
$$\frac{\Gamma \vdash A : \text{Type} \quad \Gamma, x : A \vdash B : \text{Type}}{\Gamma \vdash \Sigma x : A.B : \text{Type}}$$

### 6.3 仿射量子类型

**定义 6.4 (量子仿射类型)**
$$\tau ::= \text{Qubit} \mid \tau_1 \rightarrow \tau_2 \mid \tau_1 \otimes \tau_2 \mid !\tau$$

**定理 6.1 (量子仿射性)**
量子仿射类型系统保证量子态的不可克隆性。

## 7. 参考文献

1. Girard, J. Y. (1987). Linear logic. Theoretical computer science, 50(1), 1-101.
2. Barber, A. (1996). Dual intuitionistic linear logic. Technical report, LFCS, University of Edinburgh.
3. Wadler, P. (1990). Linear types can change the world! Programming concepts and methods, 546-566.
4. Walker, D. (2005). Substructural type systems. Advanced topics in types and programming languages, 3-43.
5. Melliès, P. A. (2009). Categorical semantics of linear logic. Panoramas et synthèses, 27, 15-215.

---

**相关文档链接**：
- [01.1 类型理论基础](../01.1_Type_Theory_Foundation.md)
- [01.2 线性类型理论](../01.2_Linear_Type_Theory.md)
- [01.4 依赖类型理论](../01.4_Dependent_Type_Theory.md)
- [02.1 形式语言基础](../02_Formal_Language_Theory/02.1_Formal_Language_Foundation.md)
