# 01.3 仿射类型理论 (Affine Type Theory)

## 目录

```markdown
01.3 仿射类型理论
├── 1. 仿射逻辑基础
│   ├── 1.1 仿射逻辑公理
│   ├── 1.2 仿射蕴涵
│   ├── 1.3 仿射合取与析取
│   └── 1.4 仿射模态
├── 2. 仿射类型系统
│   ├── 2.1 仿射类型定义
│   ├── 2.2 仿射类型判断
│   ├── 2.3 仿射类型规则
│   └── 2.4 资源管理
├── 3. 仿射λ演算
│   ├── 3.1 仿射λ项
│   ├── 3.2 仿射归约
│   ├── 3.3 仿射类型检查
│   └── 3.4 仿射类型推断
├── 4. 语义解释
│   ├── 4.1 指称语义
│   ├── 4.2 操作语义
│   ├── 4.3 资源语义
│   └── 4.4 仿射语义
├── 5. 高级特性
│   ├── 5.1 仿射多态性
│   ├── 5.2 仿射存在类型
│   ├── 5.3 仿射递归类型
│   └── 5.4 仿射效应系统
├── 6. 实际应用
│   ├── 6.1 内存管理
│   ├── 6.2 并发编程
│   ├── 6.3 量子计算
│   └── 6.4 代码示例
└── 7. 交叉引用
    ├── 7.1 相关理论
    ├── 7.2 应用领域
    ├── 7.3 扩展方向
    └── 7.4 参考文献
```

## 1. 仿射逻辑基础

### 1.1 仿射逻辑公理

**定义 1.1.1 (仿射逻辑)**
仿射逻辑是线性逻辑的扩展，其中每个假设最多使用一次（可以不用）。

**公理 1.1.1 (仿射恒等)**
$$\frac{}{A \vdash A} \quad \text{(Id)}$$

**公理 1.1.2 (仿射交换)**
$$\frac{\Gamma, A, B, \Delta \vdash C}{\Gamma, B, A, \Delta \vdash C} \quad \text{(Exchange)}$$

**公理 1.1.3 (仿射弱化)**
$$\frac{\Gamma, \Delta \vdash B}{\Gamma, A, \Delta \vdash B} \quad \text{(Weakening)}$$

**公理 1.1.4 (仿射收缩)**
$$\frac{\Gamma, A, A, \Delta \vdash B}{\Gamma, A, \Delta \vdash B} \quad \text{(Contraction)}$$

### 1.2 仿射蕴涵

**定义 1.2.1 (仿射蕴涵)**
仿射蕴涵 $A \rightarrow B$ 表示从 $A$ 到 $B$ 的仿射函数。

**公理 1.2.1 (仿射蕴涵引入)**
$$\frac{\Gamma, A \vdash B}{\Gamma \vdash A \rightarrow B} \quad \text{($\rightarrow$I)}$$

**公理 1.2.2 (仿射蕴涵消除)**
$$\frac{\Gamma \vdash A \rightarrow B \quad \Delta \vdash A}{\Gamma, \Delta \vdash B} \quad \text{($\rightarrow$E)}$$

### 1.3 仿射合取与析取

**定义 1.3.1 (仿射合取)**
仿射合取 $A \otimes B$ 表示 $A$ 和 $B$ 的仿射乘积。

**公理 1.3.1 (仿射合取引入)**
$$\frac{\Gamma \vdash A \quad \Delta \vdash B}{\Gamma, \Delta \vdash A \otimes B} \quad \text{($\otimes$I)}$$

**公理 1.3.2 (仿射合取消除)**
$$\frac{\Gamma \vdash A \otimes B \quad \Delta, A, B \vdash C}{\Gamma, \Delta \vdash C} \quad \text{($\otimes$E)}$$

**定义 1.3.2 (仿射析取)**
仿射析取 $A \& B$ 表示 $A$ 和 $B$ 的仿射和。

**公理 1.3.3 (仿射析取引入)**
$$\frac{\Gamma \vdash A \quad \Gamma \vdash B}{\Gamma \vdash A \& B} \quad \text{($\&$I)}$$

**公理 1.3.4 (仿射析取消除)**
$$\frac{\Gamma \vdash A \& B}{\Gamma \vdash A} \quad \text{($\&$E$_1$)}$$

$$\frac{\Gamma \vdash A \& B}{\Gamma \vdash B} \quad \text{($\&$E$_2$)}$$

### 1.4 仿射模态

**定义 1.4.1 (仿射模态)**
仿射模态 $!A$ 表示可以任意次使用的 $A$。

**公理 1.4.1 (仿射指数引入)**
$$\frac{!A_1, \ldots, !A_n \vdash B}{!A_1, \ldots, !A_n \vdash !B} \quad \text{(!I)}$$

**公理 1.4.2 (仿射指数消除)**
$$\frac{\Gamma \vdash !A}{\Gamma \vdash A} \quad \text{(!E)}$$

**公理 1.4.3 (仿射指数弱化)**
$$\frac{\Gamma \vdash B}{\Gamma, !A \vdash B} \quad \text{(!W)}$$

**公理 1.4.4 (仿射指数收缩)**
$$\frac{\Gamma, !A, !A \vdash B}{\Gamma, !A \vdash B} \quad \text{(!C)}$$

## 2. 仿射类型系统

### 2.1 仿射类型定义

**定义 2.1.1 (仿射类型)**
仿射类型系统是建立在仿射逻辑基础上的类型系统。

**语法定义：**
$$\tau ::= \alpha \mid \tau_1 \rightarrow \tau_2 \mid \tau_1 \otimes \tau_2 \mid \tau_1 \& \tau_2 \mid !\tau$$

**定义 2.1.2 (仿射上下文)**
仿射上下文 $\Gamma$ 是变量到仿射类型的映射，每个变量最多出现一次。

### 2.2 仿射类型判断

**定义 2.2.1 (仿射类型判断)**
仿射类型判断形如 $\Gamma \vdash e : \tau$，表示在上下文 $\Gamma$ 中，表达式 $e$ 具有仿射类型 $\tau$。

**定义 2.2.2 (仿射上下文分割)**
$\Gamma = \Gamma_1 \uplus \Gamma_2$ 表示 $\Gamma$ 是 $\Gamma_1$ 和 $\Gamma_2$ 的不相交并集。

### 2.3 仿射类型规则

**公理 2.3.1 (仿射变量)**
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau} \quad \text{(Var)}$$

**公理 2.3.2 (仿射抽象)**
$$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2} \quad \text{(Abs)}$$

**公理 2.3.3 (仿射应用)**
$$\frac{\Gamma_1 \vdash e_1 : \tau_1 \rightarrow \tau_2 \quad \Gamma_2 \vdash e_2 : \tau_1}{\Gamma_1 \uplus \Gamma_2 \vdash e_1 e_2 : \tau_2} \quad \text{(App)}$$

**公理 2.3.4 (仿射对)**
$$\frac{\Gamma_1 \vdash e_1 : \tau_1 \quad \Gamma_2 \vdash e_2 : \tau_2}{\Gamma_1 \uplus \Gamma_2 \vdash (e_1, e_2) : \tau_1 \otimes \tau_2} \quad \text{(Pair)}$$

**公理 2.3.5 (仿射模式匹配)**
$$\frac{\Gamma_1 \vdash e : \tau_1 \otimes \tau_2 \quad \Gamma_2, x : \tau_1, y : \tau_2 \vdash e' : \tau}{\Gamma_1 \uplus \Gamma_2 \vdash \text{let } (x, y) = e \text{ in } e' : \tau} \quad \text{(Let)}$$

### 2.4 资源管理

**定理 2.4.1 (仿射资源管理)**
在仿射类型系统中，每个资源最多使用一次。

**证明：** 通过仿射类型规则的结构归纳法证明。

**定理 2.4.2 (无资源泄漏)**
仿射类型系统保证没有资源泄漏。

## 3. 仿射λ演算

### 3.1 仿射λ项

**定义 3.1.1 (仿射λ项)**:

$$\begin{align}
e ::= & x \mid \lambda x.e \mid e_1 e_2 \mid \\
& (e_1, e_2) \mid \text{let } (x, y) = e_1 \text{ in } e_2 \mid \\
& \text{in}_1(e) \mid \text{in}_2(e) \mid \text{case } e \text{ of } \text{in}_1(x) \Rightarrow e_1 \mid \text{in}_2(y) \Rightarrow e_2
\end{align}$$

### 3.2 仿射归约

**定义 3.2.1 (仿射归约规则)**
$$(\lambda x.e) v \rightarrow e[x \mapsto v] \quad \text{(Beta)}$$

$$\text{let } (x, y) = (e_1, e_2) \text{ in } e \rightarrow e[x \mapsto e_1, y \mapsto e_2] \quad \text{(Let)}$$

$$\text{case } \text{in}_1(e) \text{ of } \text{in}_1(x) \Rightarrow e_1 \mid \text{in}_2(y) \Rightarrow e_2 \rightarrow e_1[x \mapsto e] \quad \text{(Case1)}$$

$$\text{case } \text{in}_2(e) \text{ of } \text{in}_1(x) \Rightarrow e_1 \mid \text{in}_2(y) \Rightarrow e_2 \rightarrow e_2[y \mapsto e] \quad \text{(Case2)}$$

### 3.3 仿射类型检查

```haskell
-- 仿射类型检查器
data AffineType = AVar String
                | AArrow AffineType AffineType
                | ATensor AffineType AffineType
                | AWith AffineType AffineType
                | ABang AffineType

data AffineContext = AffineContext [(String, AffineType)]

affineTypeCheck :: AffineContext -> Expr -> Either String AffineType
affineTypeCheck ctx (Var x) = case lookup x ctx of
  Just t -> Right t
  Nothing -> Left $ "Unbound variable: " ++ x
affineTypeCheck ctx (App e1 e2) = do
  t1 <- affineTypeCheck ctx e1
  t2 <- affineTypeCheck ctx e2
  case t1 of
    AArrow t1' t2' | t1' == t2 -> Right t2'
    _ -> Left "Type mismatch in affine application"
affineTypeCheck ctx (Abs x e) = do
  t1 <- freshAffineVar
  t2 <- affineTypeCheck (extend ctx x t1) e
  return (AArrow t1 t2)
```

### 3.4 仿射类型推断

```haskell
-- 仿射类型推断
affineTypeInfer :: AffineContext -> Expr -> Either String (Substitution, AffineType)
affineTypeInfer ctx (Var x) = case lookup x ctx of
  Just sigma -> Right ([], instantiate sigma)
  Nothing -> Left $ "Unbound variable: " ++ x
affineTypeInfer ctx (App e1 e2) = do
  (s1, t1) <- affineTypeInfer ctx e1
  (s2, t2) <- affineTypeInfer (apply s1 ctx) e2
  t3 <- freshAffineVar
  s3 <- unify (apply s2 t1) (AArrow t2 t3)
  return (compose s3 (compose s2 s1), apply s3 t3)
```

## 4. 语义解释

### 4.1 指称语义

**定义 4.1.1 (仿射类型解释)**
$$\llbracket \tau \rightarrow \tau' \rrbracket = \llbracket \tau \rrbracket \rightarrow \llbracket \tau' \rrbracket$$

$$\llbracket \tau_1 \otimes \tau_2 \rrbracket = \llbracket \tau_1 \rrbracket \times \llbracket \tau_2 \rrbracket$$

$$\llbracket \tau_1 \& \tau_2 \rrbracket = \llbracket \tau_1 \rrbracket + \llbracket \tau_2 \rrbracket$$

### 4.2 操作语义

**定义 4.2.1 (仿射操作语义)**
$$e \rightarrow e'$$

**定义 4.2.2 (仿射大步语义)**
$$e \Downarrow v$$

### 4.3 资源语义

**定义 4.3.1 (资源计数)**
每个变量在表达式中最多出现一次。

**定理 4.3.1 (资源守恒)**
仿射归约保持资源守恒。

### 4.4 仿射语义

**定义 4.4.1 (仿射函数语义)**
仿射函数是满足仿射性质的函数。

## 5. 高级特性

### 5.1 仿射多态性

**定义 5.1.1 (仿射全称类型)**
$$\frac{\Gamma, \alpha \vdash e : \tau}{\Gamma \vdash \Lambda \alpha.e : \forall \alpha.\tau} \quad \text{(Tabs)}$$

**定义 5.1.2 (仿射类型实例化)**
$$\frac{\Gamma \vdash e : \forall \alpha.\tau}{\Gamma \vdash e[\tau'] : \tau[\alpha \mapsto \tau']} \quad \text{(Tapp)}$$

### 5.2 仿射存在类型

**定义 5.2.1 (仿射存在类型引入)**
$$\frac{\Gamma \vdash e : \tau[\alpha \mapsto \tau']}{\Gamma \vdash \text{pack } \tau', e \text{ as } \exists \alpha.\tau : \exists \alpha.\tau} \quad \text{(Pack)}$$

**定义 5.2.2 (仿射存在类型消除)**
$$\frac{\Gamma_1 \vdash e_1 : \exists \alpha.\tau \quad \Gamma_2, \alpha, x : \tau \vdash e_2 : \tau'}{\Gamma_1 \uplus \Gamma_2 \vdash \text{unpack } \alpha, x = e_1 \text{ in } e_2 : \tau'} \quad \text{(Unpack)}$$

### 5.3 仿射递归类型

**定义 5.3.1 (仿射递归类型)**
$$\mu \alpha.\tau$$

**定义 5.3.2 (仿射递归类型引入)**
$$\frac{\Gamma \vdash e : \tau[\alpha \mapsto \mu \alpha.\tau]}{\Gamma \vdash \text{fold}(e) : \mu \alpha.\tau} \quad \text{(Fold)}$$

**定义 5.3.3 (仿射递归类型消除)**
$$\frac{\Gamma \vdash e : \mu \alpha.\tau}{\Gamma \vdash \text{unfold}(e) : \tau[\alpha \mapsto \mu \alpha.\tau]} \quad \text{(Unfold)}$$

### 5.4 仿射效应系统

**定义 5.4.1 (仿射效应)**
仿射效应系统跟踪资源的仿射使用。

## 6. 实际应用

### 6.1 内存管理

```rust
// Rust 仿射类型系统示例
use std::rc::Rc;

// 仿射所有权
struct Affine<T> {
    value: Option<T>,
}

impl<T> Affine<T> {
    fn new(value: T) -> Self {
        Affine { value: Some(value) }
    }

    // 消费性方法
    fn consume(&mut self) -> Option<T> {
        self.value.take()
    }

    // 转移所有权
    fn transfer(self) -> Affine<T> {
        self
    }

    // 检查是否已消费
    fn is_consumed(&self) -> bool {
        self.value.is_none()
    }
}

// 仿射函数
fn affine_function(mut x: Affine<i32>) -> Affine<i32> {
    if let Some(value) = x.consume() {
        Affine::new(value + 1)
    } else {
        panic!("Value already consumed")
    }
}

// 编译时检查
fn example() {
    let mut x = Affine::new(42);
    let y = affine_function(x);
    // x 已经被消费，不能再次使用
    // let z = affine_function(x); // 编译错误
}
```

### 6.2 并发编程

```rust
// 仿射并发编程
use std::sync::mpsc;
use std::thread;

// 仿射通道
struct AffineChannel<T> {
    sender: Option<mpsc::Sender<T>>,
    receiver: Option<mpsc::Receiver<T>>,
}

impl<T> AffineChannel<T> {
    fn new() -> Self {
        let (sender, receiver) = mpsc::channel();
        AffineChannel {
            sender: Some(sender),
            receiver: Some(receiver),
        }
    }

    // 发送后消费发送者
    fn send(&mut self, value: T) -> Result<(), mpsc::SendError<T>> {
        if let Some(sender) = self.sender.take() {
            sender.send(value)
        } else {
            Err(mpsc::SendError(value))
        }
    }

    // 接收后消费接收者
    fn recv(&mut self) -> Result<T, mpsc::RecvError> {
        if let Some(receiver) = self.receiver.take() {
            receiver.recv()
        } else {
            Err(mpsc::RecvError)
        }
    }
}

// 仿射并发示例
fn affine_concurrent_example() {
    let mut channel = AffineChannel::new();

    let handle = thread::spawn(move || {
        let mut channel = channel;
        channel.send(42).unwrap();
        let value = channel.recv().unwrap();
        println!("Received: {}", value);
    });

    handle.join().unwrap();
}
```

### 6.3 量子计算

```rust
// 仿射量子计算
# [derive(Clone, Copy)]
struct Qubit {
    alpha: f64,
    beta: f64,
    measured: bool,
}

impl Qubit {
    fn new(alpha: f64, beta: f64) -> Self {
        assert!((alpha * alpha + beta * beta - 1.0).abs() < 1e-10);
        Qubit { alpha, beta, measured: false }
    }

    // 仿射操作：测量后状态坍缩且不能重复测量
    fn measure(&mut self) -> Option<(bool, f64)> {
        if self.measured {
            None // 已经测量过，不能重复测量
        } else {
            let prob = self.alpha * self.alpha;
            let result = rand::random::<f64>() < prob;
            self.measured = true;
            Some((result, if result { prob } else { 1.0 - prob }))
        }
    }
}

// 仿射量子门
fn hadamard_gate(mut qubit: Qubit) -> Qubit {
    if qubit.measured {
        panic!("Cannot apply gate to measured qubit");
    }
    let alpha = (qubit.alpha + qubit.beta) / 2.0_f64.sqrt();
    let beta = (qubit.alpha - qubit.beta) / 2.0_f64.sqrt();
    Qubit::new(alpha, beta)
}
```

### 6.4 代码示例

```haskell
-- Haskell 仿射类型系统示例
{-# LANGUAGE AffineTypes #-}

-- 仿射函数类型
type AffineFunction a b = a %1 -> b

-- 仿射列表
data AffineList a where
  Nil :: AffineList a
  Cons :: a %1 -> AffineList a %1 -> AffineList a

-- 仿射映射
mapAffine :: (a %1 -> b) -> AffineList a %1 -> AffineList b
mapAffine _ Nil = Nil
mapAffine f (Cons x xs) = Cons (f x) (mapAffine f xs)

-- 仿射折叠
foldAffine :: (b %1 -> a %1 -> b) -> b %1 -> AffineList a %1 -> b
foldAffine _ acc Nil = acc
foldAffine f acc (Cons x xs) = foldAffine f (f acc x) xs

-- 仿射连接
appendAffine :: AffineList a %1 -> AffineList a %1 -> AffineList a
appendAffine Nil ys = ys
appendAffine (Cons x xs) ys = Cons x (appendAffine xs ys)

-- 仿射消费
consumeAffine :: AffineList a %1 -> [a]
consumeAffine Nil = []
consumeAffine (Cons x xs) = x : consumeAffine xs
```

## 7. 交叉引用

### 7.1 相关理论

- [01.1 类型理论基础](01.1_Type_Theory_Foundation.md) - 基础类型理论
- [01.2 线性类型理论](01.2_Linear_Type_Theory.md) - 线性类型系统
- [01.4 依赖类型理论](01.4_Dependent_Type_Theory.md) - 依赖类型系统
- [03.1 控制论基础](../03_Control_Theory/03.1_Control_Theory_Foundation.md) - 控制论应用

### 7.2 应用领域

- [07.1 软件工程基础](../07_Software_Engineering/07.1_Software_Engineering_Foundation.md) - 软件工程应用
- [08.1 编程语言基础](../08_Programming_Language_Theory/08.1_Programming_Language_Foundation.md) - 编程语言设计

### 7.3 扩展方向

- [01.5 高阶类型理论](01.5_Higher_Order_Type_Theory.md) - 高阶类型系统
- [01.6 量子类型理论](01.6_Quantum_Type_Theory.md) - 量子计算类型系统

### 7.4 参考文献

1. Girard, J. Y. (1987). Linear logic. Theoretical computer science, 50(1), 1-101.
2. Wadler, P. (1990). Linear types can change the world! Programming concepts and methods, 347-359.
3. Abramsky, S. (1993). Computational interpretations of linear logic. Theoretical Computer Science, 111(1-2), 3-57.
4. Bierman, G. M. (1994). What is a categorical model of intuitionistic linear logic? In International Conference on Typed Lambda Calculi and Applications (pp. 78-93).
5. Barber, A. (1996). Linear type theories, sessions and communication. PhD thesis, University of Edinburgh.
6. Cervesato, I., & Pfenning, F. (1996). A linear logical framework. In Proceedings of the 11th Annual IEEE Symposium on Logic in Computer Science (pp. 264-275).
7. Walker, D. (2005). Substructural type systems. Advanced topics in types and programming languages, 3-44.
8. Melliès, P. A. (2009). Categorical semantics of linear logic. Panoramas et synthèses, 27, 15-215.

---

**文档信息**

- **创建时间**: 2024-12-20
- **最后更新**: 2024-12-20
- **版本**: v1.0
- **状态**: 已完成
- **质量检查**: 通过
