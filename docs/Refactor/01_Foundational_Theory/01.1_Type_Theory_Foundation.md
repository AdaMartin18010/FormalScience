# 01.1 类型理论基础 (Type Theory Foundation)

## 目录

```markdown
01.1 类型理论基础
├── 1. 基础定义与公理
│   ├── 1.1 类型系统基础
│   ├── 1.2 类型判断规则
│   └── 1.3 基本公理系统
├── 2. 类型安全性理论
│   ├── 2.1 类型保持性定理
│   ├── 2.2 进展性定理
│   └── 2.3 强正规化定理
├── 3. 类型推断算法
│   ├── 3.1 Hindley-Milner系统
│   ├── 3.2 算法W实现
│   └── 3.3 正确性证明
├── 4. 语义理论
│   ├── 4.1 指称语义
│   ├── 4.2 操作语义
│   └── 4.3 公理语义
├── 5. 高级类型系统
│   ├── 5.1 参数多态性
│   ├── 5.2 存在类型
│   └── 5.3 高阶类型
├── 6. 依赖类型系统
│   ├── 6.1 Π类型
│   ├── 6.2 Σ类型
│   └── 6.3 依赖函数
├── 7. 元理论
│   ├── 7.1 一致性
│   ├── 7.2 完备性
│   └── 7.3 可判定性
├── 8. 实际应用
│   ├── 8.1 编译器实现
│   ├── 8.2 类型检查器
│   └── 8.3 代码示例
└── 9. 交叉引用
    ├── 9.1 相关理论
    ├── 9.2 扩展阅读
    └── 9.3 参考文献
```

## 1. 基础定义与公理

### 1.1 类型系统基础

**定义 1.1.1 (类型上下文)**
设 $\Gamma$ 为类型上下文，定义为变量到类型的映射：
$$\Gamma : \text{Var} \rightarrow \text{Type}$$

**定义 1.1.2 (类型环境)**
类型环境 $\rho$ 是类型变量到类型的映射：
$$\rho : \text{TypeVar} \rightarrow \text{Type}$$

**定义 1.1.3 (类型替换)**
类型替换 $\sigma$ 是类型变量到类型的映射：
$$\sigma : \text{TypeVar} \rightarrow \text{Type}$$

### 1.2 类型判断规则

**公理 1.2.1 (变量规则)**
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau} \quad \text{(Var)}$$

**公理 1.2.2 (函数抽象)**
$$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2} \quad \text{(Abs)}$$

**公理 1.2.3 (函数应用)**
$$\frac{\Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2 \quad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1 e_2 : \tau_2} \quad \text{(App)}$$

**公理 1.2.4 (类型抽象)**
$$\frac{\Gamma, \alpha \vdash e : \tau}{\Gamma \vdash \Lambda \alpha.e : \forall \alpha.\tau} \quad \text{(TAbs)}$$

**公理 1.2.5 (类型应用)**
$$\frac{\Gamma \vdash e : \forall \alpha.\tau}{\Gamma \vdash e[\tau'] : \tau[\alpha \mapsto \tau']} \quad \text{(TApp)}$$

### 1.3 基本公理系统

**公理 1.3.1 (类型等价性)**
$$\frac{\Gamma \vdash e : \tau \quad \tau \equiv \tau'}{\Gamma \vdash e : \tau'} \quad \text{(Eq)}$$

**公理 1.3.2 (上下文扩展)**
$$\frac{\Gamma \vdash e : \tau \quad x \notin \text{dom}(\Gamma)}{\Gamma, x : \tau' \vdash e : \tau} \quad \text{(Weak)}$$

## 2. 类型安全性理论

### 2.1 类型保持性定理

**定理 2.1.1 (类型保持性 - Type Preservation)**
如果 $\Gamma \vdash e : \tau$ 且 $e \rightarrow e'$，则 $\Gamma \vdash e' : \tau$。

**证明：** 通过结构归纳法证明。对于每个归约规则，需要证明类型在归约后保持不变。

**归约规则：**

1. **β归约**：$(\lambda x.e_1) e_2 \rightarrow e_1[x \mapsto e_2]$
2. **η归约**：$\lambda x.(e x) \rightarrow e$ (如果 $x \notin \text{FV}(e)$)
3. **类型β归约**：$(\Lambda \alpha.e)[\tau] \rightarrow e[\alpha \mapsto \tau]$

**证明步骤：**

1. **β归约情况**：
   - 假设：$\Gamma \vdash (\lambda x.e_1) e_2 : \tau_2$
   - 根据App规则：$\Gamma \vdash \lambda x.e_1 : \tau_1 \rightarrow \tau_2$ 且 $\Gamma \vdash e_2 : \tau_1$
   - 根据Abs规则：$\Gamma, x : \tau_1 \vdash e_1 : \tau_2$
   - 根据替换引理：$\Gamma \vdash e_1[x \mapsto e_2] : \tau_2$

2. **η归约情况**：
   - 假设：$\Gamma \vdash \lambda x.(e x) : \tau_1 \rightarrow \tau_2$
   - 根据Abs规则：$\Gamma, x : \tau_1 \vdash e x : \tau_2$
   - 根据App规则：$\Gamma, x : \tau_1 \vdash e : \tau_1 \rightarrow \tau_2$
   - 由于 $x \notin \text{FV}(e)$，有 $\Gamma \vdash e : \tau_1 \rightarrow \tau_2$

### 2.2 进展性定理

**定理 2.2.1 (进展性 - Progress)**
如果 $\emptyset \vdash e : \tau$，则要么 $e$ 是值，要么存在 $e'$ 使得 $e \rightarrow e'$。

**证明：** 通过结构归纳法证明。对于每个语法构造，证明要么是值，要么可以继续归约。

**值的定义：**
- 变量 $x$ 不是值
- 抽象 $\lambda x.e$ 是值
- 类型抽象 $\Lambda \alpha.e$ 是值
- 应用 $e_1 e_2$ 不是值（除非 $e_1$ 和 $e_2$ 都是值且 $e_1$ 是抽象）

**证明步骤：**

1. **变量情况**：$\emptyset \vdash x : \tau$ 不可能，因为 $x \notin \emptyset$

2. **抽象情况**：$\emptyset \vdash \lambda x.e : \tau_1 \rightarrow \tau_2$
   - $\lambda x.e$ 是值，无需归约

3. **应用情况**：$\emptyset \vdash e_1 e_2 : \tau_2$
   - 根据App规则：$\emptyset \vdash e_1 : \tau_1 \rightarrow \tau_2$ 且 $\emptyset \vdash e_2 : \tau_1$
   - 根据归纳假设：
     - 如果 $e_1$ 不是值，则 $e_1 \rightarrow e_1'$，所以 $e_1 e_2 \rightarrow e_1' e_2$
     - 如果 $e_1$ 是值，则 $e_1 = \lambda x.e_1'$
     - 如果 $e_2$ 不是值，则 $e_2 \rightarrow e_2'$，所以 $e_1 e_2 \rightarrow e_1 e_2'$
     - 如果 $e_2$ 是值，则可以进行β归约：$(\lambda x.e_1') e_2 \rightarrow e_1'[x \mapsto e_2]$

### 2.3 强正规化定理

**定理 2.3.1 (强正规化)**
在强类型系统中，所有良类型的项都是强正规化的。

**定义 2.3.1 (强正规化)**
项 $e$ 是强正规化的，如果不存在无限归约序列 $e \rightarrow e_1 \rightarrow e_2 \rightarrow \cdots$。

**证明思路：**
通过逻辑关系（logical relation）或可归约性（reducibility）方法证明。

## 3. 类型推断算法

### 3.1 Hindley-Milner系统

**定义 3.1.1 (类型模式)**
类型模式是可能包含类型变量的类型表达式。

**定义 3.1.2 (类型模式实例化)**
如果存在替换 $\sigma$ 使得 $\sigma(\tau) = \tau'$，则称 $\tau'$ 是 $\tau$ 的实例。

**定义 3.1.3 (最一般类型)**
如果 $\tau$ 是 $e$ 的类型，且对于 $e$ 的任意类型 $\tau'$，都有 $\tau'$ 是 $\tau$ 的实例，则称 $\tau$ 是 $e$ 的最一般类型。

### 3.2 算法W实现

**算法W (Robinson's Unification)**

```haskell
-- 类型定义
data Type = TVar String
          | TArrow Type Type
          | TCon String
          | TForall String Type
          deriving (Eq, Show)

type Substitution = [(String, Type)]

-- 自由类型变量
ftv :: Type -> [String]
ftv (TVar a) = [a]
ftv (TArrow t1 t2) = ftv t1 ++ ftv t2
ftv (TCon _) = []
ftv (TForall a t) = filter (/= a) (ftv t)

-- 替换应用
apply :: Substitution -> Type -> Type
apply s (TVar a) = case lookup a s of
  Just t -> t
  Nothing -> TVar a
apply s (TArrow t1 t2) = TArrow (apply s t1) (apply s t2)
apply s (TCon c) = TCon c
apply s (TForall a t) = TForall a (apply (filter ((/= a) . fst) s) t)

-- 替换组合
compose :: Substitution -> Substitution -> Substitution
compose s1 s2 = [(a, apply s1 t) | (a, t) <- s2] ++ s1

-- 统一算法
unify :: Type -> Type -> Either String Substitution
unify (TVar a) t
  | a `elem` ftv t = Left "Occurs check failed"
  | otherwise = Right [(a, t)]
unify t (TVar a) = unify (TVar a) t
unify (TArrow t1 t2) (TArrow t1' t2') = do
  s1 <- unify t1 t1'
  s2 <- unify (apply s1 t2) (apply s1 t2')
  return (compose s2 s1)
unify (TCon a) (TCon b)
  | a == b = Right []
  | otherwise = Left "Type constructor mismatch"
unify _ _ = Left "Type mismatch"

-- 类型推断
typeInfer :: [(String, Type)] -> Expr -> Either String (Substitution, Type)
typeInfer ctx (Var x) = case lookup x ctx of
  Just t -> Right ([], t)
  Nothing -> Left $ "Unbound variable: " ++ x
typeInfer ctx (App e1 e2) = do
  (s1, t1) <- typeInfer ctx e1
  (s2, t2) <- typeInfer (apply s1 ctx) e2
  t3 <- freshTVar
  s3 <- unify (apply s2 t1) (TArrow t2 t3)
  return (compose s3 (compose s2 s1), apply s3 t3)
typeInfer ctx (Abs x e) = do
  t1 <- freshTVar
  (s, t2) <- typeInfer ((x, t1) : ctx) e
  return (s, TArrow (apply s t1) t2)
```

### 3.3 正确性证明

**定理 3.3.1 (算法W的正确性)**
如果算法W成功，则返回的替换是最一般的一致替换。

**定理 3.3.2 (算法W的完备性)**
如果存在类型，则算法W能够找到。

## 4. 语义理论

### 4.1 指称语义

**定义 4.1.1 (类型解释)**
$$\llbracket \tau \rrbracket_\rho = \text{语义域}$$

**定义 4.1.2 (表达式解释)**
$$\llbracket e \rrbracket_{\rho,\sigma} : \llbracket \tau \rrbracket_\rho$$

**语义规则：**

1. **变量**：$\llbracket x \rrbracket_{\rho,\sigma} = \sigma(x)$
2. **抽象**：$\llbracket \lambda x.e \rrbracket_{\rho,\sigma} = \lambda v.\llbracket e \rrbracket_{\rho,\sigma[x \mapsto v]}$
3. **应用**：$\llbracket e_1 e_2 \rrbracket_{\rho,\sigma} = \llbracket e_1 \rrbracket_{\rho,\sigma} (\llbracket e_2 \rrbracket_{\rho,\sigma})$

### 4.2 操作语义

**定义 4.2.1 (小步语义)**
$$e \rightarrow e'$$

**归约规则：**

1. **β归约**：$(\lambda x.e_1) e_2 \rightarrow e_1[x \mapsto e_2]$
2. **η归约**：$\lambda x.(e x) \rightarrow e$ (如果 $x \notin \text{FV}(e)$)
3. **类型β归约**：$(\Lambda \alpha.e)[\tau] \rightarrow e[\alpha \mapsto \tau]$

**定义 4.2.2 (大步语义)**
$$e \Downarrow v$$

**求值规则：**

1. **值**：$v \Downarrow v$
2. **应用**：$\frac{e_1 \Downarrow \lambda x.e_1' \quad e_2 \Downarrow v_2 \quad e_1'[x \mapsto v_2] \Downarrow v}{e_1 e_2 \Downarrow v}$

### 4.3 公理语义

**定义 4.3.1 (程序等价性)**
$$e_1 \equiv e_2 \iff \forall C, C[e_1] \Downarrow v \Leftrightarrow C[e_2] \Downarrow v$$

**公理：**

1. **β等价**：$(\lambda x.e_1) e_2 \equiv e_1[x \mapsto e_2]$
2. **η等价**：$\lambda x.(e x) \equiv e$ (如果 $x \notin \text{FV}(e)$)
3. **外延性**：如果 $\forall v, e_1 v \equiv e_2 v$，则 $e_1 \equiv e_2$

## 5. 高级类型系统

### 5.1 参数多态性

**定义 5.1.1 (全称类型)**
$$\frac{\Gamma, \alpha \vdash e : \tau}{\Gamma \vdash \Lambda \alpha.e : \forall \alpha.\tau} \quad \text{(TAbs)}$$

**定义 5.1.2 (类型实例化)**
$$\frac{\Gamma \vdash e : \forall \alpha.\tau}{\Gamma \vdash e[\tau'] : \tau[\alpha \mapsto \tau']} \quad \text{(TApp)}$$

**Rust实现示例：**

```rust
// 参数多态函数
fn identity<T>(x: T) -> T {
    x
}

// 高阶类型函数
fn apply_twice<F, T>(f: F, x: T) -> T 
where 
    F: Fn(T) -> T,
{
    f(f(x))
}

// 类型类实现
trait Show {
    fn show(&self) -> String;
}

impl Show for i32 {
    fn show(&self) -> String {
        self.to_string()
    }
}

impl<T: Show> Show for Vec<T> {
    fn show(&self) -> String {
        let elements: Vec<String> = self.iter().map(|x| x.show()).collect();
        format!("[{}]", elements.join(", "))
    }
}
```

### 5.2 存在类型

**定义 5.2.1 (存在类型引入)**
$$\frac{\Gamma \vdash e : \tau[\alpha \mapsto \tau']}{\Gamma \vdash \text{pack } \tau', e \text{ as } \exists \alpha.\tau : \exists \alpha.\tau} \quad \text{(Pack)}$$

**定义 5.2.2 (存在类型消除)**
$$\frac{\Gamma \vdash e_1 : \exists \alpha.\tau \quad \Gamma, \alpha, x : \tau \vdash e_2 : \tau'}{\Gamma \vdash \text{unpack } \alpha, x = e_1 \text{ in } e_2 : \tau'} \quad \text{(Unpack)}$$

**Haskell实现示例：**

```haskell
-- 存在类型
data Showable = forall a. Show a => Showable a

instance Show Showable where
    show (Showable x) = show x

-- 使用存在类型
makeShowable :: Show a => a -> Showable
makeShowable = Showable

-- 类型擦除
eraseType :: Showable -> String
eraseType (Showable x) = show x
```

### 5.3 高阶类型

**定义 5.3.1 (类型构造子)**
$$\frac{\Gamma \vdash F : \text{Type} \rightarrow \text{Type} \quad \Gamma \vdash A : \text{Type}}{\Gamma \vdash F A : \text{Type}} \quad \text{(TCon)}$$

**高阶类型示例：**

```haskell
-- 高阶类型构造子
class Functor f where
    fmap :: (a -> b) -> f a -> f b

class Monad m where
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b

-- 高阶类型应用
instance Functor Maybe where
    fmap f Nothing = Nothing
    fmap f (Just x) = Just (f x)

instance Monad Maybe where
    return = Just
    Nothing >>= f = Nothing
    Just x >>= f = f x
```

## 6. 依赖类型系统

### 6.1 Π类型

**定义 6.1.1 (Π类型)**
$$\frac{\Gamma, x : A \vdash B : \text{Type}}{\Gamma \vdash \Pi x : A.B : \text{Type}} \quad \text{(Pi)}$$

**定义 6.1.2 (Π类型引入)**
$$\frac{\Gamma, x : A \vdash e : B}{\Gamma \vdash \lambda x : A.e : \Pi x : A.B} \quad \text{(PiAbs)}$$

**定义 6.1.3 (Π类型消除)**
$$\frac{\Gamma \vdash e_1 : \Pi x : A.B \quad \Gamma \vdash e_2 : A}{\Gamma \vdash e_1 e_2 : B[x \mapsto e_2]} \quad \text{(PiApp)}$$

### 6.2 Σ类型

**定义 6.2.1 (Σ类型)**
$$\frac{\Gamma \vdash A : \text{Type} \quad \Gamma, x : A \vdash B : \text{Type}}{\Gamma \vdash \Sigma x : A.B : \text{Type}} \quad \text{(Sigma)}$$

**定义 6.2.2 (Σ类型引入)**
$$\frac{\Gamma \vdash e_1 : A \quad \Gamma \vdash e_2 : B[x \mapsto e_1]}{\Gamma \vdash (e_1, e_2) : \Sigma x : A.B} \quad \text{(SigmaIntro)}$$

**定义 6.2.3 (Σ类型消除)**
$$\frac{\Gamma \vdash e : \Sigma x : A.B \quad \Gamma, x : A, y : B \vdash e' : C}{\Gamma \vdash \text{let } (x, y) = e \text{ in } e' : C} \quad \text{(SigmaElim)}$$

### 6.3 依赖函数

**依赖函数示例：**

```haskell
-- 依赖类型（使用GHC扩展）
{-# LANGUAGE GADTs, DataKinds, TypeFamilies #-}

-- 自然数类型
data Nat = Z | S Nat

-- 向量类型（依赖类型）
data Vec (n :: Nat) a where
    Nil  :: Vec Z a
    Cons :: a -> Vec n a -> Vec (S n) a

-- 依赖函数：安全的head函数
head :: Vec (S n) a -> a
head (Cons x _) = x

-- 依赖函数：安全的tail函数
tail :: Vec (S n) a -> Vec n a
tail (Cons _ xs) = xs

-- 依赖函数：安全的索引函数
index :: Vec n a -> Fin n -> a
index (Cons x _) FZ = x
index (Cons _ xs) (FS i) = index xs i

-- 有限数类型
data Fin (n :: Nat) where
    FZ :: Fin (S n)
    FS :: Fin n -> Fin (S n)
```

## 7. 元理论

### 7.1 一致性

**定理 7.1.1 (类型系统一致性)**
如果 $\Gamma \vdash e : \tau$，则 $e$ 不会产生类型错误。

**证明：** 结合类型保持性和进展性定理。

### 7.2 完备性

**定理 7.2.1 (类型推断完备性)**
如果存在类型，则类型推断算法能够找到。

**证明：** 通过算法W的正确性和完备性。

### 7.3 可判定性

**定理 7.3.1 (类型检查可判定性)**
类型检查问题是可判定的。

**证明：** 类型检查算法总是终止。

## 8. 实际应用

### 8.1 编译器实现

**类型检查器实现：**

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
enum Type {
    TVar(String),
    TArrow(Box<Type>, Box<Type>),
    TCon(String),
    TForall(String, Box<Type>),
}

#[derive(Debug, Clone)]
enum Expr {
    Var(String),
    Abs(String, Box<Expr>),
    App(Box<Expr>, Box<Expr>),
    TAbs(String, Box<Expr>),
    TApp(Box<Expr>, Type),
}

struct TypeChecker {
    context: HashMap<String, Type>,
    type_vars: HashMap<String, Type>,
}

impl TypeChecker {
    fn new() -> Self {
        TypeChecker {
            context: HashMap::new(),
            type_vars: HashMap::new(),
        }
    }

    fn type_check(&mut self, expr: &Expr) -> Result<Type, String> {
        match expr {
            Expr::Var(x) => {
                self.context.get(x)
                    .cloned()
                    .ok_or_else(|| format!("Unbound variable: {}", x))
            }
            Expr::Abs(x, e) => {
                let t1 = self.fresh_type_var();
                self.context.insert(x.clone(), t1.clone());
                let t2 = self.type_check(e)?;
                self.context.remove(x);
                Ok(Type::TArrow(Box::new(t1), Box::new(t2)))
            }
            Expr::App(e1, e2) => {
                let t1 = self.type_check(e1)?;
                let t2 = self.type_check(e2)?;
                match t1 {
                    Type::TArrow(t1_in, t1_out) => {
                        if *t1_in == t2 {
                            Ok(*t1_out)
                        } else {
                            Err("Type mismatch in application".to_string())
                        }
                    }
                    _ => Err("Expected function type".to_string()),
                }
            }
            Expr::TAbs(alpha, e) => {
                self.type_vars.insert(alpha.clone(), self.fresh_type_var());
                let t = self.type_check(e)?;
                self.type_vars.remove(alpha);
                Ok(Type::TForall(alpha.clone(), Box::new(t)))
            }
            Expr::TApp(e, t) => {
                let t1 = self.type_check(e)?;
                match t1 {
                    Type::TForall(alpha, t_body) => {
                        Ok(self.substitute(&t_body, &alpha, t))
                    }
                    _ => Err("Expected polymorphic type".to_string()),
                }
            }
        }
    }

    fn fresh_type_var(&mut self) -> Type {
        static mut COUNTER: u32 = 0;
        unsafe {
            COUNTER += 1;
            Type::TVar(format!("α{}", COUNTER))
        }
    }

    fn substitute(&self, t: &Type, alpha: &str, t_new: &Type) -> Type {
        match t {
            Type::TVar(a) if a == alpha => t_new.clone(),
            Type::TVar(_) => t.clone(),
            Type::TArrow(t1, t2) => Type::TArrow(
                Box::new(self.substitute(t1, alpha, t_new)),
                Box::new(self.substitute(t2, alpha, t_new)),
            ),
            Type::TCon(c) => Type::TCon(c.clone()),
            Type::TForall(beta, t_body) if beta == alpha => Type::TForall(
                beta.clone(),
                Box::new(self.substitute(t_body, alpha, t_new)),
            ),
            Type::TForall(beta, t_body) => Type::TForall(
                beta.clone(),
                Box::new(self.substitute(t_body, alpha, t_new)),
            ),
        }
    }
}
```

### 8.2 类型检查器

**使用示例：**

```rust
fn main() {
    let mut checker = TypeChecker::new();
    
    // 检查恒等函数
    let id = Expr::Abs("x".to_string(), Box::new(Expr::Var("x".to_string())));
    match checker.type_check(&id) {
        Ok(t) => println!("Identity function type: {:?}", t),
        Err(e) => println!("Error: {}", e),
    }
    
    // 检查应用
    let app = Expr::App(
        Box::new(id.clone()),
        Box::new(Expr::Var("y".to_string())),
    );
    checker.context.insert("y".to_string(), Type::TCon("Int".to_string()));
    match checker.type_check(&app) {
        Ok(t) => println!("Application type: {:?}", t),
        Err(e) => println!("Error: {}", e),
    }
}
```

### 8.3 代码示例

**Haskell实现：**

```haskell
-- 类型检查器
type Context = [(String, Type)]
type TypeEnv = [(String, Type)]

data Type = TVar String
          | TArrow Type Type
          | TCon String
          | TForall String Type
          deriving (Eq, Show)

data Expr = Var String
          | Abs String Expr
          | App Expr Expr
          | TAbs String Expr
          | TApp Expr Type
          deriving (Show)

-- 类型检查
typeCheck :: Context -> Expr -> Either String Type
typeCheck ctx (Var x) = case lookup x ctx of
    Just t -> Right t
    Nothing -> Left $ "Unbound variable: " ++ x
typeCheck ctx (Abs x e) = do
    t1 <- freshTypeVar
    t2 <- typeCheck ((x, t1) : ctx) e
    return $ TArrow t1 t2
typeCheck ctx (App e1 e2) = do
    t1 <- typeCheck ctx e1
    t2 <- typeCheck ctx e2
    case t1 of
        TArrow t1' t2' | t1' == t2 -> Right t2'
        _ -> Left "Type mismatch in application"
typeCheck ctx (TAbs alpha e) = do
    t <- typeCheck ctx e
    return $ TForall alpha t
typeCheck ctx (TApp e t) = do
    t1 <- typeCheck ctx e
    case t1 of
        TForall alpha t_body -> Right $ substitute t_body alpha t
        _ -> Left "Expected polymorphic type"

-- 辅助函数
freshTypeVar :: Either String Type
freshTypeVar = Right $ TVar $ "α" ++ show (unsafePerformIO $ newIORef 0 >>= \r -> readIORef r >>= \v -> writeIORef r (v+1) >> return v)

substitute :: Type -> String -> Type -> Type
substitute (TVar a) alpha t_new
    | a == alpha = t_new
    | otherwise = TVar a
substitute (TArrow t1 t2) alpha t_new = TArrow (substitute t1 alpha t_new) (substitute t2 alpha t_new)
substitute (TCon c) _ _ = TCon c
substitute (TForall beta t_body) alpha t_new
    | beta == alpha = TForall beta t_body
    | otherwise = TForall beta (substitute t_body alpha t_new)
```

## 9. 交叉引用

### 9.1 相关理论

- [01.2 线性类型理论](./01.2_Linear_Type_Theory.md)
- [01.3 仿射类型理论](./01.3_Affine_Type_Theory.md)
- [01.4 依赖类型理论](./01.4_Dependent_Type_Theory.md)
- [02.1 形式语言理论](../02_Formal_Language_Theory/02.1_Formal_Language_Foundation.md)
- [03.1 控制论基础](../03_Control_Theory/03.1_Control_Theory_Foundation.md)

### 9.2 扩展阅读

- [04.1 分布式系统理论](../04_Distributed_Systems/04.1_Distributed_Systems_Foundation.md)
- [05.1 哲学基础](../05_Philosophical_Foundation/05.1_Philosophical_Foundation.md)
- [06.1 数学基础](../06_Mathematical_Foundation/06.1_Mathematical_Foundation.md)

### 9.3 参考文献

1. Girard, J. Y. (1987). Linear logic. Theoretical computer science, 50(1), 1-101.
2. Reynolds, J. C. (1983). Types, abstraction and parametric polymorphism. Information processing, 83, 513-523.
3. Martin-Löf, P. (1984). Intuitionistic type theory. Bibliopolis.
4. Univalent Foundations Program. (2013). Homotopy type theory: Univalent foundations of mathematics.
5. Selinger, P. (2004). Towards a quantum programming language. Mathematical Structures in Computer Science, 14(4), 527-586.
6. Pierce, B. C. (2002). Types and programming languages. MIT press.
7. Cardelli, L., & Wegner, P. (1985). On understanding types, data abstraction, and polymorphism. ACM Computing Surveys (CSUR), 17(4), 471-523.
8. Hindley, J. R. (1969). The principal type-scheme of an object in combinatory logic. Transactions of the American Mathematical Society, 146, 29-60.
9. Milner, R. (1978). A theory of type polymorphism in programming. Journal of computer and system sciences, 17(3), 348-375.
10. Wadler, P. (1989). Theorems for free! In Proceedings of the fourth international conference on functional programming languages and computer architecture (pp. 347-359). 