# 01.1 类型理论基础 (Type Theory Foundation)

## 目录

```markdown
01.1 类型理论基础
├── 1. 基础定义与公理
│   ├── 1.1 类型系统基础
│   ├── 1.2 类型判断规则
│   ├── 1.3 基本类型构造
│   └── 1.4 类型安全性
├── 2. 形式化语义
│   ├── 2.1 指称语义
│   ├── 2.2 操作语义
│   ├── 2.3 类型解释
│   └── 2.4 语义一致性
├── 3. 类型推断算法
│   ├── 3.1 Hindley-Milner 系统
│   ├── 3.2 算法 W
│   ├── 3.3 最一般类型
│   └── 3.4 类型重构
├── 4. 高级类型系统
│   ├── 4.1 参数多态性
│   ├── 4.2 存在类型
│   ├── 4.3 依赖类型
│   └── 4.4 高阶类型
├── 5. 元理论性质
│   ├── 5.1 强正规化
│   ├── 5.2 一致性
│   ├── 5.3 完备性
│   └── 5.4 可判定性
├── 6. 实际应用
│   ├── 6.1 编译器实现
│   ├── 6.2 类型检查器
│   ├── 6.3 代码示例
│   └── 6.4 最佳实践
└── 7. 交叉引用
    ├── 7.1 相关理论
    ├── 7.2 应用领域
    ├── 7.3 扩展方向
    └── 7.4 参考文献
```

## 1. 基础定义与公理

### 1.1 类型系统基础

**定义 1.1.1 (类型上下文)**
设 $\Gamma$ 为类型上下文，定义为变量到类型的映射：
$$\Gamma : \text{Var} \rightarrow \text{Type}$$

**定义 1.1.2 (类型环境)**
类型环境 $\Delta$ 是类型变量的集合：
$$\Delta \subseteq \text{TypeVar}$$

**定义 1.1.3 (类型判断)**
类型判断形如 $\Gamma \vdash e : \tau$，表示在上下文 $\Gamma$ 中，表达式 $e$ 具有类型 $\tau$。

**定义 1.1.4 (类型有效性)**
类型 $\tau$ 在环境 $\Delta$ 中有效，记作 $\Delta \vdash \tau : \text{Type}$。

### 1.2 类型判断规则

**公理 1.2.1 (变量规则)**
$$\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau} \quad \text{(Var)}$$

**公理 1.2.2 (函数类型引入)**
$$\frac{\Gamma, x : \tau_1 \vdash e : \tau_2}{\Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2} \quad \text{(Abs)}$$

**公理 1.2.3 (函数类型消除)**
$$\frac{\Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2 \quad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1 e_2 : \tau_2} \quad \text{(App)}$$

**公理 1.2.4 (上下文扩展)**
$$\frac{\Gamma \vdash e : \tau \quad x \notin \text{dom}(\Gamma)}{\Gamma, x : \tau' \vdash e : \tau} \quad \text{(Weaken)}$$

### 1.3 基本类型构造

**定义 1.3.1 (基本类型)**
- $\text{Bool}$ - 布尔类型
- $\text{Int}$ - 整数类型
- $\text{Unit}$ - 单位类型

**定义 1.3.2 (乘积类型)**
$$\frac{\Gamma \vdash e_1 : \tau_1 \quad \Gamma \vdash e_2 : \tau_2}{\Gamma \vdash (e_1, e_2) : \tau_1 \times \tau_2} \quad \text{(Pair)}$$

**定义 1.3.3 (和类型)**
$$\frac{\Gamma \vdash e : \tau_i}{\Gamma \vdash \text{in}_i(e) : \tau_1 + \tau_2} \quad \text{(Inj)}$$

### 1.4 类型安全性

**定理 1.4.1 (类型保持性 - Type Preservation)**
如果 $\Gamma \vdash e : \tau$ 且 $e \rightarrow e'$，则 $\Gamma \vdash e' : \tau$。

**证明：** 通过结构归纳法证明。对于每个归约规则，需要证明类型在归约后保持不变。

**定理 1.4.2 (进展性 - Progress)**
如果 $\emptyset \vdash e : \tau$，则要么 $e$ 是值，要么存在 $e'$ 使得 $e \rightarrow e'$。

**证明：** 通过结构归纳法证明。对于每个语法构造，证明要么是值，要么可以继续归约。

## 2. 形式化语义

### 2.1 指称语义

**定义 2.1.1 (类型解释)**
$$\llbracket \tau \rrbracket_\rho = \text{语义域}$$

其中 $\rho$ 是类型变量的环境。

**定义 2.1.2 (表达式解释)**
$$\llbracket e \rrbracket_{\rho,\sigma} : \llbracket \tau \rrbracket_\rho$$

其中 $\sigma$ 是变量的环境。

### 2.2 操作语义

**定义 2.2.1 (小步语义)**
$$e \rightarrow e'$$

**定义 2.2.2 (大步语义)**
$$e \Downarrow v$$

**定义 2.2.3 (归约规则)**
$$\frac{e_1 \rightarrow e_1'}{e_1 e_2 \rightarrow e_1' e_2} \quad \text{(AppL)}$$

$$\frac{e_2 \rightarrow e_2'}{v_1 e_2 \rightarrow v_1 e_2'} \quad \text{(AppR)}$$

$$(\lambda x.e) v \rightarrow e[x \mapsto v] \quad \text{(Beta)}$$

### 2.3 类型解释

**定义 2.3.1 (基本类型解释)**
$$\llbracket \text{Bool} \rrbracket = \{true, false\}$$

$$\llbracket \text{Int} \rrbracket = \mathbb{Z}$$

$$\llbracket \text{Unit} \rrbracket = \{()\}$$

**定义 2.3.2 (函数类型解释)**
$$\llbracket \tau_1 \rightarrow \tau_2 \rrbracket = \llbracket \tau_1 \rrbracket \rightarrow \llbracket \tau_2 \rrbracket$$

### 2.4 语义一致性

**定理 2.4.1 (语义一致性)**
如果 $\Gamma \vdash e : \tau$，则 $\llbracket e \rrbracket \in \llbracket \tau \rrbracket$。

## 3. 类型推断算法

### 3.1 Hindley-Milner 系统

**定义 3.1.1 (类型模式)**
$$\sigma ::= \tau \mid \forall \alpha.\sigma$$

**定义 3.1.2 (类型实例化)**
$$\frac{\Gamma \vdash e : \forall \alpha.\sigma}{\Gamma \vdash e : \sigma[\alpha \mapsto \tau]} \quad \text{(Inst)}$$

**定义 3.1.3 (类型泛化)**
$$\frac{\Gamma \vdash e : \tau \quad \alpha \notin \text{ftv}(\Gamma)}{\Gamma \vdash e : \forall \alpha.\tau} \quad \text{(Gen)}$$

### 3.2 算法 W

**算法 W (Robinson's Unification)**

```haskell
-- 类型定义
data Type = TVar String
          | TArrow Type Type
          | TCon String
          | TForall String Type

-- 替换
type Substitution = [(String, Type)]

-- 统一算法
unify :: Type -> Type -> Either String Substitution
unify (TVar a) t = 
  if a `elem` ftv t 
  then Left "Occurs check failed"
  else Right [(a, t)]
unify t (TVar a) = unify (TVar a) t
unify (TArrow t1 t2) (TArrow t1' t2') = do
  s1 <- unify t1 t1'
  s2 <- unify (apply s1 t2) (apply s1 t2')
  return (compose s2 s1)
unify (TCon a) (TCon b) = 
  if a == b then Right [] else Left "Type mismatch"
unify _ _ = Left "Cannot unify"

-- 自由类型变量
ftv :: Type -> [String]
ftv (TVar a) = [a]
ftv (TArrow t1 t2) = ftv t1 `union` ftv t2
ftv (TCon _) = []
ftv (TForall a t) = delete a (ftv t)
```

**定理 3.2.1 (算法 W 的正确性)**
如果算法 W 成功，则返回的替换是最一般的一致替换。

### 3.3 最一般类型

**定义 3.3.1 (最一般类型)**
类型 $\sigma$ 是表达式 $e$ 的最一般类型，如果：
1. $\Gamma \vdash e : \sigma$
2. 对于任意 $\tau$，如果 $\Gamma \vdash e : \tau$，则存在替换 $S$ 使得 $\tau = S(\sigma)$

**定理 3.3.1 (最一般类型存在性)**
在 Hindley-Milner 系统中，每个良类型的表达式都有最一般类型。

### 3.4 类型重构

```haskell
-- 类型重构算法
reconstruct :: Context -> Expr -> Either String (Substitution, Type)
reconstruct ctx (Var x) = case lookup x ctx of
  Just sigma -> Right ([], instantiate sigma)
  Nothing -> Left $ "Unbound variable: " ++ x
reconstruct ctx (App e1 e2) = do
  (s1, t1) <- reconstruct ctx e1
  (s2, t2) <- reconstruct (apply s1 ctx) e2
  t3 <- freshVar
  s3 <- unify (apply s2 t1) (TArrow t2 t3)
  return (compose s3 (compose s2 s1), apply s3 t3)
reconstruct ctx (Abs x e) = do
  t1 <- freshVar
  (s, t2) <- reconstruct ((x, t1) : ctx) e
  return (s, TArrow (apply s t1) t2)
```

## 4. 高级类型系统

### 4.1 参数多态性

**定义 4.1.1 (全称类型)**
$$\frac{\Gamma, \alpha \vdash e : \tau}{\Gamma \vdash \Lambda \alpha.e : \forall \alpha.\tau} \quad \text{(Tabs)}$$

**定义 4.1.2 (类型实例化)**
$$\frac{\Gamma \vdash e : \forall \alpha.\tau}{\Gamma \vdash e[\tau'] : \tau[\alpha \mapsto \tau']} \quad \text{(Tapp)}$$

### 4.2 存在类型

**定义 4.2.1 (存在类型引入)**
$$\frac{\Gamma \vdash e : \tau[\alpha \mapsto \tau']}{\Gamma \vdash \text{pack } \tau', e \text{ as } \exists \alpha.\tau : \exists \alpha.\tau} \quad \text{(Pack)}$$

**定义 4.2.2 (存在类型消除)**
$$\frac{\Gamma \vdash e_1 : \exists \alpha.\tau \quad \Gamma, \alpha, x : \tau \vdash e_2 : \tau'}{\Gamma \vdash \text{unpack } \alpha, x = e_1 \text{ in } e_2 : \tau'} \quad \text{(Unpack)}$$

### 4.3 依赖类型

**定义 4.3.1 (Π类型)**
$$\frac{\Gamma, x : A \vdash B : \text{Type}}{\Gamma \vdash \Pi x : A.B : \text{Type}} \quad \text{(Pi)}$$

**定义 4.3.2 (Σ类型)**
$$\frac{\Gamma \vdash A : \text{Type} \quad \Gamma, x : A \vdash B : \text{Type}}{\Gamma \vdash \Sigma x : A.B : \text{Type}} \quad \text{(Sigma)}$$

### 4.4 高阶类型

**定义 4.4.1 (类型构造子)**
$$\frac{\Gamma \vdash F : \text{Type} \rightarrow \text{Type} \quad \Gamma \vdash A : \text{Type}}{\Gamma \vdash F A : \text{Type}} \quad \text{(TApp)}$$

## 5. 元理论性质

### 5.1 强正规化

**定理 5.1.1 (强正规化)**
在强类型系统中，所有良类型的项都是强正规化的。

**证明：** 通过逻辑关系或归约性证明。

### 5.2 一致性

**定理 5.2.1 (类型系统一致性)**
如果 $\Gamma \vdash e : \tau$，则 $e$ 不会产生类型错误。

### 5.3 完备性

**定理 5.3.1 (类型推断完备性)**
如果表达式 $e$ 有类型，则类型推断算法能够找到它。

### 5.4 可判定性

**定理 5.4.1 (类型检查可判定性)**
类型检查问题是可判定的。

## 6. 实际应用

### 6.1 编译器实现

```rust
// Rust 实现示例
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
enum Type {
    TVar(String),
    TArrow(Box<Type>, Box<Type>),
    TCon(String),
    TForall(String, Box<Type>),
}

#[derive(Debug, Clone)]
struct Context {
    bindings: HashMap<String, Type>,
}

impl Context {
    fn new() -> Self {
        Context {
            bindings: HashMap::new(),
        }
    }
    
    fn extend(&self, var: String, ty: Type) -> Context {
        let mut new_ctx = self.clone();
        new_ctx.bindings.insert(var, ty);
        new_ctx
    }
    
    fn lookup(&self, var: &str) -> Option<&Type> {
        self.bindings.get(var)
    }
}

// 类型检查器
fn type_check(ctx: &Context, expr: &Expr) -> Result<Type, String> {
    match expr {
        Expr::Var(x) => {
            ctx.lookup(x)
                .ok_or_else(|| format!("Unbound variable: {}", x))
                .map(|t| t.clone())
        }
        Expr::App(e1, e2) => {
            let t1 = type_check(ctx, e1)?;
            let t2 = type_check(ctx, e2)?;
            match t1 {
                Type::TArrow(t1_in, t1_out) => {
                    if t2 == *t1_in {
                        Ok(*t1_out)
                    } else {
                        Err("Type mismatch in application".to_string())
                    }
                }
                _ => Err("Expected function type".to_string()),
            }
        }
        Expr::Abs(x, e) => {
            let t1 = Type::TVar(format!("{}_type", x));
            let new_ctx = ctx.extend(x.clone(), t1.clone());
            let t2 = type_check(&new_ctx, e)?;
            Ok(Type::TArrow(Box::new(t1), Box::new(t2)))
        }
    }
}
```

### 6.2 类型检查器

```haskell
-- Haskell 实现示例
data Expr = Var String
          | App Expr Expr
          | Abs String Expr
          | Let String Expr Expr

typeCheck :: Context -> Expr -> Either TypeError Type
typeCheck ctx (Var x) = case lookup x ctx of
  Just t -> Right t
  Nothing -> Left (UnboundVariable x)
typeCheck ctx (App e1 e2) = do
  t1 <- typeCheck ctx e1
  t2 <- typeCheck ctx e2
  case t1 of
    TArrow t1' t2' | t1' == t2 -> Right t2'
    _ -> Left TypeMismatch
typeCheck ctx (Abs x e) = do
  t1 <- freshVar
  t2 <- typeCheck ((x, t1) : ctx) e
  return (TArrow t1 t2)
typeCheck ctx (Let x e1 e2) = do
  t1 <- typeCheck ctx e1
  t2 <- typeCheck ((x, t1) : ctx) e2
  return t2
```

### 6.3 代码示例

```rust
// 高级类型系统示例
trait Functor<F> {
    fn map<A, B>(fa: F<A>, f: fn(A) -> B) -> F<B>;
}

trait Monad<M> {
    fn pure<A>(a: A) -> M<A>;
    fn bind<A, B>(ma: M<A>, f: fn(A) -> M<B>) -> M<B>;
}

// 类型安全的错误处理
enum Result<T, E> {
    Ok(T),
    Err(E),
}

impl<T, E> Result<T, E> {
    fn map<U>(self, f: fn(T) -> U) -> Result<U, E> {
        match self {
            Result::Ok(t) => Result::Ok(f(t)),
            Result::Err(e) => Result::Err(e),
        }
    }
    
    fn and_then<U>(self, f: fn(T) -> Result<U, E>) -> Result<U, E> {
        match self {
            Result::Ok(t) => f(t),
            Result::Err(e) => Result::Err(e),
        }
    }
}
```

### 6.4 最佳实践

1. **利用类型系统捕获错误**：在编译时发现潜在问题
2. **通过类型抽象实现模块化**：隐藏实现细节
3. **使用类型类实现多态性**：提供统一的接口
4. **依赖类型保证正确性**：形式化验证程序性质

## 7. 交叉引用

### 7.1 相关理论

- [01.2 线性类型理论](01.2_Linear_Type_Theory.md) - 线性类型系统
- [01.3 仿射类型理论](01.3_Affine_Type_Theory.md) - 仿射类型系统
- [01.4 依赖类型理论](01.4_Dependent_Type_Theory.md) - 依赖类型系统
- [02.1 形式语言基础](../02_Formal_Language_Theory/02.1_Formal_Language_Foundation.md) - 形式语言理论

### 7.2 应用领域

- [07.1 软件工程基础](../07_Software_Engineering/07.1_Software_Engineering_Foundation.md) - 软件工程应用
- [08.1 编程语言基础](../08_Programming_Language_Theory/08.1_Programming_Language_Foundation.md) - 编程语言设计

### 7.3 扩展方向

- [01.5 高阶类型理论](01.5_Higher_Order_Type_Theory.md) - 高阶类型系统
- [01.6 量子类型理论](01.6_Quantum_Type_Theory.md) - 量子计算类型系统

### 7.4 参考文献

1. Girard, J. Y. (1987). Linear logic. Theoretical computer science, 50(1), 1-101.
2. Reynolds, J. C. (1983). Types, abstraction and parametric polymorphism. Information processing, 83, 513-523.
3. Martin-Löf, P. (1984). Intuitionistic type theory. Bibliopolis.
4. Univalent Foundations Program. (2013). Homotopy type theory: Univalent foundations of mathematics.
5. Selinger, P. (2004). Towards a quantum programming language. Mathematical Structures in Computer Science, 14(4), 527-586.
6. Pierce, B. C. (2002). Types and programming languages. MIT press.
7. Cardelli, L., & Wegner, P. (1985). On understanding types, data abstraction, and polymorphism. ACM Computing Surveys (CSUR), 17(4), 471-523.
