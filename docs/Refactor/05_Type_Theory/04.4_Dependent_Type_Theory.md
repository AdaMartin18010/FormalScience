# ä¾èµ–ç±»å‹ç†è®º (Dependent Type Theory)

## ğŸ“‹ ç« èŠ‚ä¿¡æ¯

**ç¼–å·**: 04.4  
**ä¸Šçº§ç« èŠ‚**: [ç±»å‹ç†è®º](01_Type_Theory_Index.md)  
**åˆ›å»ºæ—¶é—´**: 2024-12-21  
**æœ€åæ›´æ–°**: 2024-12-21  
**å†…å®¹å®Œæ•´åº¦**: 75%  

## ğŸ¯ ç« èŠ‚æ¦‚è¿°

ä¾èµ–ç±»å‹ç†è®ºæ˜¯ç±»å‹ç†è®ºçš„é«˜çº§åˆ†æ”¯ï¼Œå®ƒå…è®¸ç±»å‹ä¾èµ–äºå€¼ï¼Œä»è€Œå®ç°äº†ç±»å‹å’Œé€»è¾‘çš„æ·±åº¦ç»Ÿä¸€ã€‚åœ¨ä¾èµ–ç±»å‹ç³»ç»Ÿä¸­ï¼Œç±»å‹å¯ä»¥åŒ…å«å€¼ï¼Œä½¿å¾—ç±»å‹æœ¬èº«å¯ä»¥è¡¨è¾¾æ›´ä¸°å¯Œçš„ç¨‹åºæ€§è´¨å’Œè§„èŒƒã€‚è¿™ç§ç±»å‹ä¸é€»è¾‘çš„èåˆï¼ŒåŸºäºæŸ¯é‡Œ-éœåå¾·åŒæ„(Curry-Howard Isomorphism)ï¼Œä½¿å¾—ç±»å‹ç³»ç»Ÿèƒ½å¤Ÿè¡¨è¾¾ä»»æ„å¤æ‚çš„é€»è¾‘å‘½é¢˜ï¼Œå¹¶å°†ç¨‹åºçš„æ­£ç¡®æ€§è¯æ˜ç›´æ¥ç¼–ç åˆ°ç±»å‹ç³»ç»Ÿä¸­ã€‚

ä¾èµ–ç±»å‹ç†è®ºæ˜¯ç°ä»£è¯æ˜åŠ©æ‰‹(proof assistant)å¦‚Coqã€Agdaã€Leanç­‰ç³»ç»Ÿçš„ç†è®ºåŸºç¡€ï¼Œæ”¯æŒå½¢å¼åŒ–æ•°å­¦å’Œç¨‹åºéªŒè¯ã€‚æœ¬ç« å°†ä»‹ç»ä¾èµ–ç±»å‹ç†è®ºçš„åŸºæœ¬æ¦‚å¿µã€æ•°å­¦åŸºç¡€ã€æ„é€ æ¼”ç®—(calculus of constructions)ï¼Œä»¥åŠå®ƒåœ¨ç¨‹åºéªŒè¯å’Œå®šç†è¯æ˜ä¸­çš„åº”ç”¨ã€‚

## ğŸ“š æ ¸å¿ƒå†…å®¹

### 1. ä¾èµ–ç±»å‹ç³»ç»ŸåŸºç¡€

ä¾èµ–ç±»å‹ç³»ç»Ÿæ˜¯åœ¨ç®€å•ç±»å‹Î»æ¼”ç®—åŸºç¡€ä¸Šçš„é‡è¦æ‰©å±•ï¼Œé€šè¿‡å…è®¸ç±»å‹ä¾èµ–äºå€¼ï¼Œæå¤§å¢å¼ºäº†ç±»å‹ç³»ç»Ÿçš„è¡¨è¾¾èƒ½åŠ›ã€‚

#### 1.1 ä¾èµ–ç±»å‹çš„å®šä¹‰

ä¾èµ–ç±»å‹ç³»ç»Ÿå¼•å…¥äº†ä¸¤ç§å…³é”®çš„ä¾èµ–ç±»å‹å½¢å¼ï¼š

1. **ä¾èµ–å‡½æ•°ç±»å‹ï¼ˆÎ ç±»å‹ï¼‰**ï¼šè¡¨ç¤ºå‡½æ•°çš„è¿”å›ç±»å‹ä¾èµ–äºå…¶å‚æ•°å€¼
   - è®°ä½œï¼š$\Pi x:A. B(x)$
   - å¯¹äºæ¯ä¸ª$x:A$ï¼Œæœ‰ä¸€ä¸ªå¯èƒ½ä¸åŒçš„ç±»å‹$B(x)$

2. **ä¾èµ–å¯¹ç±»å‹ï¼ˆÎ£ç±»å‹ï¼‰**ï¼šè¡¨ç¤ºå¯¹çš„ç¬¬äºŒä¸ªå…ƒç´ çš„ç±»å‹ä¾èµ–äºç¬¬ä¸€ä¸ªå…ƒç´ çš„å€¼
   - è®°ä½œï¼š$\Sigma x:A. B(x)$
   - ç¬¬ä¸€ä¸ªæŠ•å½±ä¸º$x:A$ï¼Œç¬¬äºŒä¸ªæŠ•å½±ä¸º$B(x)$ç±»å‹çš„å€¼

#### 1.2 ä¾èµ–ç±»å‹ä¸é€»è¾‘çš„å¯¹åº”

åŸºäºæŸ¯é‡Œ-éœåå¾·åŒæ„ï¼Œä¾èµ–ç±»å‹ä¸é€»è¾‘å‘½é¢˜æœ‰ç€ç›´æ¥çš„å¯¹åº”å…³ç³»ï¼š

| ä¾èµ–ç±»å‹ | é€»è¾‘å‘½é¢˜ |
|---------|---------|
| $\Pi x:A. B(x)$ | $\forall x:A. B(x)$ |
| $\Sigma x:A. B(x)$ | $\exists x:A. B(x)$ |

è¿™ç§å¯¹åº”å…³ç³»ä½¿å¾—ç±»å‹ç³»ç»Ÿå¯ä»¥è¡¨è¾¾å’ŒéªŒè¯å¤æ‚çš„é€»è¾‘å‘½é¢˜ã€‚

#### 1.3 ç±»å‹ä¸é›†åˆçš„åŒºåˆ«

ä¾èµ–ç±»å‹ç†è®ºä¸­çš„ç±»å‹ä¸ä¼ ç»Ÿé›†åˆè®ºä¸­çš„é›†åˆæœ‰é‡è¦åŒºåˆ«ï¼š

- ç±»å‹æ˜¯å†…æ¶µå¼(intensional)çš„ï¼Œè€Œéå¤–å»¶å¼(extensional)çš„
- é›†åˆå¼ºè°ƒå…ƒç´ çš„å½’å±ï¼Œç±»å‹å¼ºè°ƒè¡¨è¾¾å¼çš„æ„é€ æ–¹å¼
- ç±»å‹ç­‰ä»·é€šå¸¸æ˜¯åˆ¤å®šæ€§çš„ï¼Œè€Œé›†åˆç­‰ä»·å¯èƒ½æ˜¯ä¸å¯åˆ¤å®šçš„

**è¯¦ç»†å†…å®¹è¯·å‚é˜…**: [ä¾èµ–ç±»å‹ç³»ç»Ÿ](04.4.1_Dependent_Type_System.md)

### 2. æ„é€ æ¼”ç®— (Calculus of Constructions)

æ„é€ æ¼”ç®—(CoC)æ˜¯Thierry Coquandå’ŒGÃ©rard Huetå¼€å‘çš„ä¸€ç§ä¾èµ–ç±»å‹ç³»ç»Ÿï¼Œæ˜¯Coqè¯æ˜åŠ©æ‰‹çš„ç†è®ºåŸºç¡€ã€‚

#### 2.1 è¯­æ³•

æ„é€ æ¼”ç®—çš„è¯­æ³•åŒ…æ‹¬ï¼š

$$
\begin{align}
t ::= & \; x & \text{(å˜é‡)} \\
    | & \; \lambda x:T.t & \text{(æŠ½è±¡)} \\
    | & \; t_1 \; t_2 & \text{(åº”ç”¨)} \\
    | & \; \Pi x:T_1.T_2 & \text{(ä¾èµ–å‡½æ•°ç±»å‹)} \\
    | & \; \text{Type}_i & \text{(å®‡å®™)}
\end{align}
$$

#### 2.2 ç±»å‹è§„åˆ™

æ„é€ æ¼”ç®—çš„æ ¸å¿ƒç±»å‹è§„åˆ™åŒ…æ‹¬ï¼š

**å˜é‡è§„åˆ™**:
$$\frac{x : T \in \Gamma}{\Gamma \vdash x : T} \text{(T-Var)}$$

**æŠ½è±¡è§„åˆ™**:
$$\frac{\Gamma, x : T_1 \vdash t : T_2 \quad \Gamma \vdash T_1 : \text{Type}_i}{\Gamma \vdash \lambda x:T_1.t : \Pi x:T_1.T_2} \text{(T-Abs)}$$

**åº”ç”¨è§„åˆ™**:
$$\frac{\Gamma \vdash t_1 : \Pi x:T.T' \quad \Gamma \vdash t_2 : T}{\Gamma \vdash t_1 \; t_2 : [x \mapsto t_2]T'} \text{(T-App)}$$

**Î ç±»å‹è§„åˆ™**:
$$\frac{\Gamma \vdash T : \text{Type}_i \quad \Gamma, x : T \vdash T' : \text{Type}_j}{\Gamma \vdash \Pi x:T.T' : \text{Type}_{\max(i,j)}} \text{(T-Pi)}$$

#### 2.3 æ„é€ æ¼”ç®—çš„æ‰©å±•

æ„é€ æ¼”ç®—æœ‰å¤šç§æ‰©å±•å½¢å¼ï¼ŒåŒ…æ‹¬ï¼š

- **å½’çº³æ„é€ æ¼”ç®—ï¼ˆCoICï¼‰**ï¼šæ·»åŠ å½’çº³ç±»å‹å®šä¹‰
- **æ‰©å±•æ„é€ æ¼”ç®—ï¼ˆECCï¼‰**ï¼šæ·»åŠ å®‡å®™å±‚çº§å’Œç´¯ç§¯æ€§
- **é¢„æµ‹æ„é€ æ¼”ç®—ï¼ˆpCiCï¼‰**ï¼šCoqä½¿ç”¨çš„ç‰ˆæœ¬ï¼Œæ”¯æŒåˆ¤å®šç­‰ä»·

**è¯¦ç»†å†…å®¹è¯·å‚é˜…**: [æ„é€ æ¼”ç®—](04.4.2_Calculus_of_Constructions.md)

### 3. ç±»å‹æ—ä¸ä¾èµ–æ•°æ®ç±»å‹

ç±»å‹æ—(type family)æ˜¯ä¾èµ–ç±»å‹ç³»ç»Ÿä¸­çš„å…³é”®æ¦‚å¿µï¼Œè¡¨ç¤ºç”±ç´¢å¼•å‚æ•°åŒ–çš„ç±»å‹ã€‚

#### 3.1 ç±»å‹æ—å®šä¹‰

ç±»å‹æ—æ˜¯ç±»å‹çº§å‡½æ•°ï¼Œå°†å€¼æ˜ å°„åˆ°ç±»å‹ï¼š

$$A : K \to \text{Type}$$

å…¶ä¸­$K$æ˜¯ç´¢å¼•é›†ï¼Œ$A(k)$å¯¹æ¯ä¸ª$k \in K$ç»™å‡ºä¸€ä¸ªç±»å‹ã€‚

#### 3.2 ä¾èµ–æ•°æ®ç±»å‹ç¤ºä¾‹

ä¾èµ–æ•°æ®ç±»å‹çš„å…¸å‹ä¾‹å­æ˜¯çŸ¢é‡(å‘é‡)ç±»å‹ï¼š

```agda
-- Agdaä»£ç 
data Vec (A : Set) : Nat â†’ Set where
  nil  : Vec A zero
  cons : {n : Nat} â†’ A â†’ Vec A n â†’ Vec A (suc n)
```

è¿™é‡Œ`Vec A n`è¡¨ç¤ºé•¿åº¦ä¸º`n`çš„`A`ç±»å‹å…ƒç´ åˆ—è¡¨ã€‚

#### 3.3 ç±»å‹æ—ä¸å€¼çš„äº’åŠ¨

ä¾èµ–ç±»å‹ç³»ç»Ÿä¸­ï¼Œç±»å‹æ—ä¸å€¼ç´§å¯†äº’åŠ¨ï¼š

- **ä¾èµ–æ¨¡å¼åŒ¹é…**ï¼šæ¨¡å¼åŒ¹é…å¯ä»¥ç²¾åŒ–ç±»å‹ä¿¡æ¯
- **ç±»å‹çº§è®¡ç®—**ï¼šç±»å‹ä¸­çš„è¡¨è¾¾å¼å¯ä»¥è§„èŒƒåŒ–

```agda
-- å‘é‡è¿æ¥å‡½æ•°ï¼Œä¿æŒé•¿åº¦ä¿¡æ¯
append : {A : Set}{m n : Nat} â†’ Vec A m â†’ Vec A n â†’ Vec A (m + n)
append nil ys = ys
append (cons x xs) ys = cons x (append xs ys)
```

**è¯¦ç»†å†…å®¹è¯·å‚é˜…**: [ç±»å‹æ—](04.4.3_Type_Families.md)

### 4. è¯æ˜æ— å…³æ€§ä¸è§„èŒƒæ€§

è¯æ˜æ— å…³æ€§(proof irrelevance)æ˜¯ä¾èµ–ç±»å‹ç†è®ºä¸­çš„é‡è¦æ€§è´¨ï¼Œè¡¨ç¤ºè¯æ˜å¯¹è±¡çš„å…·ä½“ç»“æ„ä¸é‡è¦ï¼Œåªå…³å¿ƒå…¶å­˜åœ¨æ€§ã€‚

#### 4.1 è¯æ˜æ— å…³æ€§æ¦‚å¿µ

åœ¨ä¾èµ–ç±»å‹ç†è®ºä¸­ï¼Œè¯æ˜å¯ä»¥è¡¨ç¤ºä¸ºç±»å‹çš„é¡¹ã€‚è¯æ˜æ— å…³æ€§æ„å‘³ç€ï¼š

- åŒä¸€å‘½é¢˜çš„ä¸¤ä¸ªè¯æ˜è¢«è§†ä¸ºç­‰ä»·
- è¯æ˜çš„å…·ä½“æ„é€ æ–¹å¼ä¸å½±å“ç¨‹åºçš„è®¡ç®—è¡Œä¸º

å½¢å¼åŒ–è¡¨ç¤ºä¸ºï¼šå¦‚æœ$p_1 : P$å’Œ$p_2 : P$ï¼Œåˆ™$p_1 = p_2$ã€‚

#### 4.2 å‘½é¢˜ä¸ç±»å‹åˆ†ç¦»

ä¸ºäº†æ”¯æŒè¯æ˜æ— å…³æ€§ï¼Œè®¸å¤šç³»ç»ŸåŒºåˆ†äº†ä¸¤ç±»ç±»å‹ï¼š

- **å‘½é¢˜(Prop)**ï¼šç”¨äºé€»è¾‘æ¨ç†ï¼Œå…·æœ‰è¯æ˜æ— å…³æ€§
- **ç±»å‹(Type)**ï¼šç”¨äºè®¡ç®—ï¼Œå…·ä½“ç»“æ„å¾ˆé‡è¦

```coq
(* Coqä»£ç ï¼šå‘½é¢˜ä¸ç±»å‹åˆ†ç¦» *)
Inductive eq {A : Type} (x : A) : A -> Prop :=
  eq_refl : eq x x.
```

#### 4.3 å­ç±»å‹åŒ–ä¸å®‡å®™å±‚çº§

ä¾èµ–ç±»å‹ç³»ç»Ÿé€šå¸¸é‡‡ç”¨å®‡å®™å±‚çº§é¿å…æ‚–è®ºï¼š

```text
Prop : Typeâ‚ : Typeâ‚‚ : ...
```

å…¶ä¸­ï¼ŒPropå¯ä»¥è§†ä¸ºTypeâ‚€çš„ç‰¹ä¾‹ï¼Œå…·æœ‰é¢å¤–çš„è¯æ˜æ— å…³æ€§æ€§è´¨ã€‚

**è¯¦ç»†å†…å®¹è¯·å‚é˜…**: [è¯æ˜æ— å…³æ€§](04.4.4_Proof_Irrelevance.md)

## ğŸ’» ä»£ç å®ç°

### Coqä¸­çš„ä¾èµ–ç±»å‹ç¤ºä¾‹

```coq
(* ä½¿ç”¨Coqå®ç°ä¾èµ–ç±»å‹ *)

(* å‘é‡ç±»å‹å®šä¹‰ *)
Inductive Vector (A : Type) : nat -> Type :=
| nil : Vector A 0
| cons : forall n, A -> Vector A n -> Vector A (S n).

Arguments nil {A}.
Arguments cons {A n}.

(* å®‰å…¨çš„å‘é‡è®¿é—®å‡½æ•° *)
Fixpoint nth {A} {n} (v : Vector A n) (i : nat) (i_lt_n : i < n) : A :=
  match v with
  | nil => match lt_n_0 i i_lt_n with end
  | cons h n' t => 
      match i with
      | O => h
      | S j => nth t j (lt_S_n j n' i_lt_n)
      end
  end.

(* å‘é‡è¿æ¥ï¼Œä¿ç•™é•¿åº¦ä¿¡æ¯ *)
Fixpoint vapp {A n m} (v : Vector A n) (w : Vector A m) : Vector A (n + m) :=
  match v with
  | nil => w
  | cons h n' t => cons h (vapp t w)
  end.

(* ä½¿ç”¨ä¾èµ–ç±»å‹å®šä¹‰ç›¸ç­‰æ€§ *)
Inductive eq {A : Type} (x : A) : A -> Prop :=
| eq_refl : eq x x.

Notation "x = y" := (eq x y).

(* å‘é‡åè½¬ï¼Œç±»å‹ä¿è¯é•¿åº¦ä¸å˜ *)
Fixpoint reverse {A n} (v : Vector A n) : Vector A n :=
  match v with
  | nil => nil
  | cons h n' t => 
      vapp (reverse t) (cons h nil)
  end.

(* ç±»å‹çº§è¿ç®—ï¼šçŸ©é˜µè½¬ç½® *)
Definition transpose {A n m} (matrix : Vector (Vector A m) n) 
  : Vector (Vector A n) m :=
  (* å®ç°ç•¥ *)
  admit.
```

### Agdaä¸­çš„ä¾èµ–ç±»å‹ç¤ºä¾‹

```agda
-- ä½¿ç”¨Agdaå®ç°ä¾èµ–ç±»å‹

-- è‡ªç„¶æ•°å®šä¹‰
data Nat : Set where
  zero : Nat
  suc  : Nat â†’ Nat

-- å‘é‡ç±»å‹(ä¾èµ–åˆ—è¡¨)
data Vec (A : Set) : Nat â†’ Set where
  []  : Vec A zero
  _âˆ·_ : âˆ€ {n} â†’ A â†’ Vec A n â†’ Vec A (suc n)

-- ç²¾ç¡®ç±»å‹çš„å‘é‡è®¿é—®å‡½æ•°
_!!_ : âˆ€ {A n} â†’ Vec A n â†’ (i : Nat) â†’ {i < n} â†’ A
(x âˆ· xs) !! zero = x
(x âˆ· xs) !! (suc i) {p} = xs !! i {subproof p}
  where subproof : {n : Nat} â†’ {i : Nat} â†’ suc i < suc n â†’ i < n
        subproof {_} {_} (sâ‰¤s p) = p

-- å‘é‡è¿æ¥ï¼Œä¿ç•™é•¿åº¦ä¿¡æ¯
_++_ : âˆ€ {A n m} â†’ Vec A n â†’ Vec A m â†’ Vec A (n + m)
[] ++ ys = ys
(x âˆ· xs) ++ ys = x âˆ· (xs ++ ys)

-- ä¾èµ–ç±»å‹è¡¨ç¤ºç­‰å¼
data _â‰¡_ {A : Set} : A â†’ A â†’ Set where
  refl : âˆ€ {x} â†’ x â‰¡ x

-- çŸ¢é‡ç¿»è½¬ï¼Œä½¿ç”¨ç±»å‹ç¡®ä¿é•¿åº¦ä¸å˜
reverse : âˆ€ {A n} â†’ Vec A n â†’ Vec A n
reverse [] = []
reverse (x âˆ· xs) = reverse xs ++ (x âˆ· [])

-- ä½¿ç”¨ä¾èµ–ç±»å‹å®ç°"ZIP"
zip : âˆ€ {A B n} â†’ Vec A n â†’ Vec B n â†’ Vec (A Ã— B) n
zip [] [] = []
zip (x âˆ· xs) (y âˆ· ys) = (x , y) âˆ· zip xs ys
```

## ğŸ“ ç»ƒä¹ ä¸æ€è€ƒ

1. å®ç°ä¸€ä¸ªç®€å•çš„ä¾èµ–ç±»å‹æ£€æŸ¥å™¨ï¼Œæ”¯æŒÎ ç±»å‹å’ŒÎ£ç±»å‹ã€‚
2. ä½¿ç”¨Coqæˆ–Agdaè¯æ˜åˆ—è¡¨åè½¬çš„åè½¬ç­‰äºåŸåˆ—è¡¨ã€‚
3. è®¾è®¡ä¸€ç§ä½¿ç”¨ä¾èµ–ç±»å‹çš„ç¼–ç¨‹è¯­è¨€ï¼ŒåŒ…æ‹¬ç±»å‹æ£€æŸ¥å’Œæ±‚å€¼è§„åˆ™ã€‚
4. æ¯”è¾ƒä¾èµ–ç±»å‹ç³»ç»Ÿå’Œéœå°”é€»è¾‘(Hoare Logic)åœ¨ç¨‹åºéªŒè¯æ–¹é¢çš„ä¼˜ç¼ºç‚¹ã€‚
5. æ¢è®¨å¦‚ä½•åœ¨ä¸»æµç¼–ç¨‹è¯­è¨€ä¸­é€æ­¥å¼•å…¥ä¾èµ–ç±»å‹ç‰¹æ€§ã€‚

## ğŸ“š æ‰©å±•é˜…è¯»

1. Martin-LÃ¶f, P. (1984). *Intuitionistic Type Theory*. Bibliopolis.
2. Coquand, T., & Huet, G. (1988). *The Calculus of Constructions*. Information and Computation, 76(2/3).
3. Norell, U. (2007). *Towards a practical programming language based on dependent type theory*. PhD thesis, Chalmers University of Technology.
4. Brady, E. (2013). *Idris, a General Purpose Dependently Typed Programming Language: Design and Implementation*. Journal of Functional Programming.
5. Bertot, Y., & CastÃ©ran, P. (2004). *Interactive Theorem Proving and Program Development: Coq'Art*. Springer.

## ğŸ”„ ä¸å…¶ä»–ç« èŠ‚çš„è”ç³»

- [ä¾èµ–ç±»å‹ç³»ç»Ÿ](04.4.1_Dependent_Type_System.md)ï¼šè¯¦ç»†ä»‹ç»ä¾èµ–ç±»å‹ç³»ç»Ÿçš„åŸºç¡€ç†è®ºå’Œå½¢å¼åŒ–å®šä¹‰ã€‚
- [æ„é€ æ¼”ç®—](04.4.2_Calculus_of_Constructions.md)ï¼šæ·±å…¥ç ”ç©¶æ„é€ æ¼”ç®—çš„å½¢å¼åŒ–å®šä¹‰å’Œæ€§è´¨ã€‚
- [ç±»å‹æ—](04.4.3_Type_Families.md)ï¼šæ¢è®¨ç±»å‹æ—å’Œä¾èµ–æ•°æ®ç±»å‹çš„è®¾è®¡å’Œåº”ç”¨ã€‚
- [è¯æ˜æ— å…³æ€§](04.4.4_Proof_Irrelevance.md)ï¼šç ”ç©¶è¯æ˜æ— å…³æ€§å’Œé€»è¾‘ä¸€è‡´æ€§çš„é—®é¢˜ã€‚
- [ç®€å•ç±»å‹ç†è®º](04.1_Simple_Type_Theory.md)ï¼šä¾èµ–ç±»å‹ç†è®ºçš„å‰å¯¼ç†è®ºã€‚
- [åŒä¼¦ç±»å‹ç†è®º](04.5_Homotopy_Type_Theory.md)ï¼šä¾èµ–ç±»å‹ç†è®ºçš„æ‰©å±•å’Œå‘å±•ã€‚
- [å®šç†è¯æ˜](04.8.3_Theorem_Proving.md)ï¼šä¾èµ–ç±»å‹ç†è®ºåœ¨å®šç†è¯æ˜é¢†åŸŸçš„åº”ç”¨ã€‚

---

**ç‰ˆæœ¬**: v1.0  
**ç»´æŠ¤è€…**: ç±»å‹ç†è®ºé‡æ„å›¢é˜Ÿ
