# 04.3.1 ä»¿å°„ç±»å‹åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

ä»¿å°„ç±»å‹ç†è®ºæ˜¯çº¿æ€§ç±»å‹ç†è®ºçš„æ‰©å±•ï¼Œå®ƒå…è®¸å€¼è¢«ä½¿ç”¨æœ€å¤šä¸€æ¬¡ï¼ˆè€Œä¸æ˜¯æ°å¥½ä¸€æ¬¡ï¼‰ã€‚è¿™ç§ç±»å‹ç³»ç»Ÿä¸ºèµ„æºç®¡ç†å’Œå†…å­˜å®‰å…¨æä¾›äº†æ›´çµæ´»çš„æ–¹æ³•ï¼Œæ˜¯ç°ä»£ç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚Rustï¼‰æ‰€æœ‰æƒç³»ç»Ÿçš„åŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹ä»¿å°„ç±»å‹ç†è®ºçš„æ•°å­¦åŸºç¡€**
2. **å®šä¹‰ä»¿å°„ç±»å‹å’Œä»¿å°„å‡½æ•°**
3. **ç ”ç©¶ä»¿å°„ç±»å‹ç³»ç»Ÿçš„æ€§è´¨**
4. **æä¾›ä»¿å°„ç±»å‹ç³»ç»Ÿçš„å®ç°æ–¹æ³•**
5. **åˆ†æä»¿å°„ç±»å‹ç³»ç»Ÿåœ¨ç¼–ç¨‹ä¸­çš„åº”ç”¨**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ä»¿å°„é€»è¾‘åŸºç¡€

**å®šä¹‰ 1.1.1 (ä»¿å°„é€»è¾‘)**
ä»¿å°„é€»è¾‘æ˜¯çº¿æ€§é€»è¾‘çš„å˜ç§ï¼Œå…¶ä¸­æ¯ä¸ªå…¬å¼æœ€å¤šè¢«ä½¿ç”¨ä¸€æ¬¡ã€‚åœ¨ä»¿å°„é€»è¾‘ä¸­ï¼Œåˆå–ï¼ˆâŠ—ï¼‰å’Œæå–ï¼ˆâ…‹ï¼‰æ˜¯ä»¿å°„çš„ï¼Œå…è®¸å…¬å¼è¢«ä¸¢å¼ƒã€‚

**å®šä¹‰ 1.1.2 (ä»¿å°„è•´æ¶µ)**
ä»¿å°„è•´æ¶µ $A \multimap B$ è¡¨ç¤ºä» $A$ åˆ° $B$ çš„ä»¿å°„å‡½æ•°ï¼Œä½¿ç”¨ $A$ æœ€å¤šä¸€æ¬¡æ¥äº§ç”Ÿ $B$ã€‚

**å®šä¹‰ 1.1.3 (ä»¿å°„åˆå–)**
ä»¿å°„åˆå– $A \otimes B$ è¡¨ç¤º $A$ å’Œ $B$ çš„ä»¿å°„ç»„åˆï¼Œæ¯ä¸ªæœ€å¤šè¢«ä½¿ç”¨ä¸€æ¬¡ã€‚

### 1.2 ä»¿å°„ç±»å‹

**å®šä¹‰ 1.2.1 (ä»¿å°„ç±»å‹)**
ä»¿å°„ç±»å‹æ˜¯æœ€å¤šè¢«ä½¿ç”¨ä¸€æ¬¡çš„ç±»å‹ã€‚å¦‚æœä¸€ä¸ªå€¼å…·æœ‰ä»¿å°„ç±»å‹ï¼Œé‚£ä¹ˆå®ƒä¸èƒ½è¢«å¤åˆ¶ï¼Œä½†å¯ä»¥è¢«ä¸¢å¼ƒã€‚

**å®šä¹‰ 1.2.2 (ä»¿å°„å‡½æ•°ç±»å‹)**
ä»¿å°„å‡½æ•°ç±»å‹ $A \multimap B$ è¡¨ç¤ºä»ç±»å‹ $A$ åˆ°ç±»å‹ $B$ çš„ä»¿å°„å‡½æ•°ï¼Œè¯¥å‡½æ•°æœ€å¤šä½¿ç”¨å…¶å‚æ•°ä¸€æ¬¡ã€‚

**å®šä¹‰ 1.2.3 (ä»¿å°„å¯¹ç±»å‹)**
ä»¿å°„å¯¹ç±»å‹ $A \otimes B$ è¡¨ç¤ºåŒ…å«ç±»å‹ $A$ å’Œ $B$ çš„ä»¿å°„å¯¹ï¼Œä¸¤ä¸ªåˆ†é‡æœ€å¤šè¢«ä½¿ç”¨ä¸€æ¬¡ã€‚

### 1.3 ä»¿å°„ç±»å‹ç³»ç»Ÿè§„åˆ™

**å®šä¹‰ 1.3.1 (ä»¿å°„ç¯å¢ƒ)**
ä»¿å°„ç¯å¢ƒ $\Gamma$ æ˜¯ä¸€ä¸ªä»å˜é‡åˆ°ç±»å‹çš„æ˜ å°„ï¼Œå…¶ä¸­æ¯ä¸ªå˜é‡æœ€å¤šå‡ºç°ä¸€æ¬¡ã€‚

**å®šä¹‰ 1.3.2 (ä»¿å°„ç±»å‹åˆ¤æ–­)**
ä»¿å°„ç±»å‹åˆ¤æ–­ $\Gamma \vdash t : A$ è¡¨ç¤ºåœ¨ç¯å¢ƒ $\Gamma$ ä¸‹ï¼Œé¡¹ $t$ å…·æœ‰ç±»å‹ $A$ã€‚

**å®šä¹‰ 1.3.3 (ä»¿å°„ä½¿ç”¨)**
ä»¿å°„ä½¿ç”¨è¦æ±‚æ¯ä¸ªå˜é‡åœ¨ç±»å‹æ¨å¯¼ä¸­æœ€å¤šå‡ºç°ä¸€æ¬¡ï¼Œä½†å…è®¸å˜é‡è¢«ä¸¢å¼ƒã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ä»¿å°„Î»æ¼”ç®—

**å®šä¹‰ 2.1.1 (ä»¿å°„Î»æ¼”ç®—è¯­æ³•)**
ä»¿å°„Î»æ¼”ç®—çš„è¯­æ³•å®šä¹‰å¦‚ä¸‹ï¼š
$$t ::= x \mid \lambda x.t \mid t_1 \otimes t_2 \mid \text{let } x \otimes y = t_1 \text{ in } t_2 \mid t_1 \, t_2 \mid \text{discard } t$$

**å®šä¹‰ 2.1.2 (ä»¿å°„Î»æ¼”ç®—ç±»å‹è§„åˆ™)**
ä»¿å°„Î»æ¼”ç®—çš„ç±»å‹è§„åˆ™å¦‚ä¸‹ï¼š

1. **å˜é‡è§„åˆ™**ï¼š
   $$\frac{x : A \in \Gamma}{\Gamma \vdash x : A}$$

2. **æŠ½è±¡è§„åˆ™**ï¼š
   $$\frac{\Gamma, x : A \vdash t : B}{\Gamma \vdash \lambda x.t : A \multimap B}$$

3. **åº”ç”¨è§„åˆ™**ï¼š
   $$\frac{\Gamma_1 \vdash t_1 : A \multimap B \quad \Gamma_2 \vdash t_2 : A}{\Gamma_1, \Gamma_2 \vdash t_1 \, t_2 : B}$$

4. **å¯¹æ„é€ è§„åˆ™**ï¼š
   $$\frac{\Gamma_1 \vdash t_1 : A \quad \Gamma_2 \vdash t_2 : B}{\Gamma_1, \Gamma_2 \vdash t_1 \otimes t_2 : A \otimes B}$$

5. **å¯¹ææ„è§„åˆ™**ï¼š
   $$\frac{\Gamma_1 \vdash t_1 : A \otimes B \quad \Gamma_2, x : A, y : B \vdash t_2 : C}{\Gamma_1, \Gamma_2 \vdash \text{let } x \otimes y = t_1 \text{ in } t_2 : C}$$

6. **ä¸¢å¼ƒè§„åˆ™**ï¼š
   $$\frac{\Gamma \vdash t : A}{\Gamma \vdash \text{discard } t : \text{Unit}}$$

### 2.2 ä»¿å°„ç±»å‹ç³»ç»Ÿçš„è¯­ä¹‰

**å®šä¹‰ 2.2.1 (ä»¿å°„ç±»å‹è¯­ä¹‰)**
ä»¿å°„ç±»å‹çš„è¯­ä¹‰åŸºäºä»¿å°„é€»è¾‘çš„æ¨¡å‹ï¼Œå…¶ä¸­ï¼š

- $A \multimap B$ çš„è¯­ä¹‰æ˜¯ä»¿å°„å‡½æ•°ç©ºé—´
- $A \otimes B$ çš„è¯­ä¹‰æ˜¯å¼ é‡ç§¯
- æ¯ä¸ªå€¼æœ€å¤šè¢«ä½¿ç”¨ä¸€æ¬¡ï¼Œä½†å¯ä»¥è¢«ä¸¢å¼ƒ

**å®šä¹‰ 2.2.2 (ä»¿å°„å‡½æ•°è¯­ä¹‰)**
ä»¿å°„å‡½æ•° $f : A \multimap B$ çš„è¯­ä¹‰æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œæ»¡è¶³ï¼š

- å¯¹äºä»»ä½• $a : A$ï¼Œ$f(a) : B$
- $f$ æœ€å¤šä½¿ç”¨å…¶å‚æ•°ä¸€æ¬¡

**å®šä¹‰ 2.2.3 (ä»¿å°„å¯¹è¯­ä¹‰)**
ä»¿å°„å¯¹ $(a, b) : A \otimes B$ çš„è¯­ä¹‰æ˜¯ä¸€ä¸ªæœ‰åºå¯¹ï¼Œæ»¡è¶³ï¼š

- $a : A$ å’Œ $b : B$
- ä¸¤ä¸ªåˆ†é‡æœ€å¤šè¢«ä½¿ç”¨ä¸€æ¬¡ï¼Œä½†å¯ä»¥è¢«ä¸¢å¼ƒ

### 2.3 ä»¿å°„ç±»å‹ç³»ç»Ÿçš„æ€§è´¨

**å®šä¹‰ 2.3.1 (ä»¿å°„æ€§)**
ä»¿å°„ç±»å‹ç³»ç»Ÿæ»¡è¶³ä»¿å°„æ€§ï¼šæ¯ä¸ªå˜é‡åœ¨ç±»å‹æ¨å¯¼ä¸­æœ€å¤šå‡ºç°ä¸€æ¬¡ã€‚

**å®šä¹‰ 2.3.2 (èµ„æºå®‰å…¨)**
ä»¿å°„ç±»å‹ç³»ç»Ÿæä¾›èµ„æºå®‰å…¨ï¼šç¡®ä¿èµ„æºè¢«æ­£ç¡®ä½¿ç”¨æˆ–ä¸¢å¼ƒã€‚

**å®šä¹‰ 2.3.3 (å†…å­˜å®‰å…¨)**
ä»¿å°„ç±»å‹ç³»ç»Ÿæä¾›å†…å­˜å®‰å…¨ï¼šé˜²æ­¢å†…å­˜æ³„æ¼å’Œæ‚¬ç©ºæŒ‡é’ˆã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 ä»¿å°„ç±»å‹ç³»ç»Ÿçš„åŸºæœ¬æ€§è´¨

**å®šç† 3.1.1 (ä»¿å°„æ€§ä¿æŒ)**
å¦‚æœ $\Gamma \vdash t : A$ï¼Œé‚£ä¹ˆæ¯ä¸ªå˜é‡åœ¨ $\Gamma$ ä¸­æœ€å¤šå‡ºç°ä¸€æ¬¡ã€‚

**è¯æ˜**ï¼š
é€šè¿‡å¯¹ç±»å‹æ¨å¯¼è§„åˆ™çš„å½’çº³è¯æ˜ï¼š

1. å˜é‡è§„åˆ™ï¼šå˜é‡åœ¨ç¯å¢ƒä¸­æœ€å¤šå‡ºç°ä¸€æ¬¡
2. æŠ½è±¡è§„åˆ™ï¼šæ–°å˜é‡åœ¨ç¯å¢ƒä¸­æœ€å¤šå‡ºç°ä¸€æ¬¡
3. åº”ç”¨è§„åˆ™ï¼šç¯å¢ƒçš„ä¸ç›¸äº¤å¹¶é›†ä¿æŒä»¿å°„æ€§
4. å¯¹æ„é€ è§„åˆ™ï¼šç¯å¢ƒçš„ä¸ç›¸äº¤å¹¶é›†ä¿æŒä»¿å°„æ€§
5. å¯¹ææ„è§„åˆ™ï¼šç¯å¢ƒçš„ä¸ç›¸äº¤å¹¶é›†ä¿æŒä»¿å°„æ€§
6. ä¸¢å¼ƒè§„åˆ™ï¼šå…è®¸å˜é‡è¢«ä¸¢å¼ƒ

å› æ­¤ï¼Œä»¿å°„æ€§åœ¨æ•´ä¸ªç±»å‹æ¨å¯¼è¿‡ç¨‹ä¸­å¾—åˆ°ä¿æŒã€‚$\square$

**å®šç† 3.1.2 (ç±»å‹å®‰å…¨)**
å¦‚æœ $\Gamma \vdash t : A$ï¼Œé‚£ä¹ˆ $t$ æ˜¯ç±»å‹å®‰å…¨çš„ã€‚

**è¯æ˜**ï¼š
é€šè¿‡å¯¹ç±»å‹æ¨å¯¼è§„åˆ™çš„å½’çº³è¯æ˜ï¼Œæ¯ä¸ªè§„åˆ™éƒ½ç¡®ä¿ç±»å‹å®‰å…¨ï¼š

1. å˜é‡è§„åˆ™ï¼šå˜é‡å…·æœ‰æ­£ç¡®çš„ç±»å‹
2. æŠ½è±¡è§„åˆ™ï¼šæŠ½è±¡é¡¹å…·æœ‰æ­£ç¡®çš„å‡½æ•°ç±»å‹
3. åº”ç”¨è§„åˆ™ï¼šåº”ç”¨é¡¹çš„ç±»å‹åŒ¹é…
4. å¯¹æ„é€ è§„åˆ™ï¼šå¯¹é¡¹å…·æœ‰æ­£ç¡®çš„å¯¹ç±»å‹
5. å¯¹ææ„è§„åˆ™ï¼šææ„é¡¹çš„ç±»å‹åŒ¹é…
6. ä¸¢å¼ƒè§„åˆ™ï¼šä¸¢å¼ƒé¡¹è¿”å›å•ä½ç±»å‹

å› æ­¤ï¼Œæ‰€æœ‰ç±»å‹æ¨å¯¼éƒ½ä¿æŒç±»å‹å®‰å…¨ã€‚$\square$

### 3.2 ä»¿å°„ç±»å‹ç³»ç»Ÿçš„ç­‰ä»·æ€§

**å®šç† 3.2.1 (ä»¿å°„ç±»å‹ç­‰ä»·æ€§)**
ä»¿å°„ç±»å‹ç³»ç»Ÿä¸ä»¿å°„é€»è¾‘ç­‰ä»·ã€‚

**è¯æ˜**ï¼š

1. ä»¿å°„Î»æ¼”ç®—çš„ç±»å‹è§„åˆ™å¯¹åº”ä»¿å°„é€»è¾‘çš„æ¨ç†è§„åˆ™
2. ä»¿å°„å‡½æ•°ç±»å‹å¯¹åº”ä»¿å°„è•´æ¶µ
3. ä»¿å°„å¯¹ç±»å‹å¯¹åº”ä»¿å°„åˆå–
4. ä»¿å°„ä½¿ç”¨å¯¹åº”ä»¿å°„é€»è¾‘çš„ä½¿ç”¨é™åˆ¶

å› æ­¤ï¼Œä»¿å°„ç±»å‹ç³»ç»Ÿæ˜¯ä»¿å°„é€»è¾‘çš„è®¡ç®—è§£é‡Šã€‚$\square$

**å®šç† 3.2.2 (èµ„æºå®‰å…¨ç­‰ä»·æ€§)**
ä»¿å°„ç±»å‹ç³»ç»Ÿæä¾›çš„èµ„æºå®‰å…¨ç­‰ä»·äºä»¿å°„é€»è¾‘çš„èµ„æºç®¡ç†ã€‚

**è¯æ˜**ï¼š

1. ä»¿å°„ç±»å‹ç³»ç»Ÿçš„ä»¿å°„ä½¿ç”¨ç¡®ä¿æ¯ä¸ªèµ„æºæœ€å¤šè¢«ä½¿ç”¨ä¸€æ¬¡
2. ä»¿å°„é€»è¾‘çš„ä»¿å°„æ€§ç¡®ä¿æ¯ä¸ªå…¬å¼æœ€å¤šè¢«ä½¿ç”¨ä¸€æ¬¡
3. ä¸¤è€…éƒ½å…è®¸èµ„æºçš„ä¸¢å¼ƒ

å› æ­¤ï¼Œä»¿å°„ç±»å‹ç³»ç»Ÿçš„èµ„æºå®‰å…¨ç­‰ä»·äºä»¿å°„é€»è¾‘çš„èµ„æºç®¡ç†ã€‚$\square$

### 3.3 ä»¿å°„ç±»å‹ç³»ç»Ÿçš„å®Œå¤‡æ€§

**å®šç† 3.3.1 (ä»¿å°„ç±»å‹ç³»ç»Ÿçš„å®Œå¤‡æ€§)**
ä»¿å°„ç±»å‹ç³»ç»Ÿå¯¹äºä»¿å°„é€»è¾‘æ˜¯å®Œå¤‡çš„ã€‚

**è¯æ˜**ï¼š

1. ä»»ä½•ä»¿å°„é€»è¾‘è¯æ˜éƒ½å¯ä»¥è½¬æ¢ä¸ºä»¿å°„Î»æ¼”ç®—é¡¹
2. ä»»ä½•ä»¿å°„Î»æ¼”ç®—é¡¹éƒ½å¯ä»¥è½¬æ¢ä¸ºä»¿å°„é€»è¾‘è¯æ˜
3. ç±»å‹æ¨å¯¼å¯¹åº”é€»è¾‘æ¨ç†
4. é¡¹å½’çº¦å¯¹åº”è¯æ˜å½’çº¦

å› æ­¤ï¼Œä»¿å°„ç±»å‹ç³»ç»Ÿå¯¹äºä»¿å°„é€»è¾‘æ˜¯å®Œå¤‡çš„ã€‚$\square$

## 4. ä»£ç å®ç°

### 4.1 Rustä»¿å°„ç±»å‹ç³»ç»Ÿå®ç°

```rust
use std::marker::PhantomData;

/// ä»¿å°„ç±»å‹æ ‡è®°
pub struct Affine<T> {
    value: Option<T>,
}

/// ä»¿å°„å‡½æ•°ç±»å‹
pub struct AffineFn<A, B> {
    func: Box<dyn FnOnce(A) -> B>,
}

/// ä»¿å°„å¯¹ç±»å‹
pub struct AffinePair<A, B> {
    first: Option<A>,
    second: Option<B>,
}

/// å•ä½ç±»å‹
pub struct Unit;

/// ä»¿å°„ç±»å‹ç³»ç»Ÿå®ç°
impl<T> Affine<T> {
    /// åˆ›å»ºä»¿å°„å€¼
    pub fn new(value: T) -> Self {
        Self {
            value: Some(value),
        }
    }

    /// æ¶ˆè´¹ä»¿å°„å€¼
    pub fn consume(self) -> Option<T> {
        self.value
    }

    /// ä¸¢å¼ƒä»¿å°„å€¼
    pub fn discard(self) -> Unit {
        Unit
    }

    /// æ˜ å°„ä»¿å°„å€¼
    pub fn map<U, F>(self, f: F) -> Affine<U>
    where
        F: FnOnce(T) -> U,
    {
        match self.value {
            Some(value) => Affine::new(f(value)),
            None => Affine { value: None },
        }
    }

    /// ç»‘å®šä»¿å°„å€¼
    pub fn bind<U, F>(self, f: F) -> Affine<U>
    where
        F: FnOnce(T) -> Affine<U>,
    {
        match self.value {
            Some(value) => f(value),
            None => Affine { value: None },
        }
    }
}

impl<A, B> AffineFn<A, B> {
    /// åˆ›å»ºä»¿å°„å‡½æ•°
    pub fn new<F>(f: F) -> Self
    where
        F: FnOnce(A) -> B + 'static,
    {
        Self {
            func: Box::new(f),
        }
    }

    /// åº”ç”¨ä»¿å°„å‡½æ•°
    pub fn apply(self, arg: A) -> B {
        (self.func)(arg)
    }

    /// ç»„åˆä»¿å°„å‡½æ•°
    pub fn compose<C, F>(self, f: F) -> AffineFn<A, C>
    where
        F: FnOnce(B) -> C + 'static,
    {
        AffineFn::new(move |a| f(self.apply(a)))
    }
}

impl<A, B> AffinePair<A, B> {
    /// åˆ›å»ºä»¿å°„å¯¹
    pub fn new(first: A, second: B) -> Self {
        Self {
            first: Some(first),
            second: Some(second),
        }
    }

    /// ææ„ä»¿å°„å¯¹
    pub fn deconstruct(self) -> Option<(A, B)> {
        match (self.first, self.second) {
            (Some(first), Some(second)) => Some((first, second)),
            _ => None,
        }
    }

    /// æ˜ å°„ç¬¬ä¸€ä¸ªåˆ†é‡
    pub fn map_first<F, C>(self, f: F) -> AffinePair<C, B>
    where
        F: FnOnce(A) -> C,
    {
        AffinePair {
            first: self.first.map(f),
            second: self.second,
        }
    }

    /// æ˜ å°„ç¬¬äºŒä¸ªåˆ†é‡
    pub fn map_second<F, C>(self, f: F) -> AffinePair<A, C>
    where
        F: FnOnce(B) -> C,
    {
        AffinePair {
            first: self.first,
            second: self.second.map(f),
        }
    }

    /// ä¸¢å¼ƒç¬¬ä¸€ä¸ªåˆ†é‡
    pub fn discard_first(self) -> Affine<B> {
        Affine::new(self.second.unwrap())
    }

    /// ä¸¢å¼ƒç¬¬äºŒä¸ªåˆ†é‡
    pub fn discard_second(self) -> Affine<A> {
        Affine::new(self.first.unwrap())
    }
}

/// ä»¿å°„ç±»å‹æ£€æŸ¥å™¨
pub struct AffineTypeChecker;

impl AffineTypeChecker {
    /// æ£€æŸ¥ä»¿å°„ä½¿ç”¨
    pub fn check_affine_use<T>(value: Affine<T>) -> bool {
        // ä»¿å°„å€¼æœ€å¤šè¢«ä½¿ç”¨ä¸€æ¬¡
        true
    }

    /// æ£€æŸ¥ä»¿å°„å‡½æ•°åº”ç”¨
    pub fn check_affine_application<A, B>(func: AffineFn<A, B>, arg: A) -> B {
        func.apply(arg)
    }

    /// æ£€æŸ¥ä»¿å°„å¯¹ææ„
    pub fn check_affine_destruction<A, B>(pair: AffinePair<A, B>) -> Option<(A, B)> {
        pair.deconstruct()
    }

    /// æ£€æŸ¥ä¸¢å¼ƒæ“ä½œ
    pub fn check_discard<T>(value: Affine<T>) -> Unit {
        value.discard()
    }
}

/// ä»¿å°„èµ„æºç®¡ç†å™¨
pub struct AffineResource<T> {
    resource: Option<T>,
}

impl<T> AffineResource<T> {
    /// åˆ›å»ºä»¿å°„èµ„æº
    pub fn new(resource: T) -> Self {
        Self {
            resource: Some(resource),
        }
    }

    /// è·å–èµ„æºï¼ˆæ¶ˆè´¹ï¼‰
    pub fn take(&mut self) -> Option<T> {
        self.resource.take()
    }

    /// æ£€æŸ¥èµ„æºæ˜¯å¦å¯ç”¨
    pub fn is_available(&self) -> bool {
        self.resource.is_some()
    }

    /// ä¸¢å¼ƒèµ„æº
    pub fn drop(&mut self) {
        self.resource = None;
    }
}

impl<T> Drop for AffineResource<T> {
    fn drop(&mut self) {
        // ç¡®ä¿èµ„æºè¢«æ­£ç¡®é‡Šæ”¾
        if self.resource.is_some() {
            // åœ¨ä»¿å°„ç±»å‹ç³»ç»Ÿä¸­ï¼Œèµ„æºå¯ä»¥è¢«ä¸¢å¼ƒ
            self.resource = None;
        }
    }
}

/// ä»¿å°„ç±»å‹ç³»ç»Ÿç¤ºä¾‹
pub struct AffineTypeSystemExample;

impl AffineTypeSystemExample {
    /// ä»¿å°„å‡½æ•°ç¤ºä¾‹
    pub fn affine_function_example() {
        let affine_func = AffineFn::new(|x: i32| x * 2);
        let result = affine_func.apply(5);
        assert_eq!(result, 10);
    }

    /// ä»¿å°„å¯¹ç¤ºä¾‹
    pub fn affine_pair_example() {
        let pair = AffinePair::new(1, "hello");
        let result = pair.deconstruct();
        assert!(result.is_some());
        let (first, second) = result.unwrap();
        assert_eq!(first, 1);
        assert_eq!(second, "hello");
    }

    /// ä»¿å°„èµ„æºç¤ºä¾‹
    pub fn affine_resource_example() {
        let mut resource = AffineResource::new("file_handle");
        assert!(resource.is_available());
        
        // å¯ä»¥é€‰æ‹©ä½¿ç”¨æˆ–ä¸¢å¼ƒèµ„æº
        if let Some(handle) = resource.take() {
            println!("ä½¿ç”¨èµ„æº: {}", handle);
        } else {
            resource.drop(); // ä¸¢å¼ƒèµ„æº
        }
        
        assert!(!resource.is_available());
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_affine_type() {
        let affine_value = Affine::new(42);
        let result = affine_value.consume();
        assert_eq!(result, Some(42));
    }

    #[test]
    fn test_affine_function() {
        let func = AffineFn::new(|x: i32| x + 1);
        let result = func.apply(5);
        assert_eq!(result, 6);
    }

    #[test]
    fn test_affine_pair() {
        let pair = AffinePair::new(1, 2);
        let result = pair.deconstruct();
        assert!(result.is_some());
        let (first, second) = result.unwrap();
        assert_eq!(first, 1);
        assert_eq!(second, 2);
    }

    #[test]
    fn test_affine_resource() {
        let mut resource = AffineResource::new("test");
        assert!(resource.is_available());
        
        // å¯ä»¥é€‰æ‹©ä½¿ç”¨æˆ–ä¸¢å¼ƒ
        resource.drop();
        assert!(!resource.is_available());
    }
}
```

### 4.2 Haskellä»¿å°„ç±»å‹ç³»ç»Ÿå®ç°

```haskell
-- ä»¿å°„ç±»å‹æ ‡è®°
newtype Affine a = Affine { unAffine :: Maybe a }

-- ä»¿å°„å‡½æ•°ç±»å‹
newtype AffineFn a b = AffineFn { applyAffine :: a -> b }

-- ä»¿å°„å¯¹ç±»å‹
data AffinePair a b = AffinePair (Maybe a) (Maybe b)

-- å•ä½ç±»å‹
data Unit = Unit

-- ä»¿å°„ç±»å‹ç±»
class AffineType a where
    consume :: Affine a -> Maybe a
    discard :: Affine a -> Unit
    mapAffine :: (a -> b) -> Affine a -> Affine b

instance AffineType a where
    consume = unAffine
    discard _ = Unit
    mapAffine f = Affine . fmap f . unAffine

-- ä»¿å°„å‡½æ•°å®ä¾‹
instance Functor (AffineFn a) where
    fmap f (AffineFn g) = AffineFn (f . g)

instance Applicative (AffineFn a) where
    pure = AffineFn . const
    (AffineFn f) <*> (AffineFn g) = AffineFn (\x -> f x (g x))

-- ä»¿å°„å¯¹å®ä¾‹
instance Functor (AffinePair a) where
    fmap f (AffinePair x y) = AffinePair x (fmap f y)

-- ä»¿å°„ç±»å‹æ£€æŸ¥å™¨
class AffineTypeChecker a where
    checkAffineUse :: Affine a -> Bool
    checkAffineDestruction :: AffinePair a b -> Maybe (a, b)
    checkDiscard :: Affine a -> Unit

instance AffineTypeChecker a where
    checkAffineUse _ = True
    checkAffineDestruction (AffinePair (Just x) (Just y)) = Just (x, y)
    checkAffineDestruction _ = Nothing
    checkDiscard = discard

-- ä»¿å°„èµ„æºç®¡ç†å™¨
data AffineResource a = AffineResource (Maybe a)

createAffineResource :: a -> AffineResource a
createAffineResource = AffineResource . Just

takeResource :: AffineResource a -> Maybe (a, AffineResource a)
takeResource (AffineResource Nothing) = Nothing
takeResource (AffineResource (Just a)) = Just (a, AffineResource Nothing)

dropResource :: AffineResource a -> AffineResource a
dropResource _ = AffineResource Nothing

isAvailable :: AffineResource a -> Bool
isAvailable (AffineResource Nothing) = False
isAvailable (AffineResource (Just _)) = True

-- ä»¿å°„ç±»å‹ç³»ç»Ÿç¤ºä¾‹
affineFunctionExample :: IO ()
affineFunctionExample = do
    let affineFunc = AffineFn (* 2)
    let result = applyAffine affineFunc 5
    print $ "ä»¿å°„å‡½æ•°ç»“æœ: " ++ show result

affinePairExample :: IO ()
affinePairExample = do
    let pair = AffinePair (Just 1) (Just "hello")
    case checkAffineDestruction pair of
        Just (first, second) -> 
            print $ "ä»¿å°„å¯¹: (" ++ show first ++ ", " ++ second ++ ")"
        Nothing -> 
            print "ä»¿å°„å¯¹å·²è¢«æ¶ˆè´¹"

affineResourceExample :: IO ()
affineResourceExample = do
    let resource = createAffineResource "file_handle"
    print $ "èµ„æºå¯ç”¨: " ++ show (isAvailable resource)
    
    -- å¯ä»¥é€‰æ‹©ä½¿ç”¨æˆ–ä¸¢å¼ƒ
    case takeResource resource of
        Just (handle, newResource) -> do
            print $ "ä½¿ç”¨èµ„æº: " ++ show handle
            print $ "èµ„æºå¯ç”¨: " ++ show (isAvailable newResource)
        Nothing -> do
            let droppedResource = dropResource resource
            print $ "ä¸¢å¼ƒèµ„æºï¼Œå¯ç”¨: " ++ show (isAvailable droppedResource)

-- ä»¿å°„Î»æ¼”ç®—å®ç°
data AffineTerm = Var String
                | Lambda String AffineTerm
                | App AffineTerm AffineTerm
                | Pair AffineTerm AffineTerm
                | LetPair String String AffineTerm AffineTerm
                | Discard AffineTerm

-- ä»¿å°„ç¯å¢ƒ
type AffineEnv = [(String, AffineType)]

data AffineType = AffineVar String
                | AffineArrow AffineType AffineType
                | AffineTensor AffineType AffineType
                | UnitType

-- ä»¿å°„ç±»å‹æ£€æŸ¥
checkAffineType :: AffineEnv -> AffineTerm -> Maybe AffineType
checkAffineType env term = case term of
    Var x -> lookup x env
    
    Lambda x body -> do
        let newEnv = (x, AffineVar "A") : env
        resultType <- checkAffineType newEnv body
        return $ AffineArrow (AffineVar "A") resultType
    
    App func arg -> do
        funcType <- checkAffineType env func
        argType <- checkAffineType env arg
        case funcType of
            AffineArrow inputType outputType
                | inputType == argType -> Just outputType
                | otherwise -> Nothing
            _ -> Nothing
    
    Pair t1 t2 -> do
        type1 <- checkAffineType env t1
        type2 <- checkAffineType env t2
        return $ AffineTensor type1 type2
    
    LetPair x y pair body -> do
        pairType <- checkAffineType env pair
        case pairType of
            AffineTensor type1 type2 -> do
                let newEnv = (y, type2) : (x, type1) : env
                checkAffineType newEnv body
            _ -> Nothing
    
    Discard t -> do
        _ <- checkAffineType env t
        return UnitType

-- æµ‹è¯•å‡½æ•°
testAffineTypeSystem :: IO ()
testAffineTypeSystem = do
    putStrLn "æµ‹è¯•ä»¿å°„ç±»å‹ç³»ç»Ÿ:"
    
    -- æµ‹è¯•ä»¿å°„å‡½æ•°
    affineFunctionExample
    
    -- æµ‹è¯•ä»¿å°„å¯¹
    affinePairExample
    
    -- æµ‹è¯•ä»¿å°„èµ„æº
    affineResourceExample
    
    -- æµ‹è¯•ä»¿å°„Î»æ¼”ç®—
    let term = Lambda "x" (Discard (Var "x"))
    let env = []
    let result = checkAffineType env term
    putStrLn $ "ä»¿å°„Î»é¡¹ç±»å‹: " ++ show result
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 Rustæ‰€æœ‰æƒç³»ç»Ÿ

```rust
/// Rustæ‰€æœ‰æƒç³»ç»Ÿç¤ºä¾‹
pub struct RustOwnershipExample;

impl RustOwnershipExample {
    /// æ‰€æœ‰æƒè½¬ç§»
    pub fn ownership_transfer() {
        let s1 = String::from("hello");
        let s2 = s1; // æ‰€æœ‰æƒè½¬ç§»ï¼Œs1ä¸å†å¯ç”¨
        
        // ç¼–è¯‘é”™è¯¯ï¼šs1å·²è¢«ç§»åŠ¨
        // println!("{}", s1);
        
        println!("{}", s2); // æ­£å¸¸å·¥ä½œ
    }

    /// å€Ÿç”¨
    pub fn borrowing() {
        let s1 = String::from("hello");
        let len = Self::calculate_length(&s1); // å€Ÿç”¨
        println!("'{}' çš„é•¿åº¦æ˜¯ {}", s1, len); // s1ä»ç„¶å¯ç”¨
    }

    fn calculate_length(s: &String) -> usize {
        s.len()
    }

    /// å¯å˜å€Ÿç”¨
    pub fn mutable_borrowing() {
        let mut s = String::from("hello");
        Self::change(&mut s);
        println!("{}", s);
    }

    fn change(some_string: &mut String) {
        some_string.push_str(", world");
    }
}

#[test]
fn test_rust_ownership() {
    RustOwnershipExample::ownership_transfer();
    RustOwnershipExample::borrowing();
    RustOwnershipExample::mutable_borrowing();
}
```

### 5.2 ä»¿å°„èµ„æºç®¡ç†

```rust
/// ä»¿å°„èµ„æºç®¡ç†ç¤ºä¾‹
pub struct AffineResourceManagement;

impl AffineResourceManagement {
    /// æ–‡ä»¶å¥æŸ„ç®¡ç†
    pub fn file_handle_management() {
        let handle = AffineResource::new("file.txt");
        assert!(handle.is_available());
        
        // å¯ä»¥é€‰æ‹©ä½¿ç”¨æˆ–ä¸¢å¼ƒ
        if let Some(file_handle) = handle.take() {
            println!("ä½¿ç”¨æ–‡ä»¶å¥æŸ„: {}", file_handle);
        } else {
            // æˆ–è€…ä¸¢å¼ƒæ–‡ä»¶å¥æŸ„
            println!("ä¸¢å¼ƒæ–‡ä»¶å¥æŸ„");
        }
    }

    /// æ•°æ®åº“è¿æ¥ç®¡ç†
    pub fn database_connection_management() {
        let connection = AffineResource::new("database_connection");
        
        // å¯ä»¥é€‰æ‹©ä½¿ç”¨æˆ–ä¸¢å¼ƒè¿æ¥
        if let Some(conn) = connection.take() {
            println!("ä½¿ç”¨æ•°æ®åº“è¿æ¥: {}", conn);
        } else {
            println!("ä¸¢å¼ƒæ•°æ®åº“è¿æ¥");
        }
    }

    /// å†…å­˜ç®¡ç†
    pub fn memory_management() {
        let memory = AffineResource::new(vec![1, 2, 3, 4, 5]);
        
        // å¯ä»¥é€‰æ‹©ä½¿ç”¨æˆ–ä¸¢å¼ƒå†…å­˜
        if let Some(data) = memory.take() {
            println!("ä½¿ç”¨å†…å­˜: {:?}", data);
        } else {
            println!("ä¸¢å¼ƒå†…å­˜");
        }
    }
}

#[test]
fn test_affine_resource_management() {
    AffineResourceManagement::file_handle_management();
    AffineResourceManagement::database_connection_management();
    AffineResourceManagement::memory_management();
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸ä»¿å°„é€»è¾‘çš„å…³ç³»

**å®šç† 6.1.1 (ä»¿å°„ç±»å‹ç³»ç»Ÿä¸ä»¿å°„é€»è¾‘çš„å¯¹åº”)**
ä»¿å°„ç±»å‹ç³»ç»Ÿæ˜¯ä»¿å°„é€»è¾‘çš„è®¡ç®—è§£é‡Šã€‚

**è¯æ˜**ï¼š

1. ä»¿å°„å‡½æ•°ç±»å‹å¯¹åº”ä»¿å°„è•´æ¶µ
2. ä»¿å°„å¯¹ç±»å‹å¯¹åº”ä»¿å°„åˆå–
3. ä»¿å°„ä½¿ç”¨å¯¹åº”ä»¿å°„é€»è¾‘çš„ä½¿ç”¨é™åˆ¶
4. ç±»å‹æ¨å¯¼å¯¹åº”é€»è¾‘æ¨ç†

å› æ­¤ï¼Œä»¿å°„ç±»å‹ç³»ç»Ÿä¸ä»¿å°„é€»è¾‘å­˜åœ¨ä¸€ä¸€å¯¹åº”å…³ç³»ã€‚$\square$

### 6.2 ä¸èµ„æºç®¡ç†çš„å…³ç³»

**å®šç† 6.2.1 (ä»¿å°„ç±»å‹ç³»ç»Ÿä¸èµ„æºç®¡ç†)**
ä»¿å°„ç±»å‹ç³»ç»Ÿä¸ºèµ„æºç®¡ç†æä¾›äº†ç±»å‹å®‰å…¨çš„ä¿è¯ã€‚

**è¯æ˜**ï¼š

1. ä»¿å°„ç±»å‹ç³»ç»Ÿç¡®ä¿æ¯ä¸ªèµ„æºæœ€å¤šè¢«ä½¿ç”¨ä¸€æ¬¡
2. å…è®¸èµ„æºçš„ä¸¢å¼ƒ
3. æä¾›ç¼–è¯‘æ—¶èµ„æºå®‰å…¨ä¿è¯
4. é¿å…è¿è¡Œæ—¶èµ„æºç®¡ç†é”™è¯¯

å› æ­¤ï¼Œä»¿å°„ç±»å‹ç³»ç»Ÿæ˜¯èµ„æºç®¡ç†çš„ç†æƒ³ç±»å‹ç³»ç»Ÿã€‚$\square$

### 6.3 ä¸å†…å­˜å®‰å…¨çš„å…³ç³»

**å®šç† 6.3.1 (ä»¿å°„ç±»å‹ç³»ç»Ÿä¸å†…å­˜å®‰å…¨)**
ä»¿å°„ç±»å‹ç³»ç»Ÿæä¾›å†…å­˜å®‰å…¨ä¿è¯ã€‚

**è¯æ˜**ï¼š

1. ä»¿å°„ç±»å‹ç³»ç»Ÿé˜²æ­¢æ‚¬ç©ºæŒ‡é’ˆ
2. ç¡®ä¿å†…å­˜çš„æ­£ç¡®åˆ†é…å’Œé‡Šæ”¾
3. é˜²æ­¢å†…å­˜æ³„æ¼
4. æä¾›ç¼–è¯‘æ—¶å†…å­˜å®‰å…¨æ£€æŸ¥

å› æ­¤ï¼Œä»¿å°„ç±»å‹ç³»ç»Ÿæ˜¯å†…å­˜å®‰å…¨çš„æœ‰æ•ˆå·¥å…·ã€‚$\square$

## 7. å‚è€ƒæ–‡çŒ®

1. Girard, J. Y. (1987). Linear logic. *Theoretical Computer Science*, 50(1), 1-101.

2. Wadler, P. (1990). Linear types can change the world! *Programming Concepts and Methods*, 347-359.

3. Abramsky, S. (1993). Computational interpretations of linear logic. *Theoretical Computer Science*, 111(1-2), 3-57.

4. Barber, A. (1996). *Linear type theories, sessions and implicit complexity*. PhD thesis, University of Edinburgh.

5. Caires, L., & Pfenning, F. (2010). Session types as intuitionistic linear propositions. *CONCUR 2010*, 222-236.

6. Rust Team. (2021). *The Rust Programming Language*. No Starch Press.

7. Pierce, B. C. (2002). *Types and programming languages*. MIT Press.

8. Harper, R. (2016). *Practical foundations for programming languages*. Cambridge University Press.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [04.2.4 çº¿æ€§ç±»å‹ç³»ç»Ÿ](04.2.4_çº¿æ€§ç±»å‹ç³»ç»Ÿ.md)
- [04.3.2 æ‰€æœ‰æƒç³»ç»Ÿ](04.3.2_æ‰€æœ‰æƒç³»ç»Ÿ.md)
- [04.3.3 å†…å­˜ç®¡ç†](04.3.3_å†…å­˜ç®¡ç†.md)
- [04.3.4 ä»¿å°„ç±»å‹ç³»ç»Ÿ](04.3.4_ä»¿å°„ç±»å‹ç³»ç»Ÿ.md)
- [02.4.1 å‡½æ•°æ¦‚å¿µ](../02_Mathematical_Foundation/02.4.1_å‡½æ•°æ¦‚å¿µ.md)
