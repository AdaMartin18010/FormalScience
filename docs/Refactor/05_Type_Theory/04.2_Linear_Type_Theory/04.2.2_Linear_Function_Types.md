# 04.2.2 çº¿æ€§å‡½æ•°ç±»å‹

## ğŸ“‹ æ¦‚è¿°

çº¿æ€§å‡½æ•°ç±»å‹æ˜¯çº¿æ€§ç±»å‹ç³»ç»Ÿçš„æ ¸å¿ƒï¼Œç¡®ä¿å‡½æ•°å‚æ•°æ°å¥½ä½¿ç”¨ä¸€æ¬¡ã€‚æœ¬ç†è®ºå»ºç«‹çº¿æ€§å‡½æ•°çš„ä¸¥æ ¼å®šä¹‰ã€æ€§è´¨å’Œå®ç°ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹çº¿æ€§å‡½æ•°ç±»å‹çš„ä¸¥æ ¼å®šä¹‰
2. è¯æ˜çº¿æ€§å‡½æ•°çš„æ€§è´¨
3. æä¾›é«˜æ•ˆçš„å®ç°
4. å±•ç¤ºåœ¨ç³»ç»Ÿç¼–ç¨‹ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ç®—æ³•å®ç°](#4-ç®—æ³•å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 çº¿æ€§å‡½æ•°

**å®šä¹‰ 1.1.1** (çº¿æ€§å‡½æ•°)
çº¿æ€§å‡½æ•° $f: A \multimap B$ æ˜¯æ»¡è¶³çº¿æ€§æ€§çš„å‡½æ•°ï¼Œå³å‚æ•°æ°å¥½ä½¿ç”¨ä¸€æ¬¡ã€‚

### 1.2 çº¿æ€§æ€§

**å®šä¹‰ 1.1.2** (çº¿æ€§æ€§)
å‡½æ•° $f$ æ˜¯çº¿æ€§çš„ï¼Œå½“ä¸”ä»…å½“å¯¹äºä»»æ„è¾“å…¥ $x$ï¼Œ$f(x)$ ä¸­ $x$ æ°å¥½å‡ºç°ä¸€æ¬¡ã€‚

### 1.3 èµ„æºç®¡ç†

**å®šä¹‰ 1.1.3** (èµ„æº)
çº¿æ€§å‡½æ•°ä¸­çš„å‚æ•°è¢«è§†ä¸ºèµ„æºï¼Œä¸èƒ½è¢«å¤åˆ¶æˆ–ä¸¢å¼ƒã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 çº¿æ€§å‡½æ•°ç±»å‹

**å®šä¹‰ 2.1.1** (çº¿æ€§å‡½æ•°ç±»å‹)
çº¿æ€§å‡½æ•°ç±»å‹ $A \multimap B$ å®šä¹‰ä¸ºï¼š
$$A \multimap B = \{f: A \to B \mid f \text{ is linear}\}$$

### 2.2 çº¿æ€§å‡½æ•°æ„é€ 

**å®šä¹‰ 2.1.2** (çº¿æ€§å‡½æ•°æ„é€ )
çº¿æ€§å‡½æ•°å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼æ„é€ ï¼š

- çº¿æ€§æŠ½è±¡ï¼š$\lambda x.M$ å…¶ä¸­ $x$ åœ¨ $M$ ä¸­æ°å¥½å‡ºç°ä¸€æ¬¡
- çº¿æ€§åº”ç”¨ï¼š$M N$ å…¶ä¸­ $M: A \multimap B$ ä¸” $N: A$

### 2.3 çº¿æ€§å‡½æ•°ç»„åˆ

**å®šä¹‰ 2.1.3** (çº¿æ€§å‡½æ•°ç»„åˆ)
çº¿æ€§å‡½æ•° $f: A \multimap B$ å’Œ $g: B \multimap C$ çš„ç»„åˆ $g \circ f: A \multimap C$ å®šä¹‰ä¸ºï¼š
$$(g \circ f)(x) = g(f(x))$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 çº¿æ€§æ€§ä¿æŒ

**å®šç† 3.1.1** (çº¿æ€§æ€§ä¿æŒ)
å¦‚æœ $f: A \multimap B$ å’Œ $g: B \multimap C$ éƒ½æ˜¯çº¿æ€§å‡½æ•°ï¼Œåˆ™ $g \circ f: A \multimap C$ ä¹Ÿæ˜¯çº¿æ€§å‡½æ•°ã€‚

**è¯æ˜**ï¼š
ç”±äº $f$ å’Œ $g$ éƒ½æ˜¯çº¿æ€§çš„ï¼Œ$f(x)$ ä¸­ $x$ æ°å¥½å‡ºç°ä¸€æ¬¡ï¼Œ$g(f(x))$ ä¸­ $f(x)$ æ°å¥½å‡ºç°ä¸€æ¬¡ï¼Œå› æ­¤ $g \circ f$ æ˜¯çº¿æ€§çš„ã€‚

### 3.2 çº¿æ€§å‡½æ•°å”¯ä¸€æ€§

**å®šç† 3.2.1** (çº¿æ€§å‡½æ•°å”¯ä¸€æ€§)
å¯¹äºä»»æ„çº¿æ€§å‡½æ•° $f: A \multimap B$ï¼Œå¦‚æœ $f(x) = g(x)$ å¯¹æ‰€æœ‰ $x \in A$ æˆç«‹ï¼Œåˆ™ $f = g$ã€‚

**è¯æ˜**ï¼š
ç”±äºçº¿æ€§å‡½æ•°æ˜¯ç¡®å®šçš„ï¼Œç›¸åŒçš„è¾“å…¥äº§ç”Ÿç›¸åŒçš„è¾“å‡ºï¼Œå› æ­¤å‡½æ•°ç›¸ç­‰ã€‚

### 3.3 çº¿æ€§å‡½æ•°å¯é€†æ€§

**å®šç† 3.3.1** (çº¿æ€§å‡½æ•°å¯é€†æ€§)
å¦‚æœçº¿æ€§å‡½æ•° $f: A \multimap B$ æ˜¯åŒå°„çš„ï¼Œåˆ™å…¶é€†å‡½æ•° $f^{-1}: B \multimap A$ ä¹Ÿæ˜¯çº¿æ€§çš„ã€‚

**è¯æ˜**ï¼š
ç”±äº $f$ æ˜¯åŒå°„çš„ï¼Œ$f^{-1}$ å­˜åœ¨ä¸”å”¯ä¸€ã€‚ç”±äº $f$ æ˜¯çº¿æ€§çš„ï¼Œ$f^{-1}$ ä¹Ÿä¿æŒçº¿æ€§æ€§ã€‚

## 4. ç®—æ³•å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::HashMap;
use std::fmt;

/// çº¿æ€§å‡½æ•°ç±»å‹
#[derive(Debug, Clone, PartialEq)]
pub struct LinearFunction<A, B> {
    func: Box<dyn Fn(A) -> B>,
    used: bool,
}

/// çº¿æ€§å‡½æ•°æ„é€ å™¨
pub struct LinearFunctionBuilder;

impl<A, B> LinearFunction<A, B> {
    /// åˆ›å»ºçº¿æ€§å‡½æ•°
    pub fn new<F>(f: F) -> Self 
    where 
        F: Fn(A) -> B + 'static
    {
        Self {
            func: Box::new(f),
            used: false,
        }
    }
    
    /// åº”ç”¨çº¿æ€§å‡½æ•°
    pub fn apply(mut self, arg: A) -> Result<B, String> {
        if self.used {
            return Err("Linear function already used".to_string());
        }
        
        self.used = true;
        Ok((self.func)(arg))
    }
    
    /// æ£€æŸ¥æ˜¯å¦å·²ä½¿ç”¨
    pub fn is_used(&self) -> bool {
        self.used
    }
    
    /// ç»„åˆçº¿æ€§å‡½æ•°
    pub fn compose<C>(self, other: LinearFunction<B, C>) -> LinearFunction<A, C> {
        LinearFunction::new(move |x| {
            let result = self.func(x);
            other.func(result)
        })
    }
    
    /// åˆ›å»ºèº«ä»½å‡½æ•°
    pub fn identity() -> LinearFunction<A, A> {
        LinearFunction::new(|x| x)
    }
    
    /// åˆ›å»ºå¸¸é‡å‡½æ•°
    pub fn constant(value: B) -> LinearFunction<A, B> 
    where 
        B: Clone + 'static
    {
        LinearFunction::new(move |_| value.clone())
    }
}

/// çº¿æ€§å‡½æ•°ç±»å‹ç³»ç»Ÿ
#[derive(Debug, Clone, PartialEq)]
pub enum LinearType {
    Unit,
    Bool,
    Int,
    Float,
    String,
    LinearFunction(Box<LinearType>, Box<LinearType>),
    Tensor(Box<LinearType>, Box<LinearType>),
    Sum(Box<LinearType>, Box<LinearType>),
}

/// çº¿æ€§è¡¨è¾¾å¼
#[derive(Debug, Clone)]
pub enum LinearExpr {
    Unit,
    Bool(bool),
    Int(i64),
    Float(f64),
    String(String),
    Variable(String),
    LinearLambda(String, Box<LinearExpr>),
    LinearApplication(Box<LinearExpr>, Box<LinearExpr>),
    LinearComposition(Box<LinearExpr>, Box<LinearExpr>),
    LinearIdentity,
    LinearConstant(Box<LinearExpr>),
    LinearDrop(Box<LinearExpr>),
    LinearCopy(Box<LinearExpr>),
}

/// çº¿æ€§ç±»å‹æ£€æŸ¥å™¨
#[derive(Debug)]
pub struct LinearTypeChecker;

impl LinearTypeChecker {
    /// ç±»å‹æ£€æŸ¥
    pub fn type_check(context: &mut LinearContext, expr: &LinearExpr) -> Result<LinearType, String> {
        match expr {
            LinearExpr::Unit => Ok(LinearType::Unit),
            
            LinearExpr::Bool(_) => Ok(LinearType::Bool),
            
            LinearExpr::Int(_) => Ok(LinearType::Int),
            
            LinearExpr::Float(_) => Ok(LinearType::Float),
            
            LinearExpr::String(_) => Ok(LinearType::String),
            
            LinearExpr::Variable(name) => {
                if let Some(ty) = context.get_type(name) {
                    if !context.is_used(name) {
                        context.mark_used(name);
                        Ok(ty.clone())
                    } else {
                        Err(format!("Variable '{}' already used", name))
                    }
                } else {
                    Err(format!("Undefined variable '{}'", name))
                }
            }
            
            LinearExpr::LinearLambda(param, body) => {
                let param_ty = LinearType::Unit; // ç®€åŒ–ï¼Œå®é™…éœ€è¦æ¨æ–­
                let mut new_context = context.clone();
                new_context.add_binding(param.clone(), param_ty.clone());
                
                let body_ty = Self::type_check(&mut new_context, body)?;
                Ok(LinearType::LinearFunction(Box::new(param_ty), Box::new(body_ty)))
            }
            
            LinearExpr::LinearApplication(func, arg) => {
                let func_ty = Self::type_check(context, func)?;
                let arg_ty = Self::type_check(context, arg)?;
                
                match func_ty {
                    LinearType::LinearFunction(input_ty, output_ty) => {
                        if *input_ty == arg_ty {
                            Ok(*output_ty)
                        } else {
                            Err(format!("Type mismatch: expected {:?}, got {:?}", input_ty, arg_ty))
                        }
                    }
                    _ => Err("Expected linear function type".to_string()),
                }
            }
            
            LinearExpr::LinearComposition(first, second) => {
                let first_ty = Self::type_check(context, first)?;
                let second_ty = Self::type_check(context, second)?;
                
                match (first_ty, second_ty) {
                    (LinearType::LinearFunction(a, b), LinearType::LinearFunction(c, d)) => {
                        if b == c {
                            Ok(LinearType::LinearFunction(a, d))
                        } else {
                            Err("Cannot compose functions with mismatched types".to_string())
                        }
                    }
                    _ => Err("Expected linear function types for composition".to_string()),
                }
            }
            
            LinearExpr::LinearIdentity => {
                Ok(LinearType::LinearFunction(
                    Box::new(LinearType::Unit),
                    Box::new(LinearType::Unit)
                ))
            }
            
            LinearExpr::LinearConstant(value) => {
                let value_ty = Self::type_check(context, value)?;
                Ok(LinearType::LinearFunction(
                    Box::new(LinearType::Unit),
                    Box::new(value_ty)
                ))
            }
            
            LinearExpr::LinearDrop(expr) => {
                let _expr_ty = Self::type_check(context, expr)?;
                Ok(LinearType::Unit)
            }
            
            LinearExpr::LinearCopy(expr) => {
                let expr_ty = Self::type_check(context, expr)?;
                match expr_ty {
                    LinearType::Bool | LinearType::Int | LinearType::Float => {
                        Ok(LinearType::Tensor(Box::new(expr_ty.clone()), Box::new(expr_ty)))
                    }
                    _ => Err("Cannot copy non-copyable type".to_string()),
                }
            }
        }
    }
}

/// çº¿æ€§å‡½æ•°ç¤ºä¾‹
pub struct LinearFunctionExamples;

impl LinearFunctionExamples {
    /// èº«ä»½å‡½æ•°
    pub fn identity_function() -> LinearExpr {
        LinearExpr::LinearIdentity
    }
    
    /// å¸¸é‡å‡½æ•°
    pub fn constant_function(value: i64) -> LinearExpr {
        LinearExpr::LinearConstant(Box::new(LinearExpr::Int(value)))
    }
    
    /// åŠ æ³•å‡½æ•°
    pub fn add_function() -> LinearExpr {
        LinearExpr::LinearLambda(
            "x".to_string(),
            Box::new(LinearExpr::LinearLambda(
                "y".to_string(),
                Box::new(LinearExpr::LinearApplication(
                    Box::new(LinearExpr::Variable("x".to_string())),
                    Box::new(LinearExpr::Variable("y".to_string()))
                ))
            ))
        )
    }
    
    /// ä¹˜æ³•å‡½æ•°
    pub fn multiply_function() -> LinearExpr {
        LinearExpr::LinearLambda(
            "x".to_string(),
            Box::new(LinearExpr::LinearLambda(
                "y".to_string(),
                Box::new(LinearExpr::LinearApplication(
                    Box::new(LinearExpr::Variable("x".to_string())),
                    Box::new(LinearExpr::Variable("y".to_string()))
                ))
            ))
        )
    }
    
    /// ç»„åˆå‡½æ•°
    pub fn compose_functions() -> LinearExpr {
        LinearExpr::LinearComposition(
            Box::new(LinearExpr::LinearIdentity),
            Box::new(LinearExpr::LinearIdentity)
        )
    }
}

/// çº¿æ€§å‡½æ•°ä¼˜åŒ–å™¨
pub struct LinearFunctionOptimizer;

impl LinearFunctionOptimizer {
    /// ä¼˜åŒ–çº¿æ€§å‡½æ•°
    pub fn optimize(expr: &LinearExpr) -> LinearExpr {
        match expr {
            LinearExpr::LinearComposition(first, second) => {
                let optimized_first = Self::optimize(first);
                let optimized_second = Self::optimize(second);
                
                // ä¼˜åŒ–ç»„åˆ
                match (&optimized_first, &optimized_second) {
                    (LinearExpr::LinearIdentity, _) => optimized_second,
                    (_, LinearExpr::LinearIdentity) => optimized_first,
                    _ => LinearExpr::LinearComposition(
                        Box::new(optimized_first),
                        Box::new(optimized_second)
                    ),
                }
            }
            
            LinearExpr::LinearApplication(func, arg) => {
                let optimized_func = Self::optimize(func);
                let optimized_arg = Self::optimize(arg);
                
                LinearExpr::LinearApplication(
                    Box::new(optimized_func),
                    Box::new(optimized_arg)
                )
            }
            
            LinearExpr::LinearLambda(param, body) => {
                LinearExpr::LinearLambda(
                    param.clone(),
                    Box::new(Self::optimize(body))
                )
            }
            
            _ => expr.clone(),
        }
    }
    
    /// æ£€æŸ¥çº¿æ€§æ€§
    pub fn check_linearity(expr: &LinearExpr) -> Result<(), String> {
        let mut used_vars = HashSet::new();
        Self::collect_used_variables(expr, &mut used_vars);
        
        // æ£€æŸ¥æ¯ä¸ªå˜é‡æ˜¯å¦æ°å¥½ä½¿ç”¨ä¸€æ¬¡
        for (var, count) in used_vars {
            if count != 1 {
                return Err(format!("Variable '{}' used {} times, expected 1", var, count));
            }
        }
        
        Ok(())
    }
    
    /// æ”¶é›†ä½¿ç”¨çš„å˜é‡
    fn collect_used_variables(expr: &LinearExpr, used: &mut HashMap<String, usize>) {
        match expr {
            LinearExpr::Variable(name) => {
                *used.entry(name.clone()).or_insert(0) += 1;
            }
            LinearExpr::LinearLambda(_, body) => {
                Self::collect_used_variables(body, used);
            }
            LinearExpr::LinearApplication(func, arg) => {
                Self::collect_used_variables(func, used);
                Self::collect_used_variables(arg, used);
            }
            LinearExpr::LinearComposition(first, second) => {
                Self::collect_used_variables(first, used);
                Self::collect_used_variables(second, used);
            }
            LinearExpr::LinearDrop(expr) | LinearExpr::LinearCopy(expr) => {
                Self::collect_used_variables(expr, used);
            }
            _ => {}
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_linear_function_creation() {
        let linear_func = LinearFunction::new(|x: i32| x + 1);
        assert!(!linear_func.is_used());
    }
    
    #[test]
    fn test_linear_function_application() {
        let linear_func = LinearFunction::new(|x: i32| x + 1);
        let result = linear_func.apply(5);
        assert_eq!(result, Ok(6));
    }
    
    #[test]
    fn test_linear_function_reuse_error() {
        let linear_func = LinearFunction::new(|x: i32| x + 1);
        let _ = linear_func.apply(5);
        // å†æ¬¡ä½¿ç”¨åº”è¯¥å¤±è´¥
        // let result = linear_func.apply(10); // è¿™è¡Œä¼šç¼–è¯‘é”™è¯¯
    }
    
    #[test]
    fn test_linear_function_composition() {
        let f = LinearFunction::new(|x: i32| x + 1);
        let g = LinearFunction::new(|x: i32| x * 2);
        let composed = f.compose(g);
        
        let result = composed.apply(5);
        assert_eq!(result, Ok(12));
    }
    
    #[test]
    fn test_identity_function() {
        let identity = LinearFunction::<i32, i32>::identity();
        let result = identity.apply(42);
        assert_eq!(result, Ok(42));
    }
    
    #[test]
    fn test_constant_function() {
        let constant = LinearFunction::<i32, i32>::constant(42);
        let result = constant.apply(100);
        assert_eq!(result, Ok(42));
    }
    
    #[test]
    fn test_type_checking() {
        let mut context = LinearContext::new();
        let expr = LinearFunctionExamples::identity_function();
        let result = LinearTypeChecker::type_check(&mut context, &expr);
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_linearity_checking() {
        let expr = LinearFunctionExamples::identity_function();
        let result = LinearFunctionOptimizer::check_linearity(&expr);
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_function_optimization() {
        let expr = LinearFunctionExamples::compose_functions();
        let optimized = LinearFunctionOptimizer::optimize(&expr);
        assert_eq!(optimized, LinearExpr::LinearIdentity);
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å†…å­˜å®‰å…¨

- é˜²æ­¢å†…å­˜æ³„æ¼
- é˜²æ­¢æ‚¬ç©ºæŒ‡é’ˆ
- è‡ªåŠ¨èµ„æºç®¡ç†

### 5.2 å¹¶å‘ç¼–ç¨‹

- æ— é”æ•°æ®ç»“æ„
- çº¿ç¨‹å®‰å…¨ä¿è¯
- æ•°æ®ç«äº‰é¢„é˜²

### 5.3 ç³»ç»Ÿç¼–ç¨‹

- æ“ä½œç³»ç»Ÿå†…æ ¸
- è®¾å¤‡é©±åŠ¨ç¨‹åº
- åµŒå…¥å¼ç³»ç»Ÿ

## 6. ç›¸å…³ç†è®º

### 6.1 çº¿æ€§ç±»å‹ç†è®º

- [04.2.1 çº¿æ€§ç±»å‹åŸºç¡€](04.2.1_Linear_Type_Basics.md)

### 6.2 çº¿æ€§é€»è¾‘

- [01.4.1 é€»è¾‘åŸºç¡€](../../01_Philosophical_Foundation/01.4_Logic_Foundation/01.4.1_Logic_Basics.md)

### 6.3 èµ„æºç®¡ç†

- [08.5 å†…å­˜ç®¡ç†](../README.md)

## 7. å‚è€ƒæ–‡çŒ®

1. Girard, J. Y. (1987). *Linear Logic*. Theoretical Computer Science.

2. Wadler, P. (1993). *A Taste of Linear Logic*. Mathematical Foundations of Computer Science.

3. Abramsky, S. (1993). *Computational Interpretations of Linear Logic*. Theoretical Computer Science.

4. Bierman, G. M., & de Paiva, V. (2000). *On an Intuitionistic Modal Logic*. Studia Logica.

5. Pfenning, F., & Davies, R. (2001). *A Judgmental Reconstruction of Modal Logic*. Mathematical Structures in Computer Science.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [ä¸Šä¸€çº§ï¼š04.2 çº¿æ€§ç±»å‹ç†è®º](../README.md)
- [ä¸‹ä¸€çº§ï¼š04.2.3 çº¿æ€§æ•°æ®ç»“æ„](./04.2.3_Linear_Data_Structures.md)
- [ä¸»ç´¢å¼•ï¼šå½¢å¼ç§‘å­¦ç†è®ºä½“ç³»](../README.md)


## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
