# 04.2.1 çº¿æ€§ç±»å‹ç†è®ºåŸºç¡€

## ğŸ“‹ æ¦‚è¿°

çº¿æ€§ç±»å‹ç†è®ºæ˜¯èµ„æºæ•æ„Ÿçš„ç±»å‹ç³»ç»Ÿï¼Œç¡®ä¿æ¯ä¸ªå€¼æ°å¥½ä½¿ç”¨ä¸€æ¬¡ã€‚æœ¬ç†è®ºä¸ºå†…å­˜å®‰å…¨ã€å¹¶å‘ç¼–ç¨‹å’Œèµ„æºç®¡ç†æä¾›å½¢å¼åŒ–åŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹çº¿æ€§ç±»å‹çš„ä¸¥æ ¼æ•°å­¦å®šä¹‰
2. è¯æ˜çº¿æ€§ç±»å‹ç³»ç»Ÿçš„æ€§è´¨
3. æä¾›é«˜æ•ˆçš„ç±»å‹æ£€æŸ¥ç®—æ³•
4. å±•ç¤ºåœ¨ç³»ç»Ÿç¼–ç¨‹ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ç®—æ³•å®ç°](#4-ç®—æ³•å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 çº¿æ€§ç±»å‹

**å®šä¹‰ 1.1.1** (çº¿æ€§ç±»å‹)
çº¿æ€§ç±»å‹ $A \multimap B$ è¡¨ç¤ºä»ç±»å‹ $A$ åˆ°ç±»å‹ $B$ çš„çº¿æ€§å‡½æ•°ï¼Œè¦æ±‚å‚æ•°æ°å¥½ä½¿ç”¨ä¸€æ¬¡ã€‚

### 1.2 çº¿æ€§é€»è¾‘

**å®šä¹‰ 1.1.2** (çº¿æ€§é€»è¾‘)
çº¿æ€§é€»è¾‘æ˜¯ç»å…¸é€»è¾‘çš„å˜ä½“ï¼Œå…¶ä¸­æ¯ä¸ªå‡è®¾å¿…é¡»æ°å¥½ä½¿ç”¨ä¸€æ¬¡ã€‚

### 1.3 èµ„æºç®¡ç†

**å®šä¹‰ 1.1.3** (èµ„æº)
èµ„æºæ˜¯å…·æœ‰å”¯ä¸€æ‰€æœ‰æƒçš„å€¼ï¼Œä¸èƒ½è¢«å¤åˆ¶æˆ–å…±äº«ã€‚

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 çº¿æ€§ç±»å‹ç³»ç»Ÿ

**å®šä¹‰ 2.1.1** (çº¿æ€§ç±»å‹ç³»ç»Ÿ)
çº¿æ€§ç±»å‹ç³»ç»Ÿ $\mathcal{L}$ åŒ…å«ä»¥ä¸‹ç±»å‹æ„é€ ï¼š

- åŸå­ç±»å‹ï¼š$A, B, C, \ldots$
- çº¿æ€§å‡½æ•°ç±»å‹ï¼š$A \multimap B$
- å¼ é‡ç§¯ï¼š$A \otimes B$
- çº¿æ€§å’Œï¼š$A \oplus B$
- å•ä½ç±»å‹ï¼š$\mathbf{1}$

### 2.2 ç±»å‹æ¨å¯¼è§„åˆ™

**å®šä¹‰ 2.1.2** (çº¿æ€§å‡½æ•°å¼•å…¥)
$$\frac{\Gamma, x:A \vdash M:B}{\Gamma \vdash \lambda x.M : A \multimap B}$$

**å®šä¹‰ 2.1.3** (çº¿æ€§å‡½æ•°æ¶ˆé™¤)
$$\frac{\Gamma \vdash M:A \multimap B \quad \Delta \vdash N:A}{\Gamma, \Delta \vdash M N : B}$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 çº¿æ€§æ€§ä¿æŒ

**å®šç† 3.1.1** (çº¿æ€§æ€§ä¿æŒ)
å¦‚æœ $\Gamma \vdash M:A$ ä¸” $M$ æ˜¯çº¿æ€§é¡¹ï¼Œåˆ™ $M$ ä¸­æ¯ä¸ªå˜é‡æ°å¥½å‡ºç°ä¸€æ¬¡ã€‚

**è¯æ˜**ï¼š
ä½¿ç”¨ç»“æ„å½’çº³æ³•è¯æ˜ã€‚

### 3.2 ç±»å‹å®‰å…¨

**å®šç† 3.2.1** (ç±»å‹å®‰å…¨)
å¦‚æœ $\Gamma \vdash M:A$ï¼Œåˆ™ $M$ ä¸ä¼šäº§ç”Ÿè¿è¡Œæ—¶é”™è¯¯ã€‚

**è¯æ˜**ï¼š
ä½¿ç”¨è¿›å±•å’Œä¿æŒæ€§è´¨è¯æ˜ã€‚

## 4. ç®—æ³•å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::HashMap;
use std::fmt;

/// çº¿æ€§ç±»å‹
#[derive(Debug, Clone, PartialEq)]
pub enum LinearType {
    Unit,
    Bool,
    Int,
    Float,
    String,
    LinearFunction(Box<LinearType>, Box<LinearType>),
    Tensor(Box<LinearType>, Box<LinearType>),
    Sum(Box<LinearType>, Box<LinearType>),
    Reference(Box<LinearType>),
}

/// çº¿æ€§è¡¨è¾¾å¼
#[derive(Debug, Clone)]
pub enum LinearExpr {
    Unit,
    Bool(bool),
    Int(i64),
    Float(f64),
    String(String),
    Variable(String),
    Lambda(String, Box<LinearExpr>),
    Application(Box<LinearExpr>, Box<LinearExpr>),
    Pair(Box<LinearExpr>, Box<LinearExpr>),
    First(Box<LinearExpr>),
    Second(Box<LinearExpr>),
    Left(Box<LinearExpr>),
    Right(Box<LinearExpr>),
    Case(Box<LinearExpr>, String, Box<LinearExpr>, String, Box<LinearExpr>),
    Let(String, Box<LinearExpr>, Box<LinearExpr>),
    Drop(Box<LinearExpr>),
    Copy(Box<LinearExpr>),
}

/// çº¿æ€§ç±»å‹ç¯å¢ƒ
#[derive(Debug, Clone)]
pub struct LinearContext {
    bindings: HashMap<String, LinearType>,
    used: HashSet<String>,
}

/// çº¿æ€§ç±»å‹æ£€æŸ¥å™¨
#[derive(Debug)]
pub struct LinearTypeChecker;

impl LinearContext {
    /// åˆ›å»ºæ–°çš„ç±»å‹ç¯å¢ƒ
    pub fn new() -> Self {
        Self {
            bindings: HashMap::new(),
            used: HashSet::new(),
        }
    }
    
    /// æ·»åŠ ç»‘å®š
    pub fn add_binding(&mut self, name: String, ty: LinearType) {
        self.bindings.insert(name, ty);
    }
    
    /// è·å–ç±»å‹
    pub fn get_type(&self, name: &str) -> Option<&LinearType> {
        self.bindings.get(name)
    }
    
    /// æ ‡è®°å˜é‡ä¸ºå·²ä½¿ç”¨
    pub fn mark_used(&mut self, name: &str) -> bool {
        self.used.insert(name.to_string())
    }
    
    /// æ£€æŸ¥å˜é‡æ˜¯å¦å·²ä½¿ç”¨
    pub fn is_used(&self, name: &str) -> bool {
        self.used.contains(name)
    }
    
    /// åˆå¹¶ç¯å¢ƒ
    pub fn merge(&self, other: &Self) -> Result<Self, String> {
        let mut merged = Self::new();
        
        // æ£€æŸ¥å†²çª
        for (name, ty1) in &self.bindings {
            if let Some(ty2) = other.bindings.get(name) {
                if ty1 != ty2 {
                    return Err(format!("Type conflict for variable '{}'", name));
                }
            }
        }
        
        // åˆå¹¶ç»‘å®š
        merged.bindings.extend(self.bindings.clone());
        merged.bindings.extend(other.bindings.clone());
        
        // åˆå¹¶ä½¿ç”¨æ ‡è®°
        merged.used.extend(self.used.clone());
        merged.used.extend(other.used.clone());
        
        Ok(merged)
    }
    
    /// ç§»é™¤ç»‘å®š
    pub fn remove_binding(&mut self, name: &str) -> Option<LinearType> {
        self.bindings.remove(name)
    }
}

impl LinearTypeChecker {
    /// ç±»å‹æ£€æŸ¥
    pub fn type_check(context: &mut LinearContext, expr: &LinearExpr) -> Result<LinearType, String> {
        match expr {
            LinearExpr::Unit => Ok(LinearType::Unit),
            
            LinearExpr::Bool(_) => Ok(LinearType::Bool),
            
            LinearExpr::Int(_) => Ok(LinearType::Int),
            
            LinearExpr::Float(_) => Ok(LinearType::Float),
            
            LinearExpr::String(_) => Ok(LinearType::String),
            
            LinearExpr::Variable(name) => {
                if let Some(ty) = context.get_type(name) {
                    if !context.is_used(name) {
                        context.mark_used(name);
                        Ok(ty.clone())
                    } else {
                        Err(format!("Variable '{}' already used", name))
                    }
                } else {
                    Err(format!("Undefined variable '{}'", name))
                }
            }
            
            LinearExpr::Lambda(param, body) => {
                let param_ty = LinearType::Unit; // ç®€åŒ–ï¼Œå®é™…éœ€è¦æ¨æ–­
                let mut new_context = context.clone();
                new_context.add_binding(param.clone(), param_ty.clone());
                
                let body_ty = Self::type_check(&mut new_context, body)?;
                Ok(LinearType::LinearFunction(Box::new(param_ty), Box::new(body_ty)))
            }
            
            LinearExpr::Application(func, arg) => {
                let func_ty = Self::type_check(context, func)?;
                let arg_ty = Self::type_check(context, arg)?;
                
                match func_ty {
                    LinearType::LinearFunction(input_ty, output_ty) => {
                        if *input_ty == arg_ty {
                            Ok(*output_ty)
                        } else {
                            Err(format!("Type mismatch: expected {:?}, got {:?}", input_ty, arg_ty))
                        }
                    }
                    _ => Err("Expected linear function type".to_string()),
                }
            }
            
            LinearExpr::Pair(first, second) => {
                let first_ty = Self::type_check(context, first)?;
                let second_ty = Self::type_check(context, second)?;
                Ok(LinearType::Tensor(Box::new(first_ty), Box::new(second_ty)))
            }
            
            LinearExpr::First(pair) => {
                let pair_ty = Self::type_check(context, pair)?;
                match pair_ty {
                    LinearType::Tensor(first_ty, _) => Ok(*first_ty),
                    _ => Err("Expected tensor type".to_string()),
                }
            }
            
            LinearExpr::Second(pair) => {
                let pair_ty = Self::type_check(context, pair)?;
                match pair_ty {
                    LinearType::Tensor(_, second_ty) => Ok(*second_ty),
                    _ => Err("Expected tensor type".to_string()),
                }
            }
            
            LinearExpr::Left(expr) => {
                let expr_ty = Self::type_check(context, expr)?;
                Ok(LinearType::Sum(Box::new(expr_ty), Box::new(LinearType::Unit)))
            }
            
            LinearExpr::Right(expr) => {
                let expr_ty = Self::type_check(context, expr)?;
                Ok(LinearType::Sum(Box::new(LinearType::Unit), Box::new(expr_ty)))
            }
            
            LinearExpr::Case(expr, left_var, left_body, right_var, right_body) => {
                let expr_ty = Self::type_check(context, expr)?;
                
                match expr_ty {
                    LinearType::Sum(left_ty, right_ty) => {
                        // æ£€æŸ¥å·¦åˆ†æ”¯
                        let mut left_context = context.clone();
                        left_context.add_binding(left_var.clone(), *left_ty);
                        let left_result = Self::type_check(&mut left_context, left_body)?;
                        
                        // æ£€æŸ¥å³åˆ†æ”¯
                        let mut right_context = context.clone();
                        right_context.add_binding(right_var.clone(), *right_ty);
                        let right_result = Self::type_check(&mut right_context, right_body)?;
                        
                        if left_result == right_result {
                            Ok(left_result)
                        } else {
                            Err("Case branches must have same type".to_string())
                        }
                    }
                    _ => Err("Expected sum type".to_string()),
                }
            }
            
            LinearExpr::Let(name, value, body) => {
                let value_ty = Self::type_check(context, value)?;
                let mut new_context = context.clone();
                new_context.add_binding(name.clone(), value_ty);
                Self::type_check(&mut new_context, body)
            }
            
            LinearExpr::Drop(expr) => {
                let _expr_ty = Self::type_check(context, expr)?;
                Ok(LinearType::Unit)
            }
            
            LinearExpr::Copy(expr) => {
                let expr_ty = Self::type_check(context, expr)?;
                // åªæœ‰å¯å¤åˆ¶ç±»å‹æ‰èƒ½è¢«å¤åˆ¶
                match expr_ty {
                    LinearType::Bool | LinearType::Int | LinearType::Float => {
                        Ok(LinearType::Tensor(Box::new(expr_ty.clone()), Box::new(expr_ty)))
                    }
                    _ => Err("Cannot copy non-copyable type".to_string()),
                }
            }
        }
    }
    
    /// æ£€æŸ¥çº¿æ€§æ€§
    pub fn check_linearity(context: &LinearContext, expr: &LinearExpr) -> Result<(), String> {
        let mut used_vars = HashSet::new();
        Self::collect_used_variables(expr, &mut used_vars);
        
        for (name, _) in &context.bindings {
            if !used_vars.contains(name) {
                return Err(format!("Unused variable '{}'", name));
            }
        }
        
        Ok(())
    }
    
    /// æ”¶é›†ä½¿ç”¨çš„å˜é‡
    fn collect_used_variables(expr: &LinearExpr, used: &mut HashSet<String>) {
        match expr {
            LinearExpr::Variable(name) => {
                used.insert(name.clone());
            }
            LinearExpr::Lambda(_, body) => {
                Self::collect_used_variables(body, used);
            }
            LinearExpr::Application(func, arg) => {
                Self::collect_used_variables(func, used);
                Self::collect_used_variables(arg, used);
            }
            LinearExpr::Pair(first, second) => {
                Self::collect_used_variables(first, used);
                Self::collect_used_variables(second, used);
            }
            LinearExpr::First(pair) | LinearExpr::Second(pair) => {
                Self::collect_used_variables(pair, used);
            }
            LinearExpr::Left(expr) | LinearExpr::Right(expr) => {
                Self::collect_used_variables(expr, used);
            }
            LinearExpr::Case(expr, _, left_body, _, right_body) => {
                Self::collect_used_variables(expr, used);
                Self::collect_used_variables(left_body, used);
                Self::collect_used_variables(right_body, used);
            }
            LinearExpr::Let(_, value, body) => {
                Self::collect_used_variables(value, used);
                Self::collect_used_variables(body, used);
            }
            LinearExpr::Drop(expr) | LinearExpr::Copy(expr) => {
                Self::collect_used_variables(expr, used);
            }
            _ => {}
        }
    }
}

/// çº¿æ€§ç±»å‹ç¤ºä¾‹
pub struct LinearTypeExamples;

impl LinearTypeExamples {
    /// èº«ä»½å‡½æ•°
    pub fn identity_function() -> LinearExpr {
        LinearExpr::Lambda("x".to_string(), Box::new(LinearExpr::Variable("x".to_string())))
    }
    
    /// äº¤æ¢å‡½æ•°
    pub fn swap_function() -> LinearExpr {
        LinearExpr::Lambda(
            "pair".to_string(),
            Box::new(LinearExpr::Pair(
                Box::new(LinearExpr::Second(Box::new(LinearExpr::Variable("pair".to_string())))),
                Box::new(LinearExpr::First(Box::new(LinearExpr::Variable("pair".to_string()))))
            ))
        )
    }
    
    /// å¤åˆ¶å‡½æ•°
    pub fn copy_function() -> LinearExpr {
        LinearExpr::Lambda(
            "x".to_string(),
            Box::new(LinearExpr::Copy(Box::new(LinearExpr::Variable("x".to_string()))))
        )
    }
    
    /// ä¸¢å¼ƒå‡½æ•°
    pub fn drop_function() -> LinearExpr {
        LinearExpr::Lambda(
            "x".to_string(),
            Box::new(LinearExpr::Drop(Box::new(LinearExpr::Variable("x".to_string()))))
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_unit_type() {
        let mut context = LinearContext::new();
        let expr = LinearExpr::Unit;
        let result = LinearTypeChecker::type_check(&mut context, &expr);
        assert_eq!(result, Ok(LinearType::Unit));
    }
    
    #[test]
    fn test_identity_function() {
        let mut context = LinearContext::new();
        let expr = LinearTypeExamples::identity_function();
        let result = LinearTypeChecker::type_check(&mut context, &expr);
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_swap_function() {
        let mut context = LinearContext::new();
        let expr = LinearTypeExamples::swap_function();
        let result = LinearTypeChecker::type_check(&mut context, &expr);
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_copy_function() {
        let mut context = LinearContext::new();
        let expr = LinearTypeExamples::copy_function();
        let result = LinearTypeChecker::type_check(&mut context, &expr);
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_drop_function() {
        let mut context = LinearContext::new();
        let expr = LinearTypeExamples::drop_function();
        let result = LinearTypeChecker::type_check(&mut context, &expr);
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_variable_usage() {
        let mut context = LinearContext::new();
        context.add_binding("x".to_string(), LinearType::Int);
        
        let expr = LinearExpr::Variable("x".to_string());
        let result = LinearTypeChecker::type_check(&mut context, &expr);
        assert_eq!(result, Ok(LinearType::Int));
        
        // å†æ¬¡ä½¿ç”¨åº”è¯¥å¤±è´¥
        let result2 = LinearTypeChecker::type_check(&mut context, &expr);
        assert!(result2.is_err());
    }
    
    #[test]
    fn test_application() {
        let mut context = LinearContext::new();
        
        let func = LinearExpr::Lambda(
            "x".to_string(),
            Box::new(LinearExpr::Variable("x".to_string()))
        );
        let arg = LinearExpr::Int(42);
        let app = LinearExpr::Application(Box::new(func), Box::new(arg));
        
        let result = LinearTypeChecker::type_check(&mut context, &app);
        assert!(result.is_ok());
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å†…å­˜å®‰å…¨

- é˜²æ­¢å†…å­˜æ³„æ¼
- é˜²æ­¢æ‚¬ç©ºæŒ‡é’ˆ
- è‡ªåŠ¨èµ„æºç®¡ç†

### 5.2 å¹¶å‘ç¼–ç¨‹

- æ— é”æ•°æ®ç»“æ„
- çº¿ç¨‹å®‰å…¨ä¿è¯
- æ•°æ®ç«äº‰é¢„é˜²

### 5.3 ç³»ç»Ÿç¼–ç¨‹

- æ“ä½œç³»ç»Ÿå†…æ ¸
- è®¾å¤‡é©±åŠ¨ç¨‹åº
- åµŒå…¥å¼ç³»ç»Ÿ

## 6. ç›¸å…³ç†è®º

### 6.1 ç±»å‹ç†è®º

- [04.1.1 ç®€å•ç±»å‹Î»æ¼”ç®—](../04.1_Simple_Type_Theory/04.1.1_Simply_Typed_Lambda_Calculus.md)

### 6.2 çº¿æ€§é€»è¾‘

- [01.4.1 é€»è¾‘åŸºç¡€](../../01_Philosophical_Foundation/01.4_Logic_Foundation/01.4.1_Logic_Basics.md)

### 6.3 èµ„æºç®¡ç†

- [08.5 å†…å­˜ç®¡ç†](../../08_Programming_Language_Theory/08.5_Memory_Management/README.md)

## 7. å‚è€ƒæ–‡çŒ®

1. Girard, J. Y. (1987). *Linear Logic*. Theoretical Computer Science.

2. Wadler, P. (1993). *A Taste of Linear Logic*. Mathematical Foundations of Computer Science.

3. Abramsky, S. (1993). *Computational Interpretations of Linear Logic*. Theoretical Computer Science.

4. Bierman, G. M., & de Paiva, V. (2000). *On an Intuitionistic Modal Logic*. Studia Logica.

5. Pfenning, F., & Davies, R. (2001). *A Judgmental Reconstruction of Modal Logic*. Mathematical Structures in Computer Science.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [ä¸Šä¸€çº§ï¼š04.2 çº¿æ€§ç±»å‹ç†è®º](../README.md)
- [ä¸‹ä¸€çº§ï¼š04.2.2 çº¿æ€§å‡½æ•°ç±»å‹](./04.2.2_Linear_Function_Types.md)
- [ä¸»ç´¢å¼•ï¼šå½¢å¼ç§‘å­¦ç†è®ºä½“ç³»](../../00_Master_Index/README.md)
