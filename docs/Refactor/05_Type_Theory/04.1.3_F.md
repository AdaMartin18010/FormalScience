# 04.1.3 ç³»ç»ŸF

## ğŸ“‹ æ¦‚è¿°

ç³»ç»ŸFï¼ˆSystem Fï¼‰æ˜¯Jean-Yves Girardæå‡ºçš„äºŒé˜¶å¤šæ€Î»æ¼”ç®—ï¼Œä¹Ÿç§°ä¸ºå¤šæ€Î»æ¼”ç®—ã€‚å®ƒæ‰©å±•äº†ç®€å•ç±»å‹Î»æ¼”ç®—ï¼Œå¼•å…¥äº†ç±»å‹æŠ½è±¡å’Œç±»å‹åº”ç”¨ï¼Œæ˜¯ç°ä»£å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»Ÿçš„åŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹ä¸¥æ ¼çš„ç³»ç»ŸFæ¦‚å¿µå’Œå½¢å¼åŒ–å®šä¹‰
2. è¯æ˜ç³»ç»ŸFçš„åŸºæœ¬å®šç†
3. æä¾›å®Œæ•´çš„ä»£ç å®ç°
4. å±•ç¤ºç³»ç»ŸFåœ¨å½¢å¼ç§‘å­¦ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç³»ç»ŸFçš„åŠ¨æœº

**å®šä¹‰ 1.1.1** (å¤šæ€æ€§)
å¤šæ€æ€§æ˜¯æŒ‡ä¸€ä¸ªå‡½æ•°æˆ–æ•°æ®ç»“æ„å¯ä»¥å¤„ç†å¤šç§ç±»å‹çš„æ•°æ®ï¼Œè€Œä¸éœ€è¦ä¸ºæ¯ç§ç±»å‹ç¼–å†™å•ç‹¬çš„ä»£ç ã€‚

**å®šä¹‰ 1.1.2** (ç±»å‹æŠ½è±¡)
ç±»å‹æŠ½è±¡å…è®¸å°†ç±»å‹ä½œä¸ºå‚æ•°ä¼ é€’ç»™å‡½æ•°ï¼Œå®ç°çœŸæ­£çš„å¤šæ€æ€§ã€‚

### 1.2 ç³»ç»ŸFçš„è¯­æ³•

**å®šä¹‰ 1.2.1** (ç³»ç»ŸFè¯­æ³•)
ç³»ç»ŸFçš„è¯­æ³•åŒ…æ‹¬ï¼š

- **ç±»å‹å˜é‡**ï¼š$X, Y, Z, \ldots$
- **ç±»å‹æ„é€ **ï¼š$T \to U$ï¼ˆå‡½æ•°ç±»å‹ï¼‰
- **ç±»å‹æŠ½è±¡**ï¼š$\forall X. T$ï¼ˆå…¨ç§°ç±»å‹ï¼‰
- **ç±»å‹åº”ç”¨**ï¼š$T[U]$ï¼ˆç±»å‹å®ä¾‹åŒ–ï¼‰
- **é¡¹å˜é‡**ï¼š$x, y, z, \ldots$
- **Î»æŠ½è±¡**ï¼š$\lambda x: T. t$
- **å‡½æ•°åº”ç”¨**ï¼š$t \, u$
- **ç±»å‹Î»æŠ½è±¡**ï¼š$\Lambda X. t$
- **ç±»å‹åº”ç”¨**ï¼š$t[U]$

### 1.3 ç±»å‹å’Œé¡¹çš„å±‚æ¬¡

**å®šä¹‰ 1.3.1** (ç±»å‹å±‚æ¬¡)
ç³»ç»ŸFä¸­çš„ç±»å‹åˆ†ä¸ºä¸¤ä¸ªå±‚æ¬¡ï¼š

1. **ç±»å‹**ï¼šåŸºæœ¬ç±»å‹ã€å‡½æ•°ç±»å‹ã€å…¨ç§°ç±»å‹
2. **ç§ç±»**ï¼šç±»å‹çš„ç±»å‹ï¼Œåœ¨ç³»ç»ŸFä¸­åªæœ‰ä¸€ç§ç§ç±» *

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ç±»å‹è¯­æ³•

**å®šä¹‰ 2.1.1** (ç±»å‹è¯­æ³•)
ç±»å‹ $T$ çš„è¯­æ³•å®šä¹‰ä¸ºï¼š
$$T ::= X \mid T \to U \mid \forall X. T$$

å…¶ä¸­ï¼š

- $X$ æ˜¯ç±»å‹å˜é‡
- $T \to U$ æ˜¯å‡½æ•°ç±»å‹
- $\forall X. T$ æ˜¯å…¨ç§°ç±»å‹

### 2.2 é¡¹è¯­æ³•

**å®šä¹‰ 2.2.1** (é¡¹è¯­æ³•)
é¡¹ $t$ çš„è¯­æ³•å®šä¹‰ä¸ºï¼š
$$t ::= x \mid \lambda x: T. t \mid t \, u \mid \Lambda X. t \mid t[T]$$

å…¶ä¸­ï¼š

- $x$ æ˜¯é¡¹å˜é‡
- $\lambda x: T. t$ æ˜¯Î»æŠ½è±¡
- $t \, u$ æ˜¯å‡½æ•°åº”ç”¨
- $\Lambda X. t$ æ˜¯ç±»å‹Î»æŠ½è±¡
- $t[T]$ æ˜¯ç±»å‹åº”ç”¨

### 2.3 ç±»å‹ç¯å¢ƒ

**å®šä¹‰ 2.3.1** (ç±»å‹ç¯å¢ƒ)
ç±»å‹ç¯å¢ƒ $\Gamma$ æ˜¯ç±»å‹å˜é‡çš„æœ‰é™é›†åˆï¼Œè®°ä½œï¼š
$$\Gamma = \{X_1, X_2, \ldots, X_n\}$$

**å®šä¹‰ 2.3.2** (é¡¹ç¯å¢ƒ)
é¡¹ç¯å¢ƒ $\Gamma$ æ˜¯ç±»å‹å‡è®¾çš„æœ‰é™åºåˆ—ï¼Œè®°ä½œï¼š
$$\Gamma = x_1: T_1, x_2: T_2, \ldots, x_n: T_n$$

## 3. å®šç†ä¸è¯æ˜

### 3.1 ç±»å‹æ¨å¯¼è§„åˆ™

**å®šç† 3.1.1** (ç³»ç»ŸFç±»å‹æ¨å¯¼è§„åˆ™)
ç³»ç»ŸFçš„ç±»å‹æ¨å¯¼è§„åˆ™åŒ…æ‹¬ï¼š

1. **å˜é‡è§„åˆ™**ï¼š
   $$\frac{x: T \in \Gamma}{\Gamma \vdash x: T}$$

2. **Î»æŠ½è±¡è§„åˆ™**ï¼š
   $$\frac{\Gamma, x: T \vdash t: U}{\Gamma \vdash \lambda x: T. t: T \to U}$$

3. **å‡½æ•°åº”ç”¨è§„åˆ™**ï¼š
   $$\frac{\Gamma \vdash t: T \to U \quad \Gamma \vdash u: T}{\Gamma \vdash t \, u: U}$$

4. **ç±»å‹Î»æŠ½è±¡è§„åˆ™**ï¼š
   $$\frac{\Gamma, X \vdash t: T}{\Gamma \vdash \Lambda X. t: \forall X. T}$$

5. **ç±»å‹åº”ç”¨è§„åˆ™**ï¼š
   $$\frac{\Gamma \vdash t: \forall X. T}{\Gamma \vdash t[U]: T[U/X]}$$

**è¯æ˜**ï¼š
è¿™äº›è§„åˆ™é€šè¿‡å½’çº³æ³•è¯æ˜ç±»å‹å®‰å…¨æ€§ã€‚æ¯ä¸ªè§„åˆ™éƒ½ç¡®ä¿ç±»å‹çš„ä¸€è‡´æ€§ã€‚

### 3.2 ç±»å‹æ›¿æ¢

**å®šç† 3.2.1** (ç±»å‹æ›¿æ¢)
è®¾ $\Gamma \vdash t: T$ï¼Œåˆ™å¯¹ä»»æ„ç±»å‹ $U$ å’Œç±»å‹å˜é‡ $X$ï¼š
$$\Gamma[U/X] \vdash t[U/X]: T[U/X]$$

**è¯æ˜**ï¼š
é€šè¿‡å¯¹é¡¹ $t$ çš„ç»“æ„å½’çº³è¯æ˜ï¼š

- åŸºç¡€æƒ…å†µï¼š$t = x$ï¼Œç›´æ¥åº”ç”¨å˜é‡è§„åˆ™
- å½’çº³æ­¥éª¤ï¼šå¯¹æ¯ç§é¡¹æ„é€ åº”ç”¨ç›¸åº”çš„ç±»å‹æ¨å¯¼è§„åˆ™

### 3.3 ç±»å‹ä¿æŒ

**å®šç† 3.3.1** (ç±»å‹ä¿æŒ)
å¦‚æœ $\Gamma \vdash t: T$ ä¸” $t \to t'$ï¼Œåˆ™ $\Gamma \vdash t': T$ã€‚

**è¯æ˜**ï¼š
é€šè¿‡å¯¹å½’çº¦è§„åˆ™çš„åˆ†æè¯æ˜ï¼š

1. **Î²å½’çº¦**ï¼š$(\lambda x: T. t) \, u \to t[u/x]$
2. **ç±»å‹Î²å½’çº¦**ï¼š$[\Lambda X. t](U) \to t[U/X]$

æ¯ç§å½’çº¦éƒ½ä¿æŒç±»å‹ã€‚

### 3.4 å¼ºæ­£è§„åŒ–

**å®šç† 3.4.1** (å¼ºæ­£è§„åŒ–)
ç³»ç»ŸFä¸­çš„æ¯ä¸ªè‰¯ç±»å‹é¡¹éƒ½æ˜¯å¼ºæ­£è§„åŒ–çš„ã€‚

**è¯æ˜**ï¼š
ä½¿ç”¨é€»è¾‘å…³ç³»æ–¹æ³•è¯æ˜ã€‚æ„é€ ç±»å‹ä¸Šçš„é€»è¾‘å…³ç³»ï¼Œè¯æ˜æ¯ä¸ªè‰¯ç±»å‹é¡¹éƒ½æ»¡è¶³ç›¸åº”çš„é€»è¾‘å…³ç³»ï¼Œä»è€Œä¿è¯å¼ºæ­£è§„åŒ–ã€‚

## 4. ä»£ç å®ç°

### 4.1 Rust å®ç°

```rust
use std::collections::HashMap;
use std::fmt;

/// ç³»ç»ŸFç±»å‹
#[derive(Debug, Clone, PartialEq)]
pub enum SystemFType {
    TypeVar(String),
    Function(Box<SystemFType>, Box<SystemFType>),
    ForAll(String, Box<SystemFType>),
}

impl SystemFType {
    /// ç±»å‹æ›¿æ¢
    pub fn substitute(&self, var: &str, replacement: &SystemFType) -> SystemFType {
        match self {
            SystemFType::TypeVar(name) => {
                if name == var {
                    replacement.clone()
                } else {
                    self.clone()
                }
            }
            SystemFType::Function(from, to) => {
                SystemFType::Function(
                    Box::new(from.substitute(var, replacement)),
                    Box::new(to.substitute(var, replacement))
                )
            }
            SystemFType::ForAll(param, body) => {
                if param == var {
                    self.clone()
                } else {
                    SystemFType::ForAll(
                        param.clone(),
                        Box::new(body.substitute(var, replacement))
                    )
                }
            }
        }
    }
    
    /// è‡ªç”±ç±»å‹å˜é‡
    pub fn free_type_vars(&self) -> Vec<String> {
        match self {
            SystemFType::TypeVar(name) => vec![name.clone()],
            SystemFType::Function(from, to) => {
                let mut vars = from.free_type_vars();
                vars.extend(to.free_type_vars());
                vars
            }
            SystemFType::ForAll(param, body) => {
                body.free_type_vars().into_iter()
                    .filter(|var| var != param)
                    .collect()
            }
        }
    }
}

/// ç³»ç»ŸFé¡¹
#[derive(Debug, Clone)]
pub enum SystemFTerm {
    Var(String),
    Lambda(String, SystemFType, Box<SystemFTerm>),
    App(Box<SystemFTerm>, Box<SystemFTerm>),
    TypeLambda(String, Box<SystemFTerm>),
    TypeApp(Box<SystemFTerm>, SystemFType),
}

impl SystemFTerm {
    /// é¡¹æ›¿æ¢
    pub fn substitute(&self, var: &str, replacement: &SystemFTerm) -> SystemFTerm {
        match self {
            SystemFTerm::Var(name) => {
                if name == var {
                    replacement.clone()
                } else {
                    self.clone()
                }
            }
            SystemFTerm::Lambda(param, typ, body) => {
                if param == var {
                    self.clone()
                } else {
                    SystemFTerm::Lambda(
                        param.clone(),
                        typ.clone(),
                        Box::new(body.substitute(var, replacement))
                    )
                }
            }
            SystemFTerm::App(func, arg) => {
                SystemFTerm::App(
                    Box::new(func.substitute(var, replacement)),
                    Box::new(arg.substitute(var, replacement))
                )
            }
            SystemFTerm::TypeLambda(param, body) => {
                SystemFTerm::TypeLambda(
                    param.clone(),
                    Box::new(body.substitute(var, replacement))
                )
            }
            SystemFTerm::TypeApp(term, typ) => {
                SystemFTerm::TypeApp(
                    Box::new(term.substitute(var, replacement)),
                    typ.clone()
                )
            }
        }
    }
    
    /// ç±»å‹æ›¿æ¢
    pub fn type_substitute(&self, var: &str, replacement: &SystemFType) -> SystemFTerm {
        match self {
            SystemFTerm::Var(name) => SystemFTerm::Var(name.clone()),
            SystemFTerm::Lambda(param, typ, body) => {
                SystemFTerm::Lambda(
                    param.clone(),
                    typ.substitute(var, replacement),
                    Box::new(body.type_substitute(var, replacement))
                )
            }
            SystemFTerm::App(func, arg) => {
                SystemFTerm::App(
                    Box::new(func.type_substitute(var, replacement)),
                    Box::new(arg.type_substitute(var, replacement))
                )
            }
            SystemFTerm::TypeLambda(param, body) => {
                if param == var {
                    self.clone()
                } else {
                    SystemFTerm::TypeLambda(
                        param.clone(),
                        Box::new(body.type_substitute(var, replacement))
                    )
                }
            }
            SystemFTerm::TypeApp(term, typ) => {
                SystemFTerm::TypeApp(
                    Box::new(term.type_substitute(var, replacement)),
                    typ.substitute(var, replacement)
                )
            }
        }
    }
}

/// ç±»å‹ç¯å¢ƒ
#[derive(Debug, Clone)]
pub struct TypeEnvironment {
    pub type_vars: Vec<String>,
    pub term_vars: HashMap<String, SystemFType>,
}

impl TypeEnvironment {
    pub fn new() -> Self {
        Self {
            type_vars: Vec::new(),
            term_vars: HashMap::new(),
        }
    }
    
    pub fn add_type_var(&mut self, var: String) {
        self.type_vars.push(var);
    }
    
    pub fn add_term_var(&mut self, var: String, typ: SystemFType) {
        self.term_vars.insert(var, typ);
    }
    
    pub fn get_term_type(&self, var: &str) -> Option<&SystemFType> {
        self.term_vars.get(var)
    }
    
    pub fn contains_type_var(&self, var: &str) -> bool {
        self.type_vars.contains(&var.to_string())
    }
}

/// ç³»ç»ŸFç±»å‹æ£€æŸ¥å™¨
pub struct SystemFTypeChecker;

impl SystemFTypeChecker {
    /// ç±»å‹æ£€æŸ¥
    pub fn type_check(env: &TypeEnvironment, term: &SystemFTerm) -> Result<SystemFType, String> {
        match term {
            SystemFTerm::Var(name) => {
                env.get_term_type(name)
                    .cloned()
                    .ok_or_else(|| format!("æœªå®šä¹‰çš„å˜é‡: {}", name))
            }
            
            SystemFTerm::Lambda(param, param_type, body) => {
                let mut new_env = env.clone();
                new_env.add_term_var(param.clone(), param_type.clone());
                let body_type = Self::type_check(&new_env, body)?;
                Ok(SystemFType::Function(Box::new(param_type.clone()), Box::new(body_type)))
            }
            
            SystemFTerm::App(func, arg) => {
                let func_type = Self::type_check(env, func)?;
                let arg_type = Self::type_check(env, arg)?;
                
                match func_type {
                    SystemFType::Function(from, to) => {
                        if *from == arg_type {
                            Ok(*to)
                        } else {
                            Err(format!("ç±»å‹ä¸åŒ¹é…: æœŸæœ› {}, å¾—åˆ° {}", from, arg_type))
                        }
                    }
                    _ => Err("å‡½æ•°åº”ç”¨çš„ç±»å‹é”™è¯¯".to_string()),
                }
            }
            
            SystemFTerm::TypeLambda(param, body) => {
                let mut new_env = env.clone();
                new_env.add_type_var(param.clone());
                let body_type = Self::type_check(&new_env, body)?;
                Ok(SystemFType::ForAll(param.clone(), Box::new(body_type)))
            }
            
            SystemFTerm::TypeApp(term, type_arg) => {
                let term_type = Self::type_check(env, term)?;
                
                match term_type {
                    SystemFType::ForAll(param, body) => {
                        Ok(body.substitute(&param, type_arg))
                    }
                    _ => Err("ç±»å‹åº”ç”¨çš„ç±»å‹é”™è¯¯".to_string()),
                }
            }
        }
    }
}

/// ç³»ç»ŸFæ±‚å€¼å™¨
pub struct SystemFEvaluator;

impl SystemFEvaluator {
    /// æ±‚å€¼
    pub fn evaluate(term: &SystemFTerm) -> SystemFTerm {
        match term {
            SystemFTerm::App(func, arg) => {
                let func_val = Self::evaluate(func);
                let arg_val = Self::evaluate(arg);
                
                match func_val {
                    SystemFTerm::Lambda(param, _, body) => {
                        let substituted = body.substitute(&param, &arg_val);
                        Self::evaluate(&substituted)
                    }
                    _ => SystemFTerm::App(Box::new(func_val), Box::new(arg_val)),
                }
            }
            
            SystemFTerm::TypeApp(term, type_arg) => {
                let term_val = Self::evaluate(term);
                
                match term_val {
                    SystemFTerm::TypeLambda(param, body) => {
                        let substituted = body.type_substitute(&param, type_arg);
                        Self::evaluate(&substituted)
                    }
                    _ => SystemFTerm::TypeApp(Box::new(term_val), type_arg.clone()),
                }
            }
            
            _ => term.clone(),
        }
    }
}

/// å¤šæ€å‡½æ•°ç¤ºä¾‹
pub struct PolymorphicFunctions;

impl PolymorphicFunctions {
    /// æ’ç­‰å‡½æ•°
    pub fn identity() -> SystemFTerm {
        SystemFTerm::TypeLambda(
            "X".to_string(),
            Box::new(SystemFTerm::Lambda(
                "x".to_string(),
                SystemFType::TypeVar("X".to_string()),
                Box::new(SystemFTerm::Var("x".to_string()))
            ))
        )
    }
    
    /// ç»„åˆå‡½æ•°
    pub fn compose() -> SystemFTerm {
        SystemFTerm::TypeLambda(
            "X".to_string(),
            Box::new(SystemFTerm::TypeLambda(
                "Y".to_string(),
                Box::new(SystemFTerm::TypeLambda(
                    "Z".to_string(),
                    Box::new(SystemFTerm::Lambda(
                        "f".to_string(),
                        SystemFType::Function(
                            Box::new(SystemFType::TypeVar("Y".to_string())),
                            Box::new(SystemFType::TypeVar("Z".to_string()))
                        ),
                        Box::new(SystemFTerm::Lambda(
                            "g".to_string(),
                            SystemFType::Function(
                                Box::new(SystemFType::TypeVar("X".to_string())),
                                Box::new(SystemFType::TypeVar("Y".to_string()))
                            ),
                            Box::new(SystemFTerm::Lambda(
                                "x".to_string(),
                                SystemFType::TypeVar("X".to_string()),
                                Box::new(SystemFTerm::App(
                                    Box::new(SystemFTerm::Var("f".to_string())),
                                    Box::new(SystemFTerm::App(
                                        Box::new(SystemFTerm::Var("g".to_string())),
                                        Box::new(SystemFTerm::Var("x".to_string()))
                                    ))
                                ))
                            ))
                        ))
                    ))
                ))
            ))
        )
    }
    
    /// æ˜ å°„å‡½æ•°
    pub fn map() -> SystemFTerm {
        SystemFTerm::TypeLambda(
            "X".to_string(),
            Box::new(SystemFTerm::TypeLambda(
                "Y".to_string(),
                Box::new(SystemFTerm::Lambda(
                    "f".to_string(),
                    SystemFType::Function(
                        Box::new(SystemFType::TypeVar("X".to_string())),
                        Box::new(SystemFType::TypeVar("Y".to_string()))
                    ),
                    Box::new(SystemFTerm::Lambda(
                        "xs".to_string(),
                        SystemFType::TypeVar("X".to_string()), // ç®€åŒ–ç‰ˆæœ¬
                        Box::new(SystemFTerm::App(
                            Box::new(SystemFTerm::Var("f".to_string())),
                            Box::new(SystemFTerm::Var("xs".to_string()))
                        ))
                    ))
                ))
            ))
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_identity_function() {
        let identity = PolymorphicFunctions::identity();
        let mut env = TypeEnvironment::new();
        
        // æ£€æŸ¥ç±»å‹
        let result = SystemFTypeChecker::type_check(&env, &identity);
        assert!(result.is_ok());
        
        // æµ‹è¯•åº”ç”¨
        let int_type = SystemFType::TypeVar("Int".to_string());
        let type_app = SystemFTerm::TypeApp(Box::new(identity.clone()), int_type.clone());
        let value = SystemFTerm::Var("x".to_string());
        let app = SystemFTerm::App(Box::new(type_app), Box::new(value));
        
        env.add_term_var("x".to_string(), int_type);
        let result = SystemFTypeChecker::type_check(&env, &app);
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_type_substitution() {
        let original = SystemFType::ForAll(
            "X".to_string(),
            Box::new(SystemFType::Function(
                Box::new(SystemFType::TypeVar("X".to_string())),
                Box::new(SystemFType::TypeVar("X".to_string()))
            ))
        );
        
        let replacement = SystemFType::TypeVar("Int".to_string());
        let substituted = original.substitute("X", &replacement);
        
        let expected = SystemFType::Function(
            Box::new(SystemFType::TypeVar("Int".to_string())),
            Box::new(SystemFType::TypeVar("Int".to_string()))
        );
        
        assert_eq!(substituted, expected);
    }
}
```

### 4.2 Haskell å®ç°

```haskell
-- ç³»ç»ŸFå®ç°
module SystemF where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set

-- ç³»ç»ŸFç±»å‹
data SystemFType = 
    TypeVar String
  | Function SystemFType SystemFType
  | ForAll String SystemFType
  deriving (Eq, Show)

-- ç³»ç»ŸFé¡¹
data SystemFTerm = 
    Var String
  | Lambda String SystemFType SystemFTerm
  | App SystemFTerm SystemFTerm
  | TypeLambda String SystemFTerm
  | TypeApp SystemFTerm SystemFType
  deriving (Eq, Show)

-- ç±»å‹ç¯å¢ƒ
data TypeEnvironment = TypeEnvironment {
    typeVars :: Set String,
    termVars :: Map String SystemFType
} deriving (Show)

-- åˆ›å»ºç©ºç¯å¢ƒ
emptyEnv :: TypeEnvironment
emptyEnv = TypeEnvironment Set.empty Map.empty

-- æ·»åŠ ç±»å‹å˜é‡
addTypeVar :: String -> TypeEnvironment -> TypeEnvironment
addTypeVar var env = env { typeVars = Set.insert var (typeVars env) }

-- æ·»åŠ é¡¹å˜é‡
addTermVar :: String -> SystemFType -> TypeEnvironment -> TypeEnvironment
addTermVar var typ env = env { termVars = Map.insert var typ (termVars env) }

-- è·å–é¡¹ç±»å‹
getTermType :: String -> TypeEnvironment -> Maybe SystemFType
getTermType var env = Map.lookup var (termVars env)

-- æ£€æŸ¥ç±»å‹å˜é‡
containsTypeVar :: String -> TypeEnvironment -> Bool
containsTypeVar var env = Set.member var (typeVars env)

-- ç±»å‹æ›¿æ¢
typeSubstitute :: SystemFType -> String -> SystemFType -> SystemFType
typeSubstitute (TypeVar name) var replacement
  | name == var = replacement
  | otherwise = TypeVar name
typeSubstitute (Function from to) var replacement = 
  Function (typeSubstitute from var replacement) (typeSubstitute to var replacement)
typeSubstitute (ForAll param body) var replacement
  | param == var = ForAll param body
  | otherwise = ForAll param (typeSubstitute body var replacement)

-- é¡¹æ›¿æ¢
termSubstitute :: SystemFTerm -> String -> SystemFTerm -> SystemFTerm
termSubstitute (Var name) var replacement
  | name == var = replacement
  | otherwise = Var name
termSubstitute (Lambda param typ body) var replacement
  | param == var = Lambda param typ body
  | otherwise = Lambda param typ (termSubstitute body var replacement)
termSubstitute (App func arg) var replacement = 
  App (termSubstitute func var replacement) (termSubstitute arg var replacement)
termSubstitute (TypeLambda param body) var replacement = 
  TypeLambda param (termSubstitute body var replacement)
termSubstitute (TypeApp term typ) var replacement = 
  TypeApp (termSubstitute term var replacement) typ

-- ç±»å‹æ›¿æ¢ï¼ˆåœ¨é¡¹ä¸­ï¼‰
termTypeSubstitute :: SystemFTerm -> String -> SystemFType -> SystemFTerm
termTypeSubstitute (Var name) _ _ = Var name
termTypeSubstitute (Lambda param typ body) var replacement = 
  Lambda param (typeSubstitute typ var replacement) (termTypeSubstitute body var replacement)
termTypeSubstitute (App func arg) var replacement = 
  App (termTypeSubstitute func var replacement) (termTypeSubstitute arg var replacement)
termTypeSubstitute (TypeLambda param body) var replacement
  | param == var = TypeLambda param body
  | otherwise = TypeLambda param (termTypeSubstitute body var replacement)
termTypeSubstitute (TypeApp term typ) var replacement = 
  TypeApp (termTypeSubstitute term var replacement) (typeSubstitute typ var replacement)

-- ç±»å‹æ£€æŸ¥å™¨
typeCheck :: TypeEnvironment -> SystemFTerm -> Either String SystemFType
typeCheck env (Var name) = 
  case getTermType name env of
    Just typ -> Right typ
    Nothing -> Left $ "æœªå®šä¹‰çš„å˜é‡: " ++ name

typeCheck env (Lambda param paramType body) = do
  let newEnv = addTermVar param paramType env
  bodyType <- typeCheck newEnv body
  return $ Function paramType bodyType

typeCheck env (App func arg) = do
  funcType <- typeCheck env func
  argType <- typeCheck env arg
  case funcType of
    Function from to -> 
      if from == argType 
        then return to 
        else Left $ "ç±»å‹ä¸åŒ¹é…: æœŸæœ› " ++ show from ++ ", å¾—åˆ° " ++ show argType
    _ -> Left "å‡½æ•°åº”ç”¨çš„ç±»å‹é”™è¯¯"

typeCheck env (TypeLambda param body) = do
  let newEnv = addTypeVar param env
  bodyType <- typeCheck newEnv body
  return $ ForAll param bodyType

typeCheck env (TypeApp term typeArg) = do
  termType <- typeCheck env term
  case termType of
    ForAll param body -> return $ typeSubstitute body param typeArg
    _ -> Left "ç±»å‹åº”ç”¨çš„ç±»å‹é”™è¯¯"

-- æ±‚å€¼å™¨
evaluate :: SystemFTerm -> SystemFTerm
evaluate (App func arg) = 
  let funcVal = evaluate func
      argVal = evaluate arg
  in case funcVal of
       Lambda param _ body -> evaluate $ termSubstitute body param argVal
       _ -> App funcVal argVal

evaluate (TypeApp term typeArg) = 
  let termVal = evaluate term
  in case termVal of
       TypeLambda param body -> evaluate $ termTypeSubstitute body param typeArg
       _ -> TypeApp termVal typeArg

evaluate term = term

-- å¤šæ€å‡½æ•°ç¤ºä¾‹
identity :: SystemFTerm
identity = TypeLambda "X" $ Lambda "x" (TypeVar "X") (Var "x")

compose :: SystemFTerm
compose = TypeLambda "X" $ TypeLambda "Y" $ TypeLambda "Z" $
  Lambda "f" (Function (TypeVar "Y") (TypeVar "Z")) $
  Lambda "g" (Function (TypeVar "X") (TypeVar "Y")) $
  Lambda "x" (TypeVar "X") $
  App (Var "f") (App (Var "g") (Var "x"))

map :: SystemFTerm
map = TypeLambda "X" $ TypeLambda "Y" $
  Lambda "f" (Function (TypeVar "X") (TypeVar "Y")) $
  Lambda "xs" (TypeVar "X") $ -- ç®€åŒ–ç‰ˆæœ¬
  App (Var "f") (Var "xs")

-- æµ‹è¯•å‡½æ•°
testSystemF :: IO ()
testSystemF = do
    putStrLn "ç³»ç»ŸFæµ‹è¯•:"
    
    -- æµ‹è¯•æ’ç­‰å‡½æ•°
    let env = emptyEnv
    case typeCheck env identity of
        Right typ -> putStrLn $ "æ’ç­‰å‡½æ•°ç±»å‹: " ++ show typ
        Left err -> putStrLn $ "ç±»å‹é”™è¯¯: " ++ err
    
    -- æµ‹è¯•ç±»å‹æ›¿æ¢
    let original = ForAll "X" (Function (TypeVar "X") (TypeVar "X"))
    let replacement = TypeVar "Int"
    let substituted = typeSubstitute original "X" replacement
    putStrLn $ "ç±»å‹æ›¿æ¢ç»“æœ: " ++ show substituted
    
    -- æµ‹è¯•æ±‚å€¼
    let intType = TypeVar "Int"
    let typeApp = TypeApp identity intType
    let value = Var "x"
    let app = App typeApp value
    let result = evaluate app
    putStrLn $ "æ±‚å€¼ç»“æœ: " ++ show result
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ä¸­çš„åº”ç”¨

```rust
/// å‡½æ•°å¼ç¼–ç¨‹è¯­è¨€ç‰¹æ€§
pub struct FunctionalProgrammingFeatures;

impl FunctionalProgrammingFeatures {
    /// é«˜é˜¶å‡½æ•°
    pub fn higher_order_functions() -> SystemFTerm {
        // map :: (a -> b) -> [a] -> [b]
        SystemFTerm::TypeLambda(
            "A".to_string(),
            Box::new(SystemFTerm::TypeLambda(
                "B".to_string(),
                Box::new(SystemFTerm::Lambda(
                    "f".to_string(),
                    SystemFType::Function(
                        Box::new(SystemFType::TypeVar("A".to_string())),
                        Box::new(SystemFType::TypeVar("B".to_string()))
                    ),
                    Box::new(SystemFTerm::Lambda(
                        "xs".to_string(),
                        SystemFType::TypeVar("List".to_string()), // ç®€åŒ–
                        Box::new(SystemFTerm::App(
                            Box::new(SystemFTerm::Var("f".to_string())),
                            Box::new(SystemFTerm::Var("xs".to_string()))
                        ))
                    ))
                ))
            ))
        )
    }
    
    /// æŸ¯é‡ŒåŒ–
    pub fn currying() -> SystemFTerm {
        // curry :: ((a, b) -> c) -> a -> b -> c
        SystemFTerm::TypeLambda(
            "A".to_string(),
            Box::new(SystemFTerm::TypeLambda(
                "B".to_string(),
                Box::new(SystemFTerm::TypeLambda(
                    "C".to_string(),
                    Box::new(SystemFTerm::Lambda(
                        "f".to_string(),
                        SystemFType::Function(
                            Box::new(SystemFType::TypeVar("A".to_string())),
                            Box::new(SystemFType::Function(
                                Box::new(SystemFType::TypeVar("B".to_string())),
                                Box::new(SystemFType::TypeVar("C".to_string()))
                            ))
                        ),
                        Box::new(SystemFTerm::Lambda(
                            "a".to_string(),
                            SystemFType::TypeVar("A".to_string()),
                            Box::new(SystemFTerm::Lambda(
                                "b".to_string(),
                                SystemFType::TypeVar("B".to_string()),
                                Box::new(SystemFTerm::App(
                                    Box::new(SystemFTerm::App(
                                        Box::new(SystemFTerm::Var("f".to_string())),
                                        Box::new(SystemFTerm::Var("a".to_string()))
                                    )),
                                    Box::new(SystemFTerm::Var("b".to_string()))
                                ))
                            ))
                        ))
                    ))
                ))
            ))
        )
    }
    
    /// ç±»å‹ç±»
    pub fn type_class() -> SystemFTerm {
        // Eq :: * -> *
        SystemFTerm::TypeLambda(
            "A".to_string(),
            Box::new(SystemFTerm::Lambda(
                "eq".to_string(),
                SystemFType::Function(
                    Box::new(SystemFType::TypeVar("A".to_string())),
                    Box::new(SystemFType::Function(
                        Box::new(SystemFType::TypeVar("A".to_string())),
                        Box::new(SystemFType::TypeVar("Bool".to_string()))
                    ))
                ),
                Box::new(SystemFTerm::Var("eq".to_string()))
            ))
        )
    }
}
```

### 5.2 ç±»å‹ç³»ç»Ÿè®¾è®¡ä¸­çš„åº”ç”¨

```rust
/// ç±»å‹ç³»ç»Ÿè®¾è®¡å™¨
pub struct TypeSystemDesigner;

impl TypeSystemDesigner {
    /// è®¾è®¡é€šç”¨ç±»å‹ç³»ç»Ÿ
    pub fn design_universal_type_system() -> UniversalTypeSystem {
        UniversalTypeSystem {
            base_types: vec![
                "Int".to_string(),
                "Bool".to_string(),
                "String".to_string(),
                "Unit".to_string(),
            ],
            type_constructors: vec![
                TypeConstructor::Function,
                TypeConstructor::Product,
                TypeConstructor::Sum,
                TypeConstructor::ForAll,
                TypeConstructor::Exists,
            ],
            type_classes: vec![
                TypeClass::new("Eq".to_string(), vec!["eq".to_string()]),
                TypeClass::new("Ord".to_string(), vec!["compare".to_string()]),
                TypeClass::new("Show".to_string(), vec!["show".to_string()]),
                TypeClass::new("Functor".to_string(), vec!["fmap".to_string()]),
                TypeClass::new("Monad".to_string(), vec!["return".to_string(), "bind".to_string()]),
            ],
        }
    }
    
    /// ç±»å‹æ¨æ–­ç®—æ³•
    pub fn type_inference(term: &SystemFTerm) -> Result<SystemFType, String> {
        let mut env = TypeEnvironment::new();
        let mut constraints = Vec::new();
        
        Self::collect_constraints(&mut env, &mut constraints, term)?;
        Self::solve_constraints(constraints)
    }
    
    fn collect_constraints(
        env: &mut TypeEnvironment,
        constraints: &mut Vec<TypeConstraint>,
        term: &SystemFTerm,
    ) -> Result<SystemFType, String> {
        match term {
            SystemFTerm::Var(name) => {
                env.get_term_type(name)
                    .cloned()
                    .ok_or_else(|| format!("æœªå®šä¹‰çš„å˜é‡: {}", name))
            }
            SystemFTerm::Lambda(param, param_type, body) => {
                env.add_term_var(param.clone(), param_type.clone());
                let body_type = Self::collect_constraints(env, constraints, body)?;
                Ok(SystemFType::Function(Box::new(param_type.clone()), Box::new(body_type)))
            }
            SystemFTerm::App(func, arg) => {
                let func_type = Self::collect_constraints(env, constraints, func)?;
                let arg_type = Self::collect_constraints(env, constraints, arg)?;
                let result_type = SystemFType::TypeVar(format!("T{}", constraints.len()));
                
                constraints.push(TypeConstraint::Equal(
                    func_type,
                    SystemFType::Function(Box::new(arg_type), Box::new(result_type.clone()))
                ));
                
                Ok(result_type)
            }
            _ => Err("ä¸æ”¯æŒçš„ç±»å‹æ¨æ–­".to_string()),
        }
    }
    
    fn solve_constraints(constraints: Vec<TypeConstraint>) -> Result<SystemFType, String> {
        // ç®€åŒ–çš„çº¦æŸæ±‚è§£
        for constraint in constraints {
            match constraint {
                TypeConstraint::Equal(t1, t2) => {
                    if t1 != t2 {
                        return Err(format!("ç±»å‹ä¸åŒ¹é…: {} != {}", t1, t2));
                    }
                }
            }
        }
        Ok(SystemFType::TypeVar("T".to_string()))
    }
}

#[derive(Debug)]
pub struct UniversalTypeSystem {
    pub base_types: Vec<String>,
    pub type_constructors: Vec<TypeConstructor>,
    pub type_classes: Vec<TypeClass>,
}

#[derive(Debug)]
pub enum TypeConstructor {
    Function,
    Product,
    Sum,
    ForAll,
    Exists,
}

#[derive(Debug)]
pub struct TypeClass {
    pub name: String,
    pub methods: Vec<String>,
}

impl TypeClass {
    pub fn new(name: String, methods: Vec<String>) -> Self {
        Self { name, methods }
    }
}

#[derive(Debug)]
pub enum TypeConstraint {
    Equal(SystemFType, SystemFType),
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸ç®€å•ç±»å‹Î»æ¼”ç®—çš„å…³ç³»

ç³»ç»ŸFæ˜¯ç®€å•ç±»å‹Î»æ¼”ç®—çš„æ‰©å±•ï¼Œæ·»åŠ äº†ç±»å‹æŠ½è±¡å’Œç±»å‹åº”ç”¨ã€‚

### 6.2 ä¸Hindley-Milnerç±»å‹ç³»ç»Ÿçš„å…³ç³»

**å®šç† 6.2.1** (ç±»å‹ç³»ç»ŸåŒ…å«å…³ç³»)
Hindley-Milnerç±»å‹ç³»ç»Ÿæ˜¯ç³»ç»ŸFçš„å­é›†ï¼Œå»é™¤äº†æ˜¾å¼çš„ç±»å‹æŠ½è±¡å’Œç±»å‹åº”ç”¨ã€‚

### 6.3 ä¸ä¾èµ–ç±»å‹ç†è®ºçš„å…³ç³»

ç³»ç»ŸFä¸ºä¾èµ–ç±»å‹ç†è®ºæä¾›åŸºç¡€ï¼Œä¾èµ–ç±»å‹ç†è®ºè¿›ä¸€æ­¥æ‰©å±•äº†ç±»å‹æŠ½è±¡çš„èƒ½åŠ›ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. **Girard, J. Y.** (1972). *InterprÃ©tation fonctionnelle et Ã©limination des coupures dans l'arithmÃ©tique d'ordre supÃ©rieur*. PhD thesis, UniversitÃ© Paris 7.
2. **Reynolds, J. C.** (1974). *Towards a theory of type structure*. Programming Symposium.
3. **Pierce, B. C.** (2002). *Types and Programming Languages*. MIT Press.
4. **Cardelli, L., & Wegner, P.** (1985). *On understanding types, data abstraction, and polymorphism*. ACM Computing Surveys.
5. **Wadler, P.** (1989). *Theorems for free!*. Functional Programming Languages and Computer Architecture.

---

**ç›¸å…³æ–‡æ¡£**:

- [04.1.1 ç®€å•ç±»å‹Î»æ¼”ç®—](../04.1.1_ç®€å•ç±»å‹Î»æ¼”ç®—.md)
- [04.1.2 Hindley-Milnerç±»å‹ç³»ç»Ÿ](../04.1.2_Hindley_Milnerç±»å‹ç³»ç»Ÿ.md)
- [04.1.4 ä¾èµ–ç±»å‹](../04.1.4_ä¾èµ–ç±»å‹.md)
- [04.2.1 çº¿æ€§ç±»å‹åŸºç¡€](../04.2.1_çº¿æ€§ç±»å‹åŸºç¡€.md)
- [04.3.1 ä»¿å°„ç±»å‹åŸºç¡€](../04.3.1_ä»¿å°„ç±»å‹åŸºç¡€.md)


## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
