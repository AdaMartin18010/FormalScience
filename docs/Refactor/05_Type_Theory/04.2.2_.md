# 04.2.2 çº¿æ€§å‡½æ•°ç±»å‹

## ğŸ“‹ æ¦‚è¿°

çº¿æ€§å‡½æ•°ç±»å‹ï¼ˆLinear Function Typesï¼‰æ˜¯çº¿æ€§ç±»å‹ç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µï¼Œå®ƒç¡®ä¿å‡½æ•°å‚æ•°è¢«ä½¿ç”¨ä¸”ä»…ä½¿ç”¨ä¸€æ¬¡ã€‚è¿™ç§ç±»å‹ç³»ç»Ÿä¸ºèµ„æºç®¡ç†å’Œå†…å­˜å®‰å…¨æä¾›äº†å¼ºå¤§çš„ä¿è¯ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å½¢å¼åŒ–å®šä¹‰**ï¼šå»ºç«‹çº¿æ€§å‡½æ•°ç±»å‹çš„æ•°å­¦åŸºç¡€
2. **ç±»å‹è§„åˆ™**ï¼šè®¾è®¡çº¿æ€§å‡½æ•°çš„ç±»å‹æ¨å¯¼è§„åˆ™
3. **å®ç°éªŒè¯**ï¼šæä¾›å®Œæ•´çš„ä»£ç å®ç°å’Œæµ‹è¯•
4. **åº”ç”¨æ‰©å±•**ï¼šæ¢è®¨åœ¨èµ„æºç®¡ç†ä¸­çš„åº”ç”¨

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [ç±»å‹è§„åˆ™](#3-ç±»å‹è§„åˆ™)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 çº¿æ€§å‡½æ•°åŸç†

**å®šä¹‰ 1.1** (çº¿æ€§å‡½æ•°)
çº¿æ€§å‡½æ•°æ˜¯æ»¡è¶³çº¿æ€§æ€§æ¡ä»¶çš„å‡½æ•°ï¼šå‚æ•°å¿…é¡»è¢«ä½¿ç”¨ä¸”ä»…ä½¿ç”¨ä¸€æ¬¡ã€‚

**å®šç† 1.1** (çº¿æ€§å‡½æ•°çš„å”¯ä¸€æ€§)
å¯¹äºçº¿æ€§å‡½æ•°f: A âŠ¸ Bï¼Œå¦‚æœå­˜åœ¨ä¸¤ä¸ªä¸åŒçš„å®ç°fâ‚å’Œfâ‚‚ï¼Œåˆ™å®ƒä»¬åœ¨è¯­ä¹‰ä¸Šç­‰ä»·ã€‚

### 1.2 çº¿æ€§æ€§ä¸ä»¿å°„æ€§

**å®šä¹‰ 1.2** (çº¿æ€§æ€§)
ç±»å‹Aæ˜¯çº¿æ€§çš„ï¼Œå½“ä¸”ä»…å½“ï¼š

- Açš„å€¼å¿…é¡»è¢«ä½¿ç”¨
- Açš„å€¼ä¸èƒ½è¢«å¤åˆ¶

**å®šä¹‰ 1.3** (ä»¿å°„æ€§)
ç±»å‹Aæ˜¯ä»¿å°„çš„ï¼Œå½“ä¸”ä»…å½“ï¼š

- Açš„å€¼æœ€å¤šè¢«ä½¿ç”¨ä¸€æ¬¡
- Açš„å€¼å¯ä»¥è¢«ä¸¢å¼ƒ

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 çº¿æ€§å‡½æ•°ç±»å‹

**å®šä¹‰ 2.1** (çº¿æ€§å‡½æ•°ç±»å‹)
çº¿æ€§å‡½æ•°ç±»å‹A âŠ¸ Bè¡¨ç¤ºä»ç±»å‹Aåˆ°ç±»å‹Bçš„çº¿æ€§å‡½æ•°ï¼Œå…¶ä¸­ï¼š

- å‚æ•°ç±»å‹Aæ˜¯çº¿æ€§çš„
- å‡½æ•°å¿…é¡»ä½¿ç”¨å‚æ•°ä¸”ä»…ä½¿ç”¨ä¸€æ¬¡

**å®šä¹‰ 2.2** (çº¿æ€§å‡½æ•°è¯­ä¹‰)
çº¿æ€§å‡½æ•°f: A âŠ¸ Bçš„è¯­ä¹‰æ˜¯ä¸€ä¸ªæ˜ å°„ï¼š

- è¾“å…¥ï¼šAçš„ä¸€ä¸ªå€¼
- è¾“å‡ºï¼šBçš„ä¸€ä¸ªå€¼
- çº¦æŸï¼šè¾“å…¥å€¼è¢«æ¶ˆè€—ï¼Œä¸èƒ½é‡å¤ä½¿ç”¨

### 2.2 ç±»å‹ç¯å¢ƒ

**å®šä¹‰ 2.3** (çº¿æ€§ç±»å‹ç¯å¢ƒ)
çº¿æ€§ç±»å‹ç¯å¢ƒÎ“æ˜¯ä¸€ä¸ªä»å˜é‡åˆ°ç±»å‹çš„æ˜ å°„ï¼Œæ»¡è¶³ï¼š

- æ¯ä¸ªå˜é‡æœ€å¤šå‡ºç°ä¸€æ¬¡
- æ‰€æœ‰å˜é‡éƒ½å¿…é¡»è¢«ä½¿ç”¨

## 3. ç±»å‹è§„åˆ™

### 3.1 åŸºæœ¬ç±»å‹è§„åˆ™

```rust
// çº¿æ€§å‡½æ•°ç±»å‹çš„ç±»å‹è§„åˆ™
#[derive(Debug, Clone, PartialEq)]
pub enum Type {
    Unit,
    Int,
    Bool,
    LinearFunction(Box<Type>, Box<Type>), // A âŠ¸ B
    Product(Box<Type>, Box<Type>),        // A âŠ— B
    Sum(Box<Type>, Box<Type>),           // A âŠ• B
    Reference(Box<Type>),                // !A (æŒ‡æ•°ç±»å‹)
}

#[derive(Debug, Clone)]
pub struct TypeEnvironment {
    bindings: HashMap<String, Type>,
}

impl TypeEnvironment {
    pub fn new() -> Self {
        TypeEnvironment {
            bindings: HashMap::new(),
        }
    }
    
    pub fn add(&mut self, name: String, ty: Type) -> Result<(), String> {
        if self.bindings.contains_key(&name) {
            Err(format!("Variable {} already bound", name))
        } else {
            self.bindings.insert(name, ty);
            Ok(())
        }
    }
    
    pub fn get(&self, name: &str) -> Option<&Type> {
        self.bindings.get(name)
    }
    
    pub fn remove(&mut self, name: &str) -> Option<Type> {
        self.bindings.remove(name)
    }
    
    pub fn is_empty(&self) -> bool {
        self.bindings.is_empty()
    }
}

// ç±»å‹æ¨å¯¼è§„åˆ™
pub struct LinearTypeChecker;

impl LinearTypeChecker {
    // å˜é‡è§„åˆ™
    pub fn var(env: &TypeEnvironment, name: &str) -> Result<Type, String> {
        env.get(name)
            .cloned()
            .ok_or(format!("Variable {} not found", name))
    }
    
    // æŠ½è±¡è§„åˆ™ (Î»x:A. e)
    pub fn abs(env: &TypeEnvironment, param: &str, param_type: &Type, body_type: &Type) -> Result<Type, String> {
        let mut new_env = env.clone();
        new_env.add(param.to_string(), param_type.clone())?;
        
        Ok(Type::LinearFunction(
            Box::new(param_type.clone()),
            Box::new(body_type.clone())
        ))
    }
    
    // åº”ç”¨è§„åˆ™ (eâ‚ eâ‚‚)
    pub fn app(env: &TypeEnvironment, func_type: &Type, arg_type: &Type) -> Result<Type, String> {
        match func_type {
            Type::LinearFunction(input_type, output_type) => {
                if input_type == arg_type {
                    Ok(*output_type.clone())
                } else {
                    Err(format!("Type mismatch: expected {}, got {}", input_type, arg_type))
                }
            },
            _ => Err("Expected function type".to_string()),
        }
    }
    
    // ä¹˜ç§¯è§„åˆ™ (eâ‚, eâ‚‚)
    pub fn pair(env: &TypeEnvironment, type1: &Type, type2: &Type) -> Result<Type, String> {
        Ok(Type::Product(
            Box::new(type1.clone()),
            Box::new(type2.clone())
        ))
    }
    
    // æŠ•å½±è§„åˆ™ (Ï€áµ¢ e)
    pub fn proj(env: &TypeEnvironment, product_type: &Type, index: usize) -> Result<Type, String> {
        match product_type {
            Type::Product(type1, type2) => {
                match index {
                    1 => Ok(*type1.clone()),
                    2 => Ok(*type2.clone()),
                    _ => Err("Invalid projection index".to_string()),
                }
            },
            _ => Err("Expected product type".to_string()),
        }
    }
    
    // å’Œç±»å‹è§„åˆ™ (Î¹áµ¢ e)
    pub fn inj(env: &TypeEnvironment, sum_type: &Type, index: usize, value_type: &Type) -> Result<Type, String> {
        match sum_type {
            Type::Sum(type1, type2) => {
                let expected_type = match index {
                    1 => *type1.clone(),
                    2 => *type2.clone(),
                    _ => return Err("Invalid injection index".to_string()),
                };
                
                if &expected_type == value_type {
                    Ok(sum_type.clone())
                } else {
                    Err(format!("Type mismatch in injection"))
                }
            },
            _ => Err("Expected sum type".to_string()),
        }
    }
    
    // æ¨¡å¼åŒ¹é…è§„åˆ™ (case e of Î¹â‚xâ‚ => eâ‚ | Î¹â‚‚xâ‚‚ => eâ‚‚)
    pub fn case(
        env: &TypeEnvironment,
        sum_type: &Type,
        type1: &Type,
        type2: &Type
    ) -> Result<Type, String> {
        match sum_type {
            Type::Sum(left_type, right_type) => {
                if left_type == type1 && right_type == type2 {
                    Ok(type1.clone())
                } else {
                    Err("Type mismatch in case analysis".to_string()),
                }
            },
            _ => Err("Expected sum type".to_string()),
        }
    }
}
```

### 3.2 çº¿æ€§æ€§æ£€æŸ¥

```rust
// çº¿æ€§æ€§æ£€æŸ¥å™¨
pub struct LinearityChecker;

impl LinearityChecker {
    // æ£€æŸ¥è¡¨è¾¾å¼æ˜¯å¦çº¿æ€§ä½¿ç”¨å˜é‡
    pub fn check_linearity(expr: &Expression, env: &TypeEnvironment) -> Result<TypeEnvironment, String> {
        match expr {
            Expression::Variable(name) => {
                let mut new_env = TypeEnvironment::new();
                new_env.add(name.clone(), env.get(name).cloned().unwrap())?;
                Ok(new_env)
            },
            Expression::Lambda(param, body) => {
                let param_type = env.get(param).cloned().unwrap();
                let mut body_env = env.clone();
                body_env.add(param.clone(), param_type)?;
                
                let body_usage = Self::check_linearity(body, &body_env)?;
                
                // æ£€æŸ¥å‚æ•°æ˜¯å¦è¢«ä½¿ç”¨
                if body_usage.get(param).is_some() {
                    Err(format!("Parameter {} not used linearly", param))
                } else {
                    Ok(body_usage)
                }
            },
            Expression::Application(func, arg) => {
                let func_usage = Self::check_linearity(func, env)?;
                let arg_usage = Self::check_linearity(arg, env)?;
                
                // åˆå¹¶ä½¿ç”¨æƒ…å†µï¼Œæ£€æŸ¥å†²çª
                Self::merge_usage(func_usage, arg_usage)
            },
            Expression::Pair(left, right) => {
                let left_usage = Self::check_linearity(left, env)?;
                let right_usage = Self::check_linearity(right, env)?;
                
                Self::merge_usage(left_usage, right_usage)
            },
            Expression::Proj(expr, _) => {
                Self::check_linearity(expr, env)
            },
            _ => Ok(env.clone()),
        }
    }
    
    // åˆå¹¶ä¸¤ä¸ªä½¿ç”¨ç¯å¢ƒ
    fn merge_usage(env1: TypeEnvironment, env2: TypeEnvironment) -> Result<TypeEnvironment, String> {
        let mut result = TypeEnvironment::new();
        
        for (name, ty) in env1.bindings {
            if env2.bindings.contains_key(&name) {
                return Err(format!("Variable {} used multiple times", name));
            }
            result.add(name, ty)?;
        }
        
        for (name, ty) in env2.bindings {
            result.add(name, ty)?;
        }
        
        Ok(result)
    }
}
```

## 4. ä»£ç å®ç°

### 4.1 å®Œæ•´çš„çº¿æ€§å‡½æ•°ç±»å‹å®ç°

```rust
use std::collections::HashMap;

// è¡¨è¾¾å¼ç±»å‹
#[derive(Debug, Clone)]
pub enum Expression {
    Variable(String),
    Lambda(String, Box<Expression>),
    Application(Box<Expression>, Box<Expression>),
    Pair(Box<Expression>, Box<Expression>),
    Proj(Box<Expression>, usize),
    Inj(Box<Expression>, usize),
    Case(Box<Expression>, String, Box<Expression>, String, Box<Expression>),
    Literal(i64),
    Unit,
}

// çº¿æ€§å‡½æ•°ç±»å‹ç³»ç»Ÿ
pub struct LinearTypeSystem;

impl LinearTypeSystem {
    // ç±»å‹æ£€æŸ¥
    pub fn type_check(expr: &Expression, env: &TypeEnvironment) -> Result<Type, String> {
        match expr {
            Expression::Variable(name) => {
                LinearTypeChecker::var(env, name)
            },
            Expression::Lambda(param, body) => {
                // è·å–å‚æ•°ç±»å‹
                let param_type = env.get(param)
                    .ok_or(format!("Parameter {} not found in environment", param))?
                    .clone();
                
                // åˆ›å»ºæ–°çš„ç¯å¢ƒ
                let mut body_env = env.clone();
                body_env.remove(param);
                
                // æ£€æŸ¥å‡½æ•°ä½“
                let body_type = Self::type_check(body, &body_env)?;
                
                // æ£€æŸ¥çº¿æ€§æ€§
                LinearityChecker::check_linearity(body, &body_env)?;
                
                Ok(Type::LinearFunction(
                    Box::new(param_type),
                    Box::new(body_type)
                ))
            },
            Expression::Application(func, arg) => {
                let func_type = Self::type_check(func, env)?;
                let arg_type = Self::type_check(arg, env)?;
                
                LinearTypeChecker::app(env, &func_type, &arg_type)
            },
            Expression::Pair(left, right) => {
                let left_type = Self::type_check(left, env)?;
                let right_type = Self::type_check(right, env)?;
                
                LinearTypeChecker::pair(env, &left_type, &right_type)
            },
            Expression::Proj(expr, index) => {
                let expr_type = Self::type_check(expr, env)?;
                LinearTypeChecker::proj(env, &expr_type, *index)
            },
            Expression::Inj(expr, index) => {
                let expr_type = Self::type_check(expr, env)?;
                // è¿™é‡Œéœ€è¦çŸ¥é“å’Œç±»å‹ï¼Œç®€åŒ–å¤„ç†
                Ok(Type::Sum(Box::new(expr_type), Box::new(Type::Unit)))
            },
            Expression::Case(expr, var1, body1, var2, body2) => {
                let expr_type = Self::type_check(expr, env)?;
                
                // åˆ›å»ºåˆ†æ”¯ç¯å¢ƒ
                let mut env1 = env.clone();
                let mut env2 = env.clone();
                
                // ç®€åŒ–å¤„ç†ï¼Œå‡è®¾å’Œç±»å‹
                env1.add(var1.clone(), Type::Unit)?;
                env2.add(var2.clone(), Type::Unit)?;
                
                let body1_type = Self::type_check(body1, &env1)?;
                let body2_type = Self::type_check(body2, &env2)?;
                
                if body1_type == body2_type {
                    Ok(body1_type)
                } else {
                    Err("Case branches must have same type".to_string())
                }
            },
            Expression::Literal(_) => Ok(Type::Int),
            Expression::Unit => Ok(Type::Unit),
        }
    }
    
    // æ±‚å€¼
    pub fn evaluate(expr: &Expression, env: &HashMap<String, Value>) -> Result<Value, String> {
        match expr {
            Expression::Variable(name) => {
                env.get(name)
                    .cloned()
                    .ok_or(format!("Variable {} not found", name))
            },
            Expression::Lambda(param, body) => {
                Ok(Value::Closure(param.clone(), body.clone(), env.clone()))
            },
            Expression::Application(func, arg) => {
                let func_val = Self::evaluate(func, env)?;
                let arg_val = Self::evaluate(arg, env)?;
                
                match func_val {
                    Value::Closure(param, body, closure_env) => {
                        let mut new_env = closure_env.clone();
                        new_env.insert(param, arg_val);
                        Self::evaluate(&body, &new_env)
                    },
                    _ => Err("Expected function value".to_string()),
                }
            },
            Expression::Pair(left, right) => {
                let left_val = Self::evaluate(left, env)?;
                let right_val = Self::evaluate(right, env)?;
                Ok(Value::Pair(Box::new(left_val), Box::new(right_val)))
            },
            Expression::Proj(expr, index) => {
                let expr_val = Self::evaluate(expr, env)?;
                match expr_val {
                    Value::Pair(left, right) => {
                        match index {
                            1 => Ok(*left),
                            2 => Ok(*right),
                            _ => Err("Invalid projection index".to_string()),
                        }
                    },
                    _ => Err("Expected pair value".to_string()),
                }
            },
            Expression::Literal(value) => Ok(Value::Int(*value)),
            Expression::Unit => Ok(Value::Unit),
            _ => Err("Not implemented".to_string()),
        }
    }
}

// å€¼ç±»å‹
#[derive(Debug, Clone)]
pub enum Value {
    Int(i64),
    Bool(bool),
    Unit,
    Closure(String, Expression, HashMap<String, Value>),
    Pair(Box<Value>, Box<Value>),
    Inj(Box<Value>, usize),
}

// æµ‹è¯•ä»£ç 
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_linear_function_type() {
        // æµ‹è¯•çº¿æ€§å‡½æ•°ç±»å‹æ£€æŸ¥
        let expr = Expression::Lambda(
            "x".to_string(),
            Box::new(Expression::Variable("x".to_string())),
        );
        
        let mut env = TypeEnvironment::new();
        env.add("x".to_string(), Type::Int).unwrap();
        
        let result = LinearTypeSystem::type_check(&expr, &env);
        assert!(result.is_ok());
        
        if let Ok(Type::LinearFunction(input, output)) = result {
            assert_eq!(*input, Type::Int);
            assert_eq!(*output, Type::Int);
        } else {
            panic!("Expected linear function type");
        }
    }
    
    #[test]
    fn test_linear_function_application() {
        // æµ‹è¯•çº¿æ€§å‡½æ•°åº”ç”¨
        let func = Expression::Lambda(
            "x".to_string(),
            Box::new(Expression::Variable("x".to_string())),
        );
        let arg = Expression::Literal(42);
        let app = Expression::Application(Box::new(func), Box::new(arg));
        
        let env = TypeEnvironment::new();
        let result = LinearTypeSystem::type_check(&app, &env);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), Type::Int);
    }
    
    #[test]
    fn test_nonlinear_function_error() {
        // æµ‹è¯•éçº¿æ€§å‡½æ•°é”™è¯¯
        let expr = Expression::Pair(
            Box::new(Expression::Variable("x".to_string())),
            Box::new(Expression::Variable("x".to_string())),
        );
        
        let mut env = TypeEnvironment::new();
        env.add("x".to_string(), Type::Int).unwrap();
        
        let result = LinearTypeSystem::type_check(&expr, &env);
        assert!(result.is_err()); // åº”è¯¥å¤±è´¥ï¼Œå› ä¸ºxè¢«ä½¿ç”¨äº†ä¸¤æ¬¡
    }
}
```

### 4.2 Haskellå®ç°ç‰ˆæœ¬

```haskell
-- çº¿æ€§å‡½æ•°ç±»å‹çš„Haskellå®ç°
module LinearFunctionTypes where

import Data.Map (Map)
import qualified Data.Map as Map

-- ç±»å‹å®šä¹‰
data Type = Unit
          | Int
          | Bool
          | LinearFunction Type Type  -- A âŠ¸ B
          | Product Type Type         -- A âŠ— B
          | Sum Type Type            -- A âŠ• B
          | Reference Type           -- !A
          deriving (Show, Eq)

-- è¡¨è¾¾å¼å®šä¹‰
data Expression = Variable String
                | Lambda String Expression
                | Application Expression Expression
                | Pair Expression Expression
                | Proj Expression Int
                | Inj Expression Int
                | Case Expression String Expression String Expression
                | Literal Int
                | Unit
                deriving (Show, Eq)

-- å€¼å®šä¹‰
data Value = VInt Int
           | VBool Bool
           | VUnit
           | VClosure String Expression (Map String Value)
           | VPair Value Value
           | VInj Value Int
           deriving (Show, Eq)

-- ç±»å‹ç¯å¢ƒ
type TypeEnvironment = Map String Type

-- çº¿æ€§ç±»å‹æ£€æŸ¥å™¨
class LinearTypeChecker a where
    typeCheck :: a -> TypeEnvironment -> Either String Type

instance LinearTypeChecker Expression where
    typeCheck (Variable name) env = 
        case Map.lookup name env of
            Just ty -> Right ty
            Nothing -> Left $ "Variable " ++ name ++ " not found"
    
    typeCheck (Lambda param body) env = do
        paramType <- case Map.lookup param env of
            Just ty -> Right ty
            Nothing -> Left $ "Parameter " ++ param ++ " not found"
        
        let bodyEnv = Map.delete param env
        bodyType <- typeCheck body bodyEnv
        
        -- æ£€æŸ¥çº¿æ€§æ€§
        checkLinearity body bodyEnv
        
        return $ LinearFunction paramType bodyType
    
    typeCheck (Application func arg) env = do
        funcType <- typeCheck func env
        argType <- typeCheck arg env
        
        case funcType of
            LinearFunction inputType outputType ->
                if inputType == argType
                then return outputType
                else Left $ "Type mismatch: expected " ++ show inputType ++ ", got " ++ show argType
            _ -> Left "Expected function type"
    
    typeCheck (Pair left right) env = do
        leftType <- typeCheck left env
        rightType <- typeCheck right env
        return $ Product leftType rightType
    
    typeCheck (Proj expr index) env = do
        exprType <- typeCheck expr env
        case exprType of
            Product type1 type2 ->
                case index of
                    1 -> return type1
                    2 -> return type2
                    _ -> Left "Invalid projection index"
            _ -> Left "Expected product type"
    
    typeCheck (Literal _) _ = return Int
    typeCheck Unit _ = return Unit
    typeCheck _ _ = Left "Not implemented"

-- çº¿æ€§æ€§æ£€æŸ¥
checkLinearity :: Expression -> TypeEnvironment -> Either String ()
checkLinearity expr env = do
    usage <- getUsage expr env
    validateUsage usage
    return ()

-- è·å–å˜é‡ä½¿ç”¨æƒ…å†µ
getUsage :: Expression -> TypeEnvironment -> Either String (Map String Type)
getUsage (Variable name) env = 
    case Map.lookup name env of
        Just ty -> Right $ Map.singleton name ty
        Nothing -> Left $ "Variable " ++ name ++ " not found"

getUsage (Lambda param body) env = do
    let bodyEnv = Map.delete param env
    bodyUsage <- getUsage body bodyEnv
    
    -- æ£€æŸ¥å‚æ•°æ˜¯å¦è¢«ä½¿ç”¨
    if Map.member param bodyUsage
    then Left $ "Parameter " ++ param ++ " not used linearly"
    else return bodyUsage

getUsage (Application func arg) env = do
    funcUsage <- getUsage func env
    argUsage <- getUsage arg env
    mergeUsage funcUsage argUsage

getUsage (Pair left right) env = do
    leftUsage <- getUsage left env
    rightUsage <- getUsage right env
    mergeUsage leftUsage rightUsage

getUsage _ _ = Right Map.empty

-- åˆå¹¶ä½¿ç”¨æƒ…å†µ
mergeUsage :: Map String Type -> Map String Type -> Either String (Map String Type)
mergeUsage usage1 usage2 = 
    let intersection = Map.intersection usage1 usage2
    in if Map.null intersection
       then Right $ Map.union usage1 usage2
       else Left $ "Variables used multiple times: " ++ show (Map.keys intersection)

-- éªŒè¯ä½¿ç”¨æƒ…å†µ
validateUsage :: Map String Type -> Either String ()
validateUsage usage = 
    if Map.null usage
    then return ()
    else Left $ "Unused variables: " ++ show (Map.keys usage)

-- æ±‚å€¼å™¨
evaluate :: Expression -> Map String Value -> Either String Value
evaluate (Variable name) env = 
    case Map.lookup name env of
        Just value -> Right value
        Nothing -> Left $ "Variable " ++ name ++ " not found"

evaluate (Lambda param body) env = 
    Right $ VClosure param body env

evaluate (Application func arg) env = do
    funcVal <- evaluate func env
    argVal <- evaluate arg env
    
    case funcVal of
        VClosure param body closureEnv -> do
            let newEnv = Map.insert param argVal closureEnv
            evaluate body newEnv
        _ -> Left "Expected function value"

evaluate (Pair left right) env = do
    leftVal <- evaluate left env
    rightVal <- evaluate right env
    return $ VPair leftVal rightVal

evaluate (Proj expr index) env = do
    exprVal <- evaluate expr env
    case exprVal of
        VPair left right ->
            case index of
                1 -> return left
                2 -> return right
                _ -> Left "Invalid projection index"
        _ -> Left "Expected pair value"

evaluate (Literal value) _ = return $ VInt value
evaluate Unit _ = return VUnit
evaluate _ _ = Left "Not implemented"

-- æµ‹è¯•å‡½æ•°
testLinearFunctionTypes :: IO ()
testLinearFunctionTypes = do
    putStrLn "Testing linear function types..."
    
    -- æµ‹è¯•çº¿æ€§å‡½æ•°ç±»å‹æ£€æŸ¥
    let lambda = Lambda "x" (Variable "x")
    let env = Map.singleton "x" Int
    
    case typeCheck lambda env of
        Left err -> putStrLn $ "Error: " ++ err
        Right ty -> putStrLn $ "Type: " ++ show ty
    
    -- æµ‹è¯•å‡½æ•°åº”ç”¨
    let app = Application lambda (Literal 42)
    let emptyEnv = Map.empty
    
    case typeCheck app emptyEnv of
        Left err -> putStrLn $ "Error: " ++ err
        Right ty -> putStrLn $ "Application type: " ++ show ty
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 èµ„æºç®¡ç†

```rust
// åŸºäºçº¿æ€§å‡½æ•°ç±»å‹çš„èµ„æºç®¡ç†
pub struct ResourceManager {
    resources: HashMap<String, Resource>,
}

#[derive(Debug, Clone)]
pub struct Resource {
    pub name: String,
    pub data: Vec<u8>,
    pub is_consumed: bool,
}

impl ResourceManager {
    pub fn new() -> Self {
        ResourceManager {
            resources: HashMap::new(),
        }
    }
    
    pub fn create_resource(&mut self, name: String, data: Vec<u8>) -> Resource {
        let resource = Resource {
            name: name.clone(),
            data,
            is_consumed: false,
        };
        self.resources.insert(name, resource.clone());
        resource
    }
    
    pub fn consume_resource(&mut self, name: &str) -> Result<Vec<u8>, String> {
        if let Some(resource) = self.resources.get_mut(name) {
            if resource.is_consumed {
                Err(format!("Resource {} already consumed", name))
            } else {
                resource.is_consumed = true;
                Ok(resource.data.clone())
            }
        } else {
            Err(format!("Resource {} not found", name))
        }
    }
}

// çº¿æ€§èµ„æºç±»å‹
#[derive(Debug, Clone)]
pub struct LinearResource {
    pub name: String,
    pub data: Vec<u8>,
}

impl LinearResource {
    pub fn new(name: String, data: Vec<u8>) -> Self {
        LinearResource { name, data }
    }
    
    pub fn consume(self) -> Vec<u8> {
        self.data
    }
}

// çº¿æ€§å‡½æ•°å¤„ç†èµ„æº
pub fn process_resource(resource: LinearResource) -> i64 {
    let data = resource.consume();
    data.len() as i64
}

// ä½¿ç”¨ç¤ºä¾‹
fn main() {
    let resource = LinearResource::new("file.txt".to_string(), vec![1, 2, 3, 4, 5]);
    let result = process_resource(resource);
    println!("Processed resource, result: {}", result);
    
    // ä¸‹é¢çš„ä»£ç ä¼šç¼–è¯‘é”™è¯¯ï¼Œå› ä¸ºresourceå·²ç»è¢«æ¶ˆè´¹
    // let result2 = process_resource(resource);
}
```

### 5.2 å†…å­˜å®‰å…¨

```rust
// åŸºäºçº¿æ€§å‡½æ•°ç±»å‹çš„å†…å­˜å®‰å…¨
pub struct LinearBuffer {
    data: Vec<u8>,
    is_consumed: bool,
}

impl LinearBuffer {
    pub fn new(data: Vec<u8>) -> Self {
        LinearBuffer {
            data,
            is_consumed: false,
        }
    }
    
    pub fn read(self) -> Vec<u8> {
        if self.is_consumed {
            panic!("Buffer already consumed");
        }
        self.data
    }
    
    pub fn write(mut self, new_data: Vec<u8>) -> Self {
        if self.is_consumed {
            panic!("Buffer already consumed");
        }
        self.data = new_data;
        self
    }
}

// çº¿æ€§å‡½æ•°å¤„ç†ç¼“å†²åŒº
pub fn process_buffer(buffer: LinearBuffer) -> i64 {
    let data = buffer.read();
    data.len() as i64
}

pub fn modify_buffer(buffer: LinearBuffer, new_data: Vec<u8>) -> LinearBuffer {
    buffer.write(new_data)
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å…¶ä»–ç±»å‹ç³»ç»Ÿçš„å…³ç³»

| ç‰¹æ€§ | çº¿æ€§ç±»å‹ | ä»¿å°„ç±»å‹ | ç›¸å…³ç±»å‹ |
|------|----------|----------|----------|
| ä½¿ç”¨æ¬¡æ•° | æ°å¥½ä¸€æ¬¡ | æœ€å¤šä¸€æ¬¡ | ä»»æ„æ¬¡æ•° |
| å¤åˆ¶ | ç¦æ­¢ | ç¦æ­¢ | å…è®¸ |
| ä¸¢å¼ƒ | ç¦æ­¢ | å…è®¸ | å…è®¸ |
| èµ„æºç®¡ç† | å¼º | ä¸­ç­‰ | å¼± |

### 6.2 ç†è®ºè”ç³»

**å®šç† 6.1** (çº¿æ€§å‡½æ•°ä¸èµ„æºç®¡ç†çš„å…³ç³»)
çº¿æ€§å‡½æ•°ç±»å‹ç³»ç»Ÿèƒ½å¤Ÿä¿è¯èµ„æºçš„æ­£ç¡®ä½¿ç”¨å’Œé‡Šæ”¾ã€‚

**å®šç† 6.2** (çº¿æ€§å‡½æ•°ä¸å†…å­˜å®‰å…¨çš„å…³ç³»)
çº¿æ€§å‡½æ•°ç±»å‹ç³»ç»Ÿèƒ½å¤Ÿé˜²æ­¢å†…å­˜æ³„æ¼å’Œé‡å¤é‡Šæ”¾ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Girard, J.-Y. (1987). *Linear logic*. Theoretical Computer Science, 50(1), 1-101.

2. Wadler, P. (1990). *Linear types can change the world!*. In Programming Concepts and Methods (pp. 546-566).

3. Walker, D. (2005). *Substructural type systems*. In Advanced Topics in Types and Programming Languages (pp. 3-43).

4. Pfenning, F., & Davies, R. (2001). *A judgmental reconstruction of modal logic*. Mathematical Structures in Computer Science, 11(4), 511-540.

5. Krishnaswami, N. R., & Pradic, P. (2019). *A higher-order abstract syntax approach to the verified compilation of functional programs*. In Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation (pp. 1007-1021).

6. Atkey, R. (2009). *Parameterised notions of computation*. Journal of Functional Programming, 19(3-4), 335-376.

7. MelliÃ¨s, P. A. (2009). *Categorical semantics of linear logic*. Panoramas et synthÃ¨ses, 27, 15-215.

8. Abramsky, S. (1993). *Computational interpretations of linear logic*. Theoretical Computer Science, 111(1-2), 3-57.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [04.2.1 çº¿æ€§ç±»å‹åŸºç¡€](../04.2.1_çº¿æ€§ç±»å‹åŸºç¡€.md)
- [04.2.3 çº¿æ€§æ•°æ®ç»“æ„](../04.2.3_çº¿æ€§æ•°æ®ç»“æ„.md)
- [04.2.4 çº¿æ€§ç±»å‹ç³»ç»Ÿ](../04.2.4_çº¿æ€§ç±»å‹ç³»ç»Ÿ.md)
- [04.1.1 ç®€å•ç±»å‹Î»æ¼”ç®—](../04.1.1_ç®€å•ç±»å‹Î»æ¼”ç®—.md)
- [04.3.1 ä»¿å°„ç±»å‹åŸºç¡€](../04.3.1_ä»¿å°„ç±»å‹åŸºç¡€.md)


## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
