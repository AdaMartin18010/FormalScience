# 11.2.1 ÁΩëÁªúÂçèËÆÆÁêÜËÆ∫

## ÁõÆÂΩï

- [11.2.1 ÁΩëÁªúÂçèËÆÆÁêÜËÆ∫](#1121-ÁΩëÁªúÂçèËÆÆÁêÜËÆ∫)
  - [ÁõÆÂΩï](#ÁõÆÂΩï)
  - [üìã Ê¶ÇËø∞](#-Ê¶ÇËø∞)
  - [1. Âü∫Êú¨Ê¶ÇÂøµ](#1-Âü∫Êú¨Ê¶ÇÂøµ)
    - [1.1 ÁΩëÁªúÂçèËÆÆÂÆö‰πâ](#11-ÁΩëÁªúÂçèËÆÆÂÆö‰πâ)
    - [1.2 ÂçèËÆÆÂàÜÁ±ª](#12-ÂçèËÆÆÂàÜÁ±ª)
  - [2. ÂΩ¢ÂºèÂåñÂÆö‰πâ](#2-ÂΩ¢ÂºèÂåñÂÆö‰πâ)
    - [2.1 ÂçèËÆÆÁä∂ÊÄÅÊú∫](#21-ÂçèËÆÆÁä∂ÊÄÅÊú∫)
    - [2.2 ÂçèËÆÆÊ†à](#22-ÂçèËÆÆÊ†à)
    - [2.3 ÂçèËÆÆÈ™åËØÅ](#23-ÂçèËÆÆÈ™åËØÅ)
  - [3. ÂÆöÁêÜ‰∏éËØÅÊòé](#3-ÂÆöÁêÜ‰∏éËØÅÊòé)
    - [3.1 TCPÂèØÈù†ÊÄßÂÆöÁêÜ](#31-tcpÂèØÈù†ÊÄßÂÆöÁêÜ)
    - [3.2 ÂçèËÆÆÊ≠ªÈîÅÈÅøÂÖçÂÆöÁêÜ](#32-ÂçèËÆÆÊ≠ªÈîÅÈÅøÂÖçÂÆöÁêÜ)
  - [4. Rust‰ª£Á†ÅÂÆûÁé∞](#4-rust‰ª£Á†ÅÂÆûÁé∞)
    - [4.1 TCPÂçèËÆÆÂÆûÁé∞](#41-tcpÂçèËÆÆÂÆûÁé∞)
    - [4.2 HTTPÂçèËÆÆÂÆûÁé∞](#42-httpÂçèËÆÆÂÆûÁé∞)
    - [4.3 ÂçèËÆÆÁä∂ÊÄÅÊú∫ÂÆûÁé∞](#43-ÂçèËÆÆÁä∂ÊÄÅÊú∫ÂÆûÁé∞)
  - [5. Áõ∏ÂÖ≥ÁêÜËÆ∫‰∏é‰∫§ÂèâÂºïÁî®](#5-Áõ∏ÂÖ≥ÁêÜËÆ∫‰∏é‰∫§ÂèâÂºïÁî®)
  - [6. ÂèÇËÄÉÊñáÁåÆ](#6-ÂèÇËÄÉÊñáÁåÆ)
  - [ÊâπÂà§ÊÄßÂàÜÊûê](#ÊâπÂà§ÊÄßÂàÜÊûê)

## üìã Ê¶ÇËø∞

ÁΩëÁªúÂçèËÆÆÁêÜËÆ∫Á†îÁ©∂ËÆ°ÁÆóÊú∫ÁΩëÁªú‰∏≠ÈÄö‰ø°ÂçèËÆÆÁöÑËßÑËåÉ„ÄÅÂÆûÁé∞Âíå‰ºòÂåñ„ÄÇ
ËØ•ÁêÜËÆ∫Ê∂µÁõñTCP/IPÂçèËÆÆÊóè„ÄÅÂçèËÆÆÁä∂ÊÄÅÊú∫„ÄÅÂçèËÆÆÈ™åËØÅ„ÄÅÂçèËÆÆÊÄßËÉΩÁ≠âÊ†∏ÂøÉÊ¶ÇÂøµÔºå‰∏∫ÁΩëÁªúÈÄö‰ø°Êèê‰æõÁêÜËÆ∫Âü∫Á°Ä„ÄÇ

## 1. Âü∫Êú¨Ê¶ÇÂøµ

### 1.1 ÁΩëÁªúÂçèËÆÆÂÆö‰πâ

**ÂÆö‰πâ 1.1**ÔºàÁΩëÁªúÂçèËÆÆÔºâ
ÁΩëÁªúÂçèËÆÆÊòØËÆ°ÁÆóÊú∫ÁΩëÁªú‰∏≠ÈÄö‰ø°ÂÆû‰ΩìÈó¥‰∫§Êç¢‰ø°ÊÅØÁöÑËßÑÂàôÂíåÁ∫¶ÂÆö„ÄÇ

### 1.2 ÂçèËÆÆÂàÜÁ±ª

| ÂçèËÆÆÁ±ªÂûã     | Ëã±ÊñáÂêçÁß∞         | ÂäüËÉΩÊèèËø∞                     | ÂÖ∏ÂûãÂçèËÆÆ         |
|--------------|------------------|------------------------------|------------------|
| ‰º†ËæìÂçèËÆÆ     | Transport        | Á´ØÂà∞Á´ØÊï∞ÊçÆ‰º†Ëæì               | TCP, UDP         |
| Ë∑ØÁî±ÂçèËÆÆ     | Routing          | ÁΩëÁªúË∑ØÂæÑÈÄâÊã©                 | OSPF, BGP        |
| Â∫îÁî®ÂçèËÆÆ     | Application      | Áî®Êà∑ÊúçÂä°ÂÆûÁé∞                 | HTTP, FTP, SMTP  |
| ÂÆâÂÖ®ÂçèËÆÆ     | Security         | ÈÄö‰ø°ÂÆâÂÖ®‰øùÈöú                 | SSL, TLS, IPSec  |

## 2. ÂΩ¢ÂºèÂåñÂÆö‰πâ

### 2.1 ÂçèËÆÆÁä∂ÊÄÅÊú∫

**ÂÆö‰πâ 2.1**ÔºàÂçèËÆÆÁä∂ÊÄÅÊú∫Ôºâ
ÂçèËÆÆÁä∂ÊÄÅÊú∫ÊòØÊèèËø∞ÂçèËÆÆÂÆû‰ΩìÁä∂ÊÄÅËΩ¨Êç¢ÁöÑÊúâÈôêÁä∂ÊÄÅËá™Âä®Êú∫„ÄÇ

### 2.2 ÂçèËÆÆÊ†à

**ÂÆö‰πâ 2.2**ÔºàÂçèËÆÆÊ†àÔºâ
ÂçèËÆÆÊ†àÊòØÁΩëÁªúÂçèËÆÆÁöÑÂ±ÇÊ¨°ÂåñÁªÑÁªáÔºåÊØèÂ±ÇÂÆûÁé∞ÁâπÂÆöÂäüËÉΩ„ÄÇ

### 2.3 ÂçèËÆÆÈ™åËØÅ

**ÂÆö‰πâ 2.3**ÔºàÂçèËÆÆÈ™åËØÅÔºâ
ÂçèËÆÆÈ™åËØÅÊòØÁ°Æ‰øùÂçèËÆÆÂÆûÁé∞Á¨¶ÂêàËßÑËåÉÁöÑËøáÁ®ã„ÄÇ

## 3. ÂÆöÁêÜ‰∏éËØÅÊòé

### 3.1 TCPÂèØÈù†ÊÄßÂÆöÁêÜ

**ÂÆöÁêÜ 3.1**ÔºàTCPÂèØÈù†ÊÄßÔºâ
TCPÂçèËÆÆÈÄöËøáÂ∫èÂàóÂè∑„ÄÅÁ°ÆËÆ§Êú∫Âà∂ÂíåÈáç‰º†Êú∫Âà∂‰øùËØÅÊï∞ÊçÆ‰º†ËæìÂèØÈù†ÊÄß„ÄÇ

**ËØÅÊòé**Ôºö
ËÆæÊï∞ÊçÆÂåÖÂ∫èÂàó‰∏∫ $S_1, S_2, ..., S_n$ÔºåTCPÈÄöËøáÂ∫èÂàóÂè∑Ê£ÄÊµã‰∏¢Â§±ÔºåÈÄöËøáÁ°ÆËÆ§Êú∫Âà∂Á°ÆËÆ§Êé•Êî∂ÔºåÈÄöËøáÈáç‰º†Êú∫Âà∂ÊÅ¢Â§ç‰∏¢Â§±Êï∞ÊçÆ„ÄÇ‚ñ°

### 3.2 ÂçèËÆÆÊ≠ªÈîÅÈÅøÂÖçÂÆöÁêÜ

**ÂÆöÁêÜ 3.2**ÔºàÂçèËÆÆÊ≠ªÈîÅÈÅøÂÖçÔºâ
Ëã•ÂçèËÆÆÁä∂ÊÄÅÊú∫Êó†ÁéØ‰∏îÊØè‰∏™Áä∂ÊÄÅÈÉΩÊúâÂá∫ËæπÔºåÂàôÂçèËÆÆ‰∏ç‰ºöÊ≠ªÈîÅ„ÄÇ

**ËØÅÊòé**Ôºö
ËÆæÁä∂ÊÄÅÊú∫‰∏∫ $M = (Q, \Sigma, \delta, q_0)$ÔºåËã•Êó†ÁéØ‰∏îÊØè‰∏™Áä∂ÊÄÅÈÉΩÊúâÂá∫ËæπÔºåÂàôÊÄªÂ≠òÂú®ËΩ¨Êç¢Ë∑ØÂæÑÔºåÈÅøÂÖçÊ≠ªÈîÅ„ÄÇ‚ñ°

## 4. Rust‰ª£Á†ÅÂÆûÁé∞

### 4.1 TCPÂçèËÆÆÂÆûÁé∞

```rust
use std::collections::HashMap;
use std::net::{IpAddr, SocketAddr};
use std::time::{Duration, Instant};

#[derive(Debug, Clone)]
pub struct TCPHeader {
    pub source_port: u16,
    pub destination_port: u16,
    pub sequence_number: u32,
    pub acknowledgment_number: u32,
    pub data_offset: u8,
    pub flags: TCPFlags,
    pub window_size: u16,
    pub checksum: u16,
    pub urgent_pointer: u16,
}

#[derive(Debug, Clone)]
pub struct TCPFlags {
    pub fin: bool,
    pub syn: bool,
    pub rst: bool,
    pub psh: bool,
    pub ack: bool,
    pub urg: bool,
}

impl TCPFlags {
    pub fn new() -> Self {
        TCPFlags {
            fin: false,
            syn: false,
            rst: false,
            psh: false,
            ack: false,
            urg: false,
        }
    }
    
    pub fn to_u8(&self) -> u8 {
        let mut flags = 0u8;
        if self.fin { flags |= 0x01; }
        if self.syn { flags |= 0x02; }
        if self.rst { flags |= 0x04; }
        if self.psh { flags |= 0x08; }
        if self.ack { flags |= 0x10; }
        if self.urg { flags |= 0x20; }
        flags
    }
    
    pub fn from_u8(flags: u8) -> Self {
        TCPFlags {
            fin: (flags & 0x01) != 0,
            syn: (flags & 0x02) != 0,
            rst: (flags & 0x04) != 0,
            psh: (flags & 0x08) != 0,
            ack: (flags & 0x10) != 0,
            urg: (flags & 0x20) != 0,
        }
    }
}

#[derive(Debug, Clone)]
pub struct TCPPacket {
    pub header: TCPHeader,
    pub data: Vec<u8>,
}

impl TCPPacket {
    pub fn new(source_port: u16, dest_port: u16) -> Self {
        TCPPacket {
            header: TCPHeader {
                source_port,
                destination_port: dest_port,
                sequence_number: 0,
                acknowledgment_number: 0,
                data_offset: 5,
                flags: TCPFlags::new(),
                window_size: 65535,
                checksum: 0,
                urgent_pointer: 0,
            },
            data: Vec::new(),
        }
    }
    
    pub fn serialize(&self) -> Vec<u8> {
        let mut buffer = Vec::new();
        
        // Â∫èÂàóÂåñÂ§¥ÈÉ®
        buffer.extend_from_slice(&self.header.source_port.to_be_bytes());
        buffer.extend_from_slice(&self.header.destination_port.to_be_bytes());
        buffer.extend_from_slice(&self.header.sequence_number.to_be_bytes());
        buffer.extend_from_slice(&self.header.acknowledgment_number.to_be_bytes());
        
        let offset_flags = (self.header.data_offset << 4) | self.header.flags.to_u8();
        buffer.push(offset_flags);
        buffer.push(0); // ‰øùÁïôÂ≠óÊÆµ
        
        buffer.extend_from_slice(&self.header.window_size.to_be_bytes());
        buffer.extend_from_slice(&self.header.checksum.to_be_bytes());
        buffer.extend_from_slice(&self.header.urgent_pointer.to_be_bytes());
        
        // Ê∑ªÂä†Êï∞ÊçÆ
        buffer.extend_from_slice(&self.data);
        
        buffer
    }
    
    pub fn deserialize(data: &[u8]) -> Result<Self, String> {
        if data.len() < 20 {
            return Err("Packet too short".to_string());
        }
        
        let header = TCPHeader {
            source_port: u16::from_be_bytes([data[0], data[1]]),
            destination_port: u16::from_be_bytes([data[2], data[3]]),
            sequence_number: u32::from_be_bytes([data[4], data[5], data[6], data[7]]),
            acknowledgment_number: u32::from_be_bytes([data[8], data[9], data[10], data[11]]),
            data_offset: data[12] >> 4,
            flags: TCPFlags::from_u8(data[12] & 0x3F),
            window_size: u16::from_be_bytes([data[14], data[15]]),
            checksum: u16::from_be_bytes([data[16], data[17]]),
            urgent_pointer: u16::from_be_bytes([data[18], data[19]]),
        };
        
        let packet_data = data[20..].to_vec();
        
        Ok(TCPPacket {
            header,
            data: packet_data,
        })
    }
}

#[derive(Debug, Clone)]
pub enum TCPState {
    Closed,
    Listen,
    SynSent,
    SynReceived,
    Established,
    FinWait1,
    FinWait2,
    CloseWait,
    Closing,
    LastAck,
    TimeWait,
}

#[derive(Debug, Clone)]
pub struct TCPConnection {
    pub local_addr: SocketAddr,
    pub remote_addr: SocketAddr,
    pub state: TCPState,
    pub sequence_number: u32,
    pub acknowledgment_number: u32,
    pub window_size: u16,
    pub send_buffer: Vec<u8>,
    pub receive_buffer: Vec<u8>,
    pub unacked_segments: HashMap<u32, (Vec<u8>, Instant)>,
    pub retransmission_timeout: Duration,
}

impl TCPConnection {
    pub fn new(local_addr: SocketAddr, remote_addr: SocketAddr) -> Self {
        TCPConnection {
            local_addr,
            remote_addr,
            state: TCPState::Closed,
            sequence_number: 0,
            acknowledgment_number: 0,
            window_size: 65535,
            send_buffer: Vec::new(),
            receive_buffer: Vec::new(),
            unacked_segments: HashMap::new(),
            retransmission_timeout: Duration::from_secs(1),
        }
    }
    
    pub fn connect(&mut self) -> Result<TCPPacket, String> {
        match self.state {
            TCPState::Closed => {
                self.state = TCPState::SynSent;
                self.sequence_number = rand::random::<u32>();
                
                let mut packet = TCPPacket::new(
                    self.local_addr.port(),
                    self.remote_addr.port()
                );
                packet.header.sequence_number = self.sequence_number;
                packet.header.flags.syn = true;
                
                Ok(packet)
            },
            _ => Err("Invalid state for connect".to_string()),
        }
    }
    
    pub fn handle_syn_ack(&mut self, packet: &TCPPacket) -> Result<TCPPacket, String> {
        match self.state {
            TCPState::SynSent => {
                if packet.header.flags.syn && packet.header.flags.ack {
                    self.state = TCPState::Established;
                    self.acknowledgment_number = packet.header.sequence_number + 1;
                    
                    let mut ack_packet = TCPPacket::new(
                        self.local_addr.port(),
                        self.remote_addr.port()
                    );
                    ack_packet.header.sequence_number = self.sequence_number;
                    ack_packet.header.acknowledgment_number = self.acknowledgment_number;
                    ack_packet.header.flags.ack = true;
                    
                    Ok(ack_packet)
                } else {
                    Err("Expected SYN-ACK packet".to_string())
                }
            },
            _ => Err("Invalid state for SYN-ACK".to_string()),
        }
    }
    
    pub fn send_data(&mut self, data: &[u8]) -> Result<TCPPacket, String> {
        match self.state {
            TCPState::Established => {
                let mut packet = TCPPacket::new(
                    self.local_addr.port(),
                    self.remote_addr.port()
                );
                packet.header.sequence_number = self.sequence_number;
                packet.header.acknowledgment_number = self.acknowledgment_number;
                packet.header.flags.ack = true;
                packet.header.flags.psh = true;
                packet.data = data.to_vec();
                
                // ‰øùÂ≠òÊú™Á°ÆËÆ§ÁöÑÊÆµ
                self.unacked_segments.insert(
                    self.sequence_number,
                    (data.to_vec(), Instant::now())
                );
                
                self.sequence_number += data.len() as u32;
                
                Ok(packet)
            },
            _ => Err("Connection not established".to_string()),
        }
    }
    
    pub fn handle_data(&mut self, packet: &TCPPacket) -> Result<TCPPacket, String> {
        match self.state {
            TCPState::Established => {
                // Â§ÑÁêÜÊé•Êî∂Âà∞ÁöÑÊï∞ÊçÆ
                if packet.header.sequence_number == self.acknowledgment_number {
                    self.receive_buffer.extend_from_slice(&packet.data);
                    self.acknowledgment_number += packet.data.len() as u32;
                    
                    // ÂèëÈÄÅÁ°ÆËÆ§
                    let mut ack_packet = TCPPacket::new(
                        self.local_addr.port(),
                        self.remote_addr.port()
                    );
                    ack_packet.header.sequence_number = self.sequence_number;
                    ack_packet.header.acknowledgment_number = self.acknowledgment_number;
                    ack_packet.header.flags.ack = true;
                    
                    Ok(ack_packet)
                } else {
                    Err("Out of order packet".to_string())
                }
            },
            _ => Err("Connection not established".to_string()),
        }
    }
    
    pub fn handle_ack(&mut self, packet: &TCPPacket) -> Result<(), String> {
        // Â§ÑÁêÜÁ°ÆËÆ§ÔºåÁßªÈô§Â∑≤Á°ÆËÆ§ÁöÑÊÆµ
        let ack_number = packet.header.acknowledgment_number;
        self.unacked_segments.retain(|seq, _| *seq < ack_number);
        Ok(())
    }
    
    pub fn close(&mut self) -> Result<TCPPacket, String> {
        match self.state {
            TCPState::Established => {
                self.state = TCPState::FinWait1;
                
                let mut packet = TCPPacket::new(
                    self.local_addr.port(),
                    self.remote_addr.port()
                );
                packet.header.sequence_number = self.sequence_number;
                packet.header.acknowledgment_number = self.acknowledgment_number;
                packet.header.flags.fin = true;
                packet.header.flags.ack = true;
                
                Ok(packet)
            },
            _ => Err("Invalid state for close".to_string()),
        }
    }
    
    pub fn check_timeouts(&mut self) -> Vec<TCPPacket> {
        let mut retransmissions = Vec::new();
        let now = Instant::now();
        
        for (seq, (data, timestamp)) in &self.unacked_segments {
            if now.duration_since(*timestamp) > self.retransmission_timeout {
                let mut packet = TCPPacket::new(
                    self.local_addr.port(),
                    self.remote_addr.port()
                );
                packet.header.sequence_number = *seq;
                packet.header.acknowledgment_number = self.acknowledgment_number;
                packet.header.flags.ack = true;
                packet.data = data.clone();
                
                retransmissions.push(packet);
            }
        }
        
        retransmissions
    }
}
```

### 4.2 HTTPÂçèËÆÆÂÆûÁé∞

```rust
use std::collections::HashMap;

#[derive(Debug, Clone)]
pub enum HTTPMethod {
    GET,
    POST,
    PUT,
    DELETE,
    HEAD,
    OPTIONS,
}

#[derive(Debug, Clone)]
pub enum HTTPVersion {
    HTTP1_0,
    HTTP1_1,
    HTTP2_0,
}

#[derive(Debug, Clone)]
pub struct HTTPRequest {
    pub method: HTTPMethod,
    pub uri: String,
    pub version: HTTPVersion,
    pub headers: HashMap<String, String>,
    pub body: Vec<u8>,
}

#[derive(Debug, Clone)]
pub struct HTTPResponse {
    pub version: HTTPVersion,
    pub status_code: u16,
    pub status_text: String,
    pub headers: HashMap<String, String>,
    pub body: Vec<u8>,
}

impl HTTPRequest {
    pub fn new(method: HTTPMethod, uri: String) -> Self {
        HTTPRequest {
            method,
            uri,
            version: HTTPVersion::HTTP1_1,
            headers: HashMap::new(),
            body: Vec::new(),
        }
    }
    
    pub fn add_header(&mut self, key: String, value: String) {
        self.headers.insert(key, value);
    }
    
    pub fn set_body(&mut self, body: Vec<u8>) {
        self.body = body;
        self.add_header("Content-Length".to_string(), body.len().to_string());
    }
    
    pub fn serialize(&self) -> Vec<u8> {
        let mut buffer = Vec::new();
        
        // ËØ∑Ê±ÇË°å
        let method_str = match self.method {
            HTTPMethod::GET => "GET",
            HTTPMethod::POST => "POST",
            HTTPMethod::PUT => "PUT",
            HTTPMethod::DELETE => "DELETE",
            HTTPMethod::HEAD => "HEAD",
            HTTPMethod::OPTIONS => "OPTIONS",
        };
        
        let version_str = match self.version {
            HTTPVersion::HTTP1_0 => "HTTP/1.0",
            HTTPVersion::HTTP1_1 => "HTTP/1.1",
            HTTPVersion::HTTP2_0 => "HTTP/2.0",
        };
        
        let request_line = format!("{} {} {}\r\n", method_str, self.uri, version_str);
        buffer.extend_from_slice(request_line.as_bytes());
        
        // Â§¥ÈÉ®
        for (key, value) in &self.headers {
            let header_line = format!("{}: {}\r\n", key, value);
            buffer.extend_from_slice(header_line.as_bytes());
        }
        
        // Á©∫Ë°å
        buffer.extend_from_slice(b"\r\n");
        
        // ‰∏ª‰Ωì
        buffer.extend_from_slice(&self.body);
        
        buffer
    }
    
    pub fn deserialize(data: &[u8]) -> Result<Self, String> {
        let data_str = String::from_utf8_lossy(data);
        let lines: Vec<&str> = data_str.lines().collect();
        
        if lines.is_empty() {
            return Err("Empty request".to_string());
        }
        
        // Ëß£ÊûêËØ∑Ê±ÇË°å
        let request_line: Vec<&str> = lines[0].split_whitespace().collect();
        if request_line.len() != 3 {
            return Err("Invalid request line".to_string());
        }
        
        let method = match request_line[0] {
            "GET" => HTTPMethod::GET,
            "POST" => HTTPMethod::POST,
            "PUT" => HTTPMethod::PUT,
            "DELETE" => HTTPMethod::DELETE,
            "HEAD" => HTTPMethod::HEAD,
            "OPTIONS" => HTTPMethod::OPTIONS,
            _ => return Err("Unknown HTTP method".to_string()),
        };
        
        let uri = request_line[1].to_string();
        let version = match request_line[2] {
            "HTTP/1.0" => HTTPVersion::HTTP1_0,
            "HTTP/1.1" => HTTPVersion::HTTP1_1,
            "HTTP/2.0" => HTTPVersion::HTTP2_0,
            _ => return Err("Unknown HTTP version".to_string()),
        };
        
        let mut request = HTTPRequest {
            method,
            uri,
            version,
            headers: HashMap::new(),
            body: Vec::new(),
        };
        
        // Ëß£ÊûêÂ§¥ÈÉ®
        let mut i = 1;
        while i < lines.len() && !lines[i].is_empty() {
            if let Some(colon_pos) = lines[i].find(':') {
                let key = lines[i][..colon_pos].trim().to_string();
                let value = lines[i][colon_pos + 1..].trim().to_string();
                request.headers.insert(key, value);
            }
            i += 1;
        }
        
        // Ëß£Êûê‰∏ª‰Ωì
        if i + 1 < lines.len() {
            let body_start = data_str.find("\r\n\r\n").unwrap_or(0) + 4;
            if body_start < data.len() {
                request.body = data[body_start..].to_vec();
            }
        }
        
        Ok(request)
    }
}

impl HTTPResponse {
    pub fn new(status_code: u16, status_text: String) -> Self {
        HTTPResponse {
            version: HTTPVersion::HTTP1_1,
            status_code,
            status_text,
            headers: HashMap::new(),
            body: Vec::new(),
        }
    }
    
    pub fn add_header(&mut self, key: String, value: String) {
        self.headers.insert(key, value);
    }
    
    pub fn set_body(&mut self, body: Vec<u8>) {
        self.body = body.clone();
        self.add_header("Content-Length".to_string(), body.len().to_string());
    }
    
    pub fn serialize(&self) -> Vec<u8> {
        let mut buffer = Vec::new();
        
        // Áä∂ÊÄÅË°å
        let version_str = match self.version {
            HTTPVersion::HTTP1_0 => "HTTP/1.0",
            HTTPVersion::HTTP1_1 => "HTTP/1.1",
            HTTPVersion::HTTP2_0 => "HTTP/2.0",
        };
        
        let status_line = format!("{} {} {}\r\n", version_str, self.status_code, self.status_text);
        buffer.extend_from_slice(status_line.as_bytes());
        
        // Â§¥ÈÉ®
        for (key, value) in &self.headers {
            let header_line = format!("{}: {}\r\n", key, value);
            buffer.extend_from_slice(header_line.as_bytes());
        }
        
        // Á©∫Ë°å
        buffer.extend_from_slice(b"\r\n");
        
        // ‰∏ª‰Ωì
        buffer.extend_from_slice(&self.body);
        
        buffer
    }
    
    pub fn deserialize(data: &[u8]) -> Result<Self, String> {
        let data_str = String::from_utf8_lossy(data);
        let lines: Vec<&str> = data_str.lines().collect();
        
        if lines.is_empty() {
            return Err("Empty response".to_string());
        }
        
        // Ëß£ÊûêÁä∂ÊÄÅË°å
        let status_line: Vec<&str> = lines[0].split_whitespace().collect();
        if status_line.len() < 3 {
            return Err("Invalid status line".to_string());
        }
        
        let version = match status_line[0] {
            "HTTP/1.0" => HTTPVersion::HTTP1_0,
            "HTTP/1.1" => HTTPVersion::HTTP1_1,
            "HTTP/2.0" => HTTPVersion::HTTP2_0,
            _ => return Err("Unknown HTTP version".to_string()),
        };
        
        let status_code = status_line[1].parse::<u16>()
            .map_err(|_| "Invalid status code".to_string())?;
        let status_text = status_line[2..].join(" ");
        
        let mut response = HTTPResponse {
            version,
            status_code,
            status_text,
            headers: HashMap::new(),
            body: Vec::new(),
        };
        
        // Ëß£ÊûêÂ§¥ÈÉ®
        let mut i = 1;
        while i < lines.len() && !lines[i].is_empty() {
            if let Some(colon_pos) = lines[i].find(':') {
                let key = lines[i][..colon_pos].trim().to_string();
                let value = lines[i][colon_pos + 1..].trim().to_string();
                response.headers.insert(key, value);
            }
            i += 1;
        }
        
        // Ëß£Êûê‰∏ª‰Ωì
        if i + 1 < lines.len() {
            let body_start = data_str.find("\r\n\r\n").unwrap_or(0) + 4;
            if body_start < data.len() {
                response.body = data[body_start..].to_vec();
            }
        }
        
        Ok(response)
    }
}
```

### 4.3 ÂçèËÆÆÁä∂ÊÄÅÊú∫ÂÆûÁé∞

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ProtocolEvent {
    Connect,
    Disconnect,
    SendData,
    ReceiveData,
    Timeout,
    Error,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ProtocolState {
    Initial,
    Connecting,
    Connected,
    Disconnecting,
    Disconnected,
    Error,
}

#[derive(Debug, Clone)]
pub struct StateTransition {
    pub from_state: ProtocolState,
    pub event: ProtocolEvent,
    pub to_state: ProtocolState,
    pub action: Option<String>,
}

#[derive(Debug, Clone)]
pub struct ProtocolStateMachine {
    pub current_state: ProtocolState,
    pub transitions: HashMap<(ProtocolState, ProtocolEvent), StateTransition>,
    pub data: HashMap<String, String>,
}

impl ProtocolStateMachine {
    pub fn new() -> Self {
        let mut sm = ProtocolStateMachine {
            current_state: ProtocolState::Initial,
            transitions: HashMap::new(),
            data: HashMap::new(),
        };
        
        // ÂÆö‰πâÁä∂ÊÄÅËΩ¨Êç¢
        sm.add_transition(ProtocolState::Initial, ProtocolEvent::Connect, 
                         ProtocolState::Connecting, Some("Initiate connection".to_string()));
        sm.add_transition(ProtocolState::Connecting, ProtocolEvent::ReceiveData, 
                         ProtocolState::Connected, Some("Connection established".to_string()));
        sm.add_transition(ProtocolState::Connecting, ProtocolEvent::Error, 
                         ProtocolState::Error, Some("Connection failed".to_string()));
        sm.add_transition(ProtocolState::Connected, ProtocolEvent::SendData, 
                         ProtocolState::Connected, Some("Send data".to_string()));
        sm.add_transition(ProtocolState::Connected, ProtocolEvent::ReceiveData, 
                         ProtocolState::Connected, Some("Receive data".to_string()));
        sm.add_transition(ProtocolState::Connected, ProtocolEvent::Disconnect, 
                         ProtocolState::Disconnecting, Some("Initiate disconnect".to_string()));
        sm.add_transition(ProtocolState::Disconnecting, ProtocolEvent::ReceiveData, 
                         ProtocolState::Disconnected, Some("Disconnection complete".to_string()));
        sm.add_transition(ProtocolState::Error, ProtocolEvent::Connect, 
                         ProtocolState::Connecting, Some("Retry connection".to_string()));
        
        sm
    }
    
    pub fn add_transition(&mut self, from: ProtocolState, event: ProtocolEvent, 
                         to: ProtocolState, action: Option<String>) {
        let transition = StateTransition {
            from_state: from.clone(),
            event: event.clone(),
            to_state: to,
            action,
        };
        self.transitions.insert((from, event), transition);
    }
    
    pub fn process_event(&mut self, event: ProtocolEvent) -> Result<Option<String>, String> {
        let key = (self.current_state.clone(), event.clone());
        
        if let Some(transition) = self.transitions.get(&key) {
            let action = transition.action.clone();
            self.current_state = transition.to_state.clone();
            Ok(action)
        } else {
            Err(format!("Invalid transition from {:?} on event {:?}", 
                       self.current_state, event))
        }
    }
    
    pub fn get_current_state(&self) -> &ProtocolState {
        &self.current_state
    }
    
    pub fn is_connected(&self) -> bool {
        self.current_state == ProtocolState::Connected
    }
    
    pub fn is_error(&self) -> bool {
        self.current_state == ProtocolState::Error
    }
    
    pub fn set_data(&mut self, key: String, value: String) {
        self.data.insert(key, value);
    }
    
    pub fn get_data(&self, key: &str) -> Option<&String> {
        self.data.get(key)
    }
}

#[derive(Debug, Clone)]
pub struct ProtocolValidator {
    pub rules: Vec<ValidationRule>,
}

#[derive(Debug, Clone)]
pub struct ValidationRule {
    pub name: String,
    pub condition: String,
    pub message: String,
}

impl ProtocolValidator {
    pub fn new() -> Self {
        ProtocolValidator {
            rules: Vec::new(),
        }
    }
    
    pub fn add_rule(&mut self, name: String, condition: String, message: String) {
        self.rules.push(ValidationRule {
            name,
            condition,
            message,
        });
    }
    
    pub fn validate_packet(&self, packet: &[u8]) -> Vec<String> {
        let mut errors = Vec::new();
        
        // Âü∫Êú¨È™åËØÅËßÑÂàô
        if packet.is_empty() {
            errors.push("Packet is empty".to_string());
        }
        
        if packet.len() < 20 {
            errors.push("Packet too short".to_string());
        }
        
        // Ê£ÄÊü•Ê†°È™åÂíåÔºàÁÆÄÂåñÂÆûÁé∞Ôºâ
        if packet.len() >= 20 {
            let checksum = u16::from_be_bytes([packet[16], packet[17]]);
            if checksum != 0 {
                // ËøôÈáåÂ∫îËØ•ËÆ°ÁÆóÂÆûÈôÖÁöÑÊ†°È™åÂíå
                // errors.push("Invalid checksum".to_string());
            }
        }
        
        errors
    }
    
    pub fn validate_state_transition(&self, from: &ProtocolState, 
                                   event: &ProtocolEvent, to: &ProtocolState) -> Vec<String> {
        let mut errors = Vec::new();
        
        // Áä∂ÊÄÅËΩ¨Êç¢È™åËØÅËßÑÂàô
        if from == &ProtocolState::Disconnected && event == &ProtocolEvent::SendData {
            errors.push("Cannot send data in disconnected state".to_string());
        }
        
        if from == &ProtocolState::Initial && event == &ProtocolEvent::Disconnect {
            errors.push("Cannot disconnect from initial state".to_string());
        }
        
        errors
    }
}
```

## 5. Áõ∏ÂÖ≥ÁêÜËÆ∫‰∏é‰∫§ÂèâÂºïÁî®

- [ÁΩëÁªúÊû∂ÊûÑÁêÜËÆ∫](../01_Network_Architecture/01_Network_Architecture_Theory.md)
- [ÁΩëÁªúÂÆâÂÖ®ÁêÜËÆ∫](../03_Network_Security/01_Network_Security_Theory.md)
- [ÂàÜÂ∏ÉÂºèÁ≥ªÁªüÁêÜËÆ∫](../04_Distributed_Systems/01_Distributed_Systems_Theory.md)

## 6. ÂèÇËÄÉÊñáÁåÆ

1. Stevens, W. R. (1994). TCP/IP Illustrated, Volume 1: The Protocols. Addison-Wesley.
2. Fielding, R., & Reschke, J. (2014). Hypertext Transfer Protocol (HTTP/1.1): Authentication. RFC 7235.
3. Postel, J. (1981). Transmission Control Protocol. RFC 793.

---

**ÊúÄÂêéÊõ¥Êñ∞**: 2024Âπ¥12Êúà21Êó•  
**Áª¥Êä§ËÄÖ**: AIÂä©Êâã  
**ÁâàÊú¨**: v1.0

## ÊâπÂà§ÊÄßÂàÜÊûê

- Êú¨ËäÇÂÜÖÂÆπÂæÖË°•ÂÖÖÔºöËØ∑‰ªéÂ§öÂÖÉÁêÜËÆ∫ËßÜËßí„ÄÅÂ±ÄÈôêÊÄß„ÄÅ‰∫âËÆÆÁÇπ„ÄÅÂ∫îÁî®ÂâçÊôØÁ≠âÊñπÈù¢ËøõË°åÊâπÂà§ÊÄßÂàÜÊûê„ÄÇ
