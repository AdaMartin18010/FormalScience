# 11.1 ç½‘ç»œç®¡ç†åŸºç¡€ç†è®º

## ç›®å½•

- [11.1 ç½‘ç»œç®¡ç†åŸºç¡€ç†è®º](#111-ç½‘ç»œç®¡ç†åŸºç¡€ç†è®º)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 ç½‘ç»œç®¡ç†å®šä¹‰](#11-ç½‘ç»œç®¡ç†å®šä¹‰)
    - [1.2 ç®¡ç†åŠŸèƒ½åˆ†ç±»](#12-ç®¡ç†åŠŸèƒ½åˆ†ç±»)
  - [2. å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
    - [2.1 ç½‘ç»œæ‹“æ‰‘æ¨¡å‹](#21-ç½‘ç»œæ‹“æ‰‘æ¨¡å‹)
    - [2.2 ç®¡ç†ä¿¡æ¯æ¨¡å‹](#22-ç®¡ç†ä¿¡æ¯æ¨¡å‹)
    - [2.3 é…ç½®ç®¡ç†æ¨¡å‹](#23-é…ç½®ç®¡ç†æ¨¡å‹)
  - [3. å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
    - [3.1 ç½‘ç»œå¯è¾¾æ€§å®šç†](#31-ç½‘ç»œå¯è¾¾æ€§å®šç†)
    - [3.2 ç®¡ç†ä¿¡æ¯å®Œæ•´æ€§å®šç†](#32-ç®¡ç†ä¿¡æ¯å®Œæ•´æ€§å®šç†)
  - [4. Rustä»£ç å®ç°](#4-rustä»£ç å®ç°)
    - [4.1 ç½‘ç»œæ‹“æ‰‘ç®¡ç†å™¨](#41-ç½‘ç»œæ‹“æ‰‘ç®¡ç†å™¨)
    - [4.2 é…ç½®ç®¡ç†ç³»ç»Ÿ](#42-é…ç½®ç®¡ç†ç³»ç»Ÿ)
    - [4.3 ç›‘æ§ä»£ç†å®ç°](#43-ç›‘æ§ä»£ç†å®ç°)
  - [5. ç›¸å…³ç†è®ºä¸äº¤å‰å¼•ç”¨](#5-ç›¸å…³ç†è®ºä¸äº¤å‰å¼•ç”¨)
  - [6. å‚è€ƒæ–‡çŒ®](#6-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)
    - [ä¸»è¦ç†è®ºè§‚ç‚¹æ¢³ç†](#ä¸»è¦ç†è®ºè§‚ç‚¹æ¢³ç†)
    - [ç†è®ºä¼˜åŠ¿ä¸å±€é™æ€§](#ç†è®ºä¼˜åŠ¿ä¸å±€é™æ€§)
    - [å­¦ç§‘äº¤å‰èåˆ](#å­¦ç§‘äº¤å‰èåˆ)
    - [åˆ›æ–°æ‰¹åˆ¤ä¸æœªæ¥å±•æœ›](#åˆ›æ–°æ‰¹åˆ¤ä¸æœªæ¥å±•æœ›)
    - [å‚è€ƒæ–‡çŒ®](#å‚è€ƒæ–‡çŒ®)

## ğŸ“‹ æ¦‚è¿°

ç½‘ç»œç®¡ç†åŸºç¡€ç†è®ºç ”ç©¶è®¡ç®—æœºç½‘ç»œçš„ç®¡ç†ã€ç›‘æ§å’Œé…ç½®æ–¹æ³•ã€‚
è¯¥ç†è®ºæ¶µç›–ç½‘ç»œæ‹“æ‰‘ã€é…ç½®ç®¡ç†ã€æ€§èƒ½ç›‘æ§ç­‰æ ¸å¿ƒæ¦‚å¿µï¼Œä¸ºç½‘ç»œç³»ç»Ÿç®¡ç†æä¾›ç†è®ºåŸºç¡€ã€‚

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 ç½‘ç»œç®¡ç†å®šä¹‰

**å®šä¹‰ 1.1**ï¼ˆç½‘ç»œç®¡ç†ï¼‰
ç½‘ç»œç®¡ç†æ˜¯å¯¹è®¡ç®—æœºç½‘ç»œè¿›è¡Œè§„åˆ’ã€è®¾è®¡ã€å®æ–½ã€ç›‘æ§å’Œç»´æŠ¤çš„ç³»ç»Ÿæ€§æ´»åŠ¨ã€‚

### 1.2 ç®¡ç†åŠŸèƒ½åˆ†ç±»

| åŠŸèƒ½ç±»å‹     | è‹±æ–‡åç§°         | æè¿°                         | å…¸å‹åº”ç”¨         |
|--------------|------------------|------------------------------|------------------|
| é…ç½®ç®¡ç†     | Configuration    | ç½‘ç»œè®¾å¤‡å’ŒæœåŠ¡çš„é…ç½®ç®¡ç†     | SNMP, NETCONF    |
| æ•…éšœç®¡ç†     | Fault Management | ç½‘ç»œæ•…éšœçš„æ£€æµ‹å’Œå¤„ç†         | å‘Šè­¦ç³»ç»Ÿ         |
| æ€§èƒ½ç®¡ç†     | Performance      | ç½‘ç»œæ€§èƒ½çš„ç›‘æ§å’Œä¼˜åŒ–         | æ€§èƒ½åˆ†æå·¥å…·     |
| å®‰å…¨ç®¡ç†     | Security         | ç½‘ç»œå®‰å…¨ç­–ç•¥çš„å®æ–½           | é˜²ç«å¢™ç®¡ç†       |
| è®¡è´¹ç®¡ç†     | Accounting       | ç½‘ç»œèµ„æºä½¿ç”¨çš„è®¡è´¹           | æµé‡ç»Ÿè®¡         |

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ç½‘ç»œæ‹“æ‰‘æ¨¡å‹

**å®šä¹‰ 2.1**ï¼ˆç½‘ç»œæ‹“æ‰‘ï¼‰
ç½‘ç»œæ‹“æ‰‘æ˜¯ç½‘ç»œèŠ‚ç‚¹å’Œé“¾è·¯çš„è¿æ¥å…³ç³»å›¾G = (V, E)ï¼Œå…¶ä¸­Væ˜¯èŠ‚ç‚¹é›†åˆï¼ŒEæ˜¯é“¾è·¯é›†åˆã€‚

**å®šä¹‰ 2.2**ï¼ˆç½‘ç»œè¿é€šæ€§ï¼‰
ç½‘ç»œè¿é€šæ€§æ˜¯æŒ‡ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´å­˜åœ¨è·¯å¾„çš„æ€§è´¨ã€‚

**å®šä¹‰ 2.3**ï¼ˆç½‘ç»œå¯é æ€§ï¼‰
ç½‘ç»œå¯é æ€§æ˜¯ç½‘ç»œåœ¨æ•…éšœæƒ…å†µä¸‹ä¿æŒè¿é€šæ€§çš„èƒ½åŠ›ã€‚

### 2.2 ç®¡ç†ä¿¡æ¯æ¨¡å‹

**å®šä¹‰ 2.4**ï¼ˆç®¡ç†ä¿¡æ¯åº“ï¼‰
ç®¡ç†ä¿¡æ¯åº“(MIB)æ˜¯ç½‘ç»œç®¡ç†ä¿¡æ¯çš„ç»“æ„åŒ–å­˜å‚¨ã€‚

**å®šä¹‰ 2.5**ï¼ˆç®¡ç†å¯¹è±¡ï¼‰
ç®¡ç†å¯¹è±¡æ˜¯ç½‘ç»œä¸­è¢«ç®¡ç†çš„å®ä½“ï¼Œå…·æœ‰å±æ€§å’Œæ“ä½œã€‚

**å®šä¹‰ 2.6**ï¼ˆç®¡ç†åè®®ï¼‰
ç®¡ç†åè®®æ˜¯ç½‘ç»œç®¡ç†å®ä½“é—´é€šä¿¡çš„è§„åˆ™å’Œæ ¼å¼ã€‚

### 2.3 é…ç½®ç®¡ç†æ¨¡å‹

**å®šä¹‰ 2.7**ï¼ˆé…ç½®é¡¹ï¼‰
é…ç½®é¡¹æ˜¯ç½‘ç»œä¸­è¢«ç®¡ç†çš„é…ç½®å•å…ƒã€‚

**å®šä¹‰ 2.8**ï¼ˆé…ç½®ç‰ˆæœ¬ï¼‰
é…ç½®ç‰ˆæœ¬æ˜¯é…ç½®é¡¹åœ¨æ—¶é—´è½´ä¸Šçš„çŠ¶æ€å¿«ç…§ã€‚

**å®šä¹‰ 2.9**ï¼ˆé…ç½®ä¸€è‡´æ€§ï¼‰
é…ç½®ä¸€è‡´æ€§æ˜¯ç½‘ç»œé…ç½®æ»¡è¶³ä¸šåŠ¡éœ€æ±‚çš„ç¨‹åº¦ã€‚

## 3. å®šç†ä¸è¯æ˜

### 3.1 ç½‘ç»œå¯è¾¾æ€§å®šç†

**å®šç† 3.1**ï¼ˆç½‘ç»œå¯è¾¾æ€§ï¼‰
å¦‚æœç½‘ç»œæ‹“æ‰‘å›¾Gæ˜¯è¿é€šçš„ï¼Œåˆ™ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´éƒ½å­˜åœ¨è·¯å¾„ã€‚

**è¯æ˜**ï¼š
è®¾ç½‘ç»œæ‹“æ‰‘å›¾G = (V, E)æ˜¯è¿é€šçš„ï¼Œå¯¹äºä»»æ„èŠ‚ç‚¹u, v âˆˆ Vï¼Œç”±äºGè¿é€šï¼Œå­˜åœ¨ä»uåˆ°vçš„è·¯å¾„Pã€‚
è·¯å¾„Pç”±ä¸€ç³»åˆ—è¾¹ç»„æˆï¼šP = (u, vâ‚), (vâ‚, vâ‚‚), ..., (vâ‚–, v)ã€‚
å› æ­¤ï¼ŒèŠ‚ç‚¹uå’Œvä¹‹é—´æ˜¯å¯è¾¾çš„ã€‚â–¡

### 3.2 ç®¡ç†ä¿¡æ¯å®Œæ•´æ€§å®šç†

**å®šç† 3.2**ï¼ˆç®¡ç†ä¿¡æ¯å®Œæ•´æ€§ï¼‰
å¦‚æœç®¡ç†ä¿¡æ¯åº“MIBæ»¡è¶³å®Œæ•´æ€§çº¦æŸï¼Œåˆ™ç®¡ç†æ“ä½œä¸ä¼šç ´åæ•°æ®ä¸€è‡´æ€§ã€‚

**è¯æ˜**ï¼š
è®¾MIBåŒ…å«å¯¹è±¡Oâ‚, Oâ‚‚, ..., Oâ‚™ï¼Œæ¯ä¸ªå¯¹è±¡Oáµ¢éƒ½æœ‰å®Œæ•´æ€§çº¦æŸCáµ¢ã€‚
å¯¹äºä»»æ„ç®¡ç†æ“ä½œopï¼Œå¦‚æœopæ»¡è¶³æ‰€æœ‰çº¦æŸCáµ¢ï¼Œåˆ™æ“ä½œåMIBä»ç„¶æ»¡è¶³å®Œæ•´æ€§çº¦æŸã€‚
å› æ­¤ï¼Œç®¡ç†ä¿¡æ¯ä¿æŒä¸€è‡´æ€§ã€‚â–¡

## 4. Rustä»£ç å®ç°

### 4.1 ç½‘ç»œæ‹“æ‰‘ç®¡ç†å™¨

```rust
use std::collections::{HashMap, HashSet};
use std::sync::{Arc, Mutex};

#[derive(Debug, Clone)]
pub struct NetworkNode {
    pub id: String,
    pub name: String,
    pub node_type: NodeType,
    pub interfaces: Vec<Interface>,
    pub status: NodeStatus,
}

#[derive(Debug, Clone)]
pub enum NodeType {
    Router,
    Switch,
    Host,
    Server,
}

#[derive(Debug, Clone)]
pub struct Interface {
    pub id: String,
    pub name: String,
    pub ip_address: String,
    pub subnet_mask: String,
    pub status: InterfaceStatus,
}

#[derive(Debug, Clone)]
pub enum NodeStatus {
    Online,
    Offline,
    Maintenance,
}

#[derive(Debug, Clone)]
pub enum InterfaceStatus {
    Up,
    Down,
    Testing,
}

#[derive(Debug, Clone)]
pub struct NetworkLink {
    pub id: String,
    pub source_node: String,
    pub target_node: String,
    pub bandwidth: u64,
    pub status: LinkStatus,
}

#[derive(Debug, Clone)]
pub enum LinkStatus {
    Active,
    Inactive,
    Degraded,
}

#[derive(Debug)]
pub struct NetworkTopology {
    pub nodes: HashMap<String, NetworkNode>,
    pub links: HashMap<String, NetworkLink>,
    pub adjacency_matrix: Arc<Mutex<HashMap<String, HashSet<String>>>>,
}

impl NetworkTopology {
    pub fn new() -> Self {
        NetworkTopology {
            nodes: HashMap::new(),
            links: HashMap::new(),
            adjacency_matrix: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    pub fn add_node(&mut self, node: NetworkNode) -> Result<(), String> {
        if self.nodes.contains_key(&node.id) {
            return Err(format!("Node '{}' already exists", node.id));
        }
        
        self.nodes.insert(node.id.clone(), node);
        self.update_adjacency_matrix();
        Ok(())
    }
    
    pub fn add_link(&mut self, link: NetworkLink) -> Result<(), String> {
        if self.links.contains_key(&link.id) {
            return Err(format!("Link '{}' already exists", link.id));
        }
        
        // éªŒè¯æºèŠ‚ç‚¹å’Œç›®æ ‡èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨
        if !self.nodes.contains_key(&link.source_node) {
            return Err(format!("Source node '{}' not found", link.source_node));
        }
        if !self.nodes.contains_key(&link.target_node) {
            return Err(format!("Target node '{}' not found", link.target_node));
        }
        
        self.links.insert(link.id.clone(), link);
        self.update_adjacency_matrix();
        Ok(())
    }
    
    pub fn is_connected(&self) -> bool {
        if self.nodes.is_empty() {
            return true;
        }
        
        let mut visited = HashSet::new();
        let start_node = self.nodes.keys().next().unwrap();
        self.dfs(start_node, &mut visited);
        
        visited.len() == self.nodes.len()
    }
    
    fn dfs(&self, node_id: &str, visited: &mut HashSet<String>) {
        visited.insert(node_id.to_string());
        
        if let Some(adjacent) = self.adjacency_matrix.lock().unwrap().get(node_id) {
            for neighbor in adjacent {
                if !visited.contains(neighbor) {
                    self.dfs(neighbor, visited);
                }
            }
        }
    }
    
    pub fn find_path(&self, source: &str, target: &str) -> Option<Vec<String>> {
        if !self.nodes.contains_key(source) || !self.nodes.contains_key(target) {
            return None;
        }
        
        let mut queue = std::collections::VecDeque::new();
        let mut visited = HashSet::new();
        let mut parent = HashMap::new();
        
        queue.push_back(source.to_string());
        visited.insert(source.to_string());
        
        while let Some(current) = queue.pop_front() {
            if current == target {
                return Some(self.reconstruct_path(&parent, source, target));
            }
            
            if let Some(adjacent) = self.adjacency_matrix.lock().unwrap().get(&current) {
                for neighbor in adjacent {
                    if !visited.contains(neighbor) {
                        visited.insert(neighbor.clone());
                        parent.insert(neighbor.clone(), current.clone());
                        queue.push_back(neighbor.clone());
                    }
                }
            }
        }
        
        None
    }
    
    fn reconstruct_path(&self, parent: &HashMap<String, String>, source: &str, target: &str) -> Vec<String> {
        let mut path = Vec::new();
        let mut current = target.to_string();
        
        while current != source {
            path.push(current.clone());
            current = parent.get(&current).unwrap().clone();
        }
        path.push(source.to_string());
        path.reverse();
        path
    }
    
    fn update_adjacency_matrix(&mut self) {
        let mut adjacency = HashMap::new();
        
        for link in self.links.values() {
            if link.status == LinkStatus::Active {
                adjacency.entry(link.source_node.clone())
                    .or_insert_with(HashSet::new)
                    .insert(link.target_node.clone());
                adjacency.entry(link.target_node.clone())
                    .or_insert_with(HashSet::new)
                    .insert(link.source_node.clone());
            }
        }
        
        *self.adjacency_matrix.lock().unwrap() = adjacency;
    }
}
```

### 4.2 é…ç½®ç®¡ç†ç³»ç»Ÿ

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConfigurationItem {
    pub id: String,
    pub name: String,
    pub category: String,
    pub parameters: HashMap<String, String>,
    pub version: u32,
    pub created_at: u64,
    pub modified_at: u64,
}

#[derive(Debug, Clone)]
pub struct ConfigurationVersion {
    pub version_id: String,
    pub items: HashMap<String, ConfigurationItem>,
    pub description: String,
    pub created_at: u64,
    pub is_active: bool,
}

#[derive(Debug)]
pub struct ConfigurationManager {
    pub versions: HashMap<String, ConfigurationVersion>,
    pub current_version: String,
    pub items: Arc<Mutex<HashMap<String, ConfigurationItem>>>,
}

impl ConfigurationManager {
    pub fn new() -> Self {
        let initial_version = ConfigurationVersion {
            version_id: "v1.0".to_string(),
            items: HashMap::new(),
            description: "Initial configuration".to_string(),
            created_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            is_active: true,
        };
        
        ConfigurationManager {
            versions: HashMap::new(),
            current_version: "v1.0".to_string(),
            items: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    pub fn add_configuration_item(&mut self, item: ConfigurationItem) -> Result<(), String> {
        let mut items = self.items.lock().unwrap();
        
        if items.contains_key(&item.id) {
            return Err(format!("Configuration item '{}' already exists", item.id));
        }
        
        items.insert(item.id.clone(), item);
        Ok(())
    }
    
    pub fn update_configuration_item(&mut self, item: ConfigurationItem) -> Result<(), String> {
        let mut items = self.items.lock().unwrap();
        
        if !items.contains_key(&item.id) {
            return Err(format!("Configuration item '{}' not found", item.id));
        }
        
        items.insert(item.id.clone(), item);
        Ok(())
    }
    
    pub fn create_version(&mut self, version_id: String, description: String) -> Result<(), String> {
        if self.versions.contains_key(&version_id) {
            return Err(format!("Version '{}' already exists", version_id));
        }
        
        let items = self.items.lock().unwrap();
        let version = ConfigurationVersion {
            version_id: version_id.clone(),
            items: items.clone(),
            description,
            created_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            is_active: false,
        };
        
        self.versions.insert(version_id, version);
        Ok(())
    }
    
    pub fn activate_version(&mut self, version_id: &str) -> Result<(), String> {
        if !self.versions.contains_key(version_id) {
            return Err(format!("Version '{}' not found", version_id));
        }
        
        // åœç”¨å½“å‰ç‰ˆæœ¬
        if let Some(current) = self.versions.get_mut(&self.current_version) {
            current.is_active = false;
        }
        
        // æ¿€æ´»æ–°ç‰ˆæœ¬
        if let Some(new_version) = self.versions.get_mut(version_id) {
            new_version.is_active = true;
            self.current_version = version_id.to_string();
            
            // æ›´æ–°å½“å‰é…ç½®é¡¹
            let mut items = self.items.lock().unwrap();
            *items = new_version.items.clone();
        }
        
        Ok(())
    }
    
    pub fn rollback_to_version(&mut self, version_id: &str) -> Result<(), String> {
        self.activate_version(version_id)
    }
    
    pub fn validate_configuration(&self) -> Vec<String> {
        let mut errors = Vec::new();
        let items = self.items.lock().unwrap();
        
        for (id, item) in items.iter() {
            // æ£€æŸ¥å¿…éœ€å‚æ•°
            if item.parameters.is_empty() {
                errors.push(format!("Configuration item '{}' has no parameters", id));
            }
            
            // æ£€æŸ¥å‚æ•°æ ¼å¼
            for (param_name, param_value) in &item.parameters {
                if param_value.is_empty() {
                    errors.push(format!("Parameter '{}' in item '{}' is empty", param_name, id));
                }
            }
        }
        
        errors
    }
}
```

### 4.3 ç›‘æ§ä»£ç†å®ç°

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

#[derive(Debug, Clone)]
pub struct MonitoringAgent {
    pub agent_id: String,
    pub node_id: String,
    pub metrics: Arc<Mutex<HashMap<String, MetricValue>>>,
    pub alerts: Arc<Mutex<Vec<Alert>>>,
    pub config: AgentConfig,
}

#[derive(Debug, Clone)]
pub struct MetricValue {
    pub value: f64,
    pub timestamp: u64,
    pub unit: String,
}

#[derive(Debug, Clone)]
pub struct Alert {
    pub id: String,
    pub severity: AlertSeverity,
    pub message: String,
    pub metric_name: String,
    pub threshold: f64,
    pub current_value: f64,
    pub timestamp: u64,
}

#[derive(Debug, Clone)]
pub enum AlertSeverity {
    Info,
    Warning,
    Critical,
}

#[derive(Debug, Clone)]
pub struct AgentConfig {
    pub collection_interval: Duration,
    pub alert_thresholds: HashMap<String, f64>,
    pub enabled_metrics: Vec<String>,
}

impl MonitoringAgent {
    pub fn new(agent_id: String, node_id: String) -> Self {
        MonitoringAgent {
            agent_id,
            node_id,
            metrics: Arc::new(Mutex::new(HashMap::new())),
            alerts: Arc::new(Mutex::new(Vec::new())),
            config: AgentConfig {
                collection_interval: Duration::from_secs(60),
                alert_thresholds: HashMap::new(),
                enabled_metrics: vec![
                    "cpu_usage".to_string(),
                    "memory_usage".to_string(),
                    "network_throughput".to_string(),
                ],
            },
        }
    }
    
    pub fn collect_metrics(&self) -> Result<(), String> {
        let mut metrics = self.metrics.lock().unwrap();
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();
        
        // æ¨¡æ‹Ÿæ”¶é›†CPUä½¿ç”¨ç‡
        let cpu_usage = self.simulate_cpu_usage();
        metrics.insert("cpu_usage".to_string(), MetricValue {
            value: cpu_usage,
            timestamp,
            unit: "%".to_string(),
        });
        
        // æ¨¡æ‹Ÿæ”¶é›†å†…å­˜ä½¿ç”¨ç‡
        let memory_usage = self.simulate_memory_usage();
        metrics.insert("memory_usage".to_string(), MetricValue {
            value: memory_usage,
            timestamp,
            unit: "%".to_string(),
        });
        
        // æ¨¡æ‹Ÿæ”¶é›†ç½‘ç»œååé‡
        let network_throughput = self.simulate_network_throughput();
        metrics.insert("network_throughput".to_string(), MetricValue {
            value: network_throughput,
            timestamp,
            unit: "Mbps".to_string(),
        });
        
        // æ£€æŸ¥å‘Šè­¦æ¡ä»¶
        self.check_alerts();
        
        Ok(())
    }
    
    fn simulate_cpu_usage(&self) -> f64 {
        // æ¨¡æ‹ŸCPUä½¿ç”¨ç‡ï¼Œå®é™…å®ç°ä¸­åº”è¯¥ä»ç³»ç»Ÿè·å–
        use rand::Rng;
        let mut rng = rand::thread_rng();
        rng.gen_range(10.0..90.0)
    }
    
    fn simulate_memory_usage(&self) -> f64 {
        // æ¨¡æ‹Ÿå†…å­˜ä½¿ç”¨ç‡
        use rand::Rng;
        let mut rng = rand::thread_rng();
        rng.gen_range(20.0..95.0)
    }
    
    fn simulate_network_throughput(&self) -> f64 {
        // æ¨¡æ‹Ÿç½‘ç»œååé‡
        use rand::Rng;
        let mut rng = rand::thread_rng();
        rng.gen_range(10.0..1000.0)
    }
    
    fn check_alerts(&self) {
        let metrics = self.metrics.lock().unwrap();
        let mut alerts = self.alerts.lock().unwrap();
        
        for (metric_name, threshold) in &self.config.alert_thresholds {
            if let Some(metric) = metrics.get(metric_name) {
                if metric.value > *threshold {
                    let alert = Alert {
                        id: format!("alert_{}", alerts.len() + 1),
                        severity: AlertSeverity::Warning,
                        message: format!("Metric '{}' exceeded threshold: {} > {}", 
                                       metric_name, metric.value, threshold),
                        metric_name: metric_name.clone(),
                        threshold: *threshold,
                        current_value: metric.value,
                        timestamp: metric.timestamp,
                    };
                    alerts.push(alert);
                }
            }
        }
    }
    
    pub fn get_metrics(&self) -> HashMap<String, MetricValue> {
        self.metrics.lock().unwrap().clone()
    }
    
    pub fn get_alerts(&self) -> Vec<Alert> {
        self.alerts.lock().unwrap().clone()
    }
    
    pub fn set_threshold(&mut self, metric_name: String, threshold: f64) {
        self.config.alert_thresholds.insert(metric_name, threshold);
    }
    
    pub fn start_monitoring(&self) {
        let agent = self.clone();
        std::thread::spawn(move || {
            loop {
                if let Err(e) = agent.collect_metrics() {
                    eprintln!("Error collecting metrics: {}", e);
                }
                std::thread::sleep(agent.config.collection_interval);
            }
        });
    }
}
```

## 5. ç›¸å…³ç†è®ºä¸äº¤å‰å¼•ç”¨

- **æ•°å­¦åŸºç¡€**ï¼šå›¾è®ºã€ç»Ÿè®¡å­¦åœ¨ç½‘ç»œç®¡ç†ä¸­çš„åº”ç”¨
- **å½¢å¼è¯­è¨€ç†è®º**ï¼šç®¡ç†åè®®çš„å½¢å¼åŒ–æè¿°
- **ç±»å‹ç†è®º**ï¼šç½‘ç»œç®¡ç†ç³»ç»Ÿçš„ç±»å‹å®‰å…¨ä¿è¯
- **æ§åˆ¶è®º**ï¼šç½‘ç»œç®¡ç†çš„åé¦ˆæ§åˆ¶æœºåˆ¶
- **äººå·¥æ™ºèƒ½ç†è®º**ï¼šæ™ºèƒ½åŒ–çš„ç½‘ç»œç®¡ç†å’Œä¼˜åŒ–

## 6. å‚è€ƒæ–‡çŒ®

1. Stallings, W. (2015). "Network management: Principles and practice"
2. Subramanian, M. (2000). "Network management: Principles and practice"
3. Clemm, A. (2007). "Network management fundamentals"
4. Harrington, D., Presuhn, R., & Wijnen, B. (2002). "An architecture for describing simple network management protocol (SNMP) management frameworks"

## æ‰¹åˆ¤æ€§åˆ†æ

### ä¸»è¦ç†è®ºè§‚ç‚¹æ¢³ç†

ç½‘ç»œç®¡ç†åŸºç¡€ç†è®ºå…³æ³¨ç½‘ç»œç³»ç»Ÿçš„ç›‘æ§ã€é…ç½®å’Œç»´æŠ¤ï¼Œæ˜¯æ„å»ºå¯é ç½‘ç»œåŸºç¡€è®¾æ–½çš„é‡è¦åŸºç¡€ã€‚

### ç†è®ºä¼˜åŠ¿ä¸å±€é™æ€§

**ä¼˜åŠ¿**ï¼š
- æä¾›äº†ç³»ç»ŸåŒ–çš„ç½‘ç»œç®¡ç†æ–¹æ³•
- å»ºç«‹äº†å®Œæ•´çš„ç›‘æ§å’Œé…ç½®ä½“ç³»
- æ”¯æŒå¤§è§„æ¨¡ç½‘ç»œç³»ç»Ÿçš„ç®¡ç†

**å±€é™æ€§**ï¼š
- ç½‘ç»œå¤æ‚æ€§çš„ç®¡ç†æŒ‘æˆ˜
- å®‰å…¨å¨èƒçš„å¤šæ ·æ€§
- å¯¹æ–°å…´æŠ€æœ¯çš„é€‚åº”æ€§éœ€æ±‚

### å­¦ç§‘äº¤å‰èåˆ

- ä¸æ•°å­¦åŸºç¡€åœ¨å›¾è®ºã€ç»Ÿè®¡å­¦ç­‰é¢†åŸŸæœ‰æ·±å…¥åº”ç”¨
- ä¸å½¢å¼è¯­è¨€ç†è®ºåœ¨åè®®è®¾è®¡ã€è¯­ä¹‰åˆ†æç­‰æ–¹é¢æœ‰åˆ›æ–°åº”ç”¨
- ä¸äººå·¥æ™ºèƒ½ç†è®ºåœ¨æ™ºèƒ½ç®¡ç†ã€è‡ªåŠ¨ä¼˜åŒ–ç­‰æ–¹é¢æœ‰æ–°å…´èåˆ
- ä¸æ§åˆ¶è®ºåœ¨åé¦ˆæ§åˆ¶ã€è‡ªé€‚åº”ç®¡ç†ç­‰æ–¹é¢äº’è¡¥

### åˆ›æ–°æ‰¹åˆ¤ä¸æœªæ¥å±•æœ›

æœªæ¥ç½‘ç»œç®¡ç†åŸºç¡€ç†è®ºéœ€åŠ å¼ºä¸AIã€æœºå™¨å­¦ä¹ ã€è‡ªåŠ¨åŒ–ç­‰é¢†åŸŸçš„èåˆï¼Œæ¨åŠ¨æ™ºèƒ½åŒ–ã€è‡ªé€‚åº”çš„ç½‘ç»œç®¡ç†ç³»ç»Ÿã€‚

### å‚è€ƒæ–‡çŒ®

- äº¤å‰ç´¢å¼•.md
- Meta/æ‰¹åˆ¤æ€§åˆ†ææ¨¡æ¿.md
