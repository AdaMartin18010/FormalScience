# 05.2.2 æœ€ä¼˜æ§åˆ¶ç†è®º

## ğŸ“‹ æ¦‚è¿°

æœ€ä¼˜æ§åˆ¶ç†è®ºæ˜¯ç°ä»£æ§åˆ¶ç†è®ºçš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶å¦‚ä½•è®¾è®¡æ§åˆ¶å¾‹ä½¿å¾—ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡è¾¾åˆ°æœ€ä¼˜ã€‚æœ€ä¼˜æ§åˆ¶ç†è®ºä¸ºå¤æ‚ç³»ç»Ÿçš„æ§åˆ¶è®¾è®¡æä¾›äº†ä¸¥æ ¼çš„æ•°å­¦åŸºç¡€ï¼Œå¹¿æ³›åº”ç”¨äºèˆªç©ºèˆªå¤©ã€æœºå™¨äººã€ç»æµç³»ç»Ÿç­‰é¢†åŸŸã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **æ€§èƒ½æŒ‡æ ‡ä¼˜åŒ–**ï¼šæœ€å°åŒ–æˆ–æœ€å¤§åŒ–ç‰¹å®šçš„æ€§èƒ½æŒ‡æ ‡
2. **çº¦æŸæ¡ä»¶å¤„ç†**ï¼šåœ¨ç³»ç»Ÿçº¦æŸä¸‹å¯»æ‰¾æœ€ä¼˜è§£
3. **åŠ¨æ€ä¼˜åŒ–**ï¼šå¤„ç†æ—¶å˜ç³»ç»Ÿçš„ä¼˜åŒ–é—®é¢˜
4. **æ•°å€¼ç®—æ³•**ï¼šæä¾›æœ‰æ•ˆçš„æ•°å€¼æ±‚è§£æ–¹æ³•

## ğŸ“š ç›®å½•

- [05.2.2 æœ€ä¼˜æ§åˆ¶ç†è®º](#0522-æœ€ä¼˜æ§åˆ¶ç†è®º)
  - [ğŸ“‹ æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ æ ¸å¿ƒç›®æ ‡](#-æ ¸å¿ƒç›®æ ‡)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 æœ€ä¼˜æ§åˆ¶é—®é¢˜](#11-æœ€ä¼˜æ§åˆ¶é—®é¢˜)
    - [1.2 æ€§èƒ½æŒ‡æ ‡åˆ†ç±»](#12-æ€§èƒ½æŒ‡æ ‡åˆ†ç±»)
    - [1.3 æœ€ä¼˜æ€§æ¡ä»¶](#13-æœ€ä¼˜æ€§æ¡ä»¶)
  - [2. å˜åˆ†æ³•åŸºç¡€](#2-å˜åˆ†æ³•åŸºç¡€)
    - [2.1 æ¬§æ‹‰-æ‹‰æ ¼æœ—æ—¥æ–¹ç¨‹](#21-æ¬§æ‹‰-æ‹‰æ ¼æœ—æ—¥æ–¹ç¨‹)
    - [2.2 æ¨ªæˆªæ¡ä»¶](#22-æ¨ªæˆªæ¡ä»¶)
    - [2.3 çº¦æŸå˜åˆ†æ³•](#23-çº¦æŸå˜åˆ†æ³•)
  - [3. æå¤§å€¼åŸç†](#3-æå¤§å€¼åŸç†)
    - [3.1 åºç‰¹é‡Œäºšé‡‘æå¤§å€¼åŸç†](#31-åºç‰¹é‡Œäºšé‡‘æå¤§å€¼åŸç†)
    - [3.2 æ¨ªæˆªæ¡ä»¶](#32-æ¨ªæˆªæ¡ä»¶)
    - [3.3 æå¤§å€¼åŸç†çš„åº”ç”¨](#33-æå¤§å€¼åŸç†çš„åº”ç”¨)
  - [4. åŠ¨æ€è§„åˆ’](#4-åŠ¨æ€è§„åˆ’)
    - [4.1 è´å°”æ›¼æœ€ä¼˜æ€§åŸç†](#41-è´å°”æ›¼æœ€ä¼˜æ€§åŸç†)
    - [4.2 å“ˆå¯†é¡¿-é›…å¯æ¯”-è´å°”æ›¼æ–¹ç¨‹](#42-å“ˆå¯†é¡¿-é›…å¯æ¯”-è´å°”æ›¼æ–¹ç¨‹)
    - [4.3 çº¿æ€§äºŒæ¬¡å‹é—®é¢˜çš„è§£](#43-çº¿æ€§äºŒæ¬¡å‹é—®é¢˜çš„è§£)
  - [5. çº¿æ€§äºŒæ¬¡å‹é—®é¢˜](#5-çº¿æ€§äºŒæ¬¡å‹é—®é¢˜)
    - [5.1 æœ‰é™æ—¶é—´LQé—®é¢˜](#51-æœ‰é™æ—¶é—´lqé—®é¢˜)
    - [5.2 æ— é™æ—¶é—´LQé—®é¢˜](#52-æ— é™æ—¶é—´lqé—®é¢˜)
    - [5.3 è·Ÿè¸ªé—®é¢˜](#53-è·Ÿè¸ªé—®é¢˜)
  - [6. æ•°å€¼æ–¹æ³•](#6-æ•°å€¼æ–¹æ³•)
    - [6.1 æ¢¯åº¦æ³•](#61-æ¢¯åº¦æ³•)
    - [6.2 å…±è½­æ¢¯åº¦æ³•](#62-å…±è½­æ¢¯åº¦æ³•)
    - [6.3 ç›´æ¥æ³•](#63-ç›´æ¥æ³•)
  - [7. ä»£ç å®ç°](#7-ä»£ç å®ç°)
    - [7.1 æœ€ä¼˜æ§åˆ¶é—®é¢˜æ¡†æ¶](#71-æœ€ä¼˜æ§åˆ¶é—®é¢˜æ¡†æ¶)
    - [7.2 çº¿æ€§äºŒæ¬¡å‹é—®é¢˜æ±‚è§£å™¨](#72-çº¿æ€§äºŒæ¬¡å‹é—®é¢˜æ±‚è§£å™¨)
    - [7.3 åŠ¨æ€è§„åˆ’æ±‚è§£å™¨](#73-åŠ¨æ€è§„åˆ’æ±‚è§£å™¨)
  - [8. åº”ç”¨ç¤ºä¾‹](#8-åº”ç”¨ç¤ºä¾‹)
    - [8.1 å€’ç«‹æ‘†æœ€ä¼˜æ§åˆ¶](#81-å€’ç«‹æ‘†æœ€ä¼˜æ§åˆ¶)
    - [8.2 æ—¶é—´æœ€ä¼˜æ§åˆ¶](#82-æ—¶é—´æœ€ä¼˜æ§åˆ¶)
  - [9. ç›¸å…³ç†è®º](#9-ç›¸å…³ç†è®º)
    - [9.1 ä¸å˜åˆ†æ³•çš„å…³ç³»](#91-ä¸å˜åˆ†æ³•çš„å…³ç³»)
    - [9.2 ä¸åŠ¨æ€è§„åˆ’çš„å…³ç³»](#92-ä¸åŠ¨æ€è§„åˆ’çš„å…³ç³»)
    - [9.3 ä¸é²æ£’æ§åˆ¶çš„å…³ç³»](#93-ä¸é²æ£’æ§åˆ¶çš„å…³ç³»)
  - [10. å‚è€ƒæ–‡çŒ®](#10-å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)
    - [å¤šå…ƒç†è®ºè§†è§’](#å¤šå…ƒç†è®ºè§†è§’)
    - [å±€é™æ€§åˆ†æ](#å±€é™æ€§åˆ†æ)
    - [äº‰è®®ä¸åˆ†æ­§](#äº‰è®®ä¸åˆ†æ­§)
    - [åº”ç”¨å‰æ™¯](#åº”ç”¨å‰æ™¯)
    - [æ”¹è¿›å»ºè®®](#æ”¹è¿›å»ºè®®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 æœ€ä¼˜æ§åˆ¶é—®é¢˜

**å®šä¹‰ 1.1.1** (æœ€ä¼˜æ§åˆ¶é—®é¢˜)
æœ€ä¼˜æ§åˆ¶é—®é¢˜å®šä¹‰ä¸ºï¼š

$$\min_{u(t)} J = \int_{t_0}^{t_f} L(x(t), u(t), t)dt + \phi(x(t_f), t_f)$$

çº¦æŸæ¡ä»¶ï¼š
$$
\begin{align}
\dot{x}(t) &= f(x(t), u(t), t) \\
x(t_0) &= x_0 \\
u(t) &\in U(t)
\end{align}
$$

å…¶ä¸­ï¼š

- $J$ æ˜¯æ€§èƒ½æŒ‡æ ‡
- $L$ æ˜¯æ‹‰æ ¼æœ—æ—¥å‡½æ•°
- $\phi$ æ˜¯ç»ˆç«¯ä»£ä»·å‡½æ•°
- $U(t)$ æ˜¯æ§åˆ¶çº¦æŸé›†

### 1.2 æ€§èƒ½æŒ‡æ ‡åˆ†ç±»

**å®šä¹‰ 1.2.1** (æ€§èƒ½æŒ‡æ ‡ç±»å‹)

1. **æ‹‰æ ¼æœ—æ—¥å‹**ï¼š$J = \int_{t_0}^{t_f} L(x(t), u(t), t)dt$
2. **è¿ˆè€¶å‹**ï¼š$J = \phi(x(t_f), t_f)$
3. **æ³¢å°”æ‰å‹**ï¼š$J = \int_{t_0}^{t_f} L(x(t), u(t), t)dt + \phi(x(t_f), t_f)$

### 1.3 æœ€ä¼˜æ€§æ¡ä»¶

**å®šä¹‰ 1.3.1** (æœ€ä¼˜æ€§)
æ§åˆ¶ $u^*(t)$ æ˜¯æœ€ä¼˜çš„ï¼Œå¦‚æœå¯¹äºæ‰€æœ‰å…è®¸çš„æ§åˆ¶ $u(t)$ï¼Œéƒ½æœ‰ï¼š

$$J(u^*) \leq J(u)$$

## 2. å˜åˆ†æ³•åŸºç¡€

### 2.1 æ¬§æ‹‰-æ‹‰æ ¼æœ—æ—¥æ–¹ç¨‹

**å®šç† 2.1.1** (æ¬§æ‹‰-æ‹‰æ ¼æœ—æ—¥æ–¹ç¨‹)
å¯¹äºæ³›å‡½ï¼š

$$J = \int_{t_0}^{t_f} L(x(t), \dot{x}(t), t)dt$$

å…¶æå€¼æ¡ä»¶ä¸ºï¼š

$$\frac{\partial L}{\partial x} - \frac{d}{dt}\frac{\partial L}{\partial \dot{x}} = 0$$

**è¯æ˜**ï¼š
è®¾ $x^*(t)$ æ˜¯æå€¼å‡½æ•°ï¼Œ$\eta(t)$ æ˜¯ä»»æ„å˜åˆ†å‡½æ•°ï¼Œæ»¡è¶³ $\eta(t_0) = \eta(t_f) = 0$ã€‚
å®šä¹‰ $x(t, \alpha) = x^*(t) + \alpha\eta(t)$ï¼Œåˆ™ï¼š

$$J(\alpha) = \int_{t_0}^{t_f} L(x(t, \alpha), \dot{x}(t, \alpha), t)dt$$

æå€¼æ¡ä»¶ä¸º $\frac{dJ}{d\alpha}\big|_{\alpha=0} = 0$ï¼Œå³ï¼š

$$\int_{t_0}^{t_f} \left(\frac{\partial L}{\partial x}\eta + \frac{\partial L}{\partial \dot{x}}\dot{\eta}\right)dt = 0$$

ä½¿ç”¨åˆ†éƒ¨ç§¯åˆ†ï¼š

$$\int_{t_0}^{t_f} \frac{\partial L}{\partial \dot{x}}\dot{\eta}dt = \frac{\partial L}{\partial \dot{x}}\eta\big|_{t_0}^{t_f} - \int_{t_0}^{t_f} \frac{d}{dt}\frac{\partial L}{\partial \dot{x}}\eta dt$$

ç”±äº $\eta(t_0) = \eta(t_f) = 0$ï¼Œå¾—åˆ°ï¼š

$$\int_{t_0}^{t_f} \left(\frac{\partial L}{\partial x} - \frac{d}{dt}\frac{\partial L}{\partial \dot{x}}\right)\eta dt = 0$$

ç”±äº $\eta(t)$ æ˜¯ä»»æ„çš„ï¼Œå› æ­¤ï¼š

$$\frac{\partial L}{\partial x} - \frac{d}{dt}\frac{\partial L}{\partial \dot{x}} = 0$$

### 2.2 æ¨ªæˆªæ¡ä»¶

**å®šç† 2.2.1** (æ¨ªæˆªæ¡ä»¶)
å¦‚æœç»ˆç«¯çŠ¶æ€ $x(t_f)$ æ˜¯è‡ªç”±çš„ï¼Œåˆ™æ¨ªæˆªæ¡ä»¶ä¸ºï¼š

$$\frac{\partial L}{\partial \dot{x}}\big|_{t=t_f} = 0$$

å¦‚æœç»ˆç«¯æ—¶é—´ $t_f$ æ˜¯è‡ªç”±çš„ï¼Œåˆ™æ¨ªæˆªæ¡ä»¶ä¸ºï¼š

$$L - \frac{\partial L}{\partial \dot{x}}\dot{x}\big|_{t=t_f} = 0$$

### 2.3 çº¦æŸå˜åˆ†æ³•

**å®šç† 2.3.1** (çº¦æŸå˜åˆ†æ³•)
å¯¹äºå¸¦çº¦æŸçš„å˜åˆ†é—®é¢˜ï¼š

$$\min J = \int_{t_0}^{t_f} L(x(t), \dot{x}(t), t)dt$$

çº¦æŸæ¡ä»¶ï¼š
$$g(x(t), \dot{x}(t), t) = 0$$

æå€¼æ¡ä»¶ä¸ºï¼š

$$\frac{\partial L}{\partial x} - \frac{d}{dt}\frac{\partial L}{\partial \dot{x}} + \lambda(t)\left(\frac{\partial g}{\partial x} - \frac{d}{dt}\frac{\partial g}{\partial \dot{x}}\right) = 0$$

å…¶ä¸­ $\lambda(t)$ æ˜¯æ‹‰æ ¼æœ—æ—¥ä¹˜å­ã€‚

## 3. æå¤§å€¼åŸç†

### 3.1 åºç‰¹é‡Œäºšé‡‘æå¤§å€¼åŸç†

**å®šç† 3.1.1** (åºç‰¹é‡Œäºšé‡‘æå¤§å€¼åŸç†)
å¯¹äºæœ€ä¼˜æ§åˆ¶é—®é¢˜ï¼š

$$\min_{u(t)} J = \int_{t_0}^{t_f} L(x(t), u(t), t)dt + \phi(x(t_f), t_f)$$

çº¦æŸæ¡ä»¶ï¼š
$$\dot{x}(t) = f(x(t), u(t), t)$$

æœ€ä¼˜æ§åˆ¶ $u^*(t)$ æ»¡è¶³ï¼š

$$u^*(t) = \arg\min_{u(t) \in U(t)} H(x^*(t), u(t), \lambda^*(t), t)$$

å…¶ä¸­å“ˆå¯†é¡¿å‡½æ•°ä¸ºï¼š

$$H(x, u, \lambda, t) = L(x, u, t) + \lambda^T f(x, u, t)$$

åæ€å˜é‡ $\lambda(t)$ æ»¡è¶³ï¼š

$$\dot{\lambda}(t) = -\frac{\partial H}{\partial x}$$

**è¯æ˜**ï¼š
ä½¿ç”¨å˜åˆ†æ³•ï¼Œè€ƒè™‘æ§åˆ¶å˜åˆ† $\delta u(t)$ å¯¹æ€§èƒ½æŒ‡æ ‡çš„å½±å“ï¼š

$$\delta J = \int_{t_0}^{t_f} \left(\frac{\partial L}{\partial x}\delta x + \frac{\partial L}{\partial u}\delta u\right)dt + \frac{\partial \phi}{\partial x}\delta x(t_f)$$

çŠ¶æ€å˜åˆ†æ»¡è¶³ï¼š

$$\delta \dot{x} = \frac{\partial f}{\partial x}\delta x + \frac{\partial f}{\partial u}\delta u$$

å¼•å…¥åæ€å˜é‡ $\lambda(t)$ï¼Œå®šä¹‰å“ˆå¯†é¡¿å‡½æ•°ï¼š

$$H = L + \lambda^T f$$

åˆ™ï¼š

$$\delta J = \int_{t_0}^{t_f} \left(\frac{\partial H}{\partial x}\delta x + \frac{\partial H}{\partial u}\delta u + \lambda^T\delta \dot{x} - \lambda^T\frac{\partial f}{\partial x}\delta x\right)dt + \frac{\partial \phi}{\partial x}\delta x(t_f)$$

ä½¿ç”¨åˆ†éƒ¨ç§¯åˆ†ï¼š

$$\int_{t_0}^{t_f} \lambda^T\delta \dot{x} dt = \lambda^T\delta x\big|_{t_0}^{t_f} - \int_{t_0}^{t_f} \dot{\lambda}^T\delta x dt$$

å› æ­¤ï¼š

$$\delta J = \int_{t_0}^{t_f} \left(\frac{\partial H}{\partial u}\delta u + \left(\frac{\partial H}{\partial x} + \dot{\lambda}^T\right)\delta x\right)dt + \left(\lambda^T + \frac{\partial \phi}{\partial x}\right)\delta x(t_f)$$

ä¸ºäº† $\delta J = 0$ï¼Œéœ€è¦ï¼š

$$\frac{\partial H}{\partial u} = 0, \quad \dot{\lambda} = -\frac{\partial H}{\partial x}, \quad \lambda(t_f) = -\frac{\partial \phi}{\partial x}$$

### 3.2 æ¨ªæˆªæ¡ä»¶

**å®šç† 3.2.1** (æ¨ªæˆªæ¡ä»¶)
å¯¹äºæå¤§å€¼åŸç†ï¼Œæ¨ªæˆªæ¡ä»¶ä¸ºï¼š

$$\lambda(t_f) = -\frac{\partial \phi}{\partial x(t_f)}$$

å¦‚æœç»ˆç«¯çŠ¶æ€å›ºå®šï¼Œåˆ™ $\delta x(t_f) = 0$ï¼Œæ¨ªæˆªæ¡ä»¶è‡ªåŠ¨æ»¡è¶³ã€‚

### 3.3 æå¤§å€¼åŸç†çš„åº”ç”¨

**ä¾‹ 3.3.1** (æ—¶é—´æœ€ä¼˜æ§åˆ¶)
è€ƒè™‘æ—¶é—´æœ€ä¼˜æ§åˆ¶é—®é¢˜ï¼š

$$\min_{u(t)} J = \int_0^{t_f} dt = t_f$$

çº¦æŸæ¡ä»¶ï¼š
$$\dot{x}(t) = f(x(t), u(t), t)$$

å“ˆå¯†é¡¿å‡½æ•°ä¸ºï¼š
$$H = 1 + \lambda^T f$$

æœ€ä¼˜æ§åˆ¶æ»¡è¶³ï¼š
$$u^*(t) = \arg\min_{u(t) \in U} \lambda^T(t) f(x^*(t), u(t), t)$$

## 4. åŠ¨æ€è§„åˆ’

### 4.1 è´å°”æ›¼æœ€ä¼˜æ€§åŸç†

**å®šç† 4.1.1** (è´å°”æ›¼æœ€ä¼˜æ€§åŸç†)
æœ€ä¼˜æ§åˆ¶ç­–ç•¥å…·æœ‰ä»¥ä¸‹æ€§è´¨ï¼šæ— è®ºåˆå§‹çŠ¶æ€å’Œåˆå§‹å†³ç­–å¦‚ä½•ï¼Œå‰©ä½™å†³ç­–å¿…é¡»æ„æˆç›¸å¯¹äºç”±ç¬¬ä¸€ä¸ªå†³ç­–äº§ç”Ÿçš„çŠ¶æ€çš„æœ€ä¼˜ç­–ç•¥ã€‚

**å½¢å¼åŒ–è¡¨è¿°**ï¼š
è®¾ $V(x, t)$ æ˜¯ä»çŠ¶æ€ $x$ å’Œæ—¶é—´ $t$ å¼€å§‹çš„æœ€ä¼˜å€¼å‡½æ•°ï¼Œåˆ™ï¼š

$$V(x, t) = \min_{u(t)} \left\{L(x, u, t)dt + V(x + f(x, u, t)dt, t + dt)\right\}$$

### 4.2 å“ˆå¯†é¡¿-é›…å¯æ¯”-è´å°”æ›¼æ–¹ç¨‹

**å®šç† 4.2.1** (HJBæ–¹ç¨‹)
æœ€ä¼˜å€¼å‡½æ•° $V(x, t)$ æ»¡è¶³åå¾®åˆ†æ–¹ç¨‹ï¼š

$$-\frac{\partial V}{\partial t} = \min_{u \in U} \left\{L(x, u, t) + \frac{\partial V}{\partial x}f(x, u, t)\right\}$$

è¾¹ç•Œæ¡ä»¶ï¼š
$$V(x, t_f) = \phi(x, t_f)$$

**è¯æ˜**ï¼š
ä»è´å°”æ›¼æœ€ä¼˜æ€§åŸç†ï¼š

$$V(x, t) = \min_{u(t)} \left\{L(x, u, t)dt + V(x + f(x, u, t)dt, t + dt)\right\}$$

å±•å¼€ $V(x + f(x, u, t)dt, t + dt)$ åˆ°ä¸€é˜¶ï¼š

$$V(x + f(x, u, t)dt, t + dt) = V(x, t) + \frac{\partial V}{\partial x}f(x, u, t)dt + \frac{\partial V}{\partial t}dt + o(dt)$$

ä»£å…¥å¾—åˆ°ï¼š

$$V(x, t) = \min_{u(t)} \left\{L(x, u, t)dt + V(x, t) + \frac{\partial V}{\partial x}f(x, u, t)dt + \frac{\partial V}{\partial t}dt + o(dt)\right\}$$

ç®€åŒ–å¾—åˆ°HJBæ–¹ç¨‹ã€‚

### 4.3 çº¿æ€§äºŒæ¬¡å‹é—®é¢˜çš„è§£

**å®šç† 4.3.1** (LQé—®é¢˜çš„HJBè§£)
å¯¹äºçº¿æ€§äºŒæ¬¡å‹é—®é¢˜ï¼š

$$\min_{u(t)} J = \int_{t_0}^{t_f} (x^TQx + u^TRu)dt + x^T(t_f)Sx(t_f)$$

çº¦æŸæ¡ä»¶ï¼š
$$\dot{x} = Ax + Bu$$

æœ€ä¼˜å€¼å‡½æ•°ä¸ºï¼š
$$V(x, t) = x^TP(t)x$$

å…¶ä¸­ $P(t)$ æ»¡è¶³é»å¡æå¾®åˆ†æ–¹ç¨‹ï¼š

$$-\dot{P} = A^TP + PA - PBR^{-1}B^TP + Q$$

è¾¹ç•Œæ¡ä»¶ï¼š
$$P(t_f) = S$$

æœ€ä¼˜æ§åˆ¶ä¸ºï¼š
$$u^*(t) = -R^{-1}B^TP(t)x(t)$$

## 5. çº¿æ€§äºŒæ¬¡å‹é—®é¢˜

### 5.1 æœ‰é™æ—¶é—´LQé—®é¢˜

**å®šä¹‰ 5.1.1** (æœ‰é™æ—¶é—´LQé—®é¢˜)
æœ‰é™æ—¶é—´çº¿æ€§äºŒæ¬¡å‹é—®é¢˜å®šä¹‰ä¸ºï¼š

$$\min_{u(t)} J = \int_{t_0}^{t_f} (x^T(t)Q(t)x(t) + u^T(t)R(t)u(t))dt + x^T(t_f)Sx(t_f)$$

çº¦æŸæ¡ä»¶ï¼š
$$\dot{x}(t) = A(t)x(t) + B(t)u(t)$$

**å®šç† 5.1.1** (LQé—®é¢˜è§£)
LQé—®é¢˜çš„æœ€ä¼˜æ§åˆ¶ä¸ºï¼š

$$u^*(t) = -R^{-1}(t)B^T(t)P(t)x(t)$$

å…¶ä¸­ $P(t)$ æ˜¯é»å¡æå¾®åˆ†æ–¹ç¨‹çš„è§£ï¼š

$$-\dot{P}(t) = A^T(t)P(t) + P(t)A(t) - P(t)B(t)R^{-1}(t)B^T(t)P(t) + Q(t)$$

è¾¹ç•Œæ¡ä»¶ï¼š
$$P(t_f) = S$$

### 5.2 æ— é™æ—¶é—´LQé—®é¢˜

**å®šä¹‰ 5.2.1** (æ— é™æ—¶é—´LQé—®é¢˜)
æ— é™æ—¶é—´çº¿æ€§äºŒæ¬¡å‹é—®é¢˜å®šä¹‰ä¸ºï¼š

$$\min_{u(t)} J = \int_{0}^{\infty} (x^T(t)Qx(t) + u^T(t)Ru(t))dt$$

çº¦æŸæ¡ä»¶ï¼š
$$\dot{x}(t) = Ax(t) + Bu(t)$$

**å®šç† 5.2.1** (æ— é™æ—¶é—´LQé—®é¢˜è§£)
å¦‚æœç³»ç»Ÿ $(A,B)$ å¯æ§ä¸” $(A,Q^{1/2})$ å¯è§‚ï¼Œåˆ™æ— é™æ—¶é—´LQé—®é¢˜çš„æœ€ä¼˜æ§åˆ¶ä¸ºï¼š

$$u^*(t) = -R^{-1}B^TPx(t)$$

å…¶ä¸­ $P$ æ˜¯ä»£æ•°é»å¡ææ–¹ç¨‹çš„æ­£å®šè§£ï¼š

$$A^TP + PA - PBR^{-1}B^TP + Q = 0$$

### 5.3 è·Ÿè¸ªé—®é¢˜

**å®šä¹‰ 5.3.1** (LQè·Ÿè¸ªé—®é¢˜)
LQè·Ÿè¸ªé—®é¢˜å®šä¹‰ä¸ºï¼š

$$\min_{u(t)} J = \int_{t_0}^{t_f} ((x(t) - r(t))^TQ(t)(x(t) - r(t)) + u^T(t)R(t)u(t))dt$$

çº¦æŸæ¡ä»¶ï¼š
$$\dot{x}(t) = A(t)x(t) + B(t)u(t)$$

**å®šç† 5.3.1** (è·Ÿè¸ªé—®é¢˜è§£)
è·Ÿè¸ªé—®é¢˜çš„æœ€ä¼˜æ§åˆ¶ä¸ºï¼š

$$u^*(t) = -R^{-1}(t)B^T(t)(P(t)x(t) - g(t))$$

å…¶ä¸­ $P(t)$ å’Œ $g(t)$ æ»¡è¶³ï¼š

$$-\dot{P}(t) = A^T(t)P(t) + P(t)A(t) - P(t)B(t)R^{-1}(t)B^T(t)P(t) + Q(t)$$

$$-\dot{g}(t) = (A^T(t) - P(t)B(t)R^{-1}(t)B^T(t))g(t) + Q(t)r(t)$$

è¾¹ç•Œæ¡ä»¶ï¼š
$$P(t_f) = 0, \quad g(t_f) = 0$$

## 6. æ•°å€¼æ–¹æ³•

### 6.1 æ¢¯åº¦æ³•

**ç®—æ³• 6.1.1** (æ¢¯åº¦æ³•)

1. åˆå§‹åŒ–æ§åˆ¶åºåˆ— $u^{(0)}(t)$
2. è®¡ç®—æ¢¯åº¦ $\nabla J(u^{(k)})$
3. æ›´æ–°æ§åˆ¶ï¼š$u^{(k+1)}(t) = u^{(k)}(t) - \alpha \nabla J(u^{(k)})$
4. é‡å¤æ­¥éª¤2-3ç›´åˆ°æ”¶æ•›

### 6.2 å…±è½­æ¢¯åº¦æ³•

**ç®—æ³• 6.2.1** (å…±è½­æ¢¯åº¦æ³•)

1. åˆå§‹åŒ– $u^{(0)}(t)$ å’Œæœç´¢æ–¹å‘ $d^{(0)}(t) = -\nabla J(u^{(0)})$
2. è®¡ç®—æ­¥é•¿ï¼š$\alpha_k = \arg\min_{\alpha} J(u^{(k)} + \alpha d^{(k)})$
3. æ›´æ–°æ§åˆ¶ï¼š$u^{(k+1)}(t) = u^{(k)}(t) + \alpha_k d^{(k)}(t)$
4. è®¡ç®—æ–°çš„æ¢¯åº¦ï¼š$\nabla J(u^{(k+1)})$
5. æ›´æ–°æœç´¢æ–¹å‘ï¼š$d^{(k+1)}(t) = -\nabla J(u^{(k+1)}) + \beta_k d^{(k)}(t)$
6. é‡å¤æ­¥éª¤2-5ç›´åˆ°æ”¶æ•›

### 6.3 ç›´æ¥æ³•

**ç®—æ³• 6.3.1** (ç›´æ¥æ³•)

1. å°†è¿ç»­æ—¶é—´é—®é¢˜ç¦»æ•£åŒ–
2. å°†æ§åˆ¶åºåˆ—å‚æ•°åŒ–
3. ä½¿ç”¨éçº¿æ€§è§„åˆ’æ±‚è§£å‚æ•°ä¼˜åŒ–é—®é¢˜

## 7. ä»£ç å®ç°

### 7.1 æœ€ä¼˜æ§åˆ¶é—®é¢˜æ¡†æ¶

```rust
use nalgebra::{DMatrix, DVector};
use std::f64::consts::PI;

/// æœ€ä¼˜æ§åˆ¶é—®é¢˜
pub struct OptimalControlProblem {
    pub t0: f64,
    pub tf: f64,
    pub x0: DVector<f64>,
    pub xf: Option<DVector<f64>>,
}

/// æ€§èƒ½æŒ‡æ ‡
pub trait CostFunction {
    fn lagrangian(&self, x: &DVector<f64>, u: &DVector<f64>, t: f64) -> f64;
    fn terminal_cost(&self, x: &DVector<f64>, t: f64) -> f64;
}

/// ç³»ç»ŸåŠ¨åŠ›å­¦
pub trait SystemDynamics {
    fn dynamics(&self, x: &DVector<f64>, u: &DVector<f64>, t: f64) -> DVector<f64>;
    fn jacobian_x(&self, x: &DVector<f64>, u: &DVector<f64>, t: f64) -> DMatrix<f64>;
    fn jacobian_u(&self, x: &DVector<f64>, u: &DVector<f64>, t: f64) -> DMatrix<f64>;
}

/// æœ€ä¼˜æ§åˆ¶æ±‚è§£å™¨
pub struct OptimalControlSolver<C, S> {
    cost: C,
    system: S,
    problem: OptimalControlProblem,
}

impl<C: CostFunction, S: SystemDynamics> OptimalControlSolver<C, S> {
    pub fn new(cost: C, system: S, problem: OptimalControlProblem) -> Self {
        Self { cost, system, problem }
    }

    /// ä½¿ç”¨æå¤§å€¼åŸç†æ±‚è§£
    pub fn solve_maximum_principle(&self, dt: f64) -> (Vec<DVector<f64>>, Vec<DVector<f64>>) {
        let n_steps = ((self.problem.tf - self.problem.t0) / dt) as usize;
        let mut x = vec![self.problem.x0.clone(); n_steps + 1];
        let mut u = vec![DVector::zeros(1); n_steps];
        let mut lambda = vec![DVector::zeros(x[0].len()); n_steps + 1];

        // åˆå§‹åŒ–åæ€å˜é‡
        if let Some(xf) = &self.problem.xf {
            lambda[n_steps] = xf - &x[n_steps];
        }

        // å‰å‘ç§¯åˆ†çŠ¶æ€æ–¹ç¨‹
        for k in 0..n_steps {
            let t = self.problem.t0 + k as f64 * dt;
            let uk = self.compute_optimal_control(&x[k], &lambda[k + 1], t);
            u[k] = uk.clone();

            let dx = self.system.dynamics(&x[k], &uk, t) * dt;
            x[k + 1] = &x[k] + &dx;
        }

        // åå‘ç§¯åˆ†åæ€æ–¹ç¨‹
        for k in (0..n_steps).rev() {
            let t = self.problem.t0 + k as f64 * dt;
            let dlambda = -self.system.jacobian_x(&x[k], &u[k], t).transpose() * &lambda[k + 1] * dt;
            lambda[k] = &lambda[k + 1] + &dlambda;
        }

        (x, u)
    }

    /// è®¡ç®—æœ€ä¼˜æ§åˆ¶
    fn compute_optimal_control(&self, x: &DVector<f64>, lambda: &DVector<f64>, t: f64) -> DVector<f64> {
        // ä½¿ç”¨æ¢¯åº¦æ³•æ±‚è§£æœ€ä¼˜æ§åˆ¶
        let mut u = DVector::zeros(1);
        let learning_rate = 0.01;

        for _ in 0..100 {
            let gradient = self.control_gradient(x, &u, lambda, t);
            u = &u - &(gradient * learning_rate);
        }

        u
    }

    /// è®¡ç®—æ§åˆ¶æ¢¯åº¦
    fn control_gradient(&self, x: &DVector<f64>, u: &DVector<f64>, lambda: &DVector<f64>, t: f64) -> DVector<f64> {
        let dL_du = self.cost_gradient_u(x, u, t);
        let df_du = self.system.jacobian_u(x, u, t);
        dL_du + df_du.transpose() * lambda
    }

    /// è®¡ç®—æ‹‰æ ¼æœ—æ—¥å‡½æ•°å¯¹æ§åˆ¶çš„æ¢¯åº¦
    fn cost_gradient_u(&self, x: &DVector<f64>, u: &DVector<f64>, t: f64) -> DVector<f64> {
        // æ•°å€¼æ¢¯åº¦
        let h = 1e-6;
        let mut gradient = DVector::zeros(u.len());

        for i in 0..u.len() {
            let mut u_plus = u.clone();
            u_plus[i] += h;
            let mut u_minus = u.clone();
            u_minus[i] -= h;

            let cost_plus = self.cost.lagrangian(x, &u_plus, t);
            let cost_minus = self.cost.lagrangian(x, &u_minus, t);

            gradient[i] = (cost_plus - cost_minus) / (2.0 * h);
        }

        gradient
    }
}
```

### 7.2 çº¿æ€§äºŒæ¬¡å‹é—®é¢˜æ±‚è§£å™¨

```rust
/// çº¿æ€§äºŒæ¬¡å‹é—®é¢˜
pub struct LQProblem {
    pub A: DMatrix<f64>,
    pub B: DMatrix<f64>,
    pub Q: DMatrix<f64>,
    pub R: DMatrix<f64>,
    pub S: DMatrix<f64>,
    pub t0: f64,
    pub tf: f64,
}

impl LQProblem {
    /// æ±‚è§£æœ‰é™æ—¶é—´LQé—®é¢˜
    pub fn solve_finite_time(&self, x0: &DVector<f64>, dt: f64) -> (Vec<DVector<f64>>, Vec<DVector<f64>>) {
        let n_steps = ((self.tf - self.t0) / dt) as usize;
        let mut x = vec![x0.clone(); n_steps + 1];
        let mut u = vec![DVector::zeros(self.B.ncols()); n_steps];

        // åå‘ç§¯åˆ†é»å¡ææ–¹ç¨‹
        let mut P = self.S.clone();
        let mut P_history = vec![P.clone(); n_steps + 1];

        for k in (0..n_steps).rev() {
            let t = self.t0 + k as f64 * dt;

            // é»å¡æå¾®åˆ†æ–¹ç¨‹
            let dP = -(self.A.transpose() * &P + &P * &self.A - &P * &self.B * &self.R.inverse() * &self.B.transpose() * &P + &self.Q) * dt;
            P = &P + &dP;
            P_history[k] = P.clone();
        }

        // å‰å‘ç§¯åˆ†çŠ¶æ€æ–¹ç¨‹
        for k in 0..n_steps {
            let t = self.t0 + k as f64 * dt;

            // æœ€ä¼˜æ§åˆ¶
            let K = &self.R.inverse() * &self.B.transpose() * &P_history[k];
            u[k] = -K * &x[k];

            // çŠ¶æ€æ›´æ–°
            let dx = (&self.A * &x[k] + &self.B * &u[k]) * dt;
            x[k + 1] = &x[k] + &dx;
        }

        (x, u)
    }

    /// æ±‚è§£æ— é™æ—¶é—´LQé—®é¢˜
    pub fn solve_infinite_time(&self, x0: &DVector<f64>) -> DMatrix<f64> {
        // ä½¿ç”¨è¿­ä»£æ–¹æ³•æ±‚è§£ä»£æ•°é»å¡ææ–¹ç¨‹
        let mut P = DMatrix::identity(self.A.nrows(), self.A.nrows());
        let R_inv = self.R.inverse();

        for _ in 0..100 {
            let P_new = &self.A.transpose() * &P + &P * &self.A - &P * &self.B * &R_inv * &self.B.transpose() * &P + &self.Q;

            let diff = (&P_new - &P).norm();
            P = P_new;

            if diff < 1e-6 {
                break;
            }
        }

        P
    }
}
```

### 7.3 åŠ¨æ€è§„åˆ’æ±‚è§£å™¨

```rust
/// åŠ¨æ€è§„åˆ’æ±‚è§£å™¨
pub struct DynamicProgrammingSolver<C, S> {
    cost: C,
    system: S,
    problem: OptimalControlProblem,
}

impl<C: CostFunction, S: SystemDynamics> DynamicProgrammingSolver<C, S> {
    pub fn new(cost: C, system: S, problem: OptimalControlProblem) -> Self {
        Self { cost, system, problem }
    }

    /// ä½¿ç”¨åŠ¨æ€è§„åˆ’æ±‚è§£
    pub fn solve(&self, dt: f64, dx: f64) -> (Vec<DVector<f64>>, Vec<DVector<f64>>) {
        let n_steps = ((self.problem.tf - self.problem.t0) / dt) as usize;
        let n_states = ((10.0) / dx) as usize; // å‡è®¾çŠ¶æ€èŒƒå›´[-5, 5]

        // åˆå§‹åŒ–å€¼å‡½æ•°
        let mut V = vec![vec![f64::INFINITY; n_states]; n_steps + 1];
        let mut policy = vec![vec![0; n_states]; n_steps];

        // ç»ˆç«¯æ¡ä»¶
        for i in 0..n_states {
            let x = (i as f64 - n_states as f64 / 2.0) * dx;
            let state = DVector::from_column_slice(&[x]);
            V[n_steps][i] = self.cost.terminal_cost(&state, self.problem.tf);
        }

        // åå‘é€’å½’
        for k in (0..n_steps).rev() {
            let t = self.problem.t0 + k as f64 * dt;

            for i in 0..n_states {
                let x = (i as f64 - n_states as f64 / 2.0) * dx;
                let state = DVector::from_column_slice(&[x]);

                let mut min_cost = f64::INFINITY;
                let mut best_u = 0.0;

                // æœç´¢æœ€ä¼˜æ§åˆ¶
                for u_idx in 0..100 {
                    let u_val = (u_idx as f64 - 50.0) * 0.1;
                    let control = DVector::from_column_slice(&[u_val]);

                    let dx = self.system.dynamics(&state, &control, t) * dt;
                    let next_state = &state + &dx;

                    let next_x = next_state[0];
                    let next_i = ((next_x / dx) + n_states as f64 / 2.0) as usize;

                    if next_i < n_states {
                        let cost = self.cost.lagrangian(&state, &control, t) * dt + V[k + 1][next_i];

                        if cost < min_cost {
                            min_cost = cost;
                            best_u = u_val;
                        }
                    }
                }

                V[k][i] = min_cost;
                policy[k][i] = best_u as i32;
            }
        }

        // å‰å‘æ¨¡æ‹Ÿæœ€ä¼˜è½¨è¿¹
        let mut x = vec![self.problem.x0.clone(); n_steps + 1];
        let mut u = vec![DVector::zeros(1); n_steps];

        for k in 0..n_steps {
            let x_val = x[k][0];
            let i = ((x_val / dx) + n_states as f64 / 2.0) as usize;

            if i < n_states {
                u[k] = DVector::from_column_slice(&[policy[k][i] as f64]);
            }

            let t = self.problem.t0 + k as f64 * dt;
            let dx = self.system.dynamics(&x[k], &u[k], t) * dt;
            x[k + 1] = &x[k] + &dx;
        }

        (x, u)
    }
}
```

## 8. åº”ç”¨ç¤ºä¾‹

### 8.1 å€’ç«‹æ‘†æœ€ä¼˜æ§åˆ¶

```rust
/// å€’ç«‹æ‘†æœ€ä¼˜æ§åˆ¶ç¤ºä¾‹
pub fn inverted_pendulum_optimal_control() {
    // ç³»ç»Ÿå‚æ•°
    let M = 0.5; // å°è½¦è´¨é‡
    let m = 0.2; // æ‘†æ†è´¨é‡
    let b = 0.1; // æ‘©æ“¦ç³»æ•°
    let I = 0.006; // è½¬åŠ¨æƒ¯é‡
    let g = 9.8; // é‡åŠ›åŠ é€Ÿåº¦
    let l = 0.3; // æ‘†æ†é•¿åº¦

    // çŠ¶æ€ç©ºé—´æ¨¡å‹
    let p = I * (M + m) + M * m * l * l;

    let A = DMatrix::from_row_slice(4, 4, &[
        0.0, 1.0, 0.0, 0.0,
        0.0, -(I + m * l * l) * b / p, m * m * g * l * l / p, 0.0,
        0.0, 0.0, 0.0, 1.0,
        0.0, -m * l * b / p, m * g * l * (M + m) / p, 0.0
    ]);

    let B = DMatrix::from_column_slice(4, 1, &[
        0.0,
        (I + m * l * l) / p,
        0.0,
        m * l / p
    ]);

    // æ€§èƒ½æŒ‡æ ‡æƒé‡
    let Q = DMatrix::diagonal(4, &[1.0, 1.0, 10.0, 10.0]);
    let R = DMatrix::from_element(1, 1, 0.1);
    let S = DMatrix::diagonal(4, &[1.0, 1.0, 10.0, 10.0]);

    let lq_problem = LQProblem {
        A, B, Q, R, S,
        t0: 0.0,
        tf: 10.0,
    };

    // åˆå§‹çŠ¶æ€ï¼šå°è½¦ä½ç½®=0.1mï¼Œæ‘†æ†è§’åº¦=0.1rad
    let x0 = DVector::from_column_slice(&[0.1, 0.0, 0.1, 0.0]);

    // æ±‚è§£æœ€ä¼˜æ§åˆ¶
    let (x, u) = lq_problem.solve_finite_time(&x0, 0.01);

    println!("å€’ç«‹æ‘†æœ€ä¼˜æ§åˆ¶ç»“æœï¼š");
    for (i, (state, control)) in x.iter().zip(u.iter()).enumerate() {
        if i % 100 == 0 {
            println!("t={:.1}s: ä½ç½®={:.3}m, è§’åº¦={:.3}rad, æ§åˆ¶={:.3}N",
                i as f64 * 0.01, state[0], state[2], control[0]);
        }
    }
}
```

### 8.2 æ—¶é—´æœ€ä¼˜æ§åˆ¶

```rust
/// æ—¶é—´æœ€ä¼˜æ§åˆ¶ç¤ºä¾‹
pub fn time_optimal_control_example() {
    // åŒç§¯åˆ†å™¨ç³»ç»Ÿ
    let A = DMatrix::from_row_slice(2, 2, &[0.0, 1.0, 0.0, 0.0]);
    let B = DMatrix::from_column_slice(2, 1, &[0.0, 1.0]);

    // æ—¶é—´æœ€ä¼˜æ§åˆ¶é—®é¢˜
    struct TimeOptimalCost;

    impl CostFunction for TimeOptimalCost {
        fn lagrangian(&self, _x: &DVector<f64>, _u: &DVector<f64>, _t: f64) -> f64 {
            1.0 // æœ€å°åŒ–æ—¶é—´
        }

        fn terminal_cost(&self, _x: &DVector<f64>, _t: f64) -> f64 {
            0.0
        }
    }

    struct DoubleIntegrator;

    impl SystemDynamics for DoubleIntegrator {
        fn dynamics(&self, x: &DVector<f64>, u: &DVector<f64>, _t: f64) -> DVector<f64> {
            DVector::from_column_slice(&[x[1], u[0]])
        }

        fn jacobian_x(&self, _x: &DVector<f64>, _u: &DVector<f64>, _t: f64) -> DMatrix<f64> {
            DMatrix::from_row_slice(2, 2, &[0.0, 1.0, 0.0, 0.0])
        }

        fn jacobian_u(&self, _x: &DVector<f64>, _u: &DVector<f64>, _t: f64) -> DMatrix<f64> {
            DMatrix::from_column_slice(2, 1, &[0.0, 1.0])
        }
    }

    let problem = OptimalControlProblem {
        t0: 0.0,
        tf: 5.0,
        x0: DVector::from_column_slice(&[1.0, 0.0]),
        xf: Some(DVector::from_column_slice(&[0.0, 0.0])),
    };

    let solver = OptimalControlSolver::new(TimeOptimalCost, DoubleIntegrator, problem);
    let (x, u) = solver.solve_maximum_principle(0.01);

    println!("æ—¶é—´æœ€ä¼˜æ§åˆ¶ç»“æœï¼š");
    for (i, (state, control)) in x.iter().zip(u.iter()).enumerate() {
        if i % 100 == 0 {
            println!("t={:.1}s: ä½ç½®={:.3}m, é€Ÿåº¦={:.3}m/s, æ§åˆ¶={:.3}m/sÂ²",
                i as f64 * 0.01, state[0], state[1], control[0]);
        }
    }
}
```

## 9. ç›¸å…³ç†è®º

### 9.1 ä¸å˜åˆ†æ³•çš„å…³ç³»

æœ€ä¼˜æ§åˆ¶ç†è®ºæ˜¯å˜åˆ†æ³•çš„æ¨å¹¿ï¼š

1. **çº¦æŸå¤„ç†**ï¼šæœ€ä¼˜æ§åˆ¶ç†è®ºå¯ä»¥å¤„ç†å¾®åˆ†æ–¹ç¨‹çº¦æŸ
2. **æ§åˆ¶çº¦æŸ**ï¼šå¯ä»¥å¤„ç†æ§åˆ¶å˜é‡çš„çº¦æŸæ¡ä»¶
3. **æ•°å€¼æ–¹æ³•**ï¼šæä¾›äº†æ›´æœ‰æ•ˆçš„æ•°å€¼æ±‚è§£æ–¹æ³•

### 9.2 ä¸åŠ¨æ€è§„åˆ’çš„å…³ç³»

æœ€ä¼˜æ§åˆ¶ç†è®ºä¸åŠ¨æ€è§„åˆ’å¯†åˆ‡ç›¸å…³ï¼š

1. **è´å°”æ›¼æ–¹ç¨‹**ï¼šåŠ¨æ€è§„åˆ’æä¾›äº†æ±‚è§£æœ€ä¼˜æ§åˆ¶é—®é¢˜çš„æ¡†æ¶
2. **å€¼å‡½æ•°**ï¼šé€šè¿‡å€¼å‡½æ•°å¯ä»¥æ„é€ æœ€ä¼˜æ§åˆ¶å¾‹
3. **æ•°å€¼å®ç°**ï¼šåŠ¨æ€è§„åˆ’æä¾›äº†æ•°å€¼æ±‚è§£æ–¹æ³•

### 9.3 ä¸é²æ£’æ§åˆ¶çš„å…³ç³»

æœ€ä¼˜æ§åˆ¶ç†è®ºä¸ºé²æ£’æ§åˆ¶æä¾›äº†åŸºç¡€ï¼š

1. **æ ‡ç§°è®¾è®¡**ï¼šåŸºäºæ ‡ç§°æ¨¡å‹è®¾è®¡æœ€ä¼˜æ§åˆ¶å™¨
2. **é²æ£’æ€§åˆ†æ**ï¼šåˆ†ææœ€ä¼˜æ§åˆ¶å™¨å¯¹å‚æ•°ä¸ç¡®å®šæ€§çš„é²æ£’æ€§
3. **é²æ£’ä¼˜åŒ–**ï¼šåœ¨ä¸ç¡®å®šæ€§ä¸‹è¿›è¡Œä¼˜åŒ–è®¾è®¡

## 10. å‚è€ƒæ–‡çŒ®

1. Kirk, D. E. (2012). Optimal Control Theory: An Introduction. Dover Publications.
2. Lewis, F. L., Vrabie, D., & Syrmos, V. L. (2012). Optimal Control. John Wiley & Sons.
3. Bryson, A. E., & Ho, Y. C. (1975). Applied Optimal Control: Optimization, Estimation, and Control. Hemisphere.
4. Pontryagin, L. S., Boltyanskii, V. G., Gamkrelidze, R. V., & Mishchenko, E. F. (1962). The Mathematical Theory of Optimal Processes. Interscience.
5. Bellman, R. (1957). Dynamic Programming. Princeton University Press.
6. Bertsekas, D. P. (2017). Dynamic Programming and Optimal Control. Athena Scientific.
7. Anderson, B. D., & Moore, J. B. (1990). Optimal Control: Linear Quadratic Methods. Prentice Hall.
8. Kwakernaak, H., & Sivan, R. (1972). Linear Optimal Control Systems. Wiley-Interscience.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [05.2.1 ç°ä»£æ§åˆ¶ç†è®º](05.2.1_ç°ä»£æ§åˆ¶ç†è®º.md)
- [05.2.3 é²æ£’æ§åˆ¶ç†è®º](05.2.3_é²æ£’æ§åˆ¶ç†è®º.md)
- [05.3.1 éçº¿æ€§æ§åˆ¶ç†è®º](05.3.1_éçº¿æ€§æ§åˆ¶ç†è®º.md)
- [05.3.2 è‡ªé€‚åº”æ§åˆ¶ç†è®º](05.3.2_è‡ªé€‚åº”æ§åˆ¶ç†è®º.md)

## æ‰¹åˆ¤æ€§åˆ†æ

### å¤šå…ƒç†è®ºè§†è§’

**å˜åˆ†/æå¤§å€¼è§†è§’**ï¼šæä¾›å¿…è¦æ¡ä»¶ï¼ˆEL/Hamiltonian/MPï¼‰ï¼Œç†è®ºä¼˜é›…ä½†æ˜“é™·å±€éƒ¨æœ€ä¼˜ä¸æ•°å€¼ä¸ç¨³ã€‚

**åŠ¨æ€è§„åˆ’è§†è§’**ï¼šä»¥HJBä¸ºæ ¸å¿ƒå…·å……åˆ†æ€§ï¼Œä½†ç»´åº¦ç¾éš¾é™åˆ¶é«˜ç»´åº”ç”¨ã€‚

**å·¥ç¨‹æ•°å€¼è§†è§’**ï¼šç›´æ¥æ³•/é—´æ¥æ³•ã€è½¨è¿¹ä¼˜åŒ–ã€SQP/å†…ç‚¹å¹¿æ³›ä½¿ç”¨ï¼Œæ”¶æ•›ä¸å…¨å±€æ€§ç¼ºä¹ç»Ÿä¸€ä¿è¯ã€‚

### å±€é™æ€§åˆ†æ

**æ¨¡å‹ä¾èµ–ä¸ç¨³å¥æ€§**ï¼šæ ‡ç§°æœ€ä¼˜å¯¹æ¨¡å‹è¯¯å·®æ•æ„Ÿï¼Œæ€§èƒ½ä¸ç¨³å®šè£•åº¦å¯èƒ½åœ¨å®é™…ä¸­é€€åŒ–ã€‚

**çº¦æŸå¤æ‚æ€§**ï¼šè·¯å¾„/ç»ˆç«¯/è¾“å…¥é¥±å’Œ/å®‰å…¨çº¦æŸä¼šæ˜¾è‘—å¢åŠ æ±‚è§£éš¾åº¦ä¸è®¡ç®—æˆæœ¬ã€‚

**å®æ—¶æ€§**ï¼šåœ¨çº¿ä¼˜åŒ–ï¼ˆMPCï¼‰åœ¨é«˜ç»´ç³»ç»Ÿæˆ–ç¡¬å®æ—¶åœºæ™¯å—é™äºç®—åŠ›ä¸å¯é¢„è§æ€§ã€‚

### äº‰è®®ä¸åˆ†æ­§

**å¿…è¦vså……åˆ†**ï¼šMPç»™å‡ºå¿…è¦æ¡ä»¶ï¼ŒHJBæä¾›å……åˆ†æ¡ä»¶ä½†éš¾è§£ï¼›äºŒè€…åœ¨å·¥ç¨‹ä¸­çš„ä¼˜å…ˆçº§ä¸å–èˆå¸¸æœ‰åˆ†æ­§ã€‚

**å…¨å±€vså±€éƒ¨**ï¼šæ˜¯å¦è¿½æ±‚å…¨å±€æœ€ä¼˜è¿˜æ˜¯å·¥ç¨‹ä¸Šâ€œè¶³å¤Ÿå¥½â€çš„å±€éƒ¨æœ€ä¼˜ï¼Œé¢†åŸŸåå¥½ä¸åŒã€‚

**æœ€ä¼˜vsé²æ£’**ï¼šæ€§èƒ½æœ€ä¼˜ä¸æœ€åæƒ…å½¢ä¿è¯çš„æƒè¡¡ï¼Œé²æ£’æœ€ä¼˜åŒ–ä¸åˆ†å¸ƒé²æ£’ä¼˜åŒ–çš„è¾¹ç•Œä¸æˆæœ¬äº‰è®®å¤§ã€‚

### åº”ç”¨å‰æ™¯

**MPCä¸å·¥ä¸šè½åœ°**ï¼šåœ¨æµç¨‹ã€èƒ½æºã€åŒ–å·¥ã€è‡ªåŠ¨é©¾é©¶ä¸­ç»§ç»­æ‰©å¼ ï¼Œé‡è§†è½¯ç¡¬çº¦æŸä¸ç»æµMPCã€‚

**è½¨è¿¹ä¼˜åŒ–ä¸è‡ªä¸»ç³»ç»Ÿ**ï¼šèˆªå¤©/æœºå™¨äºº/ç‰©æµçš„åœ¨çº¿è½¨è¿¹ç”Ÿæˆä¸å†è§„åˆ’éœ€æ±‚æ—ºç››ã€‚

**æ•°æ®åŒåŒ–ä¸å­¦ä¹ å¢å¼º**ï¼šå°†å¼ºåŒ–å­¦ä¹ /æ¨¡ä»¿å­¦ä¹ ä¸æœ€ä¼˜æ§åˆ¶ç»“åˆï¼Œå®ç°å¯è¿ç§»çš„æ§åˆ¶ç­–ç•¥ã€‚

### æ”¹è¿›å»ºè®®

**é²æ£’-æœ€ä¼˜èåˆ**ï¼šå¼•å…¥ä¸ç¡®å®šæ€§é›†ä¸é£é™©åº¦é‡ï¼ˆCVaR/DRSOï¼‰ï¼Œå®ç°æ€§èƒ½-é²æ£’ååŒã€‚

**å¯è®¡ç®—æ€§å·¥ç¨‹**ï¼šå¼€å‘å¯é¢„æœŸå®æ—¶æ€§çš„æ±‚è§£å™¨ã€æš–å¯åŠ¨ä¸åˆ†å¸ƒå¼å¹¶è¡Œè®¡ç®—ã€‚

**å®‰å…¨ä¸ä¿è¯**ï¼šç»“åˆCBFã€å®‰å…¨çº¦æŸMPCä¸å½¢å¼åŒ–æ–¹æ³•ï¼Œæä¾›å¯éªŒè¯çš„å®‰å…¨æœ€ä¼˜æ§åˆ¶ã€‚
