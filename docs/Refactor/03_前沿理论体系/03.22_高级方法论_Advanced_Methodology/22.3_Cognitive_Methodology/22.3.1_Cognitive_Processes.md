# 22.3.1 è®¤çŸ¥è¿‡ç¨‹ (Cognitive Processes)

## ğŸ“‹ ç†è®ºæ¦‚è¿°

è®¤çŸ¥è¿‡ç¨‹æ˜¯äººç±»æ€ç»´å’Œä¿¡æ¯å¤„ç†çš„åŸºæœ¬æœºåˆ¶ï¼ŒåŒ…æ‹¬æ„ŸçŸ¥ã€æ³¨æ„ã€è®°å¿†ã€æ€ç»´ã€è¯­è¨€ç­‰æ ¸å¿ƒè¿‡ç¨‹ã€‚
æœ¬ç†è®ºæ¶µç›–è®¤çŸ¥è¿‡ç¨‹çš„åŸºæœ¬åŸç†ã€ä¿¡æ¯å¤„ç†æ¨¡å‹ã€è®¤çŸ¥æ¶æ„ç­‰æ ¸å¿ƒæ¦‚å¿µï¼Œä¸ºç†è§£äººç±»æ€ç»´å’Œè®¾è®¡æ™ºèƒ½ç³»ç»Ÿæä¾›ç†è®ºåŸºç¡€ã€‚

## ğŸ”¬ å½¢å¼åŒ–è¯­ä¹‰

### æ ¸å¿ƒå®šä¹‰

**å®šä¹‰ 1.1** (è®¤çŸ¥è¿‡ç¨‹)
è®¤çŸ¥è¿‡ç¨‹æ˜¯ä¿¡æ¯åœ¨è®¤çŸ¥ç³»ç»Ÿä¸­çš„å¤„ç†æµç¨‹ï¼š$CP = (I, P, M, O)$ï¼Œå…¶ä¸­ï¼š

- $I$ æ˜¯è¾“å…¥é›†åˆï¼š$I = \{i_1, i_2, \ldots, i_n\}$
- $P$ æ˜¯å¤„ç†é›†åˆï¼š$P = \{p_1, p_2, \ldots, p_m\}$
- $M$ æ˜¯è®°å¿†é›†åˆï¼š$M = \{m_1, m_2, \ldots, m_k\}$
- $O$ æ˜¯è¾“å‡ºé›†åˆï¼š$O = \{o_1, o_2, \ldots, o_l\}$

**å®šä¹‰ 1.2** (æ„ŸçŸ¥è¿‡ç¨‹)
æ„ŸçŸ¥è¿‡ç¨‹æ˜¯å¤–éƒ¨åˆºæ¿€è½¬æ¢ä¸ºå†…éƒ¨è¡¨å¾çš„è¿‡ç¨‹ï¼š$P = \{s_1, s_2, \ldots, s_n\} \rightarrow \{r_1, r_2, \ldots, r_m\}$

**å®šä¹‰ 1.3** (æ³¨æ„æœºåˆ¶)
æ³¨æ„æœºåˆ¶æ˜¯é€‰æ‹©æ€§ä¿¡æ¯å¤„ç†çš„è¿‡ç¨‹ï¼š$A = \{f_1, f_2, \ldots, f_n\} \rightarrow \{s_1, s_2, \ldots, s_k\}$

**å®šä¹‰ 1.4** (è®°å¿†ç³»ç»Ÿ)
è®°å¿†ç³»ç»Ÿæ˜¯ä¿¡æ¯å­˜å‚¨å’Œæ£€ç´¢çš„æœºåˆ¶ï¼š$M = (S, R, L)$ï¼Œå…¶ä¸­ï¼š

- $S$ æ˜¯å­˜å‚¨é›†åˆï¼š$S = \{s_1, s_2, \ldots, s_n\}$
- $R$ æ˜¯æ£€ç´¢é›†åˆï¼š$R = \{r_1, r_2, \ldots, r_m\}$
- $L$ æ˜¯å­¦ä¹ é›†åˆï¼š$L = \{l_1, l_2, \ldots, l_k\}$

### æ ¸å¿ƒå®šç†

**å®šç† 1.1** (è®¤çŸ¥å®¹é‡é™åˆ¶)
äººç±»è®¤çŸ¥ç³»ç»Ÿå­˜åœ¨å®¹é‡é™åˆ¶ï¼š
$\exists C : |P| \leq C$

**å®šç† 1.2** (æ³¨æ„é€‰æ‹©æ€§)
æ³¨æ„è¿‡ç¨‹å…·æœ‰é€‰æ‹©æ€§ç‰¹å¾ï¼š
$\forall i \in I, \exists a \in A : a(i) \in \{0, 1\}$

**å®šç† 1.3** (è®°å¿†è¡°å‡)
è®°å¿†å¼ºåº¦éšæ—¶é—´è¡°å‡ï¼š
$M(t) = M_0 \cdot e^{-\lambda t}$

## ğŸ¯ å¤šè¡¨å¾æ–¹å¼

### 1. å›¾å½¢è¡¨å¾

```mermaid
graph TD
    A[æ„Ÿè§‰è¾“å…¥] --> B[æ„ŸçŸ¥å¤„ç†]
    B --> C[æ³¨æ„é€‰æ‹©]
    C --> D[å·¥ä½œè®°å¿†]
    D --> E[é•¿æœŸè®°å¿†]
    E --> F[æ€ç»´æ¨ç†]
    F --> G[è¡Œä¸ºè¾“å‡º]
    G --> H[åé¦ˆå¾ªç¯]
    H --> A
```

### 2. è¡¨æ ¼è¡¨å¾

| è®¤çŸ¥è¿‡ç¨‹ | ä¸»è¦åŠŸèƒ½ | å¤„ç†æœºåˆ¶ | æ—¶é—´å°ºåº¦ |
|---------|---------|---------|----------|
| æ„ŸçŸ¥ | ä¿¡æ¯æ¥æ”¶ | æ¨¡å¼è¯†åˆ« | æ¯«ç§’çº§ |
| æ³¨æ„ | ä¿¡æ¯é€‰æ‹© | é€‰æ‹©æ€§è¿‡æ»¤ | ç§’çº§ |
| è®°å¿† | ä¿¡æ¯å­˜å‚¨ | ç¼–ç æ£€ç´¢ | åˆ†é’Ÿåˆ°å¹´ |
| æ€ç»´ | ä¿¡æ¯æ¨ç† | é€»è¾‘è¿ç®— | ç§’åˆ°åˆ†é’Ÿ |
| è¯­è¨€ | ä¿¡æ¯è¡¨è¾¾ | ç¬¦å·å¤„ç† | ç§’çº§ |

### 3. æ•°å­¦è¡¨å¾

**ä¿¡æ¯å¤„ç†å‡½æ•°**ï¼š
$f_{process}(input) = \sum_{i=1}^{n} w_i \cdot f_i(input)$

**æ³¨æ„æƒé‡å‡½æ•°**ï¼š
$A(x) = \frac{e^{s(x)}}{\sum_{i} e^{s(i)}}$

**è®°å¿†è¡°å‡å‡½æ•°**ï¼š
$M(t) = M_0 \cdot e^{-\lambda t} + M_{base}$

### 4. ä¼ªä»£ç è¡¨å¾

```python
class CognitiveProcess:
    def __init__(self):
        self.sensory_input = []
        self.attention = Attention()
        self.working_memory = WorkingMemory()
        self.long_term_memory = LongTermMemory()

    def process_input(self, stimulus):
        """å¤„ç†è¾“å…¥åˆºæ¿€"""
        # æ„ŸçŸ¥å¤„ç†
        perception = self.perceive(stimulus)

        # æ³¨æ„é€‰æ‹©
        attended = self.attention.select(perception)

        # å·¥ä½œè®°å¿†å¤„ç†
        self.working_memory.store(attended)

        # é•¿æœŸè®°å¿†æ£€ç´¢
        relevant_memory = self.long_term_memory.retrieve(attended)

        # æ€ç»´æ¨ç†
        reasoning = self.reason(attended, relevant_memory)

        return reasoning

    def perceive(self, stimulus):
        """æ„ŸçŸ¥å¤„ç†"""
        return self.sensory_processing(stimulus)

    def reason(self, current, memory):
        """æ€ç»´æ¨ç†"""
        return self.cognitive_reasoning(current, memory)
```

## ğŸ’» Rustå®ç°

```rust
use std::collections::HashMap;
use std::fmt;

/// è®¤çŸ¥åˆºæ¿€
#[derive(Debug, Clone)]
pub struct Stimulus {
    pub id: String,
    pub modality: String, // è§†è§‰ã€å¬è§‰ç­‰
    pub intensity: f64,
    pub features: HashMap<String, f64>,
    pub timestamp: u64,
}

/// æ„ŸçŸ¥è¡¨å¾
#[derive(Debug, Clone)]
pub struct Perception {
    pub id: String,
    pub stimulus_id: String,
    pub features: HashMap<String, f64>,
    pub confidence: f64,
    pub processing_time: u64,
}

/// æ³¨æ„ç„¦ç‚¹
#[derive(Debug, Clone)]
pub struct AttentionFocus {
    pub id: String,
    pub target_id: String,
    pub priority: f64,
    pub duration: u64,
    pub resources: f64,
}

/// è®°å¿†é¡¹ç›®
#[derive(Debug, Clone)]
pub struct MemoryItem {
    pub id: String,
    pub content: String,
    pub strength: f64,
    pub last_accessed: u64,
    pub access_count: u32,
    pub associations: Vec<String>,
}

/// å·¥ä½œè®°å¿†
#[derive(Debug)]
pub struct WorkingMemory {
    pub capacity: usize,
    pub items: Vec<MemoryItem>,
    pub current_focus: Option<String>,
}

/// é•¿æœŸè®°å¿†
#[derive(Debug)]
pub struct LongTermMemory {
    pub items: HashMap<String, MemoryItem>,
    pub associations: HashMap<String, Vec<String>>,
    pub decay_rate: f64,
}

/// è®¤çŸ¥è¿‡ç¨‹
#[derive(Debug)]
pub struct CognitiveProcess {
    pub id: String,
    pub working_memory: WorkingMemory,
    pub long_term_memory: LongTermMemory,
    pub attention: AttentionSystem,
    pub processing_history: Vec<ProcessingStep>,
    pub current_time: u64,
}

/// æ³¨æ„ç³»ç»Ÿ
#[derive(Debug)]
pub struct AttentionSystem {
    pub capacity: f64,
    pub current_focus: Vec<AttentionFocus>,
    pub salience_map: HashMap<String, f64>,
}

/// å¤„ç†æ­¥éª¤
#[derive(Debug, Clone)]
pub struct ProcessingStep {
    pub step_id: String,
    pub process_type: String,
    pub input: String,
    pub output: String,
    pub duration: u64,
    pub success: bool,
}

impl CognitiveProcess {
    /// åˆ›å»ºæ–°çš„è®¤çŸ¥è¿‡ç¨‹
    pub fn new(id: String) -> Self {
        Self {
            id,
            working_memory: WorkingMemory {
                capacity: 7, // ç±³å‹’å®šå¾‹
                items: Vec::new(),
                current_focus: None,
            },
            long_term_memory: LongTermMemory {
                items: HashMap::new(),
                associations: HashMap::new(),
                decay_rate: 0.1,
            },
            attention: AttentionSystem {
                capacity: 1.0,
                current_focus: Vec::new(),
                salience_map: HashMap::new(),
            },
            processing_history: Vec::new(),
            current_time: 0,
        }
    }

    /// å¤„ç†è®¤çŸ¥åˆºæ¿€
    pub fn process_stimulus(&mut self, stimulus: Stimulus) -> ProcessingResult {
        let mut result = ProcessingResult::new();

        // æ„ŸçŸ¥å¤„ç†
        let perception = self.perceive_stimulus(&stimulus);
        result.add_step("æ„ŸçŸ¥å¤„ç†", &stimulus.id, &perception.id);

        // æ³¨æ„é€‰æ‹©
        let attended = self.attend_to_stimulus(&perception);
        result.add_step("æ³¨æ„é€‰æ‹©", &perception.id, &attended.id);

        // å·¥ä½œè®°å¿†å­˜å‚¨
        let memory_item = self.store_in_working_memory(&attended);
        result.add_step("å·¥ä½œè®°å¿†å­˜å‚¨", &attended.id, &memory_item.id);

        // é•¿æœŸè®°å¿†æ£€ç´¢
        let relevant_memories = self.retrieve_from_long_term_memory(&memory_item);
        result.add_step("é•¿æœŸè®°å¿†æ£€ç´¢", &memory_item.id, &format!("{}ä¸ªç›¸å…³è®°å¿†", relevant_memories.len()));

        // è®¤çŸ¥æ¨ç†
        let reasoning = self.cognitive_reasoning(&memory_item, &relevant_memories);
        result.add_step("è®¤çŸ¥æ¨ç†", &memory_item.id, &reasoning);

        result
    }

    /// æ„ŸçŸ¥åˆºæ¿€
    fn perceive_stimulus(&self, stimulus: &Stimulus) -> Perception {
        // æ¨¡æ‹Ÿæ„ŸçŸ¥å¤„ç†
        let mut features = HashMap::new();
        for (key, value) in &stimulus.features {
            features.insert(key.clone(), value * 0.8 + 0.2); // æ·»åŠ å™ªå£°
        }

        Perception {
            id: format!("PER_{}", stimulus.id),
            stimulus_id: stimulus.id.clone(),
            features,
            confidence: 0.85,
            processing_time: 50, // æ¯«ç§’
        }
    }

    /// æ³¨æ„é€‰æ‹©
    fn attend_to_stimulus(&mut self, perception: &Perception) -> AttentionFocus {
        // è®¡ç®—æ˜¾è‘—æ€§
        let salience = self.calculate_salience(perception);

        // æ›´æ–°æ˜¾è‘—æ€§å›¾
        self.attention.salience_map.insert(perception.id.clone(), salience);

        // é€‰æ‹©æ³¨æ„ç„¦ç‚¹
        let focus = AttentionFocus {
            id: format!("ATT_{}", perception.id),
            target_id: perception.id.clone(),
            priority: salience,
            duration: 200, // æ¯«ç§’
            resources: salience * self.attention.capacity,
        };

        self.attention.current_focus.push(focus.clone());
        focus
    }

    /// å­˜å‚¨åˆ°å·¥ä½œè®°å¿†
    fn store_in_working_memory(&mut self, attended: &AttentionFocus) -> MemoryItem {
        let memory_item = MemoryItem {
            id: format!("WM_{}", attended.id),
            content: format!("æ³¨æ„ç„¦ç‚¹: {}", attended.target_id),
            strength: attended.priority,
            last_accessed: self.current_time,
            access_count: 1,
            associations: vec![attended.target_id.clone()],
        };

        // æ£€æŸ¥å®¹é‡é™åˆ¶
        if self.working_memory.items.len() >= self.working_memory.capacity {
            // ç§»é™¤æœ€å¼±çš„é¡¹ç›®
            self.working_memory.items.sort_by(|a, b| a.strength.partial_cmp(&b.strength).unwrap());
            self.working_memory.items.remove(0);
        }

        self.working_memory.items.push(memory_item.clone());
        memory_item
    }

    /// ä»é•¿æœŸè®°å¿†æ£€ç´¢
    fn retrieve_from_long_term_memory(&mut self, memory_item: &MemoryItem) -> Vec<MemoryItem> {
        let mut relevant_memories = Vec::new();

        for (id, item) in &self.long_term_memory.items {
            // è®¡ç®—ç›¸å…³æ€§
            let relevance = self.calculate_relevance(memory_item, item);

            if relevance > 0.5 {
                // æ›´æ–°è®¿é—®ä¿¡æ¯
                let mut updated_item = item.clone();
                updated_item.last_accessed = self.current_time;
                updated_item.access_count += 1;
                updated_item.strength = self.update_memory_strength(item);

                self.long_term_memory.items.insert(id.clone(), updated_item.clone());
                relevant_memories.push(updated_item);
            }
        }

        relevant_memories
    }

    /// è®¤çŸ¥æ¨ç†
    fn cognitive_reasoning(&self, current: &MemoryItem, memories: &[MemoryItem]) -> String {
        // æ¨¡æ‹Ÿæ¨ç†è¿‡ç¨‹
        let reasoning_patterns = vec![
            "æ¨¡å¼åŒ¹é…".to_string(),
            "ç±»æ¯”æ¨ç†".to_string(),
            "é€»è¾‘æ¨ç†".to_string(),
            "åˆ›é€ æ€§æ€ç»´".to_string(),
        ];

        let selected_pattern = reasoning_patterns[self.current_time as usize % reasoning_patterns.len()];

        format!("åŸºäº{}çš„æ¨ç†ç»“æœ", selected_pattern)
    }

    /// è®¡ç®—æ˜¾è‘—æ€§
    fn calculate_salience(&self, perception: &Perception) -> f64 {
        // åŸºäºç‰¹å¾å¼ºåº¦è®¡ç®—æ˜¾è‘—æ€§
        let feature_strength: f64 = perception.features.values().sum();
        let novelty = 1.0 / (1.0 + perception.access_count as f64);

        feature_strength * novelty
    }

    /// è®¡ç®—ç›¸å…³æ€§
    fn calculate_relevance(&self, item1: &MemoryItem, item2: &MemoryItem) -> f64 {
        // åŸºäºå†…å®¹ç›¸ä¼¼æ€§è®¡ç®—ç›¸å…³æ€§
        let content_similarity = self.calculate_content_similarity(&item1.content, &item2.content);
        let association_strength = self.calculate_association_strength(item1, item2);

        content_similarity * 0.7 + association_strength * 0.3
    }

    /// è®¡ç®—å†…å®¹ç›¸ä¼¼æ€§
    fn calculate_content_similarity(&self, content1: &str, content2: &str) -> f64 {
        // ç®€åŒ–çš„ç›¸ä¼¼æ€§è®¡ç®—
        let words1: Vec<&str> = content1.split_whitespace().collect();
        let words2: Vec<&str> = content2.split_whitespace().collect();

        let common_words = words1.iter().filter(|w| words2.contains(w)).count();
        let total_words = words1.len().max(words2.len());

        if total_words == 0 { 0.0 } else { common_words as f64 / total_words as f64 }
    }

    /// è®¡ç®—å…³è”å¼ºåº¦
    fn calculate_association_strength(&self, item1: &MemoryItem, item2: &MemoryItem) -> f64 {
        let common_associations = item1.associations.iter()
            .filter(|a| item2.associations.contains(a))
            .count();

        let total_associations = item1.associations.len() + item2.associations.len();

        if total_associations == 0 { 0.0 } else { common_associations as f64 / total_associations as f64 }
    }

    /// æ›´æ–°è®°å¿†å¼ºåº¦
    fn update_memory_strength(&self, item: &MemoryItem) -> f64 {
        let time_decay = (-self.long_term_memory.decay_rate *
            (self.current_time - item.last_accessed) as f64).exp();

        let access_boost = 1.0 + (item.access_count as f64 * 0.1);

        (item.strength * time_decay * access_boost).min(1.0)
    }

    /// è·å–è®¤çŸ¥çŠ¶æ€
    pub fn get_cognitive_state(&self) -> CognitiveState {
        CognitiveState {
            working_memory_load: self.working_memory.items.len() as f64 / self.working_memory.capacity as f64,
            attention_load: self.attention.current_focus.len() as f64,
            long_term_memory_size: self.long_term_memory.items.len(),
            processing_steps: self.processing_history.len(),
        }
    }
}

/// å¤„ç†ç»“æœ
#[derive(Debug)]
pub struct ProcessingResult {
    pub steps: Vec<ProcessingStep>,
    pub final_output: String,
    pub success: bool,
}

impl ProcessingResult {
    pub fn new() -> Self {
        Self {
            steps: Vec::new(),
            final_output: String::new(),
            success: true,
        }
    }

    pub fn add_step(&mut self, process_type: &str, input: &str, output: &str) {
        let step = ProcessingStep {
            step_id: format!("STEP_{}", self.steps.len() + 1),
            process_type: process_type.to_string(),
            input: input.to_string(),
            output: output.to_string(),
            duration: 100, // æ¯«ç§’
            success: true,
        };
        self.steps.push(step);
    }
}

/// è®¤çŸ¥çŠ¶æ€
#[derive(Debug)]
pub struct CognitiveState {
    pub working_memory_load: f64,
    pub attention_load: f64,
    pub long_term_memory_size: usize,
    pub processing_steps: usize,
}

// ç¤ºä¾‹ä½¿ç”¨
fn main() {
    let mut cognitive_process = CognitiveProcess::new("CP_001".to_string());

    // åˆ›å»ºåˆºæ¿€
    let stimulus = Stimulus {
        id: "STIM_001".to_string(),
        modality: "è§†è§‰".to_string(),
        intensity: 0.8,
        features: HashMap::from([
            ("é¢œè‰²".to_string(), 0.9),
            ("å½¢çŠ¶".to_string(), 0.7),
            ("å¤§å°".to_string(), 0.5),
        ]),
        timestamp: 0,
    };

    // å¤„ç†åˆºæ¿€
    let result = cognitive_process.process_stimulus(stimulus);
    println!("å¤„ç†ç»“æœ: {:?}", result);

    // è·å–è®¤çŸ¥çŠ¶æ€
    let state = cognitive_process.get_cognitive_state();
    println!("è®¤çŸ¥çŠ¶æ€: {:?}", state);

    // æ¨¡æ‹Ÿå¤šä¸ªåˆºæ¿€å¤„ç†
    for i in 1..5 {
        let new_stimulus = Stimulus {
            id: format!("STIM_{:03}", i),
            modality: "å¬è§‰".to_string(),
            intensity: 0.6 + (i as f64 * 0.1),
            features: HashMap::from([
                ("éŸ³è°ƒ".to_string(), 0.8),
                ("éŸ³é‡".to_string(), 0.6),
                ("æŒç»­æ—¶é—´".to_string(), 0.4),
            ]),
            timestamp: i as u64,
        };

        let result = cognitive_process.process_stimulus(new_stimulus);
        println!("åˆºæ¿€{}å¤„ç†ç»“æœ: {:?}", i, result);
    }
}
```

## ğŸ§  å“²å­¦æ€§æ‰¹åˆ¤ä¸å±•æœ›

### æœ¬ä½“è®ºåæ€

**è®¤çŸ¥è¿‡ç¨‹çš„æœ¬è´¨**ï¼š
è®¤çŸ¥è¿‡ç¨‹æ­ç¤ºäº†äººç±»æ€ç»´å’Œä¿¡æ¯å¤„ç†çš„å“²å­¦æœ¬è´¨ã€‚å®ƒä¸æ˜¯ç®€å•çš„æœºæ¢°è¿‡ç¨‹ï¼Œè€Œæ˜¯å…·æœ‰æ¶Œç°æ€§ã€éçº¿æ€§ã€è‡ªç»„ç»‡ç­‰ç‰¹å¾çš„æœ‰æœºè¿‡ç¨‹ã€‚è¿™ç§å¤æ‚æ€§æŒ‘æˆ˜äº†ä¼ ç»Ÿçš„æœºæ¢°è®ºä¸–ç•Œè§‚ã€‚

**æ„è¯†ä¸è®¤çŸ¥çš„å…³ç³»**ï¼š
è®¤çŸ¥è¿‡ç¨‹ä¸æ„è¯†çš„å…³ç³»æ˜¯å“²å­¦çš„æ ¸å¿ƒé—®é¢˜ã€‚è®¤çŸ¥è¿‡ç¨‹æ˜¯å¦ç­‰åŒäºæ„è¯†ï¼Œè¿˜æ˜¯æ„è¯†æ˜¯è®¤çŸ¥è¿‡ç¨‹çš„æ¶Œç°æ€§è´¨ï¼Œè¿™ä¸ªé—®é¢˜éœ€è¦æ·±å…¥çš„å“²å­¦æ€è€ƒã€‚

### è®¤è¯†è®ºæ‰¹åˆ¤

**è®¤çŸ¥è¿‡ç¨‹çš„å±€é™æ€§**ï¼š
äººç±»è®¤çŸ¥è¿‡ç¨‹å­˜åœ¨æ ¹æœ¬æ€§å±€é™ã€‚æˆ‘ä»¬æ— æ³•å®Œå…¨ç†è§£è‡ªå·±çš„è®¤çŸ¥è¿‡ç¨‹ï¼Œè¿™ç§è®¤çŸ¥çš„è®¤çŸ¥ï¼ˆå…ƒè®¤çŸ¥ï¼‰å­˜åœ¨å¾ªç¯æ€§é—®é¢˜ã€‚

**è®¤çŸ¥åè§çš„å½±å“**ï¼š
è®¤çŸ¥è¿‡ç¨‹ä¸­å­˜åœ¨å„ç§åè§å’Œå¯å‘å¼ï¼Œè¿™äº›åè§å½±å“æˆ‘ä»¬çš„åˆ¤æ–­å’Œå†³ç­–ã€‚è®¤è¯†åˆ°è¿™äº›åè§æ˜¯è®¤çŸ¥ç§‘å­¦çš„é‡è¦è´¡çŒ®ã€‚

### ç¤¾ä¼šå½±å“åˆ†æ

**è®¤çŸ¥ç§‘å­¦çš„ç¤¾ä¼šä»·å€¼**ï¼š
è®¤çŸ¥ç§‘å­¦ä¸ºç¤¾ä¼šé—®é¢˜è§£å†³æä¾›äº†æ–°çš„è§†è§’ã€‚å®ƒå¸®åŠ©æˆ‘ä»¬ç†è§£äººç±»æ€ç»´çš„æœ¬è´¨ï¼Œæœ‰åŠ©äºè®¾è®¡æ›´å¥½çš„æ•™è‚²ã€åŒ»ç–—å’Œç¤¾ä¼šç³»ç»Ÿã€‚

**è®¤çŸ¥æŠ€æœ¯çš„ç¤¾ä¼šè´£ä»»**ï¼š
è®¤çŸ¥æŠ€æœ¯çš„åº”ç”¨éœ€è¦è€ƒè™‘ç¤¾ä¼šå½±å“å’Œä¼¦ç†è´£ä»»ã€‚è®¤çŸ¥å¢å¼ºæŠ€æœ¯åº”è¯¥æœåŠ¡äºäººç±»çš„ç¦ç¥‰ï¼Œè€Œä¸æ˜¯åŠ å‰§ç¤¾ä¼šä¸å¹³ç­‰ã€‚

### ç»ˆæå“²å­¦å»ºè®®

**å¤šå…ƒè®¤çŸ¥ç†è®ºçš„èåˆ**ï¼š
æœªæ¥åº”è¯¥å‘å±•å¤šå…ƒåŒ–çš„è®¤çŸ¥ç†è®ºä½“ç³»ï¼Œèåˆä¸åŒå­¦ç§‘å’Œå“²å­¦ä¼ ç»Ÿçš„è®¤çŸ¥æ€æƒ³ã€‚

**è®¤çŸ¥ç§‘å­¦çš„æ°‘ä¸»åŒ–**ï¼š
è®¤çŸ¥ç§‘å­¦åº”è¯¥æ›´åŠ æ°‘ä¸»åŒ–ï¼Œè®©æ›´å¤šäººèƒ½å¤Ÿç†è§£å’Œåº”ç”¨è®¤çŸ¥ç§‘å­¦çŸ¥è¯†ã€‚

**è®¤çŸ¥ç§‘å­¦çš„ç”Ÿæ€åŒ–**ï¼š
è®¤çŸ¥ç§‘å­¦åº”è¯¥æ›´åŠ å…³æ³¨ç”Ÿæ€ç³»ç»Ÿçš„æ•´ä½“æ€§ï¼Œå‘å±•ç”Ÿæ€å‹å¥½çš„è®¤çŸ¥ç†è®ºã€‚

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Anderson, J. R. _Cognitive Psychology and Its Implications_. Worth Publishers, 2015.
2. Baddeley, A. _Working Memory, Thought, and Action_. Oxford University Press, 2007.
3. Kahneman, D. _Thinking, Fast and Slow_. Farrar, Straus and Giroux, 2011.
4. Posner, M. I. _Attention in a Social World_. Oxford University Press, 2012.
5. Tulving, E. _Elements of Episodic Memory_. Oxford University Press, 1983.
