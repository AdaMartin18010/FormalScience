# 23.1.3 é‡å­ç”µè·¯ (Quantum Circuits)

## ğŸ“‹ ç†è®ºæ¦‚è¿°

é‡å­ç”µè·¯æ˜¯é‡å­è®¡ç®—çš„åŸºæœ¬æ¶æ„ï¼Œç”±é‡å­æ¯”ç‰¹ã€é‡å­é—¨å’Œæµ‹é‡æ“ä½œç»„æˆã€‚æœ¬ç†è®ºæ¶µç›–é‡å­ç”µè·¯çš„è¡¨ç¤ºã€ä¼˜åŒ–ã€æ¨¡æ‹Ÿç­‰æ ¸å¿ƒæ¦‚å¿µï¼Œä¸ºç†è§£é‡å­è®¡ç®—çš„å®ç°åŸºç¡€æä¾›ç†è®ºæ”¯æ’‘ã€‚

## ğŸ”¬ å½¢å¼åŒ–è¯­ä¹‰

### æ ¸å¿ƒå®šä¹‰

**å®šä¹‰ 3.1** (é‡å­ç”µè·¯)
é‡å­ç”µè·¯æ˜¯ç”±é‡å­æ¯”ç‰¹ã€é‡å­é—¨å’Œæµ‹é‡æ“ä½œç»„æˆçš„è®¡ç®—æ¨¡å‹ï¼š$C = (Q, G, M)$ï¼Œå…¶ä¸­ï¼š

- $Q = \{q_1, q_2, ..., q_n\}$ æ˜¯é‡å­æ¯”ç‰¹é›†åˆ
- $G = \{g_1, g_2, ..., g_m\}$ æ˜¯é‡å­é—¨åºåˆ—
- $M = \{m_1, m_2, ..., m_k\}$ æ˜¯æµ‹é‡æ“ä½œ

**å®šä¹‰ 3.2** (ç”µè·¯æ·±åº¦)
ç”µè·¯æ·±åº¦æ˜¯ç”µè·¯ä¸­ä»»æ„è·¯å¾„ä¸Šçš„æœ€å¤§é—¨æ•°ï¼š$D(C) = \max_{p \in P} |p|$

**å®šä¹‰ 3.3** (ç”µè·¯å®½åº¦)
ç”µè·¯å®½åº¦æ˜¯ç”µè·¯ä¸­é‡å­æ¯”ç‰¹çš„æ•°é‡ï¼š$W(C) = |Q|$

**å®šä¹‰ 3.4** (ç”µè·¯å¤æ‚åº¦)
ç”µè·¯å¤æ‚åº¦æ˜¯ç”µè·¯ä¸­é—¨çš„æ€»æ•°ï¼š$C(C) = |G|$

### æ ¸å¿ƒå®šç†

**å®šç† 3.1** (ç”µè·¯å¯é€†æ€§)
é‡å­ç”µè·¯ä¸­çš„é—¨æ“ä½œéƒ½æ˜¯å¯é€†çš„ï¼Œä½†æµ‹é‡æ“ä½œä¸å¯é€†ã€‚

**å®šç† 3.2** (ç”µè·¯åˆ†è§£)
ä»»æ„é‡å­ç”µè·¯éƒ½å¯ä»¥åˆ†è§£ä¸ºå•æ¯”ç‰¹é—¨å’ŒåŒæ¯”ç‰¹é—¨çš„åºåˆ—ã€‚

**å®šç† 3.3** (ç”µè·¯ä¼˜åŒ–)
ä»»æ„é‡å­ç”µè·¯éƒ½å¯ä»¥é€šè¿‡é—¨åˆå¹¶å’Œé‡æ’è¿›è¡Œä¼˜åŒ–ã€‚

**å®šç† 3.4** (ç”µè·¯æ¨¡æ‹Ÿ)
é‡å­ç”µè·¯å¯ä»¥åœ¨ç»å…¸è®¡ç®—æœºä¸Šæ¨¡æ‹Ÿï¼Œä½†å¤æ‚åº¦éšé‡å­æ¯”ç‰¹æ•°æŒ‡æ•°å¢é•¿ã€‚

## ğŸ¯ å¤šè¡¨å¾æ–¹å¼

### 1. å›¾å½¢è¡¨å¾

```mermaid
graph TD
    A[é‡å­ç”µè·¯] --> B[é‡å­æ¯”ç‰¹]
    A --> C[é‡å­é—¨]
    A --> D[æµ‹é‡æ“ä½œ]

    B --> E[qâ‚€]
    B --> F[qâ‚]
    B --> G[qâ‚‚]

    C --> H[Hé—¨]
    C --> I[CNOTé—¨]
    C --> J[Té—¨]

    D --> K[æµ‹é‡]
    D --> L[ç»å…¸è¾“å‡º]

    subgraph ç”µè·¯ç»“æ„
        M[è¾“å…¥æ€] --> N[é—¨åºåˆ—]
        N --> O[æµ‹é‡]
        O --> P[è¾“å‡ºæ€]
    end
```

### 2. è¡¨æ ¼è¡¨å¾

| ç”µè·¯ç±»å‹ | é‡å­æ¯”ç‰¹æ•° | é—¨æ•°é‡ | æ·±åº¦ | å¤æ‚åº¦ | å¯é€†æ€§ |
|----------|------------|--------|------|--------|--------|
| ç®€å•ç”µè·¯ | 2 | 3 | 2 | O(1) | æ˜¯ |
| ä¸­ç­‰ç”µè·¯ | 5 | 15 | 8 | O(n) | æ˜¯ |
| å¤æ‚ç”µè·¯ | 10 | 50 | 20 | O(nÂ²) | æ˜¯ |
| é€šç”¨ç”µè·¯ | n | O(nÂ²) | O(n) | O(nÂ³) | æ˜¯ |

### 3. æ•°å­¦è¡¨å¾

**ç”µè·¯çŠ¶æ€æ¼”åŒ–**ï¼š
$|\psi(t)\rangle = U_t U_{t-1} ... U_1|\psi(0)\rangle$

**ç”µè·¯è¾“å‡ºæ¦‚ç‡**ï¼š
$P(x) = |\langle x|U|\psi(0)\rangle|^2$

**ç”µè·¯ä¿çœŸåº¦**ï¼š
$F = |\langle\psi_{ideal}|\psi_{actual}\rangle|^2$

### 4. ä¼ªä»£ç è¡¨å¾

```python
class QuantumCircuit:
    def __init__(self, num_qubits):
        self.num_qubits = num_qubits
        self.gates = []
        self.measurements = []

    def add_gate(self, gate, qubits):
        """æ·»åŠ é—¨åˆ°ç”µè·¯"""
        self.gates.append((gate, qubits))

    def add_measurement(self, qubit):
        """æ·»åŠ æµ‹é‡æ“ä½œ"""
        self.measurements.append(qubit)

    def execute(self, initial_state):
        """æ‰§è¡Œç”µè·¯"""
        state = initial_state
        for gate, qubits in self.gates:
            state = gate.apply(state, qubits)
        return state

    def measure(self, state):
        """æ‰§è¡Œæµ‹é‡"""
        results = []
        for qubit in self.measurements:
            result = state.measure(qubit)
            results.append(result)
        return results
```

## ğŸ’» Rustå®ç°

```rust
use std::f64::consts::PI;
use num_complex::Complex;

/// é‡å­ç”µè·¯
#[derive(Debug)]
pub struct QuantumCircuit {
    pub num_qubits: usize,
    pub gates: Vec<CircuitGate>,
    pub measurements: Vec<usize>,
}

/// ç”µè·¯é—¨
#[derive(Debug)]
pub struct CircuitGate {
    pub gate: QuantumGate,
    pub target_qubits: Vec<usize>,
    pub control_qubits: Vec<usize>,
}

impl QuantumCircuit {
    /// åˆ›å»ºæ–°çš„é‡å­ç”µè·¯
    pub fn new(num_qubits: usize) -> Self {
        Self {
            num_qubits,
            gates: Vec::new(),
            measurements: Vec::new(),
        }
    }

    /// æ·»åŠ å•æ¯”ç‰¹é—¨
    pub fn add_single_gate(&mut self, gate: QuantumGate, target: usize) {
        self.gates.push(CircuitGate {
            gate,
            target_qubits: vec![target],
            control_qubits: Vec::new(),
        });
    }

    /// æ·»åŠ åŒæ¯”ç‰¹é—¨
    pub fn add_two_qubit_gate(&mut self, gate: QuantumGate, control: usize, target: usize) {
        self.gates.push(CircuitGate {
            gate,
            target_qubits: vec![target],
            control_qubits: vec![control],
        });
    }

    /// æ·»åŠ æµ‹é‡æ“ä½œ
    pub fn add_measurement(&mut self, qubit: usize) {
        self.measurements.push(qubit);
    }

    /// æ‰§è¡Œç”µè·¯
    pub fn execute(&self, initial_state: &mut [Qubit]) -> Vec<bool> {
        // åº”ç”¨æ‰€æœ‰é—¨
        for circuit_gate in &self.gates {
            self.apply_gate(circuit_gate, initial_state);
        }

        // æ‰§è¡Œæµ‹é‡
        let mut results = Vec::new();
        for &qubit in &self.measurements {
            results.push(initial_state[qubit].measure());
        }

        results
    }

    /// åº”ç”¨é—¨åˆ°é‡å­æ¯”ç‰¹
    fn apply_gate(&self, circuit_gate: &CircuitGate, qubits: &mut [Qubit]) {
        if circuit_gate.control_qubits.is_empty() {
            // å•æ¯”ç‰¹é—¨
            for &target in &circuit_gate.target_qubits {
                qubits[target] = circuit_gate.gate.apply(&qubits[target]);
            }
        } else {
            // æ§åˆ¶é—¨
            let control_qubit = circuit_gate.control_qubits[0];
            let target_qubit = circuit_gate.target_qubits[0];

            if qubits[control_qubit].measure() {
                qubits[target_qubit] = circuit_gate.gate.apply(&qubits[target_qubit]);
            }
        }
    }

    /// è·å–ç”µè·¯æ·±åº¦
    pub fn depth(&self) -> usize {
        if self.gates.is_empty() {
            return 0;
        }

        let mut max_depth = 0;
        let mut qubit_depths = vec![0; self.num_qubits];

        for gate in &self.gates {
            let mut gate_depth = 0;

            // è®¡ç®—æ§åˆ¶æ¯”ç‰¹çš„æœ€å¤§æ·±åº¦
            for &control in &gate.control_qubits {
                gate_depth = gate_depth.max(qubit_depths[control]);
            }

            // è®¡ç®—ç›®æ ‡æ¯”ç‰¹çš„æœ€å¤§æ·±åº¦
            for &target in &gate.target_qubits {
                gate_depth = gate_depth.max(qubit_depths[target]);
            }

            // æ›´æ–°æ·±åº¦
            gate_depth += 1;
            for &control in &gate.control_qubits {
                qubit_depths[control] = gate_depth;
            }
            for &target in &gate.target_qubits {
                qubit_depths[target] = gate_depth;
            }

            max_depth = max_depth.max(gate_depth);
        }

        max_depth
    }

    /// è·å–ç”µè·¯å®½åº¦
    pub fn width(&self) -> usize {
        self.num_qubits
    }

    /// è·å–ç”µè·¯å¤æ‚åº¦
    pub fn complexity(&self) -> usize {
        self.gates.len()
    }

    /// ä¼˜åŒ–ç”µè·¯
    pub fn optimize(&mut self) {
        // ç®€åŒ–çš„ä¼˜åŒ–ï¼šç§»é™¤å†—ä½™é—¨
        let mut optimized_gates = Vec::new();
        let mut i = 0;

        while i < self.gates.len() {
            let current_gate = &self.gates[i];

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥ä¸ä¸‹ä¸€ä¸ªé—¨åˆå¹¶
            if i + 1 < self.gates.len() {
                let next_gate = &self.gates[i + 1];

                if self.can_merge_gates(current_gate, next_gate) {
                    let merged_gate = self.merge_gates(current_gate, next_gate);
                    optimized_gates.push(merged_gate);
                    i += 2;
                    continue;
                }
            }

            optimized_gates.push(current_gate.clone());
            i += 1;
        }

        self.gates = optimized_gates;
    }

    /// æ£€æŸ¥ä¸¤ä¸ªé—¨æ˜¯å¦å¯ä»¥åˆå¹¶
    fn can_merge_gates(&self, gate1: &CircuitGate, gate2: &CircuitGate) -> bool {
        // ç®€åŒ–çš„åˆå¹¶æ¡ä»¶ï¼šç›¸åŒçš„ç›®æ ‡æ¯”ç‰¹ï¼Œæ²¡æœ‰æ§åˆ¶æ¯”ç‰¹
        gate1.control_qubits.is_empty() &&
        gate2.control_qubits.is_empty() &&
        gate1.target_qubits == gate2.target_qubits
    }

    /// åˆå¹¶ä¸¤ä¸ªé—¨
    fn merge_gates(&self, gate1: &CircuitGate, gate2: &CircuitGate) -> CircuitGate {
        let merged_gate = gate1.gate.multiply(&gate2.gate);
        CircuitGate {
            gate: merged_gate,
            target_qubits: gate1.target_qubits.clone(),
            control_qubits: Vec::new(),
        }
    }
}

/// ç”µè·¯æ¨¡æ‹Ÿå™¨
#[derive(Debug)]
pub struct CircuitSimulator {
    pub circuit: QuantumCircuit,
}

impl CircuitSimulator {
    /// åˆ›å»ºæ–°çš„æ¨¡æ‹Ÿå™¨
    pub fn new(circuit: QuantumCircuit) -> Self {
        Self { circuit }
    }

    /// æ¨¡æ‹Ÿç”µè·¯æ‰§è¡Œ
    pub fn simulate(&self, num_shots: usize) -> Vec<Vec<bool>> {
        let mut results = Vec::new();

        for _ in 0..num_shots {
            let mut initial_state = vec![Qubit::zero(); self.circuit.num_qubits];
            let result = self.circuit.execute(&mut initial_state);
            results.push(result);
        }

        results
    }

    /// è®¡ç®—è¾“å‡ºåˆ†å¸ƒ
    pub fn output_distribution(&self, num_shots: usize) -> std::collections::HashMap<Vec<bool>, usize> {
        let results = self.simulate(num_shots);
        let mut distribution = std::collections::HashMap::new();

        for result in results {
            *distribution.entry(result).or_insert(0) += 1;
        }

        distribution
    }

    /// è®¡ç®—ç”µè·¯ä¿çœŸåº¦
    pub fn fidelity(&self, ideal_circuit: &QuantumCircuit) -> f64 {
        // ç®€åŒ–çš„ä¿çœŸåº¦è®¡ç®—
        let mut fidelity = 1.0;

        // æ¯”è¾ƒé—¨åºåˆ—
        let min_gates = self.circuit.gates.len().min(ideal_circuit.gates.len());
        for i in 0..min_gates {
            let actual_gate = &self.circuit.gates[i];
            let ideal_gate = &ideal_circuit.gates[i];

            // è®¡ç®—é—¨çš„ä¿çœŸåº¦
            let gate_fidelity = actual_gate.gate.fidelity(&ideal_gate.gate);
            fidelity *= gate_fidelity;
        }

        fidelity
    }
}

/// ç”µè·¯æ„å»ºå™¨
#[derive(Debug)]
pub struct CircuitBuilder {
    pub circuit: QuantumCircuit,
}

impl CircuitBuilder {
    /// åˆ›å»ºæ–°çš„æ„å»ºå™¨
    pub fn new(num_qubits: usize) -> Self {
        Self {
            circuit: QuantumCircuit::new(num_qubits),
        }
    }

    /// æ·»åŠ Hadamardé—¨
    pub fn h(&mut self, qubit: usize) -> &mut Self {
        self.circuit.add_single_gate(StandardGates::h(), qubit);
        self
    }

    /// æ·»åŠ Xé—¨
    pub fn x(&mut self, qubit: usize) -> &mut Self {
        self.circuit.add_single_gate(StandardGates::x(), qubit);
        self
    }

    /// æ·»åŠ CNOTé—¨
    pub fn cnot(&mut self, control: usize, target: usize) -> &mut Self {
        self.circuit.add_two_qubit_gate(StandardGates::x(), control, target);
        self
    }

    /// æ·»åŠ æµ‹é‡
    pub fn measure(&mut self, qubit: usize) -> &mut Self {
        self.circuit.add_measurement(qubit);
        self
    }

    /// æ„å»ºç”µè·¯
    pub fn build(self) -> QuantumCircuit {
        self.circuit
    }
}

// ç¤ºä¾‹ä½¿ç”¨
fn main() {
    // åˆ›å»ºBellæ€ç”µè·¯
    let mut bell_circuit = CircuitBuilder::new(2)
        .h(0)
        .cnot(0, 1)
        .measure(0)
        .measure(1)
        .build();

    println!("Bellç”µè·¯æ·±åº¦: {}", bell_circuit.depth());
    println!("Bellç”µè·¯å¤æ‚åº¦: {}", bell_circuit.complexity());

    // æ¨¡æ‹Ÿç”µè·¯
    let simulator = CircuitSimulator::new(bell_circuit);
    let results = simulator.simulate(1000);

    // ç»Ÿè®¡ç»“æœ
    let mut count_00 = 0;
    let mut count_11 = 0;

    for result in results {
        if result == vec![false, false] {
            count_00 += 1;
        } else if result == vec![true, true] {
            count_11 += 1;
        }
    }

    println!("Bellæ€æµ‹é‡ç»“æœ:");
    println!("|00âŸ©: {} ({}%)", count_00, count_00 * 100 / 1000);
    println!("|11âŸ©: {} ({}%)", count_11, count_11 * 100 / 1000);

    // åˆ›å»ºæ›´å¤æ‚çš„ç”µè·¯
    let mut complex_circuit = CircuitBuilder::new(3)
        .h(0)
        .h(1)
        .cnot(0, 2)
        .cnot(1, 2)
        .h(0)
        .h(1)
        .measure(0)
        .measure(1)
        .measure(2)
        .build();

    println!("å¤æ‚ç”µè·¯æ·±åº¦: {}", complex_circuit.depth());
    println!("å¤æ‚ç”µè·¯å¤æ‚åº¦: {}", complex_circuit.complexity());

    // ä¼˜åŒ–ç”µè·¯
    complex_circuit.optimize();
    println!("ä¼˜åŒ–åç”µè·¯å¤æ‚åº¦: {}", complex_circuit.complexity());
}
```

## ğŸ§  å“²å­¦æ€§æ‰¹åˆ¤ä¸å±•æœ›

### æœ¬ä½“è®ºåæ€

**é‡å­ç”µè·¯çš„å“²å­¦æœ¬è´¨**ï¼š
é‡å­ç”µè·¯ä¸ä»…ä»…æ˜¯è®¡ç®—å·¥å…·ï¼Œè€Œæ˜¯é‡å­ä¿¡æ¯å¤„ç†çš„åŸºæœ¬æ¶æ„ã€‚å®ƒä½“ç°äº†é‡å­ä¸–ç•Œçš„ä¿¡æ¯å¤„ç†æ–¹å¼ï¼Œä¸ç»å…¸ç”µè·¯æœ‰æ ¹æœ¬æ€§ä¸åŒã€‚

**é‡å­ç”µè·¯çš„å®åœ¨æ€§**ï¼š
é‡å­ç”µè·¯çš„æ“ä½œæ­ç¤ºäº†é‡å­ä¿¡æ¯çš„å®åœ¨æ€§ã€‚ç”µè·¯ä¸­çš„æ¯ä¸ªé—¨æ“ä½œéƒ½æ˜¯ç‰©ç†è¿‡ç¨‹ï¼Œä½“ç°äº†é‡å­ä¸–ç•Œçš„éå±€åŸŸæ€§å’Œçº ç¼ æ€§ã€‚

**é‡å­ç”µè·¯çš„æ™®é€‚æ€§**ï¼š
é‡å­ç”µè·¯çš„æ™®é€‚æ€§æš—ç¤ºäº†é‡å­è®¡ç®—çš„åŸºæœ¬åŸç†ã€‚ä»»ä½•é‡å­è®¡ç®—éƒ½å¯ä»¥ç”¨æœ‰é™çš„é—¨é›†åˆå®ç°ï¼Œè¿™è¡¨æ˜é‡å­ä¸–ç•Œå…·æœ‰æŸç§å†…åœ¨çš„ç»Ÿä¸€æ€§ã€‚

### è®¤è¯†è®ºæ‰¹åˆ¤

**é‡å­ç”µè·¯æ“ä½œçš„è®¤è¯†è®ºæŒ‘æˆ˜**ï¼š
é‡å­ç”µè·¯æ“ä½œä¸ç»å…¸ç”µè·¯æ“ä½œæœ‰æ ¹æœ¬æ€§ä¸åŒã€‚é‡å­ç”µè·¯çš„å¯é€†æ€§ã€å åŠ æ€§ç­‰ç‰¹å¾æŒ‘æˆ˜äº†ä¼ ç»Ÿçš„è®¡ç®—æ¦‚å¿µï¼Œè¦æ±‚æˆ‘ä»¬é‡æ–°ç†è§£è®¡ç®—å’Œä¿¡æ¯å¤„ç†çš„æœ¬è´¨ã€‚

**é‡å­ç”µè·¯æµ‹é‡çš„å“²å­¦é—®é¢˜**ï¼š
é‡å­ç”µè·¯ä¸­çš„æµ‹é‡è¿‡ç¨‹å¼•å‘äº†æ·±åˆ»çš„å“²å­¦é—®é¢˜ã€‚æµ‹é‡æ˜¯å¦æ”¹å˜äº†é‡å­ç³»ç»Ÿçš„æœ¬è´¨ï¼Œè¿˜æ˜¯ä»…ä»…æ­ç¤ºäº†é¢„å…ˆå­˜åœ¨çš„çŠ¶æ€ï¼Ÿ

**é‡å­ç”µè·¯è®¾è®¡çš„è®¤è¯†è®ºå±€é™**ï¼š
äººç±»è®¾è®¡é‡å­ç”µè·¯æ—¶å—åˆ°ç»å…¸æ€ç»´çš„é™åˆ¶ã€‚æˆ‘ä»¬éœ€è¦å‘å±•æ–°çš„æ€ç»´æ–¹å¼æ¥ç†è§£å’Œè®¾è®¡é‡å­ç”µè·¯ã€‚

### ç¤¾ä¼šå½±å“åˆ†æ

**é‡å­ç”µè·¯æŠ€æœ¯çš„ç¤¾ä¼šä»·å€¼**ï¼š
é‡å­ç”µè·¯æŠ€æœ¯ä¸ºè®¡ç®—ç§‘å­¦å¸¦æ¥äº†é©å‘½æ€§å˜åŒ–ã€‚å®ƒå¯èƒ½å½»åº•æ”¹å˜å¯†ç å­¦ã€ä¼˜åŒ–ç®—æ³•ã€æ¨¡æ‹Ÿç­‰é¢†åŸŸï¼Œä¸ºç¤¾ä¼šå‘å±•æä¾›æ–°çš„å¯èƒ½æ€§ã€‚

**é‡å­ç”µè·¯æŠ€æœ¯çš„ç¤¾ä¼šè´£ä»»**ï¼š
é‡å­ç”µè·¯æŠ€æœ¯çš„å‘å±•éœ€è¦è€ƒè™‘ç¤¾ä¼šå½±å“å’Œä¼¦ç†è´£ä»»ã€‚é‡å­è®¡ç®—åº”è¯¥æœåŠ¡äºäººç±»çš„ç¦ç¥‰ï¼Œè€Œä¸æ˜¯åŠ å‰§ç¤¾ä¼šä¸å¹³ç­‰ã€‚

**é‡å­ç”µè·¯æŠ€æœ¯çš„æ°‘ä¸»åŒ–**ï¼š
é‡å­ç”µè·¯æŠ€æœ¯åº”è¯¥æ›´åŠ æ°‘ä¸»åŒ–ï¼Œè®©æ›´å¤šäººèƒ½å¤Ÿç†è§£å’Œåº”ç”¨é‡å­è®¡ç®—æŠ€æœ¯ã€‚éœ€è¦å‘å±•é‡å­æ•™è‚²å’Œæ™®åŠå·¥ä½œã€‚

### ç»ˆæå“²å­¦å»ºè®®

**å¤šå…ƒé‡å­ç”µè·¯ç†è®ºçš„èåˆ**ï¼š
æœªæ¥åº”è¯¥å‘å±•å¤šå…ƒåŒ–çš„é‡å­ç”µè·¯ç†è®ºä½“ç³»ï¼Œèåˆä¸åŒå­¦ç§‘å’Œå“²å­¦ä¼ ç»Ÿçš„é‡å­æ€æƒ³ã€‚éœ€è¦å»ºç«‹è·¨å­¦ç§‘çš„é‡å­ç”µè·¯å“²å­¦æ¡†æ¶ã€‚

**é‡å­ç”µè·¯æŠ€æœ¯çš„ç”Ÿæ€åŒ–**ï¼š
é‡å­ç”µè·¯æŠ€æœ¯åº”è¯¥æ›´åŠ å…³æ³¨ç”Ÿæ€ç³»ç»Ÿçš„æ•´ä½“æ€§ï¼Œå‘å±•ç”Ÿæ€å‹å¥½çš„é‡å­è®¡ç®—æŠ€æœ¯ã€‚éœ€è¦è€ƒè™‘é‡å­ç”µè·¯æŠ€æœ¯çš„ç¯å¢ƒå½±å“ã€‚

**é‡å­ç”µè·¯æŠ€æœ¯çš„ä¼¦ç†åŒ–**ï¼š
é‡å­ç”µè·¯æŠ€æœ¯çš„å‘å±•åº”è¯¥æ›´åŠ æ³¨é‡ä¼¦ç†è€ƒè™‘ï¼Œç¡®ä¿æŠ€æœ¯å‘å±•ç¬¦åˆäººç±»çš„æ ¹æœ¬åˆ©ç›Šå’Œä»·å€¼è§‚ã€‚

**é‡å­ç”µè·¯æŠ€æœ¯çš„å“²å­¦åŒ–**ï¼š
é‡å­ç”µè·¯æŠ€æœ¯åº”è¯¥ä¸å“²å­¦æ€è€ƒç›¸ç»“åˆï¼Œå‘å±•å…·æœ‰å“²å­¦æ·±åº¦çš„é‡å­ç”µè·¯æŠ€æœ¯ç†è®ºä½“ç³»ã€‚

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Nielsen, M. A., & Chuang, I. L. _Quantum Computation and Quantum Information_. Cambridge University Press, 2010.
2. Barenco, A., et al. _Elementary gates for quantum computation_. Physical Review A, 1995.
3. DiVincenzo, D. P. _Two-bit gates are universal for quantum computation_. Physical Review A, 1995.
4. Lloyd, S. _Universal quantum simulators_. Science, 1996.
5. Deutsch, D. _Quantum computational networks_. Proceedings of the Royal Society of London A, 1989.
6. Feynman, R. P. _Simulating physics with computers_. International Journal of Theoretical Physics, 1982.
7. Shor, P. W. _Algorithms for quantum computation: discrete logarithms and factoring_. Proceedings of the 35th Annual Symposium on Foundations of Computer Science, 1994.
8. Grover, L. K. _A fast quantum mechanical algorithm for database search_. Proceedings of the 28th Annual ACM Symposium on Theory of Computing, 1996.
