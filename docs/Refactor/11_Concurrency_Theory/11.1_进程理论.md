# 11.1 è¿›ç¨‹ç†è®º

## ğŸ“‹ æ¦‚è¿°

è¿›ç¨‹ç†è®ºæ˜¯å¹¶å‘ç†è®ºçš„åŸºç¡€ï¼Œç ”ç©¶å¹¶å‘ç³»ç»Ÿä¸­è¿›ç¨‹çš„è¡Œä¸ºã€äº¤äº’å’Œæ€§è´¨ã€‚è¿›ç¨‹ç†è®ºä¸ºç†è§£å¹¶å‘è®¡ç®—ã€åˆ†å¸ƒå¼ç³»ç»Ÿå’Œå¹¶è¡Œç¼–ç¨‹æä¾›äº†ä¸¥æ ¼çš„æ•°å­¦åŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹è¿›ç¨‹çš„æ•°å­¦åŸºç¡€
2. å®šä¹‰è¿›ç¨‹çš„è¡Œä¸ºè¯­ä¹‰
3. æä¾›è¿›ç¨‹ç­‰ä»·æ€§ç†è®º
4. å»ºç«‹è¿›ç¨‹ç»„åˆæ–¹æ³•

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [è¿›ç¨‹ä»£æ•°](#2-è¿›ç¨‹ä»£æ•°)
3. [è¡Œä¸ºè¯­ä¹‰](#3-è¡Œä¸ºè¯­ä¹‰)
4. [ç­‰ä»·å…³ç³»](#4-ç­‰ä»·å…³ç³»)
5. [è¿›ç¨‹ç»„åˆ](#5-è¿›ç¨‹ç»„åˆ)
6. [åº”ç”¨ç¤ºä¾‹](#6-åº”ç”¨ç¤ºä¾‹)
7. [ç›¸å…³ç†è®º](#7-ç›¸å…³ç†è®º)
8. [å‚è€ƒæ–‡çŒ®](#8-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 è¿›ç¨‹çš„å®šä¹‰

**å®šä¹‰ 1.1.1** (è¿›ç¨‹)
è¿›ç¨‹æ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $P = (S, \Sigma, \rightarrow)$ï¼Œå…¶ä¸­ï¼š
- $S$ æ˜¯çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯åŠ¨ä½œé›†åˆ
- $\rightarrow \subseteq S \times \Sigma \times S$ æ˜¯è½¬æ¢å…³ç³»

**å®šä¹‰ 1.1.2** (è¿›ç¨‹çŠ¶æ€)
è¿›ç¨‹çŠ¶æ€ $s \in S$ è¡¨ç¤ºè¿›ç¨‹åœ¨æŸä¸ªæ—¶åˆ»çš„å†…éƒ¨çŠ¶æ€ï¼ŒåŒ…æ‹¬å±€éƒ¨å˜é‡ã€ç¨‹åºè®¡æ•°å™¨ç­‰ä¿¡æ¯ã€‚

**å®šä¹‰ 1.1.3** (è¿›ç¨‹åŠ¨ä½œ)
è¿›ç¨‹åŠ¨ä½œ $a \in \Sigma$ è¡¨ç¤ºè¿›ç¨‹å¯ä»¥æ‰§è¡Œçš„åŸºæœ¬æ“ä½œï¼Œå¦‚å†…éƒ¨è®¡ç®—ã€é€šä¿¡ã€åŒæ­¥ç­‰ã€‚

### 1.2 è¿›ç¨‹è¡Œä¸º

**å®šä¹‰ 1.2.1** (è½¬æ¢)
è¿›ç¨‹ä»çŠ¶æ€ $s$ é€šè¿‡åŠ¨ä½œ $a$ è½¬æ¢åˆ°çŠ¶æ€ $s'$ï¼Œè®°ä½œ $s \xrightarrow{a} s'$ï¼Œå½“ä¸”ä»…å½“ $(s, a, s') \in \rightarrow$ã€‚

**å®šä¹‰ 1.2.2** (æ‰§è¡Œåºåˆ—)
è¿›ç¨‹çš„æ‰§è¡Œåºåˆ—æ˜¯ä¸€ä¸ªæœ‰é™æˆ–æ— é™çš„åºåˆ— $\sigma = s_0 \xrightarrow{a_0} s_1 \xrightarrow{a_1} s_2 \xrightarrow{a_2} \cdots$ã€‚

## 2. è¿›ç¨‹ä»£æ•°

### 2.1 CCSè¯­æ³•

**å®šä¹‰ 2.1.1** (CCSè¯­æ³•)
CCSï¼ˆCalculus of Communicating Systemsï¼‰çš„è¯­æ³•ç”±ä»¥ä¸‹BNFè§„åˆ™å®šä¹‰ï¼š
$$P ::= 0 \mid \alpha.P \mid P + P \mid P \mid P \mid P \setminus L \mid P[f] \mid A$$

å…¶ä¸­ï¼š
- $0$ æ˜¯ç©ºè¿›ç¨‹
- $\alpha.P$ æ˜¯å‰ç¼€æ“ä½œ
- $P + Q$ æ˜¯é€‰æ‹©æ“ä½œ
- $P \mid Q$ æ˜¯å¹¶è¡Œç»„åˆ
- $P \setminus L$ æ˜¯é™åˆ¶æ“ä½œ
- $P[f]$ æ˜¯é‡å‘½åæ“ä½œ
- $A$ æ˜¯è¿›ç¨‹æ ‡è¯†ç¬¦

### 2.2 åŠ¨ä½œç±»å‹

**å®šä¹‰ 2.2.1** (åŠ¨ä½œåˆ†ç±»)
åŠ¨ä½œ $\alpha$ å¯ä»¥æ˜¯ï¼š
- $\tau$ï¼šå†…éƒ¨åŠ¨ä½œï¼ˆä¸å¯è§‚å¯Ÿï¼‰
- $a$ï¼šè¾“å…¥åŠ¨ä½œ
- $\bar{a}$ï¼šè¾“å‡ºåŠ¨ä½œ
- $\checkmark$ï¼šæˆåŠŸç»ˆæ­¢åŠ¨ä½œ

## 3. è¡Œä¸ºè¯­ä¹‰

### 3.1 æ“ä½œè¯­ä¹‰

**å®šä¹‰ 3.1.1** (CCSæ“ä½œè¯­ä¹‰)
CCSçš„æ“ä½œè¯­ä¹‰ç”±ä»¥ä¸‹æ¨ç†è§„åˆ™å®šä¹‰ï¼š

1. **å‰ç¼€è§„åˆ™**ï¼š$\alpha.P \xrightarrow{\alpha} P$
2. **é€‰æ‹©è§„åˆ™1**ï¼š$\frac{P \xrightarrow{\alpha} P'}{P + Q \xrightarrow{\alpha} P'}$
3. **é€‰æ‹©è§„åˆ™2**ï¼š$\frac{Q \xrightarrow{\alpha} Q'}{P + Q \xrightarrow{\alpha} Q'}$
4. **å¹¶è¡Œè§„åˆ™1**ï¼š$\frac{P \xrightarrow{\alpha} P'}{P \mid Q \xrightarrow{\alpha} P' \mid Q}$
5. **å¹¶è¡Œè§„åˆ™2**ï¼š$\frac{Q \xrightarrow{\alpha} Q'}{P \mid Q \xrightarrow{\alpha} P \mid Q'}$
6. **é€šä¿¡è§„åˆ™**ï¼š$\frac{P \xrightarrow{a} P' \quad Q \xrightarrow{\bar{a}} Q'}{P \mid Q \xrightarrow{\tau} P' \mid Q'}$
7. **é™åˆ¶è§„åˆ™**ï¼š$\frac{P \xrightarrow{\alpha} P' \quad \alpha \notin L \cup \bar{L}}{P \setminus L \xrightarrow{\alpha} P' \setminus L}$
8. **é‡å‘½åè§„åˆ™**ï¼š$\frac{P \xrightarrow{\alpha} P'}{P[f] \xrightarrow{f(\alpha)} P'[f]}$

### 3.2 æ ‡è®°è½¬æ¢ç³»ç»Ÿ

**å®šä¹‰ 3.2.1** (æ ‡è®°è½¬æ¢ç³»ç»Ÿ)
æ ‡è®°è½¬æ¢ç³»ç»Ÿï¼ˆLabeled Transition System, LTSï¼‰æ˜¯ä¸€ä¸ªå››å…ƒç»„ $M = (S, \Sigma, \rightarrow, s_0)$ï¼Œå…¶ä¸­ï¼š
- $S$ æ˜¯çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯åŠ¨ä½œé›†åˆ
- $\rightarrow \subseteq S \times \Sigma \times S$ æ˜¯è½¬æ¢å…³ç³»
- $s_0 \in S$ æ˜¯åˆå§‹çŠ¶æ€

**å®šç† 3.2.1** (LTSçš„æ€§è´¨)
å¯¹äºä»»æ„LTS $M$ï¼š
1. çŠ¶æ€é›†åˆ $S$ æ˜¯å¯æ•°çš„
2. è½¬æ¢å…³ç³» $\rightarrow$ æ˜¯æœ‰é™çš„
3. å­˜åœ¨å¯è¾¾æ€§å…³ç³» $\rightarrow^*$

## 4. ç­‰ä»·å…³ç³»

### 4.1 å¼ºç­‰ä»·

**å®šä¹‰ 4.1.1** (å¼ºåŒæ¨¡æ‹Ÿ)
å…³ç³» $R \subseteq S \times S$ æ˜¯å¼ºåŒæ¨¡æ‹Ÿï¼Œå½“ä¸”ä»…å½“å¯¹äºä»»æ„ $(s, t) \in R$ï¼š
1. å¦‚æœ $s \xrightarrow{\alpha} s'$ï¼Œåˆ™å­˜åœ¨ $t'$ ä½¿å¾— $t \xrightarrow{\alpha} t'$ ä¸” $(s', t') \in R$
2. å¦‚æœ $t \xrightarrow{\alpha} t'$ï¼Œåˆ™å­˜åœ¨ $s'$ ä½¿å¾— $s \xrightarrow{\alpha} s'$ ä¸” $(s', t') \in R$

**å®šä¹‰ 4.1.2** (å¼ºç­‰ä»·)
ä¸¤ä¸ªè¿›ç¨‹ $P$ å’Œ $Q$ æ˜¯å¼ºç­‰ä»·çš„ï¼Œè®°ä½œ $P \sim Q$ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨åŒ…å« $(P, Q)$ çš„å¼ºåŒæ¨¡æ‹Ÿå…³ç³»ã€‚

### 4.2 å¼±ç­‰ä»·

**å®šä¹‰ 4.2.1** (å¼±è½¬æ¢)
å¼±è½¬æ¢ $\Rightarrow$ å®šä¹‰ä¸ºï¼š
- $s \Rightarrow s$ï¼ˆè‡ªåé—­åŒ…ï¼‰
- $s \xrightarrow{\tau} s' \Rightarrow s''$ è•´å« $s \Rightarrow s''$ï¼ˆä¼ é€’é—­åŒ…ï¼‰
- $s \Rightarrow s' \xrightarrow{\alpha} s'' \Rightarrow s'''$ è•´å« $s \xRightarrow{\alpha} s'''$ï¼ˆå¯¹äº $\alpha \neq \tau$ï¼‰

**å®šä¹‰ 4.2.2** (å¼±åŒæ¨¡æ‹Ÿ)
å…³ç³» $R$ æ˜¯å¼±åŒæ¨¡æ‹Ÿï¼Œå½“ä¸”ä»…å½“å¯¹äºä»»æ„ $(s, t) \in R$ï¼š
1. å¦‚æœ $s \xrightarrow{\alpha} s'$ï¼Œåˆ™å­˜åœ¨ $t'$ ä½¿å¾— $t \xRightarrow{\alpha} t'$ ä¸” $(s', t') \in R$
2. å¦‚æœ $t \xrightarrow{\alpha} t'$ï¼Œåˆ™å­˜åœ¨ $s'$ ä½¿å¾— $s \xRightarrow{\alpha} s'$ ä¸” $(s', t') \in R$

**å®šä¹‰ 4.2.3** (è§‚å¯Ÿç­‰ä»·)
ä¸¤ä¸ªè¿›ç¨‹ $P$ å’Œ $Q$ æ˜¯è§‚å¯Ÿç­‰ä»·çš„ï¼Œè®°ä½œ $P \approx Q$ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨åŒ…å« $(P, Q)$ çš„å¼±åŒæ¨¡æ‹Ÿå…³ç³»ã€‚

## 5. è¿›ç¨‹ç»„åˆ

### 5.1 å¹¶è¡Œç»„åˆ

**å®šä¹‰ 5.1.1** (å¹¶è¡Œç»„åˆ)
ä¸¤ä¸ªè¿›ç¨‹ $P$ å’Œ $Q$ çš„å¹¶è¡Œç»„åˆ $P \mid Q$ å®šä¹‰ä¸ºï¼š
- çŠ¶æ€é›†åˆï¼š$S_P \times S_Q$
- åŠ¨ä½œé›†åˆï¼š$\Sigma_P \cup \Sigma_Q$
- è½¬æ¢å…³ç³»ï¼šåŒ…å«æ‰€æœ‰å¯èƒ½çš„å¹¶è¡Œè½¬æ¢å’Œé€šä¿¡è½¬æ¢

**å®šç† 5.1.1** (å¹¶è¡Œç»„åˆçš„æ€§è´¨)
å¹¶è¡Œç»„åˆæ»¡è¶³ï¼š
1. äº¤æ¢å¾‹ï¼š$P \mid Q \sim Q \mid P$
2. ç»“åˆå¾‹ï¼š$(P \mid Q) \mid R \sim P \mid (Q \mid R)$
3. å•ä½å…ƒï¼š$P \mid 0 \sim P$

### 5.2 é€‰æ‹©ç»„åˆ

**å®šä¹‰ 5.2.1** (é€‰æ‹©ç»„åˆ)
ä¸¤ä¸ªè¿›ç¨‹ $P$ å’Œ $Q$ çš„é€‰æ‹©ç»„åˆ $P + Q$ å®šä¹‰ä¸ºï¼š
- çŠ¶æ€é›†åˆï¼š$S_P \cup S_Q \cup \{s_0\}$
- åŠ¨ä½œé›†åˆï¼š$\Sigma_P \cup \Sigma_Q$
- è½¬æ¢å…³ç³»ï¼šåŒ…å« $P$ å’Œ $Q$ çš„æ‰€æœ‰è½¬æ¢

**å®šç† 5.2.1** (é€‰æ‹©ç»„åˆçš„æ€§è´¨)
é€‰æ‹©ç»„åˆæ»¡è¶³ï¼š
1. äº¤æ¢å¾‹ï¼š$P + Q \sim Q + P$
2. ç»“åˆå¾‹ï¼š$(P + Q) + R \sim P + (Q + R)$
3. å¹‚ç­‰å¾‹ï¼š$P + P \sim P$

## 6. åº”ç”¨ç¤ºä¾‹

### 6.1 ç®€å•è¿›ç¨‹å®ç°

```rust
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct Process {
    name: String,
    states: HashSet<State>,
    actions: HashSet<Action>,
    transitions: Vec<Transition>,
    initial_state: State,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct State(String);

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
enum Action {
    Tau,
    Input(String),
    Output(String),
    Tick,
}

#[derive(Debug, Clone)]
struct Transition {
    from: State,
    action: Action,
    to: State,
}

impl Process {
    fn new(name: &str) -> Self {
        Process {
            name: name.to_string(),
            states: HashSet::new(),
            actions: HashSet::new(),
            transitions: Vec::new(),
            initial_state: State("init".to_string()),
        }
    }
    
    fn add_state(&mut self, state: State) {
        self.states.insert(state);
    }
    
    fn add_action(&mut self, action: Action) {
        self.actions.insert(action);
    }
    
    fn add_transition(&mut self, from: State, action: Action, to: State) {
        self.transitions.push(Transition { from, action, to });
    }
    
    fn successors(&self, state: &State, action: &Action) -> Vec<State> {
        self.transitions
            .iter()
            .filter(|t| &t.from == state && &t.action == action)
            .map(|t| t.to.clone())
            .collect()
    }
    
    fn can_perform(&self, state: &State, action: &Action) -> bool {
        !self.successors(state, action).is_empty()
    }
}
```

### 6.2 è¿›ç¨‹ç»„åˆç¤ºä¾‹

```rust
fn parallel_composition(p1: &Process, p2: &Process) -> Process {
    let mut composed = Process::new(&format!("{}|{}", p1.name, p2.name));
    
    // æ„é€ ä¹˜ç§¯çŠ¶æ€
    for state1 in &p1.states {
        for state2 in &p2.states {
            let composed_state = State(format!("({},{})", state1.0, state2.0));
            composed.add_state(composed_state);
        }
    }
    
    // æ·»åŠ å¹¶è¡Œè½¬æ¢
    for state1 in &p1.states {
        for state2 in &p2.states {
            for action in &p1.actions {
                for next_state1 in p1.successors(state1, action) {
                    let from_state = State(format!("({},{})", state1.0, state2.0));
                    let to_state = State(format!("({},{})", next_state1.0, state2.0));
                    composed.add_transition(from_state, action.clone(), to_state);
                }
            }
            
            for action in &p2.actions {
                for next_state2 in p2.successors(state2, action) {
                    let from_state = State(format!("({},{})", state1.0, state2.0));
                    let to_state = State(format!("({},{})", state1.0, next_state2.0));
                    composed.add_transition(from_state, action.clone(), to_state);
                }
            }
        }
    }
    
    // æ·»åŠ é€šä¿¡è½¬æ¢
    for state1 in &p1.states {
        for state2 in &p2.states {
            for action in &p1.actions {
                if let Action::Output(name) = action {
                    let input_action = Action::Input(name.clone());
                    if p2.can_perform(state2, &input_action) {
                        for next_state1 in p1.successors(state1, action) {
                            for next_state2 in p2.successors(state2, &input_action) {
                                let from_state = State(format!("({},{})", state1.0, state2.0));
                                let to_state = State(format!("({},{})", next_state1.0, next_state2.0));
                                composed.add_transition(from_state, Action::Tau, to_state);
                            }
                        }
                    }
                }
            }
        }
    }
    
    composed
}
```

## 7. ç›¸å…³ç†è®º

### 7.1 ä¸è‡ªåŠ¨æœºç†è®ºçš„å…³ç³»

è¿›ç¨‹ç†è®ºä¸è‡ªåŠ¨æœºç†è®ºå¯†åˆ‡ç›¸å…³ï¼š
- è¿›ç¨‹å¯¹åº”æ ‡è®°è½¬æ¢ç³»ç»Ÿ
- è¿›ç¨‹ç­‰ä»·å¯¹åº”è‡ªåŠ¨æœºç­‰ä»·
- è¿›ç¨‹ç»„åˆå¯¹åº”è‡ªåŠ¨æœºä¹˜ç§¯

### 7.2 ä¸å¹¶å‘ç†è®ºçš„å…³ç³»

è¿›ç¨‹ç†è®ºä¸ºå¹¶å‘ç†è®ºæä¾›åŸºç¡€ï¼š
- è¿›ç¨‹é—´é€šä¿¡
- è¿›ç¨‹åŒæ­¥
- è¿›ç¨‹è°ƒåº¦

### 7.3 ä¸å½¢å¼éªŒè¯çš„å…³ç³»

è¿›ç¨‹ç†è®ºåœ¨å½¢å¼éªŒè¯ä¸­çš„åº”ç”¨ï¼š
- ç³»ç»Ÿå»ºæ¨¡
- æ€§è´¨éªŒè¯
- ç­‰ä»·æ€§æ£€æŸ¥

## 8. å‚è€ƒæ–‡çŒ®

1. Milner, R. (1989). Communication and concurrency. Prentice Hall.
2. Hoare, C. A. R. (1985). Communicating sequential processes. Prentice Hall.
3. Bergstra, J. A., & Klop, J. W. (1984). Process algebra for synchronous communication. Information and control, 60(1-3), 109-137.
4. Baeten, J. C., & Weijland, W. P. (1990). Process algebra. Cambridge University Press.
5. Sangiorgi, D., & Walker, D. (2001). The Ï€-calculus: a theory of mobile processes. Cambridge University Press.

---

**æ–‡æ¡£ä¿¡æ¯**
- åˆ›å»ºæ—¶é—´ï¼š2024å¹´12æœˆ21æ—¥
- æœ€åæ›´æ–°ï¼š2024å¹´12æœˆ21æ—¥
- ç‰ˆæœ¬ï¼š1.0
- çŠ¶æ€ï¼šå®Œæˆ

**ç›¸å…³é“¾æ¥**
- [å¹¶å‘ç†è®ºæ¦‚è¿°](./README.md)
- [åŒæ­¥ç†è®º](./11.2_åŒæ­¥ç†è®º.md)
- [æ­»é”ç†è®º](./11.3_æ­»é”ç†è®º.md)
- [ç«æ€æ¡ä»¶ç†è®º](./11.4_ç«æ€æ¡ä»¶ç†è®º.md) 