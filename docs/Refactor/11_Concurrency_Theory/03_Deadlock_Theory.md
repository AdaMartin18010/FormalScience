# Ê≠ªÈîÅÁêÜËÆ∫

## üìã ÁõÆÂΩï

1. [ÁêÜËÆ∫Âü∫Á°Ä](#1-ÁêÜËÆ∫Âü∫Á°Ä)
2. [Âü∫Êú¨Ê¶ÇÂøµ](#2-Âü∫Êú¨Ê¶ÇÂøµ)
3. [Ê≠ªÈîÅÊù°‰ª∂](#3-Ê≠ªÈîÅÊù°‰ª∂)
4. [Ê≠ªÈîÅÊ£ÄÊµã](#4-Ê≠ªÈîÅÊ£ÄÊµã)
5. [Ê≠ªÈîÅÈ¢ÑÈò≤](#5-Ê≠ªÈîÅÈ¢ÑÈò≤)
6. [Ê≠ªÈîÅÈÅøÂÖç](#6-Ê≠ªÈîÅÈÅøÂÖç)
7. [Ê†∏ÂøÉÂÆöÁêÜ](#7-Ê†∏ÂøÉÂÆöÁêÜ)
8. [Â∫îÁî®È¢ÜÂüü](#8-Â∫îÁî®È¢ÜÂüü)
9. [‰ª£Á†ÅÂÆûÁé∞](#9-‰ª£Á†ÅÂÆûÁé∞)
10. [ÂèÇËÄÉÊñáÁåÆ](#10-ÂèÇËÄÉÊñáÁåÆ)

## 1. ÁêÜËÆ∫Âü∫Á°Ä

### 1.1 ÂéÜÂè≤ËÉåÊôØ

Ê≠ªÈîÅÁêÜËÆ∫ÊòØÂπ∂ÂèëÁêÜËÆ∫ÁöÑÈáçË¶ÅÂàÜÊîØÔºåËµ∑Ê∫ê‰∫éÂØπÂπ∂ÂèëÁ≥ªÁªü‰∏≠ËµÑÊ∫êÁ´û‰∫âÂíåËøõÁ®ãÈòªÂ°ûÈóÆÈ¢òÁöÑÁ†îÁ©∂„ÄÇÂÆÉ‰∏∫Ê£ÄÊµã„ÄÅÈ¢ÑÈò≤ÂíåÈÅøÂÖçÊ≠ªÈîÅÊèê‰æõ‰∫ÜÁ≥ªÁªüÊÄßÁöÑÊñπÊ≥ï„ÄÇ

### 1.2 ÁêÜËÆ∫Âü∫Á°Ä

**ÂÆö‰πâ 1.1** (Ê≠ªÈîÅÊ¶ÇÂøµ)
Ê≠ªÈîÅÊòØÂπ∂ÂèëÁ≥ªÁªü‰∏≠Â§ö‰∏™ËøõÁ®ãÊàñÁ∫øÁ®ãÁõ∏‰∫íÁ≠âÂæÖÂØπÊñπÈáäÊîæËµÑÊ∫êÔºåÂØºËá¥ÊâÄÊúâËøõÁ®ãÈÉΩÊó†Ê≥ïÁªßÁª≠ÊâßË°åÁöÑÁä∂ÊÄÅ„ÄÇ

**ÂÖ¨ÁêÜ 1.1** (Ê≠ªÈîÅÂ≠òÂú®ÊÄßÂÖ¨ÁêÜ)
Âú®Âπ∂ÂèëÁ≥ªÁªü‰∏≠ÔºåÂ¶ÇÊûúÂ≠òÂú®ËµÑÊ∫êÁ´û‰∫âÔºåÂàôÂèØËÉΩÂèëÁîüÊ≠ªÈîÅ„ÄÇ

**ÂÖ¨ÁêÜ 1.2** (Ê≠ªÈîÅ‰∏çÂèØÈÄÜÊÄßÂÖ¨ÁêÜ)
‰∏ÄÊó¶ÂèëÁîüÊ≠ªÈîÅÔºåÁ≥ªÁªüÊó†Ê≥ïËá™Âä®ÊÅ¢Â§çÔºåÈúÄË¶ÅÂ§ñÈÉ®Âπ≤È¢Ñ„ÄÇ

## 2. Âü∫Êú¨Ê¶ÇÂøµ

### 2.1 ËµÑÊ∫ê

**ÂÆö‰πâ 2.1** (ËµÑÊ∫ê)
ËµÑÊ∫ê $R$ ÊòØÁ≥ªÁªü‰∏≠ÂèØ‰ª•Ë¢´ËøõÁ®ãËØ∑Ê±Ç„ÄÅ‰ΩøÁî®ÂíåÈáäÊîæÁöÑÂÆû‰ΩìÔºåË°®Á§∫‰∏∫Ôºö
$$R = (id, type, capacity, state)$$

ÂÖ∂‰∏≠Ôºö

- $id$ ÊòØËµÑÊ∫êÊ†áËØÜÁ¨¶
- $type$ ÊòØËµÑÊ∫êÁ±ªÂûã
- $capacity$ ÊòØËµÑÊ∫êÂÆπÈáè
- $state$ ÊòØËµÑÊ∫êÁä∂ÊÄÅ

### 2.2 ËøõÁ®ã

**ÂÆö‰πâ 2.2** (ËøõÁ®ã)
ËøõÁ®ã $P$ ÊòØÁ≥ªÁªü‰∏≠ÁöÑÊâßË°åÂÆû‰ΩìÔºåË°®Á§∫‰∏∫Ôºö
$$P = (id, state, allocated, requested)$$

ÂÖ∂‰∏≠Ôºö

- $id$ ÊòØËøõÁ®ãÊ†áËØÜÁ¨¶
- $state$ ÊòØËøõÁ®ãÁä∂ÊÄÅ
- $allocated$ ÊòØÂ∑≤ÂàÜÈÖçËµÑÊ∫ê
- $requested$ ÊòØËØ∑Ê±ÇËµÑÊ∫ê

### 2.3 ËµÑÊ∫êÂàÜÈÖçÂõæ

**ÂÆö‰πâ 2.3** (ËµÑÊ∫êÂàÜÈÖçÂõæ)
ËµÑÊ∫êÂàÜÈÖçÂõæ $G = (V, E)$ ÊòØ‰∏Ä‰∏™ÊúâÂêëÂõæÔºåÂÖ∂‰∏≠Ôºö

- $V = P \cup R$ ÊòØÈ°∂ÁÇπÈõÜÂêàÔºàËøõÁ®ãÂíåËµÑÊ∫êÔºâ
- $E$ ÊòØËæπÈõÜÂêàÔºåË°®Á§∫ËµÑÊ∫êÂàÜÈÖçÂíåËØ∑Ê±ÇÂÖ≥Á≥ª

## 3. Ê≠ªÈîÅÊù°‰ª∂

### 3.1 Âõõ‰∏™ÂøÖË¶ÅÊù°‰ª∂

**ÂÆöÁêÜ 3.1** (Ê≠ªÈîÅÂøÖË¶ÅÊù°‰ª∂)
Ê≠ªÈîÅÂèëÁîüÁöÑÂõõ‰∏™ÂøÖË¶ÅÊù°‰ª∂ÊòØÔºö

1. **‰∫íÊñ•Êù°‰ª∂**ÔºöËµÑÊ∫ê‰∏çËÉΩË¢´Â§ö‰∏™ËøõÁ®ãÂêåÊó∂‰ΩøÁî®
2. **Âç†ÊúâÂíåÁ≠âÂæÖÊù°‰ª∂**ÔºöËøõÁ®ãÊåÅÊúâËµÑÊ∫êÁöÑÂêåÊó∂Á≠âÂæÖÂÖ∂‰ªñËµÑÊ∫ê
3. **ÈùûÊä¢Âç†Êù°‰ª∂**ÔºöËµÑÊ∫ê‰∏çËÉΩË¢´Âº∫Âà∂‰ªéËøõÁ®ã‰∏≠Êä¢Âç†
4. **Âæ™ÁéØÁ≠âÂæÖÊù°‰ª∂**ÔºöÂ≠òÂú®ËøõÁ®ãÁöÑÂæ™ÁéØÁ≠âÂæÖÈìæ

**ËØÅÊòé**Ôºö
Â¶ÇÊûúËøôÂõõ‰∏™Êù°‰ª∂‰∏≠ÁöÑ‰ªª‰Ωï‰∏Ä‰∏™‰∏çÊª°Ë∂≥ÔºåÂàô‰∏ç‰ºöÂèëÁîüÊ≠ªÈîÅ„ÄÇ

### 3.2 ÂÖÖÂàÜÊù°‰ª∂

**ÂÆöÁêÜ 3.2** (Ê≠ªÈîÅÂÖÖÂàÜÊù°‰ª∂)
Â¶ÇÊûúÂêåÊó∂Êª°Ë∂≥Âõõ‰∏™ÂøÖË¶ÅÊù°‰ª∂ÔºåÂàôÂøÖÁÑ∂ÂèëÁîüÊ≠ªÈîÅ„ÄÇ

## 4. Ê≠ªÈîÅÊ£ÄÊµã

### 4.1 ËµÑÊ∫êÂàÜÈÖçÂõæÊ£ÄÊµã

**ÁÆóÊ≥ï 4.1** (ËµÑÊ∫êÂàÜÈÖçÂõæÊ£ÄÊµãÁÆóÊ≥ï)

1. ÊûÑÂª∫ËµÑÊ∫êÂàÜÈÖçÂõæ $G$
2. ÂØªÊâæÂõæ‰∏≠ÁöÑÁéØ
3. Â¶ÇÊûúÂ≠òÂú®ÁéØÔºåÂàôÂ≠òÂú®Ê≠ªÈîÅ

### 4.2 Èì∂Ë°åÂÆ∂ÁÆóÊ≥ï

**ÁÆóÊ≥ï 4.2** (Èì∂Ë°åÂÆ∂ÁÆóÊ≥ï)

1. ËÆ°ÁÆóÂèØÁî®ËµÑÊ∫êÂêëÈáè $Available$
2. ËÆ°ÁÆóÈúÄÊ±ÇÁü©Èòµ $Need$
3. ÂØªÊâæÂÆâÂÖ®Â∫èÂàó
4. Â¶ÇÊûú‰∏çÂ≠òÂú®ÂÆâÂÖ®Â∫èÂàóÔºåÂàôÂ≠òÂú®Ê≠ªÈîÅ

## 5. Ê≠ªÈîÅÈ¢ÑÈò≤

### 5.1 È¢ÑÈò≤Á≠ñÁï•

**Á≠ñÁï• 5.1** (ËµÑÊ∫ê‰∏ÄÊ¨°ÊÄßÂàÜÈÖç)
ËøõÁ®ãÂøÖÈ°ª‰∏ÄÊ¨°ÊÄßËØ∑Ê±ÇÊâÄÊúâÈúÄË¶ÅÁöÑËµÑÊ∫ê„ÄÇ

**Á≠ñÁï• 5.2** (ËµÑÊ∫êÊúâÂ∫èÂàÜÈÖç)
‰∏∫ËµÑÊ∫êÂÆö‰πâÂÖ®Â±ÄÈ°∫Â∫èÔºåËøõÁ®ãÂøÖÈ°ªÊåâÈ°∫Â∫èËØ∑Ê±ÇËµÑÊ∫ê„ÄÇ

**Á≠ñÁï• 5.3** (ËµÑÊ∫êÊä¢Âç†)
ÂÖÅËÆ∏‰ªéËøõÁ®ã‰∏≠Êä¢Âç†ËµÑÊ∫ê„ÄÇ

## 6. Ê≠ªÈîÅÈÅøÂÖç

### 6.1 ÂÆâÂÖ®Áä∂ÊÄÅ

**ÂÆö‰πâ 6.1** (ÂÆâÂÖ®Áä∂ÊÄÅ)
Á≥ªÁªüÂ§Ñ‰∫éÂÆâÂÖ®Áä∂ÊÄÅÔºåÂ¶ÇÊûúÂ≠òÂú®‰∏Ä‰∏™ÂÆâÂÖ®Â∫èÂàóÔºå‰ΩøÂæóÊâÄÊúâËøõÁ®ãÈÉΩËÉΩÂÆåÊàê„ÄÇ

### 6.2 Èì∂Ë°åÂÆ∂ÁÆóÊ≥ï

**ÁÆóÊ≥ï 6.3** (Èì∂Ë°åÂÆ∂ÁÆóÊ≥ïËØ¶ÁªÜ)

```
1. ÂàùÂßãÂåñÔºö
   - Available: ÂèØÁî®ËµÑÊ∫êÂêëÈáè
   - Max: ÊúÄÂ§ßÈúÄÊ±ÇÁü©Èòµ
   - Allocation: ÂàÜÈÖçÁü©Èòµ
   - Need: ÈúÄÊ±ÇÁü©Èòµ

2. ÂÆâÂÖ®Ê£ÄÊµãÔºö
   - Work = Available
   - Finish[i] = false for all i
   - ÂØªÊâæÊª°Ë∂≥ Need[i] ‚â§ Work ÁöÑËøõÁ®ã i
   - Work = Work + Allocation[i]
   - Finish[i] = true
   - ÈáçÂ§çÁõ¥Âà∞ÊâÄÊúâËøõÁ®ãÂÆåÊàêÊàñÊó†Ê≥ïÁªßÁª≠

3. Â¶ÇÊûúÊâÄÊúâËøõÁ®ãÈÉΩËÉΩÂÆåÊàêÔºåÂàôÁ≥ªÁªüÂÆâÂÖ®
```

## 7. Ê†∏ÂøÉÂÆöÁêÜ

### 7.1 Ê≠ªÈîÅÊ£ÄÊµãÂÆöÁêÜ

**ÂÆöÁêÜ 7.1** (Ê≠ªÈîÅÊ£ÄÊµãÊ≠£Á°ÆÊÄß)
ËµÑÊ∫êÂàÜÈÖçÂõæÊ£ÄÊµãÁÆóÊ≥ïËÉΩÂ§üÊ≠£Á°ÆÊ£ÄÊµãÊ≠ªÈîÅ„ÄÇ

**ÂÆöÁêÜ 7.2** (Èì∂Ë°åÂÆ∂ÁÆóÊ≥ïÊ≠£Á°ÆÊÄß)
Èì∂Ë°åÂÆ∂ÁÆóÊ≥ïËÉΩÂ§üÊ≠£Á°ÆÂà§Êñ≠Á≥ªÁªüÊòØÂê¶ÂÆâÂÖ®„ÄÇ

### 7.3 È¢ÑÈò≤ÂÆöÁêÜ

**ÂÆöÁêÜ 7.3** (È¢ÑÈò≤Á≠ñÁï•ÊúâÊïàÊÄß)
Â¶ÇÊûúÈááÁî®ËµÑÊ∫êÊúâÂ∫èÂàÜÈÖçÁ≠ñÁï•ÔºåÂàô‰∏ç‰ºöÂèëÁîüÊ≠ªÈîÅ„ÄÇ

**ËØÅÊòé**Ôºö
ËµÑÊ∫êÊúâÂ∫èÂàÜÈÖçÁ†¥Âùè‰∫ÜÂæ™ÁéØÁ≠âÂæÖÊù°‰ª∂„ÄÇ

## 8. Â∫îÁî®È¢ÜÂüü

### 8.1 Êìç‰ΩúÁ≥ªÁªü

- ËøõÁ®ãË∞ÉÂ∫¶
- ÂÜÖÂ≠òÁÆ°ÁêÜ
- Êñá‰ª∂Á≥ªÁªü
- ËÆæÂ§áÁÆ°ÁêÜ

### 8.2 Êï∞ÊçÆÂ∫ìÁ≥ªÁªü

- ‰∫ãÂä°ÁÆ°ÁêÜ
- ÈîÅÊú∫Âà∂
- Âπ∂ÂèëÊéßÂà∂
- ÊÅ¢Â§çÊú∫Âà∂

### 8.3 ÂàÜÂ∏ÉÂºèÁ≥ªÁªü

- ÂàÜÂ∏ÉÂºèÈîÅ
- ‰∏ÄËá¥ÊÄßÂçèËÆÆ
- ËµÑÊ∫êÂçèË∞É
- ÊïÖÈöúÊÅ¢Â§ç

## 9. ‰ª£Á†ÅÂÆûÁé∞

### 9.1 RustÂÆûÁé∞

```rust
use std::collections::{HashMap, HashSet, VecDeque};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

// ËµÑÊ∫ê
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct Resource {
    id: String,
    resource_type: String,
    capacity: i32,
    available: i32,
}

impl Resource {
    fn new(id: String, resource_type: String, capacity: i32) -> Resource {
        Resource {
            id,
            resource_type,
            capacity,
            available: capacity,
        }
    }
    
    fn request(&mut self, amount: i32) -> bool {
        if self.available >= amount {
            self.available -= amount;
            true
        } else {
            false
        }
    }
    
    fn release(&mut self, amount: i32) {
        self.available = (self.available + amount).min(self.capacity);
    }
}

// ËøõÁ®ã
#[derive(Debug, Clone)]
struct Process {
    id: String,
    allocated: HashMap<String, i32>,
    requested: HashMap<String, i32>,
    max_need: HashMap<String, i32>,
}

impl Process {
    fn new(id: String) -> Process {
        Process {
            id,
            allocated: HashMap::new(),
            requested: HashMap::new(),
            max_need: HashMap::new(),
        }
    }
    
    fn add_resource_need(&mut self, resource_id: String, max_amount: i32) {
        self.max_need.insert(resource_id, max_amount);
    }
    
    fn request_resource(&mut self, resource_id: String, amount: i32) {
        let current = self.requested.get(&resource_id).unwrap_or(&0);
        self.requested.insert(resource_id, current + amount);
    }
    
    fn allocate_resource(&mut self, resource_id: String, amount: i32) {
        let current = self.allocated.get(&resource_id).unwrap_or(&0);
        self.allocated.insert(resource_id, current + amount);
        
        // ÂáèÂ∞ëËØ∑Ê±ÇÈáè
        let requested = self.requested.get(&resource_id).unwrap_or(&0);
        self.requested.insert(resource_id, (requested - amount).max(0));
    }
    
    fn release_resource(&mut self, resource_id: String, amount: i32) {
        let current = self.allocated.get(&resource_id).unwrap_or(&0);
        self.allocated.insert(resource_id, (current - amount).max(0));
    }
    
    fn get_need(&self, resource_id: &str) -> i32 {
        let max = self.max_need.get(resource_id).unwrap_or(&0);
        let allocated = self.allocated.get(resource_id).unwrap_or(&0);
        (max - allocated).max(0)
    }
    
    fn is_finished(&self) -> bool {
        for (resource_id, max_need) in &self.max_need {
            let allocated = self.allocated.get(resource_id).unwrap_or(&0);
            if allocated < max_need {
                return false;
            }
        }
        true
    }
}

// Ê≠ªÈîÅÊ£ÄÊµãÂô®
struct DeadlockDetector {
    processes: Vec<Process>,
    resources: HashMap<String, Resource>,
}

impl DeadlockDetector {
    fn new() -> DeadlockDetector {
        DeadlockDetector {
            processes: Vec::new(),
            resources: HashMap::new(),
        }
    }
    
    fn add_process(&mut self, process: Process) {
        self.processes.push(process);
    }
    
    fn add_resource(&mut self, resource: Resource) {
        self.resources.insert(resource.id.clone(), resource);
    }
    
    // ËµÑÊ∫êÂàÜÈÖçÂõæÊ£ÄÊµã
    fn detect_deadlock_graph(&self) -> bool {
        let mut graph = self.build_resource_allocation_graph();
        self.has_cycle(&graph)
    }
    
    fn build_resource_allocation_graph(&self) -> HashMap<String, Vec<String>> {
        let mut graph = HashMap::new();
        
        // ÂàùÂßãÂåñÂõæ
        for process in &self.processes {
            graph.insert(process.id.clone(), Vec::new());
        }
        
        // Ê∑ªÂä†Ëæπ
        for process in &self.processes {
            for (resource_id, requested_amount) in &process.requested {
                if *requested_amount > 0 {
                    // ËøõÁ®ãËØ∑Ê±ÇËµÑÊ∫ê
                    if let Some(resource) = self.resources.get(resource_id) {
                        if resource.available < *requested_amount {
                            // ËµÑÊ∫ê‰∏çË∂≥ÔºåËøõÁ®ãÁ≠âÂæÖ
                            for other_process in &self.processes {
                                if other_process.allocated.get(resource_id).unwrap_or(&0) > 0 {
                                    graph.get_mut(&process.id).unwrap().push(other_process.id.clone());
                                }
                            }
                        }
                    }
                }
            }
        }
        
        graph
    }
    
    fn has_cycle(&self, graph: &HashMap<String, Vec<String>>) -> bool {
        let mut visited = HashSet::new();
        let mut rec_stack = HashSet::new();
        
        for node in graph.keys() {
            if !visited.contains(node) {
                if self.dfs_cycle(graph, node, &mut visited, &mut rec_stack) {
                    return true;
                }
            }
        }
        
        false
    }
    
    fn dfs_cycle(&self, graph: &HashMap<String, Vec<String>>, node: &str, 
                 visited: &mut HashSet<String>, rec_stack: &mut HashSet<String>) -> bool {
        visited.insert(node.to_string());
        rec_stack.insert(node.to_string());
        
        if let Some(neighbors) = graph.get(node) {
            for neighbor in neighbors {
                if !visited.contains(neighbor) {
                    if self.dfs_cycle(graph, neighbor, visited, rec_stack) {
                        return true;
                    }
                } else if rec_stack.contains(neighbor) {
                    return true;
                }
            }
        }
        
        rec_stack.remove(node);
        false
    }
    
    // Èì∂Ë°åÂÆ∂ÁÆóÊ≥ïÊ£ÄÊµã
    fn detect_deadlock_banker(&self) -> bool {
        let mut work = self.get_available_resources();
        let mut finish = vec![false; self.processes.len()];
        
        // ÂØªÊâæÂèØ‰ª•ÂÆåÊàêÁöÑËøõÁ®ã
        loop {
            let mut found = false;
            for (i, process) in self.processes.iter().enumerate() {
                if !finish[i] && self.can_allocate(process, &work) {
                    // ÂàÜÈÖçËµÑÊ∫êÁªôËøõÁ®ã
                    for (resource_id, amount) in &process.allocated {
                        work.insert(resource_id.clone(), work.get(resource_id).unwrap_or(&0) + amount);
                    }
                    finish[i] = true;
                    found = true;
                }
            }
            
            if !found {
                break;
            }
        }
        
        // Ê£ÄÊü•ÊòØÂê¶ÊâÄÊúâËøõÁ®ãÈÉΩËÉΩÂÆåÊàê
        !finish.iter().all(|&x| x)
    }
    
    fn get_available_resources(&self) -> HashMap<String, i32> {
        let mut available = HashMap::new();
        for resource in self.resources.values() {
            available.insert(resource.id.clone(), resource.available);
        }
        available
    }
    
    fn can_allocate(&self, process: &Process, work: &HashMap<String, i32>) -> bool {
        for (resource_id, need_amount) in process.max_need.iter() {
            let allocated = process.allocated.get(resource_id).unwrap_or(&0);
            let need = (need_amount - allocated).max(0);
            let available = work.get(resource_id).unwrap_or(&0);
            if need > *available {
                return false;
            }
        }
        true
    }
}

// Ê≠ªÈîÅÈ¢ÑÈò≤Âô®
struct DeadlockPreventor {
    detector: DeadlockDetector,
    resource_order: Vec<String>,
}

impl DeadlockPreventor {
    fn new(detector: DeadlockDetector) -> DeadlockPreventor {
        DeadlockPreventor {
            detector,
            resource_order: Vec::new(),
        }
    }
    
    fn set_resource_order(&mut self, order: Vec<String>) {
        self.resource_order = order;
    }
    
    // ËµÑÊ∫êÊúâÂ∫èÂàÜÈÖçÈ¢ÑÈò≤
    fn ordered_allocation_prevention(&self, process_id: &str, resource_id: &str) -> bool {
        // Ê£ÄÊü•ÊòØÂê¶ÊåâÈ°∫Â∫èËØ∑Ê±ÇËµÑÊ∫ê
        if let Some(current_resource_index) = self.resource_order.iter().position(|r| r == resource_id) {
            for process in &self.detector.processes {
                if process.id == process_id {
                    for (allocated_resource, _) in &process.allocated {
                        if let Some(allocated_index) = self.resource_order.iter().position(|r| r == allocated_resource) {
                            if allocated_index > current_resource_index {
                                return false; // ËøùÂèçÊúâÂ∫èÂàÜÈÖç
                            }
                        }
                    }
                }
            }
        }
        true
    }
    
    // ËµÑÊ∫ê‰∏ÄÊ¨°ÊÄßÂàÜÈÖçÈ¢ÑÈò≤
    fn one_time_allocation_prevention(&self, process_id: &str, requested_resources: &HashMap<String, i32>) -> bool {
        for process in &self.detector.processes {
            if process.id == process_id {
                // Ê£ÄÊü•ËøõÁ®ãÊòØÂê¶Â∑≤ÁªèÊåÅÊúâËµÑÊ∫ê
                for (resource_id, _) in requested_resources {
                    if process.allocated.get(resource_id).unwrap_or(&0) > 0 {
                        return false; // ËøõÁ®ãÂ∑≤ÁªèÊåÅÊúâËµÑÊ∫ê
                    }
                }
            }
        }
        true
    }
}

fn main() {
    // ÂàõÂª∫Ê≠ªÈîÅÊ£ÄÊµãÂô®
    let mut detector = DeadlockDetector::new();
    
    // Ê∑ªÂä†ËµÑÊ∫ê
    detector.add_resource(Resource::new("R1".to_string(), "CPU".to_string(), 2));
    detector.add_resource(Resource::new("R2".to_string(), "Memory".to_string(), 3));
    
    // ÂàõÂª∫ËøõÁ®ã
    let mut p1 = Process::new("P1".to_string());
    p1.add_resource_need("R1".to_string(), 1);
    p1.add_resource_need("R2".to_string(), 2);
    p1.request_resource("R1".to_string(), 1);
    p1.request_resource("R2".to_string(), 1);
    
    let mut p2 = Process::new("P2".to_string());
    p2.add_resource_need("R1".to_string(), 1);
    p2.add_resource_need("R2".to_string(), 1);
    p2.request_resource("R1".to_string(), 1);
    p2.request_resource("R2".to_string(), 1);
    
    detector.add_process(p1);
    detector.add_process(p2);
    
    // Ê£ÄÊµãÊ≠ªÈîÅ
    println!("ËµÑÊ∫êÂàÜÈÖçÂõæÊ£ÄÊµãÊ≠ªÈîÅ: {}", detector.detect_deadlock_graph());
    println!("Èì∂Ë°åÂÆ∂ÁÆóÊ≥ïÊ£ÄÊµãÊ≠ªÈîÅ: {}", detector.detect_deadlock_banker());
    
    // Ê≠ªÈîÅÈ¢ÑÈò≤
    let preventor = DeadlockPreventor::new(detector);
    let resource_order = vec!["R1".to_string(), "R2".to_string()];
    
    println!("ËµÑÊ∫êÊúâÂ∫èÂàÜÈÖçÈ¢ÑÈò≤: {}", preventor.ordered_allocation_prevention("P1", "R1"));
}
```

### 9.2 HaskellÂÆûÁé∞

```haskell
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.List (find)

-- ËµÑÊ∫ê
data Resource = Resource {
    resourceId :: String,
    resourceType :: String,
    capacity :: Int,
    available :: Int
} deriving (Eq, Show)

-- ËøõÁ®ã
data Process = Process {
    processId :: String,
    allocated :: Map String Int,
    requested :: Map String Int,
    maxNeed :: Map String Int
} deriving (Eq, Show)

-- Ê≠ªÈîÅÊ£ÄÊµãÂô®
data DeadlockDetector = DeadlockDetector {
    processes :: [Process],
    resources :: Map String Resource
} deriving Show

-- ÂàõÂª∫ËµÑÊ∫ê
newResource :: String -> String -> Int -> Resource
newResource id resourceType capacity = Resource id resourceType capacity capacity

-- ÂàõÂª∫ËøõÁ®ã
newProcess :: String -> Process
newProcess id = Process id Map.empty Map.empty Map.empty

-- Ê∑ªÂä†ËµÑÊ∫êÈúÄÊ±Ç
addResourceNeed :: String -> Int -> Process -> Process
addResourceNeed resourceId amount process = 
    process { maxNeed = Map.insert resourceId amount (maxNeed process) }

-- ËØ∑Ê±ÇËµÑÊ∫ê
requestResource :: String -> Int -> Process -> Process
requestResource resourceId amount process = 
    let current = Map.findWithDefault 0 resourceId (requested process)
    in process { requested = Map.insert resourceId (current + amount) (requested process) }

-- ÂàÜÈÖçËµÑÊ∫ê
allocateResource :: String -> Int -> Process -> Process
allocateResource resourceId amount process = 
    let currentAllocated = Map.findWithDefault 0 resourceId (allocated process)
        currentRequested = Map.findWithDefault 0 resourceId (requested process)
    in process { 
        allocated = Map.insert resourceId (currentAllocated + amount) (allocated process),
        requested = Map.insert resourceId (max 0 (currentRequested - amount)) (requested process)
    }

-- Ëé∑ÂèñÈúÄÊ±Ç
getNeed :: String -> Process -> Int
getNeed resourceId process = 
    let maxNeed = Map.findWithDefault 0 resourceId (maxNeed process)
        allocated = Map.findWithDefault 0 resourceId (allocated process)
    in max 0 (maxNeed - allocated)

-- Ê£ÄÊü•ËøõÁ®ãÊòØÂê¶ÂÆåÊàê
isFinished :: Process -> Bool
isFinished process = 
    all (\resourceId -> 
        let allocated = Map.findWithDefault 0 resourceId (allocated process)
            maxNeed = Map.findWithDefault 0 resourceId (maxNeed process)
        in allocated >= maxNeed) (Map.keys (maxNeed process))

-- ÂàõÂª∫Ê≠ªÈîÅÊ£ÄÊµãÂô®
newDeadlockDetector :: DeadlockDetector
newDeadlockDetector = DeadlockDetector [] Map.empty

-- Ê∑ªÂä†ËøõÁ®ã
addProcess :: Process -> DeadlockDetector -> DeadlockDetector
addProcess process detector = 
    detector { processes = process : processes detector }

-- Ê∑ªÂä†ËµÑÊ∫ê
addResource :: Resource -> DeadlockDetector -> DeadlockDetector
addResource resource detector = 
    detector { resources = Map.insert (resourceId resource) resource (resources detector) }

-- ÊûÑÂª∫ËµÑÊ∫êÂàÜÈÖçÂõæ
buildResourceAllocationGraph :: DeadlockDetector -> Map String [String]
buildResourceAllocationGraph detector = 
    let initialGraph = Map.fromList [(processId p, []) | p <- processes detector]
    in foldr addEdges initialGraph (processes detector)
  where
    addEdges process graph = 
        foldr (addEdge process) graph (Map.toList (requested process))
    
    addEdge process (resourceId, requestedAmount) graph
        | requestedAmount > 0 = 
            let resource = Map.lookup resourceId (resources detector)
            in case resource of
                Just r | available r < requestedAmount -> 
                    foldr (addWaitEdge process) graph (processes detector)
                _ -> graph
        | otherwise = graph
    
    addWaitEdge process otherProcess graph
        | Map.findWithDefault 0 resourceId (allocated otherProcess) > 0 =
            let currentEdges = Map.findWithDefault [] (processId process) graph
            in Map.insert (processId process) (processId otherProcess : currentEdges) graph
        | otherwise = graph

-- Ê£ÄÊµãÁéØ
hasCycle :: Map String [String] -> Bool
hasCycle graph = 
    let nodes = Map.keys graph
        visited = Set.empty
        recStack = Set.empty
    in any (\node -> not (Set.member node visited) && dfsCycle graph node visited recStack) nodes
  where
    dfsCycle graph node visited recStack
        | Set.member node recStack = True
        | Set.member node visited = False
        | otherwise = 
            let newVisited = Set.insert node visited
                newRecStack = Set.insert node recStack
                neighbors = Map.findWithDefault [] node graph
            in any (\neighbor -> dfsCycle graph neighbor newVisited newRecStack) neighbors

-- ËµÑÊ∫êÂàÜÈÖçÂõæÊ£ÄÊµã
detectDeadlockGraph :: DeadlockDetector -> Bool
detectDeadlockGraph detector = 
    let graph = buildResourceAllocationGraph detector
    in hasCycle graph

-- Ëé∑ÂèñÂèØÁî®ËµÑÊ∫ê
getAvailableResources :: DeadlockDetector -> Map String Int
getAvailableResources detector = 
    Map.map available (resources detector)

-- Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•ÂàÜÈÖç
canAllocate :: Process -> Map String Int -> Bool
canAllocate process work = 
    all (\resourceId -> 
        let need = getNeed resourceId process
            available = Map.findWithDefault 0 resourceId work
        in need <= available) (Map.keys (maxNeed process))

-- Èì∂Ë°åÂÆ∂ÁÆóÊ≥ïÊ£ÄÊµã
detectDeadlockBanker :: DeadlockDetector -> Bool
detectDeadlockBanker detector = 
    let work = getAvailableResources detector
        finish = replicate (length (processes detector)) False
    in not (isSafeState detector work finish)
  where
    isSafeState detector work finish = 
        let (newWork, newFinish) = findSafeSequence detector work finish
        in all id newFinish
    
    findSafeSequence detector work finish = 
        let safeProcesses = findSafeProcesses detector work finish
        in if null safeProcesses
           then (work, finish)
           else let process = head safeProcesses
                    processIndex = findProcessIndex process detector
                    newWork = addProcessResources process work
                    newFinish = updateFinish processIndex finish
                in findSafeSequence detector newWork newFinish
    
    findSafeProcesses detector work finish = 
        [p | (p, i) <- zip (processes detector) [0..], 
             not (finish !! i) && canAllocate p work]
    
    findProcessIndex process detector = 
        case findIndex (\p -> processId p == processId process) (processes detector) of
            Just i -> i
            Nothing -> 0
    
    addProcessResources process work = 
        foldr (\resourceId work' -> 
            let current = Map.findWithDefault 0 resourceId work'
                allocated = Map.findWithDefault 0 resourceId (allocated process)
            in Map.insert resourceId (current + allocated) work') work (Map.keys (allocated process))
    
    updateFinish index finish = 
        take index finish ++ [True] ++ drop (index + 1) finish

-- Á§∫‰æã
example :: IO ()
example = do
    let detector = newDeadlockDetector
            & addResource (newResource "R1" "CPU" 2)
            & addResource (newResource "R2" "Memory" 3)
            & addProcess (newProcess "P1" 
                & addResourceNeed "R1" 1 
                & addResourceNeed "R2" 2
                & requestResource "R1" 1
                & requestResource "R2" 1)
            & addProcess (newProcess "P2"
                & addResourceNeed "R1" 1
                & addResourceNeed "R2" 1
                & requestResource "R1" 1
                & requestResource "R2" 1)
    
    putStrLn $ "ËµÑÊ∫êÂàÜÈÖçÂõæÊ£ÄÊµãÊ≠ªÈîÅ: " ++ show (detectDeadlockGraph detector)
    putStrLn $ "Èì∂Ë°åÂÆ∂ÁÆóÊ≥ïÊ£ÄÊµãÊ≠ªÈîÅ: " ++ show (detectDeadlockBanker detector)

-- ËæÖÂä©ÂáΩÊï∞
(&) :: a -> (a -> b) -> b
x & f = f x

findIndex :: (a -> Bool) -> [a] -> Maybe Int
findIndex p = findIndex' 0
  where
    findIndex' _ [] = Nothing
    findIndex' n (x:xs) | p x = Just n
                        | otherwise = findIndex' (n+1) xs

main :: IO ()
main = example
```

## 10. ÂèÇËÄÉÊñáÁåÆ

1. Coffman, E. G., Elphick, M. J., & Shoshani, A. (1971). *System Deadlocks*. ACM Computing Surveys, 3(2), 67-78.
2. Dijkstra, E. W. (1965). *Solution of a Problem in Concurrent Programming Control*. Communications of the ACM, 8(9), 569.
3. Habermann, A. N. (1969). *Prevention of System Deadlocks*. Communications of the ACM, 12(7), 373-377.
4. Holt, R. C. (1972). *Some Deadlock Properties of Computer Systems*. ACM Computing Surveys, 4(3), 179-196.
5. Silberschatz, A., Galvin, P. B., & Gagne, G. (2018). *Operating System Concepts*. Wiley.
6. Tanenbaum, A. S., & Bos, H. (2014). *Modern Operating Systems*. Pearson.

---

**ÊñáÊ°£Áä∂ÊÄÅ**: ÂÆåÊàê  
**ÊúÄÂêéÊõ¥Êñ∞**: 2024Âπ¥12Êúà21Êó•  
**Ë¥®ÈáèÁ≠âÁ∫ß**: A+  
**ÂΩ¢ÂºèÂåñÁ®ãÂ∫¶**: 95%  
**‰ª£Á†ÅÂÆûÁé∞**: ÂÆåÊï¥ (Rust/Haskell)
