# 09.4 è½¬æ¢ç³»ç»Ÿç†è®º

## æ–‡æ¡£ä¿¡æ¯

- **æ–‡æ¡£ç¼–å·**: 09.4
- **ç†è®ºé¢†åŸŸ**: å½¢å¼æ¨¡å‹ç†è®º
- **åˆ›å»ºæ—¶é—´**: 2024å¹´12æœˆ21æ—¥
- **æœ€åæ›´æ–°**: 2024å¹´12æœˆ21æ—¥
- **æ–‡æ¡£çŠ¶æ€**: å®Œæ•´æ–‡æ¡£
- **è´¨é‡ç­‰çº§**: å­¦æœ¯æ ‡å‡†

## ğŸ“š ç›®å½•

- [09.4 è½¬æ¢ç³»ç»Ÿç†è®º](#094-è½¬æ¢ç³»ç»Ÿç†è®º)
  - [æ–‡æ¡£ä¿¡æ¯](#æ–‡æ¡£ä¿¡æ¯)
  - [ğŸ“š ç›®å½•](#-ç›®å½•)
  - [ç†è®ºæ¦‚è¿°](#ç†è®ºæ¦‚è¿°)
  - [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
    - [9.4.1 è½¬æ¢ç³»ç»ŸåŸºç¡€](#941-è½¬æ¢ç³»ç»ŸåŸºç¡€)
      - [å®šä¹‰ 9.4.1 (è½¬æ¢ç³»ç»Ÿ)](#å®šä¹‰-941-è½¬æ¢ç³»ç»Ÿ)
      - [ç¤ºä¾‹ 9.4.1 (è½¬æ¢ç³»ç»Ÿå®ç°)](#ç¤ºä¾‹-941-è½¬æ¢ç³»ç»Ÿå®ç°)
    - [9.4.2 æœ‰é™çŠ¶æ€æœº](#942-æœ‰é™çŠ¶æ€æœº)
      - [å®šä¹‰ 9.4.2 (æœ‰é™çŠ¶æ€æœº)](#å®šä¹‰-942-æœ‰é™çŠ¶æ€æœº)
      - [ç¤ºä¾‹ 9.4.2 (æœ‰é™çŠ¶æ€æœºå®ç°)](#ç¤ºä¾‹-942-æœ‰é™çŠ¶æ€æœºå®ç°)
    - [9.4.3 æ ‡è®°è½¬æ¢ç³»ç»Ÿ](#943-æ ‡è®°è½¬æ¢ç³»ç»Ÿ)
      - [å®šä¹‰ 9.4.3 (æ ‡è®°è½¬æ¢ç³»ç»Ÿ)](#å®šä¹‰-943-æ ‡è®°è½¬æ¢ç³»ç»Ÿ)
      - [ç¤ºä¾‹ 9.4.3 (æ ‡è®°è½¬æ¢ç³»ç»Ÿå®ç°)](#ç¤ºä¾‹-943-æ ‡è®°è½¬æ¢ç³»ç»Ÿå®ç°)
  - [å½¢å¼åŒ–è¯­ä¹‰](#å½¢å¼åŒ–è¯­ä¹‰)
    - [9.4.4 æ‰§è¡Œè¯­ä¹‰](#944-æ‰§è¡Œè¯­ä¹‰)
      - [å®šä¹‰ 9.4.4 (æ‰§è¡Œè·¯å¾„)](#å®šä¹‰-944-æ‰§è¡Œè·¯å¾„)
      - [ç¤ºä¾‹ 9.4.4 (è·¯å¾„åˆ†æ)](#ç¤ºä¾‹-944-è·¯å¾„åˆ†æ)
    - [9.4.5 å¯è¾¾æ€§åˆ†æ](#945-å¯è¾¾æ€§åˆ†æ)
      - [å®šä¹‰ 9.4.5 (å¯è¾¾çŠ¶æ€)](#å®šä¹‰-945-å¯è¾¾çŠ¶æ€)
      - [ç¤ºä¾‹ 9.4.5 (å¯è¾¾æ€§åˆ†æ)](#ç¤ºä¾‹-945-å¯è¾¾æ€§åˆ†æ)
  - [å…³ç³»ä¸æ“ä½œ](#å…³ç³»ä¸æ“ä½œ)
    - [9.4.6 ç­‰ä»·å…³ç³»](#946-ç­‰ä»·å…³ç³»)
      - [å®šä¹‰ 9.4.6 (äº’æ¨¡æ‹Ÿ)](#å®šä¹‰-946-äº’æ¨¡æ‹Ÿ)
      - [ç¤ºä¾‹ 9.4.6 (äº’æ¨¡æ‹Ÿæ£€æŸ¥ - æ¦‚å¿µæ€§)](#ç¤ºä¾‹-946-äº’æ¨¡æ‹Ÿæ£€æŸ¥---æ¦‚å¿µæ€§)
    - [9.4.7 ç³»ç»Ÿç»„åˆ](#947-ç³»ç»Ÿç»„åˆ)
      - [å®šä¹‰ 9.4.7 (å¹³è¡Œç»„åˆ)](#å®šä¹‰-947-å¹³è¡Œç»„åˆ)
      - [ç¤ºä¾‹ 9.4.7 (å¹³è¡Œç»„åˆ)](#ç¤ºä¾‹-947-å¹³è¡Œç»„åˆ)
  - [åº”ç”¨](#åº”ç”¨)
    - [9.4.8 æ¨¡å‹æ£€æµ‹](#948-æ¨¡å‹æ£€æµ‹)
    - [9.4.9 åè®®éªŒè¯](#949-åè®®éªŒè¯)
    - [9.4.10 è½¯ä»¶å·¥ç¨‹](#9410-è½¯ä»¶å·¥ç¨‹)
  - [å‚è€ƒæ–‡çŒ®](#å‚è€ƒæ–‡çŒ®)
  - [æ‰¹åˆ¤æ€§åˆ†æ](#æ‰¹åˆ¤æ€§åˆ†æ)

## ç†è®ºæ¦‚è¿°

è½¬æ¢ç³»ç»Ÿç†è®ºæ˜¯å½¢å¼åŒ–å»ºæ¨¡çš„æ ¸å¿ƒç†è®ºï¼Œæä¾›äº†ä¸€å¥—ç»Ÿä¸€çš„æ¡†æ¶æ¥æè¿°ç³»ç»Ÿçš„çŠ¶æ€è½¬æ¢è¡Œä¸ºã€‚
æœ¬ç†è®ºæ¶µç›–äº†æœ‰é™çŠ¶æ€æœºã€æ— é™çŠ¶æ€ç³»ç»Ÿã€æ ‡è®°è½¬æ¢ç³»ç»Ÿç­‰æ ¸å¿ƒæ¦‚å¿µã€‚

## æ ¸å¿ƒæ¦‚å¿µ

### 9.4.1 è½¬æ¢ç³»ç»ŸåŸºç¡€

#### å®šä¹‰ 9.4.1 (è½¬æ¢ç³»ç»Ÿ)

è½¬æ¢ç³»ç»Ÿæ˜¯ä¸€ä¸ªå››å…ƒç»„ TS = (S, Î£, â†’, sâ‚€)ï¼Œå…¶ä¸­ï¼š

- S æ˜¯çŠ¶æ€é›†åˆ
- Î£ æ˜¯åŠ¨ä½œå­—æ¯è¡¨
- â†’ âŠ† S Ã— Î£ Ã— S æ˜¯è½¬æ¢å…³ç³»
- sâ‚€ âˆˆ S æ˜¯åˆå§‹çŠ¶æ€

#### ç¤ºä¾‹ 9.4.1 (è½¬æ¢ç³»ç»Ÿå®ç°)

```rust
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct State(String);

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct Action(String);

#[derive(Debug, Clone)]
struct TransitionSystem {
    states: HashSet<State>,
    actions: HashSet<Action>,
    transitions: HashMap<State, HashMap<Action, HashSet<State>>>,
    initial_state: State,
}

impl TransitionSystem {
    fn new(initial_state: State) -> Self {
        let mut states = HashSet::new();
        states.insert(initial_state.clone());
        TransitionSystem {
            states,
            actions: HashSet::new(),
            transitions: HashMap::new(),
            initial_state,
        }
    }
    
    fn add_transition(&mut self, from: State, action: Action, to: State) {
        self.states.insert(from.clone());
        self.states.insert(to.clone());
        self.actions.insert(action.clone());
        
        self.transitions
            .entry(from)
            .or_insert_with(HashMap::new)
            .entry(action)
            .or_insert_with(HashSet::new)
            .insert(to);
    }
    
    fn get_all_successors(&self, state: &State) -> Vec<(Action, State)> {
        let mut successors = Vec::new();
        if let Some(actions_map) = self.transitions.get(state) {
            for (action, states) in actions_map.iter() {
                for next_state in states.iter() {
                    successors.push((action.clone(), next_state.clone()));
                }
            }
        }
        successors
    }
}
```

### 9.4.2 æœ‰é™çŠ¶æ€æœº

#### å®šä¹‰ 9.4.2 (æœ‰é™çŠ¶æ€æœº)

æœ‰é™çŠ¶æ€æœºæ˜¯è½¬æ¢ç³»ç»Ÿçš„ç‰¹ä¾‹ï¼Œå…¶ä¸­çŠ¶æ€é›†åˆ S æ˜¯æœ‰é™çš„ã€‚

#### ç¤ºä¾‹ 9.4.2 (æœ‰é™çŠ¶æ€æœºå®ç°)

```rust
use std::collections::HashMap;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
enum FSMState {
    Initial,
    Processing,
    Success,
    Error,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
enum FSMAction {
    Start,
    Process,
    Complete,
    Fail,
}

#[derive(Debug, Clone)]
struct FiniteStateMachine {
    current_state: FSMState,
    transitions: HashMap<FSMState, HashMap<FSMAction, FSMState>>,
}

impl FiniteStateMachine {
    fn new() -> Self {
        let mut fsm = FiniteStateMachine {
            current_state: FSMState::Initial,
            transitions: HashMap::new(),
        };
        
        fsm.add_transition(FSMState::Initial, FSMAction::Start, FSMState::Processing);
        fsm.add_transition(FSMState::Processing, FSMAction::Complete, FSMState::Success);
        fsm.add_transition(FSMState::Processing, FSMAction::Fail, FSMState::Error);
        
        fsm
    }
    
    fn add_transition(&mut self, from: FSMState, action: FSMAction, to: FSMState) {
        self.transitions
            .entry(from)
            .or_default()
            .insert(action, to);
    }

    fn execute(&mut self, action: FSMAction) -> Result<FSMState, String> {
        if let Some(new_state) = self.transitions.get(&self.current_state).and_then(|t| t.get(&action)) {
            self.current_state = *new_state;
            Ok(self.current_state)
        } else {
            Err(format!("Invalid action {:?} for current state {:?}", action, self.current_state))
        }
    }
}
```

### 9.4.3 æ ‡è®°è½¬æ¢ç³»ç»Ÿ

#### å®šä¹‰ 9.4.3 (æ ‡è®°è½¬æ¢ç³»ç»Ÿ)

æ ‡è®°è½¬æ¢ç³»ç»Ÿæ˜¯äº”å…ƒç»„ LTS = (S, Î£, â†’, sâ‚€, L)ï¼Œå…¶ä¸­ï¼š

- (S, Î£, â†’, sâ‚€) æ˜¯è½¬æ¢ç³»ç»Ÿ
- L: S â†’ 2^AP æ˜¯æ ‡è®°å‡½æ•°ï¼ŒAP æ˜¯åŸå­å‘½é¢˜é›†åˆ

#### ç¤ºä¾‹ 9.4.3 (æ ‡è®°è½¬æ¢ç³»ç»Ÿå®ç°)

```rust
use std::collections::{HashMap, HashSet};
// Assuming TransitionSystem, State, Action are defined as in 9.4.1
# #[derive(Debug, Clone, PartialEq, Eq, Hash)]
# struct State(String);
# #[derive(Debug, Clone, PartialEq, Eq, Hash)]
# struct Action(String);
# #[derive(Debug, Clone)]
# struct TransitionSystem {
#     states: HashSet<State>,
#     actions: HashSet<Action>,
#     transitions: HashMap<State, HashMap<Action, HashSet<State>>>,
#     initial_state: State,
# }
# impl TransitionSystem {
#     fn new(initial_state: State) -> Self {
#         let mut states = HashSet::new();
#         states.insert(initial_state.clone());
#         TransitionSystem {
#             states,
#             actions: HashSet::new(),
#             transitions: HashMap::new(),
#             initial_state,
#         }
#     }
#     fn add_state(&mut self, state: State) { self.states.insert(state); }
# }


#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct AtomicProposition(String);

#[derive(Debug, Clone)]
struct LabeledTransitionSystem {
    transition_system: TransitionSystem,
    labels: HashMap<State, HashSet<AtomicProposition>>,
}

impl LabeledTransitionSystem {
    fn new(initial_state: State) -> Self {
        LabeledTransitionSystem {
            transition_system: TransitionSystem::new(initial_state.clone()),
            labels: HashMap::new(),
        }
    }
    
    fn add_state(&mut self, state: State, propositions: HashSet<AtomicProposition>) {
        self.transition_system.add_state(state.clone());
        self.labels.insert(state, propositions);
    }
    
    fn satisfies_proposition(&self, state: &State, proposition: &AtomicProposition) -> bool {
        self.labels.get(state).map_or(false, |props| props.contains(proposition))
    }
}
```

## å½¢å¼åŒ–è¯­ä¹‰

### 9.4.4 æ‰§è¡Œè¯­ä¹‰

#### å®šä¹‰ 9.4.4 (æ‰§è¡Œè·¯å¾„)

æ‰§è¡Œè·¯å¾„æ˜¯çŠ¶æ€å’ŒåŠ¨ä½œçš„äº¤æ›¿åºåˆ—ï¼š
\[ \pi = s_0 \xrightarrow{\alpha_1} s_1 \xrightarrow{\alpha_2} s_2 \xrightarrow{\alpha_3} \dots \]
å…¶ä¸­ \(s_i \in S\), \(\alpha_i \in \Sigma\), å¹¶ä¸” \((s_{i-1}, \alpha_i, s_i) \in \rightarrow\) å¯¹æ‰€æœ‰ \(i \ge 1\) æˆç«‹ã€‚

#### ç¤ºä¾‹ 9.4.4 (è·¯å¾„åˆ†æ)

```rust
# #[derive(Debug, Clone, PartialEq, Eq, Hash)]
# struct State(String);
# #[derive(Debug, Clone, PartialEq, Eq, Hash)]
# struct Action(String);

#[derive(Debug, Clone)]
struct ExecutionPath {
    states: Vec<State>,
    actions: Vec<Action>,
}

impl ExecutionPath {
    fn new(initial_state: State) -> Self {
        ExecutionPath {
            states: vec![initial_state],
            actions: vec![],
        }
    }
    
    fn add_step(&mut self, action: Action, state: State) {
        self.actions.push(action);
        self.states.push(state);
    }
    
    fn get_length(&self) -> usize {
        self.actions.len()
    }
    
    fn get_final_state(&self) -> Option<&State> {
        self.states.last()
    }
}
```

### 9.4.5 å¯è¾¾æ€§åˆ†æ

#### å®šä¹‰ 9.4.5 (å¯è¾¾çŠ¶æ€)

çŠ¶æ€ s' ä»çŠ¶æ€ s å¯è¾¾ï¼Œè®°ä½œ \(s \rightarrow^* s'\)ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨ä¸€æ¡ä» s å¼€å§‹åˆ° s' ç»“æŸçš„æ‰§è¡Œè·¯å¾„ã€‚

#### ç¤ºä¾‹ 9.4.5 (å¯è¾¾æ€§åˆ†æ)

```rust
use std::collections::{HashSet, VecDeque};
// Assuming TransitionSystem, State, Action are defined as in 9.4.1
# #[derive(Debug, Clone, PartialEq, Eq, Hash)]
# struct State(String);
# #[derive(Debug, Clone, PartialEq, Eq, Hash)]
# struct Action(String);
# #[derive(Debug, Clone)]
# struct TransitionSystem {
#     states: HashSet<State>,
#     actions: HashSet<Action>,
#     transitions: HashMap<State, HashMap<Action, HashSet<State>>>,
#     initial_state: State,
# }
# impl TransitionSystem {
#     fn get_all_successors(&self, state: &State) -> Vec<(Action, State)> {
#         let mut successors = Vec::new();
#         if let Some(actions_map) = self.transitions.get(state) {
#             for (action, states) in actions_map.iter() {
#                 for next_state in states.iter() {
#                     successors.push((action.clone(), next_state.clone()));
#                 }
#             }
#         }
#         successors
#     }
# }

impl TransitionSystem {
    fn get_reachable_states(&self, from: &State) -> HashSet<State> {
        let mut reachable = HashSet::new();
        let mut queue = VecDeque::new();
        
        queue.push_back(from.clone());
        reachable.insert(from.clone());
        
        while let Some(current) = queue.pop_front() {
            for (_, next_state) in self.get_all_successors(&current) {
                if !reachable.contains(&next_state) {
                    reachable.insert(next_state.clone());
                    queue.push_back(next_state);
                }
            }
        }
        
        reachable
    }

    fn is_reachable(&self, from: &State, to: &State) -> bool {
        self.get_reachable_states(from).contains(to)
    }
}
```

## å…³ç³»ä¸æ“ä½œ

### 9.4.6 ç­‰ä»·å…³ç³»

#### å®šä¹‰ 9.4.6 (äº’æ¨¡æ‹Ÿ)

ä¸¤ä¸ªçŠ¶æ€ sâ‚ å’Œ sâ‚‚ æ˜¯äº’æ¨¡æ‹Ÿçš„ (sâ‚ ~ sâ‚‚)ï¼Œå¦‚æœå­˜åœ¨ä¸€ä¸ªäº’æ¨¡æ‹Ÿå…³ç³» R âŠ† S Ã— S ä½¿å¾— (sâ‚, sâ‚‚) âˆˆ Rã€‚
ä¸€ä¸ªå…³ç³» R æ˜¯äº’æ¨¡æ‹Ÿçš„ï¼Œå¦‚æœå¯¹äºæ‰€æœ‰ (p, q) âˆˆ R:

1. å¯¹äº p çš„æ¯ä¸ªè½¬æ¢ p â†’áµ… p'ï¼Œå­˜åœ¨ q çš„ä¸€ä¸ªè½¬æ¢ q â†’áµ… q' ä½¿å¾— (p', q') âˆˆ Rã€‚
2. å¯¹äº q çš„æ¯ä¸ªè½¬æ¢ q â†’áµ… q'ï¼Œå­˜åœ¨ p çš„ä¸€ä¸ªè½¬æ¢ p â†’áµ… p' ä½¿å¾— (p', q') âˆˆ Rã€‚

#### ç¤ºä¾‹ 9.4.6 (äº’æ¨¡æ‹Ÿæ£€æŸ¥ - æ¦‚å¿µæ€§)

äº’æ¨¡æ‹Ÿçš„ç®—æ³•æ£€æŸ¥é€šå¸¸å¾ˆå¤æ‚ï¼Œæ¶‰åŠåˆ°åˆ’åˆ†æ±‚ç²¾ç®—æ³•ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªæ¦‚å¿µæ€§çš„é«˜çº§æè¿°ã€‚

```rust
// A full bisimulation check is complex.
// The Paige-Tarjan algorithm is a classic approach.
// It works by partition refinement.
// 1. Start with an initial partition of states (e.g., based on labels in LTS).
// 2. Iteratively refine the partition by splitting blocks.
// 3. A block B is split by a (action, splitter_block) pair if some states in B
//    can transition to the splitter_block via the action, and others cannot.
// 4. The algorithm terminates when no more splits can be made.
// 5. Two states are bisimilar if and only if they remain in the same block
//    in the final partition.
fn check_bisimulation(ts1: &TransitionSystem, s1: &State, ts2: &TransitionSystem, s2: &State) -> bool {
    // Placeholder for a complex algorithm
    unimplemented!("Bisimulation checking requires a dedicated algorithm like Paige-Tarjan.");
}
```

### 9.4.7 ç³»ç»Ÿç»„åˆ

#### å®šä¹‰ 9.4.7 (å¹³è¡Œç»„åˆ)

ä¸¤ä¸ªè½¬æ¢ç³»ç»Ÿ TSâ‚ = (Sâ‚, Î£â‚, â†’â‚, sâ‚€â‚) å’Œ TSâ‚‚ = (Sâ‚‚, Î£â‚‚, â†’â‚‚, sâ‚€â‚‚) çš„å¹³è¡Œç»„åˆï¼Œè®°ä½œ TSâ‚ || TSâ‚‚ï¼Œå®šä¹‰ä¸ºä¸€ä¸ªæ–°çš„è½¬æ¢ç³»ç»Ÿã€‚å…¶çŠ¶æ€æ˜¯ (sâ‚, sâ‚‚)ï¼ŒåŠ¨ä½œåœ¨å…¶å…±äº«çš„å­—æ¯è¡¨ä¸ŠåŒæ­¥ï¼Œåœ¨ç‹¬ç«‹çš„å­—æ¯è¡¨ä¸Šäº¤é”™ã€‚

#### ç¤ºä¾‹ 9.4.7 (å¹³è¡Œç»„åˆ)

```rust
// Assuming TransitionSystem, State, Action are defined
# #[derive(Debug, Clone, PartialEq, Eq, Hash)]
# struct State(String);
# #[derive(Debug, Clone, PartialEq, Eq, Hash)]
# struct Action(String);
# #[derive(Debug, Clone)]
# struct TransitionSystem {
#     states: HashSet<State>,
#     actions: HashSet<Action>,
#     transitions: HashMap<State, HashMap<Action, HashSet<State>>>,
#     initial_state: State,
# }
# impl TransitionSystem {
#     fn new(initial_state: State) -> Self {
#         let mut states = HashSet::new();
#         states.insert(initial_state.clone());
#         TransitionSystem {
#             states,
#             actions: HashSet::new(),
#             transitions: HashMap::new(),
#             initial_state,
#         }
#     }
#    fn add_transition(&mut self, from: State, action: Action, to: State) { }
# }


fn parallel_composition(ts1: &TransitionSystem, ts2: &TransitionSystem) -> TransitionSystem {
    let initial_state_comp = State(format!("({},{})", ts1.initial_state.0, ts2.initial_state.0));
    let mut composed_ts = TransitionSystem::new(initial_state_comp);

    let mut queue = std::collections::VecDeque::new();
    let mut visited = std::collections::HashSet::new();

    let initial_pair = (ts1.initial_state.clone(), ts2.initial_state.clone());
    queue.push_back(initial_pair.clone());
    visited.insert(initial_pair);
    
    let shared_actions = ts1.actions.intersection(&ts2.actions).cloned().collect::<HashSet<_>>();

    while let Some((s1, s2)) = queue.pop_front() {
        let from_state_comp = State(format!("({},{})", s1.0, s2.0));

        // TS1 moves independently
        for (a, s1_prime) in ts1.get_all_successors(&s1) {
            if !shared_actions.contains(&a) {
                let to_state_comp = State(format!("({},{})", s1_prime.0, s2.0));
                composed_ts.add_transition(from_state_comp.clone(), a.clone(), to_state_comp.clone());
                if visited.insert((s1_prime.clone(), s2.clone())) {
                    queue.push_back((s1_prime, s2.clone()));
                }
            }
        }

        // TS2 moves independently
        for (a, s2_prime) in ts2.get_all_successors(&s2) {
            if !shared_actions.contains(&a) {
                let to_state_comp = State(format!("({},{})", s1.0, s2_prime.0));
                composed_ts.add_transition(from_state_comp.clone(), a.clone(), to_state_comp.clone());
                if visited.insert((s1.clone(), s2_prime.clone())) {
                    queue.push_back((s1.clone(), s2_prime));
                }
            }
        }
        
        // Synchronized move
        for (a, s1_prime) in ts1.get_all_successors(&s1) {
            if shared_actions.contains(&a) {
                for (a2, s2_prime) in ts2.get_all_successors(&s2) {
                    if a == a2 {
                        let to_state_comp = State(format!("({},{})", s1_prime.0, s2_prime.0));
                        composed_ts.add_transition(from_state_comp.clone(), a.clone(), to_state_comp.clone());
                        if visited.insert((s1_prime.clone(), s2_prime.clone())) {
                            queue.push_back((s1_prime.clone(), s2_prime.clone()));
                        }
                    }
                }
            }
        }
    }
    composed_ts
}

```

## åº”ç”¨

### 9.4.8 æ¨¡å‹æ£€æµ‹

è½¬æ¢ç³»ç»Ÿæ˜¯æ¨¡å‹æ£€æµ‹å·¥å…·çš„æ ¸å¿ƒæ•°æ®ç»“æ„ã€‚æ—¶æ€é€»è¾‘å…¬å¼ (å¦‚LTL, CTL) åœ¨è½¬æ¢ç³»ç»Ÿä¸Šè¿›è¡Œè§£é‡Šå’ŒéªŒè¯ï¼Œä»¥æ£€æŸ¥ç³»ç»Ÿæ˜¯å¦æ»¡è¶³ç»™å®šçš„æ€§è´¨ (å¦‚å®‰å…¨æ€§ã€æ´»æ€§)ã€‚

### 9.4.9 åè®®éªŒè¯

é€šä¿¡åè®®å’Œåˆ†å¸ƒå¼ç®—æ³•çš„è¡Œä¸ºå¯ä»¥è¢«å»ºæ¨¡ä¸ºè½¬æ¢ç³»ç»Ÿã€‚é€šè¿‡åˆ†æå…¶å¯è¾¾çŠ¶æ€é›†ã€æ­»é”ç­‰ï¼Œå¯ä»¥éªŒè¯åè®®çš„æ­£ç¡®æ€§ã€‚

### 9.4.10 è½¯ä»¶å·¥ç¨‹

åœ¨æ¨¡å‹é©±åŠ¨å¼€å‘ä¸­ï¼Œè½¯ä»¶çš„ä½“ç³»ç»“æ„å’Œè¡Œä¸ºå¯ä»¥é€šè¿‡è½¬æ¢ç³»ç»Ÿæ¥è§„çº¦ã€‚è¿™æœ‰åŠ©äºåœ¨ç¼–ç å‰å‘ç°è®¾è®¡ç¼ºé™·ã€‚

## å‚è€ƒæ–‡çŒ®

1. Baier, C., & Katoen, J. P. (2008). *Principles of Model Checking*. MIT Press.
2. Clarke, E. M., Grumberg, O., & Peled, D. A. (1999). *Model Checking*. MIT Press.
3. Milner, R. (1989). *Communication and Concurrency*. Prentice Hall.

## æ‰¹åˆ¤æ€§åˆ†æ

- å¤šå…ƒç†è®ºè§†è§’ï¼š
  - ç»Ÿä¸€è¯­ä¹‰è½½ä½“ï¼šè½¬æ¢ç³»ç»ŸæŠŠâ€œçŠ¶æ€â€”äº‹ä»¶â€”æ¼”åŒ–â€æŠ½è±¡ä¸ºé€šç”¨éª¨æ¶ï¼Œå¯å¯¹æ¥è‡ªåŠ¨æœºã€è¿›ç¨‹ä»£æ•°ã€æ—¶æ€é€»è¾‘ä¸æ¨¡å‹æ£€æµ‹ï¼Œå½¢æˆè¯­æ³•â€”è¯­ä¹‰â€”éªŒè¯çš„é€šé“ã€‚
  - èŒƒç•´ä¸åˆæˆï¼šä»¥ç³»ç»Ÿä¸ºå¯¹è±¡ã€åŒæ­¥/ä¸²è”/å¹¶è¡Œä¸ºæ€å°„ï¼Œå¯ç”¨ï¼ˆå¯¹ç§°ï¼‰å•oidal/åŒèŒƒç•´ç­‰æè¿°ç»„åˆè¯­ä¹‰ï¼Œæ”¯æ’‘æ¨¡å—åŒ–ä¸åˆ†å±‚éªŒè¯ã€‚
  - å·¥ç¨‹å¯¹é½ï¼šä»çŠ¶æ€å›¾ã€LTS åˆ° Kripke ç»“æ„æ˜¯å·¥ä¸šå·¥å…·çš„äº‹å®æ ‡å‡†ï¼Œåˆ©äºä¸è§„æ ¼ï¼ˆLTL/CTLï¼‰ã€çº¦æŸä¸æµ‹è¯•å·¥ä»¶äº’æ“ä½œã€‚
- å±€é™æ€§åˆ†æï¼š
  - çŠ¶æ€çˆ†ç‚¸ï¼šå¹¶å‘/å‚æ•°åŒ–ç³»ç»Ÿåœ¨ç»„åˆåæŒ‡æ•°å¢é•¿ï¼›éœ€è¦æŠ½è±¡è§£é‡Šã€å¯¹ç§°/éƒ¨ä»½åºçº¦ç®€ã€åˆ‡ç‰‡ä¸åˆæˆæ¨ç†ã€‚
  - å¯è¾¾æ€§ä¸ç­‰ä»·å¤æ‚åº¦ï¼šä¸€èˆ¬å¯è¾¾æ€§ã€äº’æ¨¡æ‹Ÿ/ä»¿çœŸæ£€æŸ¥åœ¨è§„æ¨¡ä¸Šæ˜‚è´µï¼›ç®—æ³•ä¸æ•°æ®ç»“æ„ï¼ˆBDD/SAT/IC3/PDRï¼‰é€‰å‹å…³é”®ã€‚
  - è¯­ä¹‰è´«ä¹ï¼šæ—¶é’Ÿã€æ¦‚ç‡ã€èµ„æºç­‰éœ€æ‰©å±•åˆ° Timed/Probabilistic/Weighted TSï¼›å¦åˆ™éš¾ä»¥è¦†ç›–æ€§èƒ½ä¸ä¸ç¡®å®šæ€§åˆ†æã€‚
- äº‰è®®ä¸åˆ†æ­§ï¼š
  - å›¾æ¨¡å‹ vs. ä»£æ•°æ¼”ç®—ï¼šå¯è§†ç›´è§‚ä¸ç­‰å¼æ¨ç†çš„å–èˆï¼›å®é™…å¤šé‡‡ç”¨åŒè½¨ï¼ˆå›¾éªŒè¯ + æ¼”ç®—åˆæˆï¼‰ã€‚
  - å¼ºè¯­ä¹‰ä¸€è‡´æ€§ï¼šä¸åŒå·¥å…·å¯¹åŒæ­¥ã€éšå¼Ï„ã€æ ‡ç­¾ä½œç”¨åŸŸçš„çº¦å®šä¸ä¸€ï¼Œæ˜“è‡´è¿ç§»æ­§ä¹‰ã€‚
- åº”ç”¨å‰æ™¯ï¼š
  - è§„æ¨¡åŒ–éªŒè¯ï¼šä¸IC3/PDRã€å¯ç»„åˆæŠ½è±¡ã€å­¦ä¹ å¼ä¸å˜å¼ç»“åˆï¼Œæå‡ç¡¬ä»¶/è½¯ä»¶/åè®®çš„éªŒè¯ä¸Šé™ã€‚
  - è®¾è®¡å³éªŒè¯ï¼šå°†LTSå†…åµŒåˆ°è®¾è®¡æµç¨‹ï¼ˆåˆæˆ/çº¦æŸé©±åŠ¨è®¾è®¡ï¼‰ï¼Œåœ¨CIä¸­æŒç»­åœ°äº§ç”Ÿå¯è¿½æº¯è¯æ®äº§ç‰©ã€‚
  - è·¨åŸŸå»ºæ¨¡ï¼šä¸å·¥ä½œæµã€ä¸šåŠ¡è¿‡ç¨‹ã€åˆ¶é€ /ç½‘ç»œç³»ç»Ÿå¯¹æ¥ï¼Œç»Ÿä¸€â€œæµç¨‹â€”èµ„æºâ€”çº¦æŸâ€çš„å¯éªŒè¯è¡¨è¾¾ã€‚
- æ”¹è¿›å»ºè®®ï¼š
  - ç»„åˆä¸çº¦ç®€ç­–ç•¥é»˜è®¤åŒ–ï¼šåœ¨å¹¶è¡Œç»„åˆæ—¶è‡ªåŠ¨å¯ç”¨å¯¹ç§°/éƒ¨ä»½åºçº¦ç®€ä¸åˆ‡ç‰‡ï¼Œæ˜¾å¼è®°å½•å¤±æ•ˆæ¡ä»¶ã€‚
  - è¯æ®ä¸å¯å¤ç°ï¼šä¸ºå¯è¾¾æ€§/ç­‰ä»·æ£€æŸ¥ç”Ÿæˆè¯ä¹¦ï¼ˆå¯ç‹¬ç«‹éªŒè¯ï¼‰ï¼Œåœ¨ä»“åº“å†…ç®¡ç†è¯æ®ä¸åŸºå‡†ã€‚
  - è¯­ä¹‰æ‰©å±•è§„èŒƒï¼šæä¾› Timed/Probabilistic LTS çš„æœ€å°å¯ç”¨æ‰©å±•ä¸åˆ° Kripke/MC å·¥å…·çš„å¯é€†è½¬æ¢è„šæœ¬è¯´æ˜ã€‚
