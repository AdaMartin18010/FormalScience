# 09.1.2 çŠ¶æ€æœºç†è®º

## ğŸ“‹ æ¦‚è¿°

çŠ¶æ€æœºç†è®ºæ˜¯å½¢å¼æ¨¡å‹ç†è®ºçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œç ”ç©¶ç³»ç»Ÿçš„çŠ¶æ€è½¬æ¢è¡Œä¸ºå’Œæ€§è´¨ã€‚çŠ¶æ€æœºä¸ºç†è§£å¤æ‚ç³»ç»Ÿçš„åŠ¨æ€è¡Œä¸ºæä¾›äº†ä¸¥æ ¼çš„æ•°å­¦åŸºç¡€ï¼Œå¹¿æ³›åº”ç”¨äºè½¯ä»¶å·¥ç¨‹ã€ç¡¬ä»¶è®¾è®¡ã€åè®®éªŒè¯ç­‰é¢†åŸŸã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹çŠ¶æ€æœºçš„æ•°å­¦åŸºç¡€
2. å®šä¹‰çŠ¶æ€æœºçš„åˆ†ç±»å’Œæ€§è´¨
3. æä¾›çŠ¶æ€æœºåˆ†æå’ŒéªŒè¯æ–¹æ³•
4. å»ºç«‹çŠ¶æ€æœºç»„åˆç†è®º

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [çŠ¶æ€æœºåˆ†ç±»](#3-çŠ¶æ€æœºåˆ†ç±»)
4. [çŠ¶æ€æœºæ€§è´¨](#4-çŠ¶æ€æœºæ€§è´¨)
5. [çŠ¶æ€æœºåˆ†æ](#5-çŠ¶æ€æœºåˆ†æ)
6. [çŠ¶æ€æœºç»„åˆ](#6-çŠ¶æ€æœºç»„åˆ)
7. [åº”ç”¨ç¤ºä¾‹](#7-åº”ç”¨ç¤ºä¾‹)
8. [ç›¸å…³ç†è®º](#8-ç›¸å…³ç†è®º)
9. [å‚è€ƒæ–‡çŒ®](#9-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 çŠ¶æ€æœºçš„å®šä¹‰

**å®šä¹‰ 1.1.1** (çŠ¶æ€æœº)
çŠ¶æ€æœºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š

- $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times \Sigma \rightarrow Q$ æ˜¯çŠ¶æ€è½¬æ¢å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†åˆ

### 1.2 çŠ¶æ€æœºçš„è¿è¡Œ

**å®šä¹‰ 1.2.1** (é…ç½®)
çŠ¶æ€æœºçš„é…ç½®æ˜¯ä¸€ä¸ªäºŒå…ƒç»„ $(q, w)$ï¼Œå…¶ä¸­ $q \in Q$ æ˜¯å½“å‰çŠ¶æ€ï¼Œ$w \in \Sigma^*$ æ˜¯å‰©ä½™è¾“å…¥ä¸²ã€‚

**å®šä¹‰ 1.2.2** (ä¸€æ­¥è½¬æ¢)
é…ç½® $(q, aw)$ ä¸€æ­¥è½¬æ¢åˆ° $(q', w)$ï¼Œè®°ä½œ $(q, aw) \vdash (q', w)$ï¼Œå½“ä¸”ä»…å½“ $\delta(q, a) = q'$ã€‚

**å®šä¹‰ 1.2.3** (å¤šæ­¥è½¬æ¢)
é…ç½® $(q, w)$ å¤šæ­¥è½¬æ¢åˆ° $(q', \epsilon)$ï¼Œè®°ä½œ $(q, w) \vdash^* (q', \epsilon)$ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨é…ç½®åºåˆ—ä½¿å¾—ï¼š
$$(q, w) \vdash (q_1, w_1) \vdash \cdots \vdash (q', \epsilon)$$

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 ç¡®å®šæ€§çŠ¶æ€æœº

**å®šä¹‰ 2.1.1** (ç¡®å®šæ€§æœ‰é™çŠ¶æ€æœº - DFA)
ç¡®å®šæ€§æœ‰é™çŠ¶æ€æœºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š

- $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times \Sigma \rightarrow Q$ æ˜¯çŠ¶æ€è½¬æ¢å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†åˆ

**å®šç† 2.1.1** (DFAçš„è¯­è¨€)
DFA $M$ æ¥å—çš„è¯­è¨€å®šä¹‰ä¸ºï¼š
$$L(M) = \{w \in \Sigma^* \mid (q_0, w) \vdash^* (q, \epsilon) \text{ ä¸” } q \in F\}$$

### 2.2 éç¡®å®šæ€§çŠ¶æ€æœº

**å®šä¹‰ 2.2.1** (éç¡®å®šæ€§æœ‰é™çŠ¶æ€æœº - NFA)
éç¡®å®šæ€§æœ‰é™çŠ¶æ€æœºæ˜¯ä¸€ä¸ªäº”å…ƒç»„ $M = (Q, \Sigma, \delta, q_0, F)$ï¼Œå…¶ä¸­ï¼š

- $Q$ æ˜¯æœ‰é™çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\delta: Q \times \Sigma \rightarrow \mathcal{P}(Q)$ æ˜¯çŠ¶æ€è½¬æ¢å‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€
- $F \subseteq Q$ æ˜¯æ¥å—çŠ¶æ€é›†åˆ

**å®šä¹‰ 2.2.2** (NFAçš„æ‰©å±•è½¬æ¢å‡½æ•°)
NFAçš„æ‰©å±•è½¬æ¢å‡½æ•° $\delta^*: Q \times \Sigma^* \rightarrow \mathcal{P}(Q)$ å®šä¹‰ä¸ºï¼š

1. $\delta^*(q, \epsilon) = \{q\}$
2. $\delta^*(q, wa) = \bigcup_{p \in \delta^*(q, w)} \delta(p, a)$

## 3. çŠ¶æ€æœºåˆ†ç±»

### 3.1 æŒ‰ç¡®å®šæ€§åˆ†ç±»

**å®šä¹‰ 3.1.1** (ç¡®å®šæ€§çŠ¶æ€æœº)
çŠ¶æ€æœº $M$ æ˜¯ç¡®å®šæ€§çš„ï¼Œå½“ä¸”ä»…å½“å¯¹äºä»»æ„çŠ¶æ€ $q \in Q$ å’Œè¾“å…¥ $a \in \Sigma$ï¼Œ$|\delta(q, a)| \leq 1$ã€‚

**å®šä¹‰ 3.1.2** (éç¡®å®šæ€§çŠ¶æ€æœº)
çŠ¶æ€æœº $M$ æ˜¯éç¡®å®šæ€§çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨çŠ¶æ€ $q \in Q$ å’Œè¾“å…¥ $a \in \Sigma$ï¼Œä½¿å¾— $|\delta(q, a)| > 1$ã€‚

### 3.2 æŒ‰çŠ¶æ€æ•°é‡åˆ†ç±»

**å®šä¹‰ 3.2.1** (æœ‰é™çŠ¶æ€æœº)
çŠ¶æ€æœº $M$ æ˜¯æœ‰é™çŠ¶æ€çš„ï¼Œå½“ä¸”ä»…å½“ $|Q| < \infty$ã€‚

**å®šä¹‰ 3.2.2** (æ— é™çŠ¶æ€æœº)
çŠ¶æ€æœº $M$ æ˜¯æ— é™çŠ¶æ€çš„ï¼Œå½“ä¸”ä»…å½“ $|Q| = \infty$ã€‚

### 3.3 æŒ‰è¾“å‡ºåˆ†ç±»

**å®šä¹‰ 3.3.1** (æ‘©å°”æœº)
æ‘©å°”æœºæ˜¯ä¸€ä¸ªå…­å…ƒç»„ $M = (Q, \Sigma, \Gamma, \delta, \lambda, q_0)$ï¼Œå…¶ä¸­ï¼š

- $Q$ æ˜¯çŠ¶æ€é›†åˆ
- $\Sigma$ æ˜¯è¾“å…¥å­—æ¯è¡¨
- $\Gamma$ æ˜¯è¾“å‡ºå­—æ¯è¡¨
- $\delta: Q \times \Sigma \rightarrow Q$ æ˜¯çŠ¶æ€è½¬æ¢å‡½æ•°
- $\lambda: Q \rightarrow \Gamma$ æ˜¯è¾“å‡ºå‡½æ•°
- $q_0 \in Q$ æ˜¯åˆå§‹çŠ¶æ€

**å®šä¹‰ 3.3.2** (ç±³åˆ©æœº)
ç±³åˆ©æœºæ˜¯ä¸€ä¸ªå…­å…ƒç»„ $M = (Q, \Sigma, \Gamma, \delta, \lambda, q_0)$ï¼Œå…¶ä¸­ï¼š

- $\lambda: Q \times \Sigma \rightarrow \Gamma$ æ˜¯è¾“å‡ºå‡½æ•°

## 4. çŠ¶æ€æœºæ€§è´¨

### 4.1 å¯è¾¾æ€§

**å®šä¹‰ 4.1.1** (å¯è¾¾çŠ¶æ€)
çŠ¶æ€ $q \in Q$ æ˜¯å¯è¾¾çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨è¾“å…¥ä¸² $w \in \Sigma^*$ ä½¿å¾— $(q_0, w) \vdash^* (q, \epsilon)$ã€‚

**å®šç† 4.1.1** (å¯è¾¾æ€§ç®—æ³•)
çŠ¶æ€ $q$ æ˜¯å¯è¾¾çš„ï¼Œå½“ä¸”ä»…å½“ $q$ åœ¨ä» $q_0$ å¼€å§‹çš„å¹¿åº¦ä¼˜å…ˆæœç´¢ä¸­è¢«è®¿é—®åˆ°ã€‚

### 4.2 ç­‰ä»·æ€§

**å®šä¹‰ 4.2.1** (çŠ¶æ€ç­‰ä»·)
ä¸¤ä¸ªçŠ¶æ€ $q_1, q_2 \in Q$ æ˜¯ç­‰ä»·çš„ï¼Œå½“ä¸”ä»…å½“å¯¹äºä»»æ„è¾“å…¥ä¸² $w \in \Sigma^*$ï¼š
$$(q_1, w) \vdash^* (p_1, \epsilon) \text{ ä¸” } p_1 \in F \iff (q_2, w) \vdash^* (p_2, \epsilon) \text{ ä¸” } p_2 \in F$$

**å®šä¹‰ 4.2.2** (çŠ¶æ€æœºç­‰ä»·)
ä¸¤ä¸ªçŠ¶æ€æœº $M_1$ å’Œ $M_2$ æ˜¯ç­‰ä»·çš„ï¼Œå½“ä¸”ä»…å½“ $L(M_1) = L(M_2)$ã€‚

### 4.3 æœ€å°åŒ–

**å®šä¹‰ 4.3.1** (æœ€å°çŠ¶æ€æœº)
çŠ¶æ€æœº $M$ æ˜¯æœ€å°çš„ï¼Œå½“ä¸”ä»…å½“ä¸å­˜åœ¨ç­‰ä»·çš„çŠ¶æ€æœº $M'$ ä½¿å¾— $|Q'| < |Q|$ã€‚

**å®šç† 4.3.1** (æœ€å°åŒ–å®šç†)
å¯¹äºä»»æ„DFA $M$ï¼Œå­˜åœ¨å”¯ä¸€çš„æœ€å°DFA $M'$ ä½¿å¾— $L(M) = L(M')$ã€‚

## 5. çŠ¶æ€æœºåˆ†æ

### 5.1 è¯­è¨€åˆ†æ

**ç®—æ³• 5.1.1** (è¯­è¨€æˆå‘˜åˆ¤å®š)

```rust
fn is_member(dfa: &DFA, input: &str) -> bool {
    let mut current_state = dfa.initial_state;
    
    for symbol in input.chars() {
        if let Some(next_state) = dfa.transition(current_state, symbol) {
            current_state = next_state;
        } else {
            return false; // æ— å®šä¹‰è½¬æ¢
        }
    }
    
    dfa.accepting_states.contains(&current_state)
}
```

### 5.2 çŠ¶æ€åˆ†æ

**ç®—æ³• 5.2.1** (å¯è¾¾æ€§åˆ†æ)

```rust
fn reachable_states(dfa: &DFA) -> HashSet<State> {
    let mut reachable = HashSet::new();
    let mut to_visit = vec![dfa.initial_state];
    
    while let Some(state) = to_visit.pop() {
        if reachable.insert(state) {
            for symbol in &dfa.alphabet {
                if let Some(next_state) = dfa.transition(state, *symbol) {
                    to_visit.push(next_state);
                }
            }
        }
    }
    
    reachable
}
```

## 6. çŠ¶æ€æœºç»„åˆ

### 6.1 å¹¶è¡Œç»„åˆ

**å®šä¹‰ 6.1.1** (å¹¶è¡Œç»„åˆ)
ä¸¤ä¸ªçŠ¶æ€æœº $M_1 = (Q_1, \Sigma_1, \delta_1, q_{01}, F_1)$ å’Œ $M_2 = (Q_2, \Sigma_2, \delta_2, q_{02}, F_2)$ çš„å¹¶è¡Œç»„åˆå®šä¹‰ä¸ºï¼š
$$M_1 \parallel M_2 = (Q_1 \times Q_2, \Sigma_1 \cup \Sigma_2, \delta, (q_{01}, q_{02}), F_1 \times F_2)$$

å…¶ä¸­ $\delta((q_1, q_2), a) = (\delta_1(q_1, a), \delta_2(q_2, a))$ï¼ˆå¦‚æœ $a \in \Sigma_1 \cap \Sigma_2$ï¼‰

### 6.2 é¡ºåºç»„åˆ

**å®šä¹‰ 6.2.1** (é¡ºåºç»„åˆ)
ä¸¤ä¸ªçŠ¶æ€æœº $M_1$ å’Œ $M_2$ çš„é¡ºåºç»„åˆå®šä¹‰ä¸ºï¼š
$$M_1 \cdot M_2 = (Q_1 \cup Q_2, \Sigma_1 \cup \Sigma_2, \delta, q_{01}, F_2)$$

å…¶ä¸­ $\delta$ åŒ…å« $M_1$ å’Œ $M_2$ çš„æ‰€æœ‰è½¬æ¢ï¼Œä»¥åŠä» $M_1$ çš„æ¥å—çŠ¶æ€åˆ° $M_2$ åˆå§‹çŠ¶æ€çš„ $\epsilon$ è½¬æ¢ã€‚

## 7. åº”ç”¨ç¤ºä¾‹

### 7.1 ç®€å•DFAå®ç°

```rust
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct DFA {
    states: HashSet<State>,
    alphabet: HashSet<char>,
    transitions: HashMap<(State, char), State>,
    initial_state: State,
    accepting_states: HashSet<State>,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct State(String);

impl DFA {
    fn new() -> Self {
        DFA {
            states: HashSet::new(),
            alphabet: HashSet::new(),
            transitions: HashMap::new(),
            initial_state: State("q0".to_string()),
            accepting_states: HashSet::new(),
        }
    }
    
    fn add_state(&mut self, state: State) {
        self.states.insert(state);
    }
    
    fn add_transition(&mut self, from: State, symbol: char, to: State) {
        self.alphabet.insert(symbol);
        self.transitions.insert((from, symbol), to);
    }
    
    fn set_accepting(&mut self, state: State) {
        self.accepting_states.insert(state);
    }
    
    fn transition(&self, state: &State, symbol: char) -> Option<State> {
        self.transitions.get(&(state.clone(), symbol)).cloned()
    }
    
    fn accepts(&self, input: &str) -> bool {
        let mut current_state = self.initial_state.clone();
        
        for symbol in input.chars() {
            if let Some(next_state) = self.transition(&current_state, symbol) {
                current_state = next_state;
            } else {
                return false;
            }
        }
        
        self.accepting_states.contains(&current_state)
    }
}
```

### 7.2 çŠ¶æ€æœºéªŒè¯ç¤ºä¾‹

```rust
fn verify_dfa_properties() {
    // åˆ›å»ºä¸€ä¸ªæ¥å—å¶æ•°ä¸ª'a'çš„DFA
    let mut dfa = DFA::new();
    
    let q0 = State("q0".to_string());
    let q1 = State("q1".to_string());
    
    dfa.add_state(q0.clone());
    dfa.add_state(q1.clone());
    
    dfa.add_transition(q0.clone(), 'a', q1.clone());
    dfa.add_transition(q1.clone(), 'a', q0.clone());
    
    dfa.set_accepting(q0.clone());
    
    // éªŒè¯æ€§è´¨
    assert!(dfa.accepts(""));      // ç©ºä¸²ï¼ˆ0ä¸ª'a'ï¼‰
    assert!(!dfa.accepts("a"));    // 1ä¸ª'a'
    assert!(dfa.accepts("aa"));    // 2ä¸ª'a'
    assert!(!dfa.accepts("aaa"));  // 3ä¸ª'a'
    assert!(dfa.accepts("aaaa"));  // 4ä¸ª'a'
}
```

## 8. ç›¸å…³ç†è®º

### 8.1 ä¸è‡ªåŠ¨æœºç†è®ºçš„å…³ç³»

çŠ¶æ€æœºæ˜¯è‡ªåŠ¨æœºç†è®ºçš„åŸºç¡€ï¼š

- DFAå¯¹åº”æ­£åˆ™è¯­è¨€
- NFAå¯¹åº”æ­£åˆ™è¯­è¨€
- çŠ¶æ€æœºæœ€å°åŒ–å¯¹åº”æ­£åˆ™è¡¨è¾¾å¼æœ€å°åŒ–

### 8.2 ä¸å½¢å¼è¯­è¨€ç†è®ºçš„å…³ç³»

çŠ¶æ€æœºä¸ºå½¢å¼è¯­è¨€æä¾›è¯†åˆ«æœºåˆ¶ï¼š

- çŠ¶æ€æœºè¯†åˆ«è¯­è¨€
- è¯­è¨€ç”ŸæˆçŠ¶æ€æœº
- çŠ¶æ€æœºç­‰ä»·äºè¯­è¨€ç­‰ä»·

### 8.3 ä¸æ¨¡å‹æ£€æŸ¥çš„å…³ç³»

çŠ¶æ€æœºä¸ºæ¨¡å‹æ£€æŸ¥æä¾›åŸºç¡€ï¼š

- çŠ¶æ€æœºä½œä¸ºç³»ç»Ÿæ¨¡å‹
- çŠ¶æ€æœºéªŒè¯ç³»ç»Ÿæ€§è´¨
- çŠ¶æ€æœºåˆ†æç³»ç»Ÿè¡Œä¸º

## 9. å‚è€ƒæ–‡çŒ®

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). Introduction to automata theory, languages, and computation. Pearson Education.
2. Sipser, M. (2012). Introduction to the theory of computation. Cengage Learning.
3. Kozen, D. C. (2006). Automata and computability. Springer Science & Business Media.
4. Lewis, H. R., & Papadimitriou, C. H. (1997). Elements of the theory of computation. Prentice Hall.
5. Hopcroft, J. E. (1971). An n log n algorithm for minimizing states in a finite automaton. Theory of machines and computations, 189-196.

---

**æ–‡æ¡£ä¿¡æ¯**:

- åˆ›å»ºæ—¶é—´ï¼š2024å¹´12æœˆ21æ—¥
- æœ€åæ›´æ–°ï¼š2024å¹´12æœˆ21æ—¥
- ç‰ˆæœ¬ï¼š1.0
- çŠ¶æ€ï¼šå®Œæˆ

**ç›¸å…³é“¾æ¥**:

- [å½¢å¼æ¨¡å‹ç†è®ºæ¦‚è¿°](README.md)
- [å½¢å¼æ¨¡å‹åŸºç¡€ç†è®º](./09.1.1_å½¢å¼æ¨¡å‹åŸºç¡€ç†è®º.md)
- [Petriç½‘ç†è®º](09.2_Petri_Nets.md)
- [è¿›ç¨‹æ¼”ç®—ç†è®º](./09.3_Process_Calculi.md)

## æ‰¹åˆ¤æ€§åˆ†æ

- æœ¬èŠ‚å†…å®¹å¾…è¡¥å……ï¼šè¯·ä»å¤šå…ƒç†è®ºè§†è§’ã€å±€é™æ€§ã€äº‰è®®ç‚¹ã€åº”ç”¨å‰æ™¯ç­‰æ–¹é¢è¿›è¡Œæ‰¹åˆ¤æ€§åˆ†æã€‚
