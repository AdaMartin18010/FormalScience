# 06.1.1 åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€

## ğŸ“‹ æ¦‚è¿°

åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€ç†è®ºæ˜¯è®¡ç®—æœºç§‘å­¦çš„é‡è¦åˆ†æ”¯ï¼Œç ”ç©¶ç”±å¤šä¸ªç‹¬ç«‹è®¡ç®—æœºç»„æˆçš„ç³»ç»Ÿå¦‚ä½•ååŒå·¥ä½œã€‚å®ƒåŒ…æ‹¬ç³»ç»Ÿæ¨¡å‹ã€é€šä¿¡åè®®ã€ä¸€è‡´æ€§ç®—æ³•ç­‰æ ¸å¿ƒæ¦‚å¿µï¼Œä¸ºç°ä»£åˆ†å¸ƒå¼åº”ç”¨æä¾›ç†è®ºåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. å»ºç«‹åˆ†å¸ƒå¼ç³»ç»Ÿçš„åŸºæœ¬æ•°å­¦æ¨¡å‹
2. ç ”ç©¶åˆ†å¸ƒå¼ç³»ç»Ÿçš„é€šä¿¡æœºåˆ¶
3. æ¢è®¨ç³»ç»Ÿæ•…éšœå’Œå®¹é”™ç†è®º
4. åˆ†æåˆ†å¸ƒå¼ç®—æ³•çš„æ­£ç¡®æ€§
5. æä¾›å®Œæ•´çš„ä»£ç å®ç°

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ç³»ç»Ÿæ¨¡å‹](#4-ç³»ç»Ÿæ¨¡å‹)
5. [ä»£ç å®ç°](#5-ä»£ç å®ç°)
6. [åº”ç”¨ç¤ºä¾‹](#6-åº”ç”¨ç¤ºä¾‹)
7. [ç›¸å…³ç†è®º](#7-ç›¸å…³ç†è®º)
8. [å‚è€ƒæ–‡çŒ®](#8-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 åˆ†å¸ƒå¼ç³»ç»Ÿçš„ç›´è§‚ç†è§£

åˆ†å¸ƒå¼ç³»ç»Ÿæ˜¯ç”±å¤šä¸ªç‹¬ç«‹èŠ‚ç‚¹ç»„æˆçš„ç³»ç»Ÿï¼Œè¿™äº›èŠ‚ç‚¹é€šè¿‡ç½‘ç»œè¿›è¡Œé€šä¿¡å’Œåä½œï¼Œå…±åŒå®Œæˆç³»ç»ŸåŠŸèƒ½ã€‚

**åŸºæœ¬ç‰¹å¾**ï¼š

- **å¹¶å‘æ€§**ï¼šå¤šä¸ªèŠ‚ç‚¹åŒæ—¶æ‰§è¡Œ
- **ç¼ºä¹å…¨å±€æ—¶é’Ÿ**ï¼šèŠ‚ç‚¹é—´æ—¶é’Ÿä¸åŒæ­¥
- **æ•…éšœç‹¬ç«‹æ€§**ï¼šèŠ‚ç‚¹æ•…éšœç›¸äº’ç‹¬ç«‹
- **æ¶ˆæ¯ä¼ é€’**ï¼šé€šè¿‡æ¶ˆæ¯è¿›è¡Œé€šä¿¡

### 1.2 åˆ†å¸ƒå¼ç³»ç»Ÿçš„åŸºæœ¬ç±»å‹

1. **å®¢æˆ·ç«¯-æœåŠ¡å™¨ç³»ç»Ÿ**ï¼šé›†ä¸­å¼æ§åˆ¶
2. **å¯¹ç­‰ç½‘ç»œç³»ç»Ÿ**ï¼šå»ä¸­å¿ƒåŒ–æ¶æ„
3. **é›†ç¾¤ç³»ç»Ÿ**ï¼šåŒæ„èŠ‚ç‚¹é›†åˆ
4. **ç½‘æ ¼ç³»ç»Ÿ**ï¼šå¼‚æ„èµ„æºæ•´åˆ

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 åˆ†å¸ƒå¼ç³»ç»Ÿæ¨¡å‹

**å®šä¹‰ 2.1.1** (åˆ†å¸ƒå¼ç³»ç»Ÿ)
åˆ†å¸ƒå¼ç³»ç»Ÿæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $DS = (N, C, P)$ï¼Œå…¶ä¸­ï¼š

- $N = \{n_1, n_2, ..., n_k\}$ æ˜¯èŠ‚ç‚¹é›†åˆ
- $C \subseteq N \times N$ æ˜¯é€šä¿¡å…³ç³»
- $P = \{p_1, p_2, ..., p_m\}$ æ˜¯è¿›ç¨‹é›†åˆ

### 2.2 æ¶ˆæ¯ä¼ é€’æ¨¡å‹

**å®šä¹‰ 2.1.2** (æ¶ˆæ¯)
æ¶ˆæ¯æ˜¯ä¸€ä¸ªå››å…ƒç»„ $m = (s, d, t, c)$ï¼Œå…¶ä¸­ï¼š

- $s \in N$ æ˜¯å‘é€èŠ‚ç‚¹
- $d \in N$ æ˜¯æ¥æ”¶èŠ‚ç‚¹
- $t \in \mathbb{R}$ æ˜¯å‘é€æ—¶é—´
- $c$ æ˜¯æ¶ˆæ¯å†…å®¹

### 2.3 äº‹ä»¶æ¨¡å‹

**å®šä¹‰ 2.1.3** (äº‹ä»¶)
äº‹ä»¶æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $e = (n, t, type, data, state)$ï¼Œå…¶ä¸­ï¼š

- $n \in N$ æ˜¯äº‹ä»¶å‘ç”Ÿçš„èŠ‚ç‚¹
- $t \in \mathbb{R}$ æ˜¯äº‹ä»¶æ—¶é—´æˆ³
- $type \in \{send, receive, internal\}$ æ˜¯äº‹ä»¶ç±»å‹
- $data$ æ˜¯äº‹ä»¶æ•°æ®
- $state$ æ˜¯èŠ‚ç‚¹çŠ¶æ€

## 3. å®šç†ä¸è¯æ˜

### 3.1 CAPå®šç†

**å®šç† 3.1.1** (CAPå®šç†)
åœ¨å¼‚æ­¥ç½‘ç»œæ¨¡å‹ä¸­ï¼Œåˆ†å¸ƒå¼ç³»ç»Ÿæ— æ³•åŒæ—¶æ»¡è¶³ä»¥ä¸‹ä¸‰ä¸ªæ€§è´¨ï¼š

1. **ä¸€è‡´æ€§(Consistency)**ï¼šæ‰€æœ‰èŠ‚ç‚¹çœ‹åˆ°ç›¸åŒçš„æ•°æ®
2. **å¯ç”¨æ€§(Availability)**ï¼šæ¯ä¸ªè¯·æ±‚éƒ½èƒ½å¾—åˆ°å“åº”
3. **åˆ†åŒºå®¹é”™æ€§(Partition Tolerance)**ï¼šç½‘ç»œåˆ†åŒºæ—¶ç³»ç»Ÿä»èƒ½å·¥ä½œ

**è¯æ˜**ï¼š
å‡è®¾ç³»ç»Ÿæ»¡è¶³CAï¼Œåœ¨ç½‘ç»œåˆ†åŒºæ—¶ï¼ŒèŠ‚ç‚¹æ— æ³•é€šä¿¡ï¼Œæ— æ³•ä¿è¯ä¸€è‡´æ€§ï¼ŒçŸ›ç›¾ã€‚

### 3.2 FLPä¸å¯èƒ½æ€§å®šç†

**å®šç† 3.2.1** (FLPä¸å¯èƒ½æ€§å®šç†)
åœ¨å¼‚æ­¥åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œå³ä½¿åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹å¯èƒ½å´©æºƒï¼Œä¹Ÿä¸å­˜åœ¨ç¡®å®šæ€§ç®—æ³•èƒ½å¤Ÿè§£å†³å…±è¯†é—®é¢˜ã€‚

**è¯æ˜**ï¼š
é€šè¿‡æ„é€ åä¾‹è¯æ˜ï¼Œä»»ä½•ç¡®å®šæ€§ç®—æ³•éƒ½å­˜åœ¨æ‰§è¡Œåºåˆ—å¯¼è‡´æ— æ³•è¾¾æˆå…±è¯†ã€‚

### 3.3 ä¸¤å°†å†›é—®é¢˜

**å®šç† 3.3.1** (ä¸¤å°†å†›é—®é¢˜)
åœ¨ä¸å¯é é€šä¿¡ç½‘ç»œä¸­ï¼Œä¸¤ä¸ªå°†å†›æ— æ³•é€šè¿‡æ¶ˆæ¯ä¼ é€’è¾¾æˆä¸€è‡´çš„æ”»å‡»è®¡åˆ’ã€‚

**è¯æ˜**ï¼š
é€šè¿‡å½’çº³æ³•è¯æ˜ï¼Œæ— è®ºå‘é€å¤šå°‘æ¶ˆæ¯ï¼Œéƒ½æ— æ³•ä¿è¯ä¸¤ä¸ªå°†å†›åŒæ—¶çŸ¥é“å¯¹æ–¹æ”¶åˆ°äº†æ¶ˆæ¯ã€‚

## 4. ç³»ç»Ÿæ¨¡å‹

### 4.1 åŒæ­¥æ¨¡å‹

**å®šä¹‰ 4.1.1** (åŒæ­¥åˆ†å¸ƒå¼ç³»ç»Ÿ)
åŒæ­¥åˆ†å¸ƒå¼ç³»ç»Ÿæ»¡è¶³ï¼š

1. **æ¶ˆæ¯å»¶è¿Ÿæœ‰ç•Œ**ï¼šå­˜åœ¨å¸¸æ•° $\Delta$ ä½¿å¾—æ¶ˆæ¯å»¶è¿Ÿ $\leq \Delta$
2. **å¤„ç†æ—¶é—´æœ‰ç•Œ**ï¼šå­˜åœ¨å¸¸æ•° $\tau$ ä½¿å¾—å¤„ç†æ—¶é—´ $\leq \tau$
3. **æ—¶é’ŸåŒæ­¥**ï¼šèŠ‚ç‚¹é—´æ—¶é’Ÿåå·®æœ‰ç•Œ

### 4.2 å¼‚æ­¥æ¨¡å‹

**å®šä¹‰ 4.1.2** (å¼‚æ­¥åˆ†å¸ƒå¼ç³»ç»Ÿ)
å¼‚æ­¥åˆ†å¸ƒå¼ç³»ç»Ÿæ»¡è¶³ï¼š

1. **æ¶ˆæ¯å»¶è¿Ÿæ— ç•Œ**ï¼šæ¶ˆæ¯å¯èƒ½æ— é™å»¶è¿Ÿ
2. **å¤„ç†æ—¶é—´æ— ç•Œ**ï¼šå¤„ç†æ—¶é—´å¯èƒ½æ— é™é•¿
3. **æ—¶é’Ÿä¸åŒæ­¥**ï¼šèŠ‚ç‚¹é—´æ—¶é’Ÿå¯èƒ½å®Œå…¨ä¸åŒæ­¥

### 4.3 éƒ¨åˆ†åŒæ­¥æ¨¡å‹

**å®šä¹‰ 4.1.3** (éƒ¨åˆ†åŒæ­¥åˆ†å¸ƒå¼ç³»ç»Ÿ)
éƒ¨åˆ†åŒæ­¥åˆ†å¸ƒå¼ç³»ç»Ÿæ»¡è¶³ï¼š

1. **æ¶ˆæ¯å»¶è¿Ÿæœ‰ç•Œä½†æœªçŸ¥**ï¼šå­˜åœ¨æœ‰ç•Œå»¶è¿Ÿä½†ä¸çŸ¥é“å…·ä½“å€¼
2. **å¤„ç†æ—¶é—´æœ‰ç•Œä½†æœªçŸ¥**ï¼šå­˜åœ¨æœ‰ç•Œå¤„ç†æ—¶é—´ä½†ä¸çŸ¥é“å…·ä½“å€¼
3. **æ—¶é’Ÿåå·®æœ‰ç•Œä½†æœªçŸ¥**ï¼šå­˜åœ¨æœ‰ç•Œæ—¶é’Ÿåå·®ä½†ä¸çŸ¥é“å…·ä½“å€¼

## 5. ä»£ç å®ç°

### 5.1 Rust å®ç°

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{Duration, Instant};
use tokio::sync::mpsc;
use uuid::Uuid;

/// èŠ‚ç‚¹ID
pub type NodeId = String;

/// æ¶ˆæ¯ç±»å‹
#[derive(Debug, Clone)]
pub enum MessageType {
    Request,
    Response,
    Heartbeat,
    Consensus,
}

/// æ¶ˆæ¯
#[derive(Debug, Clone)]
pub struct Message {
    pub id: String,
    pub from: NodeId,
    pub to: NodeId,
    pub msg_type: MessageType,
    pub content: String,
    pub timestamp: Instant,
}

impl Message {
    pub fn new(from: NodeId, to: NodeId, msg_type: MessageType, content: String) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            from,
            to,
            msg_type,
            content,
            timestamp: Instant::now(),
        }
    }
}

/// èŠ‚ç‚¹çŠ¶æ€
#[derive(Debug, Clone, PartialEq)]
pub enum NodeState {
    Active,
    Inactive,
    Failed,
    Recovering,
}

/// åˆ†å¸ƒå¼èŠ‚ç‚¹
pub struct DistributedNode {
    pub id: NodeId,
    pub state: Arc<Mutex<NodeState>>,
    pub neighbors: Arc<Mutex<Vec<NodeId>>>,
    pub message_queue: Arc<Mutex<Vec<Message>>>,
    pub local_clock: Arc<Mutex<Instant>>,
    pub tx: mpsc::Sender<Message>,
    pub rx: mpsc::Receiver<Message>,
}

impl DistributedNode {
    pub fn new(id: NodeId) -> Self {
        let (tx, rx) = mpsc::channel(100);
        Self {
            id,
            state: Arc::new(Mutex::new(NodeState::Active)),
            neighbors: Arc::new(Mutex::new(Vec::new())),
            message_queue: Arc::new(Mutex::new(Vec::new())),
            local_clock: Arc::new(Mutex::new(Instant::now())),
            tx,
            rx,
        }
    }
    
    pub fn add_neighbor(&self, neighbor_id: NodeId) {
        let mut neighbors = self.neighbors.lock().unwrap();
        if !neighbors.contains(&neighbor_id) {
            neighbors.push(neighbor_id);
        }
    }
    
    pub fn remove_neighbor(&self, neighbor_id: &NodeId) {
        let mut neighbors = self.neighbors.lock().unwrap();
        neighbors.retain(|id| id != neighbor_id);
    }
    
    pub async fn send_message(&self, to: NodeId, msg_type: MessageType, content: String) {
        let message = Message::new(self.id.clone(), to, msg_type, content);
        if let Err(e) = self.tx.send(message).await {
            eprintln!("Failed to send message: {}", e);
        }
    }
    
    pub async fn broadcast(&self, msg_type: MessageType, content: String) {
        let neighbors = self.neighbors.lock().unwrap().clone();
        for neighbor in neighbors {
            self.send_message(neighbor, msg_type.clone(), content.clone()).await;
        }
    }
    
    pub async fn process_messages(&mut self) {
        while let Some(message) = self.rx.recv().await {
            self.handle_message(message).await;
        }
    }
    
    async fn handle_message(&self, message: Message) {
        let mut queue = self.message_queue.lock().unwrap();
        queue.push(message.clone());
        
        match message.msg_type {
            MessageType::Request => {
                println!("Node {} received request: {}", self.id, message.content);
                // å¤„ç†è¯·æ±‚
            }
            MessageType::Response => {
                println!("Node {} received response: {}", self.id, message.content);
                // å¤„ç†å“åº”
            }
            MessageType::Heartbeat => {
                println!("Node {} received heartbeat from {}", self.id, message.from);
                // æ›´æ–°é‚»å±…çŠ¶æ€
            }
            MessageType::Consensus => {
                println!("Node {} received consensus message: {}", self.id, message.content);
                // å¤„ç†å…±è¯†æ¶ˆæ¯
            }
        }
    }
    
    pub fn get_state(&self) -> NodeState {
        self.state.lock().unwrap().clone()
    }
    
    pub fn set_state(&self, state: NodeState) {
        *self.state.lock().unwrap() = state;
    }
    
    pub fn get_clock(&self) -> Instant {
        *self.local_clock.lock().unwrap()
    }
    
    pub fn update_clock(&self) {
        *self.local_clock.lock().unwrap() = Instant::now();
    }
}

/// åˆ†å¸ƒå¼ç³»ç»Ÿ
pub struct DistributedSystem {
    pub nodes: HashMap<NodeId, Arc<DistributedNode>>,
    pub network_delay: Duration,
    pub failure_probability: f64,
}

impl DistributedSystem {
    pub fn new() -> Self {
        Self {
            nodes: HashMap::new(),
            network_delay: Duration::from_millis(10),
            failure_probability: 0.01,
        }
    }
    
    pub fn add_node(&mut self, node: DistributedNode) {
        let node_id = node.id.clone();
        self.nodes.insert(node_id, Arc::new(node));
    }
    
    pub fn remove_node(&mut self, node_id: &NodeId) {
        self.nodes.remove(node_id);
        // ä»å…¶ä»–èŠ‚ç‚¹çš„é‚»å±…åˆ—è¡¨ä¸­ç§»é™¤
        for node in self.nodes.values() {
            node.remove_neighbor(node_id);
        }
    }
    
    pub fn connect_nodes(&self, node1_id: &NodeId, node2_id: &NodeId) {
        if let Some(node1) = self.nodes.get(node1_id) {
            node1.add_neighbor(node2_id.clone());
        }
        if let Some(node2) = self.nodes.get(node2_id) {
            node2.add_neighbor(node1_id.clone());
        }
    }
    
    pub async fn simulate_network(&self, duration: Duration) {
        let start = Instant::now();
        let mut handles = Vec::new();
        
        // å¯åŠ¨æ‰€æœ‰èŠ‚ç‚¹çš„æ¶ˆæ¯å¤„ç†
        for node in self.nodes.values() {
            let node_clone = Arc::clone(node);
            let handle = tokio::spawn(async move {
                let mut node_guard = node_clone;
                node_guard.process_messages().await;
            });
            handles.push(handle);
        }
        
        // ç­‰å¾…ä»¿çœŸå®Œæˆ
        tokio::time::sleep(duration).await;
        
        // å–æ¶ˆæ‰€æœ‰ä»»åŠ¡
        for handle in handles {
            handle.abort();
        }
        
        println!("Simulation completed in {:?}", start.elapsed());
    }
}

/// å…±è¯†ç®—æ³•
pub trait ConsensusAlgorithm {
    fn propose(&self, value: String) -> Result<(), String>;
    fn decide(&self) -> Option<String>;
    fn is_decided(&self) -> bool;
}

/// Paxoså…±è¯†ç®—æ³•
pub struct PaxosNode {
    pub node: Arc<DistributedNode>,
    pub proposal_number: u64,
    pub accepted_value: Option<String>,
    pub decided_value: Option<String>,
}

impl PaxosNode {
    pub fn new(node: Arc<DistributedNode>) -> Self {
        Self {
            node,
            proposal_number: 0,
            accepted_value: None,
            decided_value: None,
        }
    }
    
    pub async fn propose(&mut self, value: String) -> Result<(), String> {
        self.proposal_number += 1;
        
        // Phase 1: Prepare
        let prepare_msg = format!("PREPARE:{}", self.proposal_number);
        self.node.broadcast(MessageType::Consensus, prepare_msg).await;
        
        // ç­‰å¾…å¤šæ•°æ´¾å“åº”
        tokio::time::sleep(Duration::from_millis(100)).await;
        
        // Phase 2: Accept
        let accept_msg = format!("ACCEPT:{}:{}", self.proposal_number, value);
        self.node.broadcast(MessageType::Consensus, accept_msg).await;
        
        Ok(())
    }
    
    pub async fn handle_consensus_message(&mut self, message: Message) {
        let parts: Vec<&str> = message.content.split(':').collect();
        if parts.len() >= 2 {
            match parts[0] {
                "PREPARE" => {
                    // å¤„ç†Prepareæ¶ˆæ¯
                    if let Ok(proposal_num) = parts[1].parse::<u64>() {
                        if proposal_num > self.proposal_number {
                            self.proposal_number = proposal_num;
                        }
                    }
                }
                "ACCEPT" => {
                    // å¤„ç†Acceptæ¶ˆæ¯
                    if parts.len() >= 3 {
                        if let Ok(proposal_num) = parts[1].parse::<u64>() {
                            if proposal_num >= self.proposal_number {
                                self.accepted_value = Some(parts[2].to_string());
                            }
                        }
                    }
                }
                "DECIDE" => {
                    // å¤„ç†Decideæ¶ˆæ¯
                    if parts.len() >= 2 {
                        self.decided_value = Some(parts[1].to_string());
                    }
                }
                _ => {}
            }
        }
    }
}

impl ConsensusAlgorithm for PaxosNode {
    fn propose(&self, value: String) -> Result<(), String> {
        // ç®€åŒ–å®ç°
        Ok(())
    }
    
    fn decide(&self) -> Option<String> {
        self.decided_value.clone()
    }
    
    fn is_decided(&self) -> bool {
        self.decided_value.is_some()
    }
}

/// æ•…éšœæ£€æµ‹å™¨
pub struct FailureDetector {
    pub nodes: HashMap<NodeId, Instant>,
    pub timeout: Duration,
}

impl FailureDetector {
    pub fn new(timeout: Duration) -> Self {
        Self {
            nodes: HashMap::new(),
            timeout,
        }
    }
    
    pub fn update_heartbeat(&mut self, node_id: NodeId) {
        self.nodes.insert(node_id, Instant::now());
    }
    
    pub fn get_suspected_nodes(&self) -> Vec<NodeId> {
        let now = Instant::now();
        self.nodes
            .iter()
            .filter(|(_, &last_heartbeat)| now.duration_since(last_heartbeat) > self.timeout)
            .map(|(node_id, _)| node_id.clone())
            .collect()
    }
    
    pub fn is_node_suspected(&self, node_id: &NodeId) -> bool {
        if let Some(&last_heartbeat) = self.nodes.get(node_id) {
            Instant::now().duration_since(last_heartbeat) > self.timeout
        } else {
            true
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tokio;
    
    #[tokio::test]
    async fn test_distributed_node() {
        let node = DistributedNode::new("node1".to_string());
        assert_eq!(node.get_state(), NodeState::Active);
        
        node.set_state(NodeState::Inactive);
        assert_eq!(node.get_state(), NodeState::Inactive);
    }
    
    #[tokio::test]
    async fn test_distributed_system() {
        let mut system = DistributedSystem::new();
        
        let node1 = DistributedNode::new("node1".to_string());
        let node2 = DistributedNode::new("node2".to_string());
        
        system.add_node(node1);
        system.add_node(node2);
        
        assert_eq!(system.nodes.len(), 2);
        
        system.connect_nodes(&"node1".to_string(), &"node2".to_string());
        
        // æµ‹è¯•ç½‘ç»œä»¿çœŸ
        system.simulate_network(Duration::from_millis(100)).await;
    }
    
    #[tokio::test]
    async fn test_consensus() {
        let node = DistributedNode::new("node1".to_string());
        let mut paxos = PaxosNode::new(Arc::new(node));
        
        let result = paxos.propose("test_value".to_string()).await;
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_failure_detector() {
        let mut detector = FailureDetector::new(Duration::from_millis(100));
        
        detector.update_heartbeat("node1".to_string());
        assert!(!detector.is_node_suspected(&"node1".to_string()));
        
        // ç­‰å¾…è¶…æ—¶
        std::thread::sleep(Duration::from_millis(150));
        assert!(detector.is_node_suspected(&"node1".to_string()));
    }
}
```

### 5.2 Haskell å®ç°

```haskell
module DistributedSystems where

import Data.Map (Map)
import qualified Data.Map as Map
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Time.Clock
import Data.Time.Clock.POSIX
import Control.Concurrent
import Control.Concurrent.STM
import Control.Monad
import System.Random

-- èŠ‚ç‚¹ID
type NodeId = String

-- æ¶ˆæ¯ç±»å‹
data MessageType = Request | Response | Heartbeat | Consensus
    deriving (Eq, Show)

-- æ¶ˆæ¯
data Message = Message {
    msgId :: String,
    msgFrom :: NodeId,
    msgTo :: NodeId,
    msgType :: MessageType,
    msgContent :: String,
    msgTimestamp :: POSIXTime
} deriving (Show)

-- èŠ‚ç‚¹çŠ¶æ€
data NodeState = Active | Inactive | Failed | Recovering
    deriving (Eq, Show)

-- åˆ†å¸ƒå¼èŠ‚ç‚¹
data DistributedNode = DistributedNode {
    nodeId :: NodeId,
    nodeState :: TVar NodeState,
    neighbors :: TVar (Set NodeId),
    messageQueue :: TVar [Message],
    localClock :: TVar POSIXTime
}

-- åˆ›å»ºèŠ‚ç‚¹
createNode :: NodeId -> IO DistributedNode
createNode id = do
    state <- newTVarIO Active
    neighs <- newTVarIO Set.empty
    queue <- newTVarIO []
    clock <- newTVarIO =<< getPOSIXTime
    return $ DistributedNode id state neighs queue clock

-- æ·»åŠ é‚»å±…
addNeighbor :: DistributedNode -> NodeId -> IO ()
addNeighbor node neighborId = 
    atomically $ modifyTVar (neighbors node) (Set.insert neighborId)

-- ç§»é™¤é‚»å±…
removeNeighbor :: DistributedNode -> NodeId -> IO ()
removeNeighbor node neighborId = 
    atomically $ modifyTVar (neighbors node) (Set.delete neighborId)

-- è·å–é‚»å±…åˆ—è¡¨
getNeighbors :: DistributedNode -> IO (Set NodeId)
getNeighbors node = readTVarIO (neighbors node)

-- å‘é€æ¶ˆæ¯
sendMessage :: DistributedNode -> NodeId -> MessageType -> String -> IO Message
sendMessage node to msgType content = do
    timestamp <- getPOSIXTime
    let message = Message {
        msgId = show timestamp,
        msgFrom = nodeId node,
        msgTo = to,
        msgType = msgType,
        msgContent = content,
        msgTimestamp = timestamp
    }
    return message

-- å¹¿æ’­æ¶ˆæ¯
broadcast :: DistributedNode -> MessageType -> String -> IO [Message]
broadcast node msgType content = do
    neighs <- getNeighbors node
    mapM (\neighbor -> sendMessage node neighbor msgType content) (Set.toList neighs)

-- æ¥æ”¶æ¶ˆæ¯
receiveMessage :: DistributedNode -> Message -> IO ()
receiveMessage node message = 
    atomically $ modifyTVar (messageQueue node) (message :)

-- å¤„ç†æ¶ˆæ¯
handleMessage :: DistributedNode -> Message -> IO ()
handleMessage node message = do
    receiveMessage node message
    case msgType message of
        Request -> putStrLn $ "Node " ++ nodeId node ++ " received request: " ++ msgContent message
        Response -> putStrLn $ "Node " ++ nodeId node ++ " received response: " ++ msgContent message
        Heartbeat -> putStrLn $ "Node " ++ nodeId node ++ " received heartbeat from " ++ msgFrom message
        Consensus -> putStrLn $ "Node " ++ nodeId node ++ " received consensus: " ++ msgContent message

-- è·å–èŠ‚ç‚¹çŠ¶æ€
getNodeState :: DistributedNode -> IO NodeState
getNodeState node = readTVarIO (nodeState node)

-- è®¾ç½®èŠ‚ç‚¹çŠ¶æ€
setNodeState :: DistributedNode -> NodeState -> IO ()
setNodeState node state = writeTVarIO (nodeState node) state

-- åˆ†å¸ƒå¼ç³»ç»Ÿ
data DistributedSystem = DistributedSystem {
    nodes :: TVar (Map NodeId DistributedNode),
    networkDelay :: Int, -- milliseconds
    failureProbability :: Double
}

-- åˆ›å»ºåˆ†å¸ƒå¼ç³»ç»Ÿ
createDistributedSystem :: Int -> Double -> IO DistributedSystem
createDistributedSystem delay prob = do
    nodesMap <- newTVarIO Map.empty
    return $ DistributedSystem nodesMap delay prob

-- æ·»åŠ èŠ‚ç‚¹
addNodeToSystem :: DistributedSystem -> DistributedNode -> IO ()
addNodeToSystem system node = 
    atomically $ modifyTVar (nodes system) (Map.insert (nodeId node) node)

-- ç§»é™¤èŠ‚ç‚¹
removeNodeFromSystem :: DistributedSystem -> NodeId -> IO ()
removeNodeFromSystem system nodeId = do
    atomically $ modifyTVar (nodes system) (Map.delete nodeId)
    -- ä»å…¶ä»–èŠ‚ç‚¹çš„é‚»å±…åˆ—è¡¨ä¸­ç§»é™¤
    nodesMap <- readTVarIO (nodes system)
    mapM_ (\node -> removeNeighbor node nodeId) (Map.elems nodesMap)

-- è¿æ¥èŠ‚ç‚¹
connectNodes :: DistributedSystem -> NodeId -> NodeId -> IO ()
connectNodes system node1Id node2Id = do
    nodesMap <- readTVarIO (nodes system)
    case (Map.lookup node1Id nodesMap, Map.lookup node2Id nodesMap) of
        (Just node1, Just node2) -> do
            addNeighbor node1 node2Id
            addNeighbor node2 node1Id
        _ -> return ()

-- å…±è¯†ç®—æ³•ç±»å‹ç±»
class ConsensusAlgorithm a where
    propose :: a -> String -> IO (Either String ())
    decide :: a -> IO (Maybe String)
    isDecided :: a -> IO Bool

-- PaxosèŠ‚ç‚¹
data PaxosNode = PaxosNode {
    paxosNode :: DistributedNode,
    proposalNumber :: TVar Integer,
    acceptedValue :: TVar (Maybe String),
    decidedValue :: TVar (Maybe String)
}

-- åˆ›å»ºPaxosèŠ‚ç‚¹
createPaxosNode :: DistributedNode -> IO PaxosNode
createPaxosNode node = do
    propNum <- newTVarIO 0
    accVal <- newTVarIO Nothing
    decVal <- newTVarIO Nothing
    return $ PaxosNode node propNum accVal decVal

-- Paxoså…±è¯†å®ç°
instance ConsensusAlgorithm PaxosNode where
    propose paxos value = do
        atomically $ modifyTVar (proposalNumber paxos) (+1)
        
        -- Phase 1: Prepare
        propNum <- readTVarIO (proposalNumber paxos)
        let prepareMsg = "PREPARE:" ++ show propNum
        broadcast (paxosNode paxos) Consensus prepareMsg
        
        -- ç­‰å¾…ä¸€æ®µæ—¶é—´
        threadDelay 100000 -- 100ms
        
        -- Phase 2: Accept
        let acceptMsg = "ACCEPT:" ++ show propNum ++ ":" ++ value
        broadcast (paxosNode paxos) Consensus acceptMsg
        
        return $ Right ()
    
    decide paxos = readTVarIO (decidedValue paxos)
    
    isDecided paxos = do
        val <- readTVarIO (decidedValue paxos)
        return $ isJust val

-- å¤„ç†Paxosæ¶ˆæ¯
handlePaxosMessage :: PaxosNode -> Message -> IO ()
handlePaxosMessage paxos message = do
    let parts = words $ map (\c -> if c == ':' then ' ' else c) (msgContent message)
    case parts of
        ["PREPARE", numStr] -> do
            let num = read numStr :: Integer
            currentNum <- readTVarIO (proposalNumber paxos)
            when (num > currentNum) $ 
                writeTVarIO (proposalNumber paxos) num
        
        ["ACCEPT", numStr, value] -> do
            let num = read numStr :: Integer
            currentNum <- readTVarIO (proposalNumber paxos)
            when (num >= currentNum) $ 
                writeTVarIO (acceptedValue paxos) (Just value)
        
        ["DECIDE", value] -> 
            writeTVarIO (decidedValue paxos) (Just value)
        
        _ -> return ()

-- æ•…éšœæ£€æµ‹å™¨
data FailureDetector = FailureDetector {
    nodeHeartbeats :: TVar (Map NodeId POSIXTime),
    timeout :: Int -- milliseconds
}

-- åˆ›å»ºæ•…éšœæ£€æµ‹å™¨
createFailureDetector :: Int -> IO FailureDetector
createFailureDetector timeoutMs = do
    heartbeats <- newTVarIO Map.empty
    return $ FailureDetector heartbeats timeoutMs

-- æ›´æ–°å¿ƒè·³
updateHeartbeat :: FailureDetector -> NodeId -> IO ()
updateFailureDetector detector nodeId = do
    timestamp <- getPOSIXTime
    atomically $ modifyTVar (nodeHeartbeats detector) (Map.insert nodeId timestamp)

-- è·å–å¯ç–‘èŠ‚ç‚¹
getSuspectedNodes :: FailureDetector -> IO [NodeId]
getSuspectedNodes detector = do
    now <- getPOSIXTime
    heartbeats <- readTVarIO (nodeHeartbeats detector)
    let timeoutSeconds = fromIntegral (timeout detector) / 1000.0
    return [nodeId | (nodeId, lastHeartbeat) <- Map.toList heartbeats,
                    now - lastHeartbeat > timeoutSeconds]

-- æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å¯ç–‘
isNodeSuspected :: FailureDetector -> NodeId -> IO Bool
isNodeSuspected detector nodeId = do
    now <- getPOSIXTime
    heartbeats <- readTVarIO (nodeHeartbeats detector)
    case Map.lookup nodeId heartbeats of
        Just lastHeartbeat -> do
            let timeoutSeconds = fromIntegral (timeout detector) / 1000.0
            return $ now - lastHeartbeat > timeoutSeconds
        Nothing -> return True

-- ç½‘ç»œä»¿çœŸ
simulateNetwork :: DistributedSystem -> Int -> IO ()
simulateNetwork system durationMs = do
    putStrLn "Starting network simulation..."
    
    -- å¯åŠ¨æ‰€æœ‰èŠ‚ç‚¹çš„æ¶ˆæ¯å¤„ç†
    nodesMap <- readTVarIO (nodes system)
    let nodeIds = Map.keys nodesMap
    
    -- æ¨¡æ‹Ÿæ¶ˆæ¯ä¼ é€’
    replicateM_ (durationMs `div` 100) $ do
        -- éšæœºé€‰æ‹©èŠ‚ç‚¹å‘é€æ¶ˆæ¯
        randomNode <- randomRIO (0, length nodeIds - 1)
        let senderId = nodeIds !! randomNode
        case Map.lookup senderId nodesMap of
            Just sender -> do
                -- å‘é€å¿ƒè·³æ¶ˆæ¯
                messages <- broadcast sender Heartbeat "ping"
                -- æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
                threadDelay (networkDelay system * 1000)
            Nothing -> return ()
        
        threadDelay 100000 -- 100ms
    
    putStrLn "Network simulation completed."

-- ç¤ºä¾‹å‡½æ•°
exampleDistributedSystem :: IO ()
exampleDistributedSystem = do
    -- åˆ›å»ºåˆ†å¸ƒå¼ç³»ç»Ÿ
    system <- createDistributedSystem 10 0.01
    
    -- åˆ›å»ºèŠ‚ç‚¹
    node1 <- createNode "node1"
    node2 <- createNode "node2"
    node3 <- createNode "node3"
    
    -- æ·»åŠ èŠ‚ç‚¹åˆ°ç³»ç»Ÿ
    addNodeToSystem system node1
    addNodeToSystem system node2
    addNodeToSystem system node3
    
    -- è¿æ¥èŠ‚ç‚¹
    connectNodes system "node1" "node2"
    connectNodes system "node2" "node3"
    connectNodes system "node1" "node3"
    
    -- åˆ›å»ºPaxosèŠ‚ç‚¹
    paxos1 <- createPaxosNode node1
    
    -- è¿è¡Œå…±è¯†
    result <- propose paxos1 "test_value"
    case result of
        Right () -> putStrLn "Proposal sent successfully"
        Left err -> putStrLn $ "Proposal failed: " ++ err
    
    -- åˆ›å»ºæ•…éšœæ£€æµ‹å™¨
    detector <- createFailureDetector 100
    
    -- æ›´æ–°å¿ƒè·³
    updateHeartbeat detector "node1"
    updateHeartbeat detector "node2"
    
    -- æ£€æŸ¥å¯ç–‘èŠ‚ç‚¹
    suspected <- getSuspectedNodes detector
    putStrLn $ "Suspected nodes: " ++ show suspected
    
    -- è¿è¡Œç½‘ç»œä»¿çœŸ
    simulateNetwork system 1000

-- æµ‹è¯•å‡½æ•°
testDistributedNode :: IO Bool
testDistributedNode = do
    node <- createNode "test_node"
    state <- getNodeState node
    return $ state == Active

testConsensus :: IO Bool
testConsensus = do
    node <- createNode "consensus_node"
    paxos <- createPaxosNode node
    result <- propose paxos "test"
    case result of
        Right () -> return True
        Left _ -> return False

testFailureDetector :: IO Bool
testFailureDetector = do
    detector <- createFailureDetector 50
    updateHeartbeat detector "test_node"
    suspected <- isNodeSuspected detector "test_node"
    return $ not suspected
```

## 6. åº”ç”¨ç¤ºä¾‹

### 6.1 åˆ†å¸ƒå¼æ•°æ®åº“

**ç¤ºä¾‹ 6.1.1** (åˆ†å¸ƒå¼æ•°æ®åº“)
åˆ†å¸ƒå¼æ•°æ®åº“ä½¿ç”¨å…±è¯†ç®—æ³•ç¡®ä¿æ•°æ®ä¸€è‡´æ€§ï¼Œå¦‚Raftã€Paxosç­‰ã€‚

### 6.2 åˆ†å¸ƒå¼ç¼“å­˜

**ç¤ºä¾‹ 6.1.2** (åˆ†å¸ƒå¼ç¼“å­˜)
Redis Clusterä½¿ç”¨ä¸€è‡´æ€§å“ˆå¸Œå’Œæ•…éšœæ£€æµ‹å®ç°é«˜å¯ç”¨ç¼“å­˜ã€‚

### 6.3 å¾®æœåŠ¡æ¶æ„

**ç¤ºä¾‹ 6.1.3** (å¾®æœåŠ¡)
å¾®æœåŠ¡æ¶æ„ä¸­çš„æœåŠ¡å‘ç°ã€è´Ÿè½½å‡è¡¡ã€ç†”æ–­å™¨ç­‰éƒ½æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿçš„åº”ç”¨ã€‚

## 7. ç›¸å…³ç†è®º

### 7.1 ä¸ç½‘ç»œç†è®ºçš„å…³ç³»

åˆ†å¸ƒå¼ç³»ç»Ÿå»ºç«‹åœ¨ç½‘ç»œé€šä¿¡åŸºç¡€ä¹‹ä¸Šï¼Œç½‘ç»œç†è®ºä¸ºå…¶æä¾›é€šä¿¡æ¨¡å‹ã€‚

### 7.2 ä¸å¹¶å‘ç†è®ºçš„å…³ç³»

åˆ†å¸ƒå¼ç³»ç»Ÿçš„å¹¶å‘æ§åˆ¶ä¸å¹¶å‘ç†è®ºå¯†åˆ‡ç›¸å…³ã€‚

### 7.3 ä¸ç®—æ³•ç†è®ºçš„å…³ç³»

åˆ†å¸ƒå¼ç®—æ³•æ˜¯ç®—æ³•ç†è®ºåœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸‹çš„æ‰©å±•ã€‚

## 8. å‚è€ƒæ–‡çŒ®

1. Tanenbaum, A. S., & Van Steen, M. (2007). *Distributed Systems: Principles and Paradigms*. Prentice Hall.
2. Coulouris, G., Dollimore, J., Kindberg, T., & Blair, G. (2011). *Distributed Systems: Concepts and Design*. Pearson.
3. Lamport, L. (1998). *The Part-Time Parliament*. ACM Transactions on Computer Systems.
4. Fischer, M. J., Lynch, N. A., & Paterson, M. S. (1985). *Impossibility of Distributed Consensus with One Faulty Process*. Journal of the ACM.
5. Chandra, T. D., & Toueg, S. (1996). *Unreliable Failure Detectors for Reliable Distributed Systems*. Journal of the ACM.

---

**ç›¸å…³æ–‡æ¡£**ï¼š

- [06.1.2 å…±è¯†ç†è®º](../06_Distributed_Systems_Theory/06.1.2_å…±è¯†ç†è®º.md)
- [06.1.3 ä¸€è‡´æ€§ç†è®º](../06_Distributed_Systems_Theory/06.1.3_ä¸€è‡´æ€§ç†è®º.md)
- [06.1.4 åˆ†å¸ƒå¼ç®—æ³•](../06_Distributed_Systems_Theory/06.1.4_åˆ†å¸ƒå¼ç®—æ³•.md)
- [02.6.1 ç¾¤è®ºåŸºç¡€](../02_Mathematical_Foundation/02.6.1_Group_Theory_Foundation.md)
- [03.2.2 ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•](../03_Formal_Language_Theory/03.2.2_ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³•.md)
</rewritten_file>
