# 06.2.3 åˆ†å¸ƒå¼äº‹åŠ¡ç†è®º

## ğŸ“‹ æ¦‚è¿°

åˆ†å¸ƒå¼äº‹åŠ¡ç†è®ºæ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿç†è®ºçš„æ ¸å¿ƒç»„æˆéƒ¨åˆ†ï¼Œç ”ç©¶åœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸­å¦‚ä½•ä¿è¯äº‹åŠ¡çš„åŸå­æ€§ã€ä¸€è‡´æ€§ã€éš”ç¦»æ€§å’ŒæŒä¹…æ€§ï¼ˆACIDå±æ€§ï¼‰ã€‚æœ¬ç†è®ºä¸ºåˆ†å¸ƒå¼æ•°æ®åº“ã€å¾®æœåŠ¡æ¶æ„å’ŒåŒºå—é“¾ç³»ç»Ÿæä¾›ç†è®ºåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å½¢å¼åŒ–å®šä¹‰åˆ†å¸ƒå¼äº‹åŠ¡**
2. **å»ºç«‹ACIDå±æ€§çš„æ•°å­¦åŸºç¡€**
3. **è®¾è®¡åˆ†å¸ƒå¼äº‹åŠ¡åè®®**
4. **åˆ†æäº‹åŠ¡ä¸€è‡´æ€§é—®é¢˜**
5. **æä¾›å¯è¯æ˜æ­£ç¡®çš„äº‹åŠ¡ç®—æ³•**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [å½¢å¼åŒ–å®šä¹‰](#2-å½¢å¼åŒ–å®šä¹‰)
3. [å®šç†ä¸è¯æ˜](#3-å®šç†ä¸è¯æ˜)
4. [ä»£ç å®ç°](#4-ä»£ç å®ç°)
5. [åº”ç”¨ç¤ºä¾‹](#5-åº”ç”¨ç¤ºä¾‹)
6. [ç›¸å…³ç†è®º](#6-ç›¸å…³ç†è®º)
7. [å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 åˆ†å¸ƒå¼äº‹åŠ¡

**å®šä¹‰ 1.1.1** (åˆ†å¸ƒå¼äº‹åŠ¡)
åˆ†å¸ƒå¼äº‹åŠ¡æ˜¯ä¸€ä¸ªåœ¨å¤šä¸ªèŠ‚ç‚¹ä¸Šæ‰§è¡Œçš„æ“ä½œåºåˆ—ï¼Œå¿…é¡»æ»¡è¶³ACIDå±æ€§ï¼š

- **åŸå­æ€§ (Atomicity)**: äº‹åŠ¡è¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥
- **ä¸€è‡´æ€§ (Consistency)**: äº‹åŠ¡æ‰§è¡Œå‰åç³»ç»ŸçŠ¶æ€ä¿æŒä¸€è‡´
- **éš”ç¦»æ€§ (Isolation)**: å¹¶å‘äº‹åŠ¡ä¹‹é—´ç›¸äº’éš”ç¦»
- **æŒä¹…æ€§ (Durability)**: å·²æäº¤äº‹åŠ¡çš„ç»“æœæ°¸ä¹…ä¿å­˜

### 1.2 äº‹åŠ¡çŠ¶æ€

**å®šä¹‰ 1.2.1** (äº‹åŠ¡çŠ¶æ€)
äº‹åŠ¡çŠ¶æ€æ˜¯ä¸€ä¸ªäº”å…ƒç»„ $(S, T, V, L, C)$ï¼Œå…¶ä¸­ï¼š

- $S$: çŠ¶æ€é›†åˆ $\{active, prepared, committed, aborted\}$
- $T$: äº‹åŠ¡æ ‡è¯†ç¬¦
- $V$: ç‰ˆæœ¬å‘é‡
- $L$: é”é›†åˆ
- $C$: æäº¤æ—¶é—´æˆ³

### 1.3 åˆ†å¸ƒå¼äº‹åŠ¡æ¨¡å‹

**å®šä¹‰ 1.3.1** (åˆ†å¸ƒå¼äº‹åŠ¡æ¨¡å‹)
åˆ†å¸ƒå¼äº‹åŠ¡æ¨¡å‹æ˜¯ä¸€ä¸ªä¸ƒå…ƒç»„ $(N, R, T, O, S, P, C)$ï¼Œå…¶ä¸­ï¼š

- $N$: èŠ‚ç‚¹é›†åˆ
- $R$: èµ„æºé›†åˆ
- $T$: äº‹åŠ¡é›†åˆ
- $O$: æ“ä½œé›†åˆ
- $S$: çŠ¶æ€è½¬æ¢å‡½æ•°
- $P$: åè®®é›†åˆ
- $C$: ä¸€è‡´æ€§çº¦æŸ

## 2. å½¢å¼åŒ–å®šä¹‰

### 2.1 äº‹åŠ¡æ“ä½œè¯­ä¹‰

**å®šä¹‰ 2.1.1** (äº‹åŠ¡æ“ä½œ)
äº‹åŠ¡æ“ä½œæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $(op, res, val)$ï¼Œå…¶ä¸­ï¼š

- $op \in \{read, write, commit, abort\}$
- $res \in R$ æ˜¯èµ„æºæ ‡è¯†ç¬¦
- $val$ æ˜¯æ“ä½œå€¼

**å®šä¹‰ 2.1.2** (æ“ä½œåºåˆ—)
æ“ä½œåºåˆ—æ˜¯ä¸€ä¸ªæœ‰åºçš„æ“ä½œåˆ—è¡¨ï¼š
$$\sigma = [op_1, op_2, ..., op_n]$$

### 2.2 ä¸€è‡´æ€§æ¨¡å‹

**å®šä¹‰ 2.2.1** (çº¿æ€§ä¸€è‡´æ€§)
ä¸€ä¸ªæ‰§è¡Œæ˜¯çº¿æ€§ä¸€è‡´çš„ï¼Œå½“ä¸”ä»…å½“å­˜åœ¨ä¸€ä¸ªå…¨å±€é¡ºåºï¼Œä½¿å¾—ï¼š
$$\forall op_1, op_2: op_1 \prec op_2 \Rightarrow op_1 \prec_{global} op_2$$

**å®šä¹‰ 2.2.2** (é¡ºåºä¸€è‡´æ€§)
ä¸€ä¸ªæ‰§è¡Œæ˜¯é¡ºåºä¸€è‡´çš„ï¼Œå½“ä¸”ä»…å½“ï¼š
$$\forall P_i: \sigma|_{P_i} \text{ æ˜¯åˆæ³•çš„é¡ºåºæ‰§è¡Œ}$$

### 2.3 åˆ†å¸ƒå¼äº‹åŠ¡åè®®

**å®šä¹‰ 2.3.1** (ä¸¤é˜¶æ®µæäº¤åè®®)
ä¸¤é˜¶æ®µæäº¤åè®®æ˜¯ä¸€ä¸ªçŠ¶æ€æœºï¼ŒåŒ…å«ä»¥ä¸‹çŠ¶æ€ï¼š

1. **å‡†å¤‡é˜¶æ®µ**: åè°ƒè€…å‘æ‰€æœ‰å‚ä¸è€…å‘é€å‡†å¤‡è¯·æ±‚
2. **æäº¤é˜¶æ®µ**: æ ¹æ®å‚ä¸è€…å“åº”å†³å®šæäº¤æˆ–ä¸­æ­¢

**å®šä¹‰ 2.3.2** (ä¸‰é˜¶æ®µæäº¤åè®®)
ä¸‰é˜¶æ®µæäº¤åè®®åœ¨2PCåŸºç¡€ä¸Šå¢åŠ é¢„æäº¤é˜¶æ®µï¼š

1. **å‡†å¤‡é˜¶æ®µ**: æ”¶é›†å‚ä¸è€…å‡†å¤‡çŠ¶æ€
2. **é¢„æäº¤é˜¶æ®µ**: ç¡®ä¿æ‰€æœ‰å‚ä¸è€…å‡†å¤‡å°±ç»ª
3. **æäº¤é˜¶æ®µ**: æ‰§è¡Œæœ€ç»ˆæäº¤æˆ–ä¸­æ­¢

## 3. å®šç†ä¸è¯æ˜

### 3.1 ä¸¤é˜¶æ®µæäº¤æ­£ç¡®æ€§

**å®šç† 3.1.1** (2PCæ­£ç¡®æ€§)
ä¸¤é˜¶æ®µæäº¤åè®®ä¿è¯åˆ†å¸ƒå¼äº‹åŠ¡çš„åŸå­æ€§ã€‚

**è¯æ˜**:
è®¾ $T$ æ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼äº‹åŠ¡ï¼Œ$P = \{p_1, p_2, ..., p_n\}$ æ˜¯å‚ä¸è€…é›†åˆã€‚

1. **å‡†å¤‡é˜¶æ®µ**: åè°ƒè€…å‘æ‰€æœ‰å‚ä¸è€…å‘é€ `prepare` æ¶ˆæ¯
2. **ç­‰å¾…å“åº”**: æ”¶é›†æ‰€æœ‰å‚ä¸è€…çš„ `ready` æˆ– `abort` å“åº”
3. **å†³ç­–é˜¶æ®µ**:
   - å¦‚æœæ‰€æœ‰å‚ä¸è€…éƒ½ `ready`ï¼Œå‘é€ `commit`
   - å¦‚æœæœ‰ä»»ä½•å‚ä¸è€… `abort`ï¼Œå‘é€ `abort`

**åŸå­æ€§ä¿è¯**:

- å¦‚æœæ‰€æœ‰å‚ä¸è€…éƒ½å‡†å¤‡å°±ç»ªï¼Œäº‹åŠ¡æäº¤
- å¦‚æœæœ‰ä»»ä½•å‚ä¸è€…å¤±è´¥ï¼Œäº‹åŠ¡ä¸­æ­¢
- ä¸å­˜åœ¨éƒ¨åˆ†æäº¤çš„æƒ…å†µ

### 3.2 é˜»å¡å®šç†

**å®šç† 3.2.1** (2PCé˜»å¡å®šç†)
ä¸¤é˜¶æ®µæäº¤åè®®åœ¨åè°ƒè€…æ•…éšœæ—¶å¯èƒ½é˜»å¡ã€‚

**è¯æ˜**:
è€ƒè™‘ä»¥ä¸‹åœºæ™¯ï¼š

1. åè°ƒè€…å‘é€ `prepare` æ¶ˆæ¯ç»™æ‰€æœ‰å‚ä¸è€…
2. æ‰€æœ‰å‚ä¸è€…éƒ½å“åº” `ready`
3. åè°ƒè€…åœ¨å‘é€ `commit` æ¶ˆæ¯å‰æ•…éšœ

æ­¤æ—¶å‚ä¸è€…æ— æ³•ç¡®å®šäº‹åŠ¡çŠ¶æ€ï¼Œå¿…é¡»ç­‰å¾…åè°ƒè€…æ¢å¤ï¼Œå¯¼è‡´é˜»å¡ã€‚

### 3.3 ä¸‰é˜¶æ®µæäº¤æ— é˜»å¡æ€§

**å®šç† 3.3.1** (3PCæ— é˜»å¡æ€§)
ä¸‰é˜¶æ®µæäº¤åè®®åœ¨å•ç‚¹æ•…éšœæ—¶ä¸ä¼šé˜»å¡ã€‚

**è¯æ˜**:
3PCé€šè¿‡é¢„æäº¤é˜¶æ®µç¡®ä¿ï¼š

1. å¦‚æœåè°ƒè€…åœ¨é¢„æäº¤é˜¶æ®µæ•…éšœï¼Œæ–°åè°ƒè€…å¯ä»¥å®‰å…¨æäº¤
2. å¦‚æœåè°ƒè€…åœ¨æäº¤é˜¶æ®µæ•…éšœï¼Œå‚ä¸è€…å¯ä»¥å®‰å…¨æäº¤
3. é¢„æäº¤é˜¶æ®µç¡®ä¿æ‰€æœ‰å‚ä¸è€…éƒ½å‡†å¤‡å°±ç»ª

## 4. ä»£ç å®ç°

### 4.1 ä¸¤é˜¶æ®µæäº¤åè®®å®ç°

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TransactionState {
    Active,
    Prepared,
    Committed,
    Aborted,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Message {
    Prepare { transaction_id: String },
    Ready { transaction_id: String },
    Abort { transaction_id: String },
    Commit { transaction_id: String },
}

#[derive(Debug)]
pub struct Participant {
    id: String,
    state: Arc<Mutex<TransactionState>>,
    tx: mpsc::Sender<Message>,
}

impl Participant {
    pub fn new(id: String, tx: mpsc::Sender<Message>) -> Self {
        Self {
            id,
            state: Arc::new(Mutex::new(TransactionState::Active)),
            tx,
        }
    }

    pub async fn handle_prepare(&self, transaction_id: String) -> Result<(), Box<dyn std::error::Error>> {
        let mut state = self.state.lock().unwrap();
        match *state {
            TransactionState::Active => {
                // æ‰§è¡Œæœ¬åœ°äº‹åŠ¡å‡†å¤‡
                if self.prepare_local_transaction(&transaction_id).await? {
                    *state = TransactionState::Prepared;
                    self.tx.send(Message::Ready { transaction_id }).await?;
                } else {
                    *state = TransactionState::Aborted;
                    self.tx.send(Message::Abort { transaction_id }).await?;
                }
            }
            _ => {
                // å·²ç»å¤„ç†è¿‡ï¼Œå¿½ç•¥é‡å¤æ¶ˆæ¯
            }
        }
        Ok(())
    }

    pub async fn handle_commit(&self, transaction_id: String) -> Result<(), Box<dyn std::error::Error>> {
        let mut state = self.state.lock().unwrap();
        match *state {
            TransactionState::Prepared => {
                // æ‰§è¡Œæœ¬åœ°æäº¤
                self.commit_local_transaction(&transaction_id).await?;
                *state = TransactionState::Committed;
            }
            _ => {
                // çŠ¶æ€ä¸æ­£ç¡®ï¼Œå¿½ç•¥æ¶ˆæ¯
            }
        }
        Ok(())
    }

    pub async fn handle_abort(&self, transaction_id: String) -> Result<(), Box<dyn std::error::Error>> {
        let mut state = self.state.lock().unwrap();
        match *state {
            TransactionState::Prepared => {
                // æ‰§è¡Œæœ¬åœ°å›æ»š
                self.abort_local_transaction(&transaction_id).await?;
                *state = TransactionState::Aborted;
            }
            _ => {
                // çŠ¶æ€ä¸æ­£ç¡®ï¼Œå¿½ç•¥æ¶ˆæ¯
            }
        }
        Ok(())
    }

    async fn prepare_local_transaction(&self, transaction_id: &str) -> Result<bool, Box<dyn std::error::Error>> {
        // æ¨¡æ‹Ÿæœ¬åœ°äº‹åŠ¡å‡†å¤‡
        // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œä¼šæ‰§è¡Œæ•°æ®åº“äº‹åŠ¡å‡†å¤‡
        println!("Participant {} preparing transaction {}", self.id, transaction_id);
        Ok(true)
    }

    async fn commit_local_transaction(&self, transaction_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        // æ¨¡æ‹Ÿæœ¬åœ°äº‹åŠ¡æäº¤
        println!("Participant {} committing transaction {}", self.id, transaction_id);
        Ok(())
    }

    async fn abort_local_transaction(&self, transaction_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        // æ¨¡æ‹Ÿæœ¬åœ°äº‹åŠ¡å›æ»š
        println!("Participant {} aborting transaction {}", self.id, transaction_id);
        Ok(())
    }
}

#[derive(Debug)]
pub struct Coordinator {
    participants: Vec<Participant>,
    transaction_id: String,
}

impl Coordinator {
    pub fn new(participants: Vec<Participant>, transaction_id: String) -> Self {
        Self {
            participants,
            transaction_id,
        }
    }

    pub async fn execute_transaction(&self) -> Result<bool, Box<dyn std::error::Error>> {
        println!("Starting 2PC for transaction {}", self.transaction_id);

        // é˜¶æ®µ1: å‡†å¤‡é˜¶æ®µ
        let prepare_results = self.prepare_phase().await?;
        
        // æ£€æŸ¥æ‰€æœ‰å‚ä¸è€…æ˜¯å¦å‡†å¤‡å°±ç»ª
        let all_ready = prepare_results.iter().all(|&ready| ready);
        
        if all_ready {
            // é˜¶æ®µ2: æäº¤é˜¶æ®µ
            self.commit_phase().await?;
            println!("Transaction {} committed successfully", self.transaction_id);
            Ok(true)
        } else {
            // é˜¶æ®µ2: ä¸­æ­¢é˜¶æ®µ
            self.abort_phase().await?;
            println!("Transaction {} aborted", self.transaction_id);
            Ok(false)
        }
    }

    async fn prepare_phase(&self) -> Result<Vec<bool>, Box<dyn std::error::Error>> {
        let mut results = Vec::new();
        
        for participant in &self.participants {
            // å‘é€å‡†å¤‡æ¶ˆæ¯
            participant.tx.send(Message::Prepare { 
                transaction_id: self.transaction_id.clone() 
            }).await?;
            
            // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œä¼šç­‰å¾…å‚ä¸è€…çš„å“åº”
            // ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬å‡è®¾æ‰€æœ‰å‚ä¸è€…éƒ½å‡†å¤‡å°±ç»ª
            results.push(true);
        }
        
        Ok(results)
    }

    async fn commit_phase(&self) -> Result<(), Box<dyn std::error::Error>> {
        for participant in &self.participants {
            participant.tx.send(Message::Commit { 
                transaction_id: self.transaction_id.clone() 
            }).await?;
        }
        Ok(())
    }

    async fn abort_phase(&self) -> Result<(), Box<dyn std::error::Error>> {
        for participant in &self.participants {
            participant.tx.send(Message::Abort { 
                transaction_id: self.transaction_id.clone() 
            }).await?;
        }
        Ok(())
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆ›å»ºå‚ä¸è€…
    let (tx1, mut rx1) = mpsc::channel(100);
    let (tx2, mut rx2) = mpsc::channel(100);
    let (tx3, mut rx3) = mpsc::channel(100);

    let participant1 = Participant::new("P1".to_string(), tx1);
    let participant2 = Participant::new("P2".to_string(), tx2);
    let participant3 = Participant::new("P3".to_string(), tx3);

    let participants = vec![participant1, participant2, participant3];
    let coordinator = Coordinator::new(participants, "TXN-001".to_string());

    // å¯åŠ¨å‚ä¸è€…æ¶ˆæ¯å¤„ç†
    let participant1_clone = participant1.clone();
    let participant2_clone = participant2.clone();
    let participant3_clone = participant3.clone();

    tokio::spawn(async move {
        while let Some(msg) = rx1.recv().await {
            match msg {
                Message::Prepare { transaction_id } => {
                    participant1_clone.handle_prepare(transaction_id).await.unwrap();
                }
                Message::Commit { transaction_id } => {
                    participant1_clone.handle_commit(transaction_id).await.unwrap();
                }
                Message::Abort { transaction_id } => {
                    participant1_clone.handle_abort(transaction_id).await.unwrap();
                }
                _ => {}
            }
        }
    });

    tokio::spawn(async move {
        while let Some(msg) = rx2.recv().await {
            match msg {
                Message::Prepare { transaction_id } => {
                    participant2_clone.handle_prepare(transaction_id).await.unwrap();
                }
                Message::Commit { transaction_id } => {
                    participant2_clone.handle_commit(transaction_id).await.unwrap();
                }
                Message::Abort { transaction_id } => {
                    participant2_clone.handle_abort(transaction_id).await.unwrap();
                }
                _ => {}
            }
        }
    });

    tokio::spawn(async move {
        while let Some(msg) = rx3.recv().await {
            match msg {
                Message::Prepare { transaction_id } => {
                    participant3_clone.handle_prepare(transaction_id).await.unwrap();
                }
                Message::Commit { transaction_id } => {
                    participant3_clone.handle_commit(transaction_id).await.unwrap();
                }
                Message::Abort { transaction_id } => {
                    participant3_clone.handle_abort(transaction_id).await.unwrap();
                }
                _ => {}
            }
        }
    });

    // æ‰§è¡Œåˆ†å¸ƒå¼äº‹åŠ¡
    let result = coordinator.execute_transaction().await?;
    println!("Transaction result: {}", result);

    Ok(())
}
```

### 4.2 ä¸‰é˜¶æ®µæäº¤åè®®å®ç°

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc;
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ThreePCState {
    Active,
    Prepared,
    PreCommitted,
    Committed,
    Aborted,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ThreePCMessage {
    Prepare { transaction_id: String },
    Ready { transaction_id: String },
    Abort { transaction_id: String },
    PreCommit { transaction_id: String },
    Ack { transaction_id: String },
    Commit { transaction_id: String },
}

#[derive(Debug)]
pub struct ThreePCParticipant {
    id: String,
    state: Arc<Mutex<ThreePCState>>,
    tx: mpsc::Sender<ThreePCMessage>,
}

impl ThreePCParticipant {
    pub fn new(id: String, tx: mpsc::Sender<ThreePCMessage>) -> Self {
        Self {
            id,
            state: Arc::new(Mutex::new(ThreePCState::Active)),
            tx,
        }
    }

    pub async fn handle_prepare(&self, transaction_id: String) -> Result<(), Box<dyn std::error::Error>> {
        let mut state = self.state.lock().unwrap();
        match *state {
            ThreePCState::Active => {
                if self.prepare_local_transaction(&transaction_id).await? {
                    *state = ThreePCState::Prepared;
                    self.tx.send(ThreePCMessage::Ready { transaction_id }).await?;
                } else {
                    *state = ThreePCState::Aborted;
                    self.tx.send(ThreePCMessage::Abort { transaction_id }).await?;
                }
            }
            _ => {}
        }
        Ok(())
    }

    pub async fn handle_pre_commit(&self, transaction_id: String) -> Result<(), Box<dyn std::error::Error>> {
        let mut state = self.state.lock().unwrap();
        match *state {
            ThreePCState::Prepared => {
                *state = ThreePCState::PreCommitted;
                self.tx.send(ThreePCMessage::Ack { transaction_id }).await?;
            }
            _ => {}
        }
        Ok(())
    }

    pub async fn handle_commit(&self, transaction_id: String) -> Result<(), Box<dyn std::error::Error>> {
        let mut state = self.state.lock().unwrap();
        match *state {
            ThreePCState::PreCommitted => {
                self.commit_local_transaction(&transaction_id).await?;
                *state = ThreePCState::Committed;
            }
            _ => {}
        }
        Ok(())
    }

    pub async fn handle_abort(&self, transaction_id: String) -> Result<(), Box<dyn std::error::Error>> {
        let mut state = self.state.lock().unwrap();
        match *state {
            ThreePCState::Prepared | ThreePCState::PreCommitted => {
                self.abort_local_transaction(&transaction_id).await?;
                *state = ThreePCState::Aborted;
            }
            _ => {}
        }
        Ok(())
    }

    async fn prepare_local_transaction(&self, transaction_id: &str) -> Result<bool, Box<dyn std::error::Error>> {
        println!("3PC Participant {} preparing transaction {}", self.id, transaction_id);
        Ok(true)
    }

    async fn commit_local_transaction(&self, transaction_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        println!("3PC Participant {} committing transaction {}", self.id, transaction_id);
        Ok(())
    }

    async fn abort_local_transaction(&self, transaction_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        println!("3PC Participant {} aborting transaction {}", self.id, transaction_id);
        Ok(())
    }
}

#[derive(Debug)]
pub struct ThreePCCoordinator {
    participants: Vec<ThreePCParticipant>,
    transaction_id: String,
}

impl ThreePCCoordinator {
    pub fn new(participants: Vec<ThreePCParticipant>, transaction_id: String) -> Self {
        Self {
            participants,
            transaction_id,
        }
    }

    pub async fn execute_transaction(&self) -> Result<bool, Box<dyn std::error::Error>> {
        println!("Starting 3PC for transaction {}", self.transaction_id);

        // é˜¶æ®µ1: å‡†å¤‡é˜¶æ®µ
        let prepare_results = self.prepare_phase().await?;
        let all_ready = prepare_results.iter().all(|&ready| ready);
        
        if !all_ready {
            self.abort_phase().await?;
            println!("Transaction {} aborted in prepare phase", self.transaction_id);
            return Ok(false);
        }

        // é˜¶æ®µ2: é¢„æäº¤é˜¶æ®µ
        let precommit_results = self.precommit_phase().await?;
        let all_acked = precommit_results.iter().all(|&acked| acked);
        
        if !all_acked {
            self.abort_phase().await?;
            println!("Transaction {} aborted in precommit phase", self.transaction_id);
            return Ok(false);
        }

        // é˜¶æ®µ3: æäº¤é˜¶æ®µ
        self.commit_phase().await?;
        println!("Transaction {} committed successfully", self.transaction_id);
        Ok(true)
    }

    async fn prepare_phase(&self) -> Result<Vec<bool>, Box<dyn std::error::Error>> {
        let mut results = Vec::new();
        
        for participant in &self.participants {
            participant.tx.send(ThreePCMessage::Prepare { 
                transaction_id: self.transaction_id.clone() 
            }).await?;
            results.push(true);
        }
        
        Ok(results)
    }

    async fn precommit_phase(&self) -> Result<Vec<bool>, Box<dyn std::error::Error>> {
        let mut results = Vec::new();
        
        for participant in &self.participants {
            participant.tx.send(ThreePCMessage::PreCommit { 
                transaction_id: self.transaction_id.clone() 
            }).await?;
            results.push(true);
        }
        
        Ok(results)
    }

    async fn commit_phase(&self) -> Result<(), Box<dyn std::error::Error>> {
        for participant in &self.participants {
            participant.tx.send(ThreePCMessage::Commit { 
                transaction_id: self.transaction_id.clone() 
            }).await?;
        }
        Ok(())
    }

    async fn abort_phase(&self) -> Result<(), Box<dyn std::error::Error>> {
        for participant in &self.participants {
            participant.tx.send(ThreePCMessage::Abort { 
                transaction_id: self.transaction_id.clone() 
            }).await?;
        }
        Ok(())
    }
}
```

## 5. åº”ç”¨ç¤ºä¾‹

### 5.1 åˆ†å¸ƒå¼æ•°æ®åº“äº‹åŠ¡

```rust
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::RwLock;

#[derive(Debug, Clone)]
pub struct DatabaseRecord {
    key: String,
    value: String,
    version: u64,
}

#[derive(Debug)]
pub struct DistributedDatabase {
    nodes: HashMap<String, Arc<RwLock<HashMap<String, DatabaseRecord>>>>,
    coordinator: Arc<Mutex<Coordinator>>,
}

impl DistributedDatabase {
    pub fn new() -> Self {
        let mut nodes = HashMap::new();
        nodes.insert("node1".to_string(), Arc::new(RwLock::new(HashMap::new())));
        nodes.insert("node2".to_string(), Arc::new(RwLock::new(HashMap::new())));
        nodes.insert("node3".to_string(), Arc::new(RwLock::new(HashMap::new())));

        let coordinator = Arc::new(Mutex::new(Coordinator::new()));
        
        Self { nodes, coordinator }
    }

    pub async fn execute_transaction(&self, operations: Vec<DatabaseOperation>) -> Result<bool, Box<dyn std::error::Error>> {
        let transaction_id = format!("txn_{}", uuid::Uuid::new_v4());
        
        // å‡†å¤‡é˜¶æ®µï¼šé”å®šèµ„æº
        let prepare_results = self.prepare_operations(&transaction_id, &operations).await?;
        
        if !prepare_results.iter().all(|&success| success) {
            // å›æ»šæ‰€æœ‰æ“ä½œ
            self.rollback_operations(&transaction_id, &operations).await?;
            return Ok(false);
        }

        // æäº¤é˜¶æ®µï¼šæ‰§è¡Œæ“ä½œ
        self.commit_operations(&transaction_id, &operations).await?;
        
        Ok(true)
    }

    async fn prepare_operations(&self, transaction_id: &str, operations: &[DatabaseOperation]) -> Result<Vec<bool>, Box<dyn std::error::Error>> {
        let mut results = Vec::new();
        
        for operation in operations {
            let node = self.nodes.get(&operation.node).unwrap();
            let mut db = node.write().await;
            
            // æ£€æŸ¥èµ„æºæ˜¯å¦å¯ç”¨
            let success = match operation.op_type {
                OperationType::Read => {
                    db.contains_key(&operation.key)
                }
                OperationType::Write => {
                    // æ£€æŸ¥å†™é”
                    true // ç®€åŒ–å®ç°
                }
            };
            
            results.push(success);
        }
        
        Ok(results)
    }

    async fn commit_operations(&self, transaction_id: &str, operations: &[DatabaseOperation]) -> Result<(), Box<dyn std::error::Error>> {
        for operation in operations {
            let node = self.nodes.get(&operation.node).unwrap();
            let mut db = node.write().await;
            
            match operation.op_type {
                OperationType::Read => {
                    // è¯»å–æ“ä½œ
                    if let Some(record) = db.get(&operation.key) {
                        println!("Read: {} = {}", record.key, record.value);
                    }
                }
                OperationType::Write => {
                    // å†™å…¥æ“ä½œ
                    let record = DatabaseRecord {
                        key: operation.key.clone(),
                        value: operation.value.clone().unwrap_or_default(),
                        version: 1,
                    };
                    db.insert(operation.key.clone(), record);
                }
            }
        }
        
        Ok(())
    }

    async fn rollback_operations(&self, transaction_id: &str, operations: &[DatabaseOperation]) -> Result<(), Box<dyn std::error::Error>> {
        // å›æ»šæ“ä½œå®ç°
        println!("Rolling back transaction {}", transaction_id);
        Ok(())
    }
}

#[derive(Debug)]
pub enum OperationType {
    Read,
    Write,
}

#[derive(Debug)]
pub struct DatabaseOperation {
    node: String,
    key: String,
    value: Option<String>,
    op_type: OperationType,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let db = DistributedDatabase::new();
    
    let operations = vec![
        DatabaseOperation {
            node: "node1".to_string(),
            key: "user:1".to_string(),
            value: Some("Alice".to_string()),
            op_type: OperationType::Write,
        },
        DatabaseOperation {
            node: "node2".to_string(),
            key: "user:2".to_string(),
            value: Some("Bob".to_string()),
            op_type: OperationType::Write,
        },
        DatabaseOperation {
            node: "node3".to_string(),
            key: "user:1".to_string(),
            value: None,
            op_type: OperationType::Read,
        },
    ];
    
    let result = db.execute_transaction(operations).await?;
    println!("Transaction result: {}", result);
    
    Ok(())
}
```

## 6. ç›¸å…³ç†è®º

### 6.1 ä¸å…±è¯†ç†è®ºçš„å…³ç³»

åˆ†å¸ƒå¼äº‹åŠ¡ç†è®ºæ˜¯å…±è¯†ç†è®ºåœ¨äº‹åŠ¡å¤„ç†é¢†åŸŸçš„åº”ç”¨ã€‚ä¸¤é˜¶æ®µæäº¤åè®®æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªå…±è¯†ç®—æ³•ï¼Œç”¨äºåœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸­è¾¾æˆäº‹åŠ¡æäº¤æˆ–ä¸­æ­¢çš„å…±è¯†ã€‚

### 6.2 ä¸ä¸€è‡´æ€§ç†è®ºçš„å…³ç³»

åˆ†å¸ƒå¼äº‹åŠ¡ç†è®ºä¸ºä¸€è‡´æ€§ç†è®ºæä¾›äº†å…·ä½“çš„å®ç°æœºåˆ¶ã€‚ACIDå±æ€§ä¸­çš„ä¸€è‡´æ€§è¦æ±‚ä¸åˆ†å¸ƒå¼ä¸€è‡´æ€§æ¨¡å‹å¯†åˆ‡ç›¸å…³ã€‚

### 6.3 ä¸åˆ†å¸ƒå¼ç®—æ³•ç†è®ºçš„å…³ç³»

åˆ†å¸ƒå¼äº‹åŠ¡åè®®æ˜¯åˆ†å¸ƒå¼ç®—æ³•çš„é‡è¦å®ä¾‹ï¼Œæ¶‰åŠæ¶ˆæ¯ä¼ é€’ã€æ•…éšœå¤„ç†ã€çŠ¶æ€åŒæ­¥ç­‰æ ¸å¿ƒé—®é¢˜ã€‚

## 7. å‚è€ƒæ–‡çŒ®

1. Gray, J., & Lamport, L. (2006). Consensus on transaction commit. ACM Transactions on Database Systems, 31(1), 133-160.

2. Bernstein, P. A., Hadzilacos, V., & Goodman, N. (1987). Concurrency control and recovery in database systems. Addison-Wesley.

3. Lamport, L. (1998). The part-time parliament. ACM Transactions on Computer Systems, 16(2), 133-169.

4. Chandra, T. D., & Toueg, S. (1996). Unreliable failure detectors for reliable distributed systems. Journal of the ACM, 43(2), 225-267.

5. Skeen, D. (1981). Nonblocking commit protocols. In Proceedings of the 1981 ACM SIGMOD international conference on Management of data (pp. 133-142).

---

**ç›¸å…³æ–‡æ¡£**:

- [06.2.1 å…±è¯†ç†è®º](../06_Distributed_Systems_Theory/06.2.1_å…±è¯†ç†è®º.md)
- [06.2.2 ä¸€è‡´æ€§ç†è®º](../06_Distributed_Systems_Theory/06.2.2_ä¸€è‡´æ€§ç†è®º.md)
- [06.2.4 åˆ†å¸ƒå¼å­˜å‚¨ç†è®º](../06_Distributed_Systems_Theory/06.2.4_åˆ†å¸ƒå¼å­˜å‚¨ç†è®º.md)
