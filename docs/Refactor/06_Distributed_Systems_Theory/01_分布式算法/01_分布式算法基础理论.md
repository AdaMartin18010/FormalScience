# åˆ†å¸ƒå¼ç®—æ³•åŸºç¡€ç†è®º (Distributed Algorithms Foundation)

## ğŸ¯ **æ¦‚è¿°**

åˆ†å¸ƒå¼ç®—æ³•æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿç†è®ºçš„æ ¸å¿ƒï¼Œç ”ç©¶å¦‚ä½•åœ¨å¤šä¸ªèŠ‚ç‚¹ä¹‹é—´åè°ƒè®¡ç®—ï¼Œè§£å†³å…±è¯†ã€ä¸€è‡´æ€§ã€å®¹é”™ç­‰å…³é”®é—®é¢˜ã€‚æœ¬æ–‡æ¡£æ„å»ºäº†å®Œæ•´çš„åˆ†å¸ƒå¼ç®—æ³•ç†è®ºä½“ç³»ã€‚

## ğŸ“š **ç›®å½•**

### 1. åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€ç†è®º

- **1.1** ç³»ç»Ÿæ¨¡å‹å½¢å¼åŒ–
- **1.2** æ•…éšœæ¨¡å‹
- **1.3** ç³»ç»Ÿæ‰§è¡Œæ¨¡å‹
- **1.4** å¤æ‚åº¦åˆ†æ

### 2. å…±è¯†ç®—æ³•

- **2.1** å…±è¯†é—®é¢˜å®šä¹‰
- **2.2** Paxosç®—æ³•
- **2.3** Raftç®—æ³•
- **2.4** æ‹œå åº­å®¹é”™ç®—æ³•

### 3. ä¸€è‡´æ€§åè®®

- **3.1** å¼ºä¸€è‡´æ€§
- **3.2** æœ€ç»ˆä¸€è‡´æ€§
- **3.3** å› æœä¸€è‡´æ€§
- **3.4** é¡ºåºä¸€è‡´æ€§

### 4. å®¹é”™ç®—æ³•

- **4.1** æ•…éšœæ£€æµ‹
- **4.2** æ•…éšœæ¢å¤
- **4.3** å¤åˆ¶ç®¡ç†
- **4.4** çŠ¶æ€åŒæ­¥

### 5. åˆ†å¸ƒå¼åè°ƒ

- **5.1** åˆ†å¸ƒå¼é”
- **5.2** é¢†å¯¼è€…é€‰ä¸¾
- **5.3** ç»„æˆå‘˜ç®¡ç†
- **5.4** åˆ†å¸ƒå¼äº‹åŠ¡

## 1. åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€ç†è®º

### 1.1 ç³»ç»Ÿæ¨¡å‹å½¢å¼åŒ–

**å®šä¹‰ 1.1 (åˆ†å¸ƒå¼ç³»ç»Ÿ)**
åˆ†å¸ƒå¼ç³»ç»Ÿæ˜¯ä¸€ä¸ªä¸‰å…ƒç»„ $DS = (N, C, M)$ï¼Œå…¶ä¸­ï¼š

- $N = \{p_1, p_2, \ldots, p_n\}$ æ˜¯èŠ‚ç‚¹é›†åˆï¼Œ$|N| = n$
- $C \subseteq N \times N$ æ˜¯é€šä¿¡å…³ç³»
- $M$ æ˜¯æ¶ˆæ¯ä¼ é€’æœºåˆ¶

**å®šä¹‰ 1.2 (å¼‚æ­¥ç³»ç»Ÿ)**
å¼‚æ­¥åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼š

- æ¶ˆæ¯ä¼ é€’å»¶è¿Ÿæ— ç•Œä½†æœ‰é™
- èŠ‚ç‚¹å¤„ç†æ—¶é—´æ— ç•Œä½†æœ‰é™
- ä¸å­˜åœ¨å…¨å±€æ—¶é’Ÿ

**å®šä¹‰ 1.3 (åŒæ­¥ç³»ç»Ÿ)**
åŒæ­¥åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼š

- æ¶ˆæ¯ä¼ é€’å»¶è¿Ÿæœ‰ç•Œ
- èŠ‚ç‚¹å¤„ç†æ—¶é—´æœ‰ç•Œ
- å­˜åœ¨å…¨å±€æ—¶é’Ÿæˆ–åŒæ­¥è½®æ¬¡

**å®šä¹‰ 1.4 (éƒ¨åˆ†åŒæ­¥ç³»ç»Ÿ)**
éƒ¨åˆ†åŒæ­¥ç³»ç»Ÿä¸­ï¼š

- æ¶ˆæ¯ä¼ é€’å»¶è¿Ÿæœ‰ç•Œä½†æœªçŸ¥
- èŠ‚ç‚¹å¤„ç†æ—¶é—´æœ‰ç•Œä½†æœªçŸ¥
- æ—¶é’Ÿæ¼‚ç§»æœ‰ç•Œ

**å½¢å¼åŒ–å®ç°ï¼š**

```haskell
data Node = Node {
  nodeId :: NodeId,
  state :: NodeState,
  neighbors :: [NodeId]
} deriving (Show, Eq)

data DistributedSystem = DistributedSystem {
  nodes :: Map NodeId Node,
  communication :: CommunicationModel,
  messageMechanism :: MessageMechanism
} deriving (Show)

data CommunicationModel = 
  Synchronous {
    maxDelay :: Time,
    maxProcessingTime :: Time
  }
  | Asynchronous {
    minDelay :: Time,
    maxDelay :: Time
  }
  | PartialSynchronous {
    unknownBound :: Time
  }
  deriving (Show)

-- ç³»ç»Ÿæ‰§è¡Œæ¨¡å‹
data Event = 
  InternalEvent NodeId StateTransition
  | SendEvent NodeId NodeId Message
  | ReceiveEvent NodeId NodeId Message
  deriving (Show)

type Execution = [Event]

-- ç³»ç»Ÿæ‰§è¡Œ
executeSystem :: DistributedSystem -> Execution -> DistributedSystem
executeSystem sys events = 
  foldl executeEvent sys events

executeEvent :: DistributedSystem -> Event -> DistributedSystem
executeEvent sys event = 
  case event of
    InternalEvent nodeId transition -> 
      let node = nodes sys ! nodeId
          newState = applyTransition (state node) transition
          newNode = node { state = newState }
      in sys { nodes = Map.insert nodeId newNode (nodes sys) }
    
    SendEvent from to message -> 
      let -- å‘é€æ¶ˆæ¯
          newMessages = addMessage (messageMechanism sys) from to message
      in sys { messageMechanism = newMessages }
    
    ReceiveEvent from to message -> 
      let -- æ¥æ”¶æ¶ˆæ¯
          node = nodes sys ! to
          newState = processMessage (state node) message
          newNode = node { state = newState }
      in sys { nodes = Map.insert to newNode (nodes sys) }
```

### 1.2 æ•…éšœæ¨¡å‹

**å®šä¹‰ 1.5 (æ•…éšœç±»å‹)**
èŠ‚ç‚¹æ•…éšœç±»å‹ï¼š

- **å´©æºƒæ•…éšœ**ï¼šèŠ‚ç‚¹åœæ­¢å·¥ä½œ
- **æ‹œå åº­æ•…éšœ**ï¼šèŠ‚ç‚¹ä»»æ„è¡Œä¸º
- **é—æ¼æ•…éšœ**ï¼šèŠ‚ç‚¹é—æ¼æŸäº›æ“ä½œ
- **æ—¶åºæ•…éšœ**ï¼šèŠ‚ç‚¹è¿åæ—¶åºçº¦æŸ

**å®šä¹‰ 1.6 (æ•…éšœå‡è®¾)**
æ•…éšœå‡è®¾ $F$ æŒ‡å®šï¼š

- æ•…éšœç±»å‹
- æœ€å¤§æ•…éšœèŠ‚ç‚¹æ•° $f$
- æ•…éšœæ¨¡å¼ï¼ˆé™æ€/åŠ¨æ€ï¼‰

**å®šç† 1.1 (æ•…éšœè¾¹ç•Œ)**
åœ¨ $n$ ä¸ªèŠ‚ç‚¹çš„ç³»ç»Ÿä¸­ï¼Œæœ€å¤šå¯ä»¥å®¹å¿ $f$ ä¸ªæ•…éšœèŠ‚ç‚¹ï¼Œå…¶ä¸­ï¼š

- å´©æºƒæ•…éšœï¼š$f < n$
- æ‹œå åº­æ•…éšœï¼š$f < n/3$
- é—æ¼æ•…éšœï¼š$f < n/2$

**è¯æ˜ï¼š** é€šè¿‡åè¯æ³•ï¼š

1. å‡è®¾å¯ä»¥å®¹å¿æ›´å¤šæ•…éšœèŠ‚ç‚¹
2. æ„é€ æ•…éšœåœºæ™¯å¯¼è‡´åè®®å¤±è´¥
3. å¾—å‡ºçŸ›ç›¾ï¼Œè¯æ˜è¾¹ç•Œæ­£ç¡®

**å½¢å¼åŒ–å®ç°ï¼š**

```haskell
data FaultType = 
  CrashFault
  | ByzantineFault
  | OmissionFault
  | TimingFault
  deriving (Show, Eq)

data FaultAssumption = FaultAssumption {
  faultType :: FaultType,
  maxFaultyNodes :: Int,
  faultPattern :: FaultPattern
} deriving (Show)

data FaultPattern = Static | Dynamic deriving (Show, Eq)

-- æ•…éšœæ£€æµ‹å™¨
data FailureDetector = FailureDetector {
  suspected :: Map NodeId Bool,
  timeout :: Time
} deriving (Show)

-- æ•…éšœæ£€æµ‹
detectFaults :: DistributedSystem -> FailureDetector -> FailureDetector
detectFaults sys detector = 
  let -- æ£€æŸ¥æ¯ä¸ªèŠ‚ç‚¹
      newSuspected = Map.mapWithKey (\nodeId _ -> 
        isNodeFaulty sys nodeId detector) (nodes sys)
  in detector { suspected = newSuspected }

isNodeFaulty :: DistributedSystem -> NodeId -> FailureDetector -> Bool
isNodeFaulty sys nodeId detector = 
  let -- æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å“åº”
      lastHeartbeat = getLastHeartbeat sys nodeId
      currentTime = getCurrentTime sys
  in currentTime - lastHeartbeat > timeout detector

-- æ•…éšœè¾¹ç•Œæ£€æŸ¥
checkFaultBound :: Int -> FaultType -> Bool
checkFaultBound n faultType = 
  let maxFaulty = case faultType of
        CrashFault -> n - 1
        ByzantineFault -> n `div` 3 - 1
        OmissionFault -> n `div` 2 - 1
        TimingFault -> n - 1
  in maxFaulty >= 0
```

### 1.3 ç³»ç»Ÿæ‰§è¡Œæ¨¡å‹

**å®šä¹‰ 1.7 (ç³»ç»Ÿæ‰§è¡Œ)**
ç³»ç»Ÿæ‰§è¡Œæ˜¯äº‹ä»¶åºåˆ— $\sigma = e_1, e_2, \ldots$ï¼Œå…¶ä¸­æ¯ä¸ªäº‹ä»¶ $e_i$ æ˜¯ï¼š

- å†…éƒ¨äº‹ä»¶ï¼šèŠ‚ç‚¹å†…éƒ¨çŠ¶æ€è½¬æ¢
- å‘é€äº‹ä»¶ï¼šèŠ‚ç‚¹å‘é€æ¶ˆæ¯
- æ¥æ”¶äº‹ä»¶ï¼šèŠ‚ç‚¹æ¥æ”¶æ¶ˆæ¯

**å®šä¹‰ 1.8 (æ‰§è¡Œå…¬å¹³æ€§)**
æ‰§è¡Œæ˜¯å…¬å¹³çš„ï¼Œå¦‚æœï¼š

- æ¯ä¸ªæ¶ˆæ¯æœ€ç»ˆè¢«ä¼ é€’
- æ¯ä¸ªæ­£ç¡®èŠ‚ç‚¹æ— é™æ¬¡æ‰§è¡Œæ­¥éª¤

**å½¢å¼åŒ–å®ç°ï¼š**

```haskell
data ExecutionModel = ExecutionModel {
  events :: [Event],
  fairness :: FairnessConstraint
} deriving (Show)

data FairnessConstraint = 
  Unfair
  | WeakFairness
  | StrongFairness
  deriving (Show)

-- æ‰§è¡Œå…¬å¹³æ€§æ£€æŸ¥
checkFairness :: Execution -> FairnessConstraint -> Bool
checkFairness execution fairness = 
  case fairness of
    Unfair -> True
    WeakFairness -> checkWeakFairness execution
    StrongFairness -> checkStrongFairness execution

checkWeakFairness :: Execution -> Bool
checkWeakFairness execution = 
  let -- æ£€æŸ¥æ¯ä¸ªæ¶ˆæ¯æ˜¯å¦æœ€ç»ˆè¢«ä¼ é€’
      messages = extractMessages execution
      delivered = extractDeliveredMessages execution
  in all (\msg -> msg `elem` delivered) messages

checkStrongFairness :: Execution -> Bool
checkWeakFairness execution = 
  let -- æ£€æŸ¥æ¯ä¸ªæ­£ç¡®èŠ‚ç‚¹æ˜¯å¦æ— é™æ¬¡æ‰§è¡Œ
      nodeExecutions = countNodeExecutions execution
  in all (\count -> count > 0) nodeExecutions
```

## 2. å…±è¯†ç®—æ³•

### 2.1 å…±è¯†é—®é¢˜

**å®šä¹‰ 2.1 (å…±è¯†é—®é¢˜)**
å…±è¯†é—®é¢˜è¦æ±‚æ‰€æœ‰æ­£ç¡®èŠ‚ç‚¹å°±æŸä¸ªå€¼è¾¾æˆä¸€è‡´ï¼Œæ»¡è¶³ï¼š

- **ä¸€è‡´æ€§**ï¼šæ‰€æœ‰æ­£ç¡®èŠ‚ç‚¹å†³å®šç›¸åŒå€¼
- **æœ‰æ•ˆæ€§**ï¼šå¦‚æœæ‰€æœ‰æ­£ç¡®èŠ‚ç‚¹æè®®ç›¸åŒå€¼ï¼Œåˆ™å†³å®šè¯¥å€¼
- **ç»ˆæ­¢æ€§**ï¼šæ‰€æœ‰æ­£ç¡®èŠ‚ç‚¹æœ€ç»ˆåšå‡ºå†³å®š

**å®šä¹‰ 2.2 (å…±è¯†å¤æ‚åº¦)**
å…±è¯†é—®é¢˜çš„å¤æ‚åº¦åº¦é‡ï¼š

- **æ¶ˆæ¯å¤æ‚åº¦**ï¼šæ€»æ¶ˆæ¯æ•°é‡
- **æ—¶é—´å¤æ‚åº¦**ï¼šå†³å®šè½®æ¬¡æ•°é‡
- **ç©ºé—´å¤æ‚åº¦**ï¼šæ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨ç©ºé—´

**å®šç† 2.1 (FLPä¸å¯èƒ½æ€§)**
åœ¨å¼‚æ­¥ç³»ç»Ÿä¸­ï¼Œå³ä½¿åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹å´©æºƒï¼Œä¹Ÿæ— æ³•å®ç°ç¡®å®šæ€§å…±è¯†ã€‚

**è¯æ˜ï¼š** é€šè¿‡æ„é€ æ€§è¯æ˜ï¼š

1. å‡è®¾å­˜åœ¨ç¡®å®šæ€§å…±è¯†ç®—æ³•
2. æ„é€ æ‰§è¡Œåºåˆ—å¯¼è‡´æ— é™å»¶è¿Ÿ
3. è¿åç»ˆæ­¢æ€§ï¼Œå¾—å‡ºçŸ›ç›¾

**å½¢å¼åŒ–å®ç°ï¼š**

```haskell
data ConsensusProblem = ConsensusProblem {
  nodes :: [NodeId],
  proposedValues :: Map NodeId Value,
  decidedValues :: Map NodeId Value
} deriving (Show)

data ConsensusProperties = ConsensusProperties {
  agreement :: Bool,    -- ä¸€è‡´æ€§
  validity :: Bool,     -- æœ‰æ•ˆæ€§
  termination :: Bool   -- ç»ˆæ­¢æ€§
} deriving (Show)

-- å…±è¯†ç®—æ³•æ¥å£
class ConsensusAlgorithm a where
  propose :: a -> NodeId -> Value -> a
  decide :: a -> NodeId -> Maybe Value
  step :: a -> Event -> a

-- å…±è¯†æ­£ç¡®æ€§æ£€æŸ¥
checkConsensusCorrectness :: ConsensusProblem -> ConsensusProperties
checkConsensusCorrectness problem = 
  let -- æ£€æŸ¥ä¸€è‡´æ€§
      agreement = checkAgreement problem
      -- æ£€æŸ¥æœ‰æ•ˆæ€§
      validity = checkValidity problem
      -- æ£€æŸ¥ç»ˆæ­¢æ€§
      termination = checkTermination problem
  in ConsensusProperties {
    agreement = agreement,
    validity = validity,
    termination = termination
  }

checkAgreement :: ConsensusProblem -> Bool
checkAgreement problem = 
  let decidedValues = Map.elems (decidedValues problem)
      uniqueValues = Set.fromList decidedValues
  in Set.size uniqueValues <= 1

checkValidity :: ConsensusProblem -> Bool
checkValidity problem = 
  let -- æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æè®®å€¼ç›¸åŒ
      proposedValues = Map.elems (proposedValues problem)
      allSame = all (\v -> v == head proposedValues) proposedValues
      -- æ£€æŸ¥å†³å®šå€¼æ˜¯å¦åœ¨æè®®å€¼ä¸­
      decidedInProposed = all (\v -> v `elem` proposedValues) 
                              (Map.elems (decidedValues problem))
  in not allSame || decidedInProposed
```

### 2.2 Paxosç®—æ³•

**å®šä¹‰ 2.3 (Paxosè§’è‰²)**
Paxosç®—æ³•ä¸­çš„è§’è‰²ï¼š

- **æè®®è€…**ï¼šå‘èµ·æè®®
- **æ¥å—è€…**ï¼šæ¥å—æè®®
- **å­¦ä¹ è€…**ï¼šå­¦ä¹ æœ€ç»ˆå†³å®š

**å®šä¹‰ 2.4 (PaxosçŠ¶æ€)**
PaxosçŠ¶æ€åŒ…å«ï¼š

- **æè®®ç¼–å·**ï¼š$n \in \mathbb{N}$
- **å·²æ¥å—å€¼**ï¼š$v \in V$
- **å·²æ¥å—ç¼–å·**ï¼š$n_a \in \mathbb{N}$

**å½¢å¼åŒ–å®ç°ï¼š**

```rust
// Rustå®ç°Paxosç®—æ³•
#[derive(Debug, Clone)]
pub struct PaxosState {
    proposal_number: u64,
    accepted_value: Option<Value>,
    accepted_number: u64,
    promised_number: u64,
}

#[derive(Debug)]
pub enum PaxosRole {
    Proposer,
    Acceptor,
    Learner,
}

#[derive(Debug)]
pub struct PaxosNode {
    node_id: NodeId,
    role: PaxosRole,
    state: PaxosState,
    acceptors: Vec<NodeId>,
    learners: Vec<NodeId>,
}

impl PaxosNode {
    pub fn new(node_id: NodeId, role: PaxosRole) -> Self {
        PaxosNode {
            node_id,
            role,
            state: PaxosState {
                proposal_number: 0,
                accepted_value: None,
                accepted_number: 0,
                promised_number: 0,
            },
            acceptors: Vec::new(),
            learners: Vec::new(),
        }
    }
    
    // Phase 1a: æè®®è€…å‘é€Prepareæ¶ˆæ¯
    pub fn phase_1a(&mut self, value: Value) -> Vec<Message> {
        self.state.proposal_number += 1;
        let prepare_msg = Message::Prepare {
            from: self.node_id,
            proposal_number: self.state.proposal_number,
            value,
        };
        
        self.acceptors.iter().map(|&acceptor_id| {
            Message::new(prepare_msg.clone(), self.node_id, acceptor_id)
        }).collect()
    }
    
    // Phase 1b: æ¥å—è€…å“åº”Prepareæ¶ˆæ¯
    pub fn phase_1b(&mut self, msg: &Message) -> Option<Message> {
        if let Message::Prepare { proposal_number, .. } = msg {
            if *proposal_number > self.state.promised_number {
                self.state.promised_number = *proposal_number;
                
                let response = Message::Promise {
                    from: self.node_id,
                    proposal_number: *proposal_number,
                    accepted_number: self.state.accepted_number,
                    accepted_value: self.state.accepted_value.clone(),
                };
                
                Some(Message::new(response, self.node_id, msg.from()))
            } else {
                Some(Message::Nack {
                    from: self.node_id,
                    proposal_number: *proposal_number,
                })
            }
        } else {
            None
        }
    }
    
    // Phase 2a: æè®®è€…å‘é€Acceptæ¶ˆæ¯
    pub fn phase_2a(&mut self, value: Value) -> Vec<Message> {
        let accept_msg = Message::Accept {
            from: self.node_id,
            proposal_number: self.state.proposal_number,
            value,
        };
        
        self.acceptors.iter().map(|&acceptor_id| {
            Message::new(accept_msg.clone(), self.node_id, acceptor_id)
        }).collect()
    }
    
    // Phase 2b: æ¥å—è€…å“åº”Acceptæ¶ˆæ¯
    pub fn phase_2b(&mut self, msg: &Message) -> Option<Message> {
        if let Message::Accept { proposal_number, value } = msg {
            if *proposal_number >= self.state.promised_number {
                self.state.accepted_number = *proposal_number;
                self.state.accepted_value = Some(value.clone());
                
                let response = Message::Accepted {
                    from: self.node_id,
                    proposal_number: *proposal_number,
                    value: value.clone(),
                };
                
                // é€šçŸ¥å­¦ä¹ è€…
                self.notify_learners(&response);
                
                Some(Message::new(response, self.node_id, msg.from()))
            } else {
                Some(Message::Nack {
                    from: self.node_id,
                    proposal_number: *proposal_number,
                })
            }
        } else {
            None
        }
    }
    
    fn notify_learners(&self, msg: &Message) {
        for &learner_id in &self.learners {
            // å‘é€å­¦ä¹ æ¶ˆæ¯
        }
    }
}

#[derive(Debug, Clone)]
pub enum Message {
    Prepare {
        from: NodeId,
        proposal_number: u64,
        value: Value,
    },
    Promise {
        from: NodeId,
        proposal_number: u64,
        accepted_number: u64,
        accepted_value: Option<Value>,
    },
    Accept {
        from: NodeId,
        proposal_number: u64,
        value: Value,
    },
    Accepted {
        from: NodeId,
        proposal_number: u64,
        value: Value,
    },
    Nack {
        from: NodeId,
        proposal_number: u64,
    },
}
```

### 2.3 Raftç®—æ³•

**å®šä¹‰ 2.5 (Raftè§’è‰²)**
Raftç®—æ³•ä¸­çš„è§’è‰²ï¼š

- **é¢†å¯¼è€…**ï¼šå¤„ç†å®¢æˆ·ç«¯è¯·æ±‚
- **è·Ÿéšè€…**ï¼šå“åº”é¢†å¯¼è€…è¯·æ±‚
- **å€™é€‰äºº**ï¼šå‚ä¸é¢†å¯¼è€…é€‰ä¸¾

**å®šä¹‰ 2.6 (RaftçŠ¶æ€)**
RaftçŠ¶æ€åŒ…å«ï¼š

- **å½“å‰ä»»æœŸ**ï¼š$term \in \mathbb{N}$
- **æŠ•ç¥¨ä¿¡æ¯**ï¼š$votedFor \in N \cup \{\bot\}$
- **æ—¥å¿—æ¡ç›®**ï¼š$log = [entry_1, entry_2, \ldots]$

**å½¢å¼åŒ–å®ç°ï¼š**

```rust
// Rustå®ç°Raftç®—æ³•
#[derive(Debug, Clone)]
pub struct RaftState {
    current_term: u64,
    voted_for: Option<NodeId>,
    log: Vec<LogEntry>,
    commit_index: u64,
    last_applied: u64,
}

#[derive(Debug, Clone)]
pub struct LogEntry {
    term: u64,
    index: u64,
    command: Command,
}

#[derive(Debug)]
pub enum RaftRole {
    Follower,
    Candidate,
    Leader,
}

#[derive(Debug)]
pub struct RaftNode {
    node_id: NodeId,
    role: RaftRole,
    state: RaftState,
    election_timeout: Duration,
    heartbeat_interval: Duration,
    last_heartbeat: Instant,
}

impl RaftNode {
    pub fn new(node_id: NodeId) -> Self {
        RaftNode {
            node_id,
            role: RaftRole::Follower,
            state: RaftState {
                current_term: 0,
                voted_for: None,
                log: Vec::new(),
                commit_index: 0,
                last_applied: 0,
            },
            election_timeout: Duration::from_millis(150),
            heartbeat_interval: Duration::from_millis(50),
            last_heartbeat: Instant::now(),
        }
    }
    
    // é¢†å¯¼è€…é€‰ä¸¾
    pub fn start_election(&mut self) -> Vec<Message> {
        self.state.current_term += 1;
        self.role = RaftRole::Candidate;
        self.state.voted_for = Some(self.node_id);
        
        let request_vote_msg = Message::RequestVote {
            term: self.state.current_term,
            candidate_id: self.node_id,
            last_log_index: self.state.log.len() as u64,
            last_log_term: self.state.log.last().map(|e| e.term).unwrap_or(0),
        };
        
        // å‘æ‰€æœ‰å…¶ä»–èŠ‚ç‚¹å‘é€æŠ•ç¥¨è¯·æ±‚
        self.get_all_nodes().iter().filter(|&&id| id != self.node_id)
            .map(|&node_id| {
                Message::new(request_vote_msg.clone(), self.node_id, node_id)
            }).collect()
    }
    
    // å¤„ç†æŠ•ç¥¨è¯·æ±‚
    pub fn handle_request_vote(&mut self, msg: &Message) -> Option<Message> {
        if let Message::RequestVote { term, candidate_id, last_log_index, last_log_term } = msg {
            let mut vote_granted = false;
            
            if *term > self.state.current_term {
                self.state.current_term = *term;
                self.role = RaftRole::Follower;
                self.state.voted_for = None;
            }
            
            if *term == self.state.current_term && 
               (self.state.voted_for.is_none() || self.state.voted_for == Some(*candidate_id)) {
                // æ£€æŸ¥æ—¥å¿—å®Œæ•´æ€§
                let last_log = self.state.log.last();
                if last_log.is_none() || 
                   (*last_log_term > last_log.unwrap().term) ||
                   (*last_log_term == last_log.unwrap().term && *last_log_index >= last_log.unwrap().index) {
                    vote_granted = true;
                    self.state.voted_for = Some(*candidate_id);
                }
            }
            
            Some(Message::RequestVoteResponse {
                term: self.state.current_term,
                vote_granted,
            })
        } else {
            None
        }
    }
    
    // é¢†å¯¼è€…å¿ƒè·³
    pub fn send_heartbeat(&self) -> Vec<Message> {
        let append_entries_msg = Message::AppendEntries {
            term: self.state.current_term,
            leader_id: self.node_id,
            prev_log_index: 0,
            prev_log_term: 0,
            entries: Vec::new(),
            leader_commit: self.state.commit_index,
        };
        
        self.get_all_nodes().iter().filter(|&&id| id != self.node_id)
            .map(|&node_id| {
                Message::new(append_entries_msg.clone(), self.node_id, node_id)
            }).collect()
    }
    
    // å¤„ç†å¿ƒè·³
    pub fn handle_append_entries(&mut self, msg: &Message) -> Option<Message> {
        if let Message::AppendEntries { term, leader_id, entries, leader_commit } = msg {
            if *term >= self.state.current_term {
                self.state.current_term = *term;
                self.role = RaftRole::Follower;
                self.last_heartbeat = Instant::now();
                
                // åº”ç”¨æ—¥å¿—æ¡ç›®
                if !entries.is_empty() {
                    self.apply_log_entries(entries);
                }
                
                // æ›´æ–°æäº¤ç´¢å¼•
                if *leader_commit > self.state.commit_index {
                    self.state.commit_index = std::cmp::min(*leader_commit, self.state.log.len() as u64);
                }
                
                Some(Message::AppendEntriesResponse {
                    term: self.state.current_term,
                    success: true,
                })
            } else {
                Some(Message::AppendEntriesResponse {
                    term: self.state.current_term,
                    success: false,
                })
            }
        } else {
            None
        }
    }
    
    fn apply_log_entries(&mut self, entries: &[LogEntry]) {
        for entry in entries {
            if entry.index <= self.state.log.len() as u64 {
                // æˆªæ–­å†²çªçš„æ—¥å¿—
                self.state.log.truncate(entry.index as usize);
            }
            self.state.log.push(entry.clone());
        }
    }
}
```

## 3. ä¸€è‡´æ€§åè®®

### 3.1 å¼ºä¸€è‡´æ€§

**å®šä¹‰ 3.1 (å¼ºä¸€è‡´æ€§)**
å¼ºä¸€è‡´æ€§è¦æ±‚æ‰€æœ‰èŠ‚ç‚¹çœ‹åˆ°ç›¸åŒçš„æ“ä½œé¡ºåºã€‚

**å®šä¹‰ 3.2 (çº¿æ€§ä¸€è‡´æ€§)**
çº¿æ€§ä¸€è‡´æ€§æ˜¯æœ€å¼ºçš„ä¸€è‡´æ€§æ¨¡å‹ï¼Œè¦æ±‚ï¼š

- **åŸå­æ€§**ï¼šæ“ä½œè¦ä¹ˆå®Œå…¨æ‰§è¡Œï¼Œè¦ä¹ˆå®Œå…¨ä¸æ‰§è¡Œ
- **é¡ºåºæ€§**ï¼šæ‰€æœ‰æ“ä½œéƒ½æœ‰å…¨å±€é¡ºåº
- **å®æ—¶æ€§**ï¼šå¦‚æœæ“ä½œAåœ¨æ“ä½œBå¼€å§‹å‰å®Œæˆï¼Œåˆ™Aåœ¨Bä¹‹å‰

**å½¢å¼åŒ–å®ç°ï¼š**

```haskell
data ConsistencyModel = 
  StrongConsistency
  | Linearizability
  | SequentialConsistency
  | CausalConsistency
  | EventualConsistency
  deriving (Show, Eq)

data Operation = Operation {
  operationId :: OperationId,
  nodeId :: NodeId,
  timestamp :: Timestamp,
  operationType :: OperationType,
  key :: Key,
  value :: Value
} deriving (Show)

data OperationType = Read | Write | Delete deriving (Show, Eq)

-- å¼ºä¸€è‡´æ€§æ£€æŸ¥
checkStrongConsistency :: [Operation] -> Bool
checkStrongConsistency operations = 
  let -- æ£€æŸ¥åŸå­æ€§
      atomic = checkAtomicity operations
      -- æ£€æŸ¥é¡ºåºæ€§
      ordered = checkOrdering operations
      -- æ£€æŸ¥å®æ—¶æ€§
      realtime = checkRealtime operations
  in atomic && ordered && realtime

checkAtomicity :: [Operation] -> Bool
checkAtomicity operations = 
  let -- æ£€æŸ¥æ¯ä¸ªæ“ä½œæ˜¯å¦å®Œå…¨æ‰§è¡Œ
      completed = all isCompleted operations
  in completed

checkOrdering :: [Operation] -> Bool
checkOrdering operations = 
  let -- æ£€æŸ¥æ˜¯å¦å­˜åœ¨å…¨å±€é¡ºåº
      globalOrder = findGlobalOrder operations
  in isConsistent globalOrder

checkRealtime :: [Operation] -> Bool
checkRealtime operations = 
  let -- æ£€æŸ¥å®æ—¶æ€§çº¦æŸ
      realtimeConstraints = generateRealtimeConstraints operations
  in all checkConstraint realtimeConstraints
```

## 4. å®¹é”™ç®—æ³•

### 4.1 æ•…éšœæ£€æµ‹

**å®šä¹‰ 4.1 (æ•…éšœæ£€æµ‹å™¨)**
æ•…éšœæ£€æµ‹å™¨æ˜¯å‡½æ•° $FD : N \rightarrow 2^N$ï¼Œæ»¡è¶³ï¼š

- **å®Œæ•´æ€§**ï¼šå´©æºƒèŠ‚ç‚¹æœ€ç»ˆè¢«æ‰€æœ‰æ­£ç¡®èŠ‚ç‚¹æ€€ç–‘
- **å‡†ç¡®æ€§**ï¼šæ­£ç¡®èŠ‚ç‚¹æœ€ç»ˆä¸è¢«æ€€ç–‘

**å®šç† 4.1 (æ•…éšœæ£€æµ‹å™¨ä¸å¯èƒ½æ€§)**
åœ¨å¼‚æ­¥ç³»ç»Ÿä¸­ï¼Œæ— æ³•å®ç°å®Œç¾çš„æ•…éšœæ£€æµ‹å™¨ã€‚

**è¯æ˜ï¼š** é€šè¿‡å¼‚æ­¥æ€§ï¼š

1. æ— æ³•åŒºåˆ†æ…¢èŠ‚ç‚¹å’Œæ•…éšœèŠ‚ç‚¹
2. å®Œç¾æ£€æµ‹å™¨éœ€è¦åŒæ­¥å‡è®¾
3. å› æ­¤å¼‚æ­¥ç³»ç»Ÿä¸­ä¸å¯èƒ½

**å½¢å¼åŒ–å®ç°ï¼š**

```haskell
data FailureDetector = FailureDetector {
  suspected :: Map NodeId Bool,
  timeout :: Time,
  heartbeatInterval :: Time
} deriving (Show)

-- æ•…éšœæ£€æµ‹ç®—æ³•
detectFailures :: DistributedSystem -> FailureDetector -> FailureDetector
detectFailures sys detector = 
  let -- æ£€æŸ¥æ¯ä¸ªèŠ‚ç‚¹
      newSuspected = Map.mapWithKey (\nodeId _ -> 
        isNodeSuspected sys nodeId detector) (nodes sys)
  in detector { suspected = newSuspected }

isNodeSuspected :: DistributedSystem -> NodeId -> FailureDetector -> Bool
isNodeSuspected sys nodeId detector = 
  let -- æ£€æŸ¥æœ€åå¿ƒè·³æ—¶é—´
      lastHeartbeat = getLastHeartbeat sys nodeId
      currentTime = getCurrentTime sys
  in currentTime - lastHeartbeat > timeout detector

-- å¿ƒè·³æœºåˆ¶
sendHeartbeat :: NodeId -> [NodeId] -> [Message]
sendHeartbeat sender receivers = 
  map (\receiver -> Message {
    from = sender,
    to = receiver,
    content = Heartbeat { timestamp = getCurrentTime }
  }) receivers
```

## 5. åˆ†å¸ƒå¼åè°ƒ

### 5.1 åˆ†å¸ƒå¼é”

**å®šä¹‰ 5.1 (åˆ†å¸ƒå¼é”)**
åˆ†å¸ƒå¼é”ç¡®ä¿åœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸­èµ„æºçš„äº’æ–¥è®¿é—®ã€‚

**å®šä¹‰ 5.2 (é”æ€§è´¨)**
åˆ†å¸ƒå¼é”åº”æ»¡è¶³ï¼š

- **äº’æ–¥æ€§**ï¼šåŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹æŒæœ‰é”
- **æ— æ­»é”**ï¼šä¸ä¼šå‡ºç°æ‰€æœ‰èŠ‚ç‚¹éƒ½åœ¨ç­‰å¾…çš„æƒ…å†µ
- **æ— é¥¥é¥¿**ï¼šæ¯ä¸ªè¯·æ±‚æœ€ç»ˆéƒ½èƒ½è·å¾—é”

**å½¢å¼åŒ–å®ç°ï¼š**

```rust
// Rustå®ç°åˆ†å¸ƒå¼é”
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::time::{Duration, Instant};

#[derive(Debug, Clone)]
pub struct LockRequest {
    node_id: NodeId,
    resource_id: ResourceId,
    timestamp: Instant,
    timeout: Duration,
}

#[derive(Debug)]
pub struct DistributedLock {
    resource_id: ResourceId,
    holder: Option<NodeId>,
    queue: Vec<LockRequest>,
    timeout: Duration,
}

impl DistributedLock {
    pub fn new(resource_id: ResourceId) -> Self {
        DistributedLock {
            resource_id,
            holder: None,
            queue: Vec::new(),
            timeout: Duration::from_secs(30),
        }
    }
    
    pub fn acquire(&mut self, request: LockRequest) -> LockResult {
        if self.holder.is_none() {
            // é”å¯ç”¨ï¼Œç›´æ¥è·å–
            self.holder = Some(request.node_id);
            LockResult::Granted
        } else if self.holder == Some(request.node_id) {
            // é‡å…¥é”
            LockResult::Granted
        } else {
            // é”è¢«å ç”¨ï¼ŒåŠ å…¥é˜Ÿåˆ—
            self.queue.push(request);
            LockResult::Queued
        }
    }
    
    pub fn release(&mut self, node_id: NodeId) -> Option<LockRequest> {
        if self.holder == Some(node_id) {
            self.holder = None;
            
            // ä»é˜Ÿåˆ—ä¸­é€‰æ‹©ä¸‹ä¸€ä¸ªè¯·æ±‚
            if let Some(next_request) = self.queue.pop() {
                self.holder = Some(next_request.node_id);
                Some(next_request)
            } else {
                None
            }
        } else {
            None
        }
    }
    
    pub fn check_timeout(&mut self) -> Vec<LockRequest> {
        let now = Instant::now();
        let mut timed_out = Vec::new();
        
        // æ£€æŸ¥è¶…æ—¶çš„è¯·æ±‚
        self.queue.retain(|request| {
            if now.duration_since(request.timestamp) > request.timeout {
                timed_out.push(request.clone());
                false
            } else {
                true
            }
        });
        
        timed_out
    }
}

#[derive(Debug)]
pub enum LockResult {
    Granted,
    Queued,
    Timeout,
    Error(String),
}

// åˆ†å¸ƒå¼é”ç®¡ç†å™¨
#[derive(Debug)]
pub struct LockManager {
    locks: Arc<Mutex<HashMap<ResourceId, DistributedLock>>>,
}

impl LockManager {
    pub fn new() -> Self {
        LockManager {
            locks: Arc::new(Mutex::new(HashMap::new())),
        }
    }
    
    pub async fn acquire_lock(&self, resource_id: ResourceId, node_id: NodeId) -> LockResult {
        let mut locks = self.locks.lock().unwrap();
        
        let lock = locks.entry(resource_id).or_insert_with(|| {
            DistributedLock::new(resource_id)
        });
        
        let request = LockRequest {
            node_id,
            resource_id,
            timestamp: Instant::now(),
            timeout: Duration::from_secs(30),
        };
        
        lock.acquire(request)
    }
    
    pub async fn release_lock(&self, resource_id: ResourceId, node_id: NodeId) -> bool {
        let mut locks = self.locks.lock().unwrap();
        
        if let Some(lock) = locks.get_mut(&resource_id) {
            lock.release(node_id).is_some()
        } else {
            false
        }
    }
}
```

## ğŸ“Š **ç†è®ºå…³ç³»å›¾**

```mermaid
graph TD
    A[åˆ†å¸ƒå¼ç®—æ³•] --> B[ç³»ç»Ÿæ¨¡å‹]
    A --> C[å…±è¯†ç®—æ³•]
    A --> D[ä¸€è‡´æ€§åè®®]
    A --> E[å®¹é”™ç®—æ³•]
    A --> F[åˆ†å¸ƒå¼åè°ƒ]
    
    B --> B1[å¼‚æ­¥ç³»ç»Ÿ]
    B --> B2[åŒæ­¥ç³»ç»Ÿ]
    B --> B3[æ•…éšœæ¨¡å‹]
    
    C --> C1[Paxosç®—æ³•]
    C --> C2[Raftç®—æ³•]
    C --> C3[æ‹œå åº­å®¹é”™]
    
    D --> D1[å¼ºä¸€è‡´æ€§]
    D --> D2[æœ€ç»ˆä¸€è‡´æ€§]
    D --> D3[å› æœä¸€è‡´æ€§]
    
    E --> E1[æ•…éšœæ£€æµ‹]
    E --> E2[æ•…éšœæ¢å¤]
    E --> E3[å¤åˆ¶ç®¡ç†]
    
    F --> F1[åˆ†å¸ƒå¼é”]
    F --> F2[é¢†å¯¼è€…é€‰ä¸¾]
    F --> F3[ç»„æˆå‘˜ç®¡ç†]
```

## ğŸ”— **ç›¸å…³ç†è®ºé“¾æ¥**

- [ä¸€è‡´æ€§ç†è®º](../02_ä¸€è‡´æ€§ç†è®º/01_ä¸€è‡´æ€§åŸºç¡€ç†è®º.md)
- [å®¹é”™ç†è®º](../03_å®¹é”™ç†è®º/01_å®¹é”™åŸºç¡€ç†è®º.md)
- [å¹¶å‘æ§åˆ¶ç†è®º](../04_å¹¶å‘æ§åˆ¶ç†è®º/01_å¹¶å‘æ§åˆ¶åŸºç¡€ç†è®º.md)
- [åˆ†å¸ƒå¼åè®®ç†è®º](../05_åˆ†å¸ƒå¼åè®®ç†è®º/01_åˆ†å¸ƒå¼åè®®åŸºç¡€ç†è®º.md)
- [æ§åˆ¶è®ºç†è®º](../../05_Control_Theory/01_ç»å…¸æ§åˆ¶è®º/01_ç»å…¸æ§åˆ¶è®ºåŸºç¡€ç†è®º.md)
- [ç±»å‹ç†è®º](../../04_Type_Theory/01_ç®€å•ç±»å‹ç†è®º/01_ç®€å•ç±»å‹åŸºç¡€ç†è®º.md)

## ğŸ“š **å‚è€ƒæ–‡çŒ®**

1. Lynch, N. A. (1996). Distributed algorithms. Morgan Kaufmann.
2. Lamport, L. (1998). The part-time parliament. ACM Transactions on Computer Systems, 16(2), 133-169.
3. Ongaro, D., & Ousterhout, J. (2014). In search of an understandable consensus algorithm. In USENIX Annual Technical Conference (pp. 305-319).
4. Fischer, M. J., Lynch, N. A., & Paterson, M. S. (1985). Impossibility of distributed consensus with one faulty process. Journal of the ACM, 32(2), 374-382.
5. Chandra, T. D., & Toueg, S. (1996). Unreliable failure detectors for reliable distributed systems. Journal of the ACM, 43(2), 225-267.

---

**æœ€åæ›´æ–°æ—¶é—´**: 2024-12-20  
**ç‰ˆæœ¬**: v1.0.0  
**ç»´æŠ¤è€…**: å½¢å¼ç§‘å­¦ä½“ç³»æ„å»ºå›¢é˜Ÿ
