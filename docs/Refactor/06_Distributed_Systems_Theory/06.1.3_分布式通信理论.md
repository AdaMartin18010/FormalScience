# 06.1.3 åˆ†å¸ƒå¼é€šä¿¡ç†è®º

## ğŸ“‹ æ¦‚è¿°

åˆ†å¸ƒå¼é€šä¿¡ç†è®ºç ”ç©¶åˆ†å¸ƒå¼ç³»ç»Ÿä¸­èŠ‚ç‚¹é—´çš„é€šä¿¡æœºåˆ¶ã€åè®®è®¾è®¡å’Œç½‘ç»œæ‹“æ‰‘ã€‚é€šä¿¡æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿçš„åŸºç¡€ï¼Œå†³å®šäº†ç³»ç»Ÿçš„æ€§èƒ½ã€å¯é æ€§å’Œå¯æ‰©å±•æ€§ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹åˆ†å¸ƒå¼é€šä¿¡çš„æ•°å­¦æ¡†æ¶**
2. **ç ”ç©¶é€šä¿¡åè®®è®¾è®¡åŸç†**
3. **å‘å±•ç½‘ç»œæ‹“æ‰‘åˆ†ææ–¹æ³•**
4. **æä¾›é€šä¿¡å¯é æ€§ä¿è¯**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [é€šä¿¡æ¨¡å‹](#2-é€šä¿¡æ¨¡å‹)
3. [ç½‘ç»œæ‹“æ‰‘](#3-ç½‘ç»œæ‹“æ‰‘)
4. [é€šä¿¡åè®®](#4-é€šä¿¡åè®®)
5. [æ¶ˆæ¯ä¼ é€’](#5-æ¶ˆæ¯ä¼ é€’)
6. [è·¯ç”±ç®—æ³•](#6-è·¯ç”±ç®—æ³•)
7. [å¯é æ€§ä¿è¯](#7-å¯é æ€§ä¿è¯)
8. [æ€§èƒ½åˆ†æ](#8-æ€§èƒ½åˆ†æ)
9. [ä»£ç å®ç°](#9-ä»£ç å®ç°)
10. [åº”ç”¨ç¤ºä¾‹](#10-åº”ç”¨ç¤ºä¾‹)
11. [ç›¸å…³ç†è®º](#11-ç›¸å…³ç†è®º)
12. [å‚è€ƒæ–‡çŒ®](#12-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 åˆ†å¸ƒå¼é€šä¿¡å®šä¹‰

**å®šä¹‰ 1.1.1** (åˆ†å¸ƒå¼é€šä¿¡)
åˆ†å¸ƒå¼é€šä¿¡æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿä¸­èŠ‚ç‚¹é—´é€šè¿‡æ¶ˆæ¯ä¼ é€’è¿›è¡Œä¿¡æ¯äº¤æ¢çš„è¿‡ç¨‹ã€‚

### 1.2 é€šä¿¡ç‰¹å¾

**å®šä¹‰ 1.1.2** (é€šä¿¡ç‰¹å¾)

1. **å¼‚æ­¥æ€§**: æ¶ˆæ¯ä¼ é€’æ—¶é—´ä¸ç¡®å®š
2. **ä¸å¯é æ€§**: æ¶ˆæ¯å¯èƒ½ä¸¢å¤±æˆ–é‡å¤
3. **æ— åºæ€§**: æ¶ˆæ¯å¯èƒ½ä¹±åºåˆ°è¾¾
4. **å¹¶å‘æ€§**: å¤šä¸ªæ¶ˆæ¯åŒæ—¶ä¼ è¾“

## 2. é€šä¿¡æ¨¡å‹

### 2.1 åŒæ­¥é€šä¿¡æ¨¡å‹

**å®šä¹‰ 2.1.1** (åŒæ­¥é€šä¿¡)
å‘é€æ–¹å¿…é¡»ç­‰å¾…æ¥æ”¶æ–¹ç¡®è®¤åæ‰ç»§ç»­æ‰§è¡Œã€‚

### 2.2 å¼‚æ­¥é€šä¿¡æ¨¡å‹

**å®šä¹‰ 2.1.2** (å¼‚æ­¥é€šä¿¡)
å‘é€æ–¹å‘é€æ¶ˆæ¯åç«‹å³ç»§ç»­æ‰§è¡Œï¼Œä¸ç­‰å¾…ç¡®è®¤ã€‚

### 2.3 æ¶ˆæ¯ä¼ é€’æ¥å£

```rust
pub trait CommunicationInterface {
    fn send(&self, dest: NodeId, message: Message) -> Result<(), Error>;
    fn receive(&self) -> Result<(NodeId, Message), Error>;
    fn broadcast(&self, message: Message) -> Result<(), Error>;
}
```

## 3. ç½‘ç»œæ‹“æ‰‘

### 3.1 æ‹“æ‰‘ç±»å‹

**å®šä¹‰ 3.1.1** (ç½‘ç»œæ‹“æ‰‘)

1. **å®Œå…¨å›¾**: æ‰€æœ‰èŠ‚ç‚¹ç›´æ¥ç›¸è¿
2. **ç¯æ‹“æ‰‘**: èŠ‚ç‚¹æ„æˆç¯çŠ¶ç»“æ„
3. **æ ‘æ‹“æ‰‘**: èŠ‚ç‚¹æ„æˆæ ‘çŠ¶ç»“æ„
4. **ç½‘æ ¼æ‹“æ‰‘**: èŠ‚ç‚¹æ„æˆç½‘æ ¼ç»“æ„
5. **éšæœºæ‹“æ‰‘**: èŠ‚ç‚¹éšæœºè¿æ¥

### 3.2 æ‹“æ‰‘åˆ†æ

**å®šç† 3.1.1** (è¿é€šæ€§)
ç½‘ç»œæ˜¯è¿é€šçš„å½“ä¸”ä»…å½“ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹é—´å­˜åœ¨è·¯å¾„ã€‚

**å®šç† 3.1.2** (ç›´å¾„)
ç½‘ç»œç›´å¾„æ˜¯ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹é—´æœ€çŸ­è·¯å¾„çš„æœ€å¤§é•¿åº¦ã€‚

## 4. é€šä¿¡åè®®

### 4.1 å¯é ä¼ è¾“åè®®

**ç®—æ³• 4.1.1** (åœæ­¢ç­‰å¾…åè®®)

```rust
fn stop_and_wait_send(dest: NodeId, message: Message) -> Result<(), Error> {
    let seq_num = get_next_sequence_number();
    let packet = Packet { seq_num, message };
    
    loop {
        send(dest, packet.clone())?;
        if wait_for_ack(dest, seq_num, timeout)? {
            break;
        }
    }
    Ok(())
}
```

### 4.2 æ»‘åŠ¨çª—å£åè®®

**ç®—æ³• 4.1.2** (æ»‘åŠ¨çª—å£)

```rust
struct SlidingWindow {
    window_size: usize,
    base: u32,
    next_seq: u32,
    unacked: Vec<Packet>,
}

impl SlidingWindow {
    fn send(&mut self, dest: NodeId, message: Message) -> Result<(), Error> {
        if self.next_seq < self.base + self.window_size as u32 {
            let packet = Packet { seq_num: self.next_seq, message };
            send(dest, packet.clone())?;
            self.unacked.push(packet);
            self.next_seq += 1;
        }
        Ok(())
    }
    
    fn receive_ack(&mut self, ack_num: u32) {
        while !self.unacked.is_empty() && self.unacked[0].seq_num <= ack_num {
            self.unacked.remove(0);
            self.base += 1;
        }
    }
}
```

## 5. æ¶ˆæ¯ä¼ é€’

### 5.1 æ¶ˆæ¯ç±»å‹

**å®šä¹‰ 5.1.1** (æ¶ˆæ¯ç±»å‹)

1. **æ•°æ®æ¶ˆæ¯**: æºå¸¦åº”ç”¨æ•°æ®
2. **æ§åˆ¶æ¶ˆæ¯**: ç”¨äºåè®®æ§åˆ¶
3. **å¿ƒè·³æ¶ˆæ¯**: ç”¨äºæ•…éšœæ£€æµ‹
4. **åŒæ­¥æ¶ˆæ¯**: ç”¨äºåŒæ­¥æ“ä½œ

### 5.2 æ¶ˆæ¯æ ¼å¼

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message {
    pub header: MessageHeader,
    pub payload: MessagePayload,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessageHeader {
    pub source: NodeId,
    pub destination: NodeId,
    pub message_type: MessageType,
    pub sequence_number: u64,
    pub timestamp: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MessagePayload {
    Data(Vec<u8>),
    Control(ControlMessage),
    Heartbeat,
    Sync(SyncMessage),
}
```

## 6. è·¯ç”±ç®—æ³•

### 6.1 æœ€çŸ­è·¯å¾„è·¯ç”±

**ç®—æ³• 6.1.1** (Dijkstraç®—æ³•)

```rust
fn dijkstra_shortest_path(graph: &Graph, source: NodeId) -> HashMap<NodeId, (f64, Vec<NodeId>)> {
    let mut distances = HashMap::new();
    let mut previous = HashMap::new();
    let mut unvisited = HashSet::new();
    
    for node in graph.nodes() {
        distances.insert(node, f64::INFINITY);
        unvisited.insert(node);
    }
    distances.insert(source, 0.0);
    
    while !unvisited.is_empty() {
        let current = unvisited.iter()
            .min_by(|a, b| distances[a].partial_cmp(&distances[b]).unwrap())
            .unwrap()
            .clone();
        unvisited.remove(&current);
        
        for neighbor in graph.neighbors(current) {
            if unvisited.contains(&neighbor) {
                let distance = distances[&current] + graph.edge_weight(current, neighbor);
                if distance < distances[&neighbor] {
                    distances.insert(neighbor, distance);
                    previous.insert(neighbor, current);
                }
            }
        }
    }
    
    // æ„å»ºè·¯å¾„
    let mut paths = HashMap::new();
    for node in graph.nodes() {
        let mut path = Vec::new();
        let mut current = node;
        while current != source {
            path.push(current);
            current = previous[&current];
        }
        path.push(source);
        path.reverse();
        paths.insert(node, (distances[&node], path));
    }
    
    paths
}
```

### 6.2 å¹¿æ’­è·¯ç”±

**ç®—æ³• 6.1.2** (æ³›æ´ªç®—æ³•)

```rust
fn flood_broadcast(source: NodeId, message: Message, visited: &mut HashSet<NodeId>) {
    if visited.contains(&source) {
        return;
    }
    visited.insert(source);
    
    for neighbor in get_neighbors(source) {
        send(neighbor, message.clone());
        flood_broadcast(neighbor, message.clone(), visited);
    }
}
```

## 7. å¯é æ€§ä¿è¯

### 7.1 é”™è¯¯æ£€æµ‹

**ç®—æ³• 7.1.1** (æ ¡éªŒå’Œ)

```rust
fn calculate_checksum(data: &[u8]) -> u32 {
    data.iter().fold(0u32, |acc, &byte| acc.wrapping_add(byte as u32))
}

fn verify_checksum(data: &[u8], checksum: u32) -> bool {
    calculate_checksum(data) == checksum
}
```

### 7.2 é‡ä¼ æœºåˆ¶

**ç®—æ³• 7.1.2** (æŒ‡æ•°é€€é¿)

```rust
fn exponential_backoff(attempt: u32, base_delay: Duration) -> Duration {
    let delay = base_delay * 2u32.pow(attempt);
    let jitter = rand::thread_rng().gen_range(0..delay.as_millis() as u32);
    Duration::from_millis(delay.as_millis() as u64 + jitter as u64)
}
```

## 8. æ€§èƒ½åˆ†æ

### 8.1 å»¶è¿Ÿåˆ†æ

**å®šä¹‰ 8.1.1** (é€šä¿¡å»¶è¿Ÿ)
é€šä¿¡å»¶è¿ŸåŒ…æ‹¬ï¼š

1. **ä¼ æ’­å»¶è¿Ÿ**: ä¿¡å·åœ¨ä»‹è´¨ä¸­ä¼ æ’­çš„æ—¶é—´
2. **ä¼ è¾“å»¶è¿Ÿ**: æ•°æ®åŒ…ä¼ è¾“çš„æ—¶é—´
3. **å¤„ç†å»¶è¿Ÿ**: èŠ‚ç‚¹å¤„ç†æ•°æ®åŒ…çš„æ—¶é—´
4. **æ’é˜Ÿå»¶è¿Ÿ**: æ•°æ®åŒ…åœ¨é˜Ÿåˆ—ä¸­ç­‰å¾…çš„æ—¶é—´

### 8.2 ååé‡åˆ†æ

**å®šä¹‰ 8.1.2** (ç½‘ç»œååé‡)
ç½‘ç»œååé‡æ˜¯å•ä½æ—¶é—´å†…æˆåŠŸä¼ è¾“çš„æ•°æ®é‡ã€‚

## 9. ä»£ç å®ç°

### 9.1 é€šä¿¡ç®¡ç†å™¨

```rust
pub struct CommunicationManager {
    pub node_id: NodeId,
    pub neighbors: Vec<NodeId>,
    pub message_queue: VecDeque<(NodeId, Message)>,
    pub reliability: ReliabilityLevel,
}

impl CommunicationManager {
    pub fn new(node_id: NodeId, neighbors: Vec<NodeId>) -> Self {
        Self {
            node_id,
            neighbors,
            message_queue: VecDeque::new(),
            reliability: ReliabilityLevel::Reliable,
        }
    }
    
    pub fn send(&mut self, dest: NodeId, message: Message) -> Result<(), Error> {
        match self.reliability {
            ReliabilityLevel::Unreliable => self.unreliable_send(dest, message),
            ReliabilityLevel::Reliable => self.reliable_send(dest, message),
            ReliabilityLevel::Ordered => self.ordered_send(dest, message),
        }
    }
    
    fn reliable_send(&mut self, dest: NodeId, message: Message) -> Result<(), Error> {
        let seq_num = self.get_next_sequence_number();
        let packet = Packet { seq_num, message };
        
        let mut attempts = 0;
        loop {
            self.send_packet(dest, packet.clone())?;
            
            if self.wait_for_ack(dest, seq_num, Duration::from_millis(100))? {
                break;
            }
            
            attempts += 1;
            if attempts > 3 {
                return Err(Error::Timeout);
            }
            
            tokio::time::sleep(exponential_backoff(attempts, Duration::from_millis(10))).await;
        }
        Ok(())
    }
    
    pub fn broadcast(&mut self, message: Message) -> Result<(), Error> {
        for &neighbor in &self.neighbors {
            self.send(neighbor, message.clone())?;
        }
        Ok(())
    }
    
    pub fn receive(&mut self) -> Option<(NodeId, Message)> {
        self.message_queue.pop_front()
    }
}
```

### 9.2 ç½‘ç»œæ¨¡æ‹Ÿå™¨

```rust
pub struct NetworkSimulator {
    pub nodes: HashMap<NodeId, CommunicationManager>,
    pub topology: NetworkTopology,
    pub delay_model: DelayModel,
    pub loss_model: LossModel,
}

impl NetworkSimulator {
    pub fn new(topology: NetworkTopology) -> Self {
        Self {
            nodes: HashMap::new(),
            topology,
            delay_model: DelayModel::Constant(Duration::from_millis(10)),
            loss_model: LossModel::Bernoulli(0.01),
        }
    }
    
    pub fn add_node(&mut self, node_id: NodeId, neighbors: Vec<NodeId>) {
        self.nodes.insert(node_id, CommunicationManager::new(node_id, neighbors));
    }
    
    pub fn send_message(&mut self, from: NodeId, to: NodeId, message: Message) -> Result<(), Error> {
        // æ£€æŸ¥ç½‘ç»œè¿æ¥
        if !self.topology.is_connected(from, to) {
            return Err(Error::NoRoute);
        }
        
        // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
        let delay = self.delay_model.get_delay(from, to);
        
        // æ¨¡æ‹Ÿç½‘ç»œä¸¢åŒ…
        if self.loss_model.should_drop() {
            return Err(Error::PacketLoss);
        }
        
        // ä¼ é€’æ¶ˆæ¯
        if let Some(dest_manager) = self.nodes.get_mut(&to) {
            dest_manager.message_queue.push_back((from, message));
        }
        
        Ok(())
    }
}
```

## 10. åº”ç”¨ç¤ºä¾‹

### 10.1 å¯é é€šä¿¡ç¤ºä¾‹

```rust
async fn reliable_communication_example() {
    let mut network = NetworkSimulator::new(NetworkTopology::Ring(5));
    
    // æ·»åŠ èŠ‚ç‚¹
    for i in 0..5 {
        let neighbors = vec![(i + 1) % 5, (i + 4) % 5];
        network.add_node(i, neighbors);
    }
    
    // å‘é€å¯é æ¶ˆæ¯
    let message = Message::new_data(b"Hello, distributed world!".to_vec());
    network.send_message(0, 2, message).await.unwrap();
    
    println!("å¯é æ¶ˆæ¯å‘é€æˆåŠŸ");
}
```

### 10.2 å¹¿æ’­é€šä¿¡ç¤ºä¾‹

```rust
async fn broadcast_communication_example() {
    let mut network = NetworkSimulator::new(NetworkTopology::Complete(4));
    
    // æ·»åŠ èŠ‚ç‚¹
    for i in 0..4 {
        let neighbors = (0..4).filter(|&j| j != i).collect();
        network.add_node(i, neighbors);
    }
    
    // å¹¿æ’­æ¶ˆæ¯
    let message = Message::new_control(ControlMessage::Sync);
    network.broadcast_message(0, message).await.unwrap();
    
    println!("å¹¿æ’­æ¶ˆæ¯å‘é€æˆåŠŸ");
}
```

## 11. ç›¸å…³ç†è®º

### 11.1 åˆ†å¸ƒå¼ç³»ç»Ÿç†è®º

- [06.1.1 åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€](06.1.1_åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€.md)
- [06.1.2 åˆ†å¸ƒå¼ç®—æ³•åŸºç¡€](06.1.2_åˆ†å¸ƒå¼ç®—æ³•åŸºç¡€.md)
- [06.1.4 åˆ†å¸ƒå¼åŒæ­¥ç†è®º](06.1.4_åˆ†å¸ƒå¼åŒæ­¥ç†è®º.md)

### 11.2 ç½‘ç»œç†è®º

- [02.11.4 å›¾è®ºåŸºç¡€](../02_Mathematical_Foundation/02.11.4_å›¾è®ºåŸºç¡€.md)
- [03.7.3 åè®®è®¾è®¡](../03_Formal_Language_Theory/03.7.3_åè®®è®¾è®¡.md)

### 11.3 å¹¶å‘ç†è®º

- [11.1.1 Petriç½‘ç†è®º](../11_Concurrency_Theory/11.1.1_Petriç½‘ç†è®º.md)
- [11.2.1 è¿›ç¨‹ä»£æ•°](../11_Concurrency_Theory/11.2.1_è¿›ç¨‹ä»£æ•°.md)

## 12. å‚è€ƒæ–‡çŒ®

1. **Tanenbaum, A. S., & van Steen, M.** (2007). *Distributed Systems: Principles and Paradigms*. Prentice Hall.
2. **Coulouris, G., Dollimore, J., Kindberg, T., & Blair, G.** (2011). *Distributed Systems: Concepts and Design*. Addison-Wesley.
3. **Birman, K. P.** (2012). *Guide to Reliable Distributed Systems: Building High-Assurance Applications and Cloud-Hosted Services*. Springer.
4. **Lamport, L.** (1978). *Time, Clocks, and the Ordering of Events in a Distributed System*. Communications of the ACM.
5. **Chandy, K. M., & Lamport, L.** (1985). *Distributed Snapshots: Determining Global States of Distributed Systems*. ACM Transactions on Computer Systems.

---

**å…³é”®è¯**: åˆ†å¸ƒå¼é€šä¿¡ã€é€šä¿¡åè®®ã€ç½‘ç»œæ‹“æ‰‘ã€æ¶ˆæ¯ä¼ é€’ã€è·¯ç”±ç®—æ³•ã€å¯é æ€§ä¿è¯

**ç›¸å…³æ–‡æ¡£**:

- [06.1.1 åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€](06.1.1_åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€.md)
- [06.1.2 åˆ†å¸ƒå¼ç®—æ³•åŸºç¡€](06.1.2_åˆ†å¸ƒå¼ç®—æ³•åŸºç¡€.md)
- [06.1.4 åˆ†å¸ƒå¼åŒæ­¥ç†è®º](06.1.4_åˆ†å¸ƒå¼åŒæ­¥ç†è®º.md)
