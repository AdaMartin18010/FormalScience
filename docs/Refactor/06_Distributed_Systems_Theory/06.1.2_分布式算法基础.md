# 06.1.2 åˆ†å¸ƒå¼ç®—æ³•åŸºç¡€

## ğŸ“‹ æ¦‚è¿°

åˆ†å¸ƒå¼ç®—æ³•åŸºç¡€æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿç†è®ºçš„æ ¸å¿ƒï¼Œç ”ç©¶åœ¨å¤šä¸ªè®¡ç®—èŠ‚ç‚¹ä¸ŠååŒå·¥ä½œçš„ç®—æ³•è®¾è®¡åŸç†å’Œæ–¹æ³•ã€‚åˆ†å¸ƒå¼ç®—æ³•éœ€è¦å¤„ç†èŠ‚ç‚¹é—´çš„é€šä¿¡ã€åŒæ­¥ã€æ•…éšœæ¢å¤ç­‰æŒ‘æˆ˜ï¼Œä¸ºæ„å»ºå¯é çš„åˆ†å¸ƒå¼ç³»ç»Ÿæä¾›ç†è®ºåŸºç¡€ã€‚

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **å»ºç«‹åˆ†å¸ƒå¼ç®—æ³•çš„æ•°å­¦æ¡†æ¶**
2. **ç ”ç©¶åˆ†å¸ƒå¼ç®—æ³•çš„è®¾è®¡åŸåˆ™**
3. **å‘å±•åˆ†å¸ƒå¼ç®—æ³•çš„åˆ†ææ–¹æ³•**
4. **æä¾›åˆ†å¸ƒå¼ç®—æ³•çš„å®ç°æŠ€æœ¯**

## ğŸ“š ç›®å½•

1. [åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
2. [åˆ†å¸ƒå¼ç³»ç»Ÿæ¨¡å‹](#2-åˆ†å¸ƒå¼ç³»ç»Ÿæ¨¡å‹)
3. [ç®—æ³•åˆ†ç±»](#3-ç®—æ³•åˆ†ç±»)
4. [é€šä¿¡æ¨¡å‹](#4-é€šä¿¡æ¨¡å‹)
5. [åŒæ­¥æœºåˆ¶](#5-åŒæ­¥æœºåˆ¶)
6. [æ•…éšœå¤„ç†](#6-æ•…éšœå¤„ç†)
7. [å¤æ‚åº¦åˆ†æ](#7-å¤æ‚åº¦åˆ†æ)
8. [ç®—æ³•è®¾è®¡æ¨¡å¼](#8-ç®—æ³•è®¾è®¡æ¨¡å¼)
9. [ä»£ç å®ç°](#9-ä»£ç å®ç°)
10. [åº”ç”¨ç¤ºä¾‹](#10-åº”ç”¨ç¤ºä¾‹)
11. [ç›¸å…³ç†è®º](#11-ç›¸å…³ç†è®º)
12. [å‚è€ƒæ–‡çŒ®](#12-å‚è€ƒæ–‡çŒ®)

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 åˆ†å¸ƒå¼ç®—æ³•å®šä¹‰

**å®šä¹‰ 1.1.1** (åˆ†å¸ƒå¼ç®—æ³•)
åˆ†å¸ƒå¼ç®—æ³•æ˜¯åœ¨å¤šä¸ªè®¡ç®—èŠ‚ç‚¹ä¸Šæ‰§è¡Œçš„ç®—æ³•ï¼ŒèŠ‚ç‚¹é—´é€šè¿‡æ¶ˆæ¯ä¼ é€’è¿›è¡Œé€šä¿¡å’Œåè°ƒï¼Œå…±åŒå®Œæˆè®¡ç®—ä»»åŠ¡ã€‚

### 1.2 åˆ†å¸ƒå¼ç³»ç»Ÿç‰¹å¾

**å®šä¹‰ 1.1.2** (åˆ†å¸ƒå¼ç³»ç»Ÿç‰¹å¾)
1. **å¹¶å‘æ€§**: å¤šä¸ªèŠ‚ç‚¹åŒæ—¶æ‰§è¡Œ
2. **å¼‚æ­¥æ€§**: èŠ‚ç‚¹é—´æ²¡æœ‰å…¨å±€æ—¶é’Ÿ
3. **å±€éƒ¨æ€§**: èŠ‚ç‚¹åªèƒ½è®¿é—®å±€éƒ¨ä¿¡æ¯
4. **æ•…éšœæ€§**: èŠ‚ç‚¹å¯èƒ½å‘ç”Ÿæ•…éšœ
5. **ä¸ç¡®å®šæ€§**: æ¶ˆæ¯ä¼ é€’å»¶è¿Ÿä¸ç¡®å®š

### 1.3 ç®—æ³•æ­£ç¡®æ€§

**å®šä¹‰ 1.1.3** (ç®—æ³•æ­£ç¡®æ€§)
åˆ†å¸ƒå¼ç®—æ³•çš„æ­£ç¡®æ€§åŒ…æ‹¬ï¼š
1. **å®‰å…¨æ€§**: ç®—æ³•ä¸ä¼šäº§ç”Ÿé”™è¯¯ç»“æœ
2. **æ´»æ€§**: ç®—æ³•æœ€ç»ˆä¼šå®Œæˆé¢„æœŸä»»åŠ¡
3. **å…¬å¹³æ€§**: æ‰€æœ‰èŠ‚ç‚¹éƒ½æœ‰æœºä¼šå‚ä¸

## 2. åˆ†å¸ƒå¼ç³»ç»Ÿæ¨¡å‹

### 2.1 ç³»ç»Ÿæ¨¡å‹

**å®šä¹‰ 2.1.1** (åˆ†å¸ƒå¼ç³»ç»Ÿæ¨¡å‹)
åˆ†å¸ƒå¼ç³»ç»Ÿå¯ä»¥å»ºæ¨¡ä¸ºå›¾ $G = (V, E)$ï¼Œå…¶ä¸­ï¼š
- $V$ æ˜¯èŠ‚ç‚¹é›†åˆ
- $E$ æ˜¯é€šä¿¡é“¾è·¯é›†åˆ
- æ¯ä¸ªèŠ‚ç‚¹ $v \in V$ æœ‰å±€éƒ¨çŠ¶æ€ $s_v$
- æ¯æ¡è¾¹ $(u, v) \in E$ è¡¨ç¤ºèŠ‚ç‚¹é—´çš„é€šä¿¡èƒ½åŠ›

### 2.2 è®¡ç®—æ¨¡å‹

**å®šä¹‰ 2.1.2** (è®¡ç®—æ¨¡å‹)
åˆ†å¸ƒå¼è®¡ç®—æ¨¡å‹åŒ…æ‹¬ï¼š
1. **æ¶ˆæ¯ä¼ é€’æ¨¡å‹**: èŠ‚ç‚¹é€šè¿‡æ¶ˆæ¯é€šä¿¡
2. **å…±äº«å†…å­˜æ¨¡å‹**: èŠ‚ç‚¹é€šè¿‡å…±äº«å˜é‡é€šä¿¡
3. **ç§»åŠ¨ä»£ç†æ¨¡å‹**: è®¡ç®—å®ä½“åœ¨ç½‘ç»œä¸­ç§»åŠ¨

### 2.3 æ—¶é—´æ¨¡å‹

**å®šä¹‰ 2.1.3** (æ—¶é—´æ¨¡å‹)
1. **åŒæ­¥æ¨¡å‹**: æ‰€æœ‰èŠ‚ç‚¹æœ‰å…¨å±€æ—¶é’Ÿ
2. **å¼‚æ­¥æ¨¡å‹**: èŠ‚ç‚¹é—´æ²¡æœ‰æ—¶é’ŸåŒæ­¥
3. **éƒ¨åˆ†åŒæ­¥æ¨¡å‹**: æ—¶é’ŸåŒæ­¥æœ‰ç•Œä½†ä¸ç²¾ç¡®

## 3. ç®—æ³•åˆ†ç±»

### 3.1 æŒ‰åŠŸèƒ½åˆ†ç±»

**å®šä¹‰ 3.1.1** (åŠŸèƒ½åˆ†ç±»)
1. **åè°ƒç®—æ³•**: èŠ‚ç‚¹é—´åè°ƒå’ŒåŒæ­¥
2. **è·¯ç”±ç®—æ³•**: æ¶ˆæ¯è·¯ç”±å’Œè½¬å‘
3. **å…±è¯†ç®—æ³•**: è¾¾æˆä¸€è‡´æ„è§
4. **èµ„æºåˆ†é…ç®—æ³•**: åˆ†é…å…±äº«èµ„æº
5. **æ•…éšœæ£€æµ‹ç®—æ³•**: æ£€æµ‹èŠ‚ç‚¹æ•…éšœ

### 3.2 æŒ‰æ‹“æ‰‘åˆ†ç±»

**å®šä¹‰ 3.1.2** (æ‹“æ‰‘åˆ†ç±»)
1. **ç¯ç®—æ³•**: èŠ‚ç‚¹æ„æˆç¯çŠ¶æ‹“æ‰‘
2. **æ ‘ç®—æ³•**: èŠ‚ç‚¹æ„æˆæ ‘çŠ¶æ‹“æ‰‘
3. **ç½‘æ ¼ç®—æ³•**: èŠ‚ç‚¹æ„æˆç½‘æ ¼æ‹“æ‰‘
4. **éšæœºå›¾ç®—æ³•**: èŠ‚ç‚¹æ„æˆéšæœºå›¾

### 3.3 æŒ‰å¤æ‚åº¦åˆ†ç±»

**å®šä¹‰ 3.1.3** (å¤æ‚åº¦åˆ†ç±»)
1. **å¸¸æ•°æ—¶é—´ç®—æ³•**: $O(1)$ æ—¶é—´å¤æ‚åº¦
2. **å¯¹æ•°æ—¶é—´ç®—æ³•**: $O(\log n)$ æ—¶é—´å¤æ‚åº¦
3. **çº¿æ€§æ—¶é—´ç®—æ³•**: $O(n)$ æ—¶é—´å¤æ‚åº¦
4. **å¤šé¡¹å¼æ—¶é—´ç®—æ³•**: $O(n^k)$ æ—¶é—´å¤æ‚åº¦

## 4. é€šä¿¡æ¨¡å‹

### 4.1 æ¶ˆæ¯ä¼ é€’æ¨¡å‹

**å®šä¹‰ 4.1.1** (æ¶ˆæ¯ä¼ é€’)
æ¶ˆæ¯ä¼ é€’æ¨¡å‹åŒ…æ‹¬ï¼š
1. **å‘é€æ“ä½œ**: `send(dest, message)`
2. **æ¥æ”¶æ“ä½œ**: `receive(source, message)`
3. **å¹¿æ’­æ“ä½œ**: `broadcast(message)`

**ç®—æ³• 4.1.1** (å¯é æ¶ˆæ¯ä¼ é€’)
```rust
// å¯é æ¶ˆæ¯ä¼ é€’ç®—æ³•
fn reliable_send(dest: NodeId, message: Message) {
    let seq_num = get_next_sequence_number();
    let packet = Packet { seq_num, message };
    
    loop {
        send(dest, packet);
        if wait_for_ack(dest, seq_num, timeout) {
            break;
        }
    }
}
```

### 4.2 é€šä¿¡åŸè¯­

**å®šä¹‰ 4.1.2** (é€šä¿¡åŸè¯­)
1. **ç‚¹å¯¹ç‚¹é€šä¿¡**: ä¸¤ä¸ªèŠ‚ç‚¹é—´çš„ç›´æ¥é€šä¿¡
2. **ç»„é€šä¿¡**: ä¸€ç»„èŠ‚ç‚¹é—´çš„é€šä¿¡
3. **å¹¿æ’­é€šä¿¡**: ä¸€ä¸ªèŠ‚ç‚¹å‘æ‰€æœ‰èŠ‚ç‚¹å‘é€æ¶ˆæ¯
4. **å¤šæ’­é€šä¿¡**: ä¸€ä¸ªèŠ‚ç‚¹å‘éƒ¨åˆ†èŠ‚ç‚¹å‘é€æ¶ˆæ¯

### 4.3 é€šä¿¡å¯é æ€§

**å®šä¹‰ 4.1.3** (é€šä¿¡å¯é æ€§)
1. **å¯é é€šä¿¡**: æ¶ˆæ¯ä¸ä¸¢å¤±ã€ä¸é‡å¤ã€æœ‰åº
2. **å°½åŠ›è€Œä¸ºé€šä¿¡**: æ¶ˆæ¯å¯èƒ½ä¸¢å¤±æˆ–é‡å¤
3. **å› æœé€šä¿¡**: ä¿æŒå› æœå…³ç³»çš„æ¶ˆæ¯ä¼ é€’

## 5. åŒæ­¥æœºåˆ¶

### 5.1 æ—¶é’ŸåŒæ­¥

**ç®—æ³• 5.1.1** (Cristianç®—æ³•)
Cristianæ—¶é’ŸåŒæ­¥ç®—æ³•ï¼š
```rust
fn cristian_sync() -> TimeOffset {
    let t0 = local_time();
    send(server, "time_request");
    let t1 = receive(server, "time_response");
    let t2 = local_time();
    
    let round_trip_time = t2 - t0;
    let server_time = t1 + round_trip_time / 2;
    let offset = server_time - t2;
    
    offset
}
```

### 5.2 é€»è¾‘æ—¶é’Ÿ

**å®šä¹‰ 5.1.1** (Lamporté€»è¾‘æ—¶é’Ÿ)
Lamporté€»è¾‘æ—¶é’Ÿç®—æ³•ï¼š
```rust
struct LogicalClock {
    counter: u64,
}

impl LogicalClock {
    fn new() -> Self {
        Self { counter: 0 }
    }
    
    fn tick(&mut self) {
        self.counter += 1;
    }
    
    fn send_message(&mut self, message: Message) {
        self.tick();
        message.timestamp = self.counter;
        send(dest, message);
    }
    
    fn receive_message(&mut self, message: Message) {
        self.counter = max(self.counter, message.timestamp) + 1;
    }
}
```

### 5.3 å‘é‡æ—¶é’Ÿ

**å®šä¹‰ 5.1.2** (å‘é‡æ—¶é’Ÿ)
å‘é‡æ—¶é’Ÿç®—æ³•ï¼š
```rust
struct VectorClock {
    timestamps: Vec<u64>,
    node_id: usize,
}

impl VectorClock {
    fn new(n_nodes: usize, node_id: usize) -> Self {
        let mut timestamps = vec![0; n_nodes];
        timestamps[node_id] = 1;
        Self { timestamps, node_id }
    }
    
    fn tick(&mut self) {
        self.timestamps[self.node_id] += 1;
    }
    
    fn send_message(&mut self, message: Message) {
        self.tick();
        message.timestamps = self.timestamps.clone();
        send(dest, message);
    }
    
    fn receive_message(&mut self, message: Message) {
        for i in 0..self.timestamps.len() {
            self.timestamps[i] = max(self.timestamps[i], message.timestamps[i]);
        }
        self.timestamps[self.node_id] += 1;
    }
    
    fn happens_before(&self, other: &VectorClock) -> bool {
        for i in 0..self.timestamps.len() {
            if self.timestamps[i] > other.timestamps[i] {
                return false;
            }
        }
        self.timestamps.iter().sum::<u64>() < other.timestamps.iter().sum::<u64>()
    }
}
```

## 6. æ•…éšœå¤„ç†

### 6.1 æ•…éšœæ¨¡å‹

**å®šä¹‰ 6.1.1** (æ•…éšœæ¨¡å‹)
1. **å´©æºƒæ•…éšœ**: èŠ‚ç‚¹åœæ­¢å·¥ä½œ
2. **æ‹œå åº­æ•…éšœ**: èŠ‚ç‚¹å¯èƒ½å‘é€é”™è¯¯æ¶ˆæ¯
3. **é—æ¼æ•…éšœ**: èŠ‚ç‚¹å¯èƒ½ä¸¢å¤±æ¶ˆæ¯
4. **æ—¶åºæ•…éšœ**: èŠ‚ç‚¹å“åº”æ—¶é—´å¼‚å¸¸

### 6.2 æ•…éšœæ£€æµ‹

**ç®—æ³• 6.1.1** (å¿ƒè·³æ£€æµ‹)
å¿ƒè·³æ£€æµ‹ç®—æ³•ï¼š
```rust
struct HeartbeatDetector {
    timeouts: HashMap<NodeId, Instant>,
    timeout_duration: Duration,
}

impl HeartbeatDetector {
    fn new(timeout_duration: Duration) -> Self {
        Self {
            timeouts: HashMap::new(),
            timeout_duration,
        }
    }
    
    fn start_monitoring(&mut self, node_id: NodeId) {
        self.timeouts.insert(node_id, Instant::now() + self.timeout_duration);
    }
    
    fn receive_heartbeat(&mut self, node_id: NodeId) {
        self.timeouts.insert(node_id, Instant::now() + self.timeout_duration);
    }
    
    fn check_failures(&self) -> Vec<NodeId> {
        let now = Instant::now();
        self.timeouts.iter()
            .filter(|(_, &timeout)| now > timeout)
            .map(|(&node_id, _)| node_id)
            .collect()
    }
}
```

### 6.3 æ•…éšœæ¢å¤

**ç®—æ³• 6.1.2** (æ•…éšœæ¢å¤)
æ•…éšœæ¢å¤ç®—æ³•ï¼š
```rust
struct FaultRecovery {
    checkpoint_interval: Duration,
    checkpoints: HashMap<NodeId, Checkpoint>,
}

impl FaultRecovery {
    fn new(checkpoint_interval: Duration) -> Self {
        Self {
            checkpoint_interval,
            checkpoints: HashMap::new(),
        }
    }
    
    fn create_checkpoint(&mut self, node_id: NodeId, state: State) {
        let checkpoint = Checkpoint {
            timestamp: Instant::now(),
            state,
        };
        self.checkpoints.insert(node_id, checkpoint);
    }
    
    fn recover_from_failure(&self, node_id: NodeId) -> Option<State> {
        self.checkpoints.get(&node_id).map(|cp| cp.state.clone())
    }
}
```

## 7. å¤æ‚åº¦åˆ†æ

### 7.1 æ—¶é—´å¤æ‚åº¦

**å®šä¹‰ 7.1.1** (æ—¶é—´å¤æ‚åº¦)
åˆ†å¸ƒå¼ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦é€šå¸¸è€ƒè™‘ï¼š
1. **æ¶ˆæ¯è½®æ•°**: ç®—æ³•éœ€è¦çš„æ¶ˆæ¯ä¼ é€’è½®æ•°
2. **æœ¬åœ°è®¡ç®—æ—¶é—´**: æ¯ä¸ªèŠ‚ç‚¹çš„è®¡ç®—æ—¶é—´
3. **é€šä¿¡å»¶è¿Ÿ**: æ¶ˆæ¯ä¼ é€’çš„å»¶è¿Ÿæ—¶é—´

### 7.2 ç©ºé—´å¤æ‚åº¦

**å®šä¹‰ 7.1.2** (ç©ºé—´å¤æ‚åº¦)
åˆ†å¸ƒå¼ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦åŒ…æ‹¬ï¼š
1. **æœ¬åœ°å­˜å‚¨**: æ¯ä¸ªèŠ‚ç‚¹çš„å­˜å‚¨éœ€æ±‚
2. **æ¶ˆæ¯å¤§å°**: æ¶ˆæ¯çš„æ•°æ®é‡
3. **å…¨å±€å­˜å‚¨**: æ•´ä¸ªç³»ç»Ÿçš„æ€»å­˜å‚¨éœ€æ±‚

### 7.3 é€šä¿¡å¤æ‚åº¦

**å®šä¹‰ 7.1.3** (é€šä¿¡å¤æ‚åº¦)
é€šä¿¡å¤æ‚åº¦è¡¡é‡ï¼š
1. **æ¶ˆæ¯æ•°é‡**: ç®—æ³•å‘é€çš„æ¶ˆæ¯æ€»æ•°
2. **æ¶ˆæ¯å¤§å°**: æ¯ä¸ªæ¶ˆæ¯çš„æ•°æ®é‡
3. **å¸¦å®½ä½¿ç”¨**: ç½‘ç»œå¸¦å®½çš„æ¶ˆè€—

## 8. ç®—æ³•è®¾è®¡æ¨¡å¼

### 8.1 é¢†å¯¼è€…é€‰ä¸¾

**ç®—æ³• 8.1.1** (ç¯é€‰ä¸¾ç®—æ³•)
ç¯é€‰ä¸¾ç®—æ³•ï¼š
```rust
struct RingElection {
    node_id: NodeId,
    ring_size: usize,
    leader: Option<NodeId>,
}

impl RingElection {
    fn new(node_id: NodeId, ring_size: usize) -> Self {
        Self {
            node_id,
            ring_size,
            leader: None,
        }
    }
    
    fn start_election(&mut self) {
        let election_message = ElectionMessage {
            initiator: self.node_id,
            participants: vec![self.node_id],
        };
        send((self.node_id + 1) % self.ring_size, election_message);
    }
    
    fn handle_election_message(&mut self, message: ElectionMessage) {
        if message.initiator == self.node_id {
            // é€‰ä¸¾å®Œæˆ
            let leader = message.participants.iter().max().unwrap();
            self.leader = Some(*leader);
            broadcast(LeaderMessage { leader: *leader });
        } else {
            // ç»§ç»­é€‰ä¸¾
            let mut new_message = message;
            new_message.participants.push(self.node_id);
            send((self.node_id + 1) % self.ring_size, new_message);
        }
    }
}
```

### 8.2 åˆ†å¸ƒå¼å¿«ç…§

**ç®—æ³• 8.1.2** (Chandy-Lamportå¿«ç…§ç®—æ³•)
Chandy-Lamportå¿«ç…§ç®—æ³•ï¼š
```rust
struct DistributedSnapshot {
    node_id: NodeId,
    state: State,
    marker_sent: HashSet<ChannelId>,
    marker_received: HashSet<ChannelId>,
    channel_states: HashMap<ChannelId, Vec<Message>>,
}

impl DistributedSnapshot {
    fn new(node_id: NodeId) -> Self {
        Self {
            node_id,
            state: State::new(),
            marker_sent: HashSet::new(),
            marker_received: HashSet::new(),
            channel_states: HashMap::new(),
        }
    }
    
    fn initiate_snapshot(&mut self) {
        self.state = self.get_current_state();
        for channel in self.get_outgoing_channels() {
            send_marker(channel);
            self.marker_sent.insert(channel);
        }
    }
    
    fn receive_marker(&mut self, channel: ChannelId) {
        if !self.marker_received.contains(&channel) {
            self.marker_received.insert(channel);
            self.channel_states.insert(channel, vec![]);
            
            if self.marker_received.len() == self.get_incoming_channels().len() {
                self.complete_snapshot();
            }
        }
    }
    
    fn receive_message(&mut self, channel: ChannelId, message: Message) {
        if self.marker_received.contains(&channel) {
            self.channel_states.get_mut(&channel).unwrap().push(message);
        }
        // å¤„ç†æ¶ˆæ¯
    }
}
```

### 8.3 åˆ†å¸ƒå¼äº’æ–¥

**ç®—æ³• 8.1.3** (Lamportäº’æ–¥ç®—æ³•)
Lamportäº’æ–¥ç®—æ³•ï¼š
```rust
struct LamportMutex {
    node_id: NodeId,
    clock: LogicalClock,
    request_queue: Vec<Request>,
    in_critical_section: bool,
}

impl LamportMutex {
    fn new(node_id: NodeId) -> Self {
        Self {
            node_id,
            clock: LogicalClock::new(),
            request_queue: Vec::new(),
            in_critical_section: false,
        }
    }
    
    fn request_critical_section(&mut self) {
        self.clock.tick();
        let request = Request {
            node_id: self.node_id,
            timestamp: self.clock.get_time(),
        };
        
        self.request_queue.push(request.clone());
        broadcast(RequestMessage { request });
    }
    
    fn receive_request(&mut self, request: Request) {
        self.clock.receive_message();
        self.request_queue.push(request);
        send(request.node_id, ReplyMessage { from: self.node_id });
    }
    
    fn can_enter_critical_section(&self) -> bool {
        if self.in_critical_section {
            return false;
        }
        
        let my_request = self.request_queue.iter()
            .find(|r| r.node_id == self.node_id)
            .unwrap();
        
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ›´æ—©çš„è¯·æ±‚éƒ½å·²å›å¤
        self.request_queue.iter()
            .filter(|r| r.timestamp < my_request.timestamp || 
                       (r.timestamp == my_request.timestamp && r.node_id < my_request.node_id))
            .all(|r| self.has_reply_from(r.node_id))
    }
}
```

## 9. ä»£ç å®ç°

### 9.1 åˆ†å¸ƒå¼èŠ‚ç‚¹

```rust
use std::collections::{HashMap, HashSet};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{Duration, Instant};
use tokio::sync::mpsc;
use serde::{Serialize, Deserialize};

/// èŠ‚ç‚¹IDç±»å‹
pub type NodeId = usize;

/// æ¶ˆæ¯ç±»å‹
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Message {
    Heartbeat { from: NodeId },
    Election { initiator: NodeId, participants: Vec<NodeId> },
    Leader { leader: NodeId },
    Request { node_id: NodeId, timestamp: u64 },
    Reply { from: NodeId },
    Snapshot { initiator: NodeId },
    Marker { from: NodeId, channel: ChannelId },
    Data { content: String },
}

/// é€šé“IDç±»å‹
#[derive(Debug, Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct ChannelId {
    pub from: NodeId,
    pub to: NodeId,
}

/// åˆ†å¸ƒå¼èŠ‚ç‚¹
pub struct DistributedNode {
    pub id: NodeId,
    pub neighbors: Vec<NodeId>,
    pub state: Arc<Mutex<NodeState>>,
    pub message_sender: mpsc::Sender<(NodeId, Message)>,
    pub message_receiver: mpsc::Receiver<(NodeId, Message)>,
}

/// èŠ‚ç‚¹çŠ¶æ€
#[derive(Debug)]
pub struct NodeState {
    pub clock: LogicalClock,
    pub leader: Option<NodeId>,
    pub in_critical_section: bool,
    pub request_queue: Vec<Request>,
    pub replies_received: HashSet<NodeId>,
    pub checkpoints: HashMap<NodeId, Checkpoint>,
    pub channel_states: HashMap<ChannelId, Vec<Message>>,
}

/// é€»è¾‘æ—¶é’Ÿ
#[derive(Debug)]
pub struct LogicalClock {
    pub counter: u64,
    pub node_id: NodeId,
}

impl LogicalClock {
    pub fn new(node_id: NodeId) -> Self {
        Self { counter: 0, node_id }
    }
    
    pub fn tick(&mut self) {
        self.counter += 1;
    }
    
    pub fn get_time(&self) -> u64 {
        self.counter
    }
    
    pub fn receive_message(&mut self, timestamp: u64) {
        self.counter = std::cmp::max(self.counter, timestamp) + 1;
    }
}

/// è¯·æ±‚ç»“æ„
#[derive(Debug, Clone)]
pub struct Request {
    pub node_id: NodeId,
    pub timestamp: u64,
}

/// æ£€æŸ¥ç‚¹ç»“æ„
#[derive(Debug, Clone)]
pub struct Checkpoint {
    pub timestamp: Instant,
    pub state: NodeState,
}

impl DistributedNode {
    /// åˆ›å»ºæ–°çš„åˆ†å¸ƒå¼èŠ‚ç‚¹
    pub fn new(id: NodeId, neighbors: Vec<NodeId>) -> (Self, mpsc::Sender<(NodeId, Message)>) {
        let (tx, rx) = mpsc::channel(100);
        let (node_tx, node_rx) = mpsc::channel(100);
        
        let node = Self {
            id,
            neighbors,
            state: Arc::new(Mutex::new(NodeState {
                clock: LogicalClock::new(id),
                leader: None,
                in_critical_section: false,
                request_queue: Vec::new(),
                replies_received: HashSet::new(),
                checkpoints: HashMap::new(),
                channel_states: HashMap::new(),
            })),
            message_sender: node_tx,
            message_receiver: node_rx,
        };
        
        (node, tx)
    }
    
    /// å¯åŠ¨èŠ‚ç‚¹
    pub async fn start(mut self) {
        println!("èŠ‚ç‚¹ {} å¯åŠ¨", self.id);
        
        // å¯åŠ¨æ¶ˆæ¯å¤„ç†å¾ªç¯
        while let Some((from, message)) = self.message_receiver.recv().await {
            self.handle_message(from, message).await;
        }
    }
    
    /// å¤„ç†æ¥æ”¶åˆ°çš„æ¶ˆæ¯
    async fn handle_message(&mut self, from: NodeId, message: Message) {
        match message {
            Message::Heartbeat { from } => {
                self.handle_heartbeat(from).await;
            }
            Message::Election { initiator, participants } => {
                self.handle_election(initiator, participants).await;
            }
            Message::Leader { leader } => {
                self.handle_leader_elected(leader).await;
            }
            Message::Request { node_id, timestamp } => {
                self.handle_mutex_request(node_id, timestamp).await;
            }
            Message::Reply { from } => {
                self.handle_mutex_reply(from).await;
            }
            Message::Snapshot { initiator } => {
                self.handle_snapshot_initiation(initiator).await;
            }
            Message::Marker { from, channel } => {
                self.handle_snapshot_marker(from, channel).await;
            }
            Message::Data { content } => {
                self.handle_data_message(content).await;
            }
        }
    }
    
    /// å¤„ç†å¿ƒè·³æ¶ˆæ¯
    async fn handle_heartbeat(&mut self, from: NodeId) {
        println!("èŠ‚ç‚¹ {} æ”¶åˆ°æ¥è‡ªèŠ‚ç‚¹ {} çš„å¿ƒè·³", self.id, from);
        // æ›´æ–°èŠ‚ç‚¹çŠ¶æ€ï¼Œæ ‡è®°èŠ‚ç‚¹ä¸ºæ´»è·ƒ
    }
    
    /// å¤„ç†é€‰ä¸¾æ¶ˆæ¯
    async fn handle_election(&mut self, initiator: NodeId, mut participants: Vec<NodeId>) {
        println!("èŠ‚ç‚¹ {} å¤„ç†é€‰ä¸¾æ¶ˆæ¯", self.id);
        
        if !participants.contains(&self.id) {
            participants.push(self.id);
        }
        
        if initiator == self.id {
            // é€‰ä¸¾å®Œæˆ
            let leader = participants.iter().max().unwrap();
            self.leader = Some(*leader);
            self.broadcast(Message::Leader { leader: *leader }).await;
        } else {
            // ç»§ç»­é€‰ä¸¾
            let next_node = (self.id + 1) % self.neighbors.len();
            self.send_message(next_node, Message::Election { initiator, participants }).await;
        }
    }
    
    /// å¤„ç†é¢†å¯¼è€…é€‰ä¸¾ç»“æœ
    async fn handle_leader_elected(&mut self, leader: NodeId) {
        println!("èŠ‚ç‚¹ {} ç¡®è®¤é¢†å¯¼è€…ä¸º {}", self.id, leader);
        self.leader = Some(leader);
    }
    
    /// å¤„ç†äº’æ–¥è¯·æ±‚
    async fn handle_mutex_request(&mut self, node_id: NodeId, timestamp: u64) {
        let mut state = self.state.lock().unwrap();
        state.clock.receive_message(timestamp);
        
        let request = Request { node_id, timestamp };
        state.request_queue.push(request);
        
        // å‘é€å›å¤
        self.send_message(node_id, Message::Reply { from: self.id }).await;
    }
    
    /// å¤„ç†äº’æ–¥å›å¤
    async fn handle_mutex_reply(&mut self, from: NodeId) {
        let mut state = self.state.lock().unwrap();
        state.replies_received.insert(from);
    }
    
    /// å¤„ç†å¿«ç…§åˆå§‹åŒ–
    async fn handle_snapshot_initiation(&mut self, initiator: NodeId) {
        println!("èŠ‚ç‚¹ {} å¼€å§‹å¿«ç…§", self.id);
        let mut state = self.state.lock().unwrap();
        
        // åˆ›å»ºæœ¬åœ°æ£€æŸ¥ç‚¹
        let checkpoint = Checkpoint {
            timestamp: Instant::now(),
            state: state.clone(),
        };
        state.checkpoints.insert(self.id, checkpoint);
        
        // å‘é€æ ‡è®°æ¶ˆæ¯
        for &neighbor in &self.neighbors {
            self.send_message(neighbor, Message::Marker { 
                from: self.id, 
                channel: ChannelId { from: self.id, to: neighbor } 
            }).await;
        }
    }
    
    /// å¤„ç†å¿«ç…§æ ‡è®°
    async fn handle_snapshot_marker(&mut self, from: NodeId, channel: ChannelId) {
        let mut state = self.state.lock().unwrap();
        
        if !state.channel_states.contains_key(&channel) {
            state.channel_states.insert(channel, Vec::new());
        }
    }
    
    /// å¤„ç†æ•°æ®æ¶ˆæ¯
    async fn handle_data_message(&mut self, content: String) {
        println!("èŠ‚ç‚¹ {} æ”¶åˆ°æ•°æ®: {}", self.id, content);
        // å¤„ç†æ•°æ®æ¶ˆæ¯
    }
    
    /// å‘é€æ¶ˆæ¯
    async fn send_message(&self, to: NodeId, message: Message) {
        if let Err(e) = self.message_sender.send((to, message)).await {
            eprintln!("å‘é€æ¶ˆæ¯å¤±è´¥: {}", e);
        }
    }
    
    /// å¹¿æ’­æ¶ˆæ¯
    async fn broadcast(&self, message: Message) {
        for &neighbor in &self.neighbors {
            self.send_message(neighbor, message.clone()).await;
        }
    }
    
    /// è¯·æ±‚è¿›å…¥ä¸´ç•ŒåŒº
    pub async fn request_critical_section(&mut self) {
        let mut state = self.state.lock().unwrap();
        state.clock.tick();
        
        let request = Request {
            node_id: self.id,
            timestamp: state.clock.get_time(),
        };
        
        state.request_queue.push(request.clone());
        state.replies_received.clear();
        
        drop(state);
        
        // å‘é€è¯·æ±‚ç»™æ‰€æœ‰é‚»å±…
        for &neighbor in &self.neighbors {
            self.send_message(neighbor, Message::Request { 
                node_id: request.node_id, 
                timestamp: request.timestamp 
            }).await;
        }
    }
    
    /// æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›å…¥ä¸´ç•ŒåŒº
    pub fn can_enter_critical_section(&self) -> bool {
        let state = self.state.lock().unwrap();
        
        if state.in_critical_section {
            return false;
        }
        
        let my_request = state.request_queue.iter()
            .find(|r| r.node_id == self.id)
            .unwrap();
        
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ›´æ—©çš„è¯·æ±‚éƒ½å·²å›å¤
        state.request_queue.iter()
            .filter(|r| r.timestamp < my_request.timestamp || 
                       (r.timestamp == my_request.timestamp && r.node_id < my_request.node_id))
            .all(|r| state.replies_received.contains(&r.node_id))
    }
    
    /// è¿›å…¥ä¸´ç•ŒåŒº
    pub fn enter_critical_section(&mut self) {
        let mut state = self.state.lock().unwrap();
        state.in_critical_section = true;
        println!("èŠ‚ç‚¹ {} è¿›å…¥ä¸´ç•ŒåŒº", self.id);
    }
    
    /// ç¦»å¼€ä¸´ç•ŒåŒº
    pub fn leave_critical_section(&mut self) {
        let mut state = self.state.lock().unwrap();
        state.in_critical_section = false;
        
        // ç§»é™¤è‡ªå·±çš„è¯·æ±‚
        state.request_queue.retain(|r| r.node_id != self.id);
        
        println!("èŠ‚ç‚¹ {} ç¦»å¼€ä¸´ç•ŒåŒº", self.id);
    }
    
    /// å¯åŠ¨é¢†å¯¼è€…é€‰ä¸¾
    pub async fn start_election(&mut self) {
        println!("èŠ‚ç‚¹ {} å¯åŠ¨é¢†å¯¼è€…é€‰ä¸¾", self.id);
        let participants = vec![self.id];
        self.send_message((self.id + 1) % self.neighbors.len(), 
                         Message::Election { initiator: self.id, participants }).await;
    }
    
    /// å‘é€å¿ƒè·³
    pub async fn send_heartbeat(&self) {
        for &neighbor in &self.neighbors {
            self.send_message(neighbor, Message::Heartbeat { from: self.id }).await;
        }
    }
    
    /// å¯åŠ¨å¿«ç…§
    pub async fn start_snapshot(&mut self) {
        println!("èŠ‚ç‚¹ {} å¯åŠ¨åˆ†å¸ƒå¼å¿«ç…§", self.id);
        self.broadcast(Message::Snapshot { initiator: self.id }).await;
    }
}
```

### 9.2 åˆ†å¸ƒå¼ç³»ç»Ÿæ¨¡æ‹Ÿå™¨

```rust
/// åˆ†å¸ƒå¼ç³»ç»Ÿæ¨¡æ‹Ÿå™¨
pub struct DistributedSystemSimulator {
    pub nodes: HashMap<NodeId, DistributedNode>,
    pub network: NetworkSimulator,
}

/// ç½‘ç»œæ¨¡æ‹Ÿå™¨
pub struct NetworkSimulator {
    pub message_queue: Vec<(NodeId, NodeId, Message, Instant)>,
    pub delay_range: (Duration, Duration),
    pub failure_rate: f64,
}

impl NetworkSimulator {
    pub fn new(delay_range: (Duration, Duration), failure_rate: f64) -> Self {
        Self {
            message_queue: Vec::new(),
            delay_range,
            failure_rate,
        }
    }
    
    pub fn send_message(&mut self, from: NodeId, to: NodeId, message: Message) {
        let mut rng = rand::thread_rng();
        
        // æ¨¡æ‹Ÿç½‘ç»œæ•…éšœ
        if rng.gen::<f64>() < self.failure_rate {
            return;
        }
        
        // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
        let delay = rng.gen_range(self.delay_range.0..self.delay_range.1);
        let delivery_time = Instant::now() + delay;
        
        self.message_queue.push((from, to, message, delivery_time));
    }
    
    pub fn deliver_messages(&mut self, nodes: &mut HashMap<NodeId, DistributedNode>) {
        let now = Instant::now();
        let mut delivered = Vec::new();
        
        for (i, (from, to, message, delivery_time)) in self.message_queue.iter().enumerate() {
            if now >= *delivery_time {
                if let Some(node) = nodes.get_mut(to) {
                    // è¿™é‡Œéœ€è¦å®é™…çš„å¼‚æ­¥å¤„ç†
                    println!("æ¶ˆæ¯ä»èŠ‚ç‚¹ {} ä¼ é€’åˆ°èŠ‚ç‚¹ {}", from, to);
                }
                delivered.push(i);
            }
        }
        
        // ç§»é™¤å·²ä¼ é€’çš„æ¶ˆæ¯
        for &index in delivered.iter().rev() {
            self.message_queue.remove(index);
        }
    }
}

impl DistributedSystemSimulator {
    pub fn new(n_node_count: usize, delay_range: (Duration, Duration), failure_rate: f64) -> Self {
        let mut nodes = HashMap::new();
        let mut network = NetworkSimulator::new(delay_range, failure_rate);
        
        for i in 0..n_node_count {
            let neighbors = (0..n_node_count).filter(|&j| j != i).collect();
            let (node, _) = DistributedNode::new(i, neighbors);
            nodes.insert(i, node);
        }
        
        Self { nodes, network }
    }
    
    pub async fn run_simulation(&mut self, duration: Duration) {
        let start_time = Instant::now();
        
        while start_time.elapsed() < duration {
            // æ¨¡æ‹Ÿç½‘ç»œæ¶ˆæ¯ä¼ é€’
            self.network.deliver_messages(&mut self.nodes);
            
            // æ¨¡æ‹ŸèŠ‚ç‚¹æ´»åŠ¨
            for node in self.nodes.values_mut() {
                // å®šæœŸå‘é€å¿ƒè·³
                if start_time.elapsed().as_secs() % 5 == 0 {
                    node.send_heartbeat().await;
                }
            }
            
            tokio::time::sleep(Duration::from_millis(100)).await;
        }
    }
    
    pub async fn run_election(&mut self) {
        println!("å¼€å§‹é¢†å¯¼è€…é€‰ä¸¾...");
        
        // æ‰€æœ‰èŠ‚ç‚¹åŒæ—¶å¯åŠ¨é€‰ä¸¾
        for node in self.nodes.values_mut() {
            node.start_election().await;
        }
        
        // ç­‰å¾…é€‰ä¸¾å®Œæˆ
        tokio::time::sleep(Duration::from_secs(2)).await;
        
        // æ£€æŸ¥é€‰ä¸¾ç»“æœ
        for (id, node) in &self.nodes {
            let state = node.state.lock().unwrap();
            if let Some(leader) = state.leader {
                println!("èŠ‚ç‚¹ {} è®¤ä¸ºé¢†å¯¼è€…æ˜¯ {}", id, leader);
            }
        }
    }
    
    pub async fn run_mutex_test(&mut self) {
        println!("å¼€å§‹äº’æ–¥æµ‹è¯•...");
        
        // å¤šä¸ªèŠ‚ç‚¹åŒæ—¶è¯·æ±‚ä¸´ç•ŒåŒº
        for node in self.nodes.values_mut() {
            node.request_critical_section().await;
        }
        
        // æ¨¡æ‹Ÿä¸´ç•ŒåŒºè®¿é—®
        for (id, node) in &mut self.nodes {
            if node.can_enter_critical_section() {
                node.enter_critical_section();
                
                // æ¨¡æ‹Ÿä¸´ç•ŒåŒºæ“ä½œ
                tokio::time::sleep(Duration::from_millis(100)).await;
                
                node.leave_critical_section();
                println!("èŠ‚ç‚¹ {} å®Œæˆä¸´ç•ŒåŒºè®¿é—®", id);
            }
        }
    }
}
```

### 9.3 æµ‹è¯•ä»£ç 

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_distributed_node_creation() {
        let neighbors = vec![1, 2, 3];
        let (node, _) = DistributedNode::new(0, neighbors);
        
        assert_eq!(node.id, 0);
        assert_eq!(node.neighbors, vec![1, 2, 3]);
    }
    
    #[tokio::test]
    async fn test_logical_clock() {
        let mut clock = LogicalClock::new(0);
        
        assert_eq!(clock.get_time(), 0);
        
        clock.tick();
        assert_eq!(clock.get_time(), 1);
        
        clock.receive_message(5);
        assert_eq!(clock.get_time(), 6);
    }
    
    #[tokio::test]
    async fn test_mutex_request() {
        let neighbors = vec![1];
        let (mut node, _) = DistributedNode::new(0, neighbors);
        
        // è¯·æ±‚ä¸´ç•ŒåŒº
        node.request_critical_section().await;
        
        // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›å…¥ä¸´ç•ŒåŒº
        assert!(!node.can_enter_critical_section());
    }
    
    #[tokio::test]
    async fn test_system_simulation() {
        let mut simulator = DistributedSystemSimulator::new(
            3,
            (Duration::from_millis(10), Duration::from_millis(50)),
            0.1
        );
        
        // è¿è¡Œé€‰ä¸¾æµ‹è¯•
        simulator.run_election().await;
        
        // è¿è¡Œäº’æ–¥æµ‹è¯•
        simulator.run_mutex_test().await;
    }
}
```

## 10. åº”ç”¨ç¤ºä¾‹

### 10.1 åˆ†å¸ƒå¼é¢†å¯¼è€…é€‰ä¸¾

```rust
/// åˆ†å¸ƒå¼é¢†å¯¼è€…é€‰ä¸¾ç¤ºä¾‹
pub async fn distributed_leader_election_example() {
    println!("åˆ†å¸ƒå¼é¢†å¯¼è€…é€‰ä¸¾ç¤ºä¾‹:");
    
    // åˆ›å»º5ä¸ªèŠ‚ç‚¹çš„åˆ†å¸ƒå¼ç³»ç»Ÿ
    let mut simulator = DistributedSystemSimulator::new(
        5,
        (Duration::from_millis(10), Duration::from_millis(100)),
        0.05
    );
    
    // å¯åŠ¨æ‰€æœ‰èŠ‚ç‚¹
    for (id, node) in &mut simulator.nodes {
        println!("å¯åŠ¨èŠ‚ç‚¹ {}", id);
    }
    
    // è¿è¡Œé¢†å¯¼è€…é€‰ä¸¾
    simulator.run_election().await;
    
    // æ£€æŸ¥é€‰ä¸¾ç»“æœ
    let mut leaders = HashSet::new();
    for (id, node) in &simulator.nodes {
        let state = node.state.lock().unwrap();
        if let Some(leader) = state.leader {
            leaders.insert(leader);
            println!("èŠ‚ç‚¹ {} é€‰ä¸¾é¢†å¯¼è€…: {}", id, leader);
        }
    }
    
    // éªŒè¯é€‰ä¸¾ä¸€è‡´æ€§
    if leaders.len() == 1 {
        println!("é€‰ä¸¾æˆåŠŸï¼Œæ‰€æœ‰èŠ‚ç‚¹è¾¾æˆä¸€è‡´");
    } else {
        println!("é€‰ä¸¾å¤±è´¥ï¼Œå­˜åœ¨åˆ†æ­§");
    }
}
```

### 10.2 åˆ†å¸ƒå¼äº’æ–¥

```rust
/// åˆ†å¸ƒå¼äº’æ–¥ç¤ºä¾‹
pub async fn distributed_mutex_example() {
    println!("åˆ†å¸ƒå¼äº’æ–¥ç¤ºä¾‹:");
    
    // åˆ›å»º3ä¸ªèŠ‚ç‚¹çš„ç³»ç»Ÿ
    let mut simulator = DistributedSystemSimulator::new(
        3,
        (Duration::from_millis(5), Duration::from_millis(20)),
        0.02
    );
    
    // æ¨¡æ‹Ÿå¤šä¸ªèŠ‚ç‚¹åŒæ—¶è¯·æ±‚ä¸´ç•ŒåŒº
    let mut tasks = Vec::new();
    
    for (id, node) in &mut simulator.nodes {
        let node_id = *id;
        let task = tokio::spawn(async move {
            println!("èŠ‚ç‚¹ {} è¯·æ±‚ä¸´ç•ŒåŒº", node_id);
            
            // è¿™é‡Œéœ€è¦å®é™…çš„å¼‚æ­¥å¤„ç†
            tokio::time::sleep(Duration::from_millis(100)).await;
            
            println!("èŠ‚ç‚¹ {} å®Œæˆæ“ä½œ", node_id);
        });
        tasks.push(task);
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    for task in tasks {
        task.await.unwrap();
    }
    
    println!("æ‰€æœ‰èŠ‚ç‚¹å®Œæˆä¸´ç•ŒåŒºè®¿é—®");
}
```

### 10.3 åˆ†å¸ƒå¼å¿«ç…§

```rust
/// åˆ†å¸ƒå¼å¿«ç…§ç¤ºä¾‹
pub async fn distributed_snapshot_example() {
    println!("åˆ†å¸ƒå¼å¿«ç…§ç¤ºä¾‹:");
    
    // åˆ›å»º4ä¸ªèŠ‚ç‚¹çš„ç³»ç»Ÿ
    let mut simulator = DistributedSystemSimulator::new(
        4,
        (Duration::from_millis(10), Duration::from_millis(50)),
        0.1
    );
    
    // å¯åŠ¨å¿«ç…§
    for (id, node) in &mut simulator.nodes {
        println!("èŠ‚ç‚¹ {} å¯åŠ¨å¿«ç…§", id);
        node.start_snapshot().await;
    }
    
    // ç­‰å¾…å¿«ç…§å®Œæˆ
    tokio::time::sleep(Duration::from_secs(1)).await;
    
    // æ£€æŸ¥å¿«ç…§ç»“æœ
    for (id, node) in &simulator.nodes {
        let state = node.state.lock().unwrap();
        if !state.checkpoints.is_empty() {
            println!("èŠ‚ç‚¹ {} å®Œæˆå¿«ç…§ï¼ŒåŒ…å« {} ä¸ªæ£€æŸ¥ç‚¹", id, state.checkpoints.len());
        }
    }
    
    println!("åˆ†å¸ƒå¼å¿«ç…§å®Œæˆ");
}
```

## 11. ç›¸å…³ç†è®º

### 11.1 åˆ†å¸ƒå¼ç³»ç»Ÿç†è®º
- [06.1.1 åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€](06.1.1_åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€.md)
- [06.2.1 å…±è¯†ç†è®º](06.2.1_å…±è¯†ç†è®º.md)
- [06.3.1 ä¸€è‡´æ€§ç†è®º](06.3.1_ä¸€è‡´æ€§ç†è®º.md)

### 11.2 ç®—æ³•ç†è®º
- [02.11.1 è®¡æ•°åŸç†](../02_Mathematical_Foundation/02.11.1_è®¡æ•°åŸç†.md)
- [02.11.2 æ’åˆ—ç»„åˆ](../02_Mathematical_Foundation/02.11.2_æ’åˆ—ç»„åˆ.md)
- [02.11.3 ç”Ÿæˆå‡½æ•°](../02_Mathematical_Foundation/02.11.3_ç”Ÿæˆå‡½æ•°.md)

### 11.3 å¹¶å‘ç†è®º
- [11.1.1 Petriç½‘ç†è®º](../11_Concurrency_Theory/11.1.1_Petriç½‘ç†è®º.md)
- [11.2.1 è¿›ç¨‹ä»£æ•°](../11_Concurrency_Theory/11.2.1_è¿›ç¨‹ä»£æ•°.md)

### 11.4 å½¢å¼åŒ–æ–¹æ³•
- [09.1.1 å½¢å¼æ¨¡å‹åŸºç¡€](../09_Formal_Model_Theory/09.1.1_å½¢å¼æ¨¡å‹åŸºç¡€.md)
- [09.2.1 çŠ¶æ€æœºç†è®º](../09_Formal_Model_Theory/09.2.1_çŠ¶æ€æœºç†è®º.md)

## 12. å‚è€ƒæ–‡çŒ®

1. **Lynch, N. A.** (1996). *Distributed Algorithms*. Morgan Kaufmann.
2. **Attiya, H., & Welch, J.** (2004). *Distributed Computing: Fundamentals, Simulations, and Advanced Topics*. Wiley.
3. **Lamport, L.** (1978). *Time, Clocks, and the Ordering of Events in a Distributed System*. Communications of the ACM.
4. **Chandy, K. M., & Lamport, L.** (1985). *Distributed Snapshots: Determining Global States of Distributed Systems*. ACM Transactions on Computer Systems.
5. **Lamport, L.** (1974). *A New Solution of Dijkstra's Concurrent Programming Problem*. Communications of the ACM.
6. **Cristian, F.** (1989). *Probabilistic Clock Synchronization*. Distributed Computing.
7. **Fidge, C. J.** (1988). *Timestamps in Message-Passing Systems That Preserve the Partial Ordering*. Australian Computer Science Conference.
8. **Mattern, F.** (1989). *Virtual Time and Global States of Distributed Systems*. Parallel and Distributed Algorithms.
9. **Garcia-Molina, H.** (1982). *Elections in a Distributed Computing System*. IEEE Transactions on Computers.
10. **Dijkstra, E. W.** (1965). *Solution of a Problem in Concurrent Programming Control*. Communications of the ACM.

---

**å…³é”®è¯**: åˆ†å¸ƒå¼ç®—æ³•ã€æ¶ˆæ¯ä¼ é€’ã€åŒæ­¥æœºåˆ¶ã€æ•…éšœå¤„ç†ã€é¢†å¯¼è€…é€‰ä¸¾ã€åˆ†å¸ƒå¼äº’æ–¥ã€åˆ†å¸ƒå¼å¿«ç…§

**ç›¸å…³æ–‡æ¡£**: 
- [06.1.1 åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€](06.1.1_åˆ†å¸ƒå¼ç³»ç»ŸåŸºç¡€.md)
- [06.1.3 åˆ†å¸ƒå¼é€šä¿¡ç†è®º](06.1.3_åˆ†å¸ƒå¼é€šä¿¡ç†è®º.md)
- [06.1.4 åˆ†å¸ƒå¼åŒæ­¥ç†è®º](06.1.4_åˆ†å¸ƒå¼åŒæ­¥ç†è®º.md) 